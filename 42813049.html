<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737795674365" as="style"/><link rel="stylesheet" href="styles.css?v=1737795674365"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://restate.dev/blog/every-system-is-a-log-avoiding-coordination-in-distributed-applications/">Every System is a Log: Avoiding coordination in distributed applications</a> <span class="domain">(<a href="https://restate.dev">restate.dev</a>)</span></div><div class="subtext"><span>sewen</span> | <span>132 comments</span></div><br/><div><div id="42816757" class="c"><input type="checkbox" id="c-42816757" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42814796">next</a><span>|</span><label class="collapse" for="c-42816757">[-]</label><label class="expand" for="c-42816757">[18 more]</label></div><br/><div class="children"><div class="content">This is a basic concept in accounting. The general ledger is an immutable log of transactions. Other accounting documents are constructed from the general ledger, and can, if necessary, be rebuilt from it. This is the accepted way to do money-related things.<p>Synchronization is called &quot;reconcilation&quot; in accounting terminology.<p>The computer concept is that we have a current state, and changes to it come in. The database with the current state is authoritative. This is not suitable for handling money.<p>The real question is, do you really care what happened last month? Last year? If yes, a log-based approach is appropriate.</div><br/><div id="42816840" class="c"><input type="checkbox" id="c-42816840" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#42816757">parent</a><span>|</span><a href="#42820297">next</a><span>|</span><label class="collapse" for="c-42816840">[-]</label><label class="expand" for="c-42816840">[13 more]</label></div><br/><div class="children"><div class="content">I’ve always concurred with the Helland&#x2F;Kleppman observation mentioned viz. that the transaction log of a typical RDBMS is the canonical form and all the rows &amp; tables merely projections.<p>It’s curious that over those projections, we then build event stores for CQRS&#x2F;ES systems, ledgers etc, with their own projections mediated by application code.<p>But look underneath too. The journaled filesystem on which the database resides also has a log representation, and under that, a modern SSD is using an adaptive log structure to balance block writes.<p>It’s been a long time since we wrote an application event stream linearly straight to media, and although I appreciate the separate concerns that each of these layers addresses, I’d probably struggle to justify them all from first principles to even a slightly more Socratic version of myself.</div><br/><div id="42816941" class="c"><input type="checkbox" id="c-42816941" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42816840">parent</a><span>|</span><a href="#42817203">next</a><span>|</span><label class="collapse" for="c-42816941">[-]</label><label class="expand" for="c-42816941">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It’s curious that over those projections, we then build event stores for CQRS&#x2F;ES systems, ledgers etc, with their own projections mediated by application code.<p>The database only supports CRUD. So while the CDC stream is the truth, it&#x27;s very low level. We build higher-level event types (as in event sourcing) for the same reason we build any higher-level abstraction: it gives us a language in which to talk about business rules. Kleppmann makes this point in his book and it was something of an aha moment for me.</div><br/><div id="42817060" class="c"><input type="checkbox" id="c-42817060" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42816941">parent</a><span>|</span><a href="#42817203">next</a><span>|</span><label class="collapse" for="c-42817060">[-]</label><label class="expand" for="c-42817060">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry; but have you ever actually used a database before? A database supports FAR more than &quot;only CRUD&quot;. Some really simple examples are CTEs, SELECT ... INTO (or INSERT ... SELECT for some dialects), triggers, views, etc.</div><br/><div id="42818012" class="c"><input type="checkbox" id="c-42818012" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817060">parent</a><span>|</span><a href="#42818054">next</a><span>|</span><label class="collapse" for="c-42818012">[-]</label><label class="expand" for="c-42818012">[1 more]</label></div><br/><div class="children"><div class="content">CTE&#x27;s are extensions to try an regain some of what was lost when adopting a model loosely based on Codd&#x27;s declarative relational algebra, specifically the lack of transitive closure, the rest mostly fit into the CRUD world.<p>It is a bit circular, CRUD&#x27;s elements <i>create, read, update, and delete</i> were chosen to represent the core features of a persistence layer.</div><br/></div></div><div id="42818054" class="c"><input type="checkbox" id="c-42818054" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817060">parent</a><span>|</span><a href="#42818012">prev</a><span>|</span><a href="#42817203">next</a><span>|</span><label class="collapse" for="c-42818054">[-]</label><label class="expand" for="c-42818054">[1 more]</label></div><br/><div class="children"><div class="content">what you mention is a high level projection over transaction log and is subject to transaction isolation levels<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;transaction-iso.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;transaction-iso.html</a></div><br/></div></div></div></div></div></div><div id="42817203" class="c"><input type="checkbox" id="c-42817203" checked=""/><div class="controls bullet"><span class="by">ianburrell</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42816840">parent</a><span>|</span><a href="#42816941">prev</a><span>|</span><a href="#42820297">next</a><span>|</span><label class="collapse" for="c-42817203">[-]</label><label class="expand" for="c-42817203">[8 more]</label></div><br/><div class="children"><div class="content">The table data in database is the canonical form. You can delete the transaction logs, and temporarily lose some reliability. It is very common to delete the transaction logs when not needed. When databases are backed up, they either dump the logical data or take snapshot of the data. Then can take stream of transaction logs for syncing or backup until the next checkpoint.<p>I&#x27;m pretty sure journalled filesystem recycle the journal. There are log-structured filesystem but they aren&#x27;t used much beyond low-level flash.</div><br/><div id="42817274" class="c"><input type="checkbox" id="c-42817274" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817203">parent</a><span>|</span><a href="#42820297">next</a><span>|</span><label class="collapse" for="c-42817274">[-]</label><label class="expand" for="c-42817274">[7 more]</label></div><br/><div class="children"><div class="content">Sorry, this is mistaking the operational for the fundamental.<p>If a transaction log is replayed, then an identical set of relations will be obtained. Ergo, the log is the prime form of the database.<p>It’s that simple.</div><br/><div id="42817352" class="c"><input type="checkbox" id="c-42817352" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817274">parent</a><span>|</span><a href="#42817353">next</a><span>|</span><label class="collapse" for="c-42817352">[-]</label><label class="expand" for="c-42817352">[2 more]</label></div><br/><div class="children"><div class="content">At work we need to distribute daily changes to a dataset, so we have a series of daily deltas. If a new client is brought up, they need to apply all the deltas to get the current dataset.<p>This is time consuming, so we optimized it by creating &quot;base versions&quot; every month. So a client only needs to download the latest base version and the apply the deltas since then...</div><br/><div id="42817513" class="c"><input type="checkbox" id="c-42817513" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817352">parent</a><span>|</span><a href="#42817353">next</a><span>|</span><label class="collapse" for="c-42817513">[-]</label><label class="expand" for="c-42817513">[1 more]</label></div><br/><div class="children"><div class="content">Which is what accountants call &quot;closing the books&quot;. Once all ledgers have been reconciled, old ledgers can be archived and you go forward from the last closing.<p>Forensic accounting, incidentally, is when something went badly wrong and outside accountants have to go back through the old ledgers, and maybe old invoices and payments and reconstruct the books. FTX had to do that after the bankruptcy to find out where the money went and where it was supposed to go.</div><br/></div></div></div></div><div id="42817353" class="c"><input type="checkbox" id="c-42817353" checked=""/><div class="controls bullet"><span class="by">isignal</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817274">parent</a><span>|</span><a href="#42817352">prev</a><span>|</span><a href="#42820065">next</a><span>|</span><label class="collapse" for="c-42817353">[-]</label><label class="expand" for="c-42817353">[3 more]</label></div><br/><div class="children"><div class="content">The transaction log maintained from time 0 would be equivalent but too expensive to store compared to the tables.</div><br/><div id="42817816" class="c"><input type="checkbox" id="c-42817816" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817353">parent</a><span>|</span><a href="#42817465">next</a><span>|</span><label class="collapse" for="c-42817816">[-]</label><label class="expand" for="c-42817816">[1 more]</label></div><br/><div class="children"><div class="content">If you relax your constraint to &quot;retain logs for the past N days&quot;, you can accumulate the logs from T=0 to T=(today - N) into tables and still benefit from having snapshots from that cutoff onwards.</div><br/></div></div><div id="42817465" class="c"><input type="checkbox" id="c-42817465" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817353">parent</a><span>|</span><a href="#42817816">prev</a><span>|</span><a href="#42820065">next</a><span>|</span><label class="collapse" for="c-42817465">[-]</label><label class="expand" for="c-42817465">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary, I’ve known plenty of sites that keep their logs.<p>Often written to tape, for obvious reasons.</div><br/></div></div></div></div><div id="42820065" class="c"><input type="checkbox" id="c-42820065" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42817274">parent</a><span>|</span><a href="#42817353">prev</a><span>|</span><a href="#42820297">next</a><span>|</span><label class="collapse" for="c-42820065">[-]</label><label class="expand" for="c-42820065">[1 more]</label></div><br/><div class="children"><div class="content">Conversely, given a database, you can&#x27;t (in general) reconstruct the specific transaction log that resulted in it. You can reconstruct <i>some</i> log, but it&#x27;s not uniquely defined and is missing a lot of potentially relevant information.</div><br/></div></div></div></div></div></div></div></div><div id="42820297" class="c"><input type="checkbox" id="c-42820297" checked=""/><div class="controls bullet"><span class="by">funcDropShadow</span><span>|</span><a href="#42816757">parent</a><span>|</span><a href="#42816840">prev</a><span>|</span><a href="#42817704">next</a><span>|</span><label class="collapse" for="c-42820297">[-]</label><label class="expand" for="c-42820297">[1 more]</label></div><br/><div class="children"><div class="content">Could you recommend some resource to understand this view of accounting better?</div><br/></div></div><div id="42817704" class="c"><input type="checkbox" id="c-42817704" checked=""/><div class="controls bullet"><span class="by">fellowniusmonk</span><span>|</span><a href="#42816757">parent</a><span>|</span><a href="#42820297">prev</a><span>|</span><a href="#42819082">next</a><span>|</span><label class="collapse" for="c-42817704">[-]</label><label class="expand" for="c-42817704">[1 more]</label></div><br/><div class="children"><div class="content">This is why EG-Walker is so important, diamond types adoption and a solid TS port can&#x27;t come soon enough for distributed systems.</div><br/></div></div><div id="42819082" class="c"><input type="checkbox" id="c-42819082" checked=""/><div class="controls bullet"><span class="by">calvinmorrison</span><span>|</span><a href="#42816757">parent</a><span>|</span><a href="#42817704">prev</a><span>|</span><a href="#42814796">next</a><span>|</span><label class="collapse" for="c-42819082">[-]</label><label class="expand" for="c-42819082">[2 more]</label></div><br/><div class="children"><div class="content">You over estimate ERP and accounting systems.</div><br/><div id="42820308" class="c"><input type="checkbox" id="c-42820308" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#42816757">root</a><span>|</span><a href="#42819082">parent</a><span>|</span><a href="#42814796">next</a><span>|</span><label class="collapse" for="c-42820308">[-]</label><label class="expand" for="c-42820308">[1 more]</label></div><br/><div class="children"><div class="content">That was basic accounting when computers were people with pencils and paper.</div><br/></div></div></div></div></div></div><div id="42814796" class="c"><input type="checkbox" id="c-42814796" checked=""/><div class="controls bullet"><span class="by">shikhar</span><span>|</span><a href="#42816757">prev</a><span>|</span><a href="#42814554">next</a><span>|</span><label class="collapse" for="c-42814796">[-]</label><label class="expand" for="c-42814796">[9 more]</label></div><br/><div class="children"><div class="content">This post makes a great case for how universal logs are in data systems. It was strange to me that there was no log-as-service with the qualities that make it suitable for building higher-level systems like durable execution: conditional appends (as called out by the post!), support very large numbers of logs, allow pushing high throughputs with strict ordering, and just generally provide a simple serverless experience like object storage. This led to <a href="https:&#x2F;&#x2F;s2.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;s2.dev&#x2F;</a> which is now available in preview.<p>It was interesting to learn how Restate links events for a key, with key-level logical logs multiplexed over partitioned physical logs. I imagine this is implemented with a leader per physical log, so you can consistently maintain an index. A log service supporting conditional appends allows such a leader to act like the log is local to it, despite offering replicated durability.<p>Leadership can be an important optimization for most systems, but shared logs also allow for multi-writer systems pretty easily. We blogged about this pattern <a href="https:&#x2F;&#x2F;s2.dev&#x2F;blog&#x2F;kv-store" rel="nofollow">https:&#x2F;&#x2F;s2.dev&#x2F;blog&#x2F;kv-store</a></div><br/><div id="42816638" class="c"><input type="checkbox" id="c-42816638" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42814796">parent</a><span>|</span><a href="#42815217">next</a><span>|</span><label class="collapse" for="c-42816638">[-]</label><label class="expand" for="c-42816638">[3 more]</label></div><br/><div class="children"><div class="content">I just want a recognized standard format for write ahead logs. Start with replicating data between OLTP and OLAP databases with minimal glue code, and start moving other systems to a similar structure, like Kafka, then new things we haven’t thought of yet.</div><br/><div id="42817107" class="c"><input type="checkbox" id="c-42817107" checked=""/><div class="controls bullet"><span class="by">ianburrell</span><span>|</span><a href="#42814796">root</a><span>|</span><a href="#42816638">parent</a><span>|</span><a href="#42815217">next</a><span>|</span><label class="collapse" for="c-42817107">[-]</label><label class="expand" for="c-42817107">[2 more]</label></div><br/><div class="children"><div class="content">The structure for the write head logs needs to different between systems. For Postgres, the WAL is a record of writes with new blocks. It can&#x27;t be used without knowing the Postgres disk format. I don&#x27;t think it can be used to construct logical changes.<p>Using a standard format, converting things into logical data, would be significantly slower. It is important that WAL be fast because it is the bottleneck in transactions. It would make more sense to have a separate change streaming service.</div><br/><div id="42817264" class="c"><input type="checkbox" id="c-42817264" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#42814796">root</a><span>|</span><a href="#42817107">parent</a><span>|</span><a href="#42815217">next</a><span>|</span><label class="collapse" for="c-42817264">[-]</label><label class="expand" for="c-42817264">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think it can be used to construct logical changes.<p>It can: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;logicaldecoding.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;logicaldecoding.html</a><p>It&#x27;s not entirely from the WAL though, some catalog accesses are necessary for metadata (shape and name of tables etc).</div><br/></div></div></div></div></div></div><div id="42815217" class="c"><input type="checkbox" id="c-42815217" checked=""/><div class="controls bullet"><span class="by">logsr</span><span>|</span><a href="#42814796">parent</a><span>|</span><a href="#42816638">prev</a><span>|</span><a href="#42816852">next</a><span>|</span><label class="collapse" for="c-42815217">[-]</label><label class="expand" for="c-42815217">[1 more]</label></div><br/><div class="children"><div class="content">&gt; log as a service<p>very exciting. this is the future. i am working on a very similar concept. every database is a log at its core, so the log, which is the highest performance part of the system, is buried behind many layers of much lower performing cruft. edge persistence with log-per-user application patterns opens up so many possibilities.</div><br/></div></div><div id="42816852" class="c"><input type="checkbox" id="c-42816852" checked=""/><div class="controls bullet"><span class="by">xuancanh</span><span>|</span><a href="#42814796">parent</a><span>|</span><a href="#42815217">prev</a><span>|</span><a href="#42816551">next</a><span>|</span><label class="collapse" for="c-42816852">[-]</label><label class="expand" for="c-42816852">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It was strange to me that there was no log-as-service with the qualities that make it suitable for building higher-level systems like durable execution<p>There are several services like that, but they are mostly kept behind the scene as a competitive advantage when building distributed systems. AWS uses it behind the scene for many services, as mentioned here by Marc Brooker <a href="https:&#x2F;&#x2F;brooker.co.za&#x2F;blog&#x2F;2024&#x2F;04&#x2F;25&#x2F;memorydb.html" rel="nofollow">https:&#x2F;&#x2F;brooker.co.za&#x2F;blog&#x2F;2024&#x2F;04&#x2F;25&#x2F;memorydb.html</a>. Facebook has similar systems like LogDevice <a href="https:&#x2F;&#x2F;logdevice.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;logdevice.io&#x2F;</a>, and recently Delos <a href="https:&#x2F;&#x2F;research.facebook.com&#x2F;publications&#x2F;log-structured-protocols-in-delos&#x2F;" rel="nofollow">https:&#x2F;&#x2F;research.facebook.com&#x2F;publications&#x2F;log-structured-pr...</a></div><br/><div id="42816950" class="c"><input type="checkbox" id="c-42816950" checked=""/><div class="controls bullet"><span class="by">shikhar</span><span>|</span><a href="#42814796">root</a><span>|</span><a href="#42816852">parent</a><span>|</span><a href="#42816551">next</a><span>|</span><label class="collapse" for="c-42816950">[-]</label><label class="expand" for="c-42816950">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. We are trying to democratize that secret sauce. Since it is backed by object storage, the latencies are not what AWS enjoys with its internal Journal service, but we intend to get there with a NVMe-based tier later. In the meantime there is an existing large market for event streaming where a &quot;truly serverless&quot; (<a href="https:&#x2F;&#x2F;erikbern.com&#x2F;2021&#x2F;04&#x2F;19&#x2F;software-infrastructure-2.0-a-wishlist.html" rel="nofollow">https:&#x2F;&#x2F;erikbern.com&#x2F;2021&#x2F;04&#x2F;19&#x2F;software-infrastructure-2.0-...</a>) API has been missing.</div><br/></div></div></div></div><div id="42816551" class="c"><input type="checkbox" id="c-42816551" checked=""/><div class="controls bullet"><span class="by">gavindean90</span><span>|</span><a href="#42814796">parent</a><span>|</span><a href="#42816852">prev</a><span>|</span><a href="#42814554">next</a><span>|</span><label class="collapse" for="c-42816551">[-]</label><label class="expand" for="c-42816551">[2 more]</label></div><br/><div class="children"><div class="content">What about journalctl?</div><br/><div id="42816682" class="c"><input type="checkbox" id="c-42816682" checked=""/><div class="controls bullet"><span class="by">shikhar</span><span>|</span><a href="#42814796">root</a><span>|</span><a href="#42816551">parent</a><span>|</span><a href="#42814554">next</a><span>|</span><label class="collapse" for="c-42816682">[-]</label><label class="expand" for="c-42816682">[1 more]</label></div><br/><div class="children"><div class="content">This is why we didn&#x27;t actually call it logs as a service, but streams :P I meant to refer to the log abstraction this post talks about, see links therein. Observability events are but one kind of data you may want as a stream of durable records.</div><br/></div></div></div></div></div></div><div id="42814554" class="c"><input type="checkbox" id="c-42814554" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42814796">prev</a><span>|</span><a href="#42814466">next</a><span>|</span><label class="collapse" for="c-42814554">[-]</label><label class="expand" for="c-42814554">[4 more]</label></div><br/><div class="children"><div class="content">Some clarification on what &quot;one log&quot; means here:<p>- It means using one log across different concerns like state a, communication with b, lock c. Often that is in the scope of a single entity (payment, user, session, etc.) and thus the scope for the one log is still small. You would have a lot of independent logs still, for separate payments.<p>- It does _not_ mean that one should share the same log (and partition) for all the entities in your app, like necessarily funneling all users, payments, etc. through the same log. That goes actually beyond the proposal here - has some benefits of its own, but have a hard time scaling.</div><br/><div id="42814709" class="c"><input type="checkbox" id="c-42814709" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42814554">parent</a><span>|</span><a href="#42814466">next</a><span>|</span><label class="collapse" for="c-42814709">[-]</label><label class="expand" for="c-42814709">[3 more]</label></div><br/><div class="children"><div class="content">Interesting read, not my area but I think I got the gist of it.<p>In your Restate example of the &quot;processPayment&quot; function, how do you handle errors of the &quot;accountService&quot; call? Like, what if it times out or returns a server error?<p>Do you store the error result and the caller of &quot;processPayment&quot; has to re-trigger the payment, in order to generate a new log?</div><br/><div id="42815148" class="c"><input type="checkbox" id="c-42815148" checked=""/><div class="controls bullet"><span class="by">stsffap</span><span>|</span><a href="#42814554">root</a><span>|</span><a href="#42814709">parent</a><span>|</span><a href="#42814466">next</a><span>|</span><label class="collapse" for="c-42815148">[-]</label><label class="expand" for="c-42815148">[2 more]</label></div><br/><div class="children"><div class="content">By default, failing ctx.run() calls (like the accountService call) will be retried indefinitely until they succeed unless you have configured a retry policy for them. In the case of a configured retry policy where you have exhausted the number of retry attempts, Restate will mark this call as terminally failed and record it in its log as such and return it to the caller.</div><br/><div id="42815338" class="c"><input type="checkbox" id="c-42815338" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42814554">root</a><span>|</span><a href="#42815148">parent</a><span>|</span><a href="#42814466">next</a><span>|</span><label class="collapse" for="c-42815338">[-]</label><label class="expand" for="c-42815338">[1 more]</label></div><br/><div class="children"><div class="content">You can catch these errors and handle them in a common try&#x2F;catch manner, and because the results of `ctx.run` are recorded in the log, this is deterministic and reliable</div><br/></div></div></div></div></div></div></div></div><div id="42814466" class="c"><input type="checkbox" id="c-42814466" checked=""/><div class="controls bullet"><span class="by">daxfohl</span><span>|</span><a href="#42814554">prev</a><span>|</span><a href="#42813692">next</a><span>|</span><label class="collapse" for="c-42814466">[-]</label><label class="expand" for="c-42814466">[4 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t formed thoughts on the content yet, but happy to see a company launching something non-AI for a change.</div><br/><div id="42814723" class="c"><input type="checkbox" id="c-42814723" checked=""/><div class="controls bullet"><span class="by">gjtorikian</span><span>|</span><a href="#42814466">parent</a><span>|</span><a href="#42813692">next</a><span>|</span><label class="collapse" for="c-42814723">[-]</label><label class="expand" for="c-42814723">[3 more]</label></div><br/><div class="children"><div class="content">My startup, Yetto (<a href="http:&#x2F;&#x2F;www.yetto.app" rel="nofollow">http:&#x2F;&#x2F;www.yetto.app</a>) is building a better way for support professionals to do their job. (Shameless plug but we always gotta hustle.)<p>We, too, are weighed down by how much space AI-focused companies are taking.</div><br/><div id="42815304" class="c"><input type="checkbox" id="c-42815304" checked=""/><div class="controls bullet"><span class="by">hansonkd</span><span>|</span><a href="#42814466">root</a><span>|</span><a href="#42814723">parent</a><span>|</span><a href="#42813692">next</a><span>|</span><label class="collapse" for="c-42815304">[-]</label><label class="expand" for="c-42815304">[2 more]</label></div><br/><div class="children"><div class="content">TBH looking at helpdesk software in 2025, I would expect new ones to be built AI first. It would be hard for me to consider one without at least some sort of LLMs helping with triage or at classifications of tickets, etc.</div><br/><div id="42815426" class="c"><input type="checkbox" id="c-42815426" checked=""/><div class="controls bullet"><span class="by">gk1</span><span>|</span><a href="#42814466">root</a><span>|</span><a href="#42815304">parent</a><span>|</span><a href="#42813692">next</a><span>|</span><label class="collapse" for="c-42815426">[-]</label><label class="expand" for="c-42815426">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;www.fixify.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.fixify.com&#x2F;</a>, although they are too modest about mentioning the AI they&#x27;re using under the hood.</div><br/></div></div></div></div></div></div></div></div><div id="42813692" class="c"><input type="checkbox" id="c-42813692" checked=""/><div class="controls bullet"><span class="by">jaseemabid</span><span>|</span><a href="#42814466">prev</a><span>|</span><a href="#42813668">next</a><span>|</span><label class="collapse" for="c-42813692">[-]</label><label class="expand" for="c-42813692">[5 more]</label></div><br/><div class="children"><div class="content">A notable example of a large-scale app built with a very similar architecture is ATproto&#x2F;Bluesky[1].<p>&quot;ATProto for Distributed Systems Engineers&quot; describes how updates from the users end up in their own small databases (called PDS) and then a replicated log. What we traditionally think of as an API server (called a view server in ATProto) is simply one among the many materializations of this log.<p>I personally find this model of thinking about dataflow in large-scale apps pretty neat and easy to understand. The parallels are unsurprising since both the Restate blog and ATProto docs link to the same blog post by Martin Kleppmann.<p>This arch seems to be working really well for Bluesky, as they clearly aced through multiple 10x events very recently.<p>[1]: <a href="https:&#x2F;&#x2F;atproto.com&#x2F;articles&#x2F;atproto-for-distsys-engineers" rel="nofollow">https:&#x2F;&#x2F;atproto.com&#x2F;articles&#x2F;atproto-for-distsys-engineers</a></div><br/><div id="42814164" class="c"><input type="checkbox" id="c-42814164" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42813692">parent</a><span>|</span><a href="#42815691">next</a><span>|</span><label class="collapse" for="c-42814164">[-]</label><label class="expand" for="c-42814164">[2 more]</label></div><br/><div class="children"><div class="content">That blog post is a great read as well.
Truely, the log abstraction [1] and &quot;Turning the DB inside out&quot; [2] have been hugely influential.<p>In a way this article here suggests to extend that<p>(1) from a log that represents data (upserts, cdc, etc.) to a log of coordination commands (update this, acquire that log, journal that steo)<p>(2) have a way to link the events related to a broader operation (handler execution) together<p>(3) make the log aware of handler execution (better yet, put it in charge), so you can automatically fence outdated executions<p>[1] <a href="https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-what-every-software-engineer-should-know-about-real-time-datas-unifying" rel="nofollow">https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-wha...</a></div><br/><div id="42814167" class="c"><input type="checkbox" id="c-42814167" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42813692">root</a><span>|</span><a href="#42814164">parent</a><span>|</span><a href="#42815691">next</a><span>|</span><label class="collapse" for="c-42814167">[-]</label><label class="expand" for="c-42814167">[1 more]</label></div><br/><div class="children"><div class="content">[2] <a href="https:&#x2F;&#x2F;martin.kleppmann.com&#x2F;2015&#x2F;11&#x2F;05&#x2F;database-inside-out-at-oredev.html" rel="nofollow">https:&#x2F;&#x2F;martin.kleppmann.com&#x2F;2015&#x2F;11&#x2F;05&#x2F;database-inside-out-...</a></div><br/></div></div></div></div><div id="42815691" class="c"><input type="checkbox" id="c-42815691" checked=""/><div class="controls bullet"><span class="by">zellyn</span><span>|</span><a href="#42813692">parent</a><span>|</span><a href="#42814164">prev</a><span>|</span><a href="#42814175">next</a><span>|</span><label class="collapse" for="c-42815691">[-]</label><label class="expand" for="c-42815691">[1 more]</label></div><br/><div class="children"><div class="content">Martin Kleppmann was also directly involved with Bluesky as a consultant.</div><br/></div></div><div id="42814175" class="c"><input type="checkbox" id="c-42814175" checked=""/><div class="controls bullet"><span class="by">grahamj</span><span>|</span><a href="#42813692">parent</a><span>|</span><a href="#42815691">prev</a><span>|</span><a href="#42813668">next</a><span>|</span><label class="collapse" for="c-42814175">[-]</label><label class="expand" for="c-42814175">[1 more]</label></div><br/><div class="children"><div class="content">Table&#x2F;log duality goes back further than Kleppmann though. An earlier article that really influenced me was<p><a href="https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-what-every-software-engineer-should-know-about-real-time-datas-unifying" rel="nofollow">https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-wha...</a></div><br/></div></div></div></div><div id="42813668" class="c"><input type="checkbox" id="c-42813668" checked=""/><div class="controls bullet"><span class="by">trollbridge</span><span>|</span><a href="#42813692">prev</a><span>|</span><a href="#42820314">next</a><span>|</span><label class="collapse" for="c-42813668">[-]</label><label class="expand" for="c-42813668">[18 more]</label></div><br/><div class="children"><div class="content">I’ve been doing a similar thing, although I called it “append only transaction ledgers”. Same idea as a log. A few principles:<p>- The order of log entries does not matter.<p>- Users of the log are peers. No client &#x2F; server distinction.<p>- When appending a log entry, you can send a copy of the append to all your peers.<p>- You can ask your peers to refresh the latest log entries.<p>- When creating a new entry, it is a very good idea to have a nonce field. (I use nano IDs for this purpose along with a timestamp, which is probabilistically unique.)<p>- If you want to do database style queries of the data, load all the log entries into an in memory database and query away.<p>- You can append a log entry containing a summary of all log entries you have so far. For example: you’ve been given 10 new customer entries. You can create a log entry of “We have 10 customers as of this date.”<p>- When creating new entries, prepare the entry or list of entries in memory, allow the user to edit&#x2F;revise them as a draft, then when they click “Save”, they are in the permanent record.<p>- To fix a mistake in an entry, create a new entry that “negates” that entry.<p>A lot of parallelism &#x2F; concurrency problems just go away with this design.</div><br/><div id="42814063" class="c"><input type="checkbox" id="c-42814063" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#42813668">parent</a><span>|</span><a href="#42813994">next</a><span>|</span><label class="collapse" for="c-42814063">[-]</label><label class="expand" for="c-42814063">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The order of log entries does not matter.<p>This is surprising, Kafka-like logs are all strictly ordered.</div><br/><div id="42819041" class="c"><input type="checkbox" id="c-42819041" checked=""/><div class="controls bullet"><span class="by">trollbridge</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42814063">parent</a><span>|</span><a href="#42814282">next</a><span>|</span><label class="collapse" for="c-42819041">[-]</label><label class="expand" for="c-42819041">[1 more]</label></div><br/><div class="children"><div class="content">The reason I made ordering not matter is so that multiple peers don’t have to worry about keeping the exact same order when appending to each other’s logs.<p>The log entries do have timestamps on them. You can sort by timestamp, but a peer has the right to append an new entry that’s older than the latest timestamp.</div><br/></div></div><div id="42814282" class="c"><input type="checkbox" id="c-42814282" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42814063">parent</a><span>|</span><a href="#42819041">prev</a><span>|</span><a href="#42813994">next</a><span>|</span><label class="collapse" for="c-42814282">[-]</label><label class="expand" for="c-42814282">[1 more]</label></div><br/><div class="children"><div class="content">* within a partition</div><br/></div></div></div></div><div id="42813994" class="c"><input type="checkbox" id="c-42813994" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42813668">parent</a><span>|</span><a href="#42814063">prev</a><span>|</span><a href="#42814211">next</a><span>|</span><label class="collapse" for="c-42813994">[-]</label><label class="expand" for="c-42813994">[3 more]</label></div><br/><div class="children"><div class="content">How do you know summary entries are valid if order doesn&#x27;t matter?<p>I.e. &quot;we have 10 customers as of this date&quot; can become immediately invalid if a new entry is appended afterwards with a date before that summary entry (i.e. because it was on a peer which hadn&#x27;t yet sent it)</div><br/><div id="42817162" class="c"><input type="checkbox" id="c-42817162" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42813994">parent</a><span>|</span><a href="#42814256">next</a><span>|</span><label class="collapse" for="c-42817162">[-]</label><label class="expand" for="c-42817162">[1 more]</label></div><br/><div class="children"><div class="content">Realistically, you never store summaries in the log. Instead, you store what it took to calculate them. So you won&#x27;t store &quot;we have 10 customers on this date with this range&quot; but instead store &quot;we found these 10 customers on this date with this range&quot;. This assumes you can store infinite sized lists in your log, but realistically, this is never a concern if you can keep your time windows small enough. Then, you periodically do a reconciliation and log corrections (look for entries not summarized -- easily done via a bloom filter which can tell you what entries are definitely NOT in your set) over a longer period.<p>For example, we had a 28-day reconciliation period at one company I worked at (and handled over 120 million events per day). If you appended an event earlier than 28 days prior, it was simply ignored. This very rarely happened, but allowed us to fix bugs with events for up to 28 days.</div><br/></div></div><div id="42814256" class="c"><input type="checkbox" id="c-42814256" checked=""/><div class="controls bullet"><span class="by">clayg</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42813994">parent</a><span>|</span><a href="#42817162">prev</a><span>|</span><a href="#42814211">next</a><span>|</span><label class="collapse" for="c-42814256">[-]</label><label class="expand" for="c-42814256">[1 more]</label></div><br/><div class="children"><div class="content">IME you have to be willing to recalculate the summaries up to some kind of consistency window.<p>Yes you may be changing history and you may have a business reason not to <i>address</i> that revision immediately (you&#x27;ve already billed them?) - but the system can still learn it made a mistake and fix it (add activity from Jan 30 evening that comes in late to the Feb bill?)</div><br/></div></div></div></div><div id="42814211" class="c"><input type="checkbox" id="c-42814211" checked=""/><div class="controls bullet"><span class="by">log4shell</span><span>|</span><a href="#42813668">parent</a><span>|</span><a href="#42813994">prev</a><span>|</span><a href="#42814621">next</a><span>|</span><label class="collapse" for="c-42814211">[-]</label><label class="expand" for="c-42814211">[4 more]</label></div><br/><div class="children"><div class="content">Calling a WAL a ledger, why? Ledger sounds fancier but why would it be a ledger in this case?</div><br/><div id="42819048" class="c"><input type="checkbox" id="c-42819048" checked=""/><div class="controls bullet"><span class="by">trollbridge</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42814211">parent</a><span>|</span><a href="#42814337">next</a><span>|</span><label class="collapse" for="c-42819048">[-]</label><label class="expand" for="c-42819048">[1 more]</label></div><br/><div class="children"><div class="content">We called it a ledger since we stored financial data and basically used the “ledger” format from plain text accounting, initially.</div><br/></div></div><div id="42814337" class="c"><input type="checkbox" id="c-42814337" checked=""/><div class="controls bullet"><span class="by">hcarvalhoalves</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42814211">parent</a><span>|</span><a href="#42819048">prev</a><span>|</span><a href="#42814621">next</a><span>|</span><label class="collapse" for="c-42814337">[-]</label><label class="expand" for="c-42814337">[2 more]</label></div><br/><div class="children"><div class="content">I believe &quot;ledger&quot; implies commutative property (order does not matter).</div><br/><div id="42815861" class="c"><input type="checkbox" id="c-42815861" checked=""/><div class="controls bullet"><span class="by">log4shell</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42814337">parent</a><span>|</span><a href="#42814621">next</a><span>|</span><label class="collapse" for="c-42815861">[-]</label><label class="expand" for="c-42815861">[1 more]</label></div><br/><div class="children"><div class="content">I am not aware of any such implicit connection of ledger and commutative property, also couldn&#x27;t find anything as my google-fu is letting me down. Anything I can refer to? Generally curious to know use of term ledger outside of accounting and blockchains.<p>I have seen it used to mean WAL before, so I am taking this with a dose of skepticism.</div><br/></div></div></div></div></div></div><div id="42814621" class="c"><input type="checkbox" id="c-42814621" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#42813668">parent</a><span>|</span><a href="#42814211">prev</a><span>|</span><a href="#42818096">next</a><span>|</span><label class="collapse" for="c-42814621">[-]</label><label class="expand" for="c-42814621">[2 more]</label></div><br/><div class="children"><div class="content">How do you manage log size for high-transaction systems?</div><br/><div id="42819051" class="c"><input type="checkbox" id="c-42819051" checked=""/><div class="controls bullet"><span class="by">trollbridge</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42814621">parent</a><span>|</span><a href="#42818096">next</a><span>|</span><label class="collapse" for="c-42819051">[-]</label><label class="expand" for="c-42819051">[1 more]</label></div><br/><div class="children"><div class="content">It’s not terribly high transaction, yet. If it becomes that way, I would partition the one by entry type so all the high transaction stuff gets stuffed in a particular log, and then ensure it can be summarised regularly.</div><br/></div></div></div></div><div id="42818096" class="c"><input type="checkbox" id="c-42818096" checked=""/><div class="controls bullet"><span class="by">random3</span><span>|</span><a href="#42813668">parent</a><span>|</span><a href="#42814621">prev</a><span>|</span><a href="#42814131">next</a><span>|</span><label class="collapse" for="c-42818096">[-]</label><label class="expand" for="c-42818096">[3 more]</label></div><br/><div class="children"><div class="content">if order does not matter how do you implement deletes?</div><br/><div id="42819022" class="c"><input type="checkbox" id="c-42819022" checked=""/><div class="controls bullet"><span class="by">trollbridge</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42818096">parent</a><span>|</span><a href="#42814131">next</a><span>|</span><label class="collapse" for="c-42819022">[-]</label><label class="expand" for="c-42819022">[2 more]</label></div><br/><div class="children"><div class="content">You don’t do deletes. The log is append only.<p>If you want to get rid of an entry, you create a new entry that negates the existing entry.</div><br/><div id="42820374" class="c"><input type="checkbox" id="c-42820374" checked=""/><div class="controls bullet"><span class="by">shipp02</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42819022">parent</a><span>|</span><a href="#42814131">next</a><span>|</span><label class="collapse" for="c-42820374">[-]</label><label class="expand" for="c-42820374">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but if order doesn&#x27;t matter, the delete might appear before the create.<p>Might be misunderstand something</div><br/></div></div></div></div></div></div><div id="42814131" class="c"><input type="checkbox" id="c-42814131" checked=""/><div class="controls bullet"><span class="by">grahamj</span><span>|</span><a href="#42813668">parent</a><span>|</span><a href="#42818096">prev</a><span>|</span><a href="#42820314">next</a><span>|</span><label class="collapse" for="c-42814131">[-]</label><label class="expand" for="c-42814131">[2 more]</label></div><br/><div class="children"><div class="content">The lack of ordering is surprising. Without that you can’t stream without a buffer.</div><br/><div id="42819064" class="c"><input type="checkbox" id="c-42819064" checked=""/><div class="controls bullet"><span class="by">trollbridge</span><span>|</span><a href="#42813668">root</a><span>|</span><a href="#42814131">parent</a><span>|</span><a href="#42820314">next</a><span>|</span><label class="collapse" for="c-42819064">[-]</label><label class="expand" for="c-42819064">[1 more]</label></div><br/><div class="children"><div class="content">The idea is that all peers eventually have the same collection of log entries, with an agreed-upon sort method. Currently that sort method is time stamps.<p>When it’s time to have identical replicas, a log entry must be appended that says the log is closed. Once all peers have this, the log is now immutable and can be treated as such. An example of this (for a payroll system) is a collection of entries for time clock in and outs, payroll taxes withheld, direct deposits to employees, etc when it’s time to do a payroll. The log is closed and that data can never be altered, but now the data can be relied on by someone else.<p>Conceptually this is surprisingly similar to the type of internal logs a typical database like PostgreSQL keeps.</div><br/></div></div></div></div></div></div><div id="42820314" class="c"><input type="checkbox" id="c-42820314" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#42813668">prev</a><span>|</span><a href="#42813050">next</a><span>|</span><label class="collapse" for="c-42820314">[-]</label><label class="expand" for="c-42820314">[1 more]</label></div><br/><div class="children"><div class="content">Or, every database is bitemporal, some just don’t know it yet</div><br/></div></div><div id="42813050" class="c"><input type="checkbox" id="c-42813050" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42820314">prev</a><span>|</span><a href="#42815733">next</a><span>|</span><label class="collapse" for="c-42813050">[-]</label><label class="expand" for="c-42813050">[5 more]</label></div><br/><div class="children"><div class="content">A short summary:<p>Complex distributed coordination and orchestration is at the root of what makes many apps brittle and prone to inconsistencies.<p>But we can mitigate much of complexity with a neat trick, building on the fact that every system (database, queue, state machine) is effectively a log underneath the hood. By implementing interaction with those systems as (conditional) events on a shared log, we can build amazingly robust apps.<p>If you have come across “Turning the Database Inside Out” (<a href="https:&#x2F;&#x2F;martin.kleppmann.com&#x2F;2015&#x2F;11&#x2F;05&#x2F;database-inside-out-at-oredev.html" rel="nofollow">https:&#x2F;&#x2F;martin.kleppmann.com&#x2F;2015&#x2F;11&#x2F;05&#x2F;database-inside-out-...</a>), you can think of this a bit like “Turning the Microservice Inside Out”<p>The post also looks at how this can be used in practice, given that our DBs and queues aren&#x27;t built like this, and how to strike a sweet-spot balance between this model with its great consistency, and maintaining healthy decoupling and separation of concerns.</div><br/><div id="42813579" class="c"><input type="checkbox" id="c-42813579" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#42813050">parent</a><span>|</span><a href="#42815733">next</a><span>|</span><label class="collapse" for="c-42813579">[-]</label><label class="expand" for="c-42813579">[4 more]</label></div><br/><div class="children"><div class="content">Is this summary AI generated?</div><br/><div id="42813634" class="c"><input type="checkbox" id="c-42813634" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42813050">root</a><span>|</span><a href="#42813579">parent</a><span>|</span><a href="#42815733">next</a><span>|</span><label class="collapse" for="c-42813634">[-]</label><label class="expand" for="c-42813634">[3 more]</label></div><br/><div class="children"><div class="content">Haha, no, but maybe all the AI-generated contents out there is starting to train me to write in a similar style...</div><br/><div id="42813645" class="c"><input type="checkbox" id="c-42813645" checked=""/><div class="controls bullet"><span class="by">p10jkle</span><span>|</span><a href="#42813050">root</a><span>|</span><a href="#42813634">parent</a><span>|</span><a href="#42815733">next</a><span>|</span><label class="collapse" for="c-42813645">[-]</label><label class="expand" for="c-42813645">[2 more]</label></div><br/><div class="children"><div class="content">I feel this happening to me too... depressing</div><br/><div id="42814380" class="c"><input type="checkbox" id="c-42814380" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42813050">root</a><span>|</span><a href="#42813645">parent</a><span>|</span><a href="#42815733">next</a><span>|</span><label class="collapse" for="c-42814380">[-]</label><label class="expand" for="c-42814380">[1 more]</label></div><br/><div class="children"><div class="content">Or an improvement, given that SOTA models write better than most people...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42815733" class="c"><input type="checkbox" id="c-42815733" checked=""/><div class="controls bullet"><span class="by">zellyn</span><span>|</span><a href="#42813050">prev</a><span>|</span><a href="#42815838">next</a><span>|</span><label class="collapse" for="c-42815733">[-]</label><label class="expand" for="c-42815733">[4 more]</label></div><br/><div class="children"><div class="content">sewen (et al)<p>This is lovely and I&#x27;m itching to try it. One question:<p>We have a use case where a location gets cut off completely from the internet at large. In that case, it makes sense for the local hardware (typically Android and&#x2F;or iOS tablets or equivalent) to take over as a log owner: even though you&#x27;re cut off, if you&#x27;re willing to swallow the risk (and hence cost) of offline payments, you should be able to create orders, fulfill them, pay for them, close them out, send tickets to the kitchen to cook the food or to the warehouse to fetch the tractor, etc.<p>Does restate include something that covers that use-case? In the noodling&#x2F;daydreaming a colleague and I have done, we ended up with something very close to restate (I imagined just using Kafka), except that additionally many operations would have a CRDT nature: eg. you should _always_ be allowed to add a payment to an order, because presumably a real-life payment happened.<p>I&#x27;ve also noodled with the idea of logs whose canonical ownership can be transferred. That covers cases where you start offline and then reconnect, but doesn&#x27;t work so well for transactions that start out connected (and thus owned in the datacenter) and need to continue offline.<p>One could also imagine ensuring that &gt; n&#x2F;2 consensus members are always located inside the restaurant&#x2F;hardware store&#x2F;etc., so if you go offline, you can still proceed. It might even be possible to recognize disconnection and then take one full vote to further subdivide that pool of consensus members so if one dies it doesn&#x27;t halt progress. This feels like it would be getting very tricksy…</div><br/><div id="42817306" class="c"><input type="checkbox" id="c-42817306" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42815733">parent</a><span>|</span><a href="#42818631">next</a><span>|</span><label class="collapse" for="c-42817306">[-]</label><label class="expand" for="c-42817306">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually working on a database implementation for this exact use-case... It&#x27;s a distributed edge database and still quite a long ways to go -- <a href="https:&#x2F;&#x2F;github.com&#x2F;bottledcode&#x2F;atlas-db">https:&#x2F;&#x2F;github.com&#x2F;bottledcode&#x2F;atlas-db</a> if you want to give it a star.<p>It&#x27;s mostly based on wpaxos (wide-area consensus), spaxos, fpaxos and pretty neat. The repo above is a productionization of several proof of concepts to get there.<p>&gt; One could also imagine ensuring that &gt; n&#x2F;2 consensus members are always located inside the restaurant&#x2F;hardware store&#x2F;etc., so if you go offline, you can still proceed.<p>This is what annoys me to no end about RAFT. It&#x27;s a great protocol, don&#x27;t get me wrong, but its too simple for these types of problems. RAFT fails when it doesn&#x27;t have consensus and because the consensus is non-deterministic, it must have an odd number of nodes. PAXOS, while far more complex than RAFT in terms of &quot;grok&quot;, is deterministic so you don&#x27;t need an odd number of nodes.<p>If you throw in some flexible quorums, you can do some really neat stuff, like how Atlas handles a &quot;region&quot; (ie, areas connected via the internet instead of the same network) becoming disconnected; but I&#x27;m not ready yet. There&#x27;s still a long way to go!</div><br/></div></div><div id="42818631" class="c"><input type="checkbox" id="c-42818631" checked=""/><div class="controls bullet"><span class="by">WilcoKruijer</span><span>|</span><a href="#42815733">parent</a><span>|</span><a href="#42817306">prev</a><span>|</span><a href="#42817894">next</a><span>|</span><label class="collapse" for="c-42818631">[-]</label><label class="expand" for="c-42818631">[1 more]</label></div><br/><div class="children"><div class="content">Interesting use case, I&#x27;ve also thought about this in the past.<p>I wonder why you want to designate the local device as &quot;owner&quot;. The devices could simply keep the (closed) payments in a local outbox, and send them to the server when it comes back online. If there is no way for syncing the local changes to the server to fail, you&#x27;ve essentially created a CRDT (at least the &quot;conflict-free&quot; part).<p>Of course that means you cannot have any server side validation at all (maybe this is what you mean by &quot;owner&quot;?). Because that would mean closed out payments would be rejected by the server and you&#x27;d end up in an inconsistent state. A consequence of this is that there could be no balance checking (as an example). Payments in a ledger are inherently a CRDT!<p>The consensus part is interesting. Would you really need it? Wouldn&#x27;t one device be sufficient to validate a transaction? And would consensus really even mean something within a small building? If the restaurant catches on fire the data would be lost anyway, so if you don&#x27;t achieve &quot;high-availability&quot;, why bother?</div><br/></div></div><div id="42817894" class="c"><input type="checkbox" id="c-42817894" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42815733">parent</a><span>|</span><a href="#42818631">prev</a><span>|</span><a href="#42815838">next</a><span>|</span><label class="collapse" for="c-42817894">[-]</label><label class="expand" for="c-42817894">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One could also imagine ensuring that &gt; n&#x2F;2 consensus members are always located inside the restaurant&#x2F;hardware store&#x2F;etc.<p>If the simple-majority is inside the restaurant, then the restaurant is online and the rest of the world is offline.</div><br/></div></div></div></div><div id="42815838" class="c"><input type="checkbox" id="c-42815838" checked=""/><div class="controls bullet"><span class="by">TuringTest</span><span>|</span><a href="#42815733">prev</a><span>|</span><a href="#42814173">next</a><span>|</span><label class="collapse" for="c-42815838">[-]</label><label class="expand" for="c-42815838">[6 more]</label></div><br/><div class="children"><div class="content">Excuse me for sounding rough, but - isn&#x27;t this reinventing comp-sci, one step at a time?<p>I learned about distributed incrementally 
-monotonic logs back at the late 90s, with many other ways to do guaranteed transactional database actions. And I&#x27;m quite certain these must have been invented in the 50s or 60s, as these are the problems that early business computer users had: banking software. These are the techniques that were buried in legacy COBOL routines, and needed to be slowly replaced by robust Java core services.<p>I&#x27;m sure the Restate designers will have learned terribly useful insights in how to translate these basic principles into a working system with the complexities of today&#x27;s hardware&#x2F;software ecosystem.<p>Yet it makes me wonder if young programmers are only being taught the &quot;build fast-break things&quot; mentality and there are no longer SW engineers able to insert these guarantees into their systems from the beginning, by standing on the shoulders of the ancients that invented our discipline, so that their lore is actually used in practice? Or am I just missing something new in the article that describes some novel twist?</div><br/><div id="42816712" class="c"><input type="checkbox" id="c-42816712" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42815838">parent</a><span>|</span><a href="#42816135">next</a><span>|</span><label class="collapse" for="c-42816712">[-]</label><label class="expand" for="c-42816712">[3 more]</label></div><br/><div class="children"><div class="content">When I was in school I had an optional requirement. You had to take one out of 2 or 3 classes to graduate. That was compiler design, which was getting terrible reviews from my peers who were taking it the semester before me, or distributed computing. Might have been a third but if so it was unmemorable.<p>So I took distributed computing. Which ended up being one of the four classes that satisfied the 80&#x2F;20 rule for my college education.<p>Quite recently I started asking coworkers if they took such a class and was shocked to learn how many not only didn’t take it, but could not even recall it being an option at their school. What?<p>I can understand it being rare in the 90’s but the 00’s and on were paying attention to horizontal scaling, and the 2020’s are rotten with it distributed computing concerns. How… why… I don’t understand how we got here.</div><br/><div id="42817249" class="c"><input type="checkbox" id="c-42817249" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42815838">root</a><span>|</span><a href="#42816712">parent</a><span>|</span><a href="#42816135">next</a><span>|</span><label class="collapse" for="c-42817249">[-]</label><label class="expand" for="c-42817249">[2 more]</label></div><br/><div class="children"><div class="content">So many people I work with don&#x27;t &quot;get&quot; distributed systems and how they interplay and cause problems. Most people don&#x27;t even know that the ORDER you take potentially competing (distributed) locks even matters -- which is super important if you have different teams taking the same locks in different services!<p>The article is well written, but they still have a lot of problems to solve.</div><br/><div id="42818537" class="c"><input type="checkbox" id="c-42818537" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42815838">root</a><span>|</span><a href="#42817249">parent</a><span>|</span><a href="#42816135">next</a><span>|</span><label class="collapse" for="c-42818537">[-]</label><label class="expand" for="c-42818537">[1 more]</label></div><br/><div class="children"><div class="content">I went too far the other way. Concurrent things just fit my brain so well that I created systems that made my coworkers have to ask for help. One that still sticks in my mind after all these years wanted to ask me to knock it off but lacked the technical chops to make it a demand. But I could read between the lines. He was part of my process of coming around to interpreting all questions as feedback.<p>There’s about 20% of reasonable designs that get you 80% of your potential, and I’m a world with multiple unrelated work loads running in parallel, most incidental inefficiencies are papered over by multitasking.<p>The problem is that cloud computing is actively flouting a lot of this knowledge and then charging us a premium for pretending that a bunch of the Fallacies don’t exist. The hangover is going to be spectacular when it hits.</div><br/></div></div></div></div></div></div><div id="42816135" class="c"><input type="checkbox" id="c-42816135" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42815838">parent</a><span>|</span><a href="#42816712">prev</a><span>|</span><a href="#42816283">next</a><span>|</span><label class="collapse" for="c-42816135">[-]</label><label class="expand" for="c-42816135">[1 more]</label></div><br/><div class="children"><div class="content">I think your points are pretty spot on - most things have already been invented, and there&#x27;s too much of a move-fast-and-break-things mentality.<p>Here&#x27;s a follow-up thought: to what extent did the grey-beards let us juniors down by steering us down a different path? A few instances:<p>DB creators knew about replicated logs, but we got given DBs, not replicated log products.<p>The Java creators knew about immutability: &quot;I would use an immutable whenever I can.&quot; [James Gosling, 1] but it was years later when someone else provided us with pcollections&#x2F;javaslang&#x2F;vavr.  And they&#x27;re still far from widespread, and nowhere near the standard library.<p>Brendan Eich supposedly wanted to put Scheme into browsers, but his superiors had him make JS instead.<p>What other stuff have we been missing out on?<p>[1] <a href="https:&#x2F;&#x2F;www.artima.com&#x2F;articles&#x2F;james-gosling-on-java-may-2001" rel="nofollow">https:&#x2F;&#x2F;www.artima.com&#x2F;articles&#x2F;james-gosling-on-java-may-20...</a></div><br/></div></div><div id="42816283" class="c"><input type="checkbox" id="c-42816283" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42815838">parent</a><span>|</span><a href="#42816135">prev</a><span>|</span><a href="#42814173">next</a><span>|</span><label class="collapse" for="c-42816283">[-]</label><label class="expand" for="c-42816283">[1 more]</label></div><br/><div class="children"><div class="content">This is certainly building on principles and ideas from a long history of computer science research.<p>And yes, there are moment where you go &quot;oh, we implicitly gave up xyz (i.e., causal order across steps) when we started adopting architecture pqr (microservices). But here is a thought on how to bring that back without breaking the benefits of pqr&quot;.<p>If you want, you can think of this as one of these cases. I would argue that there is tremendous practical value in that (I found that to be the case throughout my career).<p>And technology advances in zig zag lines. You add capability x but lose y on the way and later someone finds a way to have x and y together. That&#x27;s progress.</div><br/></div></div></div></div><div id="42814173" class="c"><input type="checkbox" id="c-42814173" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42815838">prev</a><span>|</span><a href="#42813578">next</a><span>|</span><label class="collapse" for="c-42814173">[-]</label><label class="expand" for="c-42814173">[5 more]</label></div><br/><div class="children"><div class="content">Using one-log-only for an entire system does have its upsides, but it will kill performance.  It would be like building a CRUD system with a single mutex for everyone to share.</div><br/><div id="42814290" class="c"><input type="checkbox" id="c-42814290" checked=""/><div class="controls bullet"><span class="by">hcarvalhoalves</span><span>|</span><a href="#42814173">parent</a><span>|</span><a href="#42813578">next</a><span>|</span><label class="collapse" for="c-42814290">[-]</label><label class="expand" for="c-42814290">[4 more]</label></div><br/><div class="children"><div class="content">I believe you want &quot;one log&quot; in the logical sense. In theory, you could have &quot;one log&quot; per user or group of users, or whatever sharding technique makes sense for multi tenancy model. It can also be &quot;one log&quot; per bounded context - e.g. the entire payment pipeline in one log.</div><br/><div id="42814387" class="c"><input type="checkbox" id="c-42814387" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42814173">root</a><span>|</span><a href="#42814290">parent</a><span>|</span><a href="#42814310">next</a><span>|</span><label class="collapse" for="c-42814387">[-]</label><label class="expand" for="c-42814387">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what the rest of us are doing in event-sourcing land, but TFA is arguing for something much stronger:<p><pre><code>  If everything’s in one log, there’s nothing to coordinate
</code></pre>
The rest of us have to coordinate the logical log of user creation&#x2F;deletion and the logical log of user payments, etc.<p>Separate logical logs with no need for coordination can only work if they are truly independent systems - no causality between them.</div><br/></div></div><div id="42814310" class="c"><input type="checkbox" id="c-42814310" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42814173">root</a><span>|</span><a href="#42814290">parent</a><span>|</span><a href="#42814387">prev</a><span>|</span><a href="#42813578">next</a><span>|</span><label class="collapse" for="c-42814310">[-]</label><label class="expand" for="c-42814310">[2 more]</label></div><br/><div class="children"><div class="content">Yes, exactly right. One log per logical entity, here &quot;payment ID&quot;.<p>The way our open source project implements that is with a partitioned log and indexes at key-granularity, so it is like virtually a log per key.</div><br/><div id="42817192" class="c"><input type="checkbox" id="c-42817192" checked=""/><div class="controls bullet"><span class="by">ianburrell</span><span>|</span><a href="#42814173">root</a><span>|</span><a href="#42814310">parent</a><span>|</span><a href="#42813578">next</a><span>|</span><label class="collapse" for="c-42817192">[-]</label><label class="expand" for="c-42817192">[1 more]</label></div><br/><div class="children"><div class="content">How do you deal with one side of transaction getting lost? Traditional double entry accounting puts entry for each side of the transaction. It will cause problems if one side is lost or delayed.<p>How do you handle transactions in general? It is pretty common to have multiple changes that need to be applied together. In a single log, can write the changes and then write a record that says the changes are committed. This is how databases work.</div><br/></div></div></div></div></div></div></div></div><div id="42813578" class="c"><input type="checkbox" id="c-42813578" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#42814173">prev</a><span>|</span><a href="#42815318">next</a><span>|</span><label class="collapse" for="c-42813578">[-]</label><label class="expand" for="c-42813578">[3 more]</label></div><br/><div class="children"><div class="content">My takeaway from this article is that the proposed solution for distributed app coordination is a shared, centralized log. What did I miss?</div><br/><div id="42813708" class="c"><input type="checkbox" id="c-42813708" checked=""/><div class="controls bullet"><span class="by">azmy</span><span>|</span><a href="#42813578">parent</a><span>|</span><a href="#42813756">next</a><span>|</span><label class="collapse" for="c-42813708">[-]</label><label class="expand" for="c-42813708">[1 more]</label></div><br/><div class="children"><div class="content">IMHO the article is not mainly about the implementation of the Log, but rather leveraging  on the idea of the log to build reliable and fault tolerant applications. The implementation of the log itself can be either centralised or decentralised.</div><br/></div></div><div id="42813756" class="c"><input type="checkbox" id="c-42813756" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42813578">parent</a><span>|</span><a href="#42813708">prev</a><span>|</span><a href="#42815318">next</a><span>|</span><label class="collapse" for="c-42813756">[-]</label><label class="expand" for="c-42813756">[1 more]</label></div><br/><div class="children"><div class="content">That gist is correct - I would add that the log needs a few specific properties and conceptually be the shared log for state, communication, execution scheduling.<p>The next step is the, how do you make this usable in practice...</div><br/></div></div></div></div><div id="42815318" class="c"><input type="checkbox" id="c-42815318" checked=""/><div class="controls bullet"><span class="by">jamamp</span><span>|</span><a href="#42813578">prev</a><span>|</span><a href="#42814215">next</a><span>|</span><label class="collapse" for="c-42815318">[-]</label><label class="expand" for="c-42815318">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how this compares, conceptually, to Temporal? While Temporal doesn&#x27;t talk about a single centralized log, I feel the output is the same: your event handlers become durable and can be retried without re-executing certain actions with outside systems. Both Restate and Temporal feel, as a developer coding these event handlers, like a framework where they handle a lot of the &quot;has this action been performed yet?&quot; and such for you.<p>Though to be fair I&#x27;ve only read Temporal docs, and this Restate blog post, without much experience in either. Temporal may not have as much on the distributed locking (or concept of) side of things that Restate does, in this post.</div><br/><div id="42815369" class="c"><input type="checkbox" id="c-42815369" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42815318">parent</a><span>|</span><a href="#42814215">next</a><span>|</span><label class="collapse" for="c-42815369">[-]</label><label class="expand" for="c-42815369">[1 more]</label></div><br/><div class="children"><div class="content">Temporal is related, but I would say it is a subset of this.<p>If you only consider appending results of steps of a handler, then you have something like Temporal.<p>This here uses the log also for RPC between services, for state that outlives an individual handler execution (state that outlives a workflow, in Temporal&#x27;s terms).</div><br/></div></div></div></div><div id="42814215" class="c"><input type="checkbox" id="c-42814215" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#42815318">prev</a><span>|</span><a href="#42814204">next</a><span>|</span><label class="collapse" for="c-42814215">[-]</label><label class="expand" for="c-42814215">[5 more]</label></div><br/><div class="children"><div class="content">I am a <i>huge</i> fan of append-only logs as a fundamental architectural principle. The Log [1] should be required reading for any CS undergraduate.<p>[1]: <a href="https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-what-every-software-engineer-should-know-about-real-time-datas-unifying" rel="nofollow">https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-wha...</a></div><br/><div id="42814236" class="c"><input type="checkbox" id="c-42814236" checked=""/><div class="controls bullet"><span class="by">kasey_junk</span><span>|</span><a href="#42814215">parent</a><span>|</span><a href="#42814204">next</a><span>|</span><label class="collapse" for="c-42814236">[-]</label><label class="expand" for="c-42814236">[4 more]</label></div><br/><div class="children"><div class="content">I love them so much that I’ve noodled with building a programming language optimized for using them.<p>Things like types that encode what events are legal in a log, first class support for data versions, fast file read and writes, etc</div><br/><div id="42814314" class="c"><input type="checkbox" id="c-42814314" checked=""/><div class="controls bullet"><span class="by">daxfohl</span><span>|</span><a href="#42814215">root</a><span>|</span><a href="#42814236">parent</a><span>|</span><a href="#42814204">next</a><span>|</span><label class="collapse" for="c-42814314">[-]</label><label class="expand" for="c-42814314">[3 more]</label></div><br/><div class="children"><div class="content">How do you do GDPR takedowns?</div><br/><div id="42815045" class="c"><input type="checkbox" id="c-42815045" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42814215">root</a><span>|</span><a href="#42814314">parent</a><span>|</span><a href="#42814776">next</a><span>|</span><label class="collapse" for="c-42815045">[-]</label><label class="expand" for="c-42815045">[1 more]</label></div><br/><div class="children"><div class="content">Best method is to encrypt data with a per user key so you if you delete the encryption key that customer&#x27;s data cannot be read. You can create a new customer key at a fixed time interval to make deletion more granular.</div><br/></div></div><div id="42814776" class="c"><input type="checkbox" id="c-42814776" checked=""/><div class="controls bullet"><span class="by">jaseemabid</span><span>|</span><a href="#42814215">root</a><span>|</span><a href="#42814314">parent</a><span>|</span><a href="#42815045">prev</a><span>|</span><a href="#42814204">next</a><span>|</span><label class="collapse" for="c-42814776">[-]</label><label class="expand" for="c-42814776">[1 more]</label></div><br/><div class="children"><div class="content">Immutable append only persistent log doesn&#x27;t imply store everything _forever_.<p>If you want to remove something you could add a tombstone record (like Cassandra) and eventually remove the original entry during routine maintenance operations like repacking into a more efficient format, archival into cold storage, TTL handling etc.</div><br/></div></div></div></div></div></div></div></div><div id="42814204" class="c"><input type="checkbox" id="c-42814204" checked=""/><div class="controls bullet"><span class="by">xnorswap</span><span>|</span><a href="#42814215">prev</a><span>|</span><a href="#42818515">next</a><span>|</span><label class="collapse" for="c-42814204">[-]</label><label class="expand" for="c-42814204">[2 more]</label></div><br/><div class="children"><div class="content">It sounds like they have just re-discovered Distributed Transactions with a Distributed Transaction Coordinator.<p>But DTs have a huge problem: What happens if the owner of the lock netsplits?<p>Either the DTC waits (potentially forever?) for the owner of the lock to get back in touch and release the lock, or a timeout is applied and now the owner of the lock (who may be unaware of the netsplit) will be out of sync with the system.</div><br/><div id="42815322" class="c"><input type="checkbox" id="c-42815322" checked=""/><div class="controls bullet"><span class="by">logsr</span><span>|</span><a href="#42814204">parent</a><span>|</span><a href="#42818515">next</a><span>|</span><label class="collapse" for="c-42815322">[-]</label><label class="expand" for="c-42815322">[1 more]</label></div><br/><div class="children"><div class="content">they point out that they are adding conditional append to a log, which gives the universality of a log data structure and a mechanism for implementing lock-free&#x2F;wait-free concurrency algorithms. it is a complete toolkit for building distributed systems because you can build anything else on top of those primitives.</div><br/></div></div></div></div><div id="42818515" class="c"><input type="checkbox" id="c-42818515" checked=""/><div class="controls bullet"><span class="by">yftsui</span><span>|</span><a href="#42814204">prev</a><span>|</span><a href="#42816175">next</a><span>|</span><label class="collapse" for="c-42818515">[-]</label><label class="expand" for="c-42818515">[1 more]</label></div><br/><div class="children"><div class="content">The diagrams are remarkably neat, has a feeling of both excalidraw and draw.io, anyone know what tool was used create those?</div><br/></div></div><div id="42816175" class="c"><input type="checkbox" id="c-42816175" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42818515">prev</a><span>|</span><a href="#42814134">next</a><span>|</span><label class="collapse" for="c-42816175">[-]</label><label class="expand" for="c-42816175">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly this example from Temporal: <a href="https:&#x2F;&#x2F;github.com&#x2F;temporal-sa&#x2F;temporal-order-fulfill-demo">https:&#x2F;&#x2F;github.com&#x2F;temporal-sa&#x2F;temporal-order-fulfill-demo</a></div><br/></div></div><div id="42814134" class="c"><input type="checkbox" id="c-42814134" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#42816175">prev</a><span>|</span><a href="#42813462">next</a><span>|</span><label class="collapse" for="c-42814134">[-]</label><label class="expand" for="c-42814134">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Having a single place (the one log) that forces a linear history of events as the ground truth and owns the decision of who can add to that ground truth, means we don’t have to coordinate much any more.<p>Well, yes, but then you&#x27;ve backed into CAP again because you only have <i>one</i> log.</div><br/><div id="42814383" class="c"><input type="checkbox" id="c-42814383" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42814134">parent</a><span>|</span><a href="#42814213">next</a><span>|</span><label class="collapse" for="c-42814383">[-]</label><label class="expand" for="c-42814383">[1 more]</label></div><br/><div class="children"><div class="content">Yes, we are assuming a log that picks linearizability at the cost of availability under partitions. Like most logs do, including Kafka, Pulsar, RedPanda, etc.<p>The application state is defined by the log here, and the log drives retries&#x2F;recovery, so it doesn&#x27;t much matter if the process that executes the app code splits off. The log would hydrate another one.<p>Also the one log is at the granularity of a single key or handler execution. More of a logical log, than a physical log or even partition.<p>In Restate, we implement a logical log-per-key, backed by a partitioned physical log.</div><br/></div></div><div id="42814213" class="c"><input type="checkbox" id="c-42814213" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42814134">parent</a><span>|</span><a href="#42814383">prev</a><span>|</span><a href="#42814193">next</a><span>|</span><label class="collapse" for="c-42814213">[-]</label><label class="expand" for="c-42814213">[1 more]</label></div><br/><div class="children"><div class="content">If I&#x27;ve understood it, it&#x27;s like using Kafka with 1 topic and 1 partition.  But it shouldn&#x27;t rule out multiple brokers with a &gt;1 replication factor, giving you CP.</div><br/></div></div><div id="42814193" class="c"><input type="checkbox" id="c-42814193" checked=""/><div class="controls bullet"><span class="by">clayg</span><span>|</span><a href="#42814134">parent</a><span>|</span><a href="#42814213">prev</a><span>|</span><a href="#42815090">next</a><span>|</span><label class="collapse" for="c-42814193">[-]</label><label class="expand" for="c-42814193">[3 more]</label></div><br/><div class="children"><div class="content">But can&#x27;t any log be implemented as a CRDT?  Was that not implied in the post?  I didn&#x27;t read it that close...</div><br/><div id="42814273" class="c"><input type="checkbox" id="c-42814273" checked=""/><div class="controls bullet"><span class="by">ismailmaj</span><span>|</span><a href="#42814134">root</a><span>|</span><a href="#42814193">parent</a><span>|</span><a href="#42815419">next</a><span>|</span><label class="collapse" for="c-42814273">[-]</label><label class="expand" for="c-42814273">[1 more]</label></div><br/><div class="children"><div class="content">CRDT is really only useful when inconsistencies could be acceptable in some situations and so it depends on the application.<p>For something that is trying to solve the general problem of consistent single ground-truth log, you can&#x27;t really do much better than Spanner.</div><br/></div></div><div id="42815419" class="c"><input type="checkbox" id="c-42815419" checked=""/><div class="controls bullet"><span class="by">logsr</span><span>|</span><a href="#42814134">root</a><span>|</span><a href="#42814193">parent</a><span>|</span><a href="#42814273">prev</a><span>|</span><a href="#42815090">next</a><span>|</span><label class="collapse" for="c-42815419">[-]</label><label class="expand" for="c-42815419">[1 more]</label></div><br/><div class="children"><div class="content">the &quot;conflict-free&quot; in crdt is like miller high life being the &quot;champagne of beers.&quot; it really means conflicts ignored and conflicting items discarded by established rules, which works well for some use cases, but for many does not.</div><br/></div></div></div></div><div id="42815090" class="c"><input type="checkbox" id="c-42815090" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42814134">parent</a><span>|</span><a href="#42814193">prev</a><span>|</span><a href="#42813462">next</a><span>|</span><label class="collapse" for="c-42815090">[-]</label><label class="expand" for="c-42815090">[5 more]</label></div><br/><div class="children"><div class="content">couldn&#x27;t the log be synchronously replicated to multiple servers to increase A?</div><br/><div id="42815793" class="c"><input type="checkbox" id="c-42815793" checked=""/><div class="controls bullet"><span class="by">ismailmaj</span><span>|</span><a href="#42814134">root</a><span>|</span><a href="#42815090">parent</a><span>|</span><a href="#42813462">next</a><span>|</span><label class="collapse" for="c-42815793">[-]</label><label class="expand" for="c-42815793">[4 more]</label></div><br/><div class="children"><div class="content">In case of mutation either the replicas will be out of sync (so no C), or you&#x27;ll need to synchronously mutate the replicas (so bad A due to latency).</div><br/><div id="42815964" class="c"><input type="checkbox" id="c-42815964" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42814134">root</a><span>|</span><a href="#42815793">parent</a><span>|</span><a href="#42813462">next</a><span>|</span><label class="collapse" for="c-42815964">[-]</label><label class="expand" for="c-42815964">[3 more]</label></div><br/><div class="children"><div class="content">delaying writes by a factor longer than the max clock skew of the cluster is a pretty common strategy. It is what Google Spanner does.</div><br/><div id="42816077" class="c"><input type="checkbox" id="c-42816077" checked=""/><div class="controls bullet"><span class="by">ismailmaj</span><span>|</span><a href="#42814134">root</a><span>|</span><a href="#42815964">parent</a><span>|</span><a href="#42813462">next</a><span>|</span><label class="collapse" for="c-42816077">[-]</label><label class="expand" for="c-42816077">[2 more]</label></div><br/><div class="children"><div class="content">Right but it&#x27;s not magic as you cannot predict networking delays.<p>The max clock skew also has to pick between A and C, in underestimates you lose serializability, in overestimates you pay in write latency.</div><br/><div id="42816374" class="c"><input type="checkbox" id="c-42816374" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42814134">root</a><span>|</span><a href="#42816077">parent</a><span>|</span><a href="#42813462">next</a><span>|</span><label class="collapse" for="c-42816374">[-]</label><label class="expand" for="c-42816374">[1 more]</label></div><br/><div class="children"><div class="content">What if you use CockroachDB for your log? They do something pretty clever: <a href="https:&#x2F;&#x2F;www.cockroachlabs.com&#x2F;blog&#x2F;living-without-atomic-clocks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cockroachlabs.com&#x2F;blog&#x2F;living-without-atomic-clo...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42813462" class="c"><input type="checkbox" id="c-42813462" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#42814134">prev</a><span>|</span><a href="#42814151">next</a><span>|</span><label class="collapse" for="c-42813462">[-]</label><label class="expand" for="c-42813462">[7 more]</label></div><br/><div class="children"><div class="content">Since we’re on the subject of logs and embarassingly parallel distributed systems, I know someone who’s also in NYC who’s been building a project exactly along these lines. It’s called <i>gossiplog</i> and it uses Prolly trees to make some interesting results.<p><a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@canvas-js&#x2F;gossiplog" rel="nofollow">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@canvas-js&#x2F;gossiplog</a><p>Joel Gustafson started this stuff at MIT and used to work at Protocol Labs. It’s very straightforward. By any chance sewen do you know him?<p>I first became aware of this guy’s work when he posted “merklizing the key value store for fun and profit” or something like that. Afterwards I looked at log protocols, including SLEEP protocol for Dat&#x2F;Hypercore&#x2F; pear and time-travel DBs that track diffs, including including Dolt and even Quadrable.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36265429">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36265429</a><p>Gossiplog’s README says exactly what this article says— everything is a log underneath and if you can sync that (using prolly tree techniques) people can just focus on business logic and get sync for free!</div><br/><div id="42819249" class="c"><input type="checkbox" id="c-42819249" checked=""/><div class="controls bullet"><span class="by">hem777</span><span>|</span><a href="#42813462">parent</a><span>|</span><a href="#42813603">next</a><span>|</span><label class="collapse" for="c-42819249">[-]</label><label class="expand" for="c-42819249">[1 more]</label></div><br/><div class="children"><div class="content">There’s also OrbitDB <a href="https:&#x2F;&#x2F;github.com&#x2F;orbitdb&#x2F;orbitdb">https:&#x2F;&#x2F;github.com&#x2F;orbitdb&#x2F;orbitdb</a> which to my understanding has been a pioneer for p2p logs, databases and CRDTs.</div><br/></div></div><div id="42813603" class="c"><input type="checkbox" id="c-42813603" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42813462">parent</a><span>|</span><a href="#42819249">prev</a><span>|</span><a href="#42813693">next</a><span>|</span><label class="collapse" for="c-42813603">[-]</label><label class="expand" for="c-42813603">[2 more]</label></div><br/><div class="children"><div class="content">Never encountered it before, but it looks cool.<p>I think they are trying to solve a related problem. &quot;We can consolidate the work by making a generic log that has networking and syncing built-in. This can be used by developers to make automatically-decentralized apps without writing a single line of networking code.&quot;<p>At a first glance, I would say that Gossiplog is a bit more low level, targeting developers of databases and queues, to save them from re-building a log every time. But then there are elements of sharing the log between components. Worth a deeper look, but seems a bit lower level abstraction.</div><br/><div id="42813874" class="c"><input type="checkbox" id="c-42813874" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#42813462">root</a><span>|</span><a href="#42813603">parent</a><span>|</span><a href="#42813693">next</a><span>|</span><label class="collapse" for="c-42813874">[-]</label><label class="expand" for="c-42813874">[1 more]</label></div><br/><div class="children"><div class="content">It’s part of his higher-level framework called Canvas.<p>Check this out: <a href="https:&#x2F;&#x2F;joelgustafson.com&#x2F;posts&#x2F;2024-09-30&#x2F;introduction-to-causal-logs" rel="nofollow">https:&#x2F;&#x2F;joelgustafson.com&#x2F;posts&#x2F;2024-09-30&#x2F;introduction-to-c...</a><p>And this: <a href="https:&#x2F;&#x2F;github.com&#x2F;canvasxyz&#x2F;canvas">https:&#x2F;&#x2F;github.com&#x2F;canvasxyz&#x2F;canvas</a></div><br/></div></div></div></div><div id="42813693" class="c"><input type="checkbox" id="c-42813693" checked=""/><div class="controls bullet"><span class="by">vdm</span><span>|</span><a href="#42813462">parent</a><span>|</span><a href="#42813603">prev</a><span>|</span><a href="#42814151">next</a><span>|</span><label class="collapse" for="c-42813693">[-]</label><label class="expand" for="c-42813693">[3 more]</label></div><br/><div class="children"><div class="content">Thank you @EGreg for sharing this.</div><br/><div id="42813831" class="c"><input type="checkbox" id="c-42813831" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#42813462">root</a><span>|</span><a href="#42813693">parent</a><span>|</span><a href="#42813802">next</a><span>|</span><label class="collapse" for="c-42813831">[-]</label><label class="expand" for="c-42813831">[1 more]</label></div><br/><div class="children"><div class="content">Def. I geek out on this stuff, as I am building my own distributed systems. I have had discussions with a lot of people in the space, like Leslie Lamport, Petar Maymounkov etc.<p>You might like this interview:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JWrRqUkJpMQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JWrRqUkJpMQ</a><p>This is what I’m working on now:
<a href="https:&#x2F;&#x2F;intercoin.org&#x2F;intercloud.pdf" rel="nofollow">https:&#x2F;&#x2F;intercoin.org&#x2F;intercloud.pdf</a></div><br/></div></div></div></div></div></div><div id="42814151" class="c"><input type="checkbox" id="c-42814151" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#42813462">prev</a><span>|</span><a href="#42814157">next</a><span>|</span><label class="collapse" for="c-42814151">[-]</label><label class="expand" for="c-42814151">[1 more]</label></div><br/><div class="children"><div class="content">Great post!  At pico we&#x27;ve been spending a lot of time thinking about logs and a distributed system that can read and respond to events from logs.  This is being driven in part by building out global services and a need for centralized logs for monitoring.<p>The end result is <a href="https:&#x2F;&#x2F;pipe.pico.sh" rel="nofollow">https:&#x2F;&#x2F;pipe.pico.sh</a> which is an authenticated, networked *nix pipes over SSH.  Since it relies on stdin&#x2F;stdout via SSH it&#x27;s one of the easiest pubsub systems we&#x27;ve used and we keep finding its ergonomics powerful.  We have a centralized log-drain, metric-drain, and cache-clearing-drain all using `pipe`.</div><br/></div></div><div id="42814157" class="c"><input type="checkbox" id="c-42814157" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#42814151">prev</a><span>|</span><a href="#42813229">next</a><span>|</span><label class="collapse" for="c-42814157">[-]</label><label class="expand" for="c-42814157">[7 more]</label></div><br/><div class="children"><div class="content">&gt; If everything’s in one log, there’s nothing to coordinate #<p>On the contrary. Everything becomes coordinated.<p>The entire &quot;log&quot; becomes a giant ass mutex lock. Good luck scaling it.</div><br/><div id="42814292" class="c"><input type="checkbox" id="c-42814292" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42814157">parent</a><span>|</span><a href="#42814467">next</a><span>|</span><label class="collapse" for="c-42814292">[-]</label><label class="expand" for="c-42814292">[1 more]</label></div><br/><div class="children"><div class="content">There is nothing to coordinate for the application, because, yes, the log coordinates everything. But not globally, on the level of a single event handler execution, or a single key.<p>That has been proven to scale well - the way we implement that in Restate is classical shared nothing physical partitioning, with indexing on a key granularity.<p>So nothing like a shared mutex unless you want to access the same key, which otherwise your database synchronizes, if you want any reasonable level of consistency.</div><br/></div></div><div id="42814467" class="c"><input type="checkbox" id="c-42814467" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42814157">parent</a><span>|</span><a href="#42814292">prev</a><span>|</span><a href="#42816691">next</a><span>|</span><label class="collapse" for="c-42814467">[-]</label><label class="expand" for="c-42814467">[3 more]</label></div><br/><div class="children"><div class="content">I think the author is motte-and-baileying between:<p><i>Literally one log</i> - which does indeed reduce your coordination headache, but is susceptible to your &quot;giant ass mutex&quot; comment, and<p><i>One log per ...</i> - which brings the coordination problems right back into existence.</div><br/><div id="42814587" class="c"><input type="checkbox" id="c-42814587" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42814157">root</a><span>|</span><a href="#42814467">parent</a><span>|</span><a href="#42816691">next</a><span>|</span><label class="collapse" for="c-42814587">[-]</label><label class="expand" for="c-42814587">[2 more]</label></div><br/><div class="children"><div class="content">I can see where some of that could be written more clearly. To elaborate:<p>- We mean using one log across different concerns like state a, communication with b, lock c. Often that is in the scope of a single entity (payment, user, session, etc.) and thus the scope for the one log is still small, and it reduces coordination headache for coordinating between the systems. You would have a lot of independent logs still, for separate payments.<p>- It does _not_ mean that one should share the same log (and partition) for all the entities in your app, like necessarily funneling all users, payments, etc. through the same log. What would be needed if you try and do some multi-key-distributed transaction processing. That goes actually beyond the proposal here, and has some benefits of its own, but have a hard time scaling.</div><br/><div id="42814810" class="c"><input type="checkbox" id="c-42814810" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42814157">root</a><span>|</span><a href="#42814587">parent</a><span>|</span><a href="#42816691">next</a><span>|</span><label class="collapse" for="c-42814810">[-]</label><label class="expand" for="c-42814810">[1 more]</label></div><br/><div class="children"><div class="content">&gt; thus the scope for the one log is still small, and it reduces coordination headache for coordinating between the systems.<p>This does not follow.<p>Neither the dev (nor the product seller) is in control of what real-world effects have a causal relationship.<p>If my actions can be <i>independently processed</i> from your actions, then we don&#x27;t need to coordinate, and micrologs will perform faster than a monolog.<p>If my actions cannot be <i>independently processed</i> from your actions, then we do need to coordinate, unless we use a monolog, which kills performance.<p>Either way, we don&#x27;t get to choose the level of independence.  If the actions are dependent, we either coordinate or or mess up causality.</div><br/></div></div></div></div></div></div><div id="42816691" class="c"><input type="checkbox" id="c-42816691" checked=""/><div class="controls bullet"><span class="by">neuroelectron</span><span>|</span><a href="#42814157">parent</a><span>|</span><a href="#42814467">prev</a><span>|</span><a href="#42816461">next</a><span>|</span><label class="collapse" for="c-42816691">[-]</label><label class="expand" for="c-42816691">[1 more]</label></div><br/><div class="children"><div class="content">Exactly what I was thinking. Now what&#x27;s the best mutex system we&#x27;ve built? An SQL database.</div><br/></div></div><div id="42816461" class="c"><input type="checkbox" id="c-42816461" checked=""/><div class="controls bullet"><span class="by">kikimora</span><span>|</span><a href="#42814157">parent</a><span>|</span><a href="#42816691">prev</a><span>|</span><a href="#42813229">next</a><span>|</span><label class="collapse" for="c-42816461">[-]</label><label class="expand" for="c-42816461">[1 more]</label></div><br/><div class="children"><div class="content">You can use something like DynamoDb with partition per interaction. That would scale great.</div><br/></div></div></div></div><div id="42813229" class="c"><input type="checkbox" id="c-42813229" checked=""/><div class="controls bullet"><span class="by">whoiskatrin</span><span>|</span><a href="#42814157">prev</a><span>|</span><a href="#42815759">next</a><span>|</span><label class="collapse" for="c-42813229">[-]</label><label class="expand" for="c-42813229">[3 more]</label></div><br/><div class="children"><div class="content">whats your take on handling log compaction to prevent unbounded growth, especially in systems with high write throughput?</div><br/><div id="42813248" class="c"><input type="checkbox" id="c-42813248" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42813229">parent</a><span>|</span><a href="#42813744">next</a><span>|</span><label class="collapse" for="c-42813248">[-]</label><label class="expand" for="c-42813248">[1 more]</label></div><br/><div class="children"><div class="content">Nice question! Restate is not a log that retains the raw events for a long time - conceptually just until they where processed by the handlers, DB, locking, etc.<p>When you build stateful handlers, the state per key is in the internal DB, and that get&#x27;s you a similar effect to log compaction, i.e., retain one value per key.</div><br/></div></div><div id="42813744" class="c"><input type="checkbox" id="c-42813744" checked=""/><div class="controls bullet"><span class="by">trollbridge</span><span>|</span><a href="#42813229">parent</a><span>|</span><a href="#42813248">prev</a><span>|</span><a href="#42815759">next</a><span>|</span><label class="collapse" for="c-42813744">[-]</label><label class="expand" for="c-42813744">[1 more]</label></div><br/><div class="children"><div class="content">I have a “summarise” log entry: the current log’s contents that will be relevant to the future are summarised. For example, if it’s FY2023’s financial transactions, we compute the final balances at the end of the year. We then close the log, and write an entry to it of “no more log entries after this are valid”.<p>We then copy the summary transactions to a new log, and compress and archive the old log.<p>You can identify high throughput and low throughput types of log entries and segregate them into different log streams. For example, the “new customer&#x2F;change customer info” stream probably gets way less traffic than the “customer has logged in” stream. The former is also harder to summarise. Put the hard to summarise but low volume stuff in its own log.</div><br/></div></div></div></div><div id="42815759" class="c"><input type="checkbox" id="c-42815759" checked=""/><div class="controls bullet"><span class="by">amirjak</span><span>|</span><a href="#42813229">prev</a><span>|</span><a href="#42815542">next</a><span>|</span><label class="collapse" for="c-42815759">[-]</label><label class="expand" for="c-42815759">[2 more]</label></div><br/><div class="children"><div class="content">How would you compare this to the actor model or to temporal?</div><br/><div id="42815797" class="c"><input type="checkbox" id="c-42815797" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42815759">parent</a><span>|</span><a href="#42815542">next</a><span>|</span><label class="collapse" for="c-42815797">[-]</label><label class="expand" for="c-42815797">[1 more]</label></div><br/><div class="children"><div class="content">Great question:<p>The Virtual Objects in Restate are much like actors. They are somewhat inspired by Orleans [1], and you could call them virtual stateful actors. They blend with the durable execution for processing messages with multiple durable steps.<p>Regarding temporal, check also this question: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42815318">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42815318</a></div><br/></div></div></div></div><div id="42815542" class="c"><input type="checkbox" id="c-42815542" checked=""/><div class="controls bullet"><span class="by">erikerikson</span><span>|</span><a href="#42815759">prev</a><span>|</span><a href="#42818108">next</a><span>|</span><label class="collapse" for="c-42815542">[-]</label><label class="expand" for="c-42815542">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s there a hosted offering? (Or plans to offer one?)</div><br/><div id="42818070" class="c"><input type="checkbox" id="c-42818070" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42815542">parent</a><span>|</span><a href="#42818108">next</a><span>|</span><label class="collapse" for="c-42818070">[-]</label><label class="expand" for="c-42818070">[2 more]</label></div><br/><div class="children"><div class="content">Yes, there is one, have a look at <a href="https:&#x2F;&#x2F;restate.dev&#x2F;cloud&#x2F;" rel="nofollow">https:&#x2F;&#x2F;restate.dev&#x2F;cloud&#x2F;</a></div><br/><div id="42818137" class="c"><input type="checkbox" id="c-42818137" checked=""/><div class="controls bullet"><span class="by">erikerikson</span><span>|</span><a href="#42815542">root</a><span>|</span><a href="#42818070">parent</a><span>|</span><a href="#42818108">next</a><span>|</span><label class="collapse" for="c-42818137">[-]</label><label class="expand" for="c-42818137">[1 more]</label></div><br/><div class="children"><div class="content">Thank you and sorry I missed it.</div><br/></div></div></div></div></div></div><div id="42818108" class="c"><input type="checkbox" id="c-42818108" checked=""/><div class="controls bullet"><span class="by">random3</span><span>|</span><a href="#42815542">prev</a><span>|</span><a href="#42816532">next</a><span>|</span><label class="collapse" for="c-42818108">[-]</label><label class="expand" for="c-42818108">[1 more]</label></div><br/><div class="children"><div class="content">looks like a new generation is ready to discover Paxos, Zab, Raft</div><br/></div></div><div id="42816532" class="c"><input type="checkbox" id="c-42816532" checked=""/><div class="controls bullet"><span class="by">paulsutter</span><span>|</span><a href="#42818108">prev</a><span>|</span><a href="#42813813">next</a><span>|</span><label class="collapse" for="c-42816532">[-]</label><label class="expand" for="c-42816532">[1 more]</label></div><br/><div class="children"><div class="content">This is very compelling, nice work. I&#x27;m going to spend some quality time on this.</div><br/></div></div><div id="42813813" class="c"><input type="checkbox" id="c-42813813" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42816532">prev</a><span>|</span><label class="collapse" for="c-42813813">[-]</label><label class="expand" for="c-42813813">[2 more]</label></div><br/><div class="children"><div class="content">This is basically CSP no?</div><br/><div id="42813915" class="c"><input type="checkbox" id="c-42813915" checked=""/><div class="controls bullet"><span class="by">sewen</span><span>|</span><a href="#42813813">parent</a><span>|</span><label class="collapse" for="c-42813915">[-]</label><label class="expand" for="c-42813915">[1 more]</label></div><br/><div class="children"><div class="content">I assume CSP is communicating sequential processes?<p>Interesting analogy - in a way it is doing something CSP-like in a distributed app&#x2F;service architecture with the all the different processes and components that are there. The shared log (or a partition of that) being a way to establish a sequential order.</div><br/></div></div></div></div></div></div></div></div></div></body></html>