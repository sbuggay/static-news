<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735203655002" as="style"/><link rel="stylesheet" href="styles.css?v=1735203655002"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fstar-lang.org/">F*: A proof oriented general purpose programming language</a> <span class="domain">(<a href="https://fstar-lang.org">fstar-lang.org</a>)</span></div><div class="subtext"><span>akkad33</span> | <span>55 comments</span></div><br/><div><div id="42514003" class="c"><input type="checkbox" id="c-42514003" checked=""/><div class="controls bullet"><span class="by">deknos</span><span>|</span><a href="#42510078">next</a><span>|</span><label class="collapse" for="c-42514003">[-]</label><label class="expand" for="c-42514003">[1 more]</label></div><br/><div class="children"><div class="content">Nice, but as long as at least core and minimal standard library is not really opensource, well maintained and first class citizen on linux, it will not get real distribution.<p>Even C# suffers from that, though it is a nice language.<p>For a programming language to have success it needs to be<p>* opensource
* well maintained
* first class citizen on win&#x2F;lin&#x2F;mac</div><br/></div></div><div id="42510078" class="c"><input type="checkbox" id="c-42510078" checked=""/><div class="controls bullet"><span class="by">seeknotfind</span><span>|</span><a href="#42514003">prev</a><span>|</span><a href="#42512790">next</a><span>|</span><label class="collapse" for="c-42510078">[-]</label><label class="expand" for="c-42510078">[13 more]</label></div><br/><div class="children"><div class="content">I studied formal languages for ~2 years and have professional experience programming coq. The real benefit of this language, over other formal languages is the focus on being able to write real programs in it. Most theorem proving languages are focused on mathematics or proving things about a program, and they are very abstract. This language appears to have a goal of bridging the gap and making it simple to write programs and prove parts of them. I believe this is the future of formal languages. If you write something in Rust, it would be great to prove aspects about it. Why not? Well F* is a vision if this future. As proof automation gets better, we will be able to prove many things about our programs, something which is not typically attempted due to difficulty. For instance, imagine proving that a certain path has no allocations, spawns no threads, cannot deadlock, preserves privacy, only modifies a certain subset of global data, is a specific algorithmic complexity, is not subject to timing attacks, maintains the conference of a cache, is memory safe (without a borrow checker). The limit is your imagination and Rice&#x27;s theorem.</div><br/><div id="42510118" class="c"><input type="checkbox" id="c-42510118" checked=""/><div class="controls bullet"><span class="by">akkad33</span><span>|</span><a href="#42510078">parent</a><span>|</span><a href="#42510227">next</a><span>|</span><label class="collapse" for="c-42510118">[-]</label><label class="expand" for="c-42510118">[6 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;dafny.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dafny.org&#x2F;</a> also allows proof checking and allows do write real programs with it. It has a java like syntax and is also from MS I believe</div><br/><div id="42510664" class="c"><input type="checkbox" id="c-42510664" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#42510078">root</a><span>|</span><a href="#42510118">parent</a><span>|</span><a href="#42510803">next</a><span>|</span><label class="collapse" for="c-42510664">[-]</label><label class="expand" for="c-42510664">[4 more]</label></div><br/><div class="children"><div class="content">Having used both Dafny and F* quite extensively, Dafny, and its predecessor Spec#, are simple and practical, thanks to being based on Hoare logic (contracts).<p>It&#x27;s a great place to start with verification, as proofs are discharged to SAT&#x2F;SMT, so things are automated. It can get a bit frustrating when automation is not able to prove things, that&#x27;s the major disadvantage of SAT&#x2F;SMT.<p>But it&#x27;s not a toy. Some of the largest verification efforts have been done in Dafny. See e.g. IronFleet [1].<p>[1] <a href="https:&#x2F;&#x2F;www.andrew.cmu.edu&#x2F;user&#x2F;bparno&#x2F;papers&#x2F;ironfleet.pdf" rel="nofollow">https:&#x2F;&#x2F;www.andrew.cmu.edu&#x2F;user&#x2F;bparno&#x2F;papers&#x2F;ironfleet.pdf</a></div><br/><div id="42512099" class="c"><input type="checkbox" id="c-42512099" checked=""/><div class="controls bullet"><span class="by">fovc</span><span>|</span><a href="#42510078">root</a><span>|</span><a href="#42510664">parent</a><span>|</span><a href="#42511283">next</a><span>|</span><label class="collapse" for="c-42512099">[-]</label><label class="expand" for="c-42512099">[1 more]</label></div><br/><div class="children"><div class="content">Agree it’s not a toy. AWS implemented a large chunk of IAM in Dafny. Though IIRC they have their own non-public compiler to Java</div><br/></div></div><div id="42511283" class="c"><input type="checkbox" id="c-42511283" checked=""/><div class="controls bullet"><span class="by">gsbcbdjfncnjd</span><span>|</span><a href="#42510078">root</a><span>|</span><a href="#42510664">parent</a><span>|</span><a href="#42512099">prev</a><span>|</span><a href="#42510803">next</a><span>|</span><label class="collapse" for="c-42511283">[-]</label><label class="expand" for="c-42511283">[2 more]</label></div><br/><div class="children"><div class="content">F* also uses SAT&#x2F;SMT, specifically Z3.</div><br/><div id="42512801" class="c"><input type="checkbox" id="c-42512801" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#42510078">root</a><span>|</span><a href="#42511283">parent</a><span>|</span><a href="#42510803">next</a><span>|</span><label class="collapse" for="c-42512801">[-]</label><label class="expand" for="c-42512801">[1 more]</label></div><br/><div class="children"><div class="content">Sure, what I meant is that Dafny outsources everything to SAT&#x2F;SMT. If it doesn&#x27;t manage to prove things for you, it gets a bit frustrating as there is not much support for manual tactics compared to F*, Coq or Isabelle, which can also leverage SAT&#x2F;SMT, but have other options.</div><br/></div></div></div></div></div></div></div></div><div id="42510227" class="c"><input type="checkbox" id="c-42510227" checked=""/><div class="controls bullet"><span class="by">markusde</span><span>|</span><a href="#42510078">parent</a><span>|</span><a href="#42510118">prev</a><span>|</span><a href="#42512378">next</a><span>|</span><label class="collapse" for="c-42510227">[-]</label><label class="expand" for="c-42510227">[2 more]</label></div><br/><div class="children"><div class="content">Do you think you might be able to elaborate a little bit more about this?<p>I was skimming the &quot;Proof-Oriented Programming&quot; book, and it seems that the primary way to execute F* programs is by extraction or trusted compilation (same as Rocq and Lean, for example). Does F* have some special way to work directly with realistic source code that these other systems don&#x27;t?</div><br/><div id="42511197" class="c"><input type="checkbox" id="c-42511197" checked=""/><div class="controls bullet"><span class="by">seeknotfind</span><span>|</span><a href="#42510078">root</a><span>|</span><a href="#42510227">parent</a><span>|</span><a href="#42512378">next</a><span>|</span><label class="collapse" for="c-42511197">[-]</label><label class="expand" for="c-42511197">[1 more]</label></div><br/><div class="children"><div class="content">F* is a programming language with proof support. Lean&#x2F;Coq are theorem providers that can be used to model and generate code. In Coq, there&#x27;s not a standard way to generate code, you might model and create code many different ways. F* seems to bring this in as the central goal of the language. So I&#x27;m discussing this structural difference. F* has an SMT solver, but Lean can import an SMT solver. So the goal is the important difference here - making theorem proving as accessible as possible in a real language. It&#x27;s a move in the right direction, but we want to get to the point standard program languages have this support if you need it.</div><br/></div></div></div></div><div id="42512378" class="c"><input type="checkbox" id="c-42512378" checked=""/><div class="controls bullet"><span class="by">newpavlov</span><span>|</span><a href="#42510078">parent</a><span>|</span><a href="#42510227">prev</a><span>|</span><a href="#42511303">next</a><span>|</span><label class="collapse" for="c-42512378">[-]</label><label class="expand" for="c-42512378">[1 more]</label></div><br/><div class="children"><div class="content">&gt;memory safe (without a borrow checker)<p>This sounds like a very weird statement.<p>In my opinion, a proper proof-oriented language would inevitably contain a borrow checker variant as a subset of its functionality (assuming the language has notion of pointers&#x2F;references and focuses on achieving &quot;zero cost abstractions&quot;). Lifetime annotations and shared&#x2F;exclusive references provide essential information and code use restrictions which enable automatic proof generation.<p>After all, type and borrow checkers are nothing more than limited forms of automatic proof generation which are practical enough for wide use.</div><br/></div></div><div id="42511303" class="c"><input type="checkbox" id="c-42511303" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#42510078">parent</a><span>|</span><a href="#42512378">prev</a><span>|</span><a href="#42511043">next</a><span>|</span><label class="collapse" for="c-42511303">[-]</label><label class="expand" for="c-42511303">[1 more]</label></div><br/><div class="children"><div class="content">I’ll add that SPARK Ada allows this now, has commercial tooling from Adacore, and was field-prove in years of commercial deployments.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;SPARK_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;SPARK_(programming_language)</a><p>It builds on the Why3 platform which also supports Frama-C for the C language. IIRC, SPARK can be compiled to C for C-only, runtime targets as well.</div><br/></div></div><div id="42511043" class="c"><input type="checkbox" id="c-42511043" checked=""/><div class="controls bullet"><span class="by">rajamaka</span><span>|</span><a href="#42510078">parent</a><span>|</span><a href="#42511303">prev</a><span>|</span><a href="#42512790">next</a><span>|</span><label class="collapse" for="c-42511043">[-]</label><label class="expand" for="c-42511043">[2 more]</label></div><br/><div class="children"><div class="content">Where would a smooth brained CRUD app web developer who failed high school maths perhaps learn more  about the point of this?</div><br/><div id="42511246" class="c"><input type="checkbox" id="c-42511246" checked=""/><div class="controls bullet"><span class="by">seeknotfind</span><span>|</span><a href="#42510078">root</a><span>|</span><a href="#42511043">parent</a><span>|</span><a href="#42512790">next</a><span>|</span><label class="collapse" for="c-42511246">[-]</label><label class="expand" for="c-42511246">[1 more]</label></div><br/><div class="children"><div class="content">The point would be to prove that your database stays consistent, a DB upgrade wouldn&#x27;t break, or that you could achieve 100% up time given certain assumptions. An automated solver&#x2F;prover might even be able to tell you where in your program breaks this. Without a technology like this, you have to carefully read your program, but this is the methodology to make the computer deal with that. Unfortunately formal verification is mostly used for research, F* is framing itself as taking a step to bring that to production codebases. Unfortunately I don&#x27;t know good resources, but as researchers adapt this technology, and as we automate a lot of the heavy mathematics, you&#x27;d never want a programming language without this option.</div><br/></div></div></div></div></div></div><div id="42512790" class="c"><input type="checkbox" id="c-42512790" checked=""/><div class="controls bullet"><span class="by">agnishom</span><span>|</span><a href="#42510078">prev</a><span>|</span><a href="#42509868">next</a><span>|</span><label class="collapse" for="c-42512790">[-]</label><label class="expand" for="c-42512790">[1 more]</label></div><br/><div class="children"><div class="content">I think Lean is another closely related language. It is very famous for its theorem proving capabilities, of course, but it seems that it can also express effectful computations (aka, real world programs).<p>Somebody managed to solve Advent of Code with Lean: <a href="https:&#x2F;&#x2F;github.com&#x2F;anurudhp&#x2F;aoc2022">https:&#x2F;&#x2F;github.com&#x2F;anurudhp&#x2F;aoc2022</a><p>Somebody managed to write a raytracer with Lean: <a href="https:&#x2F;&#x2F;github.com&#x2F;kmill&#x2F;lean4-raytracer">https:&#x2F;&#x2F;github.com&#x2F;kmill&#x2F;lean4-raytracer</a></div><br/></div></div><div id="42509868" class="c"><input type="checkbox" id="c-42509868" checked=""/><div class="controls bullet"><span class="by">thunkingdeep</span><span>|</span><a href="#42512790">prev</a><span>|</span><a href="#42510330">next</a><span>|</span><label class="collapse" for="c-42509868">[-]</label><label class="expand" for="c-42509868">[8 more]</label></div><br/><div class="children"><div class="content">In what situations would one prefer this vs Lean?<p>This seems to compile to native code if desired, so does that mean it’s faster than Lean?<p>Forgive me if these are obvious questions, I’m just curious and on my phone right now away from my machine.</div><br/><div id="42510138" class="c"><input type="checkbox" id="c-42510138" checked=""/><div class="controls bullet"><span class="by">markusde</span><span>|</span><a href="#42509868">parent</a><span>|</span><a href="#42512806">next</a><span>|</span><label class="collapse" for="c-42510138">[-]</label><label class="expand" for="c-42510138">[2 more]</label></div><br/><div class="children"><div class="content">One technical difference is that F* heavily uses SMT automation, which is less emphasized in Lean (their book even says that F* typechecking is undecidable). F* programmers frequently talk about the language&#x27;s emphasis on monadic programming, which I&#x27;ll admit that I don&#x27;t understand (but would like to!)</div><br/><div id="42510781" class="c"><input type="checkbox" id="c-42510781" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#42509868">root</a><span>|</span><a href="#42510138">parent</a><span>|</span><a href="#42512806">next</a><span>|</span><label class="collapse" for="c-42510781">[-]</label><label class="expand" for="c-42510781">[1 more]</label></div><br/><div class="children"><div class="content">As long as you understand that a monad is a monad, you should be fine!</div><br/></div></div></div></div><div id="42512806" class="c"><input type="checkbox" id="c-42512806" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#42509868">parent</a><span>|</span><a href="#42510138">prev</a><span>|</span><a href="#42511403">next</a><span>|</span><label class="collapse" for="c-42512806">[-]</label><label class="expand" for="c-42512806">[2 more]</label></div><br/><div class="children"><div class="content">Lean has very little support for proving things about software. Right now, the community is mainly geared towards mathematics. This could change. <i>Concrete Semantics</i> was rewritten in Lean [1], but I haven&#x27;t seen more efforts geared towards software in the Lean community.<p>Dafny, Isabelle, Why3, Coq and F* have been used to verify non-trivial software artifacts. Liquid Haskell, Agda and others are also interesting, but less mature.<p>[1] <a href="https:&#x2F;&#x2F;browncs1951x.github.io&#x2F;static&#x2F;files&#x2F;hitchhikersguide.pdf" rel="nofollow">https:&#x2F;&#x2F;browncs1951x.github.io&#x2F;static&#x2F;files&#x2F;hitchhikersguide...</a></div><br/><div id="42513919" class="c"><input type="checkbox" id="c-42513919" checked=""/><div class="controls bullet"><span class="by">TypingOutBugs</span><span>|</span><a href="#42509868">root</a><span>|</span><a href="#42512806">parent</a><span>|</span><a href="#42511403">next</a><span>|</span><label class="collapse" for="c-42513919">[-]</label><label class="expand" for="c-42513919">[1 more]</label></div><br/><div class="children"><div class="content">Agda and Liquid Haskell are used for Cardano, one of the largest blockchain platforms, alongside other tooling in that space. It’s one of the larger formally verified projects in the wild so I’d argue it’s fairly mature.<p>For example their formal specification of their ledger system:<p><a href="https:&#x2F;&#x2F;drops.dagstuhl.de&#x2F;storage&#x2F;01oasics&#x2F;oasics-vol118-fmbc2024&#x2F;OASIcs.FMBC.2024.2&#x2F;OASIcs.FMBC.2024.2.pdf" rel="nofollow">https:&#x2F;&#x2F;drops.dagstuhl.de&#x2F;storage&#x2F;01oasics&#x2F;oasics-vol118-fmb...</a></div><br/></div></div></div></div><div id="42511403" class="c"><input type="checkbox" id="c-42511403" checked=""/><div class="controls bullet"><span class="by">jey</span><span>|</span><a href="#42509868">parent</a><span>|</span><a href="#42512806">prev</a><span>|</span><a href="#42510864">next</a><span>|</span><label class="collapse" for="c-42511403">[-]</label><label class="expand" for="c-42511403">[1 more]</label></div><br/><div class="children"><div class="content">&gt; F* is oriented toward verified, effectful functional programming for real-world software, while Lean is geared toward interactive theorem proving and formalizing mathematical theories, though both support dependent types and can serve as general-purpose functional languages in principle.</div><br/></div></div><div id="42510864" class="c"><input type="checkbox" id="c-42510864" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42509868">parent</a><span>|</span><a href="#42511403">prev</a><span>|</span><a href="#42510011">next</a><span>|</span><label class="collapse" for="c-42510864">[-]</label><label class="expand" for="c-42510864">[1 more]</label></div><br/><div class="children"><div class="content">Lean also started at MSR, and nowadays is bootstraped, they use different approaches.</div><br/></div></div><div id="42510011" class="c"><input type="checkbox" id="c-42510011" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42509868">parent</a><span>|</span><a href="#42510864">prev</a><span>|</span><a href="#42510330">next</a><span>|</span><label class="collapse" for="c-42510011">[-]</label><label class="expand" for="c-42510011">[1 more]</label></div><br/><div class="children"><div class="content">Looking at publications on the home pages for both projects it seems F* results in more practical stuff like hardened cryptography and memory allocation libraries, while Lean presents itself as more of an experiment in developing proof assistants.</div><br/></div></div></div></div><div id="42510330" class="c"><input type="checkbox" id="c-42510330" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42509868">prev</a><span>|</span><a href="#42511491">next</a><span>|</span><label class="collapse" for="c-42510330">[-]</label><label class="expand" for="c-42510330">[1 more]</label></div><br/><div class="children"><div class="content">I tried to learn F* but honestly it was quite confusing with all the different sub-languages and variants.</div><br/></div></div><div id="42511491" class="c"><input type="checkbox" id="c-42511491" checked=""/><div class="controls bullet"><span class="by">tdiff</span><span>|</span><a href="#42510330">prev</a><span>|</span><a href="#42510036">next</a><span>|</span><label class="collapse" for="c-42511491">[-]</label><label class="expand" for="c-42511491">[3 more]</label></div><br/><div class="children"><div class="content">I believe future of programming would vaguely be some mix of intelligent code generation (e.g. LLMs) + formal verification. &quot;LLMs&quot; would be the compiler of the future, something like gcc today, converting &quot;human&quot; language into machine code.</div><br/><div id="42513737" class="c"><input type="checkbox" id="c-42513737" checked=""/><div class="controls bullet"><span class="by">GoblinSlayer</span><span>|</span><a href="#42511491">parent</a><span>|</span><a href="#42510036">next</a><span>|</span><label class="collapse" for="c-42513737">[-]</label><label class="expand" for="c-42513737">[2 more]</label></div><br/><div class="children"><div class="content">I wonder why AI doesn&#x27;t do this verification already. It&#x27;s a sufficiently simple routine task that doesn&#x27;t require great precision.</div><br/><div id="42513892" class="c"><input type="checkbox" id="c-42513892" checked=""/><div class="controls bullet"><span class="by">IceDane</span><span>|</span><a href="#42511491">root</a><span>|</span><a href="#42513737">parent</a><span>|</span><a href="#42510036">next</a><span>|</span><label class="collapse" for="c-42513892">[-]</label><label class="expand" for="c-42513892">[1 more]</label></div><br/><div class="children"><div class="content">Formal verification of arbitrary code is a &quot;simple, routine task&quot;?</div><br/></div></div></div></div></div></div><div id="42510036" class="c"><input type="checkbox" id="c-42510036" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#42511491">prev</a><span>|</span><a href="#42512486">next</a><span>|</span><label class="collapse" for="c-42510036">[-]</label><label class="expand" for="c-42510036">[8 more]</label></div><br/><div class="children"><div class="content">I wonder if it&#x27;s a good idea to pick a name that&#x27;s hard to search for...</div><br/><div id="42510340" class="c"><input type="checkbox" id="c-42510340" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#42510036">parent</a><span>|</span><a href="#42510413">next</a><span>|</span><label class="collapse" for="c-42510340">[-]</label><label class="expand" for="c-42510340">[2 more]</label></div><br/><div class="children"><div class="content">For a language that touts its practicalities, the name isn&#x27;t a great start.  Although F*lang or F***lang (maybe Foq?) seem like reasonable search proxies.</div><br/><div id="42510359" class="c"><input type="checkbox" id="c-42510359" checked=""/><div class="controls bullet"><span class="by">markusde</span><span>|</span><a href="#42510036">root</a><span>|</span><a href="#42510340">parent</a><span>|</span><a href="#42510413">next</a><span>|</span><label class="collapse" for="c-42510359">[-]</label><label class="expand" for="c-42510359">[1 more]</label></div><br/><div class="children"><div class="content">Foq is hilarious, especially given that just today Coq released its website with its new name (Rocq)</div><br/></div></div></div></div><div id="42510413" class="c"><input type="checkbox" id="c-42510413" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#42510036">parent</a><span>|</span><a href="#42510340">prev</a><span>|</span><a href="#42511242">next</a><span>|</span><label class="collapse" for="c-42510413">[-]</label><label class="expand" for="c-42510413">[3 more]</label></div><br/><div class="children"><div class="content">Is it really that much harder to search for than &quot;C&quot;, &quot;C++&quot;, &quot;C#&quot;, &quot;F#&quot;, &quot;Go&quot;, &quot;Rust&quot;, &quot;D&quot;...?<p>Googling &quot;Fstar programming language&quot; works fine for me.</div><br/><div id="42512261" class="c"><input type="checkbox" id="c-42512261" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#42510036">root</a><span>|</span><a href="#42510413">parent</a><span>|</span><a href="#42510508">next</a><span>|</span><label class="collapse" for="c-42512261">[-]</label><label class="expand" for="c-42512261">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t say those are more inspired. At least Rust is long enough to not get ignored by the search engines. And some of the older ones have being older than the internet as an excuse.</div><br/></div></div><div id="42510508" class="c"><input type="checkbox" id="c-42510508" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42510036">root</a><span>|</span><a href="#42510413">parent</a><span>|</span><a href="#42512261">prev</a><span>|</span><a href="#42511242">next</a><span>|</span><label class="collapse" for="c-42510508">[-]</label><label class="expand" for="c-42510508">[1 more]</label></div><br/><div class="children"><div class="content">&quot;.NET&quot;</div><br/></div></div></div></div><div id="42511242" class="c"><input type="checkbox" id="c-42511242" checked=""/><div class="controls bullet"><span class="by">fosefx</span><span>|</span><a href="#42510036">parent</a><span>|</span><a href="#42510413">prev</a><span>|</span><a href="#42510298">next</a><span>|</span><label class="collapse" for="c-42511242">[-]</label><label class="expand" for="c-42511242">[1 more]</label></div><br/><div class="children"><div class="content">Just like with &quot;golang&quot;, &quot;FStar&quot; is the query if choice. But don&#x27;t think you&#x27;ll find much, if the documentation is in the same state as it was two years ago.</div><br/></div></div><div id="42510298" class="c"><input type="checkbox" id="c-42510298" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42510036">parent</a><span>|</span><a href="#42511242">prev</a><span>|</span><a href="#42512486">next</a><span>|</span><label class="collapse" for="c-42510298">[-]</label><label class="expand" for="c-42510298">[1 more]</label></div><br/><div class="children"><div class="content">...and that looks like someone is swearing.</div><br/></div></div></div></div><div id="42512486" class="c"><input type="checkbox" id="c-42512486" checked=""/><div class="controls bullet"><span class="by">aranchelk</span><span>|</span><a href="#42510036">prev</a><span>|</span><a href="#42510512">next</a><span>|</span><label class="collapse" for="c-42512486">[-]</label><label class="expand" for="c-42512486">[1 more]</label></div><br/><div class="children"><div class="content">Anyone coming from a Haskell background, there’s some interesting (though possibly dated) info here:<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;76k1x0&#x2F;what_do_you_guys_think_of_f_fstar&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;76k1x0&#x2F;what_do_you...</a></div><br/></div></div><div id="42510512" class="c"><input type="checkbox" id="c-42510512" checked=""/><div class="controls bullet"><span class="by">kittikitti</span><span>|</span><a href="#42512486">prev</a><span>|</span><a href="#42509976">next</a><span>|</span><label class="collapse" for="c-42510512">[-]</label><label class="expand" for="c-42510512">[7 more]</label></div><br/><div class="children"><div class="content">This is great and could provide additional guardrails on top of large language models. I imagine we could provide a more rigorous approach to prove that a LLM can behave in certain ways within a workflow.</div><br/><div id="42513960" class="c"><input type="checkbox" id="c-42513960" checked=""/><div class="controls bullet"><span class="by">TypingOutBugs</span><span>|</span><a href="#42510512">parent</a><span>|</span><a href="#42510775">next</a><span>|</span><label class="collapse" for="c-42513960">[-]</label><label class="expand" for="c-42513960">[1 more]</label></div><br/><div class="children"><div class="content">There’s a few papers in this space but it’s still early days, both using Formal Verification to test outputs of LLMs and using LLMs in formal verification itself<p>Examples of both:<p><a href="https:&#x2F;&#x2F;sumitkumarjha.com&#x2F;papers&#x2F;2023_ICAA_LLM_Dehallucinating_Jha.pdf" rel="nofollow">https:&#x2F;&#x2F;sumitkumarjha.com&#x2F;papers&#x2F;2023_ICAA_LLM_Dehallucinati...</a><p><a href="https:&#x2F;&#x2F;mathai2023.github.io&#x2F;papers&#x2F;28.pdf" rel="nofollow">https:&#x2F;&#x2F;mathai2023.github.io&#x2F;papers&#x2F;28.pdf</a></div><br/></div></div><div id="42510775" class="c"><input type="checkbox" id="c-42510775" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#42510512">parent</a><span>|</span><a href="#42513960">prev</a><span>|</span><a href="#42513896">next</a><span>|</span><label class="collapse" for="c-42510775">[-]</label><label class="expand" for="c-42510775">[1 more]</label></div><br/><div class="children"><div class="content">LLMs are fundamentally probabilistic in nature; I think you could prove things about distributions of outputs but nothing like the kind of formal verification you can create with Lean or Rust.</div><br/></div></div><div id="42513896" class="c"><input type="checkbox" id="c-42513896" checked=""/><div class="controls bullet"><span class="by">IceDane</span><span>|</span><a href="#42510512">parent</a><span>|</span><a href="#42510775">prev</a><span>|</span><a href="#42511838">next</a><span>|</span><label class="collapse" for="c-42513896">[-]</label><label class="expand" for="c-42513896">[1 more]</label></div><br/><div class="children"><div class="content">You are really comparing apples to oranges here, and to say that trying to apply formal verification to a probabilistic lying machine is silly would be a colossal understatement.</div><br/></div></div><div id="42511838" class="c"><input type="checkbox" id="c-42511838" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#42510512">parent</a><span>|</span><a href="#42513896">prev</a><span>|</span><a href="#42510988">next</a><span>|</span><label class="collapse" for="c-42511838">[-]</label><label class="expand" for="c-42511838">[1 more]</label></div><br/><div class="children"><div class="content">An LLM is pretty much a black box. You can’t prove anything meaningful about its output.</div><br/></div></div><div id="42510988" class="c"><input type="checkbox" id="c-42510988" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#42510512">parent</a><span>|</span><a href="#42511838">prev</a><span>|</span><a href="#42509976">next</a><span>|</span><label class="collapse" for="c-42510988">[-]</label><label class="expand" for="c-42510988">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it a fundamental limitation of LLMs that we can&#x27;t?</div><br/><div id="42511202" class="c"><input type="checkbox" id="c-42511202" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#42510512">root</a><span>|</span><a href="#42510988">parent</a><span>|</span><a href="#42509976">next</a><span>|</span><label class="collapse" for="c-42511202">[-]</label><label class="expand" for="c-42511202">[1 more]</label></div><br/><div class="children"><div class="content">Obviously not. It&#x27;s right in the name, isn&#x27;t it? LLM = limitless model...</div><br/></div></div></div></div></div></div><div id="42509976" class="c"><input type="checkbox" id="c-42509976" checked=""/><div class="controls bullet"><span class="by">vb-8448</span><span>|</span><a href="#42510512">prev</a><span>|</span><a href="#42510310">next</a><span>|</span><label class="collapse" for="c-42509976">[-]</label><label class="expand" for="c-42509976">[7 more]</label></div><br/><div class="children"><div class="content">I wonder if the proliferation of programming languages we saw in the last decade is due to the fact that nowadays it&#x27;s extremely easy to create one or that existing ones sucks?</div><br/><div id="42510161" class="c"><input type="checkbox" id="c-42510161" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#42509976">parent</a><span>|</span><a href="#42510057">next</a><span>|</span><label class="collapse" for="c-42510161">[-]</label><label class="expand" for="c-42510161">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s because (a) it&#x27;s become a lot easier to create languages and (b) we&#x27;re stuck.<p>I am hoping (a) is straightforward.  For (b), I think most of us sense at least intuitively, with different strengths, that our current crop of programming languages are not really good enough.  Too low-level, too difficult to get to a more compact and meaningful representation.<p>LLMs have kinda demonstrated the source for this feeling of unease, by generating quite a bit of code from fairly short natural language instructions.  The information density of that generated code can&#x27;t really be all that high, can it now?<p>So we have this issue with expressiveness, but we lack the insight required to make substantial progress.  So we bounce around along the well-trodden paths of language design, hoping for progress that refuses to materialize.</div><br/><div id="42510284" class="c"><input type="checkbox" id="c-42510284" checked=""/><div class="controls bullet"><span class="by">TypingOutBugs</span><span>|</span><a href="#42509976">root</a><span>|</span><a href="#42510161">parent</a><span>|</span><a href="#42510057">next</a><span>|</span><label class="collapse" for="c-42510284">[-]</label><label class="expand" for="c-42510284">[2 more]</label></div><br/><div class="children"><div class="content">F* is a research project thats almost 15 years old! Its not part of the recent wave of languages</div><br/><div id="42513810" class="c"><input type="checkbox" id="c-42513810" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#42509976">root</a><span>|</span><a href="#42510284">parent</a><span>|</span><a href="#42510057">next</a><span>|</span><label class="collapse" for="c-42513810">[-]</label><label class="expand" for="c-42513810">[1 more]</label></div><br/><div class="children"><div class="content">Cool!<p>Though I&#x27;d say we&#x27;ve been stuck since about the 80s.</div><br/></div></div></div></div></div></div><div id="42510057" class="c"><input type="checkbox" id="c-42510057" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#42509976">parent</a><span>|</span><a href="#42510161">prev</a><span>|</span><a href="#42512628">next</a><span>|</span><label class="collapse" for="c-42510057">[-]</label><label class="expand" for="c-42510057">[1 more]</label></div><br/><div class="children"><div class="content">F* is older than a decade. Also it&#x27;s a research project, so quite different than the random &quot;memory safe&quot; language iteration of the day.</div><br/></div></div><div id="42512628" class="c"><input type="checkbox" id="c-42512628" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#42509976">parent</a><span>|</span><a href="#42510057">prev</a><span>|</span><a href="#42511175">next</a><span>|</span><label class="collapse" for="c-42512628">[-]</label><label class="expand" for="c-42512628">[1 more]</label></div><br/><div class="children"><div class="content">Neither. It’s always been easy to create a language. What’s been hard is promoting that language.<p>The things that’s changed is that these days you have a combination of more people using computers plus more convenient forums (like this) for people to promote their new language.</div><br/></div></div><div id="42511175" class="c"><input type="checkbox" id="c-42511175" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42509976">parent</a><span>|</span><a href="#42512628">prev</a><span>|</span><a href="#42510310">next</a><span>|</span><label class="collapse" for="c-42511175">[-]</label><label class="expand" for="c-42511175">[1 more]</label></div><br/><div class="children"><div class="content">Is there really a proliferation of PLs that hasn&#x27;t been the case before? I recall many new languages back in 00s as well, it&#x27;s just that most of them didn&#x27;t live long enough for people to remember them now.</div><br/></div></div></div></div><div id="42510310" class="c"><input type="checkbox" id="c-42510310" checked=""/><div class="controls bullet"><span class="by">madihaa</span><span>|</span><a href="#42509976">prev</a><span>|</span><a href="#42510722">next</a><span>|</span><label class="collapse" for="c-42510310">[-]</label><label class="expand" for="c-42510310">[1 more]</label></div><br/><div class="children"><div class="content">(old discussion) 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40377685">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40377685</a></div><br/></div></div><div id="42510722" class="c"><input type="checkbox" id="c-42510722" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#42510310">prev</a><span>|</span><label class="collapse" for="c-42510722">[-]</label><label class="expand" for="c-42510722">[3 more]</label></div><br/><div class="children"><div class="content">Never used it, but <a href="https:&#x2F;&#x2F;github.com&#x2F;project-everest&#x2F;mitls-fstar">https:&#x2F;&#x2F;github.com&#x2F;project-everest&#x2F;mitls-fstar</a> always seems an incredibly cool thing. Huh, apparently there&#x27;s a successor to F* called F7 (<a href="https:&#x2F;&#x2F;github.com&#x2F;mitls&#x2F;mitls-flex">https:&#x2F;&#x2F;github.com&#x2F;mitls&#x2F;mitls-flex</a>) ?</div><br/><div id="42512673" class="c"><input type="checkbox" id="c-42512673" checked=""/><div class="controls bullet"><span class="by">mlinksva</span><span>|</span><a href="#42510722">parent</a><span>|</span><a href="#42512884">next</a><span>|</span><label class="collapse" for="c-42512673">[-]</label><label class="expand" for="c-42512673">[1 more]</label></div><br/><div class="children"><div class="content">Looks like it&#x27;s a predecessor <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;project&#x2F;f7-refinement-types-for-f&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;project&#x2F;f7-refineme...</a></div><br/></div></div><div id="42512884" class="c"><input type="checkbox" id="c-42512884" checked=""/><div class="controls bullet"><span class="by">Taikonerd</span><span>|</span><a href="#42510722">parent</a><span>|</span><a href="#42512673">prev</a><span>|</span><label class="collapse" for="c-42512884">[-]</label><label class="expand" for="c-42512884">[1 more]</label></div><br/><div class="children"><div class="content">Is Project Everest still going?  The GitHub link says that the repo has been archived...</div><br/></div></div></div></div></div></div></div></div></div></body></html>