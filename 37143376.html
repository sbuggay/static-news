<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692349258435" as="style"/><link rel="stylesheet" href="styles.css?v=1692349258435"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://betterprogramming.pub/load-balancing-the-intuition-behind-the-power-of-two-random-choices-6de2e139ac2f">Load Balancing: The Intuition Behind the Power of Two Random Choices</a> <span class="domain">(<a href="https://betterprogramming.pub">betterprogramming.pub</a>)</span></div><div class="subtext"><span>fagnerbrack</span> | <span>11 comments</span></div><br/><div><div id="37171993" class="c"><input type="checkbox" id="c-37171993" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#37172979">next</a><span>|</span><label class="collapse" for="c-37171993">[-]</label><label class="expand" for="c-37171993">[3 more]</label></div><br/><div class="children"><div class="content">Maybe I misunderstood something, I admit I glossed over parts of the article, but the explanations seemed a bit over-complicated.<p>In the balls and bucket scenario, ideally you&#x27;d want to scan all the buckets and put the ball in the least filled one.<p>By picking two random buckets and putting the ball in the least filled of the two, you approximate the ideal algorithm.<p>The chance of picking two relatively filled buckets is inversely proportional to how &quot;bad&quot; it is. If there are just two buckets which have more balls than the others then it&#x27;s relatively bad to pick those two, but chances are low. And vice versa.<p>Still, hadn&#x27;t thought about this before, interesting trick indeed!</div><br/><div id="37172958" class="c"><input type="checkbox" id="c-37172958" checked=""/><div class="controls bullet"><span class="by">movpasd</span><span>|</span><a href="#37171993">parent</a><span>|</span><a href="#37172209">next</a><span>|</span><label class="collapse" for="c-37172958">[-]</label><label class="expand" for="c-37172958">[1 more]</label></div><br/><div class="children"><div class="content">I think it comes down to complexity. Scanning is O(N) where N is the number of buckets, two random choices is O(1) (if bucket lookup is O(1), e.g. a hash map).</div><br/></div></div><div id="37172209" class="c"><input type="checkbox" id="c-37172209" checked=""/><div class="controls bullet"><span class="by">potamic</span><span>|</span><a href="#37171993">parent</a><span>|</span><a href="#37172958">prev</a><span>|</span><a href="#37172979">next</a><span>|</span><label class="collapse" for="c-37172209">[-]</label><label class="expand" for="c-37172209">[1 more]</label></div><br/><div class="children"><div class="content">They talked about doing this for AWS lambda at &quot;gigantic scale&quot;. I assume at some point scanning all the buckets becomes infeasible.</div><br/></div></div></div></div><div id="37172979" class="c"><input type="checkbox" id="c-37172979" checked=""/><div class="controls bullet"><span class="by">trabant00</span><span>|</span><a href="#37171993">prev</a><span>|</span><a href="#37171601">next</a><span>|</span><label class="collapse" for="c-37172979">[-]</label><label class="expand" for="c-37172979">[1 more]</label></div><br/><div class="children"><div class="content">I do not understand why they chose random assignment as a base line instead of round robin which is really the simplest common load balancing algorithm.</div><br/></div></div><div id="37171601" class="c"><input type="checkbox" id="c-37171601" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37172979">prev</a><span>|</span><a href="#37171946">next</a><span>|</span><label class="collapse" for="c-37171601">[-]</label><label class="expand" for="c-37171601">[1 more]</label></div><br/><div class="children"><div class="content">This is excellent! A prime example of what real engineering work can look like in the field of “software engineering”. I wish we saw more posts sharing this kind of knowledge.</div><br/></div></div><div id="37171946" class="c"><input type="checkbox" id="c-37171946" checked=""/><div class="controls bullet"><span class="by">digaozao</span><span>|</span><a href="#37171601">prev</a><span>|</span><a href="#37172110">next</a><span>|</span><label class="collapse" for="c-37171946">[-]</label><label class="expand" for="c-37171946">[4 more]</label></div><br/><div class="children"><div class="content">I liked the approach. I did not know it.
But what are the advantages against taking the least occupied server&#x2F;bin always? 
I have seen good improvements with nginx load balancing when changing its configuration to least_conn, that chooses the server with least connections.</div><br/><div id="37172007" class="c"><input type="checkbox" id="c-37172007" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#37171946">parent</a><span>|</span><a href="#37171999">next</a><span>|</span><label class="collapse" for="c-37172007">[-]</label><label class="expand" for="c-37172007">[1 more]</label></div><br/><div class="children"><div class="content">Not my field but I&#x27;m guessing when you have thousands of servers it can be quite the overhead to keeping track of the load of each one for each request.<p>The proposed algorithm only needs to consider two, and from what I can gather should work in parallel with multiple load balancers without coordination.</div><br/></div></div><div id="37171999" class="c"><input type="checkbox" id="c-37171999" checked=""/><div class="controls bullet"><span class="by">dtjohnnymonkey</span><span>|</span><a href="#37171946">parent</a><span>|</span><a href="#37172007">prev</a><span>|</span><a href="#37172131">next</a><span>|</span><label class="collapse" for="c-37171999">[-]</label><label class="expand" for="c-37171999">[1 more]</label></div><br/><div class="children"><div class="content">It’s more costly to determine the server with absolute least connections since you have to keep track of the ordering of the servers by how many connections they have.</div><br/></div></div><div id="37172131" class="c"><input type="checkbox" id="c-37172131" checked=""/><div class="controls bullet"><span class="by">andromeduck</span><span>|</span><a href="#37171946">parent</a><span>|</span><a href="#37171999">prev</a><span>|</span><a href="#37172110">next</a><span>|</span><label class="collapse" for="c-37172131">[-]</label><label class="expand" for="c-37172131">[1 more]</label></div><br/><div class="children"><div class="content">O(log n) vs O(1)</div><br/></div></div></div></div><div id="37172110" class="c"><input type="checkbox" id="c-37172110" checked=""/><div class="controls bullet"><span class="by">andromeduck</span><span>|</span><a href="#37171946">prev</a><span>|</span><label class="collapse" for="c-37172110">[-]</label><label class="expand" for="c-37172110">[1 more]</label></div><br/><div class="children"><div class="content">Easier to think of it as a form of cuckoo hashing.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Cuckoo_hashing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Cuckoo_hashing</a></div><br/></div></div></div></div></div></div></div></body></html>