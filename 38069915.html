<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698742865399" as="style"/><link rel="stylesheet" href="styles.css?v=1698742865399"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://robertovitillo.com/costs-of-microservices/">The costs of microservices (2020)</a> <span class="domain">(<a href="https://robertovitillo.com">robertovitillo.com</a>)</span></div><div class="subtext"><span>kiyanwang</span> | <span>307 comments</span></div><br/><div><div id="38070396" class="c"><input type="checkbox" id="c-38070396" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#38070122">next</a><span>|</span><label class="collapse" for="c-38070396">[-]</label><label class="expand" for="c-38070396">[44 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t disagree with the article, but to play Devil&#x27;s Advocate, here are some examples of when IME the cost IS worth it:<p>1) there are old 3rd party dependency incompatibilities that you can spin off and let live separately instead of doing a painful refactor, rebuilding in house, or kludgy gluing<p>2) there are deploy limitations on mission critical high available systems that should not hold up other systems deployment that have different priorities&#x2F;sensitive business hours time windows<p>3) system design decisions that cannot be abstracted away are at the mercy of some large clients of the company that are unable or unwilling to change their way of doing things - you can silo the pain.<p>And to be clear, it&#x27;s not that these things are &quot;cost free&quot;. It&#x27;s just a cost that is worth paying to protect the simpler monolith from becoming crap encrusted, disrupted with risky deploys, or constrained by business partners with worse tech stacks.</div><br/><div id="38071156" class="c"><input type="checkbox" id="c-38071156" checked=""/><div class="controls bullet"><span class="by">eduction</span><span>|</span><a href="#38070396">parent</a><span>|</span><a href="#38072139">next</a><span>|</span><label class="collapse" for="c-38071156">[-]</label><label class="expand" for="c-38071156">[23 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t this just be &quot;having one or two services&quot;? I don&#x27;t think that&#x27;s the same as &quot;microservices&quot;.<p>Correct me if I&#x27;m wrong, but isn&#x27;t &quot;microservices&quot; when you make internal components into services <i>by default</i>, instead of defaulting to making a library or class?</div><br/><div id="38080441" class="c"><input type="checkbox" id="c-38080441" checked=""/><div class="controls bullet"><span class="by">shados</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071156">parent</a><span>|</span><a href="#38071954">next</a><span>|</span><label class="collapse" for="c-38080441">[-]</label><label class="expand" for="c-38080441">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a pretty common issue. If you have 2-3 services, it&#x27;s pretty easy to manage. And if you have 1000, you likely have the infra to manage them and get the full benefit.<p>But if you have 20 engineers and 60 services, you&#x27;re likely in a world of pain. That&#x27;s not microservices, it&#x27;s distributed monolith and it&#x27;s the one model that doesn&#x27;t work (but everyone seems to do)</div><br/><div id="38081938" class="c"><input type="checkbox" id="c-38081938" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38080441">parent</a><span>|</span><a href="#38081704">next</a><span>|</span><label class="collapse" for="c-38081938">[-]</label><label class="expand" for="c-38081938">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; That&#x27;s not microservices, it&#x27;s distributed monolith and it&#x27;s the one model that doesn&#x27;t work (but everyone seems to do)<p>I called ours a macrolith.</div><br/></div></div><div id="38081704" class="c"><input type="checkbox" id="c-38081704" checked=""/><div class="controls bullet"><span class="by">jabradoodle</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38080441">parent</a><span>|</span><a href="#38081938">prev</a><span>|</span><a href="#38080578">next</a><span>|</span><label class="collapse" for="c-38081704">[-]</label><label class="expand" for="c-38081704">[1 more]</label></div><br/><div class="children"><div class="content">A distributed monolith isn&#x27;t based on how many services you have, a better question is, how many services do you need to redeploy&#x2F;update to make a change.<p>Yes, by the time you get to thousands of services you hopefully have moved past the distributed monololith, if you built one.</div><br/></div></div><div id="38080578" class="c"><input type="checkbox" id="c-38080578" checked=""/><div class="controls bullet"><span class="by">alrs</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38080441">parent</a><span>|</span><a href="#38081704">prev</a><span>|</span><a href="#38080917">next</a><span>|</span><label class="collapse" for="c-38080578">[-]</label><label class="expand" for="c-38080578">[1 more]</label></div><br/><div class="children"><div class="content">A &quot;microservice&quot; solves scaling issues for huge companies. If you have 60 microservices, you should probably have 600 engineers (10 per) to deal with them. If you&#x27;re completely underwater and have 10 services per engineer, you&#x27;re 100% absolutely play-acting &quot;web-scale&quot; for an audience of <i>really</i> dumb managers&#x2F;investors.</div><br/></div></div><div id="38080917" class="c"><input type="checkbox" id="c-38080917" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38080441">parent</a><span>|</span><a href="#38080578">prev</a><span>|</span><a href="#38071954">next</a><span>|</span><label class="collapse" for="c-38080917">[-]</label><label class="expand" for="c-38080917">[2 more]</label></div><br/><div class="children"><div class="content">It depends on how you do it. We have 5 engineers and around 50 services and it’s much easier for us to maintain that than it was when it was monolith with a couple of services on top.<p>Though to understand why this is, you would have to know just how poorly our monolith was designed. That’s sometimes the issue with monoliths though, they allow you to “cut corners” and suddenly you end up with this huge spiderweb mess of a database that nobody knows who pulls what from because everyone has connected some sort of thing to it and now your monolith isn’t really a monolith because of it. Which isn’t how a monolith is supposed to work, but is somehow always how it ends up working anyway.<p>I do agree though, that the “DevOps” space for “medium-non-software-development” IT departments in larger companies is just terrible. We ended up outsourcing it, sort of, so that our regular IT operations partner (the ones which also help with networking, storage, backups, security and so on) also handle the management part of our managed Kubernetes cluster. So that once something leaves the build pipeline, it’s theirs. Which was surprisingly cheap by the way.<p>I do get where you’re coming from of course. If we had wanted to do it ourselves, we’d likely need to write “infrastructure as code” that was twice the size of the actual services we deploy.</div><br/><div id="38081746" class="c"><input type="checkbox" id="c-38081746" checked=""/><div class="controls bullet"><span class="by">jabradoodle</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38080917">parent</a><span>|</span><a href="#38071954">next</a><span>|</span><label class="collapse" for="c-38081746">[-]</label><label class="expand" for="c-38081746">[1 more]</label></div><br/><div class="children"><div class="content">&gt; designed. That’s sometimes the issue with monoliths though, they allow you to “cut corners”<p>I find this hard to relate to, the idea you have the discipline and culture to do microservices well if you can&#x27;t do it with a monolith.<p>More likely is you migrate away from the monolith you never invested in fixing, and once you get to microservices you either call it a mistake and migrate back, or you have to eventually finally invest in fixing things.<p>Perhaps your microservice rewrite goes well because you now know your domain after building the monolith, that is another option.</div><br/></div></div></div></div></div></div><div id="38071954" class="c"><input type="checkbox" id="c-38071954" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071156">parent</a><span>|</span><a href="#38080441">prev</a><span>|</span><a href="#38072626">next</a><span>|</span><label class="collapse" for="c-38071954">[-]</label><label class="expand" for="c-38071954">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to get too tied up in the terminology, but &quot;microservices-first&quot; does not seem to be the problem the post is describing:<p><i>One way to mitigate the growing pains of a monolithic backend is to split it into a set of independently deployable services that communicate via APIs. The APIs decouple the services from each other by creating boundaries that are hard to violate, unlike the ones between components running in the same process</i></div><br/><div id="38072209" class="c"><input type="checkbox" id="c-38072209" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071954">parent</a><span>|</span><a href="#38072626">next</a><span>|</span><label class="collapse" for="c-38072209">[-]</label><label class="expand" for="c-38072209">[6 more]</label></div><br/><div class="children"><div class="content">Without getting tied up in the whole &quot;every language except assembly, Python and possibly JavaScript already solved this problem by forcing people to adhere to module-level APIs&quot; argument, I think the crux of the issue is that the article just defines microservice architecture as any architecture consisting of multiple services, and explicitly states &quot;there doesn’t have to be anything micro about the services&quot;. Which imho is watering down the term microservices too much. You don&#x27;t have microservices as soon as you add a second or third service.</div><br/><div id="38073059" class="c"><input type="checkbox" id="c-38073059" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38072209">parent</a><span>|</span><a href="#38072626">next</a><span>|</span><label class="collapse" for="c-38073059">[-]</label><label class="expand" for="c-38073059">[5 more]</label></div><br/><div class="children"><div class="content">I think we should start calling this Pendulum Blindness.<p>We just go from &#x27;one&#x27; to &#x27;too many&#x27; as equally unworkable solutions to all of our problems, and each side (and each person currently subscribed to that &#x27;side&#x27;) knows the other side is wrong. The assumption is that this means their side is right instead of reality, which is nobody is right.<p>The moderates are right, but their answers are wiggly and they&#x27;re too busy getting stuff done to argue with the purists. But the optics are bad so here we go again on another swing of the swingset.<p>&#x27;Some Services&#x27; is probably right, but it varies with domain, company size, and company structure (Conway&#x27;s Law). And honestly developer maturity, so while 7 may be right for me and my peers today, in a year it might be 6, or 9. There&#x27;s no clever soundbite to parrot.</div><br/><div id="38079046" class="c"><input type="checkbox" id="c-38079046" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38073059">parent</a><span>|</span><a href="#38078993">next</a><span>|</span><label class="collapse" for="c-38079046">[-]</label><label class="expand" for="c-38079046">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s no clever soundbite to parrot.<p>Introducing the Revolutionary &quot;Ten Service Applications&quot; – because Ten is the Magic Number!<p>Tired of the endless debates about how many services your applications should have? Frustrated with the constant struggle to find the &quot;Goldilocks&quot; number of services? Look no further! The future of software design is here, and it&#x27;s as easy as 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10!<p>The &quot;Ten Service Applications&quot; model is here to rescue you from your software design woes. We&#x27;re not messing around with random numbers like 7 or 12 services. No, we&#x27;ve cracked the code, and it&#x27;s all about that perfect &quot;ten.&quot; You don&#x27;t need any more services, and you definitely don&#x27;t need any less. Ten is the answer to all your architectural problems!<p>So, are you ready to embrace the simplicity, predictability, and coolness of the &quot;Ten Service Applications&quot; model? Join the revolution today and experience software development like never before!<p>Act now, and we&#x27;ll even throw in a bonus &quot;Top 10 Services&quot; list to inspire your next project. But remember, you only get 10 services, no more, no less—because why mess with perfection?</div><br/><div id="38080271" class="c"><input type="checkbox" id="c-38080271" checked=""/><div class="controls bullet"><span class="by">porridgeraisin</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38079046">parent</a><span>|</span><a href="#38078993">next</a><span>|</span><label class="collapse" for="c-38080271">[-]</label><label class="expand" for="c-38080271">[1 more]</label></div><br/><div class="children"><div class="content">You have for sure worked in sales before, amazing write-up</div><br/></div></div></div></div><div id="38078993" class="c"><input type="checkbox" id="c-38078993" checked=""/><div class="controls bullet"><span class="by">akrotkov</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38073059">parent</a><span>|</span><a href="#38079046">prev</a><span>|</span><a href="#38079781">next</a><span>|</span><label class="collapse" for="c-38078993">[-]</label><label class="expand" for="c-38078993">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been looking for a concise soundbite (ironically) for this exact issue and Pendulum Blindness definitely fits what I&#x27;ve been trying to summarize.<p>Going to definitely yoink it for next time I have this discussion. It applies to so many things!</div><br/></div></div><div id="38079781" class="c"><input type="checkbox" id="c-38079781" checked=""/><div class="controls bullet"><span class="by">caller9</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38073059">parent</a><span>|</span><a href="#38078993">prev</a><span>|</span><a href="#38072626">next</a><span>|</span><label class="collapse" for="c-38079781">[-]</label><label class="expand" for="c-38079781">[1 more]</label></div><br/><div class="children"><div class="content">You might like &quot;Software Architecture: The Hard Parts.&quot; Though you already describe some of the points of the book. There isn&#x27;t a magic bullet and every decision to split something apart or which parts to combine has various trade-offs.<p>The book isn&#x27;t perfect. The use of afferent and efferent terminology and some of the arbitrary methods to put numbers on decisions weren&#x27;t ideal. Most of the concepts are sound. The fact that almost every decision has cost&#x2F;benefit and real world implications for a living product was refreshing. That a monolith can&#x27;t be cut over instantly with zero effort to a perfect system is absolutely true.<p>It&#x27;s good food for thought for anyone considering slicing up a monolith, but maybe don&#x27;t follow it to the letter.</div><br/></div></div></div></div></div></div></div></div><div id="38072626" class="c"><input type="checkbox" id="c-38072626" checked=""/><div class="controls bullet"><span class="by">philwelch</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071156">parent</a><span>|</span><a href="#38071954">prev</a><span>|</span><a href="#38071432">next</a><span>|</span><label class="collapse" for="c-38072626">[-]</label><label class="expand" for="c-38072626">[1 more]</label></div><br/><div class="children"><div class="content">This is why I prefer the old term &quot;service oriented architecture&quot; over &quot;microservices&quot;. &quot;Microservices&quot; implies any time a service gets too big, you split it apart and introduce a network dependency even if it introduces more problems than it solves.</div><br/></div></div><div id="38071432" class="c"><input type="checkbox" id="c-38071432" checked=""/><div class="controls bullet"><span class="by">Dudester230602</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071156">parent</a><span>|</span><a href="#38072626">prev</a><span>|</span><a href="#38071650">next</a><span>|</span><label class="collapse" for="c-38071432">[-]</label><label class="expand" for="c-38071432">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, just use well-factored services of any size and smack anyone saying &quot;micro...&quot; with a wet towel for they are just parroting some barely-profitable silicon valley money sinks.</div><br/></div></div><div id="38071650" class="c"><input type="checkbox" id="c-38071650" checked=""/><div class="controls bullet"><span class="by">rmbyrro</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071156">parent</a><span>|</span><a href="#38071432">prev</a><span>|</span><a href="#38072014">next</a><span>|</span><label class="collapse" for="c-38071650">[-]</label><label class="expand" for="c-38071650">[4 more]</label></div><br/><div class="children"><div class="content">Exactly my thoughts</div><br/><div id="38071736" class="c"><input type="checkbox" id="c-38071736" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071650">parent</a><span>|</span><a href="#38072014">next</a><span>|</span><label class="collapse" for="c-38071736">[-]</label><label class="expand" for="c-38071736">[3 more]</label></div><br/><div class="children"><div class="content">Microservices is a newer term than SOA.</div><br/><div id="38073225" class="c"><input type="checkbox" id="c-38073225" checked=""/><div class="controls bullet"><span class="by">PedroBatista</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071736">parent</a><span>|</span><a href="#38072014">next</a><span>|</span><label class="collapse" for="c-38073225">[-]</label><label class="expand" for="c-38073225">[2 more]</label></div><br/><div class="children"><div class="content">They are not the same thing! Microservices is a discount version of SOA with a new coat of paint.</div><br/><div id="38076149" class="c"><input type="checkbox" id="c-38076149" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38073225">parent</a><span>|</span><a href="#38072014">next</a><span>|</span><label class="collapse" for="c-38076149">[-]</label><label class="expand" for="c-38076149">[1 more]</label></div><br/><div class="children"><div class="content">Clearly. But it’s also SOA taken to the extreme!</div><br/></div></div></div></div></div></div></div></div><div id="38072014" class="c"><input type="checkbox" id="c-38072014" checked=""/><div class="controls bullet"><span class="by">gedy</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071156">parent</a><span>|</span><a href="#38071650">prev</a><span>|</span><a href="#38072139">next</a><span>|</span><label class="collapse" for="c-38072014">[-]</label><label class="expand" for="c-38072014">[3 more]</label></div><br/><div class="children"><div class="content">For some reason, most of the people I&#x27;ve worked with recently are either fully into monoliths or lots of fine grained, interdependent microservices.<p>They don&#x27;t seem to understand there&#x27;s a useful middleground of adding fewer, larger data services, etc.  It&#x27;s like SOA isn&#x27;t a hot topic so people aren&#x27;t aware of it.</div><br/><div id="38072173" class="c"><input type="checkbox" id="c-38072173" checked=""/><div class="controls bullet"><span class="by">andorov</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38072014">parent</a><span>|</span><a href="#38072139">next</a><span>|</span><label class="collapse" for="c-38072173">[-]</label><label class="expand" for="c-38072173">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using the term &#x27;macro-services&#x27; to describe this middle ground.</div><br/><div id="38080104" class="c"><input type="checkbox" id="c-38080104" checked=""/><div class="controls bullet"><span class="by">anymouse123456</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38072173">parent</a><span>|</span><a href="#38072139">next</a><span>|</span><label class="collapse" for="c-38080104">[-]</label><label class="expand" for="c-38080104">[1 more]</label></div><br/><div class="children"><div class="content">We used to just call them, &quot;services&quot;</div><br/></div></div></div></div></div></div></div></div><div id="38072139" class="c"><input type="checkbox" id="c-38072139" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#38070396">parent</a><span>|</span><a href="#38071156">prev</a><span>|</span><a href="#38070778">next</a><span>|</span><label class="collapse" for="c-38072139">[-]</label><label class="expand" for="c-38072139">[2 more]</label></div><br/><div class="children"><div class="content">To add another to your list:<p>Being able to easily use different programming languages. Not every language is a good fit for every problem. Being able to write your machine learning deduction services in Python, your server side rendered UI in Rails and your IO and concurrency heavy services in Go might justify the additional overhead of having separate services for these three.</div><br/><div id="38079309" class="c"><input type="checkbox" id="c-38079309" checked=""/><div class="controls bullet"><span class="by">renegade-otter</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38072139">parent</a><span>|</span><a href="#38070778">next</a><span>|</span><label class="collapse" for="c-38079309">[-]</label><label class="expand" for="c-38079309">[1 more]</label></div><br/><div class="children"><div class="content">These are almost never pragmatic decisions. Giving teams independence over the stack usually results in resume-driven development, and now your JS developers are forced to maintain a Go server because some jock thought it was a cool thing to do .<p>Due diligence in these cases is rare.</div><br/></div></div></div></div><div id="38070778" class="c"><input type="checkbox" id="c-38070778" checked=""/><div class="controls bullet"><span class="by">eterevsky</span><span>|</span><a href="#38070396">parent</a><span>|</span><a href="#38072139">prev</a><span>|</span><a href="#38070779">next</a><span>|</span><label class="collapse" for="c-38070778">[-]</label><label class="expand" for="c-38070778">[16 more]</label></div><br/><div class="children"><div class="content">1) Why is it better than wrapping it in an interface with a clear API without extracting it into a separate service?</div><br/><div id="38070931" class="c"><input type="checkbox" id="c-38070931" checked=""/><div class="controls bullet"><span class="by">voxic11</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38070778">parent</a><span>|</span><a href="#38070819">next</a><span>|</span><label class="collapse" for="c-38070931">[-]</label><label class="expand" for="c-38070931">[12 more]</label></div><br/><div class="children"><div class="content">Because of dependency issues like he mentioned. If I am using Library A which depends on version 1 of Library C and I need to start using Library B which depends on version 2 of Library C then I have a clear problem because most popular programming languages don&#x27;t support referencing multiple different versions of the same library.</div><br/><div id="38074383" class="c"><input type="checkbox" id="c-38074383" checked=""/><div class="controls bullet"><span class="by">slowmovintarget</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38070931">parent</a><span>|</span><a href="#38072730">next</a><span>|</span><label class="collapse" for="c-38074383">[-]</label><label class="expand" for="c-38074383">[6 more]</label></div><br/><div class="children"><div class="content">OSGi and Java Modules would like a word.<p>Too few developers use the facilities available for that kind of in-process isolation, even when it is possible. (Don&#x27;t tell me Java isn&#x27;t popular... It may be the new COBOL, but it&#x27;s still mainstream.)</div><br/><div id="38081198" class="c"><input type="checkbox" id="c-38081198" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38074383">parent</a><span>|</span><a href="#38077741">next</a><span>|</span><label class="collapse" for="c-38081198">[-]</label><label class="expand" for="c-38081198">[1 more]</label></div><br/><div class="children"><div class="content">Your dependencies might be tied to different JVM versions. Less likely but happened few times, especially during 8 to 9+ transition. You would&#x27;ve been stuck with your entire system on Java 8 for ages.<p>Also JNI won&#x27;t be isolated which occasionally might be a factor (more likely for stability).<p>On the other hand one could make colocated multi-process services to work around this while avoiding  all the other complexities of microservices.</div><br/></div></div><div id="38077741" class="c"><input type="checkbox" id="c-38077741" checked=""/><div class="controls bullet"><span class="by">lemmsjid</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38074383">parent</a><span>|</span><a href="#38081198">prev</a><span>|</span><a href="#38079272">next</a><span>|</span><label class="collapse" for="c-38077741">[-]</label><label class="expand" for="c-38077741">[2 more]</label></div><br/><div class="children"><div class="content">Good show for mentioning that.  If it becomes commonplace for popular runtimes and languages to be able to load modules and their dependencies at that level, then a lot of arguments for service encapsulation go away.<p>I think in these discussions, a lot of times people are taking past one another.  If I start putting a JRE-targeted application together, I know I can eventually reach for isolated modules if I follow good internal practices, whereas if I&#x27;m in Python land it&#x27;s pretty unattainable.</div><br/><div id="38079233" class="c"><input type="checkbox" id="c-38079233" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38077741">parent</a><span>|</span><a href="#38079272">next</a><span>|</span><label class="collapse" for="c-38079233">[-]</label><label class="expand" for="c-38079233">[1 more]</label></div><br/><div class="children"><div class="content">AWS Lambdas and OSGI invocations are the same thing! (Except one costs you money and one doesn&#x27;t, guess which one is easier to use).</div><br/></div></div></div></div><div id="38079272" class="c"><input type="checkbox" id="c-38079272" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38074383">parent</a><span>|</span><a href="#38077741">prev</a><span>|</span><a href="#38078197">next</a><span>|</span><label class="collapse" for="c-38079272">[-]</label><label class="expand" for="c-38079272">[1 more]</label></div><br/><div class="children"><div class="content">To be fair the problem is that its not baked into the language.<p>If you have to do X,Y,Z to get A done, then you&#x27;ll do X,Y,Z.<p>If your language gives you a shortcut and now you can get away with X,Y then you&#x27;ll drop Z.<p>And even if your language doesn&#x27;t give you those shortcuts, if Cool Language lets you do just X or X,Y, you&#x27;ll naturally want to use Cool Language. So, its a losing game...<p>KISS is great when applied correctly, but you have to be able to know the level of complexity you&#x27;ll actually need for the problem at hand, and it is so so very easy to over or under engineer something...</div><br/></div></div><div id="38078197" class="c"><input type="checkbox" id="c-38078197" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38074383">parent</a><span>|</span><a href="#38079272">prev</a><span>|</span><a href="#38072730">next</a><span>|</span><label class="collapse" for="c-38078197">[-]</label><label class="expand" for="c-38078197">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OSGi and Java Modules would like a word.<p>OSGi is the one that&#x27;s deprecated and Java Modules is the one that can&#x27;t actually provide that functionality yet, right? Or is it the other way round? Either way you get the point.</div><br/></div></div></div></div><div id="38072730" class="c"><input type="checkbox" id="c-38072730" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38070931">parent</a><span>|</span><a href="#38074383">prev</a><span>|</span><a href="#38071318">next</a><span>|</span><label class="collapse" for="c-38072730">[-]</label><label class="expand" for="c-38072730">[1 more]</label></div><br/><div class="children"><div class="content">You’re not wrong here but usually this comes down to having one or a small number of version specific container processors (and I do not mean container in the docker sense) to host those functions. Not microservices.<p>That said, almost always, if you are seriously trying to keep old unsupported dependencies running, you’re violating any reasonable security stance.<p>I’m not saying it never happens, but often the issues that the code is not understood, and no one is capable of supporting it, and so you are deep in the shit already.</div><br/></div></div><div id="38071318" class="c"><input type="checkbox" id="c-38071318" checked=""/><div class="controls bullet"><span class="by">furstenheim</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38070931">parent</a><span>|</span><a href="#38072730">prev</a><span>|</span><a href="#38071693">next</a><span>|</span><label class="collapse" for="c-38071318">[-]</label><label class="expand" for="c-38071318">[1 more]</label></div><br/><div class="children"><div class="content">This node got it just right. You only get this issue for big stateful libraries, like frameworks</div><br/></div></div><div id="38071693" class="c"><input type="checkbox" id="c-38071693" checked=""/><div class="controls bullet"><span class="by">rmbyrro</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38070931">parent</a><span>|</span><a href="#38071318">prev</a><span>|</span><a href="#38070819">next</a><span>|</span><label class="collapse" for="c-38071693">[-]</label><label class="expand" for="c-38071693">[3 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t we just isolate these two services in containers, using different library versions?<p>They don&#x27;t need to be microservices in order to isolate dependencies, do they?<p>In Python, for instance, you don&#x27;t even need containers. Just different virtual environments running on separate processes.</div><br/><div id="38072155" class="c"><input type="checkbox" id="c-38072155" checked=""/><div class="controls bullet"><span class="by">jethro_tell</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071693">parent</a><span>|</span><a href="#38071944">next</a><span>|</span><label class="collapse" for="c-38072155">[-]</label><label class="expand" for="c-38072155">[1 more]</label></div><br/><div class="children"><div class="content">I suppose if you do that, they will communicate over the network likely via api and have the ability to scale independently.<p>You just invented microservices, lol.</div><br/></div></div><div id="38071944" class="c"><input type="checkbox" id="c-38071944" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38071693">parent</a><span>|</span><a href="#38072155">prev</a><span>|</span><a href="#38070819">next</a><span>|</span><label class="collapse" for="c-38071944">[-]</label><label class="expand" for="c-38071944">[1 more]</label></div><br/><div class="children"><div class="content">If you have two separate processes running in two separate containers... those are two separate services. You need to solve the same problems that would come with running them on two different EC2 instances: what&#x27;s the method for communicating with the other container? What happens if the other container I&#x27;m calling is down? If the other container is down or slow to respond to my API calls, am I dealing with backpressure gracefully or will the system start to experiencing a cascade of failures?</div><br/></div></div></div></div></div></div><div id="38070819" class="c"><input type="checkbox" id="c-38070819" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38070778">parent</a><span>|</span><a href="#38070931">prev</a><span>|</span><a href="#38070779">next</a><span>|</span><label class="collapse" for="c-38070819">[-]</label><label class="expand" for="c-38070819">[3 more]</label></div><br/><div class="children"><div class="content">Those dependencies might cross language boundaries, or interfere with your other dependencies running in the same process.</div><br/><div id="38070991" class="c"><input type="checkbox" id="c-38070991" checked=""/><div class="controls bullet"><span class="by">bingemaker</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38070819">parent</a><span>|</span><a href="#38070779">next</a><span>|</span><label class="collapse" for="c-38070991">[-]</label><label class="expand" for="c-38070991">[2 more]</label></div><br/><div class="children"><div class="content">On the contrary, when they fail silently, it is hard debug &quot;dependent&quot; services</div><br/><div id="38073022" class="c"><input type="checkbox" id="c-38073022" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#38070396">root</a><span>|</span><a href="#38070991">parent</a><span>|</span><a href="#38070779">next</a><span>|</span><label class="collapse" for="c-38073022">[-]</label><label class="expand" for="c-38073022">[1 more]</label></div><br/><div class="children"><div class="content">In the Java world, we&#x27;ve developed record&#x2F;replay across microservice boundaries, so it&#x27;s effectively possible to step from a failure in one microservice and into the service that sent it bad data.<p><a href="https:&#x2F;&#x2F;docs.undo.io&#x2F;java&#x2F;Microservices.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.undo.io&#x2F;java&#x2F;Microservices.html</a><p>[Edit: for which, by the way, any feedback is welcome - it&#x27;s technically quite promising but real world experience is worth a lot!]</div><br/></div></div></div></div></div></div></div></div><div id="38070779" class="c"><input type="checkbox" id="c-38070779" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38070396">parent</a><span>|</span><a href="#38070778">prev</a><span>|</span><a href="#38071929">next</a><span>|</span><label class="collapse" for="c-38070779">[-]</label><label class="expand" for="c-38070779">[1 more]</label></div><br/><div class="children"><div class="content">And those would apply to &lt; 10% of your total code base.</div><br/></div></div><div id="38071929" class="c"><input type="checkbox" id="c-38071929" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#38070396">parent</a><span>|</span><a href="#38070779">prev</a><span>|</span><a href="#38070122">next</a><span>|</span><label class="collapse" for="c-38071929">[-]</label><label class="expand" for="c-38071929">[1 more]</label></div><br/><div class="children"><div class="content">There are many ways to architecture well that doesn’t mean prematurely introducing micro services.<p>I’m a fan of microservices btw.<p>Premature optimization and scaling is almost as bad of a form of technical debt as others when you have to optimize in a completely different manner and direction.</div><br/></div></div></div></div><div id="38070122" class="c"><input type="checkbox" id="c-38070122" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070396">prev</a><span>|</span><a href="#38070112">next</a><span>|</span><label class="collapse" for="c-38070122">[-]</label><label class="expand" for="c-38070122">[87 more]</label></div><br/><div class="children"><div class="content">The right time to extract something into a separate service is when there&#x27;s a problem that you can&#x27;t tractably solve without doing so.<p>Increasing architectural complexity to enforce boundaries is never a solution to a lack of organizational discipline, but midsize tech companies _incessantly_ treat it like one. If you&#x27;re having trouble because your domains lack good boundaries, then extracting services _is not going to go well_.</div><br/><div id="38070262" class="c"><input type="checkbox" id="c-38070262" checked=""/><div class="controls bullet"><span class="by">arzke</span><span>|</span><a href="#38070122">parent</a><span>|</span><a href="#38070389">next</a><span>|</span><label class="collapse" for="c-38070262">[-]</label><label class="expand" for="c-38070262">[10 more]</label></div><br/><div class="children"><div class="content">&quot;The last responsible moment (LRM) is the strategy of delaying a decision until the moment when the cost of not making the decision is greater than the cost of making it.&quot;<p>Quoted from: <a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;software-architects-handbook&#x2F;9781788624060&#x2F;a844b94f-be9e-456d-8ef0-cd9b46b41c33.xhtml" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;software-architects-han...</a></div><br/><div id="38075335" class="c"><input type="checkbox" id="c-38075335" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070262">parent</a><span>|</span><a href="#38071743">next</a><span>|</span><label class="collapse" for="c-38075335">[-]</label><label class="expand" for="c-38075335">[8 more]</label></div><br/><div class="children"><div class="content">Still trying to unlearn that one. Turns out, most decisions are cheap to revert or backtrack on, while delaying them until Last Responsible Moment often ends in shooting past that moment.</div><br/><div id="38079016" class="c"><input type="checkbox" id="c-38079016" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38075335">parent</a><span>|</span><a href="#38079323">next</a><span>|</span><label class="collapse" for="c-38079016">[-]</label><label class="expand" for="c-38079016">[1 more]</label></div><br/><div class="children"><div class="content">Committing to a decision is costly, but implementing it one way or the other and seeing how that works is often the cheapest way to proceed.</div><br/></div></div><div id="38079323" class="c"><input type="checkbox" id="c-38079323" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38075335">parent</a><span>|</span><a href="#38079016">prev</a><span>|</span><a href="#38076404">next</a><span>|</span><label class="collapse" for="c-38079323">[-]</label><label class="expand" for="c-38079323">[2 more]</label></div><br/><div class="children"><div class="content">Depends who you are, mostly the ones making the decisions aren&#x27;t usually listening to their developers (maybe by choice maybe because they are at the whim of a customer), so their cost functions are calibrated towards course changing being more expensive than less.<p>By the time your devs are saying &quot;this sucks&quot; you&#x27;ve long overshot.</div><br/><div id="38079823" class="c"><input type="checkbox" id="c-38079823" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38079323">parent</a><span>|</span><a href="#38076404">next</a><span>|</span><label class="collapse" for="c-38079823">[-]</label><label class="expand" for="c-38079823">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good point. The (estimate of the) cost function is key, it determines whether delaying decision is better or worse than making it eagerly and reverting if it turns out to be wrong. You give a good case for when delaying is a better choice.<p>In my case however, I ended up applying the &quot;LRM&quot; strategy to my own work, where I&#x27;m both the decision maker and the sole implementer. This is where I see my mistake. In my defense, the software development books that argued for delaying decisions did <i>not</i> warn that this applies to larger decisions in projects developed by teams, and may not apply to small-scale design decisions made by an individual contributor or a small team in the scope of a small piece of work. It took me way too long to realize that, for most of my day-to-day choices, the cost function is pretty much flat.</div><br/></div></div></div></div><div id="38076404" class="c"><input type="checkbox" id="c-38076404" checked=""/><div class="controls bullet"><span class="by">cle</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38075335">parent</a><span>|</span><a href="#38079323">prev</a><span>|</span><a href="#38075792">next</a><span>|</span><label class="collapse" for="c-38076404">[-]</label><label class="expand" for="c-38076404">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you need to unlearn it, but update your cost function.</div><br/></div></div><div id="38075792" class="c"><input type="checkbox" id="c-38075792" checked=""/><div class="controls bullet"><span class="by">jlundberg</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38075335">parent</a><span>|</span><a href="#38076404">prev</a><span>|</span><a href="#38071743">next</a><span>|</span><label class="collapse" for="c-38075792">[-]</label><label class="expand" for="c-38075792">[3 more]</label></div><br/><div class="children"><div class="content">Interesting term and I am curious to learn a few examples on overshooting here!<p>My experience is that the new data available when postponing decisions can be very very valuable.</div><br/><div id="38078256" class="c"><input type="checkbox" id="c-38078256" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38075792">parent</a><span>|</span><a href="#38071743">next</a><span>|</span><label class="collapse" for="c-38078256">[-]</label><label class="expand" for="c-38078256">[2 more]</label></div><br/><div class="children"><div class="content">We&#x27;re moving out of business context and to more general one, as I have more experience there - I learned the idea of postponing decisions from software design, and mistakenly started to apply it to my life in general :).<p>It&#x27;s absolutely true that postponing a decision lets you take advantage of more data and experience. But making a decision now <i>also</i> generates new data - and often does it better and faster: you&#x27;re directly observing how your choice plays out in the real world. For cheaply reversible decisions it means that, when things go bad, you can go back and make a new decision, this time informed by knowledge of what went wrong with your previous choice. If you squint, it almost looks like time travel :).<p>Not every decision is going to be like that, but e.g. in software design, I would often delay deciding between several possible approaches to seek out more information (and&#x2F;or wait for it to come from customer side), only to later realize that in that time, I could&#x27;ve prototyped most or <i>all</i> of the options, or I could&#x27;ve picked one and made progress and undo it fast when more information came - and that either of those two approaches would&#x27;ve let me to gain the missing data faster, while also keeping forward momentum.<p>There&#x27;s a reason many programmers (myself included) need to repeatedly hear the mantra that goes: &quot;make it work, then make it right, then make it fast&quot;. In my case, postponing decisions is often a kind of analysis paralysis, and I&#x27;m slowly learning that in many cases, it&#x27;s better to just pick <i>any</i> option, &quot;make it work&quot; in the dumbest, most straightforward way possible, and <i>then</i> reevaluate.<p>But as I said, I am learning this slowly. My mind knows better, but my heart still wants to delay by default :).</div><br/><div id="38079094" class="c"><input type="checkbox" id="c-38079094" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38078256">parent</a><span>|</span><a href="#38071743">next</a><span>|</span><label class="collapse" for="c-38079094">[-]</label><label class="expand" for="c-38079094">[1 more]</label></div><br/><div class="children"><div class="content">Agree with all of that, and want to add a shoutout to the Cult of Done [0].<p>Very few things need to be perfect, or right first try. Waiting until the last possible moment is a version of perfectionism that is often counter-productive. Trying something out before it&#x27;s needed gives room to experiment and discover new approaches.<p>[0] <a href="https:&#x2F;&#x2F;medium.com&#x2F;@bre&#x2F;the-cult-of-done-manifesto-724ca1c2ff13" rel="nofollow noreferrer">https:&#x2F;&#x2F;medium.com&#x2F;@bre&#x2F;the-cult-of-done-manifesto-724ca1c2f...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="38070389" class="c"><input type="checkbox" id="c-38070389" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">parent</a><span>|</span><a href="#38070262">prev</a><span>|</span><a href="#38070186">next</a><span>|</span><label class="collapse" for="c-38070389">[-]</label><label class="expand" for="c-38070389">[46 more]</label></div><br/><div class="children"><div class="content">&gt; Increasing architectural complexity to enforce boundaries is never a solution to a lack of organizational discipline,<p>And yet we do this all the time. Your CI&#x2F;CD blocking your PRs until tests pass? That&#x27;s a costly technical solution to solve an issue of organizational discipline.</div><br/><div id="38070619" class="c"><input type="checkbox" id="c-38070619" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070389">parent</a><span>|</span><a href="#38072767">next</a><span>|</span><label class="collapse" for="c-38070619">[-]</label><label class="expand" for="c-38070619">[12 more]</label></div><br/><div class="children"><div class="content">That&#x27;s technical, and not architectural. I&#x27;m _all about_ technical solutions to lack of discipline, and in fact I think technical and process solutions are the only immediate way to create cultural solutions (which are the long-term ones). I&#x27;d even consider minor increases to architectural complexity for that purpose justifiable - it&#x27;s a real problem, and trading to solve it is reasonable.<p>But architectural complexity has outsized long-term cost, and service-orientation in particular has a _lot_ of it. And in this particular case, it doesn&#x27;t actually solve the problem, since you _can&#x27;t_ successfully enforce those domain boundaries unless you already have them well-defined.</div><br/><div id="38070746" class="c"><input type="checkbox" id="c-38070746" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070619">parent</a><span>|</span><a href="#38071382">next</a><span>|</span><label class="collapse" for="c-38070746">[-]</label><label class="expand" for="c-38070746">[4 more]</label></div><br/><div class="children"><div class="content">Can you explain the salient distinction between a &quot;technical&quot; versus &quot;architectural&quot; solution? Candidly, I&#x27;m not convinced that there is one.<p>&gt; But architectural complexity has outsized long-term cost<p>As do technical solutions, of course. CI&#x2F;CD systems are very expensive, just from a monetary perspective, but also impose significant burdens to developers in terms of blocking PRs, especially if there are flaky or expensive tests.<p>&gt; And in this particular case, it doesn&#x27;t actually solve the problem, since you _can&#x27;t_ successfully enforce those domain boundaries unless you already have them well-defined.<p>Ignoring microservices, just focusing on underlying SoA for a moment, the boundary is the process. That is an enforceable boundary. I think what you&#x27;re saying amounts to, in microservice parlance, that there is no way to prevent a single microservice from crossing multiple bounded contexts, that it ultimately relies on developers. This is true, but it&#x27;s also just as true for good monolithic designs around modules - there is no technical constraint for a module to not expand into domains, becoming cluttered and overly complex.<p>Microservices do not make that problem harder, but SoA does give you a powerful technical tool for isolation.</div><br/><div id="38071460" class="c"><input type="checkbox" id="c-38071460" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070746">parent</a><span>|</span><a href="#38071382">next</a><span>|</span><label class="collapse" for="c-38071460">[-]</label><label class="expand" for="c-38071460">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Can you explain the salient distinction between a &quot;technical&quot; versus &quot;architectural&quot; solution? Candidly, I&#x27;m not convinced that there is one.<p>Not concisely in the general case, but in this case the difference is fairly straightforward - CI&#x2F;CD doesn&#x27;t affect the structure of your executing application at all, only the surrounding context. I don&#x27;t want to spend the hours it would take to characterize architecture as distinct from implementation, but the vast number of textbooks on the topic all generally agree that there is one, though they draw the lines in slightly different places.<p>&gt; I think what you&#x27;re saying amounts to,<p>Very much no - my point is about the process of implementation. The services.. _do_ enforce boundaries, but the boundaries they enforce may not be good ones.<p>In order to successfully extract services from a monolith, you have to go through a process that includes finding and creating those domain boundaries for the domain being extracted. If it&#x27;s your first time, you might be doing that implicitly and without realizing it&#x27;s what you&#x27;re doing, but under the hood it&#x27;s the bulk of the mental effort.<p>The part where you actually _introduce a service_ can be anywhere from a tenth to half of the work (that fraction varies a lot by technical stack and depending on how coupled the domain in question is to the central behavioral tangle in the monolith), but by the time you&#x27;ve gotten the domain boundary created you&#x27;ve _already solved_ the original problem. Now you&#x27;re facing a trade of &quot;extract this well-factored domain out to a separate service application, to prevent its now-clear boundaries from being violated in the future&quot;. And I contend that that&#x27;s a trade that should rarely be made.</div><br/><div id="38072562" class="c"><input type="checkbox" id="c-38072562" checked=""/><div class="controls bullet"><span class="by">danielovichdk</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071460">parent</a><span>|</span><a href="#38071382">next</a><span>|</span><label class="collapse" for="c-38072562">[-]</label><label class="expand" for="c-38072562">[2 more]</label></div><br/><div class="children"><div class="content">Which is exactly why the real challenges around (micro) services is to a large extent an organisational challenge mixed how those boundaries are belonging to which business capabilities.<p>The technical part of services is easy enough really but if the organisation leaks its boundaries, which always flow downstream into the actual teams, you are proper fucked.<p>It takes a different level of maturity, both in organisation and team, to build a service oriented software.<p>That&#x27;s my experience at least.</div><br/><div id="38072748" class="c"><input type="checkbox" id="c-38072748" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38072562">parent</a><span>|</span><a href="#38071382">next</a><span>|</span><label class="collapse" for="c-38072748">[-]</label><label class="expand" for="c-38072748">[1 more]</label></div><br/><div class="children"><div class="content">Right! What I&#x27;m fundamentally saying is that the majority of orgs trying to adopt SOA are doing it for the wrong reasons, and will deeply regret it. In general, the &quot;right way&quot; to adopt SOA is to extract services one at a time because you have to, to solve various problems you&#x27;ve encountered (scaling problems, technical problems, stability issues), and then realize that you are in fact currently using a service-oriented architecture, and have been for several years.</div><br/></div></div></div></div></div></div></div></div><div id="38071382" class="c"><input type="checkbox" id="c-38071382" checked=""/><div class="controls bullet"><span class="by">jcstauffer</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070619">parent</a><span>|</span><a href="#38070746">prev</a><span>|</span><a href="#38070679">next</a><span>|</span><label class="collapse" for="c-38071382">[-]</label><label class="expand" for="c-38071382">[6 more]</label></div><br/><div class="children"><div class="content">I would hope that there is more process in place protecting against downtime than code review - for example automated tests across several levels, burn-in testing, etc.<p>People are not reliable enough to leave them as the only protection against system failure...</div><br/><div id="38071521" class="c"><input type="checkbox" id="c-38071521" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071382">parent</a><span>|</span><a href="#38070679">next</a><span>|</span><label class="collapse" for="c-38071521">[-]</label><label class="expand" for="c-38071521">[5 more]</label></div><br/><div class="children"><div class="content">Did you mean to reply to somebody else? I&#x27;m a huge believer in automated testing, and if I said something that can be interpreted otherwise I&#x27;d like to clarify it.</div><br/><div id="38072016" class="c"><input type="checkbox" id="c-38072016" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071521">parent</a><span>|</span><a href="#38070679">next</a><span>|</span><label class="collapse" for="c-38072016">[-]</label><label class="expand" for="c-38072016">[4 more]</label></div><br/><div class="children"><div class="content">I guess the GP&#x27;s issue is because automated tests (and every other kind of validation) imposes architectural constraints on your system, and thus are an exception to your rule.<p>I don&#x27;t think that rule can be applied as universally as you stated it. But then, I have never seen anybody breaking it in a bad way that did also break it in a good way, so the people that need to hear it will have no problem with the simplified version until they grow a bit.<p>Anyway, that problem is very general of software development methods. Almost every one of them is contextual. And people start without the maturity to discern the context from the advice, so they tend to overgeneralize what they see.</div><br/><div id="38072350" class="c"><input type="checkbox" id="c-38072350" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38072016">parent</a><span>|</span><a href="#38070679">next</a><span>|</span><label class="collapse" for="c-38072350">[-]</label><label class="expand" for="c-38072350">[3 more]</label></div><br/><div class="children"><div class="content">Hm. I think maybe you&#x27;re using &quot;system&quot; to mean a different thing than I am? I thinking of &quot;the system&quot; as the thing that is executing in production - it provides the business behavior we are trying to provide; there is a larger &quot;system&quot; surrounding it, that includes the processes and engineers, and the CI&#x2F;CD pipelines  - it too has an &quot;architecture&quot;, and _that_ architecture gets (moderately) more complex when you add CI&#x2F;CD. Is that where our communication is clashing?<p>Because the complexity of that outer system is also important, but there are a few very major differences between the two that are probably too obvious to belabor. But in general, architectural complexity in the inner system costs a lot more than it does in the outer system, because it&#x27;s both higher churn (development practices change much slower than most products) and higher risk (taking production systems offline is much less permissible than freezing deployments)</div><br/><div id="38073195" class="c"><input type="checkbox" id="c-38073195" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38072350">parent</a><span>|</span><a href="#38070679">next</a><span>|</span><label class="collapse" for="c-38073195">[-]</label><label class="expand" for="c-38073195">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think maybe you&#x27;re using &quot;system&quot; to mean a different thing than I am?<p>No, I&#x27;m not. Are you overlooking some of the impacts of your tests and most of the impact of static verification?<p>Those do absolutely impact your system, not only your environment. For tests it&#x27;s good to keep those impacts at a minimum (for static verification you want to maximize them), but they still have some.</div><br/><div id="38073353" class="c"><input type="checkbox" id="c-38073353" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38073195">parent</a><span>|</span><a href="#38070679">next</a><span>|</span><label class="collapse" for="c-38073353">[-]</label><label class="expand" for="c-38073353">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I&#x27;m overlooking any major ones, but we are probably working in quite different types of systems - I&#x27;m not aware of any type of static verification I&#x27;d use in a rails application that would affect _architecture_ in a meaningful way (unless I would write quite terrifying code without the verifier I suppose).<p>I&#x27;m not sure about the tests - it depends on what you&#x27;d consider an impact possibly; I&#x27;ve been trained by my context to design code to be decomposable in a way that _is_ easily testable, but I&#x27;m not sure that is really an &#x27;impact of the tests&#x27; (and I&#x27;m fairly confident that it makes the abstractions less complex instead of more).<p>Would you mind explaining what you mean in more detail?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38070679" class="c"><input type="checkbox" id="c-38070679" checked=""/><div class="controls bullet"><span class="by">jaxr</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070619">parent</a><span>|</span><a href="#38071382">prev</a><span>|</span><a href="#38072767">next</a><span>|</span><label class="collapse" for="c-38070679">[-]</label><label class="expand" for="c-38070679">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. isn&#x27;t that why strongly typed languages made a comeback?</div><br/></div></div></div></div><div id="38072767" class="c"><input type="checkbox" id="c-38072767" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070389">parent</a><span>|</span><a href="#38070619">prev</a><span>|</span><a href="#38070522">next</a><span>|</span><label class="collapse" for="c-38072767">[-]</label><label class="expand" for="c-38072767">[2 more]</label></div><br/><div class="children"><div class="content">No, not at all. CI&#x2F;CD blocking pull requests is in place because large systems have large test suites and challenging dependencies which mean that individual developers literally can&#x27;t run every test on their local machine and can often break things without realising it. It&#x27;s not about organisational discipline, it&#x27;s about ensuring correctness.</div><br/><div id="38072955" class="c"><input type="checkbox" id="c-38072955" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38072767">parent</a><span>|</span><a href="#38070522">next</a><span>|</span><label class="collapse" for="c-38072955">[-]</label><label class="expand" for="c-38072955">[1 more]</label></div><br/><div class="children"><div class="content">I can run every test on my machine if I want.  It would be a manual effort, but wouldn&#x27;t be hard to automate if I cared to try.  However it would take about 5 days to finish.  It isn&#x27;t worth it when such tests rarely fail - the CI system just spin them off to many AWS nodes and if something fails then run just that test locally and I get results in a few hours (some of the tests are end to end integration that need more than half an hour).<p>Like any good test system I have a large suite of &quot;unit&quot; tests that run quick that I run locally before committing code - it takes a few minutes to get high code coverage if you care about that  metric.  Even then I just run the tests for x86-64, if they fail on arm that is something for my CI system to figure out for me.</div><br/></div></div></div></div><div id="38070522" class="c"><input type="checkbox" id="c-38070522" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070389">parent</a><span>|</span><a href="#38072767">prev</a><span>|</span><a href="#38070186">next</a><span>|</span><label class="collapse" for="c-38070522">[-]</label><label class="expand" for="c-38070522">[31 more]</label></div><br/><div class="children"><div class="content">The other problem is that these self-imposed roadblocks are so engrained in the modern SDLC that developers literally cannot imagine a world where they do not exist. I got _reamed_ by some &quot;senior&quot; engineers for merging a small PR without an approval recently. And we&#x27;re not some megacorp, we&#x27;re a 12 person engineering startup! We can make our own rules! We don&#x27;t even have any customers...</div><br/><div id="38070836" class="c"><input type="checkbox" id="c-38070836" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070522">parent</a><span>|</span><a href="#38071462">next</a><span>|</span><label class="collapse" for="c-38070836">[-]</label><label class="expand" for="c-38070836">[22 more]</label></div><br/><div class="children"><div class="content">Your &#x27;senior&#x27; engineer is likely right: they are trying to get some kind of process going and you are actively sabotaging that. This could come back to haunt you later on when you by your lonesome decide to merge a &#x27;small PR&#x27; with massive downtime as a result of not having your code reviewed. Ok, you say, I&#x27;m perfect. And I believe you. But now you have another problem: the other junior devs on your team who see vrosas commit and merge stuff by themselves will see you as their shining example. And as a result they by their lonesomes decide to merge &#x27;small PR&#x27;s with massive downtime as a result.<p>If you got _reamed_ you got off lucky: in plenty of places you&#x27;d be out on the street.<p>It may well be that you had it right but from context as given I hope this shows you some alternative perspective that might give you pause the next time you decide to throw out the rulebook, even in emergencies - especially in emergencies - these rules are there to keep you, your team <i>and</i> the company safe. In regulated industries you can multiply all of that by a factor of five or so.</div><br/><div id="38071172" class="c"><input type="checkbox" id="c-38071172" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070836">parent</a><span>|</span><a href="#38071067">next</a><span>|</span><label class="collapse" for="c-38071172">[-]</label><label class="expand" for="c-38071172">[18 more]</label></div><br/><div class="children"><div class="content">&gt; Your &#x27;senior&#x27; engineer is likely right: they are trying to get some kind of process going and you are actively sabotaging that<p>Why? Because it&#x27;s a &quot;good practice&quot;? They have 12 people and no customers, they can almost certainly adopt a very aggressive developer cycle that optimizes almost exclusively for happy-path velocity. You&#x27;d never do that at 50+ engineers with customers but for 12 engineers who have no customers? It&#x27;s fine, in fact it&#x27;s <i>ideal</i>.<p>&gt;  with massive downtime as a result.<p>They have <i>no customers</i>, downtime literally does not exist for them. You are following a dogmatic practice that is optimizing for a situation that literally does not exist within their company.</div><br/><div id="38071258" class="c"><input type="checkbox" id="c-38071258" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071172">parent</a><span>|</span><a href="#38071837">next</a><span>|</span><label class="collapse" for="c-38071258">[-]</label><label class="expand" for="c-38071258">[4 more]</label></div><br/><div class="children"><div class="content">You establish a process before you need it, and code review, especially when starting up is a fantastic way to make sure that everybody is on the same page and that you don&#x27;t end up with a bunch of latent issues further down the line. The fact that they have no customers <i>today</i> doesn&#x27;t mean that they won&#x27;t have any in the future and mistakes made <i>today</i> can cause downtime further down the line.<p>If you&#x27;re wondering why software is crap: it is because every new generation of coders insists on making all the same mistakes all over again. Learn from the past, understand that &#x27;good practice&#x27; has been established over many years of very expensive mistakes. 12 engineers is already a nice little recipe for pulling in 12 directions at once and even if they&#x27;re all perfect they can still learn from looking at each others code and it will ensure that there are no critical dependencies on single individuals (which can bite you hard if one of them decides to leave, not unheard of in a startup) and that if need be labor can be re-divided without too much hassle.</div><br/><div id="38071302" class="c"><input type="checkbox" id="c-38071302" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071258">parent</a><span>|</span><a href="#38071837">next</a><span>|</span><label class="collapse" for="c-38071302">[-]</label><label class="expand" for="c-38071302">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not advocating for having no processes, I&#x27;m advocating for a process that matches their situation. A company with no customers should not be worrying about causing a production outage, they should be worried about getting a demoable product out.<p>Dogmatic adherence to a process that limits developer velocity and optimizes for correct code is very likely the <i>wrong</i> call when you have no customers.</div><br/><div id="38071446" class="c"><input type="checkbox" id="c-38071446" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071302">parent</a><span>|</span><a href="#38071837">next</a><span>|</span><label class="collapse" for="c-38071446">[-]</label><label class="expand" for="c-38071446">[2 more]</label></div><br/><div class="children"><div class="content">If it is dogmatic, then yes: but you have no knowledge of that and besides there are always people who believe there is too much process and there are people that there is too little. If you want to challenge the process you do that by talking about it not by breaking the process on purpose. That&#x27;s an excellent way to get fired.<p>I don&#x27;t know the context and I don&#x27;t know the particular business the OP is talking about. What I <i>do</i> know is that if you feel that your management is cargo culting development methodology (which really does happen) you can either engage them constructively or you can leave for a better company. Going in with a confrontational mindset isn&#x27;t going to be a good experience for anybody involved. Case in point: the OP is still upset enough that he feels it necessary to vent about this in an online forum.<p>Note that this is the same person who in another comment wrote:<p>&quot;On the flip side I’m trying to convince my CTO to fire half our engineering team - a group of jokers he hired during the run-up who are now wildly overpaid and massively under-delivering. With all the tech talent out there I’m convinced we’d replace them all within a week.&quot;</div><br/><div id="38071810" class="c"><input type="checkbox" id="c-38071810" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071446">parent</a><span>|</span><a href="#38071837">next</a><span>|</span><label class="collapse" for="c-38071810">[-]</label><label class="expand" for="c-38071810">[1 more]</label></div><br/><div class="children"><div class="content">Heh, both can be true. Process doesn&#x27;t make good engineers any better. Bad code gets approved and merged every day. I&#x27;d rather have a team I could trust to merge and steward their code to production on their own instead of bureaucracy giving people a false sense of security.<p>&gt; Case in point: the OP is still upset enough that he feels it necessary to vent about this in an online forum.<p>I apologize for the conversation starter.</div><br/></div></div></div></div></div></div></div></div><div id="38071837" class="c"><input type="checkbox" id="c-38071837" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071172">parent</a><span>|</span><a href="#38071258">prev</a><span>|</span><a href="#38077301">next</a><span>|</span><label class="collapse" for="c-38071837">[-]</label><label class="expand" for="c-38071837">[12 more]</label></div><br/><div class="children"><div class="content">With no customers, one of the purposes of code-review is removed, but it&#x27;s the lesser one anyway. The primary goal of code-review should _not_ be to &quot;catch mistakes&quot; in a well-functioning engineering team - that&#x27;s a thing that happens, but mostly your CI handles that. Code-review is about unifying approaches, cross-pollinating strategies and techniques, and helping each other to improve as engineers.<p>Your attitude towards code-review on the other hand is one I&#x27;ve seen before several times, and I was glad when each of those people were fired.</div><br/><div id="38072525" class="c"><input type="checkbox" id="c-38072525" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071837">parent</a><span>|</span><a href="#38074711">next</a><span>|</span><label class="collapse" for="c-38072525">[-]</label><label class="expand" for="c-38072525">[5 more]</label></div><br/><div class="children"><div class="content">We did post-merge code reviews. But half our team was on the other side of the planet from the other half (4 people on the team, US, EU. APAC, and AU).<p>If we waited for reviews before merging, we’d be waiting weeks to merge a single PR. Thus, you wrote your code, opened a PR, did a self-review, then deployed it. We had millions of customers, downtime was a real possibility. So you’d watch metrics and revert if anything looked slightly off.<p>You would wake up to your PR being reviewed. Sometimes there would be mistakes pointed out, suggestions to improve it, etc. Sometimes it was just a thumbs up emoji.<p>The point is, there are many ways to skin this cat and to “ream” someone for merging without deploying is incredibly immature and uncreative. You can still review a merged PR.</div><br/><div id="38072782" class="c"><input type="checkbox" id="c-38072782" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38072525">parent</a><span>|</span><a href="#38074711">next</a><span>|</span><label class="collapse" for="c-38072782">[-]</label><label class="expand" for="c-38072782">[4 more]</label></div><br/><div class="children"><div class="content">That process sounds fine to me, especially in a context with either good integration coverage or low downtime cost.<p>&gt; to “ream” someone for merging without deploying is incredibly immature and uncreative.<p>I&#x27;d agree, but I _highly_ doubt that description was an accurate one. Read through the other comments by the same person and you&#x27;ll get a picture of their personality pretty quickly.<p>It&#x27;s likely that there was already an ongoing conflict either in general or specifically between them about this issue. They probably got a moderately harsh comment to the effect of &quot;hey, you&#x27;re expected to wait for code-reviews now, knock it off&quot;</div><br/><div id="38074650" class="c"><input type="checkbox" id="c-38074650" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38072782">parent</a><span>|</span><a href="#38074711">next</a><span>|</span><label class="collapse" for="c-38074650">[-]</label><label class="expand" for="c-38074650">[3 more]</label></div><br/><div class="children"><div class="content">I suggested it&#x27;s possible to write, commit and own code without others&#x27; approval to increase productivity and people get _extremely_ defensive about it. It&#x27;s so odd. It happened in real life and it&#x27;s happening in this thread now, too. They even attack your character over it.</div><br/><div id="38076076" class="c"><input type="checkbox" id="c-38076076" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38074650">parent</a><span>|</span><a href="#38074711">next</a><span>|</span><label class="collapse" for="c-38076076">[-]</label><label class="expand" for="c-38076076">[2 more]</label></div><br/><div class="children"><div class="content">Yes. Some people get personally attached to code. It’s incredibly frustrating. Some people use reviews to push dogmatic approaches to architecture and&#x2F;or exert some kind of control over things. Whenever I meet these people in a code review, and they make unnecessary suggestions or whatever, my favorite phrase to say is, “I can get behind that, but I don’t think it’s worth the time to do that right now,” or, “I disagree, can you give an argument grounded in computer science.” With the latter only being used twice in my career, when someone left a shitload of comments suggesting variable name changes, and then again, when someone suggested rewriting something that was O(n) to O(n^2) and claimed it was better and wouldn’t give up.<p>You want to get the team to a point where you can disagree and commit, no code will ever be perfect and there is no reason spending 3-4 rounds of change requests trying. I think the worst code review I ever had, ended with me saying, “if you’re going to be this nitpicky, why don’t you take the ticket?” (It was extremely complex and hard to read — and there wasn’t any getting around it, lots of math, bit shifting, and other shenanigans. The reviewer kept making suggestions that would result in bugs, and then make more suggestions…)<p>He came back the next day and approved my PR once he understood the problem I was trying to solve.<p>Even these days, where I work on a close team IRL, I’ve been known to say, “if there are no objections, I’m merging this unreviewed code.” And then I usually get a thumbs up from the team, or they say something like “oh, I wanted to take a look at that. Give me a few mins I got sidetracked!” And I’ve even heard, “I already reviewed it, I just forgot to push approve!”<p>Communication is key in a team. Often, if the team is taking a long time to review, give them the benefit of the doubt, but don’t let yourself get blocked by a review.</div><br/><div id="38079426" class="c"><input type="checkbox" id="c-38079426" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38076076">parent</a><span>|</span><a href="#38074711">next</a><span>|</span><label class="collapse" for="c-38079426">[-]</label><label class="expand" for="c-38079426">[1 more]</label></div><br/><div class="children"><div class="content">If the code work&#x2F;it&#x27;s tested, review is for sanity checking&#x2F;looking for obvious bugs.<p>Anything else is un-needed grooming that&#x27;s more about the other developer&#x27;s ego, not about good code (sometimes its to follow some other constraint, but its a good sign the person has a personality issue).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38074711" class="c"><input type="checkbox" id="c-38074711" checked=""/><div class="controls bullet"><span class="by">namtab00</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071837">parent</a><span>|</span><a href="#38072525">prev</a><span>|</span><a href="#38072679">next</a><span>|</span><label class="collapse" for="c-38074711">[-]</label><label class="expand" for="c-38074711">[1 more]</label></div><br/><div class="children"><div class="content">I cannot agree more, and have nothing to add except &quot;can I work with you?&quot;..</div><br/></div></div><div id="38072679" class="c"><input type="checkbox" id="c-38072679" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071837">parent</a><span>|</span><a href="#38074711">prev</a><span>|</span><a href="#38077301">next</a><span>|</span><label class="collapse" for="c-38072679">[-]</label><label class="expand" for="c-38072679">[5 more]</label></div><br/><div class="children"><div class="content">You have no idea what my attitude towards code-review is.</div><br/><div id="38073076" class="c"><input type="checkbox" id="c-38073076" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38072679">parent</a><span>|</span><a href="#38072911">next</a><span>|</span><label class="collapse" for="c-38073076">[-]</label><label class="expand" for="c-38073076">[3 more]</label></div><br/><div class="children"><div class="content">Well, partly that was a mistaken impression because I thought that your comment was also from vrosas. But I think there&#x27;s enough in there to assess your attitude toward code-review at least a _bit_:<p>&gt; They have 12 people and no customers, they can almost certainly adopt a very aggressive developer cycle that optimizes almost exclusively for happy-path velocity. You&#x27;d never do that at 50+ engineers with customers but for 12 engineers who have no customers? It&#x27;s fine, in fact it&#x27;s ideal.<p>12 engineers churning out code with no code-review at all? That&#x27;ll produce velocity, for sure. It&#x27;ll also produce not just an unmaintainable mess, but an interesting experiment, in which you get to find out which of your engineers are socially capable enough to initiate technical communication independently and construct technical rapport _without_ that process helping them to do so. Hope none of them hold strong technical opinions that clash!</div><br/><div id="38073569" class="c"><input type="checkbox" id="c-38073569" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38073076">parent</a><span>|</span><a href="#38078983">next</a><span>|</span><label class="collapse" for="c-38073569">[-]</label><label class="expand" for="c-38073569">[1 more]</label></div><br/><div class="children"><div class="content">Who said &quot;no code-review at all&quot;? Not me, not vrosas as far as I saw.</div><br/></div></div></div></div></div></div></div></div><div id="38077301" class="c"><input type="checkbox" id="c-38077301" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071172">parent</a><span>|</span><a href="#38071837">prev</a><span>|</span><a href="#38071067">next</a><span>|</span><label class="collapse" for="c-38077301">[-]</label><label class="expand" for="c-38077301">[1 more]</label></div><br/><div class="children"><div class="content">No, because you&#x27;re not infallible, you&#x27;ll merge some crap, some things that are outright wrong, that your reviewer might have caught and that slight delay is less painful than dealing with that commited mistake - whether it be an incident in production or &#x27;just&#x27; confusion when the next person in that area has to work out if your bug was for some reason intentional and what might break if they fix it.</div><br/></div></div></div></div><div id="38071067" class="c"><input type="checkbox" id="c-38071067" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070836">parent</a><span>|</span><a href="#38071172">prev</a><span>|</span><a href="#38071890">next</a><span>|</span><label class="collapse" for="c-38071067">[-]</label><label class="expand" for="c-38071067">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m challenging my team to actually think about that process, why it&#x27;s in place, how it&#x27;s helping (or actively hurting!) us. Comparing ourselves to companies that have regulatory requirements (spoiler: we don&#x27;t and likely won&#x27;t for a long, long time) just furthers my point that no one really thinks about these things. They just cargo cult how everyone else does it.</div><br/><div id="38071187" class="c"><input type="checkbox" id="c-38071187" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071067">parent</a><span>|</span><a href="#38071890">next</a><span>|</span><label class="collapse" for="c-38071187">[-]</label><label class="expand" for="c-38071187">[1 more]</label></div><br/><div class="children"><div class="content">You can challenge them without actually violating established process. I wasn&#x27;t comparing you to companies that have regulatory requirements, I was merely saying that all of the above will factor in much, much stronger still in a regulated industry.<p>But not being in a regulated industry doesn&#x27;t mean there isn&#x27;t a very good reason to have a code review in your process, assuming it is used effectively and not for nitpicking.<p><i>Not</i> having a code review step is usually a bad idea, unless everybody on your team is of absolutely amazing quality and they never make silly mistakes. I&#x27;ve yet to come across a team like that, but maybe you are the exception to the rule.</div><br/></div></div></div></div><div id="38071890" class="c"><input type="checkbox" id="c-38071890" checked=""/><div class="controls bullet"><span class="by">mgkimsal</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070836">parent</a><span>|</span><a href="#38071067">prev</a><span>|</span><a href="#38071462">next</a><span>|</span><label class="collapse" for="c-38071890">[-]</label><label class="expand" for="c-38071890">[1 more]</label></div><br/><div class="children"><div class="content">Then... the people responsible for this should have blocked PRs without a review.  Or protected the target branch.  Or... something.  If it&#x27;s sacrosanct to do what OP did, but the &#x27;senior&#x27; folks didn&#x27;t put in actual guardrails to prevent it... OP is not entirely at fault.</div><br/></div></div></div></div><div id="38071462" class="c"><input type="checkbox" id="c-38071462" checked=""/><div class="controls bullet"><span class="by">elzbardico</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070522">parent</a><span>|</span><a href="#38070836">prev</a><span>|</span><a href="#38070783">next</a><span>|</span><label class="collapse" for="c-38071462">[-]</label><label class="expand" for="c-38071462">[4 more]</label></div><br/><div class="children"><div class="content">Really man. I have almost two decades developing software and yet, I feel a lot more comfortable having all my code reviewed. If anything I get annoyed by junior developers in my team when they just rub-stamp my PRs because supposedly I am this super senior guy that can&#x27;t err. Code Reviews are supposed to give you peace of mind, not being a hassle.<p>During all this time, I&#x27;ve seen plenty of &quot;small changes&quot; having completely unexpected consequences, and sometimes all it would take to avoid would someone else seeing it from another perspective.</div><br/><div id="38072822" class="c"><input type="checkbox" id="c-38072822" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071462">parent</a><span>|</span><a href="#38072071">next</a><span>|</span><label class="collapse" for="c-38072822">[-]</label><label class="expand" for="c-38072822">[2 more]</label></div><br/><div class="children"><div class="content">At 30 years of coding professionally in great engineering-focused organizations, and that on top of nearly a lifetime of having coded for myself, I’ve concluded code reviews barely work.<p>I agree with everything you say here, but honestly it’s quite ineffective. I wish we had found something better than unit tests (often misleading and fragile) and the ability of a qualified reviewer to maintain attention and context that a real review entails.</div><br/><div id="38079754" class="c"><input type="checkbox" id="c-38079754" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38072822">parent</a><span>|</span><a href="#38072071">next</a><span>|</span><label class="collapse" for="c-38079754">[-]</label><label class="expand" for="c-38079754">[1 more]</label></div><br/><div class="children"><div class="content">IMO catching bugs is a nice side-effect of code reviews.<p>The primary value I&#x27;ve seen across teams has been more on having shared team context across a codebase, if something goes bump in the night you&#x27;ve got a sense on how that part of the codebase works. It&#x27;s also a great opportunity for other engineers to ask &quot;why&quot; and explain parts that aren&#x27;t obvious or other context that&#x27;s relevant. We&#x27;ll find the occasional architectural mismatch(although we like to catch those much earlier in the design process) and certainly prevented bugs from shipping but if that&#x27;s the primary focus I think a team is missing a lot of the value from regular code reviews.</div><br/></div></div></div></div><div id="38072071" class="c"><input type="checkbox" id="c-38072071" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071462">parent</a><span>|</span><a href="#38072822">prev</a><span>|</span><a href="#38070783">next</a><span>|</span><label class="collapse" for="c-38072071">[-]</label><label class="expand" for="c-38072071">[1 more]</label></div><br/><div class="children"><div class="content">Not a man.<p>I’m not convinced bad code would get merged more often if we didn’t require approvals. I am convinced we’d deliver code faster though, and that’s what I’m trying to optimize for. Your company and engineering problems are not the same as mine.</div><br/></div></div></div></div><div id="38070783" class="c"><input type="checkbox" id="c-38070783" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070522">parent</a><span>|</span><a href="#38071462">prev</a><span>|</span><a href="#38070186">next</a><span>|</span><label class="collapse" for="c-38070783">[-]</label><label class="expand" for="c-38070783">[4 more]</label></div><br/><div class="children"><div class="content">Indeed, dogmatic adherence to arbitrary patterns is a huge problem in our field. People have strong beliefs, &quot;X good&quot; or &quot;X bad&quot;, with almost no idea of what X even is, what the alternatives are, why X was something people did or did not like, etc.</div><br/><div id="38070875" class="c"><input type="checkbox" id="c-38070875" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070783">parent</a><span>|</span><a href="#38070186">next</a><span>|</span><label class="collapse" for="c-38070875">[-]</label><label class="expand" for="c-38070875">[3 more]</label></div><br/><div class="children"><div class="content">Another problem is people making decisions with potentially far reaching consequences well above their paygrade without authorization.</div><br/><div id="38071328" class="c"><input type="checkbox" id="c-38071328" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070875">parent</a><span>|</span><a href="#38070186">next</a><span>|</span><label class="collapse" for="c-38071328">[-]</label><label class="expand" for="c-38071328">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that problem is nearly as significant.</div><br/><div id="38071375" class="c"><input type="checkbox" id="c-38071375" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071328">parent</a><span>|</span><a href="#38070186">next</a><span>|</span><label class="collapse" for="c-38071375">[-]</label><label class="expand" for="c-38071375">[1 more]</label></div><br/><div class="children"><div class="content">What you think is usually the limit of your experience, which effectively makes it anecdata. I&#x27;ve looked at enough companies and dealt with the aftermath of enough such instances that I beg to differ. It&#x27;s possible that due to the nature of my business my experience is skewed in the other direction which makes that anecdata as well. But it is probably more important than you think (and less important than I think).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38070186" class="c"><input type="checkbox" id="c-38070186" checked=""/><div class="controls bullet"><span class="by">avelis</span><span>|</span><a href="#38070122">parent</a><span>|</span><a href="#38070389">prev</a><span>|</span><a href="#38074343">next</a><span>|</span><label class="collapse" for="c-38070186">[-]</label><label class="expand" for="c-38070186">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a SISP (solution in search of a problem). Or throwing a solution at a problem not understanding the root issue of it.</div><br/></div></div><div id="38074343" class="c"><input type="checkbox" id="c-38074343" checked=""/><div class="controls bullet"><span class="by">mike_ivanov</span><span>|</span><a href="#38070122">parent</a><span>|</span><a href="#38070186">prev</a><span>|</span><a href="#38077869">next</a><span>|</span><label class="collapse" for="c-38074343">[-]</label><label class="expand" for="c-38074343">[1 more]</label></div><br/><div class="children"><div class="content">I want this printed and neatly framed. Where to order?</div><br/></div></div><div id="38077869" class="c"><input type="checkbox" id="c-38077869" checked=""/><div class="controls bullet"><span class="by">smrtinsert</span><span>|</span><a href="#38070122">parent</a><span>|</span><a href="#38074343">prev</a><span>|</span><a href="#38070217">next</a><span>|</span><label class="collapse" for="c-38077869">[-]</label><label class="expand" for="c-38077869">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always thought of this as the best example of deferred execution.  It&#x27;s surprising how often businesses get it wrong.  I think the problem is most &quot;good&quot; workers are over eager to demonstrate value.  They do that by over engineering and that leads to hell etc...</div><br/></div></div><div id="38070217" class="c"><input type="checkbox" id="c-38070217" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#38070122">parent</a><span>|</span><a href="#38077869">prev</a><span>|</span><a href="#38070112">next</a><span>|</span><label class="collapse" for="c-38070217">[-]</label><label class="expand" for="c-38070217">[27 more]</label></div><br/><div class="children"><div class="content">I find it odd that there is this widespread meme—on HN, not in the industry—that microservices are never justified. I think everyone recognizes that it makes sense that domain name resolution is performed by an external service, and very few people are out there integrating a recursive DNS resolver and cache into their monolith. And yet, this long-standing division of responsibility never seems to count as an example.</div><br/><div id="38070468" class="c"><input type="checkbox" id="c-38070468" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070217">parent</a><span>|</span><a href="#38070380">next</a><span>|</span><label class="collapse" for="c-38070468">[-]</label><label class="expand" for="c-38070468">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re certainly misunderstanding me. Microservices are definitely justifiable in plenty of cases, and _services_ even more often. But they _need to be technically justified_ - that&#x27;s the point I&#x27;m making.<p>The majority of SOA adoption in small-to-medium tech companies is driven by the wrong type of pain, by technical leaders that can see that if they had their domains already split out into services, their problems would not exist, but don&#x27;t understand that reaching that point involves _solving their problems first_.</div><br/><div id="38072966" class="c"><input type="checkbox" id="c-38072966" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070468">parent</a><span>|</span><a href="#38070380">next</a><span>|</span><label class="collapse" for="c-38072966">[-]</label><label class="expand" for="c-38072966">[1 more]</label></div><br/><div class="children"><div class="content">Whenever someone on the projects, I’m attached to tries to create a new service, first I asked them what data it works with, and then I ask them what the alternative to making this a service would be. Usually, by the time we start answering the second question, they realize that, actually, adding the service is just more work.<p>To me, what’s amazing is that in almost no organization is there a requirement to justify technically the addition of a new service, despite the cost and administrative and cognitive overhead of doing so.</div><br/></div></div></div></div><div id="38070380" class="c"><input type="checkbox" id="c-38070380" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070217">parent</a><span>|</span><a href="#38070468">prev</a><span>|</span><a href="#38070361">next</a><span>|</span><label class="collapse" for="c-38070380">[-]</label><label class="expand" for="c-38070380">[10 more]</label></div><br/><div class="children"><div class="content">_Services_ are obviously a good idea (nobody is arguing something like PostgreSQL or Redis or DNS or what have you should all run in the same process as the web server).<p>_Microservices_ attract the criticism. It seems to assume something about the optimal size of services (&quot;micro&quot;) that probably isn&#x27;t optimal for all kinds of service you can think of.</div><br/><div id="38070463" class="c"><input type="checkbox" id="c-38070463" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070380">parent</a><span>|</span><a href="#38070419">next</a><span>|</span><label class="collapse" for="c-38070463">[-]</label><label class="expand" for="c-38070463">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny because the term &quot;microservices&quot; picked up in popularity because previously, most &quot;service-oriented architecture&quot; (the old term) implementations in large companies had services that were worked on by dozens or hundreds of developers, at least in my experience. So going from that to services that were worked on by a single development team of ~10 people was indeed a &quot;microservice&quot; relatively speaking.<p>Now, thanks to massive changes in how software is built (cloud, containers et al) it&#x27;s a lot more standard for a normal &quot;service&quot; with no prefix to be built by a small team of developers, no micro- prefix needed.</div><br/><div id="38070612" class="c"><input type="checkbox" id="c-38070612" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070463">parent</a><span>|</span><a href="#38072423">next</a><span>|</span><label class="collapse" for="c-38070612">[-]</label><label class="expand" for="c-38070612">[2 more]</label></div><br/><div class="children"><div class="content">I can understand wanting to split things off so that one team handles one service, roughly.<p>There was a recent thread here where someone mentioned he personally was responsible for about four of their microservices...</div><br/><div id="38070700" class="c"><input type="checkbox" id="c-38070700" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070612">parent</a><span>|</span><a href="#38072423">next</a><span>|</span><label class="collapse" for="c-38070700">[-]</label><label class="expand" for="c-38070700">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, my last company had 10 microservices (the entirety of their codebase) managed by a single team when I started. Some of them had fewer than 5 API endpoints (and weren&#x27;t doing anything complex to justify that).</div><br/></div></div></div></div></div></div><div id="38070419" class="c"><input type="checkbox" id="c-38070419" checked=""/><div class="controls bullet"><span class="by">xnorswap</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070380">parent</a><span>|</span><a href="#38070463">prev</a><span>|</span><a href="#38072200">next</a><span>|</span><label class="collapse" for="c-38070419">[-]</label><label class="expand" for="c-38070419">[3 more]</label></div><br/><div class="children"><div class="content">That may be true, but the article describes a services architecture and labels it microservices, indeed goes onto to say:<p>&gt; The term micro can be misleading, though - there doesn’t have to be anything micro about the services</div><br/><div id="38070587" class="c"><input type="checkbox" id="c-38070587" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070419">parent</a><span>|</span><a href="#38072200">next</a><span>|</span><label class="collapse" for="c-38070587">[-]</label><label class="expand" for="c-38070587">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but the &quot;widespread meme&quot; as I see it is about microservices, not services in general.</div><br/><div id="38071159" class="c"><input type="checkbox" id="c-38071159" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070587">parent</a><span>|</span><a href="#38072200">next</a><span>|</span><label class="collapse" for="c-38071159">[-]</label><label class="expand" for="c-38071159">[1 more]</label></div><br/><div class="children"><div class="content">The smaller the service, the more likely that the overhead of having a separate service exceeds the benefit of doing so. It isn&#x27;t at all normal for a service to have its own database unless it provides a substantial piece of functionality, for example, and there are non-trivial costs to splitting databases unnecessarily.  If you are not very careful, it is a good way to make certain things a dozen times slower and a dozen times more expensive to develop.</div><br/></div></div></div></div></div></div><div id="38072200" class="c"><input type="checkbox" id="c-38072200" checked=""/><div class="controls bullet"><span class="by">arethuza</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070380">parent</a><span>|</span><a href="#38070419">prev</a><span>|</span><a href="#38071208">next</a><span>|</span><label class="collapse" for="c-38072200">[-]</label><label class="expand" for="c-38072200">[1 more]</label></div><br/><div class="children"><div class="content">You do see people arguing for running SQLite in-process rather than using a separate database server like PostgreSQL?</div><br/></div></div><div id="38071208" class="c"><input type="checkbox" id="c-38071208" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070380">parent</a><span>|</span><a href="#38072200">prev</a><span>|</span><a href="#38070361">next</a><span>|</span><label class="collapse" for="c-38071208">[-]</label><label class="expand" for="c-38071208">[1 more]</label></div><br/><div class="children"><div class="content">This seems subjective. It&#x27;s like putting &quot;compatible with the character of the neighborhood&quot; in a city&#x27;s zoning codes.</div><br/></div></div></div></div><div id="38070361" class="c"><input type="checkbox" id="c-38070361" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070217">parent</a><span>|</span><a href="#38070380">prev</a><span>|</span><a href="#38070416">next</a><span>|</span><label class="collapse" for="c-38070361">[-]</label><label class="expand" for="c-38070361">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I find it odd that there is this widespread meme—on HN, not in the industry—that microservices are never justified.<p>There&#x27;s a few things in play IMO.<p>One is lack of definition -- what&#x27;s a &quot;microservice&quot; anyhow? Netflix popularized the idea of microservices literally being a few hundred lines of code maintained by a single developer, and some people believe that&#x27;s what a microservice is. Others are more lax and see microservices as being maintained by small (4-10 person) development teams.<p>Another is that most people have not worked at a place where microservices were done well, because they were implemented by CTOs and &quot;software architects&quot; with no experience at companies with 10 developers. There are a lot of problems that come from doing microservices poorly, particularly around building distributed monoliths and operational overhead. It&#x27;s definitely preferable to have a poorly-built monolith than poorly-built microservice architectures.<p>I&#x27;ve been at 4 companies that did microservices (in my definition, which is essentially one service per dev team). Three were a great development experience and dev&#x2F;deploy velocity was excellent. One was a total clusterfuck.</div><br/><div id="38070455" class="c"><input type="checkbox" id="c-38070455" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070361">parent</a><span>|</span><a href="#38070416">next</a><span>|</span><label class="collapse" for="c-38070455">[-]</label><label class="expand" for="c-38070455">[4 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t lack a definition, there&#x27;s lots of people talking about this. In general you&#x27;ll find something like &quot;a small service that solves one problem within a single bounded context&quot;.<p>&gt; It&#x27;s definitely preferable to have a poorly-built monolith than poorly-built microservice architectures.<p>I don&#x27;t know about &quot;definitely&quot; at all. Having worked with some horrible monoliths, I really don&#x27;t think I agree. Microservices can be done poorly but at minimum there&#x27;s a fundamental isolation of components. If you don&#x27;t have any isolation of components it was never even close to microservices&#x2F;SoA, at which point, is it really a fair criticism?</div><br/><div id="38070699" class="c"><input type="checkbox" id="c-38070699" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070455">parent</a><span>|</span><a href="#38070416">next</a><span>|</span><label class="collapse" for="c-38070699">[-]</label><label class="expand" for="c-38070699">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It doesn&#x27;t lack a definition, there&#x27;s lots of people talking about this. In general you&#x27;ll find something like &quot;a small service that solves one problem within a single bounded context&quot;.<p>How small is small? Even within this comment section there are people talking about a single developer being the sole maintainer of multiple microservices. I&#x27;m a strong advocate of (micro?)service architecture but I would never recommend doing the &quot;all behavior is 100-line lambda functions&quot; approach.<p>A horrible monolith vs horrible microservices is subjective, of course, but IMO having everything self-contained to one repository, one collection of app servers, etc. at least gives you some <i>hope</i> of salvation, often by building new functionality in separate services, ironically. Horrible microservices that violate data boundaries, i.e. multiple services sharing a database which is a sadly common mistake, is a much harder problem to solve. (both are bad, of course!)</div><br/><div id="38071033" class="c"><input type="checkbox" id="c-38071033" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070699">parent</a><span>|</span><a href="#38070416">next</a><span>|</span><label class="collapse" for="c-38071033">[-]</label><label class="expand" for="c-38071033">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Small&quot; is a relative term, and not an ideal one, but what it generally means is &quot;no larger than is needed&quot; - that is, if you have one concrete solution within a bounded context, &quot;small&quot; is the code necessary to implement that solution. It&#x27;s not a matter of LOC.<p>&gt; IMO having everything self-contained to one repository<p>I highly recommend keeping all microservices in a single repository. It&#x27;s even more important in a microservice world to ensure that you can update dependencies across your organization atomically.<p>&gt;  Horrible microservices that violate data boundaries, i.e. multiple services sharing a database which is a sadly common mistake, is a much harder problem to solve.<p>But that&#x27;s not microservices. Maybe this is in and of itself an issue of microservice architecture, the fact that people think they&#x27;re implementing microservices when they&#x27;re actually just doing SoA, but microservice architecture would absolutely <i>not</i> include multiple services with a single database, that would <i>not be</i> microservices.<p>So I think the criticism would be &quot;people find it hard to actually implement microservices&quot; and not &quot;microservice architecture leads to these problems&quot;, because microservice architecture is going to steer you <i>away</i> from multiple services using one database.</div><br/><div id="38071697" class="c"><input type="checkbox" id="c-38071697" checked=""/><div class="controls bullet"><span class="by">sally_glance</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071033">parent</a><span>|</span><a href="#38070416">next</a><span>|</span><label class="collapse" for="c-38071697">[-]</label><label class="expand" for="c-38071697">[1 more]</label></div><br/><div class="children"><div class="content">A little off topic but there are even more sinister patterns than the shared database which some architects are actively advocating for, like<p>1. The &quot;data service&quot; layer, which (if done improperly) is basically just a worse SQL implemented on top of HTTP but still centralised. Though now you can claim it&#x27;s a shared service instead of a DB.<p>2. The &quot;fat cache&quot; database - especially common in strongly event-based systems. Basically every service decides to store whatever it needs from events to have lower latency access for common data. Sounds great but in practice leads to (undocumented) duplicate data, which theoretically should be synchronised but since those service-local mirror DBs are usually introduced without central coordination it&#x27;s bound to desync at some point.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38070416" class="c"><input type="checkbox" id="c-38070416" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070217">parent</a><span>|</span><a href="#38070361">prev</a><span>|</span><a href="#38070708">next</a><span>|</span><label class="collapse" for="c-38070416">[-]</label><label class="expand" for="c-38070416">[3 more]</label></div><br/><div class="children"><div class="content">DNS resolution is genuninely reusable, though. Perhaps that&#x27;s the test: is this something that could concievably be used by others, as a product in itself, or is it tied very heavily to the business and the rest of the &quot;microservices&quot;?<p>Remember this is how AWS was born, as a set of &quot;microservices&quot; which could start being sold to external customers, like &quot;storage&quot;.</div><br/><div id="38071333" class="c"><input type="checkbox" id="c-38071333" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070416">parent</a><span>|</span><a href="#38070708">next</a><span>|</span><label class="collapse" for="c-38071333">[-]</label><label class="expand" for="c-38071333">[2 more]</label></div><br/><div class="children"><div class="content">What about a mailer that&#x27;s divided into the SMTP server and the local delivery agent?</div><br/><div id="38075776" class="c"><input type="checkbox" id="c-38075776" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38071333">parent</a><span>|</span><a href="#38070708">next</a><span>|</span><label class="collapse" for="c-38075776">[-]</label><label class="expand" for="c-38075776">[1 more]</label></div><br/><div class="children"><div class="content">qmail probably counts as &quot;microservices&quot; as well, yes. In that case, for security separation of authority in a multi-user environment. Nowadays we don&#x27;t really do multi-user environments and separation would be by container.</div><br/></div></div></div></div></div></div><div id="38070708" class="c"><input type="checkbox" id="c-38070708" checked=""/><div class="controls bullet"><span class="by">rqtwteye</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070217">parent</a><span>|</span><a href="#38070416">prev</a><span>|</span><a href="#38070377">next</a><span>|</span><label class="collapse" for="c-38070708">[-]</label><label class="expand" for="c-38070708">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I find it odd that there is this widespread meme—on HN, not in the industry—that microservices are never justified&quot;<p>I think the problem is the word &quot;micro&quot;. At my company I see a lot of projects that are run by three devs that and have 13 microservices. They are easy to develop but the maintenance overhead is enormous. And they never get shared between projects so you have 5 services that do basically the same.</div><br/></div></div><div id="38070933" class="c"><input type="checkbox" id="c-38070933" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070217">parent</a><span>|</span><a href="#38070377">prev</a><span>|</span><a href="#38070479">next</a><span>|</span><label class="collapse" for="c-38070933">[-]</label><label class="expand" for="c-38070933">[2 more]</label></div><br/><div class="children"><div class="content">I rarely see anyone claiming that microservices are never justified. I think the general attitude toward them is due to the amount of Resume Driven Development that happens in the real world.</div><br/><div id="38074081" class="c"><input type="checkbox" id="c-38074081" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070933">parent</a><span>|</span><a href="#38070479">next</a><span>|</span><label class="collapse" for="c-38074081">[-]</label><label class="expand" for="c-38074081">[1 more]</label></div><br/><div class="children"><div class="content">Eh, I think a lot more of it is caused by optimism than RDD - people who haven&#x27;t _tried to do it_ look at the mess they&#x27;ve got, and they can see that if it were divided into domain-based services it would be less of a mess.<p>And the process seems almost straightforward until you _actually try to do it_, and find out that it&#x27;s actually fractally difficult - by that point you&#x27;ve committed your organization and your reputation to the task, and &quot;hey, that was a mistake, oops&quot; _after_ you&#x27;ve sunk that kind of organizational resources into such a project is a kind of professional suicide.</div><br/></div></div></div></div><div id="38070479" class="c"><input type="checkbox" id="c-38070479" checked=""/><div class="controls bullet"><span class="by">mdekkers</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070217">parent</a><span>|</span><a href="#38070933">prev</a><span>|</span><a href="#38072897">next</a><span>|</span><label class="collapse" for="c-38070479">[-]</label><label class="expand" for="c-38070479">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find it odd that there is this widespread meme—on HN, not in the industry—that microservices are never justified.<p>Many HN patrons are actually working where the rubber meets the road.<p>DNS is a poor comparison. Pretty much everything, related to your application or not, needs DNS. On the other hand, the only thing WNGMAN[0]may or may not do, is help with finding the user’s DOB.<p><a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=y8OnoxKotPQ">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=y8OnoxKotPQ</a></div><br/></div></div><div id="38072897" class="c"><input type="checkbox" id="c-38072897" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#38070122">root</a><span>|</span><a href="#38070217">parent</a><span>|</span><a href="#38070479">prev</a><span>|</span><a href="#38070112">next</a><span>|</span><label class="collapse" for="c-38072897">[-]</label><label class="expand" for="c-38072897">[1 more]</label></div><br/><div class="children"><div class="content">Can you point to a comment on HN saying microservices are never justified?</div><br/></div></div></div></div></div></div><div id="38070112" class="c"><input type="checkbox" id="c-38070112" checked=""/><div class="controls bullet"><span class="by">jihadjihad</span><span>|</span><a href="#38070122">prev</a><span>|</span><a href="#38072226">next</a><span>|</span><label class="collapse" for="c-38070112">[-]</label><label class="expand" for="c-38070112">[52 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Microservices
    
    grug wonder why big brain take hardest problem, factoring system correctly, and introduce network call too

    seem very confusing to grug
</code></pre>
<a href="https:&#x2F;&#x2F;grugbrain.dev&#x2F;#grug-on-microservices" rel="nofollow noreferrer">https:&#x2F;&#x2F;grugbrain.dev&#x2F;#grug-on-microservices</a></div><br/><div id="38070185" class="c"><input type="checkbox" id="c-38070185" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#38070112">parent</a><span>|</span><a href="#38071651">next</a><span>|</span><label class="collapse" for="c-38070185">[-]</label><label class="expand" for="c-38070185">[34 more]</label></div><br/><div class="children"><div class="content">grug not experience large teams stepping on each other&#x27;s domains and data models, locking in a given implementation and requiring large, organizational efforts to to get features out at the team level. Team velocity is empowered via microservices and controlling their own data stores.<p>&quot;We want to modernize how we access our FOO_TABLE for SCALE_REASONS by moving it to DynamoDB out of MySQL - unfortunately, 32 of our 59 teams are directly accessing the FOO_TABLE or directly accessing private methods on our classes. Due to competing priorities, those teams cannot do the work to move to using our FOO_SERVICE and they can&#x27;t change their query method to use a sharded table. To scale our FOO_TABLE will now be a multi-quarter effort providing the ability for teams to slow roll their update. After a year or two, we should be able to retire the old method that is on fire right now. In the meanwhile, enjoy oncall.&quot;<p>Compare this to a microservice: Team realizes their table wont scale, but their data is provided via API. They plan and execute the migration next sprint. Users of the API report that it is now much faster.</div><br/><div id="38070220" class="c"><input type="checkbox" id="c-38070220" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070185">parent</a><span>|</span><a href="#38078550">next</a><span>|</span><label class="collapse" for="c-38070220">[-]</label><label class="expand" for="c-38070220">[15 more]</label></div><br/><div class="children"><div class="content">&gt; Team velocity is empowered via microservices and controlling their own data stores.<p>Bologna.  Choosing clear abstractions is an enabler of focus, but that doesn’t necessarily imply those abstractions are a network call away.</div><br/><div id="38070334" class="c"><input type="checkbox" id="c-38070334" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070220">parent</a><span>|</span><a href="#38078550">next</a><span>|</span><label class="collapse" for="c-38070334">[-]</label><label class="expand" for="c-38070334">[14 more]</label></div><br/><div class="children"><div class="content">our team of 300 - we _can&#x27;t_ enforce the clear abstractions. New dev gets hired, team feels pressured to deliver despite leadership saying to prioritize quality, they are not aware of all the access controls, they push a PR, it gets merged.<p>We have an org wide push to get more linting and more checks in place. The damage is done and now we have a multi-quarter effort to re-organize all our code.<p>This _can_ be enforced via well designed modules. I&#x27;ve just not seen that succeed. Anywhere. Microservices are a pain for smaller teams and you have to have CI and observability and your pains shift and are different. But for stepping on eachother? I&#x27;ve found microservices to be a super power for velocity in these cases. Can microservices be a shitshow? Absolutely, esp. when they share data stores or have circular dependencies. They also allow teams to be uncoupled assuming they don&#x27;t break their API.</div><br/><div id="38070470" class="c"><input type="checkbox" id="c-38070470" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070334">parent</a><span>|</span><a href="#38071396">next</a><span>|</span><label class="collapse" for="c-38070470">[-]</label><label class="expand" for="c-38070470">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; leadership saying to prioritize quality</i><p>Well, that&#x27;s different.<p>My experience is that &quot;leadership&quot; often finds quality to be expensive and unnecessary overhead.<p>That&#x27;s one reason that I stayed at a company that took Quality seriously. It introduced many issues that folks, hereabouts would find unbearable, but they consistently shipped some of the highest-Quality (and expensive) kit in the world.<p>Quality is not cheap, and it is not easy. It is also not really the path to riches, so it is often actively discouraged by managers.</div><br/></div></div><div id="38071396" class="c"><input type="checkbox" id="c-38071396" checked=""/><div class="controls bullet"><span class="by">Pet_Ant</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070334">parent</a><span>|</span><a href="#38070470">prev</a><span>|</span><a href="#38070792">next</a><span>|</span><label class="collapse" for="c-38071396">[-]</label><label class="expand" for="c-38071396">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  we _can&#x27;t_ enforce the clear abstractions<p>Really, you can&#x27;t? Then I struggle to see how&#x27;ll get anything else right. I&#x27;ve done it by using separate build scripts. That way only the interfaces and domain objects are exposed in the libraries. Now you lock down at the repository level access to each sub-project to the team working on it. There you go: modularity, boundaries, all without network hops.</div><br/><div id="38071728" class="c"><input type="checkbox" id="c-38071728" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071396">parent</a><span>|</span><a href="#38070792">next</a><span>|</span><label class="collapse" for="c-38071728">[-]</label><label class="expand" for="c-38071728">[2 more]</label></div><br/><div class="children"><div class="content">sure - if you do that from the start. Most don&#x27;t. The codebase organically grows and then lines are blurred and then you have to come in and refactor. When this refactor affects several teams, it gets harder in combinatorial fashion.<p>With an HTTP API boundary, you don&#x27;t get to reach into my code - it is literally impossible.</div><br/><div id="38073722" class="c"><input type="checkbox" id="c-38073722" checked=""/><div class="controls bullet"><span class="by">ndriscoll</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071728">parent</a><span>|</span><a href="#38070792">next</a><span>|</span><label class="collapse" for="c-38073722">[-]</label><label class="expand" for="c-38073722">[1 more]</label></div><br/><div class="children"><div class="content">But the work required to factor things out behind an HTTP boundary is a superset of the work required to factor things out into a module as GP describes. So if you <i>were</i> going to do microservices, you could do that same factoring and then just stop when you get to the part where you&#x27;d add in networking and deployment scripts.</div><br/></div></div></div></div></div></div><div id="38070792" class="c"><input type="checkbox" id="c-38070792" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070334">parent</a><span>|</span><a href="#38071396">prev</a><span>|</span><a href="#38072540">next</a><span>|</span><label class="collapse" for="c-38070792">[-]</label><label class="expand" for="c-38070792">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They also allow teams to be uncoupled assuming they don&#x27;t break their API.<p>Presumably you would still need tooling to enforce teams not breaking their API, and also to prevent people just modifying services to expose private internals that should not be part of the public API?</div><br/></div></div><div id="38072540" class="c"><input type="checkbox" id="c-38072540" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070334">parent</a><span>|</span><a href="#38070792">prev</a><span>|</span><a href="#38070914">next</a><span>|</span><label class="collapse" for="c-38072540">[-]</label><label class="expand" for="c-38072540">[6 more]</label></div><br/><div class="children"><div class="content">How the whole open source ecosystem is working fine and delivering software while depending upon each other for almost decades all the while not ever being in the same room and yet having no microservices?<p>I mean take your pick, anything open source be it desktop or web has a huge and deep dependency tree all the way down to libc.<p>Just wondering.<p>EDIT: Typos and desktop.</div><br/><div id="38073173" class="c"><input type="checkbox" id="c-38073173" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38072540">parent</a><span>|</span><a href="#38073768">next</a><span>|</span><label class="collapse" for="c-38073173">[-]</label><label class="expand" for="c-38073173">[2 more]</label></div><br/><div class="children"><div class="content">Someone does the integration work for you, that’s why it works. Try running some distro that just grabs the latest upstream versions and see how often things break.</div><br/><div id="38073981" class="c"><input type="checkbox" id="c-38073981" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38073173">parent</a><span>|</span><a href="#38073768">next</a><span>|</span><label class="collapse" for="c-38073981">[-]</label><label class="expand" for="c-38073981">[1 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s my point.</div><br/></div></div></div></div><div id="38073768" class="c"><input type="checkbox" id="c-38073768" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38072540">parent</a><span>|</span><a href="#38073173">prev</a><span>|</span><a href="#38070914">next</a><span>|</span><label class="collapse" for="c-38073768">[-]</label><label class="expand" for="c-38073768">[3 more]</label></div><br/><div class="children"><div class="content">Open source projects rarely involve live services, or providing SaaS. In those situations I think microservices are much more helpful</div><br/><div id="38073991" class="c"><input type="checkbox" id="c-38073991" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38073768">parent</a><span>|</span><a href="#38070914">next</a><span>|</span><label class="collapse" for="c-38073991">[-]</label><label class="expand" for="c-38073991">[2 more]</label></div><br/><div class="children"><div class="content">But Microservices have nothing to do with scaling or deployment. The main selling point is that it scales across teams etc?</div><br/><div id="38074216" class="c"><input type="checkbox" id="c-38074216" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38073991">parent</a><span>|</span><a href="#38070914">next</a><span>|</span><label class="collapse" for="c-38074216">[-]</label><label class="expand" for="c-38074216">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a bit of both IME. It helps a lot with deployment across teams.</div><br/></div></div></div></div></div></div></div></div><div id="38070914" class="c"><input type="checkbox" id="c-38070914" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070334">parent</a><span>|</span><a href="#38072540">prev</a><span>|</span><a href="#38071128">next</a><span>|</span><label class="collapse" for="c-38070914">[-]</label><label class="expand" for="c-38070914">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t really retrofit culture and behavior, you can only very gradually move towards a particular goal and usually that&#x27;s a multi-year effort, if it can be done at all.</div><br/></div></div><div id="38071128" class="c"><input type="checkbox" id="c-38071128" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070334">parent</a><span>|</span><a href="#38070914">prev</a><span>|</span><a href="#38078550">next</a><span>|</span><label class="collapse" for="c-38071128">[-]</label><label class="expand" for="c-38071128">[1 more]</label></div><br/><div class="children"><div class="content">If you want to change that model, there&#x27;s three things that need to happen:<p>1) engineering needs a reason to embrace abstraction. Because the only thing that stops a new cowboy engineer is their peers explaining to them in what ways this isn&#x27;t the Wild Wesst. One can assume if rules would benefit the team, they&#x27;d be doing them already, so why don&#x27;t they? Maybe they perceive feature output velocity to be too high to risk changing method. Maybe decisionmaking power rests in the hands of one system architect who is holding the whole machine in their head so things that look complex to others seem simple to them (in that case, the team needs to spread around peer review signoff responsibilities on purpose, so one engineer <i>can&#x27;t</i> be the decisionmaker and the architecture itself <i>must</i> self-describe). Maybe (this is how I see it usually happen) they were a three-person startup and complexity crept up on them like a boiling frog. Whatever the reason, if you&#x27;re gonna convince them otherwise, someone&#x27;s gonna have to generate hard data on how changing the abstraction could make their jobs easier.<p>2) If management has no idea what &quot;prioritize quality&quot; means (meaning no metrics by which to measure it and no real grasp of the art of software engineering), the engineers will interpret buzzwords as noise and route around them. Management needs to give actionable goals <i>other</i> than &quot;release feature X by Y date&quot; if they want to change engineering culture. That can take many forms (I&#x27;ve seen <i>rewarded</i> fixit weeks and externally-reported issue burndown charts as two good examples).<p>3) Engineering leadership needs time and bandwidth to do training so they can see outside their prairie-dog hole over to how other teams solve problems. Otherwise, they get locked into the solutions they know, and the only way new approaches ever enter the team is by hires.<p>And the key thing is: microservices may not <i>be</i> the tool for the job when all is said and done. This is an approach to give your engineering team ways to discover the right patterns, not to trick them into doing microservices. Your engineering team, at the end of the day, is still the best-equipped people to know the machinery of the product and how to shape it.</div><br/></div></div></div></div></div></div><div id="38078550" class="c"><input type="checkbox" id="c-38078550" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070185">parent</a><span>|</span><a href="#38070220">prev</a><span>|</span><a href="#38077086">next</a><span>|</span><label class="collapse" for="c-38078550">[-]</label><label class="expand" for="c-38078550">[1 more]</label></div><br/><div class="children"><div class="content">Or how about &quot;we want to update a 3rd party library due to a critical security issue, but we can&#x27;t because that library is used in 500 different parts of the code and no way in hell can we stop development across the entire org for multiple weeks&quot;.<p>With microservices, you deploy the updates to public facing services first, write any learnings down, pass it along to the next most vulnerable tier.<p>Heck on multiple occasions I&#x27;ve been part of projects where just updating the build system for a monolithic codebase was a year+ long effort involving dozens of engineers trying to work around commits from everyone else.<p>Compare this to a microservice model where you just declare all new services get the new build tools. If the new tools come with a large enough carrot (e.g. new version of typescript) teams may very well update their own build tooling to the latest stuff without anyone even asking them to!</div><br/></div></div><div id="38077086" class="c"><input type="checkbox" id="c-38077086" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070185">parent</a><span>|</span><a href="#38078550">prev</a><span>|</span><a href="#38072544">next</a><span>|</span><label class="collapse" for="c-38077086">[-]</label><label class="expand" for="c-38077086">[1 more]</label></div><br/><div class="children"><div class="content">Microservices don&#x27;t magically fix shared schema headaches. Getting abstraction and APIs right is the solution regardless of whether it&#x27;s in-memory or over the network.<p>Instead of microservices, you could add a static analysis build step that checks if code in packages is calling private or protected interfaces in different packages. That would also help enforce service boundaries without introducing the network as the boundary.</div><br/></div></div><div id="38072544" class="c"><input type="checkbox" id="c-38072544" checked=""/><div class="controls bullet"><span class="by">sally_glance</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070185">parent</a><span>|</span><a href="#38077086">prev</a><span>|</span><a href="#38070282">next</a><span>|</span><label class="collapse" for="c-38072544">[-]</label><label class="expand" for="c-38072544">[1 more]</label></div><br/><div class="children"><div class="content">This applies to performance optimizations which leave the interface untouched, but there are other scenarios, for example:<p>- Performance optimizations which can&#x27;t be realized without changing the interface model. For example, FOO_TABLE should actually be BAR and BAZ with different update patterns to allow for efficient caching and querying.<p>- Domain model updates, adding&#x2F;updating&#x2F;removing new properties or entities.<p>This kind of update will still require the 32 consumers to upgrade. The API-based approach has benefits in terms of the migration process and backwards-compatibility though (a HTTP API is much easier to version than a DB schema, although you can also do this on the DB level by only allowing queries on views).</div><br/></div></div><div id="38070282" class="c"><input type="checkbox" id="c-38070282" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070185">parent</a><span>|</span><a href="#38072544">prev</a><span>|</span><a href="#38073437">next</a><span>|</span><label class="collapse" for="c-38070282">[-]</label><label class="expand" for="c-38070282">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Team realizes their table wont scale, but their data is provided via API. They plan and execute the migration next sprint.<p>... followed by howls of anguish from the rest of the business when it turns out they were relying on reports generated from a data warehouse which incorporated a copy of that MySQL database and was being populated by an undocumented, not-in-version-control cron script running on a PC under a long-departed team member&#x27;s desk.<p>(I&#x27;m not saying this is good, but it&#x27;s not an unlikely scenario.)</div><br/><div id="38070635" class="c"><input type="checkbox" id="c-38070635" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070282">parent</a><span>|</span><a href="#38070430">next</a><span>|</span><label class="collapse" for="c-38070635">[-]</label><label class="expand" for="c-38070635">[3 more]</label></div><br/><div class="children"><div class="content">&gt; they were relying on reports generated from a data warehouse which incorporated a copy of that MySQL database and was being populated by an undocumented, not-in-version-control cron script running on a PC under a long-departed team member&#x27;s desk.<p>This definitely happens but at some point someone with authority needs to show technical leadership and say &quot;you cannot do this no matter how desperately you need those reports.&quot; If you don&#x27;t have anyone in your org who can do that, you&#x27;re screwed regardless.</div><br/><div id="38070788" class="c"><input type="checkbox" id="c-38070788" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070635">parent</a><span>|</span><a href="#38070430">next</a><span>|</span><label class="collapse" for="c-38070788">[-]</label><label class="expand" for="c-38070788">[2 more]</label></div><br/><div class="children"><div class="content">A lot of organizations are screwed.</div><br/><div id="38071634" class="c"><input type="checkbox" id="c-38071634" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070788">parent</a><span>|</span><a href="#38070430">next</a><span>|</span><label class="collapse" for="c-38071634">[-]</label><label class="expand" for="c-38071634">[1 more]</label></div><br/><div class="children"><div class="content">I do agree with that. Microservices are <i>not</i> a good idea whatsoever for organizations with weak senior technical people. Which is probably 90%+ of businesses.</div><br/></div></div></div></div></div></div><div id="38070430" class="c"><input type="checkbox" id="c-38070430" checked=""/><div class="controls bullet"><span class="by">mason55</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070282">parent</a><span>|</span><a href="#38070635">prev</a><span>|</span><a href="#38070574">next</a><span>|</span><label class="collapse" for="c-38070430">[-]</label><label class="expand" for="c-38070430">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>... followed by howls of anguish from the rest of the business when it turns out they were relying on reports generated from a data warehouse which incorporated a copy of that MySQL database and was being populated by an undocumented, not-in-version-control cron script running on a PC under a long-departed team member&#x27;s desk.</i><p>Once you get to this point, there&#x27;s no path forward.  Either you have to making some breaking changes or your product is calcified at that point.<p>If this is a real concern then you should be asking what you can do to keep from getting into that state, and the answer is encapsulating services in defined interfaces&#x2F;boundaries that are small enough that the team understands everything going on in the critical database layer.</div><br/></div></div><div id="38070574" class="c"><input type="checkbox" id="c-38070574" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070282">parent</a><span>|</span><a href="#38070430">prev</a><span>|</span><a href="#38070347">next</a><span>|</span><label class="collapse" for="c-38070574">[-]</label><label class="expand" for="c-38070574">[1 more]</label></div><br/><div class="children"><div class="content">This was why the &quot;if you breach the service boundary you&#x27;re fired&quot; Amazon memo was issued.</div><br/></div></div><div id="38070347" class="c"><input type="checkbox" id="c-38070347" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070282">parent</a><span>|</span><a href="#38070574">prev</a><span>|</span><a href="#38073437">next</a><span>|</span><label class="collapse" for="c-38070347">[-]</label><label class="expand" for="c-38070347">[4 more]</label></div><br/><div class="children"><div class="content">another reason why you provide data only over API - don&#x27;t reach into my tables and lock me into an implementation.</div><br/><div id="38071102" class="c"><input type="checkbox" id="c-38071102" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070347">parent</a><span>|</span><a href="#38073437">next</a><span>|</span><label class="collapse" for="c-38071102">[-]</label><label class="expand" for="c-38071102">[3 more]</label></div><br/><div class="children"><div class="content">An approach I like better than &quot;only access my data via API&quot; is this:<p>The team that maintains the service is also responsible for how that service is represented in the data warehouse.<p>The data warehouse tables - effectively denormalized copies of the data that the service stores - are treated as another API contract - they are clearly documented and tested as such.<p>If the team refactors, they also update the scripts that populate the data warehouse.<p>If that results in specific columns etc becoming invalid they document that in their release notes, and ideally notify other affected teams.</div><br/><div id="38071474" class="c"><input type="checkbox" id="c-38071474" checked=""/><div class="controls bullet"><span class="by">hermanradtke</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071102">parent</a><span>|</span><a href="#38073437">next</a><span>|</span><label class="collapse" for="c-38071474">[-]</label><label class="expand" for="c-38071474">[2 more]</label></div><br/><div class="children"><div class="content">This same thing can be applied to contracts when firing events, etc. I point people to <a href="https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-what-every-software-engineer-should-know-about-real-time-datas-unifying" rel="nofollow noreferrer">https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-wha...</a> and use the same approach to ownership.</div><br/><div id="38071577" class="c"><input type="checkbox" id="c-38071577" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071474">parent</a><span>|</span><a href="#38073437">next</a><span>|</span><label class="collapse" for="c-38071577">[-]</label><label class="expand" for="c-38071577">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, having a documented stream of published events in Kafka is a similar API contract the team can be responsible for - it might even double as the channel through which the data warehouse is populated.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38073437" class="c"><input type="checkbox" id="c-38073437" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070185">parent</a><span>|</span><a href="#38070282">prev</a><span>|</span><a href="#38070970">next</a><span>|</span><label class="collapse" for="c-38073437">[-]</label><label class="expand" for="c-38073437">[2 more]</label></div><br/><div class="children"><div class="content">Found the author of CISCO &#x2F; Java Spring documentation.<p>I honestly expected people used passive-aggressive corpo-slang only for work &#x2F; ironically.  But this reads intentionally obfuscated.<p>But, to answer to the substance: you for some reason assumed that whoever designed first solution was an idiot and whoever designed the second was, at least clairvoyant.<p>The problem you describe isn&#x27;t a result of inevitable design decisions.  You just described a situation where someone screwed up doing something and didn&#x27;t screw up doing something else.  And that led you to believe that whatever that something else is, it&#x27;s easier to design.<p>The reality of the situation is, unfortunately, the reverse.  Upgrading microservices is much harder than replacing components in monolithic systems because it&#x27;s easier to discover all users of the feature.  There are, in general, fewer components in monolithic systems, so less things will need to change.  Deployment of a monolithic system will be much more likely to discover problems created by incorrectly implemented upgrade.<p>In my experience of dealing with both worlds, microservices tend to create a maze-like system where nobody can be sure if any change will not adversely affect some other part of the system due to the distributed and highly fragmented nature of such systems.  So, your ideas about upgrades are uncorroborated by practice.  If you want to be able to update with more ease, you should choose a smaller, more cohesive system.</div><br/><div id="38076402" class="c"><input type="checkbox" id="c-38076402" checked=""/><div class="controls bullet"><span class="by">perrylaj</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38073437">parent</a><span>|</span><a href="#38070970">next</a><span>|</span><label class="collapse" for="c-38076402">[-]</label><label class="expand" for="c-38076402">[1 more]</label></div><br/><div class="children"><div class="content">I think I view the situation in a similar fashion as you.  There&#x27;s absolutely nothing preventing a well architected modular monolith from establishing domain&#x2F;module-specific persistence that is accessible only through APIs and connectable only through the owning domain&#x2F;module.  To accomplish that requires a decent application designer&#x2F;architect, and yes, it needs to be considered ahead of time, but it&#x27;s 100% doable and scalable across teams if needed.<p>There are definitely reasons why a microservice architecture could make sense for an organization, but &quot;we don&#x27;t have good application engineers&#x2F;architects&quot; should not be one of them.  Going to a distributed microservice model because your teams aren&#x27;t good enough to manage a modular monolith sounds like a recipe for disaster.</div><br/></div></div></div></div><div id="38070970" class="c"><input type="checkbox" id="c-38070970" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070185">parent</a><span>|</span><a href="#38073437">prev</a><span>|</span><a href="#38071826">next</a><span>|</span><label class="collapse" for="c-38070970">[-]</label><label class="expand" for="c-38070970">[2 more]</label></div><br/><div class="children"><div class="content">As with so many software solutions, the success of microservices is predicated upon having sufficient prognostication about how the system will be used to recognize where the cut-points are.<p>When I hear success stories like that, I have to ask &quot;Is there some inherent benefit to the abstraction or did you get lucky in picking your cleave-points?&quot;</div><br/><div id="38071833" class="c"><input type="checkbox" id="c-38071833" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070970">parent</a><span>|</span><a href="#38071826">next</a><span>|</span><label class="collapse" for="c-38071833">[-]</label><label class="expand" for="c-38071833">[1 more]</label></div><br/><div class="children"><div class="content">That comes with experience, but you can let time be the judge if you factor your monolith early enough. If the factorization proves stable, proceed with carving it into microservices.</div><br/></div></div></div></div><div id="38071826" class="c"><input type="checkbox" id="c-38071826" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070185">parent</a><span>|</span><a href="#38070970">prev</a><span>|</span><a href="#38071651">next</a><span>|</span><label class="collapse" for="c-38071826">[-]</label><label class="expand" for="c-38071826">[1 more]</label></div><br/><div class="children"><div class="content">Other teams can access your data directly even if it&#x27;s in your own separate database.</div><br/></div></div></div></div><div id="38071651" class="c"><input type="checkbox" id="c-38071651" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38070112">parent</a><span>|</span><a href="#38070185">prev</a><span>|</span><a href="#38070398">next</a><span>|</span><label class="collapse" for="c-38071651">[-]</label><label class="expand" for="c-38071651">[6 more]</label></div><br/><div class="children"><div class="content">I just wanted to note that static typing isn&#x27;t required for autocomplete. JetBrains has IDEs for languages like Ruby and Python that can do it. If you open the REPL in a recent version of Ruby you get much of what you expect from an IDE with a statically typed language (with regards to autocomplete and syntax checking).</div><br/><div id="38071794" class="c"><input type="checkbox" id="c-38071794" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071651">parent</a><span>|</span><a href="#38074252">next</a><span>|</span><label class="collapse" for="c-38071794">[-]</label><label class="expand" for="c-38071794">[3 more]</label></div><br/><div class="children"><div class="content">Also, DRY is not about repeated code. This drives me crazy. Ruby developers love to make code worse by trying to &quot;DRY it up&quot;.</div><br/><div id="38072126" class="c"><input type="checkbox" id="c-38072126" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071794">parent</a><span>|</span><a href="#38074252">next</a><span>|</span><label class="collapse" for="c-38072126">[-]</label><label class="expand" for="c-38072126">[2 more]</label></div><br/><div class="children"><div class="content">What are you replying to? The article is about how Dry shouldn&#x27;t be over applied.<p>Dry is literally &quot;Don&#x27;t Repeat Yourself&quot; and is definitely pushed for cleaning up redundant code, so it&#x27;s not unreasonable for people to think that&#x27;s what about. It&#x27;s only recently that people have pointed out that there&#x27;s a difference between Duplicated code and Repeated code.</div><br/><div id="38073291" class="c"><input type="checkbox" id="c-38073291" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38072126">parent</a><span>|</span><a href="#38074252">next</a><span>|</span><label class="collapse" for="c-38073291">[-]</label><label class="expand" for="c-38073291">[1 more]</label></div><br/><div class="children"><div class="content">Redundant code is not code that looks the same. It&#x27;s only reasonable for people to believe it is about code that looks the same if they have never bothered to learn what it means.</div><br/></div></div></div></div></div></div><div id="38074252" class="c"><input type="checkbox" id="c-38074252" checked=""/><div class="controls bullet"><span class="by">998244353</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071651">parent</a><span>|</span><a href="#38071794">prev</a><span>|</span><a href="#38070398">next</a><span>|</span><label class="collapse" for="c-38074252">[-]</label><label class="expand" for="c-38074252">[2 more]</label></div><br/><div class="children"><div class="content">You are correct, but static typing does make it a lot easier. Working with Rider feels like working with an IDE that fully understands the code, at least structurally. Working with PyCharm feels like working with an IDE that makes intelligent guesses.</div><br/><div id="38074996" class="c"><input type="checkbox" id="c-38074996" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38074252">parent</a><span>|</span><a href="#38070398">next</a><span>|</span><label class="collapse" for="c-38074996">[-]</label><label class="expand" for="c-38074996">[1 more]</label></div><br/><div class="children"><div class="content">The REPL in current versions of Ruby is probably a better example of how it should be done. Because it is actually running the code it has much better information.<p><a href="https:&#x2F;&#x2F;ruby-doc.org&#x2F;core-3.1.0&#x2F;NEWS_md.html#label-IRB+Autocomplete+and+Document+Display" rel="nofollow noreferrer">https:&#x2F;&#x2F;ruby-doc.org&#x2F;core-3.1.0&#x2F;NEWS_md.html#label-IRB+Autoc...</a></div><br/></div></div></div></div></div></div><div id="38070398" class="c"><input type="checkbox" id="c-38070398" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#38070112">parent</a><span>|</span><a href="#38071651">prev</a><span>|</span><a href="#38070491">next</a><span>|</span><label class="collapse" for="c-38070398">[-]</label><label class="expand" for="c-38070398">[1 more]</label></div><br/><div class="children"><div class="content">new role: lead grug</div><br/></div></div><div id="38070491" class="c"><input type="checkbox" id="c-38070491" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070112">parent</a><span>|</span><a href="#38070398">prev</a><span>|</span><a href="#38072226">next</a><span>|</span><label class="collapse" for="c-38070491">[-]</label><label class="expand" for="c-38070491">[10 more]</label></div><br/><div class="children"><div class="content">Network calls are a powerful thing to introduce. It means that you have an impassable boundary, one that is actually physically enforced - your two services <i>have</i> to treat each other as if they are isolated.<p>Isolation is not anything to scoff at, it&#x27;s one of the most powerful features you can encode into your software. Isolation can improve performance, it can create fault boundaries, it can provide security boundaries, etc.<p>This is the same foundational concept behind the actor model - instead of two components being able to share and mutate one another&#x27;s memory, you have two isolated systems (actors, microservices) that can only communicate over a defined protocol.</div><br/><div id="38070749" class="c"><input type="checkbox" id="c-38070749" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070491">parent</a><span>|</span><a href="#38071179">next</a><span>|</span><label class="collapse" for="c-38070749">[-]</label><label class="expand" for="c-38070749">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Network calls are a powerful thing to introduce. It means that you have an impassable boundary, one that is actually physically enforced - your two services have to treat each other as if they are isolated.<p>That is not too true at all. I&#x27;ve seen &quot;microservice&quot; setups where one microservice depends on the state within another microservice. And even cases where service A calls into service B which calls back into service A, relying on the state from the initial call being present.<p>Isolation is good, but microservices are neither necessary nor sufficient to enforce it.</div><br/><div id="38070865" class="c"><input type="checkbox" id="c-38070865" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070749">parent</a><span>|</span><a href="#38071179">next</a><span>|</span><label class="collapse" for="c-38070865">[-]</label><label class="expand" for="c-38070865">[3 more]</label></div><br/><div class="children"><div class="content">Well, I&#x27;d say you&#x27;ve seen SoA setups that do that, maybe. But those don&#x27;t sound like microservices :) Perhaps that&#x27;s not a strong point though.<p>Let me be a bit clearer on my point because I was wrong to say that you have to treat a service as being totally isolated, what I should have said that they <i>are</i> isolated, whether you treat them that way or not. There is a <i>physical</i> boundary between two computers. You can try to ignore that boundary, you can implement distributed transactions, etc, but the boundary is there - if you do the extra work to try to pretend it isn&#x27;t, that&#x27;s a lot of extra work to do the wrong thing.<p>Concretely, you can write:<p><pre><code>    rpc_call(&amp;mut my_state)
</code></pre>
But under the hood what <i>has</i> to happen, physically, is that your state has to be copied to the other service, the service can return a new state (or an update), and the caller can then mutate the state locally. There is no way for you to actually transfer a mutable reference to your own memory to another computer (and a service should be treated as if it may be on another computer, even if it is colocated) without obscene shenanigans. You can try to abstract around that isolation to give the appearance of shared mutable state but it is just an abstraction, it is effectively impossible to implement that directly.<p>But shared mutable state is <i>trivial</i> without the process boundary. It&#x27;s just... every function call. Any module can take a mutable pointer and modify it. And that&#x27;s great for lots of things, of course, you give up isolation sometimes when you need to.</div><br/><div id="38071057" class="c"><input type="checkbox" id="c-38071057" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070865">parent</a><span>|</span><a href="#38071179">next</a><span>|</span><label class="collapse" for="c-38071057">[-]</label><label class="expand" for="c-38071057">[2 more]</label></div><br/><div class="children"><div class="content">Hmm... I guess I very rarely use shared mutable state in web services anyway. The last job I worked at, <i>all</i> state was either in the database (effectively another service anyway) or stored on the client (e.g. auth tokens). So anything that was mutating a function parameter would already be subject to extra scrutiny during code review (Why is it doing that? What scope &#x2F; module boundary is the mutation limited to?).</div><br/><div id="38071105" class="c"><input type="checkbox" id="c-38071105" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071057">parent</a><span>|</span><a href="#38071179">next</a><span>|</span><label class="collapse" for="c-38071105">[-]</label><label class="expand" for="c-38071105">[1 more]</label></div><br/><div class="children"><div class="content">Shared mutable state also goes beyond a mutable reference. If you call a function and that function throws an exception you are tying the caller&#x2F;callee&#x27;s states together. In a SoA the callee machine can literally blow up and your caller state is preserved.<p>If your web service is generally low-state and these problems are manageable for the complexity scale you&#x27;re solving for, microservices aren&#x27;t really something to even consider - I mean, you basically have a microservice already, it&#x27;s solving a single problem within a bounded context, give or take. It&#x27;s just... one service and one context.</div><br/></div></div></div></div></div></div></div></div><div id="38071390" class="c"><input type="checkbox" id="c-38071390" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070491">parent</a><span>|</span><a href="#38071179">prev</a><span>|</span><a href="#38073652">next</a><span>|</span><label class="collapse" for="c-38071390">[-]</label><label class="expand" for="c-38071390">[2 more]</label></div><br/><div class="children"><div class="content">It is trivial to tightly couple two services. They don&#x27;t have to treat each other as isolated at all. The same people who create tightly coupled code within a single service are likely going to create tightly coupled services.</div><br/><div id="38071442" class="c"><input type="checkbox" id="c-38071442" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38071390">parent</a><span>|</span><a href="#38073652">next</a><span>|</span><label class="collapse" for="c-38071442">[-]</label><label class="expand" for="c-38071442">[1 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;ve covered this in another comment just below the one you&#x27;ve replied to.</div><br/></div></div></div></div><div id="38073652" class="c"><input type="checkbox" id="c-38073652" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38070491">parent</a><span>|</span><a href="#38071390">prev</a><span>|</span><a href="#38072226">next</a><span>|</span><label class="collapse" for="c-38073652">[-]</label><label class="expand" for="c-38073652">[2 more]</label></div><br/><div class="children"><div class="content">The reality of this situation is that the tool everyone is using to build microservices is Kubernetes.  It imposes a huge tax on communication between services.  So your aspiration as to improving performance fly out of the window.<p>On top of this, you need to consider that most of the software you are going to write will be based on existing components.  Many of these have no desire to communicate over network, and your micro- or w&#x2F;e size services will have to cave in to their demands.  Simple example: want to use Docker? -- say hello to UNIX sockets.  Other components may require communication through shared memory, filesystem, and so on.<p>Finally, isolation is not a feature of microservices, especially if the emphasis is on <i>micro</i>.  You have to be able to control the size and where you want to draw the boundary.  If you committed upfront to having your units be as small as possible -- well, you might have function-level isolation, but you won&#x27;t have class- or module- or program-level isolation, to put it in more understandable terms.  This is where your comparison between the actors model and microservices breaks: first doesn&#x27;t prescribe the size.</div><br/><div id="38073872" class="c"><input type="checkbox" id="c-38073872" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38070112">root</a><span>|</span><a href="#38073652">parent</a><span>|</span><a href="#38072226">next</a><span>|</span><label class="collapse" for="c-38073872">[-]</label><label class="expand" for="c-38073872">[1 more]</label></div><br/><div class="children"><div class="content">Microservices definitely predate k8s, but sure, lots of people use k8s. I don&#x27;t know what penalty you&#x27;re referring to. There is a minor impact on network performance for containers measured in microseconds under some configurations. Maybe Kubernetes makes that worse somehow? I think it does some proxying stuff so you probably pay for a local hop to something like Envoy. If Envoy is on your system and you&#x27;re not double-wrapping your TLS the communication with it should stay entirely in the kernel, afaik.<p><a href="http:&#x2F;&#x2F;domino.research.ibm.com&#x2F;library&#x2F;cyberdig.nsf&#x2F;papers&#x2F;0929052195DD819C85257D2300681E7B&#x2F;$File&#x2F;rc25482.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;domino.research.ibm.com&#x2F;library&#x2F;cyberdig.nsf&#x2F;papers&#x2F;0...</a><p>In no way is this throwing out performance. It&#x27;s sort of like saying that Kafka is in Java so you&#x27;re throwing away performance when you use it, when there are massive performance benefits if you leverage partition isolation.<p>&gt; Many of these have no desire to communicate over network, and your micro- or w&#x2F;e size services will have to cave in to their demands. Simple example: want to use Docker? -- say hello to UNIX sockets. Other components may require communication through shared memory, filesystem, and so on.<p>I&#x27;m not sure what you&#x27;re referring to. Why would that matter at all? I mean, ignoring the fact that you can easily talk to Docker over a network.<p>&gt; Finally, isolation is not a feature of microservices,<p>Isolation is a feature of any process based architecture, whether it&#x27;s SoA, actors, or microservices.<p>&gt; well, you might have function-level isolation, but you won&#x27;t have class- or module- or program-level isolation,<p>You get isolation at the service layer. I don&#x27;t see why that would be contentious, it&#x27;s obvious. If you&#x27;re saying you want more isolation, ok, you can write your code to do that if you&#x27;d like.<p>&gt; first doesn&#x27;t prescribe the size.<p>Yep, the actor model is very low level. Microservice architecture is far more prescriptive. It&#x27;s one of the reasons why I think Microservice architecture has been far more successful than actor based systems.</div><br/></div></div></div></div></div></div></div></div><div id="38072226" class="c"><input type="checkbox" id="c-38072226" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38070112">prev</a><span>|</span><a href="#38071070">next</a><span>|</span><label class="collapse" for="c-38072226">[-]</label><label class="expand" for="c-38072226">[53 more]</label></div><br/><div class="children"><div class="content">&gt; And think of the sheer number of libraries - one for each language adopted - that need to be supported to provide common functionality that all services need, like logging.<p>This is the #1 reason we quit the microservices game. It is simply a complete waste of mental bandwidth to worry about with the kind of tooling we have in 2023 (pure cloud native &#x2F; infiniscale FaaS), especially when you have a customer base (e.g. banks &amp; financial instutitions) who will rake you over hot coals for <i>every single</i> 3rd party dependency you bring.<p>We currently operate with one monolithic .NET binary distribution which is around 250 megs (gzipped). Not even the slightest hint of cracks forming. So, if you are sitting there with a 10~100 meg SaaS distribution starting to get nervous about pedantic things like &quot;my exe doesnt fit in L2 anymore&quot;, then rest assured - Your monolithic software journey hasn&#x27;t even <i>begun</i> yet.<p>God forbid you find yourself with a need to rewrite one of these shitpiles. Wouldn&#x27;t it be a hell of a lot easier if it was all in one place where each commit is globally consistent?</div><br/><div id="38073506" class="c"><input type="checkbox" id="c-38073506" checked=""/><div class="controls bullet"><span class="by">superfrank</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38073580">next</a><span>|</span><label class="collapse" for="c-38073506">[-]</label><label class="expand" for="c-38073506">[7 more]</label></div><br/><div class="children"><div class="content">I think this is a false dichotomy. Most places I&#x27;ve worked with microservices had 2 or 3 approved languages for this reason (and others) and exceptions could be made by leadership if a team could show they had no other options.<p>Microservices doesn&#x27;t need to mean it&#x27;s the wild west and every team can act without considering the larger org. There can and should be rules to keep a certain level of consistency across teams.</div><br/><div id="38074229" class="c"><input type="checkbox" id="c-38074229" checked=""/><div class="controls bullet"><span class="by">orochimaaru</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073506">parent</a><span>|</span><a href="#38076878">next</a><span>|</span><label class="collapse" for="c-38074229">[-]</label><label class="expand" for="c-38074229">[1 more]</label></div><br/><div class="children"><div class="content">Not sure why you’re downvoted - but you’re right. We heavily use microservices but we have a well defined stack. Python&#x2F;gunicorn&#x2F;flask&#x2F;mongodb with k8s. We run these on Kafka or rest api. We even runs jobs and corn jobs in k8s.<p>Functional decomp is left to different teams. But the libraries for logging, a&amp;a, various utilities etc are common.<p>No microservices that don’t meet the stack unless they’re already developed&#x2F;open source - eg open telemetry collectors.<p>Edit: I think the article is a path to a book written by the author. It’s more of an advertisement than an actual assessment. At least that’s my take on it.</div><br/></div></div><div id="38076878" class="c"><input type="checkbox" id="c-38076878" checked=""/><div class="controls bullet"><span class="by">tcgv</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073506">parent</a><span>|</span><a href="#38074229">prev</a><span>|</span><a href="#38076936">next</a><span>|</span><label class="collapse" for="c-38076878">[-]</label><label class="expand" for="c-38076878">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Most places I&#x27;ve worked with microservices had 2 or 3 approved languages for this reason (and others) and exceptions could be made by leadership if a team could show they had no other options.<p>This works well if you have knowledge redundancy in your organization, i.e., multiple teams that are experienced in each programming language. This way, if one or more developers experienced in language &#x27;A&#x27; quit, you can easily replace them by rearranging developers from other teams.<p>In small companies, this flexibility of allowing multiple languages can result in a situation in which developers moving to other jobs or companies will leave a significant gap that can only be filled with recruiting (then onboarding), which takes much more time and will significantly impact the product development plan.<p>More often than not, the choice between Microservices and Monoliths is more of a business decision than a technical one to make.</div><br/><div id="38077901" class="c"><input type="checkbox" id="c-38077901" checked=""/><div class="controls bullet"><span class="by">LelouBil</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38076878">parent</a><span>|</span><a href="#38076936">next</a><span>|</span><label class="collapse" for="c-38077901">[-]</label><label class="expand" for="c-38077901">[1 more]</label></div><br/><div class="children"><div class="content">&gt; More often than not, the choice between Microservices and Monoliths is more of a business decision than a technical one to make.<p>I think that, technically you can use one or the other and make it work. 
However management is very different in the two cases, so I completely agree with you. I hadn&#x27;t thought of the part about moving people between teams.<p>It&#x27;s my first job but I understand why they chose microservices : 6 teams working on 6 &quot;features&#x2F;apps&quot; can be managed (almost) fully independently of each other if you split your code base.</div><br/></div></div></div></div><div id="38076936" class="c"><input type="checkbox" id="c-38076936" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073506">parent</a><span>|</span><a href="#38076878">prev</a><span>|</span><a href="#38077876">next</a><span>|</span><label class="collapse" for="c-38076936">[-]</label><label class="expand" for="c-38076936">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s fair to say microservices increase the need for governance, whether manual or automated systems. When you start having more than 1 thing, you create the &quot;how do I keep things consistent and what level of consistency do I want&quot; problem</div><br/></div></div><div id="38077876" class="c"><input type="checkbox" id="c-38077876" checked=""/><div class="controls bullet"><span class="by">LelouBil</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073506">parent</a><span>|</span><a href="#38076936">prev</a><span>|</span><a href="#38075947">next</a><span>|</span><label class="collapse" for="c-38077876">[-]</label><label class="expand" for="c-38077876">[1 more]</label></div><br/><div class="children"><div class="content">In the department I work there&#x27;s a lot of microservices, about 5-6 so 5-6 teams. 
But everything is quarkus&#x2F;spring java and nothing else.</div><br/></div></div></div></div><div id="38073580" class="c"><input type="checkbox" id="c-38073580" checked=""/><div class="controls bullet"><span class="by">cpill</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38073506">prev</a><span>|</span><a href="#38075481">next</a><span>|</span><label class="collapse" for="c-38073580">[-]</label><label class="expand" for="c-38073580">[13 more]</label></div><br/><div class="children"><div class="content">&gt; God forbid you find yourself with a need to rewrite one of these shitpiles.
Actually, this is much easier with micro services as you have a clear interface you need to support and the code is not woven into the rest of the monolith like a French plat. The best code is the easiest to throw away and rewrite, because let&#x27;s face it, the older the code is, the more hands it&#x27;s been through, the worse it is, but more importantly the less motivated anyone is in maintaining it.</div><br/><div id="38074385" class="c"><input type="checkbox" id="c-38074385" checked=""/><div class="controls bullet"><span class="by">lemmsjid</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073580">parent</a><span>|</span><a href="#38076322">next</a><span>|</span><label class="collapse" for="c-38074385">[-]</label><label class="expand" for="c-38074385">[8 more]</label></div><br/><div class="children"><div class="content">If the monolithic application is written in a language with sufficient encapsulation and good tooling around multi-module projects, then you can indeed have well known and encapsulated interfaces within the monolith.  Within the monolith itself you can create a DAG of enforced interfaces and dependencies that is logically identical to a set of services from different codebases.  There are well known design issues in monoliths that can undermine this approach (the biggest one that comes to mind is favoring composition over inheritance, because that&#x27;s how encapsulation can be most easily broken as messages flow across a single-application interfaces, but then I&#x27;d also throw in enforced immutability, and separating data from logic).<p>It takes effort to keep a monolithic application set up this way, but IMHO the effort is far less than moving to and maintaining microservices. I think a problem is that there&#x27;s very popular ecosystems that don&#x27;t have particularly good tooling around this approach, Python being a major example--it can be done, but it&#x27;s not smooth.<p>To me the time when you pull the trigger on a different service+codebase should not be code complexity, because that can be best managed in one repo.  It is when you need a different platform in your ecosystem (say your API is in Java and you need Python services so they can use X Y or Z packages as dependencies), or when you have enough people involved that multiple teams benefit from owning their own soup-to-nuts code-to-deployment ecosystem, or when, to your point, you have a chunk of code that the team doesn&#x27;t or can&#x27;t own&#x2F;maintain and wants to slowly branch functionality away from.</div><br/><div id="38075697" class="c"><input type="checkbox" id="c-38075697" checked=""/><div class="controls bullet"><span class="by">protomolecule</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074385">parent</a><span>|</span><a href="#38077933">next</a><span>|</span><label class="collapse" for="c-38075697">[-]</label><label class="expand" for="c-38075697">[2 more]</label></div><br/><div class="children"><div class="content">&quot;composition over inheritance, because that&#x27;s how encapsulation can be most easily broken as messages flow across a single-application interfaces, but then I&#x27;d also throw in enforced immutability, and separating data from logic&quot;<p>Could you elaborate on this? I see how &quot;separating data from logic&quot; is a problem but what about the other two?</div><br/><div id="38077247" class="c"><input type="checkbox" id="c-38077247" checked=""/><div class="controls bullet"><span class="by">lemmsjid</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38075697">parent</a><span>|</span><a href="#38077933">next</a><span>|</span><label class="collapse" for="c-38077247">[-]</label><label class="expand" for="c-38077247">[1 more]</label></div><br/><div class="children"><div class="content">Well now that you mention it I think it does all come down to &#x27;separating data from logic&#x27;.  I was working backwards from the premise of: &quot;what if we want a monolithic in-process application to have the same cognitive simplicity as an API-based client-server model?&quot;<p>If you want to enforce a clean interface between an in-process client and server (i.e. a piece of code calling a library interface), then the best model is to think of it as a message passing system, where once a payload is passed from the client to the server and vice versa, the other side should not be able to witness changes to the payload.  An immutable payload in this context is the same as the json that goes over the wire between a client and server.<p>If you really wanted an in-process application to look like a microservice you could take the added step of forcing a serialization &#x2F; deserialization step on both client and server.  I&#x27;ve seen frameworks that do this.  But I think immutability, if it can be enforced, is a practical way of solving this problem and far less complex.<p>Inheritance is a hazier point I was making, in hindsight, because you could use inheritance for data modeling, which is quite fine in some situations... so I think it&#x27;s effectively subsumed under the &quot;separating data from logic&quot; argument: which is that if you&#x27;re passing <i>behavioral</i> inheritance from a &quot;server&quot; to a &quot;client&quot;, then it gets harder and harder to predict how that client is going to use it and thus it&#x27;s harder to reason about the functional boundary between two pieces of code.  But it&#x27;s a hazy point because I think the larger and more important point to make, as you point out, is that you simply shouldn&#x27;t (in most cases) pass any kind of behavior between client and server--just data.<p>Another approach to look at (besides taking inspiration from Smalltalk) is the actor model, where it&#x27;s incredibly clear that any communication between modules in an ecosystem is immutable messages.  In fact a side effect of the actor model is that it gets pretty easy to move things from in-process to cross-process because most activity in the system is already performed through message passing, so you can just start channeling messages from Actor A to Actor B through a serialization&#x2F;networking layer rather than in-process if you want to deploy them separately for reasons of convenience or computational needs.</div><br/></div></div></div></div><div id="38077933" class="c"><input type="checkbox" id="c-38077933" checked=""/><div class="controls bullet"><span class="by">LelouBil</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074385">parent</a><span>|</span><a href="#38075697">prev</a><span>|</span><a href="#38077157">next</a><span>|</span><label class="collapse" for="c-38077933">[-]</label><label class="expand" for="c-38077933">[3 more]</label></div><br/><div class="children"><div class="content">With microservices, you can also version them independently. In a monolith you can&#x27;t roll back &quot;a part&quot; of the app to the latest version if you pushed multiple unrelated features at once.</div><br/><div id="38078243" class="c"><input type="checkbox" id="c-38078243" checked=""/><div class="controls bullet"><span class="by">lemmsjid</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38077933">parent</a><span>|</span><a href="#38079006">next</a><span>|</span><label class="collapse" for="c-38078243">[-]</label><label class="expand" for="c-38078243">[1 more]</label></div><br/><div class="children"><div class="content">You can do the same with the approach I described.  If you set up the modular DAG as I mentioned above, you can now set up service boundaries between the leaves of the DAG.  E.g. parts of the code call other parts of the code as a service.  You then version and deploy the same codebase separately.<p>Say you have Libraries A, B, and C, where B and C depend on A and not one another.  You can have B call into C via a service, just as you would in a microservice.  Now B and C can be versioned and deployed independency.  You can also deploy updates to Library A incrementally, tying it to the B and C deployments.<p>If you are literally pushing different features that are in fact unrelated, you don&#x27;t even need to worry about B calling into C, you can just partition your app into different modules, deploy them separately, and use a load balancer with routing rules to arbitrate between the deployments.<p>I like having this type of environment because you can make fairly quick and easily-resersible decisions about whether or not different parts of the codebase are deployed differently: sometimes it&#x27;s compute and hardware requirements, sometimes it&#x27;s because you want parts to be stable and other parts more experimental and volatile.<p>The microservice argument isn&#x27;t addressing this type of deployment scenario: it&#x27;s suggesting a shared-nothing or shared-little architecture across services.</div><br/></div></div><div id="38079006" class="c"><input type="checkbox" id="c-38079006" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38077933">parent</a><span>|</span><a href="#38078243">prev</a><span>|</span><a href="#38077157">next</a><span>|</span><label class="collapse" for="c-38079006">[-]</label><label class="expand" for="c-38079006">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a monolith you can&#x27;t roll back &quot;a part&quot; of the app to the latest version if you pushed multiple unrelated features at once.<p>git revert &lt;bad commit&gt;</div><br/></div></div></div></div><div id="38077157" class="c"><input type="checkbox" id="c-38077157" checked=""/><div class="controls bullet"><span class="by">gedy</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074385">parent</a><span>|</span><a href="#38077933">prev</a><span>|</span><a href="#38076322">next</a><span>|</span><label class="collapse" for="c-38077157">[-]</label><label class="expand" for="c-38077157">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If the monolithic application is written in a language with sufficient encapsulation and good tooling around multi-module projects, then you can indeed have well known and encapsulated interfaces within the monolith. Within the monolith itself you can create a DAG of enforced interfaces and dependencies that is logically identical to a set of services from different codebases.<p>So then, not Rails apps</div><br/><div id="38077430" class="c"><input type="checkbox" id="c-38077430" checked=""/><div class="controls bullet"><span class="by">lemmsjid</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38077157">parent</a><span>|</span><a href="#38076322">next</a><span>|</span><label class="collapse" for="c-38077430">[-]</label><label class="expand" for="c-38077430">[1 more]</label></div><br/><div class="children"><div class="content">Yes, a good point, I think the more dynamic the language, the more one gravitates towards microservices as a problem solving tool, because you&#x27;d give up a lot of the value of the dynamic environment by enforcing strict rules.<p>Though I&#x27;m seeing a lot of convergence between environments over time, which makes me think we&#x27;re all headed towards a nicer future.<p>For example in Scala, which does a lot of type inferencing, it&#x27;s typical to tell the linter to require that public methods have explicit types, even though the compiler will reify them at compile time anyhow, because that makes the interface much more robust to refactoring.  Meanwhile in a more dynamic environment, in Python it&#x27;s getting more typical to use type annotations, and, similarly, to especially use them on functions that define a reusable interface.<p>I figure that the ideal languages in the future have module-level systems where they can define strict interfaces across modules, but then get as crazy and dynamic as they want inside of the modules.</div><br/></div></div></div></div></div></div><div id="38076322" class="c"><input type="checkbox" id="c-38076322" checked=""/><div class="controls bullet"><span class="by">butlike</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073580">parent</a><span>|</span><a href="#38074385">prev</a><span>|</span><a href="#38075729">next</a><span>|</span><label class="collapse" for="c-38076322">[-]</label><label class="expand" for="c-38076322">[2 more]</label></div><br/><div class="children"><div class="content">I disagree. The older the code is, the more hands it&#x27;s been through, which generally means it&#x27;s stronger, hardened code. Each `if` statement added to the method is an if statement to catch a specific bug or esoteric business requirement. If a rewrite happens, all that context is lost and the software is generally worse for it.<p>That being said, I agree that maintaining legacy systems is far from fun.</div><br/><div id="38077186" class="c"><input type="checkbox" id="c-38077186" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38076322">parent</a><span>|</span><a href="#38075729">next</a><span>|</span><label class="collapse" for="c-38077186">[-]</label><label class="expand" for="c-38077186">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If a rewrite happens, all that context is lost and the software is generally worse for it.<p>Unless you have a strong test suite which tests the absence of those bugs. OFC you can never prove the absence of an issue just the continued functionality of your codebase, but re-writes are often prompted by weird &quot;in-between&quot; functionality becoming the norm (or slow&#x2F;buggy behavior).<p>Of course a lot of test suites are of dubious quality&#x2F;many devs have no idea what a good test suite looks like (usually unit tests are some combination of throw-away&#x2F;waste-of-time, acceptance tests are mostly happy-path and due to recent trends integration tests are all but non-existent).<p>But in theory, re-writes are fine when you do have a test-suite. Even with a bad one, you learn what areas of the application were never properly tested and have opportunities to write good tests.</div><br/></div></div></div></div><div id="38075729" class="c"><input type="checkbox" id="c-38075729" checked=""/><div class="controls bullet"><span class="by">antonhag</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073580">parent</a><span>|</span><a href="#38076322">prev</a><span>|</span><a href="#38076889">next</a><span>|</span><label class="collapse" for="c-38075729">[-]</label><label class="expand" for="c-38075729">[1 more]</label></div><br/><div class="children"><div class="content">This assumes a clear interface. Which assumes that you get the interfaces right - but what&#x27;s the chance of that if the code needs rewriting?<p>Most substantial rewrites crosses module boundaries. In micro services changing the module boundary is harder than in a monolith, since it can be done in a single commit&#x2F;deploy.</div><br/></div></div><div id="38076889" class="c"><input type="checkbox" id="c-38076889" checked=""/><div class="controls bullet"><span class="by">wernercd</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073580">parent</a><span>|</span><a href="#38075729">prev</a><span>|</span><a href="#38075481">next</a><span>|</span><label class="collapse" for="c-38076889">[-]</label><label class="expand" for="c-38076889">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The best code is the easiest to throw away and rewrite, because let&#x27;s face it, the older the code is, the more hands it&#x27;s been through, the worse it is, but more importantly the less motivated anyone is in maintaining it.<p>The more testing that&#x27;s been done and the more stable it should be.<p>The argument for new can be flipped because new doesn&#x27;t mean better and old doesn&#x27;t mean hell.</div><br/></div></div></div></div><div id="38075481" class="c"><input type="checkbox" id="c-38075481" checked=""/><div class="controls bullet"><span class="by">bibabaloo</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38073580">prev</a><span>|</span><a href="#38074384">next</a><span>|</span><label class="collapse" for="c-38075481">[-]</label><label class="expand" for="c-38075481">[1 more]</label></div><br/><div class="children"><div class="content">How many developers do you have working on that monolith though? The size of your binary isn&#x27;t usually why teams start breaking up a monolith.</div><br/></div></div><div id="38074384" class="c"><input type="checkbox" id="c-38074384" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38075481">prev</a><span>|</span><a href="#38077030">next</a><span>|</span><label class="collapse" for="c-38074384">[-]</label><label class="expand" for="c-38074384">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn&#x27;t it be a hell of a lot easier if it was all in one place where each commit is globally consistent?<p>I always find this sentence to be a bit of a laugh. It&#x27;s so commonly said (by either group of people with a dog in this fight) but seemingly so uncommonly thought of from the other group&#x27;s perspective.<p>People that prefer microservices say it&#x27;s easier to change&#x2F;rewrite code in a microservice because you have a clearly defined contract for how that service needs to operate and a much smaller codebase for the given service. The monolith crowd claims it&#x27;s easier to change&#x2F;rewrite code in a monolith because it&#x27;s all one big pile of yarn and if you want to change out one strand of it, you just need to know each juncture where that strand weaves into other strands.<p>Who is right? I sure don&#x27;t know. Probably monoliths for tenured employees that have studied the codebase under a microscope for the past few years already, and microservices for everyone else.</div><br/><div id="38074450" class="c"><input type="checkbox" id="c-38074450" checked=""/><div class="controls bullet"><span class="by">tklinglol</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074384">parent</a><span>|</span><a href="#38074915">next</a><span>|</span><label class="collapse" for="c-38074450">[-]</label><label class="expand" for="c-38074450">[1 more]</label></div><br/><div class="children"><div class="content">My first gig out of school was a .net monolith with ~14 million lines of code; it&#x27;s the best dev environment I&#x27;ve ever experienced, even as a newcomer who didn&#x27;t have a mental map of the system. All the code was right there, all I had to do was embrace &quot;go to definition&quot; to find the answers to like 95% of my questions. I spend the majority of my time debugging distrubuted issues across microservices these days; I miss the simplicity of my monolith years :(</div><br/></div></div><div id="38074915" class="c"><input type="checkbox" id="c-38074915" checked=""/><div class="controls bullet"><span class="by">disintegore</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074384">parent</a><span>|</span><a href="#38074450">prev</a><span>|</span><a href="#38074464">next</a><span>|</span><label class="collapse" for="c-38074915">[-]</label><label class="expand" for="c-38074915">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve noticed that a lot of industry practices demonstrate their value in unexpected ways. Code tests, for instance, train you to think of every piece of code you write as having at minimum two integrations, and that makes developers who write unit tests better at separating concerns. Even if they were to stop writing tests altogether, they would still go on to write better code.<p>Microservices are a bit like that. They make it extremely difficult to insert cross cutting concerns into a code base. Conditioning yourself to think of how to work within these boundaries means you are going to write monolithic applications that are far easier to understand and maintain.</div><br/></div></div><div id="38074464" class="c"><input type="checkbox" id="c-38074464" checked=""/><div class="controls bullet"><span class="by">iterateoften</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074384">parent</a><span>|</span><a href="#38074915">prev</a><span>|</span><a href="#38075747">next</a><span>|</span><label class="collapse" for="c-38074464">[-]</label><label class="expand" for="c-38074464">[3 more]</label></div><br/><div class="children"><div class="content">Not so much a ball of yarn but more like the cabling coming out of a network cabinet. It can be bad and a big mess if you let it, but most professionals can organize things in such a way that maintenance isn’t that hard.</div><br/><div id="38074723" class="c"><input type="checkbox" id="c-38074723" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074464">parent</a><span>|</span><a href="#38075747">next</a><span>|</span><label class="collapse" for="c-38074723">[-]</label><label class="expand" for="c-38074723">[2 more]</label></div><br/><div class="children"><div class="content">Well, the point I was making was that the same can easily be true of microservice architectures. If you have people that don&#x27;t know what they&#x27;re doing architecting your microservices, you&#x27;ll have a difficult time maintaining them without clear and strict service contracts.<p>It&#x27;s not clear to me that we&#x27;re ever comparing apples to apples in these discussions. It would seem to me that everyone arguing left a job where they were doing X architecture the wrong way and now they only advocate for Y architecture online and in future shops.</div><br/><div id="38079002" class="c"><input type="checkbox" id="c-38079002" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074723">parent</a><span>|</span><a href="#38075747">next</a><span>|</span><label class="collapse" for="c-38079002">[-]</label><label class="expand" for="c-38079002">[1 more]</label></div><br/><div class="children"><div class="content">Functionally its the same stuff.<p>Both have boxes of stuff and the stuff talks to other stuff.<p>Logistically its a bit easier to scale the one where the boxes are married to closer to the hardware abstraction (microservices on instances) versus the one where boxes are married to the software abstraction (threads with memory), for the same reason one (monolith) is a lot faster (dev&#x2F;process&#x2F;latency) (at small scales) than the other (microservice).<p>You can scale both, really its mostly about fights about the tooling, process, and where your sec-ops decided to screw you over the most (did they lock down your environments or did they make it impossible to debug ports&#x2F;get logs).<p>Practically, AWS is expensive, and they&#x27;re bloated. Cluster environments that let you merge 1000 computers into 1 big supercomputer and have 1 million cores&#x2F;terabytes of ram, come with different technical challenges that not as many people know how to overcome, or expensive hardware bills.<p>So I&#x27;d say if someone tells you it &quot;has to be&quot; one or the other they are blowing smoke. Micro-services were recently the hip-new-thing so it makes sense some really really bad nonsense has been written in them so people are rediscovering monoliths (and realizing the microservice people were snake-oil salesmen). In 10 years we&#x27;ll realize again that some monoliths are really badly written and some people without a clue will re-write them as microservices...</div><br/></div></div></div></div></div></div><div id="38075747" class="c"><input type="checkbox" id="c-38075747" checked=""/><div class="controls bullet"><span class="by">protomolecule</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074384">parent</a><span>|</span><a href="#38074464">prev</a><span>|</span><a href="#38078397">next</a><span>|</span><label class="collapse" for="c-38075747">[-]</label><label class="expand" for="c-38075747">[1 more]</label></div><br/><div class="children"><div class="content">&quot;because you have a clearly defined contract for how that service needs to operate&quot;<p>But if you need to change the contract the changes span the service and all of its clients.</div><br/></div></div><div id="38078397" class="c"><input type="checkbox" id="c-38078397" checked=""/><div class="controls bullet"><span class="by">masterj</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074384">parent</a><span>|</span><a href="#38075747">prev</a><span>|</span><a href="#38077936">next</a><span>|</span><label class="collapse" for="c-38078397">[-]</label><label class="expand" for="c-38078397">[1 more]</label></div><br/><div class="children"><div class="content">If an organization can&#x27;t figure out how to factor out clearly-defined contracts within a single codebase and maintain that over time, adding a network hop and multiple codebases into that will not make it any easier.</div><br/></div></div><div id="38077936" class="c"><input type="checkbox" id="c-38077936" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074384">parent</a><span>|</span><a href="#38078397">prev</a><span>|</span><a href="#38077030">next</a><span>|</span><label class="collapse" for="c-38077936">[-]</label><label class="expand" for="c-38077936">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you just need to know each juncture where that strand weaves into other strands.<p>No I don&#x27;t, that&#x27;s what computers are for. It&#x27;s why static analysis is good. Instead of knowing what calls what, you say, &quot;yo, static analysis tool, what calls this?&quot;.</div><br/><div id="38078157" class="c"><input type="checkbox" id="c-38078157" checked=""/><div class="controls bullet"><span class="by">BHSPitMonkey</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38077936">parent</a><span>|</span><a href="#38077030">next</a><span>|</span><label class="collapse" for="c-38078157">[-]</label><label class="expand" for="c-38078157">[1 more]</label></div><br/><div class="children"><div class="content">The comment you quoted is talking about the non-monolithic situations where static analysis tools cannot help you, e.g. when the callers are external and difficult to trace.</div><br/></div></div></div></div></div></div><div id="38077030" class="c"><input type="checkbox" id="c-38077030" checked=""/><div class="controls bullet"><span class="by">duncan-donuts</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38074384">prev</a><span>|</span><a href="#38079904">next</a><span>|</span><label class="collapse" for="c-38077030">[-]</label><label class="expand" for="c-38077030">[1 more]</label></div><br/><div class="children"><div class="content">I was in a meeting to talk about our logging strategy at an old company that was starting micro services and experiencing this problem. In the meeting I half heartedly suggested we write the main lib in C and write a couple wrapper libs for the various languages we were using. At the time it felt kinda insane but in hindsight it probably would have been better than the logging mess we created for ourselves.</div><br/></div></div><div id="38079904" class="c"><input type="checkbox" id="c-38079904" checked=""/><div class="controls bullet"><span class="by">drzaiusx11</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38077030">prev</a><span>|</span><a href="#38078064">next</a><span>|</span><label class="collapse" for="c-38079904">[-]</label><label class="expand" for="c-38079904">[1 more]</label></div><br/><div class="children"><div class="content">We have 2 supported langs across our cloud teams and our core libraries are dual-lang&#x27;d where applicable; meaning they&#x27;re both Ruby Gems and Pypi packages (Python3) in one repo with unified APIs and backed by a shared static config where applicable (capability definitions etc.) Each dual lib is released simultaneously with matching SemVer versions to our various artifactory instances &amp; S3 buckets (for our lambda &quot;layers&quot;), automatically on every push to mainline by CI&#x2F;CD.<p>It works surprisingly well. We&#x27;re evaluating a 3rd language but won&#x27;t make that choice lightly (if it happens at all.)<p>We have 14+ micro services, and it&#x27;s fairly easy to &quot;rewrite the shit pile&quot; when you actually follow the micro designation. One of our services was originally in perl and we, quite mechanically, rewrote it in ruby in a sprint to align with our other services.<p>Speaking from personal experience, when monoliths and the teams working on them get big enough, you start having &quot;action at a distance&quot; problems, where seemingly benign changes affect completely unrelated flows, often to catastrophic effect.<p>You make an innocuous looking resource update in the monolith, like an update to a CSS stylesheet that fixes a bug in a flow your team owns, now breaks 10 others flows owned by teams you never heard of because they were using the existing structure for selenium tests or some js that now fails to traverse the dom because some order of selectors changed, etc.<p>Microservices are as much a team organizational tool as they are a code one. The idea being those that work on the service &quot;know it&quot;, and all it does.  They can wrap their head around the whole thing. I think some orgs don&#x27;t really get this point and _start_ with microservices, completely unnecessarily, for the stage they&#x27;re at as a company. You always start with a monolith and if you get to the point where everyone is stepping on each other&#x27;s toes from the lack of enforceable boundaries in the code, you do the obvious and start to create those boundaries.<p>Microservices aren&#x27;t the only way to do this of course. Any way of dividing up your service with enforceable contracts will work. Modules get designated with codeowners, assigned to various teams. Resources that were once shared get split up to align with the team structures better. Many frameworks allow multiple &quot;apps&quot; or distinct collections of APIs, so you can still ship your one-binary without splitting out the collections into different services. As soon as you have to independently scale one set of APIs but not another, you can state looking at service boundaries again. For the majority, that day will never come.</div><br/></div></div><div id="38078064" class="c"><input type="checkbox" id="c-38078064" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38079904">prev</a><span>|</span><a href="#38076926">next</a><span>|</span><label class="collapse" for="c-38078064">[-]</label><label class="expand" for="c-38078064">[1 more]</label></div><br/><div class="children"><div class="content">Why did you have 2-3 languages, does not make sense, I&#x27;ve been using microservice for a while and it was only one language at a time.</div><br/></div></div><div id="38076926" class="c"><input type="checkbox" id="c-38076926" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38078064">prev</a><span>|</span><a href="#38073048">next</a><span>|</span><label class="collapse" for="c-38076926">[-]</label><label class="expand" for="c-38076926">[1 more]</label></div><br/><div class="children"><div class="content">This sounds reasonable and correct, but my personal experience includes more monolithic messes than microservices ones.</div><br/></div></div><div id="38073048" class="c"><input type="checkbox" id="c-38073048" checked=""/><div class="controls bullet"><span class="by">tsss</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38076926">prev</a><span>|</span><a href="#38072710">next</a><span>|</span><label class="collapse" for="c-38073048">[-]</label><label class="expand" for="c-38073048">[15 more]</label></div><br/><div class="children"><div class="content">No one says you can&#x27;t have all of your microservices use the same language...</div><br/><div id="38073302" class="c"><input type="checkbox" id="c-38073302" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073048">parent</a><span>|</span><a href="#38081489">next</a><span>|</span><label class="collapse" for="c-38073302">[-]</label><label class="expand" for="c-38073302">[9 more]</label></div><br/><div class="children"><div class="content">Absolutely. This is how we operated when we were at the peak of our tech showmanship phase. We had ~12 different services, all .NET 4.x the exact same way.<p>This sounds like it could work, but then you start to wonder about how you&#x27;d get common code into those 12 services. Our answer at the time was nugets, but we operate in a sensitive domain with proprietary code, so public nuget services were a no go. So, we stood up our own goddamn nuget server just so we could distribute our own stuff to ourselves in the most complicated way possible.<p>Even if you are using all the same language and patterns everywhere, it still will not spare you from all of the accidental complexity that otherwise becomes <i>essential</i> if you break the solution into arbitrary piles.</div><br/><div id="38078165" class="c"><input type="checkbox" id="c-38078165" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073302">parent</a><span>|</span><a href="#38075036">next</a><span>|</span><label class="collapse" for="c-38078165">[-]</label><label class="expand" for="c-38078165">[4 more]</label></div><br/><div class="children"><div class="content">Does .net not have a way to run simple private repository like Nexus? Over in JVM-land that&#x27;s a basic thing that you&#x27;d be doing anyway.</div><br/><div id="38079082" class="c"><input type="checkbox" id="c-38079082" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38078165">parent</a><span>|</span><a href="#38075036">next</a><span>|</span><label class="collapse" for="c-38079082">[-]</label><label class="expand" for="c-38079082">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the difference between drag-dropping a reference between &quot;projects&quot; or whatnot in your monolith project, or coming up with a publish pipeline after which your merged code gets into the repo so that other people can use it, if you have three projects in three checkouts that all have to be coordinated and merged in order so that you don&#x27;t accidentally break your environment and worry about security and and and....<p>One is <i>much</i> simpler than the other. Artifact management is surprisingly complex, it only looks like it works great while you aren&#x27;t managing many versions and acting more like a monolith, just spread across repos&#x2F;deploy points.</div><br/><div id="38079712" class="c"><input type="checkbox" id="c-38079712" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38079082">parent</a><span>|</span><a href="#38079864">next</a><span>|</span><label class="collapse" for="c-38079712">[-]</label><label class="expand" for="c-38079712">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s the difference between drag-dropping a reference between &quot;projects&quot; or whatnot in your monolith project, or coming up with a publish pipeline after which your merged code gets into the repo so that other people can use it<p>You already have that pipeline for release&#x2F;deployment though, don&#x27;t you? (And it&#x27;s already hooked up to your SSO or what have you).<p>&gt; if you have three projects in three checkouts that all have to be coordinated and merged in order so that you don&#x27;t accidentally break your environment and worry about security and and and....<p>It&#x27;s the same as any other library dependency though, which is a completely normal thing to deal with. The cost of separating your pieces enough that you can use different versions of a library in different services is that you can use different versions of a library in different services.<p>I&#x27;m skeptical about microservices as a deployment model, but I&#x27;m absolutely convinced that code-level modularisation and independent release cycles for things that deploy independently are worthwhile, at least if your language ecosystem has decent dependency management.</div><br/></div></div><div id="38079864" class="c"><input type="checkbox" id="c-38079864" checked=""/><div class="controls bullet"><span class="by">briHass</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38079082">parent</a><span>|</span><a href="#38079712">prev</a><span>|</span><a href="#38075036">next</a><span>|</span><label class="collapse" for="c-38079864">[-]</label><label class="expand" for="c-38079864">[1 more]</label></div><br/><div class="children"><div class="content">The only way package feed complexity works -- and really microservices in general -- is to be absolutely fastidious about backwards compatibility of your packages and as open as possible with transitive dependency versions.<p>Nuget does provide mechanisms for obsoleting packages, so it&#x27;s reasonable to enforce that new packages should allow for a few versions worth of backwards compatibility before deprecation and finally pulling the plug.</div><br/></div></div></div></div></div></div><div id="38075036" class="c"><input type="checkbox" id="c-38075036" checked=""/><div class="controls bullet"><span class="by">ValtteriL</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073302">parent</a><span>|</span><a href="#38078165">prev</a><span>|</span><a href="#38075661">next</a><span>|</span><label class="collapse" for="c-38075036">[-]</label><label class="expand" for="c-38075036">[3 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t you share them via shared libraries in .NET?</div><br/><div id="38076765" class="c"><input type="checkbox" id="c-38076765" checked=""/><div class="controls bullet"><span class="by">jcmontx</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38075036">parent</a><span>|</span><a href="#38075661">next</a><span>|</span><label class="collapse" for="c-38076765">[-]</label><label class="expand" for="c-38076765">[2 more]</label></div><br/><div class="children"><div class="content">YMMV but I think you can only do that if you have a monorepo with the shared library and all the microservices</div><br/><div id="38076995" class="c"><input type="checkbox" id="c-38076995" checked=""/><div class="controls bullet"><span class="by">Atotalnoob</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38076765">parent</a><span>|</span><a href="#38075661">next</a><span>|</span><label class="collapse" for="c-38076995">[-]</label><label class="expand" for="c-38076995">[1 more]</label></div><br/><div class="children"><div class="content">You can, but it’s just kind of hinky, you end up relying on a specific path for the shared library</div><br/></div></div></div></div></div></div></div></div><div id="38081489" class="c"><input type="checkbox" id="c-38081489" checked=""/><div class="controls bullet"><span class="by">switch007</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073048">parent</a><span>|</span><a href="#38073302">prev</a><span>|</span><a href="#38074684">next</a><span>|</span><label class="collapse" for="c-38081489">[-]</label><label class="expand" for="c-38081489">[1 more]</label></div><br/><div class="children"><div class="content">You need a CTO with a backbone to say no to the senior people hell bent on padding their resumes and scratching an itch though<p>Too often devs weaponise micro services and say it’s one of the key reasons for microservices is to allow free language choice !</div><br/></div></div><div id="38074684" class="c"><input type="checkbox" id="c-38074684" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38073048">parent</a><span>|</span><a href="#38081489">prev</a><span>|</span><a href="#38072710">next</a><span>|</span><label class="collapse" for="c-38074684">[-]</label><label class="expand" for="c-38074684">[4 more]</label></div><br/><div class="children"><div class="content">Ideally you would use the same language if it had distributed support. Use Erlang or Elixir for example and you have everything you need for IPC out of the box. Might take a little bit more effort if you&#x27;re on Kubernetes.<p>One of my problems with microservices isn&#x27;t really the services themselves, but the insane amount of tooling that creeps in: GRPC, Kafka, custom JSON APIs, protobufs, etc. etc. and a lot of them exist in some form to communicate between services.</div><br/><div id="38075093" class="c"><input type="checkbox" id="c-38075093" checked=""/><div class="controls bullet"><span class="by">tsss</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38074684">parent</a><span>|</span><a href="#38072710">next</a><span>|</span><label class="collapse" for="c-38075093">[-]</label><label class="expand" for="c-38075093">[3 more]</label></div><br/><div class="children"><div class="content">If you do so much IPC that you have to design your language around it you&#x27;re probably doing it wrong. I don&#x27;t think that moving to a monolith would really cut down that much on other technologies. Maybe you can do without Kafka, but certainly you will need some other kind of persistent message queue. You will still need API docs and E2E integration tests.</div><br/><div id="38079155" class="c"><input type="checkbox" id="c-38079155" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38075093">parent</a><span>|</span><a href="#38075460">next</a><span>|</span><label class="collapse" for="c-38079155">[-]</label><label class="expand" for="c-38079155">[1 more]</label></div><br/><div class="children"><div class="content">&quot;You will still need API docs&quot;<p>Been free in my IDE since I compiled the code...<p>&quot;E2E integration tests&quot;<p>I can mostly run these on my machine, no need to stand up a cluster to get it running (bonus points if you virt multiple machines on one and still don&#x27;t need the cluster for complex distributed scenarios).<p>&quot;you will need some other kind of persistent message queue&quot;<p>var queue = new Queue();
&#x2F;&#x2F; then sometime later...
queue.Save();
&#x2F;&#x2F; or
queue.EmplaceAndSave(); ... queue.Pop();<p>Trivial and didn&#x27;t need a server to set it up.<p>Lots of tech stack stuff simply disappears without server boundaries and the like to get in the way. There is <i>other</i> tech you have to deal with, but at the small scales it mostly doesn&#x27;t apply. Which, you as a dev are usually only working at small, testing scales, so you don&#x27;t usually need to support it.</div><br/></div></div><div id="38075460" class="c"><input type="checkbox" id="c-38075460" checked=""/><div class="controls bullet"><span class="by">jocaal</span><span>|</span><a href="#38072226">root</a><span>|</span><a href="#38075093">parent</a><span>|</span><a href="#38079155">prev</a><span>|</span><a href="#38072710">next</a><span>|</span><label class="collapse" for="c-38075460">[-]</label><label class="expand" for="c-38075460">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you do so much IPC that you have to design your language around it you&#x27;re probably doing it wrong...<p>I&#x27;m gonna have to disagree with this. Often when languages add features to their core, it allows for a very different (and often better) approach to writing code. Think Lisp with first class functions, or Rust with the borrow checker. Why should concurrency be any different? This feels like a Blub moment and I would highly recommend you give erlang or elixir a try, just to see what it is about.</div><br/></div></div></div></div></div></div></div></div><div id="38072710" class="c"><input type="checkbox" id="c-38072710" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38072226">parent</a><span>|</span><a href="#38073048">prev</a><span>|</span><a href="#38078636">next</a><span>|</span><label class="collapse" for="c-38072710">[-]</label><label class="expand" for="c-38072710">[1 more]</label></div><br/><div class="children"><div class="content">Word. BTDT, all services getting out of sync etc. Not worth it.</div><br/></div></div></div></div><div id="38071070" class="c"><input type="checkbox" id="c-38071070" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#38072226">prev</a><span>|</span><a href="#38071415">next</a><span>|</span><label class="collapse" for="c-38071070">[-]</label><label class="expand" for="c-38071070">[7 more]</label></div><br/><div class="children"><div class="content">I think people get the modularity wrong. Modularity is important, but I came to conclusion there is another important architectural principle, which I call &quot;single vortex principle&quot;.<p>First, a vortex in a software system is any loop in a data flow. For example, if we send data somewhere, and then we get them back processed, or are in any way influenced by them, we have a vortex. A mutable variable is an example of a really small vortex.<p>Now, the single vortex principle states that there ideally should be only one vortex in the software system, or, restated, every component should know which way its vortex is going.<p>The rationale is when we have two vortices, and we want to compose the modules that form them into a single whole. If the vortices are correctly oriented, composition is easy. If they have opposite orientation, the composition is tricky and requires decision on how the new vortex is oriented. Therefore, it is best if all the vortices in all the modules have the same orientation, and thus form a single vortex.<p>This principle is a generalization of ideas such as Flux pattern, CQRS, event sourcing, and immutability.</div><br/><div id="38080462" class="c"><input type="checkbox" id="c-38080462" checked=""/><div class="controls bullet"><span class="by">porridgeraisin</span><span>|</span><a href="#38071070">parent</a><span>|</span><a href="#38073247">next</a><span>|</span><label class="collapse" for="c-38080462">[-]</label><label class="expand" for="c-38080462">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t quite understand your second-to-last paragraph(the rationale behind...), can you (or someone else) explain it further?</div><br/></div></div><div id="38073247" class="c"><input type="checkbox" id="c-38073247" checked=""/><div class="controls bullet"><span class="by">Freebytes</span><span>|</span><a href="#38071070">parent</a><span>|</span><a href="#38080462">prev</a><span>|</span><a href="#38071908">next</a><span>|</span><label class="collapse" for="c-38073247">[-]</label><label class="expand" for="c-38073247">[2 more]</label></div><br/><div class="children"><div class="content">This is a very good point, and you could probably write quite a few articles about this particular subject.  You may even have a service A that calls service B that calls service C that calls service A.  Then you have a problem.  Or, you have C get blocked by something happening in A that was unexpected.  Ideally, you only have parents calling children without relying on the parents whatsoever, and if you fail in this, you have failed in your architecture.</div><br/><div id="38080645" class="c"><input type="checkbox" id="c-38080645" checked=""/><div class="controls bullet"><span class="by">andreygrehov</span><span>|</span><a href="#38071070">root</a><span>|</span><a href="#38073247">parent</a><span>|</span><a href="#38071908">next</a><span>|</span><label class="collapse" for="c-38080645">[-]</label><label class="expand" for="c-38080645">[1 more]</label></div><br/><div class="children"><div class="content">I think Robert C. Martin has already described that fairly well [1] [2].<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=N7agCpAYp1Q">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=N7agCpAYp1Q</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Acyclic_dependencies_principle" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Acyclic_dependencies_principle</a></div><br/></div></div></div></div><div id="38071908" class="c"><input type="checkbox" id="c-38071908" checked=""/><div class="controls bullet"><span class="by">salvadormon</span><span>|</span><a href="#38071070">parent</a><span>|</span><a href="#38073247">prev</a><span>|</span><a href="#38071415">next</a><span>|</span><label class="collapse" for="c-38071908">[-]</label><label class="expand" for="c-38071908">[3 more]</label></div><br/><div class="children"><div class="content">I find this vortex concept interesting. Do you have any books or online sources that I could use to study this?</div><br/><div id="38071963" class="c"><input type="checkbox" id="c-38071963" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#38071070">root</a><span>|</span><a href="#38071908">parent</a><span>|</span><a href="#38073315">next</a><span>|</span><label class="collapse" for="c-38071963">[-]</label><label class="expand" for="c-38071963">[1 more]</label></div><br/><div class="children"><div class="content">No, I made it all up. I wish I had time and interest to formalize it.</div><br/></div></div><div id="38073315" class="c"><input type="checkbox" id="c-38073315" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38071070">root</a><span>|</span><a href="#38071908">parent</a><span>|</span><a href="#38071963">prev</a><span>|</span><a href="#38071415">next</a><span>|</span><label class="collapse" for="c-38073315">[-]</label><label class="expand" for="c-38073315">[1 more]</label></div><br/><div class="children"><div class="content">It’s called engineering. &#x2F;s</div><br/></div></div></div></div></div></div><div id="38071415" class="c"><input type="checkbox" id="c-38071415" checked=""/><div class="controls bullet"><span class="by">sazz</span><span>|</span><a href="#38071070">prev</a><span>|</span><a href="#38072284">next</a><span>|</span><label class="collapse" for="c-38071415">[-]</label><label class="expand" for="c-38071415">[2 more]</label></div><br/><div class="children"><div class="content">Speaking from a Release Management point of view going from a monolith to microservices is often done for the wrong reasons.<p>The only valid reason for actual doing the change seems to be for scaling reasons due to performance bottlenecks. Everything else is just shifting complexity from software development to system maintenance.<p>Of course, developers will be happy that they have that huge &quot;alignment with other teams&quot; burden off their shoulders. But the clarity when and how a feature is implemented, properly tested across microservices and then activated and hypercared on production will be much harder to reach if the communication between the development teams is not mature enough (which is often the actual reason from breaking up the monolith).</div><br/><div id="38072009" class="c"><input type="checkbox" id="c-38072009" checked=""/><div class="controls bullet"><span class="by">altairTF</span><span>|</span><a href="#38071415">parent</a><span>|</span><a href="#38072284">next</a><span>|</span><label class="collapse" for="c-38072009">[-]</label><label class="expand" for="c-38072009">[1 more]</label></div><br/><div class="children"><div class="content">This is the sole reason we&#x27;re considering breaking this out into a separate component of our app. It&#x27;s become too large to maintain effectively. The rest of the app will remain unchanged</div><br/></div></div></div></div><div id="38072284" class="c"><input type="checkbox" id="c-38072284" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#38071415">prev</a><span>|</span><a href="#38071694">next</a><span>|</span><label class="collapse" for="c-38072284">[-]</label><label class="expand" for="c-38072284">[2 more]</label></div><br/><div class="children"><div class="content">So where&#x27;s &quot;the costs of monoliths&quot; post? They don&#x27;t show up here, because everyone is out there cluelessly implementing microservices and only sees those problems. If everyone were out there cluelessly implementing monoliths, we&#x27;d see a lot of &quot;monoliths bad&quot; posts.<p>People don&#x27;t understand that these systems lead to the same amount of problems. It&#x27;s like asking an elephant to do a task, or asking 1000 mice. Guess what? Both are going to have problems performing the task - they&#x27;re just different problems. But you&#x27;re not going to get away from having to deal with problems.<p>You can&#x27;t just pick one or the other and expect your problems to go away. <i>You will have problems either way.</i> You just need to pick one and provide solutions. If &#x27;what kind of architecture&#x27; is your <i>biggest hurdle</i>, please let me work there.</div><br/><div id="38079500" class="c"><input type="checkbox" id="c-38079500" checked=""/><div class="controls bullet"><span class="by">yCombLinks</span><span>|</span><a href="#38072284">parent</a><span>|</span><a href="#38071694">next</a><span>|</span><label class="collapse" for="c-38079500">[-]</label><label class="expand" for="c-38079500">[1 more]</label></div><br/><div class="children"><div class="content">The 8 trillion monolith bad posts are why we are now over inundated with microservices. This is the blowback when people are realizing the cost benefit didn&#x27;t work for them</div><br/></div></div></div></div><div id="38071694" class="c"><input type="checkbox" id="c-38071694" checked=""/><div class="controls bullet"><span class="by">wnolens</span><span>|</span><a href="#38072284">prev</a><span>|</span><a href="#38079516">next</a><span>|</span><label class="collapse" for="c-38071694">[-]</label><label class="expand" for="c-38071694">[13 more]</label></div><br/><div class="children"><div class="content">If a monolith is well-factored, what is the difference between it and co-located microservices?<p>Probably just the interface - function calls become RPC. You accept some overhead for some benefits of treating components individually (patching!)<p>What is the difference between distributed microservices v.s. co-located microservices?<p>Deployment is more complex, but you get to intelligently assign processes to more optimal hardware. Number of failure modes increases, but you get to be more fault tolerant.<p>There&#x27;s no blanket answer here. If you need the benefits, you pay the costs. I think a lot of these microservice v.s. monolith arguments come from poor application of one pattern or the other, or using inadequate tooling to make your life easier, or mostly - if your software system is 10 years old and you haven&#x27;t been refactoring and re-architecting as you go, it sucks to work on no matter the initial architecture.</div><br/><div id="38073224" class="c"><input type="checkbox" id="c-38073224" checked=""/><div class="controls bullet"><span class="by">elevation</span><span>|</span><a href="#38071694">parent</a><span>|</span><a href="#38073138">next</a><span>|</span><label class="collapse" for="c-38073224">[-]</label><label class="expand" for="c-38073224">[6 more]</label></div><br/><div class="children"><div class="content">Monolith-&gt;microservice is not a trivial change no matter how well-factored it is to begin with -- though being poorly architected could certainly make the transition more difficult!<p>&gt; Probably just the interface - function calls become RPC.<p>This sounds simple, but once &quot;function calls become RPC&quot; then your client app also needs to handle:<p>* DNS server unreachable<p>* DNS server reachable but RPC hostname won&#x27;t resolve<p>* RPC host resolves but not reachable<p>* RPC host reachable but refuses connection<p>* RPC host accepts connection but rejects client authentication<p>* RPC host presents untrusted TLS cert<p>* RPC accepts authentication but this client has exceeded the rate limit<p>* RPC accepts authentication but says 301 moved permanently<p>* RPC host accepts request but it will be x seconds before result is ready<p>* RPC host times out<p>Even for a well-factored app, handling these execution paths robustly probably means rearchitecting to allow you to asynchronously queue and rate limit requests, cache results, handle failure with logarithmic back-off retry, and operate with configurable client credentials, trust store, and resource URLs (so you can honor 301 Moved Permanently) and log all the failures.<p>You&#x27;ll also need additional RPC functions and parameters to provide data that had previously been in context for local function calls.<p>Then the monolith&#x27;s UI may now need to communicate network delays and failures to the user that were impossible before network segmentation could split the app itself.<p>Refactoring into microservices will require significant effort even for the most well built monolith.</div><br/><div id="38079514" class="c"><input type="checkbox" id="c-38079514" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#38071694">root</a><span>|</span><a href="#38073224">parent</a><span>|</span><a href="#38079407">next</a><span>|</span><label class="collapse" for="c-38079514">[-]</label><label class="expand" for="c-38079514">[1 more]</label></div><br/><div class="children"><div class="content">This is why I saw microservices are &quot;closer to the metal&quot;, i.e. they depend more on the physical characteristics of their environment than non-microservices.<p>A function call in a monolith can:<p><pre><code>  * segfault
  * be called with the wrong number of parameters
  * call the wrong function
  * go through but never return
  * substitute itself with another function
</code></pre>
All of which are very similar to the RPC situation. However we practically never see this because of the OS guarantees like memory safety, security, etc, plus there are standardized ways of handling when these problems do occur, notably try &#x2F; catch patterns.<p>These issues <i>can* be abstracted as well, but the advantage of scaling (being close to the metal) is the disadvantage as well (being very close to the hardware abstractions that let you scale).<p>E.g., there is no difference between running a microservice on a scaling computer than guarantees memory access across a cluster with interrupts, etc (some millions of cpus and terabytes of memory), and running it on a bunch of instances, except the hardware. The former is exotic and abstracts the hardware, the later does not and so all these &quot;low level&quot; errors surface with great frequency.</i></div><br/></div></div><div id="38079407" class="c"><input type="checkbox" id="c-38079407" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#38071694">root</a><span>|</span><a href="#38073224">parent</a><span>|</span><a href="#38079514">prev</a><span>|</span><a href="#38074617">next</a><span>|</span><label class="collapse" for="c-38079407">[-]</label><label class="expand" for="c-38079407">[1 more]</label></div><br/><div class="children"><div class="content">That is all true but most languages have semi-sane libraries with semi-sane defaults that handle most of that. Sure you need some config and tuning but it&#x27;s not completely uncharted waters</div><br/></div></div><div id="38074617" class="c"><input type="checkbox" id="c-38074617" checked=""/><div class="controls bullet"><span class="by">ReflectedImage</span><span>|</span><a href="#38071694">root</a><span>|</span><a href="#38073224">parent</a><span>|</span><a href="#38079407">prev</a><span>|</span><a href="#38075451">next</a><span>|</span><label class="collapse" for="c-38074617">[-]</label><label class="expand" for="c-38074617">[1 more]</label></div><br/><div class="children"><div class="content">Microservices not being able to talk to each other the network basically never comes up.<p>What you are saying is outright ridiculous.</div><br/></div></div><div id="38075451" class="c"><input type="checkbox" id="c-38075451" checked=""/><div class="controls bullet"><span class="by">wnolens</span><span>|</span><a href="#38071694">root</a><span>|</span><a href="#38073224">parent</a><span>|</span><a href="#38074617">prev</a><span>|</span><a href="#38075136">next</a><span>|</span><label class="collapse" for="c-38075451">[-]</label><label class="expand" for="c-38075451">[1 more]</label></div><br/><div class="children"><div class="content">I was offering that simplification to compare monolith single host to multi-service single host. No network hops.<p>But yes, you proceed to explain (some of) the complexities of RPC over the network. Security concerns make this even worse. I could go on..<p>Engineering is hard</div><br/></div></div><div id="38075136" class="c"><input type="checkbox" id="c-38075136" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#38071694">root</a><span>|</span><a href="#38073224">parent</a><span>|</span><a href="#38075451">prev</a><span>|</span><a href="#38073138">next</a><span>|</span><label class="collapse" for="c-38075136">[-]</label><label class="expand" for="c-38075136">[1 more]</label></div><br/><div class="children"><div class="content">Honestly we just need better tooling. Where is my micro-service-fleet creator, which handles built-in all these failure modes of RPC calls?</div><br/></div></div></div></div><div id="38073138" class="c"><input type="checkbox" id="c-38073138" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#38071694">parent</a><span>|</span><a href="#38073224">prev</a><span>|</span><a href="#38079446">next</a><span>|</span><label class="collapse" for="c-38073138">[-]</label><label class="expand" for="c-38073138">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Probably just the interface - function calls become RPC.<p>Network calls introduce new failure modes and challenges which require more plumbing.<p>Can I retry this RPC call safely?<p>How about exponential backoff?<p>Is my API load-balancer doing its thing correctly? We&#x27;ll need to monitor it.<p>How about tracing between microservices? Now we need OpenTelemetry or something like that.<p>How harder is it to debug with breakpoints in a microservice architecture?<p>How can I undo a database transaction between 2 microservices?<p>Suddenly your simple function call just became a lot more problematic.</div><br/><div id="38075377" class="c"><input type="checkbox" id="c-38075377" checked=""/><div class="controls bullet"><span class="by">wnolens</span><span>|</span><a href="#38071694">root</a><span>|</span><a href="#38073138">parent</a><span>|</span><a href="#38079446">next</a><span>|</span><label class="collapse" for="c-38075377">[-]</label><label class="expand" for="c-38075377">[2 more]</label></div><br/><div class="children"><div class="content">My first Q was re: monolith on one host to many services on one host.<p>And yes, when going off-host, you&#x27;ll have these issues. One should not employ network hops unnecessarily. Engineering is hard. Doesn&#x27;t make it not worth doing.</div><br/><div id="38079260" class="c"><input type="checkbox" id="c-38079260" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38071694">root</a><span>|</span><a href="#38075377">parent</a><span>|</span><a href="#38079446">next</a><span>|</span><label class="collapse" for="c-38079260">[-]</label><label class="expand" for="c-38079260">[1 more]</label></div><br/><div class="children"><div class="content">Even on one host processes can crash at different times.</div><br/></div></div></div></div></div></div><div id="38079446" class="c"><input type="checkbox" id="c-38079446" checked=""/><div class="controls bullet"><span class="by">yCombLinks</span><span>|</span><a href="#38071694">parent</a><span>|</span><a href="#38073138">prev</a><span>|</span><a href="#38072320">next</a><span>|</span><label class="collapse" for="c-38079446">[-]</label><label class="expand" for="c-38079446">[1 more]</label></div><br/><div class="children"><div class="content">You lose atomic transactions. Every business action is orders of magnitudes more  more complex because of that.</div><br/></div></div><div id="38072320" class="c"><input type="checkbox" id="c-38072320" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38071694">parent</a><span>|</span><a href="#38079446">prev</a><span>|</span><a href="#38073799">next</a><span>|</span><label class="collapse" for="c-38072320">[-]</label><label class="expand" for="c-38072320">[1 more]</label></div><br/><div class="children"><div class="content">From the developer POV, the difference is on the interface. And while we have all kinds of tools to help us keeping a monolith in sync and correct, the few tools we have to help with IPC can not do static evaluations and are absolutely not interactive.<p>From the ops POV, &quot;deploy is more complex&quot; is a large understatement. Each package is one thing that must be managed, with its own specific quirks and issues.</div><br/></div></div><div id="38073799" class="c"><input type="checkbox" id="c-38073799" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#38071694">parent</a><span>|</span><a href="#38072320">prev</a><span>|</span><a href="#38079516">next</a><span>|</span><label class="collapse" for="c-38073799">[-]</label><label class="expand" for="c-38073799">[1 more]</label></div><br/><div class="children"><div class="content">When discussing microservices, the proponents almost always forget the key aspect of this concept, the <i>micro</i> part.  The part that makes this stand out (everyone already heard about services, there&#x27;s no convincing necessary here, if you feel like you need a service, you just make one, and don&#x27;t fret about it).<p>So, whenever someone advocates for this concept, they &quot;forget&quot; to factor in the fragmentation caused by <i>requiring</i> that services be very small.  To make this more concrete: if you have a monolith + microservice, you don&#x27;t have microservices, because the later implies everything is split into tiny services, no monoliths.<p>Most of the arguments in favor of microservices fall apart as soon as you realize that it <i>has to be micro</i>.  And once you back out of the &quot;micro&quot; requirement, you realize that nothing new or nothing deep is being offered.</div><br/></div></div></div></div><div id="38079516" class="c"><input type="checkbox" id="c-38079516" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#38071694">prev</a><span>|</span><a href="#38070994">next</a><span>|</span><label class="collapse" for="c-38079516">[-]</label><label class="expand" for="c-38079516">[4 more]</label></div><br/><div class="children"><div class="content">The article touches on it a bit, but in my experience microservices multiply operational problems (especially at startups where you don&#x27;t have big, dedicated infrastructure teams). All of a sudden you have 5-10x things getting built in CI and deployed. You need some way to debug issues so usually distributed tracing comes up. Now that you have 10x as many of everything, you obviously want to try to centralize things like networking, authn&#x2F;z, service discovery so you introduce some platforms to help with that... but someone has to run and maintain all that. That&#x27;s fine if you want platform&#x2F;infrastructure teams to maintain these but many startups only have a very small handful of people (10% or less of eng) handling CI&#x2F;infra&#x2F;release&#x2F;performance&#x2F;observability&#x2F;networking&#x2F;traffic mgmt with some title like &quot;SRE&quot; or &quot;devops&quot;</div><br/><div id="38079569" class="c"><input type="checkbox" id="c-38079569" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#38079516">parent</a><span>|</span><a href="#38070994">next</a><span>|</span><label class="collapse" for="c-38079569">[-]</label><label class="expand" for="c-38079569">[3 more]</label></div><br/><div class="children"><div class="content">A typical startup with 20k DAU: &quot;We need scale, microservices, k8s, CDNs, etc!&quot;.<p>Stackoverflow: &quot;We run a single .NET-based multi-tenant web app running across just nine web servers, at 5% to 10% of capacity&quot; [1].<p>Hacker News: &quot;HN still runs on one core, at least the part that serves logged-in requests, and yes this will all get better someday...it kills me that this isn&#x27;t done yet but one day you will all see.&quot; [2]. HN had ~12M MAU by the end of 2022.<p>[1]: <a href="https:&#x2F;&#x2F;www.datacenterdynamics.com&#x2F;en&#x2F;news&#x2F;stack-overflow-still-on-prem-runs-qa-platform-off-just-nine-servers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.datacenterdynamics.com&#x2F;en&#x2F;news&#x2F;stack-overflow-st...</a><p>[2]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35157344">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35157344</a></div><br/><div id="38079691" class="c"><input type="checkbox" id="c-38079691" checked=""/><div class="controls bullet"><span class="by">rospaya</span><span>|</span><a href="#38079516">root</a><span>|</span><a href="#38079569">parent</a><span>|</span><a href="#38070994">next</a><span>|</span><label class="collapse" for="c-38079691">[-]</label><label class="expand" for="c-38079691">[2 more]</label></div><br/><div class="children"><div class="content">Does HN have the SLA and uptime that the startup signed with their clients and will half an hour of downtime sink HN?</div><br/><div id="38079931" class="c"><input type="checkbox" id="c-38079931" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#38079516">root</a><span>|</span><a href="#38079691">parent</a><span>|</span><a href="#38070994">next</a><span>|</span><label class="collapse" for="c-38079931">[-]</label><label class="expand" for="c-38079931">[1 more]</label></div><br/><div class="children"><div class="content">No. A number of startups don&#x27;t either. I hazard to say that even giants like Tinder or Uber likely can have a 30 min outage and lose some revenue and goodwill, but not be hit by some exorbitant liabilities.<p>Also, microservices add both resilience (by running many copies) and fragility (many loosely coupled moving parts). Which effect prevails, depends on many factors.</div><br/></div></div></div></div></div></div></div></div><div id="38070994" class="c"><input type="checkbox" id="c-38070994" checked=""/><div class="controls bullet"><span class="by">aleksiy123</span><span>|</span><a href="#38079516">prev</a><span>|</span><a href="#38073465">next</a><span>|</span><label class="collapse" for="c-38070994">[-]</label><label class="expand" for="c-38070994">[6 more]</label></div><br/><div class="children"><div class="content">I recently had some discussions and did some research on this topic and I feel like there is a lot people don&#x27;t talk about in these articles.<p>Here are some more considerations between micro services and monolothic tradeoffs. Its also important to consider these two things as a scale and not a binary decision.<p>1. Isolation. Failure in on service doesn&#x27;t fail the whole system. Smaller services have better isolation.<p>2. Capacity management. Its easier to estimate the resource usage of a smaller service because it has less responsibilities. This can result in efficiency gains. Extended to this is you can also give optimized resources to specific services. A prediction service can use GPU while web server can use CPU only. A monolothic may need to use compute with both which could result in less optimized resources.<p>3. Dev Ops Overhead. In general monolothic services have less management overhead because you only need to manage&#x2F;deploy one or few services over many.<p>4. Authorization&#x2F;Permissions. Smaller services can be given a smaller scope permissions.<p>5. Locality. Monolothic can share memory and therefore have better data locality. Small services use networks and have higher overhead.<p>6. Ownership. Smaller services can have more granular ownership. Its easier to transfer ownership.<p>7. Iteration. Smaller services can move independently of one another and can release at seperate cadences.</div><br/><div id="38071120" class="c"><input type="checkbox" id="c-38071120" checked=""/><div class="controls bullet"><span class="by">tazard</span><span>|</span><a href="#38070994">parent</a><span>|</span><a href="#38071430">next</a><span>|</span><label class="collapse" for="c-38071120">[-]</label><label class="expand" for="c-38071120">[3 more]</label></div><br/><div class="children"><div class="content">1. Isolation<p>With a well built monolith, a failure on a service won&#x27;t fail the whole system.<p>For poorly built microservices, a failure on a service absolutely does being down the whole system.<p>Not sure I am convinced that by adopting microservices, your code automatically gets better isolation</div><br/><div id="38073345" class="c"><input type="checkbox" id="c-38073345" checked=""/><div class="controls bullet"><span class="by">scurvy_steve</span><span>|</span><a href="#38070994">root</a><span>|</span><a href="#38071120">parent</a><span>|</span><a href="#38071296">next</a><span>|</span><label class="collapse" for="c-38073345">[-]</label><label class="expand" for="c-38073345">[1 more]</label></div><br/><div class="children"><div class="content">I work on low code cloud ETL tools. We provide the flexibility for the customer to do stupid things. This means we have extremely high variance in resource utilization.<p>An on demand button press can start a processes that runs for multiple days, and this is expected. A job can do 100k API requests or read&#x2F;transform&#x2F;write millions of records from a database, this is also expected. Out of memory errors happen often and are expected. It&#x27;s not our bad code, its the customer&#x27;s bad code.<p>Since jobs are run as microservices on isolated machines, this is all fine. A customer(or multiple at once) can set up something badly, run out of resources, and fail or go really slow and nobody is effected but them.</div><br/></div></div><div id="38071296" class="c"><input type="checkbox" id="c-38071296" checked=""/><div class="controls bullet"><span class="by">aleksiy123</span><span>|</span><a href="#38070994">root</a><span>|</span><a href="#38071120">parent</a><span>|</span><a href="#38073345">prev</a><span>|</span><a href="#38071430">next</a><span>|</span><label class="collapse" for="c-38071296">[-]</label><label class="expand" for="c-38071296">[1 more]</label></div><br/><div class="children"><div class="content">Its not automatic but it has the potential for more isolation by definition.<p>If your service has memory leak, crash it only takes down the service. It is still up to your system to handle such a failure gracefully. If such a service is a critical dependency then your system fails. But if it is not then your service can still partially function.<p>If your monolith has memory leak, or crash it takes down the whole monolith.</div><br/></div></div></div></div><div id="38071430" class="c"><input type="checkbox" id="c-38071430" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38070994">parent</a><span>|</span><a href="#38071120">prev</a><span>|</span><a href="#38073465">next</a><span>|</span><label class="collapse" for="c-38071430">[-]</label><label class="expand" for="c-38071430">[2 more]</label></div><br/><div class="children"><div class="content">1. Except that a single process usually involves multiple services and the failure of one service often makes entire sequences impossible.</div><br/><div id="38071819" class="c"><input type="checkbox" id="c-38071819" checked=""/><div class="controls bullet"><span class="by">aleksiy123</span><span>|</span><a href="#38070994">root</a><span>|</span><a href="#38071430">parent</a><span>|</span><a href="#38073465">next</a><span>|</span><label class="collapse" for="c-38071819">[-]</label><label class="expand" for="c-38071819">[1 more]</label></div><br/><div class="children"><div class="content">But not all sequences. It depends on your dependencies. Some services are critical for some processes. In the monoloth design its a critical dependency for all processes.</div><br/></div></div></div></div></div></div><div id="38073465" class="c"><input type="checkbox" id="c-38073465" checked=""/><div class="controls bullet"><span class="by">PedroBatista</span><span>|</span><a href="#38070994">prev</a><span>|</span><a href="#38070747">next</a><span>|</span><label class="collapse" for="c-38073465">[-]</label><label class="expand" for="c-38073465">[8 more]</label></div><br/><div class="children"><div class="content">Similarly with frontend devs thinking a &quot;modern web-app&quot; can only be built with frontend frameworks&#x2F;libs like React&#x2F;Vue&#x2F;Svelte, etc, lately I feel there&#x27;s an idea floating around that &quot;monolith&quot; equals running that scary big black ball of tar as a single instance and therefore &quot;it doesn&#x27;t scale&quot;, which is insane.<p>Another observation is the overall amount of code is much bigger and most of these services are ~20% business&#x2F;domain code and ~80% having to deal with sending and receiving messages from other process over the network. You can hide it all you want, but at the end of the day it&#x27;s there and you&#x27;ll have to deal with the network in one way of another.<p>Just like the frontend madness, this microservice cult will only end once the economy goes to crap and there&#x27;s no money to support all these Babel Towers of Doom.<p>PS: microservices have a place, which is inside a select few of companies that get something out of it more than the cost they pay.</div><br/><div id="38073624" class="c"><input type="checkbox" id="c-38073624" checked=""/><div class="controls bullet"><span class="by">superfrank</span><span>|</span><a href="#38073465">parent</a><span>|</span><a href="#38077198">next</a><span>|</span><label class="collapse" for="c-38073624">[-]</label><label class="expand" for="c-38073624">[2 more]</label></div><br/><div class="children"><div class="content">I think the thing people normally miss about microservices is that the goal of microservices is usually to solve organization and people problems and not technological ones. There&#x27;s some tech benefits like allowing services to scale independently, but the biggest benefit is clear ownership boundaries and preventing code from becoming overly coupled where it doesn&#x27;t need to be.<p>If you&#x27;re a team small team working on a single product you probably don&#x27;t need microservices since you likely don&#x27;t have the type of organizational problems that microservices solve. Microservices are likely premature optimization and you&#x27;re paying the price to solve problems you don&#x27;t yet have.</div><br/><div id="38074438" class="c"><input type="checkbox" id="c-38074438" checked=""/><div class="controls bullet"><span class="by">koliber</span><span>|</span><a href="#38073465">root</a><span>|</span><a href="#38073624">parent</a><span>|</span><a href="#38077198">next</a><span>|</span><label class="collapse" for="c-38074438">[-]</label><label class="expand" for="c-38074438">[1 more]</label></div><br/><div class="children"><div class="content">Yep.<p>There are situations where microservices genuinely add net value. In discussions like this one, people make valid points for microservices and for
monoliths. Often, words like “large” and “many” are used without providing a sense of scale.<p>Hers is a heuristic. It’s not a hard rule. There are likely good counter examples. It does sketch a boundary for the for&#x2F;against equation for microservices. Would love to hear feedback about whether “100” is that number or a different heuristic would be more accurate.<p>Engineering departments with fewer than 100 engineers should favor monoliths and seriously question efforts to embrace microservices. Above that, there’s an increasing chance the microservices could provide value, but teams should stick to a monolith as long as possible.</div><br/></div></div></div></div><div id="38077198" class="c"><input type="checkbox" id="c-38077198" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#38073465">parent</a><span>|</span><a href="#38073624">prev</a><span>|</span><a href="#38075482">next</a><span>|</span><label class="collapse" for="c-38077198">[-]</label><label class="expand" for="c-38077198">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Similarly with frontend devs thinking a &quot;modern web-app&quot; can only be built with frontend frameworks&#x2F;libs like React&#x2F;Vue&#x2F;Svelte<p>Those aren’t frameworks, they are view libraries and I’ll die on that hill.<p>Further, front end complexity is all in your head: <a href="https:&#x2F;&#x2F;bower.sh&#x2F;front-end-complexity" rel="nofollow noreferrer">https:&#x2F;&#x2F;bower.sh&#x2F;front-end-complexity</a></div><br/><div id="38077847" class="c"><input type="checkbox" id="c-38077847" checked=""/><div class="controls bullet"><span class="by">PedroBatista</span><span>|</span><a href="#38073465">root</a><span>|</span><a href="#38077198">parent</a><span>|</span><a href="#38075482">next</a><span>|</span><label class="collapse" for="c-38077847">[-]</label><label class="expand" for="c-38077847">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why I included &quot;&#x2F;libs&quot;, for people like you :)<p>To be clear, for me they are libraries, but realistically people use them as frameworks, as in &quot;standard&quot; ways to think, &quot;frame&quot; and implement something.<p>But because I&#x27;m not dying on any hill specially front-end ones, I&#x27;ll take a right then a left and go on my way.</div><br/></div></div></div></div><div id="38075482" class="c"><input type="checkbox" id="c-38075482" checked=""/><div class="controls bullet"><span class="by">economist420</span><span>|</span><a href="#38073465">parent</a><span>|</span><a href="#38077198">prev</a><span>|</span><a href="#38070747">next</a><span>|</span><label class="collapse" for="c-38075482">[-]</label><label class="expand" for="c-38075482">[3 more]</label></div><br/><div class="children"><div class="content">While I agree with you that a lot of websites overuse javascript and frameworks. Can you tell me what else I&#x27;m supposed to use if I&#x27;m going to build a desktop class web app without it becoming a huge mess or I having to end up up inventing the same concepts already existing in these frameworks?</div><br/><div id="38076494" class="c"><input type="checkbox" id="c-38076494" checked=""/><div class="controls bullet"><span class="by">PedroBatista</span><span>|</span><a href="#38073465">root</a><span>|</span><a href="#38075482">parent</a><span>|</span><a href="#38070747">next</a><span>|</span><label class="collapse" for="c-38076494">[-]</label><label class="expand" for="c-38076494">[2 more]</label></div><br/><div class="children"><div class="content">&quot;desktop class web app&quot; is a subset of &quot;modern web-app&quot;. If you need frameworks, use them.</div><br/><div id="38076861" class="c"><input type="checkbox" id="c-38076861" checked=""/><div class="controls bullet"><span class="by">economist420</span><span>|</span><a href="#38073465">root</a><span>|</span><a href="#38076494">parent</a><span>|</span><a href="#38070747">next</a><span>|</span><label class="collapse" for="c-38076861">[-]</label><label class="expand" for="c-38076861">[1 more]</label></div><br/><div class="children"><div class="content">The meaning behind these is pretty blurry between whats considered a website vs an app, it&#x27;s a spectrum. I consider a web app something that has a similar UI experience to a desktop app, as the word &quot;application&quot; came derived from the desktop.</div><br/></div></div></div></div></div></div></div></div><div id="38070747" class="c"><input type="checkbox" id="c-38070747" checked=""/><div class="controls bullet"><span class="by">spott</span><span>|</span><a href="#38073465">prev</a><span>|</span><a href="#38070561">next</a><span>|</span><label class="collapse" for="c-38070747">[-]</label><label class="expand" for="c-38070747">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Microservices&quot; has always been weird to me.<p>People argue for them from two different, drastically different, points of view:<p>* Microservices become necessary at some point because they allow you to independently scale different parts of the application depending on load.<p>* Microservices become necessary at some point because they allow you to create hard team boundaries to enforce code boundaries.<p>Personal opinion: micro services are always thrown out there as a solution to the second problem because it is easier to split a service out of a monolith than it is to put the genie of bad code boundaries back in the box.<p>An application goes through a few stages of growth:<p>1) When it starts, good boundaries are really hard to define because no-one knows what the application looks like.  So whatever boundaries are defined are constantly violated because they were bad abstraction layers in the first place.<p>2) After a while, when the institutional knowledge is available to figure out what the boundaries are, it would require significant rewrites&#x2F;refactoring to enforce them.<p>3) Since a rewrite&#x2F;major refactor is necessary either way, everyone pushes to go to micro services because they are a good resume builder for leadership, and &quot;we might need the ability to scale&quot;, or people think it will be easier (&quot;we can splinter off this service!&quot;, ignoring the fact that they can splinter it off within the monolith without having to deal with networks and REST overhead).<p>Unfortunately, this means that everyone has this idea that micro services are <i>necessary</i> for code boundaries because so many teams with good code boundaries are using micro services.</div><br/><div id="38070871" class="c"><input type="checkbox" id="c-38070871" checked=""/><div class="controls bullet"><span class="by">soco</span><span>|</span><a href="#38070747">parent</a><span>|</span><a href="#38070561">next</a><span>|</span><label class="collapse" for="c-38070871">[-]</label><label class="expand" for="c-38070871">[1 more]</label></div><br/><div class="children"><div class="content">Granular performance and team boundaries are both valid points. But, I haven&#x27;t seen yet (around me) monolith applications so complex to have more teams working on them. I&#x27;ve seen instead applications developed by two persons where some higher-ups requested splitting them into microservices just because (no, scaling wasn&#x27;t needed).</div><br/></div></div></div></div><div id="38070561" class="c"><input type="checkbox" id="c-38070561" checked=""/><div class="controls bullet"><span class="by">Symmetry</span><span>|</span><a href="#38070747">prev</a><span>|</span><a href="#38071999">next</a><span>|</span><label class="collapse" for="c-38070561">[-]</label><label class="expand" for="c-38070561">[1 more]</label></div><br/><div class="children"><div class="content">In the robotics world it&#x27;s pretty common to have something that looks a lot like microservices as an organizing principle.  ROS[1] would probably the robotics framework that everybody cuts their teeth on and in that you have a number of processes communicating over a pub&#x2F;sub network.  Some of the reasons for organizing this way would be familiar to someone doing websites, but you also have factors like vendors for sensors you need providing libraries that will occasionally segfault, and needing to be able to recover from that.<p>[1]<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robot_Operating_System" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robot_Operating_System</a></div><br/></div></div><div id="38071999" class="c"><input type="checkbox" id="c-38071999" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#38070561">prev</a><span>|</span><a href="#38071985">next</a><span>|</span><label class="collapse" for="c-38071999">[-]</label><label class="expand" for="c-38071999">[2 more]</label></div><br/><div class="children"><div class="content">Last time I did a survey of my peers, companies that were all in on microservices in the cloud spent about 25% of their engineering time on the support systems for microservices.  That number is probably a bit lower now since there are some pretty good tools to handle a lot of the basics.<p>And the author sums up the advice I&#x27;ve been giving for a long time perfectly:<p>&gt; Splitting an application into services adds a lot of complexity to the overall system. Because of that, it’s generally best to start with a monolith and split it up only when there is a good reason to do so.<p>And usually that good reason is that you need to optimize a particular part of the system (which often manifests as using another language) or your organization has grown such that the overhead of microservices is cheaper than the management overhead.<p>But some of the things in this article are not quite right.<p>&gt; Nothing forbids the use of different languages, libraries, and datastores for each microservice - but doing so transforms the application into an unmaintainable mess.<p>You build a sidecar in a specific language, and any library you produce for others to consume is for that language&#x2F;sidecar. Then you can write your service in any language you want.  Chances are it will be one of a few languages anyway that have a preferred onramp (as mentioned in the article), and if it&#x27;s not, then there is probably a good reason another language was chosen, assuming you have strong technical leadership.<p>&gt; Unlike with a monolith, it’s much more expensive to staff each team responsible for a service with its own operations team. As a result, the team that develops a service is typically also on-call for it. This creates friction between development work and operational toll as the team needs to decide what to prioritize during each sprint.<p>A well run platform removes most of the ops responsibility from the team.  The only thing they really have to worry about is if they have built their system in a way to handle failures well (chaos engineering to the rescue!) and if they have any runaway algorithms.  Otherwise it&#x27;s a good thing that they take on that ops load, because it helps them prioritize fixing things that break a lot.</div><br/><div id="38079463" class="c"><input type="checkbox" id="c-38079463" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#38071999">parent</a><span>|</span><a href="#38071985">next</a><span>|</span><label class="collapse" for="c-38079463">[-]</label><label class="expand" for="c-38079463">[1 more]</label></div><br/><div class="children"><div class="content">&gt;A well run platform removes most of the ops responsibility from the team<p>It might remove most of the responsibility from the original team but it transfers it somewhere else. Making sure the new &quot;platform team&quot; is well staffed is something I don&#x27;t see mentioned&#x2F;discussed very often in the context of microservices</div><br/></div></div></div></div><div id="38071985" class="c"><input type="checkbox" id="c-38071985" checked=""/><div class="controls bullet"><span class="by">dec0dedab0de</span><span>|</span><a href="#38071999">prev</a><span>|</span><a href="#38076922">next</a><span>|</span><label class="collapse" for="c-38071985">[-]</label><label class="expand" for="c-38071985">[1 more]</label></div><br/><div class="children"><div class="content">Modern micro services are ridiculous, with few exceptions. IIRC the original idea of micro-services was that each team in a large company should provide a documented API for the rest of the company to use instead of just a web page or a manual process.  this is in contrast to their being only one development team that decides what gets worked on. Which allows individual employees to automate bigger processes that include steps outside of their own department. Somehow that changed to people spinning up containers for things that could be a function.</div><br/></div></div><div id="38076922" class="c"><input type="checkbox" id="c-38076922" checked=""/><div class="controls bullet"><span class="by">shoelessone</span><span>|</span><a href="#38071985">prev</a><span>|</span><a href="#38074153">next</a><span>|</span><label class="collapse" for="c-38076922">[-]</label><label class="expand" for="c-38076922">[2 more]</label></div><br/><div class="children"><div class="content">Anytime these discussions come up I always wonder if there are any great examples in the form of a deep technical analysis of  microservice architecture?<p>I&#x27;ve built things that I&#x27;ve called microservices, but generally have failed to do a complete job or always left with something that feels more like a monolith with a few bits broken out to match scaling patterns.<p>I know there are talks and papers by Netflix for example, but if anybody knows if any smaller scale, easier to grok talks or papers that go into common pitfalls and solve them for real (vs giving a handwavey solution that sounds good but isn&#x27;t concrete) I&#x27;d love to check it out.</div><br/><div id="38077075" class="c"><input type="checkbox" id="c-38077075" checked=""/><div class="controls bullet"><span class="by">screamingninja</span><span>|</span><a href="#38076922">parent</a><span>|</span><a href="#38074153">next</a><span>|</span><label class="collapse" for="c-38077075">[-]</label><label class="expand" for="c-38077075">[1 more]</label></div><br/><div class="children"><div class="content">This is my gold reference: <a href="https:&#x2F;&#x2F;microservices.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;microservices.io&#x2F;</a><p>Most issues I have seen around microservices circle around bad design decisions or poor implementations. Both are also major issues for monoliths, but since those issues do not surface early on, it is easier to start developing a monolith and take on the technical debt to be dealt with later on.<p>Microservices architecture takes time and effort, but pays huge dividends in the long run.</div><br/></div></div></div></div><div id="38074153" class="c"><input type="checkbox" id="c-38074153" checked=""/><div class="controls bullet"><span class="by">highspeedbus</span><span>|</span><a href="#38076922">prev</a><span>|</span><a href="#38077175">next</a><span>|</span><label class="collapse" for="c-38074153">[-]</label><label class="expand" for="c-38074153">[2 more]</label></div><br/><div class="children"><div class="content">Monoliths are like heavy trucks.<p>Microservices are like motorcycles.<p>Surely you can delivery 15 metric tons of wood with either of them. You will just need <i>a lot</i> of motorcycles to match capacity.<p>Somehow a big part of industry became convinced that <i>of course</i> that approach is better, since motorcycles are cheaper*, easier to scale*, and solve some managerial problems*.<p>* They don&#x27;t, IMHO.<p>&gt;its components become increasingly coupled over time<p>&gt;The codebase becomes complex enough that nobody fully understands every part of it<p>&gt;if a change introduces a bug - like a memory leak - the entire service can potentially be affected by it.<p>I believe the only real solution to those challenges is Competency, or Programmer Professionalism. Uncle Bob had some great points on this topic.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=BSaAMQVq01E">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=BSaAMQVq01E</a></div><br/><div id="38077896" class="c"><input type="checkbox" id="c-38077896" checked=""/><div class="controls bullet"><span class="by">ysleepy</span><span>|</span><a href="#38074153">parent</a><span>|</span><a href="#38077175">next</a><span>|</span><label class="collapse" for="c-38077896">[-]</label><label class="expand" for="c-38077896">[1 more]</label></div><br/><div class="children"><div class="content">Was with you until you mentioned Robert Martin. I have no respect for that shill.</div><br/></div></div></div></div><div id="38077175" class="c"><input type="checkbox" id="c-38077175" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#38074153">prev</a><span>|</span><a href="#38070219">next</a><span>|</span><label class="collapse" for="c-38077175">[-]</label><label class="expand" for="c-38077175">[1 more]</label></div><br/><div class="children"><div class="content">Having an API gateway sounds nice, but that’s not how I’ve seen it. Usually the FE has to query and synchronize multiple API endpoints (eg auth, product, billing).<p>In this case microservices really just means &quot;let the front-end handle the complexity of synchronizing multiple API endpoints.&quot;<p>And then we wonder why the FE is so complex: <a href="https:&#x2F;&#x2F;bower.sh&#x2F;front-end-complexity" rel="nofollow noreferrer">https:&#x2F;&#x2F;bower.sh&#x2F;front-end-complexity</a></div><br/></div></div><div id="38070219" class="c"><input type="checkbox" id="c-38070219" checked=""/><div class="controls bullet"><span class="by">harry_ord</span><span>|</span><a href="#38077175">prev</a><span>|</span><a href="#38078234">next</a><span>|</span><label class="collapse" for="c-38070219">[-]</label><label class="expand" for="c-38070219">[1 more]</label></div><br/><div class="children"><div class="content">My current job hasn&#x27;t been a great experience with microservices. It&#x27;s a industry where I&#x27;ve worked with a monolith that did a lot more but having everything split between like 17 different services makes managing anything not so fun. The other big blocker is small team and only one of us met the original staff who designed this.</div><br/></div></div><div id="38078234" class="c"><input type="checkbox" id="c-38078234" checked=""/><div class="controls bullet"><span class="by">totallywrong</span><span>|</span><a href="#38070219">prev</a><span>|</span><a href="#38075696">next</a><span>|</span><label class="collapse" for="c-38078234">[-]</label><label class="expand" for="c-38078234">[1 more]</label></div><br/><div class="children"><div class="content">As a contractor, having worked with a lot of teams, I get the feeling that the kubernetes and microservices hype a few years ago resulted in a lot of unnecessary refactors. It can make sense, of course, but often doesn&#x27;t, and running a monolith on k8s is perfectly fine.</div><br/></div></div><div id="38075696" class="c"><input type="checkbox" id="c-38075696" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#38078234">prev</a><span>|</span><a href="#38070345">next</a><span>|</span><label class="collapse" for="c-38075696">[-]</label><label class="expand" for="c-38075696">[2 more]</label></div><br/><div class="children"><div class="content">People really underestimate the eventual consistency thing. It&#x27;s 100% the case your app will behave weirdly while it&#x27;s processing some sort of change event. The options for dealing with this are real awkward, because the options for implementing transactions on top of microservices are real awkward. Product will absolutely hate this, and there won&#x27;t really be anything you can do about it. Also fun fact: this scales in reverse, as in the bigger and better your company gets, the worse this problem becomes, because more services = more brains = more latency.<p>Relatedly, you can&#x27;t really do joins. Like, let&#x27;s say you have an organizations service and a people service. You might want to know what people are in which organizations, and paginate results. Welcome to a couple of unpalatable options:<p>- Make some real slow API calls to both services (also implement all the filters and ordering, etc).<p>- Pull all the data you need into this new 3rd service, and justify it by saying you&#x27;re robust in the face of your dependency services failing, but also be aware you&#x27;re adding yet another layer of eventual consistency here too.<p>This is the simplest this problem can be. Imagine needing data from 3 or 13 services. Imagine needing to to synchronize UUIDs from one service to 20 others. Imagine needing to also delete a user&#x2F;organization from the 30 other services that have &quot;cached&quot; it. Etc etc.<p>I used to think microservices were an adaptation to Conway&#x27;s law, but now I really think it&#x27;s a response to the old days when we didn&#x27;t have databases that scaled horizontally. But we do now (Cockroach, Big Query, etc) so we really should just move on.</div><br/><div id="38077115" class="c"><input type="checkbox" id="c-38077115" checked=""/><div class="controls bullet"><span class="by">fullspectrumdev</span><span>|</span><a href="#38075696">parent</a><span>|</span><a href="#38070345">next</a><span>|</span><label class="collapse" for="c-38077115">[-]</label><label class="expand" for="c-38077115">[1 more]</label></div><br/><div class="children"><div class="content">The joins problem is fucking <i>killing</i> me in some personal projects that will need a total rewrite at this point</div><br/></div></div></div></div><div id="38070345" class="c"><input type="checkbox" id="c-38070345" checked=""/><div class="controls bullet"><span class="by">ranting-moth</span><span>|</span><a href="#38075696">prev</a><span>|</span><a href="#38075347">next</a><span>|</span><label class="collapse" for="c-38070345">[-]</label><label class="expand" for="c-38070345">[1 more]</label></div><br/><div class="children"><div class="content">The article mentions Development Experience, but doesn&#x27;t mention what I think is an overlooked huge cost.<p>Bad Development Experience results in unhappy and&#x2F;or frustrated developer. Unhappy and&#x2F;or frustrated developer is usually performing considerably worse than his happier self would.</div><br/></div></div><div id="38075347" class="c"><input type="checkbox" id="c-38075347" checked=""/><div class="controls bullet"><span class="by">Gluber</span><span>|</span><a href="#38070345">prev</a><span>|</span><a href="#38077391">next</a><span>|</span><label class="collapse" for="c-38075347">[-]</label><label class="expand" for="c-38075347">[1 more]</label></div><br/><div class="children"><div class="content">Every company i have advised jumped on the microservice bandwagon some time ago.... 
Here is what I tell them:<p>1. Microservices are a great tool... IF you have a genuine need for them
2. Decoupling in and on itself with services it not a goal
3. Developers who are bad at writing proper modular code in a monolithic setting will not magically write better code in a Microservice environment.. Rather it will get even worse since APIS ( be it GRPC, Restful or whatever ) are even harder to design
4. Most developers have NO clue about consistency or how to achieve certrain gurantees in a microservice setting ( Fun fact: My first question to developers in that area is: Define your notion of consistency, before be get to the fun stuff like RAFT or PAXOS)
5. You don&#x27;t have the problems where microservices shine ( e.g banks with a few thounsands RPS ) 
6. Your communication overhead will dramatically increase 
7. Application A that does not genuinly need microservices will be much cheaper as a monolith with proper code seperation<p>Right now we have generation of developers and managers who don&#x27;T know any better, and just do what everybody else seems to be doing: Microservices and Scrum ... and then wonder why their costs explode.</div><br/></div></div><div id="38070515" class="c"><input type="checkbox" id="c-38070515" checked=""/><div class="controls bullet"><span class="by">abound</span><span>|</span><a href="#38077391">prev</a><span>|</span><a href="#38074550">next</a><span>|</span><label class="collapse" for="c-38070515">[-]</label><label class="expand" for="c-38070515">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m as much of a &quot;build a monolith until you can&#x27;t&quot; person as any, but one motivation for using microservices that I haven&#x27;t seen mentioned here is differing resource&#x2F;infra requirements + usage patterns.<p>Throw the request&#x2F;response-oriented API with bursty traffic on something serverless, run the big async background tasks on beefy VMs (maybe with GPUs!) and scale those down when you&#x27;re done. Run the payments infra on something not internet-facing, etc.<p>Deploying all those use cases as one binary&#x2F;service means you&#x27;ve dramatically over-provisioned&#x2F;underutilized some resources, and your attack service is larger than it should be.</div><br/><div id="38071910" class="c"><input type="checkbox" id="c-38071910" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38070515">parent</a><span>|</span><a href="#38074550">next</a><span>|</span><label class="collapse" for="c-38071910">[-]</label><label class="expand" for="c-38071910">[1 more]</label></div><br/><div class="children"><div class="content">A load balancer can make this work with a monolith. Requests for expensive services can be routed to a separate tier of servers for example.</div><br/></div></div></div></div><div id="38074550" class="c"><input type="checkbox" id="c-38074550" checked=""/><div class="controls bullet"><span class="by">ph4evers</span><span>|</span><a href="#38070515">prev</a><span>|</span><a href="#38076943">next</a><span>|</span><label class="collapse" for="c-38074550">[-]</label><label class="expand" for="c-38074550">[4 more]</label></div><br/><div class="children"><div class="content">I still don’t fully understand what makes something a monolith.<p>For example, I have a big app which is serving 90% of the API traffic. I also have three separate services, one for a camera, one to run ML inference, and one to drive a laser welding process. They are split up because they all need specific hardware and preferably a separate process (one per gpu for example).<p>Is this a monolothic app or a micro service architecture?</div><br/><div id="38075238" class="c"><input type="checkbox" id="c-38075238" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#38074550">parent</a><span>|</span><a href="#38075366">next</a><span>|</span><label class="collapse" for="c-38075238">[-]</label><label class="expand" for="c-38075238">[1 more]</label></div><br/><div class="children"><div class="content">I would call that a micro-service architecture using a mono-repo.<p>I think a lot of people here are conflating mono-repo&#x2F;poly-repo with a mono-deployment. You can easily add in extra entrypoint executables to a single mono-repo. That allows initiating parts of the system on different machines, allowing scaling for skewed API rates across your different request handlers.<p>Similarly, you can create a monolith application building from a poly-repo set of dependencies. This can be easier depending on you version control system, as I find git starts to perform really poorly when you enter multi-million SLOC.<p>At my job we have a custom build system for poly-repos that analyzes dependencies and rebuilds higher level leaf packages for lower level changes. Failing a dependency rebuild gets your version rejected, keeping the overall set of packages green.</div><br/></div></div><div id="38075366" class="c"><input type="checkbox" id="c-38075366" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#38074550">parent</a><span>|</span><a href="#38075238">prev</a><span>|</span><a href="#38075364">next</a><span>|</span><label class="collapse" for="c-38075366">[-]</label><label class="expand" for="c-38075366">[1 more]</label></div><br/><div class="children"><div class="content">I tend to call these things “distributed monoliths” assuming the camera, ML and laser driver are integral to the functionality of the system.<p>There is no hard rule that I know of but my heuristic is something like “can I bring instances up and down randomly without affecting operations (too much)”. If so, I’d call that a microservice(ish) architecture.<p>The waters have been muddied though. Microservices were IMO once associated with Netflix-like scalability, bringing up and down bunches up “instances” without trouble. But nowadays what used to be good old service-oriented architecture (SOA) tend to be also called microservices.<p>SOA can also be about scalability, but it tended to focus more on how to partition the system on (business) boundaries. I guess like you did.<p>It’s all a bit muddy in my experience.</div><br/></div></div><div id="38075364" class="c"><input type="checkbox" id="c-38075364" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#38074550">parent</a><span>|</span><a href="#38075366">prev</a><span>|</span><a href="#38076943">next</a><span>|</span><label class="collapse" for="c-38075364">[-]</label><label class="expand" for="c-38075364">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is this a monolothic app or a micro service architecture?<p>Yes.<p>To be less facetious, the continuum goes from &quot;all the code in a single process&quot; to &quot;every line of code is a separate service&quot;. It&#x27;s not either-or.</div><br/></div></div></div></div><div id="38076943" class="c"><input type="checkbox" id="c-38076943" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#38074550">prev</a><span>|</span><a href="#38072355">next</a><span>|</span><label class="collapse" for="c-38076943">[-]</label><label class="expand" for="c-38076943">[1 more]</label></div><br/><div class="children"><div class="content">I’ve always thought the monolith vs. micro service debate to miss the point.<p>Taking an RPC call has costs. But sometimes you need to. Maybe the computation doesn’t fit on any of your SKUs, maybe it is best done by a combination of different SKUs, maybe you need to be able to retry if an instance goes down. There are countless reasons that justify taking the overhead of an RPC.<p>So, do you have any of those reasons? If yes, take the RPC overhead in both compute and version management and stuff.<p>If no, don’t.<p>Why is this so contentious?</div><br/></div></div><div id="38072355" class="c"><input type="checkbox" id="c-38072355" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#38076943">prev</a><span>|</span><a href="#38073011">next</a><span>|</span><label class="collapse" for="c-38072355">[-]</label><label class="expand" for="c-38072355">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Monolith first.&quot;<p>Also, call stack can go pretty deep. You can&#x27;t go deep with microservices. Everything has to be first hop or you risk adding latency.<p>Also, transactional functionalities become lot more challenging to implement across services and databases because it&#x27;s blasphemous to share database among Microservices.</div><br/></div></div><div id="38073011" class="c"><input type="checkbox" id="c-38073011" checked=""/><div class="controls bullet"><span class="by">mrinterweb</span><span>|</span><a href="#38072355">prev</a><span>|</span><a href="#38075268">next</a><span>|</span><label class="collapse" for="c-38073011">[-]</label><label class="expand" for="c-38073011">[1 more]</label></div><br/><div class="children"><div class="content">A bit over a decade ago, I was sold on the concept of microservices. After implementing, maintaining, and integrating many microservices; I have realized how incredibly exhausting it is. Sure microservices have their place, but understanding the often higher costs associated with microservices should be considered when developing a new service. Focus on the costs that are less tangible: siloed knowledge, integration costs, devops costs, coordinating releases, cross-team communication, testing, contract versioning, shared tooling. I could go on, but that&#x27;s just a sample of some of the less obvious costs.<p>I feel that the collective opinion of microservices has shifted towards being trepidatious of microservices as many have experienced the pains associated with microservcies.</div><br/></div></div><div id="38075268" class="c"><input type="checkbox" id="c-38075268" checked=""/><div class="controls bullet"><span class="by">john-tells-all</span><span>|</span><a href="#38073011">prev</a><span>|</span><label class="collapse" for="c-38075268">[-]</label><label class="expand" for="c-38075268">[1 more]</label></div><br/><div class="children"><div class="content">Monoliths are <i>so</i> much easier to test and deploy!<p>Even if one service needs to be developed separately, it can still live in the monolith. For dev, it&#x27;s easier to test. For production, deploy the <i>same</i> monolith but have it only handle a single service, depending on how it&#x27;s deployed. You get all the benefits of a monolith while a little benefit of separate services.<p>Microservices are okay, but &quot;kick up&quot; a lot of issues that can be slow&#x2F;awkward to solve. Testing being the big one. If the business decides it&#x27;s worth the exponential complexity then that&#x27;s fine.</div><br/></div></div></div></div></div></div></div></body></html>