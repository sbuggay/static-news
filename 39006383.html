<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705395658247" as="style"/><link rel="stylesheet" href="styles.css?v=1705395658247"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://eliasnaur.com/blog/immediate-mode-gui-programming">Immediate Mode GUI Programming</a>Â <span class="domain">(<a href="https://eliasnaur.com">eliasnaur.com</a>)</span></div><div class="subtext"><span>jstanley</span> | <span>85 comments</span></div><br/><div><div id="39007916" class="c"><input type="checkbox" id="c-39007916" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#39007344">next</a><span>|</span><label class="collapse" for="c-39007916">[-]</label><label class="expand" for="c-39007916">[13 more]</label></div><br/><div class="children"><div class="content">I cannot recommend immediate mode GUI programming based on the limitations I&#x27;ve experienced working with egui (<a href="https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui">https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui</a>) in Rust.<p>egui does not support putting two widgets in the center of the screen: <a href="https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui&#x2F;issues&#x2F;3211">https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui&#x2F;issues&#x2F;3211</a><p>It&#x27;s really easy to get started with immediate mode and bust out some simple UIs, but the second you start trying to involve dynamically sized elements and responsive layouts -- abandon all hope. The fact it has to calculate everything in a single pass makes these things hard&#x2F;impossible. Coming from a strong CSS&#x2F;React background I find the limitation maddening.<p>... that said, I&#x27;m still using it to build a prototype UI for <a href="https:&#x2F;&#x2F;ant.care&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ant.care&#x2F;</a> (<a href="https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;symbiants">https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;symbiants</a>) because it&#x27;s the best thing I&#x27;ve found so far.<p>I&#x27;m crossing my fingers that Bevy&#x27;s UI story (or Kayak <a href="https:&#x2F;&#x2F;github.com&#x2F;StarArawn&#x2F;kayak_ui">https:&#x2F;&#x2F;github.com&#x2F;StarArawn&#x2F;kayak_ui</a>) becomes significantly more fleshed out sooner rather than later. Bevy 0.13 should have lots more in this area though (<a href="https:&#x2F;&#x2F;github.com&#x2F;bevyengine&#x2F;bevy&#x2F;discussions&#x2F;9538">https:&#x2F;&#x2F;github.com&#x2F;bevyengine&#x2F;bevy&#x2F;discussions&#x2F;9538</a>)</div><br/><div id="39009542" class="c"><input type="checkbox" id="c-39009542" checked=""/><div class="controls bullet"><span class="by">slmjkdbtl</span><span>|</span><a href="#39007916">parent</a><span>|</span><a href="#39008650">next</a><span>|</span><label class="collapse" for="c-39009542">[-]</label><label class="expand" for="c-39009542">[2 more]</label></div><br/><div class="children"><div class="content">It sounds like limitations of egui &#x2F; Rust instead of immediate mode GUI. I&#x27;ve made flexbox-like layout systems in immediate mode GUIs and found them far easier than retained mode, since everything is redrawn every frame.</div><br/><div id="39009683" class="c"><input type="checkbox" id="c-39009683" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#39007916">root</a><span>|</span><a href="#39009542">parent</a><span>|</span><a href="#39008650">next</a><span>|</span><label class="collapse" for="c-39009683">[-]</label><label class="expand" for="c-39009683">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair. I don&#x27;t have experience with other immediate mode libraries. It&#x27;s good to hear that it&#x27;s not an intrinsic limitation<p><a href="https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui?tab=readme-ov-file#layout">https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui?tab=readme-ov-file#layout</a> Here the author discusses the issue directly. They note that there are solutions to the issue, but that they all come with (in their opinion) significant drawbacks.<p>For my use case, if I have to do a lot of manual work to achieve what I consider behavior that should be handled by the framework, then I don&#x27;t find that compelling and am inclined to use a retained mode implementation.</div><br/></div></div></div></div><div id="39008650" class="c"><input type="checkbox" id="c-39008650" checked=""/><div class="controls bullet"><span class="by">at_compile_time</span><span>|</span><a href="#39007916">parent</a><span>|</span><a href="#39009542">prev</a><span>|</span><a href="#39008753">next</a><span>|</span><label class="collapse" for="c-39008650">[-]</label><label class="expand" for="c-39008650">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve dabbled with egui, and ran into this limitation almost immediately (har har).<p>I got around it by storing widget size between frames so that I could center it properly on the next frame. Not perfect, but it worked.</div><br/></div></div><div id="39008753" class="c"><input type="checkbox" id="c-39008753" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#39007916">parent</a><span>|</span><a href="#39008650">prev</a><span>|</span><a href="#39008125">next</a><span>|</span><label class="collapse" for="c-39008753">[-]</label><label class="expand" for="c-39008753">[3 more]</label></div><br/><div class="children"><div class="content">None of these limitations have anything to do with an imgui frontend api though.</div><br/><div id="39009118" class="c"><input type="checkbox" id="c-39009118" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#39007916">root</a><span>|</span><a href="#39008753">parent</a><span>|</span><a href="#39008125">next</a><span>|</span><label class="collapse" for="c-39009118">[-]</label><label class="expand" for="c-39009118">[2 more]</label></div><br/><div class="children"><div class="content">Can you elaborate? I&#x27;m not sure I understand. To me, these limitations feel intrinsic to immediate mode.</div><br/><div id="39011058" class="c"><input type="checkbox" id="c-39011058" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39007916">root</a><span>|</span><a href="#39009118">parent</a><span>|</span><a href="#39008125">next</a><span>|</span><label class="collapse" for="c-39011058">[-]</label><label class="expand" for="c-39011058">[1 more]</label></div><br/><div class="children"><div class="content">In Dear ImGui for instance, you can get the size of view containers and use that to position your UI elements (or alternatively use the ImDrawList helper to directly render vector graphics into the view).<p>The common misconception is that immediate mode UIs don&#x27;t persist state between frames, but they absolutely do internally. The point is that the state isn&#x27;t persisted on the user-side of the API.</div><br/></div></div></div></div></div></div><div id="39008125" class="c"><input type="checkbox" id="c-39008125" checked=""/><div class="controls bullet"><span class="by">xvedejas</span><span>|</span><a href="#39007916">parent</a><span>|</span><a href="#39008753">prev</a><span>|</span><a href="#39008124">next</a><span>|</span><label class="collapse" for="c-39008125">[-]</label><label class="expand" for="c-39008125">[3 more]</label></div><br/><div class="children"><div class="content">Have you looked into slint? I&#x27;m curious to hear other Rust devs&#x27; experience with it.</div><br/><div id="39008151" class="c"><input type="checkbox" id="c-39008151" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#39007916">root</a><span>|</span><a href="#39008125">parent</a><span>|</span><a href="#39008124">next</a><span>|</span><label class="collapse" for="c-39008151">[-]</label><label class="expand" for="c-39008151">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t. I was just searching for a GUI library that was Bevy-compatible and slint isn&#x27;t at the moment: <a href="https:&#x2F;&#x2F;github.com&#x2F;slint-ui&#x2F;slint&#x2F;discussions&#x2F;940">https:&#x2F;&#x2F;github.com&#x2F;slint-ui&#x2F;slint&#x2F;discussions&#x2F;940</a><p>Sorry!</div><br/><div id="39008313" class="c"><input type="checkbox" id="c-39008313" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#39007916">root</a><span>|</span><a href="#39008151">parent</a><span>|</span><a href="#39008124">next</a><span>|</span><label class="collapse" for="c-39008313">[-]</label><label class="expand" for="c-39008313">[1 more]</label></div><br/><div class="children"><div class="content">Looks like slint aims for a native look and feel, which probably wouldn&#x27;t match Bevy&#x27;s goals.</div><br/></div></div></div></div></div></div><div id="39008124" class="c"><input type="checkbox" id="c-39008124" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#39007916">parent</a><span>|</span><a href="#39008125">prev</a><span>|</span><a href="#39008195">next</a><span>|</span><label class="collapse" for="c-39008124">[-]</label><label class="expand" for="c-39008124">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s best used for developer tools or simple UIs that don&#x27;t have complex layout constraints.<p>For what it&#x27;s worth, I&#x27;m building all of my game&#x27;s UI using a pseudo-imgui framework, but I&#x27;ve had to do manual layout in specific places, and I updated the layout engine to run a second pass in specific cases (dynamically sized elements, primarily when text is being auto-wrapped to fit available space). This sort of stuff is only possible when you control things end-to-end.<p>In practice even these IMGUI frameworks don&#x27;t generally do their layout in &quot;one pass&quot;, it just appears to be a single pass to you. oui and its derivative layout.h both do a size calculation pass and then an arranging pass, for example. I originally used layout.h&#x27;s algorithm, but eventually designed a new one which operates in ~3 passes:<p>* 1. Calculate minimum sizes and, for containers with multiple rows&#x2F;columns, construct &#x27;runs&#x27; of sequential boxes in a given row&#x2F;column.<p>* 2a. For containers with wrapping enabled, scan over runs and when we find one that&#x27;s too big for its container&#x27;s available space, split controls from one run into a new one.<p>* 2b. For containers with children, scan through their children and grow any children that are meant to expand into available space. (You can&#x27;t do this until you&#x27;ve measured everything and wrapped.)<p>* 2c. For any containers where you wrapped controls or expanded controls, recalculate their size and throw out the result from 1, since wrapping&#x2F;expanding potentially changes their size.<p>* 2d. For simplicity you can introduce an alternative version of pass 2 for &#x27;grid layout&#x27;, where children all have fixed sizes and predictable wrapping. I&#x27;ve only started doing this recently, but it&#x27;s great for things like listboxes and dataviews. If you do this, you don&#x27;t need to do the multiple subpasses of 2a&#x2F;2b&#x2F;2c, and arranging becomes easier.<p>* 3. Now that you&#x27;ve measured everything and distributed boxes into rows&#x2F;columns, you can scan through each &#x27;run&#x27; and put every control into its place, applying things like centering and RTL&#x2F;LTR modes.<p>I do think &quot;it should be possible to efficiently perform layout for your whole UI from scratch every frame&quot; is a good principle, it pressures you to architect your application in a cleaner, less fragile way. But sometimes you really want to retain stuff, like shaped glyphs for big blocks of unicode text, etc. Right now my game runs over 120FPS on a terrible laptop from 2015 and around 800FPS on my 3-year-old workstation, but a major portion of the CPU time is all spent doing layout. That&#x27;s not great.</div><br/><div id="39010035" class="c"><input type="checkbox" id="c-39010035" checked=""/><div class="controls bullet"><span class="by">empiricus</span><span>|</span><a href="#39007916">root</a><span>|</span><a href="#39008124">parent</a><span>|</span><a href="#39008195">next</a><span>|</span><label class="collapse" for="c-39010035">[-]</label><label class="expand" for="c-39010035">[1 more]</label></div><br/><div class="children"><div class="content">Did you profile the layout code? How many UI elements do you display normally? And what is the O complexity of the layout algorithm above? My intuition is that even if it looks like a lot of code, it should be incredibly fast for at least hundreds of elements.</div><br/></div></div></div></div></div></div><div id="39007344" class="c"><input type="checkbox" id="c-39007344" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#39007916">prev</a><span>|</span><a href="#39009173">next</a><span>|</span><label class="collapse" for="c-39007344">[-]</label><label class="expand" for="c-39007344">[3 more]</label></div><br/><div class="children"><div class="content">The baseline difference seems to be the difference between organizing GUI elements as stored method+field entities, vs. dynamically combined function+argument entities.<p>It is a lot like the difference between greedy and lazy execution.<p>Which code style is best depends on the structure of the items it is applied to.<p>--<p>With 100 different views, respectively over 100 different items to be viewed, storing 100 view+item pairs as objects is both general and efficient.<p>With 10 different views, repeatedly over 10 different items to be viewed, there are still 100 interface elements. But repeatedly joining view and item information at draw time provides a 10x space&#x2F;object savings. And allows for other code simplifications.<p>--<p>General takeaway: Pre-compiled general libraries, that cannot be treated as inlined compile-time optimizable templates (in the code context where the templates are applied), will be inefficient and overbuilt for cases with more structure and simplicity than they were designed for.</div><br/><div id="39008813" class="c"><input type="checkbox" id="c-39008813" checked=""/><div class="controls bullet"><span class="by">crq-yml</span><span>|</span><a href="#39007344">parent</a><span>|</span><a href="#39008597">next</a><span>|</span><label class="collapse" for="c-39008813">[-]</label><label class="expand" for="c-39008813">[1 more]</label></div><br/><div class="children"><div class="content">I see it as the crossover between approaches amenable to static order and iteration, vs those that demand constraint optimization.<p>This is a recurring problem in programming, because if you code towards the optimal result, you end up making a static, linearized computation that doesn&#x27;t need further configuration. But if your goal is to provide interfaces and automation, you are tasked with a constraint problem, where you have multiple potential solutions and you either have to filter them down to a single unambiguous result, or find a heuristic that defines the &quot;best one&quot;.<p>The problem occurs with type systems, graphical layout, multi-body physics simulation, dependency management and a host of other things. I consider it the most unaddressed subject in CS because it&#x27;s so relevant to applications and yet industry continually reinvents it in terms of a bespoken algorithm for that one application.<p>And depending on what you&#x27;re doing, you end up biasing to one or the other method first: a small, well-defined problem only needs the computer to do &quot;brute&quot; things, while a problem dependent on the computer managing the complexity of the problem needs it to find and correct errors.</div><br/></div></div><div id="39008597" class="c"><input type="checkbox" id="c-39008597" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39007344">parent</a><span>|</span><a href="#39008813">prev</a><span>|</span><a href="#39009173">next</a><span>|</span><label class="collapse" for="c-39008597">[-]</label><label class="expand" for="c-39008597">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t link-time-optimization take care of your &#x27;general takeaway&#x27;?</div><br/></div></div></div></div><div id="39009173" class="c"><input type="checkbox" id="c-39009173" checked=""/><div class="controls bullet"><span class="by">c-smile</span><span>|</span><a href="#39007344">prev</a><span>|</span><a href="#39007105">next</a><span>|</span><label class="collapse" for="c-39009173">[-]</label><label class="expand" for="c-39009173">[1 more]</label></div><br/><div class="children"><div class="content">Each tool is good for particular tasks it was designed for.<p>That&#x27;s why my Sciter [1] supports both - as retained mode (DOM&#x2F;CSS) as immediate mode (element.paintXXX()).<p>Consider the task of marking some div as resizable - with eight square handles [2]. With immediate mode drawing that task is trivial:<p><pre><code>   const div = ...;
   
   &#x2F;&#x2F; draw sizing handles:
   div.paintForeground = function(gfx) {
     gfx.fillColor = &quot;#0f0&quot;;
     for(let r of this.sizingHandlePlaces()) 
       gfx.fillRect(r); 
   }
</code></pre>
otherwise, if we have only retained mode as in browsers, we will need to modify the DOM heavily and create temporary elements for handles.<p>[1] <a href="https:&#x2F;&#x2F;sciter.com" rel="nofollow">https:&#x2F;&#x2F;sciter.com</a>
[2] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;20984181&#x2F;how-do-i-make-a-usercontrol-sizable-on-runtime-with-sizing-handles" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;20984181&#x2F;how-do-i-make-a...</a></div><br/></div></div><div id="39007105" class="c"><input type="checkbox" id="c-39007105" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39009173">prev</a><span>|</span><a href="#39009210">next</a><span>|</span><label class="collapse" for="c-39007105">[-]</label><label class="expand" for="c-39007105">[2 more]</label></div><br/><div class="children"><div class="content">TBH from looking at the code examples it looks a bit like it&#x27;s halfway stuck between a traditional object-oriented UI framework, and a &quot;proper&quot; immediate mode UI (for instance why is there a variable that seems to be a button object).</div><br/><div id="39007539" class="c"><input type="checkbox" id="c-39007539" checked=""/><div class="controls bullet"><span class="by">hsn915</span><span>|</span><a href="#39007105">parent</a><span>|</span><a href="#39009210">next</a><span>|</span><label class="collapse" for="c-39007539">[-]</label><label class="expand" for="c-39007539">[1 more]</label></div><br/><div class="children"><div class="content">Yea, it&#x27;s unfortunate.<p>I also find their layout &quot;framework&quot;&#x2F;API to be weird and counter intuitive.</div><br/></div></div></div></div><div id="39009210" class="c"><input type="checkbox" id="c-39009210" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39007105">prev</a><span>|</span><a href="#39008047">next</a><span>|</span><label class="collapse" for="c-39009210">[-]</label><label class="expand" for="c-39009210">[1 more]</label></div><br/><div class="children"><div class="content">Recent and related:<p><i>Dear ImGui: Graphical User Interface library for C++</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38710818">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38710818</a> - Dec 2023 (109 comments)</div><br/></div></div><div id="39008047" class="c"><input type="checkbox" id="c-39008047" checked=""/><div class="controls bullet"><span class="by">tuckerpo</span><span>|</span><a href="#39009210">prev</a><span>|</span><a href="#39010043">next</a><span>|</span><label class="collapse" for="c-39008047">[-]</label><label class="expand" for="c-39008047">[2 more]</label></div><br/><div class="children"><div class="content">Casey Muratori of handmade hero fame is one of the original pioneers (potentially the first?) of immediate mode user-interfaces.<p>Check out this lecture&#x2F;demo from nearly 20 years ago: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Z1qyvQsjK5Y" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Z1qyvQsjK5Y</a></div><br/><div id="39009203" class="c"><input type="checkbox" id="c-39009203" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#39008047">parent</a><span>|</span><a href="#39010043">next</a><span>|</span><label class="collapse" for="c-39009203">[-]</label><label class="expand" for="c-39009203">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, early user interface libraries existed on a spectrum from what we&#x27;d now call retained-mode to immediate-mode.<p>For example, the original Macintosh Toolbox (1984) worked _somewhat_ like that: on one hand, you had to handle events â even to the extent that you were just given a mouse click event, and had to dispatch it to the menu, scrollbars, title bars, etc; you then had to manually draw controls (but not while explicitly passing in their state.)<p>On the other hand, control state was &quot;retained&quot;, to the extent that you updated their values, displayed them etc. with handles, and their state existed off in a linked list somewhere.<p>Here&#x27;s how a later version of Inside Macintosh described having to handle a scroll bar operation, once a click and its location was identified. (I present it because it&#x27;s long and aggravating...)<p><pre><code>  1. Use the FindControl, GetControlValue, and TrackControl functions to help calculate the scrolling distance.

  2. If you are scrolling for any reason other than the user dragging the scroll box, use the SetControlValue procedure to move the scroll box a corresponding amount.

  3. Use a routineâsuch as the QuickDraw procedure ScrollRect or the TextEdit procedure TEPinScrollâto move the bits displayed in the window by the calculated scrolling distance. Then either use a call that generates an update event or else directly call your applicationâs DoUpdate routine, which should perform the rest of these steps.

  4. Use the UpdateControls procedure to update the scroll bars and then call the Window Manager procedure DrawGrowIcon to redraw the size box.

  5. Use the QuickDraw procedure SetOrigin to change the window origin by an amount equal to the scroll bar settings so that the upper-left corner of the document lies at (0,0) in the windowâs local coordinate system. (You perform this step so that your applicationâs document-drawing routines can draw in the correct area of the window.)

  6. Call your applicationâs routines for redrawing the document inside the window.

  7. Use the SetOrigin procedure to reset the window origin to (0,0) so that future Window Manager and Control Manager routines draw in the correct area of the window.

  8. Return to your event loop.

  These steps are explained in greater detail in the rest of this section.</code></pre></div><br/></div></div></div></div><div id="39010043" class="c"><input type="checkbox" id="c-39010043" checked=""/><div class="controls bullet"><span class="by">theanonymousone</span><span>|</span><a href="#39008047">prev</a><span>|</span><a href="#39007112">next</a><span>|</span><label class="collapse" for="c-39010043">[-]</label><label class="expand" for="c-39010043">[2 more]</label></div><br/><div class="children"><div class="content">Is Streamlit an immediate mode UI framework?<p>It has a very unique, easy-to-start, model for creating UIs which avoids callbacks, but I don&#x27;t know what the technical term for it is.</div><br/><div id="39010308" class="c"><input type="checkbox" id="c-39010308" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39010043">parent</a><span>|</span><a href="#39007112">next</a><span>|</span><label class="collapse" for="c-39010308">[-]</label><label class="expand" for="c-39010308">[1 more]</label></div><br/><div class="children"><div class="content">yeah, i would call streamlit an imgui framework.  also react</div><br/></div></div></div></div><div id="39007112" class="c"><input type="checkbox" id="c-39007112" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#39010043">prev</a><span>|</span><a href="#39006897">next</a><span>|</span><label class="collapse" for="c-39007112">[-]</label><label class="expand" for="c-39007112">[9 more]</label></div><br/><div class="children"><div class="content">Immediate mode is very common in game development. Super easy to reason about and debug.</div><br/><div id="39008353" class="c"><input type="checkbox" id="c-39008353" checked=""/><div class="controls bullet"><span class="by">bartwr</span><span>|</span><a href="#39007112">parent</a><span>|</span><a href="#39009003">next</a><span>|</span><label class="collapse" for="c-39008353">[-]</label><label class="expand" for="c-39008353">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a former game dev and I used ImGui a lot and don&#x27;t think it&#x27;s used because those reasons.<p>It&#x27;s used for quickly hacked debug tools to interleave UI and regular logic and not do a logic&#x2F;view separation (as it would result in code bloat and a necessity for a refactor). You want UI code do some logic (like modifying properties of some game entity or renderer) and prefer to inline it. Lots of game code is effectively YOLO without even a single test.
It&#x27;s also typically guarded by IfDefs and compiled out of release versions.<p>But as soon as it stops being just hacky debuggers and people try to write proper tools in it, it becomes much more of a pain - people try to (poorly) emulate a retained mode in it, hold state, cache - and it becomes unreadable mess.</div><br/><div id="39010039" class="c"><input type="checkbox" id="c-39010039" checked=""/><div class="controls bullet"><span class="by">1ark</span><span>|</span><a href="#39007112">root</a><span>|</span><a href="#39008353">parent</a><span>|</span><a href="#39009003">next</a><span>|</span><label class="collapse" for="c-39010039">[-]</label><label class="expand" for="c-39010039">[1 more]</label></div><br/><div class="children"><div class="content">This is such a good and clear take.</div><br/></div></div></div></div><div id="39009003" class="c"><input type="checkbox" id="c-39009003" checked=""/><div class="controls bullet"><span class="by">low_tech_punk</span><span>|</span><a href="#39007112">parent</a><span>|</span><a href="#39008353">prev</a><span>|</span><a href="#39007867">next</a><span>|</span><label class="collapse" for="c-39009003">[-]</label><label class="expand" for="c-39009003">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m web dev recently introduced to game dev. I&#x27;m curious why the two worlds have such different approaches. Another example is ECS being more prevalent in games than in web apps.</div><br/><div id="39010173" class="c"><input type="checkbox" id="c-39010173" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#39007112">root</a><span>|</span><a href="#39009003">parent</a><span>|</span><a href="#39010330">next</a><span>|</span><label class="collapse" for="c-39010173">[-]</label><label class="expand" for="c-39010173">[1 more]</label></div><br/><div class="children"><div class="content">because they&#x27;re doing different things.<p>Web page: Wait for data from server, update page to match, this usually happens at most every few seconds. (or if it&#x27;s server based) Fetch data, format into html, set to browser<p>Game: For 10s to 1000s of objects, run some code for each one at 60 frames a second. That code is usually one or more finite state machines and&#x2F;or co-routines per object (or some hacked together code that effective does the same). This code updates a bunch of state for each object, and then other code displays the current state.<p>They&#x27;re doing different things so they take different approaches.<p>PS: I get the above is over simplified.</div><br/></div></div><div id="39010330" class="c"><input type="checkbox" id="c-39010330" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39007112">root</a><span>|</span><a href="#39009003">parent</a><span>|</span><a href="#39010173">prev</a><span>|</span><a href="#39007867">next</a><span>|</span><label class="collapse" for="c-39010330">[-]</label><label class="expand" for="c-39010330">[1 more]</label></div><br/><div class="children"><div class="content">react is pretty common in web dev and it&#x27;s immediate-mode<p>ecs is just watered-down in-ram relational databases, and relational databases are also pretty popular for web apps</div><br/></div></div></div></div><div id="39007867" class="c"><input type="checkbox" id="c-39007867" checked=""/><div class="controls bullet"><span class="by">jheriko</span><span>|</span><a href="#39007112">parent</a><span>|</span><a href="#39009003">prev</a><span>|</span><a href="#39006897">next</a><span>|</span><label class="collapse" for="c-39007867">[-]</label><label class="expand" for="c-39007867">[3 more]</label></div><br/><div class="children"><div class="content">i am a gamedev. i never encountered this until unity became popular, and even then it was always looked down on as a shitty and hacky approach to a well solved class of problem.<p>10 years after this, its still about the same... which is probably why an article like this has any controversy about it instead of being run-of-the-mill.</div><br/><div id="39007897" class="c"><input type="checkbox" id="c-39007897" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#39007112">root</a><span>|</span><a href="#39007867">parent</a><span>|</span><a href="#39006897">next</a><span>|</span><label class="collapse" for="c-39007897">[-]</label><label class="expand" for="c-39007897">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely everyone (including the AAA studios) uses Dear ImGui for tools these days.<p>Retained mode is probably more common for user-facing GUIs, though.</div><br/><div id="39010115" class="c"><input type="checkbox" id="c-39010115" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#39007112">root</a><span>|</span><a href="#39007897">parent</a><span>|</span><a href="#39006897">next</a><span>|</span><label class="collapse" for="c-39010115">[-]</label><label class="expand" for="c-39010115">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Absolutely everyone (including the AAA studios) uses Dear ImGui for tools these days.<p>I&#x27;ve been working in (mostly AAA) game engines and tools since the mid-2000s, largely in custom engines and i never encountered Dear Imgui, so i disagree with the &quot;absolutely everyone&quot;. Pretty much every engine i&#x27;ve worked with (and didn&#x27;t make myself) uses something like wxWidgets, Qt, MFC or some custom toolkit for the tools and custom stuff for in-game debugging (usually a console for keyboard use and some &quot;page&#x2F;screen&quot; based reporting&#x2F;lists&#x2F;menus that are easy to navigate with a gamepad).<p>I do know that some game engines use it, but it isn&#x27;t as universal as you think.</div><br/></div></div></div></div></div></div></div></div><div id="39006897" class="c"><input type="checkbox" id="c-39006897" checked=""/><div class="controls bullet"><span class="by">moron4hire</span><span>|</span><a href="#39007112">prev</a><span>|</span><a href="#39008523">next</a><span>|</span><label class="collapse" for="c-39006897">[-]</label><label class="expand" for="c-39006897">[30 more]</label></div><br/><div class="children"><div class="content">Immediate mode GUI is fine for quick and dirty things, but once you start dealing with multiple application views that conditionally show&#x2F;hide, with branching flows of any kind, you&#x27;ll find yourself on a hardline track to reinvent retained mode GUI from scratch just so you can handle the event loop in a sane way.<p>Object oriented, event driven widgets composed into more colored views are really, really good for developing UI. There&#x27;s a reason every major OS GUI toolkit is this design. If you componentize like you are supposed to--instead of just smashing everything into one form--they work and can be reasoned over with few surprises.<p>The trouble comes from not componentizing things that you should when your current platform doesn&#x27;t provide the full menagerie of widgets that you&#x27;ll need. Basically, it you have any kind of input that results in a value that is not just a raw string, you should be building a component for that input: URLs, paths to files, numbers, dates, selectors for picking a set list of structured objects, etc.</div><br/><div id="39007003" class="c"><input type="checkbox" id="c-39007003" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39006897">parent</a><span>|</span><a href="#39007318">next</a><span>|</span><label class="collapse" for="c-39007003">[-]</label><label class="expand" for="c-39007003">[21 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the whole point of immediate mode UIs to get rid of the &quot;event loop&quot; though?<p>&gt; multiple application views that conditionally show&#x2F;hide<p>The ImGui way of doing this is to conditionally run or not run the code which describes the conditionally shown UI elements. E.g. a simple<p><pre><code>    if (viewShown) {
        ...code which describes what the view looks like
    }
</code></pre>
There are plenty of real-world applications with complex UIs implemented in Dear ImGui which don&#x27;t seem to have a problem with those things, e.g. see <a href="https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui&#x2F;labels&#x2F;gallery">https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui&#x2F;labels&#x2F;gallery</a><p>&gt; The trouble comes from not componentizing things...<p>In ImGui, reusable UI components are just code which describes the UI component by calling lower-level ImGui functions and which itself is a new ImGui-style function. It works surprisingly well.</div><br/><div id="39007284" class="c"><input type="checkbox" id="c-39007284" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007003">parent</a><span>|</span><a href="#39007258">next</a><span>|</span><label class="collapse" for="c-39007284">[-]</label><label class="expand" for="c-39007284">[18 more]</label></div><br/><div class="children"><div class="content">If your entire system ran with immediate mode GUIs your performance would either be in the toilet or battery life would be destroyed (or both).<p>Theyâre great for games and GPU where youâre in a for a pound anyway. There are some music apps that use it and itâs horrible if youâre on a laptop. No I donât want to consume a couple watts when I should be idling because the entire screen is being repainted doing nothing.
Makes electron seem nice.</div><br/><div id="39007399" class="c"><input type="checkbox" id="c-39007399" checked=""/><div class="controls bullet"><span class="by">goodpaul6</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007284">parent</a><span>|</span><a href="#39007530">next</a><span>|</span><label class="collapse" for="c-39007399">[-]</label><label class="expand" for="c-39007399">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure the perf&#x2F;battery life tradeoff is a necessary aspect of immediate mode UI.<p><pre><code>  while (running) {
    event := get_next_event()
    process_event(event)
    repaint()
  }
</code></pre>
You could just have get_next_event block until there is a meaningful event that occurs (e.g. mouse click). You could even have your UI report &quot;interactive&quot; rectangles to the event layer to prevent it from producing e.g. mouse move events that are irrelevant.<p>IMGUI is just a different API design IMO.</div><br/><div id="39007528" class="c"><input type="checkbox" id="c-39007528" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007399">parent</a><span>|</span><a href="#39007482">next</a><span>|</span><label class="collapse" for="c-39007528">[-]</label><label class="expand" for="c-39007528">[7 more]</label></div><br/><div class="children"><div class="content">&gt; You could even have your UI report &quot;interactive&quot; rectangles to the event layer to prevent it from producing e.g. mouse move events that are irrelevant.<p>And then what?<p>With this one innocuous seeming sentence you are hand waving a way a ton of complexity. If you try to implement it you will at least have some respect for toolkit authors.<p>&gt; IMGUI is just a different API design IMO.<p>Yes one that is lower level and 
therefore is fundamentally harder to deal with to get all the things people take for granted in a full blown mature state based GUI toolkit.<p>You can implement a retained GUI toolkit with IMGUI. Or you can use something already done.<p>IMGUI eschews this complexity as part of its purpose but it comes with trade offs that limit its use cases.</div><br/><div id="39008106" class="c"><input type="checkbox" id="c-39008106" checked=""/><div class="controls bullet"><span class="by">goodpaul6</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007528">parent</a><span>|</span><a href="#39007482">next</a><span>|</span><label class="collapse" for="c-39008106">[-]</label><label class="expand" for="c-39008106">[6 more]</label></div><br/><div class="children"><div class="content">I decided to implement it (IMGUI that only repaints when relevant interactions occur) so that my point comes across more clearly:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;goodpaul6&#x2F;imgui-power-saving-example">https:&#x2F;&#x2F;github.com&#x2F;goodpaul6&#x2F;imgui-power-saving-example</a><p>Of course this is a greatly simplified example, but I can see this extending to any GUI widget that can be represented with a (hierarchy) of rectangles.</div><br/><div id="39008191" class="c"><input type="checkbox" id="c-39008191" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39008106">parent</a><span>|</span><a href="#39007482">next</a><span>|</span><label class="collapse" for="c-39008191">[-]</label><label class="expand" for="c-39008191">[5 more]</label></div><br/><div class="children"><div class="content">All major GUI toolkits are ultimately implemented on some immediate mode drawing system. So I donât see the point. (Youâre literally just unfactoring what a GUI library does behind the scenes into your loop.)<p>When you unsimplify your example then you are reinventing a wheel. A big wheel. It can be done, but itâs a lot of work. And then you might go factoring things back so it starts to look very similar to prior art. Itâs actually easier than ever to implement accessibility for instance (assuming youâre ok pulling in a large dependency), but show me an actual example of this done on top of imgui.<p>Things I never said: imgui doesnât have uses, imgui isnât great.<p>But its scope is limited.</div><br/><div id="39008381" class="c"><input type="checkbox" id="c-39008381" checked=""/><div class="controls bullet"><span class="by">goodpaul6</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39008191">parent</a><span>|</span><a href="#39007482">next</a><span>|</span><label class="collapse" for="c-39008381">[-]</label><label class="expand" for="c-39008381">[4 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an IMGUI library that&#x27;s also accessible (via AccessKit): <a href="https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui">https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui</a></div><br/><div id="39008452" class="c"><input type="checkbox" id="c-39008452" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39008381">parent</a><span>|</span><a href="#39007482">next</a><span>|</span><label class="collapse" for="c-39008452">[-]</label><label class="expand" for="c-39008452">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui#cpu-usage">https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;egui#cpu-usage</a><p>Fantastic - âonlyâ 1 to 2 ms (and thatâs for simple stuff). Depending on what youâre doing thatâs a big chunk. Also time you could be sleeping. Also something you donât usually have to worry about.</div><br/><div id="39008527" class="c"><input type="checkbox" id="c-39008527" checked=""/><div class="controls bullet"><span class="by">goodpaul6</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39008452">parent</a><span>|</span><a href="#39007482">next</a><span>|</span><label class="collapse" for="c-39008527">[-]</label><label class="expand" for="c-39008527">[2 more]</label></div><br/><div class="children"><div class="content">It looks like they only repaint when there is interaction as well (so it does sleep while nothing is happening).<p>However, my point with linking this library was just to demonstrate that accessibility and IMGUI are not inherently incompatible.<p>My point with the example I created above was that you don&#x27;t have to trade away battery life in order to take advantage of the IMGUI paradigm. My secondary point was also to implement the &quot;interactive rectangles&quot; optimization I mentioned above (which only took a few lines of code).<p>While I agree with you that there are definitely tradeoffs, I don&#x27;t think the aforementioned ones are necessary.</div><br/><div id="39008878" class="c"><input type="checkbox" id="c-39008878" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39008527">parent</a><span>|</span><a href="#39007482">next</a><span>|</span><label class="collapse" for="c-39008878">[-]</label><label class="expand" for="c-39008878">[1 more]</label></div><br/><div class="children"><div class="content">&gt; my point with linking this library was just to demonstrate that accessibility and IMGUI are not inherently incompatible.<p>Once again, all major GUI toolkits and browser are implemented on top of immediate mode graphics APIs, so you continue to beat this straw man argument. Obviously everything is ultimately immediate mode. No one was refuting those points and sorry theyâre not particularly informative.<p>The point is youâre just rearranging where that state lives and who manages it.  Youâre retaining it somewhere. But your app is not the best place to manage a lot of this state (as even egui itself admits), it belongs in a well tested library.<p>Once you start using dirty rectangles, someone has to keep track of them. What benefit is it to me to drive when to call the apis for those details?<p>IMGUI has a certain elegance where your answer to that is to just say fuck it, and that works well for like a game editor. (The point about accessibility was not that it canât be done but IMGUI rarely gets actually used where this is ever done). Because if your answer isnât fuck it to all those things than just go get a library to it for you, which will be managing that state.<p>I think a lot of people pining for IMGUI really just want sane data binding. Which is understandable, but IMGUI is often throwing the baby out with the bath water.<p>Like honestly read that egui advantages&#x2F;disadvantages. Thatâs a lot of cons (that first one woo) for that one pro (which is not even inherent to all retained APIs).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39007482" class="c"><input type="checkbox" id="c-39007482" checked=""/><div class="controls bullet"><span class="by">kvemkon</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007399">parent</a><span>|</span><a href="#39007528">prev</a><span>|</span><a href="#39007601">next</a><span>|</span><label class="collapse" for="c-39007482">[-]</label><label class="expand" for="c-39007482">[1 more]</label></div><br/><div class="children"><div class="content">&gt; IMGUI is just a different API design IMO.<p>There are so many issues about so called &quot;power saving mode&quot; and several open PRs like <a href="https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui&#x2F;pull&#x2F;5116">https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui&#x2F;pull&#x2F;5116</a>.</div><br/></div></div><div id="39007601" class="c"><input type="checkbox" id="c-39007601" checked=""/><div class="controls bullet"><span class="by">all2</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007399">parent</a><span>|</span><a href="#39007482">prev</a><span>|</span><a href="#39007484">next</a><span>|</span><label class="collapse" for="c-39007601">[-]</label><label class="expand" for="c-39007601">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the paradigm where only new information is painted.</div><br/></div></div><div id="39007484" class="c"><input type="checkbox" id="c-39007484" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007399">parent</a><span>|</span><a href="#39007601">prev</a><span>|</span><a href="#39007530">next</a><span>|</span><label class="collapse" for="c-39007484">[-]</label><label class="expand" for="c-39007484">[3 more]</label></div><br/><div class="children"><div class="content">If you do that, you have an event loop again (like in the OP), which your comment&#x27;s grandparent was trying to get rid of (and your parent explained to them why they can&#x27;t).</div><br/><div id="39007617" class="c"><input type="checkbox" id="c-39007617" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007484">parent</a><span>|</span><a href="#39007530">next</a><span>|</span><label class="collapse" for="c-39007617">[-]</label><label class="expand" for="c-39007617">[2 more]</label></div><br/><div class="children"><div class="content">In practice there is always a loop. I believe the point flohofwoe was making is that with an immediate UI you don&#x27;t have to even touch events in your immediate UI code (they are abstracted away, if needed, in a pretty clean manner, IMO), so there&#x27;s no need to do anything to get a &quot;sane event loop&quot;. I might be wrong about what&#x27;s his point though.</div><br/><div id="39010460" class="c"><input type="checkbox" id="c-39010460" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007617">parent</a><span>|</span><a href="#39007530">next</a><span>|</span><label class="collapse" for="c-39010460">[-]</label><label class="expand" for="c-39010460">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a loop yes, but not an event loop - the other argument is that you can have a loop that runs every frame, and you just rerender the whole thing</div><br/></div></div></div></div></div></div></div></div><div id="39007530" class="c"><input type="checkbox" id="c-39007530" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007284">parent</a><span>|</span><a href="#39007399">prev</a><span>|</span><a href="#39007847">next</a><span>|</span><label class="collapse" for="c-39007530">[-]</label><label class="expand" for="c-39007530">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If your entire system ran with immediate mode GUIs your performance would either be in the toilet or battery life would be destroyed (or both).<p>You might be surprised! Modern computers are unbelievable fast.</div><br/><div id="39010833" class="c"><input type="checkbox" id="c-39010833" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007530">parent</a><span>|</span><a href="#39007847">next</a><span>|</span><label class="collapse" for="c-39010833">[-]</label><label class="expand" for="c-39010833">[1 more]</label></div><br/><div class="children"><div class="content">Try to mine bitcoins on battery and let me know how much it lasts.<p>Same thing.</div><br/></div></div></div></div><div id="39007847" class="c"><input type="checkbox" id="c-39007847" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007284">parent</a><span>|</span><a href="#39007530">prev</a><span>|</span><a href="#39007258">next</a><span>|</span><label class="collapse" for="c-39007847">[-]</label><label class="expand" for="c-39007847">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t need to be inefficient, it depends on the implementation. Immediate mode is describing the API and usage, you can implement it such that it&#x27;s retained mode behind the scenes, or only redrawing when necessary, etc.<p>I&#x27;ve written an immediate mode GUI for my projects and it&#x27;s fine for performance. I&#x27;ve written a music player for instance which uses a negligible amount of CPU, it uses slightly more resources than Clementine, my previous music player.</div><br/><div id="39008177" class="c"><input type="checkbox" id="c-39008177" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007847">parent</a><span>|</span><a href="#39007258">next</a><span>|</span><label class="collapse" for="c-39008177">[-]</label><label class="expand" for="c-39008177">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that it&#x27;s retained mode behind the scenes, or only redrawing when necessary<p>And why reinvent that wheel? Then localization and accessibility while youâre at it?<p>&gt; it uses slightly more resources than Clementine<p>Thatâs an odd flex, Clementine is extremely horrible for CPU usage (compared to nicer looking examples), probably not due to the GUI, but still. foobar2000 with a ton of plugins works better in wine.</div><br/></div></div></div></div></div></div><div id="39007193" class="c"><input type="checkbox" id="c-39007193" checked=""/><div class="controls bullet"><span class="by">moron4hire</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007003">parent</a><span>|</span><a href="#39007258">prev</a><span>|</span><a href="#39007318">next</a><span>|</span><label class="collapse" for="c-39007193">[-]</label><label class="expand" for="c-39007193">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Isn&#x27;t the whole point of immediate UIs to get rid of the &quot;event loop&quot; though?<p>No, not at all. It&#x27;s to take explicit control of the event loop. It&#x27;s right there, you have a loop and the buttons still fire events, you just have to check for them on every iteration of the loop.</div><br/></div></div></div></div><div id="39007318" class="c"><input type="checkbox" id="c-39007318" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#39006897">parent</a><span>|</span><a href="#39007003">prev</a><span>|</span><a href="#39008736">next</a><span>|</span><label class="collapse" for="c-39007318">[-]</label><label class="expand" for="c-39007318">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry, but I&#x27;ve got to call this out as woefully inaccurate.<p>&gt; [...] so you can handle the event loop in a sane way.<p>The whole point of an immediate-mode framework is that the call-stack acts as the event loop.  You run through your UI code, and if a thing was interacted with on the previous frame, you just handle it.  What about that setup is not sane?<p>&gt; [...] instead of just smashing everything into one form [...]<p>There is nothing about immediate mode that makes it more or less able to have everything &#x27;smashed into one form&#x27;.  You can do that just as well with your retained-mode framework of choice.<p>&gt; The trouble comes from not componentizing things<p>This also has nothing to do with the immediate vs. retained mode discussion.  You could just as easily make a giant mess in retained-mode by not making reusable components.<p>&gt; once you start dealing with multiple application views that conditionally show&#x2F;hide, with branching flows of any kind [..]<p>In my spare time, I work on a game engine whose editor&#x2F;debug UI is completely immediate mode.  There are discrete views into nearly everything in the engine.  Entity data, a color picker, memory and CPU performance views, asset viewers&#x2F;pickers, a terrain editor with like 10 modes.. you name it.  There are plenty of conditionally shown views.  There is plenty of &#x27;componentizing&#x27; of things going on.  The editor UI is in the neighborhood of 10k lines, most of which is generated.  If that&#x27;s below your bar for quick-n-dirty, maybe we have different opinions on what qualifies.</div><br/><div id="39007659" class="c"><input type="checkbox" id="c-39007659" checked=""/><div class="controls bullet"><span class="by">moron4hire</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007318">parent</a><span>|</span><a href="#39008736">next</a><span>|</span><label class="collapse" for="c-39007659">[-]</label><label class="expand" for="c-39007659">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The editor UI is in the neighborhood of 10k lines, most of which is generated.<p>I mean, this sounds like you&#x27;ve created a retained mode DSL that gets compiled into immediate mode.<p>And yes, 10 KLoC is definitely a small project, especially when &quot;most of which is generated&quot;.</div><br/><div id="39007732" class="c"><input type="checkbox" id="c-39007732" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007659">parent</a><span>|</span><a href="#39008736">next</a><span>|</span><label class="collapse" for="c-39007732">[-]</label><label class="expand" for="c-39007732">[1 more]</label></div><br/><div class="children"><div class="content">&gt; this sounds like you&#x27;ve created a retained mode DSL that gets compiled into immediate mode<p>Nope, I wrote a template-metaprogramming language, which generates the UI.  There&#x27;s nothing retained-mode about it.<p>The source code:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;scallyw4g&#x2F;bonsai&#x2F;blob&#x2F;672a3520d7537ef4e754e0dc2535f2df5817c99a&#x2F;src&#x2F;engine&#x2F;editor.h#L81">https:&#x2F;&#x2F;github.com&#x2F;scallyw4g&#x2F;bonsai&#x2F;blob&#x2F;672a3520d7537ef4e75...</a><p>The result:
<a href="https:&#x2F;&#x2F;github.com&#x2F;scallyw4g&#x2F;bonsai&#x2F;blob&#x2F;master&#x2F;generated&#x2F;do_editor_ui_for_compound_type_world_chunk.h">https:&#x2F;&#x2F;github.com&#x2F;scallyw4g&#x2F;bonsai&#x2F;blob&#x2F;master&#x2F;generated&#x2F;do...</a><p>&gt; And yes, 10 KLoC is definitely a small project<p>I said it cleared the bar for quick-n-dirty.  I agree it&#x27;s not a large amount of code.</div><br/></div></div></div></div></div></div><div id="39008736" class="c"><input type="checkbox" id="c-39008736" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#39006897">parent</a><span>|</span><a href="#39007318">prev</a><span>|</span><a href="#39007878">next</a><span>|</span><label class="collapse" for="c-39008736">[-]</label><label class="expand" for="c-39008736">[1 more]</label></div><br/><div class="children"><div class="content">The way I think about it, GUIs come down to a few basic principles:<p>1. Program data is primarily hierarchical. This means that you can generally compose a view for a data item out of smaller views down to a basic set of elements (e.g., text display, combo box, etc.), and also means that you can generally ignore all data not included that view. There are some cases where this breaks down (tables really stretch it, for example), but it definitely holds for most GUIs.<p>2. UI also has state independent of program data. Immediate GUIs to a degree go ha-ha-there&#x27;s-no-such-thing and make it somebody else&#x27;s problem, but this state has to be retained <i>somewhere</i>. However, it&#x27;s not exactly a binary choice between UI and program state--something like whether or not a checkbox is checked can go either way (I think of it as UI state because I tend to deal in batch-mode programs, where what is going to happen is the UI state will be distilled into the input to code I execute whose results will be displayed).<p>3. Conversion of program state to UI needs to be lazy--you don&#x27;t want to forcibly map every element in a list immediately to UI widgets. The best example of this, of course, is the scrollbar.<p>4. Whereas program state is hierarchical, UI state is far less hierarchical in nature. That is to say, the state of a UI element may influence the display of a UI element in a completely different tree.<p>The difference between immediate and retained mode is less important than it might seem at first glance. If your UI is simple and largely static, hierarchical application of canned elements, then both an immediate and a retained mode interface will end up looking roughly the same in terms of code. If your UI is complex and deals with heavy and very impure state, it again doesn&#x27;t matter all that much, because you&#x27;re going to have to maintain that state all yourself anyways.<p>As a programmer who hates writing GUI code, though, all I really want is a thoroughly complete set of widgets (the ontology of UI is pretty standard, after all). I don&#x27;t really care about immediate mode or retained mode, I just want a path that lets me easily render my program state with the minimum hassle. And quite frankly, it seems like the only GUI toolkits that make it as far as figuring out how to include a lazy table widget are the retained mode GUIs, which maybe suggests something about immediate mode GUIs.</div><br/></div></div><div id="39007878" class="c"><input type="checkbox" id="c-39007878" checked=""/><div class="controls bullet"><span class="by">merb</span><span>|</span><a href="#39006897">parent</a><span>|</span><a href="#39008736">prev</a><span>|</span><a href="#39008523">next</a><span>|</span><label class="collapse" for="c-39007878">[-]</label><label class="expand" for="c-39007878">[4 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a reason every major OS GUI toolkit is this design.<p>Ehh.. the latest os ui toolkit is uwp which lost to react native (a im gui) and it does not look that winui3 will fix that.
Linux has two major gui libraries, both are probably only used by enthusiasts and not by enterprises which prefer to target react native (mostly for different reasons tough)<p>Drawing components won because the object oriented world of gui design sucks and because itâs hard to target multiple systems. All modern ui libs use a kind of immediate mode. Itâs way easier to understand and you do not need to explain why you need to use mvvm.</div><br/><div id="39009599" class="c"><input type="checkbox" id="c-39009599" checked=""/><div class="controls bullet"><span class="by">rstat1</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007878">parent</a><span>|</span><a href="#39008249">next</a><span>|</span><label class="collapse" for="c-39009599">[-]</label><label class="expand" for="c-39009599">[1 more]</label></div><br/><div class="children"><div class="content">For desktop use, Qt is quite widely used pretty much everywhere. I only ever see React Native being used so a company can claim to have a &quot;native&quot; mobile app.</div><br/></div></div><div id="39008249" class="c"><input type="checkbox" id="c-39008249" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39007878">parent</a><span>|</span><a href="#39009599">prev</a><span>|</span><a href="#39008523">next</a><span>|</span><label class="collapse" for="c-39008249">[-]</label><label class="expand" for="c-39008249">[2 more]</label></div><br/><div class="children"><div class="content">React native is an imgui?  Aren&#x27;t views defined with a declarative language similar but distinct from html?</div><br/><div id="39010391" class="c"><input type="checkbox" id="c-39010391" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39006897">root</a><span>|</span><a href="#39008249">parent</a><span>|</span><a href="#39008523">next</a><span>|</span><label class="collapse" for="c-39010391">[-]</label><label class="expand" for="c-39010391">[1 more]</label></div><br/><div class="children"><div class="content">yes, it is<p>yes, they usually are, which is irrelevant to the question of whether react is retained-mode or immediate-mode<p>please see <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39010462">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39010462</a> for more detail</div><br/></div></div></div></div></div></div></div></div><div id="39008523" class="c"><input type="checkbox" id="c-39008523" checked=""/><div class="controls bullet"><span class="by">abhibeckert</span><span>|</span><a href="#39006897">prev</a><span>|</span><a href="#39007394">next</a><span>|</span><label class="collapse" for="c-39008523">[-]</label><label class="expand" for="c-39008523">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the program is in control of the main event loop, user input is handled as part of program flow<p>Is that supposed to be a good thing? I don&#x27;t want to write an event loop - I&#x27;ll probably screw it up and introduce bugs.<p>&gt; the program state is both minimal [...]<p>Um... The comparison of normal web programming and your proposed alternative shows an order of magnitude more code for the same result. And it&#x27;s not even really the same result, I can&#x27;t select text and right click to copy for example. What about complex things like varying the UX depending on the size of the screen and input method. Or accessibility features for someone who&#x27;s blind or can&#x27;t move their hands... those aren&#x27;t optional.<p>&gt; and cleanly separated.<p>Huh? You&#x27;ve got a function called &quot;loop()&quot; that contains all of the code. Where is the separation?</div><br/></div></div><div id="39007394" class="c"><input type="checkbox" id="c-39007394" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#39008523">prev</a><span>|</span><a href="#39007568">next</a><span>|</span><label class="collapse" for="c-39007394">[-]</label><label class="expand" for="c-39007394">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found the immediate-mode UI EGUI in Rust to be easy to use and expressive. It doesn&#x27;t look native, but the code is easy to read and write for reasons alluded to in the article.</div><br/><div id="39007833" class="c"><input type="checkbox" id="c-39007833" checked=""/><div class="controls bullet"><span class="by">tverbeure</span><span>|</span><a href="#39007394">parent</a><span>|</span><a href="#39007568">next</a><span>|</span><label class="collapse" for="c-39007833">[-]</label><label class="expand" for="c-39007833">[1 more]</label></div><br/><div class="children"><div class="content">Heh, my long weekend project has been to write an egui web application as a crutch for my first steps in Rust. I had no idea that it doesnât look native.</div><br/></div></div></div></div><div id="39007568" class="c"><input type="checkbox" id="c-39007568" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#39007394">prev</a><span>|</span><a href="#39008981">next</a><span>|</span><label class="collapse" for="c-39007568">[-]</label><label class="expand" for="c-39007568">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;m seeing &quot;immediate mode&quot; recently, and I hadn&#x27;t encountered it before. It is synonymous with a React &#x2F; Flutter &#x2F; SwiftUI approach to UI to my untrained eye. Help me fill in the rest?</div><br/><div id="39010321" class="c"><input type="checkbox" id="c-39010321" checked=""/><div class="controls bullet"><span class="by">mondrian</span><span>|</span><a href="#39007568">parent</a><span>|</span><a href="#39007594">next</a><span>|</span><label class="collapse" for="c-39010321">[-]</label><label class="expand" for="c-39010321">[1 more]</label></div><br/><div class="children"><div class="content">Immediate mode is a fuzzy concept, as witnessed by this writeup: <a href="https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui&#x2F;wiki&#x2F;About-the-IMGUI-paradigm">https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui&#x2F;wiki&#x2F;About-the-IMGUI-paradi...</a></div><br/></div></div><div id="39007594" class="c"><input type="checkbox" id="c-39007594" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39007568">parent</a><span>|</span><a href="#39010321">prev</a><span>|</span><a href="#39007671">next</a><span>|</span><label class="collapse" for="c-39007594">[-]</label><label class="expand" for="c-39007594">[2 more]</label></div><br/><div class="children"><div class="content">The Dear ImGui readme is a good starting point:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui">https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui</a><p>...now of course Dear ImGui is a specific implementation of the immediate mode UI philosophy, but the general ideas transfer to other imguis as well.</div><br/><div id="39007700" class="c"><input type="checkbox" id="c-39007700" checked=""/><div class="controls bullet"><span class="by">krapp</span><span>|</span><a href="#39007568">root</a><span>|</span><a href="#39007594">parent</a><span>|</span><a href="#39007671">next</a><span>|</span><label class="collapse" for="c-39007700">[-]</label><label class="expand" for="c-39007700">[1 more]</label></div><br/><div class="children"><div class="content">There is also microui, which I like[0], it&#x27;s much smaller but still gets the job done.<p>Which I forked to work with SDL2[1], no guarantees. It&#x27;s fun to hack on.<p>[0]<a href="https:&#x2F;&#x2F;github.com&#x2F;rxi&#x2F;microui">https:&#x2F;&#x2F;github.com&#x2F;rxi&#x2F;microui</a><p>[1]<a href="https:&#x2F;&#x2F;github.com&#x2F;kennethrapp&#x2F;microui">https:&#x2F;&#x2F;github.com&#x2F;kennethrapp&#x2F;microui</a></div><br/></div></div></div></div><div id="39007671" class="c"><input type="checkbox" id="c-39007671" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#39007568">parent</a><span>|</span><a href="#39007594">prev</a><span>|</span><a href="#39008045">next</a><span>|</span><label class="collapse" for="c-39007671">[-]</label><label class="expand" for="c-39007671">[2 more]</label></div><br/><div class="children"><div class="content">It is not synonymous, but you are right that they are very similar concepts.<p>React&#x27;s VDOM actually works just like immediate mode, updating it all on every &quot;re-render&quot; (with diffing taking care of updating only the parts of DOM that actually need an update). So it&#x27;s a bit like &quot;immediate on top of retained mode&quot;.</div><br/><div id="39010462" class="c"><input type="checkbox" id="c-39010462" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39007568">root</a><span>|</span><a href="#39007671">parent</a><span>|</span><a href="#39008045">next</a><span>|</span><label class="collapse" for="c-39010462">[-]</label><label class="expand" for="c-39010462">[1 more]</label></div><br/><div class="children"><div class="content">popular imgui toolkits like dear imgui (fortunately, nobody yet argues that dear imgui isn&#x27;t really imgui) also actually retain some per-widget state<p>i would say that the key question is whether widget deletion and updating is implicit or explicit; it&#x27;s a question about how the api is designed, not how it&#x27;s implemented<p>with immediate-mode graphics like &lt;canvas&gt; or windows gdi, if you update the screen and forget to visit a certain rectangle, that rectangle disappears from the screen.  the same thing happens in an immediate-mode gui if you are drawing a window and forget to visit a certain checkbox.  both whether it appears or not, and everything about how it&#x27;s drawn, are guaranteed to be up-to-date with your<p>with retained-mode graphics like svg or tk canvas or current opengl, if you update the screen and forget to visit a certain rectangle, by contrast, that rectangle <i>stays exactly the same as it was before</i>.  the same thing happens in a retained-mode gui if you are drawing a window and forget to visit a certain checkbox: the checkbox is displayed in the same way it was displayed before, and it may be outdated with respect to the program data it&#x27;s nominally supposed to represent<p>omar&#x27;s explainer at <a href="https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui&#x2F;wiki&#x2F;About-the-IMGUI-paradigm">https:&#x2F;&#x2F;github.com&#x2F;ocornut&#x2F;imgui&#x2F;wiki&#x2F;About-the-IMGUI-paradi...</a> pretty much agrees with the above, though he goes into a lot more detail.  similarly casey&#x27;s talking-at-the-camera video in which he popularized the concept <a href="https:&#x2F;&#x2F;youtu.be&#x2F;Z1qyvQsjK5Y?t=6m30s" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;Z1qyvQsjK5Y?t=6m30s</a><p>so it should be apparent that react falls solidly on the imgui side of the line, which is why people use it</div><br/></div></div></div></div><div id="39008045" class="c"><input type="checkbox" id="c-39008045" checked=""/><div class="controls bullet"><span class="by">okanat</span><span>|</span><a href="#39007568">parent</a><span>|</span><a href="#39007671">prev</a><span>|</span><a href="#39007676">next</a><span>|</span><label class="collapse" for="c-39008045">[-]</label><label class="expand" for="c-39008045">[1 more]</label></div><br/><div class="children"><div class="content">React maybe to a point but in general no.<p>Immediate means you get to decide (or even *forced*) how each and every frame gets drawn. Its opposite is retained GUI which means you have a set of data structures that are automagically drawn by the GUI library. Immediate GUI libraries work with functional-like types while retained GUI uses more data-oriented &#x2F; object oriented types. Immediate mode is imperative, retained mode is declarative.<p>Immediate can offer very low level control and easier combination of various drawing interfaces. Wanna put a button on top of your game canvas? It is basically inserting more code &#x2F; function calls that just draws the thing in an event loop. However you&#x27;re again responsible for parsing input (helper functions exist of course) and directing things to correct place yourself.<p>In retained GUI you define you need a canvas such and such place and a button with red borders and a click() callback that gets called automatically. The GUI framework does all the routing and drawing for you. If it doesn&#x27;t support putting a button over a canvas, you have to do 5x work to customize it and add a new component type.<p>Immediate mode seems the way to go isn&#x27;t it? But now you have a huge event loop that you have to split and organize. It usually takes weeks to onboard newbies and you have to write everything yourself (with the help of the libraries). If you mess up the organization, you&#x27;ll have to search what exact bit of code draws what. Refreshing the UI and looks will require many manual modifications rather than a simple stylesheet change. And immediate GUI has no caching implemented. You are responsible for implementing any such thing. Otherwise you&#x27;ll learn about the thermal and power limits of the system very quickly.<p>At its very core all GUI is immediate. Because a GPU is still a processor. A very special one that&#x27;s optimized for doing mostly branchless and mostly simple arithmetic but still a processor with a machine code and memory. So all retained GUI libraries have a immediate drawing core.</div><br/></div></div><div id="39007676" class="c"><input type="checkbox" id="c-39007676" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#39007568">parent</a><span>|</span><a href="#39008045">prev</a><span>|</span><a href="#39007704">next</a><span>|</span><label class="collapse" for="c-39007676">[-]</label><label class="expand" for="c-39007676">[1 more]</label></div><br/><div class="children"><div class="content">Immediate mode means instead of changing the state of UI widgets individually, the entire UI is redrawn with the current state. Afaik this has slightly worse performance but can simplify the code because the UI itself doesn&#x27;t hold any state.</div><br/></div></div><div id="39007704" class="c"><input type="checkbox" id="c-39007704" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#39007568">parent</a><span>|</span><a href="#39007676">prev</a><span>|</span><a href="#39008981">next</a><span>|</span><label class="collapse" for="c-39007704">[-]</label><label class="expand" for="c-39007704">[3 more]</label></div><br/><div class="children"><div class="content">In graphics programming, immediate mode is the legacy, manual way of drawing.<p>You&#x27;d have code that would &quot;draw thing 1&quot;, move, then &quot;draw thing 2&quot;.<p>Modern pipelines instead have you upload your vertex data to the GPU and write shader code that tells the system how to draw it. They become managed by the GPU and your code cares less about explicit drawing.<p>Another way to look at this is that &quot;immediate mode&quot; feels much more imperative than the modern asynchronous graphics pipeline. You tell the system to draw or render something, and it immediately does so.<p>This post has another good explanation with simple code:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6733934&#x2F;what-does-immediate-mode-mean-in-opengl" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6733934&#x2F;what-does-immedi...</a><p>It&#x27;s much easier to wrap your head around immediate mode though, and several tools with this imperative&#x2F;immediate philosophy (such as imgui) are popular.<p>Edit:<p>Here&#x27;s a fantastic comparison: <a href="https:&#x2F;&#x2F;cognitivewaves.wordpress.com&#x2F;opengl-vbo-shader-vao&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cognitivewaves.wordpress.com&#x2F;opengl-vbo-shader-vao&#x2F;</a><p>(See &quot;Immediate&quot; vs the more modern code that follows.)</div><br/><div id="39008276" class="c"><input type="checkbox" id="c-39008276" checked=""/><div class="controls bullet"><span class="by">oasisaimlessly</span><span>|</span><a href="#39007568">root</a><span>|</span><a href="#39007704">parent</a><span>|</span><a href="#39007736">next</a><span>|</span><label class="collapse" for="c-39008276">[-]</label><label class="expand" for="c-39008276">[1 more]</label></div><br/><div class="children"><div class="content">Despite both having &quot;immediate mode&quot; in the name, immediate mode OpenGL and immediate mode GUIs share very little in common. Pros&#x2F;cons definitely don&#x27;t carry over at all.</div><br/></div></div><div id="39007736" class="c"><input type="checkbox" id="c-39007736" checked=""/><div class="controls bullet"><span class="by">krapp</span><span>|</span><a href="#39007568">root</a><span>|</span><a href="#39007704">parent</a><span>|</span><a href="#39008276">prev</a><span>|</span><a href="#39008981">next</a><span>|</span><label class="collapse" for="c-39007736">[-]</label><label class="expand" for="c-39007736">[1 more]</label></div><br/><div class="children"><div class="content">Any decent immediate mode framework, including Dear ImGUI, has backends which just send quads to the GPU. The code is imperative but it just winds up filling a vertex buffer.</div><br/></div></div></div></div></div></div><div id="39008981" class="c"><input type="checkbox" id="c-39008981" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#39007568">prev</a><span>|</span><a href="#39007169">next</a><span>|</span><label class="collapse" for="c-39008981">[-]</label><label class="expand" for="c-39008981">[1 more]</label></div><br/><div class="children"><div class="content">immediate mode is a tool for certain jobs. drawing arbitrary stuff on screen without layouts or structure would be where I bring it in.</div><br/></div></div><div id="39007169" class="c"><input type="checkbox" id="c-39007169" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#39008981">prev</a><span>|</span><a href="#39008007">next</a><span>|</span><label class="collapse" for="c-39007169">[-]</label><label class="expand" for="c-39007169">[2 more]</label></div><br/><div class="children"><div class="content">Kinda an unfortunate name collision with GIO as used in another UI toolkit stack: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;GIO_(software)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;GIO_(software)</a></div><br/><div id="39007608" class="c"><input type="checkbox" id="c-39007608" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#39007169">parent</a><span>|</span><a href="#39008007">next</a><span>|</span><label class="collapse" for="c-39007608">[-]</label><label class="expand" for="c-39007608">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Please don&#x27;t complain about tangential annoyancesâe.g. article or website formats, name collisions, or back-button breakage. They&#x27;re too common to be interesting.&quot;<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div></div></div><div id="39008007" class="c"><input type="checkbox" id="c-39008007" checked=""/><div class="controls bullet"><span class="by">petabyt</span><span>|</span><a href="#39007169">prev</a><span>|</span><a href="#39007852">next</a><span>|</span><label class="collapse" for="c-39008007">[-]</label><label class="expand" for="c-39008007">[1 more]</label></div><br/><div class="children"><div class="content">I tried Gio on Android several years ago, and sadly it ran at around 15fps, and the APK was around 50mb I think.</div><br/></div></div><div id="39007852" class="c"><input type="checkbox" id="c-39007852" checked=""/><div class="controls bullet"><span class="by">jheriko</span><span>|</span><a href="#39008007">prev</a><span>|</span><a href="#39009131">next</a><span>|</span><label class="collapse" for="c-39007852">[-]</label><label class="expand" for="c-39007852">[1 more]</label></div><br/><div class="children"><div class="content">i tire of IM vs retained discussions. the difference is academic up-to tools and code-gen in my experience. you can make one with the other up-to a point of usability. the classic point of split i find is if a UI designer wants to insert intermediate &quot;for-show&quot; elements, e.g. for animation. in that space imgui is, in practice, just going to disable your ui designers vs a retained mode solution using well established tools for defining and animating ui in standard ways. sure you can undo that problem, but thats code work, code work that blocks your ui people from doing their job until its done, and more points of failure for bugs to creep in...<p>the arguments i hear about debuggability seem brain-dead, but on reflection that might be the utility here. &quot;make things easier to debug, shittier programmers can do work&quot;... and that is not to be taken lightly or dismissively when it has real world weight.<p>retained mode most often exists in the backend, e.g. Win32, although some of it may use IM style interfaces, e.g. MessageBox, and so a lot of im gui tools will still use something retained under the hood, and have to go to some lengths to be able to identify &quot;dynamically created&quot; things. yes it can be worked around, but its another headache and bug vector...<p>ive honestly never seen IM GUI as a great approach, most often i implement it due to demand, and with some frustration at the brain dead arguments levelled for it. it solves a problem of programmer burden, which is not that useful in real world projects in my experience, and since the interfaces are interchangeable, its not really a fundamental decision to be making either until someone else forces it.<p>EDIT: to be clear, imagine trying to debug your data-defined if-statement. really think it through and implement it.</div><br/></div></div><div id="39009131" class="c"><input type="checkbox" id="c-39009131" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#39007852">prev</a><span>|</span><label class="collapse" for="c-39009131">[-]</label><label class="expand" for="c-39009131">[2 more]</label></div><br/><div class="children"><div class="content">Please don&#x27;t ship immediate mode GUIs to normal users. They are good for adding UI to a game or throwing together some quick internal tool, but you&#x27;ll quickly run into tons of limitations, inconsistent behavior for the platform, and difficult styling.<p>&gt; creating user interfaces for mobile and the desktop, avoiding the platform bound and often complex native toolkits<p>Especially for mobile, just use the native toolkit, or something that uses the native toolkit for its backend. I&#x27;m sick of using apps that don&#x27;t use the native toolkit, they almost always have worse performance and just behave in weird ways. Even flutter is guilty of this, and that has all the manpower of a google team behind it.<p>A mobile app using immediate mode, written in _Go_, just sounds like a recipe for an app that will never function as well as its equivalent written specifically for the platform.<p>Stop sacrificing the experience of your users for your own personal developer experience.</div><br/></div></div></div></div></div></div></div></body></html>