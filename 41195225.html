<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723194080904" as="style"/><link rel="stylesheet" href="styles.css?v=1723194080904"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.codingconfessions.com/p/are-function-calls-still-slow-in-python">Recent Performance Improvements in Function Calls in CPython</a> <span class="domain">(<a href="https://blog.codingconfessions.com">blog.codingconfessions.com</a>)</span></div><div class="subtext"><span>rbanffy</span> | <span>61 comments</span></div><br/><div><div id="41197748" class="c"><input type="checkbox" id="c-41197748" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41199133">next</a><span>|</span><label class="collapse" for="c-41197748">[-]</label><label class="expand" for="c-41197748">[4 more]</label></div><br/><div class="children"><div class="content">One of the performance improvements mentioned is &quot;Remove the usage of the C stack in Python to Python calls&quot; [0]. Since Python 3.11, a Python-level function call can be evaluated within the bytecode interpreter loop, no longer requiring a C-level function call.<p>Interestingly, Lua 5.4 did the opposite. Its implementation <i>introduced</i> C-level function calls for performance reasons [1] (although this change was reverted in 5.4.2 [2]).<p>[0] <a href="https:&#x2F;&#x2F;bugs.python.org&#x2F;issue45256" rel="nofollow">https:&#x2F;&#x2F;bugs.python.org&#x2F;issue45256</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;lua&#x2F;lua&#x2F;commit&#x2F;196c87c9cecfacf978f37de4ec69eba0a5971256">https:&#x2F;&#x2F;github.com&#x2F;lua&#x2F;lua&#x2F;commit&#x2F;196c87c9cecfacf978f37de4ec...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;lua&#x2F;lua&#x2F;commit&#x2F;5d8ce05b3f6fad79e37ed21c1076e47a322472c6">https:&#x2F;&#x2F;github.com&#x2F;lua&#x2F;lua&#x2F;commit&#x2F;5d8ce05b3f6fad79e37ed21c10...</a></div><br/><div id="41198288" class="c"><input type="checkbox" id="c-41198288" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#41197748">parent</a><span>|</span><a href="#41198671">next</a><span>|</span><label class="collapse" for="c-41198288">[-]</label><label class="expand" for="c-41198288">[2 more]</label></div><br/><div class="children"><div class="content">Do you by chance know what LuaJIT does?</div><br/><div id="41198380" class="c"><input type="checkbox" id="c-41198380" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41197748">root</a><span>|</span><a href="#41198288">parent</a><span>|</span><a href="#41198671">next</a><span>|</span><label class="collapse" for="c-41198380">[-]</label><label class="expand" for="c-41198380">[1 more]</label></div><br/><div class="children"><div class="content">In JITted code? Nothing, it’s a pure tracing JIT so all calls are flattened. In the interpreter? We can always check the source[1], and it seems it implements its own stack.<p>[1] <a href="https:&#x2F;&#x2F;repo.or.cz&#x2F;luajit-2.0.git&#x2F;blob&#x2F;HEAD:&#x2F;src&#x2F;vm_x64.dasc" rel="nofollow">https:&#x2F;&#x2F;repo.or.cz&#x2F;luajit-2.0.git&#x2F;blob&#x2F;HEAD:&#x2F;src&#x2F;vm_x64.dasc</a>: look for BC_CALL[2], then ins_call before that, then ins_callt just above it.<p>[2] see mirror of the old wiki for the semantics: <a href="https:&#x2F;&#x2F;chrisfls.github.io&#x2F;luajit-wiki&#x2F;Bytecode&#x2F;#Calls-and-Vararg-Handling" rel="nofollow">https:&#x2F;&#x2F;chrisfls.github.io&#x2F;luajit-wiki&#x2F;Bytecode&#x2F;#Calls-and-V...</a></div><br/></div></div></div></div><div id="41198671" class="c"><input type="checkbox" id="c-41198671" checked=""/><div class="controls bullet"><span class="by">bongodongobob</span><span>|</span><a href="#41197748">parent</a><span>|</span><a href="#41198288">prev</a><span>|</span><a href="#41199133">next</a><span>|</span><label class="collapse" for="c-41198671">[-]</label><label class="expand" for="c-41198671">[1 more]</label></div><br/><div class="children"><div class="content">Can you explain what this means? I know all these words, but it looks like retro-encabulator to me.</div><br/></div></div></div></div><div id="41199133" class="c"><input type="checkbox" id="c-41199133" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#41197748">prev</a><span>|</span><a href="#41197456">next</a><span>|</span><label class="collapse" for="c-41199133">[-]</label><label class="expand" for="c-41199133">[16 more]</label></div><br/><div class="children"><div class="content">Reading this, I was interested to see how big the speed difference between Python and PHP is these days, so I tried it like this:<p>min.py:<p><pre><code>    i = 10_000_000
    r = 0

    while i&gt;0:
        i = i-1
        r += min(i,500)

    print(r)
</code></pre>
min.php:<p><pre><code>    &lt;?php

    $i = 10_000_000;
    $r = 0;

    while ($i&gt;0) {
        $i = $i-1;
        $r += min($i,500);
    }

    print($r);
</code></pre>
The results:<p><pre><code>    time python3 min.py
    4999874750
    real    0m2.523s

    time php min.php
    4999874750
    real    0m0.333s
</code></pre>
Looks like Python is still 8x slower than PHP. Pretty significant.<p>I ran it with Python 3.11.2 and PHP 8.2.18</div><br/><div id="41199613" class="c"><input type="checkbox" id="c-41199613" checked=""/><div class="controls bullet"><span class="by">ShinTakuya</span><span>|</span><a href="#41199133">parent</a><span>|</span><a href="#41199535">next</a><span>|</span><label class="collapse" for="c-41199613">[-]</label><label class="expand" for="c-41199613">[4 more]</label></div><br/><div class="children"><div class="content">Not to be a stickler, but the only fair benchmark would be to select the most recent stable version of each. Doing so is fairly easy with docker I would think, if you don&#x27;t wish to modify your system.</div><br/><div id="41199648" class="c"><input type="checkbox" id="c-41199648" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199613">parent</a><span>|</span><a href="#41199634">next</a><span>|</span><label class="collapse" for="c-41199648">[-]</label><label class="expand" for="c-41199648">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say you are a stickler. But the most productive addition to the discussion would be to do the benchmark as you see fit and then show us the results.</div><br/><div id="41199687" class="c"><input type="checkbox" id="c-41199687" checked=""/><div class="controls bullet"><span class="by">ShinTakuya</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199648">parent</a><span>|</span><a href="#41199634">next</a><span>|</span><label class="collapse" for="c-41199687">[-]</label><label class="expand" for="c-41199687">[1 more]</label></div><br/><div class="children"><div class="content">Very fair feedback. I&#x27;ll do so once I&#x27;m at a machine!</div><br/></div></div></div></div></div></div><div id="41199535" class="c"><input type="checkbox" id="c-41199535" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#41199133">parent</a><span>|</span><a href="#41199613">prev</a><span>|</span><a href="#41199913">next</a><span>|</span><label class="collapse" for="c-41199535">[-]</label><label class="expand" for="c-41199535">[1 more]</label></div><br/><div class="children"><div class="content">3.11? The article explains there are improvements on that specific benchmark in newer versions. Not on the order of magnitude that it would catch up here, but still significant.</div><br/></div></div><div id="41199913" class="c"><input type="checkbox" id="c-41199913" checked=""/><div class="controls bullet"><span class="by">fastasucan</span><span>|</span><a href="#41199133">parent</a><span>|</span><a href="#41199535">prev</a><span>|</span><a href="#41199894">next</a><span>|</span><label class="collapse" for="c-41199913">[-]</label><label class="expand" for="c-41199913">[1 more]</label></div><br/><div class="children"><div class="content">This is more a measurement of looping, calling the min function and printing than the language itself. All benchmarks is of course that to some degree, but I really don&#x27;t think this is a good comparison.</div><br/></div></div><div id="41199222" class="c"><input type="checkbox" id="c-41199222" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41199133">parent</a><span>|</span><a href="#41199894">prev</a><span>|</span><a href="#41197456">next</a><span>|</span><label class="collapse" for="c-41199222">[-]</label><label class="expand" for="c-41199222">[8 more]</label></div><br/><div class="children"><div class="content">The dynamic aspect of Python is once again probably the major penalty here.<p>One major difference here is that in Python you can overwrite min(), so it has to access this function through more abstraction, but not in PHP. I bet PyPy is close to PHP here however.</div><br/><div id="41199431" class="c"><input type="checkbox" id="c-41199431" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199222">parent</a><span>|</span><a href="#41199343">next</a><span>|</span><label class="collapse" for="c-41199431">[-]</label><label class="expand" for="c-41199431">[5 more]</label></div><br/><div class="children"><div class="content">You might be right about the min() call being the major penalty.<p>When I avoid the min() call like this ...<p>min2.py:<p><pre><code>    i = 10_000_000
    r = 0

    while i&gt;0:
        i = i-1
        if i&lt;500: r += i
        else    : r += 500

    print(r)
</code></pre>
I get a speedup of about 50%:<p><pre><code>    time python3 min2.py
    4999874750
    real    0m1.338s
</code></pre>
Still 4x slower than PHP though.<p>With PyPy I get an amazing speedup of 96%:<p><pre><code>    time pypy3 min.py
    4999874750
    real    0m0.088s
</code></pre>
4 times faster than the PHP version!<p>I&#x27;m not sure what the state of things is regarding PyPy and running a web application. Doing a bit of googling, it seems that calling C functions from PyPy is slow, so one would have to check if the application uses those (for example to connect to the database).</div><br/><div id="41200061" class="c"><input type="checkbox" id="c-41200061" checked=""/><div class="controls bullet"><span class="by">tripflag</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199431">parent</a><span>|</span><a href="#41199999">next</a><span>|</span><label class="collapse" for="c-41200061">[-]</label><label class="expand" for="c-41200061">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tested a particular python webserver in PyPy and saw roughly the same performance as CPython on average. My guess at the time was that PyPy has a bigger overhead for network sockets than CPython. You would likely see a gain from using PyPy if the webserver did heavier processing in pure python than what mine does.</div><br/></div></div><div id="41199999" class="c"><input type="checkbox" id="c-41199999" checked=""/><div class="controls bullet"><span class="by">khgrfas</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199431">parent</a><span>|</span><a href="#41200061">prev</a><span>|</span><a href="#41199832">next</a><span>|</span><label class="collapse" for="c-41199999">[-]</label><label class="expand" for="c-41199999">[1 more]</label></div><br/><div class="children"><div class="content">For a web application PHP is likely much faster, because it does templating in a sane manner, while you need huge frameworks for Python.</div><br/></div></div><div id="41199832" class="c"><input type="checkbox" id="c-41199832" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199431">parent</a><span>|</span><a href="#41199999">prev</a><span>|</span><a href="#41199343">next</a><span>|</span><label class="collapse" for="c-41199832">[-]</label><label class="expand" for="c-41199832">[2 more]</label></div><br/><div class="children"><div class="content">FWIW, if I place the code in a function, so that variable lookups are constant-time rather than a dictionary lookup in the module globals, then (on my Mac, with Python 3.12) I get a two-fold speedup. That is:<p><pre><code>    def spam():
        t1 = time.time()
        i = 10_000_000
        r = 0

        while i&gt;0:
            i = i-1
            if i&lt;500: r += i
            else    : r += 500

        t2 = time.time()
        print(r)
        print(&quot;Time:&quot;, t2-t1)
</code></pre>
reports 0.87 seconds outside a function and 0.43 seconds when inside a function.<p>(Using the shell&#x27;s time, of course, also includes the Python startup time. When I use it I get 0.94 and 0.49 seconds, indicating a 0.06s startup penalty.)</div><br/><div id="41199923" class="c"><input type="checkbox" id="c-41199923" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199832">parent</a><span>|</span><a href="#41199343">next</a><span>|</span><label class="collapse" for="c-41199923">[-]</label><label class="expand" for="c-41199923">[1 more]</label></div><br/><div class="children"><div class="content">Interesting! Same here.<p>Also with pypy3, putting it in a function about doubles the speed:<p><pre><code>    time pypy3 min_in_function.py 
    4999874750
    real    0m0.045s</code></pre></div><br/></div></div></div></div></div></div><div id="41199343" class="c"><input type="checkbox" id="c-41199343" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199222">parent</a><span>|</span><a href="#41199431">prev</a><span>|</span><a href="#41197456">next</a><span>|</span><label class="collapse" for="c-41199343">[-]</label><label class="expand" for="c-41199343">[2 more]</label></div><br/><div class="children"><div class="content">With pypy, the code runs in 0.226s on my computer.<p>So yes, the comparison of OP is CPython vs PHP.</div><br/><div id="41199448" class="c"><input type="checkbox" id="c-41199448" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#41199133">root</a><span>|</span><a href="#41199343">parent</a><span>|</span><a href="#41197456">next</a><span>|</span><label class="collapse" for="c-41199448">[-]</label><label class="expand" for="c-41199448">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is CPython. Added data on the PyPy performance to this comment now:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41199431">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41199431</a></div><br/></div></div></div></div></div></div></div></div><div id="41197456" class="c"><input type="checkbox" id="c-41197456" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41199133">prev</a><span>|</span><a href="#41196686">next</a><span>|</span><label class="collapse" for="c-41197456">[-]</label><label class="expand" for="c-41197456">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m always shocked at how much performance we leave on the table in these places. I did a super quick benchmark in python[0] and go [1] (based on necovek&#x27;s[2] comment) and ran them both locally. The go implementation runs the entire benchmark quicker than the fastest of the python ones.<p>The deviation in go&#x27;s performance is still large, but far less so than Python&#x27;s. Making the &quot;wrong&quot; choice for a single function call (bearing in mind that this is 10k iterations so we&#x27;re still in the realm of scales even a moderate app can hit) in python is catastrophic, making the wrong choice for go is a significant slowdown but still 5x faster than doing it in Python. That sort of mental overhead is going to be everywhere, and it certainly doesn&#x27;t encourage me to want to use python for a project.<p>[0] <a href="https:&#x2F;&#x2F;www.online-python.com&#x2F;9gcpKLe458" rel="nofollow">https:&#x2F;&#x2F;www.online-python.com&#x2F;9gcpKLe458</a> 
[1] <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;zYKE0oZMFF4?v=goprev" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;zYKE0oZMFF4?v=goprev</a>  
[2] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41196915">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41196915</a></div><br/><div id="41198177" class="c"><input type="checkbox" id="c-41198177" checked=""/><div class="controls bullet"><span class="by">heavyset_go</span><span>|</span><a href="#41197456">parent</a><span>|</span><a href="#41198006">next</a><span>|</span><label class="collapse" for="c-41198177">[-]</label><label class="expand" for="c-41198177">[1 more]</label></div><br/><div class="children"><div class="content">Sounds about right, you can get a ~4x speed up by compiling Python with Nuitka or Mypyc.</div><br/></div></div><div id="41198006" class="c"><input type="checkbox" id="c-41198006" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41197456">parent</a><span>|</span><a href="#41198177">prev</a><span>|</span><a href="#41197668">next</a><span>|</span><label class="collapse" for="c-41198006">[-]</label><label class="expand" for="c-41198006">[5 more]</label></div><br/><div class="children"><div class="content">Write it in Python, profile it, and move the bottlenecks into C, called with ctypes.</div><br/><div id="41198887" class="c"><input type="checkbox" id="c-41198887" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#41197456">root</a><span>|</span><a href="#41198006">parent</a><span>|</span><a href="#41197668">next</a><span>|</span><label class="collapse" for="c-41198887">[-]</label><label class="expand" for="c-41198887">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to rewrite large chunks anyway, I&#x27;d use Go from the start.</div><br/><div id="41199159" class="c"><input type="checkbox" id="c-41199159" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#41197456">root</a><span>|</span><a href="#41198887">parent</a><span>|</span><a href="#41197668">next</a><span>|</span><label class="collapse" for="c-41199159">[-]</label><label class="expand" for="c-41199159">[3 more]</label></div><br/><div class="children"><div class="content">This is something I find quite fascinating. I&#x27;ve seen so much time wasted on Python this way it&#x27;s incredible.<p>Insanely smart optimizations done. But then you rewrite the whole thing in vanilla Rust without profiling once and it&#x27;s still 20x faster, and much more readable than the mix of numpy vectorization and C-routines.<p>It&#x27;s kind of knowingly entering a sunk-cost fallacy for convenience. Before the cost is even sunk.<p>Python is often just the wrong choice. And it&#x27;s not even that much simpler if you ask me.<p>In a language where you use value-based errors, have powerful sum types and strong typing guarantees, you can often get there faster, too IMO, because you can avoid a lot of mistakes by using the strictness of the compiler in your favor.</div><br/><div id="41199178" class="c"><input type="checkbox" id="c-41199178" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#41197456">root</a><span>|</span><a href="#41199159">parent</a><span>|</span><a href="#41197668">next</a><span>|</span><label class="collapse" for="c-41199178">[-]</label><label class="expand" for="c-41199178">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Insanely smart optimizations done. But then you rewrite the whole thing in vanilla Rust without profiling once and it&#x27;s still 20x faster, and much more readable than the mix of numpy vectorization and C-routines.<p>I&#x27;d argue that if you can rewrite the whole thing in Rust (or any other language), then it&#x27;s not really a large project and it doesn&#x27;t matter what you originally wrote it in.<p>On multiple occassions I had to port parts of Python projects to C++ for performance reasons, and the amount of code you have to write (and time you need to spend) is mind blowing. Sometimes a single line of Python would expand to several files of C++, and you always had to redesign it somehow so that memory and lifetime management becomes feasible.<p>Python is often the right choice IMO, because most of the time the convenience you mention trumps all other concerns, including performance. I bet you would get tons of examples from people if you &quot;Ask HN&quot; about &quot;how many quickly written Python prototypes are still out there years later because their C++ replacement could never be implemented on time?&quot;</div><br/><div id="41199892" class="c"><input type="checkbox" id="c-41199892" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41197456">root</a><span>|</span><a href="#41199178">parent</a><span>|</span><a href="#41197668">next</a><span>|</span><label class="collapse" for="c-41199892">[-]</label><label class="expand" for="c-41199892">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a huge swathe of languages between Python and C++. On threads about Node&#x27;s performance (which is somewhere in between) people regularly say that it&#x27;s unfair of developers to solely focus on devex, which is the argument here.<p>&gt; On multiple occassions I had to port parts of Python projects to C++ for performance reasons, and the amount of code you have to write (and time you need to spend) is mind blowing. Sometimes a single line of Python would expand to several files of C++, and you always had to redesign it somehow so that memory and lifetime management becomes feasible.<p>Part of that is because it&#x27;s designed for python. Using this benchmark example, the python code (without imports) is 36 lines and the go code is 70. Except, we&#x27;re doing a 1:1 copy of python to go here, not writing it like you would write go. Most of the difference is braces, and the test scaffold.<p>I&#x27;d also argue the go code is more readable than the python code, doubly so when it scales.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41197668" class="c"><input type="checkbox" id="c-41197668" checked=""/><div class="controls bullet"><span class="by">serjester</span><span>|</span><a href="#41197456">parent</a><span>|</span><a href="#41198006">prev</a><span>|</span><a href="#41197756">next</a><span>|</span><label class="collapse" for="c-41197668">[-]</label><label class="expand" for="c-41197668">[2 more]</label></div><br/><div class="children"><div class="content">Cpython deliberately chooses to prioritize simplicity, stability and easy C extensions over raw speed. If you run the benchmark in PyPy (the performance optimized implementation) it’d be 10X faster. You could argue anything that’s performance bottlenecked shouldn’t be implemented in Python in the first place and therefore C compatibility is critical.</div><br/><div id="41199807" class="c"><input type="checkbox" id="c-41199807" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41197456">root</a><span>|</span><a href="#41197668">parent</a><span>|</span><a href="#41197756">next</a><span>|</span><label class="collapse" for="c-41199807">[-]</label><label class="expand" for="c-41199807">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have easy access to pypy so I can&#x27;t run the benchmark on that I&#x27;m afraid. I&#x27;d love to see some relative results though.<p>&gt; You could argue anything that’s performance bottlenecked shouldn’t be implemented in Python in the first place and therefore C compatibility is critical.<p>Honestly, I think I&#x27;m heading towards &quot;python should only be used for glue where performance does not matter&quot;. The sheer amount of time lost to waiting for slow runtimes is often brought up with node and electron, but I ran the benchmark in node and it&#x27;s about halfway between go and python.</div><br/></div></div></div></div><div id="41197756" class="c"><input type="checkbox" id="c-41197756" checked=""/><div class="controls bullet"><span class="by">bongodongobob</span><span>|</span><a href="#41197456">parent</a><span>|</span><a href="#41197668">prev</a><span>|</span><a href="#41196686">next</a><span>|</span><label class="collapse" for="c-41197756">[-]</label><label class="expand" for="c-41197756">[1 more]</label></div><br/><div class="children"><div class="content">Prototype in Python so you can get your ideas on the page then rewrite in something else has been my method for a while now.</div><br/></div></div></div></div><div id="41196686" class="c"><input type="checkbox" id="c-41196686" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#41197456">prev</a><span>|</span><a href="#41198334">next</a><span>|</span><label class="collapse" for="c-41196686">[-]</label><label class="expand" for="c-41196686">[4 more]</label></div><br/><div class="children"><div class="content">I wonder how would simply doing a `return min(heights)` compare to any of the options given?<p>(It sure doesn&#x27;t demonstrate the improvements between interpreter versions, but that&#x27;s the classic, Python way of optimizing: let builtins do all the looping)</div><br/><div id="41196915" class="c"><input type="checkbox" id="c-41196915" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#41196686">parent</a><span>|</span><a href="#41198334">next</a><span>|</span><label class="collapse" for="c-41196915">[-]</label><label class="expand" for="c-41196915">[3 more]</label></div><br/><div class="children"><div class="content">I was curious myself, so I&#x27;ve ran a quick benchmark:<p><pre><code>  import random
  import timeit

  heights = [random.randint(0, 10000)&#x2F;100 for i in range(10000)]

  def benchmark1(heights):
      smallest = heights[0]
      count = len(heights) - 1
      while count &gt; 0:
          if heights[count] &lt; smallest:
              smallest = heights[count]
          count -= 1
      return smallest


  def benchmark1b(heights):
      a = 1
      b = len(heights) - 1
      min_height = heights[0]
      while a &lt; b:
          if heights[a] &lt; min_height:
              min_height = heights[a]
          a += 1

      return min_height


  def benchmark2(heights):
      smallest = heights[0]
      count = len(heights) - 1
      while count &gt; 0:
          smallest = min(heights[count], smallest)
          count -= 1
      return smallest

  print(timeit.timeit(&#x27;min(heights)&#x27;, number=1000, globals={&#x27;heights&#x27;: heights}))
  print(timeit.timeit(&#x27;benchmark1(heights)&#x27;, number=1000, globals={&#x27;heights&#x27;: heights, &#x27;benchmark1&#x27;: benchmark1}))
  print(timeit.timeit(&#x27;benchmark1b(heights)&#x27;, number=1000, globals={&#x27;heights&#x27;: heights, &#x27;benchmark1b&#x27;: benchmark1b}))
  print(timeit.timeit(&#x27;benchmark2(heights)&#x27;, number=1000, globals={&#x27;heights&#x27;: heights, &#x27;benchmark2&#x27;: benchmark2}))
</code></pre>
Here are the results in Python 3.11:<p><pre><code>  0.04471710091456771
  0.21777329698670655
  0.22779683792032301
  0.6679719020612538
</code></pre>
So, using min over a list is ~5x faster, using a single variable and a constant 0 is ~5% faster than using two for boundaries, and using min inside the loop instead of the if check is another 3 times slower: so, the old approach of looking for opportunities to use a builtin instead of looping still likely &quot;wins&quot; in the newer interpreters too, but if someone&#x27;s got 3.14 alpha up, I&#x27;d love to see the results.<p>I might install 3.13 to check it out there too.</div><br/><div id="41197408" class="c"><input type="checkbox" id="c-41197408" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#41196686">root</a><span>|</span><a href="#41196915">parent</a><span>|</span><a href="#41198334">next</a><span>|</span><label class="collapse" for="c-41197408">[-]</label><label class="expand" for="c-41197408">[2 more]</label></div><br/><div class="children"><div class="content">Now try with a for loop.</div><br/><div id="41198703" class="c"><input type="checkbox" id="c-41198703" checked=""/><div class="controls bullet"><span class="by">memco</span><span>|</span><a href="#41196686">root</a><span>|</span><a href="#41197408">parent</a><span>|</span><a href="#41198334">next</a><span>|</span><label class="collapse" for="c-41198703">[-]</label><label class="expand" for="c-41198703">[1 more]</label></div><br/><div class="children"><div class="content">For science I added versions of the benchmarks as for loops: it&#x27;s faster than the while loop versions above, but min(heights) is still way faster:<p><pre><code>    def benchmark1for(heights):
        smallest = heights[0]
        for h in heights:
            if h &lt; smallest:
                smallest = h
        return smallest

    def benchmark2for(heights):
        smallest = heights[0]
        for h in heights:
            smallest = min(h, smallest)
        return smallest
</code></pre>
Results:
min(heights) : 0.07920974999433383
benchmark1   : 0.954568124958314
benchmark1for: 0.5765543330344371
benchmark2   : 1.8662503749947064
benchmark2for: 1.5281645830255002</div><br/></div></div></div></div></div></div></div></div><div id="41198334" class="c"><input type="checkbox" id="c-41198334" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#41196686">prev</a><span>|</span><a href="#41196853">next</a><span>|</span><label class="collapse" for="c-41198334">[-]</label><label class="expand" for="c-41198334">[5 more]</label></div><br/><div class="children"><div class="content">I think the safest way to understand Python is that performance is a “nice to have” feature, traded off for legibility and flexibility and even simplicity of the CPython code base (go read it! You barely need to understand C and a lot of it is written in Python!).<p>Don’t waste time being surprised that you can do better than the default implementation. Just assume that and do so when you’ve measured that it matters.<p>That being said, (mostly) free performance is always nice. I’m glad they’re working on performance improvements where they can do it without sacrificing much.</div><br/><div id="41198590" class="c"><input type="checkbox" id="c-41198590" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#41198334">parent</a><span>|</span><a href="#41196853">next</a><span>|</span><label class="collapse" for="c-41198590">[-]</label><label class="expand" for="c-41198590">[4 more]</label></div><br/><div class="children"><div class="content">Take a look at Nim.<p>You get C performance, with the readability of Python.<p><a href="https:&#x2F;&#x2F;nim-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nim-lang.org&#x2F;</a></div><br/><div id="41200011" class="c"><input type="checkbox" id="c-41200011" checked=""/><div class="controls bullet"><span class="by">tc4v</span><span>|</span><a href="#41198334">root</a><span>|</span><a href="#41198590">parent</a><span>|</span><a href="#41198800">next</a><span>|</span><label class="collapse" for="c-41200011">[-]</label><label class="expand" for="c-41200011">[1 more]</label></div><br/><div class="children"><div class="content">Everyone need to stop comparing Nim with Python. Nim is closer to pascal, and the only thing it shares with Python is indentation base syntax. It doesn&#x27;t have the expressivity and flexibility of Python. It&#x27;s a nice language, but there is no good reason to compare it to Python.</div><br/></div></div><div id="41198800" class="c"><input type="checkbox" id="c-41198800" checked=""/><div class="controls bullet"><span class="by">dilawar</span><span>|</span><a href="#41198334">root</a><span>|</span><a href="#41198590">parent</a><span>|</span><a href="#41200011">prev</a><span>|</span><a href="#41196853">next</a><span>|</span><label class="collapse" for="c-41198800">[-]</label><label class="expand" for="c-41198800">[2 more]</label></div><br/><div class="children"><div class="content">I really really want nim to catch up. It&#x27;s a lovely language. I&#x27;ve used it for small projects and it is great but I couldn&#x27;t use it for anything complex that requires third-party libraries. The ecosystem is just not there.<p>I wonder what is stopping community mindshare?</div><br/><div id="41199562" class="c"><input type="checkbox" id="c-41199562" checked=""/><div class="controls bullet"><span class="by">stoperaticless</span><span>|</span><a href="#41198334">root</a><span>|</span><a href="#41198800">parent</a><span>|</span><a href="#41196853">next</a><span>|</span><label class="collapse" for="c-41199562">[-]</label><label class="expand" for="c-41199562">[1 more]</label></div><br/><div class="children"><div class="content">I bet same reason that you just outlined.<p>(Chicken and the egg problem)</div><br/></div></div></div></div></div></div></div></div><div id="41196853" class="c"><input type="checkbox" id="c-41196853" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#41198334">prev</a><span>|</span><a href="#41197343">next</a><span>|</span><label class="collapse" for="c-41196853">[-]</label><label class="expand" for="c-41196853">[2 more]</label></div><br/><div class="children"><div class="content">So there&#x27;s only three super-instructions? I wonder if there are plans for more.</div><br/><div id="41197571" class="c"><input type="checkbox" id="c-41197571" checked=""/><div class="controls bullet"><span class="by">Ralfp</span><span>|</span><a href="#41196853">parent</a><span>|</span><a href="#41197343">next</a><span>|</span><label class="collapse" for="c-41197571">[-]</label><label class="expand" for="c-41197571">[1 more]</label></div><br/><div class="children"><div class="content">They removed most of superinstructions because those prevented other more effective optimizations:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;issues&#x2F;105229">https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;issues&#x2F;105229</a></div><br/></div></div></div></div><div id="41197343" class="c"><input type="checkbox" id="c-41197343" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#41196853">prev</a><span>|</span><a href="#41196088">next</a><span>|</span><label class="collapse" for="c-41197343">[-]</label><label class="expand" for="c-41197343">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t trust anyone who uses camelCase to write Python. Or, unnecessary while loops.<p>But, sometimes you can improve built in functions. I found that using a custom (but simple) string-to-int function in golang is a bit quicker than strconv.formatInt() for decimal numbers.<p>So, there&#x27;s that.<p>Python isn&#x27;t really supposed to be geared towards performance. I like the language, but only see articles like this as resume fodder.</div><br/><div id="41197367" class="c"><input type="checkbox" id="c-41197367" checked=""/><div class="controls bullet"><span class="by">lacksconfidence</span><span>|</span><a href="#41197343">parent</a><span>|</span><a href="#41197396">next</a><span>|</span><label class="collapse" for="c-41197367">[-]</label><label class="expand" for="c-41197367">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but only see articles like this as resume fodder.<p>Not super important, but i think it&#x27;s worth calling out. Some of us program because it&#x27;s fun. We dig into problems like this because it scratches an itch. We share in the hopes of interacting with like-minded individuals. Not everything is about resumes.</div><br/><div id="41198018" class="c"><input type="checkbox" id="c-41198018" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41197343">root</a><span>|</span><a href="#41197367">parent</a><span>|</span><a href="#41197396">next</a><span>|</span><label class="collapse" for="c-41198018">[-]</label><label class="expand" for="c-41198018">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Some of us do it because we stubbornly want to see just how fast we can make a “slow” language go.</div><br/></div></div></div></div><div id="41197396" class="c"><input type="checkbox" id="c-41197396" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#41197343">parent</a><span>|</span><a href="#41197367">prev</a><span>|</span><a href="#41196088">next</a><span>|</span><label class="collapse" for="c-41197396">[-]</label><label class="expand" for="c-41197396">[2 more]</label></div><br/><div class="children"><div class="content">Wow, very unfair. It should not be surprising that people writing Python might actually care about performance, even if it isn&#x27;t so important that they must write their software in assembly.<p>The code wasn&#x27;t the authors, and what&#x27;s more it&#x27;s just an example to talk about the bytecode. Everyone knows `min(some_list)` is faster and more Pythonic.<p>This is a very interesting article and probably exposed a few people to a few interesting Python internals.</div><br/><div id="41197427" class="c"><input type="checkbox" id="c-41197427" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#41197343">root</a><span>|</span><a href="#41197396">parent</a><span>|</span><a href="#41196088">next</a><span>|</span><label class="collapse" for="c-41197427">[-]</label><label class="expand" for="c-41197427">[1 more]</label></div><br/><div class="children"><div class="content">I was just referring to the sample code at the top. I should have clarified that and I apologize for the lack of clarity.<p>But, I would like to see the author use a for loop. I&#x27;m not why anyone would use a while loop of they know the constraints.</div><br/></div></div></div></div></div></div><div id="41196717" class="c"><input type="checkbox" id="c-41196717" checked=""/><div class="controls bullet"><span class="by">L-four</span><span>|</span><a href="#41196088">prev</a><span>|</span><a href="#41195809">next</a><span>|</span><label class="collapse" for="c-41196717">[-]</label><label class="expand" for="c-41196717">[2 more]</label></div><br/><div class="children"><div class="content">Loops should be avoided in python. Only constant time operations should be performed.</div><br/></div></div><div id="41195809" class="c"><input type="checkbox" id="c-41195809" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41196717">prev</a><span>|</span><label class="collapse" for="c-41195809">[-]</label><label class="expand" for="c-41195809">[11 more]</label></div><br/><div class="children"><div class="content">AFAIK this is because CPython has to walk the scope up to find the import for every call in your loop, and still applies to python3, right? You can still use the built in min, just create a &quot;closer&quot; reference before your loop for the same speedup:<p>inline_min = min<p>while expr:<p><pre><code>    if inline_min(blah):</code></pre></div><br/><div id="41195927" class="c"><input type="checkbox" id="c-41195927" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#41195809">parent</a><span>|</span><a href="#41196667">next</a><span>|</span><label class="collapse" for="c-41195927">[-]</label><label class="expand" for="c-41195927">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not how imports work in python at all.<p>Imports are super imperative operations that first tries to find it in sys.modules, otherwise executes the module and puts the resulting dict in sys.modules. Then it grabs the symbols you asked for and shoves all those symbols into the global dict for the module.<p>It does have to walk the locals and the globals scopes (there are ONLY exactly two scopes in Python!) to find the function, that&#x27;s true.</div><br/><div id="41197256" class="c"><input type="checkbox" id="c-41197256" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41195809">root</a><span>|</span><a href="#41195927">parent</a><span>|</span><a href="#41196145">next</a><span>|</span><label class="collapse" for="c-41197256">[-]</label><label class="expand" for="c-41197256">[1 more]</label></div><br/><div class="children"><div class="content">TIL. Apparently `nonlocal` and closures are implemented with copies, at least for my copy of dis.dis().</div><br/></div></div><div id="41196145" class="c"><input type="checkbox" id="c-41196145" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41195809">root</a><span>|</span><a href="#41195927">parent</a><span>|</span><a href="#41197256">prev</a><span>|</span><a href="#41196295">next</a><span>|</span><label class="collapse" for="c-41196145">[-]</label><label class="expand" for="c-41196145">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It does have to walk the locals and the globals scopes<p>right, this is what I meant.</div><br/></div></div><div id="41196295" class="c"><input type="checkbox" id="c-41196295" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41195809">root</a><span>|</span><a href="#41195927">parent</a><span>|</span><a href="#41196145">prev</a><span>|</span><a href="#41196667">next</a><span>|</span><label class="collapse" for="c-41196295">[-]</label><label class="expand" for="c-41196295">[3 more]</label></div><br/><div class="children"><div class="content">Also I imagine the dict lookup for the module is the slow part? So declaring in local scope just removes a dict lookup?<p>I am by no means a python expert :) I just use it occasionally.</div><br/><div id="41197461" class="c"><input type="checkbox" id="c-41197461" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41195809">root</a><span>|</span><a href="#41196295">parent</a><span>|</span><a href="#41196667">next</a><span>|</span><label class="collapse" for="c-41197461">[-]</label><label class="expand" for="c-41197461">[2 more]</label></div><br/><div class="children"><div class="content">15+ years ago many people would tell you that you should do “from foo import bar” instead of “import foo” to save the overhead inherent in referencing “bar” as “foo.bar”. Well, as almost everything in Python is in the end an dict, the dict implementation is ridiculously optimized (and in some counter-intuitive ways), so if you care about that overhead you probably should not be using (C)Python in the first place.<p>This “everything is a dict” is also a part of why removing GIL is not as straightforward as it would seem.</div><br/><div id="41199192" class="c"><input type="checkbox" id="c-41199192" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41195809">root</a><span>|</span><a href="#41197461">parent</a><span>|</span><a href="#41196667">next</a><span>|</span><label class="collapse" for="c-41199192">[-]</label><label class="expand" for="c-41199192">[1 more]</label></div><br/><div class="children"><div class="content">Actually even on a modern CPU that property lookup does add another ~10% penalty. Granted it&#x27;s like a .1 second difference out of a second runtime for 10m iterations, but it&#x27;s measurable! Although I wouldn&#x27;t be using python on those data sizes usually :)</div><br/></div></div></div></div></div></div></div></div><div id="41196667" class="c"><input type="checkbox" id="c-41196667" checked=""/><div class="controls bullet"><span class="by">ipsum2</span><span>|</span><a href="#41195809">parent</a><span>|</span><a href="#41195927">prev</a><span>|</span><label class="collapse" for="c-41196667">[-]</label><label class="expand" for="c-41196667">[4 more]</label></div><br/><div class="children"><div class="content">Benchmark it, it won&#x27;t be any faster.<p>Using the if statement: Execution time: 0.00648 seconds<p>Using the min function directly: Execution time: 0.02298 seconds<p>Using the min function with an intermediate variable: Execution time: 0.02959 seconds</div><br/><div id="41196734" class="c"><input type="checkbox" id="c-41196734" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#41195809">root</a><span>|</span><a href="#41196667">parent</a><span>|</span><a href="#41197136">next</a><span>|</span><label class="collapse" for="c-41196734">[-]</label><label class="expand" for="c-41196734">[1 more]</label></div><br/><div class="children"><div class="content">How about using the `min` builtin directly over the entire list?</div><br/></div></div><div id="41197136" class="c"><input type="checkbox" id="c-41197136" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41195809">root</a><span>|</span><a href="#41196667">parent</a><span>|</span><a href="#41196734">prev</a><span>|</span><label class="collapse" for="c-41197136">[-]</label><label class="expand" for="c-41197136">[2 more]</label></div><br/><div class="children"><div class="content">Sure, let&#x27;s benchmark it :)<p>It is consistently around 8% to 15% faster on 3.10.12 and 3.11 for me. On 3.12.5 (latest) I seem to get the same result.<p><a href="https:&#x2F;&#x2F;www.online-python.com&#x2F;B6AgKW5zod" rel="nofollow">https:&#x2F;&#x2F;www.online-python.com&#x2F;B6AgKW5zod</a><p>(please copy the code to your local to not ddos this site :D)</div><br/><div id="41197445" class="c"><input type="checkbox" id="c-41197445" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#41195809">root</a><span>|</span><a href="#41197136">parent</a><span>|</span><label class="collapse" for="c-41197445">[-]</label><label class="expand" for="c-41197445">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you. It&#x27;s a weird quirk of Python where localization is more efficient.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>