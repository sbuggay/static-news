<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695114058970" as="style"/><link rel="stylesheet" href="styles.css?v=1695114058970"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.the-pans.com/notes-on-the-foundationdb-paper/">How FoundationDB works and why it works (2021)</a> <span class="domain">(<a href="https://blog.the-pans.com">blog.the-pans.com</a>)</span></div><div class="subtext"><span>tim_sw</span> | <span>96 comments</span></div><br/><div><div id="37560005" class="c"><input type="checkbox" id="c-37560005" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#37553957">next</a><span>|</span><label class="collapse" for="c-37560005">[-]</label><label class="expand" for="c-37560005">[3 more]</label></div><br/><div class="children"><div class="content">We have run foundationdb in production for roughly 10 years.  It is solid, mostly trouble free (with one very important exception: you must NEVER allow any node on the cluster to exceed 90% full), robust and insanely fast (10M+ tx&#x2F;sec).  It is convenient, has a nice programming model, and the client includes the ability to inject random failures.<p>That said, I think most coders just can&#x27;t deal with it. For reasons I won&#x27;t go into, I came to fdb already fully aware of the compromises that software transactional memories have, and fdb roughly matches the semantics of those: retry on failure, a maximum transaction size, a maximum transaction time, and so on. For those who haven&#x27;t used it, start here: <a href="https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;developer-guide.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;developer-guide.html</a> ; especially the section on transactions.<p>These constraints _very_ inconvenient for many kinds of applications so, ok, you&#x27;d like a wrapper library that handles them gracefully and hides the details (for example count of range).<p>This seems like it should be easy to do - after all, the expectation is that _application developers_ do it directly - but it isn&#x27;t actually so in practice and introduces a layering violation into the data modeling if you have any part of your application doing direct key access. I recommend people try it.  It can surely be done, but that layer is now as critical as the DB itself, and that has interesting risks.<p>At heart, the problem is, the limits are low enough that normal applications can and do run into them, and they are annoying. It would be really nice if the FDB team would build this next layer themselves with the same degree of testing but they themselves have not, and I think it&#x27;s pretty clear that it turns out a small-transaction KV store is not enough to build complex layers in actuality.<p>Emphasis on the tested part - it&#x27;s all well and good for fdb to be rock solid, but what needs to be there is that the actual interfact used by 90% of applications is rock solid, and if you exceed basic small-size keys or time, that isn&#x27;t really true.</div><br/><div id="37567077" class="c"><input type="checkbox" id="c-37567077" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#37560005">parent</a><span>|</span><a href="#37565499">next</a><span>|</span><label class="collapse" for="c-37567077">[-]</label><label class="expand" for="c-37567077">[1 more]</label></div><br/><div class="children"><div class="content">Not to take away from your main point, and I appreciate it, but I am interested in one minor you made which is - you wrote, &quot;and insanely fast (10M+ tx&#x2F;sec)&quot;; When you say that, what does it mean, what&#x27;s the context? Is it for the cluster, is it for one machine (what kind of cluster and networking, which machines, what machine), size of transactions, is there acknowledge after each, are they truly transactional or batch in one go..</div><br/></div></div><div id="37565499" class="c"><input type="checkbox" id="c-37565499" checked=""/><div class="controls bullet"><span class="by">Dave_Rosenthal</span><span>|</span><a href="#37560005">parent</a><span>|</span><a href="#37567077">prev</a><span>|</span><a href="#37553957">next</a><span>|</span><label class="collapse" for="c-37565499">[-]</label><label class="expand" for="c-37565499">[1 more]</label></div><br/><div class="children"><div class="content">I think that’s a good and really fair summary.<p>- If you’re a developer wanting to build an application, you should really use a well designed layer between yourself and FDB. A few are out there.<p>- If you’re a dev thinking you want to build a database from scratch you probably should just use FDB as the storage engine and work on the other parts. To start, at very least!<p>(One last thing that I think is a bit overlooked with FDB is how easy it is to build basically any data structure you can in memory in FDB instead. Not that it solves the transaction timeout stuff, etc. but if you want to build skip list, or a quad tree, or a vector store, or whatever else, you can quite easily use FDB to build a durable, distributed, transactional, multi-user version of the same. You don’t have to stick to just boring tables.)</div><br/></div></div></div></div><div id="37553957" class="c"><input type="checkbox" id="c-37553957" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#37560005">prev</a><span>|</span><a href="#37556876">next</a><span>|</span><label class="collapse" for="c-37553957">[-]</label><label class="expand" for="c-37553957">[2 more]</label></div><br/><div class="children"><div class="content">An obvious question you face when deploying something like FDB is how to write your app on top of it. With FDB it&#x27;s like RocksDB. You get a transactional key&#x2F;value store, but that&#x27;s a very low level interface for apps to work with.<p>FDB provides &quot;layers&quot;, such as the Record layer. It helps map data to keys and values. But a more sophisticated solution that I sometimes wish would take off is this library:<p><a href="https:&#x2F;&#x2F;permazen.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;permazen.io&#x2F;</a><p>It&#x27;s a small(ish) open source project that implements an ORM-like API but significantly cleaned up, and it can run on any K&#x2F;V backend. There&#x27;s an FDB plugin for it, so you can connect your app directly to an FDB cluster using it. And with that you get built-in indexing, derived data, triggers, you can do queries using the Java collections API, there&#x27;s a CLI, there&#x27;s an API for making GUIs and everything else you might need for a business CRUD app. It&#x27;s got a paper of its own and is quite impressive.<p>There are a few big gaps vs an RDBMS though:<p>1. There&#x27;s no query planner. You write your own plans by using functional maps&#x2F;filters&#x2F;folds etc in regular Java (or Kotlin or Python or any other language that can run on the JVM).<p>2. It&#x27;s weak on analytics, because there&#x27;s no access control and the ad-hoc query language is less convenient than SQL.<p>3. There&#x27;s no network protocol other than FDB itself, which assumes low latency networks. So if there&#x27;s a big distance between the user generating the queries and the servers, you have a problem and will need to introduce an app specific protocol (or move the code).</div><br/><div id="37560925" class="c"><input type="checkbox" id="c-37560925" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37553957">parent</a><span>|</span><a href="#37556876">next</a><span>|</span><label class="collapse" for="c-37560925">[-]</label><label class="expand" for="c-37560925">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;permazen.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;permazen.io&#x2F;</a> hasn&#x27;t appeared on HN before*. If you&#x27;d be willing to post it and then email hn@ycombinator.com a heads-up, we&#x27;ll put the submission in the second-chance pool (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;pool">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;pool</a>, explained at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26998308">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26998308</a>), so it will get a random placement on HN&#x27;s front page.<p>* and the only previous related submission appears to be <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21646037">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21646037</a>.</div><br/></div></div></div></div><div id="37556876" class="c"><input type="checkbox" id="c-37556876" checked=""/><div class="controls bullet"><span class="by">zinodaur</span><span>|</span><a href="#37553957">prev</a><span>|</span><a href="#37559940">next</a><span>|</span><label class="collapse" for="c-37556876">[-]</label><label class="expand" for="c-37556876">[5 more]</label></div><br/><div class="children"><div class="content">If theres just one Sequencer, and every ReadVersion request to the Proxy eventually hits the Sequencer 1-1, how does the Sequencer not get crushed? Or is a scaling limit just &quot;the number of ReadVersion requests a Sequencer machine can handle per second&quot;, which admittedly is a cheap request to respond to</div><br/><div id="37564740" class="c"><input type="checkbox" id="c-37564740" checked=""/><div class="controls bullet"><span class="by">richieartoul</span><span>|</span><a href="#37556876">parent</a><span>|</span><a href="#37564041">next</a><span>|</span><label class="collapse" for="c-37564740">[-]</label><label class="expand" for="c-37564740">[1 more]</label></div><br/><div class="children"><div class="content">Requests to the sequencer are batched heavily. If the sequencer fails, the cluster goes through a recovery and will be unavailable for 2-3 seconds and then recover.</div><br/></div></div><div id="37564041" class="c"><input type="checkbox" id="c-37564041" checked=""/><div class="controls bullet"><span class="by">lowbloodsugar</span><span>|</span><a href="#37556876">parent</a><span>|</span><a href="#37564740">prev</a><span>|</span><a href="#37559940">next</a><span>|</span><label class="collapse" for="c-37564041">[-]</label><label class="expand" for="c-37564041">[3 more]</label></div><br/><div class="children"><div class="content">Yeah that seems like an untenable design choice. Was quite interested until I read that. Max TPS? and MTTR when sequence inevitably shits itself?</div><br/><div id="37565002" class="c"><input type="checkbox" id="c-37565002" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#37556876">root</a><span>|</span><a href="#37564041">parent</a><span>|</span><a href="#37564746">next</a><span>|</span><label class="collapse" for="c-37565002">[-]</label><label class="expand" for="c-37565002">[1 more]</label></div><br/><div class="children"><div class="content">You can trivially scale fdb to tens of millions of tx&#x2F;sec for write-heavy workloads without a hardcore cluster for transactions of reasonable complexity (though with careful design on my part and the part of others for collisions to be unlikely).<p>MTTR on failure is seconds. Really, there&#x27;s no system I&#x27;ve used that is as robust and performant as fdb and I include s3 in that list - s3, for example,  _routinely_ has operations with orders of magnitude latency variance and huge, correlated spikes.</div><br/></div></div><div id="37564746" class="c"><input type="checkbox" id="c-37564746" checked=""/><div class="controls bullet"><span class="by">richieartoul</span><span>|</span><a href="#37556876">root</a><span>|</span><a href="#37564041">parent</a><span>|</span><a href="#37565002">prev</a><span>|</span><a href="#37559940">next</a><span>|</span><label class="collapse" for="c-37564746">[-]</label><label class="expand" for="c-37564746">[1 more]</label></div><br/><div class="children"><div class="content">Replied above</div><br/></div></div></div></div></div></div><div id="37559940" class="c"><input type="checkbox" id="c-37559940" checked=""/><div class="controls bullet"><span class="by">pi-r-p</span><span>|</span><a href="#37556876">prev</a><span>|</span><a href="#37554137">next</a><span>|</span><label class="collapse" for="c-37559940">[-]</label><label class="expand" for="c-37559940">[1 more]</label></div><br/><div class="children"><div class="content">In my company, we tested FDB for two years, then we wrote a new backend for Warp 10 timeseries database... Performances are really impressive, we dropped HBase backend when we released Warp 10 3.0.
Note we can isolate customers easily on the same FDB cluster (tenants are not explained anywhere on internet, it is a quite recent FDB feature).<p>more info: <a href="https:&#x2F;&#x2F;blog.senx.io&#x2F;introducing-warp-10-3-0&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.senx.io&#x2F;introducing-warp-10-3-0&#x2F;</a></div><br/></div></div><div id="37554137" class="c"><input type="checkbox" id="c-37554137" checked=""/><div class="controls bullet"><span class="by">mcsoft</span><span>|</span><a href="#37559940">prev</a><span>|</span><a href="#37552704">next</a><span>|</span><label class="collapse" for="c-37554137">[-]</label><label class="expand" for="c-37554137">[7 more]</label></div><br/><div class="children"><div class="content">We have seriously looked at FoundationDB to replace our SQL-based storage for distributed writes. We decided not to proceed unless we are about to overgrow the existing deploy, a standard leader-follower setup on the off-the-shelf hardware. The limiting factor for the latter would be a number of NMVMe drives we could put into a single machine. It gives us couple dozen Tb of structured data (we don&#x27;t store blobs in the database) before we have to worry.<p>fdb is best when your workload is pretty well-defined and will stay such for a decade or so. It is not usually the case for new products which evolve fast. Two most famous installations of fdb are iTunes and Snowflake metadata. When you rewrite petabyte-size database in fdb, you transform continuous SRE&#x2F;devops opex costs into developers capex investment. It comes with reduced risks for occasional data loss. For me it&#x27;s mostly a financial decision, not really a technical one.</div><br/><div id="37555241" class="c"><input type="checkbox" id="c-37555241" checked=""/><div class="controls bullet"><span class="by">Jgrubb</span><span>|</span><a href="#37554137">parent</a><span>|</span><a href="#37555491">next</a><span>|</span><label class="collapse" for="c-37555241">[-]</label><label class="expand" for="c-37555241">[3 more]</label></div><br/><div class="children"><div class="content">&gt; transform continuous SRE&#x2F;devops opex costs into developers capex investment<p>Would you mind expanding&#x2F;educating me on this point?  When I think of capex I think of “purchasing a thing that’s depreciated over a time window”.  If you’d said “transform SRE&#x2F;COGS costs into developer&#x2F;R&amp;D&#x2F;opex costs” I would’ve understood, but eventually the thing leaves development and goes back into COGS.</div><br/><div id="37565011" class="c"><input type="checkbox" id="c-37565011" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#37554137">root</a><span>|</span><a href="#37555241">parent</a><span>|</span><a href="#37559434">next</a><span>|</span><label class="collapse" for="c-37565011">[-]</label><label class="expand" for="c-37565011">[1 more]</label></div><br/><div class="children"><div class="content">Basically the SREs don&#x27;t have anything to do with fdb for the most part. You add a node, quiesce a node, delete a node. Otherwise it&#x27;s self-balancing and trouble-free from an SRE pov.<p>See my other message for the developer issues, though. IMHO fdb as it is today is too hard for most developers if their use case is anything beyond redis simple keys.</div><br/></div></div><div id="37559434" class="c"><input type="checkbox" id="c-37559434" checked=""/><div class="controls bullet"><span class="by">mcsoft</span><span>|</span><a href="#37554137">root</a><span>|</span><a href="#37555241">parent</a><span>|</span><a href="#37565011">prev</a><span>|</span><a href="#37555491">next</a><span>|</span><label class="collapse" for="c-37559434">[-]</label><label class="expand" for="c-37559434">[1 more]</label></div><br/><div class="children"><div class="content">I assume a couple of things here: 1) that SRE costs would be lower with fdb at scale due to its handling outages, i.e. auto-resharding; and 2) that a migration project from *sql to fdb will be finite (hence an investment I hastily called capex).<p>Would love to hear from anyone with experience in fdb whether these assumptions hold.</div><br/></div></div></div></div><div id="37555491" class="c"><input type="checkbox" id="c-37555491" checked=""/><div class="controls bullet"><span class="by">endisneigh</span><span>|</span><a href="#37554137">parent</a><span>|</span><a href="#37555241">prev</a><span>|</span><a href="#37559780">next</a><span>|</span><label class="collapse" for="c-37555491">[-]</label><label class="expand" for="c-37555491">[2 more]</label></div><br/><div class="children"><div class="content">Were you planning on using the Record or Document layer if you went with it? Or maybe making your own layer?</div><br/><div id="37559509" class="c"><input type="checkbox" id="c-37559509" checked=""/><div class="controls bullet"><span class="by">mcsoft</span><span>|</span><a href="#37554137">root</a><span>|</span><a href="#37555491">parent</a><span>|</span><a href="#37559780">next</a><span>|</span><label class="collapse" for="c-37559509">[-]</label><label class="expand" for="c-37559509">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;d use the Record layer, but it was Java-only then. It would require us either to rewrite parts of our backend to Java or to implement some wrappers.</div><br/></div></div></div></div></div></div><div id="37552704" class="c"><input type="checkbox" id="c-37552704" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#37554137">prev</a><span>|</span><a href="#37564159">next</a><span>|</span><label class="collapse" for="c-37552704">[-]</label><label class="expand" for="c-37552704">[15 more]</label></div><br/><div class="children"><div class="content">Great article.<p>Demystified a lot about FDB for me.<p>&gt; <i>”Summary: FDB is probably the best k&#x2F;v store for regional deployment out there.”</i><p>Why should someone use Memcache or Redis then?<p>Is it for the data types in Redis?</div><br/><div id="37552831" class="c"><input type="checkbox" id="c-37552831" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#37552704">parent</a><span>|</span><a href="#37553307">next</a><span>|</span><label class="collapse" for="c-37552831">[-]</label><label class="expand" for="c-37552831">[9 more]</label></div><br/><div class="children"><div class="content">Because memcache and redis are in-memory. Writing to fdb will be complete once it is fsync&#x27;ed to disk.<p>Memcache is a cache. Fdb is a an ordered kv store.</div><br/><div id="37552928" class="c"><input type="checkbox" id="c-37552928" checked=""/><div class="controls bullet"><span class="by">unmole</span><span>|</span><a href="#37552704">root</a><span>|</span><a href="#37552831">parent</a><span>|</span><a href="#37552905">next</a><span>|</span><label class="collapse" for="c-37552928">[-]</label><label class="expand" for="c-37552928">[4 more]</label></div><br/><div class="children"><div class="content">Redis can be configured to persist and fsync every operation.</div><br/><div id="37553358" class="c"><input type="checkbox" id="c-37553358" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#37552704">root</a><span>|</span><a href="#37552928">parent</a><span>|</span><a href="#37552905">next</a><span>|</span><label class="collapse" for="c-37553358">[-]</label><label class="expand" for="c-37553358">[3 more]</label></div><br/><div class="children"><div class="content">Redis is not meant as a primary database and should not be used as such. FoundationDB is meant as a reliable source of truth.</div><br/><div id="37555283" class="c"><input type="checkbox" id="c-37555283" checked=""/><div class="controls bullet"><span class="by">Already__Taken</span><span>|</span><a href="#37552704">root</a><span>|</span><a href="#37553358">parent</a><span>|</span><a href="#37552905">next</a><span>|</span><label class="collapse" for="c-37555283">[-]</label><label class="expand" for="c-37555283">[2 more]</label></div><br/><div class="children"><div class="content">Redis began as a caching database, but it has since evolved into a primary database. Many applications built today use Redis as a primary database.<p><a href="https:&#x2F;&#x2F;redis.com&#x2F;blog&#x2F;redis-cache-vs-redis-primary-database-in-90-seconds&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;redis.com&#x2F;blog&#x2F;redis-cache-vs-redis-primary-database...</a><p>Very much seems like an acceptable use now</div><br/><div id="37563703" class="c"><input type="checkbox" id="c-37563703" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37552704">root</a><span>|</span><a href="#37555283">parent</a><span>|</span><a href="#37552905">next</a><span>|</span><label class="collapse" for="c-37563703">[-]</label><label class="expand" for="c-37563703">[1 more]</label></div><br/><div class="children"><div class="content">Redis can&#x27;t have a working set larger than memory. It has no mechanism to page data to disk. If your data set grows too large, you&#x27;re hosed unless you add more hardware.</div><br/></div></div></div></div></div></div></div></div><div id="37552905" class="c"><input type="checkbox" id="c-37552905" checked=""/><div class="controls bullet"><span class="by">abhishekjha</span><span>|</span><a href="#37552704">root</a><span>|</span><a href="#37552831">parent</a><span>|</span><a href="#37552928">prev</a><span>|</span><a href="#37553307">next</a><span>|</span><label class="collapse" for="c-37552905">[-]</label><label class="expand" for="c-37552905">[4 more]</label></div><br/><div class="children"><div class="content">You can configure redis to flush to disk on write operations though you lose on performance.</div><br/><div id="37553090" class="c"><input type="checkbox" id="c-37553090" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#37552704">root</a><span>|</span><a href="#37552905">parent</a><span>|</span><a href="#37553307">next</a><span>|</span><label class="collapse" for="c-37553090">[-]</label><label class="expand" for="c-37553090">[3 more]</label></div><br/><div class="children"><div class="content">That is not comparable to writes completing after they are flushed to disk.</div><br/><div id="37553268" class="c"><input type="checkbox" id="c-37553268" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#37552704">root</a><span>|</span><a href="#37553090">parent</a><span>|</span><a href="#37553307">next</a><span>|</span><label class="collapse" for="c-37553268">[-]</label><label class="expand" for="c-37553268">[2 more]</label></div><br/><div class="children"><div class="content">&gt;appendfsync always: fsync every time new commands are appended to the AOF. Very very slow, very safe. Note that the commands are appended to the AOF after a batch of commands from multiple clients or a pipeline are executed, so it means a single write and a single fsync (before sending the replies).<p><a href="https:&#x2F;&#x2F;redis.io&#x2F;docs&#x2F;management&#x2F;persistence&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;redis.io&#x2F;docs&#x2F;management&#x2F;persistence&#x2F;</a><p>It&#x27;s very slow, but if you really want to wait for fsync before replying, it can do that.</div><br/><div id="37553394" class="c"><input type="checkbox" id="c-37553394" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#37552704">root</a><span>|</span><a href="#37553268">parent</a><span>|</span><a href="#37553307">next</a><span>|</span><label class="collapse" for="c-37553394">[-]</label><label class="expand" for="c-37553394">[1 more]</label></div><br/><div class="children"><div class="content">I was unaware they could make that guarantee.<p>Thanks for the correction.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37553307" class="c"><input type="checkbox" id="c-37553307" checked=""/><div class="controls bullet"><span class="by">rullopat</span><span>|</span><a href="#37552704">parent</a><span>|</span><a href="#37552831">prev</a><span>|</span><a href="#37553196">next</a><span>|</span><label class="collapse" for="c-37553307">[-]</label><label class="expand" for="c-37553307">[1 more]</label></div><br/><div class="children"><div class="content">FDB is more a framework to create your own distributed database creating what they call a &quot;layer&quot;.<p><a href="https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;layer-concept.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;layer-concept.html</a></div><br/></div></div><div id="37553196" class="c"><input type="checkbox" id="c-37553196" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#37552704">parent</a><span>|</span><a href="#37553307">prev</a><span>|</span><a href="#37552782">next</a><span>|</span><label class="collapse" for="c-37553196">[-]</label><label class="expand" for="c-37553196">[1 more]</label></div><br/><div class="children"><div class="content">Things like Redis and Memcache are not serious data stores. Don&#x27;t put any data in them that you really need back out later.</div><br/></div></div><div id="37552782" class="c"><input type="checkbox" id="c-37552782" checked=""/><div class="controls bullet"><span class="by">c0balt</span><span>|</span><a href="#37552704">parent</a><span>|</span><a href="#37553196">prev</a><span>|</span><a href="#37552828">next</a><span>|</span><label class="collapse" for="c-37552782">[-]</label><label class="expand" for="c-37552782">[1 more]</label></div><br/><div class="children"><div class="content">Redis has a few features outside of k&#x2F;v, like a good pub-sub implementation, that make it very useful in addition to a good DX and mature libraries.<p>Memcache on the other habd is just solid and mature. It also has some inertia as being a solid k&#x2F;v cache. For example: NextCloud supports afaik both Redis and Memcache as caching engines but doesn&#x27;t have FDB support.</div><br/></div></div><div id="37553846" class="c"><input type="checkbox" id="c-37553846" checked=""/><div class="controls bullet"><span class="by">leentee</span><span>|</span><a href="#37552704">parent</a><span>|</span><a href="#37552828">prev</a><span>|</span><a href="#37564159">next</a><span>|</span><label class="collapse" for="c-37553846">[-]</label><label class="expand" for="c-37553846">[1 more]</label></div><br/><div class="children"><div class="content">I believe the author means &quot;the best transactional k&#x2F;v store&quot;</div><br/></div></div></div></div><div id="37564159" class="c"><input type="checkbox" id="c-37564159" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#37552704">prev</a><span>|</span><a href="#37553539">next</a><span>|</span><label class="collapse" for="c-37564159">[-]</label><label class="expand" for="c-37564159">[3 more]</label></div><br/><div class="children"><div class="content">FDB uses SQLite to store data, but FDB doesn’t expose SQL to the end user.<p><a href="https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;architecture.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;architecture.html</a></div><br/><div id="37565388" class="c"><input type="checkbox" id="c-37565388" checked=""/><div class="controls bullet"><span class="by">Dave_Rosenthal</span><span>|</span><a href="#37564159">parent</a><span>|</span><a href="#37564750">next</a><span>|</span><label class="collapse" for="c-37565388">[-]</label><label class="expand" for="c-37565388">[1 more]</label></div><br/><div class="children"><div class="content">That’s true, but FDB doesn’t use very much of SQLite, just a modified version of SQLite’s internal b-tree.</div><br/></div></div><div id="37564750" class="c"><input type="checkbox" id="c-37564750" checked=""/><div class="controls bullet"><span class="by">richieartoul</span><span>|</span><a href="#37564159">parent</a><span>|</span><a href="#37565388">prev</a><span>|</span><a href="#37553539">next</a><span>|</span><label class="collapse" for="c-37564750">[-]</label><label class="expand" for="c-37564750">[1 more]</label></div><br/><div class="children"><div class="content">Newer versions are moving towards a custom btree storage engine called Redwood</div><br/></div></div></div></div><div id="37553539" class="c"><input type="checkbox" id="c-37553539" checked=""/><div class="controls bullet"><span class="by">angio</span><span>|</span><a href="#37564159">prev</a><span>|</span><a href="#37565451">next</a><span>|</span><label class="collapse" for="c-37553539">[-]</label><label class="expand" for="c-37553539">[3 more]</label></div><br/><div class="children"><div class="content">How do people deploy FDB to the cloud? Is it possible to deploy it without EBS to take advantage of cheaper VM temporary storage?</div><br/><div id="37562965" class="c"><input type="checkbox" id="c-37562965" checked=""/><div class="controls bullet"><span class="by">dialogbox</span><span>|</span><a href="#37553539">parent</a><span>|</span><a href="#37556141">next</a><span>|</span><label class="collapse" for="c-37562965">[-]</label><label class="expand" for="c-37562965">[1 more]</label></div><br/><div class="children"><div class="content">I won’t do that for production. Regional failure is not impossible although it is rare. You will lose all of your data.</div><br/></div></div><div id="37556141" class="c"><input type="checkbox" id="c-37556141" checked=""/><div class="controls bullet"><span class="by">manishsharan</span><span>|</span><a href="#37553539">parent</a><span>|</span><a href="#37562965">prev</a><span>|</span><a href="#37565451">next</a><span>|</span><label class="collapse" for="c-37556141">[-]</label><label class="expand" for="c-37556141">[1 more]</label></div><br/><div class="children"><div class="content">Yes I would think so. FDB is distributed by default and the cluster is very easy to setup. As long as you have sufficient number of VMs in a cluster, the loss of a single vm or disk will not matter as you can spin up a new VM to join the cluster. On AWS, you can set up members of the cluster in different availability zones in the same region .. so the outage of on zone will not impact your database.<p>I am running this set up in my dev (personal) environment on AWS.</div><br/></div></div></div></div><div id="37565451" class="c"><input type="checkbox" id="c-37565451" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#37553539">prev</a><span>|</span><a href="#37553905">next</a><span>|</span><label class="collapse" for="c-37565451">[-]</label><label class="expand" for="c-37565451">[2 more]</label></div><br/><div class="children"><div class="content">The Sequencer:<p>- does not have a persistent&#x2F;disk-backed state<p>- It is a singleton process<p>- it and only it does order, no logs do ordering<p>... if the singleton sequencer crashes, I do not see on this high level description how the system recovers, if the sequencer is the only one that knows write order but has no persistent write &quot;log&quot;.<p>What am I missing?<p>This... does not appear to be something you run outside of a dedicated datacenter, AWS with its awful networking and slow&#x2F;silently throttling storage would probably muck this thing up under any substantive scale?</div><br/><div id="37565909" class="c"><input type="checkbox" id="c-37565909" checked=""/><div class="controls bullet"><span class="by">richieartoul</span><span>|</span><a href="#37565451">parent</a><span>|</span><a href="#37553905">next</a><span>|</span><label class="collapse" for="c-37565909">[-]</label><label class="expand" for="c-37565909">[1 more]</label></div><br/><div class="children"><div class="content">It runs fine in AWS, Snowflake and many others run it there. The most recent FoundationDB paper goes into a lot more detail on their recovery protocol, it’s a lot more nuanced than you think, but it works extremely well</div><br/></div></div></div></div><div id="37553905" class="c"><input type="checkbox" id="c-37553905" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#37565451">prev</a><span>|</span><a href="#37553463">next</a><span>|</span><label class="collapse" for="c-37553905">[-]</label><label class="expand" for="c-37553905">[2 more]</label></div><br/><div class="children"><div class="content">Queues<p>Is it correct to assume FDB is the perfect framework for creating a queue?</div><br/><div id="37554199" class="c"><input type="checkbox" id="c-37554199" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#37553905">parent</a><span>|</span><a href="#37553463">next</a><span>|</span><label class="collapse" for="c-37554199">[-]</label><label class="expand" for="c-37554199">[1 more]</label></div><br/><div class="children"><div class="content">With FDB latency shoots up when a bunch of writers compete to update the same entry, because writers can have to retry many times before the write finally goes through, with a network round-trip each time. Personally I found this much harder to work with than a postgres queue with SKIP LOCKED for example.<p>There&#x27;s this however: &quot;QuiCK: A Queuing System in CloudKit&quot;: <a href="https:&#x2F;&#x2F;www.foundationdb.org&#x2F;files&#x2F;QuiCK.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.foundationdb.org&#x2F;files&#x2F;QuiCK.pdf</a>. I suspect it really depends on what you expect from a queue, e.g. if you need strict FIFO or priorities, and how much effort you&#x27;re willing to invest.</div><br/></div></div></div></div><div id="37553463" class="c"><input type="checkbox" id="c-37553463" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37553905">prev</a><span>|</span><a href="#37553076">next</a><span>|</span><label class="collapse" for="c-37553463">[-]</label><label class="expand" for="c-37553463">[15 more]</label></div><br/><div class="children"><div class="content">&quot;FDB can tolerate f failures with only f+1 replicas.&quot;<p>Wait a minute, I know that formula... Viewstamped Replication?? I need to read the foundation DB paper. (I mainly read CRDT stuff so hopefully it&#x27;s understandable).<p>---<p>In general I&#x27;m really impressed foundation DB folks.<p>The talk &quot;Testing Distributed Systems w&#x2F; Deterministic Simulation&quot; by Will Wilson blew my mind. TL;DR they spent the majority of their initial dev effort into making a simulation of the database, then when they were happy with that plugged in real storage, time and networks at the end. Well worth a watch for anyone interested in distributed systems &amp; reliability.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4fFDFbi3toc&amp;pp=ygUgZGV0ZXJtaW5pc3RpYyBzaW11bGF0aW9uIHRlc3Rpbmc%3D">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4fFDFbi3toc&amp;pp=ygUgZGV0ZXJta...</a></div><br/><div id="37553524" class="c"><input type="checkbox" id="c-37553524" checked=""/><div class="controls bullet"><span class="by">ergl</span><span>|</span><a href="#37553463">parent</a><span>|</span><a href="#37553958">next</a><span>|</span><label class="collapse" for="c-37553524">[-]</label><label class="expand" for="c-37553524">[10 more]</label></div><br/><div class="children"><div class="content">&quot;f failures with f+1 replicas&quot; is the standard for all non-byzantine fault tolerant systems out there. You will find it in Paxos, Raft, Viewstamped Replication, etc.<p>It makes sense if you think about it: these systems follow a leader&#x2F;replica model, and naturally you only need one leader to make progress</div><br/><div id="37560124" class="c"><input type="checkbox" id="c-37560124" checked=""/><div class="controls bullet"><span class="by">ergl</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553524">parent</a><span>|</span><a href="#37553572">next</a><span>|</span><label class="collapse" for="c-37560124">[-]</label><label class="expand" for="c-37560124">[1 more]</label></div><br/><div class="children"><div class="content">Amending my own parent comment, since it won&#x27;t let me edit: I was wrong about this being standard in Paxos&#x2F;Raft etc. They actually require &quot;f failures with 2f+1 replicas&quot; (meaning that at a minimum a strict majority of replicas need to be available). I blame my morning brain.</div><br/></div></div><div id="37553572" class="c"><input type="checkbox" id="c-37553572" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553524">parent</a><span>|</span><a href="#37560124">prev</a><span>|</span><a href="#37554038">next</a><span>|</span><label class="collapse" for="c-37553572">[-]</label><label class="expand" for="c-37553572">[4 more]</label></div><br/><div class="children"><div class="content">Replica is ambiguous here: is it 1 leader and n replicas? Or is it just n replicas, one of which is assigned &quot;leader&quot;?<p>I thought &quot;these systems follow a leader&#x2F;replica model&quot; would be the former, but &quot;f failures with f+1 replicas&quot; the latter.</div><br/><div id="37553654" class="c"><input type="checkbox" id="c-37553654" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553572">parent</a><span>|</span><a href="#37553996">next</a><span>|</span><label class="collapse" for="c-37553654">[-]</label><label class="expand" for="c-37553654">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a cluster size of n replicas, with one of the n being the (current) leader.<p><i>f failures with f+1 replicas</i> is a cluster size of n replicas can sustain n-1 failures. n=f+1 or f=n-1. You wanna be able to sustain f failures, you need a cluster size (n) of f+1.<p>When there is a failure, a non-failing node becomes the leader (or there&#x27;s no leader change if the current leader isn&#x27;t the one that failed).  A cluster size of 1 has 1 leader, and can sustain 0 failures.</div><br/><div id="37553745" class="c"><input type="checkbox" id="c-37553745" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553654">parent</a><span>|</span><a href="#37553996">next</a><span>|</span><label class="collapse" for="c-37553745">[-]</label><label class="expand" for="c-37553745">[1 more]</label></div><br/><div class="children"><div class="content">Yep makes sense - &quot;f failures with f+1 replicas&quot; does indeed refer to the latter definition. Thanks!</div><br/></div></div></div></div><div id="37553996" class="c"><input type="checkbox" id="c-37553996" checked=""/><div class="controls bullet"><span class="by">octacat</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553572">parent</a><span>|</span><a href="#37553654">prev</a><span>|</span><a href="#37554038">next</a><span>|</span><label class="collapse" for="c-37553996">[-]</label><label class="expand" for="c-37553996">[1 more]</label></div><br/><div class="children"><div class="content">It is same for all CP systems in terms of CAP.
During partition, clients that have access to the leader, could read&#x2F;write.
Clients that have access to non-leader servers could only read consistent data to the point when non-leader lost connection to the leader (i.e. old data, but still consistent).</div><br/></div></div></div></div><div id="37554038" class="c"><input type="checkbox" id="c-37554038" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553524">parent</a><span>|</span><a href="#37553572">prev</a><span>|</span><a href="#37553618">next</a><span>|</span><label class="collapse" for="c-37554038">[-]</label><label class="expand" for="c-37554038">[3 more]</label></div><br/><div class="children"><div class="content">Raft (at least) goes offline if more than half the replicas are gone, doesn&#x27;t it? It won&#x27;t accept writes, and it won&#x27;t serve reads unless you&#x27;ve explicitly chosen to serve stale reads.</div><br/><div id="37554897" class="c"><input type="checkbox" id="c-37554897" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37554038">parent</a><span>|</span><a href="#37560057">next</a><span>|</span><label class="collapse" for="c-37554897">[-]</label><label class="expand" for="c-37554897">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a beheviour of quorum systems - majority voting.  It guarantees no inconsistent writes in the event of a network partition, where each half of the replicas are workig fine and can talk to each other, but are getting no response from the other half.<p>But if you can reliably confirm that all but one nodes have &quot;failed&quot;, for a suitably robust definition of failed, that&#x27;s a different scenario.  This means even though you can&#x27;t communicate with a failed node in the normal way, you are able to get confirmation that the node cannot respond to normal messages to <i>any other</i> nodes or clients, and something (maybe controlling the node, or software on the node itself) guarantees to prevent those responses, until the node goes through a recovery and reintegration process.<p>Some ways this is done are using remote-controlled power, remote-controlled reboot, or reconfiguring the network switches to cut off the node.  Just to ensure it can&#x27;t come back and carry on responding as if nothing happened except a temporary delay.  There&#x27;s some subtlety to doing this robustly: Consider a response packet that got onto the network before the cut off event, but is delayed a long time inside the network due to a queue or fault.<p>After reliable &quot;failure&quot; confirmation, you can shrink the quorum size dynamically in response, even down to a single node, and then resume forward progress.</div><br/></div></div><div id="37560057" class="c"><input type="checkbox" id="c-37560057" checked=""/><div class="controls bullet"><span class="by">ergl</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37554038">parent</a><span>|</span><a href="#37554897">prev</a><span>|</span><a href="#37553618">next</a><span>|</span><label class="collapse" for="c-37560057">[-]</label><label class="expand" for="c-37560057">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, I misspoke in my original comment. See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37560124">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37560124</a><p>What usually happens is that a leader won&#x27;t confirm an operation as successful until such operation has been applied in a quorum of replicas (see: synchronous replication).<p>In theory, nothing prevents a leader from accepting new writes even if it can&#x27;t reach a quorum, provided it never allows reading operations that haven&#x27;t been replicated to a number of replicas.</div><br/></div></div></div></div><div id="37553618" class="c"><input type="checkbox" id="c-37553618" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553524">parent</a><span>|</span><a href="#37554038">prev</a><span>|</span><a href="#37553958">next</a><span>|</span><label class="collapse" for="c-37553618">[-]</label><label class="expand" for="c-37553618">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for putting it in context! VSR is the only one I&#x27;ve read into by virtue of it having a really readable paper.</div><br/></div></div></div></div><div id="37553958" class="c"><input type="checkbox" id="c-37553958" checked=""/><div class="controls bullet"><span class="by">octacat</span><span>|</span><a href="#37553463">parent</a><span>|</span><a href="#37553524">prev</a><span>|</span><a href="#37553076">next</a><span>|</span><label class="collapse" for="c-37553958">[-]</label><label class="expand" for="c-37553958">[4 more]</label></div><br/><div class="children"><div class="content">&quot;FDB can tolerate f failures with only f+1 replicas.&quot; is too vague. What kind of failures and in which situations?<p>If &quot;failure&quot; is a netsplit, only single partition would allow writes, because they choose CP from CAP theorem.</div><br/><div id="37553983" class="c"><input type="checkbox" id="c-37553983" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553958">parent</a><span>|</span><a href="#37553076">next</a><span>|</span><label class="collapse" for="c-37553983">[-]</label><label class="expand" for="c-37553983">[3 more]</label></div><br/><div class="children"><div class="content">Oh man I&#x27;ve just had a (friendly!) debate on this with some distsys folks on twitter.<p>General consensus (no pun intended!) is the term availability is not really well defined, and the CAP thoerem is not a useful way to think about things (see Martin Kleppmanns &quot;the unhelpful CAP theorem&quot; in DDIA).</div><br/><div id="37565577" class="c"><input type="checkbox" id="c-37565577" checked=""/><div class="controls bullet"><span class="by">Dave_Rosenthal</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553983">parent</a><span>|</span><a href="#37554024">next</a><span>|</span><label class="collapse" for="c-37565577">[-]</label><label class="expand" for="c-37565577">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that the term available is overloaded. In CAP “(A)vailable” specifically means you can keep making db updates as long as you can talk to any db node (e.g. you and a db node have split off the internet together). In every other distributed systems context “available” means the system doesn’t stop working overall when failures happen. These are very different usages and it confuses a lot of people.</div><br/></div></div><div id="37554024" class="c"><input type="checkbox" id="c-37554024" checked=""/><div class="controls bullet"><span class="by">octacat</span><span>|</span><a href="#37553463">root</a><span>|</span><a href="#37553983">parent</a><span>|</span><a href="#37565577">prev</a><span>|</span><a href="#37553076">next</a><span>|</span><label class="collapse" for="c-37554024">[-]</label><label class="expand" for="c-37554024">[1 more]</label></div><br/><div class="children"><div class="content">Available = you can see one of replicas, you are good to go.
CAP is good to understand what are the limitations when you have partitioned network.<p>FoundationDB does not give you Availabity though, only CP.</div><br/></div></div></div></div></div></div></div></div><div id="37553076" class="c"><input type="checkbox" id="c-37553076" checked=""/><div class="controls bullet"><span class="by">jingles_dev</span><span>|</span><a href="#37553463">prev</a><span>|</span><a href="#37553074">next</a><span>|</span><label class="collapse" for="c-37553076">[-]</label><label class="expand" for="c-37553076">[4 more]</label></div><br/><div class="children"><div class="content">when do we choose FDB over Redis and vice versa?</div><br/><div id="37553403" class="c"><input type="checkbox" id="c-37553403" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#37553076">parent</a><span>|</span><a href="#37553907">next</a><span>|</span><label class="collapse" for="c-37553403">[-]</label><label class="expand" for="c-37553403">[1 more]</label></div><br/><div class="children"><div class="content">FDB is for permanent data storage, Redis is for temporary data. It does not matter that you can configure Redis to persist data to disk because the performance most Redis use cases need makes it less usable that way.</div><br/></div></div><div id="37553907" class="c"><input type="checkbox" id="c-37553907" checked=""/><div class="controls bullet"><span class="by">webmonkeyuk</span><span>|</span><a href="#37553076">parent</a><span>|</span><a href="#37553403">prev</a><span>|</span><a href="#37553930">next</a><span>|</span><label class="collapse" for="c-37553907">[-]</label><label class="expand" for="c-37553907">[1 more]</label></div><br/><div class="children"><div class="content">I suspect:<p>- memcached if you don&#x27;t need to persist the data<p>- Redis if you don&#x27;t know whether you need to use Redis or FoundationDB<p>- FoundationDB if you learn that Redis doesn&#x27;t do what you need<p>I don&#x27;t mean this in any kind of a derogatory way but I suspect that if you need to ask then you probably don&#x27;t need FDB.<p>The principle of keeping tech stacks boring and using well established components is less exciting as an Engineer but is usually the best choice.</div><br/></div></div><div id="37553930" class="c"><input type="checkbox" id="c-37553930" checked=""/><div class="controls bullet"><span class="by">jamesblonde</span><span>|</span><a href="#37553076">parent</a><span>|</span><a href="#37553907">prev</a><span>|</span><a href="#37553074">next</a><span>|</span><label class="collapse" for="c-37553930">[-]</label><label class="expand" for="c-37553930">[1 more]</label></div><br/><div class="children"><div class="content">If you need transactions and high availability, then use FDB. But if you also need low latency &#x2F; high throughput, then you should consider RonDB<p>Disclaimer: i am involved with RonDB</div><br/></div></div></div></div><div id="37553074" class="c"><input type="checkbox" id="c-37553074" checked=""/><div class="controls bullet"><span class="by">jrvarela56</span><span>|</span><a href="#37553076">prev</a><span>|</span><a href="#37556045">next</a><span>|</span><label class="collapse" for="c-37553074">[-]</label><label class="expand" for="c-37553074">[8 more]</label></div><br/><div class="children"><div class="content">Tangent about FoundationDB: this is a great video that explains how the team tested it <a href="https:&#x2F;&#x2F;youtu.be&#x2F;4fFDFbi3toc?si=kSZ8VcOIjW_pMmPd" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;4fFDFbi3toc?si=kSZ8VcOIjW_pMmPd</a><p>Spoiler: they even had their own custom power supplies used to test against power failures.</div><br/><div id="37553497" class="c"><input type="checkbox" id="c-37553497" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37553074">parent</a><span>|</span><a href="#37553182">next</a><span>|</span><label class="collapse" for="c-37553497">[-]</label><label class="expand" for="c-37553497">[1 more]</label></div><br/><div class="children"><div class="content">Ah someone else posted that video. I&#x27;m still recovering from it, it turned my world upside down (in a good way!).</div><br/></div></div><div id="37553182" class="c"><input type="checkbox" id="c-37553182" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#37553074">parent</a><span>|</span><a href="#37553497">prev</a><span>|</span><a href="#37553235">next</a><span>|</span><label class="collapse" for="c-37553182">[-]</label><label class="expand" for="c-37553182">[5 more]</label></div><br/><div class="children"><div class="content">Fwiw this is standard procedure for anyone shipping a persistent storage product.</div><br/><div id="37553195" class="c"><input type="checkbox" id="c-37553195" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#37553074">root</a><span>|</span><a href="#37553182">parent</a><span>|</span><a href="#37555433">next</a><span>|</span><label class="collapse" for="c-37553195">[-]</label><label class="expand" for="c-37553195">[1 more]</label></div><br/><div class="children"><div class="content">Only after FoundationDB made it standard.</div><br/></div></div><div id="37555433" class="c"><input type="checkbox" id="c-37555433" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#37553074">root</a><span>|</span><a href="#37553182">parent</a><span>|</span><a href="#37553195">prev</a><span>|</span><a href="#37553235">next</a><span>|</span><label class="collapse" for="c-37555433">[-]</label><label class="expand" for="c-37555433">[3 more]</label></div><br/><div class="children"><div class="content">FoundationDB&#x27;s testing turns the rigorous up to 11 and I&#x27;m unaware of anybody else who&#x27;s published a description of a testing approach that goes to quite the same extremes.<p>If that&#x27;s just because I haven&#x27;t noticed the others, I&#x27;d love to hear about them for comparison.</div><br/><div id="37556116" class="c"><input type="checkbox" id="c-37556116" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#37553074">root</a><span>|</span><a href="#37555433">parent</a><span>|</span><a href="#37553235">next</a><span>|</span><label class="collapse" for="c-37556116">[-]</label><label class="expand" for="c-37556116">[2 more]</label></div><br/><div class="children"><div class="content">I found a dataloss bug in the first hour of testing FDB. I think their testing hype is a bit overhyped.<p>I also find it somewhat irritating that they won&#x27;t take fixes or reports of problems with the storage engine because &quot;we fixed this in redwood&quot; when redwood is completely theoretical.</div><br/><div id="37556284" class="c"><input type="checkbox" id="c-37556284" checked=""/><div class="controls bullet"><span class="by">endisneigh</span><span>|</span><a href="#37553074">root</a><span>|</span><a href="#37556116">parent</a><span>|</span><a href="#37553235">next</a><span>|</span><label class="collapse" for="c-37556284">[-]</label><label class="expand" for="c-37556284">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve been able to use redwood since FDB 7.1 via ssd-redwood-1-experimental. Hardly theoretical.<p>Curious about that data loss bug. do you have a link? most bugs I&#x27;ve seen have to due with latency spikes and cluster unavailability. haven&#x27;t seen any around data loss after transaction has committed.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37553066" class="c"><input type="checkbox" id="c-37553066" checked=""/><div class="controls bullet"><span class="by">abhishekjha</span><span>|</span><a href="#37556045">prev</a><span>|</span><label class="collapse" for="c-37553066">[-]</label><label class="expand" for="c-37553066">[24 more]</label></div><br/><div class="children"><div class="content">This is the second article after the &quot;caddy&quot; one that I am having troble finding a usecase.<p>Nginx eixsts, why do I need to learn caddy?<p>Redis exists, why do I need to learn FundationDB?</div><br/><div id="37553170" class="c"><input type="checkbox" id="c-37553170" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37553066">parent</a><span>|</span><a href="#37553126">next</a><span>|</span><label class="collapse" for="c-37553170">[-]</label><label class="expand" for="c-37553170">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know enough to compare databases, but:<p>&gt; Nginx eixsts, why do I need to learn caddy?<p>If you&#x27;ve learned to manage nginx, by all means use it, but for new users it&#x27;s more like &quot;caddy works with like 3 lines of configuration, including HTTPS, why would I learn nginx?&quot;</div><br/><div id="37553238" class="c"><input type="checkbox" id="c-37553238" checked=""/><div class="controls bullet"><span class="by">jddj</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553170">parent</a><span>|</span><a href="#37553126">next</a><span>|</span><label class="collapse" for="c-37553238">[-]</label><label class="expand" for="c-37553238">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to derail too much but this is interesting, because I recently had the opposite experience.<p>I hadn&#x27;t spun up a webserver other than Kestrel for a long time, and was absolutely looking for the easiest solution for putting a reverse proxy in front of an API. No huge traffic requirements or low latency, seemed a perfect fit for caddy.<p>Then I googled to make sure that the necessary featureset was there and saw that rate limiting is a plugin that&#x27;s marked WIP. What&#x27;s more, there seemed to be a couple to choose from.<p>So I went through the certbot steps (very quick + straightforward) and wrote the short nginx config based on one page of getting started docs and was up and running.</div><br/><div id="37553422" class="c"><input type="checkbox" id="c-37553422" checked=""/><div class="controls bullet"><span class="by">damianh</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553238">parent</a><span>|</span><a href="#37553126">next</a><span>|</span><label class="collapse" for="c-37553422">[-]</label><label class="expand" for="c-37553422">[2 more]</label></div><br/><div class="children"><div class="content">Since you mention Kestrel I&#x27;ll assume .NET so I suggest you take a look at yarp. It&#x27;s fully programmable and &quot;plugins&quot; are just small pieces of middleware, a lot of which is available as a nuget package.<p>(I&#x27;m the author of ProxyKit that predated yarp)</div><br/><div id="37554076" class="c"><input type="checkbox" id="c-37554076" checked=""/><div class="controls bullet"><span class="by">jddj</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553422">parent</a><span>|</span><a href="#37553126">next</a><span>|</span><label class="collapse" for="c-37554076">[-]</label><label class="expand" for="c-37554076">[1 more]</label></div><br/><div class="children"><div class="content">Oh, very nice. We do use YARP actually on some of those other projects, and I was going to mention it. It&#x27;s great.<p>This particular (small, internal) project was in Go, so I wanted to use the opportunity to forego any extra runtimes and just used nginx.</div><br/></div></div></div></div></div></div></div></div><div id="37553126" class="c"><input type="checkbox" id="c-37553126" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#37553066">parent</a><span>|</span><a href="#37553170">prev</a><span>|</span><a href="#37553439">next</a><span>|</span><label class="collapse" for="c-37553126">[-]</label><label class="expand" for="c-37553126">[6 more]</label></div><br/><div class="children"><div class="content">FoundationDB replaces MySQL&#x2F;PostgreSQL (if the tradeoffs are acceptable) or Cassandra. It is a reliable distributed store.<p>Unless you are running Redis only with nothing else, fdb and redis do not play in the same space.</div><br/><div id="37553141" class="c"><input type="checkbox" id="c-37553141" checked=""/><div class="controls bullet"><span class="by">diogenes4</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553126">parent</a><span>|</span><a href="#37559984">next</a><span>|</span><label class="collapse" for="c-37553141">[-]</label><label class="expand" for="c-37553141">[4 more]</label></div><br/><div class="children"><div class="content">&gt; FoundationDB replaces MySQL&#x2F;PostgreSQL<p>Only in terms of transactions across multiple data centers. In every other way vertically scaler sql performs better, especially for your dollar.</div><br/><div id="37553166" class="c"><input type="checkbox" id="c-37553166" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553141">parent</a><span>|</span><a href="#37559984">next</a><span>|</span><label class="collapse" for="c-37553166">[-]</label><label class="expand" for="c-37553166">[3 more]</label></div><br/><div class="children"><div class="content">Performance is not the only metric. High availability (i.e. no single point of failure) with strong consistency are very important for some.</div><br/><div id="37553171" class="c"><input type="checkbox" id="c-37553171" checked=""/><div class="controls bullet"><span class="by">diogenes4</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553166">parent</a><span>|</span><a href="#37559984">next</a><span>|</span><label class="collapse" for="c-37553171">[-]</label><label class="expand" for="c-37553171">[2 more]</label></div><br/><div class="children"><div class="content">Is availability not an aspect of performance?<p>But of course, hence why i referenced multidc transactions.</div><br/><div id="37553220" class="c"><input type="checkbox" id="c-37553220" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553171">parent</a><span>|</span><a href="#37559984">next</a><span>|</span><label class="collapse" for="c-37553220">[-]</label><label class="expand" for="c-37553220">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is availability not an aspect of performance?<p>Not to my understanding. Can you elaborate?</div><br/></div></div></div></div></div></div></div></div><div id="37559984" class="c"><input type="checkbox" id="c-37559984" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553126">parent</a><span>|</span><a href="#37553141">prev</a><span>|</span><a href="#37553439">next</a><span>|</span><label class="collapse" for="c-37559984">[-]</label><label class="expand" for="c-37559984">[1 more]</label></div><br/><div class="children"><div class="content">&gt; FoundationDB replaces Cassandra<p>I think they have different use cases: fdb when you want transactions, cassandra when you want throughput.</div><br/></div></div></div></div><div id="37553439" class="c"><input type="checkbox" id="c-37553439" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37553066">parent</a><span>|</span><a href="#37553126">prev</a><span>|</span><a href="#37553117">next</a><span>|</span><label class="collapse" for="c-37553439">[-]</label><label class="expand" for="c-37553439">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Redis exists, why do I need to learn FundationDB?<p>so you know that this question does not make sense.</div><br/><div id="37553470" class="c"><input type="checkbox" id="c-37553470" checked=""/><div class="controls bullet"><span class="by">abhishekjha</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553439">parent</a><span>|</span><a href="#37553117">next</a><span>|</span><label class="collapse" for="c-37553470">[-]</label><label class="expand" for="c-37553470">[3 more]</label></div><br/><div class="children"><div class="content">From the article :<p>&gt;non-sharded, strict serializable, fault tolerant, key-value store that supports point writes, reads and range reads.<p>k-v store, non-sharded, fault tolerant, reads and range reads. Redis has these.<p>&gt;strict serializable<p>Redis&#x27;s single threaded model does this (maybe, not entirely sure).<p>Please help me understand why is this comparison orthongonal or does it really replace redis in ways that I don&#x27;t understand.</div><br/><div id="37555152" class="c"><input type="checkbox" id="c-37555152" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553470">parent</a><span>|</span><a href="#37556238">next</a><span>|</span><label class="collapse" for="c-37555152">[-]</label><label class="expand" for="c-37555152">[1 more]</label></div><br/><div class="children"><div class="content">The short version: If you have precious data you want to be stored very reliably and consistently, choose FDB over Redis, (or choose a SQL database with a good reputation for reliable storage).<p>The two words that come to mind are &quot;durable&quot;, which is the &quot;D&quot; in ACID, and the extensive testing of FDB&#x27;s distributed robustness properties in a wide range of testing and fault scenarios.<p>If you want Redis to store durably, which means the data is reliably stored by the time the database replies to the client and won&#x27;t magically disappear if there&#x27;s a crash or power failure just after, you need to turn on its &quot;fsync at every query&quot; mode.  This mode is very slow so durable storage is off by default in Redis.  So by default Redit can lose the last 1 second of writes on power failure, kernel crash, or virtual machine abrupt termination.<p>In other words, FDB is desiged for very reliable storage of every transactional write, and has been built and tested with that in mind.  Whereas Redis is not; they consider losing recent data in some realistic scenarios to be an acceptable default, and even with &quot;fsync on every query&quot; mode turned on it does not have the same level of testing and focus on durable distributed storage as FDB.<p>Without the &quot;D&quot;, things built on top which fill out the rest of ACID transactions and database indexing aren&#x27;t as reliable either.  For example &quot;C&quot;, consistency (with foreign keys, indexes, etc), is impossible to maintain if some of your recent writes may be lost while others are not.  I don&#x27;t know what guarantees Redis offers in this area, but it does not seem to be the focus.  Whereas FDB authors make it clear this sort of thing is a core focus of the product which it is architected for and also heavily tested.</div><br/></div></div><div id="37556238" class="c"><input type="checkbox" id="c-37556238" checked=""/><div class="controls bullet"><span class="by">sorenbs</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553470">parent</a><span>|</span><a href="#37555152">prev</a><span>|</span><a href="#37553117">next</a><span>|</span><label class="collapse" for="c-37556238">[-]</label><label class="expand" for="c-37556238">[1 more]</label></div><br/><div class="children"><div class="content">iCloud is build on FoundationDB. You couldn&#x27;t build iCloud on Redis. Most people are not building iCloud though.</div><br/></div></div></div></div></div></div><div id="37553117" class="c"><input type="checkbox" id="c-37553117" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#37553066">parent</a><span>|</span><a href="#37553439">prev</a><span>|</span><a href="#37560562">next</a><span>|</span><label class="collapse" for="c-37553117">[-]</label><label class="expand" for="c-37553117">[4 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t have a use case that requires FoundationDB you def. do not have to learn it.</div><br/><div id="37553499" class="c"><input type="checkbox" id="c-37553499" checked=""/><div class="controls bullet"><span class="by">abhishekjha</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553117">parent</a><span>|</span><a href="#37560562">next</a><span>|</span><label class="collapse" for="c-37553499">[-]</label><label class="expand" for="c-37553499">[3 more]</label></div><br/><div class="children"><div class="content">Well, for that the comparative features needs to be clearly laid out.<p>It solves a problem that others have not solved. Which problem is that? And how better does it work than whatever there was?</div><br/><div id="37555493" class="c"><input type="checkbox" id="c-37555493" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553499">parent</a><span>|</span><a href="#37556877">next</a><span>|</span><label class="collapse" for="c-37555493">[-]</label><label class="expand" for="c-37555493">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an analysis of a paper, not a feature checklist, so the article is for people who want to understand more about how FoundationDB works rather than trying to provide a &quot;which system should I use&quot; explanation.<p>Though &quot;super reliable distributed database presenting a single logical shard to client code&quot; is a class of system for which I don&#x27;t think there&#x27;s anything else even close out there, and I suspect generally if that&#x27;s something you -need- then you&#x27;ll already know that.</div><br/></div></div><div id="37556877" class="c"><input type="checkbox" id="c-37556877" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553499">parent</a><span>|</span><a href="#37555493">prev</a><span>|</span><a href="#37560562">next</a><span>|</span><label class="collapse" for="c-37556877">[-]</label><label class="expand" for="c-37556877">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a highly scalable (as in powers iCloud services with billion users) distributed transactional KV store. It&#x27;s owned by Apple and mostly developed by Apple and Snowflake.</div><br/></div></div></div></div></div></div><div id="37560562" class="c"><input type="checkbox" id="c-37560562" checked=""/><div class="controls bullet"><span class="by">javier2</span><span>|</span><a href="#37553066">parent</a><span>|</span><a href="#37553117">prev</a><span>|</span><a href="#37553133">next</a><span>|</span><label class="collapse" for="c-37560562">[-]</label><label class="expand" for="c-37560562">[1 more]</label></div><br/><div class="children"><div class="content">Its more like if you are considering Cassandra, but would like transactions, take a look at FoundationDB first. Cassandra is coming with some tx support in v5 most likely(?).</div><br/></div></div><div id="37554349" class="c"><input type="checkbox" id="c-37554349" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37553066">parent</a><span>|</span><a href="#37553133">prev</a><span>|</span><a href="#37553128">next</a><span>|</span><label class="collapse" for="c-37554349">[-]</label><label class="expand" for="c-37554349">[1 more]</label></div><br/><div class="children"><div class="content">Well NGINX and Docker exist why do I need Caddy at least.</div><br/></div></div><div id="37553128" class="c"><input type="checkbox" id="c-37553128" checked=""/><div class="controls bullet"><span class="by">diogenes4</span><span>|</span><a href="#37553066">parent</a><span>|</span><a href="#37554349">prev</a><span>|</span><label class="collapse" for="c-37553128">[-]</label><label class="expand" for="c-37553128">[2 more]</label></div><br/><div class="children"><div class="content">These technologies are primarily aimed at B2B markets and market them accordingly. You likely need none of them. Any meaningful technology is open source.</div><br/><div id="37555250" class="c"><input type="checkbox" id="c-37555250" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#37553066">root</a><span>|</span><a href="#37553128">parent</a><span>|</span><label class="collapse" for="c-37555250">[-]</label><label class="expand" for="c-37555250">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Any meaningful technology is open source.<p>Clearly untrue, however FoundationDB is open source, with a permissive license.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb">https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb</a><p>So is much of the operational tooling for it:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;FoundationDB&#x2F;fdb-kubernetes-operator">https:&#x2F;&#x2F;github.com&#x2F;FoundationDB&#x2F;fdb-kubernetes-operator</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>