<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738573278853" as="style"/><link rel="stylesheet" href="styles.css?v=1738573278853"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://adriacabeza.github.io/2024/07/12/caffeine-cache.html">Analyzing the codebase of Caffeine, a high performance caching library</a> <span class="domain">(<a href="https://adriacabeza.github.io">adriacabeza.github.io</a>)</span></div><div class="subtext"><span>synthc</span> | <span>51 comments</span></div><br/><div><div id="42911623" class="c"><input type="checkbox" id="c-42911623" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42908417">next</a><span>|</span><label class="collapse" for="c-42911623">[-]</label><label class="expand" for="c-42911623">[7 more]</label></div><br/><div class="children"><div class="content">Years ago I encountered a caching system that I misremembered as being a plugin for nginx and thus was never able to track down again.<p>It had a clever caching algorithm that favored latency over bandwidth. It weighted hit count versus size, so that given limited space, it would rather keep two small records that had more hits than a large record, so that it could serve more records from cache overall.<p>For some workloads the payload size is relatively proportional to the cost of the request - for the system of record. But latency and request setup costs do tend to shift that a bit.<p>But the bigger problem with LRU is that some workloads eventually resemble table scans, and the moment the data set no longer fits into cache, performance falls off a very tall cliff. And not just for that query but now for all subsequent ones as it causes cache misses for everyone else by evicting large quantities of recently used records. So you need to count frequency not just recency.</div><br/><div id="42912156" class="c"><input type="checkbox" id="c-42912156" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#42911623">parent</a><span>|</span><a href="#42914212">next</a><span>|</span><label class="collapse" for="c-42912156">[-]</label><label class="expand" for="c-42912156">[4 more]</label></div><br/><div class="children"><div class="content">For every caching algorithm you can design an adversarial workload that will perform poorly with the cache. Your choice of caching algorithm&#x2F;strategy needs to match your predicted workload. As you&#x27;re alluding there&#x27;s also the question of which resource are you trying to optimize for, if you&#x27;re trying to minimize processing time that might be a little different than optimizing for bandwidth.</div><br/><div id="42912807" class="c"><input type="checkbox" id="c-42912807" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42911623">root</a><span>|</span><a href="#42912156">parent</a><span>|</span><a href="#42914212">next</a><span>|</span><label class="collapse" for="c-42912807">[-]</label><label class="expand" for="c-42912807">[3 more]</label></div><br/><div class="children"><div class="content">If you have to refetch on a cache miss you&#x27;re going to be doing both. But all optimizations are always playing with the trigraph of cpu time, memory, and IO (with the hidden fourth dimension of legibility), so I don&#x27;t think you&#x27;re saying anything that can&#x27;t be assumed as given. Even among people who tend to pick incorrectly, or just lose track of when the situation has changed.</div><br/><div id="42913781" class="c"><input type="checkbox" id="c-42913781" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#42911623">root</a><span>|</span><a href="#42912807">parent</a><span>|</span><a href="#42914212">next</a><span>|</span><label class="collapse" for="c-42913781">[-]</label><label class="expand" for="c-42913781">[2 more]</label></div><br/><div class="children"><div class="content">I understood the OP to have said something along the lines of if we have a fixed cost per object then we should bias towards smaller objects if we want to minimize that cost.<p>And totally legibility and&#x2F;or simplicity. I&#x27;ll take something I can reason about and maintain over something more complicated just to eek out a tiny better hit ratio. That said, if you&#x27;re caching at scale your 0.05% hit ratio can be a big deal.<p>As a matter of personal taste&#x2F;opinion I also shy away from close loop systems. Feedback makes things complicated in non-intuitive ways. Caffeine seems neat in terms of using feedback to adjust the cache to the workload - as always test with your workloads and pick what is best for your situation.</div><br/><div id="42914765" class="c"><input type="checkbox" id="c-42914765" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42911623">root</a><span>|</span><a href="#42913781">parent</a><span>|</span><a href="#42914212">next</a><span>|</span><label class="collapse" for="c-42914765">[-]</label><label class="expand" for="c-42914765">[1 more]</label></div><br/><div class="children"><div class="content">The thing is that untangling the logic often reveals either new feature opportunities that would have been ugly to implement previously, or new optimization opportunities because the code is clearer, and possibly two things that seemed unrelated before are now obviously related.<p>If I can&#x27;t figure out how to make code faster without cheesing it I&#x27;ll just follow the campsite rule and hope for inspiration (the more you work with code the more you understand it, and I might as well clean while I&#x27;m here)</div><br/></div></div></div></div></div></div></div></div><div id="42914212" class="c"><input type="checkbox" id="c-42914212" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#42911623">parent</a><span>|</span><a href="#42912156">prev</a><span>|</span><a href="#42908417">next</a><span>|</span><label class="collapse" for="c-42914212">[-]</label><label class="expand" for="c-42914212">[2 more]</label></div><br/><div class="children"><div class="content">You might be interested in this thread [1] where I described an idea for how to incorporate the latency penalty into the eviction decision. A developer even hacked a prototype that showed promise. The problem is that there is not enough variety in the available trace data to be confident that a design isn&#x27;t overly fit to a particular workload and doesn&#x27;t generalize. As more data sets become available it will become possible to experiment with ideas and fix unexpected issues until a correct, simple, elegant design emerges.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;discussions&#x2F;1744">https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;discussions&#x2F;1744</a></div><br/><div id="42914796" class="c"><input type="checkbox" id="c-42914796" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42911623">root</a><span>|</span><a href="#42914212">parent</a><span>|</span><a href="#42908417">next</a><span>|</span><label class="collapse" for="c-42914796">[-]</label><label class="expand" for="c-42914796">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll check it out.<p>The thing is that the math changes when the system is saturated. The closer you get to tipping over, the more each new request costs. I feel like I can clearly recall times when I had to make a Sophie&#x27;s Choice between p50 and p95 times because of issues of this sort.</div><br/></div></div></div></div></div></div><div id="42908417" class="c"><input type="checkbox" id="c-42908417" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42911623">prev</a><span>|</span><a href="#42908670">next</a><span>|</span><label class="collapse" for="c-42908417">[-]</label><label class="expand" for="c-42908417">[5 more]</label></div><br/><div class="children"><div class="content">It would be interesting to see this on reddit&#x27;s workload.  The entire system was designed around the cache getting a 95%+ hit rate, because basically anything on front page of the top 1000 subreddits will get the overwhelming majority of traffic, so the cache is mostly filled with that.<p>In other words, this solves the problem of &quot;one hit wonders&quot; getting out of the cache quickly, but that basically already happened with the reddit workload.<p>The exception to that was Google, which would scrape old pages, and which is why we shunted them to their own infrastructure and didn&#x27;t cache their requests.  Maybe with this algo, we wouldn&#x27;t have had to do that.</div><br/><div id="42909214" class="c"><input type="checkbox" id="c-42909214" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42908417">parent</a><span>|</span><a href="#42909296">next</a><span>|</span><label class="collapse" for="c-42909214">[-]</label><label class="expand" for="c-42909214">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn’t one hit wonders still be an issue? They might get evicted relatively fast anyway but assuming an LRU each will still take a cache entry until they go through the entire thing and finally get evicted.<p>Although if that’s your concern you can probably just add a smaller admission cache in front of the main cache, possibly with a promotion memory.</div><br/><div id="42916038" class="c"><input type="checkbox" id="c-42916038" checked=""/><div class="controls bullet"><span class="by">JanecekPetr</span><span>|</span><a href="#42908417">root</a><span>|</span><a href="#42909214">parent</a><span>|</span><a href="#42909296">next</a><span>|</span><label class="collapse" for="c-42916038">[-]</label><label class="expand" for="c-42916038">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s kind of the idea of Caffeine, it has admission buffers, and it adapts automatically between LRU and LFU. The original algorithm is called Windiw TinyLFU (design <a href="https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;wiki&#x2F;Design">https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;wiki&#x2F;Design</a>), see it in action e.g. here: <a href="https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;wiki&#x2F;Efficiency">https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;wiki&#x2F;Efficiency</a></div><br/></div></div></div></div><div id="42909296" class="c"><input type="checkbox" id="c-42909296" checked=""/><div class="controls bullet"><span class="by">adbachman</span><span>|</span><a href="#42908417">parent</a><span>|</span><a href="#42909214">prev</a><span>|</span><a href="#42910095">next</a><span>|</span><label class="collapse" for="c-42909296">[-]</label><label class="expand" for="c-42909296">[1 more]</label></div><br/><div class="children"><div class="content">what are&#x2F;were Reddit&#x27;s top two or three cached structures &#x2F; things?<p>guessing post bodies and link previews feels too easy.<p>comment threads? post listings?<p>was there a lot of nesting?<p>it sounds like you&#x27;re describing a whole post--use message, comments, and all--for presentation to a browser or crawler.<p>(sorry, saw the handle and have so many questions :D)</div><br/></div></div><div id="42910095" class="c"><input type="checkbox" id="c-42910095" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#42908417">parent</a><span>|</span><a href="#42909296">prev</a><span>|</span><a href="#42908670">next</a><span>|</span><label class="collapse" for="c-42910095">[-]</label><label class="expand" for="c-42910095">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t reddit use Cassandra, Solr, and Kafka which uses Caffeine?</div><br/></div></div></div></div><div id="42908670" class="c"><input type="checkbox" id="c-42908670" checked=""/><div class="controls bullet"><span class="by">jbellis</span><span>|</span><a href="#42908417">prev</a><span>|</span><a href="#42911115">next</a><span>|</span><label class="collapse" for="c-42908670">[-]</label><label class="expand" for="c-42908670">[4 more]</label></div><br/><div class="children"><div class="content">Caffeine is a gem. Does what it claims, no drama, no scope creep, just works. I&#x27;ve used it in anger multiple times, most notably in Apache Cassandra and DataStax Astra, where it handles massive workloads invisibly, just like you&#x27;d want.<p>Shoutout to author Ben Manes if he sees this -- thanks for the great work!</div><br/><div id="42909761" class="c"><input type="checkbox" id="c-42909761" checked=""/><div class="controls bullet"><span class="by">plandis</span><span>|</span><a href="#42908670">parent</a><span>|</span><a href="#42910926">next</a><span>|</span><label class="collapse" for="c-42909761">[-]</label><label class="expand" for="c-42909761">[1 more]</label></div><br/><div class="children"><div class="content">Plus Ben made it extremely easy to migrate from Google Guava’s cache. It’s mostly the same API and way more performant to switch to Caffeine.</div><br/></div></div><div id="42910926" class="c"><input type="checkbox" id="c-42910926" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#42908670">parent</a><span>|</span><a href="#42909761">prev</a><span>|</span><a href="#42912864">next</a><span>|</span><label class="collapse" for="c-42910926">[-]</label><label class="expand" for="c-42910926">[1 more]</label></div><br/><div class="children"><div class="content">Thanks Jonathan!</div><br/></div></div></div></div><div id="42911115" class="c"><input type="checkbox" id="c-42911115" checked=""/><div class="controls bullet"><span class="by">thomastay</span><span>|</span><a href="#42908670">prev</a><span>|</span><a href="#42911437">next</a><span>|</span><label class="collapse" for="c-42911115">[-]</label><label class="expand" for="c-42911115">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However, diving into a new caching approach without a deep understanding of our current system seemed premature<p>Love love love this - I really enjoy reading articles where people analyze existing high performance systems instead of just going for the new and shiny thing</div><br/></div></div><div id="42911437" class="c"><input type="checkbox" id="c-42911437" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#42911115">prev</a><span>|</span><a href="#42910944">next</a><span>|</span><label class="collapse" for="c-42911437">[-]</label><label class="expand" for="c-42911437">[7 more]</label></div><br/><div class="children"><div class="content">Near the beginning, the author writes:<p>&gt; Caching is all about maximizing the hit ratio<p>A thing I worry about a lot is discontinuities in cache behaviour (simple example: let’s say a client polls a list of entries, and downloads each entry from the list one at a time to see if it is different. Obviously this feels like a bit of a silly way for a client to behave. If you have a small lru cache (eg maybe it is partitioned such that partitions are small and all the requests from this client go to the same partition) then there is some threshold size where the client transitions from ~all requests hitting the cache to ~none hitting the cache.)<p>This is a bit different from some behaviours always being bad for cache (eg a search crawler fetches lots of entries once).<p>Am I wrong to worry about these kinds of ‘phase transitions’? Should the focus just be on optimising hit rate in the average case?</div><br/><div id="42911840" class="c"><input type="checkbox" id="c-42911840" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#42911437">parent</a><span>|</span><a href="#42911678">next</a><span>|</span><label class="collapse" for="c-42911840">[-]</label><label class="expand" for="c-42911840">[1 more]</label></div><br/><div class="children"><div class="content">As the article mentions, Caffeine&#x27;s approach is to monitor the workload and adapt to these phase changes. This stress test [1] demonstrates shifting back and forth between LRU and MRU request patterns, and the cache reconfiguring itself to maximize the hit rate. Unfortunately most policies are not adaptive or do it poorly.<p>Thankfully most workloads are a relatively consistent pattern, so it is an atypical worry. The algorithm designers usually have a target scenario, like cdn or database, so they generally skip reporting the low performing workloads. That may work for a research paper, but when providing a library we cannot know what our users workloads are nor should we expect engineers to invest in selecting the optimal algorithm. Caffeine&#x27;s adaptivity removes this burden and broaden its applicability, and other language ecosystems have been slowly adopting similar ideas in their caching libraries.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;wiki&#x2F;Efficiency#adaptivity">https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;wiki&#x2F;Efficiency#adapti...</a></div><br/></div></div><div id="42911678" class="c"><input type="checkbox" id="c-42911678" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42911437">parent</a><span>|</span><a href="#42911840">prev</a><span>|</span><a href="#42911692">next</a><span>|</span><label class="collapse" for="c-42911678">[-]</label><label class="expand" for="c-42911678">[3 more]</label></div><br/><div class="children"><div class="content">I had a team that just did not get my explanations that they had created such a scenario. I had to show them the bus sized “corner case” they had created before they agreed to a more sophisticated cache.<p>That project was the beginning of the end of my affection for caches. Without very careful discipline that few teams have, once they are added all organic attempts at optimization are greatly complicated. It’s global shared state with all the problems that brings. And if you use it instead of the call stack to pass arguments around (eg passing ID instead of User and making everyone look it up ten times), then your goose really is cooked.</div><br/><div id="42912283" class="c"><input type="checkbox" id="c-42912283" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#42911437">root</a><span>|</span><a href="#42911678">parent</a><span>|</span><a href="#42911692">next</a><span>|</span><label class="collapse" for="c-42912283">[-]</label><label class="expand" for="c-42912283">[2 more]</label></div><br/><div class="children"><div class="content">Interesting. I hadn’t really thought of global state as being a problem (I mostly think of caches as affecting performance but not semantics but I guess I didn’t really think about cache invalidation&#x2F;poisoning either). My main worry would be more something like making a cold start very difficult or making things harder to change.</div><br/><div id="42912789" class="c"><input type="checkbox" id="c-42912789" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42911437">root</a><span>|</span><a href="#42912283">parent</a><span>|</span><a href="#42911692">next</a><span>|</span><label class="collapse" for="c-42912789">[-]</label><label class="expand" for="c-42912789">[1 more]</label></div><br/><div class="children"><div class="content">When you design a call tree so that any data used later is passed explicitly down the call tree instead of looked up by ID over and over, then you can be sure that all of the decisions about that data are made on a consistent copy of the data.<p>When you look up the same value 10 times, you not only pollute the flame graphs and call counts which makes proving that a better algorithm is necessary or has any effect much harder, but more importantly, you could get 3 different states and try to make a bunch of updates based on what should be mutually exclusive states in the system. That&#x27;s the global shared state problem.<p>When you look up a value once and remember it throughout a calculation, it may not be the current state, but at least you have a clean snapshot of the data. Which in situations such as cancelling an account immediately after getting one last discount on a purchase, well, we know which scenario the customer probably meant.</div><br/></div></div></div></div></div></div><div id="42911692" class="c"><input type="checkbox" id="c-42911692" checked=""/><div class="controls bullet"><span class="by">t0mas88</span><span>|</span><a href="#42911437">parent</a><span>|</span><a href="#42911678">prev</a><span>|</span><a href="#42911722">next</a><span>|</span><label class="collapse" for="c-42911692">[-]</label><label class="expand" for="c-42911692">[1 more]</label></div><br/><div class="children"><div class="content">These are exactly the things to worry about in an application that has enough scale for it. My usual approach is to have a wiki page or document to describe these limitations and roughly the order of magnitude where you will encounter them. Then do nothing and let them be until that scale is on the horizon.<p>There is no point fixing a &quot;this could be slow if we have more than 65535 users&quot; if you currently have 100 users.<p>I usually add a few pointers to the document on how to increase the scaling limit a bit without major rebuilding (e.g. make this cache size 2x larger). Those are useful as a short term solution during the time needed to build the real next version.</div><br/></div></div><div id="42911722" class="c"><input type="checkbox" id="c-42911722" checked=""/><div class="controls bullet"><span class="by">ratorx</span><span>|</span><a href="#42911437">parent</a><span>|</span><a href="#42911692">prev</a><span>|</span><a href="#42910944">next</a><span>|</span><label class="collapse" for="c-42911722">[-]</label><label class="expand" for="c-42911722">[1 more]</label></div><br/><div class="children"><div class="content">Caching itself is introducing a discontinuity, because whether a request does or does not hit the cache will have vastly different performance profiles (and if not, then the cache may be a bit useless).<p>I think the only way to approach this problem is statistically, but average is a bad metric. I think you’d care about some high percentile instead.</div><br/></div></div></div></div><div id="42910944" class="c"><input type="checkbox" id="c-42910944" checked=""/><div class="controls bullet"><span class="by">nighthawk454</span><span>|</span><a href="#42911437">prev</a><span>|</span><a href="#42910413">next</a><span>|</span><label class="collapse" for="c-42910944">[-]</label><label class="expand" for="c-42910944">[1 more]</label></div><br/><div class="children"><div class="content">Seems to be hugged, so here&#x27;s a cached view<p><a href="https:&#x2F;&#x2F;archive.is&#x2F;w8yFG" rel="nofollow">https:&#x2F;&#x2F;archive.is&#x2F;w8yFG</a><p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20250202094451&#x2F;https:&#x2F;&#x2F;adriacabeza.github.io&#x2F;2024&#x2F;07&#x2F;12&#x2F;caffeine-cache.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20250202094451&#x2F;https:&#x2F;&#x2F;adriacabe...</a> (images are cached better here)</div><br/></div></div><div id="42910413" class="c"><input type="checkbox" id="c-42910413" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42910944">prev</a><span>|</span><a href="#42909434">next</a><span>|</span><label class="collapse" for="c-42910413">[-]</label><label class="expand" for="c-42910413">[2 more]</label></div><br/><div class="children"><div class="content">Huh. Their segmented LRU setup is similar to the Linux kernel&#x27;s active and inactive lists for pages. Convergent evolution in action.</div><br/><div id="42910876" class="c"><input type="checkbox" id="c-42910876" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#42910413">parent</a><span>|</span><a href="#42909434">next</a><span>|</span><label class="collapse" for="c-42910876">[-]</label><label class="expand" for="c-42910876">[1 more]</label></div><br/><div class="children"><div class="content">I tried to reimplement Linux’s algorithm in [1], but I cannot be sure about correctness. They adjust the fixed sizes at construction based on device’s total memory, so it varies if a phone or server. This fast trace simulation in the CI [2] may be informative (see DClock). Segmentation is very common, where algorithms differ by how they promote and how&#x2F;if they adapt the sizes.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;blob&#x2F;master&#x2F;simulator&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;github&#x2F;benmanes&#x2F;caffeine&#x2F;cache&#x2F;simulator&#x2F;policy&#x2F;irr&#x2F;DClockPolicy.java">https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;blob&#x2F;master&#x2F;simulator&#x2F;...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;actions&#x2F;runs&#x2F;13086596566#summary-36518459069">https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;actions&#x2F;runs&#x2F;130865965...</a></div><br/></div></div></div></div><div id="42909434" class="c"><input type="checkbox" id="c-42909434" checked=""/><div class="controls bullet"><span class="by">dstroot</span><span>|</span><a href="#42910413">prev</a><span>|</span><a href="#42907969">next</a><span>|</span><label class="collapse" for="c-42909434">[-]</label><label class="expand" for="c-42909434">[9 more]</label></div><br/><div class="children"><div class="content">Codebase has &gt;16k stars on GitHub and only 1 open issue, and 3 open PRs. Never seen that before on a highly used codebase. Kudos to the maintainer(s).</div><br/><div id="42909824" class="c"><input type="checkbox" id="c-42909824" checked=""/><div class="controls bullet"><span class="by">bean-weevil</span><span>|</span><a href="#42909434">parent</a><span>|</span><a href="#42910585">next</a><span>|</span><label class="collapse" for="c-42909824">[-]</label><label class="expand" for="c-42909824">[2 more]</label></div><br/><div class="children"><div class="content">I went through some of the issues to see how aggressively they close them and found this gem: <a href="https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;issues&#x2F;1824#issuecomment-2606604996">https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;issues&#x2F;1824#issuecomme...</a></div><br/><div id="42910558" class="c"><input type="checkbox" id="c-42910558" checked=""/><div class="controls bullet"><span class="by">ketzo</span><span>|</span><a href="#42909434">root</a><span>|</span><a href="#42909824">parent</a><span>|</span><a href="#42910585">next</a><span>|</span><label class="collapse" for="c-42910558">[-]</label><label class="expand" for="c-42910558">[1 more]</label></div><br/><div class="children"><div class="content">Damn, I need that framed over my desk.</div><br/></div></div></div></div><div id="42910585" class="c"><input type="checkbox" id="c-42910585" checked=""/><div class="controls bullet"><span class="by">Lord_Zero</span><span>|</span><a href="#42909434">parent</a><span>|</span><a href="#42909824">prev</a><span>|</span><a href="#42909973">next</a><span>|</span><label class="collapse" for="c-42910585">[-]</label><label class="expand" for="c-42910585">[4 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t looked, but stalebot can make repos look squeaky clean when in reality issues are ignored and then closed without being addressed.</div><br/><div id="42910621" class="c"><input type="checkbox" id="c-42910621" checked=""/><div class="controls bullet"><span class="by">calpaterson</span><span>|</span><a href="#42909434">root</a><span>|</span><a href="#42910585">parent</a><span>|</span><a href="#42912382">next</a><span>|</span><label class="collapse" for="c-42910621">[-]</label><label class="expand" for="c-42910621">[2 more]</label></div><br/><div class="children"><div class="content">Sparing everyone else a browse of the bugtracker: the maintainer does not seem to use a bot to autoclose issues.  The close issues appeared to be actually closed and it seemed from a quick glance that he actually investigated each filing.</div><br/><div id="42911131" class="c"><input type="checkbox" id="c-42911131" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#42909434">root</a><span>|</span><a href="#42910621">parent</a><span>|</span><a href="#42912382">next</a><span>|</span><label class="collapse" for="c-42911131">[-]</label><label class="expand" for="c-42911131">[1 more]</label></div><br/><div class="children"><div class="content">Yep, no bots. A real bug not only means that I wasted someone else’s time, but reporting is a gift for an improvement. If a misunderstanding then it’s motivation that my project is used and deserves a generous reply. This perspective and treating as strictly a hobby, rather than as a criticism or demand for work, makes OSS feel more sustainable.</div><br/></div></div></div></div><div id="42912382" class="c"><input type="checkbox" id="c-42912382" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42909434">root</a><span>|</span><a href="#42910585">parent</a><span>|</span><a href="#42910621">prev</a><span>|</span><a href="#42909973">next</a><span>|</span><label class="collapse" for="c-42912382">[-]</label><label class="expand" for="c-42912382">[1 more]</label></div><br/><div class="children"><div class="content">Google-Adjacent OSS repos are the worst for this!<p>Passive-Aggressive Stalebot marches into the middle of an _active_ thread and announces that the issue is now stale&#x2F;dead and everyone should go away.<p>I get that on large projects there’s a non-trivial percentage of issues which amount to “I’m holding it wrong, didn’t actually read the log messages, or the manual, fix it for me pls” which are just unhelpful noise. However more often than not they take every other thread- including important ones, with them.</div><br/></div></div></div></div><div id="42909973" class="c"><input type="checkbox" id="c-42909973" checked=""/><div class="controls bullet"><span class="by">homebrewer</span><span>|</span><a href="#42909434">parent</a><span>|</span><a href="#42910585">prev</a><span>|</span><a href="#42910752">next</a><span>|</span><label class="collapse" for="c-42909973">[-]</label><label class="expand" for="c-42909973">[1 more]</label></div><br/><div class="children"><div class="content">kitty is very close, which is impressive when you remember that the vast majority of the work is done by one guy (Kovid Goyal).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kovidgoyal&#x2F;kitty&#x2F;issues">https:&#x2F;&#x2F;github.com&#x2F;kovidgoyal&#x2F;kitty&#x2F;issues</a> — 0.239% vs 0.137%<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kovidgoyal&#x2F;kitty&#x2F;issues">https:&#x2F;&#x2F;github.com&#x2F;kovidgoyal&#x2F;kitty&#x2F;issues</a> — 0.729% vs 0.317%<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kovidgoyal&#x2F;kitty&#x2F;graphs&#x2F;contributors">https:&#x2F;&#x2F;github.com&#x2F;kovidgoyal&#x2F;kitty&#x2F;graphs&#x2F;contributors</a></div><br/></div></div></div></div><div id="42907969" class="c"><input type="checkbox" id="c-42907969" checked=""/><div class="controls bullet"><span class="by">jupiterroom</span><span>|</span><a href="#42909434">prev</a><span>|</span><a href="#42907489">next</a><span>|</span><label class="collapse" for="c-42907969">[-]</label><label class="expand" for="c-42907969">[8 more]</label></div><br/><div class="children"><div class="content">really random question - but what is used to create the images in this blog post?  I see this style quite often but never been able to track down what is used.</div><br/><div id="42909168" class="c"><input type="checkbox" id="c-42909168" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#42907969">parent</a><span>|</span><a href="#42908006">next</a><span>|</span><label class="collapse" for="c-42909168">[-]</label><label class="expand" for="c-42909168">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;excalidraw.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;excalidraw.com&#x2F;</a><p><a href="https:&#x2F;&#x2F;d2lang.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;d2lang.com&#x2F;</a><p><a href="https:&#x2F;&#x2F;www.drawio.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.drawio.com&#x2F;</a><p>For something a bit lower level, try:<p><a href="https:&#x2F;&#x2F;roughjs.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;roughjs.com&#x2F;</a><p>It&#x27;s what powers the sketch-like look from many of the sites above.</div><br/></div></div><div id="42908006" class="c"><input type="checkbox" id="c-42908006" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#42907969">parent</a><span>|</span><a href="#42909168">prev</a><span>|</span><a href="#42912496">next</a><span>|</span><label class="collapse" for="c-42908006">[-]</label><label class="expand" for="c-42908006">[1 more]</label></div><br/><div class="children"><div class="content">I suspect they used Excalidraw [1]. It&#x27;s a nice, quick tool for this kind of sketching, and supports collaborative drawing.<p>[1] <a href="https:&#x2F;&#x2F;excalidraw.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;excalidraw.com&#x2F;</a></div><br/></div></div><div id="42912496" class="c"><input type="checkbox" id="c-42912496" checked=""/><div class="controls bullet"><span class="by">homarp</span><span>|</span><a href="#42907969">parent</a><span>|</span><a href="#42908006">prev</a><span>|</span><a href="#42907971">next</a><span>|</span><label class="collapse" for="c-42912496">[-]</label><label class="expand" for="c-42912496">[1 more]</label></div><br/><div class="children"><div class="content">if you look at the metadata of each png,  you will find the
application&#x2F;vnd&#x2F;excalidraw&#x2F;json field that contains the image in excalidraw format.</div><br/></div></div><div id="42907971" class="c"><input type="checkbox" id="c-42907971" checked=""/><div class="controls bullet"><span class="by">jupiterroom</span><span>|</span><a href="#42907969">parent</a><span>|</span><a href="#42912496">prev</a><span>|</span><a href="#42908125">next</a><span>|</span><label class="collapse" for="c-42907971">[-]</label><label class="expand" for="c-42907971">[2 more]</label></div><br/><div class="children"><div class="content">i.e these - <a href="https:&#x2F;&#x2F;adriacabeza.github.io&#x2F;img&#x2F;tinylfu.png" rel="nofollow">https:&#x2F;&#x2F;adriacabeza.github.io&#x2F;img&#x2F;tinylfu.png</a></div><br/><div id="42907995" class="c"><input type="checkbox" id="c-42907995" checked=""/><div class="controls bullet"><span class="by">syct</span><span>|</span><a href="#42907969">root</a><span>|</span><a href="#42907971">parent</a><span>|</span><a href="#42908125">next</a><span>|</span><label class="collapse" for="c-42907995">[-]</label><label class="expand" for="c-42907995">[1 more]</label></div><br/><div class="children"><div class="content">Try this <a href="https:&#x2F;&#x2F;excalidraw.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;excalidraw.com&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42907489" class="c"><input type="checkbox" id="c-42907489" checked=""/><div class="controls bullet"><span class="by">synthc</span><span>|</span><a href="#42907969">prev</a><span>|</span><a href="#42912584">next</a><span>|</span><label class="collapse" for="c-42907489">[-]</label><label class="expand" for="c-42907489">[5 more]</label></div><br/><div class="children"><div class="content">Interesting deep dive on the internals of Caffeine, a widely used JVM caching library.</div><br/></div></div><div id="42912584" class="c"><input type="checkbox" id="c-42912584" checked=""/><div class="controls bullet"><span class="by">urbandw311er</span><span>|</span><a href="#42907489">prev</a><span>|</span><label class="collapse" for="c-42912584">[-]</label><label class="expand" for="c-42912584">[1 more]</label></div><br/><div class="children"><div class="content">Caffeine is also the name of a macOS utility to stop the screen going to sleep.  Be great if whichever came second could consider a name change.</div><br/></div></div></div></div></div></div></div></body></html>