<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729155666290" as="style"/><link rel="stylesheet" href="styles.css?v=1729155666290"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://spidermonkey.dev/blog/2024/10/16/75x-faster-optimizing-the-ion-compiler-backend.html">Optimizing the Ion compiler back end</a> <span class="domain">(<a href="https://spidermonkey.dev">spidermonkey.dev</a>)</span></div><div class="subtext"><span>undercut</span> | <span>33 comments</span></div><br/><div><div id="41863932" class="c"><input type="checkbox" id="c-41863932" checked=""/><div class="controls bullet"><span class="by">rpearl</span><span>|</span><a href="#41863819">next</a><span>|</span><label class="collapse" for="c-41863932">[-]</label><label class="expand" for="c-41863932">[6 more]</label></div><br/><div class="children"><div class="content">Wow, that dominator tree algorithm I wrote as an intern (<a href="https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=666426" rel="nofollow">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=666426</a>) seems to have lasted 13 years! At the time we assumed that graphs would be small enough to not warrant the constant factor against Lengauer-Tarjan. ...And of course, browser-based apps have gotten much bigger since then.<p>Semi-NCA hadn&#x27;t even been published yet and seems like the clear choice nowadays, so I&#x27;m glad to see it in place! Great work!</div><br/><div id="41865343" class="c"><input type="checkbox" id="c-41865343" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41863932">parent</a><span>|</span><a href="#41866865">next</a><span>|</span><label class="collapse" for="c-41865343">[-]</label><label class="expand" for="c-41865343">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Semi-NCA hadn&#x27;t even been published yet and seems like the clear choice nowadays[.]<p>For those who are awkwardly lingering and casting longing glasses at the entrance door of compiler engineering like I am, and who were just as dismayed by this sentence, it wasn’t “properly” published but looks to have been described in a thesis from 2005[1] and in an extended abstract (ugh) before that[2].<p>But also, the reduction of RMQ to NCA, really?.. Ouch. I’m having flashbacks to my (very brief) competitive programming days, and not the good kind.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.princeton.edu&#x2F;research&#x2F;techreps&#x2F;TR-737-05" rel="nofollow">https:&#x2F;&#x2F;www.cs.princeton.edu&#x2F;research&#x2F;techreps&#x2F;TR-737-05</a><p>[2] <a href="https:&#x2F;&#x2F;www.cse.uoi.gr&#x2F;~loukas&#x2F;index.files&#x2F;dominators_soda04.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cse.uoi.gr&#x2F;~loukas&#x2F;index.files&#x2F;dominators_soda04...</a></div><br/><div id="41865498" class="c"><input type="checkbox" id="c-41865498" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#41863932">root</a><span>|</span><a href="#41865343">parent</a><span>|</span><a href="#41866865">next</a><span>|</span><label class="collapse" for="c-41865498">[-]</label><label class="expand" for="c-41865498">[1 more]</label></div><br/><div class="children"><div class="content">It was published prior to that in a paper named &quot;Finding dominators in practice&quot;, published in ESA 2004[1].<p>For once, the title is not actually an oversell, it actually covers that topic quite well for a conference paper.<p>[1] <a href="https:&#x2F;&#x2F;link.springer.com&#x2F;chapter&#x2F;10.1007&#x2F;978-3-540-30140-0_60" rel="nofollow">https:&#x2F;&#x2F;link.springer.com&#x2F;chapter&#x2F;10.1007&#x2F;978-3-540-30140-0_...</a></div><br/></div></div></div></div><div id="41866865" class="c"><input type="checkbox" id="c-41866865" checked=""/><div class="controls bullet"><span class="by">jandem</span><span>|</span><a href="#41863932">parent</a><span>|</span><a href="#41865343">prev</a><span>|</span><a href="#41865494">next</a><span>|</span><label class="collapse" for="c-41866865">[-]</label><label class="expand" for="c-41866865">[1 more]</label></div><br/><div class="children"><div class="content">Nice to hear from you! Yes it was a very reasonable choice back then, before (enormous) asm.js and Wasm functions.<p>The compiler wasn&#x27;t really designed for these huge graphs, but fortunately a lot of the issues can be fixed incrementally and it&#x27;s still holding up well.</div><br/></div></div><div id="41865494" class="c"><input type="checkbox" id="c-41865494" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#41863932">parent</a><span>|</span><a href="#41866865">prev</a><span>|</span><a href="#41863991">next</a><span>|</span><label class="collapse" for="c-41865494">[-]</label><label class="expand" for="c-41865494">[1 more]</label></div><br/><div class="children"><div class="content">Amusingly, the LLVM implementation was also written by an intern at one point :)<p>Semi-NCA was actually published back then, just not in the cited paper.<p>See &quot;Finding dominators in practice&quot;, published in 2004, section 2.3.
So two decades ago.<p>The main advantage of Semi-NCA (and why LLVM uses it) is that it makes for a good incremental update algorithm.
See <a href="https:&#x2F;&#x2F;reviews.llvm.org&#x2F;D34258" rel="nofollow">https:&#x2F;&#x2F;reviews.llvm.org&#x2F;D34258</a><p>Truthfully, as much as I love Cooper and friends (they were responsible for a lot of very thoughtful, well engineered algorithms at a time when lots of stuff was just &quot;here&#x27;s some research i think is better&quot;), the &quot;simple&quot; dataflow based algorithm was never worth it.<p>Part of the thing i was good at way back then was keeping track of all of the research in compiler opts and which was any good - most of their stuff is very good.<p>I used to go through every paper that came around and keep an up to date library of ones worth looking at (both now and in the future) that a bunch of folks used. This was harder back in the days of nobody really publishing code, i used to have to write a ton of prototype implementations to see which numbers were real and which were BS because they compared against crappy implementations or whatever.<p>SEMI-NCA was an obvious win - it was simple enough to implement and test, equally as fast as what existed now, and could easily be extended to incremental updates.<p>If you want to see what it takes to do incremental updates with LT, take a look at GCC&#x27;s dominator update code back around that time period (I think it&#x27;s unchanged since then, actually, but i haven&#x27;t looked in a few years).  There were a fairly small number of people who could understand the data structures and algorithms involved.</div><br/></div></div></div></div><div id="41863819" class="c"><input type="checkbox" id="c-41863819" checked=""/><div class="controls bullet"><span class="by">koala_man</span><span>|</span><a href="#41863932">prev</a><span>|</span><a href="#41863936">next</a><span>|</span><label class="collapse" for="c-41863819">[-]</label><label class="expand" for="c-41863819">[1 more]</label></div><br/><div class="children"><div class="content">&gt; extremely large functions
&gt; quadratic behavior<p>*High five*<p>I fixed several of these during my time as a compiler engineer too.<p>It&#x27;s true what they say, quadratic is the worst possible time complexity. Fast enough to work on all your test cases, slow enough to explode in prod.</div><br/></div></div><div id="41863936" class="c"><input type="checkbox" id="c-41863936" checked=""/><div class="controls bullet"><span class="by">pshc</span><span>|</span><a href="#41863819">prev</a><span>|</span><a href="#41865280">next</a><span>|</span><label class="collapse" for="c-41863936">[-]</label><label class="expand" for="c-41863936">[2 more]</label></div><br/><div class="children"><div class="content">In modern times I seldom reach for a linked list... cache friendly data structures almost always win.</div><br/><div id="41864638" class="c"><input type="checkbox" id="c-41864638" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#41863936">parent</a><span>|</span><a href="#41865280">next</a><span>|</span><label class="collapse" for="c-41864638">[-]</label><label class="expand" for="c-41864638">[1 more]</label></div><br/><div class="children"><div class="content">Yup. Almost every DS in my compiler is either an array or a hashmap.</div><br/></div></div></div></div><div id="41865280" class="c"><input type="checkbox" id="c-41865280" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#41863936">prev</a><span>|</span><a href="#41861633">next</a><span>|</span><label class="collapse" for="c-41865280">[-]</label><label class="expand" for="c-41865280">[2 more]</label></div><br/><div class="children"><div class="content">What is MIR in this context? On the one hand, given the mention of Cranelift, it seems like it could be referring to the Rust compiler&#x27;s intermediate representation, but given the context perhaps it&#x27;s referring to an independent intermediate representation that also just happens to be called MIR?</div><br/><div id="41866271" class="c"><input type="checkbox" id="c-41866271" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#41865280">parent</a><span>|</span><a href="#41861633">next</a><span>|</span><label class="collapse" for="c-41866271">[-]</label><label class="expand" for="c-41866271">[1 more]</label></div><br/><div class="children"><div class="content">MIR is the compiler intermediate representation used by Ion. I know the IonMonkey docs say the acronym is Mid-level Intermediate Representation.</div><br/></div></div></div></div><div id="41861633" class="c"><input type="checkbox" id="c-41861633" checked=""/><div class="controls bullet"><span class="by">cjblomqvist</span><span>|</span><a href="#41865280">prev</a><span>|</span><a href="#41862222">next</a><span>|</span><label class="collapse" for="c-41861633">[-]</label><label class="expand" for="c-41861633">[4 more]</label></div><br/><div class="children"><div class="content">If anyone have a comparison with V8 that would be great!</div><br/><div id="41862732" class="c"><input type="checkbox" id="c-41862732" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#41861633">parent</a><span>|</span><a href="#41862843">next</a><span>|</span><label class="collapse" for="c-41862732">[-]</label><label class="expand" for="c-41862732">[2 more]</label></div><br/><div class="children"><div class="content">Not sure what kind of comparison you mean, but you can compare desktop browsers with [1].<p>I just ran it on my mac M2 Max and got:<p><pre><code>    (F)irefox 131.0.3
    (E)dge 129.0, V8 12.9.17.8
    (S)afari 18.0 (20619.1.26.31.6)

    Speedometer 3.0
    (F) 25.9  
    (E) 22.3
    (S) 30.9

    JetStream2
    (F) 251.787
    (E) 350.74
    (S) 360.568
</code></pre>
Safari seems slightly faster in all benchmarks. I did not run motionmark because it takes forever :-&#x2F;. The page says JetStream2 is what you want if you want to benchmark wasm.<p>How this relates to TFA, no idea ... is not really easy to tell which version of SpiderMonkey is running on the installed Firefox.<p>--<p>1: <a href="https:&#x2F;&#x2F;browserbench.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;browserbench.org&#x2F;</a></div><br/><div id="41863230" class="c"><input type="checkbox" id="c-41863230" checked=""/><div class="controls bullet"><span class="by">KwanEsq</span><span>|</span><a href="#41861633">root</a><span>|</span><a href="#41862732">parent</a><span>|</span><a href="#41862843">next</a><span>|</span><label class="collapse" for="c-41863230">[-]</label><label class="expand" for="c-41863230">[1 more]</label></div><br/><div class="children"><div class="content">Spidermonkey just follows Firefox version numbering, so far as I know, and the linked bugs in the article seem to have landed in a mix of the 132 and 133 milestones, so you&#x27;ll have to wait a couple of release cycles for the full effect.</div><br/></div></div></div></div><div id="41862843" class="c"><input type="checkbox" id="c-41862843" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#41861633">parent</a><span>|</span><a href="#41862732">prev</a><span>|</span><a href="#41862222">next</a><span>|</span><label class="collapse" for="c-41862843">[-]</label><label class="expand" for="c-41862843">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;arewefastyet.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arewefastyet.com&#x2F;</a> has various comparisons between Firefox and Chrome, the script oriented ones are basically Spidermonkey vs V8</div><br/></div></div></div></div><div id="41862222" class="c"><input type="checkbox" id="c-41862222" checked=""/><div class="controls bullet"><span class="by">zyedidia</span><span>|</span><a href="#41861633">prev</a><span>|</span><a href="#41862493">next</a><span>|</span><label class="collapse" for="c-41862222">[-]</label><label class="expand" for="c-41862222">[11 more]</label></div><br/><div class="children"><div class="content">Is there any AOT WebAssembly compiler that can compile Wasm used by websites? I tried locally compiling the Photoshop Wasm module mentioned in the article but the compilers I tried (Wasmtime, wasm2c, WAMR) all complained about some unsupported Wasm extension&#x2F;proposal being required (exceptions seems like the blocker on wasmtime, and the others gave cryptic error messages).<p>Is it really the case that browsers have default-enabled all sorts of extensions that are not yet widely supported by the rest of the ecosystem?</div><br/><div id="41863118" class="c"><input type="checkbox" id="c-41863118" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41862222">parent</a><span>|</span><a href="#41862827">next</a><span>|</span><label class="collapse" for="c-41863118">[-]</label><label class="expand" for="c-41863118">[1 more]</label></div><br/><div class="children"><div class="content">No, I think most of the AOT compilers in practice are a bit behind V8 and&#x2F;or Spidermonkey for newer features. Realistically, most development driving new WASM features is motivated by website-ish use cases. Exception handling in particular is still not standardized so I guess it&#x27;s expected that the browser engines would be the one to have the most evolving support (and the ability to test it thoroughly) because people want that platform as their inevitable target anyway.</div><br/></div></div><div id="41862827" class="c"><input type="checkbox" id="c-41862827" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41862222">parent</a><span>|</span><a href="#41863118">prev</a><span>|</span><a href="#41862830">next</a><span>|</span><label class="collapse" for="c-41862827">[-]</label><label class="expand" for="c-41862827">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Is it really the case that browsers have default-enabled all sorts of extensions that are not yet widely supported by the rest of the ecosystem?<p>I don&#x27;t know the answer, but it would be hard to blame them for following normal browser development practices on the standard they created for the purpose of being in browsers.</div><br/><div id="41863641" class="c"><input type="checkbox" id="c-41863641" checked=""/><div class="controls bullet"><span class="by">zyedidia</span><span>|</span><a href="#41862222">root</a><span>|</span><a href="#41862827">parent</a><span>|</span><a href="#41862830">next</a><span>|</span><label class="collapse" for="c-41863641">[-]</label><label class="expand" for="c-41863641">[2 more]</label></div><br/><div class="children"><div class="content">Fair enough. I think it would be unfortunate if the WebAssembly language in browsers were a significantly different language than WebAssembly outside of browsers (just referring to language itself, not the overall runtime system). I don&#x27;t think that has quite happened, and the outer ecosystem can probably catch up, but it worries me.</div><br/><div id="41863748" class="c"><input type="checkbox" id="c-41863748" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#41862222">root</a><span>|</span><a href="#41863641">parent</a><span>|</span><a href="#41862830">next</a><span>|</span><label class="collapse" for="c-41863748">[-]</label><label class="expand" for="c-41863748">[1 more]</label></div><br/><div class="children"><div class="content">Non-browser environments are a little behind on the Wasm standard, but not by much. E.g. wasmtime has now landed support for Wasm GC. AFAIK they implement all phase 4 proposals. Wizard implements all the Phase 4 proposals as well. The Wasm 3.0 spec will be out soon, which will be a big milestone to motivate Wasm engines outside the Web to catch up.</div><br/></div></div></div></div></div></div><div id="41862830" class="c"><input type="checkbox" id="c-41862830" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#41862222">parent</a><span>|</span><a href="#41862827">prev</a><span>|</span><a href="#41863297">next</a><span>|</span><label class="collapse" for="c-41862830">[-]</label><label class="expand" for="c-41862830">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Is there any AOT WebAssembly compiler that can compile Wasm used by websites?<p>This doesn&#x27;t really make sense, given that the wasm used by websites is going to import a bunch of JS functions as dependencies. You&#x27;re not going to have those available in any native environment.<p>&gt; Is it really the case that browsers have default-enabled all sorts of extensions that are not yet widely supported by the rest of the ecosystem?<p>Yes<p>Photoshop in particular is a good example of a bleeding edge wasm app - browsers had to relax restrictions on things like function pointer table size in order for it to work. So I wouldn&#x27;t expect it to build and run anywhere outside of v8 or spidermonkey.</div><br/><div id="41863763" class="c"><input type="checkbox" id="c-41863763" checked=""/><div class="controls bullet"><span class="by">zyedidia</span><span>|</span><a href="#41862222">root</a><span>|</span><a href="#41862830">parent</a><span>|</span><a href="#41863297">next</a><span>|</span><label class="collapse" for="c-41863763">[-]</label><label class="expand" for="c-41863763">[4 more]</label></div><br/><div class="children"><div class="content">I think one of the interesting aspects of WebAssembly compared to JavaScript is that it can be efficiently AOT-compiled. I&#x27;ve been interested in investigating AOT compilation for a browser (perhaps there is a distant&#x2F;alternative future where web browsing does not require a JIT), but maybe Wasm AOT compilers aren&#x27;t really there yet.</div><br/><div id="41864080" class="c"><input type="checkbox" id="c-41864080" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#41862222">root</a><span>|</span><a href="#41863763">parent</a><span>|</span><a href="#41863297">next</a><span>|</span><label class="collapse" for="c-41864080">[-]</label><label class="expand" for="c-41864080">[3 more]</label></div><br/><div class="children"><div class="content">Functionally what browsers do under the hood is AOT compilation but not in the way that i.e. Wasmtime is. The following is my knowledge that may no longer be accurate, but this is the sort of model we planned for when designing WASM to begin with:<p>Browsers do a on-demand &#x27;first tier&#x27; compilation for fast startup, and in the background using threads they do a high quality AOT compilation of the whole module. That high quality AOT compilation is cached and used for future page loads.<p>It is <i>possible</i> to use a JIT model for this but AFAIK it is typically not done. In some configurations (i.e. lockdown mode) WASM is interpreted instead of AOT compiled.</div><br/><div id="41866581" class="c"><input type="checkbox" id="c-41866581" checked=""/><div class="controls bullet"><span class="by">tombl</span><span>|</span><a href="#41862222">root</a><span>|</span><a href="#41864080">parent</a><span>|</span><a href="#41864180">next</a><span>|</span><label class="collapse" for="c-41866581">[-]</label><label class="expand" for="c-41866581">[1 more]</label></div><br/><div class="children"><div class="content">I believe this is still true. Originally you could store a compiled wasm module in IndexedDB and cache it manually, but that was removed in favor of {instantiate,compile}Streaming, which take a HTTP response and hook into the existing HTTP caching layer, which was already storing the compliation output for JS.</div><br/></div></div><div id="41864180" class="c"><input type="checkbox" id="c-41864180" checked=""/><div class="controls bullet"><span class="by">hencq</span><span>|</span><a href="#41862222">root</a><span>|</span><a href="#41864080">parent</a><span>|</span><a href="#41866581">prev</a><span>|</span><a href="#41863297">next</a><span>|</span><label class="collapse" for="c-41864180">[-]</label><label class="expand" for="c-41864180">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is possible to use a JIT model for this but AFAIK it is typically not done.<p>Isn&#x27;t this what the last line of the article is hinting at? 
&gt; our WebAssembly team is making great progress rearchitecting the Wasm compiler pipeline. This work will make it possible to Ion-compile individual Wasm functions as they warm up instead of compiling everything immediately.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41862493" class="c"><input type="checkbox" id="c-41862493" checked=""/><div class="controls bullet"><span class="by">icsa</span><span>|</span><a href="#41862222">prev</a><span>|</span><a href="#41862956">next</a><span>|</span><label class="collapse" for="c-41862493">[-]</label><label class="expand" for="c-41862493">[4 more]</label></div><br/><div class="children"><div class="content">Moral of the story:<p>First, use an array. 
If an array doesn&#x27;t work, try something else.</div><br/><div id="41862877" class="c"><input type="checkbox" id="c-41862877" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#41862493">parent</a><span>|</span><a href="#41863295">next</a><span>|</span><label class="collapse" for="c-41862877">[-]</label><label class="expand" for="c-41862877">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely the case that in many scenarios, the right data structure is an array, since you&#x27;ll have work dominated by gets and sets.<p>However, the OP has one scenario where the opposite was true - they were using a dense bitset that needed to be obscenely huge because of degenerate code in the wasm module, so swapping to a sparse container was a win.<p>In the end you just have to profile and understand your data.</div><br/><div id="41864194" class="c"><input type="checkbox" id="c-41864194" checked=""/><div class="controls bullet"><span class="by">icsa</span><span>|</span><a href="#41862493">root</a><span>|</span><a href="#41862877">parent</a><span>|</span><a href="#41863295">next</a><span>|</span><label class="collapse" for="c-41864194">[-]</label><label class="expand" for="c-41864194">[1 more]</label></div><br/><div class="children"><div class="content">To your point, profile your data as you would your code.<p>A sorted array of bit locations would represent a sparse bit set well enough to start, with O(N) storage and O(log N) access. Once the sets became large and&#x2F;or dense, another data structure could be considered.</div><br/></div></div></div></div></div></div><div id="41862956" class="c"><input type="checkbox" id="c-41862956" checked=""/><div class="controls bullet"><span class="by">mgaudet</span><span>|</span><a href="#41862493">prev</a><span>|</span><label class="collapse" for="c-41862956">[-]</label><label class="expand" for="c-41862956">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s too bad the title prefix &quot;75x Faster&quot; got dropped.</div><br/></div></div></div></div></div></div></div></body></html>