<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702976459616" as="style"/><link rel="stylesheet" href="styles.css?v=1702976459616"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ashvardanian.com/posts/python-c-assembly-comparison/">Python, C, Assembly – Faster Cosine Similarity</a> <span class="domain">(<a href="https://ashvardanian.com">ashvardanian.com</a>)</span></div><div class="subtext"><span>ashvardanian</span> | <span>44 comments</span></div><br/><div><div id="38693142" class="c"><input type="checkbox" id="c-38693142" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38689228">next</a><span>|</span><label class="collapse" for="c-38693142">[-]</label><label class="expand" for="c-38693142">[2 more]</label></div><br/><div class="children"><div class="content">&gt; C is the lowest-level hardware-agnostic programming language<p>Not really, plenty of other ones offer similar capabilities.<p>&gt;  Unlike C++, however, C doesn’t support “generics” or “template functions”.<p>It does support a light version of them via _Generic.</div><br/><div id="38693243" class="c"><input type="checkbox" id="c-38693243" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38693142">parent</a><span>|</span><a href="#38689228">next</a><span>|</span><label class="collapse" for="c-38693243">[-]</label><label class="expand" for="c-38693243">[1 more]</label></div><br/><div class="children"><div class="content">`_Generic` is more akin to type switches, and generics or templates generally refer to an ability to instantiate multiple functions on demand.</div><br/></div></div></div></div><div id="38689228" class="c"><input type="checkbox" id="c-38689228" checked=""/><div class="controls bullet"><span class="by">costco</span><span>|</span><a href="#38693142">prev</a><span>|</span><a href="#38689274">next</a><span>|</span><label class="collapse" for="c-38689228">[-]</label><label class="expand" for="c-38689228">[2 more]</label></div><br/><div class="children"><div class="content">Well now I know I have a bunch of software I want to try <a href="https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;</a>.  The author is definitely brilliant.<p>I should benchmark <a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;SimSIMD&#x2F;blob&#x2F;main&#x2F;include&#x2F;simsimd&#x2F;spatial.h#L841">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;SimSIMD&#x2F;blob&#x2F;main&#x2F;include&#x2F;si...</a> and see if it&#x27;s any faster than what hnswlib currently uses for bruteforce IP search because I&#x27;m currently using hnswlib in something and it&#x27;s become a bottleneck.  Or maybe I&#x27;ll just try usearch directly.</div><br/><div id="38690129" class="c"><input type="checkbox" id="c-38690129" checked=""/><div class="controls bullet"><span class="by">syrusakbary</span><span>|</span><a href="#38689228">parent</a><span>|</span><a href="#38689274">next</a><span>|</span><label class="collapse" for="c-38690129">[-]</label><label class="expand" for="c-38690129">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, the work that Ash and team are doing with Unum is excellent!</div><br/></div></div></div></div><div id="38689274" class="c"><input type="checkbox" id="c-38689274" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38689228">prev</a><span>|</span><a href="#38691492">next</a><span>|</span><label class="collapse" for="c-38689274">[-]</label><label class="expand" for="c-38689274">[4 more]</label></div><br/><div class="children"><div class="content">The hardest (still missing) part of efficient cosine computation distance computation is picking a good epsilon for the `sqrt` calculation and avoiding &quot;division by zero&quot; problems.<p>We have an open issue about it in USearch and a related one in SimSIMD itself, so if you have any suggestions, please share your insights - they would impact millions of devices using the library (directly on servers and mobile, and through projects like ClickHouse and some of the Google repos): <a href="https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;usearch&#x2F;issues&#x2F;320">https:&#x2F;&#x2F;github.com&#x2F;unum-cloud&#x2F;usearch&#x2F;issues&#x2F;320</a></div><br/><div id="38689893" class="c"><input type="checkbox" id="c-38689893" checked=""/><div class="controls bullet"><span class="by">kridsdale3</span><span>|</span><a href="#38689274">parent</a><span>|</span><a href="#38691492">next</a><span>|</span><label class="collapse" for="c-38689893">[-]</label><label class="expand" for="c-38689893">[3 more]</label></div><br/><div class="children"><div class="content">I just did a skim, and it looks like you&#x27;re essentially seeing the limits of IEE 754 resolution at that scale (10 ^ -130). Theoretically they can store +&#x2F;- 308 base-10 exponential range, but only about 17 decimal digits of precision.<p>Floats were designed to be mostly-reliable within a mostly-reasonable range of numbers for the kinds of systems we deal with in our scale of the universe. The scale probed here is far far beyond Plank-scale if dealing with metric measurements. We have the converse issue (even with 64bit) at large scales. I could make a geometric vector in space from here to a rock on a planet 15 billion light years away, and another vector to an adjacent rock. I bet those would have a nondeterministic cosine issue too.<p>I guess a solution is FP 128, or beyond.</div><br/><div id="38690027" class="c"><input type="checkbox" id="c-38690027" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38689274">root</a><span>|</span><a href="#38689893">parent</a><span>|</span><a href="#38691469">next</a><span>|</span><label class="collapse" for="c-38690027">[-]</label><label class="expand" for="c-38690027">[1 more]</label></div><br/><div class="children"><div class="content">Kahan floats are also commonly used in such cases, but I believe there is room for improvement without hitting those extremes. First of all, we should tune the epsilon here: <a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;SimSIMD&#x2F;blob&#x2F;f8ff727dcddcd142e7e8dece33c43801af96c210&#x2F;include&#x2F;simsimd&#x2F;spatial.h#L893">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;SimSIMD&#x2F;blob&#x2F;f8ff727dcddcd14...</a><p>As for the 64-bit version, its harder, as the higher-precision `rsqrt` approximations are only available with &quot;AVX512ER&quot;. I&#x27;m not sure which CPUs support that, but its not available on Sapphire Rapids.</div><br/></div></div><div id="38691469" class="c"><input type="checkbox" id="c-38691469" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#38689274">root</a><span>|</span><a href="#38689893">parent</a><span>|</span><a href="#38690027">prev</a><span>|</span><a href="#38691492">next</a><span>|</span><label class="collapse" for="c-38691469">[-]</label><label class="expand" for="c-38691469">[1 more]</label></div><br/><div class="children"><div class="content">Why would floats for cosine similarity need to support ranges beyond Planck scale?</div><br/></div></div></div></div></div></div><div id="38691492" class="c"><input type="checkbox" id="c-38691492" checked=""/><div class="controls bullet"><span class="by">guyomes</span><span>|</span><a href="#38689274">prev</a><span>|</span><a href="#38690464">next</a><span>|</span><label class="collapse" for="c-38691492">[-]</label><label class="expand" for="c-38691492">[4 more]</label></div><br/><div class="children"><div class="content">I wonder if this code could be even further speed up, by taking into account the througput versus the latency of the FMA operator. If the latency is 4 cycles and the througput is 0.5 cycle for example, that means that doing n dependent operation will cost 4n cycles, and n independent operations will cost 0.5 cycles, that is an 8x speed up. By dependent operation, I mean that the input of an operation depends on the output the previous operation.<p>In the current final code, each loop has 3 independent FMAs. And in each loop iteration, the 3 FMAs are dependent on the FMAs from the previous iteration.<p>So one thing that could speed up the computation is to do 6 independent FMAs per loop iteration instead of 3. This can be done as follow. Instead of doing cumulative sums from 0 to n-1, one could split the computation of the cumulative sums from 0 to n&#x2F;2-1 and from n&#x2F;2 to n-1. So the main loop goes only from 0 to n&#x2F;2-1, and at the k-th loop iteration, we do the 2x3 FMAs corresponding the entries of indices k and n&#x2F;2+k. And at the end we add the cumulative sums.</div><br/><div id="38691975" class="c"><input type="checkbox" id="c-38691975" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38691492">parent</a><span>|</span><a href="#38690464">next</a><span>|</span><label class="collapse" for="c-38691975">[-]</label><label class="expand" for="c-38691975">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had a similar hypothesis, but it didn&#x27;t work out for me, only bloating the codebase. Please lmk if you have a different outcome :)</div><br/><div id="38692631" class="c"><input type="checkbox" id="c-38692631" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#38691492">root</a><span>|</span><a href="#38691975">parent</a><span>|</span><a href="#38690464">next</a><span>|</span><label class="collapse" for="c-38692631">[-]</label><label class="expand" for="c-38692631">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about this code in particular but if you&#x27;re mostly doing math you tend to run out of architectural registers before you achieve the full throughput of the instructions you care about :(</div><br/><div id="38693089" class="c"><input type="checkbox" id="c-38693089" checked=""/><div class="controls bullet"><span class="by">guyomes</span><span>|</span><a href="#38691492">root</a><span>|</span><a href="#38692631">parent</a><span>|</span><a href="#38690464">next</a><span>|</span><label class="collapse" for="c-38693089">[-]</label><label class="expand" for="c-38693089">[1 more]</label></div><br/><div class="children"><div class="content">That makes sense. I did observe significant speed up using this technic for evaluating a polynomial on several values. I used Hörner algorithm and indeed the number of registers is very small in this case.<p>If the lack of registers is really the bottleneck, a variant might to use both zmm registers for some cumulative sums and ymm registers for some others. In this case the speed up might be less spectacular though.<p>Edit: actually, I just discovered that zmm registers overlap the ymm registers, so the only registers left are the ones from the FPU.</div><br/></div></div></div></div></div></div></div></div><div id="38690464" class="c"><input type="checkbox" id="c-38690464" checked=""/><div class="controls bullet"><span class="by">eachro</span><span>|</span><a href="#38691492">prev</a><span>|</span><a href="#38692669">next</a><span>|</span><label class="collapse" for="c-38690464">[-]</label><label class="expand" for="c-38690464">[2 more]</label></div><br/><div class="children"><div class="content">Can someone explain why the numpy code ends up being so slow? Is the author actually doing things in a vectorized manner or just looping over np arrays instead of lists? It&#x27;s hard to tell from the info given.</div><br/><div id="38691327" class="c"><input type="checkbox" id="c-38691327" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#38690464">parent</a><span>|</span><a href="#38692669">next</a><span>|</span><label class="collapse" for="c-38691327">[-]</label><label class="expand" for="c-38691327">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Here’s a tip: If you’re using NumPy, go all in. Mixing it with regular Python can really slow you down!<p>It looks like they shoved numpy arrays into the place native Python containers used to occupy. They incurred more of a slowdown than you might naively have expected from that particular obvious error.<p>Unrelated to this article, numpy is often a lot slower than expected even when used &quot;correctly.&quot; Major culprits include order of operations (compared to the ideal &#x2F; forced by the API &#x2F; when you think vectorization automagically makes a bad order of operations fast), allocations, memory bandwidth, kernels optimized for a dimension other than the one you care about, kernels optimized for a use case other than the one you care about, and improper installation (appropriately linking fast BLAS&#x2F;LAPACK objects).<p>Most of those sins are rectifiable without any major change in coding habits by wrapping your nightmares in `jax.jit` or `torch.compile`, but if your devs are writing the sort of code that makes those things _necessary_ (rather than just nice-to-haves) then that probably still won&#x27;t solve your problems.</div><br/></div></div></div></div><div id="38692669" class="c"><input type="checkbox" id="c-38692669" checked=""/><div class="controls bullet"><span class="by">farhanhubble</span><span>|</span><a href="#38690464">prev</a><span>|</span><a href="#38688293">next</a><span>|</span><label class="collapse" for="c-38692669">[-]</label><label class="expand" for="c-38692669">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s some good benchmarking however doing this kind of optimization at scale is impossible. Because<p>1- Going from correct to fast is simple but the other direction is full of misery.<p>2- Optimizations are super super input and hardware specific.</div><br/><div id="38692861" class="c"><input type="checkbox" id="c-38692861" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38692669">parent</a><span>|</span><a href="#38688293">next</a><span>|</span><label class="collapse" for="c-38692861">[-]</label><label class="expand" for="c-38692861">[1 more]</label></div><br/><div class="children"><div class="content">1 - Very true, but in some ways its helpful, as provides an opportunity to highlight some of the poorly setup constraints in downstream applications. Like changing the compiler used for a major project, and seeing a 1000 warnings at once. In this case, the applications that will suffer are the ones that compares floats and float-arrays without absolute and relative tolerance intervals.<p>2 - Also true, but the SimSIMD library covers the absolute majority of mobile, desktop, and server CPUs produced in the last years.</div><br/></div></div></div></div><div id="38688293" class="c"><input type="checkbox" id="c-38688293" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#38692669">prev</a><span>|</span><a href="#38689908">next</a><span>|</span><label class="collapse" for="c-38688293">[-]</label><label class="expand" for="c-38688293">[2 more]</label></div><br/><div class="children"><div class="content">Very nice job! I love these kinds of optimizations. I wonder if we&#x27;ll get to a compiler that can do it by itself.<p>Looks like you&#x27;re missing a square root in the zip-Python version. Does that affect runtime?</div><br/><div id="38689123" class="c"><input type="checkbox" id="c-38689123" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38688293">parent</a><span>|</span><a href="#38689908">next</a><span>|</span><label class="collapse" for="c-38689123">[-]</label><label class="expand" for="c-38689123">[1 more]</label></div><br/><div class="children"><div class="content">Oh, right, forgot to put it there. If anything, it would make the Python version only slower, and the point bolder :)</div><br/></div></div></div></div><div id="38689908" class="c"><input type="checkbox" id="c-38689908" checked=""/><div class="controls bullet"><span class="by">jonesnc</span><span>|</span><a href="#38688293">prev</a><span>|</span><a href="#38691888">next</a><span>|</span><label class="collapse" for="c-38689908">[-]</label><label class="expand" for="c-38689908">[2 more]</label></div><br/><div class="children"><div class="content">If the author of the article sees this, this link in the table of contents doesn&#x27;t work:<p><a href="https:&#x2F;&#x2F;ashvardanian.com&#x2F;posts&#x2F;python-c-assembly-comparison&#x2F;#vnni" rel="nofollow noreferrer">https:&#x2F;&#x2F;ashvardanian.com&#x2F;posts&#x2F;python-c-assembly-comparison&#x2F;...</a></div><br/><div id="38689982" class="c"><input type="checkbox" id="c-38689982" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38689908">parent</a><span>|</span><a href="#38691888">next</a><span>|</span><label class="collapse" for="c-38689982">[-]</label><label class="expand" for="c-38689982">[1 more]</label></div><br/><div class="children"><div class="content">Patched, thanks!</div><br/></div></div></div></div><div id="38691888" class="c"><input type="checkbox" id="c-38691888" checked=""/><div class="controls bullet"><span class="by">nilslindemann</span><span>|</span><a href="#38689908">prev</a><span>|</span><a href="#38690071">next</a><span>|</span><label class="collapse" for="c-38691888">[-]</label><label class="expand" for="c-38691888">[2 more]</label></div><br/><div class="children"><div class="content">&quot;As pointed on HackerNews, I forgot to apply the square root for magnitude_a and magnitude_b.&quot;<p>Does that mean the example above this sentence is fixed, or does it mean it is wrong?</div><br/><div id="38691999" class="c"><input type="checkbox" id="c-38691999" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38691888">parent</a><span>|</span><a href="#38690071">next</a><span>|</span><label class="collapse" for="c-38691999">[-]</label><label class="expand" for="c-38691999">[1 more]</label></div><br/><div class="children"><div class="content">The latency of the operation will be slightly higher if we add the `sqrt`, only making the difference bigger... bigger than 2500x.<p>PS: Even though it wasn&#x27;t intended in that specific case,  square roots are often avoided in vector search, most commonly in Euclidean distance computations. Even without the square root, the triangle inequality holds, you can use it to find the closest object, it&#x27;s just you don&#x27;t know how close it is :)</div><br/></div></div></div></div><div id="38690071" class="c"><input type="checkbox" id="c-38690071" checked=""/><div class="controls bullet"><span class="by">comfymatrix</span><span>|</span><a href="#38691888">prev</a><span>|</span><a href="#38690186">next</a><span>|</span><label class="collapse" for="c-38690071">[-]</label><label class="expand" for="c-38690071">[1 more]</label></div><br/><div class="children"><div class="content">Great article! Shame it left me curious to know how a further implementation using more pure Assembly would’ve performed vs using intrinsics. Anyone know or is it easy to just assume “faster”?</div><br/></div></div><div id="38690186" class="c"><input type="checkbox" id="c-38690186" checked=""/><div class="controls bullet"><span class="by">logtempo</span><span>|</span><a href="#38690071">prev</a><span>|</span><a href="#38690210">next</a><span>|</span><label class="collapse" for="c-38690186">[-]</label><label class="expand" for="c-38690186">[3 more]</label></div><br/><div class="children"><div class="content">Remind me of an article about the opimization of matrix calculus with IA, that eventually shown better algorithm for specific size of matrix, than the one found decades ago and proven to be the best one.</div><br/><div id="38691510" class="c"><input type="checkbox" id="c-38691510" checked=""/><div class="controls bullet"><span class="by">EliasLittle</span><span>|</span><a href="#38690186">parent</a><span>|</span><a href="#38690210">next</a><span>|</span><label class="collapse" for="c-38691510">[-]</label><label class="expand" for="c-38691510">[2 more]</label></div><br/><div class="children"><div class="content">What’s IA stand for? This sounds like an interesting article, I wanna try to find it</div><br/><div id="38692152" class="c"><input type="checkbox" id="c-38692152" checked=""/><div class="controls bullet"><span class="by">fancy_pantser</span><span>|</span><a href="#38690186">root</a><span>|</span><a href="#38691510">parent</a><span>|</span><a href="#38690210">next</a><span>|</span><label class="collapse" for="c-38692152">[-]</label><label class="expand" for="c-38692152">[1 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s a typo and they meant to say &quot;AI&quot;, then I may be remembering the article(s) being alluded to:<p>&gt; AlphaTensor discovered algorithms that outperform the state-of-the-art complexity for many matrix sizes. Particularly relevant is the case of 4 × 4 matrices in a finite field, where AlphaTensor’s algorithm improves on Strassen’s two-level algorithm for the first time, to our knowledge, since its discovery 50 years ago.<p><a href="https:&#x2F;&#x2F;towardsdatascience.com&#x2F;how-deepmind-discovered-new-ways-of-multiplying-matrices-using-ai-a04557e9f861" rel="nofollow noreferrer">https:&#x2F;&#x2F;towardsdatascience.com&#x2F;how-deepmind-discovered-new-w...</a><p><a href="https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;s41586-022-05172-4" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;s41586-022-05172-4</a></div><br/></div></div></div></div></div></div><div id="38690210" class="c"><input type="checkbox" id="c-38690210" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#38690186">prev</a><span>|</span><a href="#38687967">next</a><span>|</span><label class="collapse" for="c-38690210">[-]</label><label class="expand" for="c-38690210">[1 more]</label></div><br/><div class="children"><div class="content">Just want to thank the author for writing Python using snake_case, which is what a sensible, well-educated engineer should do.</div><br/></div></div><div id="38687967" class="c"><input type="checkbox" id="c-38687967" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#38690210">prev</a><span>|</span><a href="#38688660">next</a><span>|</span><label class="collapse" for="c-38687967">[-]</label><label class="expand" for="c-38687967">[10 more]</label></div><br/><div class="children"><div class="content">Apropos of nothing, that is a horrible use of goto.<p>The code would be clearer as a do { } while(n); instead--it&#x27;s just a bottom-tested loop, which isn&#x27;t that uncommon. (I guess the author may just be unfamiliar with do&#x2F;while loops?)</div><br/><div id="38689185" class="c"><input type="checkbox" id="c-38689185" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38687967">parent</a><span>|</span><a href="#38688205">next</a><span>|</span><label class="collapse" for="c-38689185">[-]</label><label class="expand" for="c-38689185">[1 more]</label></div><br/><div class="children"><div class="content">There are several `do {} while ()` loops in the SimSIMD codebase, mostly in SVE [1]. One of the reasons I don&#x27;t like putting them in many places - mostly in cases with complex conditions, but also to avoid adding one more level of nesting for that scope.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;SimSIMD&#x2F;blob&#x2F;f8ff727dcddcd142e7e8dece33c43801af96c210&#x2F;include&#x2F;simsimd&#x2F;binary.h#L118">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;SimSIMD&#x2F;blob&#x2F;f8ff727dcddcd14...</a></div><br/></div></div><div id="38688205" class="c"><input type="checkbox" id="c-38688205" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#38687967">parent</a><span>|</span><a href="#38689185">prev</a><span>|</span><a href="#38688871">next</a><span>|</span><label class="collapse" for="c-38688205">[-]</label><label class="expand" for="c-38688205">[1 more]</label></div><br/><div class="children"><div class="content">I came to say something similar, though I would use:<p><pre><code>  while (1) {
    ...
    if (!n) {
     ...
     return 1 - ab * rsqrt_a2 * rsqrt_b2;
    }
  }
</code></pre>
Also, the &quot;So let’s use the common Pythonic zip idiom:&quot; version is missing the sqrt calls so doesn&#x27;t give the same answer as the first version.</div><br/></div></div><div id="38688871" class="c"><input type="checkbox" id="c-38688871" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#38687967">parent</a><span>|</span><a href="#38688205">prev</a><span>|</span><a href="#38688136">next</a><span>|</span><label class="collapse" for="c-38688871">[-]</label><label class="expand" for="c-38688871">[6 more]</label></div><br/><div class="children"><div class="content">Do you really think it’s likely that someone who uses SIMD intrinsic is unfamiliar with do…while loops?<p>It’s more likely that compilers generate better autovectorised code with a goto, even though they’re semantically the same.</div><br/><div id="38688976" class="c"><input type="checkbox" id="c-38688976" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#38687967">root</a><span>|</span><a href="#38688871">parent</a><span>|</span><a href="#38688923">next</a><span>|</span><label class="collapse" for="c-38688976">[-]</label><label class="expand" for="c-38688976">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It’s more likely that compilers generate better autovectorised code with a goto, even though they’re semantically the same.<p>No, it&#x27;s not. Most compiler IRs will work on a basic block representation, where the compiler will reduce all control flow to unconditional and conditional jumps. If they&#x27;re not working on that level, then they likely have some form of structure control flow, where autovectorization will ignore gotos entirely because they&#x27;re the definition of unstructured control flow, so they won&#x27;t notice when the goto forms a loop that could be autovectorized.</div><br/><div id="38689362" class="c"><input type="checkbox" id="c-38689362" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#38687967">root</a><span>|</span><a href="#38688976">parent</a><span>|</span><a href="#38688923">next</a><span>|</span><label class="collapse" for="c-38689362">[-]</label><label class="expand" for="c-38689362">[2 more]</label></div><br/><div class="children"><div class="content">Maybe, but in my experience gcc is, and clang to a lesser extent, is notoriously useless at autovectorisation unless you hold its hand all the way.
Even things like changing an ‘int’ to a ‘bool’ can throw it off completely.</div><br/><div id="38689518" class="c"><input type="checkbox" id="c-38689518" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38687967">root</a><span>|</span><a href="#38689362">parent</a><span>|</span><a href="#38688923">next</a><span>|</span><label class="collapse" for="c-38689518">[-]</label><label class="expand" for="c-38689518">[1 more]</label></div><br/><div class="children"><div class="content">That matches my experience, and goes beyond GCC and Clang. Between 2018 and 2020 I was giving a lot of lectures on this topic and we did a bunch of case studies with Intel on their older ICC and what later became the OneAPI.<p>Short story, unless you are doing trivial data-parallel operations, like in SimSIMD, compilers are practically useless. As a proof, I wrote what is now the StringZilla library (<a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;stringzilla">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;stringzilla</a>) and we&#x27;ve spent weeks with an Intel team, tuning the compiler, no result. So if you are processing a lot of strings, or variable-length coded data, like compression&#x2F;decompression, hand-written SIMD kernels are pretty much unbeatable.</div><br/></div></div></div></div></div></div><div id="38688923" class="c"><input type="checkbox" id="c-38688923" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#38687967">root</a><span>|</span><a href="#38688871">parent</a><span>|</span><a href="#38688976">prev</a><span>|</span><a href="#38688136">next</a><span>|</span><label class="collapse" for="c-38688923">[-]</label><label class="expand" for="c-38688923">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Do you really think it’s likely that someone who uses SIMD intrinsic is unfamiliar with do…while loops?<p>You don&#x27;t have to think them unfamiliar to recommend it. Sometimes very skilled people can forget to apply a particular style of control flow, even if they&#x27;re otherwise experts - everybody makes mistakes.</div><br/><div id="38689549" class="c"><input type="checkbox" id="c-38689549" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#38687967">root</a><span>|</span><a href="#38688923">parent</a><span>|</span><a href="#38688136">next</a><span>|</span><label class="collapse" for="c-38689549">[-]</label><label class="expand" for="c-38689549">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve just wasted a day of benchmarks, because in one of my major ongoing refactoring efforts a compilation flag wasn&#x27;t propagated to the needed target - so I definitely make a lot of mistakes :)<p>As for `do`&#x2F;`while` keywords, its just a preference, but feel free to recommend more patches - I&#x27;m always happy to see new contributors - it&#x27;s a luxury in low-level projects :)</div><br/></div></div></div></div></div></div></div></div><div id="38688660" class="c"><input type="checkbox" id="c-38688660" checked=""/><div class="controls bullet"><span class="by">ladberg</span><span>|</span><a href="#38687967">prev</a><span>|</span><label class="collapse" for="c-38688660">[-]</label><label class="expand" for="c-38688660">[6 more]</label></div><br/><div class="children"><div class="content">Am I understanding correctly that the Numpy one doesn&#x27;t actually use Numpy to do the calculation, but just to store the data? If so that&#x27;s a super disingenuous example. The speed of Numpy comes from being able to stay in C for the entire hot loop.<p>EDIT: I tested it myself, also using ChatGPT to code it for me.<p>&gt;&gt;&gt; can you write a cosine distance function using numpy?<p><pre><code>    def cosine_distance(vector1, vector2):
        dot_product = np.dot(vector1, vector2)
        norm_vector1 = np.linalg.norm(vector1)
        norm_vector2 = np.linalg.norm(vector2)
        cosine_similarity = dot_product &#x2F; (norm_vector1 * norm_vector2)
        cosine_distance = 1 - cosine_similarity
        return cosine_distance
</code></pre>
The original list one takes 161us on my machine, passing a Numpy array to the original function takes 750us, and using the native Numpy function takes 6.24us.<p>Using Numpy correctly makes it &gt;100x faster!</div><br/><div id="38688940" class="c"><input type="checkbox" id="c-38688940" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#38688660">parent</a><span>|</span><a href="#38689918">next</a><span>|</span><label class="collapse" for="c-38688940">[-]</label><label class="expand" for="c-38688940">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the Numpy example is bad. He should try something like,<p><pre><code>  1 - np.dot(a,b) &#x2F; (np.linalg.norm(a) * np.linalg.norm(b))</code></pre></div><br/><div id="38689177" class="c"><input type="checkbox" id="c-38689177" checked=""/><div class="controls bullet"><span class="by">arthurcolle</span><span>|</span><a href="#38688660">root</a><span>|</span><a href="#38688940">parent</a><span>|</span><a href="#38689918">next</a><span>|</span><label class="collapse" for="c-38689177">[-]</label><label class="expand" for="c-38689177">[1 more]</label></div><br/><div class="children"><div class="content">I implemented cosine similarity too in the last week or two for something and the 1- threw me for a loop until I looked at the math for another 15 seconds, realized that it didn&#x27;t make much sense for &quot;Cat&quot; and &quot;Cat&quot; to have 0 similarity haha</div><br/></div></div></div></div><div id="38689918" class="c"><input type="checkbox" id="c-38689918" checked=""/><div class="controls bullet"><span class="by">rdedev</span><span>|</span><a href="#38688660">parent</a><span>|</span><a href="#38688940">prev</a><span>|</span><a href="#38689030">next</a><span>|</span><label class="collapse" for="c-38689918">[-]</label><label class="expand" for="c-38689918">[1 more]</label></div><br/><div class="children"><div class="content">So following the numpy example the author gives one using scipy. This should be the same if not faster than a pure numpy implementation</div><br/></div></div><div id="38689030" class="c"><input type="checkbox" id="c-38689030" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#38688660">parent</a><span>|</span><a href="#38689918">prev</a><span>|</span><a href="#38689466">next</a><span>|</span><label class="collapse" for="c-38689030">[-]</label><label class="expand" for="c-38689030">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll probably want to use a function to normalize vectors if you don&#x27;t want it to barf when you accidentally put something close to a 0 vector in there.</div><br/></div></div></div></div></div></div></div></div></div></body></html>