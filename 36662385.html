<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688979649196" as="style"/><link rel="stylesheet" href="styles.css?v=1688979649196"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.fuzzypixelz.com/blog/deref-confusion/">Mistakes with Rust smart pointers: when Deref goes wrong</a> <span class="domain">(<a href="https://www.fuzzypixelz.com">www.fuzzypixelz.com</a>)</span></div><div class="subtext"><span>xy2_</span> | <span>18 comments</span></div><br/><div><div id="36662727" class="c"><input type="checkbox" id="c-36662727" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#36662835">next</a><span>|</span><label class="collapse" for="c-36662727">[-]</label><label class="expand" for="c-36662727">[3 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;ve hit the same kind of problem once. What I learned is that true smart pointers are types that (at least in Rust) aren&#x27;t really supposed to have methods on their own, to avoid this type of ambiguity during method resolution.<p>For example, Box&lt;T&gt; implements Deref so that you can conveniently use T&#x27;s methods. If you look at the documentation of Box, the things you can do with the Box <i>itself</i>, like Box::leak, are non-method functions. This means that you always have to qualify them, like Box::leak(my_box), and thus you can&#x27;t get this type of conflict.<p>Using Deref for types like String or Vec doesn&#x27;t really fall into this category. They implement something more analogous to an &quot;is-a relationship&quot; in OO. Even outside of those examples, I&#x27;ve seen people manually implement inheritance-like behavior, using Deref to delegate to a field that stores the &quot;base class&quot; instance.<p>If you do that, you&#x27;re likely to have a name conflict between the two types sooner rather than later. That&#x27;s fine as long as you&#x27;re aware that Rust doesn&#x27;t really do overload resolution -- AFAICT, the &quot;outer&quot; methods always wins regardless of the arguments at the call site.</div><br/><div id="36663436" class="c"><input type="checkbox" id="c-36663436" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#36662727">parent</a><span>|</span><a href="#36662835">next</a><span>|</span><label class="collapse" for="c-36663436">[-]</label><label class="expand" for="c-36663436">[2 more]</label></div><br/><div class="children"><div class="content">This feels analogous to <i>hiding</i> in C++. In C++ by default member functions in a base class don&#x27;t overload with member functions of the same name in a derived class. They get hidden.</div><br/><div id="36663614" class="c"><input type="checkbox" id="c-36663614" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#36662727">root</a><span>|</span><a href="#36663436">parent</a><span>|</span><a href="#36662835">next</a><span>|</span><label class="collapse" for="c-36663614">[-]</label><label class="expand" for="c-36663614">[1 more]</label></div><br/><div class="children"><div class="content">Not disagreeing with you but what&#x27;s interesting is that C++ doesn&#x27;t hide in this particularly situation. Smart pointers implement operator-&gt; and operator* but then ptr.foo() is still <i>always</i> the foo() method of the pointer type (and won&#x27;t compile if it doesn&#x27;t have it) - you need ptr-&gt;foo() or (*ptr).foo() to get the method of the pointed-to type.<p>It&#x27;s one of the few places that C++ is more explicit than Rust. I wonder if there&#x27;s a reason Rust went a different way? I&#x27;m mainly a C++ programmer so I&#x27;m genuinely curious.</div><br/></div></div></div></div></div></div><div id="36662835" class="c"><input type="checkbox" id="c-36662835" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36662727">prev</a><span>|</span><a href="#36662675">next</a><span>|</span><label class="collapse" for="c-36662835">[-]</label><label class="expand" for="c-36662835">[5 more]</label></div><br/><div class="children"><div class="content"><i>&quot;The issue, it turns out, is that method search does not check method parameter types against argument types.&quot;</i><p>Right. Rust&#x27;s doesn&#x27;t allow much overloading of function names. Partly because C++ did. The C++ overload resolution rules got very complex, especially since they interact with implicit conversions. To keep those rules from introducing errors, there&#x27;s a rule in C++ that the overload chosen must be at least one step &quot;better&quot; than any matching alternative. Something that was supposed to make thing simpler thus became very complicated.<p>So Rust makes the programmer write that stuff out, which is more verbose but less confusing.</div><br/><div id="36662955" class="c"><input type="checkbox" id="c-36662955" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36662835">parent</a><span>|</span><a href="#36662675">next</a><span>|</span><label class="collapse" for="c-36662955">[-]</label><label class="expand" for="c-36662955">[4 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;ve had equally confusing compile errors from C++ due to its lookup rules. For example removing an unused parameter from a function can cause that function not to be found anymore! I&#x27;d argue that is more confusing than this Rust issue.</div><br/><div id="36663147" class="c"><input type="checkbox" id="c-36663147" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#36662835">root</a><span>|</span><a href="#36662955">parent</a><span>|</span><a href="#36662675">next</a><span>|</span><label class="collapse" for="c-36663147">[-]</label><label class="expand" for="c-36663147">[3 more]</label></div><br/><div class="children"><div class="content">What does this comment mean? Function parameters used or not are part of the function signature, so obviously would participate in any form of argument dependent lookup.</div><br/><div id="36663273" class="c"><input type="checkbox" id="c-36663273" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#36662835">root</a><span>|</span><a href="#36663147">parent</a><span>|</span><a href="#36663384">next</a><span>|</span><label class="collapse" for="c-36663273">[-]</label><label class="expand" for="c-36663273">[1 more]</label></div><br/><div class="children"><div class="content">I mean, you can do as small a change as adding a const somewhere, and cause an (almost) independent file somewhere else in your codebase to hit the wrong overload.</div><br/></div></div><div id="36663384" class="c"><input type="checkbox" id="c-36663384" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#36662835">root</a><span>|</span><a href="#36663147">parent</a><span>|</span><a href="#36663273">prev</a><span>|</span><a href="#36662675">next</a><span>|</span><label class="collapse" for="c-36663384">[-]</label><label class="expand" for="c-36663384">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps a case where after removing the unused parameter and updating all the call sites, none of the calls resolve to the original function anymore.</div><br/></div></div></div></div></div></div></div></div><div id="36662675" class="c"><input type="checkbox" id="c-36662675" checked=""/><div class="controls bullet"><span class="by">agalunar</span><span>|</span><a href="#36662835">prev</a><span>|</span><a href="#36662690">next</a><span>|</span><label class="collapse" for="c-36662675">[-]</label><label class="expand" for="c-36662675">[3 more]</label></div><br/><div class="children"><div class="content">In case the author happens to see this thread – there seems to be a missing less-than sign:<p><pre><code>    str::from_utf8( as Deref&gt;::deref(&amp;self.0))
</code></pre>
Thanks for the article! ^_^</div><br/><div id="36663514" class="c"><input type="checkbox" id="c-36663514" checked=""/><div class="controls bullet"><span class="by">fuzzypixelz</span><span>|</span><a href="#36662675">parent</a><span>|</span><a href="#36663600">next</a><span>|</span><label class="collapse" for="c-36663514">[-]</label><label class="expand" for="c-36663514">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re welcome :)<p>I finally found out what was going wrong here. All angle brackets and other characters were being escaped in other parts of the document, even in &lt;code&gt;&lt;&#x2F;code&gt; blocks. Except when it came to code blocks inside &lt;pre&gt;&lt;&#x2F;pre&gt; blocks.<p>For context, I use Zola and Cloudflare pages.<p>It turns out there is a bug[^0] in Zola 1.40.0 which reads:<p>&gt; Fix code blocks content not being escaped when not using syntax highlighting<p>I presume that this is the culprit, as I use an external syntax highlighting library.<p>Cloudflare Pages has been famously sluggish with updating the Zola version. For reference, 1.14.0 was released in July 2021.<p>This explains why everything was working fine on my machine™.<p>Thanks for pointing this out, though I unsure how to work around it without changing my setup.<p>[^0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;zola&#x2F;blob&#x2F;master&#x2F;CHANGELOG.md#0141-2021-08-24">https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;zola&#x2F;blob&#x2F;master&#x2F;CHANGELOG.md#014...</a></div><br/></div></div></div></div><div id="36662690" class="c"><input type="checkbox" id="c-36662690" checked=""/><div class="controls bullet"><span class="by">n8henrie</span><span>|</span><a href="#36662675">prev</a><span>|</span><a href="#36663257">next</a><span>|</span><label class="collapse" for="c-36662690">[-]</label><label class="expand" for="c-36662690">[3 more]</label></div><br/><div class="children"><div class="content">Typo: `impl Index&gt; for AsciiString`</div><br/><div id="36662939" class="c"><input type="checkbox" id="c-36662939" checked=""/><div class="controls bullet"><span class="by">veber-alex</span><span>|</span><a href="#36662690">parent</a><span>|</span><a href="#36663257">next</a><span>|</span><label class="collapse" for="c-36662939">[-]</label><label class="expand" for="c-36662939">[2 more]</label></div><br/><div class="children"><div class="content">There are a bunch of typos and missing generics all over the place, looks like something there doesn&#x27;t like angle brackets.</div><br/><div id="36663015" class="c"><input type="checkbox" id="c-36663015" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36662690">root</a><span>|</span><a href="#36662939">parent</a><span>|</span><a href="#36663257">next</a><span>|</span><label class="collapse" for="c-36663015">[-]</label><label class="expand" for="c-36663015">[1 more]</label></div><br/><div class="children"><div class="content">Possibly an HTML-transparent toolchain, something like the original markdown use case would likely have this sort of effect (as HTML transparency was a feature to Gruber).</div><br/></div></div></div></div></div></div><div id="36663257" class="c"><input type="checkbox" id="c-36663257" checked=""/><div class="controls bullet"><span class="by">thatxliner</span><span>|</span><a href="#36662690">prev</a><span>|</span><a href="#36663179">next</a><span>|</span><label class="collapse" for="c-36663257">[-]</label><label class="expand" for="c-36663257">[1 more]</label></div><br/><div class="children"><div class="content">That was a good read</div><br/></div></div><div id="36663179" class="c"><input type="checkbox" id="c-36663179" checked=""/><div class="controls bullet"><span class="by">spacesuitman2</span><span>|</span><a href="#36663257">prev</a><span>|</span><a href="#36663318">next</a><span>|</span><label class="collapse" for="c-36663179">[-]</label><label class="expand" for="c-36663179">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Rather, it only checks for method names and where-clauses such as T: Trait. Types are only resolved in the confirm phase, at which point rustc would have already picked its method.<p>Not following here, the compiler iterates over the deref-chain and acquires a list of method names, but it also &quot;checks for ... where-clauses&quot;, what does that mean? A quick look at the linked probe code indicates what we filter on Self traits and return value traits.</div><br/></div></div></div></div></div></div></div></body></html>