<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722416514608" as="style"/><link rel="stylesheet" href="styles.css?v=1722416514608"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://porffor.dev/">Porffor: A from-scratch experimental ahead-of-time JS engine</a> <span class="domain">(<a href="https://porffor.dev">porffor.dev</a>)</span></div><div class="subtext"><span>bpierre</span> | <span>83 comments</span></div><br/><div><div id="41113549" class="c"><input type="checkbox" id="c-41113549" checked=""/><div class="controls bullet"><span class="by">awesomekling</span><span>|</span><a href="#41113586">next</a><span>|</span><label class="collapse" for="c-41113549">[-]</label><label class="expand" for="c-41113549">[5 more]</label></div><br/><div class="children"><div class="content">Oliver (the main developer) just announced that they’re going to work full time on Porffor: <a href="https:&#x2F;&#x2F;x.com&#x2F;canadahonk&#x2F;status&#x2F;1818347311417938237" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;canadahonk&#x2F;status&#x2F;1818347311417938237</a></div><br/><div id="41113800" class="c"><input type="checkbox" id="c-41113800" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#41113549">parent</a><span>|</span><a href="#41113586">next</a><span>|</span><label class="collapse" for="c-41113800">[-]</label><label class="expand" for="c-41113800">[4 more]</label></div><br/><div class="children"><div class="content">Financed by defunkt[1], GitHub cofounder and ex CEO, for an undisclosed future project.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;user?id=defunkt">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;user?id=defunkt</a></div><br/><div id="41114556" class="c"><input type="checkbox" id="c-41114556" checked=""/><div class="controls bullet"><span class="by">pityJuke</span><span>|</span><a href="#41113549">root</a><span>|</span><a href="#41113800">parent</a><span>|</span><a href="#41113586">next</a><span>|</span><label class="collapse" for="c-41114556">[-]</label><label class="expand" for="c-41114556">[3 more]</label></div><br/><div class="children"><div class="content">Also funded the Ladybird browser recently. Seems to like his web.</div><br/><div id="41116966" class="c"><input type="checkbox" id="c-41116966" checked=""/><div class="controls bullet"><span class="by">pandemic_region</span><span>|</span><a href="#41113549">root</a><span>|</span><a href="#41114556">parent</a><span>|</span><a href="#41113586">next</a><span>|</span><label class="collapse" for="c-41116966">[-]</label><label class="expand" for="c-41116966">[2 more]</label></div><br/><div class="children"><div class="content">Not familiar with this stuff at all, is Porffor a js engine that Ladybird could end up using? Or are they still writing their own?</div><br/><div id="41117167" class="c"><input type="checkbox" id="c-41117167" checked=""/><div class="controls bullet"><span class="by">Sammi</span><span>|</span><a href="#41113549">root</a><span>|</span><a href="#41116966">parent</a><span>|</span><a href="#41113586">next</a><span>|</span><label class="collapse" for="c-41117167">[-]</label><label class="expand" for="c-41117167">[1 more]</label></div><br/><div class="children"><div class="content">Or just two separate moonshots for now.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41113586" class="c"><input type="checkbox" id="c-41113586" checked=""/><div class="controls bullet"><span class="by">obviouslynotme</span><span>|</span><a href="#41113549">prev</a><span>|</span><a href="#41113372">next</a><span>|</span><label class="collapse" for="c-41113586">[-]</label><label class="expand" for="c-41113586">[34 more]</label></div><br/><div class="children"><div class="content">I have thought about doing this and I just can&#x27;t get around the fact that you can&#x27;t get much better performance in JS. The best you could probably do is transpile the JS into V8 C++ calls.<p>The really cool optimizations come from compiling TypeScript, or something close to it. You could use types to get enormous gains. Anything without typing gets the default slow JS calls. Interfaces can get reduced to vtables or maybe even straight calls, possibly on structs instead of maps. You could have an Int and Float type that degrade into Number that just sit inside registers.<p>The main problem is that both TS and V8 are fast-moving, non-standard targets. You could only really do such a project with a big team. Maintaining compatibility would be a job by itself.</div><br/><div id="41113894" class="c"><input type="checkbox" id="c-41113894" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#41113586">parent</a><span>|</span><a href="#41114985">next</a><span>|</span><label class="collapse" for="c-41113894">[-]</label><label class="expand" for="c-41113894">[21 more]</label></div><br/><div class="children"><div class="content">At least without additional extensions, TypeScript would help less than you think. It just wasn’t designed for the job.<p>As a simple example - TypeScript doesn’t distinguish between integers and floats; they’re all just numbers. So all array accesses need casting. A TypeScript designed to aid static compilation likely would have that distinction.<p>But the big elephant in the room is TypeScript’s structural subtyping. The nature of this makes it effectively impossible for the compiler to statically determine the physical structure of any non-primitive argument passed into a function. This gives you worse-than-JIT performance on all field access, since JITs can perform dynamic shape analysis.</div><br/><div id="41114202" class="c"><input type="checkbox" id="c-41114202" checked=""/><div class="controls bullet"><span class="by">cprecioso</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113894">parent</a><span>|</span><a href="#41114177">next</a><span>|</span><label class="collapse" for="c-41114202">[-]</label><label class="expand" for="c-41114202">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A TypeScript designed to aid static compilation likely would have that distinction.<p>AssemblyScript (<a href="https:&#x2F;&#x2F;www.assemblyscript.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.assemblyscript.org&#x2F;</a>) is a TypeScript dialect with that distinction</div><br/></div></div><div id="41114177" class="c"><input type="checkbox" id="c-41114177" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113894">parent</a><span>|</span><a href="#41114202">prev</a><span>|</span><a href="#41113985">next</a><span>|</span><label class="collapse" for="c-41114177">[-]</label><label class="expand" for="c-41114177">[1 more]</label></div><br/><div class="children"><div class="content">Such Typescript already exists, Static Typescript,<p><a href="https:&#x2F;&#x2F;makecode.com&#x2F;language" rel="nofollow">https:&#x2F;&#x2F;makecode.com&#x2F;language</a><p>Microsoft&#x27;s AOT compiler for MakeCode, via C++.</div><br/></div></div><div id="41113985" class="c"><input type="checkbox" id="c-41113985" checked=""/><div class="controls bullet"><span class="by">obviouslynotme</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113894">parent</a><span>|</span><a href="#41114177">prev</a><span>|</span><a href="#41114091">next</a><span>|</span><label class="collapse" for="c-41113985">[-]</label><label class="expand" for="c-41113985">[8 more]</label></div><br/><div class="children"><div class="content">Outside of really funky code, especially code originally written in TS, you can assume the interface is the actual underlying object. You could easily flag non-recognized-member accesses to interfaces and then degrade them back to object accesses.</div><br/><div id="41114267" class="c"><input type="checkbox" id="c-41114267" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113985">parent</a><span>|</span><a href="#41114091">next</a><span>|</span><label class="collapse" for="c-41114267">[-]</label><label class="expand" for="c-41114267">[7 more]</label></div><br/><div class="children"><div class="content">You’re misunderstanding me, I think.<p>Suppose you have some interface with fields a and c. If your function takes in an object with that interface and operates on the c field, what you want is to be able to do is compile that function to access c at “the address pointed to by the pointer to the object, plus 8” (assuming 64-bit fields). Your CPU supports such addressing directly.<p>Because of structural subtyping, you can’t do that. It’s not unrecognized member. But your caller might pass in an object with fields a, <i>b</i>, and c. This is entirely idiomatic. Now c is at offset 16, not 8. Because the physical layout of the object is different, you no longer have a statically known offset to the known field.</div><br/><div id="41114520" class="c"><input type="checkbox" id="c-41114520" checked=""/><div class="controls bullet"><span class="by">obviouslynotme</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114267">parent</a><span>|</span><a href="#41115365">next</a><span>|</span><label class="collapse" for="c-41114520">[-]</label><label class="expand" for="c-41114520">[2 more]</label></div><br/><div class="children"><div class="content">I would bet that, especially outside of library code, 95+% of the typed objects are only interacted with using a single interface. These could be turned into structs with direct calls.<p>Outside of this, you can unify the types. You would take every interface used to access the object and create a new type that has all of the members of both. You can then either create vtables or monomorphize where it is used in calls.<p>At any point that analysis cannot determine the actual underlying shape, you drop to the default any.</div><br/><div id="41117214" class="c"><input type="checkbox" id="c-41117214" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114520">parent</a><span>|</span><a href="#41115365">next</a><span>|</span><label class="collapse" for="c-41117214">[-]</label><label class="expand" for="c-41117214">[1 more]</label></div><br/><div class="children"><div class="content">Which is exactly the kind of optimizations JIT compilers are able to perform, and AOT compiler can&#x27;t do them safely without having PGO data, and even then, they can&#x27;t re-optimize if the PGO happens to miss a critical path that breaks all the assumptions.</div><br/></div></div></div></div><div id="41115365" class="c"><input type="checkbox" id="c-41115365" checked=""/><div class="controls bullet"><span class="by">fenomas</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114267">parent</a><span>|</span><a href="#41114520">prev</a><span>|</span><a href="#41114091">next</a><span>|</span><label class="collapse" for="c-41115365">[-]</label><label class="expand" for="c-41115365">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Because of structural subtyping, you can’t do that<p>In practice v8 does exactly what you&#x27;re saying can&#x27;t be done, virtually all the time for any hot function. What you mean to say is that typescript type declarations <i>alone</i> don&#x27;t give you enough information to safely do it during a static compile step. But modern JS engines, that track object maps and dynamically recompile, do what you described.</div><br/><div id="41115468" class="c"><input type="checkbox" id="c-41115468" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41115365">parent</a><span>|</span><a href="#41114091">next</a><span>|</span><label class="collapse" for="c-41115468">[-]</label><label class="expand" for="c-41115468">[3 more]</label></div><br/><div class="children"><div class="content">I mentioned this in my original comment:<p>&gt; This gives you worse-than-JIT performance on all field access, since JITs can perform dynamic shape analysis.<p>We&#x27;re talking about using types to guide static compilation. Dynamic recompilation is moot.</div><br/><div id="41115685" class="c"><input type="checkbox" id="c-41115685" checked=""/><div class="controls bullet"><span class="by">fenomas</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41115468">parent</a><span>|</span><a href="#41114091">next</a><span>|</span><label class="collapse" for="c-41115685">[-]</label><label class="expand" for="c-41115685">[2 more]</label></div><br/><div class="children"><div class="content">Oh, I thought JIT in your comment meant a single compilation. Either way, having TS type guarantees would obviously make optimizing compilers like v8&#x27;s stronger, right? You seem to be arguing there&#x27;s no value to it, and I don&#x27;t follow that.</div><br/><div id="41116282" class="c"><input type="checkbox" id="c-41116282" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41115685">parent</a><span>|</span><a href="#41114091">next</a><span>|</span><label class="collapse" for="c-41116282">[-]</label><label class="expand" for="c-41116282">[1 more]</label></div><br/><div class="children"><div class="content">My claim is that the guarantees that TS provides aren&#x27;t strong enough to help a compiler produce stronger optimizations. Types don&#x27;t just magically make code faster - there&#x27;s specific reasons why they can make code faster, and TypeScript&#x27;s type system wasn&#x27;t designed around those reasons.<p>A compiler might be able to wring <i>some</i> things out of it (I&#x27;m skeptical about obviouslynotme&#x27;s suggestions in a cousin comment, but they seem insistent) or suppress some checks if you&#x27;re happy with a segfault when someone did a cast...but it&#x27;s just not a type system like, say, C&#x27;s, which is more rigid and thus gives the compiler more to work with.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41114091" class="c"><input type="checkbox" id="c-41114091" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113894">parent</a><span>|</span><a href="#41113985">prev</a><span>|</span><a href="#41114985">next</a><span>|</span><label class="collapse" for="c-41114091">[-]</label><label class="expand" for="c-41114091">[10 more]</label></div><br/><div class="children"><div class="content">I think the even bigger elephant in the room is that TypeScript&#x27;s type system is unsound. You can have a function whose parameter type is annotated to be String and there&#x27;s absolutely no guarantee that every call to that function will pass it a string.<p>This isn&#x27;t because of `any` either. The type system itself deliberately has holes in it. So any language that uses TypeScript type annotations to generate faster&#x2F;smaller code is opening itself to miscompiling code and segfaults, etc.</div><br/><div id="41114332" class="c"><input type="checkbox" id="c-41114332" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114091">parent</a><span>|</span><a href="#41115441">next</a><span>|</span><label class="collapse" for="c-41114332">[-]</label><label class="expand" for="c-41114332">[4 more]</label></div><br/><div class="children"><div class="content">So - I know this in theory, but avoided mentioning it because I couldn’t immediately think of any persuasive examples (whereas subtype polymorphism is a core, widely used, wholly unrestricted property of the language) that didn’t involve casts or any&#x2F;unknown or other things that people might make excuses for.<p>Do you have any examples off the top of your head?</div><br/><div id="41115020" class="c"><input type="checkbox" id="c-41115020" checked=""/><div class="controls bullet"><span class="by">sixbrx</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114332">parent</a><span>|</span><a href="#41114397">next</a><span>|</span><label class="collapse" for="c-41115020">[-]</label><label class="expand" for="c-41115020">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an example I constructed after reading the TS docs [1] about flow-based type inference and thinking &quot;that can&#x27;t be right...&quot;.<p>It yields no warnings or errors at compile stage but gives runtime error based on a wrong flow-based type inference.  The crux of it is that something can be a Bird (with &quot;fly&quot; function) but can also have any other members, like &quot;swim&quot; because of structural typing (flying is the <i>minimum</i> expected of a Bird).  The presence of a spurious &quot;swim&quot; member in the bird causes tsc to infer in a conditional that checks for a &quot;swim&quot; member that the animal must be a Fish or Human, when it is not (it&#x27;s just a Bird with an unrelated, non-function &quot;swim&quot; member).<p><pre><code>    type Fish = { swim: () =&gt; void };
    type Bird = { fly: () =&gt; void };
    type Human = { swim?: () =&gt; void; fly?: () =&gt; void };

    function move(animal: Fish | Bird | Human) {
      if (&quot;swim&quot; in animal) {
        &#x2F;&#x2F; TSC infers wrongly here the presence of &quot;swim&quot; implies animal must be a Fish or Human
        onlyForFishAndHumans(animal); 
      } else {
        animal;
      }
    }

    function onlyForFishAndHumans(animal: Fish | Human) {
      if (animal.swim) {
        animal.swim(); &#x2F;&#x2F; Error: attempt to call &quot;not-callable&quot;.
      }
      &#x2F;&#x2F; (receives bird which is not a Fish or Human)
    }

    const someObj = { fly: () =&gt; {}, swim: &quot;not-callable&quot; };
    const bird: Bird = someObj;

    move(bird);

    &#x2F;&#x2F; runtime error: [ERR]: animal.swim is not a function
</code></pre>
[1] <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;narrowing.html#the-in-operator-narrowing" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;narrowing.htm...</a></div><br/><div id="41116101" class="c"><input type="checkbox" id="c-41116101" checked=""/><div class="controls bullet"><span class="by">oxidant</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41115020">parent</a><span>|</span><a href="#41114397">next</a><span>|</span><label class="collapse" for="c-41116101">[-]</label><label class="expand" for="c-41116101">[1 more]</label></div><br/><div class="children"><div class="content">This narrowing is probably not the best. I&#x27;m not sure why the TS docs suggest this approach. You should really check the type of the key to be safer, though it&#x27;s still not perfect.<p><pre><code>   if (typeof animal.swim === &#x27;function&#x27;) {....}</code></pre></div><br/></div></div></div></div><div id="41114397" class="c"><input type="checkbox" id="c-41114397" checked=""/><div class="controls bullet"><span class="by">neongreen</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114332">parent</a><span>|</span><a href="#41115020">prev</a><span>|</span><a href="#41115441">next</a><span>|</span><label class="collapse" for="c-41114397">[-]</label><label class="expand" for="c-41114397">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;counterexamples.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;counterexamples.org&#x2F;</a> is a good collection of unsoundness examples in various languages.<p>For TypeScript, they list an example with `instanceof`:<p><a href="https:&#x2F;&#x2F;counterexamples.org&#x2F;polymorphic-union-refinement.html" rel="nofollow">https:&#x2F;&#x2F;counterexamples.org&#x2F;polymorphic-union-refinement.htm...</a><p>In the playground:<p><a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play&#x2F;?#code&#x2F;GYVwdgxgLglg9mABAdwE4EMAOAeAKgPgAoAPALkV0QB9EBBVDATz3wEpz6mXEBvAKESIYwRCSFgAzlHSQApnBGd0jVolSyoIVEmIBuAWo1akAbWIBdfQF8+fUJFgIhAExYlyudhV4GICKYgSHibmiAC8KBiYJKz6guqa2oEmAAyWfDZ8fpJQiM4wAOYwUEGIYCAAtgBGsqgh4S6EJgDMADSIAIztACzmsXwA9AOI4BJw4M7kAAb5RSVTQhKI6NAg6AA264yIU81TfLPFEgB0MJDrIM6yEoTdsYJDFIyYsgCiDHCo5Iclp+eX10WZTguXQiHs0HgYD4QA" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play&#x2F;?#code&#x2F;GYVwdgxgLglg9mABA...</a></div><br/></div></div></div></div><div id="41115441" class="c"><input type="checkbox" id="c-41115441" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114091">parent</a><span>|</span><a href="#41114332">prev</a><span>|</span><a href="#41114686">next</a><span>|</span><label class="collapse" for="c-41115441">[-]</label><label class="expand" for="c-41115441">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I think the even bigger elephant in the room is that TypeScript&#x27;s type system is unsound.<p>Can you name a single language that is used for high-performance software and whose type system is sound? To speed up the process, note that none of the obvious candidates have sound type systems.</div><br/><div id="41117348" class="c"><input type="checkbox" id="c-41117348" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41115441">parent</a><span>|</span><a href="#41117263">next</a><span>|</span><label class="collapse" for="c-41117348">[-]</label><label class="expand" for="c-41117348">[1 more]</label></div><br/><div class="children"><div class="content">JVM bytecode is a &quot;language&quot; and is proven to be sound. The languages that compile to that language, on the other hand, are a different kettle of fish.</div><br/></div></div><div id="41117263" class="c"><input type="checkbox" id="c-41117263" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41115441">parent</a><span>|</span><a href="#41117348">prev</a><span>|</span><a href="#41115939">next</a><span>|</span><label class="collapse" for="c-41117263">[-]</label><label class="expand" for="c-41117263">[1 more]</label></div><br/><div class="children"><div class="content">Maybe OCaml, but I haven&#x27;t studied it much.</div><br/></div></div></div></div><div id="41114686" class="c"><input type="checkbox" id="c-41114686" checked=""/><div class="controls bullet"><span class="by">curtisblaine</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114091">parent</a><span>|</span><a href="#41115441">prev</a><span>|</span><a href="#41114985">next</a><span>|</span><label class="collapse" for="c-41114686">[-]</label><label class="expand" for="c-41114686">[1 more]</label></div><br/><div class="children"><div class="content">It might be useful for an interpreter though. I believe that in V8 you have this probabilistic mechanism in which if the interpreter &quot;learns&quot; that an array contains e.g. numbers consistently, it will optimize for numbers and start accessing the array in a more performance way. Typescript could be used to inform the interpreter even before execution.
(My supposition, I&#x27;m not an interpreter expert)</div><br/></div></div></div></div></div></div><div id="41114985" class="c"><input type="checkbox" id="c-41114985" checked=""/><div class="controls bullet"><span class="by">bobvarioa</span><span>|</span><a href="#41113586">parent</a><span>|</span><a href="#41113894">prev</a><span>|</span><a href="#41113677">next</a><span>|</span><label class="collapse" for="c-41114985">[-]</label><label class="expand" for="c-41114985">[3 more]</label></div><br/><div class="children"><div class="content">Contributor to Porffor here! 
I actually disagree, there&#x27;s quite a lot that can be improved in JS during compile time. There&#x27;s been a lot of work creating static type analysis tools for JS, that can do very very thorough analysis, an example that comes to mind is [TAJS](<a href="https:&#x2F;&#x2F;www.brics.dk&#x2F;TAJS&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.brics.dk&#x2F;TAJS&#x2F;</a>) although its somewhat old.</div><br/><div id="41115890" class="c"><input type="checkbox" id="c-41115890" checked=""/><div class="controls bullet"><span class="by">attractivechaos</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41114985">parent</a><span>|</span><a href="#41113677">next</a><span>|</span><label class="collapse" for="c-41115890">[-]</label><label class="expand" for="c-41115890">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>there&#x27;s quite a lot that can be improved in JS during compile time</i><p>I wonder how much performance gain you expect to achieve. For simple CPU-bounded tasks, C&#x2F;Rust&#x2F;etc is roughly three times as fast as v8 and Julia, which compiles full scripts and has good type analysis, is about twice as fast. There is not much room left. C&#x2F;Rust&#x2F;etc can be much faster with SIMD, multi-threading and fine control of memory layout but an AOT JS compiler might not gain much from these.</div><br/><div id="41117408" class="c"><input type="checkbox" id="c-41117408" checked=""/><div class="controls bullet"><span class="by">itsTyrion</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41115890">parent</a><span>|</span><a href="#41113677">next</a><span>|</span><label class="collapse" for="c-41117408">[-]</label><label class="expand" for="c-41117408">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, I’m fine with only some speed up compared to V8, it’s already pretty fast… 
My issue with desktop&#x2F;mobile apps using web tech (JS) is mostly the install size and RAM hunger.</div><br/></div></div></div></div></div></div><div id="41113677" class="c"><input type="checkbox" id="c-41113677" checked=""/><div class="controls bullet"><span class="by">ch_sm</span><span>|</span><a href="#41113586">parent</a><span>|</span><a href="#41114985">prev</a><span>|</span><a href="#41113808">next</a><span>|</span><label class="collapse" for="c-41113677">[-]</label><label class="expand" for="c-41113677">[1 more]</label></div><br/><div class="children"><div class="content">Somewhat related to this idea is AssemblyScript <a href="https:&#x2F;&#x2F;www.assemblyscript.org" rel="nofollow">https:&#x2F;&#x2F;www.assemblyscript.org</a></div><br/></div></div><div id="41113808" class="c"><input type="checkbox" id="c-41113808" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#41113586">parent</a><span>|</span><a href="#41113677">prev</a><span>|</span><a href="#41116049">next</a><span>|</span><label class="collapse" for="c-41113808">[-]</label><label class="expand" for="c-41113808">[5 more]</label></div><br/><div class="children"><div class="content">Ecmascript 4 was an attempt to add better types to the language, which sadly failed a long time ago.<p>It&#x27;d be nice of TS at least allowed for specifying types like integer, allowing some of the newer TS aware runtimes could take advantage of the additional info, even if the main TS-&gt;JS compilation just treated `const val: int` the same as `const val: number`.<p>I wonder if a syntax like<p><pre><code>    const counter: Number&lt;int&gt;
</code></pre>
would be acceptable.</div><br/><div id="41114642" class="c"><input type="checkbox" id="c-41114642" checked=""/><div class="controls bullet"><span class="by">the_imp</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113808">parent</a><span>|</span><a href="#41113917">next</a><span>|</span><label class="collapse" for="c-41114642">[-]</label><label class="expand" for="c-41114642">[1 more]</label></div><br/><div class="children"><div class="content">With Extractors [1] (currently at Stage 1), you could define something like this to work:<p><pre><code>    const Integer = {
      [Symbol.customMatcher]: (value) =&gt; [Number.parseInt(value)]
    }

    const Integer(counter) = 42.56;
    &#x2F;&#x2F; counter === 42
</code></pre>
[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-extractors">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-extractors</a></div><br/></div></div><div id="41113917" class="c"><input type="checkbox" id="c-41113917" checked=""/><div class="controls bullet"><span class="by">THBC</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113808">parent</a><span>|</span><a href="#41114642">prev</a><span>|</span><a href="#41113921">next</a><span>|</span><label class="collapse" for="c-41113917">[-]</label><label class="expand" for="c-41113917">[1 more]</label></div><br/><div class="children"><div class="content">Number is not semantically compatible with raw 64-bit integer, so you might as well wish for a native<p><pre><code>    const counter = UInt64(42);
</code></pre>
The current state of the art is<p><pre><code>    const counter = BigInt.asUintN(64, 42);</code></pre></div><br/></div></div><div id="41113921" class="c"><input type="checkbox" id="c-41113921" checked=""/><div class="controls bullet"><span class="by">obviouslynotme</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113808">parent</a><span>|</span><a href="#41113917">prev</a><span>|</span><a href="#41116049">next</a><span>|</span><label class="collapse" for="c-41113921">[-]</label><label class="expand" for="c-41113921">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that is why I said TS (or something similar). TS made some decisions that make sense at the time, but do not help compilation. The complexity of its typing system is another problem. I&#x27;m pretty sure that it is Turing-complete. That doesn&#x27;t remove feasibility, but it increases the complexity of compiling it by a whole lot. When you add onto this the fact that &quot;the compiler is the spec,&quot; you really get bogged down. It would be much easier to recognize a sensible subset of TS. You could probably even have the type checker throw a WTFisThisGuyDoing flag and just immediately downgrade it to an any.</div><br/><div id="41114711" class="c"><input type="checkbox" id="c-41114711" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#41113586">root</a><span>|</span><a href="#41113921">parent</a><span>|</span><a href="#41116049">next</a><span>|</span><label class="collapse" for="c-41114711">[-]</label><label class="expand" for="c-41114711">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I&#x27;m pretty sure that it is Turing-complete.<p>Because JS code can arbitrarily modify a type, any language trying to specify what the outputs of a function can be also has to be Turing complete.<p>There are of course still plenty of types that TS doesn&#x27;t bother trying to model, but it does try to cover even funny cases like field names going from kebab-case to camelCase.</div><br/></div></div></div></div></div></div><div id="41116049" class="c"><input type="checkbox" id="c-41116049" checked=""/><div class="controls bullet"><span class="by">singpolyma3</span><span>|</span><a href="#41113586">parent</a><span>|</span><a href="#41113808">prev</a><span>|</span><a href="#41115502">next</a><span>|</span><label class="collapse" for="c-41116049">[-]</label><label class="expand" for="c-41116049">[1 more]</label></div><br/><div class="children"><div class="content">You can do inference and only fall back to Dynamic&#x2F;any when something more specific can&#x27;t be globally inferred in the program. For an optimization pass this is an option.</div><br/></div></div><div id="41115502" class="c"><input type="checkbox" id="c-41115502" checked=""/><div class="controls bullet"><span class="by">myko</span><span>|</span><a href="#41113586">parent</a><span>|</span><a href="#41116049">prev</a><span>|</span><a href="#41114924">next</a><span>|</span><label class="collapse" for="c-41115502">[-]</label><label class="expand" for="c-41115502">[1 more]</label></div><br/><div class="children"><div class="content">Dart, maybe, but it lost</div><br/></div></div><div id="41114924" class="c"><input type="checkbox" id="c-41114924" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#41113586">parent</a><span>|</span><a href="#41115502">prev</a><span>|</span><a href="#41113372">next</a><span>|</span><label class="collapse" for="c-41114924">[-]</label><label class="expand" for="c-41114924">[1 more]</label></div><br/><div class="children"><div class="content">You say you have &quot;thought about doing this&quot;...&quot;[but] you can&#x27;t get much better performance&quot;, then describe the approach requiring things that are described first-thing, above the fold, on the site.<p>Did the site change? Or am I missing something? :)</div><br/></div></div></div></div><div id="41113372" class="c"><input type="checkbox" id="c-41113372" checked=""/><div class="controls bullet"><span class="by">rubenfiszel</span><span>|</span><a href="#41113586">prev</a><span>|</span><a href="#41113750">next</a><span>|</span><label class="collapse" for="c-41113372">[-]</label><label class="expand" for="c-41113372">[2 more]</label></div><br/><div class="children"><div class="content">At windmill.dev, when users deploy their code, we use Bun build (which is similar to esbuild) to bundle their scripts and all their dependencies into a single js file to load which improve cold start and memory usage. We store the bundle on s3 because of the size of the bundles.<p>If we could bundle everything to native that would completely change the game since as good as bun&#x27;s cold start is, you can&#x27;t beat running straight native with a small binary.</div><br/><div id="41115066" class="c"><input type="checkbox" id="c-41115066" checked=""/><div class="controls bullet"><span class="by">canadahonk</span><span>|</span><a href="#41113372">parent</a><span>|</span><a href="#41113750">next</a><span>|</span><label class="collapse" for="c-41115066">[-]</label><label class="expand" for="c-41115066">[1 more]</label></div><br/><div class="children"><div class="content">Hey, dev here, I agree that is an interesting application which Porffor could potentially help with! Happy to chat sometime :)</div><br/></div></div></div></div><div id="41113750" class="c"><input type="checkbox" id="c-41113750" checked=""/><div class="controls bullet"><span class="by">syrusakbary</span><span>|</span><a href="#41113372">prev</a><span>|</span><a href="#41116533">next</a><span>|</span><label class="collapse" for="c-41113750">[-]</label><label class="expand" for="c-41113750">[12 more]</label></div><br/><div class="children"><div class="content">It&#x27;s awesome to see how more JS runtimes try to approach Wasm.
This project reminds me to Static Hermes (the JS engine from Facebook to improve the speed of React Native projects on iOS and Android).<p>I&#x27;ve spent a bit of time trying to review each, so hopefully this analysis will be useful for some readers. What are the main commonalities and differences between Static Hermes and Porffor?<p><pre><code>  * They both aim for JS test262 conformance [1]
  * Porffor supports both Native and Wasm outputs while Static Hermes is mainly focused on Native outputs for now
  * Porffor is self-hosted (Porffor is written in pure JS and can compile itself), while Static Hermes relies on LLVM
  * Porffor currently doesn&#x27;t support async&#x2F;promise&#x2F;await while Static Hermes does (with some limitations)
  * Static Hermes is written in C++ while Porffor is mainly JS
  * They both support TypeScript (although Static Hermes does it through transpiling the TS AST to Flow, while Porffor supports it natively)
  * Static Hermes has a fallback interpreter (to support `eval` and other hard-to-compile JS scenarios), while Porffor only supports AOT compiling (although, as I commented in other thread here, it maybe be possible to support `eval` in Porffor as well)
</code></pre>
In general, I&#x27;m excited to see if this project can gain some traction so we can speed-up Javascript engines one the Edge!
Context: I&#x27;m Syrus, from Wasmer [3]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;hermes&#x2F;discussions&#x2F;1137">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;hermes&#x2F;discussions&#x2F;1137</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;test262">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;test262</a><p>[3] <a href="https:&#x2F;&#x2F;wasmer.io">https:&#x2F;&#x2F;wasmer.io</a></div><br/><div id="41116392" class="c"><input type="checkbox" id="c-41116392" checked=""/><div class="controls bullet"><span class="by">tmikov</span><span>|</span><a href="#41113750">parent</a><span>|</span><a href="#41114961">next</a><span>|</span><label class="collapse" for="c-41116392">[-]</label><label class="expand" for="c-41116392">[1 more]</label></div><br/><div class="children"><div class="content">For the record, Static Hermes fully supports compiling JS to WASM. We get it basically for free, because it is an existing LLVM backend. See <a href="https:&#x2F;&#x2F;x.com&#x2F;tmikov&#x2F;status&#x2F;1706138872412074204" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;tmikov&#x2F;status&#x2F;1706138872412074204</a> for example.<p>Admittedly, it is not our focus, we are focusing mainly on React Native, where WASM doesn&#x27;t make sense.<p>The most important feature of Static Hermes is our type checker, which guarantees runtime soundness.<p>Porffor is very interesting, I have been watching it for some time and I am rooting for it.</div><br/></div></div><div id="41114961" class="c"><input type="checkbox" id="c-41114961" checked=""/><div class="controls bullet"><span class="by">bobvarioa</span><span>|</span><a href="#41113750">parent</a><span>|</span><a href="#41116392">prev</a><span>|</span><a href="#41114977">next</a><span>|</span><label class="collapse" for="c-41114961">[-]</label><label class="expand" for="c-41114961">[2 more]</label></div><br/><div class="children"><div class="content">Contributor for Porffor here! I think this is a great comparison, but Porffor does technically support promises, albeit <i>synchronously</i>. It&#x27;s a similar approach to Kiesel, <a href="https:&#x2F;&#x2F;kiesel.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;kiesel.dev&#x2F;</a>.</div><br/><div id="41116337" class="c"><input type="checkbox" id="c-41116337" checked=""/><div class="controls bullet"><span class="by">frutiger</span><span>|</span><a href="#41113750">root</a><span>|</span><a href="#41114961">parent</a><span>|</span><a href="#41114977">next</a><span>|</span><label class="collapse" for="c-41116337">[-]</label><label class="expand" for="c-41116337">[1 more]</label></div><br/><div class="children"><div class="content">Not sure where you mean by synchronously but if you mean what I think you mean then that is not correct behaviour. This is important to ensure predicatibility.<p>Eg.<p><pre><code>    Promise.then(() =&gt; console.log(“a”));
    console.log(“b”)
</code></pre>
must log [“b”, “a”] and not [“a”, “b”].</div><br/></div></div></div></div><div id="41114977" class="c"><input type="checkbox" id="c-41114977" checked=""/><div class="controls bullet"><span class="by">canadahonk</span><span>|</span><a href="#41113750">parent</a><span>|</span><a href="#41114961">prev</a><span>|</span><a href="#41114951">next</a><span>|</span><label class="collapse" for="c-41114977">[-]</label><label class="expand" for="c-41114977">[1 more]</label></div><br/><div class="children"><div class="content">Good comparison and thanks! A few minor clarifications:
- Porffor isn&#x27;t fully self-hosted <i>yet</i> but should be possible hopefully! It does partially compile itself for builtins (eg Array.prototype.filter, Math.sin, atob, ...) though.
- As of late, Porffor does now support basic async&#x2F;promise&#x2F;await! Not very well yet though.</div><br/></div></div><div id="41114951" class="c"><input type="checkbox" id="c-41114951" checked=""/><div class="controls bullet"><span class="by">wdb</span><span>|</span><a href="#41113750">parent</a><span>|</span><a href="#41114977">prev</a><span>|</span><a href="#41114086">next</a><span>|</span><label class="collapse" for="c-41114951">[-]</label><label class="expand" for="c-41114951">[4 more]</label></div><br/><div class="children"><div class="content">You make it sound bad to rely on LLVM.</div><br/><div id="41115114" class="c"><input type="checkbox" id="c-41115114" checked=""/><div class="controls bullet"><span class="by">bangaladore</span><span>|</span><a href="#41113750">root</a><span>|</span><a href="#41114951">parent</a><span>|</span><a href="#41114086">next</a><span>|</span><label class="collapse" for="c-41115114">[-]</label><label class="expand" for="c-41115114">[3 more]</label></div><br/><div class="children"><div class="content">Yeah... It is unclear to me how not using LLVM is a good thing. You&#x27;d inherit millions of man-hours of optimization work, code gen, and general thought process.<p>Is there a technical reason why?</div><br/><div id="41115318" class="c"><input type="checkbox" id="c-41115318" checked=""/><div class="controls bullet"><span class="by">fabrice_d</span><span>|</span><a href="#41113750">root</a><span>|</span><a href="#41115114">parent</a><span>|</span><a href="#41114086">next</a><span>|</span><label class="collapse" for="c-41115318">[-]</label><label class="expand" for="c-41115318">[2 more]</label></div><br/><div class="children"><div class="content">In this case, being self contained will help implementing things like `eval()` and `Function()` since Porffor can self-host. That would be much harder with a LLVM based solution.</div><br/></div></div></div></div></div></div><div id="41114086" class="c"><input type="checkbox" id="c-41114086" checked=""/><div class="controls bullet"><span class="by">jonathanyc</span><span>|</span><a href="#41113750">parent</a><span>|</span><a href="#41114951">prev</a><span>|</span><a href="#41116533">next</a><span>|</span><label class="collapse" for="c-41114086">[-]</label><label class="expand" for="c-41114086">[3 more]</label></div><br/><div class="children"><div class="content">Just wanted to say I really appreciated the high-quality comparison. How something compares to existing work is my #1 question whenever I read an announcement like this.</div><br/><div id="41114945" class="c"><input type="checkbox" id="c-41114945" checked=""/><div class="controls bullet"><span class="by">syrusakbary</span><span>|</span><a href="#41113750">root</a><span>|</span><a href="#41114086">parent</a><span>|</span><a href="#41114431">next</a><span>|</span><label class="collapse" for="c-41114945">[-]</label><label class="expand" for="c-41114945">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/></div></div></div></div></div></div><div id="41116533" class="c"><input type="checkbox" id="c-41116533" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41113750">prev</a><span>|</span><a href="#41116550">next</a><span>|</span><label class="collapse" for="c-41116533">[-]</label><label class="expand" for="c-41116533">[1 more]</label></div><br/><div class="children"><div class="content"><i>Porffor can compile to real native binaries without just packaging a runtime like existing solutions.</i><p>Any language that allows generating and interpreting its own code at runtime will have the &quot;eval problem&quot;. From some other comments here, it sounds like Porffor&#x27;s solution is to simply ignore it.</div><br/></div></div><div id="41116550" class="c"><input type="checkbox" id="c-41116550" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#41116533">prev</a><span>|</span><a href="#41116243">next</a><span>|</span><label class="collapse" for="c-41116550">[-]</label><label class="expand" for="c-41116550">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a subset of JS that&#x27;s trivially compilable, it&#x27;s the long tail of other stuff that&#x27;s hard. But cool to see research happening on where that boundary lies and how much benefit can be had for that subset</div><br/></div></div><div id="41116243" class="c"><input type="checkbox" id="c-41116243" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#41116550">prev</a><span>|</span><a href="#41115057">next</a><span>|</span><label class="collapse" for="c-41116243">[-]</label><label class="expand" for="c-41116243">[1 more]</label></div><br/><div class="children"><div class="content">Its refreshing to see all the various JS engines that are out there for various usecases.<p>I have been working on providing quickjs with more node compatible API through llrt [1] for embedding into applications for plugins.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;llrt">https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;llrt</a></div><br/></div></div><div id="41115057" class="c"><input type="checkbox" id="c-41115057" checked=""/><div class="controls bullet"><span class="by">CharlesW</span><span>|</span><a href="#41116243">prev</a><span>|</span><a href="#41113883">next</a><span>|</span><label class="collapse" for="c-41115057">[-]</label><label class="expand" for="c-41115057">[2 more]</label></div><br/><div class="children"><div class="content">What subtleties am I missing that makes &quot;ahead-of-time JS engine&quot; a better description than &quot;JS-to-Wasm compiler&quot;? (If it&#x27;s mostly a framing strategy, that&#x27;s cool too.)</div><br/><div id="41115375" class="c"><input type="checkbox" id="c-41115375" checked=""/><div class="controls bullet"><span class="by">chillfox</span><span>|</span><a href="#41115057">parent</a><span>|</span><a href="#41113883">next</a><span>|</span><label class="collapse" for="c-41115375">[-]</label><label class="expand" for="c-41115375">[1 more]</label></div><br/><div class="children"><div class="content">There are already projects that does JS-to-WASM by bundling a JS interpreter. So, it&#x27;s likely to make the difference to those clearer.</div><br/></div></div></div></div><div id="41113883" class="c"><input type="checkbox" id="c-41113883" checked=""/><div class="controls bullet"><span class="by">nick_g</span><span>|</span><a href="#41115057">prev</a><span>|</span><a href="#41114167">next</a><span>|</span><label class="collapse" for="c-41113883">[-]</label><label class="expand" for="c-41113883">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit suspicious of the versioning scheme described here[0]<p>If some change were required which introduced a regression on some Test262 tests, it could cause the version number to regress as well. This means Porffor cannot have both a version number which increases monotonically and the ability to introduce necessary changes which cause Test262 regressions<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;CanadaHonk&#x2F;porffor?tab=readme-ov-file#versioning">https:&#x2F;&#x2F;github.com&#x2F;CanadaHonk&#x2F;porffor?tab=readme-ov-file#ver...</a></div><br/><div id="41114017" class="c"><input type="checkbox" id="c-41114017" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#41113883">parent</a><span>|</span><a href="#41114039">next</a><span>|</span><label class="collapse" for="c-41114017">[-]</label><label class="expand" for="c-41114017">[2 more]</label></div><br/><div class="children"><div class="content">Presumably the idea is that any work that causes Test262 regressions is temporary, takes place in a separate branch, and is only merged to main once the branch also contains all the necessary fixes to make the regressions go away again. A new version number would only be used once that merge happens.</div><br/><div id="41115077" class="c"><input type="checkbox" id="c-41115077" checked=""/><div class="controls bullet"><span class="by">canadahonk</span><span>|</span><a href="#41113883">root</a><span>|</span><a href="#41114017">parent</a><span>|</span><a href="#41114039">next</a><span>|</span><label class="collapse" for="c-41115077">[-]</label><label class="expand" for="c-41115077">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. The versioning system is definitely unique and controversial, but I think it fits for a fast moving project like this, so I don&#x27;t have to really consider versioning which could slow development. When it becomes more stable, I&#x27;ll likely move to a more traditional semver scheme from 1.0.</div><br/></div></div></div></div></div></div><div id="41114167" class="c"><input type="checkbox" id="c-41114167" checked=""/><div class="controls bullet"><span class="by">mproud</span><span>|</span><a href="#41113883">prev</a><span>|</span><a href="#41113937">next</a><span>|</span><label class="collapse" for="c-41114167">[-]</label><label class="expand" for="c-41114167">[2 more]</label></div><br/><div class="children"><div class="content">“Purple” in Welsh</div><br/><div id="41114909" class="c"><input type="checkbox" id="c-41114909" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#41114167">parent</a><span>|</span><a href="#41113937">next</a><span>|</span><label class="collapse" for="c-41114909">[-]</label><label class="expand" for="c-41114909">[1 more]</label></div><br/><div class="children"><div class="content">with etymology from the greek for purple; the english &quot;porphyry&quot; (a purple mineral) is probably the commonest word with the same root.</div><br/></div></div></div></div><div id="41113937" class="c"><input type="checkbox" id="c-41113937" checked=""/><div class="controls bullet"><span class="by">rvnx</span><span>|</span><a href="#41114167">prev</a><span>|</span><a href="#41113421">next</a><span>|</span><label class="collapse" for="c-41113937">[-]</label><label class="expand" for="c-41113937">[2 more]</label></div><br/><div class="children"><div class="content">Seems like the same idea that Facebook had with PHP which was to transpile PHP to C.<p>It was called hiphop-php, then they eventually gave up, before creating hhvm on a complete new concept.</div><br/><div id="41114203" class="c"><input type="checkbox" id="c-41114203" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41113937">parent</a><span>|</span><a href="#41113421">next</a><span>|</span><label class="collapse" for="c-41114203">[-]</label><label class="expand" for="c-41114203">[1 more]</label></div><br/><div class="children"><div class="content">Historically the sequence is a bit different.<p>After HHVM proved that its JIT compilation engine was faster than their HipHop AOT attempt, did they decided to focus only on HHVM going forward.</div><br/></div></div></div></div><div id="41113421" class="c"><input type="checkbox" id="c-41113421" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41113937">prev</a><span>|</span><a href="#41114047">next</a><span>|</span><label class="collapse" for="c-41113421">[-]</label><label class="expand" for="c-41113421">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to know if there&#x27;s a way to compile NodeJS to native libraries with this! I have a process [0], but it&#x27;s a bit hacky and error prone<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;ijustlovemath&#x2F;jescx">https:&#x2F;&#x2F;github.com&#x2F;ijustlovemath&#x2F;jescx</a></div><br/></div></div><div id="41114047" class="c"><input type="checkbox" id="c-41114047" checked=""/><div class="controls bullet"><span class="by">Borkdude</span><span>|</span><a href="#41113421">prev</a><span>|</span><a href="#41115156">next</a><span>|</span><label class="collapse" for="c-41114047">[-]</label><label class="expand" for="c-41114047">[1 more]</label></div><br/><div class="children"><div class="content">I got &quot;TodoError: no generation for ImportDeclaration!&quot; for this script:<p>import * as squint_core from &#x27;squint-cljs&#x2F;core.js&#x27;;
console.log(&quot;hello&quot;);</div><br/></div></div><div id="41115156" class="c"><input type="checkbox" id="c-41115156" checked=""/><div class="controls bullet"><span class="by">WatchDog</span><span>|</span><a href="#41114047">prev</a><span>|</span><a href="#41113399">next</a><span>|</span><label class="collapse" for="c-41115156">[-]</label><label class="expand" for="c-41115156">[2 more]</label></div><br/><div class="children"><div class="content">How does this compare to quickJS, which can also compile JS to native code(with a C compiler)</div><br/><div id="41117150" class="c"><input type="checkbox" id="c-41117150" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#41115156">parent</a><span>|</span><a href="#41113399">next</a><span>|</span><label class="collapse" for="c-41117150">[-]</label><label class="expand" for="c-41117150">[1 more]</label></div><br/><div class="children"><div class="content">I <i>think</i> QuickJS only compiles to bytecode and then embeds it together with the interpreter in an executable. The JS itself is still interpreted. Others please correct me if I&#x27;m wrong.</div><br/></div></div></div></div><div id="41113399" class="c"><input type="checkbox" id="c-41113399" checked=""/><div class="controls bullet"><span class="by">solumos</span><span>|</span><a href="#41115156">prev</a><span>|</span><a href="#41115098">next</a><span>|</span><label class="collapse" for="c-41113399">[-]</label><label class="expand" for="c-41113399">[1 more]</label></div><br/><div class="children"><div class="content">Just out of curiosity, how does the performance (compilation + runtime) compare to something like bun[0]?<p>[0] <a href="https:&#x2F;&#x2F;bun.sh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bun.sh&#x2F;</a></div><br/></div></div><div id="41115098" class="c"><input type="checkbox" id="c-41115098" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#41113399">prev</a><span>|</span><a href="#41113864">next</a><span>|</span><label class="collapse" for="c-41115098">[-]</label><label class="expand" for="c-41115098">[1 more]</label></div><br/><div class="children"><div class="content">I find this very interesting. Keep it up and bring it to production shape</div><br/></div></div><div id="41113864" class="c"><input type="checkbox" id="c-41113864" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41115098">prev</a><span>|</span><a href="#41114042">next</a><span>|</span><label class="collapse" for="c-41113864">[-]</label><label class="expand" for="c-41113864">[7 more]</label></div><br/><div class="children"><div class="content">What happens when someone calls eval?</div><br/><div id="41113969" class="c"><input type="checkbox" id="c-41113969" checked=""/><div class="controls bullet"><span class="by">syrusakbary</span><span>|</span><a href="#41113864">parent</a><span>|</span><a href="#41114917">next</a><span>|</span><label class="collapse" for="c-41113969">[-]</label><label class="expand" for="c-41113969">[4 more]</label></div><br/><div class="children"><div class="content">Since Porffor can compile itself (you can run the compiler inside of Porffor), any calls to eval could be compiled to Wasm (via executing the Porffor compiler in Porffor JS engine) and executed performantly on the same JS context *<p>*or at least, in theory</div><br/><div id="41116729" class="c"><input type="checkbox" id="c-41116729" checked=""/><div class="controls bullet"><span class="by">concerndc1tizen</span><span>|</span><a href="#41113864">root</a><span>|</span><a href="#41113969">parent</a><span>|</span><a href="#41114860">next</a><span>|</span><label class="collapse" for="c-41116729">[-]</label><label class="expand" for="c-41116729">[1 more]</label></div><br/><div class="children"><div class="content">That wouldn&#x27;t work: The Wasm spec does not allow for modifying an already running program (e.g. JIT).<p>AFAIK the only option is to include an interpreter.</div><br/></div></div><div id="41114860" class="c"><input type="checkbox" id="c-41114860" checked=""/><div class="controls bullet"><span class="by">tasty_freeze</span><span>|</span><a href="#41113864">root</a><span>|</span><a href="#41113969">parent</a><span>|</span><a href="#41116729">prev</a><span>|</span><a href="#41114917">next</a><span>|</span><label class="collapse" for="c-41114860">[-]</label><label class="expand" for="c-41114860">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used it, but reading their landing page, Porffor says their runtime is vastly smaller because it is AOT. If the compiler had to be bundled with the executable, then the size of the executable would grow much larger.</div><br/><div id="41116646" class="c"><input type="checkbox" id="c-41116646" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#41113864">root</a><span>|</span><a href="#41114860">parent</a><span>|</span><a href="#41114917">next</a><span>|</span><label class="collapse" for="c-41116646">[-]</label><label class="expand" for="c-41116646">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but you&#x27;d only need to include Porffor into compiled code if it used eval.<p>And most devs stay away from eval for well-deserved security reasons.</div><br/></div></div></div></div></div></div><div id="41114917" class="c"><input type="checkbox" id="c-41114917" checked=""/><div class="controls bullet"><span class="by">canadahonk</span><span>|</span><a href="#41113864">parent</a><span>|</span><a href="#41113969">prev</a><span>|</span><a href="#41114069">next</a><span>|</span><label class="collapse" for="c-41114917">[-]</label><label class="expand" for="c-41114917">[1 more]</label></div><br/><div class="children"><div class="content">For now, unless it is given a literal string (eg `eval(&#x27;42&#x27;)`) eval just won&#x27;t work.</div><br/></div></div><div id="41114069" class="c"><input type="checkbox" id="c-41114069" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#41113864">parent</a><span>|</span><a href="#41114917">prev</a><span>|</span><a href="#41114042">next</a><span>|</span><label class="collapse" for="c-41114069">[-]</label><label class="expand" for="c-41114069">[1 more]</label></div><br/><div class="children"><div class="content">With a string literal it works, with a dynamic string it just gives an undefined reference error to eval.</div><br/></div></div></div></div><div id="41113867" class="c"><input type="checkbox" id="c-41113867" checked=""/><div class="controls bullet"><span class="by">THBC</span><span>|</span><a href="#41114042">prev</a><span>|</span><a href="#41115157">next</a><span>|</span><label class="collapse" for="c-41113867">[-]</label><label class="expand" for="c-41113867">[1 more]</label></div><br/><div class="children"><div class="content">This seems like an opaque supply chain attack waiting to happen.</div><br/></div></div><div id="41115157" class="c"><input type="checkbox" id="c-41115157" checked=""/><div class="controls bullet"><span class="by">xiaodai</span><span>|</span><a href="#41113867">prev</a><span>|</span><label class="collapse" for="c-41115157">[-]</label><label class="expand" for="c-41115157">[1 more]</label></div><br/><div class="children"><div class="content">Stop trying to retrofit garbage on garbage. Go direct to WebAsm already</div><br/></div></div></div></div></div></div></div></body></html>