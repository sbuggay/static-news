<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727341275470" as="style"/><link rel="stylesheet" href="styles.css?v=1727341275470"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mtmucha/coros">Show HN: Coros – A Modern C++ Library for Task Parallelism</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>singledigits</span> | <span>46 comments</span></div><br/><div><div id="41648544" class="c"><input type="checkbox" id="c-41648544" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#41648684">next</a><span>|</span><label class="collapse" for="c-41648544">[-]</label><label class="expand" for="c-41648544">[4 more]</label></div><br/><div class="children"><div class="content">I am pretty okay with the code (I&#x27;m essentially talking about the usage syntax for the library and its type) shown in the examples. However, at this point any parallel computing implementations must address the baseline issues presented in &quot;Scalability! But at what COST? (McSherry,Isard,Murray 2015)&quot; a paper whose central question is can a parallel computation exhibit a Configuration that Outperforms a Single Thread (the COST in the title). [1] There is a good discussion of the paper and its applicability to parallel (and distributed) computation implementations in Richard Feldman&#x27;s 2024 Distributed Systems talk &quot;Distributed Pure Functions&quot;. [2]<p>At this point in the life-cycle of the concept of parallel computation, I think it has become somewhat imperative that devs in the area begin to honestly evaluate the practicality and benefits&#x2F;drawbacks of using the techniques for a given application area and attempt to &#x27;sell&#x27; their libraries, techniques, idioms, etc using a more transparent approach. Also, I generally think that people that argue for more prevalence of parallel code, especially those arguing for the default being parallel (or concurrent), have to wrestle with and address these same issues.<p>Again, I don&#x27;t dislike the premise of the library, think the usage examples seem very sensible and well designed, and I really like parallel computation as an area of study in general. Further, I really think that setting out a task for one&#x27;s self<p>&#x27;to try building a library using modern features from the C++ standard library. I’ve used coroutines for task encapsulation and C++23 expected for exception handling, while trying to maintain good performance.&#x27;<p>after taking inspiration from two well respected and frequently utilized libraries in the space is great and the internals of the library I saw look clean and well architected.<p>1 - <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;hotos15&#x2F;hotos15-paper-mcsherry.pdf" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;hotos15&#x2F;hotos...</a>
2 - <a href="https:&#x2F;&#x2F;youtu.be&#x2F;ztY1YRiaSiE?si=npBREw9vdF5dHcJh&amp;t=350" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;ztY1YRiaSiE?si=npBREw9vdF5dHcJh&amp;t=350</a></div><br/><div id="41648742" class="c"><input type="checkbox" id="c-41648742" checked=""/><div class="controls bullet"><span class="by">singledigits</span><span>|</span><a href="#41648544">parent</a><span>|</span><a href="#41648928">next</a><span>|</span><label class="collapse" for="c-41648742">[-]</label><label class="expand" for="c-41648742">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for your thoughtful feedback.<p>I&#x27;ve just skimmed through the paper, and it raises interesting and valid point about scalability in parallel computing. I&#x27;ll definitely look into it more thoroughly, as well as the talk you mentioned.<p>I&#x27;m glad you find the usage examples well-designed and appreciate your positive remarks about the library&#x27;s architecture. Thank you again for your insights.</div><br/></div></div><div id="41648928" class="c"><input type="checkbox" id="c-41648928" checked=""/><div class="controls bullet"><span class="by">SolarNet</span><span>|</span><a href="#41648544">parent</a><span>|</span><a href="#41648742">prev</a><span>|</span><a href="#41648684">next</a><span>|</span><label class="collapse" for="c-41648928">[-]</label><label class="expand" for="c-41648928">[2 more]</label></div><br/><div class="children"><div class="content">I think you are misapplying that paper? This as a library is the &quot;batteries&quot; to C++&#x27;s no-batteries-included standard library which does not implement asynchronous coroutines at all.<p>The paper is much more on the side of application and system performance. But you couldn&#x27;t even write such a system without a library like this providing you the tools to do so. This is much more in the domain of &quot;basic tool for ecosystem&quot; than &quot;library for specific tasks&quot;. It&#x27;s on the user of the tool to address the paper&#x27;s question, not the builder of the tools.</div><br/><div id="41649684" class="c"><input type="checkbox" id="c-41649684" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#41648544">root</a><span>|</span><a href="#41648928">parent</a><span>|</span><a href="#41648684">next</a><span>|</span><label class="collapse" for="c-41649684">[-]</label><label class="expand" for="c-41649684">[1 more]</label></div><br/><div class="children"><div class="content">You are not incorrect in stating that the primary focus of the paper is more on the application side. However, I think providers of a parallel computation infrastructure would benefit from profiling a wide range of potential use cases across several work load sizes. This could then lead to a section in a README where the baseline overhead was broken down per workload&#x2F;worksize measurements and a back of the envelope estimate by an application developer would be more particularly motivated when deciding which infrastructure tool may be the best fit for their application&#x27;s specific requirements.</div><br/></div></div></div></div></div></div><div id="41648684" class="c"><input type="checkbox" id="c-41648684" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#41648544">prev</a><span>|</span><a href="#41654182">next</a><span>|</span><label class="collapse" for="c-41648684">[-]</label><label class="expand" for="c-41648684">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also a high-quality, sophisticated Threading Building Blocks by Intel (which I wish would become a part of the C++ standard library).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Threading_Building_Blocks" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Threading_Building_Blocks</a></div><br/><div id="41652416" class="c"><input type="checkbox" id="c-41652416" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#41648684">parent</a><span>|</span><a href="#41649422">next</a><span>|</span><label class="collapse" for="c-41652416">[-]</label><label class="expand" for="c-41652416">[1 more]</label></div><br/><div class="children"><div class="content">TBB was already far from the state-of-the-art 7&#x2F;8 years ago, and there are continuously new approaches that outperform it such as <a href="https:&#x2F;&#x2F;github.com&#x2F;taskflow&#x2F;taskflow">https:&#x2F;&#x2F;github.com&#x2F;taskflow&#x2F;taskflow</a> ; <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;marl">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;marl</a> ; and the most recent contender <a href="https:&#x2F;&#x2F;github.com&#x2F;dpuyda&#x2F;scheduling">https:&#x2F;&#x2F;github.com&#x2F;dpuyda&#x2F;scheduling</a></div><br/></div></div><div id="41649422" class="c"><input type="checkbox" id="c-41649422" checked=""/><div class="controls bullet"><span class="by">Zitrax</span><span>|</span><a href="#41648684">parent</a><span>|</span><a href="#41652416">prev</a><span>|</span><a href="#41654182">next</a><span>|</span><label class="collapse" for="c-41649422">[-]</label><label class="expand" for="c-41649422">[1 more]</label></div><br/><div class="children"><div class="content">You can see in the repository that it was benchmarked against oneTBB.</div><br/></div></div></div></div><div id="41654182" class="c"><input type="checkbox" id="c-41654182" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#41648684">prev</a><span>|</span><a href="#41650361">next</a><span>|</span><label class="collapse" for="c-41654182">[-]</label><label class="expand" for="c-41654182">[1 more]</label></div><br/><div class="children"><div class="content">Martin, interesting;  have you had a look at <a href="https:&#x2F;&#x2F;github.com&#x2F;taskflow&#x2F;taskflow">https:&#x2F;&#x2F;github.com&#x2F;taskflow&#x2F;taskflow</a> ?</div><br/></div></div><div id="41650361" class="c"><input type="checkbox" id="c-41650361" checked=""/><div class="controls bullet"><span class="by">gsliepen</span><span>|</span><a href="#41654182">prev</a><span>|</span><a href="#41654966">next</a><span>|</span><label class="collapse" for="c-41650361">[-]</label><label class="expand" for="c-41650361">[3 more]</label></div><br/><div class="children"><div class="content">It would be nice if there was a function to wait for tasks and to return the results at the same time, so that you could write something like:<p><pre><code>    auto [a, b] = co_await coros::wait_tasks(fib(n - 1), fib(n - 2));
    return a + b;</code></pre></div><br/><div id="41650791" class="c"><input type="checkbox" id="c-41650791" checked=""/><div class="controls bullet"><span class="by">singledigits</span><span>|</span><a href="#41650361">parent</a><span>|</span><a href="#41651087">next</a><span>|</span><label class="collapse" for="c-41650791">[-]</label><label class="expand" for="c-41650791">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for your feedback.<p>I understand that working with tasks and retrieving values can feel a bit clunky. The main reason I&#x27;ve structured it this way is that individual tasks are RAII objects, and their coroutine state is destroyed once they go out of scope. However, I could modify the awaitable returned from wait_tasks to store tasks, and then return values directly to the user. This could definitely be a more ergonomic overload for the function. I&#x27;ll look into it!</div><br/></div></div><div id="41651087" class="c"><input type="checkbox" id="c-41651087" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#41650361">parent</a><span>|</span><a href="#41650791">prev</a><span>|</span><a href="#41654966">next</a><span>|</span><label class="collapse" for="c-41651087">[-]</label><label class="expand" for="c-41651087">[1 more]</label></div><br/><div class="children"><div class="content">If you need this interface, use threads.</div><br/></div></div></div></div><div id="41654966" class="c"><input type="checkbox" id="c-41654966" checked=""/><div class="controls bullet"><span class="by">ldb</span><span>|</span><a href="#41650361">prev</a><span>|</span><a href="#41653491">next</a><span>|</span><label class="collapse" for="c-41654966">[-]</label><label class="expand" for="c-41654966">[1 more]</label></div><br/><div class="children"><div class="content">A great project.<p>FYI: I guess there is a minor typo in the README example: the argument of the second call to fib() in the non-coros version of the code should be &quot;n-2&quot; and not &quot;n-1&quot;.</div><br/></div></div><div id="41653491" class="c"><input type="checkbox" id="c-41653491" checked=""/><div class="controls bullet"><span class="by">BenFrantzDale</span><span>|</span><a href="#41654966">prev</a><span>|</span><a href="#41650513">next</a><span>|</span><label class="collapse" for="c-41653491">[-]</label><label class="expand" for="c-41653491">[2 more]</label></div><br/><div class="children"><div class="content">Have you compared perf with the reference implementation of the P2300 “Senders” proposal? <a href="https:&#x2F;&#x2F;github.com&#x2F;NVIDIA&#x2F;stdexec">https:&#x2F;&#x2F;github.com&#x2F;NVIDIA&#x2F;stdexec</a></div><br/><div id="41653629" class="c"><input type="checkbox" id="c-41653629" checked=""/><div class="controls bullet"><span class="by">mrkent27</span><span>|</span><a href="#41653491">parent</a><span>|</span><a href="#41650513">next</a><span>|</span><label class="collapse" for="c-41653629">[-]</label><label class="expand" for="c-41653629">[1 more]</label></div><br/><div class="children"><div class="content">I came here to comment the same thing. Senders&#x2F;receivers have the added advantage of not allocating unlike coroutines that have to (usually) allocate on the heap.</div><br/></div></div></div></div><div id="41650513" class="c"><input type="checkbox" id="c-41650513" checked=""/><div class="controls bullet"><span class="by">leeter</span><span>|</span><a href="#41653491">prev</a><span>|</span><a href="#41651971">next</a><span>|</span><label class="collapse" for="c-41650513">[-]</label><label class="expand" for="c-41650513">[3 more]</label></div><br/><div class="children"><div class="content">Looks like a good start. I&#x27;m not actually sure I&#x27;d use it on windows however. CPPWinrt has a really decent coroutine support library with tools like winrt::resume_background() [1], I use it extensively even in desktop apps because it makes using the windows threadpool (which is active by default for all windows processes since at least windows 7) trivial. I&#x27;ve basically moved most of my threading code onto that unless I need a dedicated thread to hold a context for some reason. But, that&#x27;s a windows specific thing as far as I know.<p>[1] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;uwp&#x2F;cpp-ref-for-winrt&#x2F;resume-background" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;uwp&#x2F;cpp-ref-for-winrt&#x2F;resu...</a></div><br/><div id="41650955" class="c"><input type="checkbox" id="c-41650955" checked=""/><div class="controls bullet"><span class="by">singledigits</span><span>|</span><a href="#41650513">parent</a><span>|</span><a href="#41651971">next</a><span>|</span><label class="collapse" for="c-41650955">[-]</label><label class="expand" for="c-41650955">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for your response!<p>I don&#x27;t have experience with WinRT, but it does seem quite similar at first glance. One of the key reasons I focused on modern C++ was to ensure cross-platform compatibility. However, I completely understand that if you&#x27;re working on Windows and are already familiar with WinRT, sticking with it makes perfect sense. I&#x27;ll take a closer look at WinRT to see if there are any significant differences.</div><br/><div id="41651974" class="c"><input type="checkbox" id="c-41651974" checked=""/><div class="controls bullet"><span class="by">leeter</span><span>|</span><a href="#41650513">root</a><span>|</span><a href="#41650955">parent</a><span>|</span><a href="#41651971">next</a><span>|</span><label class="collapse" for="c-41651974">[-]</label><label class="expand" for="c-41651974">[1 more]</label></div><br/><div class="children"><div class="content">My suggestion is aim for compatibility with cppwinrt, but not anything else. That way devs can freely intermix and get the best of the utilities of both.</div><br/></div></div></div></div></div></div><div id="41651971" class="c"><input type="checkbox" id="c-41651971" checked=""/><div class="controls bullet"><span class="by">cxx</span><span>|</span><a href="#41650513">prev</a><span>|</span><a href="#41648663">next</a><span>|</span><label class="collapse" for="c-41651971">[-]</label><label class="expand" for="c-41651971">[1 more]</label></div><br/><div class="children"><div class="content">This looks very promising, it&#x27;s refreshing to see a library with a sane interface.<p>One thing I&#x27;d like to see is the possibility to run the coroutines in the main thread, without spawning any new threads in the thread pool. It might seem strange but sometimes you just need to do I&#x2F;O stuff concurrently in a place where you&#x27;re not allowed to spawn other threads.<p>Other than that congrats on the release, I hope you keep working on it!</div><br/></div></div><div id="41648663" class="c"><input type="checkbox" id="c-41648663" checked=""/><div class="controls bullet"><span class="by">tlb</span><span>|</span><a href="#41651971">prev</a><span>|</span><a href="#41649222">next</a><span>|</span><label class="collapse" for="c-41648663">[-]</label><label class="expand" for="c-41648663">[2 more]</label></div><br/><div class="children"><div class="content">In your dequeue&#x2F;circular buffer implementation, how is it able to grow the queue without locking?<p>The code seems to rely on atomics for head &amp; tail, but grows the queue without any special provisions I can see.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mtmucha&#x2F;coros&#x2F;blob&#x2F;ee30d3c1d0602c3071aa267eb7e4baddf9ce95fa&#x2F;include&#x2F;deque.h#L119">https:&#x2F;&#x2F;github.com&#x2F;mtmucha&#x2F;coros&#x2F;blob&#x2F;ee30d3c1d0602c3071aa26...</a></div><br/><div id="41648844" class="c"><input type="checkbox" id="c-41648844" checked=""/><div class="controls bullet"><span class="by">singledigits</span><span>|</span><a href="#41648663">parent</a><span>|</span><a href="#41649222">next</a><span>|</span><label class="collapse" for="c-41648844">[-]</label><label class="expand" for="c-41648844">[1 more]</label></div><br/><div class="children"><div class="content">The concept behind the deque is explained in Correct and Efficient Work-Stealing for Weak Memory Models [1].<p>The idea is that only the owning thread can push tasks into the deque. If the owning thread detects that the deque is full, it creates a new one and copies the original values. Once the copy is ready, the owning thread &quot;publishes&quot; it by storing it in the buffer variable. Pointers to the deque are atomic, as well as the indices. Other threads can manipulate only the indices, and even if a stealing thread has an old pointer, it still points to valid data.<p>I hope I understood your question correctly and that this answer is helpful. You can find more details in the paper mentioned above.<p>[1] <a href="https:&#x2F;&#x2F;inria.hal.science&#x2F;hal-00802885&#x2F;document" rel="nofollow">https:&#x2F;&#x2F;inria.hal.science&#x2F;hal-00802885&#x2F;document</a></div><br/></div></div></div></div><div id="41649222" class="c"><input type="checkbox" id="c-41649222" checked=""/><div class="controls bullet"><span class="by">viralsink</span><span>|</span><a href="#41648663">prev</a><span>|</span><a href="#41648813">next</a><span>|</span><label class="collapse" for="c-41649222">[-]</label><label class="expand" for="c-41649222">[3 more]</label></div><br/><div class="children"><div class="content">Is there a way to prevent callback hell in C++ when doing asynchronous communication with C++ before 20? Coroutines seem to be the only clean solution. Promises can work, but they tend to be difficult to reason about if branching is involved.</div><br/><div id="41651936" class="c"><input type="checkbox" id="c-41651936" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41649222">parent</a><span>|</span><a href="#41649503">next</a><span>|</span><label class="collapse" for="c-41651936">[-]</label><label class="expand" for="c-41651936">[1 more]</label></div><br/><div class="children"><div class="content">There are library-only stackful coroutines options, like in boost.</div><br/></div></div><div id="41649503" class="c"><input type="checkbox" id="c-41649503" checked=""/><div class="controls bullet"><span class="by">darknavi</span><span>|</span><a href="#41649222">parent</a><span>|</span><a href="#41651936">prev</a><span>|</span><a href="#41648813">next</a><span>|</span><label class="collapse" for="c-41649503">[-]</label><label class="expand" for="c-41649503">[1 more]</label></div><br/><div class="children"><div class="content">Traditionally the way to prevent &quot;callback hell&quot; is to use something like async&#x2F;await syntax.  Without that there aren&#x27;t a ton of good options.  Like you mentioned, you could switch to promises with polling.</div><br/></div></div></div></div><div id="41648813" class="c"><input type="checkbox" id="c-41648813" checked=""/><div class="controls bullet"><span class="by">throwaway_94404</span><span>|</span><a href="#41649222">prev</a><span>|</span><a href="#41652203">next</a><span>|</span><label class="collapse" for="c-41648813">[-]</label><label class="expand" for="c-41648813">[15 more]</label></div><br/><div class="children"><div class="content">I just can&#x27;t get my brain around coroutines.<p>Can anyone recommend a good tutorial or resource for me to read.<p>I find it so frustrating as I don&#x27;t think it&#x27;s necessarily a complex subject but my brain just doesn&#x27;t get it.<p>Related perhaps but many (many, many) years ago, when learning BASIC, I assumed GOSUB went off and started executing the code in the subroutine as well as the rest of the inline code.  That suggests to me that I should perhaps have a deeper understanding of this but I really don&#x27;t...</div><br/><div id="41649048" class="c"><input type="checkbox" id="c-41649048" checked=""/><div class="controls bullet"><span class="by">singledigits</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41650009">next</a><span>|</span><label class="collapse" for="c-41649048">[-]</label><label class="expand" for="c-41649048">[3 more]</label></div><br/><div class="children"><div class="content">I feel you! Coroutines can be tricky at first. I recommend Lewis Baker&#x27;s blog about coroutines [1], which is detailed and insightful. Additionally, cppreference [2] is a great resource to understand how coroutines work in C++.<p>In a nutshell, C++ coroutines are almost like regular functions, except that they can be &quot;paused&quot; (suspended), and their state is stored on the heap so they can be resumed later. When you resume a coroutine, its state is loaded back, and execution continues from where it left off.<p>The complicated part comes from the interfaces through which you use coroutines in C++. Each coroutine needs to be associated with a promise object, which defines how the coroutine behaves (for example, what happens when you co_return a value). Then, there are awaiters, which define what happens when you co_await them. For example, C++ provides a built-in awaiter called suspend_always{}, which you can co_await to pause the coroutine.<p>If you take your time and go thoroughly through the blog and Cppreference, you&#x27;ll definitely get the hang of it.<p>Hope this helps.<p>[1] <a href="https:&#x2F;&#x2F;lewissbaker.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lewissbaker.github.io&#x2F;</a>
[2] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;coroutines" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;coroutines</a></div><br/><div id="41649476" class="c"><input type="checkbox" id="c-41649476" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41648813">root</a><span>|</span><a href="#41649048">parent</a><span>|</span><a href="#41650009">next</a><span>|</span><label class="collapse" for="c-41649476">[-]</label><label class="expand" for="c-41649476">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;re just green threads with some nice syntax sugar, right?  Instead of an OS-level &quot;pause&quot; with a futex-wait or sleep (resumed by the kernel scheduler), they do an application-level pause and require some application-level scheduler.  (But coroutines can still call library or kernel functions that block&#x2F;sleep, breaking userspace scheduling?)</div><br/><div id="41651837" class="c"><input type="checkbox" id="c-41651837" checked=""/><div class="controls bullet"><span class="by">singledigits</span><span>|</span><a href="#41648813">root</a><span>|</span><a href="#41649476">parent</a><span>|</span><a href="#41650009">next</a><span>|</span><label class="collapse" for="c-41651837">[-]</label><label class="expand" for="c-41651837">[1 more]</label></div><br/><div class="children"><div class="content">Yes, exactly. Coroutines are one possible implementation of green threads. Once they are scheduled&#x2F;loaded on an OS thread, they behave just like regular functions with their own call stack. This means they can indeed call blocking operations at the OS level. A possible approach to handle such operations would be to wrap the blocking call, suspend the coroutine, and then resume it once the operation is complete, perhaps by polling(checking for completion).</div><br/></div></div></div></div></div></div><div id="41650009" class="c"><input type="checkbox" id="c-41650009" checked=""/><div class="controls bullet"><span class="by">marhee</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41649048">prev</a><span>|</span><a href="#41649056">next</a><span>|</span><label class="collapse" for="c-41650009">[-]</label><label class="expand" for="c-41650009">[1 more]</label></div><br/><div class="children"><div class="content">Coroutines are just multiple call stacks. If coroutine A calls coroutine B then B excutes on its on stack and can ‘yield’ a value back to A. Yielding is just a return across stacks without destroying the current stack. So A continued with the yielded valie on its own stack and when ready calls B again which continues on its own stack with the next statement after the previous yield. Etc.<p>Notice that this does not necessarily involve parallelism, although it can. For example, Lua has non parallel (cooperative) co-routines. Go had parallel coroutins, called goroutines, but theoretically only if they they use channels to exchange values. Otherwise, if they’re not  exchanging information they would not becoroutins in the sense that they work together in solving something.</div><br/></div></div><div id="41649056" class="c"><input type="checkbox" id="c-41649056" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41650009">prev</a><span>|</span><a href="#41649946">next</a><span>|</span><label class="collapse" for="c-41649056">[-]</label><label class="expand" for="c-41649056">[1 more]</label></div><br/><div class="children"><div class="content">Dumbed down way too far.<p>They are a function that can remember where they are in their own execution so when they are called later they continue execution where they left of.<p>There are many many ways of implementing that functionality, C++ standard coroutines are only one such implementation.<p>What you do with them is whatever you want, it&#x27;s pretty common to handle IO using them but generators are also a pretty common example. But that is generally high level.<p>C++ coroutines are basic building blocks and are very low level, there is no executor ( rust tokio &#x2F; python asyncio ) so don&#x27;t be worried if it seems hard to use, it is hard to use.<p>Look at std::generator for how coroutines are used to implement a generator, cppcoro is also a pretty popular library that builds abstractions on top of coroutines and also has some executors if I remember correctly.</div><br/></div></div><div id="41649946" class="c"><input type="checkbox" id="c-41649946" checked=""/><div class="controls bullet"><span class="by">dxuh</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41649056">prev</a><span>|</span><a href="#41649700">next</a><span>|</span><label class="collapse" for="c-41649946">[-]</label><label class="expand" for="c-41649946">[1 more]</label></div><br/><div class="children"><div class="content">Coroutines themselves are a really simple concept. But in practice they give you all the headaches async stuff generally gives you. And in C++ there is a <i>ton</i> of extra complication, especially because there is no support library. I wrote this in a tutorial a while ago:<p>&gt; they are functions that can suspend themselves, meaning they stop themselves without returning, even in the middle of their body and then can later can be resumed, continuing execution at the point they suspended from earlier.<p>If you want to use coroutines in C++ specifically you can have a look at this tutorial, if you want: <a href="https:&#x2F;&#x2F;theshoemaker.de&#x2F;posts&#x2F;yet-another-cpp-coroutine-tutorial" rel="nofollow">https:&#x2F;&#x2F;theshoemaker.de&#x2F;posts&#x2F;yet-another-cpp-coroutine-tuto...</a>
I don&#x27;t know of anyone that read it, but I spent a lot of time on it.<p>It essentially tries to explain how to build a coroutine support library yourself, but if you don&#x27;t care about that, skip it and just use libcoro or cppcoro. They have examples too. My little async io library has some examples as well if you want to get an idea.</div><br/></div></div><div id="41649700" class="c"><input type="checkbox" id="c-41649700" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41649946">prev</a><span>|</span><a href="#41651533">next</a><span>|</span><label class="collapse" for="c-41649700">[-]</label><label class="expand" for="c-41649700">[1 more]</label></div><br/><div class="children"><div class="content">One way to get a sense of coroutines is to consider the behavior presented by the async&#x2F;await design pattern [1], where &#x27;await&#x27; suspends the execution of the currently running code and yields control to the &#x27;async&#x27; task. (As an adage goes, &quot;async is not asynchronous, and await does not await anything.&quot;) Yet another pattern is &quot;promise&#x2F;future&quot;, where the code execution is (or may be) suspended as soon as the code tries to obtain the promised result.<p>[1] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;asynchronous-programming&#x2F;async-scenarios" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;asynchronous...</a></div><br/></div></div><div id="41651533" class="c"><input type="checkbox" id="c-41651533" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41649700">prev</a><span>|</span><a href="#41648886">next</a><span>|</span><label class="collapse" for="c-41651533">[-]</label><label class="expand" for="c-41651533">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t understand C++ coroutines until I learned to use Lua coroutines.  It&#x27;s basically not that different from gotos, if goto saved local state.</div><br/></div></div><div id="41648886" class="c"><input type="checkbox" id="c-41648886" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41651533">prev</a><span>|</span><a href="#41649144">next</a><span>|</span><label class="collapse" for="c-41648886">[-]</label><label class="expand" for="c-41648886">[3 more]</label></div><br/><div class="children"><div class="content">Do you mean C++ coroutines, or coroutines in general? If you&#x27;re new to the concept I would try to start with Python&#x27;s, then Javascript or C#. C++&#x27;s is way more complicated.</div><br/><div id="41649261" class="c"><input type="checkbox" id="c-41649261" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41648813">root</a><span>|</span><a href="#41648886">parent</a><span>|</span><a href="#41648998">next</a><span>|</span><label class="collapse" for="c-41649261">[-]</label><label class="expand" for="c-41649261">[1 more]</label></div><br/><div class="children"><div class="content">Note that C# and C++ are quite similar, the biggest difference are the lifetime gotchas and not having coroutines runtime on the standard library.<p>Their design has a common source, and the magic methods for awaitables as well.</div><br/></div></div></div></div><div id="41649144" class="c"><input type="checkbox" id="c-41649144" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41648886">prev</a><span>|</span><a href="#41648989">next</a><span>|</span><label class="collapse" for="c-41649144">[-]</label><label class="expand" for="c-41649144">[1 more]</label></div><br/><div class="children"><div class="content">imagine a virtual (green) thread which the kernel doesn&#x27;t run in parallel until you tell it it&#x27;s ok to do so (when you explicitly yield control) and then can continue from that place when you explicitly tell it to.<p>you can even try to run those virtual threads on real threads. much fun to be had.</div><br/></div></div><div id="41648989" class="c"><input type="checkbox" id="c-41648989" checked=""/><div class="controls bullet"><span class="by">SolarNet</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41649144">prev</a><span>|</span><a href="#41652217">next</a><span>|</span><label class="collapse" for="c-41648989">[-]</label><label class="expand" for="c-41648989">[1 more]</label></div><br/><div class="children"><div class="content">Co-routines can be a nebulous sort of concept because it means different things in different places and not all of them have the same features. But some of the big points are:<p>- Heap allocated call frame. Instead of being pushed onto the stack, co-routines tend to have their call frame (local variables, arguments, etc.) placed into heap memory (or at least <i>may</i> be place-able into heap memory). This often enables the other features.<p>- Control can leave co-routines in more ways than standard function calls. Generally this means returning (often called &quot;yield&quot;) to the caller without completing the whole function. It can then be later resumed, returning to where the function originally left off. Generators are a common pattern enabled by co-routines that rely on only this part (and so many systems can optimize out the heap usage, for example).<p>- A co-routine is usually an object with an interface that allows you to move it around and resume it in different places than it was originally called. This can include on different threads, or depending on the sophistication of the system, different processes or machines.<p>Those are the three big points in my mind. I&#x27;d recommend trying lua coroutines, personally (I like minmalist engines like defold to use it in) to really get a feel for how these are on the edge between &quot;language feature&quot; and &quot;library feature&quot;.</div><br/></div></div><div id="41652217" class="c"><input type="checkbox" id="c-41652217" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41648813">parent</a><span>|</span><a href="#41648989">prev</a><span>|</span><a href="#41652203">next</a><span>|</span><label class="collapse" for="c-41652217">[-]</label><label class="expand" for="c-41652217">[1 more]</label></div><br/><div class="children"><div class="content">Yeah there aren&#x27;t many good resources on it unfortunately. One thing to note is C++20&#x27;s coroutine support is <i>really</i> low level. It&#x27;s designed for library authors so that they can build the kinds of things &quot;normal&quot; people want - tasks, generators, futures, promises, etc.<p>This video is the best intro I&#x27;ve found. It actually explains what is happening in memory, which is the only way to really understand anything in C++.<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;aibjUHx7vew" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;aibjUHx7vew</a><p>Also this is decent:<p><a href="https:&#x2F;&#x2F;www.scs.stanford.edu&#x2F;~dm&#x2F;blog&#x2F;c++-coroutines.html" rel="nofollow">https:&#x2F;&#x2F;www.scs.stanford.edu&#x2F;~dm&#x2F;blog&#x2F;c++-coroutines.html</a><p>But don&#x27;t try and write a coroutine library yourself. Use something like libcoro.</div><br/></div></div></div></div><div id="41652203" class="c"><input type="checkbox" id="c-41652203" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#41648813">prev</a><span>|</span><a href="#41649096">next</a><span>|</span><label class="collapse" for="c-41652203">[-]</label><label class="expand" for="c-41652203">[1 more]</label></div><br/><div class="children"><div class="content">Have you had a look at SeaStar and how it works with coroutines?</div><br/></div></div><div id="41649096" class="c"><input type="checkbox" id="c-41649096" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#41652203">prev</a><span>|</span><a href="#41649188">next</a><span>|</span><label class="collapse" for="c-41649096">[-]</label><label class="expand" for="c-41649096">[3 more]</label></div><br/><div class="children"><div class="content">How is this library different from Boost.Cobalt and cppcoro?</div><br/><div id="41649274" class="c"><input type="checkbox" id="c-41649274" checked=""/><div class="controls bullet"><span class="by">singledigits</span><span>|</span><a href="#41649096">parent</a><span>|</span><a href="#41649705">next</a><span>|</span><label class="collapse" for="c-41649274">[-]</label><label class="expand" for="c-41649274">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for your question.<p>I&#x27;ve included a link to Lewis Baker&#x27;s blog (the author of CppCoro) in my repository as an excellent explanation of coroutines. From my understanding, after reviewing his library, it is no longer in active development and hasn’t been updated for a couple of years. CppCoro was an experimental library intended to explore coroutines while they were still an experimental feature. For example, CppCoro uses a custom type for storing values, similar to std::optional from the standard library (if I&#x27;m not mistaken).<p>For my implementation, I&#x27;ve opted to leverage std::expected from C++23 for storing values. I&#x27;ve also implemented monadic-like chaining. CppCoro, however, seems to focus more on asynchronous operations, whereas my library focuses more on task-based parallelism.<p>I don&#x27;t have experience with Boost.Cobalt, so I can&#x27;t provide insights there, but I will definitely look into it now that you&#x27;ve mentioned it.<p>Hope this helps.</div><br/></div></div><div id="41649705" class="c"><input type="checkbox" id="c-41649705" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#41649096">parent</a><span>|</span><a href="#41649274">prev</a><span>|</span><a href="#41649188">next</a><span>|</span><label class="collapse" for="c-41649705">[-]</label><label class="expand" for="c-41649705">[1 more]</label></div><br/><div class="children"><div class="content">I think Op&#x27;s lib is for fork-join style parallel algorithms. It&#x27;s like TBB but is based on continuation stealing. Boost.Cobalt and cppcoro are general coroutine libs. They are mostly used for async IO programming.</div><br/></div></div></div></div><div id="41649188" class="c"><input type="checkbox" id="c-41649188" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41649096">prev</a><span>|</span><label class="collapse" for="c-41649188">[-]</label><label class="expand" for="c-41649188">[3 more]</label></div><br/><div class="children"><div class="content">This looks <i>exactly</i> like .NET&#x27;s task abstraction.<p>If it works anywhere near as good, I&#x27;m definitely giving this a try next time I need to work on a C++ project. Thanks!</div><br/><div id="41649234" class="c"><input type="checkbox" id="c-41649234" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41649188">parent</a><span>|</span><a href="#41649349">next</a><span>|</span><label class="collapse" for="c-41649234">[-]</label><label class="expand" for="c-41649234">[1 more]</label></div><br/><div class="children"><div class="content">As historical note for those that don&#x27;t follow C++, C++20 co-routines grew up from the work done with asynchronous programming on WinRT for C# and C++, inspired by Midori and .NET async&#x2F;await.<p>Most of the magic methods expected by C++ compilers in awaitable types, are also present in the structured typing used by C# for awaitables.<p>The preview implementation for VC++ and clang were done by a Microsoft employee, Gor Nishanov, his talks are always quite interesting.</div><br/></div></div><div id="41649349" class="c"><input type="checkbox" id="c-41649349" checked=""/><div class="controls bullet"><span class="by">singledigits</span><span>|</span><a href="#41649188">parent</a><span>|</span><a href="#41649234">prev</a><span>|</span><label class="collapse" for="c-41649349">[-]</label><label class="expand" for="c-41649349">[1 more]</label></div><br/><div class="children"><div class="content">Hopefully, you find it useful! If you have any ideas or suggestions for improvement, feel free to open an issue or let me know. Thanks for considering it!</div><br/></div></div></div></div></div></div></div></div></div></body></html>