<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688806856383" as="style"/><link rel="stylesheet" href="styles.css?v=1688806856383"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/akutruff/typescript-needs-types">TypeScript please give us reflection/runtime types</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>decs</span> | <span>215 comments</span></div><br/><div><div id="36637819" class="c"><input type="checkbox" id="c-36637819" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36638486">next</a><span>|</span><label class="collapse" for="c-36637819">[-]</label><label class="expand" for="c-36637819">[72 more]</label></div><br/><div class="children"><div class="content">I had to read their problem statement like 4 times to understand what they are asking for. This is exactly why simple, concise writing is essential, and their wall of text is...not it.<p>&gt; I love you. You do amazing work. You are gods among mortals. You have brought JavaScript from the darkness, and given it the warm light of strong typing. Look upon us, the cowering meek masses, and understand that we live in the muck and mire of a world where we are doomed to endlessly crawl on our bellies through the alleys of Github seeking the one true npm. We will forever wonder in the dark, until we have a type reflection model.<p>What even are they getting at?<p>As for their actual ask (runtime type safety), it is probably not going to happen because the TypeScript project has drawn the line at not being an alternate or additive runtime for JavaScript. Their job is simply to compile down to JS code and exit the picture. Whatever happens after that (in V8 or elsewhere) is your own business.<p>&gt; TypeScript Needs to Emit Runtime Type Information<p>This is not possible at all because TypeScript is a <i>compiler</i>. They are really asking for a net new product which has very little to do with the TypeScript that exists today.</div><br/><div id="36638146" class="c"><input type="checkbox" id="c-36638146" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36639617">next</a><span>|</span><label class="collapse" for="c-36638146">[-]</label><label class="expand" for="c-36638146">[42 more]</label></div><br/><div class="children"><div class="content">Nit: they&#x27;re not asking for runtime type safety; they&#x27;re asking for the ability to reflect on types (at compile time, to generate values) so that they can use type information at runtime.<p>This helps ensure runtime type safety because (for example) it would be great to have a generic &quot;validation&quot; function that takes an arbitrary interface and an arbitrary object and validates that object. One way to implement this would be to use &#x2F;compile time&#x2F; reflection to generate code (TS code hypothetical, because I write C++ nowadays):<p><pre><code>  function validate&lt;T&gt;(obj: Any): T | null {
    switch constexpr (T) {
    case String:
      return typeof obj == &quot;string&quot; ? obj : null;
    case Array&lt;U&gt;
      if (!Array.isArray(obj)) {
        return null;
      }
      for (const u of obj) {
        if (validate&lt;U&gt;(u) == null) {
          return null;
        }
      }
      return obj;
    &#x2F;&#x2F; ... more base cases
    }

    for (const prop: (keyof T) of Reflect&lt;T&gt;.Properties()) {
      if (validate&lt;T[prop]&gt;(obj[prop]) == null) {
        return null;
      }
    }

    return obj;
  }

  interface Date {
    year: String;
    month: String;
    day: String;
  }
</code></pre>
It would be great if this could generate &#x2F;JavaScript&#x2F; code:<p><pre><code>  function validate__String__(obj) {
    return typeof obj == &quot;string&quot; ? obj : null;
  }
 
  function validate__Array$Date$__(obj) {
    if (!Array.isArray(obj)) {
      return null;
    }
    for (const u of obj) {
      if (validate__Date__(u) == null) {
        return null;
      }
    }
    return obj;
  }

  function validate__Date__(obj) {
    for (const prop of [&quot;year&quot;, &quot;month&quot;, &quot;day&quot;])) {
      if (validate__String__(obj[prop]) == null) {
        return null;
      }
    }
    return obj;
  }
</code></pre>
Unfortunately this is not possible (AFAIK) in TypeScript currently, and will not be possible with TypeScript&#x27;s current philosophy.<p>(The above example is a hypothetical TypeScript compiler that might support &quot;templated&quot; generic functions; with just RTTI TypeScript could accomplish the same thing in a non-templated function by passing in `T` as a function parameter at runtime and doing runtime comparisons on `T`.)</div><br/><div id="36638615" class="c"><input type="checkbox" id="c-36638615" checked=""/><div class="controls bullet"><span class="by">RyanCavanaugh</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638146">parent</a><span>|</span><a href="#36638345">next</a><span>|</span><label class="collapse" for="c-36638615">[-]</label><label class="expand" for="c-36638615">[11 more]</label></div><br/><div class="children"><div class="content">Not to be flip, but if it were really all this easy, we would have done it already.<p>There are dozens of questions you can throw at this code: What if the input&#x27;s a union? What if it&#x27;s a nested union -- how do you avoid combinatorial explosion? What if the input is a function -- how do you validate its parameter types using runtime information? What if the input is a conditional type? What if you&#x27;re inside a generic function? The list is enormous and it quickly gets into &quot;you&#x27;ve dug too deep and unleashed a Balrog&quot; territory once you get beyond the primitives.</div><br/><div id="36642548" class="c"><input type="checkbox" id="c-36642548" checked=""/><div class="controls bullet"><span class="by">KnobbleMcKnees</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638615">parent</a><span>|</span><a href="#36641188">next</a><span>|</span><label class="collapse" for="c-36642548">[-]</label><label class="expand" for="c-36642548">[1 more]</label></div><br/><div class="children"><div class="content">It is easy. It&#x27;s just a terrible idea.<p>(So as it turns out having thought about it a bit, I am vehemently against this idea.)<p>Type reflection at runtime would require polluting the JS environment with a lot of cruft.<p>That might be a global object and lots of helper functions to query types. It might also be tagging objects and fields with additional properties that need to be treated as reserved.<p>There is certainly no way to do this that doesn&#x27;t make assumptions about the runtime environment in a way that will cause a mountain of issues further down the line.<p>The other reason for my disdain is: the need to infer types at runtime is almost certainly indicative of an architectural issue with your code. If you aren&#x27;t able to write viable code in a given context without requiring runtime type querying then you should step back from your intent and re-evaluate your code structure.</div><br/></div></div><div id="36641188" class="c"><input type="checkbox" id="c-36641188" checked=""/><div class="controls bullet"><span class="by">oorza</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638615">parent</a><span>|</span><a href="#36642548">prev</a><span>|</span><a href="#36641150">next</a><span>|</span><label class="collapse" for="c-36641188">[-]</label><label class="expand" for="c-36641188">[2 more]</label></div><br/><div class="children"><div class="content">Why don&#x27;t you just make the transformer API stable, public, and let the community do the hard part? There&#x27;s plenty of us that have experimental transformers doing all sorts of fun things, these are problems that can be solved external to TS.<p>I&#x27;ve got a fully functional compile-time dependency injection container that I&#x27;ve been sitting on for literal years because the transformer API isn&#x27;t public.</div><br/><div id="36642026" class="c"><input type="checkbox" id="c-36642026" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36641188">parent</a><span>|</span><a href="#36641150">next</a><span>|</span><label class="collapse" for="c-36642026">[-]</label><label class="expand" for="c-36642026">[1 more]</label></div><br/><div class="children"><div class="content">^^^ Please do this. I&#x27;m completely ok with &quot;using transformers voids your nonexistent warranty&quot; and the community can deal with transformer API churn. Exposing the API makes it easier to adopt those community solutions, versus me needing to explain to teammates why I switched all the `tsc` invocations to `ttsc` and promise it&#x27;s not that sketchy.</div><br/></div></div></div></div><div id="36641150" class="c"><input type="checkbox" id="c-36641150" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638615">parent</a><span>|</span><a href="#36641188">prev</a><span>|</span><a href="#36639888">next</a><span>|</span><label class="collapse" for="c-36641150">[-]</label><label class="expand" for="c-36641150">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Not to be flip, but if it were really all this easy, we would have done it already.<p>Typescript is mature. There is no low hanging fruit to be develop.<p>I don&#x27;t necessarily think it needs this but this is hardly the right grounds to dismiss it.</div><br/><div id="36641934" class="c"><input type="checkbox" id="c-36641934" checked=""/><div class="controls bullet"><span class="by">afiori</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36641150">parent</a><span>|</span><a href="#36639888">next</a><span>|</span><label class="collapse" for="c-36641934">[-]</label><label class="expand" for="c-36641934">[1 more]</label></div><br/><div class="children"><div class="content">I do not think that they mean that all easy things have been done, rather that if this feature was easy then it would already exist</div><br/></div></div></div></div><div id="36639888" class="c"><input type="checkbox" id="c-36639888" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638615">parent</a><span>|</span><a href="#36641150">prev</a><span>|</span><a href="#36639130">next</a><span>|</span><label class="collapse" for="c-36639888">[-]</label><label class="expand" for="c-36639888">[2 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m very mistaken, but to me it seems this code snippet is basically an alternative to writing a ton of &quot;infer&quot;-s and overloads, no? So the same pattern matching could be used in the &quot;switch&quot;. Whatever the complier knows can be locally matched, and the combinations have to be already handled by the developer.</div><br/><div id="36640279" class="c"><input type="checkbox" id="c-36640279" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639888">parent</a><span>|</span><a href="#36639130">next</a><span>|</span><label class="collapse" for="c-36640279">[-]</label><label class="expand" for="c-36640279">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to come up with a compiler that produces a sound checker for arbitrarily complex union&#x2F;intersection types. Perhaps there could be a restriction on reflection to &quot;simple enough&quot; types, but that&#x27;s always going to be a weirdly moving target based on heuristics. There&#x27;s already cases where Typescript tries to generate ~40MB+ .d.ts files which are just re-stating the types themselves. So it&#x27;s easy to imagine a validator compiler emitting 100MB+ of code to check more wild and crazy types.</div><br/></div></div></div></div><div id="36639130" class="c"><input type="checkbox" id="c-36639130" checked=""/><div class="controls bullet"><span class="by">twosdai</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638615">parent</a><span>|</span><a href="#36639888">prev</a><span>|</span><a href="#36638345">next</a><span>|</span><label class="collapse" for="c-36639130">[-]</label><label class="expand" for="c-36639130">[3 more]</label></div><br/><div class="children"><div class="content">Can we just start with primitives and see what happens.</div><br/><div id="36639265" class="c"><input type="checkbox" id="c-36639265" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639130">parent</a><span>|</span><a href="#36638345">next</a><span>|</span><label class="collapse" for="c-36639265">[-]</label><label class="expand" for="c-36639265">[2 more]</label></div><br/><div class="children"><div class="content">JavaScript already has this. It&#x27;s called typeof.</div><br/><div id="36641654" class="c"><input type="checkbox" id="c-36641654" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639265">parent</a><span>|</span><a href="#36638345">next</a><span>|</span><label class="collapse" for="c-36641654">[-]</label><label class="expand" for="c-36641654">[1 more]</label></div><br/><div class="children"><div class="content">And instanceof</div><br/></div></div></div></div></div></div></div></div><div id="36638345" class="c"><input type="checkbox" id="c-36638345" checked=""/><div class="controls bullet"><span class="by">TheRealPomax</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638146">parent</a><span>|</span><a href="#36638615">prev</a><span>|</span><a href="#36638396">next</a><span>|</span><label class="collapse" for="c-36638345">[-]</label><label class="expand" for="c-36638345">[18 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the thing though: if you wrote your TS properly, <i>you don&#x27;t need this</i> and asking for it just highlights that you&#x27;re not using TS the way it&#x27;s meant to be used.<p>The only place you need runtime type enforcement (when you&#x27;re writing your own code in TS) is for validating third party data at the point where you&#x27;re ingesting it into your own code. Once it&#x27;s in there, <i>it is type safe</i> if you used TS to compile your code to JS, because your function calls and data copies and everything else that moves data around was defined in terms of compatible shapes.<p>And we already have runtime validation libraries to cover that validation step. So many of them.</div><br/><div id="36640811" class="c"><input type="checkbox" id="c-36640811" checked=""/><div class="controls bullet"><span class="by">ncallaway</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638345">parent</a><span>|</span><a href="#36638398">next</a><span>|</span><label class="collapse" for="c-36640811">[-]</label><label class="expand" for="c-36640811">[7 more]</label></div><br/><div class="children"><div class="content">&gt; And we already have runtime validation libraries to cover that validation step.<p>Right, but now my type information for inbound data must be in two places: the typescript type, and the validation schema. And heaven forbid I make a mistake and those two become out of sync.<p>Yes, I can use something like zod to define a schema then infer the type from it, but those inferred types are often â¦ suboptimal to work with.</div><br/><div id="36641202" class="c"><input type="checkbox" id="c-36641202" checked=""/><div class="controls bullet"><span class="by">rizky05</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36640811">parent</a><span>|</span><a href="#36638398">next</a><span>|</span><label class="collapse" for="c-36641202">[-]</label><label class="expand" for="c-36641202">[6 more]</label></div><br/><div class="children"><div class="content">Zod is great, why do you think it is suboptimal ?</div><br/><div id="36641967" class="c"><input type="checkbox" id="c-36641967" checked=""/><div class="controls bullet"><span class="by">lf-non</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36641202">parent</a><span>|</span><a href="#36642015">next</a><span>|</span><label class="collapse" for="c-36641967">[-]</label><label class="expand" for="c-36641967">[2 more]</label></div><br/><div class="children"><div class="content">I love zod and use it daily.<p>It is also the most frequent thing where junior developers get stuck. TS tooling doesn&#x27;t make it very easy to work with large extracted types though it is head and shoulders above other mainstream languages. The error messages often become incomprehensible walls of text once your types are Complex enough, and then tsserver will just truncate the type info in pop overs making them useless.<p>I am personally OK to live with all of the above. My single issue with zod is that it is not easy to use if you don&#x27;t own your types. If your types are coming from a third party lib you don&#x27;t have an easy path to derive runtypes from them. If the concept of runtypes was supported by the compiler itself, this could have been possible but as a userland library zod can&#x27;t handle this easily.</div><br/><div id="36642547" class="c"><input type="checkbox" id="c-36642547" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36641967">parent</a><span>|</span><a href="#36642015">next</a><span>|</span><label class="collapse" for="c-36642547">[-]</label><label class="expand" for="c-36642547">[1 more]</label></div><br/><div class="children"><div class="content">Why would a ts-native offering produce better error messages when it comes to complex types? That is an issue with TS in general (or rather, with complex types in any typesafe language).</div><br/></div></div></div></div><div id="36642015" class="c"><input type="checkbox" id="c-36642015" checked=""/><div class="controls bullet"><span class="by">cjdell</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36641202">parent</a><span>|</span><a href="#36641967">prev</a><span>|</span><a href="#36641348">next</a><span>|</span><label class="collapse" for="c-36642015">[-]</label><label class="expand" for="c-36642015">[1 more]</label></div><br/><div class="children"><div class="content">I found Zod a lot easier to use once we were given the &quot;satisfies&quot; keyword. I still basically have to write my schema twice (I don&#x27;t mind this) but I can ensure the two are tightly coupled. A change to either one will show a compile error in the right place:<p>interface Person {
    firstName: string;
    lastName: string;
}<p>const PersonSchema = z.object({
    firstName: z.string(),
    lastName: z.string(),
}) satisfies z.Schema&lt;Person&gt;;</div><br/></div></div><div id="36641348" class="c"><input type="checkbox" id="c-36641348" checked=""/><div class="controls bullet"><span class="by">ncallaway</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36641202">parent</a><span>|</span><a href="#36642015">prev</a><span>|</span><a href="#36638398">next</a><span>|</span><label class="collapse" for="c-36641348">[-]</label><label class="expand" for="c-36641348">[2 more]</label></div><br/><div class="children"><div class="content">I like a lot of things about zod (it&#x27;s what I use when I need to do this kind of validation), but when I was working with a mildly complicated schema the type that z.infer&lt;Schema&gt; produced wasn&#x27;t great for me.<p>When I produce a type definition for a nested schema, I&#x27;ll produce types for individual pieces.<p>So<p>type Schema = {
  foo: Foo;
  bar: Bar;
  baz: Baz[];
}<p>type Foo = {
  red: Color;
  white: Color;
  blue: Color;
}<p>type Color = {
  r: number;
  g: number;
  b: number;
}<p>type Bar = {...}
type Baz = {...}<p>I couldn&#x27;t find a clean way to decompose the type that z.infer&lt;Schema&gt; produced. It would give me a single type object that was deeply structured. For a pretty flat-simple small schema, z.infer&lt;&gt; was totally fine.<p>For the more complicated schema it wasn&#x27;t _terrible_, I still used it. I made it work, but it definitely wasn&#x27;t the dev experience I was hoping for.<p>I think something that went the other way would be much preferable for me. I&#x27;d rather define the typescript type, then have some validate&lt;Schema&gt;() function that was available to me.<p>Basically, I think it&#x27;s _easier_ to get a generated validate() function to play nicely with the rest of my code, than it is to get the inferred type to play nicely with the rest of my code.</div><br/><div id="36642202" class="c"><input type="checkbox" id="c-36642202" checked=""/><div class="controls bullet"><span class="by">solumunus</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36641348">parent</a><span>|</span><a href="#36638398">next</a><span>|</span><label class="collapse" for="c-36642202">[-]</label><label class="expand" for="c-36642202">[1 more]</label></div><br/><div class="children"><div class="content">Use objectSchema.shape.xxx to access the nested schemas and infer on those.</div><br/></div></div></div></div></div></div></div></div><div id="36638398" class="c"><input type="checkbox" id="c-36638398" checked=""/><div class="controls bullet"><span class="by">moduspol</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638345">parent</a><span>|</span><a href="#36640811">prev</a><span>|</span><a href="#36638549">next</a><span>|</span><label class="collapse" for="c-36638398">[-]</label><label class="expand" for="c-36638398">[2 more]</label></div><br/><div class="children"><div class="content">And presumably you need to also trust your third party libraries, unless you&#x27;re also compiling them from TypeScript. Right?<p>And even if you are--that might also involve ensuring their tsconfig.json is compatibly similar to yours. Otherwise the compiler might allow them to return null instead of the object they say they return, among potentially many other &quot;gotchas&quot; that are bound to appear.<p>EDIT: Though I think I do agree with you, ultimately. Runtime type checking imposes non-negligible costs and complexity that still theoretically should be able to be guaranteed at compile time for cases where one isn&#x27;t validating untrusted user input.</div><br/><div id="36638492" class="c"><input type="checkbox" id="c-36638492" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638398">parent</a><span>|</span><a href="#36638549">next</a><span>|</span><label class="collapse" for="c-36638492">[-]</label><label class="expand" for="c-36638492">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you need to trust your third party libraries, better check them. Otherwise they may steal your data, inject XSS, mine cryptos, have memory leaks or faulty logic.</div><br/></div></div></div></div><div id="36638549" class="c"><input type="checkbox" id="c-36638549" checked=""/><div class="controls bullet"><span class="by">theteapot</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638345">parent</a><span>|</span><a href="#36638398">prev</a><span>|</span><a href="#36638595">next</a><span>|</span><label class="collapse" for="c-36638549">[-]</label><label class="expand" for="c-36638549">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And we already have runtime validation libraries to cover that validation step. So many of them.<p>Did you read the article? I think that&#x27;s the point. The premise is <i>Typescript</i> should be responsible for solution to runtime validation against <i>Typescript</i> not third party hacks.</div><br/></div></div><div id="36638595" class="c"><input type="checkbox" id="c-36638595" checked=""/><div class="controls bullet"><span class="by">thanzex</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638345">parent</a><span>|</span><a href="#36638549">prev</a><span>|</span><a href="#36638489">next</a><span>|</span><label class="collapse" for="c-36638595">[-]</label><label class="expand" for="c-36638595">[6 more]</label></div><br/><div class="children"><div class="content">Except for the fact that usually there is not just one single typescript agent working within itself, for which you don&#x27;t need validation. 
There are many cases in which you need to verify some object, anything that does not come from your code i would argue is untrusted, I come across this almost daily, it would be absolutely fantastic to just have a way to check <i>does this object conform to this type?</i> Instead, i need to use some external dependency, effectively duplicate my type definitions and add yet another place to introduce bugs.</div><br/><div id="36639087" class="c"><input type="checkbox" id="c-36639087" checked=""/><div class="controls bullet"><span class="by">IggleSniggle</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638595">parent</a><span>|</span><a href="#36638489">next</a><span>|</span><label class="collapse" for="c-36639087">[-]</label><label class="expand" for="c-36639087">[5 more]</label></div><br/><div class="children"><div class="content">Just use a run-type transformer like typia, hooked right into typescript-compile. Get your runtime type validators generated from nothing but the typescript definitions.<p>Alternatively, use a runtime validator the provides good type inference out of the box so you&#x27;re still only declaring your types once.</div><br/><div id="36639445" class="c"><input type="checkbox" id="c-36639445" checked=""/><div class="controls bullet"><span class="by">JulianChastain</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639087">parent</a><span>|</span><a href="#36638489">next</a><span>|</span><label class="collapse" for="c-36639445">[-]</label><label class="expand" for="c-36639445">[4 more]</label></div><br/><div class="children"><div class="content">I would recommend `zod` as a good typescript schema runtime validation library as well. It does require strict type checking to be on however.</div><br/><div id="36640272" class="c"><input type="checkbox" id="c-36640272" checked=""/><div class="controls bullet"><span class="by">vendiddy</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639445">parent</a><span>|</span><a href="#36639565">next</a><span>|</span><label class="collapse" for="c-36640272">[-]</label><label class="expand" for="c-36640272">[1 more]</label></div><br/><div class="children"><div class="content">I use zod but it&#x27;s a workaround. I use non standard syntax to define types.<p>If typescript emitted type information, we&#x27;d be able to automatically get runtime validation at the boundaries of our apps.</div><br/></div></div><div id="36639565" class="c"><input type="checkbox" id="c-36639565" checked=""/><div class="controls bullet"><span class="by">mixedCase</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639445">parent</a><span>|</span><a href="#36640272">prev</a><span>|</span><a href="#36638489">next</a><span>|</span><label class="collapse" for="c-36639565">[-]</label><label class="expand" for="c-36639565">[2 more]</label></div><br/><div class="children"><div class="content">Alternatively, io-ts is more performant and has been around for a while longer. Although it does have a more functional interface.</div><br/><div id="36639669" class="c"><input type="checkbox" id="c-36639669" checked=""/><div class="controls bullet"><span class="by">IggleSniggle</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639565">parent</a><span>|</span><a href="#36638489">next</a><span>|</span><label class="collapse" for="c-36639669">[-]</label><label class="expand" for="c-36639669">[1 more]</label></div><br/><div class="children"><div class="content">I like typia for doing codegen basically in the way this request is asking: it hooks into the typescript API to create runtypes from plain old typescript</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36638489" class="c"><input type="checkbox" id="c-36638489" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638345">parent</a><span>|</span><a href="#36638595">prev</a><span>|</span><a href="#36638396">next</a><span>|</span><label class="collapse" for="c-36638489">[-]</label><label class="expand" for="c-36638489">[1 more]</label></div><br/><div class="children"><div class="content">That boundary validation is where that kind of reflection would be useful! And it&#x27;s a problem that (nearly) every useful application has to face.<p>Well that, and getting rid of the silly &quot;must be able to strip types without processing them&quot; design ideology would also enable stuff like typeclasses.</div><br/></div></div></div></div><div id="36638396" class="c"><input type="checkbox" id="c-36638396" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638146">parent</a><span>|</span><a href="#36638345">prev</a><span>|</span><a href="#36641170">next</a><span>|</span><label class="collapse" for="c-36638396">[-]</label><label class="expand" for="c-36638396">[8 more]</label></div><br/><div class="children"><div class="content">I still don&#x27;t see the point. There is a long list of libraries that do exactly this, and do it well enough. The author has linked to them himself. The overall benefit of this would be <i>maybe</i> slightly better syntax for these libraries (even that is doubtful, because plenty of them already have a `reflect&lt;T&gt;()` interface), but still zero runtime benefit. And getting it to be accurate for 100% of cases would entail exactly what I mentioned â writing an entire runtime to do this inference.</div><br/><div id="36638447" class="c"><input type="checkbox" id="c-36638447" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638396">parent</a><span>|</span><a href="#36641170">next</a><span>|</span><label class="collapse" for="c-36638447">[-]</label><label class="expand" for="c-36638447">[7 more]</label></div><br/><div class="children"><div class="content">So now you&#x27;re stuck writing for an awkward inner platform language rather than using the TS syntax itself.</div><br/><div id="36638538" class="c"><input type="checkbox" id="c-36638538" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638447">parent</a><span>|</span><a href="#36641170">next</a><span>|</span><label class="collapse" for="c-36638538">[-]</label><label class="expand" for="c-36638538">[6 more]</label></div><br/><div class="children"><div class="content">What&#x27;s this &quot;awkward inner platform language&quot;? They are asking for a `typescript.generateRuntimeType&lt;T&gt;()` function to be native to the language. Well plenty of libraries provide <i>exactly</i> this syntax today. Here&#x27;s tst-reflect: `const type = getType&lt;T&gt;()`. Notice any difference?</div><br/><div id="36638645" class="c"><input type="checkbox" id="c-36638645" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638538">parent</a><span>|</span><a href="#36639631">next</a><span>|</span><label class="collapse" for="c-36638645">[-]</label><label class="expand" for="c-36638645">[1 more]</label></div><br/><div class="children"><div class="content">Wow, i didn&#x27;t know that this is already possible with type script. seems like there are transformers you can add to typescript that can implement it.<p>So type script more or less supports the feature they asked for. Just not bundled with the main package, but they provide the interface to get it done with 3rd party transformers.</div><br/></div></div><div id="36639631" class="c"><input type="checkbox" id="c-36639631" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638538">parent</a><span>|</span><a href="#36638645">prev</a><span>|</span><a href="#36641170">next</a><span>|</span><label class="collapse" for="c-36639631">[-]</label><label class="expand" for="c-36639631">[4 more]</label></div><br/><div class="children"><div class="content">But tst-reflect seems to work by effectively building their own forked tsc compiler.</div><br/><div id="36639713" class="c"><input type="checkbox" id="c-36639713" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639631">parent</a><span>|</span><a href="#36641170">next</a><span>|</span><label class="collapse" for="c-36639713">[-]</label><label class="expand" for="c-36639713">[3 more]</label></div><br/><div class="children"><div class="content">No, they have a plugin into the typescript compiler which uses their API. tsc already exposes all of the info they need.</div><br/><div id="36640339" class="c"><input type="checkbox" id="c-36640339" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639713">parent</a><span>|</span><a href="#36641170">next</a><span>|</span><label class="collapse" for="c-36640339">[-]</label><label class="expand" for="c-36640339">[2 more]</label></div><br/><div class="children"><div class="content">Okay so it&#x27;s not a forked compiler but it&#x27;s adding a feature to the compiler.<p>At which point it makes a lot of sense to ask why that feature shouldn&#x27;t be merged.</div><br/><div id="36642523" class="c"><input type="checkbox" id="c-36642523" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36640339">parent</a><span>|</span><a href="#36641170">next</a><span>|</span><label class="collapse" for="c-36642523">[-]</label><label class="expand" for="c-36642523">[1 more]</label></div><br/><div class="children"><div class="content">Because of feature creep. I don&#x27;t need that feature. Don&#x27;t merge things that can be kept separate. It is called modularity.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36638660" class="c"><input type="checkbox" id="c-36638660" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638146">parent</a><span>|</span><a href="#36641170">prev</a><span>|</span><a href="#36638463">next</a><span>|</span><label class="collapse" for="c-36638660">[-]</label><label class="expand" for="c-36638660">[2 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s so much needed I wonder why there isn&#x27;t a thriving ecosystem of pluggable typescript preprocessors that add whatever values based on types direcly to typescript source before compilation.</div><br/><div id="36640135" class="c"><input type="checkbox" id="c-36640135" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638660">parent</a><span>|</span><a href="#36638463">next</a><span>|</span><label class="collapse" for="c-36640135">[-]</label><label class="expand" for="c-36640135">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot, and some are mentioned here in the comments.</div><br/></div></div></div></div><div id="36638463" class="c"><input type="checkbox" id="c-36638463" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638146">parent</a><span>|</span><a href="#36638660">prev</a><span>|</span><a href="#36639617">next</a><span>|</span><label class="collapse" for="c-36638463">[-]</label><label class="expand" for="c-36638463">[1 more]</label></div><br/><div class="children"><div class="content">It would be great if McDonalds would serve first class sushi, and pizza, and seafood, and pasta, and steak, and if they would deliver frozen meals, and iron your laundry, and ...<p>They just serve burgers and fries. And they are doing very well with that strategy. Same goes for TypeScript.</div><br/></div></div></div></div><div id="36639617" class="c"><input type="checkbox" id="c-36639617" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36638146">prev</a><span>|</span><a href="#36638352">next</a><span>|</span><label class="collapse" for="c-36639617">[-]</label><label class="expand" for="c-36639617">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This is not possible at all because TypeScript is a compiler. They are really asking for a net new product which has very little to do with the TypeScript that exists today.<p>That&#x27;s not correct. All you would really need to do is output type information as JS objects and then support reflection libraries that looked up information at runtime. Two examples where this already happens:<p>1. TS enums are output as JS objects, as opposed to, for example, string literal union types. That is, &quot;enum Foo { Bar = &#x27;BAR&#x27;, Baz = &#x27;BAZ }&quot; outputs information that can be queried at runtime, while &quot;type Foo = &#x27;BAR&#x27; | &#x27;BAZ&#x27;&quot; does not.<p>2. TS already supports runtime type guards functions, <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;narrowing.html#using-type-predicates" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;narrowing.htm...</a>. It wouldn&#x27;t be hard to generate those functions automatically using information already in the type system.</div><br/><div id="36639722" class="c"><input type="checkbox" id="c-36639722" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639617">parent</a><span>|</span><a href="#36638352">next</a><span>|</span><label class="collapse" for="c-36639722">[-]</label><label class="expand" for="c-36639722">[3 more]</label></div><br/><div class="children"><div class="content">TypeScript enums only exist at all because they were included early on before the project really narrowed on its current goal of being &quot;1-to-1 current JS, but with types&quot;. If TypeScript were started from scratch right now with the current philosophy, enums would never exist in the first place.</div><br/><div id="36639836" class="c"><input type="checkbox" id="c-36639836" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639722">parent</a><span>|</span><a href="#36639831">next</a><span>|</span><label class="collapse" for="c-36639836">[-]</label><label class="expand" for="c-36639836">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, but two points:<p>1. I was responding to the point that seemed to be arguing that just because TS is a <i>compiler</i> (to JS), that it couldn&#x27;t support runtime type info. That&#x27;s incorrect, and different from the current philosophy of &quot;TS should really only use type <i>erasure</i> when outputting JS code&quot;.<p>2. After many years I&#x27;ve come to the conclusion that there is <i>huge</i> benefit for an ecosystem to either (a) have a &quot;batteries included&quot; mindset, or (b) have a way to &quot;semi-officially&quot; designate associate libraries as being supported. I think Java really excelled here. For example, the Java Collections library was&#x2F;is excellent, and for a long time (not sure if it still is, I&#x27;ve been out of the Java ecosystem for some time now) Apache Commons were the go to place for libraries everyone used. Contrast that with the Node&#x2F;JS ecosystem, where basically &quot;whatever gets the most popular in NPM&quot; becomes a semi-standard, but there are still often 5 competing libraries, and until the module owner decides to delete a widely used library or just stop releasing updates - besides leftpad infamy, there was also an issue where lodash basically went unreleased for a long time despite needs for critical security patches.<p>When it comes to TS, I understand the guiding principle of &quot;we only implement type erasure&quot;, but I wish there at least a way to e.g. set a tsconfig flag if you wanted to allow runtime data, or to have the equivalent of Apache Commons for TS.</div><br/></div></div><div id="36639831" class="c"><input type="checkbox" id="c-36639831" checked=""/><div class="controls bullet"><span class="by">tough</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36639722">parent</a><span>|</span><a href="#36639836">prev</a><span>|</span><a href="#36638352">next</a><span>|</span><label class="collapse" for="c-36639831">[-]</label><label class="expand" for="c-36639831">[1 more]</label></div><br/><div class="children"><div class="content">But I do like TS Enums, don&#x27;t take them away</div><br/></div></div></div></div></div></div><div id="36638352" class="c"><input type="checkbox" id="c-36638352" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36639617">prev</a><span>|</span><a href="#36638225">next</a><span>|</span><label class="collapse" for="c-36638352">[-]</label><label class="expand" for="c-36638352">[3 more]</label></div><br/><div class="children"><div class="content">Counter to this post, as soon as I read the title I knew what this was, &amp; I knew it was speaking exactly to something we&#x27;ve wanted for a long time. This is asking for more official &amp; better supported <a href="https:&#x2F;&#x2F;github.com&#x2F;rbuckton&#x2F;reflect-metadata">https:&#x2F;&#x2F;github.com&#x2F;rbuckton&#x2F;reflect-metadata</a> .<p>TypeScript <i>is</i> a compiler. It has a lot of type information during compilation. We could write that type information out into a file. Instead what we do is throw that information out when the compile ends. Taking all that typing information &amp; throwing it away at the end of compile time is a bad dumb &amp; silly limitation. Especially for a language like JavaScript, which historically could be semi-proud it had such a strong <i>Everything Is An Object</i> philosophy running through it (such as the malleable prototype-based inheritance system); so much type information should be on that Class object. Reflect-metadata for example defined new methods on Reflect to store this metadata.<p>I could not be more delighted to see the pennon of this website go up. We needed a rallying point for this. We needed a rallying point for keeping class data around. A rallying point for enriching the runtime with good actionable data is a good rallying point.<p>It&#x27;s not what&#x27;s afoot here, but I think you&#x27;re a bit off-base about the impossibility of adding even <i>some</i> type-safety. We might not be able to get exact TS type safety. But we can definitely build some safety in. Owing to the malleable prototype-based type system in JS, we can add getters&#x2F;setters to objects to do a lot of type checking. This doesn&#x27;t even begin to explore the possibility of what we might do with es2015&#x27;s proxies, which could allow even more interesting checks to be layered in. I also wish JS had an official AST (and renderer), so had more official options for code-rewriting that might let us weave in type checks.<p>What we can do as programmers is limited by what we have at our disposal. Not throwing out all the typing information, keeping it around at runtime, opens a lot of interesting doors.</div><br/><div id="36641013" class="c"><input type="checkbox" id="c-36641013" checked=""/><div class="controls bullet"><span class="by">yxre</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638352">parent</a><span>|</span><a href="#36638225">next</a><span>|</span><label class="collapse" for="c-36641013">[-]</label><label class="expand" for="c-36641013">[2 more]</label></div><br/><div class="children"><div class="content">Why not keep the package separate? I also thought of reflect-metadata separately, and it doesn&#x27;t hurt to allow users to install plugins to augment core compiler behavior.<p>Some people have very tight constraints for payload size, and types could blow up payloads</div><br/><div id="36641236" class="c"><input type="checkbox" id="c-36641236" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36641013">parent</a><span>|</span><a href="#36638225">next</a><span>|</span><label class="collapse" for="c-36641236">[-]</label><label class="expand" for="c-36641236">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard for a plugin to always be begging for sufficient hooks &amp; access to read out the data. Maybe an external project is fine, but it needs some real TLC, not just being a side-quest by a maintainer or two.<p>Conceptually it feels like there should be&#x2F;needs to be some buy in on high, a shared vision that tsc is not the one, only &amp; singular tool in the typescript-verse that ever can or will care about types. Trying to constantly break in &amp; exfiltrate the data isn&#x27;t ever going to get a position where the world takes this seriously; typescript needs really should gladly be opening the gates.<p>As for whether the type information is in fact part of the payload, that&#x27;s a separate question, and one that should ideally be configurable. It&#x27;s definitely a bit of a complex situation in general; ideally we&#x27;d have good&#x2F;easy ways for libraries to include this information but then we also want want to be able to strip it out easily.<p>Maybe we just regenerate it as needed from ts source of libraries when we need it. But that implies not running a single typescript compile with one set of settings but running many compiles, as each library has its own tsconfig it&#x27;ll need that informs how files are laid out &amp; other sundry details. I might be overcomplicating. Perhaps we could just generate a foo.reflect.js, that has all the reflection data? There&#x27;s options.</div><br/></div></div></div></div></div></div><div id="36638225" class="c"><input type="checkbox" id="c-36638225" checked=""/><div class="controls bullet"><span class="by">jxf</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36638352">prev</a><span>|</span><a href="#36638027">next</a><span>|</span><label class="collapse" for="c-36638225">[-]</label><label class="expand" for="c-36638225">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This is exactly why simple, concise writing is essential, and their wall of text is...not it.<p>I only skimmed this but felt it was clear. They&#x27;re asking for TypeScript, as part of the type erasure, to emit the type information it has discovered about the types in a side channel to the emitted JavaScript. Think of, say, PDB files as an analogy.<p>&gt; They are really asking for a net new product which has very little to do with the TypeScript that exists today.<p>This is information TypeScript already has today but which it discards. It wouldn&#x27;t take a &quot;net new product&quot;.</div><br/><div id="36638377" class="c"><input type="checkbox" id="c-36638377" checked=""/><div class="controls bullet"><span class="by">RyanCavanaugh</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638225">parent</a><span>|</span><a href="#36638560">next</a><span>|</span><label class="collapse" for="c-36638377">[-]</label><label class="expand" for="c-36638377">[2 more]</label></div><br/><div class="children"><div class="content">You can use the TypeScript API to generate this information at whichever level of detail you want.<p>The level of detail TS has about types during the checking phase is much higher than you would want in practice for 99% of projects (e.g. 1 + 2 + 3 has 6 different types associated with it).<p>The level of detail TS has about types during the checking phase is potentially lower than you would want in practice for a lot of projects (which is critical since that makes the whole feature useless if that happens). For example, the list of properties of a particular generic instantiation is lazily computed, but it&#x27;s possible your program never pulls on the list so it never exists in the first place, yet is something your type-based tool might want to know.</div><br/><div id="36639752" class="c"><input type="checkbox" id="c-36639752" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638377">parent</a><span>|</span><a href="#36638560">next</a><span>|</span><label class="collapse" for="c-36639752">[-]</label><label class="expand" for="c-36639752">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re not asking for reflection on _all_ possible types (which would have the problem you mentioned), just ones explicitly requested at compile time via a function call.</div><br/></div></div></div></div></div></div><div id="36638027" class="c"><input type="checkbox" id="c-36638027" checked=""/><div class="controls bullet"><span class="by">spatialaustin</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36638225">prev</a><span>|</span><a href="#36638102">next</a><span>|</span><label class="collapse" for="c-36638027">[-]</label><label class="expand" for="c-36638027">[1 more]</label></div><br/><div class="children"><div class="content">At the top of the README they link to &quot;The 7 year old Github issue&quot; which describes the problem in they way you&#x27;re asking for.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;3628">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;3628</a></div><br/></div></div><div id="36638102" class="c"><input type="checkbox" id="c-36638102" checked=""/><div class="controls bullet"><span class="by">cornstalks</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36638027">prev</a><span>|</span><a href="#36639125">next</a><span>|</span><label class="collapse" for="c-36638102">[-]</label><label class="expand" for="c-36638102">[5 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; <i>TypeScript Needs to Emit Runtime Type Information</i><p>&gt; <i>This is not possible at all because TypeScript is a</i> compiler.<p>Sorry, can you clarify? Many compilers exist in other languages that support RTTI, so it&#x27;s not clear to me what you mean by this.</div><br/><div id="36638205" class="c"><input type="checkbox" id="c-36638205" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638102">parent</a><span>|</span><a href="#36639125">next</a><span>|</span><label class="collapse" for="c-36638205">[-]</label><label class="expand" for="c-36638205">[4 more]</label></div><br/><div class="children"><div class="content">There are plenty of projects that do the same for TypeScript (e.g. <a href="https:&#x2F;&#x2F;github.com&#x2F;typescript-rtti&#x2F;typescript-rtti">https:&#x2F;&#x2F;github.com&#x2F;typescript-rtti&#x2F;typescript-rtti</a>) and plenty that support some kind of runtime reflection, and overall emitting TS type information at compile time in some readable format is a pretty trivial problem to solve. The complicated part is on the other side â what do you do with this information? How do you get JavaScript engines to understand it?</div><br/><div id="36638241" class="c"><input type="checkbox" id="c-36638241" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638205">parent</a><span>|</span><a href="#36639125">next</a><span>|</span><label class="collapse" for="c-36638241">[-]</label><label class="expand" for="c-36638241">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t get JavaScript engines to understand it.  You use a library.</div><br/><div id="36638586" class="c"><input type="checkbox" id="c-36638586" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638241">parent</a><span>|</span><a href="#36639125">next</a><span>|</span><label class="collapse" for="c-36638586">[-]</label><label class="expand" for="c-36638586">[2 more]</label></div><br/><div class="children"><div class="content">So then...exactly how it is done today? TypeScript provides an API to get type info at compile time. Libraries write plugins to consume this type info and use it for runtime and  custom validation. What changes in this new world?</div><br/><div id="36641990" class="c"><input type="checkbox" id="c-36641990" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638586">parent</a><span>|</span><a href="#36639125">next</a><span>|</span><label class="collapse" for="c-36641990">[-]</label><label class="expand" for="c-36641990">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So then...exactly how it is done today? TypeScript provides an API to get type info at compile time.<p>That&#x27;s exactly it, it doesn&#x27;t. That project you linked (typescript-rtti) mentions in the README that you must install and use it via ttypescript, a typescript wrapper that patches the compilation process to expose compilation details to plugins. Except that plugin API is unofficial and changes break the ecosystem built on it. For example, ttypescript doesn&#x27;t work for TS 5 and the dev doesn&#x27;t want to spend time on it. ts-patch has stepped in to provide a source transformer API for TS 5.<p>There&#x27;s no way I can recommend libraries like typescript-rtti in commercial projects until something changes. I hope the ts-patch folks don&#x27;t burn out.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36639125" class="c"><input type="checkbox" id="c-36639125" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36638102">prev</a><span>|</span><a href="#36638109">next</a><span>|</span><label class="collapse" for="c-36639125">[-]</label><label class="expand" for="c-36639125">[1 more]</label></div><br/><div class="children"><div class="content">The first 7 words of the document are &quot;TypeScript Needs to Emit Runtime Type Information&quot;. Was that not clear? I guess I&#x27;m a bit confused by your confusion, unless you don&#x27;t know what runtime type information is, in which case I suppose it&#x27;s more understandable - but in that case I suppose you&#x27;re not really the target audience.</div><br/></div></div><div id="36638109" class="c"><input type="checkbox" id="c-36638109" checked=""/><div class="controls bullet"><span class="by">goodpaul6</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36639125">prev</a><span>|</span><a href="#36638208">next</a><span>|</span><label class="collapse" for="c-36638109">[-]</label><label class="expand" for="c-36638109">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is not possible at all because TypeScript is a compiler<p>Not sure if this supports your point. Lots of compilers emit runtime type information, e.g. Golang, Java.</div><br/><div id="36638173" class="c"><input type="checkbox" id="c-36638173" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#36637819">root</a><span>|</span><a href="#36638109">parent</a><span>|</span><a href="#36638208">next</a><span>|</span><label class="collapse" for="c-36638173">[-]</label><label class="expand" for="c-36638173">[1 more]</label></div><br/><div class="children"><div class="content">Those languages all have runtimes that can consume the type information. TypeScript does not.</div><br/></div></div></div></div><div id="36638679" class="c"><input type="checkbox" id="c-36638679" checked=""/><div class="controls bullet"><span class="by">cjdell</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36638208">prev</a><span>|</span><a href="#36639677">next</a><span>|</span><label class="collapse" for="c-36638679">[-]</label><label class="expand" for="c-36638679">[1 more]</label></div><br/><div class="children"><div class="content">TypeScript does emit runtime type information through enums though.</div><br/></div></div><div id="36639677" class="c"><input type="checkbox" id="c-36639677" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#36637819">parent</a><span>|</span><a href="#36638679">prev</a><span>|</span><a href="#36638985">next</a><span>|</span><label class="collapse" for="c-36639677">[-]</label><label class="expand" for="c-36639677">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, agreed, this ainât it.<p>I do think theres room in the world for typescript to be able to emit runtime code from its types, but I donât think it should be in the business of writing validation libraries.<p>Closest they should get to this work is writing an interface to export types types into runtime code that another lib can pick up and write validators with.</div><br/></div></div></div></div><div id="36638486" class="c"><input type="checkbox" id="c-36638486" checked=""/><div class="controls bullet"><span class="by">DanRosenwasser</span><span>|</span><a href="#36637819">prev</a><span>|</span><a href="#36637506">next</a><span>|</span><label class="collapse" for="c-36638486">[-]</label><label class="expand" for="c-36638486">[15 more]</label></div><br/><div class="children"><div class="content">Hey all, TypeScript PM here.<p>I understand the desire here. Runtime type checking is often necessary for data validation, and we can see lots of libraries developed to help fill the gap here. But I think the fact that there are so many libraries with different design decisions is pretty indicative that this is not a solved problem with an obvious solution. We knew this going into the early design of TypeScript, and it&#x27;s a principle that&#x27;s held up very well.<p>What have been happy to find is that we&#x27;ve grown TypeScript to be powerful enough to communicate precisely what runtime type-checking libraries are actually doing, so that we can derive the types directly. The dual of this is that people have the tools they need to build up runtime type validation logic out of types by using our APIs. That feels like a reasonable level of flexibility.</div><br/><div id="36639146" class="c"><input type="checkbox" id="c-36639146" checked=""/><div class="controls bullet"><span class="by">0xb0565e487</span><span>|</span><a href="#36638486">parent</a><span>|</span><a href="#36641489">next</a><span>|</span><label class="collapse" for="c-36639146">[-]</label><label class="expand" for="c-36639146">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m relatively new to programming and had a question about TypeScript&#x27;s functionality. Is there any specific reason why TypeScript doesn&#x27;t allow for the creation of custom and intricate data types? For example, I&#x27;m unable to define a number type within a specific range, or a string that adheres to a certain pattern (like a postal code).<p>I&#x27;m imagining a language where I could define a custom data type with a regular function. For instance, I could have a method that the compiler would use to verify the validity of what I input, as shown below:<p>function PercentType(value: number) {
    if (value &gt; 100 || value &lt; 0) throw new Error();<p><pre><code>    return true;</code></pre>
}<p>Is the lack of such a feature in TypeScript (or any language) a deliberate design decision to avoid unnecessary complexity, or due to technical constraints such as performance considerations?</div><br/><div id="36639768" class="c"><input type="checkbox" id="c-36639768" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639146">parent</a><span>|</span><a href="#36639721">next</a><span>|</span><label class="collapse" for="c-36639768">[-]</label><label class="expand" for="c-36639768">[1 more]</label></div><br/><div class="children"><div class="content">TypeScript actually does have some support for the kinds of types you&#x27;re suggesting. For example, a US postal code can be defined like so:<p><pre><code>    type PostalCode = `${Digit}${Digit}${Digit}${Digit}${Digit}`;

    type Digit = &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27;;
</code></pre>
You could trivially define a `parsePostalCode` function that accepts a string and yields a PostalCode (or throws an error if it&#x27;s the wrong format).<p>Ranges like percent are much trickierâTypeScript would need to compute the return type of `Percent + Percent` (0 &lt;= T &lt;= 200), `Percent &#x2F; Percent` (indeterminate because of division by zero or near-zero values), and so on for all the main operators. In the best case scenario this computation is very expensive and complicates the compiler, but in the worst case there&#x27;s no clear correct answer for all use cases (should we just return `number` for percent division or should we return `[0, Infinity]`?).<p>In most mainstream programming languages the solution to this problem is to define a class that enforces the invariants that you care aboutâPercent would be a class that defines only the operators you need (do you really need to divide Percent by Percent?) and that throws an exception if it&#x27;s constructed with an invalid value.</div><br/></div></div><div id="36639721" class="c"><input type="checkbox" id="c-36639721" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639146">parent</a><span>|</span><a href="#36639768">prev</a><span>|</span><a href="#36639554">next</a><span>|</span><label class="collapse" for="c-36639721">[-]</label><label class="expand" for="c-36639721">[1 more]</label></div><br/><div class="children"><div class="content">This is a feature some (experimental) programming languages have - look into dependent types. The long-and-short of it is that it adds a lot of power, but comes at an ergonomic cost - the more your types say about your code, the more the type checker needs to be able to understand and reason about your code, and you start to run up against some fundamental limits of computation unless you start making trade-offs: giving up Turing-completeness, writing proofs for the type checker, stuff like that.<p>Another interesting point of reference are &quot;refinement types&quot;, which allow you to specify things like ranges to &quot;refine&quot; a type; the various constraints are then run through a kind of automated reasoning system called an SMT solver to ensure they&#x27;re all compatible with each other.</div><br/></div></div><div id="36639554" class="c"><input type="checkbox" id="c-36639554" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639146">parent</a><span>|</span><a href="#36639721">prev</a><span>|</span><a href="#36639339">next</a><span>|</span><label class="collapse" for="c-36639554">[-]</label><label class="expand" for="c-36639554">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Is the lack of such a feature in TypeScript (or any language) a deliberate design decision to avoid unnecessary complexity, or due to technical constraints such as performance considerations?</i><p>It makes a lot of things impossible. For example, if you defined two different types of ranges, OneToFifty and OneToHundred similarly to your PercentType above, the following code would be problematic:<p><pre><code>    let x: OneToFifty = &lt;...&gt;;
    let y: OneToHundred = &lt;...&gt;;
    y = x;
</code></pre>
Any human programmer would say the third line makes sense because every OneToFifty number is also OneToHundred. But for a compiler, that&#x27;s impossible to determine because JavaScript code is Turing-complete, and so it can&#x27;t generally say that one is certainly a subset of the other.<p>In other words, any two custom-defined types like that would be unassignable from and to each other, making the language much less usable. Now add generics, co-&#x2F;contravariance, type deduction, etc., and suddenly it becomes clear how much work adding a new type to the type system is; much more than just a boolean function.<p>That said, TypeScript has a lot of primitives, for example, template string types for five-digit zip codes:<p><pre><code>    type Digit = &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &lt;...&gt; | &#x27;9&#x27;;
    type FiveDigitZipCode = `${Digit}${Digit}${Digit}${Digit}${Digit}`;
</code></pre>
(Actually, some of these are Turing-complete too, which means type-checking will sometimes fail, but those cases are rare enough for the TS team to deem the tradeoff worth.)</div><br/><div id="36640420" class="c"><input type="checkbox" id="c-36640420" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639554">parent</a><span>|</span><a href="#36639571">next</a><span>|</span><label class="collapse" for="c-36640420">[-]</label><label class="expand" for="c-36640420">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the fundamental programming language design conundrum: Every programming language feature looks easy in isolation, but once you start composing it with everything else, they get hard. And hardly anything composes as complexly as programming languages.<p>There&#x27;s sort of a meme where you should never ask why someone doesn&#x27;t &quot;just&quot; do something, and of all the people you shouldn&#x27;t ask that of, programming language designers are way, way up there. Every feature interacts not just with itself, not just with every other feature in the language, but also in every other possible combination of those features at arbitrary levels of complexity, and you can be assured that someone, somewhere out there is using that exact combination, either deliberately for some purpose, or without even realizing it.</div><br/></div></div><div id="36639571" class="c"><input type="checkbox" id="c-36639571" checked=""/><div class="controls bullet"><span class="by">0xb0565e487</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639554">parent</a><span>|</span><a href="#36640420">prev</a><span>|</span><a href="#36639339">next</a><span>|</span><label class="collapse" for="c-36639571">[-]</label><label class="expand" for="c-36639571">[1 more]</label></div><br/><div class="children"><div class="content">Thanks :)</div><br/></div></div></div></div><div id="36639339" class="c"><input type="checkbox" id="c-36639339" checked=""/><div class="controls bullet"><span class="by">bern4444</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639146">parent</a><span>|</span><a href="#36639554">prev</a><span>|</span><a href="#36639701">next</a><span>|</span><label class="collapse" for="c-36639339">[-]</label><label class="expand" for="c-36639339">[2 more]</label></div><br/><div class="children"><div class="content">Some of this is possible in the type system like a range: 
From stackoverflow: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;39494689&#x2F;is-it-possible-to-restrict-number-to-a-certain-range&#x2F;70307091#70307091" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;39494689&#x2F;is-it-possible-...</a><p><pre><code>  type Enumerate&lt;N extends number, Acc extends number[] = []&gt; = Acc[&#x27;length&#x27;] extends N
    ? Acc[number]
    : Enumerate&lt;N, [...Acc, Acc[&#x27;length&#x27;]]&gt;

  type NumberRange&lt;F extends number, T extends number&gt; = Exclude&lt;Enumerate&lt;T&gt;, Enumerate&lt;F&gt;&gt;

  type ZeroToOneHundred = NumberRange&lt;0, 100&gt;
</code></pre>
One limitation is that this has to be bounded on both ends so constructing a type for something like GreaterThanZero is not possible.<p>Similarly for zip codes you could create a union of all possible zip codes like this:<p><pre><code>  type USZipCodes = &#x27;90210&#x27; | ...
</code></pre>
Often with the idea you have in mind the solution is to implement an object where the constructor does a run time check of the requirements and if the checks pass instantiate the instance and otherwise throw a run time error.<p>In functional programming this is often handled with the Option which can be thought of as an array with exactly 0 or 1 elements always. 0 elements when a constraint is not met and 1 element when all constraints are met.<p>This [0] is a library I wrote for JS&#x2F;TS that provides an implementation of Options. Many others exist and other languages like Rust and Scala support the Option data structure natively.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;sbernheim4&#x2F;excoptional">https:&#x2F;&#x2F;github.com&#x2F;sbernheim4&#x2F;excoptional</a></div><br/><div id="36639467" class="c"><input type="checkbox" id="c-36639467" checked=""/><div class="controls bullet"><span class="by">0xb0565e487</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639339">parent</a><span>|</span><a href="#36639701">next</a><span>|</span><label class="collapse" for="c-36639467">[-]</label><label class="expand" for="c-36639467">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, thanks!</div><br/></div></div></div></div><div id="36639701" class="c"><input type="checkbox" id="c-36639701" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639146">parent</a><span>|</span><a href="#36639339">prev</a><span>|</span><a href="#36641489">next</a><span>|</span><label class="collapse" for="c-36639701">[-]</label><label class="expand" for="c-36639701">[1 more]</label></div><br/><div class="children"><div class="content">&gt; or a string that adheres to a certain pattern (like a postal code).<p>This is somewhat supported with template literal types, <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;template-literal-types.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;template-lite...</a>. However, there are good technical&#x2F;performance reasons they don&#x27;t support, for example, plain regexes - there is a HUGE discussion on this topic here, <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;6579">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;6579</a>.</div><br/></div></div></div></div><div id="36641489" class="c"><input type="checkbox" id="c-36641489" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#36638486">parent</a><span>|</span><a href="#36639146">prev</a><span>|</span><a href="#36638672">next</a><span>|</span><label class="collapse" for="c-36641489">[-]</label><label class="expand" for="c-36641489">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft hosted MacroScript as TypeScript plugin or toplevel wrapper would solve this problem.<p>You just need to spark it, community will help maintaining it.<p>It would solve all codegen needs from generating clients to runtime type assertions and many interesting problems in between.</div><br/></div></div><div id="36638672" class="c"><input type="checkbox" id="c-36638672" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#36638486">parent</a><span>|</span><a href="#36641489">prev</a><span>|</span><a href="#36637506">next</a><span>|</span><label class="collapse" for="c-36638672">[-]</label><label class="expand" for="c-36638672">[4 more]</label></div><br/><div class="children"><div class="content">Maybe official preprocessor plugins for TypeScript compiler could help?<p>I understand that everybody who needs it can already put their own preprocessor that generates runtime objects from type information before the code is passed to tsc for compilation.<p>But the effort is inconsistent and distributed.<p>If TypeScript officially supported pluggable preprocessor and plugin ecosystem for it some good solutions might get discovered.</div><br/><div id="36639138" class="c"><input type="checkbox" id="c-36639138" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36638672">parent</a><span>|</span><a href="#36637506">next</a><span>|</span><label class="collapse" for="c-36639138">[-]</label><label class="expand" for="c-36639138">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s next? An official TypeScript UI framework, will it be Vue, React, Next.js or Svelte? An official TypeScript date library?</div><br/><div id="36640482" class="c"><input type="checkbox" id="c-36640482" checked=""/><div class="controls bullet"><span class="by">clansimus</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639138">parent</a><span>|</span><a href="#36640210">next</a><span>|</span><label class="collapse" for="c-36640482">[-]</label><label class="expand" for="c-36640482">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll take an official WYSIWYG editor while we&#x27;re at it</div><br/></div></div><div id="36640210" class="c"><input type="checkbox" id="c-36640210" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#36638486">root</a><span>|</span><a href="#36639138">parent</a><span>|</span><a href="#36640482">prev</a><span>|</span><a href="#36637506">next</a><span>|</span><label class="collapse" for="c-36640210">[-]</label><label class="expand" for="c-36640210">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the point of any of those?<p>Generating code based on type annotations is frequently requested feature directly related to the core feature of TypeScript which is type system.</div><br/></div></div></div></div></div></div></div></div><div id="36637506" class="c"><input type="checkbox" id="c-36637506" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36638486">prev</a><span>|</span><a href="#36637524">next</a><span>|</span><label class="collapse" for="c-36637506">[-]</label><label class="expand" for="c-36637506">[64 more]</label></div><br/><div class="children"><div class="content">There is a good reason for not doing this. Typescript would become some kind of runtime on top of JavaScript. A new language that compiles to JavaScript. Currently TS is only JavaScript with type annotations.<p>There are many languages that compile to JavaScript. Pick one of them and use it!<p>And I have the feeling, that people who want runtime typed Typescript would rather like to write Java&#x2F;OOP style code instead of JavaScript. But JavaScript is a dynamically typed language, and that&#x27;s also nice. Be happy with what you have!</div><br/><div id="36637900" class="c"><input type="checkbox" id="c-36637900" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637899">next</a><span>|</span><label class="collapse" for="c-36637900">[-]</label><label class="expand" for="c-36637900">[6 more]</label></div><br/><div class="children"><div class="content">Not necessarily.<p>Consider<p><pre><code>    const fooType = generateTypeInfo!&lt;Foo&gt;();
</code></pre>
Where `generateTypeInfo!` is a macro that expands to a JS object encoding the âFooâ type (e.g. if `Foo` a record type, `fooType` will be a record with its encoded field types). It still compiles to readable JavaScript.<p>What this macro <i>does</i> break is that TS = JavaScript with type annotations, and all you need to do to compile is remove those annotations (excluding enums, but they are all-but-deprecated and obsoleted by string unions) without even type-checking. Since now you also need to expand the `generateTypeInfo!`, which requires actually computing the structural type of `Foo` (and if you want any sort of nominal type metadata, that too).<p>And thatâs still a problem because type-checking is slow, but removing the annotations is fast. If thereâs a limited way to resolve types for these annotations which restricts the resolution scope, that would be a good candidate.<p>â-<p>There&#x27;s also more issues with TypeScript having a separate runtime besides it not being JavaScript. TypeScript types are structural, so they currently <i>are</i> available at runtime: to determine an objectâs type, inspect its structure. Anything more and you quickly run into non-trivial cases being literally impossible: if you want erased nominal information like whether a string is part of a string union, TypeScriptâs type system is Turing complete; and if you want the nominal type name, implicit structural conversions mean that once a value leaves its annotated cast or definition itâs effectively undefined.</div><br/><div id="36638691" class="c"><input type="checkbox" id="c-36638691" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637900">parent</a><span>|</span><a href="#36638132">next</a><span>|</span><label class="collapse" for="c-36638691">[-]</label><label class="expand" for="c-36638691">[3 more]</label></div><br/><div class="children"><div class="content">What if this macro could be expanded into valid typescript by preprocessor that runs before typescript compiler?</div><br/><div id="36640359" class="c"><input type="checkbox" id="c-36640359" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638691">parent</a><span>|</span><a href="#36638132">next</a><span>|</span><label class="collapse" for="c-36640359">[-]</label><label class="expand" for="c-36640359">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an option, and maybe even the ideal one: an extension which takes a TypeScript+macros file and converts it into TypeScript before feeding to the TypeScript compiler.<p>However, such a preprocessor will basically need to re-implement TypeScript&#x27;s type checking. So either TypeScript must expose it via an API, or the preprocessor needs to itself implement a subset (which as mentioned, could also be faster)</div><br/><div id="36640706" class="c"><input type="checkbox" id="c-36640706" checked=""/><div class="controls bullet"><span class="by">matt_kantor</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36640359">parent</a><span>|</span><a href="#36638132">next</a><span>|</span><label class="collapse" for="c-36640706">[-]</label><label class="expand" for="c-36640706">[1 more]</label></div><br/><div class="children"><div class="content">This already exists. One example posted elsewhere in these comments is tst-reflect[1], with which you can write this:<p><pre><code>    const fooType = getType&lt;Foo&gt;();
</code></pre>
Which is exactly what you wanted, just as a plugin to TypeScript rather than built into the official compiler.<p>[1]: <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;tst-reflect" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;tst-reflect</a></div><br/></div></div></div></div></div></div><div id="36638132" class="c"><input type="checkbox" id="c-36638132" checked=""/><div class="controls bullet"><span class="by">baxuz</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637900">parent</a><span>|</span><a href="#36638691">prev</a><span>|</span><a href="#36637899">next</a><span>|</span><label class="collapse" for="c-36638132">[-]</label><label class="expand" for="c-36638132">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what `generateTypeInfo!&lt;Foo&gt;();` is supposed to be, but as far as I&#x27;m aware there is no way to execute anything in a JS engine from a type generic.</div><br/><div id="36638417" class="c"><input type="checkbox" id="c-36638417" checked=""/><div class="controls bullet"><span class="by">__jem</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638132">parent</a><span>|</span><a href="#36637899">next</a><span>|</span><label class="collapse" for="c-36638417">[-]</label><label class="expand" for="c-36638417">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s meant to represent a hypothetical TS compiler builtin that does codegen for you.</div><br/></div></div></div></div></div></div><div id="36637899" class="c"><input type="checkbox" id="c-36637899" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637900">prev</a><span>|</span><a href="#36637656">next</a><span>|</span><label class="collapse" for="c-36637899">[-]</label><label class="expand" for="c-36637899">[1 more]</label></div><br/><div class="children"><div class="content">You can have both. This is the beauty of lisp - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Homoiconicity" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Homoiconicity</a><p>But in all seriousness you can gain reflection without a runtime. Just expose the types as data.<p>Seems foolish to <i>not</i> do something like this. Particularly when you look at the lengths so many devs have gone to try and replicate it.</div><br/></div></div><div id="36637656" class="c"><input type="checkbox" id="c-36637656" checked=""/><div class="controls bullet"><span class="by">a_wild_dandan</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637899">prev</a><span>|</span><a href="#36637605">next</a><span>|</span><label class="collapse" for="c-36637656">[-]</label><label class="expand" for="c-36637656">[20 more]</label></div><br/><div class="children"><div class="content">I&#x27;m misunderstanding your reasoning here. TS is <i>already</i> a new (superset) language which compiles to JS. Runtime types solve the problem of maintaining two duplicate, separate type systems -- one for compilation, one for validating data. I&#x27;m not seeing how that&#x27;s related to OOP. For instance, my preferred workaround lib for this problem, `io-ts`, leans hard on functional programming.</div><br/><div id="36637765" class="c"><input type="checkbox" id="c-36637765" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637656">parent</a><span>|</span><a href="#36637807">next</a><span>|</span><label class="collapse" for="c-36637765">[-]</label><label class="expand" for="c-36637765">[2 more]</label></div><br/><div class="children"><div class="content">Yeah but just because types exist at compile time doesn&#x27;t mean they exist at run time.<p>For instance with Generics in Java a List&lt;String&gt; is the same as a List&lt;Integer&gt; at run time,  the compiler can enforce rules that let you add a String to one but not add a String to the other but the runtime has no idea.  This has various negative consequences but it also let them retrofit generic collections on top of the old collection implementation in Java unlike the disaster in .NET where both had to coexist for years.<p>Similarly C compiles to machine code and in machine code there are just memory locations and registers,  types are implicit in how you use those things but not spelled out explicitly.  C++ does have RTTI but is one of the many open pits, like Exceptions, in C++.<p>Typescript types are the same way,  once the compiler has done its type checking you know the code is going to behave according to the type system even if the types have been &quot;erased&quot;.</div><br/><div id="36638724" class="c"><input type="checkbox" id="c-36638724" checked=""/><div class="controls bullet"><span class="by">einrealist</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637765">parent</a><span>|</span><a href="#36637807">next</a><span>|</span><label class="collapse" for="c-36638724">[-]</label><label class="expand" for="c-36638724">[1 more]</label></div><br/><div class="children"><div class="content">Java&#x27;s generic type information (aka parameterized types) is available at runtime through reflection.</div><br/></div></div></div></div><div id="36637807" class="c"><input type="checkbox" id="c-36637807" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637656">parent</a><span>|</span><a href="#36637765">prev</a><span>|</span><a href="#36637832">next</a><span>|</span><label class="collapse" for="c-36637807">[-]</label><label class="expand" for="c-36637807">[15 more]</label></div><br/><div class="children"><div class="content">Emitting types would run counter to several of TypeScript&#x27;s Design Goals [0]. In particular, it would violate:<p>&gt; 3. Impose no runtime overhead on emitted programs.<p>&gt; 9. Use a consistent, fully erasable, structural type system.<p>It&#x27;s also explicitly called out as a non-goal in that doc:<p>&gt; 5. Add or rely on run-time type information in programs, or emit different code based on the results of the type system. Instead, encourage programming patterns that do not require run-time metadata.<p>&gt; 6. Provide additional runtime functionality or libraries. Instead, use TypeScript to describe existing libraries.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;TypeScript&#x2F;wiki&#x2F;TypeScript-Design-Goals">https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;TypeScript&#x2F;wiki&#x2F;TypeScript-Desi...</a></div><br/><div id="36638030" class="c"><input type="checkbox" id="c-36638030" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637807">parent</a><span>|</span><a href="#36638172">next</a><span>|</span><label class="collapse" for="c-36638030">[-]</label><label class="expand" for="c-36638030">[10 more]</label></div><br/><div class="children"><div class="content">Emitting type information to some kind of separate common format wouldn&#x27;t undermine most of these goals.  There are already apparently dozens of tools that people can use for this task in a dozen different ways.  Just have TS emit the data.<p>In this way there is no runtime overhead (point #3) -- it&#x27;s pure data to be optionally consumed.  They wouldn&#x27;t have to prescribe any particular reflection module (point #6).<p>The only point this would violate is #5 but that is, of course, the point.  We want them to reconsider because it&#x27;s such a powerfully useful feature.  And people are doing it on top of and outside of TypeScript where TypeScript would be best tool to give this information for TS users.</div><br/><div id="36638297" class="c"><input type="checkbox" id="c-36638297" checked=""/><div class="controls bullet"><span class="by">RyanCavanaugh</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638030">parent</a><span>|</span><a href="#36638280">next</a><span>|</span><label class="collapse" for="c-36638297">[-]</label><label class="expand" for="c-36638297">[5 more]</label></div><br/><div class="children"><div class="content">TypeScript dev lead here.<p>Today, you can already write a program using the TypeScript API to inspect all of this information to accomplish whichever scenario is at hand. The existence of all these tools, each with different opinions on design direction and implementation trade-offs, demonstrate that this is possible. Yet it&#x27;s not demonstrated how those tools would benefit from reading from a data file as opposed to using the TypeScript API.<p>Something like api-extractor has different constraints from io-ts which has different constraints from typescript-schema. The API exists today and is apparently sufficient to meet all these tools&#x27; needs, yet what&#x27;s proposed is a data file that can encapsulate any possible operation you might perform with that API.<p>Having TypeScript try to imagine, implement, and maintain a data file format that can satisfy _all_ of these tools&#x27; use cases, plus any future tool&#x27;s use case, is a tremendous effort with no clear upside over using the existing API.<p>It&#x27;s easy to gain support for the idea of &quot;put the types in a file&quot; because anyone reading that can imagine a straightforward implementation that just achieves their particular goals, but everyone&#x27;s goals are different and the amount of overlap is not actually all that high when you look at the wide breadth of tools in the list. There&#x27;s a very different amount of information you&#x27;d need to enable a type-aware linter (which is basically type info on every expression in the program!), as compared to a simple documentation generator (which might only need top-level declaration info).</div><br/><div id="36638385" class="c"><input type="checkbox" id="c-36638385" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638297">parent</a><span>|</span><a href="#36638280">next</a><span>|</span><label class="collapse" for="c-36638385">[-]</label><label class="expand" for="c-36638385">[4 more]</label></div><br/><div class="children"><div class="content">Hard to argue with that!  I wonder why this isn&#x27;t considered a solution to the author of this site.</div><br/><div id="36638400" class="c"><input type="checkbox" id="c-36638400" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638385">parent</a><span>|</span><a href="#36638280">next</a><span>|</span><label class="collapse" for="c-36638400">[-]</label><label class="expand" for="c-36638400">[3 more]</label></div><br/><div class="children"><div class="content">The author explicitly calls out the existence of all of these tools as <i>being</i> the problem. They seem to want a canonical version that TypeScript itself officially supports.</div><br/><div id="36638462" class="c"><input type="checkbox" id="c-36638462" checked=""/><div class="controls bullet"><span class="by">RyanCavanaugh</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638400">parent</a><span>|</span><a href="#36638280">next</a><span>|</span><label class="collapse" for="c-36638462">[-]</label><label class="expand" for="c-36638462">[2 more]</label></div><br/><div class="children"><div class="content">Situation: There are 14 competing type representation formats<p>TypeScript: We can write our own type file format!<p>Situation: There are 15 competing type representation formats</div><br/><div id="36640480" class="c"><input type="checkbox" id="c-36640480" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638462">parent</a><span>|</span><a href="#36638280">next</a><span>|</span><label class="collapse" for="c-36640480">[-]</label><label class="expand" for="c-36640480">[1 more]</label></div><br/><div class="children"><div class="content">If typescript itself defines a format, it&#x27;s hard to imagine that the majority of people won&#x27;t switch to it.<p>Though while there&#x27;s a lot of type-data tools, are there actually a lot of type-data <i>formats</i> out there right now?  I&#x27;ve been using zod, and it doesn&#x27;t have one.  You have to use code to tell it about a type.  Someone did make a library to let zod load types from pure data, but the format used there is... typescript source code.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36638280" class="c"><input type="checkbox" id="c-36638280" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638030">parent</a><span>|</span><a href="#36638297">prev</a><span>|</span><a href="#36638172">next</a><span>|</span><label class="collapse" for="c-36638280">[-]</label><label class="expand" for="c-36638280">[4 more]</label></div><br/><div class="children"><div class="content">It would violate #9 no matter what implementation you use, and #9 is absolutely essential to tools like ESBuild, Deno, and Bun, which all rely on the assumption that they can nearly instantly strip out the type annotations and execute the code as JS.</div><br/><div id="36638340" class="c"><input type="checkbox" id="c-36638340" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638280">parent</a><span>|</span><a href="#36638172">next</a><span>|</span><label class="collapse" for="c-36638340">[-]</label><label class="expand" for="c-36638340">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;d still be able to execute the code as JS.  Your library that uses type reflection wouldn&#x27;t work anymore but that&#x27;s true of all these solutions.</div><br/><div id="36638368" class="c"><input type="checkbox" id="c-36638368" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638340">parent</a><span>|</span><a href="#36638172">next</a><span>|</span><label class="collapse" for="c-36638368">[-]</label><label class="expand" for="c-36638368">[2 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s not. I can take a library that uses zod, strip the annotations, and it will execute perfectly anywhere I want to run it.</div><br/><div id="36638443" class="c"><input type="checkbox" id="c-36638443" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638368">parent</a><span>|</span><a href="#36638172">next</a><span>|</span><label class="collapse" for="c-36638443">[-]</label><label class="expand" for="c-36638443">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because Zod doesn&#x27;t use type annotations as input.  We&#x27;re talking about wanting to use type annotations as input so that we don&#x27;t have to make our code as ugly as Zod makes it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36638172" class="c"><input type="checkbox" id="c-36638172" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637807">parent</a><span>|</span><a href="#36638030">prev</a><span>|</span><a href="#36637832">next</a><span>|</span><label class="collapse" for="c-36638172">[-]</label><label class="expand" for="c-36638172">[4 more]</label></div><br/><div class="children"><div class="content">If some design goals are stupid they must be changed. It&#x27;s not god word. It&#x27;s human word. And this human was wrong.</div><br/><div id="36638216" class="c"><input type="checkbox" id="c-36638216" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638172">parent</a><span>|</span><a href="#36638243">next</a><span>|</span><label class="collapse" for="c-36638216">[-]</label><label class="expand" for="c-36638216">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t just some of the design goals, type erasure is the fundamental guiding principle of TypeScript that allowed it to become successful. Throwing it away because it complicates certain programming patterns should not be done lightly.</div><br/></div></div><div id="36638243" class="c"><input type="checkbox" id="c-36638243" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638172">parent</a><span>|</span><a href="#36638216">prev</a><span>|</span><a href="#36637832">next</a><span>|</span><label class="collapse" for="c-36638243">[-]</label><label class="expand" for="c-36638243">[2 more]</label></div><br/><div class="children"><div class="content">In my opinion they are not stupid, they make a lot of sense. And many people seem to agree and use typescript. If you donât agree, use something else. There are many alternatives, pick something that is âsmartâ in your opinion.</div><br/><div id="36640459" class="c"><input type="checkbox" id="c-36640459" checked=""/><div class="controls bullet"><span class="by">chucklenorris</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638243">parent</a><span>|</span><a href="#36637832">next</a><span>|</span><label class="collapse" for="c-36640459">[-]</label><label class="expand" for="c-36640459">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately i can&#x27;t. Like most of the people here i work in a company, with other people and i can&#x27;t chose $language that is less dumb for obvious reasons. Typescript IS the only practical solution for web development at scale. I&#x27;m stuck with the design philosophy of a guy that&#x27;s not facing my problems and obviously doesn&#x27;t care.</div><br/></div></div></div></div></div></div></div></div><div id="36637832" class="c"><input type="checkbox" id="c-36637832" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637656">parent</a><span>|</span><a href="#36637807">prev</a><span>|</span><a href="#36637776">next</a><span>|</span><label class="collapse" for="c-36637832">[-]</label><label class="expand" for="c-36637832">[1 more]</label></div><br/><div class="children"><div class="content">Small ot, if you like io-ts, @effect&#x2F;schema is the spiritual successor from the same ecosystem.<p>The fp-ts, io-ts author Giulio Canti has decided that the best way to proceed was to merge the two communities of fp-ts and effect, even though it&#x27;s his work that is mostly known with effect being much more niche.<p>It&#x27;s essentially io-ts squared in its powers. The amount of things you get from schemas are endless, not just decoders and encoders but also apis, lenses, constructors, and many other things.<p>It&#x27;s obviously heavily fp-leaning, albeit I would say effect systems such as effect, based on Scala&#x27;s ZIO, are much more approachable than haskell&#x2F;purescript-like languages.</div><br/></div></div><div id="36637776" class="c"><input type="checkbox" id="c-36637776" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637656">parent</a><span>|</span><a href="#36637832">prev</a><span>|</span><a href="#36637605">next</a><span>|</span><label class="collapse" for="c-36637776">[-]</label><label class="expand" for="c-36637776">[1 more]</label></div><br/><div class="children"><div class="content">&gt; TS is already a new (superset) language which compiles to JS.<p>Yes, but also no. The point is that it doesn&#x27;t really add more <i>semantics</i> over plain JS. You can erase all the type annotations (well, replace with &quot;any&quot;) and it&#x27;ll do the same thing if you ignore the type checking.<p>If there&#x27;s any &quot;transformation&quot; from TS to different-looking JS[0], it&#x27;s mostly just syntactic embellishment (think LISP macros and such), not semantic.<p>[0] Not sure if there is, tbh</div><br/></div></div></div></div><div id="36637605" class="c"><input type="checkbox" id="c-36637605" checked=""/><div class="controls bullet"><span class="by">Arainach</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637656">prev</a><span>|</span><a href="#36637553">next</a><span>|</span><label class="collapse" for="c-36637605">[-]</label><label class="expand" for="c-36637605">[2 more]</label></div><br/><div class="children"><div class="content">For any sufficiently large project, dynamically typed languages are not nice, they are a series of interweaved disasters consisting of constantly tripping over what you thought was your feet but is actually NaN and trying to fall forward rather than collapsing entirely.<p>In every workflow I&#x27;ve seen, TypeScript is already a language that gets compiled to JS. It might as well take full advantage.</div><br/><div id="36637683" class="c"><input type="checkbox" id="c-36637683" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637605">parent</a><span>|</span><a href="#36637553">next</a><span>|</span><label class="collapse" for="c-36637683">[-]</label><label class="expand" for="c-36637683">[1 more]</label></div><br/><div class="children"><div class="content">Typescript is not really compiled to JS, only the type annotations are removed.<p>To make dynamically typed languages nice for bigger projects we have typescript for type annotations (it&#x27;s does not make it a statically typed language!). It is there, it is used, it scales and it works. If your type script project &quot;collapses entirely&quot;, it&#x27;s probably not the languages fault.</div><br/></div></div></div></div><div id="36637553" class="c"><input type="checkbox" id="c-36637553" checked=""/><div class="controls bullet"><span class="by">fzeindl</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637605">prev</a><span>|</span><a href="#36639004">next</a><span>|</span><label class="collapse" for="c-36637553">[-]</label><label class="expand" for="c-36637553">[4 more]</label></div><br/><div class="children"><div class="content">You can use Kotlin and compile to JavaScript. It&#x27;s type system is better and the standard library greater <i>scnr</i></div><br/><div id="36642044" class="c"><input type="checkbox" id="c-36642044" checked=""/><div class="controls bullet"><span class="by">lf-non</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637553">parent</a><span>|</span><a href="#36637650">next</a><span>|</span><label class="collapse" for="c-36642044">[-]</label><label class="expand" for="c-36642044">[1 more]</label></div><br/><div class="children"><div class="content">Kotlin&#x27;s type system works great for interop with a nominally typed lang like java but for interop with a dynamically typed lang like js and myriad of its libs not designed with type safety in mind, structural typing is far more convenient.</div><br/></div></div><div id="36637650" class="c"><input type="checkbox" id="c-36637650" checked=""/><div class="controls bullet"><span class="by">booi</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637553">parent</a><span>|</span><a href="#36642044">prev</a><span>|</span><a href="#36637627">next</a><span>|</span><label class="collapse" for="c-36637650">[-]</label><label class="expand" for="c-36637650">[1 more]</label></div><br/><div class="children"><div class="content">This is the way. Best of both worlds although using js libraries is kind of a pain</div><br/></div></div><div id="36637627" class="c"><input type="checkbox" id="c-36637627" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637553">parent</a><span>|</span><a href="#36637650">prev</a><span>|</span><a href="#36639004">next</a><span>|</span><label class="collapse" for="c-36637627">[-]</label><label class="expand" for="c-36637627">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Pick whatever language you like. There are many more options.</div><br/></div></div></div></div><div id="36639004" class="c"><input type="checkbox" id="c-36639004" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637553">prev</a><span>|</span><a href="#36638147">next</a><span>|</span><label class="collapse" for="c-36639004">[-]</label><label class="expand" for="c-36639004">[4 more]</label></div><br/><div class="children"><div class="content">The reason we want typescript to have java-like features is because we work on teams which have decided, outside of our control, that we are going to write our backend in JS&#x2F;TS simply because it&#x27;s easier for the bootcamp grads to transition to backend since they already know JS on the frontend. If we wrote our backend in Java, it would require the bootcamp grads to learn a new language, which they&#x27;re not prepared to do. Choosing typescript or javascript on the backend is not about choosing the right tool for the job (because they are objectively not the right tool for backend development). It is mostly about minimizing the cost of our labor sourcing<p>As such, RTTI would make typescript go from a compromise language (we use it because we are stuck in the JS ecosystem, not because it&#x27;s a good tool) to a legitimately useful backend language (We use it because it has the right features for the use-case)<p>If I could choose what language we use on the backend, I would leave the JS ecosystem entirely and write everything in .Net. But it&#x27;s difficult to find .Net developers since every bootcamp these days produces react developers</div><br/><div id="36639074" class="c"><input type="checkbox" id="c-36639074" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36639004">parent</a><span>|</span><a href="#36638147">next</a><span>|</span><label class="collapse" for="c-36639074">[-]</label><label class="expand" for="c-36639074">[3 more]</label></div><br/><div class="children"><div class="content">So you want TypeScript to be Java, but you don&#x27;t want to use Java, because your developers only know TypeScipt. Sounds like an unsolvable problem.</div><br/><div id="36639267" class="c"><input type="checkbox" id="c-36639267" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36639074">parent</a><span>|</span><a href="#36638147">next</a><span>|</span><label class="collapse" for="c-36639267">[-]</label><label class="expand" for="c-36639267">[2 more]</label></div><br/><div class="children"><div class="content">The solution is to pile features onto typescript that were never intended to be there, the same way we have done with Javascript, HTML, CSS, and HTTP. None of these things are pure, and all of them have been ravaged by competing interests and committees who were all making financially driven decisions when writing the standards.<p>It would be best to abandon javascript and typescript as backend languages. I don&#x27;t mind them on the frontend because a typescript compiler is useful when the application you&#x27;re writing is <i>originating</i> data and not <i>receiving</i> it. And javascript does DOM manipulation admirably. However, we live in a world where humans are more expensive than computers. If I had my way, we&#x27;d write C# backends and Angular&#x2F;Typescript frontends, but that&#x27;s not the world we live in. Everything has to be JS because most people employed as &quot;software engineers&quot; are not truly very good at their jobs</div><br/><div id="36642651" class="c"><input type="checkbox" id="c-36642651" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36639267">parent</a><span>|</span><a href="#36638147">next</a><span>|</span><label class="collapse" for="c-36642651">[-]</label><label class="expand" for="c-36642651">[1 more]</label></div><br/><div class="children"><div class="content">I, on the other hand, would pick TS over .NET or Java any day. But I am sure you will conclude that it can only be because I am no good at my job.</div><br/></div></div></div></div></div></div></div></div><div id="36638147" class="c"><input type="checkbox" id="c-36638147" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36639004">prev</a><span>|</span><a href="#36637909">next</a><span>|</span><label class="collapse" for="c-36638147">[-]</label><label class="expand" for="c-36638147">[3 more]</label></div><br/><div class="children"><div class="content">TypeScript is not JavaScript with type annotations. One of the modes, may be. TypeScript supports emitting old JS constructions which look nothing like original typescript code. So it&#x27;s more like type annotations + babel. Adding one more thing to this set. Extremely useful thing. I think it&#x27;s a good idea. I miss it. It&#x27;s crazy that I can&#x27;t JSON.parse string into typed structure safely. Every other language can do that.</div><br/><div id="36642570" class="c"><input type="checkbox" id="c-36642570" checked=""/><div class="controls bullet"><span class="by">mrloba</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638147">parent</a><span>|</span><a href="#36638218">next</a><span>|</span><label class="collapse" for="c-36642570">[-]</label><label class="expand" for="c-36642570">[1 more]</label></div><br/><div class="children"><div class="content">You can easily parse json into types using something like typebox. Not only does this work, it works much better than many other languages. Have fun trying to represent even a simple patch request, or discriminated union, in something like c#</div><br/></div></div><div id="36638218" class="c"><input type="checkbox" id="c-36638218" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638147">parent</a><span>|</span><a href="#36642570">prev</a><span>|</span><a href="#36637909">next</a><span>|</span><label class="collapse" for="c-36638218">[-]</label><label class="expand" for="c-36638218">[1 more]</label></div><br/><div class="children"><div class="content">No, this is not crazy, this is the design goal of TypeScript.<p>If you want a statically and runtime typed language in the browser, you should not use typescript. Use Kotlin, Rescript, â¦</div><br/></div></div></div></div><div id="36637909" class="c"><input type="checkbox" id="c-36637909" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36638147">prev</a><span>|</span><a href="#36637572">next</a><span>|</span><label class="collapse" for="c-36637909">[-]</label><label class="expand" for="c-36637909">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Typescript would become some kind of runtime on top of JavaScript. A new language that compiles to JavaScript.<p>Typescript isn&#x27;t a runtime on top of JavaScript, but it very much is &quot;a new language that compiles to JavaScript&quot;.</div><br/><div id="36637957" class="c"><input type="checkbox" id="c-36637957" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637909">parent</a><span>|</span><a href="#36637572">next</a><span>|</span><label class="collapse" for="c-36637957">[-]</label><label class="expand" for="c-36637957">[4 more]</label></div><br/><div class="children"><div class="content">Yes, but it&#x27;s special in that it compiles by erasure. (Mostly --  the cases where it doesn&#x27;t are considered historical mistakes.)</div><br/><div id="36638323" class="c"><input type="checkbox" id="c-36638323" checked=""/><div class="controls bullet"><span class="by">vanviegen</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637957">parent</a><span>|</span><a href="#36637572">next</a><span>|</span><label class="collapse" for="c-36638323">[-]</label><label class="expand" for="c-36638323">[3 more]</label></div><br/><div class="children"><div class="content">Ok. And why is that important? So one could meticulously add typing to your JavaScript application, and then strip it all out with a regex in order to deploy? What real-life benefit does &#x27;compile by erasure&#x27; offer?</div><br/><div id="36639084" class="c"><input type="checkbox" id="c-36639084" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638323">parent</a><span>|</span><a href="#36639183">next</a><span>|</span><label class="collapse" for="c-36639084">[-]</label><label class="expand" for="c-36639084">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s essentially what all the fast transpilers do -- esbuild, babel etc. They don&#x27;t typecheck the code at all, they just parse it and strip out the type annotations.<p>This means that you can run and test code that doesn&#x27;t typecheck yet -- very useful during development. Also, production builds can run the typechecker in parallel with other build steps. That&#x27;s how we optimized our build system at work.<p>But essentially, it&#x27;s a design choice by the TypeScript team. They&#x27;ve decided that TypeScript shouldn&#x27;t add runtime features on top of JavaScript, but instead should simply <i>type</i> JavaScript, and I think this has contributed to the success of TypeScript.</div><br/></div></div><div id="36639183" class="c"><input type="checkbox" id="c-36639183" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638323">parent</a><span>|</span><a href="#36639084">prev</a><span>|</span><a href="#36637572">next</a><span>|</span><label class="collapse" for="c-36639183">[-]</label><label class="expand" for="c-36639183">[1 more]</label></div><br/><div class="children"><div class="content">I think the point is that TypeScript isn&#x27;t really &quot;a new language&quot;. It&#x27;s an existing language with an additional feature. The fact that TS maintains the promise that types can be stripped means that TS is upholding a contract that it will not stray from Javascript. It can&#x27;t, for example, add new language features.</div><br/></div></div></div></div></div></div></div></div><div id="36637572" class="c"><input type="checkbox" id="c-36637572" checked=""/><div class="controls bullet"><span class="by">asherah</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637909">prev</a><span>|</span><a href="#36638339">next</a><span>|</span><label class="collapse" for="c-36637572">[-]</label><label class="expand" for="c-36637572">[10 more]</label></div><br/><div class="children"><div class="content">typescript enums exist and are compiled to javascript (other than const enums)</div><br/><div id="36637826" class="c"><input type="checkbox" id="c-36637826" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637572">parent</a><span>|</span><a href="#36637621">next</a><span>|</span><label class="collapse" for="c-36637826">[-]</label><label class="expand" for="c-36637826">[1 more]</label></div><br/><div class="children"><div class="content">That TypeScript fails to live up perfectly to its design goals doesn&#x27;t mean it should adopt additional anti-features.</div><br/></div></div><div id="36637621" class="c"><input type="checkbox" id="c-36637621" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637572">parent</a><span>|</span><a href="#36637826">prev</a><span>|</span><a href="#36638339">next</a><span>|</span><label class="collapse" for="c-36637621">[-]</label><label class="expand" for="c-36637621">[8 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s one of the features of typescript that really sucks. String union types work so much better.</div><br/><div id="36637716" class="c"><input type="checkbox" id="c-36637716" checked=""/><div class="controls bullet"><span class="by">moystard</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637621">parent</a><span>|</span><a href="#36638339">next</a><span>|</span><label class="collapse" for="c-36637716">[-]</label><label class="expand" for="c-36637716">[7 more]</label></div><br/><div class="children"><div class="content">Why does typescript enum really suck?</div><br/><div id="36637797" class="c"><input type="checkbox" id="c-36637797" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637716">parent</a><span>|</span><a href="#36637912">next</a><span>|</span><label class="collapse" for="c-36637797">[-]</label><label class="expand" for="c-36637797">[3 more]</label></div><br/><div class="children"><div class="content">Thereâs a <i>ton</i> written about this if you search for âtypescript enums.â<p>I just finished removing them from a major project. Hereâs a few of my personal notes:<p>1. They donât play well with duck  typing. (Eg. show me a subset of an enum)<p>2. They require an import every time you want to utilize them.<p>3. They are pretty wordy compared to union strings.<p>4. Their string value version encourages misuse as a key-value pair.<p>5. Unless you use the string value version, they suck to debug because logs just show 0,1,2,3.</div><br/><div id="36638212" class="c"><input type="checkbox" id="c-36638212" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637797">parent</a><span>|</span><a href="#36637912">next</a><span>|</span><label class="collapse" for="c-36638212">[-]</label><label class="expand" for="c-36638212">[2 more]</label></div><br/><div class="children"><div class="content">Another one: they conflate Type and (Locator) Instance in a unique way that just about nothing else in TS does. Those are two very different things with the same name with Typescript&#x27;s (antiquated) enums.<p>There are too many ways to accidentally import&#x2F;redeclare&#x2F;rescope the Type of an enum so that TS &quot;knows&quot; the Type, but because that type (generally) has the same &quot;name&quot; as the most likely (Locator) Instance it assumes the same access applies leaving runtime errors behind when that Instance isn&#x27;t actually imported&#x2F;available. Typescript has no easy way to tell the difference between access to the Type isn&#x27;t access to the (Locator) Instance (nor vice versa). Reasoning about those runtime errors or preventing them is additionally tough for people <i>too</i> because of the same &quot;name&quot; problem for two different things.<p>This is something that&#x27;s painfully hard to avoid in cases where you are trying to encapsulate an API&#x27;s Types separate from its imports&#x2F;exports because they might be introduced or manipulated at runtime (plugins, sandboxes, proxies, etc). Unfortunately, this is also too easy to accidentally do even when you aren&#x27;t intentionally doing something complicated like that (trying to generate automated .d.ts files in a bundling toolchain, for example, when APIs are in the boundary space between unintentional public API and internal tree-shaking or optimized symbol renaming).</div><br/><div id="36638569" class="c"><input type="checkbox" id="c-36638569" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638212">parent</a><span>|</span><a href="#36637912">next</a><span>|</span><label class="collapse" for="c-36638569">[-]</label><label class="expand" for="c-36638569">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for putting into words why they just &quot;feel&quot; so wrong.</div><br/></div></div></div></div></div></div><div id="36637912" class="c"><input type="checkbox" id="c-36637912" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637716">parent</a><span>|</span><a href="#36637797">prev</a><span>|</span><a href="#36637846">next</a><span>|</span><label class="collapse" for="c-36637912">[-]</label><label class="expand" for="c-36637912">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s turn it around, union types are so much easier to use and so much more powerful. Enums have only a small subset of the features, are not compatible to JavaScript code and are hard to understand (read the docs about type script enums and you will see).</div><br/></div></div><div id="36637846" class="c"><input type="checkbox" id="c-36637846" checked=""/><div class="controls bullet"><span class="by">graypegg</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637716">parent</a><span>|</span><a href="#36637912">prev</a><span>|</span><a href="#36638339">next</a><span>|</span><label class="collapse" for="c-36637846">[-]</label><label class="expand" for="c-36637846">[2 more]</label></div><br/><div class="children"><div class="content">Typescript enums emit a really weird object at runtime<p>enum CheckboxState {
   On;
   ParentOn;
   Off;
}<p>Becomes<p>{
   [0]: âOnâ,
   âOnâ: 0,
   [1]: âParentOnâ,
   âParentOnâ: 1,
   [2]: âOffâ,
   âOffâ: 2
}<p>So things like Object.keys give bizarre results. Itâs done this way so you can use the name or the value as an index.</div><br/><div id="36639495" class="c"><input type="checkbox" id="c-36639495" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637846">parent</a><span>|</span><a href="#36638339">next</a><span>|</span><label class="collapse" for="c-36639495">[-]</label><label class="expand" for="c-36639495">[1 more]</label></div><br/><div class="children"><div class="content">To be clear, this kind of structure is only emitted for numeric enums. String enums with explicitly declared static values are roughly equivalent to the equivalent Record&lt;string, string&gt; (runtime) and a corresponding type T[keyof T] (type check time).<p>IME, most of the complaints about enums apply only to numeric ones.<p>The major exception to that AFAIK is the fact that enum members of any type are treated as nominally typed (as in A.Foo is not assignable to B.Foo even if they resolve to the same static value). I am among the minority who consider this a good thing, but I recognize that it violates expectations and so I understand why my position isnât widely shared.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36638339" class="c"><input type="checkbox" id="c-36638339" checked=""/><div class="controls bullet"><span class="by">adjav</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637572">prev</a><span>|</span><a href="#36637583">next</a><span>|</span><label class="collapse" for="c-36638339">[-]</label><label class="expand" for="c-36638339">[1 more]</label></div><br/><div class="children"><div class="content">My understanding has long been that web developers have decided to turn Javascript into C#, one proposal at a time.</div><br/></div></div><div id="36637583" class="c"><input type="checkbox" id="c-36637583" checked=""/><div class="controls bullet"><span class="by">joshmarinacci</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36638339">prev</a><span>|</span><a href="#36638001">next</a><span>|</span><label class="collapse" for="c-36637583">[-]</label><label class="expand" for="c-36637583">[1 more]</label></div><br/><div class="children"><div class="content">Dynamically typed means I can look up the type of an object at runtime. JavaScript lets us do this with classes&#x2F;prototypes. Since TypeScript adds types and enums and interfaces, why canât it let us look up those at runtime too? It would seem to fit with the way JS works.</div><br/></div></div><div id="36638001" class="c"><input type="checkbox" id="c-36638001" checked=""/><div class="controls bullet"><span class="by">twelve40</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36637583">prev</a><span>|</span><a href="#36637648">next</a><span>|</span><label class="collapse" for="c-36638001">[-]</label><label class="expand" for="c-36638001">[3 more]</label></div><br/><div class="children"><div class="content">&gt; dynamically typed language, and that&#x27;s also nice<p>what is nice about a dynamically typed language?  like, seriously, can you list some reasons for a dynamically typed language to exist?</div><br/><div id="36638084" class="c"><input type="checkbox" id="c-36638084" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638001">parent</a><span>|</span><a href="#36638374">next</a><span>|</span><label class="collapse" for="c-36638084">[-]</label><label class="expand" for="c-36638084">[1 more]</label></div><br/><div class="children"><div class="content">Types can get complicated. To an extent that code gets extremely overcomplicated by using a typed language. Typed languages encourage to use many layers of DTOs and models.<p>With dynamic languages you can just code, without being held back by a OOP type system, but it can get very complicated to understand what the typed of you parameters and return values actually are.<p>Typescript gives you the best of both worlds.</div><br/></div></div><div id="36638374" class="c"><input type="checkbox" id="c-36638374" checked=""/><div class="controls bullet"><span class="by">Barrin92</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36638001">parent</a><span>|</span><a href="#36638084">prev</a><span>|</span><a href="#36637648">next</a><span>|</span><label class="collapse" for="c-36638374">[-]</label><label class="expand" for="c-36638374">[1 more]</label></div><br/><div class="children"><div class="content">Peter Norvig summed it up in one of his presentations <a href="https:&#x2F;&#x2F;norvig.com&#x2F;design-patterns&#x2F;design-patterns.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;norvig.com&#x2F;design-patterns&#x2F;design-patterns.pdf</a><p><i>&quot;Dynamic Languages have fewer language limitations Less need for bookkeeping objects and classes Less need to get around class-restricted design. Study of the Design Patterns book: 16 of 23 patterns have qualitatively simpler implementation in Lisp or Dylan than in C++ for at least some uses of each pattern[...]&quot;</i></div><br/></div></div></div></div><div id="36637648" class="c"><input type="checkbox" id="c-36637648" checked=""/><div class="controls bullet"><span class="by">random_mutex</span><span>|</span><a href="#36637506">parent</a><span>|</span><a href="#36638001">prev</a><span>|</span><a href="#36637524">next</a><span>|</span><label class="collapse" for="c-36637648">[-]</label><label class="expand" for="c-36637648">[3 more]</label></div><br/><div class="children"><div class="content">ReasonML</div><br/><div id="36637728" class="c"><input type="checkbox" id="c-36637728" checked=""/><div class="controls bullet"><span class="by">dimitrios1</span><span>|</span><a href="#36637506">root</a><span>|</span><a href="#36637648">parent</a><span>|</span><a href="#36637686">next</a><span>|</span><label class="collapse" for="c-36637728">[-]</label><label class="expand" for="c-36637728">[1 more]</label></div><br/><div class="children"><div class="content">ReasonML suffered tremendously when the community split and went off to do ReScript. I don&#x27;t think either have  recovered the original luster.</div><br/></div></div></div></div></div></div><div id="36637524" class="c"><input type="checkbox" id="c-36637524" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#36637506">prev</a><span>|</span><a href="#36637802">next</a><span>|</span><label class="collapse" for="c-36637524">[-]</label><label class="expand" for="c-36637524">[3 more]</label></div><br/><div class="children"><div class="content">Above all of what I write below, I think that this is a very valid issue for discussion and debate. I don&#x27;t think there&#x27;s one objective correct answer. So this isn&#x27;t me dictating what TypeScript shalt be.<p>TypeScript is an entirely optional layer on top of JavaScript, with the exception of `Enum` that emits an object, many of which see as a mistake. You don&#x27;t even have to &quot;transform&quot; TS code to get JS: you just have to delete the typings. The rest is just JS.<p>Unless you want to depart heavily from this principle, which I think is crucially important so long as there&#x27;s still human-maintained JS code out there, what I think they&#x27;re asking for is a library to take the types and write serializers&#x2F;validators for. Which there are many of.  So I think the real request is to make the one canonical choice out of a field of many choices, which I also agree with the spirit of.  But is that really in scope for the TypeScript project?<p>What I personally don&#x27;t want is runtime reflection for TypeScript.  Or at least, not a core part of the language. Because I like that TypeScript is just for compilation and at runtime you just have JavaScript, without any sort of abstraction layer that turns JS into some sort of intermediate representation with overhead or more indirection for debugging. I <i>cherish</i> the fact that even without source mappings, my output JS is perfectly legible and debuggable.</div><br/><div id="36639603" class="c"><input type="checkbox" id="c-36639603" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36637524">parent</a><span>|</span><a href="#36642060">next</a><span>|</span><label class="collapse" for="c-36639603">[-]</label><label class="expand" for="c-36639603">[1 more]</label></div><br/><div class="children"><div class="content">&gt; with the exception of `Enum` that emits an object, many of which see as a mistake<p>There are other exceptions, most of which are considered mistakes as well, the most obvious which come to mind being `module` and `namespace` as runtime constructs. But Iâm fairly sure these have been primarily used by TypeScript itself for at least a few years, and even they recently migrated away.<p>Another one that comes to mind is, I believe, actually pretty popular: what they refer to as âparameter propertiesâ, ie class members whose types are defined in a constructorâs parameters. These seem to have escaped controversy because they eliminate a lot of redundant boilerplate, and generally behave in obvious ways (at least as obvious as their redundant boilerplate JS equivalents).</div><br/></div></div><div id="36642060" class="c"><input type="checkbox" id="c-36642060" checked=""/><div class="controls bullet"><span class="by">syspec</span><span>|</span><a href="#36637524">parent</a><span>|</span><a href="#36639603">prev</a><span>|</span><a href="#36637802">next</a><span>|</span><label class="collapse" for="c-36642060">[-]</label><label class="expand" for="c-36642060">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You don&#x27;t even have to &quot;transform&quot; TS code to get JS<p>Sure if you consider the whole language, typings</div><br/></div></div></div></div><div id="36637802" class="c"><input type="checkbox" id="c-36637802" checked=""/><div class="controls bullet"><span class="by">JohnDotAwesome</span><span>|</span><a href="#36637524">prev</a><span>|</span><a href="#36637597">next</a><span>|</span><label class="collapse" for="c-36637802">[-]</label><label class="expand" for="c-36637802">[4 more]</label></div><br/><div class="children"><div class="content">Instead of pleading to the TypeScript gods, why not make a deal with the JavaScript deities? Let&#x27;s get type-checking into JS!<p>If I want runtime types, I reach for type guards. If I need to do this a lot, then I reach for io-ts or zod and pretty much exclusively write types as validators&#x2F;codecs&#x2F;schemas or what-have-you.<p>I don&#x27;t think TS - as a specification, type-checker, community, or otherwise - needs to concern itself with runtime validation UNLESS JS gets some agreed upon way to do it.</div><br/><div id="36641524" class="c"><input type="checkbox" id="c-36641524" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#36637802">parent</a><span>|</span><a href="#36637891">next</a><span>|</span><label class="collapse" for="c-36641524">[-]</label><label class="expand" for="c-36641524">[1 more]</label></div><br/><div class="children"><div class="content">I know itâs not perfect, but Iâm pretty content writing schemas and types as validators with zod and deriving my types from those. That you can derive the types easily and the validation then evolves with your typing is really nice.<p>Iâve worked with people who find it too complicated or they feel like it should be baked into the language, but Iâd argue there are so many contentious design choices in these libraries that it might actually be best to be an implementation choice, selected based on a project and its specific needs.<p>Zod has been very good to me though. Itâs quite easy to get up and running with, and its API has never gotten in my way when scaling things out.<p>My one complaint is that certain patterns I love, such as runtime validation with zod and deriving types from schemas, doesnât necessarily always play well with something like pattern matching in ts-pattern. The type definitions behind these libraries are labyrinths, and cases where something seems like it should work wonât always behave as expected. On some level, I do wish these were seamless language level features, though I fully recognize these are selfish desires.<p>But imagine having runtime safety combined with exhaustive pattern matching. Iâd be very happy to have that.</div><br/></div></div><div id="36637891" class="c"><input type="checkbox" id="c-36637891" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#36637802">parent</a><span>|</span><a href="#36641524">prev</a><span>|</span><a href="#36637597">next</a><span>|</span><label class="collapse" for="c-36637891">[-]</label><label class="expand" for="c-36637891">[2 more]</label></div><br/><div class="children"><div class="content">I have huge doubts whether I&#x27;d like JS to have it really.<p>I feel like Promises, decorators and the new pipe operator all went into the wrong directions with their implementations.</div><br/><div id="36640935" class="c"><input type="checkbox" id="c-36640935" checked=""/><div class="controls bullet"><span class="by">esprehn</span><span>|</span><a href="#36637802">root</a><span>|</span><a href="#36637891">parent</a><span>|</span><a href="#36637597">next</a><span>|</span><label class="collapse" for="c-36640935">[-]</label><label class="expand" for="c-36640935">[1 more]</label></div><br/><div class="children"><div class="content">How do you feel like promises went in the wrong direction?<p>(I&#x27;d also add modules to your list fwiw, they were designed without taking performance into account.)</div><br/></div></div></div></div></div></div><div id="36637597" class="c"><input type="checkbox" id="c-36637597" checked=""/><div class="controls bullet"><span class="by">orangepanda</span><span>|</span><a href="#36637802">prev</a><span>|</span><a href="#36637497">next</a><span>|</span><label class="collapse" for="c-36637597">[-]</label><label class="expand" for="c-36637597">[4 more]</label></div><br/><div class="children"><div class="content">I vaguely remember one of typescripts developers stating that if they had to start it all over again, enums would not be added; as enums are the only thing emitting runtime code.<p>Typescript does not change runtime behaviour, there is no special typescript {#if}</div><br/><div id="36638009" class="c"><input type="checkbox" id="c-36638009" checked=""/><div class="controls bullet"><span class="by">ragnese</span><span>|</span><a href="#36637597">parent</a><span>|</span><a href="#36637497">next</a><span>|</span><label class="collapse" for="c-36638009">[-]</label><label class="expand" for="c-36638009">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  I vaguely remember one of typescripts developers stating that if they had to start it all over again, enums would not be added; as enums are the only thing emitting runtime code.<p>It&#x27;s true. I don&#x27;t remember if that was the only&#x2F;main reason they said that, but that was definitely one of the things.<p>I find that a weird sentiment, though, because TypeScript has a couple of other features that are not just &quot;JavaScript + type annotations&quot;.<p>Namespaces is one. It also has a syntactic sugar for defining class properties in the constructor arguments. And it had that experimental decorator feature for a long time, but I never used it, so I don&#x27;t know much about it. It also has the &quot;`this` parameter&quot; syntax for methods&#x2F;functions, which does disappear at compile time, but still <i>looks</i> and feels like more than just a JavaScript function with type annotations.</div><br/><div id="36638516" class="c"><input type="checkbox" id="c-36638516" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#36637597">root</a><span>|</span><a href="#36638009">parent</a><span>|</span><a href="#36638277">next</a><span>|</span><label class="collapse" for="c-36638516">[-]</label><label class="expand" for="c-36638516">[1 more]</label></div><br/><div class="children"><div class="content">From my understanding, namespaces are on the same list with enums of things that the developers regret ever adding to the language but can&#x27;t take out without breaking old code. Namespaces also at least have the excuse of being a &quot;necessary&quot; jQuery-era &quot;Production pattern&quot; in the land before ESM was standardized and somewhat relating to the similar syntax sugar of import&#x2F;export when generating AMD, UMD, and CommonJS modules.<p>So too are &quot;experimental decorators&quot; another thing that some of the developers seem to list as massive regrets. That example is even so much worse than namespaces because it wasn&#x27;t justified by existing patterns used in Production JS at the time <i>and</i> that they even believed that requiring a compile-time flag with the word &quot;experimental&quot; in it would <i>stop</i> developers from using that compile-time flag in <i>anything</i> destined for Production usage. (Seriously, we all should shame the many projects&#x2F;companies that did that.)</div><br/></div></div><div id="36638277" class="c"><input type="checkbox" id="c-36638277" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#36637597">root</a><span>|</span><a href="#36638009">parent</a><span>|</span><a href="#36638516">prev</a><span>|</span><a href="#36637497">next</a><span>|</span><label class="collapse" for="c-36638277">[-]</label><label class="expand" for="c-36638277">[1 more]</label></div><br/><div class="children"><div class="content">Although namespaces are not deprecated they are not recommended anymore -- much for the same reasons.</div><br/></div></div></div></div></div></div><div id="36637497" class="c"><input type="checkbox" id="c-36637497" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36637597">prev</a><span>|</span><a href="#36638190">next</a><span>|</span><label class="collapse" for="c-36637497">[-]</label><label class="expand" for="c-36637497">[2 more]</label></div><br/><div class="children"><div class="content">Better title: TypeScript please give us reflection&#x2F;runtime types<p>AFAIK the best current solution is emitlDecoratorMetadata. [1]<p>[1] <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;tsconfig#emitDecoratorMetadata" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;tsconfig#emitDecoratorMetadat...</a></div><br/><div id="36638491" class="c"><input type="checkbox" id="c-36638491" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36637497">parent</a><span>|</span><a href="#36638190">next</a><span>|</span><label class="collapse" for="c-36638491">[-]</label><label class="expand" for="c-36638491">[1 more]</label></div><br/><div class="children"><div class="content">Ok, we&#x27;ll add that bit to the title above. Thanks!</div><br/></div></div></div></div><div id="36638190" class="c"><input type="checkbox" id="c-36638190" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36637497">prev</a><span>|</span><a href="#36637880">next</a><span>|</span><label class="collapse" for="c-36638190">[-]</label><label class="expand" for="c-36638190">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Type erasure is good! It means JavaScript project can consume TypeScript projects without any knowledge of TypeScript. It&#x27;s just emitted JavaScript. This does not mean you can&#x27;t emit the type information separately in a consumable lookup table that&#x27;s separate from the code. The lack of this type information means we use esoteric libraries which ultimately pollute the JavaScript with all the convoluted typing working arounds... soo... type erasure has defeated the purpose of type erasure. It&#x27;s a second order effect, where the design goal defeats the design goal. :(<p>I think the author misunderstands the design goals of TypeScript. The goal isn&#x27;t to have pristine, beautiful JS code with no complexity, the goal is to have the runtime semantics of TypeScript be identical to the runtime semantics of JavaScript. Barring the regretted exception of enums, TypeScript can be converted to JavaScript by simply stripping type annotations. <i>That&#x27;s</i> the design goal, and that goal is not in conflict with itself.<p>The ecosystem that has built up around TypeScript depends on complete type erasure, and much of it would evaporate if this wish were granted. TS support in ESBuild, Deno, and Bun would become nearly impossible, because each would need to re-implement all of tsc in their respective languages, while right now they just need to maintain their own simplified parsers.<p>On the other hand, the convoluted libraries that OP bemoans are perfectly compatible with all of these tools, because they&#x27;re implemented in user space.</div><br/><div id="36639107" class="c"><input type="checkbox" id="c-36639107" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#36638190">parent</a><span>|</span><a href="#36637880">next</a><span>|</span><label class="collapse" for="c-36639107">[-]</label><label class="expand" for="c-36639107">[1 more]</label></div><br/><div class="children"><div class="content">There are plenty of ways to emit runtime type information statically without a runtime. `keyof` could statically convert to the list of keys in a class. Hell, even typescript classes could do what ES6 classes do and initialize class keys to undefined. Currently, typescript classes erase all keys unless explicitly defined. Object.keys() on a newly instantiated typescript class without set members will return nothing, while an ES6 class will return all of the keys. Just an option in tsconfig.json to convert TS classes to ES6 classes (or just allow ES6 classes to exist at the same time in Typescript) would make some code generation WAY easier.<p>Or some kind of syntax to emit the name of a type as a string. Currently, if you run `typeof foo` it will return the type as a string. If you could have a static version of that, like `tstypeof foo`, or with a class:<p><pre><code>    class Foo {
        bar: string;
    };

    console.log(tstypeof Foo::bar) &#x2F;&#x2F; or something less C++-looking; compiles to &quot;string&quot;.
</code></pre>
then it would be killer. This could break compatibility if you change the type of a field and a compiled client using the code were to expect &quot;string&quot; when it&#x27;s been changed to &quot;number&quot;. But I&#x27;d rather live in that world than the one we live in now<p>Just some <i>basic</i> RTTI would make a lot of ugly codesmelly boilerplate Typescript code evaporate instantly.</div><br/></div></div></div></div><div id="36637880" class="c"><input type="checkbox" id="c-36637880" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#36638190">prev</a><span>|</span><a href="#36637610">next</a><span>|</span><label class="collapse" for="c-36637880">[-]</label><label class="expand" for="c-36637880">[5 more]</label></div><br/><div class="children"><div class="content">Thanks for this. I thought I was screaming into a void. I started with typescript in 2018 and after two years started to believe this is just not really a solution because what it is. I came from Haskell&#x2F;c#&#x2F;f#, and TS, while it has a very powerful type system, just doesnât give you much of the advantages the above languages give you outside (some of) dev. Even when it does, it is really limited in practice (aka when dealing with the real world) vs, letâs say, c#. You can defend from that somewhat, however, you have to always keep the extremely (and thatâs intended, but not what it could be) leaky abstractions in mind to not run into bugs that shouldnât be possible in something that claims static typing (if you donât know that it drops to js without checks after compile).</div><br/><div id="36638053" class="c"><input type="checkbox" id="c-36638053" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#36637880">parent</a><span>|</span><a href="#36637610">next</a><span>|</span><label class="collapse" for="c-36638053">[-]</label><label class="expand" for="c-36638053">[4 more]</label></div><br/><div class="children"><div class="content">The point of TypeScript was always to run on web, it wasn&#x27;t meant to give you a language advantage over say, C#. You use C# if you have to develop for .NET, you use TypeScript if you have to develop for Web, you wouldn&#x27;t use one or the other in another context.<p>That being said, TypeScript is differently capable from C#. C# is nominally typed, with decent reified generics. I like programming in C#, and miss its features when programming in TypeScript. TypeScript, on the other hand, is structurally typed, forgoes soundness, and comes with a powerful type system to express complex type relationships (again, possible because it forgoes soundness). I like programming in TypeScript also, and also miss its features when programming in C#. I doubt a language that combined C# and TypeScript would be very nice, these languages go in different directions to good effect, but they are not compatible directions.</div><br/><div id="36638293" class="c"><input type="checkbox" id="c-36638293" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#36637880">root</a><span>|</span><a href="#36638053">parent</a><span>|</span><a href="#36637610">next</a><span>|</span><label class="collapse" for="c-36638293">[-]</label><label class="expand" for="c-36638293">[3 more]</label></div><br/><div class="children"><div class="content">But thatâs when you focus on the type system theory and I agree with that. I donât see how enforcing types after compilation has anything to do with a programming language for the web vs ânot for the webâ though, but I understand it is the philosophy to check the types and then drop to plain JS. Best tool for the job, sure, but literally losing everything typed you wrote and designed after compilation is just not as useful as it could (should imho) be. You express whatever, it compiles, and then everything can break all that you carefully set up, without any errors.<p>Thatâs not the language or type system per se, itâs the compiler implementation or rather the philosophy to stay close to js and have a very thin (powerful) layer at compile time only. Typescript in wasm, Deno maybe (didnât try yet) etc could change this. Then we can have types as in other languages. Not sure why this would not be a win for everyone vs the current status.<p>Also, as you know, the run the web went out the door with nodejs; many backends are now typescript and indeed competing (â¦ for at least writing web apps) with c#.</div><br/><div id="36639574" class="c"><input type="checkbox" id="c-36639574" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#36637880">root</a><span>|</span><a href="#36638293">parent</a><span>|</span><a href="#36637610">next</a><span>|</span><label class="collapse" for="c-36639574">[-]</label><label class="expand" for="c-36639574">[2 more]</label></div><br/><div class="children"><div class="content">TypeScripts goal of being just a layer over JavaScript led to its type system design being primarily productivity based: the goal was to make programming nicer, using types to get more performance wasnât a goal or option.<p>C#, and the CLR underneath it, were performance based, and the types feed into that. The reason they both are as they are is because of the environments they are meant to be used in. So ya, are you running web apps on the CLR, or are you running them in the browser. I donât really get nodejs, or, i guess it only seems like you would go that route if you wanted to reuse your web browser devs or web browser code to run also in the server.</div><br/><div id="36642553" class="c"><input type="checkbox" id="c-36642553" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#36637880">root</a><span>|</span><a href="#36639574">parent</a><span>|</span><a href="#36637610">next</a><span>|</span><label class="collapse" for="c-36642553">[-]</label><label class="expand" for="c-36642553">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and I am aware of the histories, we just want (and need) something more now. Typescript still seems well positioned for this. Not many reasons you cannot fix this with a compiler flag (which is default off).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36637610" class="c"><input type="checkbox" id="c-36637610" checked=""/><div class="controls bullet"><span class="by">medler</span><span>|</span><a href="#36637880">prev</a><span>|</span><a href="#36637804">next</a><span>|</span><label class="collapse" for="c-36637610">[-]</label><label class="expand" for="c-36637610">[5 more]</label></div><br/><div class="children"><div class="content">Iâm mainly a backend programmer, so I know just a little typescript, but I donât really understand what theyâre asking for here. It sounds like they want to serialize and deserialize typescript types automatically? If so, that sounds like a good fit for a library, not something most languages offer. (Please educate me if Iâm missing the point)</div><br/><div id="36637961" class="c"><input type="checkbox" id="c-36637961" checked=""/><div class="controls bullet"><span class="by">jfengel</span><span>|</span><a href="#36637610">parent</a><span>|</span><a href="#36639229">next</a><span>|</span><label class="collapse" for="c-36637961">[-]</label><label class="expand" for="c-36637961">[3 more]</label></div><br/><div class="children"><div class="content">Javascript already has standard serialization and deserialization tools.<p>The problem is that the deserialization is untyped. It&#x27;s just a Javascript object. Usually, the first thing you&#x27;ll do is to cast it to a typed Typescript definition, but there&#x27;s no way to guarantee that it actually fits that definition. No type information exists at runtime. It&#x27;s used solely to check the code itself during compilation.<p>So any time you get data from outside of your program (over the network, from a database, out of a config file, etc.) you just have to hope that it actually fits the type. You can write code to check it... but you have to write that code yourself.<p>There are libraries you can use. For example, you can use a Data Description Language with a simpler type system, which usually suffices for the kind of data you want to serialize. Then you can use that to generate both a Typescript definition <i>and</i> a runtime type checker. But that&#x27;s inelegant, and not standard, so every project is different despite it being something everybody needs.</div><br/><div id="36638972" class="c"><input type="checkbox" id="c-36638972" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#36637610">root</a><span>|</span><a href="#36637961">parent</a><span>|</span><a href="#36639229">next</a><span>|</span><label class="collapse" for="c-36638972">[-]</label><label class="expand" for="c-36638972">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s basically the same for typed languages. If you want to map JSON to a typed data structure, you need a serialization library to do that.<p>JavaScript has a very simple built-in json reader&#x2F;writer that does no type checking and returns some nested dictionaries or arrays. If you want more, you need a library (for example zod). Or you just trust the data to have the right shape.</div><br/><div id="36639216" class="c"><input type="checkbox" id="c-36639216" checked=""/><div class="controls bullet"><span class="by">jfengel</span><span>|</span><a href="#36637610">root</a><span>|</span><a href="#36638972">parent</a><span>|</span><a href="#36639229">next</a><span>|</span><label class="collapse" for="c-36639216">[-]</label><label class="expand" for="c-36639216">[1 more]</label></div><br/><div class="children"><div class="content">Java has runtime type definitions, which you can use to automatically type check deserialized objects. With reflection you can write that in ordinary Java.<p>I imagine C# and other Java-esque languages have something similar. But Typescript deliberately avoids that, and it would be difficult to get it to do so.</div><br/></div></div></div></div></div></div><div id="36639229" class="c"><input type="checkbox" id="c-36639229" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#36637610">parent</a><span>|</span><a href="#36637961">prev</a><span>|</span><a href="#36637804">next</a><span>|</span><label class="collapse" for="c-36639229">[-]</label><label class="expand" for="c-36639229">[1 more]</label></div><br/><div class="children"><div class="content">There is currently no good way to automatically validate the object input to a typescript API. In the way that you can simply specify the class of a POST body to a spring boot controller or Asp.Net controller, every class in typescript requires you write the type information twice: once for the typescript compiler, and once again for the runtime deserializer, in the form of decorators. Having to write extra code to make up for a deficiency in your framework, runtime, or language is the definition of code smell. As such: all typescript backends which attempt to properly validate user input are guilty of egregious codesmell.<p>Additionally, because it is impossible to emit these types to the runtime, even in the form of a string naming the type, you cannot validate input to an API using generics. If you have, say, a class which will run a query for a record based on the keys in that record:<p><pre><code>    class Query&lt;T&gt;{
        filter: Array&lt;keyof T&gt;
    };
</code></pre>
The typescript compiler can validate if a string in &quot;filter&quot; is, in fact, a key of the class T. However, you cannot write any decorator on this class to make the information of what keys exist on T available at runtime. Therefore, to write such a query interface and validate it at runtime, every record which can be queried with this object must have its own specific &quot;[Record]Query&quot; class written with its own decorators to validate every possible input, usually with the valid keys hardcoded into the decorator.<p>Because there is no real relationship between the class and the runtime validators, this makes validation more error prone, because it relies on either human beings to consistently remember to add new fields to the relevant decorators, or a custom linting tool to be written which basically pre-processes the typescript source using the typescript API. This is, again, writing code to account for the lack of features in the framework.<p>WHY do we put up with this crap? We have had Java and C# for a long time, and they solved these problems a long time ago. Why are we writing Typescript on the backend?<p>The simple answer; it is easier to find javascript developers than it is to find java developers. Bootcamps don&#x27;t teach Java or C# because there&#x27;s more react jobs out there. Bootcamp grads are not generally coding enthusiasts and so re-tooling is difficult for them and they don&#x27;t generally do it for fun. So, we decided to write our backend in Javascript (or Typescript) as a <i>labor</i> decision, not a <i>technology</i> decision.</div><br/></div></div></div></div><div id="36637804" class="c"><input type="checkbox" id="c-36637804" checked=""/><div class="controls bullet"><span class="by">frou_dh</span><span>|</span><a href="#36637610">prev</a><span>|</span><a href="#36637619">next</a><span>|</span><label class="collapse" for="c-36637804">[-]</label><label class="expand" for="c-36637804">[3 more]</label></div><br/><div class="children"><div class="content">I was perfectly satisfied with using <a href="https:&#x2F;&#x2F;zod.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;zod.dev</a> for some runtime data validation, and found it really cool that I didn&#x27;t have to define some nominal type off to the side and could instead just say what I meant inline using a fluent API.</div><br/><div id="36637904" class="c"><input type="checkbox" id="c-36637904" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#36637804">parent</a><span>|</span><a href="#36637619">next</a><span>|</span><label class="collapse" for="c-36637904">[-]</label><label class="expand" for="c-36637904">[2 more]</label></div><br/><div class="children"><div class="content">Nominal types have different use cases.<p>Simple one, distinguishing `2` number with `2` currency in your domain.</div><br/><div id="36641880" class="c"><input type="checkbox" id="c-36641880" checked=""/><div class="controls bullet"><span class="by">lf-non</span><span>|</span><a href="#36637804">root</a><span>|</span><a href="#36637904">parent</a><span>|</span><a href="#36637619">next</a><span>|</span><label class="collapse" for="c-36641880">[-]</label><label class="expand" for="c-36641880">[1 more]</label></div><br/><div class="children"><div class="content">We can use branded types to simulate nominal typing<p><a href="https:&#x2F;&#x2F;zod.dev&#x2F;?id=brand" rel="nofollow noreferrer">https:&#x2F;&#x2F;zod.dev&#x2F;?id=brand</a></div><br/></div></div></div></div></div></div><div id="36637619" class="c"><input type="checkbox" id="c-36637619" checked=""/><div class="controls bullet"><span class="by">moritzwarhier</span><span>|</span><a href="#36637804">prev</a><span>|</span><a href="#36637512">next</a><span>|</span><label class="collapse" for="c-36637619">[-]</label><label class="expand" for="c-36637619">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting post to me. There always was the argument that TS should be erasable and carry no runtime information, enums and decorators are a mistake, etc.<p>For what it&#x27;s worth, I want my production bundle to be as small as possible. Most people use bundlers among TypeScript, which further complicates things.<p>I would love a <i>standard</i> library to e.g. generate type predicate functions from TS types.<p>Taming the beast from this end might even end up useful for things like compilers, no?<p>TS provides a nice mechanism to be strict in the frontend and validate types using runtime code, that is, type predicates.<p>But from a higher level, this has never been enough, and you want to map JSON to TS types using some kind of schema definition.<p>I would love to just be able to pass in a TypeScript type and generate its type predicate at compile time.<p>Unfortunately, this is impossible due to the halting problem.<p>So, a <i>standard</i> solution for the case of a plain serializable JS&#x2F;JSON object and the according TS interface would be very much welcome.<p>Edit: and all of this is of course about data from external sources (requests, DOM, compiler...). For all of the code and data known at compile time, there is rarely a need to validate types, as they are statically analyzable.<p>So there is a huge scope that TypeScript has to cater to.
It includes JS projects where external type definitions often become obsolete and people who code in TS but do not enable strict mode for their own code (that is, disallow &quot;any&quot;).
And all of these type defintions have to be interoperable.<p>For API requests, this is basically calling for a default generic REST client, and I agree that would be useful. The REST client could use type predicate functions extensively.</div><br/></div></div><div id="36637512" class="c"><input type="checkbox" id="c-36637512" checked=""/><div class="controls bullet"><span class="by">dvt</span><span>|</span><a href="#36637619">prev</a><span>|</span><a href="#36637848">next</a><span>|</span><label class="collapse" for="c-36637512">[-]</label><label class="expand" for="c-36637512">[1 more]</label></div><br/><div class="children"><div class="content">I dunno, this seems like it would be out of scope for something like TS proper (there&#x27;s already been a ton of feature creep, anyway). Reflection is generally implemented via runtimes, which can be very clunky. Is it really worth doing this in JS? Tooling already seems too bulky as is.</div><br/></div></div><div id="36637848" class="c"><input type="checkbox" id="c-36637848" checked=""/><div class="controls bullet"><span class="by">can16358p</span><span>|</span><a href="#36637512">prev</a><span>|</span><a href="#36641943">next</a><span>|</span><label class="collapse" for="c-36637848">[-]</label><label class="expand" for="c-36637848">[5 more]</label></div><br/><div class="children"><div class="content">This shouldn&#x27;t happen... unless someone finds a way to do this without a runtime overhead, which naturally seems impossible.<p>If this is done, TS will become something entirely different as it currently doesn&#x27;t have a runtime: it&#x27;s a huge-and-smart linter.<p>But that&#x27;s all about it. No matter how huge, it&#x27;s a linter.<p>Reflection would imply something beyond that. Even though I absolutely love reflection, I believe it should not be integrated into TS.</div><br/><div id="36641441" class="c"><input type="checkbox" id="c-36641441" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36637848">parent</a><span>|</span><a href="#36638290">next</a><span>|</span><label class="collapse" for="c-36641441">[-]</label><label class="expand" for="c-36641441">[2 more]</label></div><br/><div class="children"><div class="content">It has nothing to do with any runtime.<p>You just write<p><pre><code>    const personType: Type = typeof(Person);
</code></pre>
This code gets compiled into<p><pre><code>    const personType = {
      name: &quot;Person&quot;,
      fields: [
        { name: &quot;lastName&quot;, type: &quot;string&quot; },
        { name: &quot;firstName&quot;, type: &quot;string&quot; },
      ],
    }
</code></pre>
There&#x27;s no runtime. It&#x27;s just an object which describes layout of some time.<p>If you would implement validation by hand, you&#x27;d come up with absolutely conceptually identical code. Look at any validation libraries out there.<p>The only difference is: you specify types with nice TypeScript language, not with some made-up abomination DSL.</div><br/><div id="36642393" class="c"><input type="checkbox" id="c-36642393" checked=""/><div class="controls bullet"><span class="by">can16358p</span><span>|</span><a href="#36637848">root</a><span>|</span><a href="#36641441">parent</a><span>|</span><a href="#36638290">next</a><span>|</span><label class="collapse" for="c-36642393">[-]</label><label class="expand" for="c-36642393">[1 more]</label></div><br/><div class="children"><div class="content">Oh okay I was thinking of more of a runtime-code-emitting-dynamically kind of thing.<p>If it&#x27;s the way you&#x27;ve shown it&#x27;d be great!</div><br/></div></div></div></div><div id="36638290" class="c"><input type="checkbox" id="c-36638290" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#36637848">parent</a><span>|</span><a href="#36641441">prev</a><span>|</span><a href="#36641943">next</a><span>|</span><label class="collapse" for="c-36638290">[-]</label><label class="expand" for="c-36638290">[2 more]</label></div><br/><div class="children"><div class="content">No runtime necessary, if I understand the problem.<p>Input is bytes.  Bytes will never carry their type information (and if they did, you couldn&#x27;t trust them).  So the type information needs to be used in the Deserialiser, not its input.<p>To get typed deserialisation of Foo, the compiler needs to generate a FooDeserialiser automatically for you.  The compiler can&#x27;t depend directly on Foo (Foo is written after the compiler), but if Foo could somehow emit its type information during compilation, then the compiler could depend on <i>that</i>.</div><br/><div id="36642403" class="c"><input type="checkbox" id="c-36642403" checked=""/><div class="controls bullet"><span class="by">can16358p</span><span>|</span><a href="#36637848">root</a><span>|</span><a href="#36638290">parent</a><span>|</span><a href="#36641943">next</a><span>|</span><label class="collapse" for="c-36642403">[-]</label><label class="expand" for="c-36642403">[1 more]</label></div><br/><div class="children"><div class="content">Then I&#x27;m all in. I thought something done at runtime dynamically, instead of statically genereting type information at compile time.<p>It&#x27;d be lovely the way you described.</div><br/></div></div></div></div></div></div><div id="36641943" class="c"><input type="checkbox" id="c-36641943" checked=""/><div class="controls bullet"><span class="by">dSebastien</span><span>|</span><a href="#36637848">prev</a><span>|</span><a href="#36641913">next</a><span>|</span><label class="collapse" for="c-36641943">[-]</label><label class="expand" for="c-36641943">[1 more]</label></div><br/><div class="children"><div class="content">Runtime type checking is an explicit non-goal of TS: <a href="https:&#x2F;&#x2F;www.dsebastien.net&#x2F;2020-04-25-typescript-non-goals&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.dsebastien.net&#x2F;2020-04-25-typescript-non-goals&#x2F;</a></div><br/></div></div><div id="36641913" class="c"><input type="checkbox" id="c-36641913" checked=""/><div class="controls bullet"><span class="by">lf-non</span><span>|</span><a href="#36641943">prev</a><span>|</span><a href="#36637734">next</a><span>|</span><label class="collapse" for="c-36641913">[-]</label><label class="expand" for="c-36641913">[1 more]</label></div><br/><div class="children"><div class="content">Deepkit (listed in the article) is a fascinating project and really deserves to be more popular.<p>It also demonstrates that what is being asked for is actually practical.<p><a href="https:&#x2F;&#x2F;deepkit.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;deepkit.io&#x2F;</a></div><br/></div></div><div id="36637734" class="c"><input type="checkbox" id="c-36637734" checked=""/><div class="controls bullet"><span class="by">noobdev9000</span><span>|</span><a href="#36641913">prev</a><span>|</span><a href="#36639304">next</a><span>|</span><label class="collapse" for="c-36637734">[-]</label><label class="expand" for="c-36637734">[2 more]</label></div><br/><div class="children"><div class="content">Modern TS code is hard for me to read and reason, and I use Rust, Haskell, C++. Way too complex for my brain</div><br/><div id="36637939" class="c"><input type="checkbox" id="c-36637939" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#36637734">parent</a><span>|</span><a href="#36639304">next</a><span>|</span><label class="collapse" for="c-36637939">[-]</label><label class="expand" for="c-36637939">[1 more]</label></div><br/><div class="children"><div class="content">Well, as always, this really depends on our the code we read and our background.<p>TypeScript&#x27;s type system is indeed way more verbose than Haskell&#x27;s.</div><br/></div></div></div></div><div id="36639304" class="c"><input type="checkbox" id="c-36639304" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36637734">prev</a><span>|</span><a href="#36637811">next</a><span>|</span><label class="collapse" for="c-36639304">[-]</label><label class="expand" for="c-36639304">[1 more]</label></div><br/><div class="children"><div class="content">Fairly recently I built a C library for object serialization, based on run-time reflection. Run-time reflection is not necessary to the task and makes it perform worse than a code-generating solution.<p>The run-time reflection approach is good in one way: it doesn&#x27;t add tooling to the project. All the modules that use serialization have to make a bunch of tedious API calls to build the type object which represents the C structure. This is created once and stashed in a global variable. Then it is used as a parameter when serializing and deserializing.<p>There is a performance impact because the marshaling code is interpreting the type object; it recursively walks the type object, and in parallel it walks the C object to extract or stuff material.<p>A generative approach would just write a serialization and deserialization stub. There would be no need for any type object to be walked at run-time. No need to construct such objects at startup and no need to carry the library for that.<p>But there would be some tool which itself has to be compiled (for the build machine, not the embedded targets), and then some Makefile steps to run that tool on some interface files. The thought of inflicting that one the project made me go yuck.<p>A third possibility is to have the run-time type info objects, and add JIT. Why do something easy, like a code generation tool called out of Makefile, when you can do something hard and nonportable?</div><br/></div></div><div id="36637811" class="c"><input type="checkbox" id="c-36637811" checked=""/><div class="controls bullet"><span class="by">william-evans</span><span>|</span><a href="#36639304">prev</a><span>|</span><a href="#36638018">next</a><span>|</span><label class="collapse" for="c-36637811">[-]</label><label class="expand" for="c-36637811">[1 more]</label></div><br/><div class="children"><div class="content">As listed, Typebox is excellent for this use case - it correctly implements the JSON schema spec and allows you to use it to write OpenAPI specifications. At my company we use this to write type-safe handlers &amp; generate our API documentation!</div><br/></div></div><div id="36638018" class="c"><input type="checkbox" id="c-36638018" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36637811">prev</a><span>|</span><a href="#36637569">next</a><span>|</span><label class="collapse" for="c-36638018">[-]</label><label class="expand" for="c-36638018">[7 more]</label></div><br/><div class="children"><div class="content">Please give me an integer type.<p>Just kidding, but I&#x27;m not pushing for JavaScript anymore. If rust&#x2F;WASM works as well, I say go with that.</div><br/><div id="36638195" class="c"><input type="checkbox" id="c-36638195" checked=""/><div class="controls bullet"><span class="by">orthecreedence</span><span>|</span><a href="#36638018">parent</a><span>|</span><a href="#36639553">next</a><span>|</span><label class="collapse" for="c-36638195">[-]</label><label class="expand" for="c-36638195">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Just kidding, but I&#x27;m not pushing for JavaScript anymore. If rust&#x2F;WASM works as well, I say go with that.<p>This is the direction I&#x27;m going. I use rust a LOT these days, and after trying out typescript for a few projects over the course of a few months, I absolutely hate it when comparing it to rust or even any other compiled language. Something about it just rubs me the wrong way...maybe the fact that it has to be JS-compatible, so the type system seems really crude? I can&#x27;t put my finger on it. It sort of hits this weird inbetween where js is quick to write&#x2F;prototype and rust is extremely &quot;correct&quot; but the ts type system slows things down&#x2F;annoys me without providing enough benefits. Also, working with it in nested projects via npm tends to be a huge pain in the ass. Maybe I need to switch to Deno or something so it&#x27;s native?<p>Now that rust&#x2F;wasm is ramping up, I&#x27;m considering using rust for the API layer and something like Leptos for the frontend. I&#x27;ve been getting into svelte a lot, and Leptos seems similar enough to not be a huge leap.</div><br/><div id="36638304" class="c"><input type="checkbox" id="c-36638304" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36638018">root</a><span>|</span><a href="#36638195">parent</a><span>|</span><a href="#36639553">next</a><span>|</span><label class="collapse" for="c-36638304">[-]</label><label class="expand" for="c-36638304">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious what you think about Dart&#x2F;Flutter if you&#x27;ve gotten a chance to dig into them. I am very impressed, but it trades simplicity for being cross platform. It has a nice set of types though. <a href="https:&#x2F;&#x2F;dart.dev&#x2F;language&#x2F;built-in-types" rel="nofollow noreferrer">https:&#x2F;&#x2F;dart.dev&#x2F;language&#x2F;built-in-types</a><p>It also has a WASM compilation target that is under early development. <a href="https:&#x2F;&#x2F;docs.flutter.dev&#x2F;platform-integration&#x2F;web&#x2F;wasm" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.flutter.dev&#x2F;platform-integration&#x2F;web&#x2F;wasm</a></div><br/><div id="36642184" class="c"><input type="checkbox" id="c-36642184" checked=""/><div class="controls bullet"><span class="by">orthecreedence</span><span>|</span><a href="#36638018">root</a><span>|</span><a href="#36638304">parent</a><span>|</span><a href="#36639553">next</a><span>|</span><label class="collapse" for="c-36642184">[-]</label><label class="expand" for="c-36642184">[1 more]</label></div><br/><div class="children"><div class="content">Good question! I prototyped some stuff on Dart&#x2F;Flutter. What I took away from it is that a) I really liked Flutter b) I really do not like Dart. I really tried to like Dart (mainly because I was enthralled by the idea of Flutter) but it just didn&#x27;t click for me. It seemed like the syntax was trying to be intuitive in some ways, logical in others, and that incongruity really made it hard for me to pick up. I think overall it felt inconsistent in confusing ways. I also was both simulaneously impressed and disgusted by the fact that it render everything in a canvas for desktop...I mean, it totally makes sense, and what a great way to get consistent rendering acros platforms, but I wonder what the tradeoffs are. Accessibility must suffer in some way, but maybe they figured all that out.<p>I wish Flutter was just a regular GUI library for another language (C maybe, so you can use it from everywhere, that&#x27;d be nice). Dart really killed it for me. Also, I know it&#x27;s beating a dead horse, but Google doesn&#x27;t have a good track record with long term support of their projects. If it was a grassroots open source project, I&#x27;d probably feel a lot more secure putting aside my Dart-inflicted OCD and really picking it up.<p>Given my current love affair with Rust, my main squeeze right now is Tauri. Once they hit mobile platforms I think it&#x27;ll be unstoppable, and in the meantime whatever you can do in Tauri you could probably translate to Ionic.</div><br/></div></div></div></div></div></div><div id="36639553" class="c"><input type="checkbox" id="c-36639553" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#36638018">parent</a><span>|</span><a href="#36638195">prev</a><span>|</span><a href="#36637569">next</a><span>|</span><label class="collapse" for="c-36639553">[-]</label><label class="expand" for="c-36639553">[3 more]</label></div><br/><div class="children"><div class="content">JS added BigInts quite a while ago.</div><br/><div id="36641458" class="c"><input type="checkbox" id="c-36641458" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36638018">root</a><span>|</span><a href="#36639553">parent</a><span>|</span><a href="#36640116">next</a><span>|</span><label class="collapse" for="c-36641458">[-]</label><label class="expand" for="c-36641458">[1 more]</label></div><br/><div class="children"><div class="content">Yet JSON.parse(&quot;9007199254740993&quot;) returns 9007199254740992, not 9007199254740993n.</div><br/></div></div></div></div></div></div><div id="36637569" class="c"><input type="checkbox" id="c-36637569" checked=""/><div class="controls bullet"><span class="by">lucidone</span><span>|</span><a href="#36638018">prev</a><span>|</span><a href="#36637784">next</a><span>|</span><label class="collapse" for="c-36637569">[-]</label><label class="expand" for="c-36637569">[3 more]</label></div><br/><div class="children"><div class="content">OP and those who feel a similar sentiment should give C# a shot, it&#x27;s what they want regardless of whether they know it or not.</div><br/><div id="36639466" class="c"><input type="checkbox" id="c-36639466" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#36637569">parent</a><span>|</span><a href="#36637895">next</a><span>|</span><label class="collapse" for="c-36639466">[-]</label><label class="expand" for="c-36639466">[1 more]</label></div><br/><div class="children"><div class="content">I love C#. At work, when I write standalone tools, I always do them in C#. My boss tolerates this since I&#x27;m usually the only one using them. But I don&#x27;t get to choose what our backend is written in</div><br/></div></div><div id="36637895" class="c"><input type="checkbox" id="c-36637895" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#36637569">parent</a><span>|</span><a href="#36639466">prev</a><span>|</span><a href="#36637784">next</a><span>|</span><label class="collapse" for="c-36637895">[-]</label><label class="expand" for="c-36637895">[1 more]</label></div><br/><div class="children"><div class="content">Yep, but you want to write frontend with it then. Blazor (or whatever liveview-like implementation) or wasm might fix that.</div><br/></div></div></div></div><div id="36637784" class="c"><input type="checkbox" id="c-36637784" checked=""/><div class="controls bullet"><span class="by">zoogeny</span><span>|</span><a href="#36637569">prev</a><span>|</span><a href="#36638155">next</a><span>|</span><label class="collapse" for="c-36637784">[-]</label><label class="expand" for="c-36637784">[1 more]</label></div><br/><div class="children"><div class="content">This is the perennial problem with language design. Everyone wants something and they even have reasonable grounds to ask for it.<p>I myself have come across moments where some rtti&#x2F;reflection would have been useful. In those cases I was often able to use branded types. Having something like that built into the language might be nice. But I&#x27;d also support TypeScript and JavaScript developers making the choice not to support it ever. IME, working around rtti type code often forces the programmer to come up with a much better approach.</div><br/></div></div><div id="36638155" class="c"><input type="checkbox" id="c-36638155" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#36637784">prev</a><span>|</span><a href="#36637505">next</a><span>|</span><label class="collapse" for="c-36638155">[-]</label><label class="expand" for="c-36638155">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m kind of doubting the real value of this.<p>For validation, ORMs, APIs, etc., once you move beyond the simplest cases, you need more information than is present in Typescript type information. And that&#x27;s before we get to the app-specific concerns.<p>So you&#x27;re going to end up with schemas, boiler-plate, code-generators, and&#x2F;or glue code anyway. Not to mention the libraries to help manage this stuff.<p>It&#x27;s not that it&#x27;s completely unhelpful, but I think it&#x27;s a partial solution, and not the tricky part either.</div><br/></div></div><div id="36637505" class="c"><input type="checkbox" id="c-36637505" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36638155">prev</a><span>|</span><a href="#36638884">next</a><span>|</span><label class="collapse" for="c-36637505">[-]</label><label class="expand" for="c-36637505">[3 more]</label></div><br/><div class="children"><div class="content">There are good typed deserialization libraries. Personally, I prefer runtypes but there are options.</div><br/><div id="36637790" class="c"><input type="checkbox" id="c-36637790" checked=""/><div class="controls bullet"><span class="by">decs</span><span>|</span><a href="#36637505">parent</a><span>|</span><a href="#36638884">next</a><span>|</span><label class="collapse" for="c-36637790">[-]</label><label class="expand" for="c-36637790">[2 more]</label></div><br/><div class="children"><div class="content">Agree, zod, arktype, and typia are impressively easy to use! Though, I feel that this environment created a different problem of spreading developers into multiple solutions. So for lib devs like me, we end up having to choose between coupling with a single validation lib or managing support for multiple (like tRPC does). To address that, I ended up doing a reusable lightweight lib that wraps that logic for supporting multiple: <a href="https:&#x2F;&#x2F;typeschema.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;typeschema.com</a></div><br/><div id="36642083" class="c"><input type="checkbox" id="c-36642083" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#36637505">root</a><span>|</span><a href="#36637790">parent</a><span>|</span><a href="#36638884">next</a><span>|</span><label class="collapse" for="c-36642083">[-]</label><label class="expand" for="c-36642083">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the lib! I&#x27;m always charmed to come across such a concrete example of the fundamental theorem of software engineering: &quot;We can solve any problem by introducing an extra level of indirection.&quot;</div><br/></div></div></div></div></div></div><div id="36638884" class="c"><input type="checkbox" id="c-36638884" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36637505">prev</a><span>|</span><a href="#36637666">next</a><span>|</span><label class="collapse" for="c-36638884">[-]</label><label class="expand" for="c-36638884">[1 more]</label></div><br/><div class="children"><div class="content">Anything run-time has to come from JavaScript.<p>TypeScript is syntactic expansion layer over JavaScript.<p>&quot;C preprocessor, please give me arrays that know how big they are at run-time. Oh, and access to the calling function&#x27;s local variables!&quot;<p>&quot;Common Lisp defmacro, give me continuations usable anywhere!&quot;<p>A macro layer can bring you the pie in the sky, but only (1) at some nonozero cost and (2) with additional representations that are not understood by regular code that is not in that framework.<p>Suppose a TypeScript type object is attached to every run-time object created in TypeScript. Firstly, those objects become more bloated and expensive to construct. [Edit: not really: all objects of the same type can have a pointer to the same meta-data which is created once]. They will need run-time support in their execution environment in order to have those type representations. Objects not created by TypeScript-generated code will not have anything like that attached to them, so places in the system where the two domains interoperate won&#x27;t be able to rely on reflection; it will need a fallback for objects that don&#x27;t do reflection.<p>I think serialization can be done without reflection. Because at the time when the static language is being processed, you could annotate certain types as requiring serialization. Then for those types, TypeScript would generate the marshaling routines.<p>Generating marshaling stubs from an interface language has been done in the C world for decades. It doesn&#x27;t require any run-time types. The generated marshaling stubs just know how to walk objects of the type that they handle, and that&#x27;s it.<p>It looks like in TypeScript, serialization is just punted to JSON, which is inadequate because when we are deserializing, we want to check that the JSON blob has a type and shape compatible with the TypeScript-level type. (Or even for that that type to be inferred in some way.) There are some libraries that try to do something in this direction like ts-serializer.<p>I think it&#x27;s something you really want in TypeScript itself.<p>Basically round up the half-dozen or so use cases for reflection, and provide for all of them somehow without actual reflection. It&#x27;s an X&#x2F;Y problem. People really want to do Y (e.g. serialization), and believe that they must first solve X (have metadata in objects for reflection).</div><br/></div></div><div id="36637666" class="c"><input type="checkbox" id="c-36637666" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#36638884">prev</a><span>|</span><a href="#36638252">next</a><span>|</span><label class="collapse" for="c-36637666">[-]</label><label class="expand" for="c-36637666">[1 more]</label></div><br/><div class="children"><div class="content">2Â¢, having non-runtime types makes code behavior easier to reason about, especially when aggressive type inference is present, and I&#x27;d hate to lose it<p>One of the things I don&#x27;t love about Rust is how type inference affects program behavior in ways that can be really subtle. In Rust&#x27;s case this is a necessary evil because it doesn&#x27;t have a dynamic foundation, but TypeScript has done great without that compromise</div><br/></div></div><div id="36638252" class="c"><input type="checkbox" id="c-36638252" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#36637666">prev</a><span>|</span><a href="#36640040">next</a><span>|</span><label class="collapse" for="c-36638252">[-]</label><label class="expand" for="c-36638252">[1 more]</label></div><br/><div class="children"><div class="content">While type hints in Python are not as nice as typescript annotations, I understand their plea, because once thing Python does better is runtime introspection.<p>Which means we can have dataclass, pydantic, typer and fastapi all generating their stuff from regular type hints. No need for special syntax or functions. And that&#x27;s super nice.</div><br/></div></div><div id="36640040" class="c"><input type="checkbox" id="c-36640040" checked=""/><div class="controls bullet"><span class="by">chmod775</span><span>|</span><a href="#36638252">prev</a><span>|</span><a href="#36640373">next</a><span>|</span><label class="collapse" for="c-36640040">[-]</label><label class="expand" for="c-36640040">[1 more]</label></div><br/><div class="children"><div class="content">Since it&#x27;s not explicitly listed there, I feel I should shout out David Blass and his incredibly cool ArkType project[1]. It&#x27;s typescript wizardry.<p>He sometimes (used to?) streams himself working on twitch and it&#x27;s a really comfy place to hang out.[2]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;arktypeio&#x2F;arktype">https:&#x2F;&#x2F;github.com&#x2F;arktypeio&#x2F;arktype</a><p>[2] <a href="https:&#x2F;&#x2F;www.twitch.tv&#x2F;arktypeio" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.twitch.tv&#x2F;arktypeio</a></div><br/></div></div><div id="36640373" class="c"><input type="checkbox" id="c-36640373" checked=""/><div class="controls bullet"><span class="by">cannabis_sam</span><span>|</span><a href="#36640040">prev</a><span>|</span><a href="#36638174">next</a><span>|</span><label class="collapse" for="c-36640373">[-]</label><label class="expand" for="c-36640373">[1 more]</label></div><br/><div class="children"><div class="content">This is just the desperation that comes with poor understanding. The strength of a type system should ideally be that you could confidently execute the underlying code even with full type erasure, and while I realize that TS has already sacrificed this to some extent, adding reflection&#x2F;runtime âtypesâ would just further degrade the value of TS.<p>No thanks! If you want this, compile java to JS or something equally hamfistedâ¦</div><br/></div></div><div id="36638174" class="c"><input type="checkbox" id="c-36638174" checked=""/><div class="controls bullet"><span class="by">nycdotnet</span><span>|</span><a href="#36640373">prev</a><span>|</span><label class="collapse" for="c-36638174">[-]</label><label class="expand" for="c-36638174">[2 more]</label></div><br/><div class="children"><div class="content">The TypeScript language service which powers IDEs and which is maintained&#x2F;shipped with TypeScript already has the knowledge of all the types in your application.  It seems like it would be relatively straight-forward (though a lot of work!) to develop some sort of code gen library that uses the TypeScript types known to the language service to reflect on those types and emit some sort of runtime type validation functions as part of a build step.  This could be done in an npm module similar to webpack or in an IDE plugin.  If that functionality doesn&#x27;t exist today given all the listed open source projects, I&#x27;m kind of surprised.  I don&#x27;t think the TypeScript team would need to do anything to allow such a project to be developed.</div><br/><div id="36638213" class="c"><input type="checkbox" id="c-36638213" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36638174">parent</a><span>|</span><label class="collapse" for="c-36638213">[-]</label><label class="expand" for="c-36638213">[1 more]</label></div><br/><div class="children"><div class="content">It has quite an awkward way of being distributed. If you google for standalone TypeScript language services you&#x27;ll find unofficial ones. Deno&#x27;s is much simpler. Maybe they should pioneer this.<p>Edit: Actually this is the first result, I hadn&#x27;t tried those exact terms. It&#x27;s a bit hairy though, which is why the unofficial typescript-language-server npm package wraps it. <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;wiki&#x2F;Standalone-Server-(tsserver)">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;wiki&#x2F;Standalone-Serv...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>