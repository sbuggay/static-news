<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703754056152" as="style"/><link rel="stylesheet" href="styles.css?v=1703754056152"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.sanctum.geek.nz/series/unix-as-ide/">Unix as IDE (2012)</a> <span class="domain">(<a href="https://blog.sanctum.geek.nz">blog.sanctum.geek.nz</a>)</span></div><div class="subtext"><span>pabs3</span> | <span>21 comments</span></div><br/><div><div id="38791058" class="c"><input type="checkbox" id="c-38791058" checked=""/><div class="controls bullet"><span class="by">reissbaker</span><span>|</span><a href="#38790722">next</a><span>|</span><label class="collapse" for="c-38791058">[-]</label><label class="expand" for="c-38791058">[1 more]</label></div><br/><div class="children"><div class="content">IMO tmux + a scriptable terminal editor (Vim, Neovim, Emacs, etc) turns Unix into a very nice IDE — but it&#x27;s pretty dependent on becoming deeply familiar with those two tools: a multiplexer and an editor.<p>I wouldn&#x27;t say Unix is an IDE, really; but you can build a very nice IDE for yourself using Unix tools, as long as you have a sufficiently configurable terminal multiplexer and a sufficiently configurable terminal editor.<p>One pretty major difference between &quot;Unix is an IDE&quot; vs &quot;you can build an IDE around Unix&quot; is that, well, the terminal editor is actually pretty close to an IDE — you can have language server based autocomplete, refactoring, linting; UI for git; etc. So, it&#x27;s not <i>really</i> that Unix is your IDE; your editor is. But the nice thing about running it in a multiplexer in a terminal, though, is you have instant and easy access to just about any other command-line tool just a keyboard shortcut away, and it can be organized visually wherever you like — a pane on the side, beneath, zoomed in temporarily to encompass the screen, hidden in a tab, etc.<p>(Sufficiently advanced terminal emulators could also fill in for tmux here.)<p>I think you get many of the same benefits using a tiling window manager... But well, the best ones require running Linux (or one of the OSS BSDs); the options for your company-provided Macbook are fewer and less good. Tmux + terminal editor is pretty nice as something that works in any Unix environment.</div><br/></div></div><div id="38790722" class="c"><input type="checkbox" id="c-38790722" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#38791058">prev</a><span>|</span><a href="#38791169">next</a><span>|</span><label class="collapse" for="c-38790722">[-]</label><label class="expand" for="c-38790722">[3 more]</label></div><br/><div class="children"><div class="content">Unix is a DE, no I about it.<p>This isn’t a ding against Unix, the integration provided by IDEs is great for some types of work, but it’s also more hindrance than help for other types of work.<p>Also, the toolset that you get from a typical Unix environment is more or less language agnostic, so you have your tool toolset available to you even when you’re working on something obscure with poor dedicated tooling support.<p>That is not a replacement for IntelliJ knowing about my DI bindings, though.</div><br/><div id="38790959" class="c"><input type="checkbox" id="c-38790959" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#38790722">parent</a><span>|</span><a href="#38791155">next</a><span>|</span><label class="collapse" for="c-38790959">[-]</label><label class="expand" for="c-38790959">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the article very conveniently ignores the &quot;integrated&quot; part of the IDE acronym. Which was one of the maint selling points of them: you don&#x27;t have to cobble various small pieces of functionalty together by yourself, it&#x27;s been figured out and done for you by the IDE developers <i>once</i>, now you can just write your programs.</div><br/></div></div></div></div><div id="38791169" class="c"><input type="checkbox" id="c-38791169" checked=""/><div class="controls bullet"><span class="by">dawnofdusk</span><span>|</span><a href="#38790722">prev</a><span>|</span><a href="#38790584">next</a><span>|</span><label class="collapse" for="c-38791169">[-]</label><label class="expand" for="c-38791169">[5 more]</label></div><br/><div class="children"><div class="content">Unix shell utilities as an idea&#x2F;philosophy are a really good IDE, but in practice a lot of them need major UX overhauls. `find` is awful, for example, if only because it uses single hyphens followed by full words for it&#x27;s flags (different from almost all other conventions...)<p>Doing anything which involves more than one pipe or xargs is just painful. Bash as a language is not ergonomic at all.<p>I don&#x27;t know if there&#x27;s a nice alternative that keeps the same spirit. My feeling is something like emacs + eshell (a shell which can execute elisp expressions)? Elisp is not a very ergonomic language either, of course... but something like this.<p>VSCode was a revolution in giving an IDE with a good UI, every feature one could want, and fairly good performance. In 2023, I feel like everyone&#x27;s on containerized&#x2F;distributable work flows so there is a big need to actually return to &quot;UNIX as IDE&quot; type work, and now would be a great time for some new CLI tools that improve on the past.</div><br/><div id="38791267" class="c"><input type="checkbox" id="c-38791267" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#38791169">parent</a><span>|</span><a href="#38791270">next</a><span>|</span><label class="collapse" for="c-38791267">[-]</label><label class="expand" for="c-38791267">[1 more]</label></div><br/><div class="children"><div class="content">Many (most?) of them have been overhauled with success. For find there is fd[1]. There&#x27;s batcat, exa (ls), ripgrep, fzf, atuin (history), delta (diff) and many more.<p>Most are both backwards compatible and fresh and friendly. Your hardwon muscle memory still of good use. But there&#x27;s sane flags and defaults too. It&#x27;s faster, more colorful (if you wish), better integration with another (e.g. exa&#x2F;eza or aware of git modifications). And, in my case, often features I never knew I needed (atuin sync!, ripgrep using gitignore).<p>1 <a href="https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;fd">https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;fd</a></div><br/></div></div><div id="38791270" class="c"><input type="checkbox" id="c-38791270" checked=""/><div class="controls bullet"><span class="by">madog</span><span>|</span><a href="#38791169">parent</a><span>|</span><a href="#38791267">prev</a><span>|</span><a href="#38790584">next</a><span>|</span><label class="collapse" for="c-38791270">[-]</label><label class="expand" for="c-38791270">[3 more]</label></div><br/><div class="children"><div class="content">There are modern alternatives to many of the classic utils e.g. `fd` for find, with better CLI args and other improvements<p>ripgrep for grep also comes to mind</div><br/><div id="38791356" class="c"><input type="checkbox" id="c-38791356" checked=""/><div class="controls bullet"><span class="by">petepete</span><span>|</span><a href="#38791169">root</a><span>|</span><a href="#38791270">parent</a><span>|</span><a href="#38790584">next</a><span>|</span><label class="collapse" for="c-38791356">[-]</label><label class="expand" for="c-38791356">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve totally switched to the newer, dev-orientated variants for my work.<p>fd, sd, ag&#x2F;rg, fzf, bat, xh&#x2F;httpie all work how I&#x27;d expect them to and I don&#x27;t need any archaic knowledge. Plus, fish&#x27;s autocomplete does fill in blanks when I need it.<p>I&#x27;d kind of consider tmux to be my ide rather than Unix. That&#x27;s where I combine everything above (along with nvim), and it&#x27;s as integrated as I need it to be.</div><br/><div id="38791476" class="c"><input type="checkbox" id="c-38791476" checked=""/><div class="controls bullet"><span class="by">pletnes</span><span>|</span><a href="#38791169">root</a><span>|</span><a href="#38791356">parent</a><span>|</span><a href="#38790584">next</a><span>|</span><label class="collapse" for="c-38791476">[-]</label><label class="expand" for="c-38791476">[1 more]</label></div><br/><div class="children"><div class="content">Cool, didn’t know about sd before. The missing part is a more modern awk somehow.</div><br/></div></div></div></div></div></div></div></div><div id="38790584" class="c"><input type="checkbox" id="c-38790584" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#38791169">prev</a><span>|</span><a href="#38789624">next</a><span>|</span><label class="collapse" for="c-38790584">[-]</label><label class="expand" for="c-38790584">[1 more]</label></div><br/><div class="children"><div class="content">This is how Mitchell Hashimoto (HashiCorp cofounder) developments.<p>His “IDE” is Nixos + Neovim.<p><a href="https:&#x2F;&#x2F;sourcegraph.com&#x2F;blog&#x2F;dev-tool-time-mitchell-hashimoto" rel="nofollow">https:&#x2F;&#x2F;sourcegraph.com&#x2F;blog&#x2F;dev-tool-time-mitchell-hashimot...</a></div><br/></div></div><div id="38789624" class="c"><input type="checkbox" id="c-38789624" checked=""/><div class="controls bullet"><span class="by">jruohonen</span><span>|</span><a href="#38790584">prev</a><span>|</span><a href="#38790146">next</a><span>|</span><label class="collapse" for="c-38789624">[-]</label><label class="expand" for="c-38789624">[2 more]</label></div><br/><div class="children"><div class="content">Still the best IDE.</div><br/><div id="38790246" class="c"><input type="checkbox" id="c-38790246" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#38789624">parent</a><span>|</span><a href="#38790146">next</a><span>|</span><label class="collapse" for="c-38790246">[-]</label><label class="expand" for="c-38790246">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve joked that I have a disintegrated development environment.</div><br/></div></div></div></div><div id="38790146" class="c"><input type="checkbox" id="c-38790146" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#38789624">prev</a><span>|</span><label class="collapse" for="c-38790146">[-]</label><label class="expand" for="c-38790146">[8 more]</label></div><br/><div class="children"><div class="content">Unix was probably a great IDE by the standards of 1975, because literally every design decision about Unix was made based on the criterion of convenience for a 1970s programmer. Those decisions haven&#x27;t aged well: fork() sucks, lack of completion-based async I&#x2F;O sucks, ill-thought-out file, socket, and process APIs riddled with TOCTOU bugs suck, two-letter  YAFIYGI commands suck, untyped pipes suck, and don&#x27;t get me started on C or its standard library.<p>It turns out, however, that we haven&#x27;t really strayed far from the &quot;Unix as IDE&quot; approach, as in order to turn Vim or Emacs into an IDE the typical approach is to just use Unix primitives and make the editor into a sort of super-shell that orchestrates pipelines of processes  consisting of Unix command line tools. And that&#x27;s fine.<p>Time has marched on, however, and we have been the lucky recipients of not only better IDEs than Unix, but also things that are better than Unix at what Unix was thought to do well. PowerShell, for instance, is a vast improvement over Unix command-line environments with its ability to operate over typed pipelines of objects. We should be expanding our horizons beyond what 1970s programmers found convenient to implement and embrace new ways of thinking about, writing, testing, and debugging code.</div><br/><div id="38790730" class="c"><input type="checkbox" id="c-38790730" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38790146">parent</a><span>|</span><a href="#38790209">next</a><span>|</span><label class="collapse" for="c-38790730">[-]</label><label class="expand" for="c-38790730">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Those decisions haven&#x27;t aged well: fork() sucks, lack of completion-based async I&#x2F;O sucks, ill-thought-out file, socket, and process APIs riddled with TOCTOU bugs suck, two-letter YAFIYGI commands suck, untyped pipes suck, and don&#x27;t get me started on C or its standard library.<p>Of those, only<p>&gt; two-letter YAFIYGI commands suck, untyped pipes suck<p>sound like problems with unix as an IDE; most of what the article discusses is unaffected by underlying APIs.<p>I also feel like I should question whether you&#x27;re not attacking a strawman; modern unix-likes are continuations of unix, but they&#x27;re not stuck in the 70s. For example, AIUI everyone agrees that fork() has shortcomings... which is why we have vfork (and I think others?) now.</div><br/><div id="38790869" class="c"><input type="checkbox" id="c-38790869" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38790146">root</a><span>|</span><a href="#38790730">parent</a><span>|</span><a href="#38790209">next</a><span>|</span><label class="collapse" for="c-38790869">[-]</label><label class="expand" for="c-38790869">[1 more]</label></div><br/><div class="children"><div class="content">vfork is a lot worse than fork, don&#x27;t use it</div><br/></div></div></div></div><div id="38790209" class="c"><input type="checkbox" id="c-38790209" checked=""/><div class="controls bullet"><span class="by">doix</span><span>|</span><a href="#38790146">parent</a><span>|</span><a href="#38790730">prev</a><span>|</span><a href="#38790712">next</a><span>|</span><label class="collapse" for="c-38790209">[-]</label><label class="expand" for="c-38790209">[1 more]</label></div><br/><div class="children"><div class="content">I agree that PowerShell is theoretically better since it can deal with structured data.<p>But in practice, I could never get as efficient with it as I could with &quot;the Unix way&quot; (everything is a string).<p>If I was writing a &quot;production&quot; script, then it&#x27;s better. But when I&#x27;m just trying to quickly do something on the command line, the &quot;everything is a string&quot; approach is good enough.</div><br/></div></div><div id="38790712" class="c"><input type="checkbox" id="c-38790712" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#38790146">parent</a><span>|</span><a href="#38790209">prev</a><span>|</span><a href="#38790867">next</a><span>|</span><label class="collapse" for="c-38790712">[-]</label><label class="expand" for="c-38790712">[1 more]</label></div><br/><div class="children"><div class="content">&quot;We should be expanding our horizons beyond what 1970s programmers found convenient …&quot;<p>You&#x27;re right; we should be going back to the Lisp and Smalltalk machines of the 1980&#x27;s.<p>In that sense, I&#x27;ve found PowerShell to be something of a letdown. I was hoping for something that was an ergonomic abstraction over NT&#x27;s primitives (or Linux&#x27;s) and over the CLR&#x27;s primitives at the same time, in much the same way that Lisp worked on Lisp machines, but PowerShell is only frustratingly alright at both.<p>With the deprecation of the ISE, the debugging story is also something that&#x27;s pulled into question. Is the VS Code extension the place to go now?<p>I wind up spending more time in F# because the whip-it-upitude story is a little better there, especially with the Jupyter notebook support, and the choice of using the same debugging and development tools I use for the rest of my tech stack is an obvious one.</div><br/></div></div><div id="38790867" class="c"><input type="checkbox" id="c-38790867" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38790146">parent</a><span>|</span><a href="#38790712">prev</a><span>|</span><a href="#38790206">next</a><span>|</span><label class="collapse" for="c-38790867">[-]</label><label class="expand" for="c-38790867">[1 more]</label></div><br/><div class="children"><div class="content">see, that&#x27;s what i thought in 01998, but you may have noticed that google, facebook, aws, openai, github, android, ios, docker, instagram, slack, whatsapp, fastly, tesla, etc., all run on unix for some reason<p>so i guess fork and epoll and the racy unix file and socket and process apis are adequate, or anyway in some way not as fatally flawed as windows.  a lot of those successful tech things of the last 25 years do involve some java or golang or erlang<p>stack overflow runs on windows tho<p>almost everything in my list runs on linux, mostly ubuntu.  the exceptions are that ios runs on darwin and whatsapp runs on freebsd</div><br/></div></div><div id="38790206" class="c"><input type="checkbox" id="c-38790206" checked=""/><div class="controls bullet"><span class="by">calvinmorrison</span><span>|</span><a href="#38790146">parent</a><span>|</span><a href="#38790867">prev</a><span>|</span><a href="#38790300">next</a><span>|</span><label class="collapse" for="c-38790206">[-]</label><label class="expand" for="c-38790206">[1 more]</label></div><br/><div class="children"><div class="content">Expanding horizons = introducing longer pipelines of learning.<p>At this point you&#x27;ll need 10 years just to get the basics down much less be competent across the stack.</div><br/></div></div><div id="38790300" class="c"><input type="checkbox" id="c-38790300" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#38790146">parent</a><span>|</span><a href="#38790206">prev</a><span>|</span><label class="collapse" for="c-38790300">[-]</label><label class="expand" for="c-38790300">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree.<p>Also, now with an IDE, code completion is table stakes and we are moving toward LLM integration where the IDE will assist in coding.<p>The Unix pipeline model is not suitable for this as you need persistent processes and low-latency two way communication.<p>It is interesting to note that the Language Server Protocol which is the biggest innovation in terms of scaling language completion across multiple languages and editors came from Microsoft.<p>We are moving into a world where although the code is stored as text, our programming tools understand and manipulate it at a deeper level than just a sequence of bytes which is what the Unix tools do. Rename that uses the AST is much more safer and powerful than sed. Context aware search is better than grep.</div><br/></div></div></div></div></div></div></div></div></div></body></html>