<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716195673996" as="style"/><link rel="stylesheet" href="styles.css?v=1716195673996"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://meringue.readthedocs.io/en/latest/meringue_philosophy.html">Meringue Philosophy</a> <span class="domain">(<a href="https://meringue.readthedocs.io">meringue.readthedocs.io</a>)</span></div><div class="subtext"><span>Vadim_samokhin</span> | <span>9 comments</span></div><br/><div><div id="40410315" class="c"><input type="checkbox" id="c-40410315" checked=""/><div class="controls bullet"><span class="by">ben_w</span><span>|</span><a href="#40410749">next</a><span>|</span><label class="collapse" for="c-40410315">[-]</label><label class="expand" for="c-40410315">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Meringue is an object-oriented implementation of datetime functionality in php. It’s built atop the few fundamental universal abstractions, so it’s minimalistic, intuitive and extendable. At the same time, it allows carrying out complex datetime calculations due to its inherent declarative nature.<p>And there I was, expecting this to be a novel food-based metaphor about how certain kinds of philosophy are sweet and delicious, yet crumble easily under the slightest pressure.</div><br/></div></div><div id="40410749" class="c"><input type="checkbox" id="c-40410749" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#40410315">prev</a><span>|</span><a href="#40410154">next</a><span>|</span><label class="collapse" for="c-40410749">[-]</label><label class="expand" for="c-40410749">[2 more]</label></div><br/><div class="children"><div class="content">Funny, I just recently commented on a different post laying out what I think is a disagreement with the basic idea here.<p>The assertion that &quot;metaphysics fits enterprise software development discovery and implementation needs perfectly&quot; overlooks a critical distinction between philosophical inquiry and practical application. Metaphysics, which delves into the nature of reality and existence, often involves abstract categorization and the pursuit of understanding universal truths. However, enterprise software development is fundamentally a practical discipline aimed at solving specific business problems.<p>When software engineers model a domain, they are not engaging in an Aristotelian or Platonic exercise to capture the true essence of entities. Instead, they are creating representations that are useful for achieving particular business objectives. The primary goal is not to uncover ontological truths but to develop functional, efficient, and scalable solutions that meet the needs of users and stakeholders.<p>Theoretical unifications and abstractions, while intellectually stimulating, can often lead to over-engineered solutions that do not align with the practical demands of enterprise software. Software development requires pragmatism: the ability to prioritize utility and business value over philosophical purity. Abstractions in software are useful only insofar as they contribute to the effectiveness and maintainability of the system within the context of its intended use.<p>I&#x27;m not suggesting there aren&#x27;t <i>some</i> situations where applying metaphysical thinking can be helpful. However, using this approach as a general, top-down strategy doesn&#x27;t make much sense. Software engineering, by definition, is a practical discipline, involving concerns and objectives that differ fundamentally from those of metaphysics.</div><br/></div></div><div id="40410154" class="c"><input type="checkbox" id="c-40410154" checked=""/><div class="controls bullet"><span class="by">eynsham</span><span>|</span><a href="#40410749">prev</a><span>|</span><a href="#40411856">next</a><span>|</span><label class="collapse" for="c-40410154">[-]</label><label class="expand" for="c-40410154">[1 more]</label></div><br/><div class="children"><div class="content">1. Some philosophers think many metaphysical debates meaningless. Consider the debate about ordinary objects such as chairs. These typically are the result of composing more fundamental entities (such as those of the Standard Model). Mereological nihilists say: there are no ordinary objects (such as chairs). Others disagree. &#x2F;Relativists&#x2F; about metaphysics say that these disputes are merely verbal. There is no fact of the matter to discover and expound. Whether or not there is such a thing as a chair is simply a matter of convention.<p>2. I disagree. But I think one point is right. Relativists point out that it is often (or maybe even always) possible to translate statements between the languages promoted by different metaphysical schools. For example, nihilists translate ‘the chair is on the ground’ to ‘some particles arranged chairwise are such that the particles at the bottom touch the ground’ (or something similar). For this reason, they claim not much hinges on whether nihilists are actually right.<p>3. Despite my antirelativist metaphysical inclinations, I think it is possible to translate statements in the language given by the ‘same ontology that constitutes reality’ systematically into languages that reflect different metaphysical views.<p>4. Some of those erroneous metaphysical views may correspond to how we naturally tend to think about certain areas, or the needs of computation (e.g. in being better complexity-wise). For this reason I am sceptical about the (admittedly very interesting) technique advanced in this essay, since it seems to assume that no conflict between these demands will arise.<p>5. A final worry is that metaphysics does not really speak with one voice. Many philosophers are quite sympathetic to the sort of picture outlined at the start of the essay, but e.g. mereological nihilism is surprisingly popular! If resolving these questions definitively is too much even for philosophers, those applying their conclusions will have some trouble too.</div><br/></div></div><div id="40411856" class="c"><input type="checkbox" id="c-40411856" checked=""/><div class="controls bullet"><span class="by">kdazzle</span><span>|</span><a href="#40410154">prev</a><span>|</span><a href="#40409682">next</a><span>|</span><label class="collapse" for="c-40411856">[-]</label><label class="expand" for="c-40411856">[1 more]</label></div><br/><div class="children"><div class="content">Enterprise software is just a shadow of the ideal software</div><br/></div></div><div id="40409682" class="c"><input type="checkbox" id="c-40409682" checked=""/><div class="controls bullet"><span class="by">uoaei</span><span>|</span><a href="#40411856">prev</a><span>|</span><label class="collapse" for="c-40409682">[-]</label><label class="expand" for="c-40409682">[2 more]</label></div><br/><div class="children"><div class="content">I appreciate linked data &#x2F; the semantic web and its domain model-forward approach, labeled &quot;ontologies&quot;. Organizing relationships between objects and actors contextualizes them and forces you to pursue parsimony. It&#x27;s nice to see this philosophy appreciated elsewhere.<p>My projects usually start with a &quot;goblin mode repo&quot; to explore the domain, its possible representation in code, and settling on a suitable domain model for the problem in question. It&#x27;s explicitly a place for prototyping, experimentation, and breaking changes galore. Naturally this technique doesn&#x27;t extend much further than a small, tight-knit team, but once you find something that works you can formalize it in a new repo and share access with a wider group. If you did it right, those others will have no trouble comprehending the domain from the organization of code structures you&#x27;ve provided and extending that code in ergonomic ways to add features.</div><br/><div id="40413483" class="c"><input type="checkbox" id="c-40413483" checked=""/><div class="controls bullet"><span class="by">p9fus</span><span>|</span><a href="#40409682">parent</a><span>|</span><label class="collapse" for="c-40413483">[-]</label><label class="expand" for="c-40413483">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My projects usually start with a &quot;goblin mode repo&quot;<p>Haha, I like the name :)</div><br/></div></div></div></div></div></div></div></div></div></body></html>