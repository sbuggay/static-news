<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710061251457" as="style"/><link rel="stylesheet" href="styles.css?v=1710061251457"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://thunderseethe.dev/posts/bet-on-cbpv/">I&#x27;m Betting on Call-by-Push-Value</a> <span class="domain">(<a href="https://thunderseethe.dev">thunderseethe.dev</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>49 comments</span></div><br/><div><div id="39655870" class="c"><input type="checkbox" id="c-39655870" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#39655535">next</a><span>|</span><label class="collapse" for="c-39655870">[-]</label><label class="expand" for="c-39655870">[3 more]</label></div><br/><div class="children"><div class="content">I got really excited about call-by-push-value about 15 years ago, when I first encountered it, but at this point I think it is overhyped, particularly the presentation of &quot;values&quot; and &quot;computations&quot; as duals. For example see <a href="http:&#x2F;&#x2F;www.itu.dk&#x2F;people&#x2F;mogel&#x2F;papers&#x2F;eec.pdf" rel="nofollow">http:&#x2F;&#x2F;www.itu.dk&#x2F;people&#x2F;mogel&#x2F;papers&#x2F;eec.pdf</a>, it is a CBPV-style lambda calculus except computations are a subset of values and there is no duality. Similarly in Levy&#x27;s book, he discusses &quot;complex values&quot; like 1+2 which allow pure computations to happen inside the &quot;value&quot; type, more evidence that they are not duals at all.<p>If you squint at CBPV, there is exactly one primitive that sequences computation, `M to x. N`. In Haskell this is just the monadic bind `M &gt;&gt;= \x -&gt; N` or `do { x &lt;- M; N}`. If I had to bet, I would place my bet on monads, not CBPV.</div><br/><div id="39656269" class="c"><input type="checkbox" id="c-39656269" checked=""/><div class="controls bullet"><span class="by">compressedgas</span><span>|</span><a href="#39655870">parent</a><span>|</span><a href="#39655535">next</a><span>|</span><label class="collapse" for="c-39656269">[-]</label><label class="expand" for="c-39656269">[2 more]</label></div><br/><div class="children"><div class="content">So what they have made would be a more complicated version of <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;A-normal_form" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;A-normal_form</a></div><br/><div id="39656555" class="c"><input type="checkbox" id="c-39656555" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#39655870">root</a><span>|</span><a href="#39656269">parent</a><span>|</span><a href="#39655535">next</a><span>|</span><label class="collapse" for="c-39656555">[-]</label><label class="expand" for="c-39656555">[1 more]</label></div><br/><div class="children"><div class="content">I hadn&#x27;t thought about it that way, but it makes sense. I would say the main difference is that ANF is type-preserving, whereas CBPV introduces new types. But they are similar in that they are IRs with accompanying translations from standard lambda calculus. You can see the translations of CBV&#x2F;CBN on page 11 of <a href="https:&#x2F;&#x2F;www.cs.bham.ac.uk&#x2F;~pbl&#x2F;papers&#x2F;tlca99.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.bham.ac.uk&#x2F;~pbl&#x2F;papers&#x2F;tlca99.pdf</a></div><br/></div></div></div></div></div></div><div id="39655535" class="c"><input type="checkbox" id="c-39655535" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#39655870">prev</a><span>|</span><a href="#39657005">next</a><span>|</span><label class="collapse" for="c-39655535">[-]</label><label class="expand" for="c-39655535">[12 more]</label></div><br/><div class="children"><div class="content">This made me think of Kernel, a programming language of the Lisp family where the main primitive is vau rather than lambda, defining a fexpr rather than a function.<p>Juste like lambdas, fexprs are lexically binded closures. The difference is that a fexpr arguments are not evaluated before it&#x27;s called, instead, the arguments <i>syntax</i> is passed to the fexpr (so it&#x27;s not call-by-name either, more like a macro), except that the fexpr also receives the dynamic environment (the one from the call site) so that it can eval its arguments in this context if it wants to.<p>This makes fexpr a kind of all powerful form that can do both what macros and functions can do. Even primitives like lambda or quote can be written as fexprs. Quite fascinating.<p>See <a href="https:&#x2F;&#x2F;web.cs.wpi.edu&#x2F;~jshutt&#x2F;kernel.html" rel="nofollow">https:&#x2F;&#x2F;web.cs.wpi.edu&#x2F;~jshutt&#x2F;kernel.html</a> about Kernel :).</div><br/><div id="39657302" class="c"><input type="checkbox" id="c-39657302" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#39655535">parent</a><span>|</span><a href="#39655590">next</a><span>|</span><label class="collapse" for="c-39657302">[-]</label><label class="expand" for="c-39657302">[2 more]</label></div><br/><div class="children"><div class="content">&gt;The difference is that a fexpr arguments are not evaluated before it&#x27;s called<p>What&#x27;s funny is that the actual lambda calculus allows multiple reduction strategies, including lazy evaluation. So I guess the only reason to introduce this distinction is to facilitate impure code, which cares about the difference.</div><br/><div id="39657623" class="c"><input type="checkbox" id="c-39657623" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#39655535">root</a><span>|</span><a href="#39657302">parent</a><span>|</span><a href="#39655590">next</a><span>|</span><label class="collapse" for="c-39657623">[-]</label><label class="expand" for="c-39657623">[1 more]</label></div><br/><div class="children"><div class="content">I mean, there are observable differences between the two. An obvious one is to have an infinite recursive function application as a parameter to a function. Depending on whether CBV or CBN is used, you either get non-halting code, or a meaningful result.</div><br/></div></div></div></div><div id="39655590" class="c"><input type="checkbox" id="c-39655590" checked=""/><div class="controls bullet"><span class="by">dmux</span><span>|</span><a href="#39655535">parent</a><span>|</span><a href="#39657302">prev</a><span>|</span><a href="#39655648">next</a><span>|</span><label class="collapse" for="c-39655590">[-]</label><label class="expand" for="c-39655590">[8 more]</label></div><br/><div class="children"><div class="content">I’m not familiar with the theoretical aspects, but what you’re describing reminds me of Tcl: arguments to procedures can be passed unevaluated (quoted, using Tcl terms) and the procedure itself can alter the caller’s environment via uplevel.</div><br/><div id="39655670" class="c"><input type="checkbox" id="c-39655670" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#39655535">root</a><span>|</span><a href="#39655590">parent</a><span>|</span><a href="#39657077">next</a><span>|</span><label class="collapse" for="c-39655670">[-]</label><label class="expand" for="c-39655670">[6 more]</label></div><br/><div class="children"><div class="content">It’s also extremely similar to R and Rebol.<p>(In fact, R isn’t just ‘extremely similar’: it <i>does</i> use fexprs, though without mentioning the term.)</div><br/><div id="39656289" class="c"><input type="checkbox" id="c-39656289" checked=""/><div class="controls bullet"><span class="by">Tyr42</span><span>|</span><a href="#39655535">root</a><span>|</span><a href="#39655670">parent</a><span>|</span><a href="#39657077">next</a><span>|</span><label class="collapse" for="c-39656289">[-]</label><label class="expand" for="c-39656289">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s what let&#x27;s the tidy data tools take arguments like .x where x is a column name, not a local varia le that&#x27;s in scope.</div><br/><div id="39657533" class="c"><input type="checkbox" id="c-39657533" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#39655535">root</a><span>|</span><a href="#39656289">parent</a><span>|</span><a href="#39656394">next</a><span>|</span><label class="collapse" for="c-39657533">[-]</label><label class="expand" for="c-39657533">[1 more]</label></div><br/><div class="children"><div class="content">“Wow this is fun and amazingly useful”<p>8 months later.<p>“I regret this decision, and a thousand curses on anyone who chooses to use this in a code base I have to work on”<p>I’ve been at the receiving end of this particular “feature” and it was <i>awful</i>. Your logic is splayed all over the place, and you’ll often get <i>mystery</i> errors, because someone else’s code makes some undocumented, un-typed assumption about the availability of some magically named variables. This is not a feature, this is bugs and misery in disguise.</div><br/></div></div><div id="39656394" class="c"><input type="checkbox" id="c-39656394" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39655535">root</a><span>|</span><a href="#39656289">parent</a><span>|</span><a href="#39657533">prev</a><span>|</span><a href="#39657077">next</a><span>|</span><label class="collapse" for="c-39656394">[-]</label><label class="expand" for="c-39656394">[3 more]</label></div><br/><div class="children"><div class="content">R is even more wild because you can access the entire definition of a function from the function object itself. You can literally make a new function that&#x27;s a copy of an existing function with some lines of code injected.</div><br/><div id="39656539" class="c"><input type="checkbox" id="c-39656539" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#39655535">root</a><span>|</span><a href="#39656394">parent</a><span>|</span><a href="#39656754">next</a><span>|</span><label class="collapse" for="c-39656539">[-]</label><label class="expand" for="c-39656539">[1 more]</label></div><br/><div class="children"><div class="content">In Tcl, [info body …].<p><a href="https:&#x2F;&#x2F;www.tcl.tk&#x2F;man&#x2F;tcl&#x2F;TclCmd&#x2F;info.htm#M6" rel="nofollow">https:&#x2F;&#x2F;www.tcl.tk&#x2F;man&#x2F;tcl&#x2F;TclCmd&#x2F;info.htm#M6</a></div><br/></div></div><div id="39656754" class="c"><input type="checkbox" id="c-39656754" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#39655535">root</a><span>|</span><a href="#39656394">parent</a><span>|</span><a href="#39656539">prev</a><span>|</span><a href="#39657077">next</a><span>|</span><label class="collapse" for="c-39656754">[-]</label><label class="expand" for="c-39656754">[1 more]</label></div><br/><div class="children"><div class="content">Powershell lets you do this too.</div><br/></div></div></div></div></div></div></div></div><div id="39657077" class="c"><input type="checkbox" id="c-39657077" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#39655535">root</a><span>|</span><a href="#39655590">parent</a><span>|</span><a href="#39655670">prev</a><span>|</span><a href="#39655648">next</a><span>|</span><label class="collapse" for="c-39657077">[-]</label><label class="expand" for="c-39657077">[1 more]</label></div><br/><div class="children"><div class="content">In Kernel, the environments are completely reified--they exist as a thing and you can pass them around.<p>However, if you don&#x27;t get an environment passed in, you <i>can&#x27;t get access to it</i>.  In addition, the environments in many ways are append-only, you can change what you see as &quot;car&quot; but you can&#x27;t change what previous callers see as &quot;car&quot; unless you get a handle to their environment but that won&#x27;t change previous calls.<p>It&#x27;s really quite tricky.  It&#x27;s doubly tricky because there are some environment mutations that you need to do as the system that you need to prevent as the user once everything is bootstrapped.<p>I really wish Shutt had implemented a version in C&#x2F;C++&#x2F;Ada&#x2F;anything systems language and not just a metacircular scheme implementation.  The metacircularity obscures the management of the environments that is key to the implementation.  It also obscures just how much garbage Kernel cons-es up in order to maintain all of the necessary housekeeping to pass all this stuff around.<p>Alas, he is no longer with us to request anything of.  RIP.</div><br/></div></div></div></div></div></div><div id="39657005" class="c"><input type="checkbox" id="c-39657005" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39655535">prev</a><span>|</span><a href="#39657404">next</a><span>|</span><label class="collapse" for="c-39657005">[-]</label><label class="expand" for="c-39657005">[1 more]</label></div><br/><div class="children"><div class="content">Who else looked at the title and thought &quot;isn&#x27;t that __cdecl?&quot; and was expecting an article about calling conventions, but got something related yet completely different?<p>For an article about efficiency, there seems to be a noticeable absence of actual instruction sequences for comparison.</div><br/></div></div><div id="39657404" class="c"><input type="checkbox" id="c-39657404" checked=""/><div class="controls bullet"><span class="by">aranchelk</span><span>|</span><a href="#39657005">prev</a><span>|</span><a href="#39655126">next</a><span>|</span><label class="collapse" for="c-39657404">[-]</label><label class="expand" for="c-39657404">[1 more]</label></div><br/><div class="children"><div class="content">Personally I like how PureScript has done it, as essentially an eager Haskell, they just implemented laziness in a library, you loose some of the elegance of laziness by default, but most of the time I want eager expressions anyway, and when I don’t it’s clear what I’m doing and easy enough to make stuff lazy.<p><a href="https:&#x2F;&#x2F;pursuit.purescript.org&#x2F;packages&#x2F;purescript-lazy&#x2F;3.0.0&#x2F;docs&#x2F;Data.Lazy" rel="nofollow">https:&#x2F;&#x2F;pursuit.purescript.org&#x2F;packages&#x2F;purescript-lazy&#x2F;3.0....</a></div><br/></div></div><div id="39655126" class="c"><input type="checkbox" id="c-39655126" checked=""/><div class="controls bullet"><span class="by">burakemir</span><span>|</span><a href="#39657404">prev</a><span>|</span><a href="#39656106">next</a><span>|</span><label class="collapse" for="c-39655126">[-]</label><label class="expand" for="c-39655126">[2 more]</label></div><br/><div class="children"><div class="content">It is nice to see CBPV on HN. It is a calculus that deal with a fundamental choice in PL of how to approach evaluation. For a different take, here is the first part of a mini series of posts on CBPV that aims at working out the connection to logic (&quot;polarised natural deduction&quot;): <a href="https:&#x2F;&#x2F;burakemir.ch&#x2F;post&#x2F;cbpv-pt1-small-steps&#x2F;" rel="nofollow">https:&#x2F;&#x2F;burakemir.ch&#x2F;post&#x2F;cbpv-pt1-small-steps&#x2F;</a></div><br/><div id="39655367" class="c"><input type="checkbox" id="c-39655367" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39655126">parent</a><span>|</span><a href="#39656106">next</a><span>|</span><label class="collapse" for="c-39655367">[-]</label><label class="expand" for="c-39655367">[1 more]</label></div><br/><div class="children"><div class="content">Interesting to see (in the followup posts) that the structure of CBPV seems to lead to &quot;lazy&quot; records as a natural choice, contrasting with &quot;strict&quot; primitive values and sum types, and &quot;lazy&quot; function types.  The connection to polarity and focusing is also worthy of note.</div><br/></div></div></div></div><div id="39656106" class="c"><input type="checkbox" id="c-39656106" checked=""/><div class="controls bullet"><span class="by">gatlin</span><span>|</span><a href="#39655126">prev</a><span>|</span><a href="#39656601">next</a><span>|</span><label class="collapse" for="c-39656106">[-]</label><label class="expand" for="c-39656106">[1 more]</label></div><br/><div class="children"><div class="content">Shameless self promotion: I made a toy CBPV language in TypeScript. It&#x27;s purely for pedagogy. The idea is that the implementation is essentially an executable small step semantics, and the interop between language and machine is real purdy.<p><a href="https:&#x2F;&#x2F;niltag.net&#x2F;code&#x2F;precursor" rel="nofollow">https:&#x2F;&#x2F;niltag.net&#x2F;code&#x2F;precursor</a></div><br/></div></div><div id="39656601" class="c"><input type="checkbox" id="c-39656601" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#39656106">prev</a><span>|</span><a href="#39654833">next</a><span>|</span><label class="collapse" for="c-39656601">[-]</label><label class="expand" for="c-39656601">[1 more]</label></div><br/><div class="children"><div class="content">So in practice using a parameter could be surprisingly very expensive?  Are you supposed to thunk all your parameters before grabbing a resource?<p>It seems like it would end up quite cumbersome.  C# has object properties that can be values or functions.  Etiquette dictates you don&#x27;t query a database in an object property but I&#x27;ve seen it happen.  I&#x27;m not even sure what the etiquette here would be.  The entire point is to lazily evaluate slow things, right?<p>But I guess its all just for IRs and the idea is a compiler is handling it all anyway?</div><br/></div></div><div id="39654833" class="c"><input type="checkbox" id="c-39654833" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#39656601">prev</a><span>|</span><a href="#39655631">next</a><span>|</span><label class="collapse" for="c-39654833">[-]</label><label class="expand" for="c-39654833">[1 more]</label></div><br/><div class="children"><div class="content">I really want to like this more, but need a better notation</div><br/></div></div><div id="39655631" class="c"><input type="checkbox" id="c-39655631" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39654833">prev</a><span>|</span><a href="#39655681">next</a><span>|</span><label class="collapse" for="c-39655631">[-]</label><label class="expand" for="c-39655631">[6 more]</label></div><br/><div class="children"><div class="content">I’m wondering what’s gained over writing your thunks as zero-argument functions (etc) in an eager language.</div><br/><div id="39655644" class="c"><input type="checkbox" id="c-39655644" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#39655631">parent</a><span>|</span><a href="#39655749">next</a><span>|</span><label class="collapse" for="c-39655644">[-]</label><label class="expand" for="c-39655644">[3 more]</label></div><br/><div class="children"><div class="content">If I understand correctly, here it is transparent. In an eager language a function needs to know whether it is given a value or a thunk, but here it can be both interchangeably (the thunk only need to have a type that says it returns a value of the same type as what could have been passed directly).</div><br/><div id="39655903" class="c"><input type="checkbox" id="c-39655903" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#39655631">root</a><span>|</span><a href="#39655644">parent</a><span>|</span><a href="#39656563">next</a><span>|</span><label class="collapse" for="c-39655903">[-]</label><label class="expand" for="c-39655903">[1 more]</label></div><br/><div class="children"><div class="content">In theory, yes i would agree that they might be a different somewhere. But it&#x27;s not clear (at least to me that) is this distinction maters in practice.<p>I think the main point here would that a thunk is also a value. And most type system can already express &quot;a computation which return Type X&quot; by a value of type &quot;() -&gt; X&quot;. Adding side effect annotation, it seems to be that a pure function of type &quot;() -&gt; X&quot; gives you very close to the same semantic.<p>It&#x27;s also unclear to me that one should want to allow both value and computation producing values to be used interchangeably. If the goal of CBPV is about  better performance, then being able to mix and match both &quot;kind&quot; of value is probably not wise (at least without good compiler error messages), same as mixing type of values would break a type system.</div><br/></div></div><div id="39656563" class="c"><input type="checkbox" id="c-39656563" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#39655631">root</a><span>|</span><a href="#39655644">parent</a><span>|</span><a href="#39655903">prev</a><span>|</span><a href="#39655749">next</a><span>|</span><label class="collapse" for="c-39656563">[-]</label><label class="expand" for="c-39656563">[1 more]</label></div><br/><div class="children"><div class="content">Is it transparent?  It seems like the goal is to be deliberate through explicit calls to thunk().  I guess you mean that a function parameter can be both a value or lambda.</div><br/></div></div></div></div><div id="39655749" class="c"><input type="checkbox" id="c-39655749" checked=""/><div class="controls bullet"><span class="by">tel</span><span>|</span><a href="#39655631">parent</a><span>|</span><a href="#39655644">prev</a><span>|</span><a href="#39656018">next</a><span>|</span><label class="collapse" for="c-39655749">[-]</label><label class="expand" for="c-39655749">[1 more]</label></div><br/><div class="children"><div class="content">There are a few differences, depending on how you evolve from the CBPV core, but basically other types may be eager or lazy. Functions can be eager (and thus statically know to represent an eager call tree) and sum types can be lazy (deferring choice). These distinctions are all available at the type level.<p>To have thunking only arise from single unit-arg functions kind of depletes the logic of useful structure. But it’s not wrong to see it as an approximation.</div><br/></div></div><div id="39656018" class="c"><input type="checkbox" id="c-39656018" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#39655631">parent</a><span>|</span><a href="#39655749">prev</a><span>|</span><a href="#39655681">next</a><span>|</span><label class="collapse" for="c-39656018">[-]</label><label class="expand" for="c-39656018">[1 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t thunks caching the result?</div><br/></div></div></div></div><div id="39655681" class="c"><input type="checkbox" id="c-39655681" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#39655631">prev</a><span>|</span><a href="#39656435">next</a><span>|</span><label class="collapse" for="c-39655681">[-]</label><label class="expand" for="c-39655681">[3 more]</label></div><br/><div class="children"><div class="content">Not sure I see a difference between thunks and futures.</div><br/><div id="39655817" class="c"><input type="checkbox" id="c-39655817" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#39655681">parent</a><span>|</span><a href="#39656435">next</a><span>|</span><label class="collapse" for="c-39655817">[-]</label><label class="expand" for="c-39655817">[2 more]</label></div><br/><div class="children"><div class="content">Thunk is a general concept of a small function which is used only to adapt the call or prepare&#x2F;modify it in some way and then redirect to the proper function. Things like promises, futures, closures, wrappers, stubs or implementations of the concept of virtual function tables in some OO languages (like C++) are just special use cases of thunks (thunks are often used to implement them).<p>Source: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;22548372&#x2F;309483" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;22548372&#x2F;309483</a></div><br/><div id="39655860" class="c"><input type="checkbox" id="c-39655860" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#39655681">root</a><span>|</span><a href="#39655817">parent</a><span>|</span><a href="#39656435">next</a><span>|</span><label class="collapse" for="c-39655860">[-]</label><label class="expand" for="c-39655860">[1 more]</label></div><br/><div class="children"><div class="content">The definition that the source is using seems wrong to me. Promise,futures and closures are not used to redirect to anything or wrapper around something else... They are proper compationational object with they own behaviors...</div><br/></div></div></div></div></div></div><div id="39656435" class="c"><input type="checkbox" id="c-39656435" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39655681">prev</a><span>|</span><a href="#39654999">next</a><span>|</span><label class="collapse" for="c-39656435">[-]</label><label class="expand" for="c-39656435">[3 more]</label></div><br/><div class="children"><div class="content">So you abstract a function argument behind an interface:<p>.get() will evaluate the argument when the specific value is needed. It might be a literal wrapper.<p>.set() will be called when the argument value is set. It either does nothing in the case of a wrapper that is call-by-value, or back-persists the mutation if the set() actually does something.<p>I get that doesn&#x27;t have the sexy lazy eval &#x2F; late binding of functional langs, but in the imperative model, is that the basic idea?<p>------<p>as an aside, I&#x27;ve found that in my (I&#x27;m a groovy programmer preferentially) scripts, where I&#x27;m doing bash-ish things with a lot of CLI execution, I do things like this:<p>&quot;cd somedir; ls -la&quot;.
    with { &lt;look for and parse out a file and its date&gt;} 
&quot;df -k&quot;.
    with { &lt;parse out some device we are interested in&gt; }<p>and I find it very nice to structure the readability, since the meat of these scripts is the command: I define the data, then &quot;push&quot; it to the processing I want to do to it.<p>Is there any programming language name for this sort of &quot;value first&quot; model? I find it also flows well for chaining operations, whereas something like:<p>saveResults(parseOutput(runCommand(&quot;df -k&quot;)))<p>forces you to mentally pop the stack. As you read from right to left you have to push the operations in your mental model until you get to the core of what you&#x27;re working on, while<p>&quot;df -k&quot;.
   with{ runCommand(it) }.
   with{ parseOutput(it) }.
   with{ saveResult(it) }<p>is more like the natural order</div><br/><div id="39657661" class="c"><input type="checkbox" id="c-39657661" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#39656435">parent</a><span>|</span><a href="#39657247">next</a><span>|</span><label class="collapse" for="c-39657661">[-]</label><label class="expand" for="c-39657661">[1 more]</label></div><br/><div class="children"><div class="content">I think what you are getting at is usually called piping. Some languages have it inbuilt (usually as a |&gt; operator).</div><br/></div></div><div id="39657247" class="c"><input type="checkbox" id="c-39657247" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39656435">parent</a><span>|</span><a href="#39657661">prev</a><span>|</span><a href="#39654999">next</a><span>|</span><label class="collapse" for="c-39657247">[-]</label><label class="expand" for="c-39657247">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know groovy, but it looks a bit like method chaining, except using an external object&#x2F;method &quot;with&quot; to chain standalone functions?</div><br/></div></div></div></div><div id="39654999" class="c"><input type="checkbox" id="c-39654999" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#39656435">prev</a><span>|</span><a href="#39654503">next</a><span>|</span><label class="collapse" for="c-39654999">[-]</label><label class="expand" for="c-39654999">[12 more]</label></div><br/><div class="children"><div class="content">Can someone TLDR this? It&#x27;s pretty thick, and I can&#x27;t help but think this is a solved problem with the ability to pass functions as arguments. What&#x27;s the new insight here?</div><br/><div id="39655148" class="c"><input type="checkbox" id="c-39655148" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39654999">parent</a><span>|</span><a href="#39655171">next</a><span>|</span><label class="collapse" for="c-39655148">[-]</label><label class="expand" for="c-39655148">[3 more]</label></div><br/><div class="children"><div class="content">I can’t. I think it would have been nice if the article defined the terminology it used to describe its toy languages.<p>But it really seemed like it was describing a language like C++ or Rust where a “computation” is a value that happens to be a callable function (std::function&lt;int ()&gt; or Fn() -&gt; int, for example).  A thunk is a value of callable (computable? is this really different?) type, and Return is the magic operation that wraps a value into a trivial closure, like:<p><pre><code>    [val]() { return val; }
</code></pre>
in C++.<p>Maybe there’s more to it than that.</div><br/><div id="39655400" class="c"><input type="checkbox" id="c-39655400" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39654999">root</a><span>|</span><a href="#39655148">parent</a><span>|</span><a href="#39655171">next</a><span>|</span><label class="collapse" for="c-39655400">[-]</label><label class="expand" for="c-39655400">[2 more]</label></div><br/><div class="children"><div class="content">It feels like half the text is dealing with arity confusion that only comes up because of a particular way of implementing functions.<p>Because I agree, if you take a statically typed call-by-value language and &quot;introduce little spurts of lazy evaluation&quot; then don&#x27;t you get the same flexibility?  And you&#x27;ll also know the arity at all times.<p>There&#x27;s something in the syntax I don&#x27;t understand in the middle about unifying things, but then it later says you have to explicitly use &quot;Return&quot; on thunks in records to evaluate them, which sounds like the same thing a CBV language does.<p>Are there other benefits I&#x27;m not understanding?<p>Does the unification apply only to function parameters?</div><br/><div id="39656664" class="c"><input type="checkbox" id="c-39656664" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39654999">root</a><span>|</span><a href="#39655400">parent</a><span>|</span><a href="#39655171">next</a><span>|</span><label class="collapse" for="c-39656664">[-]</label><label class="expand" for="c-39656664">[1 more]</label></div><br/><div class="children"><div class="content">I found it almost impossible to understand.  The syntax used for their examples was lisp-like, and the function arity seems unambiguous.  There is no implicit currying in lisp as far as I know.  Extra-confusingly, the definitions at the start were in a syntax resembling Haskell, but I think it has multiple mistakes.</div><br/></div></div></div></div></div></div><div id="39655171" class="c"><input type="checkbox" id="c-39655171" checked=""/><div class="controls bullet"><span class="by">crq-yml</span><span>|</span><a href="#39654999">parent</a><span>|</span><a href="#39655148">prev</a><span>|</span><a href="#39655408">next</a><span>|</span><label class="collapse" for="c-39655171">[-]</label><label class="expand" for="c-39655171">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re in eager evaluation land, everything evaluates as you come to it, so you can handle all arguments at runtime by using a stack and no problem is felt. Once we say, &quot;actually we don&#x27;t evaluate until it&#x27;s used&quot; ambiguity arises.<p>So the context of this is to solve a problem-in-practice with arguments in a lazy evaluation environment, which is that you don&#x27;t know how many arguments you need to supply without doing the evaluation.</div><br/><div id="39655819" class="c"><input type="checkbox" id="c-39655819" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39654999">root</a><span>|</span><a href="#39655171">parent</a><span>|</span><a href="#39655265">next</a><span>|</span><label class="collapse" for="c-39655819">[-]</label><label class="expand" for="c-39655819">[1 more]</label></div><br/><div class="children"><div class="content">I’m very far from an expert in these styles of programming languages, but I’m pretty sure I’m missing something, and it’s not well explained in the OP.<p>The OP uses a lisp-y syntax, fully parenthesized, for its code examples. But function arity isn’t so much an issue in these languages — you can infer it from the parentheses, and there’s no implicit currying. (The OP uses a Haskell-like syntax for its definitions, but I <i>think</i> it contains multiple mistakes, making it very hard to understand.)<p>A language with implicit currying <i>and</i> eager evaluation specifically of function arguments just seems overcomplicated to me.  It sounds like a stack machine in which you pop an element off the stack, evaluate it enough to determine its arity, then pop that many more elements, evaluate <i>them</i>, and then apply the function.  This sounds unpleasantly dynamic and quite hard to implement efficiently.<p>Am I missing something here?</div><br/></div></div><div id="39655265" class="c"><input type="checkbox" id="c-39655265" checked=""/><div class="controls bullet"><span class="by">analognoise</span><span>|</span><a href="#39654999">root</a><span>|</span><a href="#39655171">parent</a><span>|</span><a href="#39655819">prev</a><span>|</span><a href="#39655408">next</a><span>|</span><label class="collapse" for="c-39655265">[-]</label><label class="expand" for="c-39655265">[2 more]</label></div><br/><div class="children"><div class="content">Is that what they mean by “calculating the arity”?</div><br/><div id="39655326" class="c"><input type="checkbox" id="c-39655326" checked=""/><div class="controls bullet"><span class="by">crq-yml</span><span>|</span><a href="#39654999">root</a><span>|</span><a href="#39655265">parent</a><span>|</span><a href="#39655408">next</a><span>|</span><label class="collapse" for="c-39655326">[-]</label><label class="expand" for="c-39655326">[1 more]</label></div><br/><div class="children"><div class="content">Yes, arity is &quot;number of arguments&quot;. I don&#x27;t have expertise in lazy evaluation myself, I&#x27;ve just been exposed to enough of it to explain the motivations.</div><br/></div></div></div></div></div></div><div id="39655408" class="c"><input type="checkbox" id="c-39655408" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39654999">parent</a><span>|</span><a href="#39655171">prev</a><span>|</span><a href="#39655029">next</a><span>|</span><label class="collapse" for="c-39655408">[-]</label><label class="expand" for="c-39655408">[3 more]</label></div><br/><div class="children"><div class="content">Imagine if functions were polymorphic over the ability to pass in a function as an argument. So both f(1) and f(() =&gt; 1) would be valid for a function that takes a number. It would also apply to variables and such too. So &quot;const a = () =&gt; 1; const b = a + a;&quot; would be possible to do.</div><br/><div id="39656883" class="c"><input type="checkbox" id="c-39656883" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39654999">root</a><span>|</span><a href="#39655408">parent</a><span>|</span><a href="#39655505">next</a><span>|</span><label class="collapse" for="c-39656883">[-]</label><label class="expand" for="c-39656883">[1 more]</label></div><br/><div class="children"><div class="content">Ahh k.  So like Rebol and Red have worked for decades:<p><pre><code>  &gt;&gt; F: func [A][print type? :A   print join &quot;Arg: &quot; A]
  &gt;&gt; F &quot;Foo&quot;                                           
  string
  Arg: Foo
  &gt;&gt; F func [][return &quot;Bar&quot;]                           
  function
  Arg: Bar
</code></pre>
I really got spoiled learning Rebol as my first language, I&#x27;d already internalized a ton of concepts long before they were introduced during school and college.  Higher-order functions were the first time I really realized it, I guess here&#x27;s another to add to the pile.<p>Even knowing this though, that post really is really obtuse.  Definitely could have been better written.<p>Basically in these languages, functions don&#x27;t have a special syntax to be called, like F(), they just get called when used.  So usage of a no-argument function is identical to a variable, and what happens depends on its datatype (function, string, whatever).  The special :A syntax is to get the value without evaluating it if it is a function.</div><br/></div></div><div id="39655505" class="c"><input type="checkbox" id="c-39655505" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#39654999">root</a><span>|</span><a href="#39655408">parent</a><span>|</span><a href="#39656883">prev</a><span>|</span><a href="#39655029">next</a><span>|</span><label class="collapse" for="c-39655505">[-]</label><label class="expand" for="c-39655505">[1 more]</label></div><br/><div class="children"><div class="content">This is a good explanation. So effectively it&#x27;s making the lazy&#x2F;eager distinction controlled by the caller and not the callee.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>