<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729933251992" as="style"/><link rel="stylesheet" href="styles.css?v=1729933251992"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2311.11793">Universal optimality of Dijkstra via beyond-worst-case heaps</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>foweltschmerz</span> | <span>39 comments</span></div><br/><div><div id="41949498" class="c"><input type="checkbox" id="c-41949498" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41948670">next</a><span>|</span><label class="collapse" for="c-41949498">[-]</label><label class="expand" for="c-41949498">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve gone down a bit of a rabbit hole on path finding in the last week or two (most recently, this isn&#x27;t the first time). When you have some knowledge of the topology of the graph you can use different techniques to do better than djikstra&#x27;s.<p>Of course, if you have lots of time and space and a completely static graph, you can run all pairs shortest paths and simply store all the results for O(1) path lookup, but there are intermediates for varying types of graphs. This stack exchange article is a good overview: <a href="https:&#x2F;&#x2F;cstheory.stackexchange.com&#x2F;questions&#x2F;11855&#x2F;how-do-the-state-of-the-art-pathfinding-algorithms-for-changing-graphs-d-d-l" rel="nofollow">https:&#x2F;&#x2F;cstheory.stackexchange.com&#x2F;questions&#x2F;11855&#x2F;how-do-th...</a>.<p>I&#x27;ve been wondering about how well D* lite would perform in practice with a somewhat varying graph. I read some suggestions that if the graph is changing even a bit on occasion, then it will mostly degrade to A*, since many changed paths would need to be re-evaluated.<p>In the context of games, I&#x27;ve also been thinking about a technique called true distance heurustics (TDH), where you essentially precompute the distances between some fixed set of nodes, and then use those as a part of the heurustic for A* (or D* lite in this case), but it seems like updating these TDH in the case of a changing graph might introduce just as much overhead as not having them in the first place. It might be an interesting trade off though, if you have some &quot;lines&quot; (e.g., think train lines) that are much faster than roadways, you could handle each of these specially via the TDH, and in exchange you would be able to assume a lower &quot;max speed&quot; for use with the A* heurustic, allowing you to explore fewer paths (since with a lower &quot;max speed&quot; paths will more rapidly increase in cost), whereas if you had to assume all car based paths could move as fast as a train, you would have to explore more paths.</div><br/><div id="41949734" class="c"><input type="checkbox" id="c-41949734" checked=""/><div class="controls bullet"><span class="by">kevinwang</span><span>|</span><a href="#41949498">parent</a><span>|</span><a href="#41951140">next</a><span>|</span><label class="collapse" for="c-41949734">[-]</label><label class="expand" for="c-41949734">[4 more]</label></div><br/><div class="children"><div class="content">&gt; When you have some knowledge of the topology of the graph you can use different techniques to do better than djikstra&#x27;s.<p>But that statement doesn&#x27;t apply to the version of Dijkstra&#x27;s developed in this paper right?<p>&gt; Universal optimality is a powerful beyond-worst-case performance guarantee for graph algorithms that informally states that a single algorithm performs as well as possible for every single graph topology.</div><br/><div id="41949946" class="c"><input type="checkbox" id="c-41949946" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41949498">root</a><span>|</span><a href="#41949734">parent</a><span>|</span><a href="#41951884">next</a><span>|</span><label class="collapse" for="c-41949946">[-]</label><label class="expand" for="c-41949946">[1 more]</label></div><br/><div class="children"><div class="content">No, I don&#x27;t believe so.<p>It clarifies specifically what problem it is optimal for &quot;We prove that our working-set property is sufficient to guarantee universal optimality, specifically, for the problem of ordering vertices by their distance from the source vertex&quot;, but A* only explores a subset of vertices based on the heuristic, so it can be more efficient.</div><br/></div></div><div id="41951884" class="c"><input type="checkbox" id="c-41951884" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#41949498">root</a><span>|</span><a href="#41949734">parent</a><span>|</span><a href="#41949946">prev</a><span>|</span><a href="#41951140">next</a><span>|</span><label class="collapse" for="c-41951884">[-]</label><label class="expand" for="c-41951884">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; When you have some knowledge of the topology of the graph you can use different techniques to do better than djikstra&#x27;s.<p>&gt; But that statement doesn&#x27;t apply to the version of Dijkstra&#x27;s developed in this paper right?<p>Simple thought experiment:  I have an algorithm that has path costs for one graph memorized and first compares to that graph; it&#x27;s O(V+E) to compare and return the value for that memorized graph.  It obviously beats this algorithm for that graph.</div><br/><div id="41952729" class="c"><input type="checkbox" id="c-41952729" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41949498">root</a><span>|</span><a href="#41951884">parent</a><span>|</span><a href="#41951140">next</a><span>|</span><label class="collapse" for="c-41952729">[-]</label><label class="expand" for="c-41952729">[1 more]</label></div><br/><div class="children"><div class="content">Hm... technically they&#x27;re saying that their algorithm performs as well as possible &quot;for every single graph topology&quot;. Your special cased algorithm would only work for one particular graph in a family of isomorphic graphs (unless you have a linear time algorithm for the graph isomorphism problem, in which case please share), but would fail for the rest of the graphs in the family. So I think you could still say that their algorithm performs as well as possible for that topology.</div><br/></div></div></div></div></div></div><div id="41951140" class="c"><input type="checkbox" id="c-41951140" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#41949498">parent</a><span>|</span><a href="#41949734">prev</a><span>|</span><a href="#41950248">next</a><span>|</span><label class="collapse" for="c-41951140">[-]</label><label class="expand" for="c-41951140">[2 more]</label></div><br/><div class="children"><div class="content">TDH seems like it would tend to coincidentally reproduce the tendency of animals (humans included) to create paths by having lots of people travel through somewhere. The cause and effect is flipped, but the player doesn’t have to know that, right?</div><br/><div id="41951670" class="c"><input type="checkbox" id="c-41951670" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41949498">root</a><span>|</span><a href="#41951140">parent</a><span>|</span><a href="#41950248">next</a><span>|</span><label class="collapse" for="c-41951670">[-]</label><label class="expand" for="c-41951670">[1 more]</label></div><br/><div class="children"><div class="content">TDH doesn&#x27;t actually change the paths used, it only makes determining them more efficient. There&#x27;s different names for this family of related techniques. There&#x27;s an unfinished article (not mine) talking more about this here: <a href="https:&#x2F;&#x2F;www.redblobgames.com&#x2F;pathfinding&#x2F;heuristics&#x2F;differential.html" rel="nofollow">https:&#x2F;&#x2F;www.redblobgames.com&#x2F;pathfinding&#x2F;heuristics&#x2F;differen...</a></div><br/></div></div></div></div><div id="41950248" class="c"><input type="checkbox" id="c-41950248" checked=""/><div class="controls bullet"><span class="by">Jadrago</span><span>|</span><a href="#41949498">parent</a><span>|</span><a href="#41951140">prev</a><span>|</span><a href="#41948670">next</a><span>|</span><label class="collapse" for="c-41950248">[-]</label><label class="expand" for="c-41950248">[2 more]</label></div><br/><div class="children"><div class="content">Does google maps use something like this? I imagine all pairs is too expensive, but the topology should be fairly consistent over time</div><br/><div id="41950458" class="c"><input type="checkbox" id="c-41950458" checked=""/><div class="controls bullet"><span class="by">urbandw311er</span><span>|</span><a href="#41949498">root</a><span>|</span><a href="#41950248">parent</a><span>|</span><a href="#41948670">next</a><span>|</span><label class="collapse" for="c-41950458">[-]</label><label class="expand" for="c-41950458">[1 more]</label></div><br/><div class="children"><div class="content">Google maps uses something called contraction hierarchies</div><br/></div></div></div></div></div></div><div id="41948670" class="c"><input type="checkbox" id="c-41948670" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#41949498">prev</a><span>|</span><a href="#41950313">next</a><span>|</span><label class="collapse" for="c-41948670">[-]</label><label class="expand" for="c-41948670">[2 more]</label></div><br/><div class="children"><div class="content">The paper&#x27;s name is shorter than this post title, and summarizes the result much better.</div><br/><div id="41949144" class="c"><input type="checkbox" id="c-41949144" checked=""/><div class="controls bullet"><span class="by">mikestew</span><span>|</span><a href="#41948670">parent</a><span>|</span><a href="#41950313">next</a><span>|</span><label class="collapse" for="c-41949144">[-]</label><label class="expand" for="c-41949144">[1 more]</label></div><br/><div class="children"><div class="content">It took me a few minutes before I realized that putting “n” at the end of “prove” makes the HN title readable.<p>But yeah, should have just used the original title.</div><br/></div></div></div></div><div id="41950313" class="c"><input type="checkbox" id="c-41950313" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#41948670">prev</a><span>|</span><a href="#41949327">next</a><span>|</span><label class="collapse" for="c-41950313">[-]</label><label class="expand" for="c-41950313">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Our universal optimality result reveals a surprisingly clean interplay between this property and Dijkstra’s algorithm: Any heap with the working set property enables the algorithm to efficiently leverage every structural attribute of the graph it operates on, to the fullest extent that any comparison-based algorithm possibly can.</i><p>That last bit makes me wonder: what would a shortest path algorithm <i>without</i> comparisons look like? Are there also &quot;radix sort&quot; like approaches to shortest-path algorithms that surpass comparison-based algorithms or something?</div><br/><div id="41950405" class="c"><input type="checkbox" id="c-41950405" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41950313">parent</a><span>|</span><a href="#41952031">next</a><span>|</span><label class="collapse" for="c-41950405">[-]</label><label class="expand" for="c-41950405">[1 more]</label></div><br/><div class="children"><div class="content">Yes. If your distances are dense integers, you can use a simple array as the priority queue in Dijkstra, and it will be faster than a heap (Dial’s algorithm).</div><br/></div></div><div id="41952031" class="c"><input type="checkbox" id="c-41952031" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#41950313">parent</a><span>|</span><a href="#41950405">prev</a><span>|</span><a href="#41949327">next</a><span>|</span><label class="collapse" for="c-41952031">[-]</label><label class="expand" for="c-41952031">[1 more]</label></div><br/><div class="children"><div class="content">A sibling post answers your question, but I found your quote interesting for a different reason: This working set property seems like something that would be very useful in practice for quite a few problems, even if it can&#x27;t be pushed all the way to proving universal optimality. We often have some freedom in choosing what order to supply inputs to a problem we&#x27;re trying to solve; if we can order things so that, 99% of the time, the minimum item that we&#x27;re looking for turns out to be within the last 1000 items considered instead of the complete set of 1000000, that&#x27;s a nearly 10x constant factor speed up right there.</div><br/></div></div></div></div><div id="41949327" class="c"><input type="checkbox" id="c-41949327" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#41950313">prev</a><span>|</span><a href="#41951982">next</a><span>|</span><label class="collapse" for="c-41949327">[-]</label><label class="expand" for="c-41949327">[14 more]</label></div><br/><div class="children"><div class="content">Does this mean that Dijkstra’s algorithm can perform better than something like A*?</div><br/><div id="41949521" class="c"><input type="checkbox" id="c-41949521" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41949327">parent</a><span>|</span><a href="#41949671">next</a><span>|</span><label class="collapse" for="c-41949521">[-]</label><label class="expand" for="c-41949521">[2 more]</label></div><br/><div class="children"><div class="content">The two algorithms solve different (but related) problems. A* finds the shortest path from a source to a <i>single</i> target node. Dijkstra&#x27;s finds the shortest path<i>s</i> from a source to all other nodes. If you&#x27;re using Dijkstra&#x27;s as a search algorithm then it may be slower than A* (often will be, but it depends on the heuristic), but you&#x27;ll be terminating the algorithm early (once your target has been found you don&#x27;t need to continue the algorithm).<p>The algorithm under discussion is not that search-use of Dijkstra&#x27;s, but the original all shortest paths use, so it&#x27;s not directly comparable here to A*.</div><br/><div id="41949703" class="c"><input type="checkbox" id="c-41949703" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#41949327">root</a><span>|</span><a href="#41949521">parent</a><span>|</span><a href="#41949671">next</a><span>|</span><label class="collapse" for="c-41949703">[-]</label><label class="expand" for="c-41949703">[1 more]</label></div><br/><div class="children"><div class="content">Ok, this makes sense, it’s been a while since I did a deep dive into these algorithms for a roguelike project.<p>This article I found really interesting at the time: <a href="https:&#x2F;&#x2F;roguebasin.com&#x2F;?title=The_Incredible_Power_of_Dijkstra_Maps" rel="nofollow">https:&#x2F;&#x2F;roguebasin.com&#x2F;?title=The_Incredible_Power_of_Dijkst...</a></div><br/></div></div></div></div><div id="41949671" class="c"><input type="checkbox" id="c-41949671" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#41949327">parent</a><span>|</span><a href="#41949521">prev</a><span>|</span><a href="#41949376">next</a><span>|</span><label class="collapse" for="c-41949671">[-]</label><label class="expand" for="c-41949671">[1 more]</label></div><br/><div class="children"><div class="content">A* with a consistent heuristic is Dijkstra on a modified graph whose edge weights are the original edge weights plus f(target) - f(source) where f is the A* &quot;heuristic&quot;.<p>If the heuristic is not consistent, the edge weights aren&#x27;t necessarily nonnegative, but you can still use the &quot;hybrid Bellman–Ford–Dijkstra algorithm&quot;, which is a generalization of Dijkstra that works for all graphs, and should be asymptotically better than naive A*.</div><br/></div></div><div id="41949376" class="c"><input type="checkbox" id="c-41949376" checked=""/><div class="controls bullet"><span class="by">jprete</span><span>|</span><a href="#41949327">parent</a><span>|</span><a href="#41949671">prev</a><span>|</span><a href="#41950157">next</a><span>|</span><label class="collapse" for="c-41949376">[-]</label><label class="expand" for="c-41949376">[1 more]</label></div><br/><div class="children"><div class="content">A* is faster in practice if the heuristics used by the specific implementation are accurate and if the graph is &quot;general&quot; for the problem space. I&#x27;m being very loose with the word &quot;general&quot; but essentially it should have typical structure for the problem space it represents.<p>There&#x27;s almost certainly a paper somewhere proving that A* with a given heuristic can always be made O(large) by choosing the right adversarial inputs.</div><br/></div></div><div id="41950157" class="c"><input type="checkbox" id="c-41950157" checked=""/><div class="controls bullet"><span class="by">mvkg</span><span>|</span><a href="#41949327">parent</a><span>|</span><a href="#41949376">prev</a><span>|</span><a href="#41949778">next</a><span>|</span><label class="collapse" for="c-41950157">[-]</label><label class="expand" for="c-41950157">[1 more]</label></div><br/><div class="children"><div class="content">The paper&#x27;s claim for Dijkstra&#x27;s is it&#x27;s &quot;a single algorithm performs as well as possible for every single graph topology&quot;. A* is an augmented version of Dijkstra&#x27;s only applicable when there is a priori knowledge of a good heuristic for the topology (e.g. manhattan distance in a cartesian plane). Since there is almost certainly no heuristic that is universally optimal for all topologies, A* shouldn&#x27;t be more universally optimal than Dijkstra&#x27;s (and can probably perform worse given a bad heuristic).</div><br/></div></div><div id="41949778" class="c"><input type="checkbox" id="c-41949778" checked=""/><div class="controls bullet"><span class="by">red75prime</span><span>|</span><a href="#41949327">parent</a><span>|</span><a href="#41950157">prev</a><span>|</span><a href="#41949402">next</a><span>|</span><label class="collapse" for="c-41949778">[-]</label><label class="expand" for="c-41949778">[1 more]</label></div><br/><div class="children"><div class="content">Others pointed that A* and Dijkstra&#x27;s algorithm solve different problems. But there&#x27;s another possibility: less general but more efficient algorithm. For example, there are faster algorithms for planar graphs.</div><br/></div></div><div id="41949402" class="c"><input type="checkbox" id="c-41949402" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41949327">parent</a><span>|</span><a href="#41949778">prev</a><span>|</span><a href="#41949704">next</a><span>|</span><label class="collapse" for="c-41949402">[-]</label><label class="expand" for="c-41949402">[5 more]</label></div><br/><div class="children"><div class="content">I think A* is solving a different problem than dijkstra&#x27;s, since it requires an admissible heuristic to do any better than dijkstra&#x27;s.<p>As long as you have an admissible heurustic, A* won&#x27;t ever perform worse than dijkstra&#x27;s.</div><br/><div id="41949745" class="c"><input type="checkbox" id="c-41949745" checked=""/><div class="controls bullet"><span class="by">superjan</span><span>|</span><a href="#41949327">root</a><span>|</span><a href="#41949402">parent</a><span>|</span><a href="#41949510">next</a><span>|</span><label class="collapse" for="c-41949745">[-]</label><label class="expand" for="c-41949745">[1 more]</label></div><br/><div class="children"><div class="content">An example for those not in the know: to find a shortest route on a realworld map, an admissible heuristic would be that the minimum travel distance between two nodes will be a straight line. While examining options, A* takes this into account, Dijkstra does not.</div><br/></div></div><div id="41949510" class="c"><input type="checkbox" id="c-41949510" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#41949327">root</a><span>|</span><a href="#41949402">parent</a><span>|</span><a href="#41949745">prev</a><span>|</span><a href="#41949704">next</a><span>|</span><label class="collapse" for="c-41949510">[-]</label><label class="expand" for="c-41949510">[3 more]</label></div><br/><div class="children"><div class="content">A* is not solving a different problem. What happens if h(x)=0 for all x in A*?</div><br/><div id="41949541" class="c"><input type="checkbox" id="c-41949541" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41949327">root</a><span>|</span><a href="#41949510">parent</a><span>|</span><a href="#41949649">next</a><span>|</span><label class="collapse" for="c-41949541">[-]</label><label class="expand" for="c-41949541">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A* is not solving a different problem.<p>A* finds the shortest path from a node to a single other node. Dijkstra&#x27;s finds the shortest paths from a node to all other nodes. If you use it as a search algorithm to find the shortest path to a single target, then yes, it&#x27;s equivalent to A* with h(x)=0, but you&#x27;re terminating Dijkstra&#x27;s early (once your target is found) and not running the full algorithm.</div><br/></div></div><div id="41949649" class="c"><input type="checkbox" id="c-41949649" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41949327">root</a><span>|</span><a href="#41949510">parent</a><span>|</span><a href="#41949541">prev</a><span>|</span><a href="#41949704">next</a><span>|</span><label class="collapse" for="c-41949649">[-]</label><label class="expand" for="c-41949649">[1 more]</label></div><br/><div class="children"><div class="content">A different problem in the sense that A* is useless (it degrades to dijkstra&#x27;s) when there is no admissible heuristic. So I think it&#x27;s reasonable to say that A* solves a different problem (namely, path finding when there is an admissible heuristic), since when there&#x27;s no admissible heuristic it is identical to dijkstra&#x27;s.</div><br/></div></div></div></div></div></div><div id="41949344" class="c"><input type="checkbox" id="c-41949344" checked=""/><div class="controls bullet"><span class="by">entropicdrifter</span><span>|</span><a href="#41949327">parent</a><span>|</span><a href="#41949704">prev</a><span>|</span><a href="#41951982">next</a><span>|</span><label class="collapse" for="c-41949344">[-]</label><label class="expand" for="c-41949344">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a notable exception:<p>&gt;when combined with a sufficiently efficient heap data structure<p>So it depends on the circumstances a bit.</div><br/></div></div></div></div><div id="41951982" class="c"><input type="checkbox" id="c-41951982" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#41949327">prev</a><span>|</span><a href="#41949707">next</a><span>|</span><label class="collapse" for="c-41951982">[-]</label><label class="expand" for="c-41951982">[2 more]</label></div><br/><div class="children"><div class="content">Robert Tarjan&#x27;s name is on a simply astounding number of breakthrough papers in graph algorithms, spanning decades.</div><br/><div id="41952776" class="c"><input type="checkbox" id="c-41952776" checked=""/><div class="controls bullet"><span class="by">joshhug</span><span>|</span><a href="#41951982">parent</a><span>|</span><a href="#41949707">next</a><span>|</span><label class="collapse" for="c-41952776">[-]</label><label class="expand" for="c-41952776">[1 more]</label></div><br/><div class="children"><div class="content">I had him as a teaching assistant when I was teaching data structures at Princeton back in Fall 2013. Princeton CS has their professors rotate through as TAs every so often through their courses.<p>That semester, I made a slight mistake on the final exam where I asked students to create an algorithm that could find the second shortest path from s to every other vertex in a graph. I forgot to specify that the second shortest path should be simple (i.e. should not reuse any vertex twice). Having to deal with non-simple paths makes the problem much much harder.<p>None of the students figured it out in the time available, and I&#x27;m sure I would also have been stumped if I had tried to solve the problem. Bob figured it out though. And then I remember he graded all 150 solutions to the problem himself, having as a blast as he went through students attempts at an effectively impossible problem.</div><br/></div></div></div></div><div id="41949707" class="c"><input type="checkbox" id="c-41949707" checked=""/><div class="controls bullet"><span class="by">m0llusk</span><span>|</span><a href="#41951982">prev</a><span>|</span><a href="#41948823">next</a><span>|</span><label class="collapse" for="c-41949707">[-]</label><label class="expand" for="c-41949707">[1 more]</label></div><br/><div class="children"><div class="content">In most real situations a graph is likely to be a model with some expected characteristics or perhaps data regarding real situations.  Either way with modern computing it seems like in many cases using machine learning to predict the path or next steps on the path might actually end up being a more optimal method.  The issue is how much data and modeling is available and how any processing of that would best be accounted for in final results that make use of any analysis.</div><br/></div></div><div id="41948823" class="c"><input type="checkbox" id="c-41948823" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41949707">prev</a><span>|</span><a href="#41950233">next</a><span>|</span><label class="collapse" for="c-41948823">[-]</label><label class="expand" for="c-41948823">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Universal Optimality of Dijkstra via Beyond-Worst-Case Heaps&quot; (2024)
<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2311.11793" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2311.11793</a> :<p>&gt; Abstract: <i>This paper proves that Dijkstra&#x27;s shortest-path algorithm is universally optimal in both its running time and number of comparisons when combined with a sufficiently efficient heap data structure.</i><p>Dijkstra&#x27;s algorithm: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dijkstra%27s_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dijkstra%27s_algorithm</a><p>NetworkX docs &gt; Reference &gt; Algorithms &gt; Shortest Paths:
<a href="https:&#x2F;&#x2F;networkx.org&#x2F;documentation&#x2F;stable&#x2F;reference&#x2F;algorithms&#x2F;shortest_paths.html" rel="nofollow">https:&#x2F;&#x2F;networkx.org&#x2F;documentation&#x2F;stable&#x2F;reference&#x2F;algorith...</a><p>networkX.algorithms.shortest_path.dijkstra_path: <a href="https:&#x2F;&#x2F;networkx.org&#x2F;documentation&#x2F;stable&#x2F;reference&#x2F;algorithms&#x2F;generated&#x2F;networkx.algorithms.shortest_paths.weighted.dijkstra_path.html" rel="nofollow">https:&#x2F;&#x2F;networkx.org&#x2F;documentation&#x2F;stable&#x2F;reference&#x2F;algorith...</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;networkx&#x2F;networkx&#x2F;blob&#x2F;main&#x2F;networkx&#x2F;algorithms&#x2F;shortest_paths&#x2F;weighted.py">https:&#x2F;&#x2F;github.com&#x2F;networkx&#x2F;networkx&#x2F;blob&#x2F;main&#x2F;networkx&#x2F;algo...</a><p>&#x2F;? Dijkstra manim: <a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=dijkstra%20manim" rel="nofollow">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=dijkstra%20manim</a></div><br/></div></div><div id="41950233" class="c"><input type="checkbox" id="c-41950233" checked=""/><div class="controls bullet"><span class="by">heraldgeezer</span><span>|</span><a href="#41948823">prev</a><span>|</span><a href="#41949349">next</a><span>|</span><label class="collapse" for="c-41950233">[-]</label><label class="expand" for="c-41950233">[1 more]</label></div><br/><div class="children"><div class="content">I recognize the name due to studying CCNA in the past. His name comes up with OSPF routing protocol.</div><br/></div></div><div id="41949349" class="c"><input type="checkbox" id="c-41949349" checked=""/><div class="controls bullet"><span class="by">moron4hire</span><span>|</span><a href="#41950233">prev</a><span>|</span><a href="#41949315">next</a><span>|</span><label class="collapse" for="c-41949349">[-]</label><label class="expand" for="c-41949349">[2 more]</label></div><br/><div class="children"><div class="content">This came up for me not long ago. A* is a specialization of Dijkstra&#x27;s that is the canonical &quot;path finding algorithm&quot; for game development. A* is good for finding how to get from a specific point A to a specific point B. But I wanted to know how to get from any point A to a list of point Bs. And so it turned out that the extra work that Dijkstra&#x27;s does that A* skips is exactly the work you want when doing such a thing. It&#x27;s also cacheable, which is incredible in the modern era of having basically infinite memory for this sort of thing.</div><br/><div id="41950010" class="c"><input type="checkbox" id="c-41950010" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41949349">parent</a><span>|</span><a href="#41949315">next</a><span>|</span><label class="collapse" for="c-41950010">[-]</label><label class="expand" for="c-41950010">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s wrong, A* can trivially handle a set of points at one end (you might have to &quot;reverse&quot; the direction depending on which end has the set).</div><br/></div></div></div></div><div id="41949315" class="c"><input type="checkbox" id="c-41949315" checked=""/><div class="controls bullet"><span class="by">impure</span><span>|</span><a href="#41949349">prev</a><span>|</span><a href="#41952501">next</a><span>|</span><label class="collapse" for="c-41949315">[-]</label><label class="expand" for="c-41949315">[2 more]</label></div><br/><div class="children"><div class="content">A* has entered the chat</div><br/><div id="41949555" class="c"><input type="checkbox" id="c-41949555" checked=""/><div class="controls bullet"><span class="by">twojacobtwo</span><span>|</span><a href="#41949315">parent</a><span>|</span><a href="#41952501">next</a><span>|</span><label class="collapse" for="c-41949555">[-]</label><label class="expand" for="c-41949555">[1 more]</label></div><br/><div class="children"><div class="content">Several other commenters have now pointed out the differentiations, in case you weren&#x27;t aware.</div><br/></div></div></div></div></div></div></div></div></div></body></html>