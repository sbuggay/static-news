<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729674074069" as="style"/><link rel="stylesheet" href="styles.css?v=1729674074069"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bmchtech.github.io/post/multiply/">Solving the Mystery of ARM7TDMI Multiply Carry Flag</a> <span class="domain">(<a href="https://bmchtech.github.io">bmchtech.github.io</a>)</span></div><div class="subtext"><span>skrrtww</span> | <span>21 comments</span></div><br/><div><div id="41920807" class="c"><input type="checkbox" id="c-41920807" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41921855">next</a><span>|</span><label class="collapse" for="c-41920807">[-]</label><label class="expand" for="c-41920807">[5 more]</label></div><br/><div class="children"><div class="content"><i>And just to get this out of the way, the carry flag’s behavior after multiplication isn’t an important detail to emulate at all. Software doesn’t rely on it.</i><p>On as fixed of a hardware as a game console, and with the accompanying anti-piracy&#x2F;anti-cheating&#x2F;emulation efforts of that industry, I&#x27;d expect it to be. From the history of emulating previous consoles, we know that any deterministic difference can and will be exploited, either to determine whether the hardware is authentic, or incidentally as a result of unintentional bugs.<p>This reminds me of the Z80, where two undefined flags resisted analysis for several decades; a 2-year-old set of slides on the state of that here: <a href="https:&#x2F;&#x2F;archive.fosdem.org&#x2F;2022&#x2F;schedule&#x2F;event&#x2F;z80&#x2F;attachments&#x2F;slides&#x2F;5207&#x2F;export&#x2F;events&#x2F;attachments&#x2F;z80&#x2F;slides&#x2F;5207&#x2F;z80_last_secrets.pdf" rel="nofollow">https:&#x2F;&#x2F;archive.fosdem.org&#x2F;2022&#x2F;schedule&#x2F;event&#x2F;z80&#x2F;attachmen...</a></div><br/><div id="41922188" class="c"><input type="checkbox" id="c-41922188" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#41920807">parent</a><span>|</span><a href="#41922494">next</a><span>|</span><label class="collapse" for="c-41922188">[-]</label><label class="expand" for="c-41922188">[2 more]</label></div><br/><div class="children"><div class="content">While it’s a bit newer than the GBA, there is at least one Wii game with intentional anti-emulation measures:<p><a href="https:&#x2F;&#x2F;tcrf.net&#x2F;Cars_2_(PlayStation_3,_Xbox_360,_Windows,_Wii)#Anti-Dolphin_Code" rel="nofollow">https:&#x2F;&#x2F;tcrf.net&#x2F;Cars_2_(PlayStation_3,_Xbox_360,_Windows,_W...</a></div><br/></div></div><div id="41922494" class="c"><input type="checkbox" id="c-41922494" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41920807">parent</a><span>|</span><a href="#41922188">prev</a><span>|</span><a href="#41922248">next</a><span>|</span><label class="collapse" for="c-41922494">[-]</label><label class="expand" for="c-41922494">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; the carry flag’s behavior after multiplication isn’t an important detail to emulate at all. Software doesn’t rely on it.<p>Famous last words:<p><a href="https:&#x2F;&#x2F;www.hyrumslaw.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hyrumslaw.com&#x2F;</a></div><br/></div></div><div id="41922248" class="c"><input type="checkbox" id="c-41922248" checked=""/><div class="controls bullet"><span class="by">DevilStuff</span><span>|</span><a href="#41920807">parent</a><span>|</span><a href="#41922494">prev</a><span>|</span><a href="#41921855">next</a><span>|</span><label class="collapse" for="c-41922248">[-]</label><label class="expand" for="c-41922248">[1 more]</label></div><br/><div class="children"><div class="content">In the GBA scene, people didn&#x27;t actually tend to exploit the carry flag at all. If there was any anti emulation, it was usually flashcart related or cpu timing related.</div><br/></div></div></div></div><div id="41921855" class="c"><input type="checkbox" id="c-41921855" checked=""/><div class="controls bullet"><span class="by">ujikoluk</span><span>|</span><a href="#41920807">prev</a><span>|</span><a href="#41920773">next</a><span>|</span><label class="collapse" for="c-41921855">[-]</label><label class="expand" for="c-41921855">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Seriously, they decided that the program counter should be a general purpose register. Why???<p>Don&#x27;t really understand this reaction. Why not? Seems to make for a nice regular design that the PC is just another register.</div><br/><div id="41922215" class="c"><input type="checkbox" id="c-41922215" checked=""/><div class="controls bullet"><span class="by">DevilStuff</span><span>|</span><a href="#41921855">parent</a><span>|</span><a href="#41922238">next</a><span>|</span><label class="collapse" for="c-41922215">[-]</label><label class="expand" for="c-41922215">[5 more]</label></div><br/><div class="children"><div class="content">The big issue is that it doesn&#x27;t really need to be a GPR. You never find yourself using the PC in instructions other than in, say, the occasional add instruction for switch case jumptables, or pushes &#x2F; pops. So it ends up wasting instruction space, when you could&#x27;ve had an additional register, or encoded a zero register (which is what AARCH64 does nowadays).</div><br/><div id="41922260" class="c"><input type="checkbox" id="c-41922260" checked=""/><div class="controls bullet"><span class="by">joosters</span><span>|</span><a href="#41921855">root</a><span>|</span><a href="#41922215">parent</a><span>|</span><a href="#41922238">next</a><span>|</span><label class="collapse" for="c-41922260">[-]</label><label class="expand" for="c-41922260">[4 more]</label></div><br/><div class="children"><div class="content">But it is (or was originally) used in lots of places, not just jump tables, generally to do relative addressing, for example when you want to refer to data nearby, e.g.<p>ADD r0, r15, #200<p>LDR r1, [r15, #-100]<p>etc</div><br/><div id="41922297" class="c"><input type="checkbox" id="c-41922297" checked=""/><div class="controls bullet"><span class="by">DevilStuff</span><span>|</span><a href="#41921855">root</a><span>|</span><a href="#41922260">parent</a><span>|</span><a href="#41922238">next</a><span>|</span><label class="collapse" for="c-41922297">[-]</label><label class="expand" for="c-41922297">[3 more]</label></div><br/><div class="children"><div class="content">Ah I miscommunicated, I still think PC can and should be used in places like the operand of an LDR &#x2F; ADD. It&#x27;s using it as the <i>output</i> of certain instructions (and allowing it to be used as such) that I take issue with. ARMv4T allowed you to set PC as the output of basically any instruction, allowing you to create cursed instructions like this lol:<p>eor pc, pc, pc</div><br/><div id="41922476" class="c"><input type="checkbox" id="c-41922476" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41921855">root</a><span>|</span><a href="#41922297">parent</a><span>|</span><a href="#41922238">next</a><span>|</span><label class="collapse" for="c-41922476">[-]</label><label class="expand" for="c-41922476">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t writing to it except by a branch instruction undefined behaviour?<p>If you can use it as an operand, it has a register number, so you can use it as a result, unless you special-case one or the other, which ARM didn&#x27;t do because it was supposed to be simple. They could have ignored it by omitting some write decode circuitry, but why?</div><br/><div id="41922533" class="c"><input type="checkbox" id="c-41922533" checked=""/><div class="controls bullet"><span class="by">DevilStuff</span><span>|</span><a href="#41921855">root</a><span>|</span><a href="#41922476">parent</a><span>|</span><a href="#41922238">next</a><span>|</span><label class="collapse" for="c-41922533">[-]</label><label class="expand" for="c-41922533">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really UB, I&#x27;ve seen games do things like this before. Basically, all data processing instructions can now act as branch instructions, simply by having their dest be PC. Bowser&#x27;s Inside Story on the DS for example liked to use EOR to write to PC, as a form of encrypting their pointers.<p>Yeah I think AARCH64 special cases it? Not too familiar with their encoding or how they achieved it. My guess as to why is that it allows you to use more helpful registers (e.g. a zero register) in data processing instructions.<p>I think I can see your point though - from the perspective of ARMv4T&#x27;s design, which was to be a simple yet effective CPU, making the PC a GPR does its job. Nowadays the standards are different, but I can see why it made sense at the time.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41922238" class="c"><input type="checkbox" id="c-41922238" checked=""/><div class="controls bullet"><span class="by">joosters</span><span>|</span><a href="#41921855">parent</a><span>|</span><a href="#41922215">prev</a><span>|</span><a href="#41920773">next</a><span>|</span><label class="collapse" for="c-41922238">[-]</label><label class="expand" for="c-41922238">[5 more]</label></div><br/><div class="children"><div class="content">Yeah, it was that way for all previous ARM processors too, for exactly that reason. Adding special cases would have increased the transistor count, for no great benefit.<p>The only downside was that it exposed internal details of the pipelining IIRC. In the ARM2, a read of the PC would give the current instruction&#x27;s location + 8, rather than its actual location, because by the time the instruction &#x27;took place&#x27; the PC had moved on. So if&#x2F;when you change the pipelining for future processors, you either make older code break, or have to special case the current behaviour of returning +8.<p>Anyway, I don&#x27;t like their reaction. What they mean is &#x27;this decision makes writing an emulator more tricky&#x27; but the author decides that this makes the chip designers stupid. If the author&#x27;s reaction to problems is &#x27;the chip designers were stupid and wrong, I&#x27;ll write a blog post insulting them&#x27; then the problem is with the author.</div><br/><div id="41922286" class="c"><input type="checkbox" id="c-41922286" checked=""/><div class="controls bullet"><span class="by">DevilStuff</span><span>|</span><a href="#41921855">root</a><span>|</span><a href="#41922238">parent</a><span>|</span><a href="#41920773">next</a><span>|</span><label class="collapse" for="c-41922286">[-]</label><label class="expand" for="c-41922286">[4 more]</label></div><br/><div class="children"><div class="content">Hey, I&#x27;m the author, sorry it came off that way, I was really just poking fun. I should&#x27;ve definitely phrased that better!<p>But no, I really think that making the program counter a GPR isn&#x27;t a good design decision - there&#x27;s pretty good reasons why no modern arches do things that way anymore. I admittedly was originally in the same boat when I first heard of ARMv4T - I thought putting the PC as a GPR was quite clean, but I soon realized it just wastes instruction space, makes branch prediction slightly more complex, decrease the number of available registers (increasing register pressure), all while providing marginal benefit to the programmer</div><br/><div id="41922323" class="c"><input type="checkbox" id="c-41922323" checked=""/><div class="controls bullet"><span class="by">DevilStuff</span><span>|</span><a href="#41921855">root</a><span>|</span><a href="#41922286">parent</a><span>|</span><a href="#41922408">next</a><span>|</span><label class="collapse" for="c-41922323">[-]</label><label class="expand" for="c-41922323">[1 more]</label></div><br/><div class="children"><div class="content">Anyway, I took the time to rewrite that paragraph a bit to be more respectful. :P Hopefully that&#x27;ll come off better. The website take a few minutes to update.</div><br/></div></div><div id="41922408" class="c"><input type="checkbox" id="c-41922408" checked=""/><div class="controls bullet"><span class="by">joosters</span><span>|</span><a href="#41921855">root</a><span>|</span><a href="#41922286">parent</a><span>|</span><a href="#41922323">prev</a><span>|</span><a href="#41920773">next</a><span>|</span><label class="collapse" for="c-41922408">[-]</label><label class="expand" for="c-41922408">[2 more]</label></div><br/><div class="children"><div class="content">I think I misread your tone, sorry.<p>It&#x27;s a good article though, the explanation of how multiplies work is nicely written.</div><br/><div id="41922507" class="c"><input type="checkbox" id="c-41922507" checked=""/><div class="controls bullet"><span class="by">DevilStuff</span><span>|</span><a href="#41921855">root</a><span>|</span><a href="#41922408">parent</a><span>|</span><a href="#41920773">next</a><span>|</span><label class="collapse" for="c-41922507">[-]</label><label class="expand" for="c-41922507">[1 more]</label></div><br/><div class="children"><div class="content">No worries, I&#x27;m glad you brought it up so I could amend the article to be more respectful to those that I look up to :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41920773" class="c"><input type="checkbox" id="c-41920773" checked=""/><div class="controls bullet"><span class="by">skrrtww</span><span>|</span><a href="#41921855">prev</a><span>|</span><a href="#41922863">next</a><span>|</span><label class="collapse" for="c-41920773">[-]</label><label class="expand" for="c-41920773">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;shonumi.github.io&#x2F;blog&#x2F;nds_rolling.html" rel="nofollow">https:&#x2F;&#x2F;shonumi.github.io&#x2F;blog&#x2F;nds_rolling.html</a><p>More context on how this value affects (at least one) DS game- see post from December 27th, 2019.</div><br/><div id="41920878" class="c"><input type="checkbox" id="c-41920878" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41920773">parent</a><span>|</span><a href="#41922863">next</a><span>|</span><label class="collapse" for="c-41920878">[-]</label><label class="expand" for="c-41920878">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not really familiar with ARM Asm but do you think that&#x27;s handwritten Asm that its author overlooked the effects of the carry and it just happened to work, or a clever &quot;emulator trap&quot; added by Nintendo&#x27;s compiler?</div><br/><div id="41923027" class="c"><input type="checkbox" id="c-41923027" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#41920773">root</a><span>|</span><a href="#41920878">parent</a><span>|</span><a href="#41922863">next</a><span>|</span><label class="collapse" for="c-41923027">[-]</label><label class="expand" for="c-41923027">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s handwritten and hand-obfuscated assembly, the author didn&#x27;t know the effect of the carry but knew it was deterministic; and the code worked.<p>Though it&#x27;s not clear to me where the corruption after the second MLA instruction comes from, because the second block of three instructions should produce the same output as the first. It is possible that it was copied&#x2F;pasted incorrectly.</div><br/></div></div></div></div></div></div><div id="41922863" class="c"><input type="checkbox" id="c-41922863" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41920773">prev</a><span>|</span><label class="collapse" for="c-41922863">[-]</label><label class="expand" for="c-41922863">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it allows the program counter to be used a general purpose register<p>From a CPU emulator writer&#x27;s perspective this isn&#x27;t all that strange. For instance on Z80 the immediate jump instruction `JP nnnn` is loading a 16-bit immediate value into the internal PC register, which is the same thing as loading a 16-bit value into a regular register pair (e.g. &#x27;LD HL,nnnn&#x27;) - e.g. the mnemonics for the jump instruction could just as well be `LD PC,nnnn` ;)<p>A relative jump (which does a signed-add of an 8-bit offset value to the 16-bit address in PC) is the same math as the Z80 indexed addressing mode (IX+d) and (IY+d) (I don&#x27;t know though if the same transistors are used).<p>A RET (load 16-bit value from stack into PC) is the the same operation as a POP (load 16-bit value from stack into a regular register pair).<p>...so it&#x27;s almost surprising that the program counter <i>isn&#x27;t</i> exposed as a regular register in most (traditional) CPUs. I guess in modern CPUs it&#x27;s not so simple because of the internal pipelining though.</div><br/></div></div></div></div></div></div></div></body></html>