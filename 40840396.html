<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719824481844" as="style"/><link rel="stylesheet" href="styles.css?v=1719824481844"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.alvarorevuelta.com/posts/fft-polynomials">Convolutions, Fast Fourier Transform and polynomials (2022)</a> <span class="domain">(<a href="https://www.alvarorevuelta.com">www.alvarorevuelta.com</a>)</span></div><div class="subtext"><span>clearprop</span> | <span>38 comments</span></div><br/><div><div id="40840791" class="c"><input type="checkbox" id="c-40840791" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#40843543">next</a><span>|</span><label class="collapse" for="c-40840791">[-]</label><label class="expand" for="c-40840791">[19 more]</label></div><br/><div class="children"><div class="content">Something that always bothers me about these explanations is they usually forget about numerical errors. You can&#x27;t just abstract away multiplying coefficients as &quot;constant time&quot;. You may as well abstract away the entire multiplication to begin with! If you take into account numerical precision, it&#x27;s closer to O(n (log n)^3) [1].<p>[1]: <a href="http:&#x2F;&#x2F;numbers.computation.free.fr&#x2F;Constants&#x2F;Algorithms&#x2F;fft.html" rel="nofollow">http:&#x2F;&#x2F;numbers.computation.free.fr&#x2F;Constants&#x2F;Algorithms&#x2F;fft....</a></div><br/><div id="40841314" class="c"><input type="checkbox" id="c-40841314" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40840791">parent</a><span>|</span><a href="#40842708">next</a><span>|</span><label class="collapse" for="c-40841314">[-]</label><label class="expand" for="c-40841314">[9 more]</label></div><br/><div class="children"><div class="content">The error bound cited in that article is wildly pessimistic.  The latest edition of Knuth has the correct bound (because I gave it to him).</div><br/><div id="40841348" class="c"><input type="checkbox" id="c-40841348" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40841314">parent</a><span>|</span><a href="#40842708">next</a><span>|</span><label class="collapse" for="c-40841348">[-]</label><label class="expand" for="c-40841348">[8 more]</label></div><br/><div class="children"><div class="content">Would you mind just sharing it here...?</div><br/><div id="40842183" class="c"><input type="checkbox" id="c-40842183" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40841348">parent</a><span>|</span><a href="#40842708">next</a><span>|</span><label class="collapse" for="c-40842183">[-]</label><label class="expand" for="c-40842183">[7 more]</label></div><br/><div class="children"><div class="content">Short answer is that FFTs are about as well behaved as anything can possibly be, because they&#x27;re rotations in C^n.<p>Explicit bound is in <a href="https:&#x2F;&#x2F;www.daemonology.net&#x2F;papers&#x2F;fft.pdf" rel="nofollow">https:&#x2F;&#x2F;www.daemonology.net&#x2F;papers&#x2F;fft.pdf</a></div><br/><div id="40842355" class="c"><input type="checkbox" id="c-40842355" checked=""/><div class="controls bullet"><span class="by">eranation</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40842183">parent</a><span>|</span><a href="#40842708">next</a><span>|</span><label class="collapse" for="c-40842355">[-]</label><label class="expand" for="c-40842355">[6 more]</label></div><br/><div class="children"><div class="content">This is why I keep coming back to HN. You read an interesting article, a little proud you understand half of it, read a question that already makes you feel like the stupidest person in the room, then read a clarifying answer by someone who probably got a Knuth reward check for correcting an errata in the art of computer programming.</div><br/><div id="40842629" class="c"><input type="checkbox" id="c-40842629" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40842355">parent</a><span>|</span><a href="#40842708">next</a><span>|</span><label class="collapse" for="c-40842629">[-]</label><label class="expand" for="c-40842629">[5 more]</label></div><br/><div class="children"><div class="content">Knuth judged that it wasn&#x27;t an erratum, since the bound he included was correct and he never claimed it was optimal. :-&#x2F;</div><br/><div id="40843561" class="c"><input type="checkbox" id="c-40843561" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40842629">parent</a><span>|</span><a href="#40842693">next</a><span>|</span><label class="collapse" for="c-40843561">[-]</label><label class="expand" for="c-40843561">[2 more]</label></div><br/><div class="children"><div class="content">Did he decide to include your better bound in future editions?</div><br/><div id="40843824" class="c"><input type="checkbox" id="c-40843824" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40843561">parent</a><span>|</span><a href="#40842693">next</a><span>|</span><label class="collapse" for="c-40843824">[-]</label><label class="expand" for="c-40843824">[1 more]</label></div><br/><div class="children"><div class="content">Yes.  I believe proving the strict bound is one of the exercises now.</div><br/></div></div></div></div><div id="40842693" class="c"><input type="checkbox" id="c-40842693" checked=""/><div class="controls bullet"><span class="by">Randor</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40842629">parent</a><span>|</span><a href="#40843561">prev</a><span>|</span><a href="#40842708">next</a><span>|</span><label class="collapse" for="c-40842693">[-]</label><label class="expand" for="c-40842693">[2 more]</label></div><br/><div class="children"><div class="content">Thanks, not often we see Knuth erratas.  :)</div><br/><div id="40843281" class="c"><input type="checkbox" id="c-40843281" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40842693">parent</a><span>|</span><a href="#40842708">next</a><span>|</span><label class="collapse" for="c-40843281">[-]</label><label class="expand" for="c-40843281">[1 more]</label></div><br/><div class="children"><div class="content">&lt;pedant&gt;You never see &quot;erratas&quot;, since &quot;errata&quot; is already the plural (of &quot;erratum&quot;).&lt;&#x2F;pedant&gt;</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40842708" class="c"><input type="checkbox" id="c-40842708" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#40840791">parent</a><span>|</span><a href="#40841314">prev</a><span>|</span><a href="#40841125">next</a><span>|</span><label class="collapse" for="c-40842708">[-]</label><label class="expand" for="c-40842708">[1 more]</label></div><br/><div class="children"><div class="content">It will be great if we can minimize the multiplication errors and perhaps do away with the errors altogether by utilizing quaternion based operations describes in the OP article [1],[2],[3].<p>[1] One-Dimensional Quaternion Discrete Fourier Transform and an Approach to Its Fast Computation:<p><a href="https:&#x2F;&#x2F;www.mdpi.com&#x2F;2079-9292&#x2F;12&#x2F;24&#x2F;4974" rel="nofollow">https:&#x2F;&#x2F;www.mdpi.com&#x2F;2079-9292&#x2F;12&#x2F;24&#x2F;4974</a><p>[2] Convolution Theorems for Quaternion Fourier Transform: Properties and Applications:<p><a href="https:&#x2F;&#x2F;onlinelibrary.wiley.com&#x2F;doi&#x2F;10.1155&#x2F;2013&#x2F;162769" rel="nofollow">https:&#x2F;&#x2F;onlinelibrary.wiley.com&#x2F;doi&#x2F;10.1155&#x2F;2013&#x2F;162769</a><p>[3] On the Matrix Form of the Quaternion Fourier Transform and Quaternion Convolution:<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2307.01836" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2307.01836</a></div><br/></div></div><div id="40841125" class="c"><input type="checkbox" id="c-40841125" checked=""/><div class="controls bullet"><span class="by">e-khadem</span><span>|</span><a href="#40840791">parent</a><span>|</span><a href="#40842708">prev</a><span>|</span><a href="#40841546">next</a><span>|</span><label class="collapse" for="c-40841125">[-]</label><label class="expand" for="c-40841125">[7 more]</label></div><br/><div class="children"><div class="content">But if the coefficients are integers, you can use NTT with a big enough modulus and get exact results and a boost (esp. in hardware) in multiplication time.</div><br/><div id="40841265" class="c"><input type="checkbox" id="c-40841265" checked=""/><div class="controls bullet"><span class="by">xphos</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40841125">parent</a><span>|</span><a href="#40841285">next</a><span>|</span><label class="collapse" for="c-40841265">[-]</label><label class="expand" for="c-40841265">[3 more]</label></div><br/><div class="children"><div class="content">Had no clue what NTT was but found this as a reference <a href="https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;48798#:~:text=NTT%20(Number%20Theoretic%20Transform),calculations%20are%20done%20in%20integers" rel="nofollow">https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;48798#:~:text=NTT%20(Numbe...</a>.</div><br/><div id="40841291" class="c"><input type="checkbox" id="c-40841291" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40841265">parent</a><span>|</span><a href="#40841362">next</a><span>|</span><label class="collapse" for="c-40841291">[-]</label><label class="expand" for="c-40841291">[1 more]</label></div><br/><div class="children"><div class="content">I prefer this reference:
<a href="https:&#x2F;&#x2F;cp-algorithms.com&#x2F;algebra&#x2F;fft.html#number-theoretic-transform" rel="nofollow">https:&#x2F;&#x2F;cp-algorithms.com&#x2F;algebra&#x2F;fft.html#number-theoretic-...</a></div><br/></div></div><div id="40841362" class="c"><input type="checkbox" id="c-40841362" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40841265">parent</a><span>|</span><a href="#40841291">prev</a><span>|</span><a href="#40841285">next</a><span>|</span><label class="collapse" for="c-40841362">[-]</label><label class="expand" for="c-40841362">[1 more]</label></div><br/><div class="children"><div class="content">See chapter 26 of the &quot;FXT book&quot;. I just shared it here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40841355">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40841355</a></div><br/></div></div></div></div><div id="40841285" class="c"><input type="checkbox" id="c-40841285" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40841125">parent</a><span>|</span><a href="#40841265">prev</a><span>|</span><a href="#40841546">next</a><span>|</span><label class="collapse" for="c-40841285">[-]</label><label class="expand" for="c-40841285">[3 more]</label></div><br/><div class="children"><div class="content">Is there a way to find groups with easy generators&#x2F;primitive roots? I imagine you&#x27;d want a small root of unity, but also be able to choose a bigger modulus for extra big multiplications. Also, afaik it&#x27;s discrete-logarithm level of difficulty to even find <i>a</i> generator if you choose a random modulus, though I don&#x27;t know if it&#x27;s easier to find a modulus after you choose the generator.</div><br/><div id="40841851" class="c"><input type="checkbox" id="c-40841851" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40840791">root</a><span>|</span><a href="#40841285">parent</a><span>|</span><a href="#40842695">next</a><span>|</span><label class="collapse" for="c-40841851">[-]</label><label class="expand" for="c-40841851">[1 more]</label></div><br/><div class="children"><div class="content">since the groups you&#x27;re looking at are is size log(n), you can do a lot of work without issue. as long as you do experimental it less work, it doesn&#x27;t affect the runtime.</div><br/></div></div></div></div></div></div><div id="40841546" class="c"><input type="checkbox" id="c-40841546" checked=""/><div class="controls bullet"><span class="by">uoaei</span><span>|</span><a href="#40840791">parent</a><span>|</span><a href="#40841125">prev</a><span>|</span><a href="#40843543">next</a><span>|</span><label class="collapse" for="c-40841546">[-]</label><label class="expand" for="c-40841546">[1 more]</label></div><br/><div class="children"><div class="content">Hence the distinction between <i>computer science</i> and <i>software engineering</i>. :)</div><br/></div></div></div></div><div id="40843543" class="c"><input type="checkbox" id="c-40843543" checked=""/><div class="controls bullet"><span class="by">nickcw</span><span>|</span><a href="#40840791">prev</a><span>|</span><a href="#40841600">next</a><span>|</span><label class="collapse" for="c-40843543">[-]</label><label class="expand" for="c-40843543">[2 more]</label></div><br/><div class="children"><div class="content">You can use this method to multiply long numbers together. The key insight you need is that polynomial multiplication is the same as normal long number multiplication without doing carrying.<p>So suppose you have a 1000 digit number. You then take each digit and use it as the coefficient of a 1000 element polynomial. You can then multiply these polynomials together using the fft method as described in the article. To convert the result back to a number you need to do the carries. So if an element is bigger than 10 you carry the excess to the next digit. You then take the coefficients and turn them into numbers.<p>That&#x27;s the basic idea. There is some subtlety I&#x27;ve glossed over due to precision needed for the carries and to be sure that rounding the fft result to the nearest integer is correct. That is the way big number multiplication is done in GMP which is the leading Library for this sort of thing.</div><br/><div id="40843570" class="c"><input type="checkbox" id="c-40843570" checked=""/><div class="controls bullet"><span class="by">clearprop</span><span>|</span><a href="#40843543">parent</a><span>|</span><a href="#40841600">next</a><span>|</span><label class="collapse" for="c-40843570">[-]</label><label class="expand" for="c-40843570">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the comment. That makes sense, since as you are saying, a base10 number can be expressed as a polynomial where x=10. Eg: 983 = 9x^2 + 8x + 3 aka [9, 8, 3]. Wondering how big the number has to be to make sense, and where this is used in practice.</div><br/></div></div></div></div><div id="40841600" class="c"><input type="checkbox" id="c-40841600" checked=""/><div class="controls bullet"><span class="by">sigil</span><span>|</span><a href="#40843543">prev</a><span>|</span><a href="#40842639">next</a><span>|</span><label class="collapse" for="c-40841600">[-]</label><label class="expand" for="c-40841600">[5 more]</label></div><br/><div class="children"><div class="content">Who was the first person to propose FFTs for faster polynomial multiplication?<p>Got curious about this recently. I’m not great at citation tracing, but did make it back to this 1995 paper by David Eppstein [0] where he uses it to efficiently solve Subset Sum after an incremental update. Surely Knuth’s TAOCP had it even earlier?<p>The fact that FFT polynomial multiplication also lets you solve Exact Subset Sum with Repetition in sub-exponential time came as a real shock to me. [1] Crucially, this algo is O(N log N) where N = the maximum element, not N = the set size, so it isn’t a P ≠ NP counterexample or anything.<p>[0] <a href="https:&#x2F;&#x2F;escholarship.org&#x2F;content&#x2F;qt6sd695gn&#x2F;qt6sd695gn.pdf" rel="nofollow">https:&#x2F;&#x2F;escholarship.org&#x2F;content&#x2F;qt6sd695gn&#x2F;qt6sd695gn.pdf</a><p>[1] <a href="https:&#x2F;&#x2F;x.com&#x2F;festivitymn&#x2F;status&#x2F;1788362552998580473?s=46&amp;t=fdgdiEzkLwQ2qvItoWggvg" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;festivitymn&#x2F;status&#x2F;1788362552998580473?s=46&amp;t=...</a></div><br/><div id="40841798" class="c"><input type="checkbox" id="c-40841798" checked=""/><div class="controls bullet"><span class="by">pbsd</span><span>|</span><a href="#40841600">parent</a><span>|</span><a href="#40841771">next</a><span>|</span><label class="collapse" for="c-40841798">[-]</label><label class="expand" for="c-40841798">[2 more]</label></div><br/><div class="children"><div class="content">Pollard [1], Nicholson [2], and Schonhage-Strassen [3] seem to have come up with it independently around the same time, using different approaches. Strassen is said to have discovered the Pollard approach in 1968 but there is no (written) record of it.<p>It should also be noted that, while it was not exactly the birth of the FFT, Cooley-Tukey&#x27;s 1965 paper [4] on it was what kickstarted research on FFT and its applications. This was just a few years after that.<p>[1] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1090&#x2F;S0025-5718-1971-0301966-0" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1090&#x2F;S0025-5718-1971-0301966-0</a><p>[2] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1016&#x2F;S0022-0000(71)80014-4" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1016&#x2F;S0022-0000(71)80014-4</a><p>[3] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1007&#x2F;BF02242355" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1007&#x2F;BF02242355</a><p>[4] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1090&#x2F;S0025-5718-1965-0178586-1" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1090&#x2F;S0025-5718-1965-0178586-1</a></div><br/><div id="40842967" class="c"><input type="checkbox" id="c-40842967" checked=""/><div class="controls bullet"><span class="by">sigil</span><span>|</span><a href="#40841600">root</a><span>|</span><a href="#40841798">parent</a><span>|</span><a href="#40841771">next</a><span>|</span><label class="collapse" for="c-40842967">[-]</label><label class="expand" for="c-40842967">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!</div><br/></div></div></div></div><div id="40841771" class="c"><input type="checkbox" id="c-40841771" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#40841600">parent</a><span>|</span><a href="#40841798">prev</a><span>|</span><a href="#40841680">next</a><span>|</span><label class="collapse" for="c-40841771">[-]</label><label class="expand" for="c-40841771">[1 more]</label></div><br/><div class="children"><div class="content">Earliest maybe Gentleman and Sande from 1966 and a kickass title (for &#x27;66) - &quot;Fast Fourier Transforms: for fun and profit&quot;<p><a href="https:&#x2F;&#x2F;www.cis.rit.edu&#x2F;class&#x2F;simg716&#x2F;FFT_Fun_Profit.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cis.rit.edu&#x2F;class&#x2F;simg716&#x2F;FFT_Fun_Profit.pdf</a></div><br/></div></div><div id="40841680" class="c"><input type="checkbox" id="c-40841680" checked=""/><div class="controls bullet"><span class="by">cornstalks</span><span>|</span><a href="#40841600">parent</a><span>|</span><a href="#40841771">prev</a><span>|</span><a href="#40842639">next</a><span>|</span><label class="collapse" for="c-40841680">[-]</label><label class="expand" for="c-40841680">[1 more]</label></div><br/><div class="children"><div class="content">The Schönhage–Strassen algorithm from 1971 is basically a polynomial multiplication using FFTs: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Sch%C3%B6nhage%E2%80%93Strassen_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Sch%C3%B6nhage%E2%80%93Stras...</a></div><br/></div></div></div></div><div id="40842639" class="c"><input type="checkbox" id="c-40842639" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40841600">prev</a><span>|</span><a href="#40842323">next</a><span>|</span><label class="collapse" for="c-40842639">[-]</label><label class="expand" for="c-40842639">[1 more]</label></div><br/><div class="children"><div class="content">Another FFT trick applies well here: the middle vector multiplication can be folded into the last stage of the FFT and first stage of the IFFT. This saves writing these two stages out two stages to memory.</div><br/></div></div><div id="40842323" class="c"><input type="checkbox" id="c-40842323" checked=""/><div class="controls bullet"><span class="by">eranation</span><span>|</span><a href="#40842639">prev</a><span>|</span><a href="#40842202">next</a><span>|</span><label class="collapse" for="c-40842323">[-]</label><label class="expand" for="c-40842323">[2 more]</label></div><br/><div class="children"><div class="content">The key ”trick” of the operation seems to be this revelation:<p>&gt; In other words, performing the convolution of two signals in time domain is equivalent to multiplying them in the frequency domain.<p>Great article, as it breaks down a complex idea into much smaller steps that even my math challenged mind can somehow grasp, but did I miss a step? Or is it left as an exercise to the reader to look up? I was already stretching my math ability to that point, but it felt a little bit like - “and then, draw the rest of the F-ing owl” to me. Is it just me?<p>Great writing otherwise.</div><br/><div id="40843632" class="c"><input type="checkbox" id="c-40843632" checked=""/><div class="controls bullet"><span class="by">clearprop</span><span>|</span><a href="#40842323">parent</a><span>|</span><a href="#40842202">next</a><span>|</span><label class="collapse" for="c-40843632">[-]</label><label class="expand" for="c-40843632">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! In case it helps:
* Multiplying two polynomials as taught in school is in reality a convolution.
* &quot;performing the convolution of two signals in the time domain is equivalent to multiplying them in the frequency domain&quot;
* FFT allows us to convert from time domain to frequency domain
* We use FFT to convert our polynomial to frequency domain.
* If we are now in the frequency domain, we just need to multiply. Faster than a convolution.<p>Does it clarify the missing step? Happy to update the post with what&#x27;s missing.</div><br/></div></div></div></div><div id="40842202" class="c"><input type="checkbox" id="c-40842202" checked=""/><div class="controls bullet"><span class="by">joe_the_user</span><span>|</span><a href="#40842323">prev</a><span>|</span><a href="#40840698">next</a><span>|</span><label class="collapse" for="c-40842202">[-]</label><label class="expand" for="c-40842202">[4 more]</label></div><br/><div class="children"><div class="content">Sure, the naive method of multiplying polynomials is slow in the degree of the polynomial. But when does one have to deal with two degree 100 polynomials?<p>My impression is that this sort of method isn&#x27;t used by computer algebra system for this reason.</div><br/><div id="40842451" class="c"><input type="checkbox" id="c-40842451" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#40842202">parent</a><span>|</span><a href="#40842630">next</a><span>|</span><label class="collapse" for="c-40842451">[-]</label><label class="expand" for="c-40842451">[1 more]</label></div><br/><div class="children"><div class="content">Computer algebra systems (such as chebfun in Matlab) convert arbitrary functions to 100-degree+ polynomials to make it easier to find roots, optima, etc.</div><br/></div></div><div id="40842630" class="c"><input type="checkbox" id="c-40842630" checked=""/><div class="controls bullet"><span class="by">imjonse</span><span>|</span><a href="#40842202">parent</a><span>|</span><a href="#40842451">prev</a><span>|</span><a href="#40842236">next</a><span>|</span><label class="collapse" for="c-40842630">[-]</label><label class="expand" for="c-40842630">[1 more]</label></div><br/><div class="children"><div class="content">This convolutional view and fast GPU kernels for FFT were used in some pre-Mamba state space models for long sequence modeling where the polynomial is the input sequence. The Hazy Research blog posts from 2020-2023 have a lot of information on this approach.</div><br/></div></div><div id="40842236" class="c"><input type="checkbox" id="c-40842236" checked=""/><div class="controls bullet"><span class="by">citizen_friend</span><span>|</span><a href="#40842202">parent</a><span>|</span><a href="#40842630">prev</a><span>|</span><a href="#40840698">next</a><span>|</span><label class="collapse" for="c-40842236">[-]</label><label class="expand" for="c-40842236">[1 more]</label></div><br/><div class="children"><div class="content">Now do 1000. That’s kind of the whole point. Quadratic works fine until it sneaks up on you.</div><br/></div></div></div></div><div id="40840698" class="c"><input type="checkbox" id="c-40840698" checked=""/><div class="controls bullet"><span class="by">bjornsing</span><span>|</span><a href="#40842202">prev</a><span>|</span><a href="#40841046">next</a><span>|</span><label class="collapse" for="c-40840698">[-]</label><label class="expand" for="c-40840698">[1 more]</label></div><br/><div class="children"><div class="content">Funny feeling: Looking at the title I felt a bit puzzled. Then scrolling the article the concepts and their (well known) connections came back to me.</div><br/></div></div><div id="40841046" class="c"><input type="checkbox" id="c-40841046" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#40840698">prev</a><span>|</span><label class="collapse" for="c-40841046">[-]</label><label class="expand" for="c-40841046">[3 more]</label></div><br/><div class="children"><div class="content">I think that all machine learning is solving a convolutional equation.<p>This paper talks about it in the context of RL <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1712.06115" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1712.06115</a> but most approaches fit within that paradigm.</div><br/><div id="40841134" class="c"><input type="checkbox" id="c-40841134" checked=""/><div class="controls bullet"><span class="by">salty_biscuits</span><span>|</span><a href="#40841046">parent</a><span>|</span><label class="collapse" for="c-40841134">[-]</label><label class="expand" for="c-40841134">[2 more]</label></div><br/><div class="children"><div class="content">Basically kernel methods right?</div><br/><div id="40841196" class="c"><input type="checkbox" id="c-40841196" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#40841046">root</a><span>|</span><a href="#40841134">parent</a><span>|</span><label class="collapse" for="c-40841196">[-]</label><label class="expand" for="c-40841196">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is there. There might be more.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>