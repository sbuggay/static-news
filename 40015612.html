<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712998867886" as="style"/><link rel="stylesheet" href="styles.css?v=1712998867886"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.gypsydave5.com/posts/2024/4/12/htmx-and-the-rule-of-least-power/">Htmx and the Rule of Least Power</a> <span class="domain">(<a href="https://blog.gypsydave5.com">blog.gypsydave5.com</a>)</span></div><div class="subtext"><span>alexzeitler</span> | <span>57 comments</span></div><br/><div><div id="40021599" class="c"><input type="checkbox" id="c-40021599" checked=""/><div class="controls bullet"><span class="by">qwertyuiop12</span><span>|</span><a href="#40021565">next</a><span>|</span><label class="collapse" for="c-40021599">[-]</label><label class="expand" for="c-40021599">[1 more]</label></div><br/><div class="children"><div class="content">These years I tried many approaches and I felt in love with htmx for my side projects.<p>It’s a return to the old easy times.<p>However, many times I only use a small subset of it.<p>I recommend to begin with small steps and increasing the complexity a little bit on each one before being crazy applying ALL for a “to-do” app: pure html, htmz (a tricky way, TAKE A LOOK), htmx and react or whatever.<p>Finally, I also recommend to follow htmx in Twitter, you will laugh a lot.</div><br/></div></div><div id="40021565" class="c"><input type="checkbox" id="c-40021565" checked=""/><div class="controls bullet"><span class="by">marban</span><span>|</span><a href="#40021599">prev</a><span>|</span><a href="#40019910">next</a><span>|</span><label class="collapse" for="c-40021565">[-]</label><label class="expand" for="c-40021565">[1 more]</label></div><br/><div class="children"><div class="content">Litestar has HTMX integration: <a href="https:&#x2F;&#x2F;docs.litestar.dev&#x2F;2&#x2F;usage&#x2F;htmx.html" rel="nofollow">https:&#x2F;&#x2F;docs.litestar.dev&#x2F;2&#x2F;usage&#x2F;htmx.html</a></div><br/></div></div><div id="40019910" class="c"><input type="checkbox" id="c-40019910" checked=""/><div class="controls bullet"><span class="by">darkteflon</span><span>|</span><a href="#40021565">prev</a><span>|</span><a href="#40021553">next</a><span>|</span><label class="collapse" for="c-40019910">[-]</label><label class="expand" for="c-40019910">[10 more]</label></div><br/><div class="children"><div class="content">I work mainly on the back end but do need to do front end stuff from time to time. Having had my eye on Htmx for quite a while, and having recently gone through a painfully breaking NextJS update, I’m seriously considering going all in on it.<p>From people who have made the switch: any regrets? Any sharp edges? Can I still use all my Tailwind components without issue?</div><br/><div id="40021210" class="c"><input type="checkbox" id="c-40021210" checked=""/><div class="controls bullet"><span class="by">simonbarker87</span><span>|</span><a href="#40019910">parent</a><span>|</span><a href="#40020672">next</a><span>|</span><label class="collapse" for="c-40021210">[-]</label><label class="expand" for="c-40021210">[1 more]</label></div><br/><div class="children"><div class="content">I use it for our internal app that staff use and it’s brilliant. The sharp edge is probably getting your head back round server side rendering if you’ve been in SPA land for a long time.<p>I use Tailwind with out a problem, I don’t use components - assuming they are JSX components you’ll just need to investigate a server side way to turn that JSX component into html so that when the client receives it htmx can insert it into the dom and bind everything … I think?<p>Best bet is to head over to the htmx Discord as they are very helpful in there.<p>The thing I like the most is loading tabular data. With react you need to paginate way earlier than just a plain old html table, browsers are really fast at just displaying a tonne of html. If you do need to paginate then htmx supports infinite scroll with about 20 characters of code!</div><br/></div></div><div id="40020672" class="c"><input type="checkbox" id="c-40020672" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#40019910">parent</a><span>|</span><a href="#40021210">prev</a><span>|</span><a href="#40021015">next</a><span>|</span><label class="collapse" for="c-40020672">[-]</label><label class="expand" for="c-40020672">[2 more]</label></div><br/><div class="children"><div class="content">HTMX gets all the hype right now, but there are other tools in the same vein, my favorite being Unpoly (<a href="https:&#x2F;&#x2F;unpoly.com" rel="nofollow">https:&#x2F;&#x2F;unpoly.com</a>). Together with Shoelace (<a href="https:&#x2F;&#x2F;shoelace.style" rel="nofollow">https:&#x2F;&#x2F;shoelace.style</a>) you get nice GUIs real fast, without the burden of complicated dependency management and build steps. Also, you don&#x27;t have to write a lot of JS, just what is needed for small enhancements, as it was meant to be. Some might say the main drawback is the tight coupling to your backend. In my case, this is also the main benefit as it integrates perfectly with the backend framework (Django).</div><br/><div id="40021066" class="c"><input type="checkbox" id="c-40021066" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#40019910">root</a><span>|</span><a href="#40020672">parent</a><span>|</span><a href="#40021015">next</a><span>|</span><label class="collapse" for="c-40021066">[-]</label><label class="expand" for="c-40021066">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this. I was going to ask how Shoelace compares to Lit but I see it&#x27;s built on top of it.</div><br/></div></div></div></div><div id="40021015" class="c"><input type="checkbox" id="c-40021015" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40019910">parent</a><span>|</span><a href="#40020672">prev</a><span>|</span><a href="#40019973">next</a><span>|</span><label class="collapse" for="c-40021015">[-]</label><label class="expand" for="c-40021015">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used HTMX to create an internal app for us to manage Pull Requests from multiple repositories in a single page.<p>It works great, after you get used to how it expects things to work. Basically, think like every HTML element can be a little &quot;form&quot; which you can submit and replace its contents with the returned HTML.<p>In the server it&#x27;s not hard to get it to work, I implemented it using Kotlin&#x27;s KTor (but any server technology that lets you generate HTML would work).<p>I still needed a very minimal amount of JS to do some things that I found annoying to do with HTMX (e.g. in-page filtering), but once I accepted that&#x27;s ok, it&#x27;s been working very well.</div><br/></div></div><div id="40019973" class="c"><input type="checkbox" id="c-40019973" checked=""/><div class="controls bullet"><span class="by">hruk</span><span>|</span><a href="#40019910">parent</a><span>|</span><a href="#40021015">prev</a><span>|</span><a href="#40021462">next</a><span>|</span><label class="collapse" for="c-40019973">[-]</label><label class="expand" for="c-40019973">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used HTMX quite frequently recently for internal frontends (admin pages, reporting, etc.). It&#x27;s quite good.<p>A pattern I&#x27;ve been using a lot is not changing the backend at all - each endpoint still returns the full page. Each hypermedia control makes liberal use of hx-select and hx-select-oob to update the elements that may have changed.<p>This isn&#x27;t super efficient, but it provides some &quot;locality of behavior&quot; in that you can look at a hypermedia control and know what other elements might be changed by it. It also means the backend doesn&#x27;t really need to &quot;know&quot; about HTMX.</div><br/></div></div><div id="40021462" class="c"><input type="checkbox" id="c-40021462" checked=""/><div class="controls bullet"><span class="by">pjs_</span><span>|</span><a href="#40019910">parent</a><span>|</span><a href="#40019973">prev</a><span>|</span><a href="#40021126">next</a><span>|</span><label class="collapse" for="c-40021462">[-]</label><label class="expand" for="c-40021462">[1 more]</label></div><br/><div class="children"><div class="content">We use it for a fairly chaotic internal CRUD tool together with Flask and Postgres.<p>Basically there&#x27;s stuff on my big computer, and it needs to get onto some other guys&#x27; small computers. Sometimes the small computers need just a little bit of stuff from the big computer, or they want to tell the big computer something. If you put HTMX on the small computers, they can talk to the big computer and ask for bits of stuff whenever they want. And my nice big computer can do all the thinking, and I can tell it how to think, and the small computers aren&#x27;t expected to think much, they just do what the guys say mostly.<p>This is great, and to me much better than the alternative which is that in addition to having to make the big computer think straight, I also have to install fucking npm on my own   computer so that for every single feature I can write a turing-complete piece of thinking sludge which then goes onto hundreds of the other guys&#x27; small computers and tries to think for itself and breaks. Now I&#x27;ve got a big computer thinking, a hundred small computers thinking, and all these dumb guys thinking too. And I&#x27;m trying to think about what they all might be thinking and how that all interacts, fucking nightmare.<p>HTMX means that only the big computer is going to do any serious thinking, and the small computer only has HTMX, so it&#x27;s too dumb to think. And so when I am thinking about the computers, I don&#x27;t have to imagine what two computers might be thinking - only one.<p>Did you know that if you want to run a program in the terminal on your own computer, in order to make programs for other guys small computers, you should say &quot;npx&quot; not &quot;node&quot;? Even though they both execute code? If you don&#x27;t know this innately, a priori, unfortunately you are the programmer equivalent of a stray dog or sewer-dwelling rodent. Oh and did you know that it&#x27;s important to learn &quot;type script&quot;? Ah yes just what a language (or languages) made out of warm toffee needs, homotopy type theory. It will be so awesome when my IDE can render a little intellisense hint thing of the compound &quot;List of List of Errors&quot; type I just invented and finally I won&#x27;t need to understand what the computer is thinking but can still commit a shit load of formally self-consistent code to prod. Statements dreamed up by the utterly deranged.<p>Anyway HTMX is very good in my opinion. One pjs_ Top Tip is that you can write less code if you make your server-side endpoints either return the full template or a partial component depending on the whether the HX-Request HTTP header is present or not - saves writing two different endpoints for the full page vs partials.</div><br/></div></div><div id="40021126" class="c"><input type="checkbox" id="c-40021126" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40019910">parent</a><span>|</span><a href="#40021462">prev</a><span>|</span><a href="#40020578">next</a><span>|</span><label class="collapse" for="c-40021126">[-]</label><label class="expand" for="c-40021126">[1 more]</label></div><br/><div class="children"><div class="content">One thing which worries me is GitHub issues (including mine, it’s just a doc issue) don’t seem to be getting much feedback, not sure how big the dev team is.<p>I’m still using htmx, and enjoying it, just raising a concern as you asked.</div><br/></div></div><div id="40020578" class="c"><input type="checkbox" id="c-40020578" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#40019910">parent</a><span>|</span><a href="#40021126">prev</a><span>|</span><a href="#40021553">next</a><span>|</span><label class="collapse" for="c-40020578">[-]</label><label class="expand" for="c-40020578">[2 more]</label></div><br/><div class="children"><div class="content">I toyed around with it, but ended up using server-side rendered interactive Blazor. That’s pretty much the same concept as HTMX, but has a larger ecosystem and more flexibility in some ways.</div><br/><div id="40021187" class="c"><input type="checkbox" id="c-40021187" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40019910">root</a><span>|</span><a href="#40020578">parent</a><span>|</span><a href="#40021553">next</a><span>|</span><label class="collapse" for="c-40021187">[-]</label><label class="expand" for="c-40021187">[1 more]</label></div><br/><div class="children"><div class="content">Blazor is more brittle.</div><br/></div></div></div></div></div></div><div id="40021553" class="c"><input type="checkbox" id="c-40021553" checked=""/><div class="controls bullet"><span class="by">selfie</span><span>|</span><a href="#40019910">prev</a><span>|</span><a href="#40021356">next</a><span>|</span><label class="collapse" for="c-40021553">[-]</label><label class="expand" for="c-40021553">[1 more]</label></div><br/><div class="children"><div class="content">The rule of least power (a bit like the principle of least privilege) is a great thing for both security and understandability of code.</div><br/></div></div><div id="40021356" class="c"><input type="checkbox" id="c-40021356" checked=""/><div class="controls bullet"><span class="by">zadler</span><span>|</span><a href="#40021553">prev</a><span>|</span><a href="#40021044">next</a><span>|</span><label class="collapse" for="c-40021356">[-]</label><label class="expand" for="c-40021356">[3 more]</label></div><br/><div class="children"><div class="content">There does seem to be a little sleight of hand going on, since much of the work that you do in react is rendering, and with HTMX you’re just shifting that to the server.<p>Is a lighter client and heavier server a good thing? Not always… look at Web3 for example, where many apps can be written against a blockchain and no server at all.</div><br/><div id="40021569" class="c"><input type="checkbox" id="c-40021569" checked=""/><div class="controls bullet"><span class="by">selfie</span><span>|</span><a href="#40021356">parent</a><span>|</span><a href="#40021523">next</a><span>|</span><label class="collapse" for="c-40021569">[-]</label><label class="expand" for="c-40021569">[1 more]</label></div><br/><div class="children"><div class="content">A HTMX-y app will typically be a fetch-heavy app. Think TODO list, where each time you add a todo, you want that persisted on the server anyway. Yes you are sending more down the wire. I doubt rendering a partial HTML template is that much more work than formatting JSON but there is more crap to send down the line for sure.<p>Where the application is doing lots of micro-level stuff, like maybe you are drawing on a canvas and occasionally sending a payload of updates to a server, I think then HTMX would be much slower and clunkier, and that is when you dust off your React.</div><br/></div></div><div id="40021523" class="c"><input type="checkbox" id="c-40021523" checked=""/><div class="controls bullet"><span class="by">zadler</span><span>|</span><a href="#40021356">parent</a><span>|</span><a href="#40021569">prev</a><span>|</span><a href="#40021044">next</a><span>|</span><label class="collapse" for="c-40021523">[-]</label><label class="expand" for="c-40021523">[1 more]</label></div><br/><div class="children"><div class="content">Htmx: I feel sorry for you<p>React: I don’t think about you at all</div><br/></div></div></div></div><div id="40021044" class="c"><input type="checkbox" id="c-40021044" checked=""/><div class="controls bullet"><span class="by">s4i</span><span>|</span><a href="#40021356">prev</a><span>|</span><a href="#40021325">next</a><span>|</span><label class="collapse" for="c-40021044">[-]</label><label class="expand" for="c-40021044">[7 more]</label></div><br/><div class="children"><div class="content">&gt; suggests choosing the least powerful [computer] language suitable for a given purpose<p>This doesn’t work for projects that are planned to live for years and we aren’t sure of the scope of it beyond the next few months.<p>You may feel you completed all the current features neatly with HTMX or whatever, but what happens when later your PM or designer asks your team to implement, say, a complex multi-step form with a bunch of frontend state and validations?<p>People downplaying the need for tools like React and Next.js don’t usually acknowledge that these tools are used to ensure long-term flexibility of your tech stack and to maximize the talent pool to draw engineers from. It doesn’t matter if your site is slightly less broken for the few people that turn JavaScript off in their browsers.</div><br/><div id="40021070" class="c"><input type="checkbox" id="c-40021070" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#40021044">parent</a><span>|</span><a href="#40021123">next</a><span>|</span><label class="collapse" for="c-40021070">[-]</label><label class="expand" for="c-40021070">[2 more]</label></div><br/><div class="children"><div class="content">Are you recommending Next.js for its longevity? My experience over the last 18 months is that every new version introduces breaking changes. I wouldn’t want to come back to a Next.js project in 5 years and have to deal with migrating to Node.js v32 and whatever Next.js has broken in the meantime.</div><br/><div id="40021118" class="c"><input type="checkbox" id="c-40021118" checked=""/><div class="controls bullet"><span class="by">s4i</span><span>|</span><a href="#40021044">root</a><span>|</span><a href="#40021070">parent</a><span>|</span><a href="#40021123">next</a><span>|</span><label class="collapse" for="c-40021118">[-]</label><label class="expand" for="c-40021118">[1 more]</label></div><br/><div class="children"><div class="content">Don’t get me wrong, I’m not a Next.js fan either. Could’ve widened my list of examples to any SPA libraries and server-side JS frameworks. I just wanted to highlight the issue with the analogy: unlike some criminal a police officer is using force against, the nature of issues to be tackled in most software projects will keep changing.</div><br/></div></div></div></div><div id="40021123" class="c"><input type="checkbox" id="c-40021123" checked=""/><div class="controls bullet"><span class="by">ehnto</span><span>|</span><a href="#40021044">parent</a><span>|</span><a href="#40021070">prev</a><span>|</span><a href="#40021500">next</a><span>|</span><label class="collapse" for="c-40021123">[-]</label><label class="expand" for="c-40021123">[3 more]</label></div><br/><div class="children"><div class="content">Long term flexibility is a very surprising way to describe a JS stack. They are easy to build in, but there is nothing robust about the ecosystem. When in 5 years a PM asks me to add that simple multi step form, I&#x27;ll probably have to tell them it&#x27;s blocked by replacing deprecated dependcies and our validation library doesn&#x27;t support our new element types so we need to rewrite all the validation across the site to use a new library... man I feel a burnout coming on.<p>My counter-argument is that the simplest tool has the largest chance of not breaking over long periods of time. I have dynamic websites I built 10 years ago that still run almost untouched because I used the simplest stack possible.<p>Contrasting that, in the commercial software world we rebuild from the ground up in 1-5 years, and we aren&#x27;t even building complex things. Same level of interaction, but a stack that has an enormous complexity and web of dependencies and moving targets that absolutely require a steady hand on the maintenance wheel. Your examplen scenario is not that scary, we have been building that kind of UX long before React and friends.<p>Your final comment about people who disable javascript is disappointing, but an opinion you likely share with many PMs. I would recommend a look into accessibility, and also try to see why people might advocate for graceful degradation.</div><br/><div id="40021472" class="c"><input type="checkbox" id="c-40021472" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#40021044">root</a><span>|</span><a href="#40021123">parent</a><span>|</span><a href="#40021500">next</a><span>|</span><label class="collapse" for="c-40021472">[-]</label><label class="expand" for="c-40021472">[2 more]</label></div><br/><div class="children"><div class="content">When trying HTMX, I decided to use Tailwind for layout. Tailwind requires npm and Node to work. It was my first experience with Node. I already had some Node version installed on my machine. Running Tailwind gave some vague &quot;Unexpected token ?&quot; error and nothing else. After I bumped Node&#x27;s version, it worked. Sure not using the latest versions of the tools is a bad idea, but something from the JS ecosystem was basically the only thing in my stack which broke immediately (with a vague error, nothing like &quot;hey, old version of Node!&quot;)</div><br/><div id="40021514" class="c"><input type="checkbox" id="c-40021514" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#40021044">root</a><span>|</span><a href="#40021472">parent</a><span>|</span><a href="#40021500">next</a><span>|</span><label class="collapse" for="c-40021514">[-]</label><label class="expand" for="c-40021514">[1 more]</label></div><br/><div class="children"><div class="content">They have a standalone version of tailwind that doesn&#x27;t use node.js&#x2F;npm.<p><a href="https:&#x2F;&#x2F;tailwindcss.com&#x2F;blog&#x2F;standalone-cli" rel="nofollow">https:&#x2F;&#x2F;tailwindcss.com&#x2F;blog&#x2F;standalone-cli</a><p>It&#x27;s not as full featured, but it&#x27;s pretty good frankly for what I do with it.</div><br/></div></div></div></div></div></div><div id="40021500" class="c"><input type="checkbox" id="c-40021500" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40021044">parent</a><span>|</span><a href="#40021123">prev</a><span>|</span><a href="#40021325">next</a><span>|</span><label class="collapse" for="c-40021500">[-]</label><label class="expand" for="c-40021500">[1 more]</label></div><br/><div class="children"><div class="content">YAGNI</div><br/></div></div></div></div><div id="40021325" class="c"><input type="checkbox" id="c-40021325" checked=""/><div class="controls bullet"><span class="by">molly0</span><span>|</span><a href="#40021044">prev</a><span>|</span><a href="#40019972">next</a><span>|</span><label class="collapse" for="c-40021325">[-]</label><label class="expand" for="c-40021325">[1 more]</label></div><br/><div class="children"><div class="content">Finally an article I can reference when explaining my problems with the “modern” frontend stack.</div><br/></div></div><div id="40019972" class="c"><input type="checkbox" id="c-40019972" checked=""/><div class="controls bullet"><span class="by">seanwilson</span><span>|</span><a href="#40021325">prev</a><span>|</span><a href="#40021441">next</a><span>|</span><label class="collapse" for="c-40019972">[-]</label><label class="expand" for="c-40019972">[7 more]</label></div><br/><div class="children"><div class="content">Anyone using Django with HTMX? How are you writing UI tests for HTMX behaviour? The standard Django tests don&#x27;t run JavaScript so what do you use for this and how is the performance?</div><br/><div id="40020870" class="c"><input type="checkbox" id="c-40020870" checked=""/><div class="controls bullet"><span class="by">hellcow</span><span>|</span><a href="#40019972">parent</a><span>|</span><a href="#40020570">next</a><span>|</span><label class="collapse" for="c-40020870">[-]</label><label class="expand" for="c-40020870">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the fun part. It&#x27;s just HTML attributes, so you can test them without a full browser and JS engine. Just parse the HTML. Tests are super fast and never flaky.</div><br/><div id="40020897" class="c"><input type="checkbox" id="c-40020897" checked=""/><div class="controls bullet"><span class="by">seanwilson</span><span>|</span><a href="#40019972">root</a><span>|</span><a href="#40020870">parent</a><span>|</span><a href="#40020570">next</a><span>|</span><label class="collapse" for="c-40020897">[-]</label><label class="expand" for="c-40020897">[2 more]</label></div><br/><div class="children"><div class="content">But how are you checking that e.g. on submit the HTMX replaced the correct selector inside another form and that on submitting that form HTMX uses a HX-Redirect header to send you to the right page? If you&#x27;re not testing that, don&#x27;t you get cases of tests passing when the UI is actually broken in the browser?</div><br/><div id="40021385" class="c"><input type="checkbox" id="c-40021385" checked=""/><div class="controls bullet"><span class="by">shicholas</span><span>|</span><a href="#40019972">root</a><span>|</span><a href="#40020897">parent</a><span>|</span><a href="#40020570">next</a><span>|</span><label class="collapse" for="c-40021385">[-]</label><label class="expand" for="c-40021385">[1 more]</label></div><br/><div class="children"><div class="content">We can use playwright for these type of tests and still stay almost entirely in Python.</div><br/></div></div></div></div></div></div><div id="40020570" class="c"><input type="checkbox" id="c-40020570" checked=""/><div class="controls bullet"><span class="by">fancy_pantser</span><span>|</span><a href="#40019972">parent</a><span>|</span><a href="#40020870">prev</a><span>|</span><a href="#40021441">next</a><span>|</span><label class="collapse" for="c-40020570">[-]</label><label class="expand" for="c-40020570">[3 more]</label></div><br/><div class="children"><div class="content">Are you looking for something like Playwright or Cypress for end-to-end testing?</div><br/><div id="40020899" class="c"><input type="checkbox" id="c-40020899" checked=""/><div class="controls bullet"><span class="by">seanwilson</span><span>|</span><a href="#40019972">root</a><span>|</span><a href="#40020570">parent</a><span>|</span><a href="#40021441">next</a><span>|</span><label class="collapse" for="c-40020899">[-]</label><label class="expand" for="c-40020899">[2 more]</label></div><br/><div class="children"><div class="content">As close to end-to-end as practical.  Playwright seems a lot heavier than standard Django tests.</div><br/><div id="40021470" class="c"><input type="checkbox" id="c-40021470" checked=""/><div class="controls bullet"><span class="by">dqv</span><span>|</span><a href="#40019972">root</a><span>|</span><a href="#40020899">parent</a><span>|</span><a href="#40021441">next</a><span>|</span><label class="collapse" for="c-40021470">[-]</label><label class="expand" for="c-40021470">[1 more]</label></div><br/><div class="children"><div class="content">I think I might give it a try in one of my Django projects. In Elixirland we can use Wallaby to test LiveView. This example that uses Playwright with Django has very similar ergonomics: <a href="https:&#x2F;&#x2F;github.com&#x2F;mxschmitt&#x2F;python-django-playwright&#x2F;blob&#x2F;master&#x2F;test_login.py">https:&#x2F;&#x2F;github.com&#x2F;mxschmitt&#x2F;python-django-playwright&#x2F;blob&#x2F;m...</a></div><br/></div></div></div></div></div></div></div></div><div id="40021441" class="c"><input type="checkbox" id="c-40021441" checked=""/><div class="controls bullet"><span class="by">BillyTheKing</span><span>|</span><a href="#40019972">prev</a><span>|</span><a href="#40020679">next</a><span>|</span><label class="collapse" for="c-40021441">[-]</label><label class="expand" for="c-40021441">[2 more]</label></div><br/><div class="children"><div class="content">sooo much effort is going into saving a few milliseconds either by rendering code in the browser or on the server - honestly who actually cares.. I like react because of JSX which I prefer to just normal HTML, but whether that&#x27;s rendered in the browser, or on the server, also ok to ditch the whole thing and replace it with templating.<p>The actually difficult problem is hardly being addressed though, namely globally distributed data stores, especially with distributed writes. That&#x27;s the hard problem, I haven&#x27;t really seen a very convincing solution yet for normal &#x27;web-apps&#x27;</div><br/><div id="40021498" class="c"><input type="checkbox" id="c-40021498" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40021441">parent</a><span>|</span><a href="#40020679">next</a><span>|</span><label class="collapse" for="c-40021498">[-]</label><label class="expand" for="c-40021498">[1 more]</label></div><br/><div class="children"><div class="content">If you think it only takes &quot;a few milliseconds&quot; to render a modern web app, I understand why modern web apps apps are as slow as they are.</div><br/></div></div></div></div><div id="40020679" class="c"><input type="checkbox" id="c-40020679" checked=""/><div class="controls bullet"><span class="by">gofreddygo</span><span>|</span><a href="#40021441">prev</a><span>|</span><a href="#40020425">next</a><span>|</span><label class="collapse" for="c-40020679">[-]</label><label class="expand" for="c-40020679">[7 more]</label></div><br/><div class="children"><div class="content">Ok I&#x27;ll just say it, why not use jquery instead ?</div><br/><div id="40021094" class="c"><input type="checkbox" id="c-40021094" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40020679">parent</a><span>|</span><a href="#40021088">next</a><span>|</span><label class="collapse" for="c-40021094">[-]</label><label class="expand" for="c-40021094">[3 more]</label></div><br/><div class="children"><div class="content">With JQuery you&#x27;re still writing JS to do everything.
With HTMX, you write almost no JS. You write HTML which contains some directives like &quot;hx-post=&#x27;&#x2F;clicked&#x27;&quot; which will make a POST request to the `&#x2F;clicked` URL path, similar to how HTML forms already work... and then you write the logic to generate more HTML in the server. That is: the server becomes responsible for the logic, not the client.<p>You can still do JS on the client here and there, but that becomes much less needed.</div><br/><div id="40021331" class="c"><input type="checkbox" id="c-40021331" checked=""/><div class="controls bullet"><span class="by">preommr</span><span>|</span><a href="#40020679">root</a><span>|</span><a href="#40021094">parent</a><span>|</span><a href="#40021088">next</a><span>|</span><label class="collapse" for="c-40021331">[-]</label><label class="expand" for="c-40021331">[2 more]</label></div><br/><div class="children"><div class="content">&gt; With JQuery you&#x27;re still writing JS to do everything. With HTMX, you write almost no JS.<p>...instead write it in htmx, and html partials server-side using a templating library. What could possibly be wrong with splitting up the presentation logic and spreading it throughout the backend instead of just writing a little bit of javascript?</div><br/><div id="40021539" class="c"><input type="checkbox" id="c-40021539" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#40020679">root</a><span>|</span><a href="#40021331">parent</a><span>|</span><a href="#40021088">next</a><span>|</span><label class="collapse" for="c-40021539">[-]</label><label class="expand" for="c-40021539">[1 more]</label></div><br/><div class="children"><div class="content">No need to build and maintain a whole api layer?<p>One code base rather than two?<p>Simple pages become simple again?</div><br/></div></div></div></div></div></div><div id="40021088" class="c"><input type="checkbox" id="c-40021088" checked=""/><div class="controls bullet"><span class="by">PetitPrince</span><span>|</span><a href="#40020679">parent</a><span>|</span><a href="#40021094">prev</a><span>|</span><a href="#40020776">next</a><span>|</span><label class="collapse" for="c-40021088">[-]</label><label class="expand" for="c-40021088">[1 more]</label></div><br/><div class="children"><div class="content">An early version of Htmx was in fact based on jQuery (<a href="https:&#x2F;&#x2F;intercoolerjs.org" rel="nofollow">https:&#x2F;&#x2F;intercoolerjs.org</a>).</div><br/></div></div><div id="40020776" class="c"><input type="checkbox" id="c-40020776" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#40020679">parent</a><span>|</span><a href="#40021088">prev</a><span>|</span><a href="#40020425">next</a><span>|</span><label class="collapse" for="c-40020776">[-]</label><label class="expand" for="c-40020776">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t personally used htmx(I use Vue and also like Svelte, and try to keep simple content in Markdown), but it seems declarative.<p>I assume the compiler can give warnings at compile time?</div><br/><div id="40021082" class="c"><input type="checkbox" id="c-40021082" checked=""/><div class="controls bullet"><span class="by">lgas</span><span>|</span><a href="#40020679">root</a><span>|</span><a href="#40020776">parent</a><span>|</span><a href="#40020425">next</a><span>|</span><label class="collapse" for="c-40021082">[-]</label><label class="expand" for="c-40021082">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no compiler or compile time.</div><br/></div></div></div></div></div></div><div id="40020425" class="c"><input type="checkbox" id="c-40020425" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#40020679">prev</a><span>|</span><a href="#40021412">next</a><span>|</span><label class="collapse" for="c-40020425">[-]</label><label class="expand" for="c-40020425">[15 more]</label></div><br/><div class="children"><div class="content">We did this 20 years ago and you just end up with piles of unmaintainable partials all just used for a single page.<p>It&#x27;s far better to use something that at least embeds the templates in the web page with some simple js to show it (eg alpinejs) and a simple, private API.</div><br/><div id="40021336" class="c"><input type="checkbox" id="c-40021336" checked=""/><div class="controls bullet"><span class="by">fzumstein</span><span>|</span><a href="#40020425">parent</a><span>|</span><a href="#40020625">next</a><span>|</span><label class="collapse" for="c-40021336">[-]</label><label class="expand" for="c-40021336">[1 more]</label></div><br/><div class="children"><div class="content">For the Python&#x2F;Jinja world, there is Jinja2-fragments that allows you to return blocks of the template without having to extract it to partials. I am sure there are similar solutions for other template languages. See <a href="https:&#x2F;&#x2F;github.com&#x2F;sponsfreixes&#x2F;jinja2-fragments">https:&#x2F;&#x2F;github.com&#x2F;sponsfreixes&#x2F;jinja2-fragments</a>.</div><br/></div></div><div id="40020625" class="c"><input type="checkbox" id="c-40020625" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40020425">parent</a><span>|</span><a href="#40021336">prev</a><span>|</span><a href="#40020595">next</a><span>|</span><label class="collapse" for="c-40020625">[-]</label><label class="expand" for="c-40020625">[4 more]</label></div><br/><div class="children"><div class="content">How does your solution fix the issue you described? You still need a pile of partials, they&#x27;re just moving where they&#x27;re rendered.</div><br/><div id="40020915" class="c"><input type="checkbox" id="c-40020915" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020625">parent</a><span>|</span><a href="#40020595">next</a><span>|</span><label class="collapse" for="c-40020915">[-]</label><label class="expand" for="c-40020915">[3 more]</label></div><br/><div class="children"><div class="content">You only need partials for shared templates instead of multiple per action on a single page.</div><br/><div id="40021591" class="c"><input type="checkbox" id="c-40021591" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020915">parent</a><span>|</span><a href="#40021196">next</a><span>|</span><label class="collapse" for="c-40021591">[-]</label><label class="expand" for="c-40021591">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, I don&#x27;t get it. If you have client side rendering, you need a template for every thing you want to replace, at whatever level you choose (from full page to single element). If you do htmx, you do the same - provide a template for each replaceable part (from full page to single element). In each case, it&#x27;s your choice how granular you want the updates to be - it can be one per action, or just rerendering the whole page.<p>Why do you think the client side requires fewer partials, if you use the same scope of data changes?</div><br/></div></div><div id="40021196" class="c"><input type="checkbox" id="c-40021196" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020915">parent</a><span>|</span><a href="#40021591">prev</a><span>|</span><a href="#40020595">next</a><span>|</span><label class="collapse" for="c-40021196">[-]</label><label class="expand" for="c-40021196">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need any partials at all, so this objection just doesn&#x27;t apply. The server can return full pages and only parts of it are updated.</div><br/></div></div></div></div></div></div><div id="40020595" class="c"><input type="checkbox" id="c-40020595" checked=""/><div class="controls bullet"><span class="by">d-z-m</span><span>|</span><a href="#40020425">parent</a><span>|</span><a href="#40020625">prev</a><span>|</span><a href="#40021412">next</a><span>|</span><label class="collapse" for="c-40020595">[-]</label><label class="expand" for="c-40020595">[9 more]</label></div><br/><div class="children"><div class="content">what makes it unmaintainable in your opinion?</div><br/><div id="40020744" class="c"><input type="checkbox" id="c-40020744" checked=""/><div class="controls bullet"><span class="by">gedy</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020595">parent</a><span>|</span><a href="#40020905">next</a><span>|</span><label class="collapse" for="c-40020744">[-]</label><label class="expand" for="c-40020744">[1 more]</label></div><br/><div class="children"><div class="content">Not OP but: spreading a UI amongst a bunch of files, which themselves have server side templating and logic in them and can&#x27;t be run, imported, or tested in isolation.<p>I was never a JS fanboy but the modern JS&#x2F;TS frameworks that let you organize and test the UI without an entire system running is better for maintenance imho.</div><br/></div></div><div id="40020905" class="c"><input type="checkbox" id="c-40020905" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020595">parent</a><span>|</span><a href="#40020744">prev</a><span>|</span><a href="#40020768">next</a><span>|</span><label class="collapse" for="c-40020905">[-]</label><label class="expand" for="c-40020905">[1 more]</label></div><br/><div class="children"><div class="content">Because instead of needing separate partials for your inline edit template and all the other actions, you just stuff them into the page as hidden divs.<p>This means you have a single template per page and only need to split out partials for things that are actually shared, rather than for every action on a single page.</div><br/></div></div><div id="40020768" class="c"><input type="checkbox" id="c-40020768" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020595">parent</a><span>|</span><a href="#40020905">prev</a><span>|</span><a href="#40021412">next</a><span>|</span><label class="collapse" for="c-40020768">[-]</label><label class="expand" for="c-40020768">[6 more]</label></div><br/><div class="children"><div class="content">It’s unmaintainable when you don’t organize your endpoints well. Which is no different with React, or anything else.<p>It’s a non-point.</div><br/><div id="40020911" class="c"><input type="checkbox" id="c-40020911" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020768">parent</a><span>|</span><a href="#40021412">next</a><span>|</span><label class="collapse" for="c-40020911">[-]</label><label class="expand" for="c-40020911">[5 more]</label></div><br/><div class="children"><div class="content">No it&#x27;s a point because the number of endpoints and partials explodes to support every action in the page that uses the &quot;get HTML and replace it&quot; pattern.</div><br/><div id="40021474" class="c"><input type="checkbox" id="c-40021474" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020911">parent</a><span>|</span><a href="#40021112">next</a><span>|</span><label class="collapse" for="c-40021474">[-]</label><label class="expand" for="c-40021474">[1 more]</label></div><br/><div class="children"><div class="content">Also, when your front-end html changes, any number of these partials might have to change. Versus just returning data (json) and letting the front-end render what it needs from it. The latter seems like an obvious ideal compared to the former.</div><br/></div></div><div id="40021112" class="c"><input type="checkbox" id="c-40021112" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40020911">parent</a><span>|</span><a href="#40021474">prev</a><span>|</span><a href="#40021412">next</a><span>|</span><label class="collapse" for="c-40021112">[-]</label><label class="expand" for="c-40021112">[3 more]</label></div><br/><div class="children"><div class="content">Cant you type your partials in some way? I think for complicated things with htmx you need to write a thin layer to manage this explosion of templates.</div><br/><div id="40021188" class="c"><input type="checkbox" id="c-40021188" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40021112">parent</a><span>|</span><a href="#40021178">next</a><span>|</span><label class="collapse" for="c-40021188">[-]</label><label class="expand" for="c-40021188">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t that just pushing the complexity somewhere else? The selling point of HTMX is that it’s simple because you don’t need to deal with frameworks or JS, just write HTML! But if you have to start adding layers to support it then all that’s happening is the complexity is being moved out of the framework and into your code. Stone soup development…</div><br/></div></div><div id="40021178" class="c"><input type="checkbox" id="c-40021178" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#40020425">root</a><span>|</span><a href="#40021112">parent</a><span>|</span><a href="#40021188">prev</a><span>|</span><a href="#40021412">next</a><span>|</span><label class="collapse" for="c-40021178">[-]</label><label class="expand" for="c-40021178">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more just the fact that a single page gets unnecessarily split across multiple files (where there&#x27;s no reuse with other pages). It makes refactoring difficult and slows development IME.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40021412" class="c"><input type="checkbox" id="c-40021412" checked=""/><div class="controls bullet"><span class="by">pictur</span><span>|</span><a href="#40020425">prev</a><span>|</span><label class="collapse" for="c-40021412">[-]</label><label class="expand" for="c-40021412">[1 more]</label></div><br/><div class="children"><div class="content">You develop tools that cannot be scaled with such shitty tools and then you curse these tools.</div><br/></div></div></div></div></div></div></div></body></html>