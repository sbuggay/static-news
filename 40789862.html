<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719392515377" as="style"/><link rel="stylesheet" href="styles.css?v=1719392515377"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/glasskube/glasskube">Show HN: Glasskube – Open Source Kubernetes Package Manager, alternative to Helm</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>pmig</span> | <span>96 comments</span></div><br/><div><div id="40792931" class="c"><input type="checkbox" id="c-40792931" checked=""/><div class="controls bullet"><span class="by">guhcampos</span><span>|</span><a href="#40791997">next</a><span>|</span><label class="collapse" for="c-40792931">[-]</label><label class="expand" for="c-40792931">[31 more]</label></div><br/><div class="children"><div class="content">I think this might be a step in the right direction, but my main problem with Kubernetes package management today might not be fixable by a package manager, sadly. The biggest issue I have in my daily life is handling the multiple levels of nested YAML and the unpredictability of the results.<p>Think of an ArgoCD ApplicationSet that generates a bunch of Applications. Those Applications render a bunch of Helm charts, and inside those charts there are CRDs used by some random operator like Strimzi, Grafana or Vector.<p>Given YAML&#x27;s lack of syntax and the absense of any sort of standard for rendering templates, it&#x27;s practically impossible to know what are the actual YAML being injected in the Kubernetes API when you make a top-level change. It&#x27;s trial and error, expensive blue-green deployments and hundreds of debugging minutes all the way, every month.</div><br/><div id="40794107" class="c"><input type="checkbox" id="c-40794107" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#40792931">parent</a><span>|</span><a href="#40794176">next</a><span>|</span><label class="collapse" for="c-40794107">[-]</label><label class="expand" for="c-40794107">[17 more]</label></div><br/><div class="children"><div class="content">The wide adoption of YAML for devops adjacent tooling was a mistake.<p>I think proper programming language support is the way to go.<p>Ideally a static type system that isn&#x27;t turing complete and guaranteed to terminate. So something like starlark with types.</div><br/><div id="40795334" class="c"><input type="checkbox" id="c-40795334" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794107">parent</a><span>|</span><a href="#40794257">next</a><span>|</span><label class="collapse" for="c-40795334">[-]</label><label class="expand" for="c-40795334">[3 more]</label></div><br/><div class="children"><div class="content">The idea of declarative config is that empirically programmatic config was bad at scale.<p>If your config is the source of truth of what your infra should be, then you can use source control tools to roll back to a known good state, or to binary search for when a problem was introduced.<p>If you use programmatic config, then you can&#x27;t find out the intended state of your system without executing a program. You can&#x27;t grep through program executions in a meaningful way, especially at scale. So you can&#x27;t do even simple things like search for a string.<p>Guaranteeing termination is helpful, but it doesn&#x27;t solve the main problem that programmatic config puts a large complexity barrier between you and the ability to understand your infrastructure.<p>Tools like Helm give up a fair amount of this declarative benefit. And IMO that&#x27;s one of the reasons why it&#x27;s almost always a worse experience to use a helm chart than to just render the chart once and for all and forget Helm ever existed.</div><br/><div id="40795648" class="c"><input type="checkbox" id="c-40795648" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40795334">parent</a><span>|</span><a href="#40796114">next</a><span>|</span><label class="collapse" for="c-40795648">[-]</label><label class="expand" for="c-40795648">[1 more]</label></div><br/><div class="children"><div class="content">I think codegen&#x2F;compilation is a middle ground here. A higher level language like starlark can be compiled down to a set of instructions that provide the described guarantees.<p>This is how Pants (build system) works. You have declarative Starlark which supports basic programming semantics and this generates a state the engine reads and tries to produce.<p>I&#x27;ve been meaning to dive into jsonnet for a while but it&#x27;d be good to have a higher level representation that didn&#x27;t rely on sophisticated templating and substitution engines like current k8s.<p>Compare k8s to Terraform where you have modules, composability, variables. These can be achieved in k8s but you need to layer more tooling on (kustomize, helm, etc). There could be a richer config system than &quot;shove it in YAML&quot;<p>Things like explicit ordering and dependencies are hard to represent in pure yaml since they&#x27;re &quot;,just text fields&quot; without additional tools</div><br/></div></div><div id="40796114" class="c"><input type="checkbox" id="c-40796114" checked=""/><div class="controls bullet"><span class="by">nostrebored</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40795334">parent</a><span>|</span><a href="#40795648">prev</a><span>|</span><a href="#40794257">next</a><span>|</span><label class="collapse" for="c-40796114">[-]</label><label class="expand" for="c-40796114">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The idea of declarative config is that empirically programmatic config was bad at scale.<p>Languages can be declarative or imperative. For instance, Pulumi and CDK are declarative.<p>&gt; If you use programmatic config, then you can&#x27;t find out the intended state of your system without executing a program. You can&#x27;t grep through program executions in a meaningful way, especially at scale. So you can&#x27;t do even simple things like search for a string.<p>I don’t understand — nothing stops a language from having an intermediate compilation step that shows the intended state and is searchable. Beyond that, programmatic config means you can add in hooks to make plans or runs more interrogatable.<p>&gt; Guaranteeing termination is helpful, but it doesn&#x27;t solve the main problem that programmatic config puts a large complexity barrier between you and the ability to understand your infrastructure.<p>It seems like this is untrue — having seen templated IaC that is hundreds of thousands of lines and cdk that defers that complexity to an abstraction that I have to understand once, I’d always take the latter.<p>Agreed that helm use is a giant mistake and liability.</div><br/></div></div></div></div><div id="40794257" class="c"><input type="checkbox" id="c-40794257" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794107">parent</a><span>|</span><a href="#40795334">prev</a><span>|</span><a href="#40797409">next</a><span>|</span><label class="collapse" for="c-40794257">[-]</label><label class="expand" for="c-40794257">[4 more]</label></div><br/><div class="children"><div class="content">Have you looked at CUE? (<a href="https:&#x2F;&#x2F;cuelang.org&#x2F;docs&#x2F;concept&#x2F;the-logic-of-cue&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cuelang.org&#x2F;docs&#x2F;concept&#x2F;the-logic-of-cue&#x2F;</a>)<p>CUE is also pragmatic in that it has integrations with yaml, json, jsonschema, openapi, protobuf</div><br/><div id="40796487" class="c"><input type="checkbox" id="c-40796487" checked=""/><div class="controls bullet"><span class="by">dewbrite</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794257">parent</a><span>|</span><a href="#40797409">next</a><span>|</span><label class="collapse" for="c-40796487">[-]</label><label class="expand" for="c-40796487">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried out Pkl which is similar in spirit, and I think it&#x27;s a real solution for k8s manifests. The only thing holding it back is industry adoption imo. It&#x27;s leagues better than Helm, and mostly better than Kustomize.<p>See also: KCL, which is very similar and might _actually_ be &quot;the winner&quot;. Time will tell.</div><br/><div id="40797704" class="c"><input type="checkbox" id="c-40797704" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40796487">parent</a><span>|</span><a href="#40797409">next</a><span>|</span><label class="collapse" for="c-40797704">[-]</label><label class="expand" for="c-40797704">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t expect a winner personally, rather that there will be dozens of alternatives always. Like build systems, deployments are quite bespoke to organizations and legacy has a way of sticking around for a long time<p>Having used CUE, mainly outside of Kubernetes, I cannot see myself switching to KCL. I really like having a configuration language that isn&#x27;t so tied to a specific system and which I can use with the Go SDK</div><br/><div id="40797797" class="c"><input type="checkbox" id="c-40797797" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40797704">parent</a><span>|</span><a href="#40797409">next</a><span>|</span><label class="collapse" for="c-40797797">[-]</label><label class="expand" for="c-40797797">[1 more]</label></div><br/><div class="children"><div class="content">So whats your take on <a href="https:&#x2F;&#x2F;github.com&#x2F;stripe&#x2F;skycfg">https:&#x2F;&#x2F;github.com&#x2F;stripe&#x2F;skycfg</a> do you also have experience with it?</div><br/></div></div></div></div></div></div></div></div><div id="40797409" class="c"><input type="checkbox" id="c-40797409" checked=""/><div class="controls bullet"><span class="by">okamiueru</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794107">parent</a><span>|</span><a href="#40794257">prev</a><span>|</span><a href="#40794344">next</a><span>|</span><label class="collapse" for="c-40797409">[-]</label><label class="expand" for="c-40797409">[2 more]</label></div><br/><div class="children"><div class="content">My take on this is that the issue is not declarative infrastructure resources, but a tendency to over-complicate the infrastructure.<p>For example: You have a problem that is suitable for some message queue -&gt; Apache Kafka. Now you have 7 new problems and the complexity warrants perhaps 3 other services, and on, and on.</div><br/><div id="40797781" class="c"><input type="checkbox" id="c-40797781" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40797409">parent</a><span>|</span><a href="#40794344">next</a><span>|</span><label class="collapse" for="c-40797781">[-]</label><label class="expand" for="c-40797781">[1 more]</label></div><br/><div class="children"><div class="content">Introducing complexity is always something that needs to be introduced carefully. It makes things harder if you introduce it to early, but everything will break in a big bang if you introduce it too late.<p>Nowadays you can also start with a light weight MQ like Rabbit MQ and decouple your service just into a hand full components. This will set you up for scalability without introducing massive overheads.<p>In end it is also always a knowledge game. How experienced are you or how much time are you willing to invest into learning and understanding a technology.</div><br/></div></div></div></div><div id="40794344" class="c"><input type="checkbox" id="c-40794344" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794107">parent</a><span>|</span><a href="#40797409">prev</a><span>|</span><a href="#40794533">next</a><span>|</span><label class="collapse" for="c-40794344">[-]</label><label class="expand" for="c-40794344">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So something like starlark with types.<p>this exists for k8s[0]. there have been other users based on the same library[1], I heard reddit did something similar internally<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;cruise-automation&#x2F;isopod">https:&#x2F;&#x2F;github.com&#x2F;cruise-automation&#x2F;isopod</a>
[1] - <a href="https:&#x2F;&#x2F;github.com&#x2F;stripe&#x2F;skycfg">https:&#x2F;&#x2F;github.com&#x2F;stripe&#x2F;skycfg</a></div><br/></div></div><div id="40794533" class="c"><input type="checkbox" id="c-40794533" checked=""/><div class="controls bullet"><span class="by">davidmdm91</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794107">parent</a><span>|</span><a href="#40794344">prev</a><span>|</span><a href="#40794126">next</a><span>|</span><label class="collapse" for="c-40794533">[-]</label><label class="expand" for="c-40794533">[5 more]</label></div><br/><div class="children"><div class="content">I have been developing my own package manager, and my core idea is that proper programming languages are the proper level for describing packages.<p>Programs take inputs and can output arbitrary data such as resources. However they can do so with type safety, and everything else a programming ecosystem can achieve.<p>For asset distribution it uses wasm, and that&#x27;s it!<p>If you want to check it out its here:
github: (<a href="https:&#x2F;&#x2F;github.com&#x2F;davidmdm&#x2F;yoke">https:&#x2F;&#x2F;github.com&#x2F;davidmdm&#x2F;yoke</a>)
docs: (<a href="https:&#x2F;&#x2F;davidmdm.github.io&#x2F;yoke-website" rel="nofollow">https:&#x2F;&#x2F;davidmdm.github.io&#x2F;yoke-website</a>)<p>I like that you said:
&gt; I think proper programming language support is the way to go.<p>I think we need to stop writing new ways of generating yaml since we already have the perfect way of doing so. Typed languages!</div><br/><div id="40794584" class="c"><input type="checkbox" id="c-40794584" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794533">parent</a><span>|</span><a href="#40794126">next</a><span>|</span><label class="collapse" for="c-40794584">[-]</label><label class="expand" for="c-40794584">[4 more]</label></div><br/><div class="children"><div class="content">&gt; that isn&#x27;t turing complete and guaranteed to terminate<p>This means general purpose languages do not qualify, and more generally, no general recursion</div><br/><div id="40794717" class="c"><input type="checkbox" id="c-40794717" checked=""/><div class="controls bullet"><span class="by">davidmdm91</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794584">parent</a><span>|</span><a href="#40794126">next</a><span>|</span><label class="collapse" for="c-40794717">[-]</label><label class="expand" for="c-40794717">[3 more]</label></div><br/><div class="children"><div class="content">Why limit yourself to those types of tools?<p>To protect against somebody writing a non-terminating program?<p>General programming languages come with a lot of general purpose benefits from their ecosystems like package managers npm, cargo, go modules, etc.<p>They have test runners, and control flow.<p>Lots of them already have type definitions for kubernetes and if you are working in Go you have access to almost the entire kubernetes ecosystem.<p>Maybe we are throwing the baby out with the bath water when we disqualify general purpose languages?</div><br/><div id="40795253" class="c"><input type="checkbox" id="c-40795253" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794717">parent</a><span>|</span><a href="#40794126">next</a><span>|</span><label class="collapse" for="c-40795253">[-]</label><label class="expand" for="c-40795253">[2 more]</label></div><br/><div class="children"><div class="content">Because people write code that is hard to understand. Configuration doesn&#x27;t need all that. What it needs is to be provably correct and easy for someone to make predictable changes under high pressure (when prod is down). The non-terminating thing is one of the features of a turing incomplete language, not the goal. You don&#x27;t want inheritance either, because it becomes hard to know where and when a value gets set (which is what helm overlay via multiple -f uses effectively is)<p>You speak like turning incomplete languages cannot have the control structures, tooling, and ecosystems we enjoy elsewhere, which would be the wrong assessment. I recommend you take a look at CUE to see how this can be true<p>The OpenAPI specs are probably better than the Go language types for k8s. They have more of the validation information and you can get at the CRDs &#x2F; versions actually running in the cluster.</div><br/><div id="40795348" class="c"><input type="checkbox" id="c-40795348" checked=""/><div class="controls bullet"><span class="by">davidmdm91</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40795253">parent</a><span>|</span><a href="#40794126">next</a><span>|</span><label class="collapse" for="c-40795348">[-]</label><label class="expand" for="c-40795348">[1 more]</label></div><br/><div class="children"><div class="content">I am not saying that Turing incomplete languages don’t or can’t be a good fit for this task.<p>However there’s no reason we should rule out general purpose languages.<p>We have a lot of configuration based IaC and configuration tooling a la jsonnette and cue and yet these are riddled with their own problems and DX issues.<p>Anyways we don’t need to see eye to to eye on this but I respect your position.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40794126" class="c"><input type="checkbox" id="c-40794126" checked=""/><div class="controls bullet"><span class="by">dventimi</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794107">parent</a><span>|</span><a href="#40794533">prev</a><span>|</span><a href="#40794176">next</a><span>|</span><label class="collapse" for="c-40794126">[-]</label><label class="expand" for="c-40794126">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I think proper programming language support is the way to go.</i><p>Personally, I would prefer a SQLite database. Ok I&#x27;ll show myself out.</div><br/></div></div></div></div><div id="40794176" class="c"><input type="checkbox" id="c-40794176" checked=""/><div class="controls bullet"><span class="by">zikohh</span><span>|</span><a href="#40792931">parent</a><span>|</span><a href="#40794107">prev</a><span>|</span><a href="#40793166">next</a><span>|</span><label class="collapse" for="c-40794176">[-]</label><label class="expand" for="c-40794176">[8 more]</label></div><br/><div class="children"><div class="content">Have you tried the rendered manifests pattern ? <a href="https:&#x2F;&#x2F;akuity.io&#x2F;blog&#x2F;the-rendered-manifests-pattern&#x2F;" rel="nofollow">https:&#x2F;&#x2F;akuity.io&#x2F;blog&#x2F;the-rendered-manifests-pattern&#x2F;</a></div><br/><div id="40796156" class="c"><input type="checkbox" id="c-40796156" checked=""/><div class="controls bullet"><span class="by">rorychatt</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794176">parent</a><span>|</span><a href="#40794334">next</a><span>|</span><label class="collapse" for="c-40796156">[-]</label><label class="expand" for="c-40796156">[4 more]</label></div><br/><div class="children"><div class="content">While I agree generally with the pattern (dynamically generating manifests, and using pipelines to co-ordinate pattern change), I could never quite figure out the value of using Branches instead of Folders (with CODEOWNER restrictions) or repositories (to enforce other types of rules if needed).<p>I can&#x27;t quite put my finger on it, but having multiple, orphaned commit histories inside a single repository sounds off, even if technically feasible.</div><br/><div id="40796205" class="c"><input type="checkbox" id="c-40796205" checked=""/><div class="controls bullet"><span class="by">theptip</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40796156">parent</a><span>|</span><a href="#40794334">next</a><span>|</span><label class="collapse" for="c-40796205">[-]</label><label class="expand" for="c-40796205">[3 more]</label></div><br/><div class="children"><div class="content">I believe the idea is that it makes it very explicit to track provenance of code between environments, eg merge staging-&gt;master is a branch merge operation. And all the changes are explicitly tracked in CI as a diff.<p>With directories you need to resort to diffing to spot any changes between files in folders.<p>That said there are some merge conflict scenarios that make it a little annoying to do in practice. The author doesn’t seem to mention this one, but if you have a workflow where hotfixes can get promoted from older versions (eg prod runs 1.0.0, staging is running 1.1.0, and you need to cut 1.0.1) then you can hit merge conflicts and the dream of a simple “click to release” workflow evaporates.</div><br/><div id="40796469" class="c"><input type="checkbox" id="c-40796469" checked=""/><div class="controls bullet"><span class="by">rorychatt</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40796205">parent</a><span>|</span><a href="#40794334">next</a><span>|</span><label class="collapse" for="c-40796469">[-]</label><label class="expand" for="c-40796469">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I believe the idea is that it makes it very explicit to track provenance of code between environments, eg merge staging-&gt;master is a branch merge operation.=<p>That isn&#x27;t quite my understanding - but I am happy to be corrected.<p>There wouldn&#x27;t be be a staging-&gt;main flow. Rather CI would be pushing main-&gt;dev|staging|prod, as disconnected branches.<p>My understanding of the problem being solved, is how to see what is actually changing when moving between module versions by explicitly outputting the dynamic manifest results. I.e. instead of the commmit diff showing 4.3 -&gt; 5.0, it shows the actual Ingress &#x2F; Service &#x2F; etc being updated.<p>&gt; With directories you need to resort to diffing to spot any changes between files in folders.<p>Couldn&#x27;t you just review the Commit that instigated that change to that file? If the CI is authoring the change, the commit would still be atomic and contain all the other changes.<p>&gt; but if you have a workflow where hot-fixes can get promoted from older versions<p>Yeah 100%.<p>In either case, I&#x27;m not saying it&#x27;s wrong by any stretch.<p>It just feels &#x27;weird&#x27; to use branches to represent codebases which will never interact or be merged into each other.</div><br/><div id="40797186" class="c"><input type="checkbox" id="c-40797186" checked=""/><div class="controls bullet"><span class="by">alfons_foobar</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40796469">parent</a><span>|</span><a href="#40794334">next</a><span>|</span><label class="collapse" for="c-40797186">[-]</label><label class="expand" for="c-40797186">[1 more]</label></div><br/><div class="children"><div class="content">Glad I am not the only one feeling &quot;weird&quot; about the separate branches thing :D<p>Probably just a matter of taste, but I think having the files for different environments &quot;side by side&quot; makes it actually easier to compare them if needed, and you still have the full commit history for tracking changes to each environment.</div><br/></div></div></div></div></div></div></div></div><div id="40794334" class="c"><input type="checkbox" id="c-40794334" checked=""/><div class="controls bullet"><span class="by">granra</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794176">parent</a><span>|</span><a href="#40796156">prev</a><span>|</span><a href="#40794459">next</a><span>|</span><label class="collapse" for="c-40794334">[-]</label><label class="expand" for="c-40794334">[1 more]</label></div><br/><div class="children"><div class="content">I read this article a while ago and it seems like the most sane way of dealing with this. Which tool you use to render the manifests doesn&#x27;t even matter anymore.</div><br/></div></div><div id="40794459" class="c"><input type="checkbox" id="c-40794459" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794176">parent</a><span>|</span><a href="#40794334">prev</a><span>|</span><a href="#40795625">next</a><span>|</span><label class="collapse" for="c-40794459">[-]</label><label class="expand" for="c-40794459">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, we have a system (different context, though it does use yaml) that allows nested configurations, and arrived at a similar solution, where nested configs (implicit&#x2F;human interface) are compiled to fully qualified specifications (explicit&#x2F;machine interface). It works quite well for managing e.g. batch configurations with plenty of customization.<p>I was unaware there was a name for this pattern, thank you.</div><br/></div></div><div id="40795625" class="c"><input type="checkbox" id="c-40795625" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40794176">parent</a><span>|</span><a href="#40794459">prev</a><span>|</span><a href="#40793166">next</a><span>|</span><label class="collapse" for="c-40795625">[-]</label><label class="expand" for="c-40795625">[1 more]</label></div><br/><div class="children"><div class="content">This pattern is powerful since you can pick arbitrary tooling and easily make modifications with your own tooling. For instance substituting variables&#x2F;placeholders or applying static analysis.</div><br/></div></div></div></div><div id="40793166" class="c"><input type="checkbox" id="c-40793166" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40792931">parent</a><span>|</span><a href="#40794176">prev</a><span>|</span><a href="#40794091">next</a><span>|</span><label class="collapse" for="c-40793166">[-]</label><label class="expand" for="c-40793166">[4 more]</label></div><br/><div class="children"><div class="content">This is actually a problem we want to focus on with Glasskube Cloud (<a href="https:&#x2F;&#x2F;glasskube.cloud&#x2F;" rel="nofollow">https:&#x2F;&#x2F;glasskube.cloud&#x2F;</a>) where our glasskube[bot] will comment on your GitOps Pull request with an exact diff of resources that will get changed across all connected clusters. This diff will be performed by controller running inside your cluster.<p>Think of it as codecov analysis, but just for resource changes.</div><br/><div id="40794321" class="c"><input type="checkbox" id="c-40794321" checked=""/><div class="controls bullet"><span class="by">granra</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40793166">parent</a><span>|</span><a href="#40793359">next</a><span>|</span><label class="collapse" for="c-40794321">[-]</label><label class="expand" for="c-40794321">[1 more]</label></div><br/><div class="children"><div class="content">IMO the pull request should be the diff.<p><a href="https:&#x2F;&#x2F;akuity.io&#x2F;blog&#x2F;the-rendered-manifests-pattern&#x2F;" rel="nofollow">https:&#x2F;&#x2F;akuity.io&#x2F;blog&#x2F;the-rendered-manifests-pattern&#x2F;</a></div><br/></div></div><div id="40793359" class="c"><input type="checkbox" id="c-40793359" checked=""/><div class="controls bullet"><span class="by">ForHackernews</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40793166">parent</a><span>|</span><a href="#40794321">prev</a><span>|</span><a href="#40794091">next</a><span>|</span><label class="collapse" for="c-40793359">[-]</label><label class="expand" for="c-40793359">[2 more]</label></div><br/><div class="children"><div class="content">This sounds like terraform. Is this TF for k8s?</div><br/><div id="40793418" class="c"><input type="checkbox" id="c-40793418" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40792931">root</a><span>|</span><a href="#40793359">parent</a><span>|</span><a href="#40794091">next</a><span>|</span><label class="collapse" for="c-40793418">[-]</label><label class="expand" for="c-40793418">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting analogy, but I thinks it&#x27;s a stretch.</div><br/></div></div></div></div></div></div><div id="40794091" class="c"><input type="checkbox" id="c-40794091" checked=""/><div class="controls bullet"><span class="by">sandwitches</span><span>|</span><a href="#40792931">parent</a><span>|</span><a href="#40793166">prev</a><span>|</span><a href="#40791997">next</a><span>|</span><label class="collapse" for="c-40794091">[-]</label><label class="expand" for="c-40794091">[1 more]</label></div><br/><div class="children"><div class="content">The solution is to not use Kubernetes.</div><br/></div></div></div></div><div id="40791997" class="c"><input type="checkbox" id="c-40791997" checked=""/><div class="controls bullet"><span class="by">llama052</span><span>|</span><a href="#40792931">prev</a><span>|</span><a href="#40792020">next</a><span>|</span><label class="collapse" for="c-40791997">[-]</label><label class="expand" for="c-40791997">[2 more]</label></div><br/><div class="children"><div class="content">This looks like an interesting take on package management. Would be cool for homebrew clusters and the like.<p>However things like helmfile with renovate paired with a pipeline is my personal preference even if just for ensuring things remain consistent in a repo.<p>The `update all` button for instance seems terrifying on a cluster that means anything at all. None the less it&#x27;s still cool for personal projects and the like!<p>The package controller reminds me a lot of Helm tiller with older versions of helm, and it became a big security issue for a lot of companies, so much so that helm3 removed it and did everything clientside via configmaps. Curious how this project plans on overcoming that.</div><br/><div id="40792265" class="c"><input type="checkbox" id="c-40792265" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40791997">parent</a><span>|</span><a href="#40792020">next</a><span>|</span><label class="collapse" for="c-40792265">[-]</label><label class="expand" for="c-40792265">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for your input, let me comment on your points one by one.<p>&gt; However things like helmfile with renovate paired with a pipeline is my personal preference even if just for ensuring things remain consistent in a repo.<p>Glasskube packages can also be put inside a GitOps repository as every package is a CR (custom resource). (They can even be configured via the CLI using the `--dry-run` and `--output yaml` flags and than put into git. In addition we are working on pull request to support package updates via Renovate: <a href="https:&#x2F;&#x2F;github.com&#x2F;renovatebot&#x2F;renovate&#x2F;issues&#x2F;29322">https:&#x2F;&#x2F;github.com&#x2F;renovatebot&#x2F;renovate&#x2F;issues&#x2F;29322</a><p>&gt; The package controller reminds me a lot of Helm tiller with older versions of helm, and it became a big security issue for a lot of companies, so much so that helm3 removed it and did everything clientside via configmaps. Curious how this project plans on overcoming that.<p>As helm3 is now a client side tool only, that means that it can&#x27;t enforce any RBAC by itself. OLM introduced Operator Groups (<a href="https:&#x2F;&#x2F;olm.operatorframework.io&#x2F;docs&#x2F;advanced-tasks&#x2F;operator-scoping-with-operatorgroups&#x2F;" rel="nofollow">https:&#x2F;&#x2F;olm.operatorframework.io&#x2F;docs&#x2F;advanced-tasks&#x2F;operato...</a>) which introduces a permissions on an operator level. We might introduce something similar for Glasskube packages. Glasskube itself will still require be quite powerful, but we can than scope packages and introduce granular permissions.</div><br/></div></div></div></div><div id="40792020" class="c"><input type="checkbox" id="c-40792020" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40791997">prev</a><span>|</span><a href="#40793771">next</a><span>|</span><label class="collapse" for="c-40792020">[-]</label><label class="expand" for="c-40792020">[5 more]</label></div><br/><div class="children"><div class="content">I have a hard time seeing how a k8s package manager could ever be as simple as brew or apt. One reason that stands out is that I have different values depending on what environment I&#x27;m targeting, and almost every user has a snowflake, just the way it is. The idea of a repl like prompt or web UI for setting those values is not appealing to me.<p>The main pains remain unaddressed<p>- authoring helm charts sucks<p>- managing different values per environment<p>- connecting values across charts so I don&#x27;t have to</div><br/><div id="40792402" class="c"><input type="checkbox" id="c-40792402" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40792020">parent</a><span>|</span><a href="#40793771">next</a><span>|</span><label class="collapse" for="c-40792402">[-]</label><label class="expand" for="c-40792402">[4 more]</label></div><br/><div class="children"><div class="content">We are absolutely seeing a lot of snowflake clusters in the wild. This is also a hot topic on all cloud native conferences I attended lately.<p>Platform teams try to create internal developer platforms to further standardize Kubernetes configurations across teams and clusters, where developers can only do minor modifications. From my experience we want to reduce snow flake configurations. This is also a reason why we created Glasskube in the first place.<p>&gt; - authoring helm charts sucks<p>Yes, 100% and we are on a mission to change this in future.<p>&gt; - managing different values per environment<p>Glasskube packages are still configurable, but come with meaningful default values.<p>&gt; - connecting values across charts so I don&#x27;t have to<p>This is already possible, you can reference package configuration values from other packages easily via Glasskube, not needing to provide the same values multiple times.</div><br/><div id="40792535" class="c"><input type="checkbox" id="c-40792535" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40792020">root</a><span>|</span><a href="#40792402">parent</a><span>|</span><a href="#40793771">next</a><span>|</span><label class="collapse" for="c-40792535">[-]</label><label class="expand" for="c-40792535">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This is already possible, you can reference package configuration values from other packages<p>This misses the point, what we need is something more like Terraform, which has a way to get dynamic information from resource values that are assigned by the system. One such example would be the secret that the postgres operator generates for connecting in the api server that needs access.<p>&gt; &gt; - managing different values per environment<p>Most charts already come with meaningful defaults. The issue is that you need simpler defaults for multiple environments that the user doesn&#x27;t have to think about. There ought to be some higher level information coming into the pipeline that tells the tool what environment I&#x27;m working with and assign certain values automatically.<p>&gt; Yes, 100% and we are on a mission to change this in future.<p>Configuration needs a proper language. Please avoid Yaml and something bespoke. There are a few configuration languages emerging, CUE is my personal pick in the horse race.</div><br/><div id="40792700" class="c"><input type="checkbox" id="c-40792700" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40792020">root</a><span>|</span><a href="#40792535">parent</a><span>|</span><a href="#40793771">next</a><span>|</span><label class="collapse" for="c-40792700">[-]</label><label class="expand" for="c-40792700">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for clarifying your inputs.<p>&gt; This misses the point, what we need is something more like Terraform, which has a way to get dynamic information from resource values that are assigned by the system. One such example would be the secret that the postgres operator generates for connecting in the api server that needs access.<p>It is also already possible to inject values from secrets during runtime. You can for example create a Glasskube package that has a dependency on cnpg and add a `cluster.yaml` to your package and then dynamically patch the connection string (or credentials) from it to your deployment.<p>See the &quot;ValueFrom&quot; section of our configuration documentation for the exact inner workings: <a href="https:&#x2F;&#x2F;glasskube.dev&#x2F;docs&#x2F;design&#x2F;package-config&#x2F;">https:&#x2F;&#x2F;glasskube.dev&#x2F;docs&#x2F;design&#x2F;package-config&#x2F;</a></div><br/><div id="40792771" class="c"><input type="checkbox" id="c-40792771" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40792020">root</a><span>|</span><a href="#40792700">parent</a><span>|</span><a href="#40793771">next</a><span>|</span><label class="collapse" for="c-40792771">[-]</label><label class="expand" for="c-40792771">[1 more]</label></div><br/><div class="children"><div class="content">&gt; See the &quot;ValueFrom&quot; section of our configuration documentation<p>... this is what we have today, how do I know what value to patch in from, like what is the name of the secret?<p>Looking at that link makes me think this is like another layer of helm on helm, especially with the same go template values in yaml that are going to be fed into helm templates under the hood.<p>Putting more yaml on top of templated yaml is not the way to create the next package manager for k8s.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40793771" class="c"><input type="checkbox" id="c-40793771" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#40792020">prev</a><span>|</span><a href="#40794828">next</a><span>|</span><label class="collapse" for="c-40793771">[-]</label><label class="expand" for="c-40793771">[2 more]</label></div><br/><div class="children"><div class="content">Application packages are (traditionally) versioned immutable binaries that come with pre- and post-install steps. They are built with a specific platform in mind, with specific dependencies in mind, and with extremely limited configuration at install time. This is what makes packages work pretty well: they are designed for a very specific circumstance, and allow as little change as possible at install time.<p>Even with all that said, operating system packages require a vast amount of testing, development, and patching, constantly, even within those small parameters. Packages feel easy because potentially hundreds of hours of development and testing have gone into that package you&#x27;re installing now, on that platform you&#x27;re on now, with the components and versions you have now.<p>Kubernetes &quot;packages&quot; aren&#x27;t really packages. They are a set of instructions of components to install and configure, which often involves multiple distinct sets of applications. This is different in a couple ways: 1) K8s &quot;packages&quot; are often extremely &quot;loose&quot; in their definition, leading to a lot of variability, and 2) they are built by all kinds of people, in all kinds of ways, making all kinds of assumptions about the state of the system they&#x27;re being installed into.<p>There&#x27;s actually multiple layers of dependencies and configuration that have to come together correctly for a Kubernetes &quot;package&quot; to work. The K8s API version has to be right, the way the K8s components are installed and running have to be right, the ACLs have to be right, there has to be no other installed component which could conflict, the version of the components and containers being installed by the package need to be pinned (and compatible with everything else in the cluster), and the user has to configure everything properly. Upgrades are similarly chaotic, as there&#x27;s no sense of a stable release tree, or rolling releases. It&#x27;s like installing random .deb or .rpm or .dmg files into your OS and hoping for the best.<p>Nothing exists that does all of this today. To make Kubernetes packaging as seamless as binary platform-specific packaging, you need an entire community of maintainers, and either a rolling-release style (ala Homebrew) or stable versioned release branches. You basically need a project like ArtifactHub or Homebrew to manage all of the packages in one way. That&#x27;s a big undertaking, and in no way profitable.</div><br/><div id="40797136" class="c"><input type="checkbox" id="c-40797136" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40793771">parent</a><span>|</span><a href="#40794828">next</a><span>|</span><label class="collapse" for="c-40797136">[-]</label><label class="expand" for="c-40797136">[1 more]</label></div><br/><div class="children"><div class="content">We started similar to Homebrew with putting packages inside our &quot;core&quot; Glasskube package repository (<a href="https:&#x2F;&#x2F;github.com&#x2F;glasskube&#x2F;packages">https:&#x2F;&#x2F;github.com&#x2F;glasskube&#x2F;packages</a>) where all updates are centrally stored and tested by our CI &#x2F; CD workflows so users can enjoy tested and seamless upgrades. Users can of course host their private repositories (and packages) but we want to provide an opinionated set of packages ourselves.<p>Building them for different Kubernetes version or environments is something we also already thought about and need to happen at some time to bake more configuration into to the build step.</div><br/></div></div></div></div><div id="40794828" class="c"><input type="checkbox" id="c-40794828" checked=""/><div class="controls bullet"><span class="by">revel</span><span>|</span><a href="#40793771">prev</a><span>|</span><a href="#40793493">next</a><span>|</span><label class="collapse" for="c-40794828">[-]</label><label class="expand" for="c-40794828">[3 more]</label></div><br/><div class="children"><div class="content">In my opinion kubernetes is fundamentally hamstrung by the overly simplistic operator model. I really like the general idea, but it&#x27;s not really possible to reduce the entire model down to &quot;current state, desired state, next action.&quot; It means that an entire workflow ends up in the next action logic, but with so many operators looking at the same system state it&#x27;s not really possible to know how the various components will interact.  The problems with helm are a subcase of this larger issue.<p>By analogy, this is the same issue as frontend programming faces with the DOM. Introducing a VDOM &#x2F; reducer paradigm (like react) would go a long way towards solving these problems.</div><br/><div id="40795387" class="c"><input type="checkbox" id="c-40795387" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#40794828">parent</a><span>|</span><a href="#40793493">next</a><span>|</span><label class="collapse" for="c-40795387">[-]</label><label class="expand" for="c-40795387">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s not really possible to reduce the entire model down to &quot;current state, desired state, next action.&quot;<p>This is basically how control theory works in general though. You have a state, a goal, and a perturbation toward the goal. I think this is the right level of abstraction if you want a powerful and flexible tool.<p>&gt;  it&#x27;s not really possible to know how the various components will interact....Introducing a VDOM &#x2F; reducer paradigm (like react) would go a long way towards solving these problems.<p>I think the problem here is that the physical characteristics and layouts of the machines makes such a huge difference that it would be prohibitively costly to virtualize or simulate this in a meaningful way. So instead, people use subsets of the physical structure to verify that configuration states work. You do this by having `dev`, `staging`, `prod` environments, using colored deployments, canary analysis, partial rollouts etc.</div><br/><div id="40797789" class="c"><input type="checkbox" id="c-40797789" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#40794828">root</a><span>|</span><a href="#40795387">parent</a><span>|</span><a href="#40793493">next</a><span>|</span><label class="collapse" for="c-40797789">[-]</label><label class="expand" for="c-40797789">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think this is the right level of abstraction if you want a powerful and flexible tool.<p>This says nothing about ease of use. And for software development, ease of use matters. Otherwise we would all use assembler, or at most C++. They&#x27;re very powerful and flexible.<p>If anything, too much power and flexibility is a problem.</div><br/></div></div></div></div></div></div><div id="40793493" class="c"><input type="checkbox" id="c-40793493" checked=""/><div class="controls bullet"><span class="by">lars_francke</span><span>|</span><a href="#40794828">prev</a><span>|</span><a href="#40796853">next</a><span>|</span><label class="collapse" for="c-40793493">[-]</label><label class="expand" for="c-40793493">[2 more]</label></div><br/><div class="children"><div class="content">We[1] build a lot of Kubernetes operators[2] and deal a lot with Helm and OLM issues. Good luck!<p>One immediate question: Your docs say &quot;Upgrading CRDs will be taken care of by Glasskube to ensure CRs and its operators don&#x27;t get out-of-sync.&quot; but searching for &quot;CRD&quot; in your docs doesn&#x27;t lead to any concrete results.<p>This is one of our biggest pain ponts with Helm right now. Can you share your plans?<p>[1] &lt;<a href="https:&#x2F;&#x2F;stackable.tech&#x2F;en&#x2F;" rel="nofollow">https:&#x2F;&#x2F;stackable.tech&#x2F;en&#x2F;</a>&gt;<p>[2] &lt;<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Q8OSYOgBdCc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Q8OSYOgBdCc</a>&gt;</div><br/><div id="40793638" class="c"><input type="checkbox" id="c-40793638" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40793493">parent</a><span>|</span><a href="#40796853">next</a><span>|</span><label class="collapse" for="c-40793638">[-]</label><label class="expand" for="c-40793638">[1 more]</label></div><br/><div class="children"><div class="content">Packages available in the public Glasskube repo are configured in a way to make sure changes in CRDs get applied (either via Manifest or the helm-controller)<p>We will update the docs though.</div><br/></div></div></div></div><div id="40796853" class="c"><input type="checkbox" id="c-40796853" checked=""/><div class="controls bullet"><span class="by">danmur</span><span>|</span><a href="#40793493">prev</a><span>|</span><a href="#40795820">next</a><span>|</span><label class="collapse" for="c-40796853">[-]</label><label class="expand" for="c-40796853">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Inspired by the simplicity of Homebrew and npm&quot; had me until here :P</div><br/></div></div><div id="40795820" class="c"><input type="checkbox" id="c-40795820" checked=""/><div class="controls bullet"><span class="by">tflinton</span><span>|</span><a href="#40796853">prev</a><span>|</span><a href="#40792511">next</a><span>|</span><label class="collapse" for="c-40795820">[-]</label><label class="expand" for="c-40795820">[1 more]</label></div><br/><div class="children"><div class="content">The selling point of being faster than helm isn’t a very big draw to me.. I never felt the problem with helm was its speed.</div><br/></div></div><div id="40792511" class="c"><input type="checkbox" id="c-40792511" checked=""/><div class="controls bullet"><span class="by">slipheen</span><span>|</span><a href="#40795820">prev</a><span>|</span><a href="#40791956">next</a><span>|</span><label class="collapse" for="c-40792511">[-]</label><label class="expand" for="c-40792511">[2 more]</label></div><br/><div class="children"><div class="content">This looks interesting, thanks for sharing it.<p>Feel free to disregard, but it would help me understand if you briefly explain how this fits in with &#x2F; compares to existing tools like argocd.<p>I watched your video and I saw that argo was one of the tools you were installing, so clearly this is occupying a different niche - But I&#x27;m not sure what that is yet :)</div><br/><div id="40792638" class="c"><input type="checkbox" id="c-40792638" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40792511">parent</a><span>|</span><a href="#40791956">next</a><span>|</span><label class="collapse" for="c-40792638">[-]</label><label class="expand" for="c-40792638">[1 more]</label></div><br/><div class="children"><div class="content">ArgoCD is a great tool to sync the state from your GitOps repository to your cluster and helps by visualizing the installed resources and showcase potentials errors.<p>It is often used by developers to get a glimpse of the state of core application of a company without cluster access.<p>Glasskube focuses on the packages your core application depends on. Managing the life cycle of these infrastructure components, testing updates and providing upgrading paths. You can still put Glasskube packages into your GitOps repo and sync them via ArgoCD into the cluster. Our PackageController will do the rest.</div><br/></div></div></div></div><div id="40791956" class="c"><input type="checkbox" id="c-40791956" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#40792511">prev</a><span>|</span><a href="#40795140">next</a><span>|</span><label class="collapse" for="c-40791956">[-]</label><label class="expand" for="c-40791956">[6 more]</label></div><br/><div class="children"><div class="content">Do you plan to eventually support alternatives to the mix of Golang templates in YAML? It’s my main issue regarding Helm charts and I dream about pkl helm charts.</div><br/><div id="40792130" class="c"><input type="checkbox" id="c-40792130" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40791956">parent</a><span>|</span><a href="#40792076">next</a><span>|</span><label class="collapse" for="c-40792130">[-]</label><label class="expand" for="c-40792130">[3 more]</label></div><br/><div class="children"><div class="content">I dream of Helm adopting CUE as an option for chart templates and values. They are both written in Go, which makes the integration a possibility. I&#x27;ve played around with a wrapper that renders the CUE to to Yaml before running Helm, which effectively means helm is deploying hardcoded templates, lifting the values&#x2F;templates merging out of Helm proper.</div><br/><div id="40793782" class="c"><input type="checkbox" id="c-40793782" checked=""/><div class="controls bullet"><span class="by">kingcan</span><span>|</span><a href="#40791956">root</a><span>|</span><a href="#40792130">parent</a><span>|</span><a href="#40792076">next</a><span>|</span><label class="collapse" for="c-40793782">[-]</label><label class="expand" for="c-40793782">[2 more]</label></div><br/><div class="children"><div class="content">Have you tried <a href="https:&#x2F;&#x2F;timoni.sh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;timoni.sh&#x2F;</a>?</div><br/><div id="40793791" class="c"><input type="checkbox" id="c-40793791" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40791956">root</a><span>|</span><a href="#40793782">parent</a><span>|</span><a href="#40792076">next</a><span>|</span><label class="collapse" for="c-40793791">[-]</label><label class="expand" for="c-40793791">[1 more]</label></div><br/><div class="children"><div class="content">yes, see my other comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40793260">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40793260</a></div><br/></div></div></div></div></div></div><div id="40792076" class="c"><input type="checkbox" id="c-40792076" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40791956">parent</a><span>|</span><a href="#40792130">prev</a><span>|</span><a href="#40792089">next</a><span>|</span><label class="collapse" for="c-40792076">[-]</label><label class="expand" for="c-40792076">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but no concrete plans.<p>We already looked into pkl, but this would require every package author to either have Java (and pkl) running on their system or we would need to package the jre (and pkl) in order to make it work probably.
But Kubernetes examples are already out there (<a href="https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;pkl-k8s-examples">https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;pkl-k8s-examples</a>) and we are keeping an eye on it.</div><br/></div></div><div id="40792089" class="c"><input type="checkbox" id="c-40792089" checked=""/><div class="controls bullet"><span class="by">gtirloni</span><span>|</span><a href="#40791956">parent</a><span>|</span><a href="#40792076">prev</a><span>|</span><a href="#40795140">next</a><span>|</span><label class="collapse" for="c-40792089">[-]</label><label class="expand" for="c-40792089">[1 more]</label></div><br/><div class="children"><div class="content">Same here. It&#x27;s where I spend 90% of my time working with Helm charts and I absolutely despise it.</div><br/></div></div></div></div><div id="40795140" class="c"><input type="checkbox" id="c-40795140" checked=""/><div class="controls bullet"><span class="by">necubi</span><span>|</span><a href="#40791956">prev</a><span>|</span><a href="#40795848">next</a><span>|</span><label class="collapse" for="c-40795140">[-]</label><label class="expand" for="c-40795140">[1 more]</label></div><br/><div class="children"><div class="content">As someone with an opensource project that ships a helm package, I wish you the best of luck. Helm has many flaws, and we can definitely do better.<p>It sounds like your pitch is focused on users, but I think you might want to think about how to attract a package ecosystem. Some things that would make my life easier as a packager:<p>* Statically typed config language. It&#x27;s insane that we&#x27;re generating YAML files with Go templates. I&#x27;m a big fan of jsonnet, but whatever it is it should not be possible to have errors at runtime.<p>* A better way to document to users the various options and how they play together. For any moderately complex package it become very challenging to communicate how to configure the chart for your environment<p>* Better testing infrastructure; am I creating valid k8s resources given all of the possible configuration options?</div><br/></div></div><div id="40795848" class="c"><input type="checkbox" id="c-40795848" checked=""/><div class="controls bullet"><span class="by">cbanek</span><span>|</span><a href="#40795140">prev</a><span>|</span><a href="#40792510">next</a><span>|</span><label class="collapse" for="c-40795848">[-]</label><label class="expand" for="c-40795848">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had to use helm and argocd in anger at work, and I feel like the real problem is not helm, nor argocd.  They are tricky to learn but in general pretty straightforward once you get it.<p>What was really annoying was the constant moving and changing the yaml that kubernetes wanted.  After you update your cluster and things stop working, it&#x27;s really not about the layers on top, but it&#x27;s about kubernetes and having to keep up with the new beta versions and also sunsetting other things.</div><br/><div id="40796659" class="c"><input type="checkbox" id="c-40796659" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#40795848">parent</a><span>|</span><a href="#40792510">next</a><span>|</span><label class="collapse" for="c-40796659">[-]</label><label class="expand" for="c-40796659">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I feel like the real problem is not helm, nor argocd ... What was really annoying was the constant moving and changing the yaml that kubernetes wanted.<p>That to me sounds like you&#x27;re angry at helm and argocd, but don&#x27;t realize it.<p>The kubernetes apiserver publishes all the resources it supports, including custom-resource-definitions, including typed specifications that can be used to validate what you&#x27;re submitting client-side.<p>If helm weren&#x27;t a dumb layer of yaml templating, it could tell you locally, like compiling a typed programming language, &quot;this helm chart won&#x27;t work on your cluster because you have the beta version of this CRD and need the alpha version&quot;, or it could even transform things into the correct version.<p>The kubernetes API provides everything that&#x27;s needed to statically verify what Groups&#x2F;Kinds&#x2F;Versions exist, and tooling like helm is just too dumb to work with it.</div><br/><div id="40797618" class="c"><input type="checkbox" id="c-40797618" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#40795848">root</a><span>|</span><a href="#40796659">parent</a><span>|</span><a href="#40792510">next</a><span>|</span><label class="collapse" for="c-40797618">[-]</label><label class="expand" for="c-40797618">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what the --api-versions in helm is for. If you look at the helm commands argocd  uses you&#x27;ll see a very long string of flags that pass every available api version to helm.</div><br/></div></div></div></div></div></div><div id="40792510" class="c"><input type="checkbox" id="c-40792510" checked=""/><div class="controls bullet"><span class="by">woile</span><span>|</span><a href="#40795848">prev</a><span>|</span><a href="#40793862">next</a><span>|</span><label class="collapse" for="c-40792510">[-]</label><label class="expand" for="c-40792510">[3 more]</label></div><br/><div class="children"><div class="content">Has anyone tried <a href="https:&#x2F;&#x2F;github.com&#x2F;stefanprodan&#x2F;timoni">https:&#x2F;&#x2F;github.com&#x2F;stefanprodan&#x2F;timoni</a> ? Seems like a good alternative to helm</div><br/><div id="40793260" class="c"><input type="checkbox" id="c-40793260" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40792510">parent</a><span>|</span><a href="#40793091">next</a><span>|</span><label class="collapse" for="c-40793260">[-]</label><label class="expand" for="c-40793260">[1 more]</label></div><br/><div class="children"><div class="content">I tried it early on, being a big CUE fan.<p>Pros:<p>- comes from someone with deep k8s experience<p>- has features for secrets and dynamic information based on k8s version and CRDs<p>- thinks about the full life-cycle and e2e process<p>Cons: (at the time)<p>- holds CUE weird, there are places where they overwrite values (helm style) which is antithetical to CUE philosophy. This was rationalized to me as keeping with the Helm mindset rather than using the CUE mindset, because it is what people are used to. I think this misses the big opportunity for CUE in k8s config.<p>- has its own module system that probably won&#x27;t integrate with CUE&#x27;s (as it stands today), granted CUE&#x27;s module system wasn&#x27;t released at the time, but it seems the intention is to have a separate system because the goal is to align with k8s more than CUE<p>- Didn&#x27;t allow for Helm modules to be dependencies. This seems to have since changed, but requires you to use FluxCD (?)<p>I didn&#x27;t ever adopt it because of the philosophical differences (me from CUE, stefan from k8s). I have seen others speak highly of it, definitely worth checking out to see if it is something you&#x27;d like. I have plans for something similar once an internal Go package in CUE is made publicly available (<a href="https:&#x2F;&#x2F;github.com&#x2F;cue-lang&#x2F;cue&#x2F;commits&#x2F;master&#x2F;internal&#x2F;core&#x2F;dep">https:&#x2F;&#x2F;github.com&#x2F;cue-lang&#x2F;cue&#x2F;commits&#x2F;master&#x2F;internal&#x2F;core...</a>). The plan is to combine the CUE dep package with OpenTofu&#x27;s graph solver to power a config system that can span across the spaces.</div><br/></div></div><div id="40793091" class="c"><input type="checkbox" id="c-40793091" checked=""/><div class="controls bullet"><span class="by">geiser</span><span>|</span><a href="#40792510">parent</a><span>|</span><a href="#40793260">prev</a><span>|</span><a href="#40793862">next</a><span>|</span><label class="collapse" for="c-40793091">[-]</label><label class="expand" for="c-40793091">[1 more]</label></div><br/><div class="children"><div class="content">Reviewing their docs I found this: <a href="https:&#x2F;&#x2F;glasskube.dev&#x2F;docs&#x2F;comparisons&#x2F;timoni&#x2F;">https:&#x2F;&#x2F;glasskube.dev&#x2F;docs&#x2F;comparisons&#x2F;timoni&#x2F;</a> 
I have personally never worked with Timoni</div><br/></div></div></div></div><div id="40793862" class="c"><input type="checkbox" id="c-40793862" checked=""/><div class="controls bullet"><span class="by">impalallama</span><span>|</span><a href="#40792510">prev</a><span>|</span><a href="#40796244">next</a><span>|</span><label class="collapse" for="c-40793862">[-]</label><label class="expand" for="c-40793862">[1 more]</label></div><br/><div class="children"><div class="content">Definitely looks like a solid improvement over Helm when it comes to just downloading and installing Kubernetes packages but it still to early for me to have a solid opinion since the aspect of actually building and distributing your own chart doesn&#x27;t seem have been tackled which is basically 90% of the use case for Helm despite calling itself a package-manager, ha.</div><br/></div></div><div id="40796244" class="c"><input type="checkbox" id="c-40796244" checked=""/><div class="controls bullet"><span class="by">hodgesrm</span><span>|</span><a href="#40793862">prev</a><span>|</span><a href="#40794237">next</a><span>|</span><label class="collapse" for="c-40796244">[-]</label><label class="expand" for="c-40796244">[3 more]</label></div><br/><div class="children"><div class="content">I see that Glasskube is licensed under Apache 2.0. Do you plan to contribute it to the CNCF? Many of us are very skeptical of base infra that is not protected by a foundation.</div><br/><div id="40796610" class="c"><input type="checkbox" id="c-40796610" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40796244">parent</a><span>|</span><a href="#40796640">next</a><span>|</span><label class="collapse" for="c-40796610">[-]</label><label class="expand" for="c-40796610">[1 more]</label></div><br/><div class="children"><div class="content">The problem with contributing Glasskube to the CNCF atm would be that we would also need to contribute our Logo and trade mark. Something which we currently not willing to do. We look as Grafana as a successful example that did not contribute their core product to the CNCF and is still widely adopted.</div><br/></div></div><div id="40796640" class="c"><input type="checkbox" id="c-40796640" checked=""/><div class="controls bullet"><span class="by">Cyphus</span><span>|</span><a href="#40796244">parent</a><span>|</span><a href="#40796610">prev</a><span>|</span><a href="#40794237">next</a><span>|</span><label class="collapse" for="c-40796640">[-]</label><label class="expand" for="c-40796640">[1 more]</label></div><br/><div class="children"><div class="content">Looks like they were accepted into the CNCF Landscape at least <a href="https:&#x2F;&#x2F;glasskube.dev&#x2F;blog&#x2F;cncf-landscape&#x2F;">https:&#x2F;&#x2F;glasskube.dev&#x2F;blog&#x2F;cncf-landscape&#x2F;</a></div><br/></div></div></div></div><div id="40794237" class="c"><input type="checkbox" id="c-40794237" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#40796244">prev</a><span>|</span><a href="#40792762">next</a><span>|</span><label class="collapse" for="c-40794237">[-]</label><label class="expand" for="c-40794237">[1 more]</label></div><br/><div class="children"><div class="content">We started with some pretty cool Jsonnet-based build infrastructure and we&#x27;re pretty happy with it. Grafana Tanka is also okay, there&#x27;s tooling to generate Jsonnet libraries for anything that has a CRD. There&#x27;s jsonnet-bundler for package management.<p>One can throw Flux and Git* actions or what not in the mix. The outcome is a boring CI&#x2F;CD implementation. Boring is good. Boring and powerful because of how Jsonnet works.<p>It&#x27;s pretty neat in the right hands.</div><br/></div></div><div id="40792762" class="c"><input type="checkbox" id="c-40792762" checked=""/><div class="controls bullet"><span class="by">redbackthomson</span><span>|</span><a href="#40794237">prev</a><span>|</span><a href="#40792874">next</a><span>|</span><label class="collapse" for="c-40792762">[-]</label><label class="expand" for="c-40792762">[1 more]</label></div><br/><div class="children"><div class="content">First off I just wanted to say I think it&#x27;s great that you&#x27;re attempting to tackle the problem that is Kubernetes package management. I work at a Kubernetes SaaS startup and spend many hours working with YAML and Helm charts every day, so I absolutely feel the pain that comes with it.<p>That being said, I&#x27;m confused as to where Glasskube is positioned in solving this problem. In the title of this post, you are claiming Glasskube is an &quot;alternative to Helm&quot;; although in your documentation you have a &quot;Glasskube vs Helm&quot; guide that explicitly states that &quot;Glasskube is not a full replacement of Helm&quot;. I&#x27;m trying to understand how these two statements can be true. To make things more confusing, under the hood Glasskube repositories appear to be a repackaging of a Helm repository, albiet with a nicer UI.<p>From what I&#x27;ve gathered after reading the docs, Glasskube is being positioned as an easier way to interact with Helm charts - offering some easy-to-use tooling for upgrades and dependency management. To me, that doesn&#x27;t exactly feel like it replaces Helm, but simply supplements my use of it, because it doesn&#x27;t actually combat the real problems of using Helm.<p>My biggest pain points, some of which I don&#x27;t think Glasskube is addressing, that I think are at the crux of switching off Helm:<p>- The arbitrary nature of how value files are laid out - every chart appears to have its own standards for which fields should be exposed and the nomenclature for exposing them<p>- Helm releases frequently get stuck when updating or rolling back, from which they can&#x27;t be fixed without needing to be uninstalled and reinstalled<p>- I need to reference the Helm chart values file to know what is exposed and what values and types are accepted (Glasskube schema&#x27;d values files does address this! Yay!)<p>Apart from the Helm chart values schema, I don&#x27;t think Glasskube solves these fundamental problems. So I&#x27;m not sure why I would spend the large amount of effort to migrate to this new paradigm if the same problems could still cause headaches.<p>Lastly, I would also concur with @llama052&#x27;s comment, that an &quot;update all&quot; button will always be forbidden in my, and probably most other, companies. Considering the serious lack of standardisation that comes with Helm chart versioning (whether the app version changes between charts, whether roles or role bindings need to be updated, whether values have been deprecated or their defaults have changed, etc.), it&#x27;s incredibly risky to update a Helm chart without understanding the implications that come with it. Typically our engineers have to review the release notes for the application between the two Helm chart versions, at least test in dev and staging for a few days, and only then can we feel comfortable releasing the changes - one chart at a time.  Not to mention that if you are in charge of running a system with multiple applications, you probably want to use GitOps, and in that case a version upgrade would require a commit to the Git repository and not just a push of a button on the infra IDP.</div><br/></div></div><div id="40792874" class="c"><input type="checkbox" id="c-40792874" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40792762">prev</a><span>|</span><a href="#40792463">next</a><span>|</span><label class="collapse" for="c-40792874">[-]</label><label class="expand" for="c-40792874">[7 more]</label></div><br/><div class="children"><div class="content">My immediate question is whether&#x2F;how this can be an improvement over using the terraform helm provider.<p>If I need a better GUI anywhere, it’s probably in EKS, or something that makes working with EKS a bit less painful.</div><br/><div id="40793129" class="c"><input type="checkbox" id="c-40793129" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40792874">parent</a><span>|</span><a href="#40792463">next</a><span>|</span><label class="collapse" for="c-40793129">[-]</label><label class="expand" for="c-40793129">[6 more]</label></div><br/><div class="children"><div class="content">Helm (also in combination with terraform) is a client side tool for deploying charts to your cluster.<p>Glasskube on the other hand is a package manger where you can find look up, install and configure packages via a cli and UI and overcome some of the shortcomings of Helm.</div><br/><div id="40795193" class="c"><input type="checkbox" id="c-40795193" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40792874">root</a><span>|</span><a href="#40793129">parent</a><span>|</span><a href="#40793575">next</a><span>|</span><label class="collapse" for="c-40795193">[-]</label><label class="expand" for="c-40795193">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Helm typically described as a package manager for Kubernetes?[0][1][2]<p>But more importantly, what I&#x27;m getting at is that with Terraform I get infrastructure as code.<p>[0] &quot;The package manager for Kubernetes&quot; <a href="https:&#x2F;&#x2F;helm.sh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;helm.sh&#x2F;</a><p>[1] &quot;Get up to speed with Helm, the preeminent package manager for the Kubernetes container orchestration system.&quot; <a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;learning-helm&#x2F;9781492083641&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;learning-helm&#x2F;978149208...</a><p>[2] &quot;Helm is a package manager for Kubernetes.&quot; <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Helm_(package_manager)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Helm_(package_manager)</a></div><br/><div id="40795852" class="c"><input type="checkbox" id="c-40795852" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#40792874">root</a><span>|</span><a href="#40795193">parent</a><span>|</span><a href="#40793575">next</a><span>|</span><label class="collapse" for="c-40795852">[-]</label><label class="expand" for="c-40795852">[3 more]</label></div><br/><div class="children"><div class="content">Helm is actually three things<p>- package manager<p>- templating engine<p>- deployment tool<p>You’ll hear various opinions on how good it is at each of these roles. In my personal experience it is a decent package manager, a poor but serviceable templating engine, and a horrifically bad deployment tool.<p>Normally you pair Helm with something like Flux or Argo if you want IaC</div><br/><div id="40795987" class="c"><input type="checkbox" id="c-40795987" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40792874">root</a><span>|</span><a href="#40795852">parent</a><span>|</span><a href="#40793575">next</a><span>|</span><label class="collapse" for="c-40795987">[-]</label><label class="expand" for="c-40795987">[2 more]</label></div><br/><div class="children"><div class="content">That was just the comment I needed, just at the moment I needed it. Thanks!</div><br/><div id="40796270" class="c"><input type="checkbox" id="c-40796270" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#40792874">root</a><span>|</span><a href="#40795987">parent</a><span>|</span><a href="#40793575">next</a><span>|</span><label class="collapse" for="c-40796270">[-]</label><label class="expand" for="c-40796270">[1 more]</label></div><br/><div class="children"><div class="content">Some additional context:<p>IMO terraform is probably not the right tool for the job for managing deployments. It can do it, but like helm itself, it’s also not super great at doing cluster deployments. If you’re looking for a good GUI like experience Argo is a good option.<p>I like Terraform for managing infra, and it’s good at a lot of things, but managing deployments on a cluster with IaC is not one of them. Why? Mainly because deployments are much more dynamic than infrastructure and the amount of throat clearing required for terraform to perform a state diff is much much much higher than other tech. Much better to look at the tech I mentioned (Argo and Flux) for that, because they do state diff for these things in milliseconds. I’ll leave it to the reader to figure out how long it takes terraform to do this.<p>It’s possible to go entirely in the “everything is a kube manifest” direction using technologies like Crossplane and Cluster API and (for AWS) technologies like ACK. But I don’t think we are entirely there yet for these technologies in terms of maturity, so in my recent designs I usually settle for provisioning of cluster and initial bootstrapping with terraform before mostly handing off to Argo for deployment, but then doing this weird counterbalance for having to go back to terraform when infra stuff is necessary. I can see a future world, however, where you bootstrap management clusters with something like terraform but then basically everything else, both infra (clusters, buckets, IAM, etc) and deployments (Helm) is declarative through tech like Argo and Crossplane provisioning.<p>The tough part right now is when you have application devs that need to provision infrastructure and then deploy on top of it. Right now that looks like asking your developer to write some app specific terraform like S3&#x2F;IAM&#x2F;KMS&#x2F;Redis&#x2F;whatever  and then deploying their app on top of it with Argo or flux or what not. The ideal maybe looks like using the same tech for both eventually, as well as even provisioning the cluster that the stack runs on with the same tech.</div><br/></div></div></div></div></div></div></div></div><div id="40793575" class="c"><input type="checkbox" id="c-40793575" checked=""/><div class="controls bullet"><span class="by">fsniper</span><span>|</span><a href="#40792874">root</a><span>|</span><a href="#40793129">parent</a><span>|</span><a href="#40795193">prev</a><span>|</span><a href="#40792463">next</a><span>|</span><label class="collapse" for="c-40793575">[-]</label><label class="expand" for="c-40793575">[1 more]</label></div><br/><div class="children"><div class="content">I think there is a fundamental misunderstanding about what a package manager is.<p>From Wikipedia: &quot;A package manager or package-management system is a collection of software tools that automates the process of installing, upgrading, configuring, and removing computer programs for a computer in a consistent manner.&quot; <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Package_manager" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Package_manager</a><p>Helm is a package manager as it consistently,<p>* Can pull and deploy applications via packages
* Can manage (upgrade&#x2F;reconfigure&#x2F;delete) deployed applications
* Can search and find helm charts.<p>So the difference is it lacks a GUI? Afaik GUI was never a requirement for a package manager.<p>And another perspective is, as GlassKube does not provide a packaging mechanism, and uses helm in the backend (established in another question, which I&#x27;ll also reply) it&#x27;s not really a package manager but a frontend to another one. 
(examples: dpkg - package manager - apt-get&#x2F;apt&#x2F;aptitude frontend)<p>Also IMHO, Considering CNCF landscape, Glasskube is more positioned as a Continues Delivery tool than a package manager. But this is my take.</div><br/></div></div></div></div></div></div><div id="40792463" class="c"><input type="checkbox" id="c-40792463" checked=""/><div class="controls bullet"><span class="by">leroman</span><span>|</span><a href="#40792874">prev</a><span>|</span><a href="#40795231">next</a><span>|</span><label class="collapse" for="c-40792463">[-]</label><label class="expand" for="c-40792463">[7 more]</label></div><br/><div class="children"><div class="content">Somehow I am able to get bye with Kustimise. Cant stand the mess that is helm and its eco system.</div><br/><div id="40794119" class="c"><input type="checkbox" id="c-40794119" checked=""/><div class="controls bullet"><span class="by">joshuak</span><span>|</span><a href="#40792463">parent</a><span>|</span><a href="#40794504">next</a><span>|</span><label class="collapse" for="c-40794119">[-]</label><label class="expand" for="c-40794119">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>Adding black boxes on top of black boxes is not a good way to abstract complexity. Helm does nothing more than any template engine does, yet requires me to trust not only the competency of some random chart author but also that they will correctly account for how my k8s environment is configured.<p>When I inevitably have to debug some deployment, now I&#x27;m digging through not only the raw k8s config, but also whatever complexity Helm has added on to obfuscate that k8s config complexity.<p>Helm is an illusion. All it does is hide important details from you.</div><br/></div></div><div id="40794504" class="c"><input type="checkbox" id="c-40794504" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#40792463">parent</a><span>|</span><a href="#40794119">prev</a><span>|</span><a href="#40792859">next</a><span>|</span><label class="collapse" for="c-40794504">[-]</label><label class="expand" for="c-40794504">[1 more]</label></div><br/><div class="children"><div class="content">I always see comments like this, and as someone who used Kustomize first and then moved to Helm, it really doesn&#x27;t fit with my experience.<p>I found Kustomize extremely annoying to work with. Changing simple configuration options required way too much work.<p>Take a simple example - changing the URL value of an ingress. This is something every deploy is going to have to set, since it will be different for every cluster.<p>In Kustomize, I first have to find the ingress resource, then recreate the nesting properly in my kustomize file, and then repeat that for every deployment.<p>In Helm, I just change one entry in a values file, that is clearly named so I know what I am setting.<p>In addition, it is REALLY hard to refactor resources once there are a lot of Kustomization files. If I want to redo how the deployment works, I have to change every Kustomize file that any other repo using my project uses. If I have a lot of other people who are pulling in my project and then using kustomize on top of it, we have to coordinate any changes, because changing the structure breaks all Kustomizations.<p>With Helm, as long as I keep the same values file structure, I am free to move things around however I want. I can use values in completely new locations without having to change anything about the values files themselves.<p>I just don&#x27;t see how it is easier. I find it a lot easier to read a default values file and figure out what every setting does rather than read 20 k8s yaml files trying to figure out what does what.<p>In some ways, I kind of feel like the Kustomize enthusiasts LIKE the things I find annoying about it; they think you SHOULD have to read every resource and fully understand it, and they don&#x27;t want anyone to be able to change anything without every kustomizer also changing things. I get the theory that everyone should know the underlying resources, but in practicality I find Kustomize to be the wrong level of abstraction for what I want to do.</div><br/></div></div><div id="40792859" class="c"><input type="checkbox" id="c-40792859" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#40792463">parent</a><span>|</span><a href="#40794504">prev</a><span>|</span><a href="#40795231">next</a><span>|</span><label class="collapse" for="c-40792859">[-]</label><label class="expand" for="c-40792859">[4 more]</label></div><br/><div class="children"><div class="content">Do you rewrite all the apps that are out there as your own kustomize charts or what do you mean by &quot;its eco system&quot;</div><br/><div id="40792950" class="c"><input type="checkbox" id="c-40792950" checked=""/><div class="controls bullet"><span class="by">leroman</span><span>|</span><a href="#40792463">root</a><span>|</span><a href="#40792859">parent</a><span>|</span><a href="#40792964">next</a><span>|</span><label class="collapse" for="c-40792950">[-]</label><label class="expand" for="c-40792950">[1 more]</label></div><br/><div class="children"><div class="content">Kustomize is basically a higher level file for K8s deployments, I have all the resources as declarative code that gets deployed when I apply the relevant directory. 
I have istio + ssl certs + services and any other resource, multiple projects with cross project communication and provisioning etc..</div><br/></div></div><div id="40792964" class="c"><input type="checkbox" id="c-40792964" checked=""/><div class="controls bullet"><span class="by">leroman</span><span>|</span><a href="#40792463">root</a><span>|</span><a href="#40792859">parent</a><span>|</span><a href="#40792950">prev</a><span>|</span><a href="#40795231">next</a><span>|</span><label class="collapse" for="c-40792964">[-]</label><label class="expand" for="c-40792964">[2 more]</label></div><br/><div class="children"><div class="content">By “eco system” I mean all the charts that get shared, when ever I try to look under the hood I instantly regret it..</div><br/><div id="40794461" class="c"><input type="checkbox" id="c-40794461" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40792463">root</a><span>|</span><a href="#40792964">parent</a><span>|</span><a href="#40795231">next</a><span>|</span><label class="collapse" for="c-40794461">[-]</label><label class="expand" for="c-40794461">[1 more]</label></div><br/><div class="children"><div class="content">So what do you do when you need to deploy something a bit fiddly with multiple components (e.g. Cassandra) that would just be importing a shared chart in Helm. Do you rewrite that yourself in kustomize?</div><br/></div></div></div></div></div></div></div></div><div id="40795231" class="c"><input type="checkbox" id="c-40795231" checked=""/><div class="controls bullet"><span class="by">curiousdeadcat</span><span>|</span><a href="#40792463">prev</a><span>|</span><a href="#40791937">next</a><span>|</span><label class="collapse" for="c-40795231">[-]</label><label class="expand" for="c-40795231">[1 more]</label></div><br/><div class="children"><div class="content">Nickel feels like my end game for this kind of thing.</div><br/></div></div><div id="40791937" class="c"><input type="checkbox" id="c-40791937" checked=""/><div class="controls bullet"><span class="by">fsniper</span><span>|</span><a href="#40795231">prev</a><span>|</span><a href="#40793870">next</a><span>|</span><label class="collapse" for="c-40791937">[-]</label><label class="expand" for="c-40791937">[5 more]</label></div><br/><div class="children"><div class="content">When I check the packages repo, I see that they are yaml.files linking to helm packages. Is this only capable of deploying helm packages? Is there a packaging solution included too?</div><br/><div id="40792017" class="c"><input type="checkbox" id="c-40792017" checked=""/><div class="controls bullet"><span class="by">pmig</span><span>|</span><a href="#40791937">parent</a><span>|</span><a href="#40793870">next</a><span>|</span><label class="collapse" for="c-40792017">[-]</label><label class="expand" for="c-40792017">[4 more]</label></div><br/><div class="children"><div class="content">&gt; We are still using Helm and Manifests under the hood. However, together with the community, we plan to develop an entirely new packaging and bundling format for all cloud-native packages.<p>Yes at the moment Glasskube packages wrap around Helm charts and manifests. We don&#x27;t have a dedicated packaging format as of now.<p>We are actively looking into OCI images and other possibilities to bundle Kubernetes packages, but focus on features like multi namespace dependencies and simplicity at the moment.<p>How would you like to package Kubernetes packages or what should be avoided from your perspective?</div><br/><div id="40793040" class="c"><input type="checkbox" id="c-40793040" checked=""/><div class="controls bullet"><span class="by">ryanisnan</span><span>|</span><a href="#40791937">root</a><span>|</span><a href="#40792017">parent</a><span>|</span><a href="#40793261">next</a><span>|</span><label class="collapse" for="c-40793040">[-]</label><label class="expand" for="c-40793040">[1 more]</label></div><br/><div class="children"><div class="content">This is the worst of both worlds.<p>Helm, as an abstraction layer, is a real pain in the ass. Having another abstraction layer here is pure madness.<p>I wish you luck, but I do not wish to board your boat.</div><br/></div></div><div id="40793261" class="c"><input type="checkbox" id="c-40793261" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#40791937">root</a><span>|</span><a href="#40792017">parent</a><span>|</span><a href="#40793040">prev</a><span>|</span><a href="#40793741">next</a><span>|</span><label class="collapse" for="c-40793261">[-]</label><label class="expand" for="c-40793261">[1 more]</label></div><br/><div class="children"><div class="content">Yaml files should be avoided.</div><br/></div></div><div id="40793741" class="c"><input type="checkbox" id="c-40793741" checked=""/><div class="controls bullet"><span class="by">fsniper</span><span>|</span><a href="#40791937">root</a><span>|</span><a href="#40792017">parent</a><span>|</span><a href="#40793261">prev</a><span>|</span><a href="#40793870">next</a><span>|</span><label class="collapse" for="c-40793741">[-]</label><label class="expand" for="c-40793741">[1 more]</label></div><br/><div class="children"><div class="content">This was what I understood too.<p>As a power Kubernetes user providing Kubernetes based paas to internal customers, we are not looking for more GUI or, abstractions over helm.<p>There are already a lot of solutions out there in this area like helmsman&#x2F;argocd&#x2F;helmfile&#x2F;cross plane helm-provider. And we like kubernetes resources + gitops based automations over any other fancy tools.<p>Most of the time problems around helm is it&#x27;s string based templating and lack of type safety. That&#x27;s why timoni looks a more promising solution in this space. It&#x27;s lack of packages is the limiting factor.<p>Another interesting approach is kapp-controller and carvel tooling. Packaging helm charts, OCI images, etc as OCI artifacts to use as a combined source is really interesting. We were considering using kapp-kontroller however our current dependence helm, and some architectural concerns caused us to pass on kapp-controller for now.<p>As to the question of what could be selling points towards a new &quot;Package Manager&quot; would be,<p>* Timoni like packages that has templating with type safety. 
* A large package pool, or
* Abstraction over helm packages that could add type safety, or better yet automatic or at least semi-automatic conversion of helm charts (One can dream ;))
* Full management through kubernetes API &#x2F; CRDs
* Multicluster management, or fleet management.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>