<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694336471950" as="style"/><link rel="stylesheet" href="styles.css?v=1694336471950"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mcyoung.xyz/2023/08/09/yarns/">I Wrote a String Type</a> <span class="domain">(<a href="https://mcyoung.xyz">mcyoung.xyz</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>29 comments</span></div><br/><div><div id="37452601" class="c"><input type="checkbox" id="c-37452601" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#37453411">next</a><span>|</span><label class="collapse" for="c-37452601">[-]</label><label class="expand" for="c-37452601">[2 more]</label></div><br/><div class="children"><div class="content">Another useful datatype is a rope[0]. It is useful for using immutable&#x2F;shared pieces that can build up to other longer compositions. In particular, an operation such as concatenation can be O(1) since that&#x27;s matches the representation of a rope.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rope_(data_structure)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rope_(data_structure)</a></div><br/><div id="37453071" class="c"><input type="checkbox" id="c-37453071" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#37452601">parent</a><span>|</span><a href="#37453411">next</a><span>|</span><label class="collapse" for="c-37453071">[-]</label><label class="expand" for="c-37453071">[1 more]</label></div><br/><div class="children"><div class="content">Also worth noting that just about every javascript engine uses ropes internally to represent strings (most of the time).<p><a href="https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;1o-MJPAddpfBfDZCkIHNKbMiM86iDFld7idGbNQLuKIQ&#x2F;preview#heading=h.6kknmf22ixwc" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;1o-MJPAddpfBfDZCkIHNKbMiM...</a></div><br/></div></div></div></div><div id="37453411" class="c"><input type="checkbox" id="c-37453411" checked=""/><div class="controls bullet"><span class="by">fjfaase</span><span>|</span><a href="#37452601">prev</a><span>|</span><a href="#37453784">next</a><span>|</span><label class="collapse" for="c-37453411">[-]</label><label class="expand" for="c-37453411">[1 more]</label></div><br/><div class="children"><div class="content">Nice library with many features. But I do not always understand the focus on memory usage. I guess that the reason behind this is that less memory allocations, have a positive effect on execution times. In a parser, where you often have to compare identifiers, it is a good idea to put all strings for identifiers into a unique pointer with the help of a hash table.<p>In my interpreting parser [1] I use a hexa hash tree [2] for storing identifiers. It is not very memory efficient, but very fast. It turns every string (from the input buffer) into a unique pointer for that string pointing to a copy of the string. In this way comparing string (identifiers) is equivalent to comparing pointers.<p>The idea of the hexa hash tree is that is a tree where each node has sixteen child nodes. Which node is selected is based on a step wise evaluated hash function that first takes the lower four bytes of successive characters in the string, and after reaching the end of the string, the higher four bytes of the characters. The nodes often taken up more memory space than the strings themselves.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;FransFaase&#x2F;IParse&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;FransFaase&#x2F;IParse&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;FransFaase&#x2F;IParse&#x2F;blob&#x2F;master&#x2F;software&#x2F;Ident.cpp">https:&#x2F;&#x2F;github.com&#x2F;FransFaase&#x2F;IParse&#x2F;blob&#x2F;master&#x2F;software&#x2F;Id...</a></div><br/></div></div><div id="37453784" class="c"><input type="checkbox" id="c-37453784" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#37453411">prev</a><span>|</span><a href="#37452519">next</a><span>|</span><label class="collapse" for="c-37453784">[-]</label><label class="expand" for="c-37453784">[1 more]</label></div><br/><div class="children"><div class="content">On footnote #4. The change from two shifts to movabs&#x2F;and is only possible for unsigned. If the size was signed this wouldn&#x27;t be the correct behavior (Requires sar instead of shr). It&#x27;s not surprising that RISC-V sticks to using two shifts because it takes a bunch of instructions to load a 64-bit constant into a register. Can&#x27;t even load a 32-bit constant into register with a single instruction on RV.</div><br/></div></div><div id="37452519" class="c"><input type="checkbox" id="c-37452519" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37453784">prev</a><span>|</span><a href="#37453407">next</a><span>|</span><label class="collapse" for="c-37452519">[-]</label><label class="expand" for="c-37452519">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen an article with a minimap on the side before, that&#x27;s kinda awesome</div><br/><div id="37452591" class="c"><input type="checkbox" id="c-37452591" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#37452519">parent</a><span>|</span><a href="#37453737">next</a><span>|</span><label class="collapse" for="c-37452591">[-]</label><label class="expand" for="c-37452591">[4 more]</label></div><br/><div class="children"><div class="content">I’m genuinely disappointed that it’s not done with -moz-element() on Firefox, but still duplicates all the content and just scales it down. Using -moz-element() has the potentially-useful side-effect that things like text selection will be visible in the minimap as well, as well as avoiding the problems of the duplication approach, such as that browser find functionality looks in the minimap too. (The minimap needs `user-select: none` which fixes some of the problems, but not all.)<p>I still hope that other browsers will eventually implement element(), along with cross-fade() which is also in the CSS Images Module Level 4 draft &lt;<a href="https:&#x2F;&#x2F;w3c.github.io&#x2F;csswg-drafts&#x2F;css-images-4&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;w3c.github.io&#x2F;csswg-drafts&#x2F;css-images-4&#x2F;</a>&gt;.</div><br/><div id="37453223" class="c"><input type="checkbox" id="c-37453223" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#37452519">root</a><span>|</span><a href="#37452591">parent</a><span>|</span><a href="#37453737">next</a><span>|</span><label class="collapse" for="c-37453223">[-]</label><label class="expand" for="c-37453223">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I’m genuinely disappointed that it’s not done with -moz-element() on Firefox</i><p>Given how few of us Firefox users there are out there, I&#x27;m sadly not surprised.</div><br/><div id="37453493" class="c"><input type="checkbox" id="c-37453493" checked=""/><div class="controls bullet"><span class="by">soultrees</span><span>|</span><a href="#37452519">root</a><span>|</span><a href="#37453223">parent</a><span>|</span><a href="#37453737">next</a><span>|</span><label class="collapse" for="c-37453493">[-]</label><label class="expand" for="c-37453493">[2 more]</label></div><br/><div class="children"><div class="content">Firefox till I die. (Or until they turn into a shit company)</div><br/><div id="37453991" class="c"><input type="checkbox" id="c-37453991" checked=""/><div class="controls bullet"><span class="by">pif_</span><span>|</span><a href="#37452519">root</a><span>|</span><a href="#37453493">parent</a><span>|</span><a href="#37453737">next</a><span>|</span><label class="collapse" for="c-37453991">[-]</label><label class="expand" for="c-37453991">[1 more]</label></div><br/><div class="children"><div class="content">Exactly the same for me! I&#x27;ve been using Firefox forever, and always will.</div><br/></div></div></div></div></div></div></div></div><div id="37453737" class="c"><input type="checkbox" id="c-37453737" checked=""/><div class="controls bullet"><span class="by">Propelloni</span><span>|</span><a href="#37452519">parent</a><span>|</span><a href="#37452591">prev</a><span>|</span><a href="#37453407">next</a><span>|</span><label class="collapse" for="c-37453737">[-]</label><label class="expand" for="c-37453737">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, it&#x27;s a joy to scroll through this article using the minimap. IMO a stark reminder how useless modern scrollbars have become.</div><br/></div></div></div></div><div id="37453407" class="c"><input type="checkbox" id="c-37453407" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#37452519">prev</a><span>|</span><a href="#37452695">next</a><span>|</span><label class="collapse" for="c-37453407">[-]</label><label class="expand" for="c-37453407">[2 more]</label></div><br/><div class="children"><div class="content">Just goes to show how much work goes into the illusion that strings are a simple data type.</div><br/><div id="37454103" class="c"><input type="checkbox" id="c-37454103" checked=""/><div class="controls bullet"><span class="by">tonyedgecombe</span><span>|</span><a href="#37453407">parent</a><span>|</span><a href="#37452695">next</a><span>|</span><label class="collapse" for="c-37454103">[-]</label><label class="expand" for="c-37454103">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div></div></div><div id="37452695" class="c"><input type="checkbox" id="c-37452695" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#37453407">prev</a><span>|</span><a href="#37453949">next</a><span>|</span><label class="collapse" for="c-37452695">[-]</label><label class="expand" for="c-37452695">[14 more]</label></div><br/><div class="children"><div class="content">Or you can replace the escape sequences right in the source text: it works since no escape sequence is shorter than the text it represents.</div><br/><div id="37453256" class="c"><input type="checkbox" id="c-37453256" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#37452695">parent</a><span>|</span><a href="#37453468">next</a><span>|</span><label class="collapse" for="c-37453256">[-]</label><label class="expand" for="c-37453256">[3 more]</label></div><br/><div class="children"><div class="content">The downside is that you lose the original and can&#x27;t refer to it anymore.  If (like OP) you are writing a compiler, you may need to spit out error messages, and will want to be able to say &quot;line X, column Y&quot;, or even just print out the original line itself.<p>And no, you can&#x27;t re-escape your unescaped text, as you can&#x27;t do so losslessly in all cases.  For some, the unescaped text might not obviously need re-escaping (e.g. the original text had a unicode escape for an emoji; you&#x27;ll &quot;forget&quot; that after you unescape it).</div><br/><div id="37453430" class="c"><input type="checkbox" id="c-37453430" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#37452695">root</a><span>|</span><a href="#37453256">parent</a><span>|</span><a href="#37453468">next</a><span>|</span><label class="collapse" for="c-37453430">[-]</label><label class="expand" for="c-37453430">[2 more]</label></div><br/><div class="children"><div class="content">Well, that&#x27;s a trade-off, as most things in the parser design. You can go the way of the compilers of the yore and report only the line numbers. Or you can maintain column numbers only for a single line, everything in the previous lines will get only a line number. Or you can store the column numbers in the tokens which works better if you lexer emits them one at a time and the parser is fine with that.</div><br/><div id="37454062" class="c"><input type="checkbox" id="c-37454062" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#37452695">root</a><span>|</span><a href="#37453430">parent</a><span>|</span><a href="#37453468">next</a><span>|</span><label class="collapse" for="c-37454062">[-]</label><label class="expand" for="c-37454062">[1 more]</label></div><br/><div class="children"><div class="content">Storing column numbers for every token just in case there might be an error likely weighs out the string allocation reduction. But for error messages it might suffice to output just the line number together with a snippet of the line at the error location. Most people probably don&#x27;t care about the exact column number, though it might be bad for other tools.</div><br/></div></div></div></div></div></div><div id="37453468" class="c"><input type="checkbox" id="c-37453468" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#37452695">parent</a><span>|</span><a href="#37453256">prev</a><span>|</span><a href="#37453233">next</a><span>|</span><label class="collapse" for="c-37453468">[-]</label><label class="expand" for="c-37453468">[1 more]</label></div><br/><div class="children"><div class="content">You can also be lazy about it -- store the quoted string with 1 escape  as 3 separate (fixed-size) tokens&#x2F;spans, and don&#x27;t actually allocate or decode strings until you need to.<p>In an interpreter there may be many string constants that aren&#x27;t used (e.g. docstrings in Python).<p>And probably in a compiler too, since you may import a ton of library code and only use 1 function.<p>Storing escapes as tokens also lets you point to them in warnings.  I think most compilers warn about bad octal escapes like \777 these days.</div><br/></div></div><div id="37453019" class="c"><input type="checkbox" id="c-37453019" checked=""/><div class="controls bullet"><span class="by">ksaj</span><span>|</span><a href="#37452695">parent</a><span>|</span><a href="#37453233">prev</a><span>|</span><a href="#37453023">next</a><span>|</span><label class="collapse" for="c-37453019">[-]</label><label class="expand" for="c-37453019">[7 more]</label></div><br/><div class="children"><div class="content">What about \n, which decodes to 0x0ah - two bytes to one byte?<p>I can&#x27;t think of any others like that, but newline in different OS&#x27;s get represented in various different ways (like DOS&#x27;s famous CRLF, which adds an 0x0dh to the recipe). Operating systems that use 0x0ah alone could very well be the only example.</div><br/><div id="37453132" class="c"><input type="checkbox" id="c-37453132" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#37452695">root</a><span>|</span><a href="#37453019">parent</a><span>|</span><a href="#37453028">next</a><span>|</span><label class="collapse" for="c-37453132">[-]</label><label class="expand" for="c-37453132">[1 more]</label></div><br/><div class="children"><div class="content">Reread the suggestion, you’ve got it back to front:<p>&gt; <i>no escape sequence is shorter than the text it represents</i><p>The idea is that you unescape immediately, and if necessary shuffle the remainder back, leaving a blank space at the end, but able to reuse the initial allocation.<p>Also, I don’t even know of anything that actually turns a \n into {CARRIAGE RETURN, LINE FEED}; if you want that, you’ll need \r\n. (A very few situations are a bit fuzzy about it, e.g. \r and \n are a bit wonky in Vim’s :substitute, but that’s all I can think of).</div><br/></div></div><div id="37453028" class="c"><input type="checkbox" id="c-37453028" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#37452695">root</a><span>|</span><a href="#37453019">parent</a><span>|</span><a href="#37453132">prev</a><span>|</span><a href="#37453262">next</a><span>|</span><label class="collapse" for="c-37453028">[-]</label><label class="expand" for="c-37453028">[4 more]</label></div><br/><div class="children"><div class="content">Note that while in your compiler you don&#x27;t really care about the representation that the OS expect in real files. It&#x27;s ok for your intermediate, in-memory representation to be meaningless to the OS.<p>Also, maybe it&#x27;s not a literal character for character replacement. Since lengths are probably changing, your pre-processed input might be shorter (or longer if you truly need to expand some escaped chars (and you have a program that just wants to break your compiler by abusing that escape sequence :P))</div><br/><div id="37453033" class="c"><input type="checkbox" id="c-37453033" checked=""/><div class="controls bullet"><span class="by">ksaj</span><span>|</span><a href="#37452695">root</a><span>|</span><a href="#37453028">parent</a><span>|</span><a href="#37453262">next</a><span>|</span><label class="collapse" for="c-37453033">[-]</label><label class="expand" for="c-37453033">[3 more]</label></div><br/><div class="children"><div class="content">Yes, but some OS&#x27;s use 0x0ah alone, which is half the bytes of \n representation. People from the 90&#x27;s will easily remember navigating the ^M (which is the 0x0dh showing up) showing up at the end of every line in a DOS text file when viewing them under a Linux text editor.</div><br/><div id="37453125" class="c"><input type="checkbox" id="c-37453125" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#37452695">root</a><span>|</span><a href="#37453033">parent</a><span>|</span><a href="#37453452">next</a><span>|</span><label class="collapse" for="c-37453125">[-]</label><label class="expand" for="c-37453125">[1 more]</label></div><br/><div class="children"><div class="content">This is a different problem around how to interpret new lines from a Windows file (\r\n) or maybe an old Mac version (\n\r to keep things incompatible I guess). If you are not happy with the OS&#x27;s choice for new lines, you can pre-process that when reading the input as the very first stage. This is what I meant when I said that your compiler doesn&#x27;t really care about the OS&#x27;s semantics once the file is in memory, you only need to respect them if you are writing intermediate state to files (like some IR).<p>The article is talking about how to handle escaped characters in the source, like literal `\n` you can see on `let hi = &quot;Hello\nWorld\nfrom my compiler!&quot;` using your average text editor (0x5c+0x6e in ASCII), and how to build an  efficient string type that mostly borrows views from the in-memory version of the source file (which could be a pre-processed version of the raw file if you hate odd line breaks).</div><br/></div></div><div id="37453452" class="c"><input type="checkbox" id="c-37453452" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#37452695">root</a><span>|</span><a href="#37453033">parent</a><span>|</span><a href="#37453125">prev</a><span>|</span><a href="#37453262">next</a><span>|</span><label class="collapse" for="c-37453452">[-]</label><label class="expand" for="c-37453452">[1 more]</label></div><br/><div class="children"><div class="content">Before the UNIX had the bright idea to represent newlines as single LFs in disk files and then write a bunch of code in the kernel for the tty driver to convert LF to and from CRLF pairs (which is what ttys actually used), everybody else used CRLF pair to indicate a linebreak. That&#x27;s why almost all network protocols use CRLF, and not because Microsoft invented the time machine and travelled into the seventies to hinder the UNIX adoption.</div><br/></div></div></div></div></div></div><div id="37453262" class="c"><input type="checkbox" id="c-37453262" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37452695">root</a><span>|</span><a href="#37453019">parent</a><span>|</span><a href="#37453028">prev</a><span>|</span><a href="#37453023">next</a><span>|</span><label class="collapse" for="c-37453262">[-]</label><label class="expand" for="c-37453262">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the two byte escape sequence <i>not shorter</i> than the one byte newline?<p>I do inline replacement of escaped values all the time, because the sequence is <i>always</i> longer than the replacement.</div><br/></div></div></div></div><div id="37453023" class="c"><input type="checkbox" id="c-37453023" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#37452695">parent</a><span>|</span><a href="#37453019">prev</a><span>|</span><a href="#37453949">next</a><span>|</span><label class="collapse" for="c-37453023">[-]</label><label class="expand" for="c-37453023">[1 more]</label></div><br/><div class="children"><div class="content">I was wondering the same thing, you can probably mess a bit with the input if you can deal with the drawbacks (which seem mild, pre-processed input might be shorter and column numbers might be off).</div><br/></div></div></div></div><div id="37453949" class="c"><input type="checkbox" id="c-37453949" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#37452695">prev</a><span>|</span><label class="collapse" for="c-37453949">[-]</label><label class="expand" for="c-37453949">[2 more]</label></div><br/><div class="children"><div class="content">I feel most code in Rust falls into the premature optimisation bucket. To prototype&#x2F;hack something, TypeScript is a much better choice. To then carefully optimise something, Rust is not high-level enough for me, and too restrictive in what you can do. The kind of high-level environment I am looking for here does not exist yet, so I guess people go for Rust because there is no better choice, but it feels like a dead end to me.</div><br/><div id="37454052" class="c"><input type="checkbox" id="c-37454052" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#37453949">parent</a><span>|</span><label class="collapse" for="c-37454052">[-]</label><label class="expand" for="c-37454052">[1 more]</label></div><br/><div class="children"><div class="content">How &#x27;high-level&#x27; are you hoping for here? Haskell? Rust has very high abstractions, but I guess the fundamentals are based around giving you control over low level stuff, which seems like a good balance to me. I&#x27;m not sure what specifically you&#x27;d hope to do which you can&#x27;t do in Rust.</div><br/></div></div></div></div></div></div></div></div></div></body></html>