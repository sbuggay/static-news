<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717318872462" as="style"/><link rel="stylesheet" href="styles.css?v=1717318872462"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/MultiArrayQueue/MultiArrayQueue">Multi-Array Queue</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>vitpro2213</span> | <span>29 comments</span></div><br/><div><div id="40550306" class="c"><input type="checkbox" id="c-40550306" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#40550396">next</a><span>|</span><label class="collapse" for="c-40550306">[-]</label><label class="expand" for="c-40550306">[4 more]</label></div><br/><div class="children"><div class="content">I appreciate the detailed descriptions and it’s a neat idea, but with respect, this does not strike me as particularly novel. I’d put money down that there are implementations of this in the wild that have been written and forgotten. Kind of analogous to the concept of convergent evolution, this is a natural solution to a particular problem that pops up every once in a while.</div><br/><div id="40550455" class="c"><input type="checkbox" id="c-40550455" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#40550306">parent</a><span>|</span><a href="#40551779">next</a><span>|</span><label class="collapse" for="c-40550455">[-]</label><label class="expand" for="c-40550455">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s semi-novel as I have not seen a queue exactly like this, but the structure of the queue itself is not novel - it closely resembles Brodnik et al&#x27;s RAOTS[1], which also uses an array of pointers to other arrays which increase geometrically in size. RAOTS offer amortized O(1) for most operatons and O(√n) excess space.<p>Also are Bagwell&#x27;s VLists[2], which were based on RAOTS, which he presents an example deque for, but this differs from OPs implementation.<p>A note about the VList versus RAOTS - in Bagwell&#x27;s paper he claimed the VList performs better, giving a comparison of several soft MSB calculations, which may have been required at the time this was published, but nearly all modern hardware has instructions for very quickly calculating the MSB (Either a singe-cycle instruction, or via count leading zeroes), so it&#x27;s questionable that there&#x27;s a real benefit to it as it requires additional metadata which also comes at the cost of power-of-2 alignment of the sub-arrays. However, the VList was designed to be used for a Lisp implementation, for which there may still be other benefits.<p><pre><code>    msb = 8*sizeof(size_t) - __builtin_clz(idx)
</code></pre>
Or in Java<p><pre><code>    msb = Long.SIZE - Long.numberOfLeadingZeroes(idx)
</code></pre>
This Multi-Array queue could perhaps benefit from this previous work. In particular, if you constrain the data arrays to be powers of 2 in size, you can use the MSB calculation to very quickly determine the index of the sub-array in the &quot;rings&quot; array, and by masking out the MSB, you determine the index in the sub-array. The RAOTS paper is a forgotten gem which every language developer should be aware of when they&#x27;re implementing lists in their stdlib. They can be used for immutable lists too in place of linked lists, as cons only requires copying the contents of one sub-array and copying the rings array. In fact, you can modify it slightly to make the rings array a plain old linked-list to make this even cheaper for consing immutable lists, at the cost of slower random-access.<p>[1]:<a href="https:&#x2F;&#x2F;cs.uwaterloo.ca&#x2F;research&#x2F;tr&#x2F;1999&#x2F;09&#x2F;CS-99-09.pdf" rel="nofollow">https:&#x2F;&#x2F;cs.uwaterloo.ca&#x2F;research&#x2F;tr&#x2F;1999&#x2F;09&#x2F;CS-99-09.pdf</a><p>[2]:<a href="https:&#x2F;&#x2F;core.ac.uk&#x2F;download&#x2F;pdf&#x2F;147902641.pdf" rel="nofollow">https:&#x2F;&#x2F;core.ac.uk&#x2F;download&#x2F;pdf&#x2F;147902641.pdf</a></div><br/><div id="40551598" class="c"><input type="checkbox" id="c-40551598" checked=""/><div class="controls bullet"><span class="by">vitpro2213</span><span>|</span><a href="#40550306">root</a><span>|</span><a href="#40550455">parent</a><span>|</span><a href="#40551779">next</a><span>|</span><label class="collapse" for="c-40551598">[-]</label><label class="expand" for="c-40551598">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, will look at it.<p>I actually thought the same: Given e.g. the complex structures published in ACM papers, it would be a surprise if MultiArrayQueue would be a completely new discovery.<p>We are not in the pioneer years of 1960&#x27;s anymore (unfortunately :-))</div><br/></div></div></div></div><div id="40551779" class="c"><input type="checkbox" id="c-40551779" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40550306">parent</a><span>|</span><a href="#40550455">prev</a><span>|</span><a href="#40550396">next</a><span>|</span><label class="collapse" for="c-40551779">[-]</label><label class="expand" for="c-40551779">[1 more]</label></div><br/><div class="children"><div class="content">In particular, embedded stuff (with tight resource constraints) is where you&#x27;re likely to find this and other &quot;specialised&quot; data structures in use.</div><br/></div></div></div></div><div id="40550396" class="c"><input type="checkbox" id="c-40550396" checked=""/><div class="controls bullet"><span class="by">evil-olive</span><span>|</span><a href="#40550306">prev</a><span>|</span><a href="#40550095">next</a><span>|</span><label class="collapse" for="c-40550396">[-]</label><label class="expand" for="c-40550396">[1 more]</label></div><br/><div class="children"><div class="content">reminds me of the blist [0] package in Python, implemented using B+ trees and offering O(log n) performance for operations that are O(n) with the built-in list type - such as insertion or deletion of items at the start of the list, or somewhere in the middle.<p>sadly it seems to be abandonware, with no commits in the last 10 years and compilation errors on Python 3.9 and above [1]<p>0: <a href="http:&#x2F;&#x2F;stutzbachenterprises.com&#x2F;blist&#x2F;implementation.html" rel="nofollow">http:&#x2F;&#x2F;stutzbachenterprises.com&#x2F;blist&#x2F;implementation.html</a><p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;DanielStutzbach&#x2F;blist&#x2F;issues&#x2F;90">https:&#x2F;&#x2F;github.com&#x2F;DanielStutzbach&#x2F;blist&#x2F;issues&#x2F;90</a></div><br/></div></div><div id="40550095" class="c"><input type="checkbox" id="c-40550095" checked=""/><div class="controls bullet"><span class="by">time0ut</span><span>|</span><a href="#40550396">prev</a><span>|</span><a href="#40550809">next</a><span>|</span><label class="collapse" for="c-40550095">[-]</label><label class="expand" for="c-40550095">[2 more]</label></div><br/><div class="children"><div class="content">Interesting. A lot of care went into this. Thank you for sharing.<p>Is there a reason you chose not implement java.util.Queue?</div><br/><div id="40551606" class="c"><input type="checkbox" id="c-40551606" checked=""/><div class="controls bullet"><span class="by">vitpro2213</span><span>|</span><a href="#40550095">parent</a><span>|</span><a href="#40550809">next</a><span>|</span><label class="collapse" for="c-40551606">[-]</label><label class="expand" for="c-40551606">[1 more]</label></div><br/><div class="children"><div class="content">Implementing Queue would mean also implementing Collection and Iterable, and this would bring pains and ugliness, especially with the concurrent code.<p>Look e.g. at the disclaimers at the size method of java.util.concurrent.ConcurrentLinkedQueue.</div><br/></div></div></div></div><div id="40550809" class="c"><input type="checkbox" id="c-40550809" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#40550095">prev</a><span>|</span><a href="#40549026">next</a><span>|</span><label class="collapse" for="c-40550809">[-]</label><label class="expand" for="c-40550809">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of the queue used by libuv: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;61163161&#x2F;how-does-the-libuv-implementation-of-non-blockingness-work-exactly&#x2F;61415264#61415264" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;61163161&#x2F;how-does-the-li...</a></div><br/></div></div><div id="40549026" class="c"><input type="checkbox" id="c-40549026" checked=""/><div class="controls bullet"><span class="by">cyansmoker</span><span>|</span><a href="#40550809">prev</a><span>|</span><a href="#40548541">next</a><span>|</span><label class="collapse" for="c-40549026">[-]</label><label class="expand" for="c-40549026">[1 more]</label></div><br/><div class="children"><div class="content">Hi @vitpro2213 it&#x27;s very interesting (at least to me) to find about this data structure a few months after I had a need for its somewhat distant cousin: <a href="https:&#x2F;&#x2F;github.com&#x2F;Fusion&#x2F;slotmachine">https:&#x2F;&#x2F;github.com&#x2F;Fusion&#x2F;slotmachine</a><p>In my case, I needed a way to book and release two-ports tuples really fast to accommodate a RTP simulator. So, I wrote that slotmachine data structure and have been running in in production for months and can confirm: yes, performance is good.<p>Note: I should mention that my approach is almost exactly opposite to yours: I create a final backing slice, then create the traversal slices.</div><br/></div></div><div id="40548541" class="c"><input type="checkbox" id="c-40548541" checked=""/><div class="controls bullet"><span class="by">bigdubs</span><span>|</span><a href="#40549026">prev</a><span>|</span><a href="#40551200">next</a><span>|</span><label class="collapse" for="c-40548541">[-]</label><label class="expand" for="c-40548541">[9 more]</label></div><br/><div class="children"><div class="content">Many ring-buffer implementations grow the backing storage array transparently on enqueue but do so in place, discarding the old arrays; what&#x27;s the advantage of keeping the previous arrays? Naively I&#x27;d say it would reduce GC churn because you wouldn&#x27;t have to free the old arrays, but I&#x27;m curious what the impact of that is in benchmarks.<p>Separately; the simulator is cool and very helpful!</div><br/><div id="40548972" class="c"><input type="checkbox" id="c-40548972" checked=""/><div class="controls bullet"><span class="by">vitpro2213</span><span>|</span><a href="#40548541">parent</a><span>|</span><a href="#40549561">next</a><span>|</span><label class="collapse" for="c-40548972">[-]</label><label class="expand" for="c-40548972">[7 more]</label></div><br/><div class="children"><div class="content">If you discard the old array (and allocate a bigger one before), you must also copy all enqueued material.<p>Also this one enqueue will be mega expensive - a clear &quot;fat tail&quot; in the latency histogram.<p>In MultiArrayQueue you keep all already enqueued material in-place, &quot;just&quot; allocate the bigger array, register the new diversion, enqueue the one new element - and done.<p>Thanks</div><br/><div id="40550107" class="c"><input type="checkbox" id="c-40550107" checked=""/><div class="controls bullet"><span class="by">Szpadel</span><span>|</span><a href="#40548541">root</a><span>|</span><a href="#40548972">parent</a><span>|</span><a href="#40549561">next</a><span>|</span><label class="collapse" for="c-40550107">[-]</label><label class="expand" for="c-40550107">[6 more]</label></div><br/><div class="children"><div class="content">why not free previous smaller chunk after reader finished reading from it?<p>for me it would be better to allocate new buffer but allow reading from old one until it contains data and after that dealocate it and keep only new one in use</div><br/><div id="40550508" class="c"><input type="checkbox" id="c-40550508" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#40548541">root</a><span>|</span><a href="#40550107">parent</a><span>|</span><a href="#40551246">next</a><span>|</span><label class="collapse" for="c-40550508">[-]</label><label class="expand" for="c-40550508">[1 more]</label></div><br/><div class="children"><div class="content">You might run into ABA, though that isn&#x27;t an issue for managed languages.</div><br/></div></div><div id="40551246" class="c"><input type="checkbox" id="c-40551246" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#40548541">root</a><span>|</span><a href="#40550107">parent</a><span>|</span><a href="#40550508">prev</a><span>|</span><a href="#40549561">next</a><span>|</span><label class="collapse" for="c-40551246">[-]</label><label class="expand" for="c-40551246">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, leaving small old buffers behind seems like a major no-no to me. It could be useful if you think you&#x27;ll shrink back down, but it feels like cache locality suffering and iteration&#x2F;tracking penalties strongly incentive getting rid of the old buffer asap.<p>One other thing I want to shout out, I saw what I thought was a really neat multicast ring buffer the other day where the author has an atomic for each element, rather than the typical reader&#x2F;writer atomics. The promise was having much less contention on any given atomic, in most cases. <a href="https:&#x2F;&#x2F;github.com&#x2F;rezabrizi&#x2F;SPMC-Queue">https:&#x2F;&#x2F;github.com&#x2F;rezabrizi&#x2F;SPMC-Queue</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40410172">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40410172</a></div><br/><div id="40551615" class="c"><input type="checkbox" id="c-40551615" checked=""/><div class="controls bullet"><span class="by">vitpro2213</span><span>|</span><a href="#40548541">root</a><span>|</span><a href="#40551246">parent</a><span>|</span><a href="#40549561">next</a><span>|</span><label class="collapse" for="c-40551615">[-]</label><label class="expand" for="c-40551615">[3 more]</label></div><br/><div class="children"><div class="content">Removing anything in non-blocking structures is problematic, see e.g. the referenced lecture of Professor Scott.<p>You never know how many concurrent threads still &quot;are&quot; on the place you wish to remove.<p>You would have to deal with stuff like hazard pointers, limbo lists and the like.<p>Better to keep the small arrays there.</div><br/><div id="40552304" class="c"><input type="checkbox" id="c-40552304" checked=""/><div class="controls bullet"><span class="by">Szpadel</span><span>|</span><a href="#40548541">root</a><span>|</span><a href="#40551615">parent</a><span>|</span><a href="#40549561">next</a><span>|</span><label class="collapse" for="c-40552304">[-]</label><label class="expand" for="c-40552304">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this only issue when you allow referencing data in queue?<p>If queue only allows to copy out data you can increase reader pointer after data were copied to different buffer, therefore nothing can be at the place we are removing</div><br/><div id="40552550" class="c"><input type="checkbox" id="c-40552550" checked=""/><div class="controls bullet"><span class="by">vitpro2213</span><span>|</span><a href="#40548541">root</a><span>|</span><a href="#40552304">parent</a><span>|</span><a href="#40549561">next</a><span>|</span><label class="collapse" for="c-40552550">[-]</label><label class="expand" for="c-40552550">[1 more]</label></div><br/><div class="children"><div class="content">With ConcurrentMultiArrayQueue, there can be N threads INSIDE of the program code of the Queue, running or preempted (for a not predictable time) and you cannot control it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40549561" class="c"><input type="checkbox" id="c-40549561" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40548541">parent</a><span>|</span><a href="#40548972">prev</a><span>|</span><a href="#40551200">next</a><span>|</span><label class="collapse" for="c-40549561">[-]</label><label class="expand" for="c-40549561">[1 more]</label></div><br/><div class="children"><div class="content">When I wrote it [0], the goal was semi-bounded [1] latency.<p>[0] It needs a refactor, but here&#x27;s some version of the idea. <a href="https:&#x2F;&#x2F;github.com&#x2F;hmusgrave&#x2F;zcirc">https:&#x2F;&#x2F;github.com&#x2F;hmusgrave&#x2F;zcirc</a><p>[1] You&#x27;re not _really_ bounded since you have blocking calls to the underlying allocator (usually somewhere close to the OS, and even that can do more work than you might expect when you ask for a contiguous array), but it&#x27;s still much cheaper than a bulk copy.</div><br/></div></div></div></div><div id="40551200" class="c"><input type="checkbox" id="c-40551200" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#40548541">prev</a><span>|</span><a href="#40548644">next</a><span>|</span><label class="collapse" for="c-40551200">[-]</label><label class="expand" for="c-40551200">[1 more]</label></div><br/><div class="children"><div class="content">So similar to arraylist where it doubles allocation automatically when it runs out of room?</div><br/></div></div><div id="40548644" class="c"><input type="checkbox" id="c-40548644" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#40551200">prev</a><span>|</span><a href="#40550478">next</a><span>|</span><label class="collapse" for="c-40548644">[-]</label><label class="expand" for="c-40548644">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Do not send me Pull Requests - the code is small so I want to maintain it single-handedly.<p>Interesting contribution policy. Makes sense in lieu of producing a strict style guide, I suppose.</div><br/><div id="40549135" class="c"><input type="checkbox" id="c-40549135" checked=""/><div class="controls bullet"><span class="by">splix</span><span>|</span><a href="#40548644">parent</a><span>|</span><a href="#40549119">next</a><span>|</span><label class="collapse" for="c-40549135">[-]</label><label class="expand" for="c-40549135">[2 more]</label></div><br/><div class="children"><div class="content">While the author probably wants to own the main code, I&#x27;m sure there are other things he may want to get help from external contributors.<p>For example unit tests. At least to show that it works, and how to use it. Also a build config, like gradle&#x2F;maven, so others would be able to use this lib.</div><br/><div id="40550500" class="c"><input type="checkbox" id="c-40550500" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#40548644">root</a><span>|</span><a href="#40549135">parent</a><span>|</span><a href="#40549119">next</a><span>|</span><label class="collapse" for="c-40550500">[-]</label><label class="expand" for="c-40550500">[1 more]</label></div><br/><div class="children"><div class="content">The author says that: &quot;Reviews, tests and comments are welcome&quot;</div><br/></div></div></div></div><div id="40549119" class="c"><input type="checkbox" id="c-40549119" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#40548644">parent</a><span>|</span><a href="#40549135">prev</a><span>|</span><a href="#40550478">next</a><span>|</span><label class="collapse" for="c-40549119">[-]</label><label class="expand" for="c-40549119">[5 more]</label></div><br/><div class="children"><div class="content">I thought github let you turn off PRs on a repo -- the author may wanna do that.</div><br/><div id="40549472" class="c"><input type="checkbox" id="c-40549472" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#40548644">root</a><span>|</span><a href="#40549119">parent</a><span>|</span><a href="#40549395">next</a><span>|</span><label class="collapse" for="c-40549472">[-]</label><label class="expand" for="c-40549472">[1 more]</label></div><br/><div class="children"><div class="content">No, you can&#x27;t disable the PRs tab; you can disable any tab except Code and PRs. Torvalds famously complained about this  because he handles pull requests through email, so all PRs on his Linux repo are useless.</div><br/></div></div><div id="40549395" class="c"><input type="checkbox" id="c-40549395" checked=""/><div class="controls bullet"><span class="by">tidwall</span><span>|</span><a href="#40548644">root</a><span>|</span><a href="#40549119">parent</a><span>|</span><a href="#40549472">prev</a><span>|</span><a href="#40550478">next</a><span>|</span><label class="collapse" for="c-40549395">[-]</label><label class="expand" for="c-40549395">[3 more]</label></div><br/><div class="children"><div class="content">PRs cannot be disabled.</div><br/><div id="40549516" class="c"><input type="checkbox" id="c-40549516" checked=""/><div class="controls bullet"><span class="by">kubanczyk</span><span>|</span><a href="#40548644">root</a><span>|</span><a href="#40549395">parent</a><span>|</span><a href="#40550478">next</a><span>|</span><label class="collapse" for="c-40549516">[-]</label><label class="expand" for="c-40549516">[2 more]</label></div><br/><div class="children"><div class="content">...without archiving the repo.<p>Archived repos however have that ugly yellow warning.</div><br/><div id="40550259" class="c"><input type="checkbox" id="c-40550259" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#40548644">root</a><span>|</span><a href="#40549516">parent</a><span>|</span><a href="#40550478">next</a><span>|</span><label class="collapse" for="c-40550259">[-]</label><label class="expand" for="c-40550259">[1 more]</label></div><br/><div class="children"><div class="content">Can you still push to the repo? Perhaps via --force?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40550478" class="c"><input type="checkbox" id="c-40550478" checked=""/><div class="controls bullet"><span class="by">TheDudeMan</span><span>|</span><a href="#40548644">prev</a><span>|</span><label class="collapse" for="c-40550478">[-]</label><label class="expand" for="c-40550478">[1 more]</label></div><br/><div class="children"><div class="content">Why not also a multi-array List?</div><br/></div></div></div></div></div></div></div></body></html>