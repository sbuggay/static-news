<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727341275470" as="style"/><link rel="stylesheet" href="styles.css?v=1727341275470"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/tummychow/git-absorb">Git-absorb: Git commit –fixup, but automatic</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>striking</span> | <span>109 comments</span></div><br/><div><div id="41654268" class="c"><input type="checkbox" id="c-41654268" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#41653389">next</a><span>|</span><label class="collapse" for="c-41654268">[-]</label><label class="expand" for="c-41654268">[11 more]</label></div><br/><div class="children"><div class="content">The negativity in the comments here is unwarranted in my opinion. I&#x27;ve been using `git absorb` for years and it works amazingly well. I use it in addition to manual fixups. My most common uses of git-absorb, but definitely not the only, are when I submit a PR with multiple commits and it fails CI for whatever reason. If fixing CI requires changes across multiple commits (say, lint violations), then git-absorb will almost always find the right commit for each change automatically. It saves the tedium of finding the right commit for each change. False positives are virtually non-existent in my experience. False negatives do happen, but then you just fall back to the manual approach.<p>It seems like some would reply and say PRs should just be one commit. Or that they will be squashed anyway. And sure, that is sometimes the case. But not always. I tend to prefer logically small commits when possible, and it&#x27;s not always practical to break them up across multiple PRs. Perhaps partially due to how GitHub works.<p>I use this workflow on all of my projects on GitHub.</div><br/><div id="41654487" class="c"><input type="checkbox" id="c-41654487" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41654268">parent</a><span>|</span><a href="#41654990">next</a><span>|</span><label class="collapse" for="c-41654487">[-]</label><label class="expand" for="c-41654487">[5 more]</label></div><br/><div class="children"><div class="content">I’ve been using autofixup for this and it’s been ok but not great, it can be quite slow as things grown, and it doesn’t say anything when there was no match so it’s easy to miss. How does absorb surface that?<p>&gt; Perhaps partially due to how GitHub works.<p>That’s definitely a major factor, I’d like to use stacked PRs they sound really neat, but GitHub.<p>Also even with stacked PRs I figure sometimes you’re at the top of the stack and you change things which affect multiple commits &#x2F; prs anyway, surely in that case you need to fixup other commits than the ToS?</div><br/><div id="41655513" class="c"><input type="checkbox" id="c-41655513" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#41654268">root</a><span>|</span><a href="#41654487">parent</a><span>|</span><a href="#41655347">next</a><span>|</span><label class="collapse" for="c-41655513">[-]</label><label class="expand" for="c-41655513">[1 more]</label></div><br/><div class="children"><div class="content">The term Stacked PRs already sounds like a term that was invented specifically in order to communicate in a GitHub-influenced context. Because Stacked PRs are just a reinvention of being able to review a commit at a time (the stack part is straightforward).</div><br/></div></div><div id="41655347" class="c"><input type="checkbox" id="c-41655347" checked=""/><div class="controls bullet"><span class="by">Degorath</span><span>|</span><a href="#41654268">root</a><span>|</span><a href="#41654487">parent</a><span>|</span><a href="#41655513">prev</a><span>|</span><a href="#41654985">next</a><span>|</span><label class="collapse" for="c-41655347">[-]</label><label class="expand" for="c-41655347">[1 more]</label></div><br/><div class="children"><div class="content">GitHub&#x27;s quirks definitely make life much harder than it needs to be, but I&#x27;ve been using `git machete` for months now with great success in my team. The __one__ thing GitHub has that makes it all work is the fact that if you merge the parentmost branch, its immediate child will retarget its base branch.<p>I think if I had full &quot;control&quot; over my company&#x27;s SCM workflows I would use a tool that considers a branch as a workspace and every commit in the branch becomes its own PR (personal preference, but in my experience it also motivates people to split changes more), but alas.</div><br/></div></div><div id="41654985" class="c"><input type="checkbox" id="c-41654985" checked=""/><div class="controls bullet"><span class="by">Zitrax</span><span>|</span><a href="#41654268">root</a><span>|</span><a href="#41654487">parent</a><span>|</span><a href="#41655347">prev</a><span>|</span><a href="#41654990">next</a><span>|</span><label class="collapse" for="c-41654985">[-]</label><label class="expand" for="c-41654985">[2 more]</label></div><br/><div class="children"><div class="content">I assume you refer to <a href="https:&#x2F;&#x2F;github.com&#x2F;torbiak&#x2F;git-autofixup">https:&#x2F;&#x2F;github.com&#x2F;torbiak&#x2F;git-autofixup</a>. I have also used it, and its ok but not perfect.</div><br/><div id="41655215" class="c"><input type="checkbox" id="c-41655215" checked=""/><div class="controls bullet"><span class="by">krobelus</span><span>|</span><a href="#41654268">root</a><span>|</span><a href="#41654985">parent</a><span>|</span><a href="#41654990">next</a><span>|</span><label class="collapse" for="c-41655215">[-]</label><label class="expand" for="c-41655215">[1 more]</label></div><br/><div class="children"><div class="content">I use git autofixup; it was much better than git absorb last time I checked<p>&gt; it doesn’t say anything when there was no match<p>that&#x27;s what it should do<p>&gt; it can be quite slow as things grown<p>How? All the slowness (on large repos) I&#x27;ve seen has been fixed.</div><br/></div></div></div></div></div></div><div id="41654990" class="c"><input type="checkbox" id="c-41654990" checked=""/><div class="controls bullet"><span class="by">notlinus</span><span>|</span><a href="#41654268">parent</a><span>|</span><a href="#41654487">prev</a><span>|</span><a href="#41653389">next</a><span>|</span><label class="collapse" for="c-41654990">[-]</label><label class="expand" for="c-41654990">[5 more]</label></div><br/><div class="children"><div class="content">Criticism isn&#x27;t negativity. We&#x27;re not Pollyannas here, we&#x27;re adults who can handle critique.</div><br/><div id="41655389" class="c"><input type="checkbox" id="c-41655389" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#41654268">root</a><span>|</span><a href="#41654990">parent</a><span>|</span><a href="#41653389">next</a><span>|</span><label class="collapse" for="c-41655389">[-]</label><label class="expand" for="c-41655389">[4 more]</label></div><br/><div class="children"><div class="content">I had to look up the reference, and based on the wikipedia plot summary at least, I admit I don&#x27;t quite get the relevance. I expected a plot where someone handles criticism quite badly and suffers as a result, but in fact the plot was actually about someone who handled criticism very well instead, and improved the lives of others as a result?<p>So now I&#x27;m curious! In what way does Pollyanna relate to adults who can&#x27;t handle critique? Have I got the wrong Pollyanna by any chance? xD</div><br/><div id="41656051" class="c"><input type="checkbox" id="c-41656051" checked=""/><div class="controls bullet"><span class="by">talideon</span><span>|</span><a href="#41654268">root</a><span>|</span><a href="#41655389">parent</a><span>|</span><a href="#41655464">next</a><span>|</span><label class="collapse" for="c-41656051">[-]</label><label class="expand" for="c-41656051">[1 more]</label></div><br/><div class="children"><div class="content">A Pollyanna is somebody who&#x27;s cheerful and optimistic <i>to a fault</i>, i.e., even when it&#x27;s unjustified.<p>The plot summary of the book is likely not what you should be reading as it&#x27;s become an idiom. Something like Wiktionary or another dictionary would be a better place to look it up.<p>In this case, it&#x27;s not about being able to receive criticism, but about being reticent about _giving_ it.</div><br/></div></div><div id="41655464" class="c"><input type="checkbox" id="c-41655464" checked=""/><div class="controls bullet"><span class="by">unkulunkulu</span><span>|</span><a href="#41654268">root</a><span>|</span><a href="#41655389">parent</a><span>|</span><a href="#41656051">prev</a><span>|</span><a href="#41653389">next</a><span>|</span><label class="collapse" for="c-41655464">[-]</label><label class="expand" for="c-41655464">[2 more]</label></div><br/><div class="children"><div class="content">I’ve also thought about that based on the same info, i.e. not reading the source completely.<p>There is a notion of a “Pollyanna mode” in schematherapy. What it means is ignoring negative facts and challenges with an outwardly positive attitude and avoiding addressing the issues themselves.<p>This certainly can be harmful to oneself. Another harmful thing is hating and bashing oneself for mistakes and faults and I won’t make a comparative judgement, but a healthy way is supposed to be along the lines of speaking up openly about what bothers you and thinking what can be done about it if at all.</div><br/><div id="41655542" class="c"><input type="checkbox" id="c-41655542" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#41654268">root</a><span>|</span><a href="#41655464">parent</a><span>|</span><a href="#41653389">next</a><span>|</span><label class="collapse" for="c-41655542">[-]</label><label class="expand" for="c-41655542">[1 more]</label></div><br/><div class="children"><div class="content">This makes sense. Thank you for your comment! Learnt something new today :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41653389" class="c"><input type="checkbox" id="c-41653389" checked=""/><div class="controls bullet"><span class="by">AndrewHampton</span><span>|</span><a href="#41654268">prev</a><span>|</span><a href="#41653797">next</a><span>|</span><label class="collapse" for="c-41653389">[-]</label><label class="expand" for="c-41653389">[12 more]</label></div><br/><div class="children"><div class="content">FWIW, I&#x27;ve been using this alias for the past couple years for fixup commits, and I&#x27;ve been happy with it:<p>&gt; gfx=&#x27;git commit --fixup $(git log $(git merge-base main HEAD)..HEAD --oneline| fzf| cut -d&quot; &quot; -f1)&#x27;<p>It shows you the commits on the current branch and lets you select one via fzf. It then creates the fixup commit based on the commit you selected.</div><br/><div id="41653419" class="c"><input type="checkbox" id="c-41653419" checked=""/><div class="controls bullet"><span class="by">nickspain</span><span>|</span><a href="#41653389">parent</a><span>|</span><a href="#41653575">next</a><span>|</span><label class="collapse" for="c-41653419">[-]</label><label class="expand" for="c-41653419">[1 more]</label></div><br/><div class="children"><div class="content">Nice! I use git revise[^1] a lot which does a similar thing but without the fixup commit. I I’ll try using fzf to make it interactive though. Thanks!<p>[^1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;mystor&#x2F;git-revise">https:&#x2F;&#x2F;github.com&#x2F;mystor&#x2F;git-revise</a></div><br/></div></div><div id="41653575" class="c"><input type="checkbox" id="c-41653575" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41653389">parent</a><span>|</span><a href="#41653419">prev</a><span>|</span><a href="#41654633">next</a><span>|</span><label class="collapse" for="c-41653575">[-]</label><label class="expand" for="c-41653575">[4 more]</label></div><br/><div class="children"><div class="content">If it only lets you select one, that&#x27;s strictly less powerful. What if I want some parts of it into one commit and another parts into another? The `hg absorb` works for this case.</div><br/><div id="41656106" class="c"><input type="checkbox" id="c-41656106" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#41653389">root</a><span>|</span><a href="#41653575">parent</a><span>|</span><a href="#41654003">next</a><span>|</span><label class="collapse" for="c-41656106">[-]</label><label class="expand" for="c-41656106">[1 more]</label></div><br/><div class="children"><div class="content">Then you use `git gui`, which is part of the git distribution itself, or `tig` if TUIs are your thing. I have a key binding for `git commit --squash=%(commit)` in my tig config, so I can interactively select lines or hunks to stage and then the target commit for the squash.</div><br/></div></div><div id="41654003" class="c"><input type="checkbox" id="c-41654003" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#41653389">root</a><span>|</span><a href="#41653575">parent</a><span>|</span><a href="#41656106">prev</a><span>|</span><a href="#41654117">next</a><span>|</span><label class="collapse" for="c-41654003">[-]</label><label class="expand" for="c-41654003">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like what `git add -p` is for, stage part of the current changes.</div><br/></div></div><div id="41654117" class="c"><input type="checkbox" id="c-41654117" checked=""/><div class="controls bullet"><span class="by">k3vinw</span><span>|</span><a href="#41653389">root</a><span>|</span><a href="#41653575">parent</a><span>|</span><a href="#41654003">prev</a><span>|</span><a href="#41654633">next</a><span>|</span><label class="collapse" for="c-41654117">[-]</label><label class="expand" for="c-41654117">[1 more]</label></div><br/><div class="children"><div class="content">Might be able to use the multimode flag in the fzf command above and it should let you select more than one using Tab and Shift+Tab.</div><br/></div></div></div></div><div id="41654633" class="c"><input type="checkbox" id="c-41654633" checked=""/><div class="controls bullet"><span class="by">johnnypangs</span><span>|</span><a href="#41653389">parent</a><span>|</span><a href="#41653575">prev</a><span>|</span><a href="#41653590">next</a><span>|</span><label class="collapse" for="c-41654633">[-]</label><label class="expand" for="c-41654633">[3 more]</label></div><br/><div class="children"><div class="content">I’ve been using this:<p>alias gfixup=&quot;git commit -v --fixup HEAD &amp;&amp; GIT_SEQUENCE_EDITOR=touch git rebase -i --stat --autosquash --autostash HEAD~2&quot;<p>From what I understand it does the same thing as this crate for the most part. All I do after is:<p>git push —force-with-lease<p>Not sure what you get from the crate otherwise</div><br/><div id="41654837" class="c"><input type="checkbox" id="c-41654837" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41653389">root</a><span>|</span><a href="#41654633">parent</a><span>|</span><a href="#41654657">next</a><span>|</span><label class="collapse" for="c-41654837">[-]</label><label class="expand" for="c-41654837">[1 more]</label></div><br/><div class="children"><div class="content">Your alias seems like a completely unecessary complexity. If you want to meld new changes into your branch head you can just alias “git commit --amend”, you don’t need that mess.<p>Absorb will find the commits to fix up for each change in the working copy, it doesn’t just merge everything into the head.</div><br/></div></div><div id="41654657" class="c"><input type="checkbox" id="c-41654657" checked=""/><div class="controls bullet"><span class="by">johnnypangs</span><span>|</span><a href="#41653389">root</a><span>|</span><a href="#41654633">parent</a><span>|</span><a href="#41654837">prev</a><span>|</span><a href="#41653590">next</a><span>|</span><label class="collapse" for="c-41654657">[-]</label><label class="expand" for="c-41654657">[1 more]</label></div><br/><div class="children"><div class="content">I guess the crate version is easier to soft reset?</div><br/></div></div></div></div><div id="41653590" class="c"><input type="checkbox" id="c-41653590" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#41653389">parent</a><span>|</span><a href="#41654633">prev</a><span>|</span><a href="#41653848">next</a><span>|</span><label class="collapse" for="c-41653590">[-]</label><label class="expand" for="c-41653590">[2 more]</label></div><br/><div class="children"><div class="content">sounds like how magit lets you create fixup commits in emacs</div><br/><div id="41654459" class="c"><input type="checkbox" id="c-41654459" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41653389">root</a><span>|</span><a href="#41653590">parent</a><span>|</span><a href="#41653848">next</a><span>|</span><label class="collapse" for="c-41654459">[-]</label><label class="expand" for="c-41654459">[1 more]</label></div><br/><div class="children"><div class="content">Worse in fact, since magit lets you fixup, squash, or instafix.</div><br/></div></div></div></div></div></div><div id="41653797" class="c"><input type="checkbox" id="c-41653797" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41653389">prev</a><span>|</span><a href="#41654756">next</a><span>|</span><label class="collapse" for="c-41653797">[-]</label><label class="expand" for="c-41653797">[8 more]</label></div><br/><div class="children"><div class="content">I tried using this tool after seeing recommendations for it, but IME it got the parent commit wrong enough times that the work to undo the damage was more than if I had looked up the commit myself and used `--fixup` instead. So I moved back to this manual workflow pretty quickly.<p>I prefer having full control over my commit history, and this tool is too much magic for my taste. I&#x27;m sure that it could be improved so that mistakes are rare, but I&#x27;m not sure I would trust it enough to not have to review its work anyway.</div><br/><div id="41653865" class="c"><input type="checkbox" id="c-41653865" checked=""/><div class="controls bullet"><span class="by">3eb7988a1663</span><span>|</span><a href="#41653797">parent</a><span>|</span><a href="#41653943">next</a><span>|</span><label class="collapse" for="c-41653865">[-]</label><label class="expand" for="c-41653865">[4 more]</label></div><br/><div class="children"><div class="content">I use lazygit for this. Keyboard driven TUI which lets you easily re-order&#x2F;squash commits with minimum fuss. Being able to see them all laid out means no futzing with identifying the right ids.</div><br/><div id="41653948" class="c"><input type="checkbox" id="c-41653948" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41653797">root</a><span>|</span><a href="#41653865">parent</a><span>|</span><a href="#41654483">next</a><span>|</span><label class="collapse" for="c-41653948">[-]</label><label class="expand" for="c-41653948">[1 more]</label></div><br/><div class="children"><div class="content">I rarely refer to commits by their IDs in these cases, though. More often than not I use the relative `HEAD~n`, when it&#x27;s easy to determine `n` visually. With a few aliases, the manual fixup workflow really doesn&#x27;t take much effort.</div><br/></div></div><div id="41654483" class="c"><input type="checkbox" id="c-41654483" checked=""/><div class="controls bullet"><span class="by">arcanemachiner</span><span>|</span><a href="#41653797">root</a><span>|</span><a href="#41653865">parent</a><span>|</span><a href="#41653948">prev</a><span>|</span><a href="#41654154">next</a><span>|</span><label class="collapse" for="c-41654483">[-]</label><label class="expand" for="c-41654483">[1 more]</label></div><br/><div class="children"><div class="content">I love lazygit so much. I use it all the time, and it&#x27;s constantly improving my workflow.</div><br/></div></div><div id="41654154" class="c"><input type="checkbox" id="c-41654154" checked=""/><div class="controls bullet"><span class="by">montag</span><span>|</span><a href="#41653797">root</a><span>|</span><a href="#41653865">parent</a><span>|</span><a href="#41654483">prev</a><span>|</span><a href="#41653943">next</a><span>|</span><label class="collapse" for="c-41654154">[-]</label><label class="expand" for="c-41654154">[1 more]</label></div><br/><div class="children"><div class="content">This sounds just right.</div><br/></div></div></div></div><div id="41653943" class="c"><input type="checkbox" id="c-41653943" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41653797">parent</a><span>|</span><a href="#41653865">prev</a><span>|</span><a href="#41655192">next</a><span>|</span><label class="collapse" for="c-41653943">[-]</label><label class="expand" for="c-41653943">[2 more]</label></div><br/><div class="children"><div class="content">If it just automatically created the fix up commit and moved it to the proper place in the commit tree, I’d be happy with that. You can then run a one-liner to merge the fix up commits after reviewing.</div><br/><div id="41654112" class="c"><input type="checkbox" id="c-41654112" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#41653797">root</a><span>|</span><a href="#41653943">parent</a><span>|</span><a href="#41655192">next</a><span>|</span><label class="collapse" for="c-41654112">[-]</label><label class="expand" for="c-41654112">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what it does by default.<p>Only if you pass --and-rebase does it actually do the autosquash rebase for you.</div><br/></div></div></div></div><div id="41655192" class="c"><input type="checkbox" id="c-41655192" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41653797">parent</a><span>|</span><a href="#41653943">prev</a><span>|</span><a href="#41654756">next</a><span>|</span><label class="collapse" for="c-41655192">[-]</label><label class="expand" for="c-41655192">[1 more]</label></div><br/><div class="children"><div class="content">The more worrying thing for me is how would you know whether it got it right or wrong? I suspect if you&#x27;re using it the point is you&#x27;re not going to go and inspect each commit manually. IMO something that looks right is far more dangerous than something that&#x27;s merely wrong.</div><br/></div></div></div></div><div id="41654756" class="c"><input type="checkbox" id="c-41654756" checked=""/><div class="controls bullet"><span class="by">bradley13</span><span>|</span><a href="#41653797">prev</a><span>|</span><a href="#41655369">next</a><span>|</span><label class="collapse" for="c-41654756">[-]</label><label class="expand" for="c-41654756">[16 more]</label></div><br/><div class="children"><div class="content">Maybe I am being to much of a purist, but retroactively modifying commits and history? Why? Stuff happens, so do mistakes. Fix the mistakes, make another commit, and go on with your life.</div><br/><div id="41655129" class="c"><input type="checkbox" id="c-41655129" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#41654756">parent</a><span>|</span><a href="#41654886">next</a><span>|</span><label class="collapse" for="c-41655129">[-]</label><label class="expand" for="c-41655129">[1 more]</label></div><br/><div class="children"><div class="content">I am not history purist in that way. I don’t care about fixes for mistakes, if they are in your local branch do the cleanup before publish and if it is your own published branch force push is ok.<p>Unless of course your changes were merged to common code already - then they become not touchable - just make a new commit with fix don’t try to be smart, common code rolls only forward and fixes are new commits.</div><br/></div></div><div id="41654886" class="c"><input type="checkbox" id="c-41654886" checked=""/><div class="controls bullet"><span class="by">strunz</span><span>|</span><a href="#41654756">parent</a><span>|</span><a href="#41655129">prev</a><span>|</span><a href="#41654878">next</a><span>|</span><label class="collapse" for="c-41654886">[-]</label><label class="expand" for="c-41654886">[4 more]</label></div><br/><div class="children"><div class="content">Commits should be a contained change that can be understood as a logical piece of history, and reverted if necessary. If you have to look at multiple commits for 1 logical change to the code, it&#x27;s much more difficult to figured out what the intention was, if it was correct, and how it can be reverted.</div><br/><div id="41654942" class="c"><input type="checkbox" id="c-41654942" checked=""/><div class="controls bullet"><span class="by">notlinus</span><span>|</span><a href="#41654756">root</a><span>|</span><a href="#41654886">parent</a><span>|</span><a href="#41654878">next</a><span>|</span><label class="collapse" for="c-41654942">[-]</label><label class="expand" for="c-41654942">[3 more]</label></div><br/><div class="children"><div class="content">Do you always make all of your logical code changes in single, atomic commits? What if you have to modify a feature later on? I&#x27;m sorry, but this is ridiculous. There&#x27;s nothing wrong with having multiple commits in a row modifying something. That&#x27;s how git works. GitHub&#x27;s PR merge workflow really messed up the meta game, I tell you what...</div><br/><div id="41655913" class="c"><input type="checkbox" id="c-41655913" checked=""/><div class="controls bullet"><span class="by">trashburger</span><span>|</span><a href="#41654756">root</a><span>|</span><a href="#41654942">parent</a><span>|</span><a href="#41655189">next</a><span>|</span><label class="collapse" for="c-41655913">[-]</label><label class="expand" for="c-41655913">[1 more]</label></div><br/><div class="children"><div class="content">Yes, always. Of course I make mistakes, but the idea is that any patch I put up for review, if it cleanly applies, should not break any user and any tests. It&#x27;s much more liberating knowing that bisects actually work and each commit does exactly what it says on the tin (no followup &quot;fix&quot;&#x2F;&quot;minor&quot; commits that actually do something completely different). Incremental improvements are compatible with this approach. Also see <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;thoughtpolice&#x2F;9c45287550a56b2047c6311fbadebed2" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;thoughtpolice&#x2F;9c45287550a56b2047c631...</a> .</div><br/></div></div><div id="41655189" class="c"><input type="checkbox" id="c-41655189" checked=""/><div class="controls bullet"><span class="by">brigandish</span><span>|</span><a href="#41654756">root</a><span>|</span><a href="#41654942">parent</a><span>|</span><a href="#41655913">prev</a><span>|</span><a href="#41654878">next</a><span>|</span><label class="collapse" for="c-41655189">[-]</label><label class="expand" for="c-41655189">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you&#x27;re arguing against the point being made.<p>Logical change 1, implement Hello World:<p><pre><code>    puts &quot;Hello, World!&quot;
</code></pre>
Logical change 2, make it a method:<p><pre><code>    def hello_world
      puts &quot;Hello, World&quot;
    end
</code></pre>
Logical change 3, take an argument for the greeting:<p><pre><code>    def hello_world(greeting)
      puts &quot;#{greeting}, World&quot;
    end
</code></pre>
Logical change 4, take an argument for the recipient:<p><pre><code>    def hello_world(greeting, recipient)
      puts &quot;#{greeting}, #{recipient}&quot;
    end
</code></pre>
Logical change 5, improve the method name by showing the intent:<p><pre><code>    def greet_recipient(greeting, recipient)
      puts &quot;#{greeting}, #{recipient}&quot;
    end

</code></pre>
Logical change 6, defaults…:<p><pre><code>    def greet_recipient(greeting=&quot;Hello&quot;, recipient)
      puts &quot;#{greeting}, #{recipient}&quot;
    end
</code></pre>
And so on. These could each be their own feature or part of a feature etc. What they are, though, is logically atomic. If you want to add a default recipient later, or next, that is its own logical commit. If you roll it back, each rollback will lead you to a logical difference, not some typo fix, e.g.<p><pre><code>    def greet_recipient(greeting=&quot;Hell&quot;, recipient)
      puts &quot;#{greeting}, #{recipient}&quot;
    end
</code></pre>
plus the missing &quot;o&quot;<p><pre><code>    def greet_recipient(greeting=&quot;Hello&quot;, recipient)
      puts &quot;#{greeting}, #{recipient}&quot;
    end
</code></pre>
Are one <i>logical</i> commit, for which I&#x27;d use a fixup or `git commit --amend` or whatever. What one considers <i>logically atomic</i> may differ from person to person, language to language, feature to feature… but they can be differentiated from things like typos quite easily.<p>Personally, I make numerous commits in a feature branch, (transparently, too, my typos included - I&#x27;m not proud:) and before requesting review I&#x27;ll clean up using rebase into as few logical commits as possible, and upon acceptance either squash it all to one or leave it as is, depending on the team&#x27;s culture&#x2F;needs.</div><br/></div></div></div></div></div></div><div id="41654878" class="c"><input type="checkbox" id="c-41654878" checked=""/><div class="controls bullet"><span class="by">gorset</span><span>|</span><a href="#41654756">parent</a><span>|</span><a href="#41654886">prev</a><span>|</span><a href="#41654786">next</a><span>|</span><label class="collapse" for="c-41654878">[-]</label><label class="expand" for="c-41654878">[3 more]</label></div><br/><div class="children"><div class="content">The use case is when you look at a branch as a series of patches.<p>Reviewing a clean set of commits is much easier than a branch full of mistakes and wrong paths taken.<p>Useful when we optimize for reviewing and good history for future maintenance. This has been important and useful when I’ve worked on big mission critical backend system, but I also understand it might not be the most important factor for a new project’s success.</div><br/><div id="41654944" class="c"><input type="checkbox" id="c-41654944" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#41654756">root</a><span>|</span><a href="#41654878">parent</a><span>|</span><a href="#41654786">next</a><span>|</span><label class="collapse" for="c-41654944">[-]</label><label class="expand" for="c-41654944">[2 more]</label></div><br/><div class="children"><div class="content">So this wouldn’t work very well in workflows that flatten merges to a trunk?</div><br/><div id="41655088" class="c"><input type="checkbox" id="c-41655088" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#41654756">root</a><span>|</span><a href="#41654944">parent</a><span>|</span><a href="#41654786">next</a><span>|</span><label class="collapse" for="c-41655088">[-]</label><label class="expand" for="c-41655088">[1 more]</label></div><br/><div class="children"><div class="content">It would mostly be unnecessary. The separate commits won’t matter after the PR if they’re getting squashed.<p>Debatably, if you’re making changes during a PR review, it could be helpful to make those changes in relevant commits. That way if someone goes through them during the PR, they get one clean “story”, rather than see the pre-PR commits and the conversation after.</div><br/></div></div></div></div></div></div><div id="41654786" class="c"><input type="checkbox" id="c-41654786" checked=""/><div class="controls bullet"><span class="by">rom1v</span><span>|</span><a href="#41654756">parent</a><span>|</span><a href="#41654878">prev</a><span>|</span><a href="#41654968">next</a><span>|</span><label class="collapse" for="c-41654786">[-]</label><label class="expand" for="c-41654786">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.mail-archive.com&#x2F;dri-devel@lists.sourceforge.net&#x2F;msg39091.html" rel="nofollow">https:&#x2F;&#x2F;www.mail-archive.com&#x2F;dri-devel@lists.sourceforge.net...</a></div><br/></div></div><div id="41654968" class="c"><input type="checkbox" id="c-41654968" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#41654756">parent</a><span>|</span><a href="#41654786">prev</a><span>|</span><a href="#41655599">next</a><span>|</span><label class="collapse" for="c-41654968">[-]</label><label class="expand" for="c-41654968">[1 more]</label></div><br/><div class="children"><div class="content">If it is unreleased it may make the life of reviewers easier. If they look at the commits at all, that is.<p>But if not even reviewers are looking at commits I question whether a PR should be chunked in commits at all - why not squash all commits into a single one, so that every PR is composed of exactly one commit? Could maybe separating the changes in commits convey some information?</div><br/></div></div><div id="41655599" class="c"><input type="checkbox" id="c-41655599" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#41654756">parent</a><span>|</span><a href="#41654968">prev</a><span>|</span><a href="#41656003">next</a><span>|</span><label class="collapse" for="c-41655599">[-]</label><label class="expand" for="c-41655599">[1 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s easier to understand later on when it&#x27;s not spread out</div><br/></div></div><div id="41656003" class="c"><input type="checkbox" id="c-41656003" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41654756">parent</a><span>|</span><a href="#41655599">prev</a><span>|</span><a href="#41655169">next</a><span>|</span><label class="collapse" for="c-41656003">[-]</label><label class="expand" for="c-41656003">[1 more]</label></div><br/><div class="children"><div class="content">The point of history is so that other people (or your future self) can look back at the history of the code and understand how it changed and why changes were made.<p>There&#x27;s zero value in retaining mistakes that were never merged into `master`. In fact there is negative value because it makes the history harder to follow.<p>For example would you rather see &quot;review fixes&quot; in Git blame, or the actual useful commit message?<p>You can argue that you can&#x27;t be bothered to make your history nice; fine. But you can&#x27;t say it&#x27;s <i>wrong</i> to do that.<p>(Personally I think you should squash commits for a MR; if it&#x27;s too big to review as one commit it&#x27;s too big for one MR - except for branches that multiple people have worked on over an extended period.)</div><br/></div></div><div id="41655169" class="c"><input type="checkbox" id="c-41655169" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41654756">parent</a><span>|</span><a href="#41656003">prev</a><span>|</span><a href="#41655369">next</a><span>|</span><label class="collapse" for="c-41655169">[-]</label><label class="expand" for="c-41655169">[3 more]</label></div><br/><div class="children"><div class="content">Why store git history at all? It&#x27;s useless if you don&#x27;t take care of it. Have you ever used git history for anything? People use it to find the source of regressions (you can do it quite quickly using git bisect).</div><br/><div id="41655423" class="c"><input type="checkbox" id="c-41655423" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41654756">root</a><span>|</span><a href="#41655169">parent</a><span>|</span><a href="#41655369">next</a><span>|</span><label class="collapse" for="c-41655423">[-]</label><label class="expand" for="c-41655423">[2 more]</label></div><br/><div class="children"><div class="content">the git history of the linux kernel documents the Linux kernel detailed Design, the reasoning how things fit together.<p>I&#x27;ve used it several times to understand why things are done the way they are.<p>The discussion leading to this design is encoded in the revisions of the patch series, browsable on patchworks.<p>I agree to your point that the git history has to be taken care of to be useful.</div><br/><div id="41655779" class="c"><input type="checkbox" id="c-41655779" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41654756">root</a><span>|</span><a href="#41655423">parent</a><span>|</span><a href="#41655369">next</a><span>|</span><label class="collapse" for="c-41655779">[-]</label><label class="expand" for="c-41655779">[1 more]</label></div><br/><div class="children"><div class="content">My question was, of course, rhetorical. This and hunting regressions are two great reasons to keep history.<p>&quot;What did John do on Tuesday morning&quot; is not a good reason to keep history. Neither is &quot;This change was made as part of a sprawling &quot;fix&quot; commit that happened on Thursday afternoon&quot;.<p>The important point is if you are going to keep history at all it needs to be kept in a state that is actually useful, meaning useful for the first two things, not the last two. Otherwise it&#x27;s just a waste of disk space. The git history is meticulously maintained which is what makes it actually useful.</div><br/></div></div></div></div></div></div></div></div><div id="41655369" class="c"><input type="checkbox" id="c-41655369" checked=""/><div class="controls bullet"><span class="by">parasti</span><span>|</span><a href="#41654756">prev</a><span>|</span><a href="#41655715">next</a><span>|</span><label class="collapse" for="c-41655369">[-]</label><label class="expand" for="c-41655369">[1 more]</label></div><br/><div class="children"><div class="content">TIL about `git commit --fixup` and `git rebase --autosquash`.<p>Interactive git rebase is by far my favorite Git tool to use, it scratches a particular itch to create perfect logically atomic commits.<p>That said, sometimes this kind of history editing tends to backfire spectacularly because these crafted perfect commits have actually never been compiled and tested.</div><br/></div></div><div id="41655715" class="c"><input type="checkbox" id="c-41655715" checked=""/><div class="controls bullet"><span class="by">tripdout</span><span>|</span><a href="#41655369">prev</a><span>|</span><a href="#41653372">next</a><span>|</span><label class="collapse" for="c-41655715">[-]</label><label class="expand" for="c-41655715">[3 more]</label></div><br/><div class="children"><div class="content">How does it figure out which commit to add each change to?</div><br/><div id="41655743" class="c"><input type="checkbox" id="c-41655743" checked=""/><div class="controls bullet"><span class="by">andsens</span><span>|</span><a href="#41655715">parent</a><span>|</span><a href="#41655780">next</a><span>|</span><label class="collapse" for="c-41655743">[-]</label><label class="expand" for="c-41655743">[1 more]</label></div><br/><div class="children"><div class="content">7 lines into the README buddy:
&gt; The command essentially looks at the lines that were modified, finds a changeset modifying those lines, and amends that changeset to include your uncommitted changes.</div><br/></div></div><div id="41655780" class="c"><input type="checkbox" id="c-41655780" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#41655715">parent</a><span>|</span><a href="#41655743">prev</a><span>|</span><a href="#41653372">next</a><span>|</span><label class="collapse" for="c-41655780">[-]</label><label class="expand" for="c-41655780">[1 more]</label></div><br/><div class="children"><div class="content">it explains it in literally the first paragraph: <a href="https:&#x2F;&#x2F;github.com&#x2F;tummychow&#x2F;git-absorb?tab=readme-ov-file#git-absorb">https:&#x2F;&#x2F;github.com&#x2F;tummychow&#x2F;git-absorb?tab=readme-ov-file#g...</a><p>&gt; The command essentially looks at the lines that were modified, finds a changeset modifying those lines, and amends that changeset to include your uncommitted changes.</div><br/></div></div></div></div><div id="41653372" class="c"><input type="checkbox" id="c-41653372" checked=""/><div class="controls bullet"><span class="by">MBlume</span><span>|</span><a href="#41655715">prev</a><span>|</span><a href="#41654190">next</a><span>|</span><label class="collapse" for="c-41653372">[-]</label><label class="expand" for="c-41653372">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using this workflow with hg and it&#x27;s great, happy to see a git port</div><br/><div id="41653394" class="c"><input type="checkbox" id="c-41653394" checked=""/><div class="controls bullet"><span class="by">optymizer</span><span>|</span><a href="#41653372">parent</a><span>|</span><a href="#41654190">next</a><span>|</span><label class="collapse" for="c-41653394">[-]</label><label class="expand" for="c-41653394">[2 more]</label></div><br/><div class="children"><div class="content">One of my favorite Sapling commands at Meta</div><br/><div id="41653408" class="c"><input type="checkbox" id="c-41653408" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#41653372">root</a><span>|</span><a href="#41653394">parent</a><span>|</span><a href="#41654190">next</a><span>|</span><label class="collapse" for="c-41653408">[-]</label><label class="expand" for="c-41653408">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it singlehandedly turned me on to Mercurial when I was there, and has massively shaped the way I use git ever since.</div><br/></div></div></div></div></div></div><div id="41654190" class="c"><input type="checkbox" id="c-41654190" checked=""/><div class="controls bullet"><span class="by">tcoff91</span><span>|</span><a href="#41653372">prev</a><span>|</span><a href="#41653815">next</a><span>|</span><label class="collapse" for="c-41654190">[-]</label><label class="expand" for="c-41654190">[4 more]</label></div><br/><div class="children"><div class="content">Just use magit and easily make fixup! commits with like 3 key presses. Even if you don&#x27;t use emacs keeping it around just to use magit is worth it.<p>Edamagit for vscode users is not as good but it does this particular workflow great.</div><br/><div id="41654454" class="c"><input type="checkbox" id="c-41654454" checked=""/><div class="controls bullet"><span class="by">psanford</span><span>|</span><a href="#41654190">parent</a><span>|</span><a href="#41654678">next</a><span>|</span><label class="collapse" for="c-41654454">[-]</label><label class="expand" for="c-41654454">[1 more]</label></div><br/><div class="children"><div class="content">I use magit. I still use git absorb. The issue for me is not the speed at which I can run the interactive rebase, it is the amount of looking I have to do to find the correct commit to fixup onto in a big stack of commits. git absorb figures that out for me.</div><br/></div></div><div id="41654678" class="c"><input type="checkbox" id="c-41654678" checked=""/><div class="controls bullet"><span class="by">accelbred</span><span>|</span><a href="#41654190">parent</a><span>|</span><a href="#41654454">prev</a><span>|</span><a href="#41655794">next</a><span>|</span><label class="collapse" for="c-41654678">[-]</label><label class="expand" for="c-41654678">[1 more]</label></div><br/><div class="children"><div class="content">magit supports git-absorb out of the box if its installed; see the magit-commit-absorb command. I find it quite useful.</div><br/></div></div><div id="41655794" class="c"><input type="checkbox" id="c-41655794" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#41654190">parent</a><span>|</span><a href="#41654678">prev</a><span>|</span><a href="#41653815">next</a><span>|</span><label class="collapse" for="c-41655794">[-]</label><label class="expand" for="c-41655794">[1 more]</label></div><br/><div class="children"><div class="content">magit is fantastic but this isn&#x27;t at all the same thing.<p>fixup is &quot;stage changes, users selects past commit to fixup, commit staged changes&quot;<p>absorb is &quot;stage changes, git-absorb figures out which past commit to fixup, commit staged changes&quot;</div><br/></div></div></div></div><div id="41653815" class="c"><input type="checkbox" id="c-41653815" checked=""/><div class="controls bullet"><span class="by">taberiand</span><span>|</span><a href="#41654190">prev</a><span>|</span><a href="#41654474">next</a><span>|</span><label class="collapse" for="c-41653815">[-]</label><label class="expand" for="c-41653815">[1 more]</label></div><br/><div class="children"><div class="content">This sounds very useful, I frequently reset soft and recommit in batches of related changes before PR and this sounds like it streamlines integrating updates quite nicely</div><br/></div></div><div id="41654474" class="c"><input type="checkbox" id="c-41654474" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41653815">prev</a><span>|</span><a href="#41653920">next</a><span>|</span><label class="collapse" for="c-41654474">[-]</label><label class="expand" for="c-41654474">[2 more]</label></div><br/><div class="children"><div class="content">This seems neat in theory but I would be perpetually concerned that it is going to pull some change I don&#x27;t mean to commit and put it into something for review. How well does it do at that, anecdotally?</div><br/><div id="41655490" class="c"><input type="checkbox" id="c-41655490" checked=""/><div class="controls bullet"><span class="by">mook</span><span>|</span><a href="#41654474">parent</a><span>|</span><a href="#41653920">next</a><span>|</span><label class="collapse" for="c-41655490">[-]</label><label class="expand" for="c-41655490">[1 more]</label></div><br/><div class="children"><div class="content">It deals with things that have been staged, so if you don&#x27;t want to commit then don&#x27;t stage it. I believe a dirty working tree is fine (and gets ignored).</div><br/></div></div></div></div><div id="41653920" class="c"><input type="checkbox" id="c-41653920" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41654474">prev</a><span>|</span><a href="#41654444">next</a><span>|</span><label class="collapse" for="c-41653920">[-]</label><label class="expand" for="c-41653920">[1 more]</label></div><br/><div class="children"><div class="content">The thing that I never knew I needed, but I predict within a few days I won’t be able to live without. Thank you!</div><br/></div></div><div id="41654444" class="c"><input type="checkbox" id="c-41654444" checked=""/><div class="controls bullet"><span class="by">psanford</span><span>|</span><a href="#41653920">prev</a><span>|</span><a href="#41653705">next</a><span>|</span><label class="collapse" for="c-41654444">[-]</label><label class="expand" for="c-41654444">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a huge fan of git absorb. I love tools that do-the-right-thing so I can think less. That is what git absorb is.</div><br/></div></div><div id="41653705" class="c"><input type="checkbox" id="c-41653705" checked=""/><div class="controls bullet"><span class="by">lr4444lr</span><span>|</span><a href="#41654444">prev</a><span>|</span><a href="#41654433">next</a><span>|</span><label class="collapse" for="c-41653705">[-]</label><label class="expand" for="c-41653705">[23 more]</label></div><br/><div class="children"><div class="content"><i>you don&#x27;t want to shove them all into an opaque commit that says fixes, because you believe in atomic commits.</i><p>Sure I do. The whole branch will be squashed anyway before it&#x27;s merged in, and a single &quot;fixes&quot; commit while still on its own branch will be easier to track in a PR for addressing everything pointed out earlier.<p>I mean, don&#x27;t let me stop anyone from using this or --fixup if this is your flow, but this solves a problem neither I nor anyone in my last 10 years of working with code has.</div><br/><div id="41653892" class="c"><input type="checkbox" id="c-41653892" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41653705">parent</a><span>|</span><a href="#41655117">next</a><span>|</span><label class="collapse" for="c-41653892">[-]</label><label class="expand" for="c-41653892">[13 more]</label></div><br/><div class="children"><div class="content">Every team is free to choose what works best for them, but IMO always squashing PRs is not a good strategy. Sometimes you do want to preserve the change history, particularly if the PR does more than a single atomic change, which in practice is very common. There shouldn&#x27;t be a static merge type preference at all, and this should be chosen on a case-by-case basis.<p>At the risk of sounding judgemental, I think this preference for always squashing PRs comes from a place of either not understanding atomic commits, not caring about the benefits of them, or just choosing to be lazy. In any case, the loss of history inevitably comes at a cost of making reverting and cherry-picking changes more difficult later, making `git bisect` pretty much worthless, and losing the context of why a change was made.</div><br/><div id="41654227" class="c"><input type="checkbox" id="c-41654227" checked=""/><div class="controls bullet"><span class="by">boolemancer</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41653892">parent</a><span>|</span><a href="#41654475">next</a><span>|</span><label class="collapse" for="c-41654227">[-]</label><label class="expand" for="c-41654227">[3 more]</label></div><br/><div class="children"><div class="content">&gt; At the risk of sounding judgemental, I think this preference for always squashing PRs comes from a place of either not understanding atomic commits, not caring about the benefits of them, or just choosing to be lazy. In any case, the loss of history inevitably comes at a cost of making reverting and cherry-picking changes more difficult later, as well as losing the context of why a change was made.<p>1) Why are you ever reverting&#x2F;cherry-picking at a more granular level than an entire PR anyway? The PR is the thing that gets signed-off on, and the thing that goes through the CI build&#x2F;tests, so why wouldn&#x27;t that be the thing kept as an atomic unit?<p>2) I don&#x27;t think I&#x27;ve ever cared about the context for a specific commit within a PR once the PR has been merged. What kind of information do you expect to get out of it?<p>Edit: How does it remove the context for a change or make `git bisect` useless? How big are your PRs that you can&#x27;t get enough context from finding the PR commit to know why a particular change was made?</div><br/><div id="41655746" class="c"><input type="checkbox" id="c-41655746" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41654227">parent</a><span>|</span><a href="#41654674">next</a><span>|</span><label class="collapse" for="c-41655746">[-]</label><label class="expand" for="c-41655746">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The PR is the thing that gets signed-off on, and the thing that goes through the CI build&#x2F;tests, so why wouldn&#x27;t that be the thing kept as an atomic unit?<p>Because it often isn&#x27;t. I don&#x27;t know about your experience, but in all the teams I&#x27;ve worked in throughout my career the discipline to keep PRs atomic is almost never maintained, and sometimes just doesn&#x27;t make sense. Sometimes you start working on a change, but spot an issue that is either too trivial to go through the PR&#x2F;review process, or closely related to the work you started but worthy of a separate commit. Other times large PRs are unavoidable, especially for refactorings, where you want to propose a larger change but the history of the progress is valuable.<p>I find conventional commits helpful when deciding what makes an atomic change. By forcing a commit to be of a single type (feature, fix, refactor, etc.) it&#x27;s easier to determine what belongs together and what not. But a PR can contain different commit types with related changes, and squashing them all when merging doesn&#x27;t make the PR itself atomic.<p>&gt; I don&#x27;t think I&#x27;ve ever cared about the context for a specific commit within a PR once the PR has been merged. What kind of information do you expect to get out of it?<p>Oh, plenty. For one, when looking at `git blame` to determine why a change was made, I hope to find this information in the commit message. This is what commit messages are for anyway. If all commits have this information, following the history of a set of changes becomes much easier. This is helpful not just during code reviews, but after the merge as well, for any new members of the team trying to understand the codebase, or even the author themself in the future.</div><br/></div></div><div id="41654674" class="c"><input type="checkbox" id="c-41654674" checked=""/><div class="controls bullet"><span class="by">imp0cat</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41654227">parent</a><span>|</span><a href="#41655746">prev</a><span>|</span><a href="#41654475">next</a><span>|</span><label class="collapse" for="c-41654674">[-]</label><label class="expand" for="c-41654674">[1 more]</label></div><br/><div class="children"><div class="content">ad 1) I&#x27;d guess it depends on the size of the PR. If they&#x27;re massive it kinda makes sense.</div><br/></div></div></div></div><div id="41654475" class="c"><input type="checkbox" id="c-41654475" checked=""/><div class="controls bullet"><span class="by">seadan83</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41653892">parent</a><span>|</span><a href="#41654227">prev</a><span>|</span><a href="#41654141">next</a><span>|</span><label class="collapse" for="c-41654475">[-]</label><label class="expand" for="c-41654475">[2 more]</label></div><br/><div class="children"><div class="content">What are your thoughts on the &quot;ship, show, ask&quot; workflow? [1]<p>In that workflow, small stuff is simply pushed, which allows PRs to be more single focused and more atomic. Perhaps your only objection is direct pushes to master? I am really curious if that workflow otherwise addresses all of the downsides you stated while still allowing for all PRs to be uniformly rebase-squash merged.<p>[1] <a href="https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;ship-show-ask.html" rel="nofollow">https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;ship-show-ask.html</a></div><br/><div id="41655945" class="c"><input type="checkbox" id="c-41655945" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41654475">parent</a><span>|</span><a href="#41654141">next</a><span>|</span><label class="collapse" for="c-41655945">[-]</label><label class="expand" for="c-41655945">[1 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t aware of this particular workflow, but I&#x27;ve heard of similar ones before. The late Pieter Hintjens, of ZeroMQ fame, advocated for a strategy called &quot;optimistic merging&quot;[1], which essentially abandons the standard code review process in favor of merging changes ASAP, and fixing any issues as they arise later.<p>I&#x27;m not a fan of this. It allows contributors to abandon any established coding standards, while placing more burden on maintainers to fix issues later. This in practice never happens, so the quality of the codebase degrades over time. Not to mention that it allows malicious actors to merge changes much more easily.<p>As for &quot;ship, show, ask&quot; specifically, I have similar reservations. I think all changes should go through a review process, even if someone just glances at the changes. It not only gives the opportunity to leave feedback, but also serves as communication so that everyone is aware of the proposed changes. Also, making the decision of whether to choose &quot;ship&quot;, &quot;show&quot; or &quot;ask&quot; might only work for senior and well disciplined developers. I think that in most teams you have a mixture of experience, so you&#x27;d inevitably end up in situations where a change should&#x27;ve been &quot;show&quot; or &quot;ask&quot;, but was &quot;ship&quot;, and viceversa. I don&#x27;t think teams will ever align on a single strategy to make a correct decision, since it&#x27;s based on subjective opinion to begin with. Always following the same workflow gets rid of these uncertainties.<p>[1]: <a href="http:&#x2F;&#x2F;hintjens.com&#x2F;blog:106" rel="nofollow">http:&#x2F;&#x2F;hintjens.com&#x2F;blog:106</a></div><br/></div></div></div></div><div id="41654141" class="c"><input type="checkbox" id="c-41654141" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41653892">parent</a><span>|</span><a href="#41654475">prev</a><span>|</span><a href="#41654252">next</a><span>|</span><label class="collapse" for="c-41654141">[-]</label><label class="expand" for="c-41654141">[5 more]</label></div><br/><div class="children"><div class="content">git bisect is still perfectly useful. It will locate the squashed commit&#x2F;pr which is more than enough for me to zero in on whatever the bug is.</div><br/><div id="41654262" class="c"><input type="checkbox" id="c-41654262" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41654141">parent</a><span>|</span><a href="#41654252">next</a><span>|</span><label class="collapse" for="c-41654262">[-]</label><label class="expand" for="c-41654262">[4 more]</label></div><br/><div class="children"><div class="content">How helpful is it if it points you to a commit with 10 different changes? Will you go back to the PR to see the context of each change, and try to guess where the issue is based on the behavior? You&#x27;re right back at manual debugging at that point.<p>This workflow really shines when it points you to the actual atomic commit that introduced the issue. Then you&#x27;re simply a `git revert` away from undoing it, without risking breaking anything else, barring functional conflicts, of course. Try doing that with a squashed commit.</div><br/><div id="41654306" class="c"><input type="checkbox" id="c-41654306" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41654262">parent</a><span>|</span><a href="#41654379">next</a><span>|</span><label class="collapse" for="c-41654306">[-]</label><label class="expand" for="c-41654306">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you (see my other top level comment), but<p>&gt; Then you&#x27;re simply a `git revert` away from undoing it, without risking breaking anything else<p>This needs careful qualification. On GitHub at least, it is difficult to ensure every commit passes CI. This can result in skipping during bisect for a busted commit. It doesn&#x27;t happen often enough in my experience too convince me to give up a cleaner history, but it&#x27;s a downside we should acknowledge.<p>Ideally GitHub would make testing each individual commit easier.</div><br/><div id="41655553" class="c"><input type="checkbox" id="c-41655553" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41654306">parent</a><span>|</span><a href="#41654379">next</a><span>|</span><label class="collapse" for="c-41655553">[-]</label><label class="expand" for="c-41655553">[1 more]</label></div><br/><div class="children"><div class="content">A revert two weeks after the fact will create a new and unique tree (untested) in any case. I don’t if you’re saying that the original commit or the revert might be untested.<p>In either case the brand new revert could break something. Who knows, it’s a new state.<p>&gt;  It doesn&#x27;t happen often enough in my experience too convince me to give up a cleaner history, but it&#x27;s a downside we should acknowledge.<p>There are tools for that.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mhagger&#x2F;git-test">https:&#x2F;&#x2F;github.com&#x2F;mhagger&#x2F;git-test</a></div><br/></div></div></div></div><div id="41654379" class="c"><input type="checkbox" id="c-41654379" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41654262">parent</a><span>|</span><a href="#41654306">prev</a><span>|</span><a href="#41654252">next</a><span>|</span><label class="collapse" for="c-41654379">[-]</label><label class="expand" for="c-41654379">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve not seen code where this revert thing would work. If it&#x27;s in the PR something else now depends on it.</div><br/></div></div></div></div></div></div><div id="41654252" class="c"><input type="checkbox" id="c-41654252" checked=""/><div class="controls bullet"><span class="by">phist_mcgee</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41653892">parent</a><span>|</span><a href="#41654141">prev</a><span>|</span><a href="#41654385">next</a><span>|</span><label class="collapse" for="c-41654252">[-]</label><label class="expand" for="c-41654252">[1 more]</label></div><br/><div class="children"><div class="content">If you go all in on atomic commits, you&#x27;re probably going to be rebasing a lot. IME, that&#x27;s a lot of time spent trying to make a &quot;clean&quot; history all for the benefit of looking back infrequently at what broke.<p>Can&#x27;t you just inspect your merged branches and bisect those instead if using the squash strat?</div><br/></div></div><div id="41654385" class="c"><input type="checkbox" id="c-41654385" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41653892">parent</a><span>|</span><a href="#41654252">prev</a><span>|</span><a href="#41655117">next</a><span>|</span><label class="collapse" for="c-41654385">[-]</label><label class="expand" for="c-41654385">[1 more]</label></div><br/><div class="children"><div class="content">There can be another reason.  I do care about the benefits, but I don&#x27;t think there really are any.</div><br/></div></div></div></div><div id="41655117" class="c"><input type="checkbox" id="c-41655117" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#41653705">parent</a><span>|</span><a href="#41653892">prev</a><span>|</span><a href="#41654970">next</a><span>|</span><label class="collapse" for="c-41655117">[-]</label><label class="expand" for="c-41655117">[1 more]</label></div><br/><div class="children"><div class="content">That whole paragraph is the conditions under which this tool would be useful. If they’re not true for you, this isn’t for you. This is like quoting “You have a feature branch” and saying “No I don’t.”</div><br/></div></div><div id="41654970" class="c"><input type="checkbox" id="c-41654970" checked=""/><div class="controls bullet"><span class="by">notlinus</span><span>|</span><a href="#41653705">parent</a><span>|</span><a href="#41655117">prev</a><span>|</span><a href="#41654810">next</a><span>|</span><label class="collapse" for="c-41654970">[-]</label><label class="expand" for="c-41654970">[4 more]</label></div><br/><div class="children"><div class="content">I wish people would stop saying &quot;atomic commits&quot; and start saying &quot;main&#x2F;master is stable&quot;, because that&#x27;s what they <i>actually</i> mean. Every git commit is atomic, by definition... But people want every single possible revision to be green and buildable, which is different, and has nothing to do with git. I don&#x27;t think it makes sense (tags are a lot more helpful for marking what is and isn&#x27;t stable), but hey.</div><br/><div id="41655846" class="c"><input type="checkbox" id="c-41655846" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41654970">parent</a><span>|</span><a href="#41654810">next</a><span>|</span><label class="collapse" for="c-41655846">[-]</label><label class="expand" for="c-41655846">[3 more]</label></div><br/><div class="children"><div class="content">Yes, atomic commits is not a very descriptive term. But main&#x2F;master is stable is only a necessary condition, not a sufficient one.<p>If you squash (or mix from the beginning) several unrelated changes into a single commit, main&#x2F;master would be stable.<p>AFAIK atomic commits means nothing can be taken away without breaking the change and nothing needs to be added to make the change work. How to express that without 2 clauses is indeed a good question.</div><br/><div id="41655865" class="c"><input type="checkbox" id="c-41655865" checked=""/><div class="controls bullet"><span class="by">assiniboine</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41655846">parent</a><span>|</span><a href="#41654810">next</a><span>|</span><label class="collapse" for="c-41655865">[-]</label><label class="expand" for="c-41655865">[2 more]</label></div><br/><div class="children"><div class="content">Atomic commits ensure each change works independently.</div><br/><div id="41656040" class="c"><input type="checkbox" id="c-41656040" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41655865">parent</a><span>|</span><a href="#41654810">next</a><span>|</span><label class="collapse" for="c-41656040">[-]</label><label class="expand" for="c-41656040">[1 more]</label></div><br/><div class="children"><div class="content">That cannot be achieved in general. Later commits often depend on some earlier one.</div><br/></div></div></div></div></div></div></div></div><div id="41654810" class="c"><input type="checkbox" id="c-41654810" checked=""/><div class="controls bullet"><span class="by">rom1v</span><span>|</span><a href="#41653705">parent</a><span>|</span><a href="#41654970">prev</a><span>|</span><a href="#41653883">next</a><span>|</span><label class="collapse" for="c-41654810">[-]</label><label class="expand" for="c-41654810">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The whole branch will be squashed anyway before it&#x27;s merged in<p>That looks like a very wrong process to me. Why would you even want to do that?</div><br/></div></div><div id="41653883" class="c"><input type="checkbox" id="c-41653883" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#41653705">parent</a><span>|</span><a href="#41654810">prev</a><span>|</span><a href="#41654433">next</a><span>|</span><label class="collapse" for="c-41653883">[-]</label><label class="expand" for="c-41653883">[3 more]</label></div><br/><div class="children"><div class="content">Good for you, but you (and, apparently, everyone in your last 10 years of working with) would have a problem if I was the one reviewing your commits. I mean, to be fair, I often did let it slide (for political&#x2F;social&#x2F;practical reasons) and use autosquash, but I always actively discouraged it, so if you are a junior or a new hire with uncertain usefulness status, I&#x27;d at least talk to you about that and ask you to fix it. This is not an ok practice, it&#x27;s only acceptable because too many people don&#x27;t have a habit of making their own bed and much bigger kinds of technical debt get ignored because in the end it&#x27;s about shipping stuff, so you just sigh and say &quot;oh, whatever&quot;.</div><br/><div id="41654126" class="c"><input type="checkbox" id="c-41654126" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41653883">parent</a><span>|</span><a href="#41654980">next</a><span>|</span><label class="collapse" for="c-41654126">[-]</label><label class="expand" for="c-41654126">[1 more]</label></div><br/><div class="children"><div class="content">It has always been enough for me to trace a change back to its original pull request. Extra granularity might be nice sometimes but never essential. And I do a fair bit of digging through git history. Not sure what makes it &quot;not an ok practice&quot;. Squashing works fine and lets the 80% of people who don&#x27;t care spend their efforts thinking about something other than a perfect git history.</div><br/></div></div><div id="41654980" class="c"><input type="checkbox" id="c-41654980" checked=""/><div class="controls bullet"><span class="by">notlinus</span><span>|</span><a href="#41653705">root</a><span>|</span><a href="#41653883">parent</a><span>|</span><a href="#41654126">prev</a><span>|</span><a href="#41654433">next</a><span>|</span><label class="collapse" for="c-41654980">[-]</label><label class="expand" for="c-41654980">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, you&#x27;re right.</div><br/></div></div></div></div></div></div><div id="41654433" class="c"><input type="checkbox" id="c-41654433" checked=""/><div class="controls bullet"><span class="by">dmead</span><span>|</span><a href="#41653705">prev</a><span>|</span><a href="#41653533">next</a><span>|</span><label class="collapse" for="c-41654433">[-]</label><label class="expand" for="c-41654433">[5 more]</label></div><br/><div class="children"><div class="content">This sounds great,but kind of an anti pattern in git.<p>I definitely want to have a &quot;fixes&quot; commit on my feature branch. You should do whatever you want on a feature branch so long as your trunk has a clean history.<p>This sounds like someone wanted to lift a feature of changesets in mercurial into git. I don&#x27;t think this is safe and probably breaks a lot of people&#x27;s mental model of git changelogs being an immutable data structure.</div><br/><div id="41654456" class="c"><input type="checkbox" id="c-41654456" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41654433">parent</a><span>|</span><a href="#41653533">next</a><span>|</span><label class="collapse" for="c-41654456">[-]</label><label class="expand" for="c-41654456">[4 more]</label></div><br/><div class="children"><div class="content">At some point the changes are going to get merged in, no? And that that point I would really like the commits to be nice.</div><br/><div id="41656113" class="c"><input type="checkbox" id="c-41656113" checked=""/><div class="controls bullet"><span class="by">snatchpiesinger</span><span>|</span><a href="#41654433">root</a><span>|</span><a href="#41654456">parent</a><span>|</span><a href="#41655543">next</a><span>|</span><label class="collapse" for="c-41656113">[-]</label><label class="expand" for="c-41656113">[1 more]</label></div><br/><div class="children"><div class="content">git log --first-parent</div><br/></div></div><div id="41655543" class="c"><input type="checkbox" id="c-41655543" checked=""/><div class="controls bullet"><span class="by">dmead</span><span>|</span><a href="#41654433">root</a><span>|</span><a href="#41654456">parent</a><span>|</span><a href="#41656113">prev</a><span>|</span><a href="#41653533">next</a><span>|</span><label class="collapse" for="c-41655543">[-]</label><label class="expand" for="c-41655543">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why you squash and make the commit message readable.</div><br/><div id="41655656" class="c"><input type="checkbox" id="c-41655656" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41654433">root</a><span>|</span><a href="#41655543">parent</a><span>|</span><a href="#41653533">next</a><span>|</span><label class="collapse" for="c-41655656">[-]</label><label class="expand" for="c-41655656">[1 more]</label></div><br/><div class="children"><div class="content">Squash all the commits I worked so hard to make atomic?</div><br/></div></div></div></div></div></div></div></div><div id="41653533" class="c"><input type="checkbox" id="c-41653533" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#41654433">prev</a><span>|</span><a href="#41653903">next</a><span>|</span><label class="collapse" for="c-41653533">[-]</label><label class="expand" for="c-41653533">[5 more]</label></div><br/><div class="children"><div class="content">Uhm, I do a lot of git rebase -i HEAD~2 where I just squash the commit on the latest or sometimes I need to reorder and move the fix commits in specific commits in Pars that multiple commits, which I then need to push force. Is this for a similar use-case? I am not familiar with fixup or how it works.</div><br/><div id="41654380" class="c"><input type="checkbox" id="c-41654380" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#41653533">parent</a><span>|</span><a href="#41653605">next</a><span>|</span><label class="collapse" for="c-41654380">[-]</label><label class="expand" for="c-41654380">[1 more]</label></div><br/><div class="children"><div class="content">fixup lets you mark a change to be rolled back into a previous commit, without changing the history (yet). When you do `git rebase --autosquash` it then automatically moves those commits as `fixup` in the right places. It helps to queue up many fixups at once and only have a single rebase to do when you&#x27;re done (or for reviewers to see just the changes in a review tool, not have to reassess the entire commit because you already rebased)<p>btw you could be doing `git commit --amend` if you just want to add to the last commit.</div><br/></div></div><div id="41653605" class="c"><input type="checkbox" id="c-41653605" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#41653533">parent</a><span>|</span><a href="#41654380">prev</a><span>|</span><a href="#41653672">next</a><span>|</span><label class="collapse" for="c-41653605">[-]</label><label class="expand" for="c-41653605">[2 more]</label></div><br/><div class="children"><div class="content">fixup works with rebase if you add the -a flag for autosquash. try it and you’ll see the commits already reordered for you in the interactive menu.<p>also you can write HEAD~2 as @^^ if you want to save a couple keystrokes!</div><br/><div id="41654824" class="c"><input type="checkbox" id="c-41654824" checked=""/><div class="controls bullet"><span class="by">rom1v</span><span>|</span><a href="#41653533">root</a><span>|</span><a href="#41653605">parent</a><span>|</span><a href="#41653672">next</a><span>|</span><label class="collapse" for="c-41654824">[-]</label><label class="expand" for="c-41654824">[1 more]</label></div><br/><div class="children"><div class="content">Nit: Or @~2 (@ is HEAD, so @^^ is HEAD^^).</div><br/></div></div></div></div><div id="41653672" class="c"><input type="checkbox" id="c-41653672" checked=""/><div class="controls bullet"><span class="by">AlexCoventry</span><span>|</span><a href="#41653533">parent</a><span>|</span><a href="#41653605">prev</a><span>|</span><a href="#41653903">next</a><span>|</span><label class="collapse" for="c-41653672">[-]</label><label class="expand" for="c-41653672">[1 more]</label></div><br/><div class="children"><div class="content">You can also just press `c`, then `F`, in magit.</div><br/></div></div></div></div><div id="41654402" class="c"><input type="checkbox" id="c-41654402" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#41653903">prev</a><span>|</span><a href="#41653647">next</a><span>|</span><label class="collapse" for="c-41654402">[-]</label><label class="expand" for="c-41654402">[1 more]</label></div><br/><div class="children"><div class="content">If I understand the logic it uses correctly this will nearly always attach the fixup to the right commit. It&#x27;s not for me because I do this manually too fluidly but it seems like a good tool.</div><br/></div></div><div id="41653647" class="c"><input type="checkbox" id="c-41653647" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#41654402">prev</a><span>|</span><a href="#41653873">next</a><span>|</span><label class="collapse" for="c-41653647">[-]</label><label class="expand" for="c-41653647">[1 more]</label></div><br/><div class="children"><div class="content">Pretty clever impl of a tool. I&#x27;ll be using it, thanks.</div><br/></div></div><div id="41653873" class="c"><input type="checkbox" id="c-41653873" checked=""/><div class="controls bullet"><span class="by">rglynn</span><span>|</span><a href="#41653647">prev</a><span>|</span><a href="#41655368">next</a><span>|</span><label class="collapse" for="c-41653873">[-]</label><label class="expand" for="c-41653873">[3 more]</label></div><br/><div class="children"><div class="content">As a frequent user of fixups, this feels like a solution for already broken workflows.<p>&gt; Instead of manually finding commit SHAs for git commit --fixup<p>Assuming you are using fixups, is this actually a problem?<p>I could see this being a possibility if you are:
A. not practicing atomic commits
or B. have so many commits in your branch that this is a chore.<p>A. seems unlikely if you are already using fixups and B. seems like a problem worth solving properly rather than going around.<p>To sum up, I&#x27;m not convinced by the elevator pitch. However, I am keenly aware that the workflows of developers differ vastly across industry, company size, technology etc. I&#x27;d be  interested to understand what problems this or similar tools solve?</div><br/><div id="41654660" class="c"><input type="checkbox" id="c-41654660" checked=""/><div class="controls bullet"><span class="by">seadan83</span><span>|</span><a href="#41653873">parent</a><span>|</span><a href="#41653928">next</a><span>|</span><label class="collapse" for="c-41654660">[-]</label><label class="expand" for="c-41654660">[1 more]</label></div><br/><div class="children"><div class="content">What solutions have you seen for problem (B)?<p>The open source example is hard to fix AFAIK. Everything needs to be a PR, some changes to older code bases are simply going to be either large or multi-stepped (many commits, and sending them all as stacked PRs is often not efficient enough to be effective). In industry, I think there are more solutions available. Though, overall, I am very curious how you would go about solving B.</div><br/></div></div><div id="41653928" class="c"><input type="checkbox" id="c-41653928" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41653873">parent</a><span>|</span><a href="#41654660">prev</a><span>|</span><a href="#41655368">next</a><span>|</span><label class="collapse" for="c-41653928">[-]</label><label class="expand" for="c-41653928">[1 more]</label></div><br/><div class="children"><div class="content">How would you manage long-lived branches that are periodically rebased against the master branch (when there is a release, for example)?</div><br/></div></div></div></div><div id="41655368" class="c"><input type="checkbox" id="c-41655368" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41653873">prev</a><span>|</span><label class="collapse" for="c-41655368">[-]</label><label class="expand" for="c-41655368">[6 more]</label></div><br/><div class="children"><div class="content">Am I the only one who doesn&#x27;t like atomic commits (or stacked PRs like graphite)? When I work on large PRs I often rewrite and move things around so much that trying to keep all commits in sync is a nightmare.<p>I do try to split the work if it is very clearly isolated, but that usually means less than 3 PRs. I have tried graphite `gt absorb` (which might use this project?) and it still creates a mess.<p>What I do that I wish more people did is that I heavily comment my own PRs with information that doesn&#x27;t make sense in comments (for example on line X I add a comment: moved here from Y file).<p>&gt; You have fixes for the bugs, but you don&#x27;t want to shove them all into an opaque commit that says fixes<p>I actually like this, but split each fix in its own commit and during review I answer to comments with: &quot;fixed in commit {commit-sha}&quot;. So _often_ bugs are introduced during PR review, if the fixes are isolated it is easier to see what changes between review rounds.</div><br/><div id="41655516" class="c"><input type="checkbox" id="c-41655516" checked=""/><div class="controls bullet"><span class="by">alex23478</span><span>|</span><a href="#41655368">parent</a><span>|</span><label class="collapse" for="c-41655516">[-]</label><label class="expand" for="c-41655516">[5 more]</label></div><br/><div class="children"><div class="content">I think this really boils down how your team is using Git and which code review tool you&#x27;re using. (I&#x27;ve never used Gerrit personally, but as far as I understand it, we wouldn&#x27;t have this conversation, since it aims to refine a single change by re-submitting a commit over and over again?)<p>For GitHub&#x2F;GitLab reviews, I&#x27;m totally with you - this makes it more convenient for the reviewer to check that&#x2F;how you&#x27;ve responded to feedback.<p>But now if you merge this without squashing, your Git history on the main branch contains all your revisions, which makes operations like bisecting or blame more complicated.<p>For me personally, the sweet spot is currently a mix of stacked-commits and the PR workflow: Use a single commit as the unit of review, and polish that commit using a PR, and use the commit descriptions within that PR to tell the story of you responding to feedback. Then, squash merge that commit.<p>This provides both a good review experience and a tidy history. If you find a strange bug later and can&#x27;t grasp how someone could have come up with that, the PR still has all the history.<p>Together with tools such as git-branchless, this also makes working on stacked-PRs a breeze.</div><br/><div id="41656038" class="c"><input type="checkbox" id="c-41656038" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41655368">root</a><span>|</span><a href="#41655516">parent</a><span>|</span><a href="#41655898">next</a><span>|</span><label class="collapse" for="c-41656038">[-]</label><label class="expand" for="c-41656038">[1 more]</label></div><br/><div class="children"><div class="content">I have used standard github and graphite reviews. I tend to prefer what I mentioned in my original post than graphite stacked PR review (which are essentially atomic commits)<p>Yes I also advocate for squash-before-merge, so a lot of little commits is doesn&#x27;t show up in the main history.<p>&gt; For me personally, the sweet spot is currently a mix of stacked-commits and the PR workflow: Use a single commit as the unit of review, and polish that commit using a PR, and use the commit descriptions within that PR to tell the story of you responding to feedback. Then, squash merge that commit.<p>To me time spent on commit polishing (and dealing with conflicts) is time not spent on product. Author comments on PR review, squash-before-merge, and sit-together with reviewer for big PRs to me seems a better compromise. I don&#x27;t think super polished git history is worth the extra effort for most types of product, as long as I can track a change down to a PR discussion that is enough to me. From there I can track PR review commit changes individually if needed.<p>Like it is so uncommon for me to go digging on git history that deeply, usually all I care is &quot;code behaving weird &amp;&amp; line changed &lt; 1 month ago then probably a bug introduced then&quot;<p>Of course if you are working on aviation software and the like maybe the priorities are different. But I have spent way too much time dealing with rebase conflicts when trying to chop up my PRs into smaller commits. Dealing with these conflicts often introduces bugs too.</div><br/></div></div><div id="41655898" class="c"><input type="checkbox" id="c-41655898" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#41655368">root</a><span>|</span><a href="#41655516">parent</a><span>|</span><a href="#41656038">prev</a><span>|</span><label class="collapse" for="c-41655898">[-]</label><label class="expand" for="c-41655898">[3 more]</label></div><br/><div class="children"><div class="content">Why are people talking about stacked PRs&#x2F;MRs? Shouldn&#x27;t they be called queued? A stack is LIFO and a queue is FIFO.<p>(Of course in some special case you might want to merge a later one earlier, but I don&#x27;t think that&#x27;s the normal case people are talking about.)</div><br/><div id="41655966" class="c"><input type="checkbox" id="c-41655966" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#41655368">root</a><span>|</span><a href="#41655898">parent</a><span>|</span><label class="collapse" for="c-41655966">[-]</label><label class="expand" for="c-41655966">[2 more]</label></div><br/><div class="children"><div class="content">Why is it a &quot;Pull Request&quot; instead of a &quot;Push Request&quot;?<p>Someone named it that way and it stuck.</div><br/><div id="41656017" class="c"><input type="checkbox" id="c-41656017" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#41655368">root</a><span>|</span><a href="#41655966">parent</a><span>|</span><label class="collapse" for="c-41656017">[-]</label><label class="expand" for="c-41656017">[1 more]</label></div><br/><div class="children"><div class="content">You request others&#x2F;the maintainer to pull. That was the only way before the forges. I guess gitlab&#x27;s merge request is more descriptive.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>