<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719392515377" as="style"/><link rel="stylesheet" href="styles.css?v=1719392515377"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dotenvx.com/blog/2024/06/24/dotenvx-next-generation-config-management.html">Show HN: From dotenv to dotenvx – better config management</a> <span class="domain">(<a href="https://dotenvx.com">dotenvx.com</a>)</span></div><div class="subtext"><span>scottmotte</span> | <span>121 comments</span></div><br/><div><div id="40792016" class="c"><input type="checkbox" id="c-40792016" checked=""/><div class="controls bullet"><span class="by">cimnine</span><span>|</span><a href="#40792455">next</a><span>|</span><label class="collapse" for="c-40792016">[-]</label><label class="expand" for="c-40792016">[24 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s good advice to not pass secrets through environment variables. Env vars leak a lot. Think php_info, Sentry, java vm dumps, etc. Also, env vars leak into sub-processes if you don&#x27;t pay extra attention. Instead, read secrets from a vault or from a file-system from _inside_ your process. See also [1] (or [2] which discusses [1]). Dotnet does this pretty good with user secrets [3].<p>[1] <a href="https:&#x2F;&#x2F;blog.diogomonica.com&#x2F;2017&#x2F;03&#x2F;27&#x2F;why-you-shouldnt-use-env-variables-for-secret-data&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.diogomonica.com&#x2F;2017&#x2F;03&#x2F;27&#x2F;why-you-shouldnt-use...</a>
[2] <a href="https:&#x2F;&#x2F;security.stackexchange.com&#x2F;questions&#x2F;197784&#x2F;is-it-unsafe-to-use-environmental-variables-for-secret-data" rel="nofollow">https:&#x2F;&#x2F;security.stackexchange.com&#x2F;questions&#x2F;197784&#x2F;is-it-un...</a>
[3] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;aspnet&#x2F;core&#x2F;security&#x2F;app-secrets" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;aspnet&#x2F;core&#x2F;security&#x2F;app-s...</a></div><br/><div id="40794845" class="c"><input type="checkbox" id="c-40794845" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40792016">parent</a><span>|</span><a href="#40796872">next</a><span>|</span><label class="collapse" for="c-40794845">[-]</label><label class="expand" for="c-40794845">[19 more]</label></div><br/><div class="children"><div class="content">&gt; Instead, read secrets from a vault or from a file-system from _inside_ your process.<p>I’ve never liked making secrets available on the filesystem. Lots of security vulnerabilities have turned up over the years that let an attacker read an arbitrary file. If retrieving secrets is a completely different API from normal file IO (e.g. inject a Unix domain socket into each container, and the software running on that container sends a request to that socket to get secrets), that is much less likely to happen.</div><br/><div id="40795927" class="c"><input type="checkbox" id="c-40795927" checked=""/><div class="controls bullet"><span class="by">itchyouch</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40794845">parent</a><span>|</span><a href="#40796363">next</a><span>|</span><label class="collapse" for="c-40795927">[-]</label><label class="expand" for="c-40795927">[10 more]</label></div><br/><div class="children"><div class="content">I used to store secrets in the FS, and was told the best practice was env vars.  Now it&#x27;s not env vars.  What is it then?</div><br/><div id="40796057" class="c"><input type="checkbox" id="c-40796057" checked=""/><div class="controls bullet"><span class="by">qweqwe14</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40795927">parent</a><span>|</span><a href="#40797475">next</a><span>|</span><label class="collapse" for="c-40796057">[-]</label><label class="expand" for="c-40796057">[2 more]</label></div><br/><div class="children"><div class="content">There isn&#x27;t a right answer. It&#x27;s just that people don&#x27;t understand that one doesn&#x27;t provide any meaningful benefit over the other (in the context of storing secrets), but the security &quot;experts&quot; are always eager to claim &quot;X is insecure, do Y instead, it&#x27;s best practice btw&quot;<p>Unless I&#x27;m missing something, there are three scenarios where this comes up:<p>1. You are using a .env file to store secrets that will then be passed to the program through env vars. There&#x27;s literally no difference in this case, you end up storing secrets in the FS anyway.<p>2. You are manually setting an env var with the secret when launching a program, e.g. SECRET=foo .&#x2F;bar. The secret can still be easily obtained by inspecting &#x2F;proc&#x2F;PID&#x2F;environ. It can&#x27;t be read by other users, but so are the files in your user&#x27;s directory (.env&#x2F;secrets.json&#x2F;whatever)<p>3. A program obtains the secret via some other means (network, user input, etc). You can still access &#x2F;proc&#x2F;PID&#x2F;mem and extract the secret from process memory.<p>So I&#x27;m assuming that what people really want is passing the secret to a program and having that secret not be readable by anything other than that program. The proper way to do this is using some OS-provided mechanism, like memfd_secret in Linux. The program can ask for the secret on startup via stdin, then store that secret in the special memory region designed for storing secrets.</div><br/><div id="40796763" class="c"><input type="checkbox" id="c-40796763" checked=""/><div class="controls bullet"><span class="by">delusional</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40796057">parent</a><span>|</span><a href="#40797475">next</a><span>|</span><label class="collapse" for="c-40796763">[-]</label><label class="expand" for="c-40796763">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t even need to roll your own solution with memfd. Linux already has keyrings[1] as a kernel concept.<p>[1]: <a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;keyrings.7.html" rel="nofollow">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;keyrings.7.html</a></div><br/></div></div></div></div><div id="40797475" class="c"><input type="checkbox" id="c-40797475" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40795927">parent</a><span>|</span><a href="#40796057">prev</a><span>|</span><a href="#40796020">next</a><span>|</span><label class="collapse" for="c-40797475">[-]</label><label class="expand" for="c-40797475">[3 more]</label></div><br/><div class="children"><div class="content">The problem with .env files is that you are doing both.<p>You have a .env file that is in the same directory as your code and you just copy to to env vars at some point. This does not even meet the security principles that dotenv is supposed to implement!<p>I think people are blindly following the advice &quot;put secrets in env vars&quot; without understanding that the point of it is to keep secrets outside files your app can read - because if you do a vulnerability or misconfiguration that lets people read those files leaks the secrets.<p>What you can do is have environment vars set outside your code, preferably by another user. You do it in your init system or process supervisor. Someone mentioned passing them in from outside a docker container in another comment.</div><br/><div id="40797880" class="c"><input type="checkbox" id="c-40797880" checked=""/><div class="controls bullet"><span class="by">anentropic</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40797475">parent</a><span>|</span><a href="#40797832">next</a><span>|</span><label class="collapse" for="c-40797880">[-]</label><label class="expand" for="c-40797880">[1 more]</label></div><br/><div class="children"><div class="content">Yes... surely the point of .env file is as a shortcut to provide env vars for <i>local development</i><p>.env file shouldn&#x27;t be used in production, env vars should be injected directly</div><br/></div></div><div id="40797832" class="c"><input type="checkbox" id="c-40797832" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40797475">parent</a><span>|</span><a href="#40797880">prev</a><span>|</span><a href="#40796020">next</a><span>|</span><label class="collapse" for="c-40797832">[-]</label><label class="expand" for="c-40797832">[1 more]</label></div><br/><div class="children"><div class="content">&gt; because if you do a vulnerability or misconfiguration that lets people read those files leaks the secrets.<p>The problem with this is that, on Linux, the environment <i>is</i> a file, &#x2F;proc&#x2F;self&#x2F;environ<p>And yes, as has been mentioned in some other comments, the process memory is also a file &#x2F;proc&#x2F;self&#x2F;mem - but it is a special file that can only be read using special procedures, whereas &#x2F;proc&#x2F;self&#x2F;environ behaves much more like a normal file, so a lot of vulnerabilities that enable reading &#x2F;proc&#x2F;self&#x2F;environ wouldn’t enable reading &#x2F;proc&#x2F;self&#x2F;mem<p>Technically one workaround on Linux is to not mount &#x2F;proc (or at least not in your app’s container) - but doing that breaks a lot of things</div><br/></div></div></div></div><div id="40796020" class="c"><input type="checkbox" id="c-40796020" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40795927">parent</a><span>|</span><a href="#40797475">prev</a><span>|</span><a href="#40796122">next</a><span>|</span><label class="collapse" for="c-40796020">[-]</label><label class="expand" for="c-40796020">[1 more]</label></div><br/><div class="children"><div class="content">Well, I’d be the first to admit that we have a gap here, the solution that I personally would consider ideal doesn’t seem to actually exist, at least on the server-side.<p>If we are running under something like K8S or Docker, then I think there should be some component that runs on the host, that provides access to secrets over a Unix domain secret, and then we mount that socket into each container. (The reason I say a Unix domain socket, is so then the component can use SCM_CREDENTIALS&#x2F;SO_PEERCRED&#x2F;etc to authenticate the containers). I’d also suggest <i>not</i> using HTTP, to reduce the potential impact of any SSRF vulnerabilities (although maybe that’s less of a risk given many HTTP clients don’t work with Unix domain sockets-or at least not without special config). (Can we pass memfd_secret using SCM_RIGHTS?)<p>For desktop and native mobile, I think the best practice is to use the platform secret store (Keychain on macOS&#x2F;iOS, Freedesktop Secret Service for desktop Linux, Android Keystore, Windows Credential Manager API, etc). But for server-side apps, those APIs generally aren’t available (Windows excepted). Server-side Linux often lacks desktop Linux components such as Freedesktop APIs (and even when they’re present, they aren’t the best fit for server-side use cases)</div><br/></div></div><div id="40796385" class="c"><input type="checkbox" id="c-40796385" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40795927">parent</a><span>|</span><a href="#40796122">prev</a><span>|</span><a href="#40796036">next</a><span>|</span><label class="collapse" for="c-40796385">[-]</label><label class="expand" for="c-40796385">[1 more]</label></div><br/><div class="children"><div class="content">The filesystem is fine, but we really shouldn&#x27;t be using .env files that get loaded into environment variables due to them leaking in a few different ways.</div><br/></div></div></div></div><div id="40796363" class="c"><input type="checkbox" id="c-40796363" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40794845">parent</a><span>|</span><a href="#40795927">prev</a><span>|</span><a href="#40795339">next</a><span>|</span><label class="collapse" for="c-40796363">[-]</label><label class="expand" for="c-40796363">[7 more]</label></div><br/><div class="children"><div class="content">God this is such a prime example of how we just don&#x27;t do security well enough industry wide, and then you end up with weird stupid stuff like encryption being an enterprise paid feature.<p>Secrets have to be somewhere. Environment variables are not a good place for them, but if you can&#x27;t trust your filesystem to be secure, you&#x27;re already screwed. There&#x27;s no where else to go. The only remaining place is memory, and it&#x27;s the same story.<p>If you can&#x27;t trust memory isolation, you&#x27;re screwed.<p>As a counterintuitive example from a former insider: virtually no one is storing secrets for financial software on an HSM. Almost no one does it, period.</div><br/><div id="40796748" class="c"><input type="checkbox" id="c-40796748" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40796363">parent</a><span>|</span><a href="#40796582">next</a><span>|</span><label class="collapse" for="c-40796748">[-]</label><label class="expand" for="c-40796748">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Secrets have to be somewhere. Environment variables are not a good place for them, but if you can&#x27;t trust your filesystem to be secure, you&#x27;re already screwed. There&#x27;s no where else to go. The only remaining place is memory, and it&#x27;s the same story.<p>There’s a whole class of security vulnerabilities that let you read from arbitrary files on the filesystem. So if you end up having of those vulnerabilities, and your secret is in a file, then the vulnerability lets the attacker read the secret. And on Linux, if you have such a vulnerability, you can use it to read &#x2F;proc&#x2F;PID&#x2F;environ and get the environment variables, hence getting secrets in environment variables too.<p>However, the same isn’t necessarily true for memory. &#x2F;proc&#x2F;PID&#x2F;mem isn’t an ordinary file, and naive approaches to reading it fail. You normally read a file starting at position 0; reading &#x2F;proc&#x2F;PID&#x2F;mem requires first seeking to a mapped address (which you can get from &#x2F;proc&#x2F;PID&#x2F;maps); if you just open the file and start reading it from the start, you’ll be trying to read the unmapped zero page, and you’ll get an IO error. Many (I suspect the majority) of arbitrary-file read vulnerabilities only let you read from the start of the file and won’t let you seek past the initial unreadable portion, so they won’t let you read &#x2F;proc&#x2F;PID&#x2F;mem.<p>Additionally, there are hardening features to lock down access to &#x2F;proc&#x2F;PID&#x2F;mem, such as kernel.yama.ptrace_scope, or prctl(PR_SET_DUMPABLE)-that kind of hardening can interfere with debugging, but one option is to leave it on most of the time and only temporarily disable it when you have an issue to diagnose<p>Also, memfd_secret supports allocating extra-special memory for secret storage, which the kernel can’t read, so it shouldn’t be accessible via &#x2F;proc&#x2F;PID&#x2F;mem</div><br/><div id="40796857" class="c"><input type="checkbox" id="c-40796857" checked=""/><div class="controls bullet"><span class="by">delusional</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40796748">parent</a><span>|</span><a href="#40796582">next</a><span>|</span><label class="collapse" for="c-40796857">[-]</label><label class="expand" for="c-40796857">[2 more]</label></div><br/><div class="children"><div class="content">&gt;There’s a whole class of security vulnerabilities that let you read from arbitrary files on the filesystem.<p>This is maybe putting the cart before the horse a little bit. The reason there&#x27;s a class of vulnerabilities that allow arbitrary read is that we&#x27;ve, as an industry, decided that we classify file access as a vulnerability. It&#x27;s not that file access is somehow materially different or easier from any other security issue, it&#x27;s just that we set that as one of the goals of an attack.<p>If you decide that an attack is successful when it reads a file, then you&#x27;ll obviously get a clustering of successful attacks that read files.</div><br/><div id="40797471" class="c"><input type="checkbox" id="c-40797471" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40796857">parent</a><span>|</span><a href="#40796582">next</a><span>|</span><label class="collapse" for="c-40797471">[-]</label><label class="expand" for="c-40797471">[1 more]</label></div><br/><div class="children"><div class="content">It isn’t just about preventing vulnerabilities, it is also about limiting the damage they can cause. Suppose you have a web app, with customer data in a remote relational database. An arbitrary file read vulnerability, in itself, might not actually help an attacker in stealing your customer data, since it is in a remote DB not the web app’s filesystem. But if that vulnerability enables them to exfiltrate database credentials, that gets them one step closer to actually stealing your customer data, which can be an enormously costly legal and PR headache. (By itself, those credentials won’t be that useful, since hopefully your firewall will block direct public access to the DB - but a lot of successful attacks involve chaining multiple vulnerabilities&#x2F;weaknesses - e.g. they compromise some employee laptop that lets them talk to the DB but they don’t have credentials, and now they have the credentials too.)<p>Whereas, if all they manage to steal using a file read vulnerability is the code (possibly even just the binaries if you are using a compiled language like Go or Java) of your web app - that’s not good either, but it is a lot smaller headache. You’d much rather be having to tell the CEO “attackers stole the binaries of our app” than “attackers stole all the PII of our customers”. Both are bad but the second is a lot worse. The first kind of attack you possibly won’t be obliged to disclose, the second you legally will be</div><br/></div></div></div></div></div></div><div id="40796582" class="c"><input type="checkbox" id="c-40796582" checked=""/><div class="controls bullet"><span class="by">TristanBall</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40796363">parent</a><span>|</span><a href="#40796748">prev</a><span>|</span><a href="#40795339">next</a><span>|</span><label class="collapse" for="c-40796582">[-]</label><label class="expand" for="c-40796582">[3 more]</label></div><br/><div class="children"><div class="content">Did they say why?<p>It strikes me that those envs might be particularly prone to corporate inertia, ieg &quot;the current way passed security audit, don&#x27;t change it or we need to requalify&quot;<p>It&#x27;s possibly also harder to rely on a HSM when your software is in a container? ( I&#x27;m guessing here tho )</div><br/><div id="40797289" class="c"><input type="checkbox" id="c-40797289" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40796582">parent</a><span>|</span><a href="#40795339">next</a><span>|</span><label class="collapse" for="c-40797289">[-]</label><label class="expand" for="c-40797289">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a useless, unproveable generalisation from a supposedly omniscient &quot;insider&quot;. I know of at least one finance organisation using HSM as you&#x27;d expect.</div><br/><div id="40797419" class="c"><input type="checkbox" id="c-40797419" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40797289">parent</a><span>|</span><a href="#40795339">next</a><span>|</span><label class="collapse" for="c-40797419">[-]</label><label class="expand" for="c-40797419">[1 more]</label></div><br/><div class="children"><div class="content">And I know non-finance orgs using HSM to protect encryption keys used to encrypt PII</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40796872" class="c"><input type="checkbox" id="c-40796872" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#40792016">parent</a><span>|</span><a href="#40794845">prev</a><span>|</span><a href="#40796860">next</a><span>|</span><label class="collapse" for="c-40796872">[-]</label><label class="expand" for="c-40796872">[3 more]</label></div><br/><div class="children"><div class="content">Disagree here. Basically if you use docker (which for most of the stuff you mention, you should), environment variables are pretty much how you configure your docker containers and a lot of sever software packaged up as docker containers expects to be configured this way.<p>Building a lot of assumptions into your containers about where and how they are being deployed kind of defeats the point of using containers. You should inject configuration, including secrets, from the outside. The right time to access secret stores is just before you start the container as part of the deploy process or vm startup in cloud environments. And then you use environment variables to pass the information onto the container.<p>Of course that does make some assumptions about the environment where you run your containers not being compromised. But then if that assumption breaks you are in big trouble anyway.<p>Of course this tool is designed for developer machines and for that it seems useful. But I hope to never find this in a production environment.</div><br/><div id="40797213" class="c"><input type="checkbox" id="c-40797213" checked=""/><div class="controls bullet"><span class="by">vitalysh</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40796872">parent</a><span>|</span><a href="#40796860">next</a><span>|</span><label class="collapse" for="c-40797213">[-]</label><label class="expand" for="c-40797213">[2 more]</label></div><br/><div class="children"><div class="content">inject those variables via mount?</div><br/><div id="40797893" class="c"><input type="checkbox" id="c-40797893" checked=""/><div class="controls bullet"><span class="by">wegfawefgawefg</span><span>|</span><a href="#40792016">root</a><span>|</span><a href="#40797213">parent</a><span>|</span><a href="#40796860">next</a><span>|</span><label class="collapse" for="c-40797893">[-]</label><label class="expand" for="c-40797893">[1 more]</label></div><br/><div class="children"><div class="content">When you launch the docker containers you can pass in process env vars or do it via file. Nowadays people do this via kubernetes config yamls, which passes env to docker. Or rather they used to. Most people now use Helm charts which pass in the env to k8 yaml whivh pass them to docker. Actually thats not true. Most people have the env split halfway between github actions secrets, and amazon secrets. The yaml for your github action config sends aws secret uri to the runner, which runs cdk which grabs the aws secret, and passes that to helm which makes k8 yamls, which passes the env to docker, which passes it to the process.<p>I want to kill myself.</div><br/></div></div></div></div></div></div><div id="40796860" class="c"><input type="checkbox" id="c-40796860" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#40792016">parent</a><span>|</span><a href="#40796872">prev</a><span>|</span><a href="#40792455">next</a><span>|</span><label class="collapse" for="c-40796860">[-]</label><label class="expand" for="c-40796860">[1 more]</label></div><br/><div class="children"><div class="content">Secrets are nasty and there are tradeoffs in every direction.<p>Environment vars propagate from process to process _by design_ and generally last the entire process(es) lifetime. They are observable from many os tools unless you&#x27;ve hardened your config and they will appear in core files etc. Secrets imply scope and lifetime - so env variables feel very at odds. Alternatively Env variables are nearly perfect for config for the same reasons that they are concerning for secrets.<p>Tl&#x2F;Dr; in low stakes environments the fact that secrets are a special type of config means you will see it being used with env vars which are great for most configs but are poor for secrets. And frankly if you can stomach the risks, it is not that bad.<p>Storing secrets on the filesystem - you immediately need to answer where on the filesystem and how to restrict access (and are your rules being followed). Is your media encrypted at rest? Do you have se Linux configured? Are you sure the secrets are cleaned after you no longer need them? Retrieving secrets or elevated perms via sockets &#x2F; local ipc have very similar problems (but perhaps at this point your compartmentalizing all the secrets into a centralized, local point).<p>A step beyond this are secrets that are locked behind cloud key management APIs or systems like spiffe&#x2F;spire. At this point you still have to tackle workload identity, which is also a very nuanced problem.<p>With secrets every solution has challenges and there the only clear answer is to have a threat model and design an architecture and appropriate mitigations that let you feel comfortable while acknowledging the cost, user, developer and operator experience balancing act.</div><br/></div></div></div></div><div id="40792455" class="c"><input type="checkbox" id="c-40792455" checked=""/><div class="controls bullet"><span class="by">neonate</span><span>|</span><a href="#40792016">prev</a><span>|</span><a href="#40792422">next</a><span>|</span><label class="collapse" for="c-40792455">[-]</label><label class="expand" for="c-40792455">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;dotenvx&#x2F;dotenvx">https:&#x2F;&#x2F;github.com&#x2F;dotenvx&#x2F;dotenvx</a></div><br/></div></div><div id="40792422" class="c"><input type="checkbox" id="c-40792422" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#40792455">prev</a><span>|</span><a href="#40791606">next</a><span>|</span><label class="collapse" for="c-40792422">[-]</label><label class="expand" for="c-40792422">[1 more]</label></div><br/><div class="children"><div class="content">The only reason I use .env is because it’s dead simple and very obvious as to how it works to anyone.<p>If now someone has to read docs to figure out how to configure the app, I’d rather have them read docs for some other safer and more powerful configuration scheme.</div><br/></div></div><div id="40791606" class="c"><input type="checkbox" id="c-40791606" checked=""/><div class="controls bullet"><span class="by">sandstrom</span><span>|</span><a href="#40792422">prev</a><span>|</span><a href="#40790546">next</a><span>|</span><label class="collapse" for="c-40791606">[-]</label><label class="expand" for="c-40791606">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve started using Mise for some stuff at work. Haven&#x27;t digged in a lot yet, but looks really promising.<p><a href="https:&#x2F;&#x2F;mise.jdx.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mise.jdx.dev&#x2F;</a><p>It handles task running (wipe local test db, run linting scripts, etc), environment variables and &#x27;virtual environments&#x27;, as well as replacing stuff like  asdf, nvm, pyenv and rbenv.<p>Still somewhat early days, tasks are experimental. But looks very promising and the stuff I&#x27;ve tried to far (tasks) works really well.</div><br/><div id="40791715" class="c"><input type="checkbox" id="c-40791715" checked=""/><div class="controls bullet"><span class="by">ralgozino</span><span>|</span><a href="#40791606">parent</a><span>|</span><a href="#40795013">next</a><span>|</span><label class="collapse" for="c-40791715">[-]</label><label class="expand" for="c-40791715">[1 more]</label></div><br/><div class="children"><div class="content">I second mise, it&#x27;s been a nice replacement for direnv, asdf and makefiles for my use case. Much faster, still compatible with the old configuration files when needed and all in one tool for the new projects. Awesome.</div><br/></div></div><div id="40795013" class="c"><input type="checkbox" id="c-40795013" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#40791606">parent</a><span>|</span><a href="#40791715">prev</a><span>|</span><a href="#40790546">next</a><span>|</span><label class="collapse" for="c-40795013">[-]</label><label class="expand" for="c-40795013">[1 more]</label></div><br/><div class="children"><div class="content">I use asdf at work and mise at home. I only use it for runtime version management and it’s great!</div><br/></div></div></div></div><div id="40790546" class="c"><input type="checkbox" id="c-40790546" checked=""/><div class="controls bullet"><span class="by">michaelmior</span><span>|</span><a href="#40791606">prev</a><span>|</span><a href="#40790251">next</a><span>|</span><label class="collapse" for="c-40790546">[-]</label><label class="expand" for="c-40790546">[7 more]</label></div><br/><div class="children"><div class="content">With leaking secrets being such a big concern, it seems wise to <i>require</i> that secrets be encrypted to use dotenvx. That is, it will only work with encrypted secrets. As others have commented, this doesn&#x27;t eliminate the risk entirely, but I think having a tool that doesn&#x27;t support unencrypted secrets at all, although a bit less convenient, is a win.</div><br/><div id="40794766" class="c"><input type="checkbox" id="c-40794766" checked=""/><div class="controls bullet"><span class="by">bluelightning2k</span><span>|</span><a href="#40790546">parent</a><span>|</span><a href="#40793877">next</a><span>|</span><label class="collapse" for="c-40794766">[-]</label><label class="expand" for="c-40794766">[1 more]</label></div><br/><div class="children"><div class="content">Not all env vars are secrets. About half is just regular config. If mandatory how would it know what&#x27;s a secret?</div><br/></div></div><div id="40793877" class="c"><input type="checkbox" id="c-40793877" checked=""/><div class="controls bullet"><span class="by">akvadrako</span><span>|</span><a href="#40790546">parent</a><span>|</span><a href="#40794766">prev</a><span>|</span><a href="#40795160">next</a><span>|</span><label class="collapse" for="c-40793877">[-]</label><label class="expand" for="c-40793877">[4 more]</label></div><br/><div class="children"><div class="content">Encrypted with what key? Do you just mean obscured?</div><br/><div id="40794286" class="c"><input type="checkbox" id="c-40794286" checked=""/><div class="controls bullet"><span class="by">cced</span><span>|</span><a href="#40790546">root</a><span>|</span><a href="#40793877">parent</a><span>|</span><a href="#40794214">next</a><span>|</span><label class="collapse" for="c-40794286">[-]</label><label class="expand" for="c-40794286">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of ways of doing this, sealed secrets is one, mozilla sops is another.</div><br/></div></div><div id="40794214" class="c"><input type="checkbox" id="c-40794214" checked=""/><div class="controls bullet"><span class="by">projektfu</span><span>|</span><a href="#40790546">root</a><span>|</span><a href="#40793877">parent</a><span>|</span><a href="#40794286">prev</a><span>|</span><a href="#40795160">next</a><span>|</span><label class="collapse" for="c-40794214">[-]</label><label class="expand" for="c-40794214">[2 more]</label></div><br/><div class="children"><div class="content">The utility has a means of encrypting them with public key cryptography so that the plaintext is never in your development directory.  GP thinks this should be made mandatory.</div><br/></div></div></div></div></div></div><div id="40790251" class="c"><input type="checkbox" id="c-40790251" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#40790546">prev</a><span>|</span><a href="#40790104">next</a><span>|</span><label class="collapse" for="c-40790251">[-]</label><label class="expand" for="c-40790251">[3 more]</label></div><br/><div class="children"><div class="content">Seems pretty similar to sops[0], but without the encrypted-by-default feature that makes sops feel significantly safer for secret management.<p>Sops also integrates easily with AWS and other existing key management solutions, so that you can use your existing IAM controls on keys.<p>I mentioned in another comment, but I&#x27;ve been using it over five years at two jobs and have found it to be great.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;getsops&#x2F;sops">https:&#x2F;&#x2F;github.com&#x2F;getsops&#x2F;sops</a></div><br/><div id="40792978" class="c"><input type="checkbox" id="c-40792978" checked=""/><div class="controls bullet"><span class="by">hadlock</span><span>|</span><a href="#40790251">parent</a><span>|</span><a href="#40792639">next</a><span>|</span><label class="collapse" for="c-40792978">[-]</label><label class="expand" for="c-40792978">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using sops in production since at least 2017, plus it has excellent compatibility with containerized infra tools like helm and other infra tools like terraform (both technically using plugins, but helm secrets and the carlpetts terraform plugin have been around for ages and are widely used.</div><br/></div></div><div id="40792639" class="c"><input type="checkbox" id="c-40792639" checked=""/><div class="controls bullet"><span class="by">pmccarren</span><span>|</span><a href="#40790251">parent</a><span>|</span><a href="#40792978">prev</a><span>|</span><a href="#40790104">next</a><span>|</span><label class="collapse" for="c-40792639">[-]</label><label class="expand" for="c-40792639">[1 more]</label></div><br/><div class="children"><div class="content">I too have been using sops for years, and agree -- dotenvx encryption seems very similar to sops.<p>I&#x27;d prefer an integration between dotevnx and sops where dotevnx handles the UX of public env and injection, while leveraging sops for secret management and retrieval. Additionally, being able to have multiple keys for different actors is important.<p>Having a single `.env.keys` file feels risky and error prone. dotenvx encourages adding your various env files, such as `.env.production`, to vcs, and you&#x27;re one simple mistake away from committing your keyfile and having a bad day.<p>If sops is not to be integrated, dotenvx could take some inspiration where the main key is encrypted in the secrets file itself, and you can define multiple age key recipients, each of which can then decrypt the main key.</div><br/></div></div></div></div><div id="40790104" class="c"><input type="checkbox" id="c-40790104" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#40790251">prev</a><span>|</span><a href="#40795484">next</a><span>|</span><label class="collapse" for="c-40790104">[-]</label><label class="expand" for="c-40790104">[6 more]</label></div><br/><div class="children"><div class="content">Encrypting secrets and committing them seems very convenient but I&#x27;m paranoid about these sorts of things. Can anyone tell me why this would be a bad idea?<p>One reason I can think of is that normally with secrets I actually don&#x27;t keep any copies of them. I just set them in whatever secret manager my cloud environment uses and never touch them again unless I need to rotate them. Meaning there is no way to accidentally expose them other than by the secret vault being hacked or my environment being hacked.<p>With this approach if someone gets access to the encryption key all secrets are exposed.</div><br/><div id="40791563" class="c"><input type="checkbox" id="c-40791563" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#40790104">parent</a><span>|</span><a href="#40790200">next</a><span>|</span><label class="collapse" for="c-40791563">[-]</label><label class="expand" for="c-40791563">[2 more]</label></div><br/><div class="children"><div class="content">The biggest issue with storing secrets in version control with the code is that past secrets are never relevant after they have been rotated. This makes rollbacks risky. Consider:<p><pre><code>  1. Create secret v1
  2. Code v1
  3. Deploy
  4. Secret v2 (rotation)
  5. Code v2
  6. Deploy
  7. Oops, need to roll back to v1 (from step 2)
  8. Outage, because the secrets in step 2 are not the secrets from step 4</code></pre></div><br/><div id="40795466" class="c"><input type="checkbox" id="c-40795466" checked=""/><div class="controls bullet"><span class="by">Grimburger</span><span>|</span><a href="#40790104">root</a><span>|</span><a href="#40791563">parent</a><span>|</span><a href="#40790200">next</a><span>|</span><label class="collapse" for="c-40795466">[-]</label><label class="expand" for="c-40795466">[1 more]</label></div><br/><div class="children"><div class="content">This seems trivially solved by never mingling secret rotations with general deployments?</div><br/></div></div></div></div><div id="40790200" class="c"><input type="checkbox" id="c-40790200" checked=""/><div class="controls bullet"><span class="by">Atotalnoob</span><span>|</span><a href="#40790104">parent</a><span>|</span><a href="#40791563">prev</a><span>|</span><a href="#40795484">next</a><span>|</span><label class="collapse" for="c-40790200">[-]</label><label class="expand" for="c-40790200">[3 more]</label></div><br/><div class="children"><div class="content">Using encrypted secrets provides a way better developer experience than using a vault.<p>Typically, developers can’t change production secrets in vaults and need to follow some other protocols.<p>Encrypted secrets mean you deploy everything along side the secrets.<p>The developer experience is great, but the biggest issues I have faced while using Kubeseal were<p>1. Developers HAVE the secret in order to encrypt it. This can be not ideal as then they can use these secrets in production or leak them<p>2. The secret encryption key change causes the need to re encrypt everything.<p>3. People don’t understand the concept.</div><br/><div id="40791271" class="c"><input type="checkbox" id="c-40791271" checked=""/><div class="controls bullet"><span class="by">prepend</span><span>|</span><a href="#40790104">root</a><span>|</span><a href="#40790200">parent</a><span>|</span><a href="#40791554">next</a><span>|</span><label class="collapse" for="c-40791271">[-]</label><label class="expand" for="c-40791271">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. Using vaults isn’t that bad. And I’d also like developers to never actually know the secrets.<p>It’s a learning curve, but I think it’s best to just bite the bullet and use a vault rather than trusting developers to know and manage secrets properly.</div><br/></div></div><div id="40791554" class="c"><input type="checkbox" id="c-40791554" checked=""/><div class="controls bullet"><span class="by">nahtnam</span><span>|</span><a href="#40790104">root</a><span>|</span><a href="#40790200">parent</a><span>|</span><a href="#40791271">prev</a><span>|</span><a href="#40795484">next</a><span>|</span><label class="collapse" for="c-40791554">[-]</label><label class="expand" for="c-40791554">[1 more]</label></div><br/><div class="children"><div class="content">Another benefit is that debugging secret changes is a lot easier. We&#x27;ve had a couple of cases where someone changes the secret in a vault and that causes problems and no one can tell what changed between two deploys</div><br/></div></div></div></div></div></div><div id="40795484" class="c"><input type="checkbox" id="c-40795484" checked=""/><div class="controls bullet"><span class="by">clord</span><span>|</span><a href="#40790104">prev</a><span>|</span><a href="#40793002">next</a><span>|</span><label class="collapse" for="c-40795484">[-]</label><label class="expand" for="c-40795484">[2 more]</label></div><br/><div class="children"><div class="content">Env vars over-share and files depend on local permissions. We should have a capabilities -like way to send secrets between processes. e.g., decrypt and expose on a Unix socket with a sha filename that can only be read from once, and then gets torn down. Share the file name, target can read it and immediately the secret is now at-rest encrypted. 
Encryption based on config containing a whitelist of ssh public keys and what they can access, sort of like age.</div><br/><div id="40796926" class="c"><input type="checkbox" id="c-40796926" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#40795484">parent</a><span>|</span><a href="#40793002">next</a><span>|</span><label class="collapse" for="c-40796926">[-]</label><label class="expand" for="c-40796926">[1 more]</label></div><br/><div class="children"><div class="content">Yes and now we have to manage the identities of processes to ensure they are entitled to given capabilities.<p>Also any system as described needs security audit and analysis to truly understand it strengths and weaknesses (or glaring compromises).<p>Alternatively - secrets via environment vars weaknesses and mitigations are well understood.</div><br/></div></div></div></div><div id="40793002" class="c"><input type="checkbox" id="c-40793002" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#40795484">prev</a><span>|</span><a href="#40796795">next</a><span>|</span><label class="collapse" for="c-40793002">[-]</label><label class="expand" for="c-40793002">[4 more]</label></div><br/><div class="children"><div class="content">Importing a set of library and dependencies to handle reading a plain text file poses more risks than just leaving the file unencrypted.<p>You don&#x27;t need to encrypt your keys, with what keys are you going to do so? Will you encrypt those?<p>if someone is in your server you are pwned anyways.<p>It&#x27;s ok if you identify yourself as a cybersecurity dude and hold a cybersecurity role and you need to justify your livelihood.<p>But do it in a way where you don&#x27;t bother people. It&#x27;s ok if you bother devs, but then you go on and bother users with 4FA, 5 rule passwords, systems that can&#x27;t answer subpoenas because you have encrypted your sense of self.<p>When you are improving security at the expense of every other variable, that&#x27;s annoying, but when you keep &quot;improving security&quot; at the expense even of security, is the point where people will start ignoring and hiding shit from you</div><br/><div id="40793470" class="c"><input type="checkbox" id="c-40793470" checked=""/><div class="controls bullet"><span class="by">NegativeK</span><span>|</span><a href="#40793002">parent</a><span>|</span><a href="#40796795">next</a><span>|</span><label class="collapse" for="c-40793470">[-]</label><label class="expand" for="c-40793470">[3 more]</label></div><br/><div class="children"><div class="content">&gt; if someone is in your server you are pwned anyways.<p>This is false and also a symptom of an all-or-nothing approach to cybersecurity, which isn&#x27;t feasible in the real world.</div><br/><div id="40796221" class="c"><input type="checkbox" id="c-40796221" checked=""/><div class="controls bullet"><span class="by">qweqwe14</span><span>|</span><a href="#40793002">root</a><span>|</span><a href="#40793470">parent</a><span>|</span><a href="#40794520">next</a><span>|</span><label class="collapse" for="c-40796221">[-]</label><label class="expand" for="c-40796221">[1 more]</label></div><br/><div class="children"><div class="content">Sorry but it <i>is</i> largely all-or-nothing in this case, if someone has access to the user the app runs as, you are screwed. It doesn&#x27;t matter whether you use env vars or files.<p>I&#x27;m assuming the parent intended to say &quot;if someone gained access to your user you are pwned anyways&quot;, which is true, unless you actually go to the effort of storing the secrets securely using OS-provided mechanisms. Env vars are not that.<p>&gt; which isn&#x27;t feasible in the real world<p>Well of course it isn&#x27;t, how would you justify those sweet cybersecurity experts&#x27; paychecks otherwise? Not saying cybersecurity isn&#x27;t important, but there&#x27;s way too much snake oil in the industry nowadays (always has been?).</div><br/></div></div><div id="40794520" class="c"><input type="checkbox" id="c-40794520" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#40793002">root</a><span>|</span><a href="#40793470">parent</a><span>|</span><a href="#40796221">prev</a><span>|</span><a href="#40796795">next</a><span>|</span><label class="collapse" for="c-40794520">[-]</label><label class="expand" for="c-40794520">[1 more]</label></div><br/><div class="children"><div class="content">I suppose they could have read only access to the filesystem and read the api keys, like through an http server</div><br/></div></div></div></div></div></div><div id="40796795" class="c"><input type="checkbox" id="c-40796795" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#40793002">prev</a><span>|</span><a href="#40792215">next</a><span>|</span><label class="collapse" for="c-40796795">[-]</label><label class="expand" for="c-40796795">[1 more]</label></div><br/><div class="children"><div class="content">Something I have done for secrets is use a syntax in environment variables to tell the process to go a key vault for the secret.<p>So we can have<p>FOOPW=pw1<p>when testing locally, but<p>FOOPW=&quot;{vault1:secret1}&quot;<p>in production. Env vars are processed simply by running a regex with callback that fetches secrets from vaults. This is quite flexible and has the advantage of being able to inject the secrets in the same place as other configuration, without <i>actually</i> having the secrets in environment variables or git etc (even encrypted)</div><br/></div></div><div id="40792215" class="c"><input type="checkbox" id="c-40792215" checked=""/><div class="controls bullet"><span class="by">hamasho</span><span>|</span><a href="#40796795">prev</a><span>|</span><a href="#40790359">next</a><span>|</span><label class="collapse" for="c-40792215">[-]</label><label class="expand" for="c-40792215">[2 more]</label></div><br/><div class="children"><div class="content">I want an option to manage all env in a single file using a TOML like format like this.<p><pre><code>  [local]
  API_KEY=local-key
  API_SECRET=local-secret
  DB=postgresql:&#x2F;&#x2F;username:password@localhost:5432&#x2F;database_name
  [production]
  API_KEY=prod-key
  API_SECRET=prod-secret
  DB=postgresql:&#x2F;&#x2F;username:password@prod-db:5432&#x2F;database_name
  [staging]
  API_KEY=stg-key
  API_SECRET=stg-secret
  DB=$(production.DB)
</code></pre>
It makes it easier to update all env at once, compare, and share.
It&#x27;s not much help, but it helps me avoid a few annoyances.<p>On an unrelated note, I always find it a real headache to keep the naming convention
of the environments throughout the project.
It always ends up like a mixed bag:<p><pre><code>  * Juggling production&#x2F;prod, staging&#x2F;stg, and develop&#x2F;dev,
  * Inconsistent placement of env, e.g. prod-myproject or myproject-stg,
  * Skipping env name sometimes, e.g. myproject-bucket for dev S3 bucket but prod-myproject-bucket for prod (though it&#x27;s okay to emit env name for user facing places like URL),
  * Inconsistent resource sharing between envs, e.g. same S3 bucket for local and dev but different DB, or same Kubernetes cluster with different labels for dev&#x2F;stg but different cluster without a label for prod.
</code></pre>
These inconsistencies often result from quick decisions without much thought or out of necessities,
and everyone is too scared to fix them anyway.
But it bothers me a lot and sometimes causes serious bugs in production.<p>Fix: format</div><br/><div id="40792947" class="c"><input type="checkbox" id="c-40792947" checked=""/><div class="controls bullet"><span class="by">nunez</span><span>|</span><a href="#40792215">parent</a><span>|</span><a href="#40790359">next</a><span>|</span><label class="collapse" for="c-40792947">[-]</label><label class="expand" for="c-40792947">[1 more]</label></div><br/><div class="children"><div class="content">You can do that today with sops if you&#x27;d like!</div><br/></div></div></div></div><div id="40790359" class="c"><input type="checkbox" id="c-40790359" checked=""/><div class="controls bullet"><span class="by">rrgok</span><span>|</span><a href="#40792215">prev</a><span>|</span><a href="#40790514">next</a><span>|</span><label class="collapse" for="c-40790359">[-]</label><label class="expand" for="c-40790359">[11 more]</label></div><br/><div class="children"><div class="content">Can a kind soul point me some documentation on how to put .env in a vault correctly? Possibly open-source solutions?<p>If the vault is password protected, aren&#x27;t you just adding one more indirection and nothing more? How is that helpful, since now I have to write the vault password in clear-text somewhere such that my application can read the env file from the vault?</div><br/><div id="40790440" class="c"><input type="checkbox" id="c-40790440" checked=""/><div class="controls bullet"><span class="by">c0brac0bra</span><span>|</span><a href="#40790359">parent</a><span>|</span><a href="#40792961">next</a><span>|</span><label class="collapse" for="c-40790440">[-]</label><label class="expand" for="c-40790440">[9 more]</label></div><br/><div class="children"><div class="content">A lot of modern cloud deployments read from a secret management system or vault at deployment time, and the secrets are made accessible to the application through various indirect methods so they cannot be accessed later on (i.e.  if someone were to gain access to a running Kubernetes container).<p>At no point does the application have access to the vault itself, and access to read the vault is guarded by IAM role permissions.</div><br/><div id="40790521" class="c"><input type="checkbox" id="c-40790521" checked=""/><div class="controls bullet"><span class="by">rrgok</span><span>|</span><a href="#40790359">root</a><span>|</span><a href="#40790440">parent</a><span>|</span><a href="#40792961">next</a><span>|</span><label class="collapse" for="c-40790521">[-]</label><label class="expand" for="c-40790521">[8 more]</label></div><br/><div class="children"><div class="content">Oh well, I really appreciate you taking the time to explain it.
But honestly, I didn&#x27;t understand a word. I recognize it is my lack of knowledge.<p>I hope someone can do me a ELI5.</div><br/><div id="40790811" class="c"><input type="checkbox" id="c-40790811" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#40790359">root</a><span>|</span><a href="#40790521">parent</a><span>|</span><a href="#40790858">next</a><span>|</span><label class="collapse" for="c-40790811">[-]</label><label class="expand" for="c-40790811">[4 more]</label></div><br/><div class="children"><div class="content">Something <i>else</i> pulls from the vault and exposes it as a regular env var to your process. The .env file is a workaround to get this running locally! For open source, the simplest to explain is using a k8s secret mounted to a pod — pod identity allows access to the secret via rbac, which cannot be faked. Only that pod has access to that secret. But your process, running on the pod, sees it as an env var.</div><br/><div id="40791498" class="c"><input type="checkbox" id="c-40791498" checked=""/><div class="controls bullet"><span class="by">boarnoah</span><span>|</span><a href="#40790359">root</a><span>|</span><a href="#40790811">parent</a><span>|</span><a href="#40790858">next</a><span>|</span><label class="collapse" for="c-40791498">[-]</label><label class="expand" for="c-40791498">[3 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t cover what the GP was talking about with<p>&gt; (i.e. if someone were to gain access to a running Kubernetes container)<p>right? Since those would still be secrets available in the env.<p>I get that if someone has access to read your envvars, its a foregone conclusion already (about how compromised you are).<p>However IIUC, the part of the point of doing things in memory with reading secrets (like with a Secrets Manager, is to eliminate having to keep secrets around as envvars&#x2F;secret files in the runtime?</div><br/><div id="40792331" class="c"><input type="checkbox" id="c-40792331" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#40790359">root</a><span>|</span><a href="#40791498">parent</a><span>|</span><a href="#40792355">next</a><span>|</span><label class="collapse" for="c-40792331">[-]</label><label class="expand" for="c-40792331">[1 more]</label></div><br/><div class="children"><div class="content">If they can snoop on env vars of a running pod, it can snoop on the process. A k8s secret could be a file in the pod or a env var in the process, but neither are a persistent file distributed to developers</div><br/></div></div></div></div></div></div><div id="40790858" class="c"><input type="checkbox" id="c-40790858" checked=""/><div class="controls bullet"><span class="by">pluc</span><span>|</span><a href="#40790359">root</a><span>|</span><a href="#40790521">parent</a><span>|</span><a href="#40790811">prev</a><span>|</span><a href="#40793246">next</a><span>|</span><label class="collapse" for="c-40790858">[-]</label><label class="expand" for="c-40790858">[1 more]</label></div><br/><div class="children"><div class="content">During deployment, the pipeline connects to the Vault, dumps relevant secrets in a .env file that it pushes to production systems that the application then reads from.</div><br/></div></div><div id="40793246" class="c"><input type="checkbox" id="c-40793246" checked=""/><div class="controls bullet"><span class="by">postalrat</span><span>|</span><a href="#40790359">root</a><span>|</span><a href="#40790521">parent</a><span>|</span><a href="#40790858">prev</a><span>|</span><a href="#40794173">next</a><span>|</span><label class="collapse" for="c-40793246">[-]</label><label class="expand" for="c-40793246">[1 more]</label></div><br/><div class="children"><div class="content">A script fetches values from a database then sticks them in a file. This script runs before the your application starts so the file will be there waiting.</div><br/></div></div><div id="40794173" class="c"><input type="checkbox" id="c-40794173" checked=""/><div class="controls bullet"><span class="by">hluska</span><span>|</span><a href="#40790359">root</a><span>|</span><a href="#40790521">parent</a><span>|</span><a href="#40793246">prev</a><span>|</span><a href="#40792961">next</a><span>|</span><label class="collapse" for="c-40794173">[-]</label><label class="expand" for="c-40794173">[1 more]</label></div><br/><div class="children"><div class="content">You were on the right path when you called a vault “one more layer of redirection.” A vault on its own won’t dramatically improve your security posture. Neither will a .env file.<p>Instead, they both beat the alternative (which is writing secrets and environmental config directly in the source code). And they’re both part of defending in depth.<p>Defense in depth is hard to explain to a five year old, so think of candy. You’re five and you’re obsessed with candy. If I don’t want you to eat pounds of it every single day, I’ll likely do different things to stop you.<p>1.) I’ll give you a reasonable amount of candy.<p>2.) I’ll explain that if you eat too much candy, you’ll face health consequences like tooth decay or childhood obesity.<p>3.) I’ll put the candy somewhere both out of sight and out of reach.<p>Software security is like that too. Instead of relying upon just one method, you’ll do a number of different things. On their own, few of them are really very useful. But when you combine them all together, you can end up with a reasonably secure system.<p>In the case of vaults, it’s just a slightly safer tradeoff with its own problems. We’ve already established that it’s bad to write secrets and environmental configuration info in source code. One way around that is to put secrets in a .env file but then distributing that file becomes the weak link. Maybe you Slack them around, or email them or maybe you write all the secrets on a whiteboard in your office? A vault has a lot of flaws, but it’s better than writing them on a whiteboard. In some threat models, it’s better than Slack or email.<p>It adds depth but it’s far from perfect.</div><br/></div></div></div></div></div></div><div id="40792961" class="c"><input type="checkbox" id="c-40792961" checked=""/><div class="controls bullet"><span class="by">nunez</span><span>|</span><a href="#40790359">parent</a><span>|</span><a href="#40790440">prev</a><span>|</span><a href="#40790514">next</a><span>|</span><label class="collapse" for="c-40792961">[-]</label><label class="expand" for="c-40792961">[1 more]</label></div><br/><div class="children"><div class="content">Add your actual dotenv to .gitignore. Use bfg to make sure that any traces of your dotenv aren&#x27;t in your commit history. Use detect-secrets client-side commit hook to confirm this and also monitor for secrets leakage. Use sops to encrypt your dotenv into some other file that is tracked by git. Sops can integrate with secrets management solutions (Vault, AWS KMS, etc.). Done.<p>This is mildly complicated, but the alternative is storing config in a configuration server somewhere, which comes with its own can of worms.</div><br/></div></div></div></div><div id="40790514" class="c"><input type="checkbox" id="c-40790514" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#40790359">prev</a><span>|</span><a href="#40794114">next</a><span>|</span><label class="collapse" for="c-40790514">[-]</label><label class="expand" for="c-40790514">[7 more]</label></div><br/><div class="children"><div class="content">On my phone so can’t double test, but can’t you get this by adding “export” in front of every line in your env file and then source before running command?<p>I suppose if you don’t want it to stay after execution i believe you can:<p><pre><code>    &gt; $(source .env; my command)
</code></pre>
I’m sure there is a fairly straightforward way to encrypt and decrypt a local file</div><br/><div id="40792877" class="c"><input type="checkbox" id="c-40792877" checked=""/><div class="controls bullet"><span class="by">gkfasdfasdf</span><span>|</span><a href="#40790514">parent</a><span>|</span><a href="#40790651">next</a><span>|</span><label class="collapse" for="c-40792877">[-]</label><label class="expand" for="c-40792877">[1 more]</label></div><br/><div class="children"><div class="content">If in bash, you can use the &#x27;allexport&#x27; option and source the .env without having to add &#x27;export&#x27; in front of every line:<p><pre><code>    #!&#x2F;bin&#x2F;bash
    
    set -o allexport
    . .env
    set +o allexport
    cmd</code></pre></div><br/></div></div><div id="40790651" class="c"><input type="checkbox" id="c-40790651" checked=""/><div class="controls bullet"><span class="by">newzisforsukas</span><span>|</span><a href="#40790514">parent</a><span>|</span><a href="#40792877">prev</a><span>|</span><a href="#40790610">next</a><span>|</span><label class="collapse" for="c-40790651">[-]</label><label class="expand" for="c-40790651">[1 more]</label></div><br/><div class="children"><div class="content">Being able to source the file is the main benefit of using a .env file, IMO. Otherwise, you can just use any format for config management.</div><br/></div></div><div id="40790610" class="c"><input type="checkbox" id="c-40790610" checked=""/><div class="controls bullet"><span class="by">bogdan</span><span>|</span><a href="#40790514">parent</a><span>|</span><a href="#40790651">prev</a><span>|</span><a href="#40791172">next</a><span>|</span><label class="collapse" for="c-40790610">[-]</label><label class="expand" for="c-40790610">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;getsops&#x2F;sops">https:&#x2F;&#x2F;github.com&#x2F;getsops&#x2F;sops</a></div><br/></div></div><div id="40791172" class="c"><input type="checkbox" id="c-40791172" checked=""/><div class="controls bullet"><span class="by">eternauta3k</span><span>|</span><a href="#40790514">parent</a><span>|</span><a href="#40790610">prev</a><span>|</span><a href="#40790985">next</a><span>|</span><label class="collapse" for="c-40791172">[-]</label><label class="expand" for="c-40791172">[1 more]</label></div><br/><div class="children"><div class="content">Now take that a step further with Environment Modules and you can source them from any shell or scripting language: <a href="https:&#x2F;&#x2F;modules.readthedocs.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;modules.readthedocs.io&#x2F;</a> (without creating a subinterpreter)</div><br/></div></div><div id="40790985" class="c"><input type="checkbox" id="c-40790985" checked=""/><div class="controls bullet"><span class="by">ruined</span><span>|</span><a href="#40790514">parent</a><span>|</span><a href="#40791172">prev</a><span>|</span><a href="#40794114">next</a><span>|</span><label class="collapse" for="c-40790985">[-]</label><label class="expand" for="c-40790985">[2 more]</label></div><br/><div class="children"><div class="content">dotenv has features that include conditional selection and ordered merging of env files, which are configurable by dotenv&#x27;s runtime and buildtime APIs.</div><br/><div id="40797053" class="c"><input type="checkbox" id="c-40797053" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#40790514">root</a><span>|</span><a href="#40790985">parent</a><span>|</span><a href="#40794114">next</a><span>|</span><label class="collapse" for="c-40797053">[-]</label><label class="expand" for="c-40797053">[1 more]</label></div><br/><div class="children"><div class="content">At least merging can happen by sourcing .env files in order (last to be sourced has priority)<p>But I do agree that at some point you want a tool to orchestrate these things and guide your usage so you don’t have to reinvent the same lines of code all the item</div><br/></div></div></div></div></div></div><div id="40794114" class="c"><input type="checkbox" id="c-40794114" checked=""/><div class="controls bullet"><span class="by">frithsun</span><span>|</span><a href="#40790514">prev</a><span>|</span><a href="#40791100">next</a><span>|</span><label class="collapse" for="c-40794114">[-]</label><label class="expand" for="c-40794114">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, but I would rather go with the imperfect setup that I understand than an allegedly perfect setup with dozens of third party dependencies that I don&#x27;t understand.<p>Doubly the case now that env is natively supported by node now.</div><br/></div></div><div id="40791100" class="c"><input type="checkbox" id="c-40791100" checked=""/><div class="controls bullet"><span class="by">boundlessdreamz</span><span>|</span><a href="#40794114">prev</a><span>|</span><a href="#40790360">next</a><span>|</span><label class="collapse" for="c-40791100">[-]</label><label class="expand" for="c-40791100">[4 more]</label></div><br/><div class="children"><div class="content">This is similar to how Rails handles secrets - <a href="https:&#x2F;&#x2F;edgeguides.rubyonrails.org&#x2F;security.html#environmental-security" rel="nofollow">https:&#x2F;&#x2F;edgeguides.rubyonrails.org&#x2F;security.html#environment...</a><p>In Rails, the entire file is encrypted unlike here where only the secrets are</div><br/><div id="40791216" class="c"><input type="checkbox" id="c-40791216" checked=""/><div class="controls bullet"><span class="by">vinnymac</span><span>|</span><a href="#40791100">parent</a><span>|</span><a href="#40795573">next</a><span>|</span><label class="collapse" for="c-40791216">[-]</label><label class="expand" for="c-40791216">[1 more]</label></div><br/><div class="children"><div class="content">Dotenvx used to encrypt by file. It’s a very recent design decision to encrypt by secret.</div><br/></div></div><div id="40795573" class="c"><input type="checkbox" id="c-40795573" checked=""/><div class="controls bullet"><span class="by">kevlened</span><span>|</span><a href="#40791100">parent</a><span>|</span><a href="#40791216">prev</a><span>|</span><a href="#40795241">next</a><span>|</span><label class="collapse" for="c-40795573">[-]</label><label class="expand" for="c-40795573">[1 more]</label></div><br/><div class="children"><div class="content">How do reviewers of a PR know when&#x2F;which environment variables changed?</div><br/></div></div><div id="40795241" class="c"><input type="checkbox" id="c-40795241" checked=""/><div class="controls bullet"><span class="by">kinduff</span><span>|</span><a href="#40791100">parent</a><span>|</span><a href="#40795573">prev</a><span>|</span><a href="#40790360">next</a><span>|</span><label class="collapse" for="c-40795241">[-]</label><label class="expand" for="c-40795241">[1 more]</label></div><br/><div class="children"><div class="content">I really like how its implemented in Rails</div><br/></div></div></div></div><div id="40790360" class="c"><input type="checkbox" id="c-40790360" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40791100">prev</a><span>|</span><a href="#40791679">next</a><span>|</span><label class="collapse" for="c-40790360">[-]</label><label class="expand" for="c-40790360">[8 more]</label></div><br/><div class="children"><div class="content">We’ve been pushing for committing encrypted secrets for many years now, and have written an open source spec and implementation in multiple languages: <a href="https:&#x2F;&#x2F;github.com&#x2F;neosmart&#x2F;securestore-rs">https:&#x2F;&#x2F;github.com&#x2F;neosmart&#x2F;securestore-rs</a></div><br/><div id="40791273" class="c"><input type="checkbox" id="c-40791273" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#40790360">parent</a><span>|</span><a href="#40790949">next</a><span>|</span><label class="collapse" for="c-40791273">[-]</label><label class="expand" for="c-40791273">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also sops: <a href="https:&#x2F;&#x2F;github.com&#x2F;getsops&#x2F;sops">https:&#x2F;&#x2F;github.com&#x2F;getsops&#x2F;sops</a><p>I&#x27;ve used it at two jobs now over about 5 years and have had zero issues.</div><br/><div id="40792462" class="c"><input type="checkbox" id="c-40792462" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40790360">root</a><span>|</span><a href="#40791273">parent</a><span>|</span><a href="#40790949">next</a><span>|</span><label class="collapse" for="c-40792462">[-]</label><label class="expand" for="c-40792462">[1 more]</label></div><br/><div class="children"><div class="content">Another commenter mentioned it, I&#x27;m looking at it now.<p>SecureStore was launched in 2017 (initial version was .NET only): <a href="https:&#x2F;&#x2F;neosmart.net&#x2F;blog&#x2F;securestore-a-net-secrets-manager&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neosmart.net&#x2F;blog&#x2F;securestore-a-net-secrets-manager&#x2F;</a></div><br/></div></div></div></div><div id="40790949" class="c"><input type="checkbox" id="c-40790949" checked=""/><div class="controls bullet"><span class="by">curiousdeadcat</span><span>|</span><a href="#40790360">parent</a><span>|</span><a href="#40791273">prev</a><span>|</span><a href="#40791723">next</a><span>|</span><label class="collapse" for="c-40790949">[-]</label><label class="expand" for="c-40790949">[3 more]</label></div><br/><div class="children"><div class="content">I got so excited, but it doesn&#x27;t seem to support multiple keys and seems overly eager to encourage people to leave a valuable key lying around on disk.<p>So if a single dev machine is compromised, all of your prod secrets are exposed?<p>I wish this were closer to sops with support for gpg and or ssh keys. Because sops is a great idea locked in a questionable codebase.</div><br/><div id="40792397" class="c"><input type="checkbox" id="c-40792397" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40790360">root</a><span>|</span><a href="#40790949">parent</a><span>|</span><a href="#40791723">next</a><span>|</span><label class="collapse" for="c-40792397">[-]</label><label class="expand" for="c-40792397">[2 more]</label></div><br/><div class="children"><div class="content">Happy to discuss a proposal to add asymmetric key support to the project in the GitHub issue tracker. Although I&#x27;m not sure how the security changes with an asymmetric key, as either way the worst case scenario is the same?<p>Note that you don&#x27;t have to leave the key &quot;lying around&quot; as you can secure it the same way you would an asymmetric key. And it certainly beats leaving the plaintext secrets themselves lying around in a .env file or similar.<p>EDIT:<p>I see you were saying &quot;dev machine&quot; exposes &quot;prod secrets&quot; but that&#x27;s not the case. The protocol is designed so you would have secrets.json and secrets.prod.json, encrypted with different keys and (necessarily) managed separately but with the same tools and api. Dev machines being compromised compromises dev keys, not prod keys.<p>Read the last section in the README on GitHub for more on the dev&#x2F;prod split.</div><br/><div id="40794585" class="c"><input type="checkbox" id="c-40794585" checked=""/><div class="controls bullet"><span class="by">curiousdeadcat</span><span>|</span><a href="#40790360">root</a><span>|</span><a href="#40792397">parent</a><span>|</span><a href="#40791723">next</a><span>|</span><label class="collapse" for="c-40794585">[-]</label><label class="expand" for="c-40794585">[1 more]</label></div><br/><div class="children"><div class="content">Asymmetric keys mean you can you can have per-dev or per-team keys and allow one team to rotate them and resign them for all other consumers. I don&#x27;t know how you&#x27;d do that with symmetric keys. This is an important feature of sops, imo.<p>It also means I can do things like seal them to a key that is stored in KeyVault and then allow the transparent retrieval of that key at runtime on Instances that have been given an identity with access.<p>This means that production secrets are sealed in place and only openable by effectively authenticated workloads.<p>And if you use sops-nix, this becomes a &quot;setup once and never think about it ever again, ever&quot; kind of operation.</div><br/></div></div></div></div></div></div><div id="40791723" class="c"><input type="checkbox" id="c-40791723" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#40790360">parent</a><span>|</span><a href="#40790949">prev</a><span>|</span><a href="#40791679">next</a><span>|</span><label class="collapse" for="c-40791723">[-]</label><label class="expand" for="c-40791723">[2 more]</label></div><br/><div class="children"><div class="content">I don’t get it. There’s a symmetric secrets.key that anyone could get hold of and use to overwrite secrets? No thanks.<p>And where do I keep the key? In a secret store?</div><br/><div id="40792368" class="c"><input type="checkbox" id="c-40792368" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40790360">root</a><span>|</span><a href="#40791723">parent</a><span>|</span><a href="#40791679">next</a><span>|</span><label class="collapse" for="c-40792368">[-]</label><label class="expand" for="c-40792368">[1 more]</label></div><br/><div class="children"><div class="content">You keep the key wherever you want to keep the key, just don&#x27;t commit it and don&#x27;t distribute it. Put it in on a YubiKey for your devs, upload it out-of-band securely to prod.<p>Whether it&#x27;s a symmetric key or an asymmetric key, you have the same problem. Someone overriding your secrets is definitely not high on the list of concerns, and if they&#x27;re committed to git then they can never be truly overwritten.</div><br/></div></div></div></div></div></div><div id="40791679" class="c"><input type="checkbox" id="c-40791679" checked=""/><div class="controls bullet"><span class="by">stiiv</span><span>|</span><a href="#40790360">prev</a><span>|</span><a href="#40796613">next</a><span>|</span><label class="collapse" for="c-40791679">[-]</label><label class="expand" for="c-40791679">[3 more]</label></div><br/><div class="children"><div class="content">dotenv has zero npm dependencies. dotenvx has 21, including a few I have never heard of. Is this really more secure?</div><br/><div id="40794039" class="c"><input type="checkbox" id="c-40794039" checked=""/><div class="controls bullet"><span class="by">caliwagon</span><span>|</span><a href="#40791679">parent</a><span>|</span><a href="#40792087">prev</a><span>|</span><a href="#40796613">next</a><span>|</span><label class="collapse" for="c-40794039">[-]</label><label class="expand" for="c-40794039">[1 more]</label></div><br/><div class="children"><div class="content">Recent versions of node support env files directly, so you don&#x27;t even need one dependency anymore. <a href="https:&#x2F;&#x2F;nodejs.org&#x2F;docs&#x2F;latest-v20.x&#x2F;api&#x2F;cli.html#--env-fileconfig" rel="nofollow">https:&#x2F;&#x2F;nodejs.org&#x2F;docs&#x2F;latest-v20.x&#x2F;api&#x2F;cli.html#--env-file...</a></div><br/></div></div></div></div><div id="40796613" class="c"><input type="checkbox" id="c-40796613" checked=""/><div class="controls bullet"><span class="by">skeledrew</span><span>|</span><a href="#40791679">prev</a><span>|</span><a href="#40789873">next</a><span>|</span><label class="collapse" for="c-40796613">[-]</label><label class="expand" for="c-40796613">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve recently taken a simpler approach to handling secrets in .env files. Since I use autoenv and conda venvs for everything, I persist secrets outside all projects in appropriately-named files, so including them in a .env becomes similar to `source $HOME&#x2F;.secrets&#x2F;work__aws_access`. Also makes them easier to manage across projects.</div><br/></div></div><div id="40789873" class="c"><input type="checkbox" id="c-40789873" checked=""/><div class="controls bullet"><span class="by">ashenke</span><span>|</span><a href="#40796613">prev</a><span>|</span><a href="#40795010">next</a><span>|</span><label class="collapse" for="c-40789873">[-]</label><label class="expand" for="c-40789873">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a typo in the article, if the author reads this : 
&gt; But I think we have a solution to all three today - with dotenvx. In reverse problem order<p>The URL in `dotenvx` points to <a href="https:&#x2F;&#x2F;gitub.com&#x2F;dotenvx&#x2F;dotenvx" rel="nofollow">https:&#x2F;&#x2F;gitub.com&#x2F;dotenvx&#x2F;dotenvx</a> (gitub without the h)</div><br/><div id="40791759" class="c"><input type="checkbox" id="c-40791759" checked=""/><div class="controls bullet"><span class="by">ssahoo</span><span>|</span><a href="#40789873">parent</a><span>|</span><a href="#40795010">next</a><span>|</span><label class="collapse" for="c-40791759">[-]</label><label class="expand" for="c-40791759">[1 more]</label></div><br/><div class="children"><div class="content">Hey this link is malicious. It redirects to location: <a href="http:&#x2F;&#x2F;ww99.gitub.com&#x2F;dotenvx&#x2F;dotenvx" rel="nofollow">http:&#x2F;&#x2F;ww99.gitub.com&#x2F;dotenvx&#x2F;dotenvx</a> and then some site blocked by ublock</div><br/></div></div></div></div><div id="40795010" class="c"><input type="checkbox" id="c-40795010" checked=""/><div class="controls bullet"><span class="by">drchickensalad</span><span>|</span><a href="#40789873">prev</a><span>|</span><a href="#40790151">next</a><span>|</span><label class="collapse" for="c-40795010">[-]</label><label class="expand" for="c-40795010">[1 more]</label></div><br/><div class="children"><div class="content">Your &quot;a single gitignore append&quot; command overwrites existing .gitignore files.  It should be `&gt;&gt;`</div><br/></div></div><div id="40790151" class="c"><input type="checkbox" id="c-40790151" checked=""/><div class="controls bullet"><span class="by">hermanradtke</span><span>|</span><a href="#40795010">prev</a><span>|</span><a href="#40790134">next</a><span>|</span><label class="collapse" for="c-40790151">[-]</label><label class="expand" for="c-40790151">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been using dotenv-cli for a long time now. I appreciate the encryption, but I will keep loading secrets from a vault instead.</div><br/></div></div><div id="40790134" class="c"><input type="checkbox" id="c-40790134" checked=""/><div class="controls bullet"><span class="by">bluelightning2k</span><span>|</span><a href="#40790151">prev</a><span>|</span><a href="#40796555">next</a><span>|</span><label class="collapse" for="c-40790134">[-]</label><label class="expand" for="c-40790134">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really understand why this is a new project. Seems it would have been pretty simple to add these in a backwards compatible way.<p>It would only break in cases where people&#x27;s values specifically started with &quot;encrypted:&quot;</div><br/><div id="40791202" class="c"><input type="checkbox" id="c-40791202" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#40790134">parent</a><span>|</span><a href="#40790741">next</a><span>|</span><label class="collapse" for="c-40791202">[-]</label><label class="expand" for="c-40791202">[1 more]</label></div><br/><div class="children"><div class="content">Even without backwards compatibility, why not just a breaking change in the same project? Don&#x27;t get it either.<p>I&#x27;ve never used it (knowingly) but if I did and wanted to use this new version&#x2F;project even the CLI name change to append &#x27;x&#x27; would be annoying (I&#x27;d probably alias &#x2F;symlink it).</div><br/></div></div><div id="40790741" class="c"><input type="checkbox" id="c-40790741" checked=""/><div class="controls bullet"><span class="by">daralthus</span><span>|</span><a href="#40790134">parent</a><span>|</span><a href="#40791202">prev</a><span>|</span><a href="#40791255">next</a><span>|</span><label class="collapse" for="c-40790741">[-]</label><label class="expand" for="c-40790741">[2 more]</label></div><br/><div class="children"><div class="content">It was added in a backwards compatible way, but the author decided to make a breaking change with this release.<p>The previous (IMHO superior) version was generating a .env.vault and a .env.keys from a .env file. Leaving the .env plain text and .env.vault encrypted.</div><br/><div id="40791469" class="c"><input type="checkbox" id="c-40791469" checked=""/><div class="controls bullet"><span class="by">bluelightning2k</span><span>|</span><a href="#40790134">root</a><span>|</span><a href="#40790741">parent</a><span>|</span><a href="#40791255">next</a><span>|</span><label class="collapse" for="c-40791469">[-]</label><label class="expand" for="c-40791469">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the simple idea is to start a company. Nothing wrong with that. It&#x27;s definitely what I would do. First envx then &quot;envx vault&quot;</div><br/></div></div></div></div><div id="40791255" class="c"><input type="checkbox" id="c-40791255" checked=""/><div class="controls bullet"><span class="by">triyambakam</span><span>|</span><a href="#40790134">parent</a><span>|</span><a href="#40790741">prev</a><span>|</span><a href="#40796555">next</a><span>|</span><label class="collapse" for="c-40791255">[-]</label><label class="expand" for="c-40791255">[1 more]</label></div><br/><div class="children"><div class="content">Whether good or bad, it&#x27;s marketing</div><br/></div></div></div></div><div id="40796555" class="c"><input type="checkbox" id="c-40796555" checked=""/><div class="controls bullet"><span class="by">sampli</span><span>|</span><a href="#40790134">prev</a><span>|</span><a href="#40789853">next</a><span>|</span><label class="collapse" for="c-40796555">[-]</label><label class="expand" for="c-40796555">[1 more]</label></div><br/><div class="children"><div class="content">Based on my skim, this doesn’t really solve anything? The private key to decrypt is still stored on machine in a similar place? All this is doing is obfuscating?</div><br/></div></div><div id="40789853" class="c"><input type="checkbox" id="c-40789853" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#40796555">prev</a><span>|</span><a href="#40792659">next</a><span>|</span><label class="collapse" for="c-40789853">[-]</label><label class="expand" for="c-40789853">[12 more]</label></div><br/><div class="children"><div class="content">Secrets in env vars in production is not too secure either, ideally you’ll move to your app pulling secrets in-process from your infrastructure at boot-up or upon use. This also gives a nice advantage of not needing to rebuild the app or container or whatever to rotate a secret.</div><br/><div id="40789912" class="c"><input type="checkbox" id="c-40789912" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#40789853">parent</a><span>|</span><a href="#40792659">next</a><span>|</span><label class="collapse" for="c-40789912">[-]</label><label class="expand" for="c-40789912">[11 more]</label></div><br/><div class="children"><div class="content">This just moves the problem to a different step. How are you going to manage access to said secrets, especially when your application lives off premises?</div><br/><div id="40790047" class="c"><input type="checkbox" id="c-40790047" checked=""/><div class="controls bullet"><span class="by">nevir</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40789912">parent</a><span>|</span><a href="#40790164">next</a><span>|</span><label class="collapse" for="c-40790047">[-]</label><label class="expand" for="c-40790047">[5 more]</label></div><br/><div class="children"><div class="content">Many hosting environments give you this.<p>For example AWS gives you multiple ways of injecting secrets as env vars into your containers when they boot up (ECS + secrets manager, EKS, etc)</div><br/><div id="40790397" class="c"><input type="checkbox" id="c-40790397" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40790047">parent</a><span>|</span><a href="#40790164">next</a><span>|</span><label class="collapse" for="c-40790397">[-]</label><label class="expand" for="c-40790397">[4 more]</label></div><br/><div class="children"><div class="content">This is still “env vars”, easy to read from &#x2F;proc&#x2F;*&#x2F;env too see the decrypted secrets from a different process. Versus in-process only secret fetch where you’d need to scan the memory pages of the app, which is a bit harder - especially if you keep the credentials in memory in a scrambled format so a simple scan on process memory for “secret_prefix_” doesn’t find  them.</div><br/><div id="40790898" class="c"><input type="checkbox" id="c-40790898" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40790397">parent</a><span>|</span><a href="#40790164">next</a><span>|</span><label class="collapse" for="c-40790898">[-]</label><label class="expand" for="c-40790898">[3 more]</label></div><br/><div class="children"><div class="content">If an attacker can read other processes&#x27; envs you&#x27;ve pretty much lost as they&#x27;re<p>1. Inside your process which means they can see the decrypted values.<p>2. Root which means they can get into your process to see the decrypted values.<p>I&#x27;m not sure if your average dev has a threat model that assumes in memory scrambling let alone leaked env vars. After all we&#x27;re talking about the standard way to do it being populating a file with the decrypted secrets and just leaving it there. All the security is already kernel security.<p>I&#x27;m honestly not sure who dotenvx is aimed at.<p>- No one security conscious is going to be cool just making the cyphertext available publicly or even internally.<p>- Someone scrambling in-memory secrets isn&#x27;t using dotenv to begin with, is using SecretsManager and the like, and probably doesn&#x27;t want to change those to now go through the filesystem. You now get less auditing because all those secrets are bundled and you now only know &quot;they accessed the decryption key.&quot;<p>- And someone using dotenv for secrets doesn&#x27;t have a threat-model where this meaningfully improves security.</div><br/><div id="40791343" class="c"><input type="checkbox" id="c-40791343" checked=""/><div class="controls bullet"><span class="by">aforwardslash</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40790898">parent</a><span>|</span><a href="#40791684">next</a><span>|</span><label class="collapse" for="c-40791343">[-]</label><label class="expand" for="c-40791343">[1 more]</label></div><br/><div class="children"><div class="content">In adittion, if I&#x27;m not mistaken, child processes inherit the parent env vars, so if your application forks or use subcommands, you may be exposing the whole environment trove to 3rd party scripts, no root needed. Also, most vulnerabilities that enables execution of code will happily leak the env vars, no root access or &quot;being inside the process&quot; thingy (I know, code execution is technically &quot;inside the process&quot;, but without requiring privileged levels)</div><br/></div></div><div id="40791684" class="c"><input type="checkbox" id="c-40791684" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40790898">parent</a><span>|</span><a href="#40791343">prev</a><span>|</span><a href="#40790164">next</a><span>|</span><label class="collapse" for="c-40791684">[-]</label><label class="expand" for="c-40791684">[1 more]</label></div><br/><div class="children"><div class="content">I’m advocating people use something like SecretsManager, not this thing. In-memory only &gt; env vars &gt; secret files on disk.<p>I find env vars very precarious because harmless developer debug logging, actions like sshing into a container and typing `env` etc can easily expose them.<p>File on disk can be read by an attacker with via subdirectory path traversal bug<p>It’s much less likely for in process only secrets to be exposed by common mistakes&#x2F;bugs</div><br/></div></div></div></div></div></div></div></div><div id="40790164" class="c"><input type="checkbox" id="c-40790164" checked=""/><div class="controls bullet"><span class="by">bluelightning2k</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40789912">parent</a><span>|</span><a href="#40790047">prev</a><span>|</span><a href="#40790313">next</a><span>|</span><label class="collapse" for="c-40790164">[-]</label><label class="expand" for="c-40790164">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wondered this. Seems like a password to get more passwords is potentially actually less secure (as in practice people will reuse master keys and they might actually increase the surface area, or make it a persistent threat after the keys themselves rotate)</div><br/><div id="40790569" class="c"><input type="checkbox" id="c-40790569" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40790164">parent</a><span>|</span><a href="#40790313">next</a><span>|</span><label class="collapse" for="c-40790569">[-]</label><label class="expand" for="c-40790569">[2 more]</label></div><br/><div class="children"><div class="content">In AWS and other clouds, you application can use an infrastructure provider API to create a secure session to access infrastructure APIs with per-application-instance credentials that are automatically rotated and can be used only by that instance.  These APIs are how the cloud provider themselves provides environment variable injection features, but if your application consumes these APIs directly you can avoid having decrypted secrets hanging out in environment variables as a middleman between your app and the cloud runtime.<p>Typically the application instance sessions are automatically rotated very frequently, AWS’s sessions are limited to 6 hours for example.</div><br/><div id="40791298" class="c"><input type="checkbox" id="c-40791298" checked=""/><div class="controls bullet"><span class="by">vinnymac</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40790569">parent</a><span>|</span><a href="#40790313">next</a><span>|</span><label class="collapse" for="c-40791298">[-]</label><label class="expand" for="c-40791298">[1 more]</label></div><br/><div class="children"><div class="content">Dotenvx has a cloud hub from which the keys can be pulled. I imagine an eventual feature will be for the keys to expire, and you’ll have to re-authenticate with the cloud to get new credentials, just as you would with AWS.</div><br/></div></div></div></div></div></div><div id="40790313" class="c"><input type="checkbox" id="c-40790313" checked=""/><div class="controls bullet"><span class="by">smallerfish</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40789912">parent</a><span>|</span><a href="#40790164">prev</a><span>|</span><a href="#40790141">next</a><span>|</span><label class="collapse" for="c-40790313">[-]</label><label class="expand" for="c-40790313">[1 more]</label></div><br/><div class="children"><div class="content">Doppler is very nice, although it gets expensive at the middle tier, which is needed to separate by role.</div><br/></div></div><div id="40790141" class="c"><input type="checkbox" id="c-40790141" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#40789853">root</a><span>|</span><a href="#40789912">parent</a><span>|</span><a href="#40790313">prev</a><span>|</span><a href="#40792659">next</a><span>|</span><label class="collapse" for="c-40790141">[-]</label><label class="expand" for="c-40790141">[1 more]</label></div><br/><div class="children"><div class="content">Yeah but it seems like the right step — deployment, not implementation. All my secrets are managed by GitLab AFAIR, but in general I feel way better integrating secrets into each service&#x2F;container (I happen to use Dokku, so it’s as simple as something like `dokku add_secret APPNAME SECRET`) than having a central system.<p>I am far too clumsy to trust myself to push secrets in encrypted form, personally</div><br/></div></div></div></div></div></div><div id="40792659" class="c"><input type="checkbox" id="c-40792659" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#40789853">prev</a><span>|</span><a href="#40792112">next</a><span>|</span><label class="collapse" for="c-40792659">[-]</label><label class="expand" for="c-40792659">[1 more]</label></div><br/><div class="children"><div class="content">Since node v20.06, has built in support for --env-file=.env on load... as for local(ish) encryption and pushing them into source control, I don&#x27;t like this at all.  I&#x27;m fine using a vault or secret distribution from either the environment host (k8s) or ci&#x2F;cd deployment.<p>I do like to keep a .env.example that you can rename to .env and adjust as desired.  I tend to have defaults for running a compose stack locally that close to &quot;just works&quot; as possible.<p>I doubt I&#x27;d ever want to use this in practice.</div><br/></div></div><div id="40792112" class="c"><input type="checkbox" id="c-40792112" checked=""/><div class="controls bullet"><span class="by">nimishk</span><span>|</span><a href="#40792659">prev</a><span>|</span><a href="#40797472">next</a><span>|</span><label class="collapse" for="c-40792112">[-]</label><label class="expand" for="c-40792112">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is the best approach. I am building <a href="https:&#x2F;&#x2F;phase.dev" rel="nofollow">https:&#x2F;&#x2F;phase.dev</a> which lets you import secrets (.env), encrypt secrets (end-to-end encrypted with keys you control), sync them to other services&#x2F;platforms (think AWS, GitHub, Kubernetes), and inject them into applications at runtime (e.g., phase run node index.js).<p>Source: <a href="https:&#x2F;&#x2F;github.com&#x2F;phasehq&#x2F;console">https:&#x2F;&#x2F;github.com&#x2F;phasehq&#x2F;console</a></div><br/><div id="40793082" class="c"><input type="checkbox" id="c-40793082" checked=""/><div class="controls bullet"><span class="by">poopsmithe</span><span>|</span><a href="#40792112">parent</a><span>|</span><a href="#40797472">next</a><span>|</span><label class="collapse" for="c-40793082">[-]</label><label class="expand" for="c-40793082">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean it&#x27;s not the best approach? That&#x27;s a little light on the details.</div><br/></div></div></div></div><div id="40797472" class="c"><input type="checkbox" id="c-40797472" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#40792112">prev</a><span>|</span><a href="#40795279">next</a><span>|</span><label class="collapse" for="c-40797472">[-]</label><label class="expand" for="c-40797472">[1 more]</label></div><br/><div class="children"><div class="content">This seems to encourage committing encrypted secrets, which is a bad idea.  Configuration and code should be in separate repositories.  Secrets should be protected elsewhere.<p>The correct fix for “it’s too easy to accidentally commit .env files with secrets” is to not function (panic&#x2F;throw) if there isn’t a suitable .gitignore&#x2F;.dockerignore, not a specialized cryptosystem for .env files.  This just creates a different problem.<p>I simply use an envdir outside of the project and update all my run scripts to use “envdir $CONFIG_PATH &lt;whatever&gt;”.  Simpler and safer.</div><br/></div></div><div id="40795279" class="c"><input type="checkbox" id="c-40795279" checked=""/><div class="controls bullet"><span class="by">blacksoil</span><span>|</span><a href="#40797472">prev</a><span>|</span><a href="#40790522">next</a><span>|</span><label class="collapse" for="c-40795279">[-]</label><label class="expand" for="c-40795279">[2 more]</label></div><br/><div class="children"><div class="content">Can someone help enlightening me. In terms of preventing leaks, since we still need to ensure that the .env.keys doesn&#x27;t leak, wouldn&#x27;t effort still be the same?<p>The ability to use arbitrary filename for.env is quite nice though!</div><br/><div id="40795385" class="c"><input type="checkbox" id="c-40795385" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#40795279">parent</a><span>|</span><a href="#40790522">next</a><span>|</span><label class="collapse" for="c-40795385">[-]</label><label class="expand" for="c-40795385">[1 more]</label></div><br/><div class="children"><div class="content">The idea is that the private key is stored outside of your configuration directory (e.g. in your OS&#x27;s keychain), so your dotenv file can contain encrypted key values without leaking the value itself.</div><br/></div></div></div></div><div id="40790522" class="c"><input type="checkbox" id="c-40790522" checked=""/><div class="controls bullet"><span class="by">bradgessler</span><span>|</span><a href="#40795279">prev</a><span>|</span><a href="#40795280">next</a><span>|</span><label class="collapse" for="c-40790522">[-]</label><label class="expand" for="c-40790522">[1 more]</label></div><br/><div class="children"><div class="content">I really wish 1Password would ship an environment manager for their op CLI.</div><br/></div></div><div id="40795280" class="c"><input type="checkbox" id="c-40795280" checked=""/><div class="controls bullet"><span class="by">kodeninja</span><span>|</span><a href="#40790522">prev</a><span>|</span><label class="collapse" for="c-40795280">[-]</label><label class="expand" for="c-40795280">[1 more]</label></div><br/><div class="children"><div class="content">How would this work with application-specific Intellij Run&#x2F;Debug configurations? Would this require switching to a &quot;Shell Script&quot; configuration, thereby losing debugging capability etc?</div><br/></div></div></div></div></div></div></div></body></html>