<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684227658934" as="style"/><link rel="stylesheet" href="styles.css?v=1684227658934"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events">Server-sent events</a>Â <span class="domain">(<a href="https://developer.mozilla.org">developer.mozilla.org</a>)</span></div><div class="subtext"><span>corentin88</span> | <span>86 comments</span></div><br/><div><div id="35953359" class="c"><input type="checkbox" id="c-35953359" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#35959000">next</a><span>|</span><label class="collapse" for="c-35953359">[-]</label><label class="expand" for="c-35953359">[26 more]</label></div><br/><div class="children"><div class="content">I know alot of websites and engineers use Websocket for <i>push only</i> data. SSE is tailored made for real time one sided updates!<p>In fact, I think it made a better chat protocol, when we built a chat system at a previous job, similar to Slack. We ended up leveraging SSE to push updates to channels and traditional HTTP requests to send data to the server, resulting in lower latency and less overhead on the server side. We did this because we found the following to be true:<p>- At any given time, there are far more people reading chat messages than writing them<p>- What matters is that updates after being sent to everyone else is that their pretty close to instantaneous but you had a 500ms window to allow for the server to receive a new message and then propagate it out. Therefore, for the sender, you update the UI optimistically so they aren&#x27;t waiting for a response, and everyone else will get it in ~500ms and its imperceptible<p>- one downside: its harder (we never figured it out before I left) to do indicators for when someone is typing. That really does seem to require two way real time connections</div><br/><div id="35953830" class="c"><input type="checkbox" id="c-35953830" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#35953359">parent</a><span>|</span><a href="#35958765">next</a><span>|</span><label class="collapse" for="c-35953830">[-]</label><label class="expand" for="c-35953830">[8 more]</label></div><br/><div class="children"><div class="content">The big problem i&#x27;ve run into with SSE is the connection limit [1]:<p>&gt; Warning: When not used over HTTP&#x2F;2, SSE suffers from a limitation to the maximum number of open connections, which can be specially painful when opening various tabs as the limit is per browser and set to a very low number (6). The issue has been marked as &quot;Won&#x27;t fix&quot; in Chrome and Firefox. This limit is per browser + domain, so that means that you can open 6 SSE connections across all of the tabs to www.example1.com and another 6 SSE connections to www.example2.com. (from Stackoverflow). When using HTTP&#x2F;2, the maximum number of simultaneous HTTP streams is negotiated between the server and the client (defaults to 100).<p>The natural way to use SSE is to create an EventSource on each page. If you do this, and your user opens six tabs, they can now no longer make HTTP requests to your site. Not just SSE requests, any HTTP requests at all!<p>It&#x27;s also quite natural, i think, to want to use multiple separate streams. It&#x27;s very convenient to write separate endpoints for various kinds of data that a page might want, for example one for streaming numerical data, one for control messages, and one for descriptive events; or one for each panel on a dashboard. Here, you can hit the limit on a single page.<p>I wrote a thin layer over my HTTP server&#x27;s APIs which lets me write a single handler which can send events via either SSE or a websocket. Then, when i build a page, i use websockets, but if i want to debug, i can still use curl to make a normal HTTP request. Also, other apps can use SSE to pull data, which only requires an HTTP client, not a websocket client.<p>[1] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;EventSource" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;EventSource</a></div><br/><div id="35958319" class="c"><input type="checkbox" id="c-35958319" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953830">parent</a><span>|</span><a href="#35958714">next</a><span>|</span><label class="collapse" for="c-35958319">[-]</label><label class="expand" for="c-35958319">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The natural way to use SSE is to create an EventSource on each page. If you do this, and your user opens six tabs, they can now no longer make HTTP requests to your site. Not just SSE requests, any HTTP requests at all!<p>You can use EventSource in a singleton worker and use postMessage to forward messages to all open browser tabs for the same origin.</div><br/><div id="35958974" class="c"><input type="checkbox" id="c-35958974" checked=""/><div class="controls bullet"><span class="by">tehbeard</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35958319">parent</a><span>|</span><a href="#35958697">next</a><span>|</span><label class="collapse" for="c-35958974">[-]</label><label class="expand" for="c-35958974">[1 more]</label></div><br/><div class="children"><div class="content">SharedWorker (the thing needed for a &quot;singleton worker&quot;) only just made it into Safari the end of last year...<p>plus you now have to handle multiplexing and demultiplexing for different tabs on both server and client.<p>By the time that arrived and HTTP&#x2F;2 had wide enough adoption, everyone&#x27;s already used to building atop Websocket...<p>Also the EventSource in the browser is heavily gimped. GET only, No custom headers, and last I checked you can forget about configuring any CORS stuff for credential passing.</div><br/></div></div><div id="35958697" class="c"><input type="checkbox" id="c-35958697" checked=""/><div class="controls bullet"><span class="by">ranguna</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35958319">parent</a><span>|</span><a href="#35958974">prev</a><span>|</span><a href="#35958714">next</a><span>|</span><label class="collapse" for="c-35958697">[-]</label><label class="expand" for="c-35958697">[1 more]</label></div><br/><div class="children"><div class="content">The original comment stands: it&#x27;s harder.</div><br/></div></div></div></div><div id="35958235" class="c"><input type="checkbox" id="c-35958235" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953830">parent</a><span>|</span><a href="#35958714">prev</a><span>|</span><a href="#35958415">next</a><span>|</span><label class="collapse" for="c-35958235">[-]</label><label class="expand" for="c-35958235">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s also quite natural, i think, to want to use multiple separate streams.<p>i dont think i&#x27;d call it natural per se - i&#x27;d say it&#x27;s just &quot;easy&quot; to do so, and especially if each of these separate streams are managed by different teams, and it makes business sense to separate the responsibility.<p>There should be a framework, perhaps, to allow &quot;multiplexing&quot; of multiple streams of events into one actual tcp connection. Of course, this requires some work, but i dont think it&#x27;s actually that much extra work. It just needed to be planned out as a need, as it might be a tad hard to tack it on after the fact (tho that&#x27;s not impossible either).</div><br/></div></div><div id="35958415" class="c"><input type="checkbox" id="c-35958415" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953830">parent</a><span>|</span><a href="#35958235">prev</a><span>|</span><a href="#35958765">next</a><span>|</span><label class="collapse" for="c-35958415">[-]</label><label class="expand" for="c-35958415">[1 more]</label></div><br/><div class="children"><div class="content">Just create more subdomains if you really need more sockets.<p>Or move away from the browser. Browsers are toxic now.</div><br/></div></div></div></div><div id="35958765" class="c"><input type="checkbox" id="c-35958765" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#35953359">parent</a><span>|</span><a href="#35953830">prev</a><span>|</span><a href="#35953568">next</a><span>|</span><label class="collapse" for="c-35958765">[-]</label><label class="expand" for="c-35958765">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I understand. Both WebSockets and server-sent events are just a long lived TCP socket, right? Why would SSE be lower overhead? Why wouldn&#x27;t it be more overhead to go through the whole HTTP request handling machinery for EVRY chat message everyone sends? You already have an underlying 2-way connection in the TCP socket, why not use it?<p>And why would latency be lower with HTTP requests + SSE than with websockets?</div><br/></div></div><div id="35953568" class="c"><input type="checkbox" id="c-35953568" checked=""/><div class="controls bullet"><span class="by">franky47</span><span>|</span><a href="#35953359">parent</a><span>|</span><a href="#35958765">prev</a><span>|</span><a href="#35953705">next</a><span>|</span><label class="collapse" for="c-35953568">[-]</label><label class="expand" for="c-35953568">[5 more]</label></div><br/><div class="children"><div class="content">One major issue I encountered with SSE is dealing with reconnection. WebSocket makes it very easy to detect differences between a loss of network connectivity, a server dying, and a client exiting properly (eg: closing the tab), on either side of the socket.<p>Maybe there are facilities to do so with SSE that I don&#x27;t know of, but my experience in reliable server-to-client-only comms with it has been a bit rough.</div><br/><div id="35954054" class="c"><input type="checkbox" id="c-35954054" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953568">parent</a><span>|</span><a href="#35953705">next</a><span>|</span><label class="collapse" for="c-35954054">[-]</label><label class="expand" for="c-35954054">[4 more]</label></div><br/><div class="children"><div class="content">You pretty much just have to listen for and handle premature closing of the underlying TCP connection.  It&#x27;s the only form of dead peer detection you&#x27;ll get if someone just abrubtly closes their browser tab.</div><br/><div id="35954295" class="c"><input type="checkbox" id="c-35954295" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35954054">parent</a><span>|</span><a href="#35953705">next</a><span>|</span><label class="collapse" for="c-35954295">[-]</label><label class="expand" for="c-35954295">[3 more]</label></div><br/><div class="children"><div class="content">Do server frameworks really require you to think of the TCP connection?</div><br/><div id="35958333" class="c"><input type="checkbox" id="c-35958333" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35954295">parent</a><span>|</span><a href="#35956692">next</a><span>|</span><label class="collapse" for="c-35958333">[-]</label><label class="expand" for="c-35958333">[1 more]</label></div><br/><div class="children"><div class="content">Not TCP specifically, but ASP.NET Core binds your controller&#x2F;action methods&#x27; CancellationToken parameter (if present) to HttpContext.RequestAborted - so assuming one uses it correctly (e.g. tying it to things like SQL TRANSACTION&#x2F;ROLLBACK) then that helps prevent inadvertent changes if the user clicked their browser&#x27;s Stop button after a POST, or gracefully handle long file upload failures, and so on.</div><br/></div></div><div id="35956692" class="c"><input type="checkbox" id="c-35956692" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35954295">parent</a><span>|</span><a href="#35958333">prev</a><span>|</span><a href="#35953705">next</a><span>|</span><label class="collapse" for="c-35956692">[-]</label><label class="expand" for="c-35956692">[1 more]</label></div><br/><div class="children"><div class="content">High performance servers and frameworks will always have to think about the underlying sockets</div><br/></div></div></div></div></div></div></div></div><div id="35953705" class="c"><input type="checkbox" id="c-35953705" checked=""/><div class="controls bullet"><span class="by">stevenguh</span><span>|</span><a href="#35953359">parent</a><span>|</span><a href="#35953568">prev</a><span>|</span><a href="#35953641">next</a><span>|</span><label class="collapse" for="c-35953705">[-]</label><label class="expand" for="c-35953705">[1 more]</label></div><br/><div class="children"><div class="content">Slack does use websocket for âsomeone is typingâ event: <a href="https:&#x2F;&#x2F;slack.engineering&#x2F;real-time-messaging&#x2F;" rel="nofollow">https:&#x2F;&#x2F;slack.engineering&#x2F;real-time-messaging&#x2F;</a></div><br/></div></div><div id="35953641" class="c"><input type="checkbox" id="c-35953641" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#35953359">parent</a><span>|</span><a href="#35953705">prev</a><span>|</span><a href="#35953570">next</a><span>|</span><label class="collapse" for="c-35953641">[-]</label><label class="expand" for="c-35953641">[3 more]</label></div><br/><div class="children"><div class="content">I used both WebSockets and SSE. In one project, I even support WebSockets and a fallback working like what you describe.<p>I&#x27;m sold on using SSE for pushed updates. But how is regular requests + SSE easier on the server compared to WebSockets? It seems like an open connection to maintain in both cases plus additional http request for the SSE+requests case.</div><br/><div id="35958511" class="c"><input type="checkbox" id="c-35958511" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953641">parent</a><span>|</span><a href="#35953570">next</a><span>|</span><label class="collapse" for="c-35958511">[-]</label><label class="expand" for="c-35958511">[2 more]</label></div><br/><div class="children"><div class="content">You need to multi-thread your server on shared memory to build many-to-many solutions. The simplest way to get that working is Java + NIO with concurrent package, I have done it for you: <a href="http:&#x2F;&#x2F;github.com&#x2F;tinspin&#x2F;rupy">http:&#x2F;&#x2F;github.com&#x2F;tinspin&#x2F;rupy</a><p>My web server outperforms everything on the planet for multiplayer.<p>Websockets are notoriously hard to parallelize if you want shared memory which you need for many-to-many, mostly because JavaScript and C++ have very poor atomic concurrency, or atleast I never found any Websocket server that could do it.</div><br/><div id="35959183" class="c"><input type="checkbox" id="c-35959183" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35958511">parent</a><span>|</span><a href="#35953570">next</a><span>|</span><label class="collapse" for="c-35959183">[-]</label><label class="expand" for="c-35959183">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You need to multi-thread your server on shared memory to build many-to-many solutions<p>Not necessarily, it depends on the needs, but in any case I would not expect SSE and WebSockets to be different in this regard.<p>I&#x27;m not sure what&#x27;s specifically hard to parallelize with WebSockets. Shared memory may be hard to handle but that does not seem specific to WebSockets which are just regular two way communication channels that happen to start with an HTTP request from the client.</div><br/></div></div></div></div></div></div><div id="35953570" class="c"><input type="checkbox" id="c-35953570" checked=""/><div class="controls bullet"><span class="by">marcellus23</span><span>|</span><a href="#35953359">parent</a><span>|</span><a href="#35953641">prev</a><span>|</span><a href="#35959000">next</a><span>|</span><label class="collapse" for="c-35953570">[-]</label><label class="expand" for="c-35953570">[7 more]</label></div><br/><div class="children"><div class="content">What was the challenge in typing indicators? My naive idea is that it&#x27;s basically sending `typing_started` and `typing_ended` messages.</div><br/><div id="35953737" class="c"><input type="checkbox" id="c-35953737" checked=""/><div class="controls bullet"><span class="by">yamtaddle</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953570">parent</a><span>|</span><a href="#35953625">next</a><span>|</span><label class="collapse" for="c-35953737">[-]</label><label class="expand" for="c-35953737">[4 more]</label></div><br/><div class="children"><div class="content">You can skip the &quot;typing ended&quot;. You&#x27;re gonna need a shortish timeout anyway, may as well just let the &quot;typing is happening&quot; messages <i>all</i> terminate by timeout.</div><br/><div id="35954491" class="c"><input type="checkbox" id="c-35954491" checked=""/><div class="controls bullet"><span class="by">marcellus23</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953737">parent</a><span>|</span><a href="#35953625">next</a><span>|</span><label class="collapse" for="c-35954491">[-]</label><label class="expand" for="c-35954491">[3 more]</label></div><br/><div class="children"><div class="content">That really depends on the UX you want.</div><br/><div id="35954589" class="c"><input type="checkbox" id="c-35954589" checked=""/><div class="controls bullet"><span class="by">yamtaddle</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35954491">parent</a><span>|</span><a href="#35953625">next</a><span>|</span><label class="collapse" for="c-35954589">[-]</label><label class="expand" for="c-35954589">[2 more]</label></div><br/><div class="children"><div class="content">What do you have in mind? I can&#x27;t think of a case where you&#x27;d want &quot;X is typing&quot; to persist more than a second or <i>maybe</i> two past the last-received message that affirmed X is, in fact, still typing. I can think of cases in which a short timeout might break down in bad ways (making the notice really jittery on high-latency connections, say) but I think those are probably just situations in which any &quot;... is typing&quot; message is simply gonna be bad in one way or another.</div><br/><div id="35958995" class="c"><input type="checkbox" id="c-35958995" checked=""/><div class="controls bullet"><span class="by">Kiro</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35954589">parent</a><span>|</span><a href="#35953625">next</a><span>|</span><label class="collapse" for="c-35958995">[-]</label><label class="expand" for="c-35958995">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t want to clear it after only a second. It should persist much longer since people pause and think between words.<p>It&#x27;s common that someone starts typing but immediately change their mind and clears the input after only a couple of characters. So if the timeout is longer you need an &quot;ended&quot; event.</div><br/></div></div></div></div></div></div></div></div><div id="35953625" class="c"><input type="checkbox" id="c-35953625" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953570">parent</a><span>|</span><a href="#35953737">prev</a><span>|</span><a href="#35959000">next</a><span>|</span><label class="collapse" for="c-35953625">[-]</label><label class="expand" for="c-35953625">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing that since it&#x27;s not a full-duplex connection you have to send those messages out-of-band, ie, with a separate POST request API</div><br/><div id="35953807" class="c"><input type="checkbox" id="c-35953807" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#35953359">root</a><span>|</span><a href="#35953625">parent</a><span>|</span><a href="#35959000">next</a><span>|</span><label class="collapse" for="c-35953807">[-]</label><label class="expand" for="c-35953807">[1 more]</label></div><br/><div class="children"><div class="content">But messages themselves are already sent out-of-band as a POST request, if I understand correctly. Don&#x27;t see why that couldn&#x27;t be extended to include typing indicators.</div><br/></div></div></div></div></div></div></div></div><div id="35959000" class="c"><input type="checkbox" id="c-35959000" checked=""/><div class="controls bullet"><span class="by">bkyan</span><span>|</span><a href="#35953359">prev</a><span>|</span><a href="#35953744">next</a><span>|</span><label class="collapse" for="c-35959000">[-]</label><label class="expand" for="c-35959000">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a little confused by how this is used.  The trivial example provided on developer.mozilla.org is a PHP script that&#x27;s fully self-contained.  As far as I could tell, a self-contained PHP script doesn&#x27;t provide much value.  I would have expected something to happen on the server, like a database record getting updated, which triggers the PHP to send an SSE message to the browser, but how do you trigger that particular PHP instance to send a message?  Does the PHP instance just poll the database on a periodic basis?  That doesn&#x27;t seem much better than having the browser poll the web server on a periodic basis...</div><br/><div id="35959088" class="c"><input type="checkbox" id="c-35959088" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#35959000">parent</a><span>|</span><a href="#35959061">next</a><span>|</span><label class="collapse" for="c-35959088">[-]</label><label class="expand" for="c-35959088">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That doesn&#x27;t seem much better than having the browser poll the web server on a periodic basis...<p>It could indeed be much better for performance. It means the polling happens over a (presumably) low-latency, high-throughput local datacenter connection, and not over the end-user&#x27;s internet connection over which you have no control.<p>But more importantly, SSE only defines the interface between the web browser and web server. Rather than polling a DB, you could just as well hook the web server up to a more sophisticated pubsub system (although PHP might not be the best choice for that). In that regard, SSE is no different from websockets; the main difference is that it&#x27;s a simpler protocol to implement, and only works one-way.</div><br/></div></div><div id="35959061" class="c"><input type="checkbox" id="c-35959061" checked=""/><div class="controls bullet"><span class="by">roblabla</span><span>|</span><a href="#35959000">parent</a><span>|</span><a href="#35959088">prev</a><span>|</span><a href="#35953744">next</a><span>|</span><label class="collapse" for="c-35959061">[-]</label><label class="expand" for="c-35959061">[1 more]</label></div><br/><div class="children"><div class="content">You could have some kind of event system running that pushes the event down to php. For instance, redis has a PUBSUB system, and postgresql has NOTIFY.</div><br/></div></div></div></div><div id="35953744" class="c"><input type="checkbox" id="c-35953744" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#35959000">prev</a><span>|</span><a href="#35953677">next</a><span>|</span><label class="collapse" for="c-35953744">[-]</label><label class="expand" for="c-35953744">[16 more]</label></div><br/><div class="children"><div class="content">Server Sent Events infamously have low global connection limit per origin[1], so if you have multiple tabs open for a single site you&#x27;ll run into it pretty quickly. If it weren&#x27;t for that, they would be great.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;18584525&#x2F;server-sent-events-and-browser-limits" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;18584525&#x2F;server-sent-eve...</a></div><br/><div id="35958354" class="c"><input type="checkbox" id="c-35958354" checked=""/><div class="controls bullet"><span class="by">tentacleuno</span><span>|</span><a href="#35953744">parent</a><span>|</span><a href="#35958280">next</a><span>|</span><label class="collapse" for="c-35958354">[-]</label><label class="expand" for="c-35958354">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just over HTTP&#x2F;1.  For HTTP&#x2F;2 (which most people should be using anyway), the limit is 100.</div><br/></div></div><div id="35958280" class="c"><input type="checkbox" id="c-35958280" checked=""/><div class="controls bullet"><span class="by">janesconference</span><span>|</span><a href="#35953744">parent</a><span>|</span><a href="#35958354">prev</a><span>|</span><a href="#35953794">next</a><span>|</span><label class="collapse" for="c-35958280">[-]</label><label class="expand" for="c-35958280">[1 more]</label></div><br/><div class="children"><div class="content">You can do leader election[1] in that case<p>[1] <a href="https:&#x2F;&#x2F;greenvitriol.com&#x2F;posts&#x2F;browser-leader" rel="nofollow">https:&#x2F;&#x2F;greenvitriol.com&#x2F;posts&#x2F;browser-leader</a></div><br/></div></div><div id="35953794" class="c"><input type="checkbox" id="c-35953794" checked=""/><div class="controls bullet"><span class="by">flaviut</span><span>|</span><a href="#35953744">parent</a><span>|</span><a href="#35958280">prev</a><span>|</span><a href="#35953790">next</a><span>|</span><label class="collapse" for="c-35953794">[-]</label><label class="expand" for="c-35953794">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never worked with Web Workers, but the doc page mentions them at the very top. Isn&#x27;t that the intended workaround? Have a background thread that receives the events &amp; coordinates, rather than having each page deal with them?</div><br/><div id="35953819" class="c"><input type="checkbox" id="c-35953819" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35953794">parent</a><span>|</span><a href="#35953790">next</a><span>|</span><label class="collapse" for="c-35953819">[-]</label><label class="expand" for="c-35953819">[3 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s `ShardedWorker`.</div><br/><div id="35953918" class="c"><input type="checkbox" id="c-35953918" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35953819">parent</a><span>|</span><a href="#35953790">next</a><span>|</span><label class="collapse" for="c-35953918">[-]</label><label class="expand" for="c-35953918">[2 more]</label></div><br/><div class="children"><div class="content">I wanted so use these in a project recently, only to find out that they aren&#x27;t supported on Chrome for Android. This makes them non-usable for me, since there is no drop-in polyfill available yet.</div><br/><div id="35953954" class="c"><input type="checkbox" id="c-35953954" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35953918">parent</a><span>|</span><a href="#35953790">next</a><span>|</span><label class="collapse" for="c-35953954">[-]</label><label class="expand" for="c-35953954">[1 more]</label></div><br/><div class="children"><div class="content">If you are doing websocket in there, you could fall back to main thread, but it comes at the cost of code duplication.</div><br/></div></div></div></div></div></div></div></div><div id="35953790" class="c"><input type="checkbox" id="c-35953790" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#35953744">parent</a><span>|</span><a href="#35953794">prev</a><span>|</span><a href="#35953831">next</a><span>|</span><label class="collapse" for="c-35953790">[-]</label><label class="expand" for="c-35953790">[4 more]</label></div><br/><div class="children"><div class="content">Sophisticated services that offer SSE will have many different endpoint domains to get around browser limits on simultaneous connections to the same service.<p>endpoint-00.example.com
endpoint-01.example.com
endpoint-02.example.com<p>etc.  It isn&#x27;t specific to SSE.  It&#x27;s any HTTP request.  SSE is just the most obvious because the connections stay open for long periods.</div><br/><div id="35957880" class="c"><input type="checkbox" id="c-35957880" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35953790">parent</a><span>|</span><a href="#35953851">next</a><span>|</span><label class="collapse" for="c-35957880">[-]</label><label class="expand" for="c-35957880">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I&#x27;m saying: it&#x27;s not that good for non-sophisticated services, you need workarounds to make this &quot;great technology&quot; work. Might as well switch to websockets and not worry about this.</div><br/><div id="35958183" class="c"><input type="checkbox" id="c-35958183" checked=""/><div class="controls bullet"><span class="by">miyuru</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35957880">parent</a><span>|</span><a href="#35953851">next</a><span>|</span><label class="collapse" for="c-35958183">[-]</label><label class="expand" for="c-35958183">[1 more]</label></div><br/><div class="children"><div class="content">Another &quot;workaround&quot; is to enable HTTP&#x2F;2, which should be already enabled if the system is managed by a competent admin who cares about his work.</div><br/></div></div></div></div><div id="35953851" class="c"><input type="checkbox" id="c-35953851" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35953790">parent</a><span>|</span><a href="#35957880">prev</a><span>|</span><a href="#35953831">next</a><span>|</span><label class="collapse" for="c-35953851">[-]</label><label class="expand" for="c-35953851">[1 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s an easy workaround, with wildcard DNS entries and certs.</div><br/></div></div></div></div><div id="35953831" class="c"><input type="checkbox" id="c-35953831" checked=""/><div class="controls bullet"><span class="by">toomim</span><span>|</span><a href="#35953744">parent</a><span>|</span><a href="#35953790">prev</a><span>|</span><a href="#35953677">next</a><span>|</span><label class="collapse" for="c-35953831">[-]</label><label class="expand" for="c-35953831">[5 more]</label></div><br/><div class="children"><div class="content">This problem is fixed by using HTTP&#x2F;2.</div><br/><div id="35953910" class="c"><input type="checkbox" id="c-35953910" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35953831">parent</a><span>|</span><a href="#35953677">next</a><span>|</span><label class="collapse" for="c-35953910">[-]</label><label class="expand" for="c-35953910">[4 more]</label></div><br/><div class="children"><div class="content">No, the browser&#x27;s HTTP connection limits still apply on HTTP2, each `EventSource` per tab counts against this limit of I think 6 (?) connections.<p>Websockets to my knowledge have no such limit because they are not HTTP requests.</div><br/><div id="35954770" class="c"><input type="checkbox" id="c-35954770" checked=""/><div class="controls bullet"><span class="by">makkesk8</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35953910">parent</a><span>|</span><a href="#35955059">next</a><span>|</span><label class="collapse" for="c-35954770">[-]</label><label class="expand" for="c-35954770">[1 more]</label></div><br/><div class="children"><div class="content">This is simply not true, it&#x27;s negotiated between the client and server and defaults to 100 usually. 6 is the limit for http 1.1 not http&#x2F;2.<p>Source: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Server-sent_events&#x2F;Using_server-sent_events" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Server-sent...</a></div><br/></div></div><div id="35955059" class="c"><input type="checkbox" id="c-35955059" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35953910">parent</a><span>|</span><a href="#35954770">prev</a><span>|</span><a href="#35953677">next</a><span>|</span><label class="collapse" for="c-35955059">[-]</label><label class="expand" for="c-35955059">[2 more]</label></div><br/><div class="children"><div class="content">I believe you have it essentially backward. Websockets consume a connection no matter what, as the protocol does not work with HTTP2 (there was an attempt, but I believe it wasn&#x27;t adopted and abandoned).<p>The SSE requests do work with HTTP2, as do some other old methods like long polling. All the tabs will generally share one connection to that domain.</div><br/><div id="35958365" class="c"><input type="checkbox" id="c-35958365" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#35953744">root</a><span>|</span><a href="#35955059">parent</a><span>|</span><a href="#35953677">next</a><span>|</span><label class="collapse" for="c-35958365">[-]</label><label class="expand" for="c-35958365">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Websockets consume a connection no matter what, as the protocol does not work with HTTP2  (there was an attempt, but I believe it wasn&#x27;t adopted and abandoned).<p>Are you thinking of RFC 8441? <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8441" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8441</a><p>If so, then it&#x27;s already implemented by Firefox: <a href="https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1434137" rel="nofollow">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1434137</a><p>...and by Chrome&#x2F;Chromium since 91: <a href="https:&#x2F;&#x2F;chromestatus.com&#x2F;feature&#x2F;6251293127475200" rel="nofollow">https:&#x2F;&#x2F;chromestatus.com&#x2F;feature&#x2F;6251293127475200</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="35953677" class="c"><input type="checkbox" id="c-35953677" checked=""/><div class="controls bullet"><span class="by">mr-wendel</span><span>|</span><a href="#35953744">prev</a><span>|</span><a href="#35953576">next</a><span>|</span><label class="collapse" for="c-35953677">[-]</label><label class="expand" for="c-35953677">[1 more]</label></div><br/><div class="children"><div class="content">My favorite use of this that I&#x27;ve spotted in the wild is <a href="https:&#x2F;&#x2F;nightride.fm" rel="nofollow">https:&#x2F;&#x2F;nightride.fm</a> (not affiliated, just a fan!). It&#x27;s a Synthwave music site + community.<p>In particular, I noticed that EventSource goodies are used to broadcast currently playing songs on each station, as well as to provide anon read access to their IRC server via a simple vanilla javascript webapp.<p>WAY cleaner and easier than web sockets for this use case, and CDN friendly to boot!</div><br/></div></div><div id="35953576" class="c"><input type="checkbox" id="c-35953576" checked=""/><div class="controls bullet"><span class="by">pieter</span><span>|</span><a href="#35953677">prev</a><span>|</span><a href="#35953698">next</a><span>|</span><label class="collapse" for="c-35953576">[-]</label><label class="expand" for="c-35953576">[3 more]</label></div><br/><div class="children"><div class="content">Note that this really isnât anything except the agreement to send messages separated by 2 new lines. The SSE object in browsers is old and quirky; for example, it only supports GET requests, which means youâll hit path length limits if you use it for something like LLM completion with large prompts.<p>Luckily since thereâs nothing special about the browser support, you can very easily replace it with custom implementations. <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@microsoft&#x2F;fetch-event-source" rel="nofollow">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@microsoft&#x2F;fetch-event-source</a> for example offers mostly the same API, but does offer POST requests and a bunch of other goodies.</div><br/><div id="35953829" class="c"><input type="checkbox" id="c-35953829" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#35953576">parent</a><span>|</span><a href="#35953941">next</a><span>|</span><label class="collapse" for="c-35953829">[-]</label><label class="expand" for="c-35953829">[1 more]</label></div><br/><div class="children"><div class="content">There is this agreement, and also the fact that browsers can forget previous messages, unlike any xhr-based custom implementation since the EventSource object does not provide methods to access previous contents. I don&#x27;t know how well this package handles this.<p>I agree with the note about the auto retry mechanism of EventSource. It does no good, is unavoidable and a big annoyance. The work we had to do to work around it in Tracim (previous job) [1] was pure madness. I see this part has not been touched since I left by the way.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tracim&#x2F;tracim&#x2F;blob&#x2F;develop&#x2F;frontend_lib&#x2F;src&#x2F;LiveMessageManager.js#L193">https:&#x2F;&#x2F;github.com&#x2F;tracim&#x2F;tracim&#x2F;blob&#x2F;develop&#x2F;frontend_lib&#x2F;s...</a></div><br/></div></div><div id="35953941" class="c"><input type="checkbox" id="c-35953941" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#35953576">parent</a><span>|</span><a href="#35953829">prev</a><span>|</span><a href="#35953698">next</a><span>|</span><label class="collapse" for="c-35953941">[-]</label><label class="expand" for="c-35953941">[1 more]</label></div><br/><div class="children"><div class="content">This seems like a great solution for streaming responses scoped to a single request. Neat!<p>I&#x27;ve always used SSEs to open a more persistent comms channel to a browser which creates way more state and complexity both on the client and the server.</div><br/></div></div></div></div><div id="35953698" class="c"><input type="checkbox" id="c-35953698" checked=""/><div class="controls bullet"><span class="by">quechimba</span><span>|</span><a href="#35953576">prev</a><span>|</span><a href="#35958263">next</a><span>|</span><label class="collapse" for="c-35953698">[-]</label><label class="expand" for="c-35953698">[2 more]</label></div><br/><div class="children"><div class="content">SSE is pretty good but I have never been able to see the messages in firefox devtools, and doesn&#x27;t work with binary data.<p>HTTP&#x2F;2 streams are just as easy to implement, and work both ways and support binary data.</div><br/><div id="35958575" class="c"><input type="checkbox" id="c-35958575" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35953698">parent</a><span>|</span><a href="#35958263">next</a><span>|</span><label class="collapse" for="c-35958575">[-]</label><label class="expand" for="c-35958575">[1 more]</label></div><br/><div class="children"><div class="content">Try debugging HTTP&#x2F;2 on a live machine when you have 10.000 concurrent users and get back to me how well you sleep.<p>console.log or wireshark</div><br/></div></div></div></div><div id="35958263" class="c"><input type="checkbox" id="c-35958263" checked=""/><div class="controls bullet"><span class="by">nberkman</span><span>|</span><a href="#35953698">prev</a><span>|</span><a href="#35953403">next</a><span>|</span><label class="collapse" for="c-35958263">[-]</label><label class="expand" for="c-35958263">[1 more]</label></div><br/><div class="children"><div class="content">Streaming ChatGPT via SSE in Elixir: <a href="https:&#x2F;&#x2F;github.com&#x2F;wojtekmach&#x2F;mix_install_examples&#x2F;pull&#x2F;22#issue-1620159989">https:&#x2F;&#x2F;github.com&#x2F;wojtekmach&#x2F;mix_install_examples&#x2F;pull&#x2F;22#i...</a></div><br/></div></div><div id="35953403" class="c"><input type="checkbox" id="c-35953403" checked=""/><div class="controls bullet"><span class="by">asynchronous</span><span>|</span><a href="#35958263">prev</a><span>|</span><a href="#35953724">next</a><span>|</span><label class="collapse" for="c-35953403">[-]</label><label class="expand" for="c-35953403">[4 more]</label></div><br/><div class="children"><div class="content">Love to see stuff like this on the HN front page, when I know tons of web devs that have never even heard of SSE.<p>Tangentially, Iâm having a massive problem with SSE datastreams erroring out about two minutes in for âERR: Network chunk encodingâ reasons, anyone else seen this before?</div><br/><div id="35958684" class="c"><input type="checkbox" id="c-35958684" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#35953403">parent</a><span>|</span><a href="#35958491">next</a><span>|</span><label class="collapse" for="c-35958684">[-]</label><label class="expand" for="c-35958684">[1 more]</label></div><br/><div class="children"><div class="content">Has there been traffic during that two minutes?<p>In theory, a TCP session can remain alive forever. In practice, various things got in the way, and you need traffic to keep it alive (keep-alive, ping, heartbeat, it gets given various names). I believe once a minute should be enough. Iâve encountered &quot;ping&quot; and &quot;&quot; used as SSE event names for this purpose.</div><br/></div></div><div id="35958491" class="c"><input type="checkbox" id="c-35958491" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35953403">parent</a><span>|</span><a href="#35958684">prev</a><span>|</span><a href="#35953450">next</a><span>|</span><label class="collapse" for="c-35958491">[-]</label><label class="expand" for="c-35958491">[1 more]</label></div><br/><div class="children"><div class="content">You need to send &quot;keep-alive&quot; &quot;noop&quot; to keep the routers happy, I do it ever 5 seconds.</div><br/></div></div><div id="35953450" class="c"><input type="checkbox" id="c-35953450" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#35953403">parent</a><span>|</span><a href="#35958491">prev</a><span>|</span><a href="#35953724">next</a><span>|</span><label class="collapse" for="c-35953450">[-]</label><label class="expand" for="c-35953450">[1 more]</label></div><br/><div class="children"><div class="content">Try sending the messages without compression. A lot of servers don&#x27;t know how to handle this for SSE (since its a uncommon content type)</div><br/></div></div></div></div><div id="35953724" class="c"><input type="checkbox" id="c-35953724" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#35953403">prev</a><span>|</span><a href="#35953762">next</a><span>|</span><label class="collapse" for="c-35953724">[-]</label><label class="expand" for="c-35953724">[1 more]</label></div><br/><div class="children"><div class="content">I was looking through the implementation of chat.openai.com recently and was pleasantly surprised to see that it was 100% Server Sent Events, no Websockets.<p>SSE is a great tool to have in your belt. I&#x27;d say it can replace the majority of use cases for Websockets out there today (basically pushing small amounts of text&#x2F;JSON data to the client) with a tiny fraction of the complexity. Opening and maintaining a bidirectional TCP stream is otherwise a huge pain in the ass.</div><br/></div></div><div id="35953762" class="c"><input type="checkbox" id="c-35953762" checked=""/><div class="controls bullet"><span class="by">MetalMatze</span><span>|</span><a href="#35953724">prev</a><span>|</span><a href="#35953542">next</a><span>|</span><label class="collapse" for="c-35953762">[-]</label><label class="expand" for="c-35953762">[1 more]</label></div><br/><div class="children"><div class="content">SSE are amazing!
I&#x27;ve used them to push updates to clients from multiple goroutines (Go threads) with <a href="https:&#x2F;&#x2F;lastfm.live" rel="nofollow">https:&#x2F;&#x2F;lastfm.live</a><p>It&#x27;s quite simple to start with on the Go backend side of things and the frontend things aren&#x27;t too complicated either.</div><br/></div></div><div id="35953542" class="c"><input type="checkbox" id="c-35953542" checked=""/><div class="controls bullet"><span class="by">clessg</span><span>|</span><a href="#35953762">prev</a><span>|</span><a href="#35953686">next</a><span>|</span><label class="collapse" for="c-35953542">[-]</label><label class="expand" for="c-35953542">[1 more]</label></div><br/><div class="children"><div class="content">For my fellow high-IQ individuals initially confused by the seeming lack of content in the article, it&#x27;s under &#x27;Guides&#x27;: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Server-sent_events&#x2F;Using_server-sent_events" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Server-sent...</a><p>A bit easy to miss, but includes some actual code samples and a really nice walkthrough. Highly encouraged even if you already &quot;know&quot; SSE and want to solidify your knowledge, I like how it doesn&#x27;t hide any of the details.</div><br/></div></div><div id="35953414" class="c"><input type="checkbox" id="c-35953414" checked=""/><div class="controls bullet"><span class="by">0xCAP</span><span>|</span><a href="#35953686">prev</a><span>|</span><a href="#35953638">next</a><span>|</span><label class="collapse" for="c-35953414">[-]</label><label class="expand" for="c-35953414">[8 more]</label></div><br/><div class="children"><div class="content">Curious why is this trending? Btw sse are pretty great, only thing I don&#x27;t get is why they don&#x27;t allow for binary payloads. That&#x27;d have been the icing on the cake.</div><br/><div id="35958546" class="c"><input type="checkbox" id="c-35958546" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35953414">parent</a><span>|</span><a href="#35953540">next</a><span>|</span><label class="collapse" for="c-35958546">[-]</label><label class="expand" for="c-35958546">[1 more]</label></div><br/><div class="children"><div class="content">String parsing is never the bottleneck. You need to parallelize (shared memory) and understand your system and for that text is pretty convenient.<p>So also avoid HTTPS.<p>It&#x27;s trending because it&#x27;s the final real-time solution for eternity.</div><br/></div></div><div id="35953540" class="c"><input type="checkbox" id="c-35953540" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#35953414">parent</a><span>|</span><a href="#35958546">prev</a><span>|</span><a href="#35953987">next</a><span>|</span><label class="collapse" for="c-35953540">[-]</label><label class="expand" for="c-35953540">[1 more]</label></div><br/><div class="children"><div class="content">&gt; only thing I don&#x27;t get is why they don&#x27;t allow for binary payloads<p>I&#x27;ve always appreciated that it&#x27;s just a simple line-oriented UTF-8 text protocol.  Binary transfers are handled more efficiently with something else.  Or just base64 the payload if it&#x27;s not that big of a deal.</div><br/></div></div><div id="35953987" class="c"><input type="checkbox" id="c-35953987" checked=""/><div class="controls bullet"><span class="by">b33j0r</span><span>|</span><a href="#35953414">parent</a><span>|</span><a href="#35953540">prev</a><span>|</span><a href="#35953446">next</a><span>|</span><label class="collapse" for="c-35953987">[-]</label><label class="expand" for="c-35953987">[1 more]</label></div><br/><div class="children"><div class="content">This got into the zeitgeist somehow. I just implemented my first SSE app with FastAPI last week, then I saw a youtube video and this post!<p>I was implementing something with websockets and asked chatgpt to tell me about modern alternatives. In my years of full-stackâ¦ I hadnât heard of SSE, or at least never got why I should care.<p>Damn, I see the limitations of REST, but I was building state machines and custom protocols with websockets. Itâs nice to prototype in REST again.<p>REST+SSE ftw, I guess!</div><br/></div></div><div id="35953446" class="c"><input type="checkbox" id="c-35953446" checked=""/><div class="controls bullet"><span class="by">asplake</span><span>|</span><a href="#35953414">parent</a><span>|</span><a href="#35953987">prev</a><span>|</span><a href="#35953696">next</a><span>|</span><label class="collapse" for="c-35953446">[-]</label><label class="expand" for="c-35953446">[3 more]</label></div><br/><div class="children"><div class="content">Probably as a result of <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35937554" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35937554</a></div><br/><div id="35959168" class="c"><input type="checkbox" id="c-35959168" checked=""/><div class="controls bullet"><span class="by">corentin88</span><span>|</span><a href="#35953414">root</a><span>|</span><a href="#35953446">parent</a><span>|</span><a href="#35953716">next</a><span>|</span><label class="collapse" for="c-35959168">[-]</label><label class="expand" for="c-35959168">[1 more]</label></div><br/><div class="children"><div class="content">OP here. I was looking at Anthropic&#x27;s website as a result of <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35948742" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35948742</a><p>Turns out in their FAQ, they have this:<p>&gt; Our API is designed to be a backend that incorporates Claude into any application youâve developed. Our application sends text to our API, then receives a response via *server-sent events*, a streaming protocol for the web. We have API documentation with drop-in example code in Python and Typescript to get you started.<p>Was curious what it was and thought it was probably worth sharing.<p>Didn&#x27;t knew OpenAI uses the same mechanism.</div><br/></div></div><div id="35953716" class="c"><input type="checkbox" id="c-35953716" checked=""/><div class="controls bullet"><span class="by">marpstar</span><span>|</span><a href="#35953414">root</a><span>|</span><a href="#35953446">parent</a><span>|</span><a href="#35959168">prev</a><span>|</span><a href="#35953696">next</a><span>|</span><label class="collapse" for="c-35953716">[-]</label><label class="expand" for="c-35953716">[1 more]</label></div><br/><div class="children"><div class="content">My first thought was ChatGPT API&#x27;s `stream` option: <a href="https:&#x2F;&#x2F;platform.openai.com&#x2F;docs&#x2F;api-reference&#x2F;completions&#x2F;create#completions&#x2F;create-stream" rel="nofollow">https:&#x2F;&#x2F;platform.openai.com&#x2F;docs&#x2F;api-reference&#x2F;completions&#x2F;c...</a></div><br/></div></div></div></div><div id="35953696" class="c"><input type="checkbox" id="c-35953696" checked=""/><div class="controls bullet"><span class="by">mikek</span><span>|</span><a href="#35953414">parent</a><span>|</span><a href="#35953446">prev</a><span>|</span><a href="#35953638">next</a><span>|</span><label class="collapse" for="c-35953696">[-]</label><label class="expand" for="c-35953696">[1 more]</label></div><br/><div class="children"><div class="content">OpenAI uses this in their APIs to stream tokens</div><br/></div></div></div></div><div id="35953860" class="c"><input type="checkbox" id="c-35953860" checked=""/><div class="controls bullet"><span class="by">patwolf</span><span>|</span><a href="#35953638">prev</a><span>|</span><a href="#35953712">next</a><span>|</span><label class="collapse" for="c-35953860">[-]</label><label class="expand" for="c-35953860">[1 more]</label></div><br/><div class="children"><div class="content">I did a web app project with SSEs a while back. They worked well in the browser, but when it came time to build a mobile app (React Native), I had trouble finding a good library to use. I&#x27;m sure I could have rolled my own, but being in a time crunch I ended up using Firebase Cloud Messaging. Hopefully there&#x27;s better support these days.</div><br/></div></div><div id="35953712" class="c"><input type="checkbox" id="c-35953712" checked=""/><div class="controls bullet"><span class="by">toomim</span><span>|</span><a href="#35953860">prev</a><span>|</span><a href="#35953366">next</a><span>|</span><label class="collapse" for="c-35953712">[-]</label><label class="expand" for="c-35953712">[1 more]</label></div><br/><div class="children"><div class="content">ChatGPT uses SSE to stream the AI&#x27;s responses, token-by-token!</div><br/></div></div><div id="35953366" class="c"><input type="checkbox" id="c-35953366" checked=""/><div class="controls bullet"><span class="by">collaborative</span><span>|</span><a href="#35953712">prev</a><span>|</span><a href="#35953566">next</a><span>|</span><label class="collapse" for="c-35953366">[-]</label><label class="expand" for="c-35953366">[1 more]</label></div><br/><div class="children"><div class="content">Not really related, but this is GAE&#x27;s missing feature IMO</div><br/></div></div><div id="35953566" class="c"><input type="checkbox" id="c-35953566" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#35953366">prev</a><span>|</span><a href="#35953901">next</a><span>|</span><label class="collapse" for="c-35953566">[-]</label><label class="expand" for="c-35953566">[6 more]</label></div><br/><div class="children"><div class="content">How well do these work out in practice across a variety of platforms, behind firewalls, on phones, and so on?</div><br/><div id="35958556" class="c"><input type="checkbox" id="c-35958556" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35953566">parent</a><span>|</span><a href="#35953822">next</a><span>|</span><label class="collapse" for="c-35958556">[-]</label><label class="expand" for="c-35958556">[1 more]</label></div><br/><div class="children"><div class="content">They work EVERYWHERE except through some very rare buggy anti-viruses and ISP implementations.<p>Real life stats: &quot;759 out of 205.875 customers refunded because their antivirus blocks the pull HTTP stream&quot;, so 99.7%!<p>They even go through the great firewall without bureaucracy.</div><br/></div></div><div id="35953822" class="c"><input type="checkbox" id="c-35953822" checked=""/><div class="controls bullet"><span class="by">Mogzol</span><span>|</span><a href="#35953566">parent</a><span>|</span><a href="#35958556">prev</a><span>|</span><a href="#35954000">next</a><span>|</span><label class="collapse" for="c-35953822">[-]</label><label class="expand" for="c-35953822">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re well supported on modern browsers, both mobile and desktop. If you need to support IE then you can use a polyfill. It&#x27;s essentially just a long-running HTTP request. The main issue I&#x27;ve run into before is if your server has a response timeout configured then you&#x27;ll need to disable or work around it, otherwise it will disrupt the event stream whenever the timeout is hit, since the event stream is just an HTTP response.</div><br/></div></div><div id="35953798" class="c"><input type="checkbox" id="c-35953798" checked=""/><div class="controls bullet"><span class="by">lecarore</span><span>|</span><a href="#35953566">parent</a><span>|</span><a href="#35954000">prev</a><span>|</span><a href="#35953901">next</a><span>|</span><label class="collapse" for="c-35953798">[-]</label><label class="expand" for="c-35953798">[2 more]</label></div><br/><div class="children"><div class="content">I use this at work (Enterprise SAAS web software) and we had to implement a backup &quot;polling every 5 seconds&quot; for clients that would not support it. It&#x27;s quite rare though. We assume that some caching proxy might be waiting for the GET request to be fully done to cache it and then give it to the user or something like this. The SSE  would then never get updates, while every normal HTTP request would work</div><br/><div id="35957962" class="c"><input type="checkbox" id="c-35957962" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#35953566">root</a><span>|</span><a href="#35953798">parent</a><span>|</span><a href="#35953901">next</a><span>|</span><label class="collapse" for="c-35957962">[-]</label><label class="expand" for="c-35957962">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve read that this does indeed happen with some HTTP proxies.  In some environments that includes HTTPS because some environments intercept HTTPS traffic too.  It&#x27;s enough for me to consider SSE too unreliable to use if my application needs to be reliable with events, and it&#x27;s the first thing I thought when I saw the SSE spec the first time.<p>Back beore SSE, I recall seeing some server-to-client event protocol specification inserted extra padding bytes after events in the middle of an HTTP response stream, just to convince some HTTP proxies to forward the event in an incomplete HTTP response, but I don&#x27;t recall which protocol now.  It was never entirely clear how much padding would be enough, or if any amount would be.<p>When cometd and the Bayeux publish-subscribe protocol was designed, this is why long-polling was always used, instead of streaming partial responses inside a single HTTP response.  With correctly designed overlapping long-polling requests, it&#x27;s possible to get event latency very similar to SSE, without this issue of lost events due to proxies.  So that&#x27;s a good, reliable choice, if you don&#x27;t use WebSockets.  In fact it&#x27;s more reliable than WebSockets (which can also get stuck at some proxies), so if you value very reliable event delivery long-polling or just periodic polling are the way to do it, but with much higher overhead.<p>In theory SSE provides the option for mobile device power saving described at <a href="https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;multipage&#x2F;server-sent-events.html#eventsource-push" rel="nofollow">https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;multipage&#x2F;server-sent-events.ht...</a>  Using more active protocols almost certainly defeats this.  In theory a mobile network and network stack (modified inside the mobile browser where cleartext is available) could implement that power saving strategy for mostly-idle WebSockets too, which is another argument for WebSockets.</div><br/></div></div></div></div></div></div><div id="35953901" class="c"><input type="checkbox" id="c-35953901" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#35953566">prev</a><span>|</span><a href="#35953945">next</a><span>|</span><label class="collapse" for="c-35953901">[-]</label><label class="expand" for="c-35953901">[2 more]</label></div><br/><div class="children"><div class="content">SSE is phenomenal and underutilized because it wasn&#x27;t supported by IE.</div><br/><div id="35958608" class="c"><input type="checkbox" id="c-35958608" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35953901">parent</a><span>|</span><a href="#35953945">next</a><span>|</span><label class="collapse" for="c-35958608">[-]</label><label class="expand" for="c-35958608">[1 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t &quot;not supported&quot; they had a bug that they never could fix because it would have broken 50% of the internet.<p>Be careful what you release because it might not be fixable after release.</div><br/></div></div></div></div><div id="35953945" class="c"><input type="checkbox" id="c-35953945" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#35953901">prev</a><span>|</span><a href="#35953620">next</a><span>|</span><label class="collapse" for="c-35953945">[-]</label><label class="expand" for="c-35953945">[1 more]</label></div><br/><div class="children"><div class="content">I wish there were a way to push not just anonymous data&#x2F;events but http <i>resources,</i> to similar effect.<p>SSE &amp; websockets &amp; http streams can send anonymous data, but I&#x27;d like to be able to send an actual thing. As per the most core architecture of the web:<p>&gt; <i>Axiom 0a: Universality 2. 
Any resource of significance should be given a URI.</i> <a href="https:&#x2F;&#x2F;www.w3.org&#x2F;DesignIssues&#x2F;Axioms.html#uri" rel="nofollow">https:&#x2F;&#x2F;www.w3.org&#x2F;DesignIssues&#x2F;Axioms.html#uri</a><p>Or alternatively,<p>&gt; <i>Cool URLs don&#x27;t change</i> (implicitly, cool things have URLs, see above). <a href="https:&#x2F;&#x2F;www.w3.org&#x2F;Provider&#x2F;Style&#x2F;URI" rel="nofollow">https:&#x2F;&#x2F;www.w3.org&#x2F;Provider&#x2F;Style&#x2F;URI</a><p>Instead of pushing to a chat app an anonymous blob of json for a chat message to a room, the server could assert a &#x2F;room&#x2F;42&#x2F;msg&#x2F;c0f3 resource, could identify universally what it is it&#x27;s sending. The advantage would be so high. It&#x27;d become a standard way to assert a resource, to make known a fact, that would be viable across systems. Further http requests to the resource would just work. Folks could link to the resource. How cool it would be if we could <i>send not just data but resources?</i><p>We have come glancingly close to getting such a thing so many times. The HyBi mailing list that begat websockets had a number of alternate more resourceful ideas floating around such as a BEEP protocol that allowed patterns beyond request&#x2F;response of resources. The browser actually implements an internal protocol that uses HTTP2&#x2F;push to send resourceful messages, web push protocol&#x2F;RFC8030, <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8030" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8030</a>.<p>But the underlying http2&#x2F;push was de-implemented for webserving in general, and even when it was available, it lacked the oft requested ability to get notice of new pushed resources. (<a href="https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;fetch&#x2F;issues&#x2F;65">https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;fetch&#x2F;issues&#x2F;65</a> was an old request. <a href="https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;fetch&#x2F;issues&#x2F;607">https:&#x2F;&#x2F;github.com&#x2F;whatwg&#x2F;fetch&#x2F;issues&#x2F;607</a> had some steam in making it happen.) Tragic backwards moves in my view, and never acknowledged by blink-dev when protests arose.<p>The best we have today is to stream json-ls events, which have an <i>@id</i> property identifying them. But developers would have to snoop these events, and store them in a service worker, to make them actually accessible as http resources.<p>I continue to hold hope eventually we&#x27;ll get better at using urls to send data, to assert new things happening... But it&#x27;s been nearly 30 years of me hoping, and with some fleeting exceptions the browser teams have seemed disinterested in making urls cool, in spite of a number of requests. We&#x27;ve been left at un-web side-channels like SSE &amp; Websockets for a long long time now. Wouldn&#x27;t it be nice to see some real growth for http capabilities that we really can use, that are more than abstract underlying transport tweaks like h2 and h3?</div><br/></div></div><div id="35953620" class="c"><input type="checkbox" id="c-35953620" checked=""/><div class="controls bullet"><span class="by">schmichael</span><span>|</span><a href="#35953945">prev</a><span>|</span><label class="collapse" for="c-35953620">[-]</label><label class="expand" for="c-35953620">[4 more]</label></div><br/><div class="children"><div class="content">What is the advantage of SSE over streaming ndjson?</div><br/><div id="35953920" class="c"><input type="checkbox" id="c-35953920" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35953620">parent</a><span>|</span><a href="#35953683">next</a><span>|</span><label class="collapse" for="c-35953920">[-]</label><label class="expand" for="c-35953920">[2 more]</label></div><br/><div class="children"><div class="content">Built-in client API for parsing and event dispatching. Data doesn&#x27;t have to be JSON encoded.<p>But fundamentally nothing that Comet, steaming XHR, etc, WebSockets, can&#x27;t do.</div><br/><div id="35958358" class="c"><input type="checkbox" id="c-35958358" checked=""/><div class="controls bullet"><span class="by">tentacleuno</span><span>|</span><a href="#35953620">root</a><span>|</span><a href="#35953920">parent</a><span>|</span><a href="#35953683">next</a><span>|</span><label class="collapse" for="c-35958358">[-]</label><label class="expand" for="c-35958358">[1 more]</label></div><br/><div class="children"><div class="content">A streaming XHR is more wasteful in that it constantly has to renegotiate TLS.  This is unlike EventSources and WebSockets, which do not.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>