<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714986073264" as="style"/><link rel="stylesheet" href="styles.css?v=1714986073264"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nrk.neocities.org/articles/utf8-pext">Decoding UTF8 with parallel extract</a> <span class="domain">(<a href="https://nrk.neocities.org">nrk.neocities.org</a>)</span></div><div class="subtext"><span>g0xA52A2A</span> | <span>9 comments</span></div><br/><div><div id="40268331" class="c"><input type="checkbox" id="c-40268331" checked=""/><div class="controls bullet"><span class="by">pbsd</span><span>|</span><a href="#40266435">next</a><span>|</span><label class="collapse" for="c-40268331">[-]</label><label class="expand" for="c-40268331">[2 more]</label></div><br/><div class="children"><div class="content">The overlong lookup can also be written without a memory lookup as<p><pre><code>    0x10000U &gt;&gt; ((0x1531U &gt;&gt; (i*5)) &amp; 31);
</code></pre>
On most current x86 chips this has a latency of 3 cycles -- LEA+SHR+SHR -- which is better than an L1 cache hit almost everywhere.</div><br/><div id="40268440" class="c"><input type="checkbox" id="c-40268440" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40268331">parent</a><span>|</span><a href="#40266435">next</a><span>|</span><label class="collapse" for="c-40268440">[-]</label><label class="expand" for="c-40268440">[1 more]</label></div><br/><div class="children"><div class="content">checking for an overlong input is off the critical path, so latency is irrelevant.  (tfa doesn&#x27;t appear to use a branch—it should use a branch)</div><br/></div></div></div></div><div id="40266435" class="c"><input type="checkbox" id="c-40266435" checked=""/><div class="controls bullet"><span class="by">nwellnhof</span><span>|</span><a href="#40268331">prev</a><span>|</span><label class="collapse" for="c-40266435">[-]</label><label class="expand" for="c-40266435">[6 more]</label></div><br/><div class="children"><div class="content">In my experiments, anything using lookup tables was slower than a naive, branching decoder on real-world data. Reading from a lookup table in L1 cache has ~4 cycles latency which is prohibitive for the simple case of mostly ASCII bytes. You can easily achieve more than 1.5 GB&#x2F;s with a naive decoder while all the &quot;smarter&quot; approaches are capped to ~800 MB&#x2F;s.</div><br/><div id="40268382" class="c"><input type="checkbox" id="c-40268382" checked=""/><div class="controls bullet"><span class="by">andrewf</span><span>|</span><a href="#40266435">parent</a><span>|</span><a href="#40266601">next</a><span>|</span><label class="collapse" for="c-40268382">[-]</label><label class="expand" for="c-40268382">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;d be interesting to benchmark this on texts from different languages. English text will be very friendly to the branch predictor because it&#x27;s all 1-byte codepoints. I think a language dominated by either 2-byte or 3-byte codepoints would be as well, mixing codepoint lengths is what would trip things up.</div><br/><div id="40270863" class="c"><input type="checkbox" id="c-40270863" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#40266435">root</a><span>|</span><a href="#40268382">parent</a><span>|</span><a href="#40266601">next</a><span>|</span><label class="collapse" for="c-40270863">[-]</label><label class="expand" for="c-40270863">[1 more]</label></div><br/><div class="children"><div class="content">Been a while, but I found it was  best to assume all the text is ASCII, and fall back to a slower code path only if that turned out not to be the case.<p>A lot of tools that create JSON, XML, and so forth will escape any non ASCII characters by default. Python&#x27;s json package, for example.</div><br/></div></div></div></div><div id="40266601" class="c"><input type="checkbox" id="c-40266601" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#40266435">parent</a><span>|</span><a href="#40268382">prev</a><span>|</span><a href="#40268079">next</a><span>|</span><label class="collapse" for="c-40266601">[-]</label><label class="expand" for="c-40266601">[2 more]</label></div><br/><div class="children"><div class="content">IIRC all of the simdutf implementations use lookup tables except for the AVX512 and RVV backends.<p>Here is e.g. the NEON code: <a href="https:&#x2F;&#x2F;github.com&#x2F;simdutf&#x2F;simdutf&#x2F;blob&#x2F;1b8ca3d1072a8e2e102696f0ac128cb9ccdae977&#x2F;src&#x2F;arm64&#x2F;arm_convert_utf8_to_utf32.cpp#L55">https:&#x2F;&#x2F;github.com&#x2F;simdutf&#x2F;simdutf&#x2F;blob&#x2F;1b8ca3d1072a8e2e1026...</a></div><br/><div id="40267714" class="c"><input type="checkbox" id="c-40267714" checked=""/><div class="controls bullet"><span class="by">nwellnhof</span><span>|</span><a href="#40266435">root</a><span>|</span><a href="#40266601">parent</a><span>|</span><a href="#40268079">next</a><span>|</span><label class="collapse" for="c-40267714">[-]</label><label class="expand" for="c-40267714">[1 more]</label></div><br/><div class="children"><div class="content">SIMD is great if you want to convert to UTF-32 but most of the time, I want to iterate over UTF-8 codepoints directly. The initial test for a 1-byte sequence is just too simple with a branch and will be hit most of the time. Asian scripts are an exception but there you have longer runs of 3-byte sequences. Testing with real-world data, I found the worst case for the branch predictor to be Eastern European scripts which often alternate between 1- and 2-byte sequences. But even with Czech language content, I got around 800 MB&#x2F;s with the naive approach, IIRC.</div><br/></div></div></div></div><div id="40268079" class="c"><input type="checkbox" id="c-40268079" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#40266435">parent</a><span>|</span><a href="#40266601">prev</a><span>|</span><label class="collapse" for="c-40268079">[-]</label><label class="expand" for="c-40268079">[1 more]</label></div><br/><div class="children"><div class="content">I would expect it depends on where the lookup table enters the picture. If the table lookup is at the end of a dependency chain, it&#x27;s not going to stall anything and then you&#x27;re putting less strain on the branch predictor&#x2F;reordering machinery.<p>The article is using pext, which is different from a regular table lookup. While it has horrible latency and overhead on older chips, on Zen3 it appears to decode to a single uop with a latency of 3, and on Haswell it also decodes to one uop with a latency of 3. So it&#x27;s not as bad as a regular table lookup as long as you&#x27;re on a new enough processor.<p>It&#x27;s also possible to do vectorized lookup table loads if your lookup table is small enough and you have a modern CPU, see <a href="http:&#x2F;&#x2F;0x80.pl&#x2F;notesen&#x2F;2016-03-13-simd-lookup-pshufb.html" rel="nofollow">http:&#x2F;&#x2F;0x80.pl&#x2F;notesen&#x2F;2016-03-13-simd-lookup-pshufb.html</a> and <a href="http:&#x2F;&#x2F;0x80.pl&#x2F;notesen&#x2F;2019-02-03-simd-switch-implementation.html" rel="nofollow">http:&#x2F;&#x2F;0x80.pl&#x2F;notesen&#x2F;2019-02-03-simd-switch-implementation...</a> (there&#x27;s a more generalized version of this I can&#x27;t remember the URL of...)</div><br/></div></div></div></div></div></div></div></div></div></body></html>