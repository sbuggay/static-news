<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726822877095" as="style"/><link rel="stylesheet" href="styles.css?v=1726822877095"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arstechnica.com/gadgets/2024/09/real-time-linux-is-officially-part-of-the-kernel-after-decades-of-debate/">Real-time Linux is officially part of the kernel</a>Â <span class="domain">(<a href="https://arstechnica.com">arstechnica.com</a>)</span></div><div class="subtext"><span>jonbaer</span> | <span>99 comments</span></div><br/><div><div id="41598983" class="c"><input type="checkbox" id="c-41598983" checked=""/><div class="controls bullet"><span class="by">jpfr</span><span>|</span><a href="#41598108">next</a><span>|</span><label class="collapse" for="c-41598983">[-]</label><label class="expand" for="c-41598983">[3 more]</label></div><br/><div class="children"><div class="content">This is a big achievement after many years of work!<p>Here are a few links to see how the work is done behind the scenes.
Sadly arstechnica has only <i>funny</i> links and doesn&#x27;t provide the actual source (why LinkedIn?).<p>Most of the work was done by Thomas Gleixner and team.
He founded Linutronix, now (I believe) owned by Intel.<p>Pull request for the last printk bits: <a href="https:&#x2F;&#x2F;marc.info&#x2F;?l=linux-kernel&amp;m=172623896125062&amp;w=2" rel="nofollow">https:&#x2F;&#x2F;marc.info&#x2F;?l=linux-kernel&amp;m=172623896125062&amp;w=2</a><p>Pull request for PREEMPT_RT in the kernel config: <a href="https:&#x2F;&#x2F;marc.info&#x2F;?l=linux-kernel&amp;m=172679265718247&amp;w=2" rel="nofollow">https:&#x2F;&#x2F;marc.info&#x2F;?l=linux-kernel&amp;m=172679265718247&amp;w=2</a><p>This is the log of the RT patches on top of kernel v6.11.<p><a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;rt&#x2F;linux-rt-devel.git&#x2F;log&#x2F;?h=v6.11-rt7-rebase" rel="nofollow">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;rt&#x2F;linux-rt-...</a><p>I think there are still a few things you need on top of a vanilla kernel. For example the new printk infrastructure still needs to be adopted by the actual drivers (UART consoles and so on).
But the size of the RT patchset is already much much smaller than before. And being configurable out-of-the-box is of course a big sign of confidence by Linus.<p>Congrats to the team!</div><br/><div id="41599644" class="c"><input type="checkbox" id="c-41599644" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41598983">parent</a><span>|</span><a href="#41599891">next</a><span>|</span><label class="collapse" for="c-41599644">[-]</label><label class="expand" for="c-41599644">[1 more]</label></div><br/><div class="children"><div class="content">Thomas Gleixner is one if the most prolific people I&#x27;ve heard of. He has been one of the most active kernel developers for more than a decade, leading the pack at times, currently ranket at position five:<p><a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;956765&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;956765&#x2F;</a></div><br/></div></div><div id="41599891" class="c"><input type="checkbox" id="c-41599891" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41598983">parent</a><span>|</span><a href="#41599644">prev</a><span>|</span><a href="#41598108">next</a><span>|</span><label class="collapse" for="c-41599891">[-]</label><label class="expand" for="c-41599891">[1 more]</label></div><br/><div class="children"><div class="content">TIL in 2022, Linutronix became an &quot;independent subsidiary&quot; of Intel, indeed:<p><a href="https:&#x2F;&#x2F;www.linutronix.de&#x2F;company&#x2F;history.php" rel="nofollow">https:&#x2F;&#x2F;www.linutronix.de&#x2F;company&#x2F;history.php</a></div><br/></div></div></div></div><div id="41598108" class="c"><input type="checkbox" id="c-41598108" checked=""/><div class="controls bullet"><span class="by">femto</span><span>|</span><a href="#41598983">prev</a><span>|</span><a href="#41597259">next</a><span>|</span><label class="collapse" for="c-41598108">[-]</label><label class="expand" for="c-41598108">[10 more]</label></div><br/><div class="children"><div class="content">If you want to see the effect of the real-time kernel, build and run the cyclictest utility from the Linux Foundation.<p><a href="https:&#x2F;&#x2F;wiki.linuxfoundation.org&#x2F;realtime&#x2F;documentation&#x2F;howto&#x2F;tools&#x2F;cyclictest&#x2F;start" rel="nofollow">https:&#x2F;&#x2F;wiki.linuxfoundation.org&#x2F;realtime&#x2F;documentation&#x2F;howt...</a><p>It measures and displays the interrupt latency for each CPU core.  Without the real-time patch, worst case latency can be double digit milliseconds.  With the real-time patch, worst case drops to single digit microseconds.  (To get consistently low latency you will also have to turn off any power saving states, as a transition between sleep states can hog the CPU, despite the RT kernel.)  Cyclictest is an important tool if you&#x27;re doing real-time with Linux.<p>As an example, if you&#x27;re doing processing for software defined radio, it&#x27;s the difference between the system occasionally having &quot;blips&quot; and the system having rock solid performance, doing what it is supposed to every time.  With the real time kernel in place, I find I can do acid-test things, like running GNOME and libreoffice on the same laptop as an SDR, and the SDR doesn&#x27;t skip a beat.  Without the real-time kernel it would be dropping packets all over the place.</div><br/><div id="41598273" class="c"><input type="checkbox" id="c-41598273" checked=""/><div class="controls bullet"><span class="by">aero-glide2</span><span>|</span><a href="#41598108">parent</a><span>|</span><a href="#41599870">next</a><span>|</span><label class="collapse" for="c-41598273">[-]</label><label class="expand" for="c-41598273">[7 more]</label></div><br/><div class="children"><div class="content">Interestingly, whenever I touch my touchpad, the worst case latency shoots up 20x, even with RT patch. What could be causing this?
And this is always on core 5.</div><br/><div id="41598718" class="c"><input type="checkbox" id="c-41598718" checked=""/><div class="controls bullet"><span class="by">femto</span><span>|</span><a href="#41598108">root</a><span>|</span><a href="#41598273">parent</a><span>|</span><a href="#41598674">next</a><span>|</span><label class="collapse" for="c-41598718">[-]</label><label class="expand" for="c-41598718">[3 more]</label></div><br/><div class="children"><div class="content">Perhaps the code associated with the touchpad has a priority greater than that you used to run cyclictest (80?). Does it still happen if you boost the priority of cyclictest to the highest possible, using the option:<p>--priority=99<p>Apply priority 99 with care to your own code.  A tight endless loop with priority 99 will override pretty well everything else, so about the only way to escape will be to turn your computer off.  Been there, done that :-)</div><br/><div id="41599699" class="c"><input type="checkbox" id="c-41599699" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#41598108">root</a><span>|</span><a href="#41598718">parent</a><span>|</span><a href="#41598674">next</a><span>|</span><label class="collapse" for="c-41599699">[-]</label><label class="expand" for="c-41599699">[2 more]</label></div><br/><div class="children"><div class="content">The most important is to set the policy, described in sched(7), rather than the priority.<p>Notice that without setting the priority, default policy is other, which is the standard one most processes get unless they request else.<p>By setting priority (while not specifying policy), the policy becomes fifo, the highest, which is meant to give the cpu immediately and not preempt until process releases it.<p>This implicit change in policy is why you see such brutal effect from setting priority.</div><br/><div id="41600077" class="c"><input type="checkbox" id="c-41600077" checked=""/><div class="controls bullet"><span class="by">femto</span><span>|</span><a href="#41598108">root</a><span>|</span><a href="#41599699">parent</a><span>|</span><a href="#41598674">next</a><span>|</span><label class="collapse" for="c-41600077">[-]</label><label class="expand" for="c-41600077">[1 more]</label></div><br/><div class="children"><div class="content">Thanks.</div><br/></div></div></div></div></div></div><div id="41598674" class="c"><input type="checkbox" id="c-41598674" checked=""/><div class="controls bullet"><span class="by">angus-g</span><span>|</span><a href="#41598108">root</a><span>|</span><a href="#41598273">parent</a><span>|</span><a href="#41598718">prev</a><span>|</span><a href="#41598986">next</a><span>|</span><label class="collapse" for="c-41598674">[-]</label><label class="expand" for="c-41598674">[2 more]</label></div><br/><div class="children"><div class="content">Maybe a PS&#x2F;2 touchpad that is triggering (a bunch of) interrupts? Not sure how hardware interrupts work with RT!</div><br/><div id="41598945" class="c"><input type="checkbox" id="c-41598945" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#41598108">root</a><span>|</span><a href="#41598674">parent</a><span>|</span><a href="#41598986">next</a><span>|</span><label class="collapse" for="c-41598945">[-]</label><label class="expand" for="c-41598945">[1 more]</label></div><br/><div class="children"><div class="content">One of the features of PREEMPT_RT is that it converts interrupt handlers to running in their own threads (with some exceptions, I believe), instead of being tacked on top of whatever thread context was active at the time like with the softirq approach the &quot;normal&quot; kernel uses. This allows the scheduler to better decide what should run (e.g. your RT process rather than serving interrupts for downloading cat pictures).</div><br/></div></div></div></div><div id="41598986" class="c"><input type="checkbox" id="c-41598986" checked=""/><div class="controls bullet"><span class="by">monero-xmr</span><span>|</span><a href="#41598108">root</a><span>|</span><a href="#41598273">parent</a><span>|</span><a href="#41598674">prev</a><span>|</span><a href="#41599870">next</a><span>|</span><label class="collapse" for="c-41598986">[-]</label><label class="expand" for="c-41598986">[1 more]</label></div><br/><div class="children"><div class="content">Touchpad support very poor in Linux. I use System76 and the touchpad is always a roll of the dice with every kernel upgrade, despite it being a &quot;good&quot; distro &#x2F; vendor</div><br/></div></div></div></div><div id="41599870" class="c"><input type="checkbox" id="c-41599870" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#41598108">parent</a><span>|</span><a href="#41598273">prev</a><span>|</span><a href="#41597259">next</a><span>|</span><label class="collapse" for="c-41599870">[-]</label><label class="expand" for="c-41599870">[2 more]</label></div><br/><div class="children"><div class="content">Quiet reminder that &quot;real-time&quot; is almost best considered &quot;consistent-time&quot;.<p>The problem space is such that it doesn&#x27;t necessarily mean &quot;faster&quot; or lower latency in any way, just that where there is latency: it&#x27;s consistent.</div><br/><div id="41599906" class="c"><input type="checkbox" id="c-41599906" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41598108">root</a><span>|</span><a href="#41599870">parent</a><span>|</span><a href="#41597259">next</a><span>|</span><label class="collapse" for="c-41599906">[-]</label><label class="expand" for="c-41599906">[1 more]</label></div><br/><div class="children"><div class="content">consistent as in reliably bounded that is.</div><br/></div></div></div></div></div></div><div id="41597259" class="c"><input type="checkbox" id="c-41597259" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41598108">prev</a><span>|</span><a href="#41596562">next</a><span>|</span><label class="collapse" for="c-41597259">[-]</label><label class="expand" for="c-41597259">[14 more]</label></div><br/><div class="children"><div class="content">Without the RT patchset, I can run one or two instruments at a 3ms latency, if I don&#x27;t do anything else at all on my computer.<p>With it, I routinely have 6 instruments at 1ms, while having dozens of chrome windows open and playing 3d shooters without issue.<p>It&#x27;s shocking how much difference it makes over the regular (non-rt) low latency scheduler.</div><br/><div id="41597945" class="c"><input type="checkbox" id="c-41597945" checked=""/><div class="controls bullet"><span class="by">nixosbestos</span><span>|</span><a href="#41597259">parent</a><span>|</span><a href="#41597391">next</a><span>|</span><label class="collapse" for="c-41597945">[-]</label><label class="expand" for="c-41597945">[6 more]</label></div><br/><div class="children"><div class="content">Wait, so should casual desktop Linux users try this out too? I assumed there must be some trade-off to using RT?</div><br/><div id="41598154" class="c"><input type="checkbox" id="c-41598154" checked=""/><div class="controls bullet"><span class="by">femto</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41597945">parent</a><span>|</span><a href="#41598192">next</a><span>|</span><label class="collapse" for="c-41598154">[-]</label><label class="expand" for="c-41598154">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s every so slightly slower, but the difference is negligible and won&#x27;t be noticed on a desktop machine.  These days, I just run the (Debian) real-time kernel as a matter of course on my everyday machine.<p>I haven&#x27;t objectively tested it, but my feeling is that it actually makes for a nicer user experience.  Sometimes Gnome can briefly freeze or feel sluggish (presumably the CPU is off doing something) and I feel that the RT kernel does away with this.  It could be a placebo effect though.</div><br/></div></div><div id="41598192" class="c"><input type="checkbox" id="c-41598192" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41597945">parent</a><span>|</span><a href="#41598154">prev</a><span>|</span><a href="#41598312">next</a><span>|</span><label class="collapse" for="c-41598192">[-]</label><label class="expand" for="c-41598192">[3 more]</label></div><br/><div class="children"><div class="content">Not really any harm in trying, but definitely note that the trail marked âtrying scheduler changes to see if it improves desktop performanceâ is strewn with skeletons, the ghosts thereof haunt audio forums sayings things like â[ghostly] oooooohhhh, the sound is so much clearer now that I put vibration dampeners under my usb audio interfaceâ.<p>The reason I wrote my original comment is precisely because âaudio xruns at a higher latency with lower system loadâ is a very concrete measure of improvement that I can&#x27;t fool myself about, including effects like âthe system runs better when freshly booted for a whileâ that otherwise bias the judgements of the uninitiated towards ââ¦and therefore the new kernel improved things!â<p>There isn&#x27;t much on a desktop that is sensitive to latency spikes on the order of a couple ms, which a stock kernel should already be able to maintain.</div><br/><div id="41599706" class="c"><input type="checkbox" id="c-41599706" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41598192">parent</a><span>|</span><a href="#41598312">next</a><span>|</span><label class="collapse" for="c-41599706">[-]</label><label class="expand" for="c-41599706">[2 more]</label></div><br/><div class="children"><div class="content">It can literally sound better (objectively).<p>Suppose your audio server attempts fancy resampling, but falls back to a crude approximation after the first xrun.</div><br/><div id="41600018" class="c"><input type="checkbox" id="c-41600018" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41599706">parent</a><span>|</span><a href="#41598312">next</a><span>|</span><label class="collapse" for="c-41600018">[-]</label><label class="expand" for="c-41600018">[1 more]</label></div><br/><div class="children"><div class="content">Theoretically possible, but show me a sound server that automatically drops resampling quality instead of just increasing the buffer size.</div><br/></div></div></div></div></div></div><div id="41598312" class="c"><input type="checkbox" id="c-41598312" checked=""/><div class="controls bullet"><span class="by">bityard</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41597945">parent</a><span>|</span><a href="#41598192">prev</a><span>|</span><a href="#41597391">next</a><span>|</span><label class="collapse" for="c-41598312">[-]</label><label class="expand" for="c-41598312">[1 more]</label></div><br/><div class="children"><div class="content">The trade off is reduced throughput. How much depends a lot on the system and workload.</div><br/></div></div></div></div><div id="41597391" class="c"><input type="checkbox" id="c-41597391" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#41597259">parent</a><span>|</span><a href="#41597945">prev</a><span>|</span><a href="#41597405">next</a><span>|</span><label class="collapse" for="c-41597391">[-]</label><label class="expand" for="c-41597391">[3 more]</label></div><br/><div class="children"><div class="content">6 instruments at 1ms, that&#x27;s great!  Are these MIDI instruments or audio in?  A bit off-topic, but out of curiosity (and desperation), do you use any (and&#x2F;or can recommend) some VST instruments for Linux?<p>Do you experience any downsides running the RT scheduler?</div><br/><div id="41597811" class="c"><input type="checkbox" id="c-41597811" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41597391">parent</a><span>|</span><a href="#41597405">next</a><span>|</span><label class="collapse" for="c-41597811">[-]</label><label class="expand" for="c-41597811">[2 more]</label></div><br/><div class="children"><div class="content">Nothing specific to the RT scheduler that I&#x27;ve noticed; there is a constant overhead from the audio stuff, but that&#x27;s because of the workload (enabled by RT), not because of the RT itself.<p>My usual setup has 2 PianoTeq (physically modelled piano&#x2F;electric piano&#x2F;clavinet) instances, 3 SurgeXT instances (standard synthesizer), a setBfree (Tonewheel&#x2F;hammond simulator) instance, and a handful of sequencers and similar for drums, as well as a bunch of routing and compressors and such.</div><br/><div id="41599062" class="c"><input type="checkbox" id="c-41599062" checked=""/><div class="controls bullet"><span class="by">darkwater</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41597811">parent</a><span>|</span><a href="#41597405">next</a><span>|</span><label class="collapse" for="c-41599062">[-]</label><label class="expand" for="c-41599062">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, what music do you compose? How would you judge the Linux experience doing so, outside the RT topic?<p>Do you have any published music you will to share?<p>Thanks!</div><br/></div></div></div></div></div></div><div id="41597405" class="c"><input type="checkbox" id="c-41597405" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#41597259">parent</a><span>|</span><a href="#41597391">prev</a><span>|</span><a href="#41596562">next</a><span>|</span><label class="collapse" for="c-41597405">[-]</label><label class="expand" for="c-41597405">[4 more]</label></div><br/><div class="children"><div class="content">Is there a noticeable difference in performance in the less latency sensitive stuff? (e.g. lower fps in the games)</div><br/><div id="41597807" class="c"><input type="checkbox" id="c-41597807" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41597405">parent</a><span>|</span><a href="#41597700">next</a><span>|</span><label class="collapse" for="c-41597807">[-]</label><label class="expand" for="c-41597807">[1 more]</label></div><br/><div class="children"><div class="content">GPU-bound stuff is largely unaffected; CPU-bound definitely takes a hit (although there&#x27;s no noticeable additional latency on non-RT tasks), but that&#x27;s kinda to be expected.</div><br/></div></div><div id="41597700" class="c"><input type="checkbox" id="c-41597700" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41597259">root</a><span>|</span><a href="#41597405">parent</a><span>|</span><a href="#41597807">prev</a><span>|</span><a href="#41597473">next</a><span>|</span><label class="collapse" for="c-41597700">[-]</label><label class="expand" for="c-41597700">[1 more]</label></div><br/><div class="children"><div class="content">I would not expect lower FPS, because the amount of available CPU does not materially change. I would expect higher latency, because RT threads would more often scheduled ahead of other threads.</div><br/></div></div></div></div></div></div><div id="41596562" class="c"><input type="checkbox" id="c-41596562" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#41597259">prev</a><span>|</span><a href="#41596727">next</a><span>|</span><label class="collapse" for="c-41596562">[-]</label><label class="expand" for="c-41596562">[23 more]</label></div><br/><div class="children"><div class="content">Are there any good resources on how this kind of real-time programming is done?<p>What goes into ensuring that a program is actually realtime? Are there formal proofs, or just experience and &quot;vibes&quot;? Is realtime coding any different from normal coding? How do modern CPU architectures, which have a lot of non-constant time instructions, branch prediction, potential for cache misses and such play into this?</div><br/><div id="41596882" class="c"><input type="checkbox" id="c-41596882" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41596927">next</a><span>|</span><label class="collapse" for="c-41596882">[-]</label><label class="expand" for="c-41596882">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; What goes into ensuring that a program is actually realtime?</i><p>Realtime mostly means predictable runtime for code. As long as its predictable, you can scale the CPU&#x2F;microcontroller to fit your demands or optimize your code to fit the constraints. Itâs about making sure your code can always respond in time to hardware inputs, timers, and other interrupts.<p>Generally the Linux kernelâs scheduling makes the system very unpredictable. RT linux tries to address that along with several other subsystems. On embedded CPUs this usually means disabling advanced features like cache, branch prediction, and speculative execution (although I donât remember if RT handles that part since its very vendor specific).</div><br/><div id="41599190" class="c"><input type="checkbox" id="c-41599190" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41596882">parent</a><span>|</span><a href="#41596927">next</a><span>|</span><label class="collapse" for="c-41599190">[-]</label><label class="expand" for="c-41599190">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Responding in time&quot; here means meeting a hard deadline under any circumstances, no matter what else may be going on simultaneously. The counterintuitive part is that this about worst case, not best case or average case. So you might not want a fancy algorithm in that code path that has insanely good average runtime, but a tiny chance to blow up, but rather one that is slower on average, but has tight bounded worst case performance.<p>Example: you&#x27;d probably want the airbags in your car to fire precisely at the right time to catch you and keep you safe rather than blow up in your face too late and give you a nasty neck injury in addition to the other injuries you&#x27;ll likely get in a hard enough crash.</div><br/></div></div></div></div><div id="41596927" class="c"><input type="checkbox" id="c-41596927" checked=""/><div class="controls bullet"><span class="by">juliangmp</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41596882">prev</a><span>|</span><a href="#41597911">next</a><span>|</span><label class="collapse" for="c-41596927">[-]</label><label class="expand" for="c-41596927">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not hugely experienced in the field personally, but from what I&#x27;ve seen, actually proving hard real time capabilities is rather involved.
If something is safety critical (think break systems, avionic computers, etc.) it likely means you also need some special certification or even formal verification. And (correct me if I&#x27;m wrong) I don&#x27;t think you&#x27;ll want to use a Linux kernel, even with the preempt rt patches. 
I&#x27;d say specialized rt operating systems, like FreeRTOS or Zephyr, would be more fitting (though I don&#x27;t have direct experience with them).<p>As for the hardware, you can&#x27;t really use a âregularâ CPU and expect completely deterministic behavior. The things you mentioned (and for example caching) absolutely impact this. 
iirc amd&#x2F;xilinx actually offer a processor that has both regular arm cores, alongside some arm real time cores for these exact reasons.</div><br/></div></div><div id="41597911" class="c"><input type="checkbox" id="c-41597911" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41596927">prev</a><span>|</span><a href="#41597736">next</a><span>|</span><label class="collapse" for="c-41597911">[-]</label><label class="expand" for="c-41597911">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s only one a few projects I know of that provide formal proofs wrt their real time guarantees; sel4 being the only public example.<p>That being said, vibes and kiss principle can get you remarkably far.</div><br/></div></div><div id="41597736" class="c"><input type="checkbox" id="c-41597736" checked=""/><div class="controls bullet"><span class="by">wheels</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41597911">prev</a><span>|</span><a href="#41596856">next</a><span>|</span><label class="collapse" for="c-41597736">[-]</label><label class="expand" for="c-41597736">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some difference between user space and kernel.  I don&#x27;t have much experience in the kernel, but I feel like it&#x27;s more about making sure tasks are preemptable.<p>In user space it&#x27;s often about complexity and guarantees:  for example, you really try not to do mallocs in a real-time thread in user space, because it&#x27;s a system call that will only return in an unpredictable amount of time.  Better to preallocate buffers or use the stack.  Same for opening files, or stuff like that -- you want to avoid variable time syscalls and do them at thread &#x2F; application setup.<p>Choice of algorithms needs to be such that for whatever <i>n</i> you&#x27;re working with, that it can be processed inside of one sample generation interal.  I&#x27;m mostly familiar with audio -- e.g. if you&#x27;re generating audio at 44100 Hz, you need your algorithms to be able to process chunks in less than 22 microseconds.</div><br/><div id="41600064" class="c"><input type="checkbox" id="c-41600064" checked=""/><div class="controls bullet"><span class="by">dgan</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41597736">parent</a><span>|</span><a href="#41599731">next</a><span>|</span><label class="collapse" for="c-41600064">[-]</label><label class="expand" for="c-41600064">[1 more]</label></div><br/><div class="children"><div class="content">How do you handle runtime - defined sizes then? Just preallocate maximum possible number of bytes?</div><br/></div></div><div id="41599731" class="c"><input type="checkbox" id="c-41599731" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41597736">parent</a><span>|</span><a href="#41600064">prev</a><span>|</span><a href="#41596856">next</a><span>|</span><label class="collapse" for="c-41599731">[-]</label><label class="expand" for="c-41599731">[2 more]</label></div><br/><div class="children"><div class="content">Real-time performance is not really possible in userspace unless your kernel is kept in the loop, because preemption can happen at any time.</div><br/><div id="41600020" class="c"><input type="checkbox" id="c-41600020" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41599731">parent</a><span>|</span><a href="#41596856">next</a><span>|</span><label class="collapse" for="c-41600020">[-]</label><label class="expand" for="c-41600020">[1 more]</label></div><br/><div class="children"><div class="content">I guess we really have to add whether it is soft or hard realtime we are talking about. The former can be done in userspace (e.g. video games), the latter probably need a custom OS (I donât think rt-linux is good for actual hard realtime stuff)</div><br/></div></div></div></div></div></div><div id="41596856" class="c"><input type="checkbox" id="c-41596856" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41597736">prev</a><span>|</span><a href="#41599430">next</a><span>|</span><label class="collapse" for="c-41596856">[-]</label><label class="expand" for="c-41596856">[7 more]</label></div><br/><div class="children"><div class="content">For things like VxWorks, it&#x27;s mostly vibes and setting priority between processes. But there are other ways. You can &quot;offline schedule&quot; your tasks, i.e. you run a scheduler at compile time which decides all possible supported orderings and how long slots each task can run.<p>Then, there&#x27;s the whole thing of hardware. Do you have one or more cores? If you have more than one core, can they introduce jitter or slowdown to each other accessing memory? And so on and so forth.</div><br/><div id="41597174" class="c"><input type="checkbox" id="c-41597174" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41596856">parent</a><span>|</span><a href="#41596902">next</a><span>|</span><label class="collapse" for="c-41597174">[-]</label><label class="expand" for="c-41597174">[4 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s mostly vibes and setting priority between processes<p>I&#x27;m laughing so so hard right now. Thanks for, among other things, confirming for me that there isn&#x27;t some magic tool that I&#x27;m missing :). At least I have the benefit of working on softer real-time systems where missing a deadline might result in lower quality data but there&#x27;s no lives at risk.<p>Setting and clearing GPIOs on task entry&#x2F;exit are a nice touch for verification too.</div><br/><div id="41597768" class="c"><input type="checkbox" id="c-41597768" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41597174">parent</a><span>|</span><a href="#41596902">next</a><span>|</span><label class="collapse" for="c-41597768">[-]</label><label class="expand" for="c-41597768">[3 more]</label></div><br/><div class="children"><div class="content">Magic? Well, here&#x27;s some: predictably fast interrupts, critical sections where you code cannot be preempted, but with a watchdog so if your code hits an infinite loop it&#x27;s restarted, no unpredictable memory allocation delays, no unexpected page fault delays, things like that.<p>These are relatively easy to obtain on an MCU, where there&#x27;s no virtual memory, physical memory is predictable (if slow), interrupt hardware is simple, hardware watchdogs are a norm, an normally there&#x27;s no need for preemptive multitasking.<p>But when you try to make it work in a kernel that supports VMM, kernel &#x2F; userland privilege separation, user sessions separation, process separation, preemptive multitasking, and has to work on hardware with a really complex bus and a complex interrupt controller, â well, here&#x27;s where <i>magic</i> begins.</div><br/><div id="41599112" class="c"><input type="checkbox" id="c-41599112" checked=""/><div class="controls bullet"><span class="by">aulin</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41597768">parent</a><span>|</span><a href="#41598497">next</a><span>|</span><label class="collapse" for="c-41599112">[-]</label><label class="expand" for="c-41599112">[1 more]</label></div><br/><div class="children"><div class="content">VMM is one of the few things I really miss while working in embedded. I would happily trade off memory allocation errors from fragmented heap with some unpredictable malloc delay (which could be maybe mitigated with some timeout?).</div><br/></div></div><div id="41598497" class="c"><input type="checkbox" id="c-41598497" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41597768">parent</a><span>|</span><a href="#41599112">prev</a><span>|</span><a href="#41596902">next</a><span>|</span><label class="collapse" for="c-41598497">[-]</label><label class="expand" for="c-41598497">[1 more]</label></div><br/><div class="children"><div class="content">That first paragraph is where I fortunately get to live most of the time :D</div><br/></div></div></div></div></div></div><div id="41596902" class="c"><input type="checkbox" id="c-41596902" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41596856">parent</a><span>|</span><a href="#41597174">prev</a><span>|</span><a href="#41599430">next</a><span>|</span><label class="collapse" for="c-41596902">[-]</label><label class="expand" for="c-41596902">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you have more than one core, can they introduce jitter or slowdown to each other accessing memory?<p>DMA and fancy peripherals like UART, SPI etc, could be namedropped in this regard, too.</div><br/><div id="41597796" class="c"><input type="checkbox" id="c-41597796" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41596902">parent</a><span>|</span><a href="#41599430">next</a><span>|</span><label class="collapse" for="c-41597796">[-]</label><label class="expand" for="c-41597796">[1 more]</label></div><br/><div class="children"><div class="content">Plot twist: the very memory may be connected via SPI.</div><br/></div></div></div></div></div></div><div id="41599430" class="c"><input type="checkbox" id="c-41599430" checked=""/><div class="controls bullet"><span class="by">8bitsrule</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41596856">prev</a><span>|</span><a href="#41596740">next</a><span>|</span><label class="collapse" for="c-41599430">[-]</label><label class="expand" for="c-41599430">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wondering whether this is done in a way that&#x27;s similar to the way old 8-bit machines did with &#x27;vectored interrupts&#x27;?<p>(That was very handy for handling incoming data bits to get finished bytes safely stashed before the next bit arrived at the hardware. Been a -long time- since  I heard VI&#x27;s mentioned.)</div><br/></div></div><div id="41596740" class="c"><input type="checkbox" id="c-41596740" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41599430">prev</a><span>|</span><a href="#41597775">next</a><span>|</span><label class="collapse" for="c-41596740">[-]</label><label class="expand" for="c-41596740">[2 more]</label></div><br/><div class="children"><div class="content">On all the real time systems I&#x27;ve worked on, it has just been empirical measurements of cpu load for the different task periods and a good enough margin to overruns.<p>On an ECU I worked on, the cache was turned off to not have cache misses ... no cache no problem. I argued it should be turned on and the &quot;OK cpu load&quot; limit decreased instead. But nope.<p>I wouldn&#x27;t say there is any conceptual difference from normal coding, except for that you&#x27;d want to be kinda sure algorithms terminate in a reasonable time in a time constrained task. More online algorithms than normally, though.<p>Most of the strangeness in real time coding is actually about doing control theory stuff is my take. The program often feels like state-machine going in a circle.</div><br/><div id="41597208" class="c"><input type="checkbox" id="c-41597208" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41596562">root</a><span>|</span><a href="#41596740">parent</a><span>|</span><a href="#41597775">next</a><span>|</span><label class="collapse" for="c-41597208">[-]</label><label class="expand" for="c-41597208">[1 more]</label></div><br/><div class="children"><div class="content">&gt; On an ECU I worked on, the cache was turned off to not have cache misses ... no cache no problem. I argued it should be turned on and the &quot;OK cpu load&quot; limit decreased instead. But nope.<p>Yeah, the tradeoff there is interesting. Sometimes &quot;get it as deterministic as possible&quot; is the right answer, even if it&#x27;s slower.<p>&gt; Most of the strangeness in real time coding is actually about doing control theory stuff is my take. The program often feels like state-machine going in a circle.<p>Lol, with my colleagues&#x2F;juniors I&#x27;ll often encourage them to take code that doesn&#x27;t look like that and figure out if there&#x27;s a sane way to turn it into &quot;state-machine going in a circle&quot;. For problems that fit that mold, being able to say &quot;event X in state Y will have effect Z&quot; is really powerful for being able to reason about the system. Plus, sometimes, you can actually use that state machine to more formally reason about it or even informally just draw out the states, events, and transitions and identify if there&#x27;s anywhere you might get stuck.</div><br/></div></div></div></div><div id="41597775" class="c"><input type="checkbox" id="c-41597775" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41596740">prev</a><span>|</span><a href="#41598386">next</a><span>|</span><label class="collapse" for="c-41597775">[-]</label><label class="expand" for="c-41597775">[1 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;www.rossbencina.com&#x2F;code&#x2F;real-time-audio-programming-101-time-waits-for-nothing" rel="nofollow">http:&#x2F;&#x2F;www.rossbencina.com&#x2F;code&#x2F;real-time-audio-programming-...</a><p>Audio-centric, but will you give a feel for what&#x27;s involved.</div><br/></div></div><div id="41598386" class="c"><input type="checkbox" id="c-41598386" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41597775">prev</a><span>|</span><a href="#41596859">next</a><span>|</span><label class="collapse" for="c-41598386">[-]</label><label class="expand" for="c-41598386">[1 more]</label></div><br/><div class="children"><div class="content">In a modern architecture you have to allow for the worst possible performance. Most real-time software doesn&#x27;t interact with the world at modern cpu time scales. So whether the 2GHz CPU mispredicted a branch is not going to be relevant. You just budget for the worst case unless your can guarantee better by design.</div><br/></div></div><div id="41596859" class="c"><input type="checkbox" id="c-41596859" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41598386">prev</a><span>|</span><a href="#41597894">next</a><span>|</span><label class="collapse" for="c-41596859">[-]</label><label class="expand" for="c-41596859">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t break the electrical equipment&#x2F;motor&#x2F;armature&#x2F;process it&#x27;s hooked up to.<p>In rt land, you test in prod and hope for the best.</div><br/></div></div><div id="41597894" class="c"><input type="checkbox" id="c-41597894" checked=""/><div class="controls bullet"><span class="by">chasd00</span><span>|</span><a href="#41596562">parent</a><span>|</span><a href="#41596859">prev</a><span>|</span><a href="#41596727">next</a><span>|</span><label class="collapse" for="c-41597894">[-]</label><label class="expand" for="c-41597894">[1 more]</label></div><br/><div class="children"><div class="content">If you can count the clock cycles it takes to execute your code and itâs the same every time then itâs realtime.</div><br/></div></div></div></div><div id="41596727" class="c"><input type="checkbox" id="c-41596727" checked=""/><div class="controls bullet"><span class="by">alangibson</span><span>|</span><a href="#41596562">prev</a><span>|</span><a href="#41599032">next</a><span>|</span><label class="collapse" for="c-41596727">[-]</label><label class="expand" for="c-41596727">[18 more]</label></div><br/><div class="children"><div class="content">This is big for the CNC community. RT is a must have, and this makes builds that much easier.</div><br/><div id="41596828" class="c"><input type="checkbox" id="c-41596828" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#41596727">parent</a><span>|</span><a href="#41598503">next</a><span>|</span><label class="collapse" for="c-41596828">[-]</label><label class="expand" for="c-41596828">[15 more]</label></div><br/><div class="children"><div class="content">Why use Linux for that though? Why not build the machine like a 3D printer, with a dedicated microcontroller that doesn&#x27;t even run an OS and has completely predicable timing, and a separate non-RT Linux system for the GUI?</div><br/><div id="41596999" class="c"><input type="checkbox" id="c-41596999" checked=""/><div class="controls bullet"><span class="by">juliangmp</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41596828">parent</a><span>|</span><a href="#41597311">next</a><span>|</span><label class="collapse" for="c-41596999">[-]</label><label class="expand" for="c-41596999">[4 more]</label></div><br/><div class="children"><div class="content">I feel like Klippers approach is fairly reasonable, let an non-RT system (that generally has better performance than your micro controller) calculate the movement but leave the actual commanding of the stepper motors to the micro controller.</div><br/><div id="41597242" class="c"><input type="checkbox" id="c-41597242" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41596999">parent</a><span>|</span><a href="#41597311">next</a><span>|</span><label class="collapse" for="c-41597242">[-]</label><label class="expand" for="c-41597242">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, I looked at Klipper a few months ago and really liked what I saw. Haven&#x27;t had a chance to try it out yet but like you say they seem to have nailed the interface boundary between &quot;things that should run fast&quot; (on an embedded computer) and &quot;things that need precise timing&quot; (on a microcontroller).<p>One thing to keep in mind for people looking at the RT patches and thinking about things like this: these patches allow you to do RT processing on Linux, but they don&#x27;t make some of the complexity go away. In the Klipper case, for example, writing to the GPIOs that actually send the signals to the steppers motors in Linux is relatively complex. You&#x27;re usually making a write() syscall that&#x27;s going through the VFS layer etc. to finally get to the actual pin register. On a microcontroller you can write directly to the pin register and know exactly how many clock cycles that operation is going to take.<p>I&#x27;ve seen embedded Linux code that actually opened &#x2F;dev&#x2F;mem and did the same thing, writing directly to GPIO registers... and that is horrifying :)</div><br/><div id="41597890" class="c"><input type="checkbox" id="c-41597890" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41597242">parent</a><span>|</span><a href="#41597311">next</a><span>|</span><label class="collapse" for="c-41597890">[-]</label><label class="expand" for="c-41597890">[2 more]</label></div><br/><div class="children"><div class="content">At the same time, RT permits some more offload to the computer.<p>More effort can be devoted to microsecond-level concerns if the microprocessor can have a 1ms buffer of instructions reliably provided by the computer, vs if it has to be prepared to be on its own for hundreds of ms.</div><br/><div id="41598446" class="c"><input type="checkbox" id="c-41598446" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41597890">parent</a><span>|</span><a href="#41597311">next</a><span>|</span><label class="collapse" for="c-41598446">[-]</label><label class="expand" for="c-41598446">[1 more]</label></div><br/><div class="children"><div class="content">Totally! Iâm pumped for this in general, just want people to remember itâs not a silver bullet.</div><br/></div></div></div></div></div></div></div></div><div id="41597311" class="c"><input type="checkbox" id="c-41597311" checked=""/><div class="controls bullet"><span class="by">bubaumba</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41596828">parent</a><span>|</span><a href="#41596999">prev</a><span>|</span><a href="#41599008">next</a><span>|</span><label class="collapse" for="c-41597311">[-]</label><label class="expand" for="c-41597311">[8 more]</label></div><br/><div class="children"><div class="content">I played with it years ago, but it&#x27;s still alive and well<p><pre><code>    http:&#x2F;&#x2F;linuxcnc.org&#x2F;
</code></pre>
These days not sure, hard to find computer with parallel port. Combined version with microcontroller like raspberry pico (which costs &lt; $10) should be the right way to do it. Hard real time, WiFi remote for cheap. Then computer doesn&#x27;t need to be fat or realtime, almost anything, including smartphone.</div><br/><div id="41599015" class="c"><input type="checkbox" id="c-41599015" checked=""/><div class="controls bullet"><span class="by">alangibson</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41597311">parent</a><span>|</span><a href="#41597419">next</a><span>|</span><label class="collapse" for="c-41599015">[-]</label><label class="expand" for="c-41599015">[1 more]</label></div><br/><div class="children"><div class="content">Most people use LinuxCNC with cards from Mesa now. They have various versions for Ethernet, direct connect to Raspberry Pi GPIO, etc.</div><br/></div></div><div id="41597419" class="c"><input type="checkbox" id="c-41597419" checked=""/><div class="controls bullet"><span class="by">RockRobotRock</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41597311">parent</a><span>|</span><a href="#41599015">prev</a><span>|</span><a href="#41597724">next</a><span>|</span><label class="collapse" for="c-41597419">[-]</label><label class="expand" for="c-41597419">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;youtu.be&#x2F;FEPfznStd0s" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;FEPfznStd0s</a><p>Marco Reps has some entertaining and informative videos on LinuxCNC with EtherCAT</div><br/></div></div><div id="41597724" class="c"><input type="checkbox" id="c-41597724" checked=""/><div class="controls bullet"><span class="by">GeorgeTirebiter</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41597311">parent</a><span>|</span><a href="#41597419">prev</a><span>|</span><a href="#41599008">next</a><span>|</span><label class="collapse" for="c-41597724">[-]</label><label class="expand" for="c-41597724">[5 more]</label></div><br/><div class="children"><div class="content">USB to Parallel are common.  so, easy.</div><br/><div id="41597903" class="c"><input type="checkbox" id="c-41597903" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41597724">parent</a><span>|</span><a href="#41599008">next</a><span>|</span><label class="collapse" for="c-41597903">[-]</label><label class="expand" for="c-41597903">[4 more]</label></div><br/><div class="children"><div class="content">A ârealâ parallel port provides interrupts on each individual data line of the port, _much_ lower latency than a USB dongle can provide.  Microseconds vs milliseconds.</div><br/><div id="41598401" class="c"><input type="checkbox" id="c-41598401" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41597903">parent</a><span>|</span><a href="#41598293">next</a><span>|</span><label class="collapse" for="c-41598401">[-]</label><label class="expand" for="c-41598401">[2 more]</label></div><br/><div class="children"><div class="content">A standard PC parallel port does not provide interrupts on data lines.<p>The difference is more that you can control those output lines with really low latency and guaranteed timing. USB has a protocol layer that is less deterministic. So if you need to generate a step signal for a stepper motor e.g. you can bit bang it a lot more accurately through a direct parallel port than a USB to parallel adapter (which is really designed for printing through USB and has very different set of requirements).</div><br/><div id="41598427" class="c"><input type="checkbox" id="c-41598427" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41598401">parent</a><span>|</span><a href="#41598293">next</a><span>|</span><label class="collapse" for="c-41598427">[-]</label><label class="expand" for="c-41598427">[1 more]</label></div><br/><div class="children"><div class="content">Are you sure about that?   I&#x27;d have bet money that the input lines have an interrupt assigned, and googling seems to agree.</div><br/></div></div></div></div><div id="41598293" class="c"><input type="checkbox" id="c-41598293" checked=""/><div class="controls bullet"><span class="by">bubaumba</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41597903">parent</a><span>|</span><a href="#41598401">prev</a><span>|</span><a href="#41599008">next</a><span>|</span><label class="collapse" for="c-41598293">[-]</label><label class="expand" for="c-41598293">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s possible do to it all on raspberry pico. Having pico doing low level driving and javascript in browser taking high level, feeding pico and providing UI. That would be close to perfect solution</div><br/></div></div></div></div></div></div></div></div><div id="41599008" class="c"><input type="checkbox" id="c-41599008" checked=""/><div class="controls bullet"><span class="by">alangibson</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41596828">parent</a><span>|</span><a href="#41597311">prev</a><span>|</span><a href="#41598503">next</a><span>|</span><label class="collapse" for="c-41599008">[-]</label><label class="expand" for="c-41599008">[2 more]</label></div><br/><div class="children"><div class="content">Because LinuxCNC runs on Linux. It&#x27;s an incredibly capable CNC controller.</div><br/><div id="41600031" class="c"><input type="checkbox" id="c-41600031" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41599008">parent</a><span>|</span><a href="#41598503">next</a><span>|</span><label class="collapse" for="c-41600031">[-]</label><label class="expand" for="c-41600031">[1 more]</label></div><br/><div class="children"><div class="content">I mean yeah, but the more I know about computers the less I like the idea of it.<p>On a PC you have millions of lines of kernel code, BIOS&#x2F;EFI code, firmware, etc. You have complex video card drivers, complex storage devices. You have the SMM that yanks control away from the OS whenever it pleases.<p>The idea of running a dangerous machine controlled by that mess is frankly scary.</div><br/></div></div></div></div></div></div><div id="41598503" class="c"><input type="checkbox" id="c-41598503" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41596727">parent</a><span>|</span><a href="#41596828">prev</a><span>|</span><a href="#41599032">next</a><span>|</span><label class="collapse" for="c-41598503">[-]</label><label class="expand" for="c-41598503">[2 more]</label></div><br/><div class="children"><div class="content">linuxcnc aka emc2 runs linux under a real-time hypervisor, and so doesn&#x27;t need these patches, which i <i>believe</i> (and correct me if i&#x27;m wrong) aim at guaranteed response time around a millisecond, rather than the microseconds delivered by linuxcnc<p>(disclaimer: i&#x27;ve never run linuxcnc)<p>but nowadays usually people do the hard real-time stuff on a microcontroller or fpga.  amd64 processors have gotten worse and worse at hard-real-time stuff over the last 30 years, they don&#x27;t come with parallel ports anymore (or any gpios), and microcontrollers have gotten much faster, much bigger, much easier to program and debug, and much cheaper.  even fpgas have gotten cheaper and easier<p>there&#x27;s not much reason nowadays to try to do your hard-real-time processing on a desktop computer with caches, virtual memory, shitty device drivers, shitty hardware you can&#x27;t control, and a timesharing operating system<p>the interrupt processing jitter on an avr is one clock cycle normally, and i think the total interrupt latency is about 8 cycles before you can toggle a gpio.  that&#x27;s a guaranteed response time around 500 nanoseconds if you clock it at 16 megahertz. you are never going to get close to that with a userland process on linux, or probably anything on an amd64 cpu, and nowadays avr is a slow microcontroller.  things like raspberry pi pico pioasm, padauk fppa, and especially fpgas can do a lot better than that<p>(disclaimer: though i have done hard-real-time processing on an avr, i haven&#x27;t done it on the other platforms mentioned, and i didn&#x27;t even write the interrupt handlers, just the background c++. i did have to debug with an oscilloscope though)</div><br/><div id="41598984" class="c"><input type="checkbox" id="c-41598984" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#41596727">root</a><span>|</span><a href="#41598503">parent</a><span>|</span><a href="#41599032">next</a><span>|</span><label class="collapse" for="c-41598984">[-]</label><label class="expand" for="c-41598984">[1 more]</label></div><br/><div class="children"><div class="content">&gt; linuxcnc aka emc2 runs linux under a real-time hypervisor<p>Historically it used RTAI; now everyone is moving to preempt-rt.  The install image is now preempt-rt.<p>I&#x27;ve been on the flipside where you&#x27;re streaming g-code from something that isn&#x27;t hard-realtime to the realtime system.  You can be surprised and let the realtime system starve, and linuxcnc does a lot more than you can fit onto a really small controller.  (In particular, the way you can have fairly complicated kinematics defined in a data-driven way lets you do cool stuff).<p>Today my large milling machine is on a windows computer + GRBL; but I&#x27;m probably going to become impatient and go to linuxcnc.</div><br/></div></div></div></div></div></div><div id="41599032" class="c"><input type="checkbox" id="c-41599032" checked=""/><div class="controls bullet"><span class="by">kristoffer</span><span>|</span><a href="#41596727">prev</a><span>|</span><a href="#41596167">next</a><span>|</span><label class="collapse" for="c-41599032">[-]</label><label class="expand" for="c-41599032">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Torvalds wrote the original code for printk, a debugging tool that can pinpoint exact moments where a process crashes&quot;<p>A debugging tool? I do like printk debugging but I am not sure about that description :-)</div><br/></div></div><div id="41596167" class="c"><input type="checkbox" id="c-41596167" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#41599032">prev</a><span>|</span><a href="#41597342">next</a><span>|</span><label class="collapse" for="c-41596167">[-]</label><label class="expand" for="c-41596167">[1 more]</label></div><br/><div class="children"><div class="content">[dupe]<p>More discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41584907">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41584907</a></div><br/></div></div><div id="41597342" class="c"><input type="checkbox" id="c-41597342" checked=""/><div class="controls bullet"><span class="by">glhaynes</span><span>|</span><a href="#41596167">prev</a><span>|</span><a href="#41598282">next</a><span>|</span><label class="collapse" for="c-41597342">[-]</label><label class="expand" for="c-41597342">[3 more]</label></div><br/><div class="children"><div class="content">Very cool! How is this &quot;turned on&quot;? Compile-time&#x2F;boot-time option? Or just a matter of having processes running in the system that have requested timeslice&#x2F;latency guarantees?</div><br/><div id="41597916" class="c"><input type="checkbox" id="c-41597916" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#41597342">parent</a><span>|</span><a href="#41597463">next</a><span>|</span><label class="collapse" for="c-41597916">[-]</label><label class="expand" for="c-41597916">[1 more]</label></div><br/><div class="children"><div class="content">Kernel compiled with the option enabled (vs needing to apply the patches yourself and compile, so much easier for a distribution to provide as an option), and then the usual scheduler tools (process requesting realtime permissions, or a user running schedtool&#x2F;chrt&#x2F;whatever to run&#x2F;change the scheduling class for processes).</div><br/></div></div><div id="41597463" class="c"><input type="checkbox" id="c-41597463" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#41597342">parent</a><span>|</span><a href="#41597916">prev</a><span>|</span><a href="#41598282">next</a><span>|</span><label class="collapse" for="c-41597463">[-]</label><label class="expand" for="c-41597463">[1 more]</label></div><br/><div class="children"><div class="content">there is an option in menuconfig to turn on preempt_rt,need rebuild kernel</div><br/></div></div></div></div><div id="41598282" class="c"><input type="checkbox" id="c-41598282" checked=""/><div class="controls bullet"><span class="by">AzzyHN</span><span>|</span><a href="#41597342">prev</a><span>|</span><a href="#41597717">next</a><span>|</span><label class="collapse" for="c-41598282">[-]</label><label class="expand" for="c-41598282">[3 more]</label></div><br/><div class="children"><div class="content">For a desktop user, what&#x27;s the downside to using a realtime kernel vs the standard one?</div><br/><div id="41599013" class="c"><input type="checkbox" id="c-41599013" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#41598282">parent</a><span>|</span><a href="#41598980">next</a><span>|</span><label class="collapse" for="c-41599013">[-]</label><label class="expand" for="c-41599013">[1 more]</label></div><br/><div class="children"><div class="content">Good question. And what&#x27;s the benfit? A common misconception is that RT is fast. The truth is it&#x27;s more predictable, high priority work gets done before low priority. But who has set the correct priorities for a desktop system? I guess the answer is nobody for most of system so what works better and what worse is &quot;unpredictable&quot; again.<p>Should audio be prioritized over the touchpad &quot;moving&quot; the cursor?</div><br/></div></div><div id="41598980" class="c"><input type="checkbox" id="c-41598980" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#41598282">parent</a><span>|</span><a href="#41599013">prev</a><span>|</span><a href="#41597717">next</a><span>|</span><label class="collapse" for="c-41598980">[-]</label><label class="expand" for="c-41598980">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s going to be slower, as in lower throughput, due to more locking and scheduling overhead in the kernel. Less scalable too, although on a desktop you probably don&#x27;t have enough CPU cores for that to have much of an effect.<p>I presume most drivers haven&#x27;t been tested in RT mode, so it&#x27;s possible that RT-specific driver bugs crash your system.</div><br/></div></div></div></div><div id="41597717" class="c"><input type="checkbox" id="c-41597717" checked=""/><div class="controls bullet"><span class="by">GeorgeTirebiter</span><span>|</span><a href="#41598282">prev</a><span>|</span><a href="#41596511">next</a><span>|</span><label class="collapse" for="c-41597717">[-]</label><label class="expand" for="c-41597717">[1 more]</label></div><br/><div class="children"><div class="content">What is the time from a GPIO transition to when the 1st instruction of my service routine executes?</div><br/></div></div><div id="41596047" class="c"><input type="checkbox" id="c-41596047" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41596511">prev</a><span>|</span><a href="#41596741">next</a><span>|</span><label class="collapse" for="c-41596047">[-]</label><label class="expand" for="c-41596047">[2 more]</label></div><br/><div class="children"><div class="content">Sounds exciting.  Anyone recommend a good place to read what the nuances of these patches are?  The zdnet link about the best, at the moment?</div><br/><div id="41597325" class="c"><input type="checkbox" id="c-41597325" checked=""/><div class="controls bullet"><span class="by">bubaumba</span><span>|</span><a href="#41596047">parent</a><span>|</span><a href="#41596741">next</a><span>|</span><label class="collapse" for="c-41597325">[-]</label><label class="expand" for="c-41597325">[1 more]</label></div><br/><div class="children"><div class="content">there should be some strict requirements, proprietary video drivers can ruin it all, my guess.</div><br/></div></div></div></div><div id="41596741" class="c"><input type="checkbox" id="c-41596741" checked=""/><div class="controls bullet"><span class="by">jovial_cavalier</span><span>|</span><a href="#41596047">prev</a><span>|</span><a href="#41597226">next</a><span>|</span><label class="collapse" for="c-41596741">[-]</label><label class="expand" for="c-41596741">[4 more]</label></div><br/><div class="children"><div class="content">A few months ago, I played around with a contemporary build of preempt_rt to see if it was at the point where I could replace xenomai. My requirement is to be able to wake up on a timer with an interval of less than 350 us and do some work with low jitter. I wrote a simple task that just woke up every 350us and wrote down the time. It managed to do it once every 700us.<p>I don&#x27;t believe they&#x27;ve actually made the kernel completely preemptive, though others can correct me. This means that you cannot achieve the same realtime performance with this as you could with a mesa kernel like xenomai.</div><br/><div id="41596752" class="c"><input type="checkbox" id="c-41596752" checked=""/><div class="controls bullet"><span class="by">chris_va</span><span>|</span><a href="#41596741">parent</a><span>|</span><a href="#41597226">next</a><span>|</span><label class="collapse" for="c-41596752">[-]</label><label class="expand" for="c-41596752">[3 more]</label></div><br/><div class="children"><div class="content">Did you pin the kernel to its own core?</div><br/><div id="41597974" class="c"><input type="checkbox" id="c-41597974" checked=""/><div class="controls bullet"><span class="by">jovial_cavalier</span><span>|</span><a href="#41596741">root</a><span>|</span><a href="#41596752">parent</a><span>|</span><a href="#41597226">next</a><span>|</span><label class="collapse" for="c-41597974">[-]</label><label class="expand" for="c-41597974">[2 more]</label></div><br/><div class="children"><div class="content">single-core system.</div><br/><div id="41598862" class="c"><input type="checkbox" id="c-41598862" checked=""/><div class="controls bullet"><span class="by">shaklee3</span><span>|</span><a href="#41596741">root</a><span>|</span><a href="#41597974">parent</a><span>|</span><a href="#41597226">next</a><span>|</span><label class="collapse" for="c-41598862">[-]</label><label class="expand" for="c-41598862">[1 more]</label></div><br/><div class="children"><div class="content">You may need to modify the jiffy frequency</div><br/></div></div></div></div></div></div></div></div><div id="41597226" class="c"><input type="checkbox" id="c-41597226" checked=""/><div class="controls bullet"><span class="by">dewlinedew2</span><span>|</span><a href="#41596741">prev</a><span>|</span><a href="#41596077">next</a><span>|</span><label class="collapse" for="c-41597226">[-]</label><label class="expand" for="c-41597226">[1 more]</label></div><br/><div class="children"><div class="content">Hooray!</div><br/></div></div></div></div></div></div></div></body></html>