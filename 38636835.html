<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702544459156" as="style"/><link rel="stylesheet" href="styles.css?v=1702544459156"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/rfjakob/earlyoom">Earlyoom – Early OOM Daemon for Linux</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>harporoeder</span> | <span>17 comments</span></div><br/><div><div id="38638182" class="c"><input type="checkbox" id="c-38638182" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38638902">next</a><span>|</span><label class="collapse" for="c-38638182">[-]</label><label class="expand" for="c-38638182">[1 more]</label></div><br/><div class="children"><div class="content">Does this handle cgroups such that it would know to kill chrome even though each individual tab is only using a little bit? Could be mistaken but looking for the single largest process can be misleading if you’re dealing with applications that have forked a ton of processes…</div><br/></div></div><div id="38638902" class="c"><input type="checkbox" id="c-38638902" checked=""/><div class="controls bullet"><span class="by">ecef9-8c0f-4374</span><span>|</span><a href="#38638182">prev</a><span>|</span><a href="#38638307">next</a><span>|</span><label class="collapse" for="c-38638902">[-]</label><label class="expand" for="c-38638902">[1 more]</label></div><br/><div class="children"><div class="content">I use it on a 4GB PI in combination with XSuspender.
It has its drawbacks, but works surprisingly well.<p>XSuspender - Automatically suspend inactive X11 applications
When an application window loses focus, XSuspender tries to match it to one of the rules in its configuration. If a match is found, the application is sent a SIGSTOP signal (preventing the process from obtaining further CPU time). Upon windows regaining focus, the process is seamlessly continued where it had left off.</div><br/></div></div><div id="38638307" class="c"><input type="checkbox" id="c-38638307" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#38638902">prev</a><span>|</span><a href="#38638444">next</a><span>|</span><label class="collapse" for="c-38638307">[-]</label><label class="expand" for="c-38638307">[1 more]</label></div><br/><div class="children"><div class="content">I have taken to running this anytime I start a jupyter notebook using more than a trivial amount of data. It has only fired off a couple of times, but I have been grateful for the safety net.<p>Anytime I can consume my 64G of ram, I was probably doing something stupid anyway.</div><br/></div></div><div id="38638444" class="c"><input type="checkbox" id="c-38638444" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#38638307">prev</a><span>|</span><a href="#38638512">next</a><span>|</span><label class="collapse" for="c-38638444">[-]</label><label class="expand" for="c-38638444">[6 more]</label></div><br/><div class="children"><div class="content">If you want stuff to die inexplicably, use this! (I used to, bad idea)</div><br/><div id="38638491" class="c"><input type="checkbox" id="c-38638491" checked=""/><div class="controls bullet"><span class="by">harporoeder</span><span>|</span><a href="#38638444">parent</a><span>|</span><a href="#38638460">next</a><span>|</span><label class="collapse" for="c-38638491">[-]</label><label class="expand" for="c-38638491">[2 more]</label></div><br/><div class="children"><div class="content">I would prefer a process on my desktop be killed rather than my system become unusable to the point of requiring a hard reset of the machine as is common on Linux systems during low memory scenarios.</div><br/><div id="38639302" class="c"><input type="checkbox" id="c-38639302" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#38638444">root</a><span>|</span><a href="#38638491">parent</a><span>|</span><a href="#38638460">next</a><span>|</span><label class="collapse" for="c-38639302">[-]</label><label class="expand" for="c-38639302">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never had an OOM on Linux requiring a hard reset, but you do need some patience for the kernel&#x27;s OOM killer to kick in – up to a minute or two, perhaps even a bit bit longer (I never timed it exactly).</div><br/></div></div></div></div><div id="38638460" class="c"><input type="checkbox" id="c-38638460" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#38638444">parent</a><span>|</span><a href="#38638491">prev</a><span>|</span><a href="#38638512">next</a><span>|</span><label class="collapse" for="c-38638460">[-]</label><label class="expand" for="c-38638460">[3 more]</label></div><br/><div class="children"><div class="content">Does it has to be inexplicably? Is there any reason the OOM Daemon can&#x27;t nicely prompt you about what process they just killed? Or even ask you if you want to kill, similar to how Firefox will ask you if you want to kill a misbehaving tab?</div><br/><div id="38638598" class="c"><input type="checkbox" id="c-38638598" checked=""/><div class="controls bullet"><span class="by">Santosh83</span><span>|</span><a href="#38638444">root</a><span>|</span><a href="#38638460">parent</a><span>|</span><a href="#38638512">next</a><span>|</span><label class="collapse" for="c-38638598">[-]</label><label class="expand" for="c-38638598">[2 more]</label></div><br/><div class="children"><div class="content">I guess they could attempt to do so, but under extremely severe low memory conditions, the prompt (especially if its graphical) has a good chance of not reaching the user&#x27;s screen in any reasonable time. That&#x27;s why it has to decide without external I&#x2F;O.</div><br/><div id="38638620" class="c"><input type="checkbox" id="c-38638620" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#38638444">root</a><span>|</span><a href="#38638598">parent</a><span>|</span><a href="#38638512">next</a><span>|</span><label class="collapse" for="c-38638620">[-]</label><label class="expand" for="c-38638620">[1 more]</label></div><br/><div class="children"><div class="content">You can suspend a process, drop some caches, and even swap them to disk, if the memory approaches critical levels, or better yet, you can set a watermark that suspend the process and prompts you before it gets to that.</div><br/></div></div></div></div></div></div></div></div><div id="38638512" class="c"><input type="checkbox" id="c-38638512" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#38638444">prev</a><span>|</span><a href="#38637145">next</a><span>|</span><label class="collapse" for="c-38638512">[-]</label><label class="expand" for="c-38638512">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn’t this suck for power on laptops? Doing something at a fixed frequency (especially as high as 10Hz) will cause CPU wake ups where previously you wouldn’t need any. Say goodbye to your battery life.</div><br/><div id="38639249" class="c"><input type="checkbox" id="c-38639249" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#38638512">parent</a><span>|</span><a href="#38637145">next</a><span>|</span><label class="collapse" for="c-38639249">[-]</label><label class="expand" for="c-38639249">[1 more]</label></div><br/><div class="children"><div class="content">For an awake power state you almost certainly have at least one core waking up more frequently than 10Hz just to handle poking devices like the GPU. HW power management (such as through wait for interrupt instructions) operate on a much smaller time scale and so you wouldn&#x27;t really be perturbing anything on a real interactive system.</div><br/></div></div></div></div><div id="38637145" class="c"><input type="checkbox" id="c-38637145" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38638512">prev</a><span>|</span><label class="collapse" for="c-38637145">[-]</label><label class="expand" for="c-38637145">[5 more]</label></div><br/><div class="children"><div class="content">Why this and not Meta&#x27;s oomd?</div><br/><div id="38638108" class="c"><input type="checkbox" id="c-38638108" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#38637145">parent</a><span>|</span><a href="#38638008">next</a><span>|</span><label class="collapse" for="c-38638108">[-]</label><label class="expand" for="c-38638108">[3 more]</label></div><br/><div class="children"><div class="content">Or systemd&#x27;s systemd-oomd <a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;15206">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;15206</a><p>The answer for both of those is &quot;if you&#x27;re unfortunate enough to be running a 2.6 kernel linux server from 2005, then you can&#x27;t use cgroupsv2 and thus can&#x27;t use oomd or systemd-oomd&quot;.<p>That is the only thing earlyoom is good for at this point I think, is old systems without cgroupsv2</div><br/><div id="38638422" class="c"><input type="checkbox" id="c-38638422" checked=""/><div class="controls bullet"><span class="by">mgrandl</span><span>|</span><a href="#38637145">root</a><span>|</span><a href="#38638108">parent</a><span>|</span><a href="#38638008">next</a><span>|</span><label class="collapse" for="c-38638422">[-]</label><label class="expand" for="c-38638422">[2 more]</label></div><br/><div class="children"><div class="content">Actually no there are other reasons. Meta oomd requires you to have swap enabled, which makes it a non-starter for us. systemd-oomd has its own set of drawbacks. We evaluated all options at length and earlyoom came out as the clear winner for our usecase.</div><br/><div id="38638571" class="c"><input type="checkbox" id="c-38638571" checked=""/><div class="controls bullet"><span class="by">circularfoyers</span><span>|</span><a href="#38637145">root</a><span>|</span><a href="#38638422">parent</a><span>|</span><a href="#38638008">next</a><span>|</span><label class="collapse" for="c-38638571">[-]</label><label class="expand" for="c-38638571">[1 more]</label></div><br/><div class="children"><div class="content">Why weren&#x27;t you using swap?</div><br/></div></div></div></div></div></div><div id="38638008" class="c"><input type="checkbox" id="c-38638008" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38637145">parent</a><span>|</span><a href="#38638108">prev</a><span>|</span><label class="collapse" for="c-38638008">[-]</label><label class="expand" for="c-38638008">[1 more]</label></div><br/><div class="children"><div class="content">Or Android’s lmkd?</div><br/></div></div></div></div></div></div></div></div></div></body></html>