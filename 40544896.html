<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717405251202" as="style"/><link rel="stylesheet" href="styles.css?v=1717405251202"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://concurrencyfreaks.blogspot.com/2023/12/why-is-snapshot-isolation-not-enough.html">Why is Snapshot Isolation not enough?</a> <span class="domain">(<a href="http://concurrencyfreaks.blogspot.com">concurrencyfreaks.blogspot.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>23 comments</span></div><br/><div><div id="40557789" class="c"><input type="checkbox" id="c-40557789" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40557618">next</a><span>|</span><label class="collapse" for="c-40557789">[-]</label><label class="expand" for="c-40557789">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a typo, clearly the second transaction is removing C and not D as stated.<p>&gt; The first transaction modifies fields in records A and C, while the second transaction modifies fields in records B and D.<p>&gt; Under Snapshot Isolation both transactions will commit, which means that the doubly linked list will be left in an inconsistent state<p>That&#x27;s not how the DB we use works[1]. Both transactions will run, but as soon as either touches a row the other has already modified it will raise an &quot;Update conflict on snapshot transaction&quot; error. If the first transaction races the second, the second will be blocked on the row&#x27;s write lock until the first is committed, and then raise the same error.<p>And yes, I verified this just now, and I verified the connections are running snapshot isolation.<p>So does SQLAnywhere not implement the standard way?<p>[1]: <a href="https:&#x2F;&#x2F;infocenter.sybase.com&#x2F;help&#x2F;index.jsp?topic=&#x2F;com.sybase.help.sqlanywhere.12.0.1&#x2F;dbusage&#x2F;transact-s-4136352.html" rel="nofollow">https:&#x2F;&#x2F;infocenter.sybase.com&#x2F;help&#x2F;index.jsp?topic=&#x2F;com.syba...</a> (old version but hasn&#x27;t changed)</div><br/><div id="40559773" class="c"><input type="checkbox" id="c-40559773" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#40557789">parent</a><span>|</span><a href="#40557618">next</a><span>|</span><label class="collapse" for="c-40559773">[-]</label><label class="expand" for="c-40559773">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Both transactions will run, but as soon as either touches a row the other has already modified […]<p>The whole point of this scenario is that this never happens. The two writes touch unrelated sets of rows. There’s no point where they both try to modify the same row and a conflict is observed.</div><br/></div></div></div></div><div id="40557618" class="c"><input type="checkbox" id="c-40557618" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40557789">prev</a><span>|</span><a href="#40559353">next</a><span>|</span><label class="collapse" for="c-40557618">[-]</label><label class="expand" for="c-40557618">[3 more]</label></div><br/><div class="children"><div class="content">The problem with all of these examples is that it’s using a model of Snapshot Isolation which guarantees writes don’t conflict, but doesn’t provide a similar guarantee for reads. What you really want is the pair of constraints:<p>- Anything I write hasn’t been concurrently written to by another transaction<p>- (added): Anything I read also hasn’t been concurrently written to by another transaction<p>Adding “conflicting reads” fixes every single example in this post. The linked list example can be fixed in any number of ways. The most efficient might be to “spread out” the set of conflicting keys to also include the next &#x2F; prev pointers of the deleted items b and c. This makes the transactions conflict. Or maybe better - include all the next pointers of all items before the modified item. This adds an implicit guarantee that the visited &#x2F; modified item must be in the list for the transaction to be successfully committed.<p>Now, adding reads to the conflict set might change SI into a different concurrency model. The blog post does use the same definition as Wikipedia. And that definition only mentions writes. But I think any SI system can be made to work this way by setting X = X for any value read during each transaction.<p>The “two threads” example becomes this:<p><pre><code>    beginTxn();
      if (x == 0 &amp;&amp; y == 0) x = 1;
      x = x; y = y; &#x2F;&#x2F; implicit
    endTxn();
 
    beginTxn();
      if (x == 0 &amp;&amp; y == 0) y = 1;
      x = x; y = y;
    endTxn();
</code></pre>
And the two transactions will function correctly.<p>Having the database handle this for you is best because:<p>- Humans will forget<p>- If two transactions read some value but neither transaction writes to it, the two transactions don’t actually need to conflict. This is too strict.<p>Foundationdb in my opinion has the best API for this I’ve seen. Reads and writes within a transaction are tracked like this automatically, and you can manually add, remove or change the set of conflicting keys using an explicit api if you want to. But I’m sure it’s not alone.</div><br/><div id="40557765" class="c"><input type="checkbox" id="c-40557765" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#40557618">parent</a><span>|</span><a href="#40558356">next</a><span>|</span><label class="collapse" for="c-40557765">[-]</label><label class="expand" for="c-40557765">[1 more]</label></div><br/><div class="children"><div class="content">I think most databases have some method of turning your Reads into Write locks without needing to actually do a write.<p>Like SELECT FOR UPDATE.</div><br/></div></div><div id="40558356" class="c"><input type="checkbox" id="c-40558356" checked=""/><div class="controls bullet"><span class="by">senderista</span><span>|</span><a href="#40557618">parent</a><span>|</span><a href="#40557765">prev</a><span>|</span><a href="#40559353">next</a><span>|</span><label class="collapse" for="c-40558356">[-]</label><label class="expand" for="c-40558356">[1 more]</label></div><br/><div class="children"><div class="content">You actually don&#x27;t need the first constraint at all for serializability: see &quot;A Critique of Snapshot Isolation&quot;<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2405.18393" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2405.18393</a></div><br/></div></div></div></div><div id="40559353" class="c"><input type="checkbox" id="c-40559353" checked=""/><div class="controls bullet"><span class="by">sixtram</span><span>|</span><a href="#40557618">prev</a><span>|</span><a href="#40558545">next</a><span>|</span><label class="collapse" for="c-40559353">[-]</label><label class="expand" for="c-40559353">[2 more]</label></div><br/><div class="children"><div class="content">I always liked Jim Gray&#x27;s marbles example to demonstrate the problem with snapshot isolation, so much easy to understand:<p><a href="https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;t5&#x2F;sql-server-blog&#x2F;serializable-vs-snapshot-isolation-level&#x2F;ba-p&#x2F;383281" rel="nofollow">https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;t5&#x2F;sql-server-blog&#x2F;seria...</a></div><br/><div id="40560005" class="c"><input type="checkbox" id="c-40560005" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#40559353">parent</a><span>|</span><a href="#40558545">next</a><span>|</span><label class="collapse" for="c-40560005">[-]</label><label class="expand" for="c-40560005">[1 more]</label></div><br/><div class="children"><div class="content">This should be the standard way of explaining tx isolation, very intuitive!</div><br/></div></div></div></div><div id="40558545" class="c"><input type="checkbox" id="c-40558545" checked=""/><div class="controls bullet"><span class="by">rvdginste</span><span>|</span><a href="#40559353">prev</a><span>|</span><a href="#40557405">next</a><span>|</span><label class="collapse" for="c-40558545">[-]</label><label class="expand" for="c-40558545">[1 more]</label></div><br/><div class="children"><div class="content">I really like to work with snapshot isolation and rarely have any problems with it, but you do have to be aware what guarantees it gives and does not give.<p>In the example given in the article, there would not be a problem if the links on the removed node would be reset (which is cleaner imho) as then an update conflict would be triggered.<p>When using snapshot isolation, I sometimes implement ‘dummy’ updates (using a version field for example) on ‘root’ objects to trigger update conflicts when concurrent updates must be prevented to data linked to that same ‘root’ object. (This is similar to implementing optimistic locking using a version field on a root object.)</div><br/></div></div><div id="40557405" class="c"><input type="checkbox" id="c-40557405" checked=""/><div class="controls bullet"><span class="by">ko_pivot</span><span>|</span><a href="#40558545">prev</a><span>|</span><a href="#40557444">next</a><span>|</span><label class="collapse" for="c-40557405">[-]</label><label class="expand" for="c-40557405">[1 more]</label></div><br/><div class="children"><div class="content">This is so well explained. Cockroachdb implements serializable by default and it is a great experience being able to write sql with that in mind.</div><br/></div></div><div id="40557444" class="c"><input type="checkbox" id="c-40557444" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#40557405">prev</a><span>|</span><a href="#40557163">next</a><span>|</span><label class="collapse" for="c-40557444">[-]</label><label class="expand" for="c-40557444">[1 more]</label></div><br/><div class="children"><div class="content">It’s the ABA problem that also comes up with normal multithreading when trying to go lock free. Lock free data structures are hard. SI is giving you the same guarantees (your update is atomic, but things might have changed between when you read and when you write). If you can handle this extra complexity, all good, but it’s generally something that needs to be carefully abstracted. Nobody wants to be thinking this hard every time they have to interact with a DB.</div><br/></div></div><div id="40557163" class="c"><input type="checkbox" id="c-40557163" checked=""/><div class="controls bullet"><span class="by">belter</span><span>|</span><a href="#40557444">prev</a><span>|</span><a href="#40557211">next</a><span>|</span><label class="collapse" for="c-40557163">[-]</label><label class="expand" for="c-40557163">[1 more]</label></div><br/><div class="children"><div class="content">Related: &quot;A Critique of Snapshot Isolation&quot; - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40516582">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40516582</a></div><br/></div></div><div id="40557211" class="c"><input type="checkbox" id="c-40557211" checked=""/><div class="controls bullet"><span class="by">Max-Ganz-II</span><span>|</span><a href="#40557163">prev</a><span>|</span><a href="#40557264">next</a><span>|</span><label class="collapse" for="c-40557211">[-]</label><label class="expand" for="c-40557211">[3 more]</label></div><br/><div class="children"><div class="content">Amazon Redshift very recently has made this the default choice.</div><br/><div id="40557333" class="c"><input type="checkbox" id="c-40557333" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#40557211">parent</a><span>|</span><a href="#40557264">next</a><span>|</span><label class="collapse" for="c-40557333">[-]</label><label class="expand" for="c-40557333">[2 more]</label></div><br/><div class="children"><div class="content">Mssql on azure also has READ_COMMITTED_SNAPSHOT (server level setting, default ON on Azure SQL Database, default OFF on SQL Server &lt;&lt;wtf?&gt;&gt;). When ON, it transparently changes your explicilty specified isolation level in query&#x2F;transaction of &quot;READ COMMITTED&quot; to &quot;READ COMMITTED SNAPSHIT&quot; (genuine typo made here, decided to not correct) instead. Good luck fixing your prod incident when locally you&#x27;re using mssql docker image (default OFF).<p>If you want to say &quot;just use their edge mssql container image&quot;, yeah man – mssql&#x2F;azure sql databse&#x2F;mssql docker all support JSON_PATH_EXISTS, edge sql docker doesn&#x27;t so that&#x27;s it for better compatiblity.<p>What a mess.</div><br/><div id="40557532" class="c"><input type="checkbox" id="c-40557532" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#40557211">root</a><span>|</span><a href="#40557333">parent</a><span>|</span><a href="#40557264">next</a><span>|</span><label class="collapse" for="c-40557532">[-]</label><label class="expand" for="c-40557532">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft loves to make their support matrix look like a random tapestry.</div><br/></div></div></div></div></div></div><div id="40557264" class="c"><input type="checkbox" id="c-40557264" checked=""/><div class="controls bullet"><span class="by">_3u10</span><span>|</span><a href="#40557211">prev</a><span>|</span><label class="collapse" for="c-40557264">[-]</label><label class="expand" for="c-40557264">[8 more]</label></div><br/><div class="children"><div class="content">It’s enough, just make sure you’re not trying to fly an airplane or prevent the detonation of nuclear weapons using a database, it’s the wrong tool for the job.<p>If you’re storing doubly linked lists in a DB you’re doing it wrong.<p>Updating doubly linked lists can be done at about 200 million ops&#x2F;sec, single threaded, not sure why you need multiple threads updating the list at the same time, exactly what are you doing that can&#x27;t be solved by putting a ring buffer in front of a single thread that updates the values, doesn&#x27;t need locks and is cache coherent.</div><br/><div id="40558020" class="c"><input type="checkbox" id="c-40558020" checked=""/><div class="controls bullet"><span class="by">bradleyjg</span><span>|</span><a href="#40557264">parent</a><span>|</span><a href="#40557366">next</a><span>|</span><label class="collapse" for="c-40558020">[-]</label><label class="expand" for="c-40558020">[1 more]</label></div><br/><div class="children"><div class="content"><i>It’s enough, just make sure you’re not trying to fly an airplane or prevent the detonation of nuclear weapons using a database, it’s the wrong tool for the job.</i><p>Your intuition should be the opposite. You should always reach for correctness first and only sacrifice it after careful consideration when performance demands require it.</div><br/></div></div><div id="40557366" class="c"><input type="checkbox" id="c-40557366" checked=""/><div class="controls bullet"><span class="by">roncesvalles</span><span>|</span><a href="#40557264">parent</a><span>|</span><a href="#40558020">prev</a><span>|</span><a href="#40557615">next</a><span>|</span><label class="collapse" for="c-40557366">[-]</label><label class="expand" for="c-40557366">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It’s enough, just make sure you’re not trying to fly an airplane or prevent the detonation of nuclear weapons<p>My gripe with this kind of argument is that <i>today, you aren&#x27;t</i>. You can write application-side duct tape to deal with any kind of wonky database situation, but the whole point of having a database with strong and easy-to-reason guarantees is that it makes future development easier.</div><br/></div></div><div id="40557615" class="c"><input type="checkbox" id="c-40557615" checked=""/><div class="controls bullet"><span class="by">sam_bishop</span><span>|</span><a href="#40557264">parent</a><span>|</span><a href="#40557366">prev</a><span>|</span><a href="#40557570">next</a><span>|</span><label class="collapse" for="c-40557615">[-]</label><label class="expand" for="c-40557615">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you’re storing doubly linked lists in a DB you’re doing it wrong.<p>Assuming that the database uses B+ trees (like most do), then the database records themselves are very likely to be in a doubly linked list.<p>Not every doubly linked list is the kind you see in an introductory data structures class.</div><br/><div id="40560332" class="c"><input type="checkbox" id="c-40560332" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#40557264">root</a><span>|</span><a href="#40557615">parent</a><span>|</span><a href="#40557570">next</a><span>|</span><label class="collapse" for="c-40560332">[-]</label><label class="expand" for="c-40560332">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this. Because of this, I saw substantial data corruption that had built up over years in live medical databases: The on-disk B+trees had corrupted internal links due to incorrect handling of concurrent updates and rollbacks. This made some queries return incorrect results.<p>The developers had been writing messy heuristic workarounds for database low-level corruption in application code for over a decade, instead of figuring out the cause and fixing that.<p>For example, application code had special routines to attempt to detect and ignore duplicate records in some queries (but not others), in response to customer bug reports, but of course that didn&#x27;t fix missing records or make the data correct. It just patched over an observed symptom. It also didn&#x27;t fix all the places it could happen, so much of the application still had occasional flaky behaviour, but not consistently enough to be reported in detail and get the (bad) workarounds to hide it.<p>Correctly implemented transactions are very helpful for database internals and on-disk structures too, not just for the API level presented to applications.</div><br/></div></div></div></div><div id="40557570" class="c"><input type="checkbox" id="c-40557570" checked=""/><div class="controls bullet"><span class="by">bsaul</span><span>|</span><a href="#40557264">parent</a><span>|</span><a href="#40557615">prev</a><span>|</span><a href="#40557598">next</a><span>|</span><label class="collapse" for="c-40557570">[-]</label><label class="expand" for="c-40557570">[1 more]</label></div><br/><div class="children"><div class="content">OP provides even more simple examples than double linked lists. It made me realize how pg default isolation level was actually quite a nice footgun and reread the doc about the various isolation levels much more carefully.</div><br/></div></div><div id="40557598" class="c"><input type="checkbox" id="c-40557598" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#40557264">parent</a><span>|</span><a href="#40557570">prev</a><span>|</span><a href="#40558459">next</a><span>|</span><label class="collapse" for="c-40557598">[-]</label><label class="expand" for="c-40557598">[1 more]</label></div><br/><div class="children"><div class="content">Good luck troubleshooting why your data is subtly (or not-so-subtly) corrupt when the database transactions that started the problem occurred months previously, because the guarantees were too loose&#x2F;not well-understood.</div><br/></div></div><div id="40558459" class="c"><input type="checkbox" id="c-40558459" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40557264">parent</a><span>|</span><a href="#40557598">prev</a><span>|</span><label class="collapse" for="c-40558459">[-]</label><label class="expand" for="c-40558459">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s enough<p>Surrender consistency only in the gravest of necessity.<p>No one likes their data corrupted.</div><br/></div></div></div></div></div></div></div></div></div></body></html>