<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709974863926" as="style"/><link rel="stylesheet" href="styles.css?v=1709974863926"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/hatchet-dev/hatchet">Show HN: Hatchet – Open-source distributed task queue</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>abelanger</span> | <span>109 comments</span></div><br/><div><div id="39643991" class="c"><input type="checkbox" id="c-39643991" checked=""/><div class="controls bullet"><span class="by">kcorbitt</span><span>|</span><a href="#39650329">next</a><span>|</span><label class="collapse" for="c-39643991">[-]</label><label class="expand" for="c-39643991">[20 more]</label></div><br/><div class="children"><div class="content">I love your vision and am excited to see the execution! I&#x27;ve been looking for <i>exactly</i> this product (postgres-backed task queue with workers in multiple languages and decent built-in observability) for like... 3 years. Every 6 months I&#x27;ll check in and see if someone has built it yet, evaluate the alternatives, and come away disappointed.<p>One important feature request that probably would block our adoption: one reason why I prefer a postgres-backed queue over eg. Redis is just to simplify our infra by having fewer servers and technologies in the stack. Adding in RabbitMQ is definitely an extra dependency I&#x27;d really like to avoid.<p>(Currently we&#x27;ve settled on graphile-worker which is fine for what it does, but leaves a lot of boxes unchecked.)</div><br/><div id="39647059" class="c"><input type="checkbox" id="c-39647059" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#39643991">parent</a><span>|</span><a href="#39644137">next</a><span>|</span><label class="collapse" for="c-39647059">[-]</label><label class="expand" for="c-39647059">[2 more]</label></div><br/><div class="children"><div class="content">Funny how this is vision now. I started my career 29 years ago at a company that build exactly this, but based on oracle. The agents would run on Solaris, aix, vax vms, hpux, windows nt, iris, etc. Was also used to create an automated cicd pipeline to build all binaries on all these different systems.</div><br/><div id="39650305" class="c"><input type="checkbox" id="c-39650305" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39647059">parent</a><span>|</span><a href="#39644137">next</a><span>|</span><label class="collapse" for="c-39650305">[-]</label><label class="expand" for="c-39650305">[1 more]</label></div><br/><div class="children"><div class="content">Also basically has existed as an open source (pro version has web dashboard and complex task zoo) drop-in library (no sidecar dependencies outside of postgres) in Elixir for years called Oban.</div><br/></div></div></div></div><div id="39644137" class="c"><input type="checkbox" id="c-39644137" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39643991">parent</a><span>|</span><a href="#39647059">prev</a><span>|</span><a href="#39647179">next</a><span>|</span><label class="collapse" for="c-39644137">[-]</label><label class="expand" for="c-39644137">[3 more]</label></div><br/><div class="children"><div class="content">Thank you, appreciate the kind words! What boxes are you looking to check?<p>Yes, I&#x27;m not a fan of the RabbitMQ dependency either - see here for the reasoning: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39643940">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39643940</a>.<p>It would take some work to replace this with listen&#x2F;notify in Postgres, less work to replace this with an in-memory component, but we can&#x27;t provide the same guarantees in that case.</div><br/><div id="39647932" class="c"><input type="checkbox" id="c-39647932" checked=""/><div class="controls bullet"><span class="by">kcorbitt</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39644137">parent</a><span>|</span><a href="#39647886">next</a><span>|</span><label class="collapse" for="c-39647932">[-]</label><label class="expand" for="c-39647932">[1 more]</label></div><br/><div class="children"><div class="content">Boxes-wise, I&#x27;d like a management interface at least as good as the one Sidekiq had in Rails for years. Would also need some hard numbers around performance and probably a bit more battle-testing before using this in our current product.</div><br/></div></div><div id="39647886" class="c"><input type="checkbox" id="c-39647886" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39644137">parent</a><span>|</span><a href="#39647932">prev</a><span>|</span><a href="#39647179">next</a><span>|</span><label class="collapse" for="c-39647886">[-]</label><label class="expand" for="c-39647886">[1 more]</label></div><br/><div class="children"><div class="content">I come to this only as an interested observer, but my experience with listen&#x2F;notify is that it outperforms rabbitmq&#x2F;kafka in small to medium operations and has always pleasantly surprised me. You might find out it&#x27;s a little easier than you think to slim your dependency stack down.</div><br/></div></div></div></div><div id="39647179" class="c"><input type="checkbox" id="c-39647179" checked=""/><div class="controls bullet"><span class="by">bevekspldnw</span><span>|</span><a href="#39643991">parent</a><span>|</span><a href="#39644137">prev</a><span>|</span><a href="#39645512">next</a><span>|</span><label class="collapse" for="c-39647179">[-]</label><label class="expand" for="c-39647179">[3 more]</label></div><br/><div class="children"><div class="content">You can do a fair amount of this with Postgres using locks out of the box. It’s not super intuitive but I’ve been using just Postgres and locks in production for many years for large task distribution across independent nodes.</div><br/><div id="39648940" class="c"><input type="checkbox" id="c-39648940" checked=""/><div class="controls bullet"><span class="by">renegade-otter</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39647179">parent</a><span>|</span><a href="#39645512">next</a><span>|</span><label class="collapse" for="c-39648940">[-]</label><label class="expand" for="c-39648940">[2 more]</label></div><br/><div class="children"><div class="content">I wrote about one simple implementation:<p><a href="https:&#x2F;&#x2F;renegadeotter.com&#x2F;2023&#x2F;11&#x2F;30&#x2F;job-queues-with-postrgres.html" rel="nofollow">https:&#x2F;&#x2F;renegadeotter.com&#x2F;2023&#x2F;11&#x2F;30&#x2F;job-queues-with-postrgr...</a></div><br/><div id="39649375" class="c"><input type="checkbox" id="c-39649375" checked=""/><div class="controls bullet"><span class="by">bevekspldnw</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39648940">parent</a><span>|</span><a href="#39645512">next</a><span>|</span><label class="collapse" for="c-39649375">[-]</label><label class="expand" for="c-39649375">[1 more]</label></div><br/><div class="children"><div class="content">Looks very similar to my solution. :-)</div><br/></div></div></div></div></div></div><div id="39645512" class="c"><input type="checkbox" id="c-39645512" checked=""/><div class="controls bullet"><span class="by">BenjieGillam</span><span>|</span><a href="#39643991">parent</a><span>|</span><a href="#39647179">prev</a><span>|</span><a href="#39646111">next</a><span>|</span><label class="collapse" for="c-39645512">[-]</label><label class="expand" for="c-39645512">[3 more]</label></div><br/><div class="children"><div class="content">Not sure if you saw it but Graphile Worker supports jobs written in arbitrary languages so long as your OS can execute them: <a href="https:&#x2F;&#x2F;worker.graphile.org&#x2F;docs&#x2F;tasks#loading-executable-files" rel="nofollow">https:&#x2F;&#x2F;worker.graphile.org&#x2F;docs&#x2F;tasks#loading-executable-fi...</a><p>Would be interested to know what features you feel it’s lacking.</div><br/><div id="39647940" class="c"><input type="checkbox" id="c-39647940" checked=""/><div class="controls bullet"><span class="by">kcorbitt</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39645512">parent</a><span>|</span><a href="#39646111">next</a><span>|</span><label class="collapse" for="c-39647940">[-]</label><label class="expand" for="c-39647940">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting! Would that still involve each worker node needing to have Nodejs installed to run the process that actually reads from the queue? That&#x27;s doable, but makes the deployment story a little more annoying&#x2F;complicated if I want a worker that just runs Python or Rust or something.<p>Feature-wise, the biggest missing pieces from Graphile Worker for me are (1) a robust management web ui and (2) really strong documentation.</div><br/><div id="39648175" class="c"><input type="checkbox" id="c-39648175" checked=""/><div class="controls bullet"><span class="by">BenjieGillam</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39647940">parent</a><span>|</span><a href="#39646111">next</a><span>|</span><label class="collapse" for="c-39648175">[-]</label><label class="expand" for="c-39648175">[1 more]</label></div><br/><div class="children"><div class="content">Yes, currently Node is the runtime but we could bundle that up into a binary blob if that would help; one thing to download rather than installing Node and all its dependencies?<p>A UI is a common request, something I’ve been considering investing effort into. I don’t think we’ll ever have one in the core package, but probably as a separate package&#x2F;plugin (even a third party one); we’ve been thinking more about the events and APIs such a system would need and making these available, and adding a plugin system to enable tighter integration.<p>Could you expand on what’s missing in the documentation? That’s been a focus recently (as you may have noticed with the new expanded docusaurus site linked previously rather than just a README), but documentation can always be improved.</div><br/></div></div></div></div></div></div><div id="39646111" class="c"><input type="checkbox" id="c-39646111" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39643991">parent</a><span>|</span><a href="#39645512">prev</a><span>|</span><a href="#39650329">next</a><span>|</span><label class="collapse" for="c-39646111">[-]</label><label class="expand" for="c-39646111">[8 more]</label></div><br/><div class="children"><div class="content">Why does the RabbitMQ dependency matter?<p>It was pretty painless for me to set up and write tests against. The operator works well and is really simple if you want to save money.<p>I mean, isn’t Hatchett another dependency? Graphile Worker? I like all these things, but why draw the line at one thing over another over essentially aesthetics?<p>You better start believing in dependencies if you’re a programmer.</div><br/><div id="39646667" class="c"><input type="checkbox" id="c-39646667" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39646111">parent</a><span>|</span><a href="#39647092">next</a><span>|</span><label class="collapse" for="c-39646667">[-]</label><label class="expand" for="c-39646667">[6 more]</label></div><br/><div class="children"><div class="content">Introducing another piece of software instead of using one you already use anyway introduces new failures. That’s hardly aesthetics.<p>As a professional I’m allergic to statements like “you better start believing in X”. How can you even have objective discourse at work like that?</div><br/><div id="39646910" class="c"><input type="checkbox" id="c-39646910" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39646667">parent</a><span>|</span><a href="#39647092">next</a><span>|</span><label class="collapse" for="c-39646910">[-]</label><label class="expand" for="c-39646910">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Introducing another piece of software instead of using one you already use anyway introduces new failures.<p>Okay, but we&#x27;re talking about this on a post about using another piece of software.<p>What is the rational for, well this additional dependency, Hatchet, that&#x27;s okay, and its inevitable failures are okay, but this other dependency, RabbitMQ, which does something different, but will have fewer failures for some objective reasons, that&#x27;s not okay?<p>Hatchet is very much about aesthetics. What else does Hatchet have going on? It doesn&#x27;t have a lot of history, it&#x27;s going to have a lot of bugs. It works as a DSL written in Python annotations, which is very much an aesthetic choice, very much something I see a bunch of AI startups doing, which I personally think is kind of dumb. Like OpenAI tools are &quot;just&quot; JSON schemas, they don&#x27;t reinvent everything, and yet Trigger, Hatchet, Runloop, etc., they&#x27;re all doing DSLs. It hews to a specific promotional playbook that is also very aesthetic. Is this not the &quot;objective discourse at work&quot; you are looking for?<p>I am not saying it is bad, I am saying that 99% of people adopting it will be doing so for essentially aesthetic reasons - and being less knowledgable about alternatives might describe 50-80% of the audience, but to me, being less knowledgeable as a &quot;professional&quot; is an aesthetic choice. There&#x27;s nothing wrong with this.<p>You can get into the weeds about what you meant by whatever you said. I am aware. But I am really saying, I&#x27;m dubious of anyone promoting &quot;Use my new thing X which is good because it doesn&#x27;t introduce a new dependency.&quot; It&#x27;s an oxymoron plainly on its face. It&#x27;s not in their marketing copy but the author is talking about it here, and maybe the author isn&#x27;t completely sincere, maybe the author doesn&#x27;t care and will happily write everything on top of RabbitMQ if someone were willing to pay for it, because that decision doesn&#x27;t really matter. The author is just being reactive to people&#x27;s aesthetics, that programmers on social media &quot;like&quot; Postgres more than RabbitMQ, for reasons, and that means you can &quot;only&quot; use one, but that none of those reasons are particularly well informed by experience or whatever, yet nonetheless strongly held.<p>When you want to explain something that doesn&#x27;t make objective sense when read literally, okay, it might have an aesthetic explanation that makes more sense.</div><br/><div id="39649731" class="c"><input type="checkbox" id="c-39649731" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39646910">parent</a><span>|</span><a href="#39647710">next</a><span>|</span><label class="collapse" for="c-39649731">[-]</label><label class="expand" for="c-39649731">[2 more]</label></div><br/><div class="children"><div class="content">There is some implicit context you are missing here.<p>Tools like hatchet are one less dependency for projects already using Postgres: Postgres has become a de-facto database to build against.<p>Compare that to an application built on top of Postgres and using Celery + Redis&#x2F;RabbitMQ.<p>Also, it seems like you are confusing aesthetic with ergonomics. Since forever, software developers have tried to improve on all of &quot;aesthetics&quot; (code&#x2F;system structure appearance), &quot;ergonomics&quot; (how easy&#x2F;fast is it to build with) and &quot;performance&quot; (how well it works), and the cycle has been continuous (we introduce extra abstractions, then do away with some when it gets overly complex, and on and on).</div><br/><div id="39650308" class="c"><input type="checkbox" id="c-39650308" checked=""/><div class="controls bullet"><span class="by">danielovichdk</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39649731">parent</a><span>|</span><a href="#39647710">next</a><span>|</span><label class="collapse" for="c-39650308">[-]</label><label class="expand" for="c-39650308">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Since forever, software developers have tried to improve on all of &quot;aesthetics&quot; (code&#x2F;system structure appearance), &quot;ergonomics&quot; (how easy&#x2F;fast is it to build with) and &quot;performance&quot; (how well it works), and the cycle has been continuous&quot;<p>Fast,easy,well,cheap is not a quality measure but it sure is a way to build more useless abstractions. You tell me which abstractions has made your software twice as effective.</div><br/></div></div></div></div><div id="39647710" class="c"><input type="checkbox" id="c-39647710" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39646910">parent</a><span>|</span><a href="#39649731">prev</a><span>|</span><a href="#39647315">next</a><span>|</span><label class="collapse" for="c-39647710">[-]</label><label class="expand" for="c-39647710">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can get into the weeds about what you meant by whatever you said. I am aware.<p>&gt;When you want to explain something that doesn&#x27;t make objective sense when read literally, okay, it might have an aesthetic explanation that makes more sense.<p>What an attitude and way to kill a discussion. Again, hard for me to imagine that you&#x27;re able to have objective discussions at work. As you wish I won&#x27;t engage in discourse with you so you can feel smart.</div><br/></div></div><div id="39647315" class="c"><input type="checkbox" id="c-39647315" checked=""/><div class="controls bullet"><span class="by">danielovichdk</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39646910">parent</a><span>|</span><a href="#39647710">prev</a><span>|</span><a href="#39647092">next</a><span>|</span><label class="collapse" for="c-39647315">[-]</label><label class="expand" for="c-39647315">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree with you.<p>&#x27;But I am really saying, I&#x27;m dubious of anyone promoting &quot;Use my new thing X which is good because it doesn&#x27;t introduce a new dependency.&quot;&#x27;<p>&quot;Advances in software technology and increasing economic pressure have begun to break down many of the barriers to improved software productivity. The ${PRODUCT} is designed to remove the remaining barriers […]&quot;<p>It reads like the above quote from the pitch of r1000 in 1985. <a href="https:&#x2F;&#x2F;datamuseum.dk&#x2F;bits&#x2F;30003882" rel="nofollow">https:&#x2F;&#x2F;datamuseum.dk&#x2F;bits&#x2F;30003882</a></div><br/></div></div></div></div></div></div><div id="39647092" class="c"><input type="checkbox" id="c-39647092" checked=""/><div class="controls bullet"><span class="by">blandflakes</span><span>|</span><a href="#39643991">root</a><span>|</span><a href="#39646111">parent</a><span>|</span><a href="#39646667">prev</a><span>|</span><a href="#39650329">next</a><span>|</span><label class="collapse" for="c-39647092">[-]</label><label class="expand" for="c-39647092">[1 more]</label></div><br/><div class="children"><div class="content">And you better start critically assessing dependencies if you&#x27;re a programmer. They aren&#x27;t free; this is a wild take.</div><br/></div></div></div></div></div></div><div id="39650329" class="c"><input type="checkbox" id="c-39650329" checked=""/><div class="controls bullet"><span class="by">welder</span><span>|</span><a href="#39643991">prev</a><span>|</span><a href="#39644543">next</a><span>|</span><label class="collapse" for="c-39650329">[-]</label><label class="expand" for="c-39650329">[1 more]</label></div><br/><div class="children"><div class="content">Related, I also wrote my own distributed task queue in Python [0] and TypeScript [1] with a Show HN [2]. Time it took was about a week. I like your features, but it was easy to write my own so I&#x27;m curious how you&#x27;re building a money making business around an open source product. Maybe the fact everyone writes their own means there&#x27;s no best solution now, so you&#x27;re trying to be that and do paid closed source features for revenue?<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;wakatime&#x2F;wakaq">https:&#x2F;&#x2F;github.com&#x2F;wakatime&#x2F;wakaq</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;wakatime&#x2F;wakaq-ts">https:&#x2F;&#x2F;github.com&#x2F;wakatime&#x2F;wakaq-ts</a><p>[2] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32730038">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32730038</a></div><br/></div></div><div id="39644543" class="c"><input type="checkbox" id="c-39644543" checked=""/><div class="controls bullet"><span class="by">jerrygenser</span><span>|</span><a href="#39650329">prev</a><span>|</span><a href="#39650359">next</a><span>|</span><label class="collapse" for="c-39644543">[-]</label><label class="expand" for="c-39644543">[6 more]</label></div><br/><div class="children"><div class="content">Something I really like about some pub&#x2F;sub systems is Push subscriptions. For example in GCP pub&#x2F;sub you can have a &quot;subscriber&quot; that is not pulling events off the queue but instead is an http endpoint where events are pushed to.<p>The nice thing about this is that you can use a runtime like cloud run or lambda and allow that runtime to scale based on http requests and also scale to zero.<p>Setting up autoscaling for workers can be a little bit more finicky, e.g. in kubernetes you might set up KEDA autoscaling based on some queue depth metrics but these might need to be exported from rabbit.<p>I suppose you could have a setup where your daemon worker is making http requests and in that sense &quot;push&quot; to the place where jobs are actually running but this adds another level of complexity.<p>Is there any plan to support a push model where you can push jobs into http and some daemons that are holding the http connections opened?</div><br/><div id="39650089" class="c"><input type="checkbox" id="c-39650089" checked=""/><div class="controls bullet"><span class="by">jsmeaton</span><span>|</span><a href="#39644543">parent</a><span>|</span><a href="#39645123">next</a><span>|</span><label class="collapse" for="c-39650089">[-]</label><label class="expand" for="c-39650089">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;tasks" rel="nofollow">https:&#x2F;&#x2F;cloud.google.com&#x2F;tasks</a> is such a good model and I really want an open source version of it (or to finally bite the bullet and write my own).<p>Having http targets means you get things like rate limiting, middleware, and observability that your regular application uses, and you aren’t tied to whatever backend the task system supports.<p>Set up a separate scaling group and away you go.</div><br/></div></div><div id="39645123" class="c"><input type="checkbox" id="c-39645123" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39644543">parent</a><span>|</span><a href="#39650089">prev</a><span>|</span><a href="#39647854">next</a><span>|</span><label class="collapse" for="c-39645123">[-]</label><label class="expand" for="c-39645123">[2 more]</label></div><br/><div class="children"><div class="content">I like that idea, basically the first HTTP request ensures the worker gets spun up on a lambda, and the task gets picked up on the next poll when the worker is running. We already have the underlying push model for our streaming feature: <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;streaming">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;streaming</a>. Can configure this to post to an HTTP endpoint pretty easily.<p>The daemon feels fragile to me, why not just shut down the worker client-side after some period of inactivity?</div><br/><div id="39645490" class="c"><input type="checkbox" id="c-39645490" checked=""/><div class="controls bullet"><span class="by">jerrygenser</span><span>|</span><a href="#39644543">root</a><span>|</span><a href="#39645123">parent</a><span>|</span><a href="#39647854">next</a><span>|</span><label class="collapse" for="c-39645490">[-]</label><label class="expand" for="c-39645490">[1 more]</label></div><br/><div class="children"><div class="content">I think it depends on the http runtime. One of the things with cloud run is that if the server is not handling requests, it doesn&#x27;t get CPU time. So even if the first request is &quot;wake up&quot;, it wouldn&#x27;t get any CPU to poll outside of the request-response cycle.<p>You can configure cloud run to always allocate CPU but it&#x27;s a lot more expensive. I don&#x27;t think it would be a good autoscaling story since autoscaling is based on http requests being processed. (maybe can be done via CPU but that&#x27;s may not be what you want, it may not even be cpu bound)</div><br/></div></div></div></div><div id="39647854" class="c"><input type="checkbox" id="c-39647854" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#39644543">parent</a><span>|</span><a href="#39645123">prev</a><span>|</span><a href="#39647156">next</a><span>|</span><label class="collapse" for="c-39647854">[-]</label><label class="expand" for="c-39647854">[1 more]</label></div><br/><div class="children"><div class="content">You might want to look at <a href="https:&#x2F;&#x2F;www.inngest.com" rel="nofollow">https:&#x2F;&#x2F;www.inngest.com</a> for that.  Disclaimer:  I&#x27;m a cofounder.  We released event-driven step functions about 20 months ago.</div><br/></div></div><div id="39647156" class="c"><input type="checkbox" id="c-39647156" checked=""/><div class="controls bullet"><span class="by">alexbouchard</span><span>|</span><a href="#39644543">parent</a><span>|</span><a href="#39647854">prev</a><span>|</span><a href="#39650359">next</a><span>|</span><label class="collapse" for="c-39647156">[-]</label><label class="expand" for="c-39647156">[1 more]</label></div><br/><div class="children"><div class="content">The push queue model has major benefits has you mentioned. We&#x27;ve built Hookdeck (hookdeck.com) on that premise. I hope we see more projects adopt it.</div><br/></div></div></div></div><div id="39650359" class="c"><input type="checkbox" id="c-39650359" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#39644543">prev</a><span>|</span><a href="#39645209">next</a><span>|</span><label class="collapse" for="c-39650359">[-]</label><label class="expand" for="c-39650359">[1 more]</label></div><br/><div class="children"><div class="content">Since these are task executions in a DAG, to what degree does it compete with dagster or airflow? I get that I can’t define the task with Hatchet, but if I already want to separate my DAG from my tasks, is this a viable option?</div><br/></div></div><div id="39645209" class="c"><input type="checkbox" id="c-39645209" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#39650359">prev</a><span>|</span><a href="#39650032">next</a><span>|</span><label class="collapse" for="c-39645209">[-]</label><label class="expand" for="c-39645209">[10 more]</label></div><br/><div class="children"><div class="content">Just pointing out even though this is a &quot;Show HN&quot; they are, indeed, backed by YC.<p>Is this going to follow the &quot;open core&quot; pattern or will there be a different path to revenue?</div><br/><div id="39646788" class="c"><input type="checkbox" id="c-39646788" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39645209">parent</a><span>|</span><a href="#39650345">next</a><span>|</span><label class="collapse" for="c-39646788">[-]</label><label class="expand" for="c-39646788">[2 more]</label></div><br/><div class="children"><div class="content">Yep, we&#x27;re backed by YC in the W24 batch - this is evident on our landing page [1].<p>We&#x27;re both second time CTOs and we&#x27;ve been on both sides of this, as consumers of and creators of OSS. I was previously a co-founder and CTO of Porter [2], which had an open-core model. There are two risks that most companies think about in the open core model:<p>1. Big companies using your platform without contributing back in some way or buying a license. I think this is less of a risk, because these organizations are incentivized to buy a support license to help with maintenance, upgrades, and since we sit on a critical path, with uptime.<p>2. Hyperscalers folding your product in to their offering [3]. This is a bigger risk but is also a bit of a &quot;champagne problem&quot;.<p>Note that smaller companies&#x2F;individual developers are who we&#x27;d like to enable, not crowd out. If people would like to use our cloud offering because it reduces the headache for them, they should do so. If they just want to run our service and manage their own PostgreSQL, they should have the option to do that too.<p>Based on all of this, here&#x27;s where we land on things:<p>1. Everything we&#x27;ve built so far has been 100% MIT licensed. We&#x27;d like to keep it that way and make money off of Hatchet Cloud. We&#x27;ll likely roll out a separate enterprise support agreement for self hosting.<p>2. Our cloud version isn&#x27;t going to run a different core engine or API server than our open source version. We&#x27;ll write interfaces for all plugins to our servers and engines, so even if we have something super specific to how we&#x27;ve chosen to do things on the cloud version, we&#x27;ll expose the options to write your own plugins on the engine and server.<p>3. We&#x27;d like to make self-hosting as easy to use as our cloud version. We don&#x27;t want our self-hosted offering to be a second-class citizen.<p>Would love to hear everyone&#x27;s thoughts on this.<p>[1] <a href="https:&#x2F;&#x2F;hatchet.run">https:&#x2F;&#x2F;hatchet.run</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;porter-dev&#x2F;porter">https:&#x2F;&#x2F;github.com&#x2F;porter-dev&#x2F;porter</a><p>[3] <a href="https:&#x2F;&#x2F;www.elastic.co&#x2F;blog&#x2F;why-license-change-aws" rel="nofollow">https:&#x2F;&#x2F;www.elastic.co&#x2F;blog&#x2F;why-license-change-aws</a></div><br/><div id="39650406" class="c"><input type="checkbox" id="c-39650406" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#39645209">root</a><span>|</span><a href="#39646788">parent</a><span>|</span><a href="#39650345">next</a><span>|</span><label class="collapse" for="c-39650406">[-]</label><label class="expand" for="c-39650406">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 2. Hyperscalers folding your product in to their offering [3]. This is a bigger risk but is also a bit of a &quot;champagne problem&quot;.<p>Champagne for them, not for you.<p>Better put some venom and claws in your license.</div><br/></div></div></div></div><div id="39650345" class="c"><input type="checkbox" id="c-39650345" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#39645209">parent</a><span>|</span><a href="#39646788">prev</a><span>|</span><a href="#39645268">next</a><span>|</span><label class="collapse" for="c-39650345">[-]</label><label class="expand" for="c-39650345">[1 more]</label></div><br/><div class="children"><div class="content">Wasn’t the first Dropbox introduction also a show HN?<p>I don’t think this is out of place</div><br/></div></div><div id="39645268" class="c"><input type="checkbox" id="c-39645268" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#39645209">parent</a><span>|</span><a href="#39650345">prev</a><span>|</span><a href="#39650032">next</a><span>|</span><label class="collapse" for="c-39645268">[-]</label><label class="expand" for="c-39645268">[6 more]</label></div><br/><div class="children"><div class="content">&gt; path to revenue<p>There have to be at least 10 different ways between different cloud providers to run a distributed task queue. Amazon, Azure, GCP<p>Self-hosting RabbitMQ, etc.<p>I&#x27;m curious how they are able to convince investors that there is a sizable portion of market they think doesn&#x27;t already have this solved (or already has it solved and is willing to migrate)</div><br/><div id="39645357" class="c"><input type="checkbox" id="c-39645357" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#39645209">root</a><span>|</span><a href="#39645268">parent</a><span>|</span><a href="#39646344">next</a><span>|</span><label class="collapse" for="c-39645357">[-]</label><label class="expand" for="c-39645357">[1 more]</label></div><br/><div class="children"><div class="content">There will be space for improvement until every cloud has a managed offering with exactly the same interface. Like docker, postgres, S3.</div><br/></div></div><div id="39646344" class="c"><input type="checkbox" id="c-39646344" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#39645209">root</a><span>|</span><a href="#39645268">parent</a><span>|</span><a href="#39645357">prev</a><span>|</span><a href="#39649406">next</a><span>|</span><label class="collapse" for="c-39646344">[-]</label><label class="expand" for="c-39646344">[3 more]</label></div><br/><div class="children"><div class="content">I am curious to see where they differentiate themselves on observability on the longer run.<p>Comparing to rabbitmq it should be easier to see what is in the queue itself without mutating it, for instance.</div><br/><div id="39648403" class="c"><input type="checkbox" id="c-39648403" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#39645209">root</a><span>|</span><a href="#39646344">parent</a><span>|</span><a href="#39649406">next</a><span>|</span><label class="collapse" for="c-39648403">[-]</label><label class="expand" for="c-39648403">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;docs&#x2F;management" rel="nofollow">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;docs&#x2F;management</a></div><br/><div id="39648645" class="c"><input type="checkbox" id="c-39648645" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#39645209">root</a><span>|</span><a href="#39648403">parent</a><span>|</span><a href="#39649406">next</a><span>|</span><label class="collapse" for="c-39648645">[-]</label><label class="expand" for="c-39648645">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but to see what is in the queue you have to operate on it, mutating it. With this using postgres we can just look in the table.</div><br/></div></div></div></div></div></div><div id="39649406" class="c"><input type="checkbox" id="c-39649406" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#39645209">root</a><span>|</span><a href="#39645268">parent</a><span>|</span><a href="#39646344">prev</a><span>|</span><a href="#39650032">next</a><span>|</span><label class="collapse" for="c-39649406">[-]</label><label class="expand" for="c-39649406">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m curious how they are able to convince investors that there is a sizable portion of market they think doesn&#x27;t already have this solved<p>Is there any task queue you are completely happy with?<p>I use Redis, but it’s only half of the solution.</div><br/></div></div></div></div></div></div><div id="39650032" class="c"><input type="checkbox" id="c-39650032" checked=""/><div class="controls bullet"><span class="by">serbrech</span><span>|</span><a href="#39645209">prev</a><span>|</span><a href="#39645379">next</a><span>|</span><label class="collapse" for="c-39650032">[-]</label><label class="expand" for="c-39650032">[1 more]</label></div><br/><div class="children"><div class="content">I wish that this was just a sdk built on top of a provider&#x2F;standard.
Amqp 1.0 is a standard protocol.
You can build all this without being tied to a product or to rabbitMQ, with a storage provider and a amqp protocol layer.</div><br/></div></div><div id="39645379" class="c"><input type="checkbox" id="c-39645379" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#39650032">prev</a><span>|</span><a href="#39644200">next</a><span>|</span><label class="collapse" for="c-39645379">[-]</label><label class="expand" for="c-39645379">[1 more]</label></div><br/><div class="children"><div class="content">Ah nice! I am writing a job queue this weekend for a DAG based task runner, so timing is great. I will have a look. I don&#x27;t need anything too big, but I have written some stuff for using PostgreSQL (FOR UPDATE SKIP LOCKED for the win), sqlite, and in-memory, depending on what I want to use it for.<p>I want the task graph to run without thinking about retries, timeouts, serialized resources, etc.<p>Interested to look at your particular approach.</div><br/></div></div><div id="39644200" class="c"><input type="checkbox" id="c-39644200" checked=""/><div class="controls bullet"><span class="by">toddmorey</span><span>|</span><a href="#39645379">prev</a><span>|</span><a href="#39643927">next</a><span>|</span><label class="collapse" for="c-39644200">[-]</label><label class="expand" for="c-39644200">[4 more]</label></div><br/><div class="children"><div class="content">I need task queues where the client (web browser) can listen to the progress of the task through completion.<p>I love the simplicity &amp; approachability of Deno queues for example, but I’d need to roll my own way to subscribe to task status from the client.<p>Wondering if perhaps the Postgres underpinnings here would make that possible.<p>EDIT: seems so!
<a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;streaming">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;streaming</a></div><br/><div id="39644404" class="c"><input type="checkbox" id="c-39644404" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39644200">parent</a><span>|</span><a href="#39644287">next</a><span>|</span><label class="collapse" for="c-39644404">[-]</label><label class="expand" for="c-39644404">[2 more]</label></div><br/><div class="children"><div class="content">Yep, exactly - Gabe has also been thinking about providing per-user signed URLs to task executions so clients can subscribe more easily without a long-lived token. So basically, you would start the workflow from your API, and pass back the signed URL to the client, where we would then provide a React hook to get task updates automatically. We need this ourselves once we open our cloud instance up to self-serve, since we want to provision separate queues per user, with a Hatchet workflow of course.</div><br/><div id="39644429" class="c"><input type="checkbox" id="c-39644429" checked=""/><div class="controls bullet"><span class="by">toddmorey</span><span>|</span><a href="#39644200">root</a><span>|</span><a href="#39644404">parent</a><span>|</span><a href="#39644287">next</a><span>|</span><label class="collapse" for="c-39644429">[-]</label><label class="expand" for="c-39644429">[1 more]</label></div><br/><div class="children"><div class="content">Awesome to hear!</div><br/></div></div></div></div><div id="39644287" class="c"><input type="checkbox" id="c-39644287" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#39644200">parent</a><span>|</span><a href="#39644404">prev</a><span>|</span><a href="#39643927">next</a><span>|</span><label class="collapse" for="c-39644287">[-]</label><label class="expand" for="c-39644287">[1 more]</label></div><br/><div class="children"><div class="content">If you need to listen for the progress only, try server-sent events, maybe?: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Server-sent_events" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Server-sent_events</a><p>It&#x27;s dead simple: an existence of the URI means the topic&#x2F;channel&#x2F;whathaveu exists, to access it one needs to know the URI, data streamed but no access to old data, multiple consumers no problem.</div><br/></div></div></div></div><div id="39643927" class="c"><input type="checkbox" id="c-39643927" checked=""/><div class="controls bullet"><span class="by">bluehadoop</span><span>|</span><a href="#39644200">prev</a><span>|</span><a href="#39645312">next</a><span>|</span><label class="collapse" for="c-39643927">[-]</label><label class="expand" for="c-39643927">[5 more]</label></div><br/><div class="children"><div class="content">How does this compare against Temporal&#x2F;Cadence&#x2F;Conductor? Does hatchet also support durable execution?<p><a href="https:&#x2F;&#x2F;temporal.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;temporal.io&#x2F;</a>
<a href="https:&#x2F;&#x2F;cadenceworkflow.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cadenceworkflow.io&#x2F;</a>
<a href="https:&#x2F;&#x2F;conductor-oss.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;conductor-oss.org&#x2F;</a></div><br/><div id="39644550" class="c"><input type="checkbox" id="c-39644550" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39643927">parent</a><span>|</span><a href="#39645312">next</a><span>|</span><label class="collapse" for="c-39644550">[-]</label><label class="expand" for="c-39644550">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very similar - I used Temporal at a previous company to run a couple million workflows per month. The gRPC networking with workers is the most similar component, I especially liked that I only had to worry about an http2 connection with mTLS instead of a different broker protocol.<p>Temporal is a powerful system but we were getting to the point where it took a full-time engineer to build an observability layer around Temporal. Integrating workflows in an intuitive way with OpenTelemetry and logging was surprisingly non-arbitrary. We wanted to build more of a Vercel-like experience for managing workflows.<p>We have a section on the docs page for durable execution [1], also see the comment on HN [2]. Like I mention in that comment, we still have a long way to go before users can write a full workflow in code in the same style as a Temporal workflow, users either define the execution path ahead of time or invoke a child workflow from an existing workflow. This is also something that requires customization for each SDK - like Temporal&#x27;s custom asyncio event loop in their Python SDK [3]. We don&#x27;t want to roll this out until we can be sure about compatibility with the way most people write their functions.<p>[1] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;durable-execution">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;durable-execution</a><p>[2] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39643881">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39643881</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;temporalio&#x2F;sdk-python">https:&#x2F;&#x2F;github.com&#x2F;temporalio&#x2F;sdk-python</a></div><br/><div id="39646064" class="c"><input type="checkbox" id="c-39646064" checked=""/><div class="controls bullet"><span class="by">bicijay</span><span>|</span><a href="#39643927">root</a><span>|</span><a href="#39644550">parent</a><span>|</span><a href="#39645312">next</a><span>|</span><label class="collapse" for="c-39646064">[-]</label><label class="expand" for="c-39646064">[3 more]</label></div><br/><div class="children"><div class="content">Well, you just got an user. Love the concept of temporal, but i can&#x27;t justify the overhead you need with infra to make it work for the upper guys... And the cloud offering is a bit expensive for small companies.</div><br/><div id="39647745" class="c"><input type="checkbox" id="c-39647745" checked=""/><div class="controls bullet"><span class="by">mfateev</span><span>|</span><a href="#39643927">root</a><span>|</span><a href="#39646064">parent</a><span>|</span><a href="#39645312">next</a><span>|</span><label class="collapse" for="c-39647745">[-]</label><label class="expand" for="c-39647745">[2 more]</label></div><br/><div class="children"><div class="content">Do you know about the Temporal startup program? It gives enough credits to offset support fees for 2 years. <a href="https:&#x2F;&#x2F;temporal.io&#x2F;startup" rel="nofollow">https:&#x2F;&#x2F;temporal.io&#x2F;startup</a></div><br/><div id="39649420" class="c"><input type="checkbox" id="c-39649420" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#39643927">root</a><span>|</span><a href="#39647745">parent</a><span>|</span><a href="#39645312">next</a><span>|</span><label class="collapse" for="c-39649420">[-]</label><label class="expand" for="c-39649420">[1 more]</label></div><br/><div class="children"><div class="content">If you are expecting to still be small after 2 years that just delays the expense until you are locked in?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39645312" class="c"><input type="checkbox" id="c-39645312" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#39643927">prev</a><span>|</span><a href="#39644741">next</a><span>|</span><label class="collapse" for="c-39645312">[-]</label><label class="expand" for="c-39645312">[2 more]</label></div><br/><div class="children"><div class="content">With NATS in the stack, what&#x27;s the advantage over using NATS directly?</div><br/><div id="39649524" class="c"><input type="checkbox" id="c-39649524" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39645312">parent</a><span>|</span><a href="#39644741">next</a><span>|</span><label class="collapse" for="c-39649524">[-]</label><label class="expand" for="c-39649524">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m assuming specifically you mean Nex functions? Otherwise NATS gives you connectivity and a message queue - it doesn&#x27;t (or didn&#x27;t) have the concept of task executions or workflows.<p>With regards to Nex -- it isn&#x27;t fully stable and only supports Javascript&#x2F;Webassembly. It&#x27;s also extremely new, so I&#x27;d be curious to see how things stabilize in the coming year.</div><br/></div></div></div></div><div id="39644741" class="c"><input type="checkbox" id="c-39644741" checked=""/><div class="controls bullet"><span class="by">SCUSKU</span><span>|</span><a href="#39645312">prev</a><span>|</span><a href="#39646725">next</a><span>|</span><label class="collapse" for="c-39644741">[-]</label><label class="expand" for="c-39644741">[5 more]</label></div><br/><div class="children"><div class="content">Looks pretty great! My biggest issue with Celery has been that the observability is pretty bad. Even if you use Celery Flower, it still just doesn’t give me enough insight when I’m trying to debug some problem in production.<p>I’m all for just using Postgres in service of the grug brain philosophy.<p>Will definitely be looking into this, congrats on the launch!</div><br/><div id="39644933" class="c"><input type="checkbox" id="c-39644933" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39644741">parent</a><span>|</span><a href="#39646503">next</a><span>|</span><label class="collapse" for="c-39644933">[-]</label><label class="expand" for="c-39644933">[1 more]</label></div><br/><div class="children"><div class="content">Appreciate it, thank you! We&#x27;ve spent quite a bit of time in the Celery Flower console. Admittedly it&#x27;s been a while, I&#x27;m not sure if they&#x27;ve added views for chains&#x2F;groups&#x2F;etc - it was just a linear task view when I used it.<p>A nice thing in Celery Flower is viewing the `args, kwargs`, whereas Hatchet operates on JSON request&#x2F;response bodies, so some early users have mentioned that it&#x27;s hard to get visibility into the exact typing&#x2F;serialization that&#x27;s happening. Something for us to work on.</div><br/></div></div><div id="39646503" class="c"><input type="checkbox" id="c-39646503" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#39644741">parent</a><span>|</span><a href="#39644933">prev</a><span>|</span><a href="#39646725">next</a><span>|</span><label class="collapse" for="c-39646503">[-]</label><label class="expand" for="c-39646503">[3 more]</label></div><br/><div class="children"><div class="content">I case you’re stuck with Celery for a while: I was hit with this same problem, and solved it by adding a sidecar HTTP server thread to the Python workers that would expose metrics written by the workers into a multithreaded registry. This has been working amazingly well in production for over two years now, and makes it really straightforward to get custom metrics out of a distributed Celery app.</div><br/><div id="39649476" class="c"><input type="checkbox" id="c-39649476" checked=""/><div class="controls bullet"><span class="by">kamikaz1k</span><span>|</span><a href="#39644741">root</a><span>|</span><a href="#39646503">parent</a><span>|</span><a href="#39646725">next</a><span>|</span><label class="collapse" for="c-39649476">[-]</label><label class="expand" for="c-39649476">[2 more]</label></div><br/><div class="children"><div class="content">Any chance you could share more specifics about your solution?</div><br/><div id="39650413" class="c"><input type="checkbox" id="c-39650413" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#39644741">root</a><span>|</span><a href="#39649476">parent</a><span>|</span><a href="#39646725">next</a><span>|</span><label class="collapse" for="c-39650413">[-]</label><label class="expand" for="c-39650413">[1 more]</label></div><br/><div class="children"><div class="content">Here you go: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;75652326&#x2F;celery-spawn-sidecar-webserver-process&#x2F;75799358#75799358" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;75652326&#x2F;celery-spawn-si...</a><p>Plus some adjacent discussion on GitHub: <a href="https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;client_python&#x2F;issues&#x2F;902">https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;client_python&#x2F;issues&#x2F;902</a><p>Hope that helps!</div><br/></div></div></div></div></div></div></div></div><div id="39646725" class="c"><input type="checkbox" id="c-39646725" checked=""/><div class="controls bullet"><span class="by">fuddle</span><span>|</span><a href="#39644741">prev</a><span>|</span><a href="#39647366">next</a><span>|</span><label class="collapse" for="c-39646725">[-]</label><label class="expand" for="c-39646725">[2 more]</label></div><br/><div class="children"><div class="content">Looks great! Do you publish pricing for your cloud offering?  
For the self hosted option, are there plans to create a Kubernetes operator? With an MIT license do you fear Amazon could create a Amazon Hatchet Service sometime in the future?</div><br/><div id="39647101" class="c"><input type="checkbox" id="c-39647101" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39646725">parent</a><span>|</span><a href="#39647366">next</a><span>|</span><label class="collapse" for="c-39647101">[-]</label><label class="expand" for="c-39647101">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!<p>&gt; Do you publish pricing for your cloud offering?<p>Not yet, we&#x27;re rolling out the cloud offering slowly to make sure we don&#x27;t experience any widespread outages.  As soon as we&#x27;re open for self-serve on the cloud side, we&#x27;ll publish our pricing model.<p>&gt; For the self hosted option, are there plans to create a Kubernetes operator?<p>Not at the moment, our initial plan was to help folks with a KEDA autoscaling setup based on Hatchet queue metrics, which is something I&#x27;ve done with Sidekiq queue depth. We&#x27;ll probably wait to build a k8s operator after our existing Helm chart is relatively stable.<p>&gt; With an MIT license do you fear Amazon could create a Amazon Hatchet Service sometime in the future?<p>Yes. The question is whether that risk is worth the tradeoff of not being MIT-licensed. There are also paths to getting integrated into AWS marketplace we&#x27;ll explore longer-term. I added some thoughts here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39646788">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39646788</a>.</div><br/></div></div></div></div><div id="39647366" class="c"><input type="checkbox" id="c-39647366" checked=""/><div class="controls bullet"><span class="by">beerkat</span><span>|</span><a href="#39646725">prev</a><span>|</span><a href="#39646300">next</a><span>|</span><label class="collapse" for="c-39647366">[-]</label><label class="expand" for="c-39647366">[2 more]</label></div><br/><div class="children"><div class="content">How does this compare to River Queue (<a href="https:&#x2F;&#x2F;riverqueue.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;riverqueue.com&#x2F;</a>)? Besides the additional Python and TS client libraries.</div><br/><div id="39649469" class="c"><input type="checkbox" id="c-39649469" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39647366">parent</a><span>|</span><a href="#39646300">next</a><span>|</span><label class="collapse" for="c-39649469">[-]</label><label class="expand" for="c-39649469">[1 more]</label></div><br/><div class="children"><div class="content">The underlying queue is very similar. See this comment, which details how we&#x27;re different from a library client: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39644327">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39644327</a>. We also have the concept of workflows, which last I checked doesn&#x27;t exist in River.<p>I&#x27;m personally very excited about River and I think it fills an important gap in the Go ecosystem! Also now that sqlc w&#x2F; pgx seems to be getting more popular, it&#x27;s very easy to integrate.</div><br/></div></div></div></div><div id="39646300" class="c"><input type="checkbox" id="c-39646300" checked=""/><div class="controls bullet"><span class="by">moribvndvs</span><span>|</span><a href="#39647366">prev</a><span>|</span><a href="#39647915">next</a><span>|</span><label class="collapse" for="c-39646300">[-]</label><label class="expand" for="c-39646300">[9 more]</label></div><br/><div class="children"><div class="content">One repeat issue I’ve had with my past position is need to schedule an unlimited number of jobs, often months to year from now. Example use case: a patient schedules an appointment for a follow up in 6 months, so I schedule a series of appointment reminders in the days leading up to it. I might have millions of these jobs.<p>I started out by just entering a record into a database queue and just polling every few seconds. Functional, but our IO costs for polling weren’t ideal, and we wanted to distribute this without using stuff like schedlock. I switched to Redis but it got complicated dealing with multiple dispatchers, OOM issues, and having to run a secondary job to move individual tasks in and out of the immediate queue, etc. I had started looking at switching to backing it with PG and SKIP LOCKED, etc. but I’ve changed positions.<p>I can see a similar use case on my horizon wondered if Hatchet would be suitable for it.</div><br/><div id="39647154" class="c"><input type="checkbox" id="c-39647154" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39646300">parent</a><span>|</span><a href="#39646374">next</a><span>|</span><label class="collapse" for="c-39647154">[-]</label><label class="expand" for="c-39647154">[2 more]</label></div><br/><div class="children"><div class="content">It wouldn&#x27;t be suitable for that at the moment, but might be after some refactors coming this weekend. I wrote a very quick scheduling API which pushes schedules as workflow triggers, but it&#x27;s only supported on the Go SDK. It also is CPU-intensive at thousands of schedules, as the schedules are run as separate goroutines (on a dedicated `ticker` service) - I&#x27;m not proud of this. This was a pattern that made sense for the cron schedule and I just adapted it for the one-time scheduling.<p>Looking ahead (and back) in the database and placing an exclusive lock on the schedule is the way to do this. You basically guarantee scheduling at +&#x2F;- the polling interval if your service goes down while maintaining the lock. This allows you to horizontally scale the `tickers` which are polling for the schedules.</div><br/><div id="39647520" class="c"><input type="checkbox" id="c-39647520" checked=""/><div class="controls bullet"><span class="by">moribvndvs</span><span>|</span><a href="#39646300">root</a><span>|</span><a href="#39647154">parent</a><span>|</span><a href="#39646374">next</a><span>|</span><label class="collapse" for="c-39647520">[-]</label><label class="expand" for="c-39647520">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the follow-up! I’ll keep an eye on the progress.</div><br/></div></div></div></div><div id="39646374" class="c"><input type="checkbox" id="c-39646374" checked=""/><div class="controls bullet"><span class="by">herval</span><span>|</span><a href="#39646300">parent</a><span>|</span><a href="#39647154">prev</a><span>|</span><a href="#39646511">next</a><span>|</span><label class="collapse" for="c-39646374">[-]</label><label class="expand" for="c-39646374">[4 more]</label></div><br/><div class="children"><div class="content">why do you need to schedule things 6 months in advance, instead of, say, check everything that needs notifications in a rolling window (eg 24h ahead) and schedule those?</div><br/><div id="39646719" class="c"><input type="checkbox" id="c-39646719" checked=""/><div class="controls bullet"><span class="by">moribvndvs</span><span>|</span><a href="#39646300">root</a><span>|</span><a href="#39646374">parent</a><span>|</span><a href="#39646511">next</a><span>|</span><label class="collapse" for="c-39646719">[-]</label><label class="expand" for="c-39646719">[3 more]</label></div><br/><div class="children"><div class="content">Well, it was a dumbed down example. In that particular case, appointments can be added, removed, or moved at any moment, so I can’t just run one job every 24 hours to tee up the next day’s work and leave it at that. Simply polling the database for messages that are due to go out gives me my just-in-time queue, but then I need to build out the work to distribute it, and we didn’t like the IO costs.<p>I did end up moving it Redis and basically ZADD an execution timestamp and job ID, then ZRANGEBYSCORE at my desired interval and remove those jobs as I successfully distribute them out to workers. I then set a fence time. At that time a job runs to move stuff that should have ran but didn’t (rare, thankfully) into a remediation queue, and load the next block of items that should run between now + fence. At the service level, any items with a scheduled date within the fence gets ZADDed after being inserted into the normal database. Anything outside the fence will be picked up at the appropriate time.<p>This worked. I was able to ramp up the polling time to get near-real time dispatch while also noticeably reducing costs. Problems were some occasional Redis issues (OOM and having to either a keep bumping up the Redis instance size or reduce the fence duration), allowing multiple pollers for redundancy and scale (I used schelock for that :&#x2F;), and occasionally a bug where the poller craps out in the middle of the Redis work resulting in at least once SLA which required downstream protections to make sure I don’t send the same message multiple time to the patient.<p>Again, it all works but I’m interested in seeing if there are solutions that I don’t have to hand roll.</div><br/><div id="39648268" class="c"><input type="checkbox" id="c-39648268" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#39646300">root</a><span>|</span><a href="#39646719">parent</a><span>|</span><a href="#39647999">next</a><span>|</span><label class="collapse" for="c-39648268">[-]</label><label class="expand" for="c-39648268">[1 more]</label></div><br/><div class="children"><div class="content">I built <a href="https:&#x2F;&#x2F;www.inngest.com" rel="nofollow">https:&#x2F;&#x2F;www.inngest.com</a> specifically because of healthcare flows.  You should check it out, with the obvious disclaimer that I&#x27;m biased.  Here&#x27;s what you need:<p>1. Functions which allow you to declaratively sleep until a specific time, automatically rescheduling jobs (<a href="https:&#x2F;&#x2F;www.inngest.com&#x2F;docs&#x2F;reference&#x2F;functions&#x2F;step-sleep-until" rel="nofollow">https:&#x2F;&#x2F;www.inngest.com&#x2F;docs&#x2F;reference&#x2F;functions&#x2F;step-sleep-...</a>).<p>2. Declarative cancellation, which allows you to cancel jobs if the user reschedules their appointment automatically (<a href="https:&#x2F;&#x2F;www.inngest.com&#x2F;docs&#x2F;guides&#x2F;cancel-running-functions" rel="nofollow">https:&#x2F;&#x2F;www.inngest.com&#x2F;docs&#x2F;guides&#x2F;cancel-running-functions</a>).<p>3. General reliability and API access.<p>Inngest does that for you, but again — disclaimer, I made it and am biased.</div><br/></div></div><div id="39647999" class="c"><input type="checkbox" id="c-39647999" checked=""/><div class="controls bullet"><span class="by">herval</span><span>|</span><a href="#39646300">root</a><span>|</span><a href="#39646719">parent</a><span>|</span><a href="#39648268">prev</a><span>|</span><a href="#39646511">next</a><span>|</span><label class="collapse" for="c-39647999">[-]</label><label class="expand" for="c-39647999">[1 more]</label></div><br/><div class="children"><div class="content">Couldn’t u just enqueue + change a status, then check before firing? I don’t see why you’d need more than a dumb queue and a db table for that, unless you’re doing millions of qps</div><br/></div></div></div></div></div></div><div id="39646511" class="c"><input type="checkbox" id="c-39646511" checked=""/><div class="controls bullet"><span class="by">kbar13</span><span>|</span><a href="#39646300">parent</a><span>|</span><a href="#39646374">prev</a><span>|</span><a href="#39647915">next</a><span>|</span><label class="collapse" for="c-39646511">[-]</label><label class="expand" for="c-39646511">[2 more]</label></div><br/><div class="children"><div class="content">can you explain why this cannot be a simple daily cronjob to query for appointments upcoming next &lt;time window&gt; and send out notifications at that time? polling every few seconds seems way overkill</div><br/><div id="39646795" class="c"><input type="checkbox" id="c-39646795" checked=""/><div class="controls bullet"><span class="by">moribvndvs</span><span>|</span><a href="#39646300">root</a><span>|</span><a href="#39646511">parent</a><span>|</span><a href="#39647915">next</a><span>|</span><label class="collapse" for="c-39646795">[-]</label><label class="expand" for="c-39646795">[1 more]</label></div><br/><div class="children"><div class="content">Sure: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39646719">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39646719</a></div><br/></div></div></div></div></div></div><div id="39647915" class="c"><input type="checkbox" id="c-39647915" checked=""/><div class="controls bullet"><span class="by">krawczstef</span><span>|</span><a href="#39646300">prev</a><span>|</span><a href="#39643642">next</a><span>|</span><label class="collapse" for="c-39647915">[-]</label><label class="expand" for="c-39647915">[5 more]</label></div><br/><div class="children"><div class="content">Can you explain why you chose every function to take in context?  <a href="https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;blob&#x2F;main&#x2F;python-sdk&#x2F;examples&#x2F;dag&#x2F;worker.py">https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;blob&#x2F;main&#x2F;python-sdk&#x2F;...</a><p>This seems like a lot of boiler plate to write functions with to me (context I created <a href="http:&#x2F;&#x2F;github.com&#x2F;DAGWorks-Inc&#x2F;hamilton">http:&#x2F;&#x2F;github.com&#x2F;DAGWorks-Inc&#x2F;hamilton</a>).</div><br/><div id="39649444" class="c"><input type="checkbox" id="c-39649444" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39647915">parent</a><span>|</span><a href="#39643642">next</a><span>|</span><label class="collapse" for="c-39649444">[-]</label><label class="expand" for="c-39649444">[4 more]</label></div><br/><div class="children"><div class="content">We did it because there are methods that should be accessed which don&#x27;t map to `args` cleanly. For example, we let users call `context.log`, `context.done` (to determine whether to return on cancellation) or `context.step_output` (to dynamically access a parent&#x27;s step output). Perhaps there&#x27;s a more pythonic way to do this? Admittedly this is a pattern we adapted from Go.</div><br/><div id="39649503" class="c"><input type="checkbox" id="c-39649503" checked=""/><div class="controls bullet"><span class="by">kamikaz1k</span><span>|</span><a href="#39647915">root</a><span>|</span><a href="#39649444">parent</a><span>|</span><a href="#39649814">next</a><span>|</span><label class="collapse" for="c-39649503">[-]</label><label class="expand" for="c-39649503">[2 more]</label></div><br/><div class="children"><div class="content">Probably just have it attached to self, like self.context<p>But nbd IMHO</div><br/><div id="39649823" class="c"><input type="checkbox" id="c-39649823" checked=""/><div class="controls bullet"><span class="by">krawczstef</span><span>|</span><a href="#39647915">root</a><span>|</span><a href="#39649503">parent</a><span>|</span><a href="#39649814">next</a><span>|</span><label class="collapse" for="c-39649823">[-]</label><label class="expand" for="c-39649823">[1 more]</label></div><br/><div class="children"><div class="content">yep nbd, but :&#x2F;</div><br/></div></div></div></div><div id="39649814" class="c"><input type="checkbox" id="c-39649814" checked=""/><div class="controls bullet"><span class="by">krawczstef</span><span>|</span><a href="#39647915">root</a><span>|</span><a href="#39649444">parent</a><span>|</span><a href="#39649503">prev</a><span>|</span><a href="#39643642">next</a><span>|</span><label class="collapse" for="c-39649814">[-]</label><label class="expand" for="c-39649814">[1 more]</label></div><br/><div class="children"><div class="content">you could just make them optional arguments that you inject if they&#x27;re declared. Happy to chat more. With Hamilton we could actually build an alternative way to describe your API pretty easily...</div><br/></div></div></div></div></div></div><div id="39643642" class="c"><input type="checkbox" id="c-39643642" checked=""/><div class="controls bullet"><span class="by">kevinlu1248</span><span>|</span><a href="#39647915">prev</a><span>|</span><a href="#39649442">next</a><span>|</span><label class="collapse" for="c-39643642">[-]</label><label class="expand" for="c-39643642">[2 more]</label></div><br/><div class="children"><div class="content">We&#x27;re building a webhook services on FastAPI + Celery + Redis + Grafana + Loki and the experience with setting up every service incrementally was miserable, and even then it feels like logs are being dropped and we run into reliability issues. Felt like something like this should exist already but I couldn&#x27;t find anything at the time. Really excited to see where this takes us!</div><br/><div id="39643727" class="c"><input type="checkbox" id="c-39643727" checked=""/><div class="controls bullet"><span class="by">tasn</span><span>|</span><a href="#39643642">parent</a><span>|</span><a href="#39649442">next</a><span>|</span><label class="collapse" for="c-39643727">[-]</label><label class="expand" for="c-39643727">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly why we built Svix[1]. Building webhooks services, even with amazing tools like FastAPI, Celery and Redis is still a big pain. So we just built a product to solve it.<p>Hatchet looks cool nonetheless. Queues are a pain for many other use-cases too.<p>1: <a href="https:&#x2F;&#x2F;www.svix.com">https:&#x2F;&#x2F;www.svix.com</a></div><br/></div></div></div></div><div id="39649442" class="c"><input type="checkbox" id="c-39649442" checked=""/><div class="controls bullet"><span class="by">Yanael</span><span>|</span><a href="#39643642">prev</a><span>|</span><a href="#39643364">next</a><span>|</span><label class="collapse" for="c-39649442">[-]</label><label class="expand" for="c-39649442">[2 more]</label></div><br/><div class="children"><div class="content">Looks very promising. Recently, I built an asynchronous DAG executor in Python, and I always felt I was reinventing the wheel, but when looking for a resilient and distributed DAG executor, nothing was really meeting the requirements. The feature set is appealing. Wondering if adding&#x2F;removing&#x2F;skipping nodes to the DAG dynamically at runtime is possible.</div><br/><div id="39649804" class="c"><input type="checkbox" id="c-39649804" checked=""/><div class="controls bullet"><span class="by">leafmeal</span><span>|</span><a href="#39649442">parent</a><span>|</span><a href="#39643364">next</a><span>|</span><label class="collapse" for="c-39649804">[-]</label><label class="expand" for="c-39649804">[1 more]</label></div><br/><div class="children"><div class="content">a little late now, but I wonder if <a href="https:&#x2F;&#x2F;github.com&#x2F;DataBiosphere&#x2F;toil">https:&#x2F;&#x2F;github.com&#x2F;DataBiosphere&#x2F;toil</a> might meet your requirements</div><br/></div></div></div></div><div id="39643364" class="c"><input type="checkbox" id="c-39643364" checked=""/><div class="controls bullet"><span class="by">topicseed</span><span>|</span><a href="#39649442">prev</a><span>|</span><a href="#39646970">next</a><span>|</span><label class="collapse" for="c-39643364">[-]</label><label class="expand" for="c-39643364">[8 more]</label></div><br/><div class="children"><div class="content">What specific strategies does Hatchet employ to guarantee fault tolerance and enable durable execution? How does it handle partial failures in multi-step workflows?</div><br/><div id="39643881" class="c"><input type="checkbox" id="c-39643881" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39643364">parent</a><span>|</span><a href="#39646970">next</a><span>|</span><label class="collapse" for="c-39643881">[-]</label><label class="expand" for="c-39643881">[7 more]</label></div><br/><div class="children"><div class="content">Each task in Hatchet is backed by a workflow [1]. Workflows are predefined steps which are persisted in PostgreSQL. If a worker dies or crashes midway through (stops heartbeating to the engine), we reassign tasks (assuming they have retries left). We also track timeouts in the database, which means if we miss a timeout, we simply retry after some amount of time. Like I mentioned in the post, we avoid some classes of faults just by relying on PostgreSQL and persisting each workflow run, so you don&#x27;t need to time out with distributed locks in Redis, for example, or worry about data loss if Redis OOMs. Our `ticker` service is basically its own worker which is assigned a lease for each step run.<p>We also store the input&#x2F;output of each workflow step in the database. So resuming a multi-step workflow is pretty simple - we just replay the step with the same input.<p>To zoom out a bit - unlike many alternatives [2], the execution path of a multi-step workflow in Hatchet is declared ahead of time. There are tradeoffs to this approach; it makes it much easier to run a single-step workflow or if you know the workflow execution path ahead of time. You also avoid classes of problems related to workflow versioning, we can gracefully drain older workflow version with a different execution path. It&#x27;s also more natural to debug and see a DAG execution instead of debugging procedural logic.<p>The clear tradeoff is that you can&#x27;t try...catch the execution of a single task or concatenate a bunch of futures that you wait for later. Roadmap-wise, we&#x27;re considering adding procedural execution on top of our workflows concept. Which means providing a nice API for calling `await workflow.run` and capturing errors. These would be a higher-level concept in Hatchet and are not built yet.<p>There are some interesting concepts around using semaphores and durable leases that are relevant here, which we&#x27;re exploring [3].<p>[1] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;basics&#x2F;workflows">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;basics&#x2F;workflows</a>
[2] <a href="https:&#x2F;&#x2F;temporal.io" rel="nofollow">https:&#x2F;&#x2F;temporal.io</a>
[3] <a href="https:&#x2F;&#x2F;www.citusdata.com&#x2F;blog&#x2F;2016&#x2F;08&#x2F;12&#x2F;state-machines-to-run-databases&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.citusdata.com&#x2F;blog&#x2F;2016&#x2F;08&#x2F;12&#x2F;state-machines-to-...</a></div><br/><div id="39644522" class="c"><input type="checkbox" id="c-39644522" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#39643364">root</a><span>|</span><a href="#39643881">parent</a><span>|</span><a href="#39645566">next</a><span>|</span><label class="collapse" for="c-39644522">[-]</label><label class="expand" for="c-39644522">[3 more]</label></div><br/><div class="children"><div class="content">What happens if a worker goes silent for longer than the heartbeat duration, then a new worker is spawned, then the original worker “comes back to life”? For example, because there was a network partition, or because the first worker’s host machine was sleeping, or even just that the first worker process was CPU starved?</div><br/><div id="39647221" class="c"><input type="checkbox" id="c-39647221" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39643364">root</a><span>|</span><a href="#39644522">parent</a><span>|</span><a href="#39645566">next</a><span>|</span><label class="collapse" for="c-39647221">[-]</label><label class="expand" for="c-39647221">[2 more]</label></div><br/><div class="children"><div class="content">The heartbeat duration (5s) is not the same as the inactive duration (60s). If a worker has been down for 60 seconds, we reassign to provide some buffer and handle unstable networks. Once someone asks we&#x27;ll expose these options and make them configurable.<p>We currently send cancellation signals for individual tasks to workers, but our cancellation signals aren&#x27;t replayed if they fail on the network. This is an important edge case for us to figure out.<p>There&#x27;s not much we can do if the worker ignores that signal. We should probably add some alerting if we see multiple responses on the same task, because that means the worker is ignoring the cancellation signal. This would also be a problem if workloads start blocking the whole thread.</div><br/><div id="39647844" class="c"><input type="checkbox" id="c-39647844" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#39643364">root</a><span>|</span><a href="#39647221">parent</a><span>|</span><a href="#39645566">next</a><span>|</span><label class="collapse" for="c-39647844">[-]</label><label class="expand" for="c-39647844">[1 more]</label></div><br/><div class="children"><div class="content">Right, I meant inactive duration, of course.<p>Cancellation signals are tricky. You of course cannot be sure that the remote end receives it. This turns into the two generals problem.<p>Yes, you need monitoring for this case. I work on scientific workloads which can completely consume CPU resources. This failure scenario is quite real.<p>Not all tasks are idempotent, but it sounds like a prudent user should try to design things that way, since your system has “at least once” execution of tasks, as opposed to “at most once.” Despite any marketing claims, “exactly once” is not generally possible.<p>Good docs on this point are important, as is configurability for cases when “at most once” is preferable.</div><br/></div></div></div></div></div></div><div id="39645566" class="c"><input type="checkbox" id="c-39645566" checked=""/><div class="controls bullet"><span class="by">sigmarule</span><span>|</span><a href="#39643364">root</a><span>|</span><a href="#39643881">parent</a><span>|</span><a href="#39644522">prev</a><span>|</span><a href="#39644055">next</a><span>|</span><label class="collapse" for="c-39645566">[-]</label><label class="expand" for="c-39645566">[2 more]</label></div><br/><div class="children"><div class="content">I think the answer is no but just to be sure: are you able to trigger step executions programmatically from within a step, even if you can&#x27;t await their results?<p>Related, but separately: can you trigger a variable number of task executions from one step? If the answer to the previous question is yes then it would of course be trivial; if not, I&#x27;m wondering if you could i.e. have a task act as a generator and yield values, or just return a list, and have each individual item get passed off to its own execution of the next task(s) in the DAG.<p>For example some of the examples involve a load_docs step, but all loaded docs seem to be passed to the next step execution in the DAG together, unless I&#x27;m just misunderstanding something. How could we tweak such an example to have a separate task execution per document loaded? The benefits of durable execution and being able to resume an intensive workflow without repeating work is lessened if you can&#x27;t naturally&#x2F;easily control the size of the unit of work for task executions.</div><br/><div id="39646219" class="c"><input type="checkbox" id="c-39646219" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39643364">root</a><span>|</span><a href="#39645566">parent</a><span>|</span><a href="#39644055">next</a><span>|</span><label class="collapse" for="c-39646219">[-]</label><label class="expand" for="c-39646219">[1 more]</label></div><br/><div class="children"><div class="content">You can execute a new workflow programmatically, for example see [1]. So people have triggered, for example, 50 child workflows from a parent step. As you&#x27;ve identified the difficult part there is the &quot;collect&quot; or &quot;gathering&quot; step, we&#x27;ve had people hack around that by waiting for all the steps from a second workflow (and falling back to the list events method to get status), but this isn&#x27;t an approach I&#x27;d recommend and it&#x27;s not well documented. And there&#x27;s no circuit breaker.<p>&gt; I&#x27;m wondering if you could i.e. have a task act as a generator and yield values, or just return a list, and have each individual item get passed off to its own execution of the next task(s) in the DAG.<p>Yeah, we were having a conversation yesterday about this - there&#x27;s probably a simple decorator we could add so that if a step returns an array, and a child step is dependent on that parent step, it fans out if a `fanout` key is set. If we can avoid unstructured trace diagrams in favor of a nice DAG-style workflow execution we&#x27;d prefer to support that.<p>The other thing we&#x27;ve started on is propagating a single &quot;flow id&quot; to each child workflow so we can provide the same visualization&#x2F;tracing that we provide in each workflow execution. This is similar to AWS X-rays.<p>As I mentioned we&#x27;re working on the durable workflow model, and we&#x27;ll find a way to make child workflows durable in the same way activities (and child workflows) are durable on Temporal.<p>[1] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;sdks&#x2F;typescript-sdk&#x2F;api&#x2F;admin-client#run_workflow">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;sdks&#x2F;typescript-sdk&#x2F;api&#x2F;admin-clien...</a></div><br/></div></div></div></div><div id="39644055" class="c"><input type="checkbox" id="c-39644055" checked=""/><div class="controls bullet"><span class="by">topicseed</span><span>|</span><a href="#39643364">root</a><span>|</span><a href="#39643881">parent</a><span>|</span><a href="#39645566">prev</a><span>|</span><a href="#39646970">next</a><span>|</span><label class="collapse" for="c-39644055">[-]</label><label class="expand" for="c-39644055">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the thorough response!</div><br/></div></div></div></div></div></div><div id="39646970" class="c"><input type="checkbox" id="c-39646970" checked=""/><div class="controls bullet"><span class="by">mfrye0</span><span>|</span><a href="#39643364">prev</a><span>|</span><a href="#39645091">next</a><span>|</span><label class="collapse" for="c-39646970">[-]</label><label class="expand" for="c-39646970">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been looking for this exact thing for awhile now. I&#x27;m just starting to dig into the docs and examples, and I have a question on workflows.<p>I have an existing pipeline that runs tasks across two K8 clusters and share a DB. Is it possible to define steps in a workflow where the step run logic is setup to run elsewhere? Essentially not having an inline run function defined, and another worker process listening for that step name.</div><br/><div id="39649456" class="c"><input type="checkbox" id="c-39649456" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39646970">parent</a><span>|</span><a href="#39645091">next</a><span>|</span><label class="collapse" for="c-39649456">[-]</label><label class="expand" for="c-39649456">[1 more]</label></div><br/><div class="children"><div class="content">This depends on the SDK - both Typescript and Golang support a `registerAction` method on the worker which basically let you register a single step to only run on that worker. You would then call `putWorkflow` programmatically before starting the worker. Steps are distributed by default so they run on the workers which have registered them. Happy to provide a more concrete example for the language you&#x27;re using.</div><br/></div></div></div></div><div id="39645091" class="c"><input type="checkbox" id="c-39645091" checked=""/><div class="controls bullet"><span class="by">acaloiar</span><span>|</span><a href="#39646970">prev</a><span>|</span><a href="#39643782">next</a><span>|</span><label class="collapse" for="c-39645091">[-]</label><label class="expand" for="c-39645091">[1 more]</label></div><br/><div class="children"><div class="content">A related lively dicussion from a few months ago: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37636841">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37636841</a><p>Long live Postgres queues.</div><br/></div></div><div id="39643782" class="c"><input type="checkbox" id="c-39643782" checked=""/><div class="controls bullet"><span class="by">pyrossh</span><span>|</span><a href="#39645091">prev</a><span>|</span><a href="#39645974">next</a><span>|</span><label class="collapse" for="c-39643782">[-]</label><label class="expand" for="c-39643782">[2 more]</label></div><br/><div class="children"><div class="content">How is this different from pg-boss[1]? Other than the distributed part it also seems to use skip locked.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;timgit&#x2F;pg-boss">https:&#x2F;&#x2F;github.com&#x2F;timgit&#x2F;pg-boss</a></div><br/><div id="39644327" class="c"><input type="checkbox" id="c-39644327" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39643782">parent</a><span>|</span><a href="#39645974">next</a><span>|</span><label class="collapse" for="c-39644327">[-]</label><label class="expand" for="c-39644327">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used pg-boss, and feature-wise it looks very similar and is an impressive project.<p>The core difference is that pg-boss is a library while Hatchet is a separate service which runs independently of your workers. This service also provides a UI and API for interacting with Hatchet - I don&#x27;t think pg-boss has those things, so you&#x27;d probably have to build out observability yourself.<p>This doesn&#x27;t make a huge difference when you&#x27;re at 1 worker, but having each worker poll your database can lead to DB issues if you&#x27;re not careful - I&#x27;ve seen some pretty low-throughput setups for very long-running jobs using a database with 60 CPUs because of polling workers. Hatchet distributes in two layers - the &quot;engine&quot; and the &quot;worker&quot; layer. Each engine polls the database and fans out to the workers over a long-lived gRPC connection. This reduces pressure on the DB and lets us manage which workers to assign tasks to based on things like max concurrent runs on each worker or worker health.</div><br/></div></div></div></div><div id="39645974" class="c"><input type="checkbox" id="c-39645974" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39643782">prev</a><span>|</span><a href="#39649393">next</a><span>|</span><label class="collapse" for="c-39645974">[-]</label><label class="expand" for="c-39645974">[3 more]</label></div><br/><div class="children"><div class="content">It’s been about a dozen years since I heard someone assert that some CI&#x2F;CD services were the most reliable task scheduling software for periodic tasks (far better than cron). Shouldn’t the scheduling be factored out as a separate library?<p>I found that shocking at the time, if plausible, and wondered why nobody pulled on that thread. I suppose like me they had bigger fish to fry.</div><br/><div id="39647338" class="c"><input type="checkbox" id="c-39647338" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39645974">parent</a><span>|</span><a href="#39649944">next</a><span>|</span><label class="collapse" for="c-39647338">[-]</label><label class="expand" for="c-39647338">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28234057">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28234057</a><p>If you&#x27;re saying that the scheduling in Hatchet should be a separate library, we rely on go-cron [1] to run cron schedules.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;go-co-op&#x2F;gocron">https:&#x2F;&#x2F;github.com&#x2F;go-co-op&#x2F;gocron</a></div><br/></div></div><div id="39649944" class="c"><input type="checkbox" id="c-39649944" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39645974">parent</a><span>|</span><a href="#39647338">prev</a><span>|</span><a href="#39649393">next</a><span>|</span><label class="collapse" for="c-39649944">[-]</label><label class="expand" for="c-39649944">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, I&#x27;m doing something like that right now, just not in a position to show.<p>All I want is a simple way to specify a tree of jobs to run to do things like checkout a git branch, build it, run the tests, then install the artifacts.<p>Or push a new static website to some site. Or periodically do something.<p>My grug brain simply doesn&#x27;t want to deal with <i>modern way of doing</i> $SHIT. I don&#x27;t need to manage a million different tasks per hour, so scaling vertically is acceptable to me, and the benefits of scaling horizontally simply don&#x27;t appear in my use cases.</div><br/></div></div></div></div><div id="39649393" class="c"><input type="checkbox" id="c-39649393" checked=""/><div class="controls bullet"><span class="by">CoolCold</span><span>|</span><a href="#39645974">prev</a><span>|</span><a href="#39646077">next</a><span>|</span><label class="collapse" for="c-39649393">[-]</label><label class="expand" for="c-39649393">[1 more]</label></div><br/><div class="children"><div class="content">From your experience, what would be a good way for doing Postgres Master-Master ? My understanding that Postgres Professional&#x2F;EnterpriseDB based solutions provide reliable M-M and those are proprietary.</div><br/></div></div><div id="39646077" class="c"><input type="checkbox" id="c-39646077" checked=""/><div class="controls bullet"><span class="by">treesciencebot</span><span>|</span><a href="#39649393">prev</a><span>|</span><a href="#39649341">next</a><span>|</span><label class="collapse" for="c-39646077">[-]</label><label class="expand" for="c-39646077">[2 more]</label></div><br/><div class="children"><div class="content">Latency is really important and that is honestly why we re-wrote most of this stuck ourselves but the project with the gurantee of 25ms&lt; looks interesting. I wish there was an &quot;instant&quot; mode where enough workers are available it could just do direct placement.</div><br/><div id="39647307" class="c"><input type="checkbox" id="c-39647307" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39646077">parent</a><span>|</span><a href="#39649341">next</a><span>|</span><label class="collapse" for="c-39647307">[-]</label><label class="expand" for="c-39647307">[1 more]</label></div><br/><div class="children"><div class="content">To be clear, the 25ms isn&#x27;t a guarantee. We have a load testing CLI [1] and the secondary steps on multi-step workflows are in the range of 25ms, while the first steps are in the range of 50ms, so that&#x27;s what I&#x27;m referencing.<p>There&#x27;s still a lot of work to do for optimization though, particularly to improve the polling interval if there aren&#x27;t workers available to run the task. Some people might expect to set a max concurrency limit of 1 on each worker and have each subsequent workflow take 50ms to start, which isn&#x27;t be the case at the moment.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;tree&#x2F;main&#x2F;examples&#x2F;loadtest&#x2F;cli">https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;tree&#x2F;main&#x2F;examples&#x2F;lo...</a></div><br/></div></div></div></div><div id="39649341" class="c"><input type="checkbox" id="c-39649341" checked=""/><div class="controls bullet"><span class="by">dataangel</span><span>|</span><a href="#39646077">prev</a><span>|</span><a href="#39643575">next</a><span>|</span><label class="collapse" for="c-39649341">[-]</label><label class="expand" for="c-39649341">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Distributed<p>&gt; Built on PostGRES<p>Not what people usually mean by distributed, caveat emptor</div><br/></div></div><div id="39643575" class="c"><input type="checkbox" id="c-39643575" checked=""/><div class="controls bullet"><span class="by">tzahifadida</span><span>|</span><a href="#39649341">prev</a><span>|</span><a href="#39647943">next</a><span>|</span><label class="collapse" for="c-39643575">[-]</label><label class="expand" for="c-39643575">[5 more]</label></div><br/><div class="children"><div class="content">Why not use postgres listen&#x2F;notify instead of rabbitmq pub sub.</div><br/><div id="39643940" class="c"><input type="checkbox" id="c-39643940" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39643575">parent</a><span>|</span><a href="#39643663">next</a><span>|</span><label class="collapse" for="c-39643940">[-]</label><label class="expand" for="c-39643940">[2 more]</label></div><br/><div class="children"><div class="content">When I started on this codebase, we needed to implement some custom exchange logic that maps very neatly to fanout exchanges and non-durable queues in RabbitMQ and weren&#x27;t built out on our PostgreSQL layer yet. This was a bootstrapping problem. Like I mentioned in the comment, we&#x27;d like to switch to pub&#x2F;sub pattern that lets us distribute our engine over multiple geographies. Listen&#x2F;notify could be the answer once we migrate to PG 16, though there are some concerns around connection poolers like pg_bouncer having limited support for listen&#x2F;notify. There&#x27;s a Github discussion on this if you&#x27;re curious: <a href="https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;discussions&#x2F;224">https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;discussions&#x2F;224</a>.</div><br/><div id="39646840" class="c"><input type="checkbox" id="c-39646840" checked=""/><div class="controls bullet"><span class="by">tzahifadida</span><span>|</span><a href="#39643575">root</a><span>|</span><a href="#39643940">parent</a><span>|</span><a href="#39643663">next</a><span>|</span><label class="collapse" for="c-39646840">[-]</label><label class="expand" for="c-39646840">[1 more]</label></div><br/><div class="children"><div class="content">I use haproxy with go listen notify of one of the libs. It works as long as the connection is up. I.e.i have a timeout of 30 min configured in haproxy. Then you have to assume you lost sync and recheck. That is not that bad every 30min... at least for me. You can configure to never close...</div><br/></div></div></div></div><div id="39643663" class="c"><input type="checkbox" id="c-39643663" checked=""/><div class="controls bullet"><span class="by">anentropic</span><span>|</span><a href="#39643575">parent</a><span>|</span><a href="#39643940">prev</a><span>|</span><a href="#39647943">next</a><span>|</span><label class="collapse" for="c-39643663">[-]</label><label class="expand" for="c-39643663">[2 more]</label></div><br/><div class="children"><div class="content">It uses Postgres rather than RabbitMQ: <a href="https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet?tab=readme-ov-file#how-does-this-compare-to-alternatives-celery-bullmq">https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet?tab=readme-ov-file#ho...</a></div><br/><div id="39645790" class="c"><input type="checkbox" id="c-39645790" checked=""/><div class="controls bullet"><span class="by">anentropic</span><span>|</span><a href="#39643575">root</a><span>|</span><a href="#39643663">parent</a><span>|</span><a href="#39647943">next</a><span>|</span><label class="collapse" for="c-39645790">[-]</label><label class="expand" for="c-39645790">[1 more]</label></div><br/><div class="children"><div class="content">I see... apparently it uses both</div><br/></div></div></div></div></div></div><div id="39647943" class="c"><input type="checkbox" id="c-39647943" checked=""/><div class="controls bullet"><span class="by">iangregson</span><span>|</span><a href="#39643575">prev</a><span>|</span><a href="#39649268">next</a><span>|</span><label class="collapse" for="c-39647943">[-]</label><label class="expand" for="c-39647943">[1 more]</label></div><br/><div class="children"><div class="content">I love this idea. I wish it existed a few years ago when I did a not so good job of implementing a distributed DAG processing system :D<p>Looking forward to trying it out!</div><br/></div></div><div id="39649268" class="c"><input type="checkbox" id="c-39649268" checked=""/><div class="controls bullet"><span class="by">peterisdirsa</span><span>|</span><a href="#39647943">prev</a><span>|</span><a href="#39643868">next</a><span>|</span><label class="collapse" for="c-39649268">[-]</label><label class="expand" for="c-39649268">[1 more]</label></div><br/><div class="children"><div class="content">This is not a viable product, it&#x27;s a feature</div><br/></div></div><div id="39643868" class="c"><input type="checkbox" id="c-39643868" checked=""/><div class="controls bullet"><span class="by">radus</span><span>|</span><a href="#39649268">prev</a><span>|</span><a href="#39643427">next</a><span>|</span><label class="collapse" for="c-39643868">[-]</label><label class="expand" for="c-39643868">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve explained your value proposition vs. celery, but I&#x27;m curious if you also see Hatchet as an alternative to Nextflow&#x2F;Snakemake which are commonly used in bioinformatics.</div><br/></div></div><div id="39643427" class="c"><input type="checkbox" id="c-39643427" checked=""/><div class="controls bullet"><span class="by">nextworddev</span><span>|</span><a href="#39643868">prev</a><span>|</span><label class="collapse" for="c-39643427">[-]</label><label class="expand" for="c-39643427">[2 more]</label></div><br/><div class="children"><div class="content">I’m interested in self hosting this. What’s the recommendation here for state persistence and self healing? Wish there was a guide for a small team who wants to self host before trying managed cloud</div><br/><div id="39644042" class="c"><input type="checkbox" id="c-39644042" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#39643427">parent</a><span>|</span><label class="collapse" for="c-39644042">[-]</label><label class="expand" for="c-39644042">[1 more]</label></div><br/><div class="children"><div class="content">I think we might have had a dead link in the README to our self-hosting guide, here it is: <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;self-hosting">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;self-hosting</a>.<p>The component which needs the highest uptime is our ingestion service [1]. This ingests events from the Hatchet SDKs and is responsible for writing the workflow execution path, and then sends messages downstream to our other engine components. This is a horizontally scalable service and you should run at least 2 replicas across different AZs. Also see how to configure different services for engine components [2].<p>The other piece of this is PostgreSQL, use your favorite managed provider which has point-in-time restores and backups. This is the core of our self-healing, I&#x27;m not sure where it makes sense to route writes if the primary goes down.<p>Let me know what you need for self-hosted docs, happy to write them up for you.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;tree&#x2F;main&#x2F;internal&#x2F;services&#x2F;ingestor">https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;tree&#x2F;main&#x2F;internal&#x2F;se...</a>
[2] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;self-hosting&#x2F;configuration-options#services-configuration">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;self-hosting&#x2F;configuration-options#...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>