<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689152467644" as="style"/><link rel="stylesheet" href="styles.css?v=1689152467644"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wouter.coekaerts.be/2023/breaking-string">Breaking java.lang.String</a> <span class="domain">(<a href="https://wouter.coekaerts.be">wouter.coekaerts.be</a>)</span></div><div class="subtext"><span>coekie</span> | <span>78 comments</span></div><br/><div><div id="36689281" class="c"><input type="checkbox" id="c-36689281" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#36689601">next</a><span>|</span><label class="collapse" for="c-36689281">[-]</label><label class="expand" for="c-36689281">[24 more]</label></div><br/><div class="children"><div class="content">Is this actually a bug? The default assumption in Java is that types are not thread-safe unless otherwise specified. Attempting to use types in a way that exceeds their documented thread safety has always been allowed to leave your program in an inconsistent state.</div><br/><div id="36689404" class="c"><input type="checkbox" id="c-36689404" checked=""/><div class="controls bullet"><span class="by">cempaka</span><span>|</span><a href="#36689281">parent</a><span>|</span><a href="#36691808">next</a><span>|</span><label class="collapse" for="c-36689404">[-]</label><label class="expand" for="c-36689404">[12 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, but in the case of Strings in particular they are generally considered to be thread-safe by virtue of being immutable (and the Javadocs themselves say this in many places). Concurrently modifying the input character array may seem like willful abuse in this case, but I suppose there might be some carelessly written code out there which does it and the post shows how it would create some weird and very hard-to-debug behavior. And I can see the argument going both ways as far as the Javadoc: on the one hand, it only promises to return a String representing what is <i>currently</i> in the input character array, which seems to warn against concurrent&#x2F;subsequent modification at least obliquely. But on the other hand, it does seem to commit to an up-front defensive copy of the input character array which doesn&#x27;t quite take place, and without which things go a bit haywire if the encoding of the string changes.<p>I don&#x27;t think the correct answer is to sacrifice any performance to guard against this weird edge case, though.</div><br/><div id="36689569" class="c"><input type="checkbox" id="c-36689569" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36689404">parent</a><span>|</span><a href="#36691255">next</a><span>|</span><label class="collapse" for="c-36689569">[-]</label><label class="expand" for="c-36689569">[9 more]</label></div><br/><div class="children"><div class="content">As the article points out, the only thing the Javadoc guarantees is the subsequent modifications of the character array have no effect. It says nothing about concurrent modifications.<p>The type whose thread safety is in question here is not actually String, but char[]. I&#x27;m not going to say it is always wrong to share char[] between threads (as a primitive array of something other than double and long, the Java Spec does make some guarentees about char[]), however it is almost always wrong to be sharing char[] between threads.<p>If you want a language that protects you from this type of mistake, you simply need something more advanced than Java.<p>This isn&#x27;t even the biggest hole in Java&#x27;s safety. Java has a type system, which is at least a nominal claim to type safety. Yet, you can do things like:<p><pre><code>    Integer[] foo = new Integer[1];
    Object[] bar = foo;
    bar[0] = new Object()
</code></pre>
And the compiler will let you (although the runtime won&#x27;t).<p>Its even worse with generics:<p><pre><code>        List&lt;Integer&gt; foo = new ArrayList&lt;&gt;();
        List bar = foo;
        bar.add(new Object());
        System.out.println(foo.get(0));
        Integer x = foo.get(0);
</code></pre>
Will compile, and won&#x27;t even through an exception until the very last line, past the point where you have retrieved and used a non Integer from a List&lt;Integer&gt;<p>In fairness to java on the last one, it is at least a warning, and a deliberate compromise to support backwards compatability when they introduced generics.</div><br/><div id="36690679" class="c"><input type="checkbox" id="c-36690679" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36689569">parent</a><span>|</span><a href="#36690771">next</a><span>|</span><label class="collapse" for="c-36690679">[-]</label><label class="expand" for="c-36690679">[6 more]</label></div><br/><div class="children"><div class="content">While you are technically right in all your points, I think you exaggerate the problems regarding Java’s type system. Arrays are indeed a pain point from different times (the mistake of their covariance even “infected” C#), but generics are not problematic at all. In fact, code that compiles without warning is guaranteed to never get a ClassCastException.<p>Every language’s type system gives you escape hatches, so that last example is similar to how one might implement an optimization library in Rust where you have uninitiated elements. Hell, there you don’t even get runtime errors if you get it wrong, it will just segfault. So I really disagree with this notion of “it even worse with generics”.</div><br/><div id="36691559" class="c"><input type="checkbox" id="c-36691559" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36690679">parent</a><span>|</span><a href="#36691988">prev</a><span>|</span><a href="#36690771">next</a><span>|</span><label class="collapse" for="c-36691559">[-]</label><label class="expand" for="c-36691559">[4 more]</label></div><br/><div class="children"><div class="content">&gt; how one might implement an optimization library in Rust where you have uninitiated elements<p>The correct way to do this is use the MaybeUninit&lt;T&gt; type. Then you&#x27;re responsible for correctly initializing a T before you call MaybeUninit&lt;T&gt;::assume_init() to get a T.</div><br/><div id="36691691" class="c"><input type="checkbox" id="c-36691691" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36691559">parent</a><span>|</span><a href="#36690771">next</a><span>|</span><label class="collapse" for="c-36691691">[-]</label><label class="expand" for="c-36691691">[3 more]</label></div><br/><div class="children"><div class="content">And that MaybeUninit type uses an unsafe call under the hood as an escape hatch from the &quot;draconian&quot; compiler&#x27;s rules. Every practical language has these.<p>(nonetheless, thanks for mentioning the MaybeUninit, that was what I was thinking of, but didn&#x27;t remember the name -- I haven&#x27;t programmed in Rust for a long time)</div><br/><div id="36691923" class="c"><input type="checkbox" id="c-36691923" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36691691">parent</a><span>|</span><a href="#36690771">next</a><span>|</span><label class="collapse" for="c-36691923">[-]</label><label class="expand" for="c-36691923">[2 more]</label></div><br/><div class="children"><div class="content">MaybeUninit&lt;T&gt;::assume_init() <i>is</i> the unsafe call. The promise that this is actually a T and not just a T-sized blob of uninitialized memory is made by that unsafe call, and since it&#x27;s unsafe it&#x27;s your responsibility as the programmer to obey the constraint, that this is, in fact, an initialized T.<p>Depending on how long &quot;a long time&quot; is, you might well not actually have been thinking of MaybeUninit. The prior solution (until mid-2019) was as you describe, and it was in fact unsound.</div><br/><div id="36691956" class="c"><input type="checkbox" id="c-36691956" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36691923">parent</a><span>|</span><a href="#36690771">next</a><span>|</span><label class="collapse" for="c-36691956">[-]</label><label class="expand" for="c-36691956">[1 more]</label></div><br/><div class="children"><div class="content">The point I was trying to convey (badly) with this example is that in both the assign to raw generic and assume_init case, the developer overrides the compiler&#x27;s knowledge for his&#x2F;her, demonstrating that most languages have similar escape hatches, because they are sometimes simply needed.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36690771" class="c"><input type="checkbox" id="c-36690771" checked=""/><div class="controls bullet"><span class="by">sorokod</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36689569">parent</a><span>|</span><a href="#36690679">prev</a><span>|</span><a href="#36691255">next</a><span>|</span><label class="collapse" for="c-36690771">[-]</label><label class="expand" for="c-36690771">[2 more]</label></div><br/><div class="children"><div class="content">&quot;The type whose thread safety is in question here is not actually String, but char[]&quot;<p>Not quite, it is String constructor that has the race condition, char array is incidental there.</div><br/><div id="36691110" class="c"><input type="checkbox" id="c-36691110" checked=""/><div class="controls bullet"><span class="by">sk5t</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36690771">parent</a><span>|</span><a href="#36691255">next</a><span>|</span><label class="collapse" for="c-36691110">[-]</label><label class="expand" for="c-36691110">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn’t point the finger at the ctor; making a defensive deep copy of mutable parameters is not in the contract.</div><br/></div></div></div></div></div></div><div id="36691255" class="c"><input type="checkbox" id="c-36691255" checked=""/><div class="controls bullet"><span class="by">pitkali</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36689404">parent</a><span>|</span><a href="#36689569">prev</a><span>|</span><a href="#36691325">next</a><span>|</span><label class="collapse" for="c-36691255">[-]</label><label class="expand" for="c-36691255">[1 more]</label></div><br/><div class="children"><div class="content">Immutable types are only considered thread-safe after their construction, though.</div><br/></div></div><div id="36691325" class="c"><input type="checkbox" id="c-36691325" checked=""/><div class="controls bullet"><span class="by">elygre</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36689404">parent</a><span>|</span><a href="#36691255">prev</a><span>|</span><a href="#36691808">next</a><span>|</span><label class="collapse" for="c-36691325">[-]</label><label class="expand" for="c-36691325">[1 more]</label></div><br/><div class="children"><div class="content">I’d argue that while a string is thread safe, this is not actually a string yet.</div><br/></div></div></div></div><div id="36691808" class="c"><input type="checkbox" id="c-36691808" checked=""/><div class="controls bullet"><span class="by">coekie</span><span>|</span><a href="#36689281">parent</a><span>|</span><a href="#36689404">prev</a><span>|</span><a href="#36690312">next</a><span>|</span><label class="collapse" for="c-36691808">[-]</label><label class="expand" for="c-36691808">[1 more]</label></div><br/><div class="children"><div class="content">Author of the blog here.
Yes, this is a bug. While the javadoc doesn&#x27;t state it explicitly, immutable classes in the core library are expected to be thread safe. Java tries to be and mostly succeeds at being a safe language, where (by default) the guarantees of its internals cannot be broken no matter what user code does. The JVM preserves its own integrity.<p>There are some other deliberate holes in that safety, such as using reflection to access private members, and instrumentation, where it is clear you are stepping outside the safety zone, but even that is getting locked down now with the &quot;Integrity and Strong Encapsulation&quot; effort <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8305968" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8305968</a> .<p>In general, most code we write would not (and should not) try to protect against such abuse, but classes in the core platform play by different rules.<p>Btw, this has been accepted into the bug database now: <a href="https:&#x2F;&#x2F;bugs.java.com&#x2F;bugdatabase&#x2F;view_bug?bug_id=JDK-8311906" rel="nofollow noreferrer">https:&#x2F;&#x2F;bugs.java.com&#x2F;bugdatabase&#x2F;view_bug?bug_id=JDK-831190...</a> . I expect this to be fixed in a future release.</div><br/></div></div><div id="36690312" class="c"><input type="checkbox" id="c-36690312" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#36689281">parent</a><span>|</span><a href="#36691808">prev</a><span>|</span><a href="#36689660">next</a><span>|</span><label class="collapse" for="c-36690312">[-]</label><label class="expand" for="c-36690312">[1 more]</label></div><br/><div class="children"><div class="content">Not really. I&#x27;m sure there are some edge cases where the ability for someone to do silly things like this is harmful but otherwise this goes in category of things where the general advice is &quot;just don&#x27;t do that and you&#x27;re fine&quot;.<p>Basically, if you look at why the standard library would not go out of its way to prevent you from doing stuff like this it boils down to the same reason as why they put the string compression optimization in to begin with: doing so would make things slower rather than faster. And that&#x27;s just not desirable in something as performance critical as string initialization, which is a thing that a lot of Java programs would do a lot.<p>Having string compression helps save some memory but it&#x27;s a weird low level hack. It&#x27;s fine as long as you don&#x27;t actively try to break things in your own program. You&#x27;d have to jump through some hoops to do it accidentally. That is not likely to happen just like that.<p>So, not a bug but a known limitation that you should be aware of if you go down the path of doing lots of concurrent modifications to arrays that may or may not be used to create Strings. Java has lots of nice primitives and frameworks to make writing such code less error prone but it&#x27;s up to you to use those properly and it&#x27;s entirely possible to write all sorts of code that has lots of concurrency issues.</div><br/></div></div><div id="36689660" class="c"><input type="checkbox" id="c-36689660" checked=""/><div class="controls bullet"><span class="by">hashmash</span><span>|</span><a href="#36689281">parent</a><span>|</span><a href="#36690312">prev</a><span>|</span><a href="#36690805">next</a><span>|</span><label class="collapse" for="c-36689660">[-]</label><label class="expand" for="c-36689660">[3 more]</label></div><br/><div class="children"><div class="content">For locally generated strings, it&#x27;s not a concern. For String.intern, this is actually a very serious bug that should be treated as a security vulnerability.</div><br/><div id="36689728" class="c"><input type="checkbox" id="c-36689728" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36689660">parent</a><span>|</span><a href="#36690805">next</a><span>|</span><label class="collapse" for="c-36689728">[-]</label><label class="expand" for="c-36689728">[2 more]</label></div><br/><div class="children"><div class="content">At best it is only a security vulnerability if you are running different trust domains within your process. That is something Java supports, but most Java code does not attempt to take advantage of it. Most Java programs have 100% of there code being allowed to use reflection to simply hack the program however they please, including corrupting the intern pool.<p>But still, for the few people who actually trust Java&#x27;s isolation features and use it, possible bypasses are a concern. Having said that, I don&#x27;t see how you can turn this into an attack on String.intern.<p>The guarentees about interning are as follows:<p>&gt; When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.<p>&gt; It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.<p>If you pollute the pool with a &quot;broken&quot; String, all that would happen is that that String would not be returned in place of a logically equivalent correct String, and vice-versa.</div><br/><div id="36689846" class="c"><input type="checkbox" id="c-36689846" checked=""/><div class="controls bullet"><span class="by">hashmash</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36689728">parent</a><span>|</span><a href="#36690805">next</a><span>|</span><label class="collapse" for="c-36689846">[-]</label><label class="expand" for="c-36689846">[1 more]</label></div><br/><div class="children"><div class="content">If a security sensitive operation was (for whatever reason) calling startsWith (as shown in the blog), then it might return an incorrect result. I&#x27;m merely speculating that an exploit is possible, and I&#x27;m not aware of any code that would be affected.<p>Regardless, the fix is quite simple. The public String.intern method just needs to validate the encoding first. This will have little impact on performance because the String.intern method is rarely called.</div><br/></div></div></div></div></div></div><div id="36690805" class="c"><input type="checkbox" id="c-36690805" checked=""/><div class="controls bullet"><span class="by">pulse7</span><span>|</span><a href="#36689281">parent</a><span>|</span><a href="#36689660">prev</a><span>|</span><a href="#36689354">next</a><span>|</span><label class="collapse" for="c-36690805">[-]</label><label class="expand" for="c-36690805">[2 more]</label></div><br/><div class="children"><div class="content">I remember a bug in Visual&#x2F;Digitalk Smalltalk: conversion from integer to string  (method printString) was not thread safe, because it used global buffer for better performance. Very rarely - when we used a progress indicator in another thread (called Process in Visual Smalltalk) - this global buffer was overriden by another integer to string conversion... It took a year to find out the reason why our code sometimes got wrong results... I submitted the bug to Digitalk and they decided to not fix it (performance reasons). Only in later versions they abandoned the global buffer...</div><br/><div id="36691671" class="c"><input type="checkbox" id="c-36691671" checked=""/><div class="controls bullet"><span class="by">gene91</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36690805">parent</a><span>|</span><a href="#36689354">next</a><span>|</span><label class="collapse" for="c-36691671">[-]</label><label class="expand" for="c-36691671">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know the terminology for it. But the behavior that you just described isn’t just “not thread safe”. It’s violating basic assumptions. I’d call that hostile or a trap.</div><br/></div></div></div></div><div id="36689354" class="c"><input type="checkbox" id="c-36689354" checked=""/><div class="controls bullet"><span class="by">neandrake</span><span>|</span><a href="#36689281">parent</a><span>|</span><a href="#36690805">prev</a><span>|</span><a href="#36690106">next</a><span>|</span><label class="collapse" for="c-36689354">[-]</label><label class="expand" for="c-36689354">[1 more]</label></div><br/><div class="children"><div class="content">My thinking is the same. I doubt this is an oversight. Making the String constructor thread-safe would likely slow things significantly. Great point about things being assumed not thread-safe. The JDK is pretty thorough with documenting thread-safety.</div><br/></div></div><div id="36690106" class="c"><input type="checkbox" id="c-36690106" checked=""/><div class="controls bullet"><span class="by">NotYourLawyer</span><span>|</span><a href="#36689281">parent</a><span>|</span><a href="#36689354">prev</a><span>|</span><a href="#36691427">next</a><span>|</span><label class="collapse" for="c-36690106">[-]</label><label class="expand" for="c-36690106">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;&#x2F; compareTo does consider them equal (even though its javadoc<p>&#x2F;&#x2F; specifies that &quot;compareTo returns 0 exactly when the<p>&#x2F;&#x2F; equals(Object) method would return true&quot;)<p>Seems like at least a documentation error.</div><br/></div></div><div id="36691427" class="c"><input type="checkbox" id="c-36691427" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#36689281">parent</a><span>|</span><a href="#36690106">prev</a><span>|</span><a href="#36689601">next</a><span>|</span><label class="collapse" for="c-36691427">[-]</label><label class="expand" for="c-36691427">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Attempting to use types in a way that exceeds their documented thread safety has always been allowed to leave your program in an inconsistent state.<p>Wasn&#x27;t there an attempt for Java to define the range of outcomes even of programs with data races?</div><br/><div id="36691653" class="c"><input type="checkbox" id="c-36691653" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36689281">root</a><span>|</span><a href="#36691427">parent</a><span>|</span><a href="#36689601">next</a><span>|</span><label class="collapse" for="c-36691653">[-]</label><label class="expand" for="c-36691653">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Java promises (unlike C, C++, Go, etc.) not to have Undefined Behaviour as a result of data races, however you do lose Sequential Consistency, which means humans aren&#x27;t able to successfully reason about non-trivial programs with data races.<p>More specifically Java says something like, if you race a value of some sort, even a complex value like a hash table, it doesn&#x27;t get fatally damaged, but its new state is some state it had, or might have during other executions.</div><br/></div></div></div></div></div></div><div id="36689601" class="c"><input type="checkbox" id="c-36689601" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#36689281">prev</a><span>|</span><a href="#36688486">next</a><span>|</span><label class="collapse" for="c-36689601">[-]</label><label class="expand" for="c-36689601">[3 more]</label></div><br/><div class="children"><div class="content">Calling this a &quot;bug in java.lang.String&quot; is silly. The same &quot;bug&quot; exists for all functions that take mutable objects. If you take a map and lookup two different keys, yep, that&#x27;s a &quot;bug&quot;.<p>The bug is the other piece of code that introduces the data race in the first place. You can argue the case for languages like Rust with it&#x27;s borrow system, or others that use linear types or something along those lines, to eliminate the possibility of this happening, but it&#x27;s quite misleading to say that the innocent user of a mutable object is the source of a bug. You may as well say there&#x27;s a bug in `printf(&quot;Hello, World!\n&quot;);` in C because you could have another thread writing random values to random memory, running `while(1) { *((unsigned char*)(void*)rand()) = rand(); }`</div><br/><div id="36691695" class="c"><input type="checkbox" id="c-36691695" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#36689601">parent</a><span>|</span><a href="#36691413">next</a><span>|</span><label class="collapse" for="c-36691695">[-]</label><label class="expand" for="c-36691695">[1 more]</label></div><br/><div class="children"><div class="content">It’s a bug for constructor functions, in my book. I certainly always code defensively to prevent such misbehavior. A successfully constructed object should obey its documented interface contract, period.</div><br/></div></div><div id="36691413" class="c"><input type="checkbox" id="c-36691413" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36689601">parent</a><span>|</span><a href="#36691695">prev</a><span>|</span><a href="#36688486">next</a><span>|</span><label class="collapse" for="c-36691413">[-]</label><label class="expand" for="c-36691413">[1 more]</label></div><br/><div class="children"><div class="content">It is probably a gotcha. But yeah if you hit this problem you have bigger worries, the code immediately before the constructor is not thread safe.</div><br/></div></div></div></div><div id="36688486" class="c"><input type="checkbox" id="c-36688486" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#36689601">prev</a><span>|</span><a href="#36688766">next</a><span>|</span><label class="collapse" for="c-36688486">[-]</label><label class="expand" for="c-36688486">[6 more]</label></div><br/><div class="children"><div class="content">This is exactly why java needs frozen arrays [1].<p>The safe thing to do is freeze the array before doing anything with it.  Then, you can rely on COW to copy to the array if someone is modifying it concurrently with you reading it.  In the general case, you&#x27;d have fast string creation and in the tricky case you simply pay the clone cost as a penalty for being dumb.<p>[1] <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8261007#:~:text=How%20do%20I%20use%20a%20frozen%20array%3F%201,an%20array%20is%20frozen%20or%20modifiable.%20More%20items" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8261007#:~:text=How%20do%20I%20use%...</a></div><br/><div id="36691713" class="c"><input type="checkbox" id="c-36691713" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#36688486">parent</a><span>|</span><a href="#36688818">next</a><span>|</span><label class="collapse" for="c-36691713">[-]</label><label class="expand" for="c-36691713">[1 more]</label></div><br/><div class="children"><div class="content">This doesn’t help when the parameter is one of the collection interfaces, or CharSequence, or the like. You always need to defensively copy their contents first to “freeze“ their values.</div><br/></div></div><div id="36688818" class="c"><input type="checkbox" id="c-36688818" checked=""/><div class="controls bullet"><span class="by">malfist</span><span>|</span><a href="#36688486">parent</a><span>|</span><a href="#36691713">prev</a><span>|</span><a href="#36688766">next</a><span>|</span><label class="collapse" for="c-36688818">[-]</label><label class="expand" for="c-36688818">[4 more]</label></div><br/><div class="children"><div class="content">Java does have immutable collections. It&#x27;s just not an explicit type.<p>Lots of common ways to instantiate arrays (i.e. Arrays.asList) generate immutable lists</div><br/><div id="36689750" class="c"><input type="checkbox" id="c-36689750" checked=""/><div class="controls bullet"><span class="by">cowsandmilk</span><span>|</span><a href="#36688486">root</a><span>|</span><a href="#36688818">parent</a><span>|</span><a href="#36689317">next</a><span>|</span><label class="collapse" for="c-36689750">[-]</label><label class="expand" for="c-36689750">[1 more]</label></div><br/><div class="children"><div class="content">Arrays.asList doesn’t generate an immutable list, prevent writes to the array, or prevent modifying the array via the List interface.<p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;17&#x2F;docs&#x2F;api&#x2F;java.base&#x2F;java&#x2F;util&#x2F;Arrays.html#asList(T" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;17&#x2F;docs&#x2F;api&#x2F;java.base...</a>...)</div><br/></div></div><div id="36689317" class="c"><input type="checkbox" id="c-36689317" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#36688486">root</a><span>|</span><a href="#36688818">parent</a><span>|</span><a href="#36689750">prev</a><span>|</span><a href="#36688766">next</a><span>|</span><label class="collapse" for="c-36689317">[-]</label><label class="expand" for="c-36689317">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s instantiating a List, not an array.</div><br/><div id="36691754" class="c"><input type="checkbox" id="c-36691754" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36688486">root</a><span>|</span><a href="#36689317">parent</a><span>|</span><a href="#36688766">next</a><span>|</span><label class="collapse" for="c-36691754">[-]</label><label class="expand" for="c-36691754">[1 more]</label></div><br/><div class="children"><div class="content">As you would expect in a vaguely modern language, Java&#x27;s &quot;List&quot; interface is typically backed by a growable array as the type ArrayList. Only people who have no idea about caches would think List should necessarily be some sort of <i>Linked</i> List type.<p>You would use Collections.unmodifiableList to make it unmodifiable.</div><br/></div></div></div></div></div></div></div></div><div id="36688766" class="c"><input type="checkbox" id="c-36688766" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#36688486">prev</a><span>|</span><a href="#36689210">next</a><span>|</span><label class="collapse" for="c-36688766">[-]</label><label class="expand" for="c-36688766">[29 more]</label></div><br/><div class="children"><div class="content">This is the exact kind of bug that Rust solves with its borrowing system. The problem is that Java has no way to express the concept of &quot;something that nothing else can modify while I&#x27;m looking at it&quot;.</div><br/><div id="36691792" class="c"><input type="checkbox" id="c-36691792" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#36688766">parent</a><span>|</span><a href="#36688806">next</a><span>|</span><label class="collapse" for="c-36691792">[-]</label><label class="expand" for="c-36691792">[1 more]</label></div><br/><div class="children"><div class="content">Arguably, C++ arguably already solved that specific problem with const safety. I was flabbergasted back in 1995 that Java had dropped that notion.</div><br/></div></div><div id="36688806" class="c"><input type="checkbox" id="c-36688806" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#36688766">parent</a><span>|</span><a href="#36691792">prev</a><span>|</span><a href="#36689210">next</a><span>|</span><label class="collapse" for="c-36688806">[-]</label><label class="expand" for="c-36688806">[27 more]</label></div><br/><div class="children"><div class="content">Mutexes etc ... exist in Java.</div><br/><div id="36688842" class="c"><input type="checkbox" id="c-36688842" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36688806">parent</a><span>|</span><a href="#36688937">next</a><span>|</span><label class="collapse" for="c-36688842">[-]</label><label class="expand" for="c-36688842">[18 more]</label></div><br/><div class="children"><div class="content">Right, but in rust, not using one is a compile time error. In Java (as you can see by the article), not using one is a silent bug at runtime.</div><br/><div id="36691031" class="c"><input type="checkbox" id="c-36691031" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36688842">parent</a><span>|</span><a href="#36689089">next</a><span>|</span><label class="collapse" for="c-36691031">[-]</label><label class="expand" for="c-36691031">[1 more]</label></div><br/><div class="children"><div class="content">Only for in-memory data structures under Rust&#x27;s control, if it is related to OS IPC, Rust cannot do anything.</div><br/></div></div><div id="36689089" class="c"><input type="checkbox" id="c-36689089" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36688842">parent</a><span>|</span><a href="#36691031">prev</a><span>|</span><a href="#36688937">next</a><span>|</span><label class="collapse" for="c-36689089">[-]</label><label class="expand" for="c-36689089">[16 more]</label></div><br/><div class="children"><div class="content">This is a heavily optimized system library - you don’t use mutexes here. Rust wouldn’t help here, if mutexes would be fine, they would have been used. Especially that this is the result of C++ and Java code simultaneously.<p>Hell, it’s probably one area where rust’s benefits are a “hard sell” — you would have to constantly be in unsafe rust manipulating pointers manually as the compiler <i>can’t</i> reason statically about what a layer built on top does without a huge runtime cost (huge, as in you really don’t want to lock&#x2F;unlock, or even refcount in these hot paths).</div><br/><div id="36689765" class="c"><input type="checkbox" id="c-36689765" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689089">parent</a><span>|</span><a href="#36690039">next</a><span>|</span><label class="collapse" for="c-36689765">[-]</label><label class="expand" for="c-36689765">[8 more]</label></div><br/><div class="children"><div class="content">No idea why Thaxll and the other comments are mentioning mutexes.<p>The equivalent (*) API to this Java API in Rust does exist; it&#x27;s `String::from_utf8(Vec&lt;u8&gt;) -&gt; String`. And the bug in TFA does not exist there. Since the signature consumes the `Vec&lt;u8&gt;` it&#x27;s impossible for the caller or any other code to still have access to it to be able to modify it concurrently.<p>Also consider the similar API `str::from_utf8(&amp;[u8]) -&gt; &amp;str`. The bug in TFA does not exist here either. Since the signature takes a `&amp;` borrow of the slice, it is not possible for anything else in the program to have a `&amp;mut` borrow of that slice to be able to modify it concurrently. After the function returns other parts of the program could mutate the slice, but they would only be able to do after the `&amp;str` that is derived from the slice is dropped. So once again nothing would be able to mutate the slice and observe the effects in the `&amp;str` itself.<p>All these &quot;unable to do&quot; are enforced at compile-time, because &quot;consuming a value makes it unavailable to other parts of the program&quot; and &quot;cannot get a `&amp;mut` to a value as long as a `&amp;` from that value is still in scope&quot; are all typesystem concepts. No mutexes or other runtime checks are involved.<p>(*) &quot;Equivalent&quot; in that it&#x27;s an API to convert a sequence of bytes into a string. The Rust API doesn&#x27;t have the encoding thing of the Java API because the Rust String &#x2F; str are required to be utf-8 internally. But if an exact equivalent of the Java API did exist in Rust, the signature would still be the same wrt consuming `Vec&lt;u8&gt;` &#x2F; borrowing `[u8]`, so it doesn&#x27;t change the overall point re: concurrent modification. Furthermore, concurrent modification would cause problems even with Rust Strings if it was possible, because it would allow a String &#x2F; str to become invalid utf-8 after they&#x27;d already been checked to be valid utf-8, which Rust considers to be UB.</div><br/><div id="36691465" class="c"><input type="checkbox" id="c-36691465" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689765">parent</a><span>|</span><a href="#36690660">next</a><span>|</span><label class="collapse" for="c-36691465">[-]</label><label class="expand" for="c-36691465">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No idea why Thaxll and the other comments are mentioning mutexes.<p><i>Thaxll</i> mentioned mutexes in a reply to the statement<p><i>Java has no way to express the concept of &quot;something that nothing else can modify while I&#x27;m looking at it&quot;</i><p>Even ignoring the performance aspect that is not the perfect answer, though. AFAIK, the JVM doesn’t have a notion of “you can only modify <i>foo</i> if you hold mutex <i>bar</i>”. That remains something the programmer must enforce.<p>On the other hand, tooling exists to help them, for example <a href="https:&#x2F;&#x2F;www.javadoc.io&#x2F;doc&#x2F;com.google.code.findbugs&#x2F;annotations&#x2F;3.0.1&#x2F;javax&#x2F;annotation&#x2F;concurrent&#x2F;GuardedBy.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.javadoc.io&#x2F;doc&#x2F;com.google.code.findbugs&#x2F;annotati...</a></div><br/></div></div><div id="36690660" class="c"><input type="checkbox" id="c-36690660" checked=""/><div class="controls bullet"><span class="by">invalidname</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689765">parent</a><span>|</span><a href="#36691465">prev</a><span>|</span><a href="#36690710">next</a><span>|</span><label class="collapse" for="c-36690660">[-]</label><label class="expand" for="c-36690660">[1 more]</label></div><br/><div class="children"><div class="content">The problem here is that we don&#x27;t want a mutex. Once you have it the performance cost would apply in runtime. In fact, to write this code in rust you would need to write unsafe code to get around the problem where Rust forces you to write correct but inefficient code.<p>This code is intentionally not thread-safe. This isn&#x27;t so much a bug but an interesting thought experiment.</div><br/></div></div><div id="36690710" class="c"><input type="checkbox" id="c-36690710" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689765">parent</a><span>|</span><a href="#36690660">prev</a><span>|</span><a href="#36690039">next</a><span>|</span><label class="collapse" for="c-36690710">[-]</label><label class="expand" for="c-36690710">[5 more]</label></div><br/><div class="children"><div class="content">The scenario I was imagining and commenting on was about “implementing a JVM with Java’s semantics in Rust”. Of course if we limit the language itself to safe Rust, we get data race freedom, but at a quite significant price for a high level language (it constraints possibly correct programs down <i>a lot</i>). But Rust would not help with relation to the primitives here at all (implemented in C++&#x2F;Java).</div><br/><div id="36691425" class="c"><input type="checkbox" id="c-36691425" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36690710">parent</a><span>|</span><a href="#36690039">next</a><span>|</span><label class="collapse" for="c-36691425">[-]</label><label class="expand" for="c-36691425">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Rust wouldn&#x27;t help&quot;<p>&quot;This bug can&#x27;t be implemented in rust&quot;<p>&quot;I meant that Rust doesn&#x27;t fix the bug in Java. Even if you write rust code, you can also write buggy java code too so rust didn&#x27;t fix the java code&quot;<p>You&#x27;re the only one here who thought &quot;rust&quot; meant &quot;java semantics implemented in rust&quot; in this context.</div><br/><div id="36691482" class="c"><input type="checkbox" id="c-36691482" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36691425">parent</a><span>|</span><a href="#36690039">next</a><span>|</span><label class="collapse" for="c-36691482">[-]</label><label class="expand" for="c-36691482">[3 more]</label></div><br/><div class="children"><div class="content">Because in case of the problem at hand, this is a complex interplay between Java&#x27;s standard library&#x27;s Java code and the underlying JVM. There is not much to discuss regarding &quot;rust would make the code safe&quot;, because so does JS as it is single threaded.. That&#x27;s hardly interesting.<p>If we put Java on top of Rust, then no, Rust no longer can help about this. That was my whole point.</div><br/><div id="36691560" class="c"><input type="checkbox" id="c-36691560" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36691482">parent</a><span>|</span><a href="#36690039">next</a><span>|</span><label class="collapse" for="c-36691560">[-]</label><label class="expand" for="c-36691560">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s hardly interesting<p>Rust and javascript having differences which prevent this class of bugs might not be very interesting, but it&#x27;s more interesting than your point.<p>Unless I&#x27;m misunderstanding, your point is that a bug in Java cannot be avoided by switching languages to Java.</div><br/><div id="36691685" class="c"><input type="checkbox" id="c-36691685" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36691560">parent</a><span>|</span><a href="#36690039">next</a><span>|</span><label class="collapse" for="c-36691685">[-]</label><label class="expand" for="c-36691685">[1 more]</label></div><br/><div class="children"><div class="content">No, my point is that changing the implementation language <i>of java</i> wouldn&#x27;t have helped here.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36690039" class="c"><input type="checkbox" id="c-36690039" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689089">parent</a><span>|</span><a href="#36689765">prev</a><span>|</span><a href="#36689128">next</a><span>|</span><label class="collapse" for="c-36690039">[-]</label><label class="expand" for="c-36690039">[3 more]</label></div><br/><div class="children"><div class="content">Rust <i>absolutely</i> helps here because in Rust it’s simply impossible for someone else to mutate something concurrently to you holding a reference to it. Code equivalent to that in the article simply won’t compile in Rust. This is, like, the very <i>point</i> of Rust’s borrow system. You can share, <i>xor</i> you can mutate, but not both at the same time. This holds equally for single and multi-threaded code.</div><br/><div id="36690346" class="c"><input type="checkbox" id="c-36690346" checked=""/><div class="controls bullet"><span class="by">ironmagma</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36690039">parent</a><span>|</span><a href="#36689128">next</a><span>|</span><label class="collapse" for="c-36690346">[-]</label><label class="expand" for="c-36690346">[2 more]</label></div><br/><div class="children"><div class="content">In safe Rust, that is. For unsafe Rust, I don&#x27;t know exactly which bets are off but it&#x27;s more than none.</div><br/><div id="36690634" class="c"><input type="checkbox" id="c-36690634" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36690346">parent</a><span>|</span><a href="#36689128">next</a><span>|</span><label class="collapse" for="c-36690634">[-]</label><label class="expand" for="c-36690634">[1 more]</label></div><br/><div class="children"><div class="content">In unsafe rust this is a concurrent modification of an object with shared references, which is an UB.</div><br/></div></div></div></div></div></div><div id="36689128" class="c"><input type="checkbox" id="c-36689128" checked=""/><div class="controls bullet"><span class="by">lostmsu</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689089">parent</a><span>|</span><a href="#36690039">prev</a><span>|</span><a href="#36689671">next</a><span>|</span><label class="collapse" for="c-36689128">[-]</label><label class="expand" for="c-36689128">[1 more]</label></div><br/><div class="children"><div class="content">Huh? This is exactly where Rust would help. In Rust the caller of the constructor would either have to add mutex if they needed concurrency, or just use the constructor without mutex overhead if they did not.</div><br/></div></div><div id="36689671" class="c"><input type="checkbox" id="c-36689671" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689089">parent</a><span>|</span><a href="#36689128">prev</a><span>|</span><a href="#36689389">next</a><span>|</span><label class="collapse" for="c-36689671">[-]</label><label class="expand" for="c-36689671">[2 more]</label></div><br/><div class="children"><div class="content">99% of the time, the calling code trivially owns the array. If you are in a situation where the compiler cannot figure that out, then you need to deal with it regardless of what String does, because the exact same problem exists by the caller itself having a reference to the object.</div><br/><div id="36690051" class="c"><input type="checkbox" id="c-36690051" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689671">parent</a><span>|</span><a href="#36689389">next</a><span>|</span><label class="collapse" for="c-36690051">[-]</label><label class="expand" for="c-36690051">[1 more]</label></div><br/><div class="children"><div class="content">Java compiler have a (not too bad) escape analysis engine. For something as low level as String intern&#x2F;optimisation, it can be done in compile time</div><br/></div></div></div></div><div id="36689389" class="c"><input type="checkbox" id="c-36689389" checked=""/><div class="controls bullet"><span class="by">ironmagma</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689089">parent</a><span>|</span><a href="#36689671">prev</a><span>|</span><a href="#36688937">next</a><span>|</span><label class="collapse" for="c-36689389">[-]</label><label class="expand" for="c-36689389">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a compile-time cost instead of a runtime cost.</div><br/></div></div></div></div></div></div><div id="36688937" class="c"><input type="checkbox" id="c-36688937" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36688806">parent</a><span>|</span><a href="#36688842">prev</a><span>|</span><a href="#36689216">next</a><span>|</span><label class="collapse" for="c-36688937">[-]</label><label class="expand" for="c-36688937">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but Java will happily accept code that doesn&#x27;t use them where it needs to, leading to bugs like this one. Rust catches that mistake at compile time instead.</div><br/><div id="36691041" class="c"><input type="checkbox" id="c-36691041" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36688937">parent</a><span>|</span><a href="#36689216">next</a><span>|</span><label class="collapse" for="c-36691041">[-]</label><label class="expand" for="c-36691041">[1 more]</label></div><br/><div class="children"><div class="content">Not if the memory has been allocated on a shared memory segment, Rust has no control over what other processes might do.</div><br/></div></div></div></div><div id="36689216" class="c"><input type="checkbox" id="c-36689216" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36688806">parent</a><span>|</span><a href="#36688937">prev</a><span>|</span><a href="#36689210">next</a><span>|</span><label class="collapse" for="c-36689216">[-]</label><label class="expand" for="c-36689216">[6 more]</label></div><br/><div class="children"><div class="content">What about Rust’s borrow checker (affine types) enforces the use of mutexes (or other sync prims) here?</div><br/><div id="36690317" class="c"><input type="checkbox" id="c-36690317" checked=""/><div class="controls bullet"><span class="by">ekimekim</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689216">parent</a><span>|</span><a href="#36689516">next</a><span>|</span><label class="collapse" for="c-36690317">[-]</label><label class="expand" for="c-36690317">[1 more]</label></div><br/><div class="children"><div class="content">As sibling comments point out, mutexes aren&#x27;t needed here. But to answer your direct question, Rust&#x27;s type system enforces the use of mutexes to access protected values (if you&#x27;re using the stdlib Mutex implementation) by only allowing access to protected values through a MutexGuard object which is created by locking the mutex. The borrow checker enforces you can&#x27;t access the MutexGuard concurrently, so therefore you can&#x27;t access the protected value concurrently.</div><br/></div></div><div id="36689516" class="c"><input type="checkbox" id="c-36689516" checked=""/><div class="controls bullet"><span class="by">chowells</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689216">parent</a><span>|</span><a href="#36690317">prev</a><span>|</span><a href="#36689210">next</a><span>|</span><label class="collapse" for="c-36689516">[-]</label><label class="expand" for="c-36689516">[4 more]</label></div><br/><div class="children"><div class="content">Why would it need to? Rust&#x27;s borrow checker makes it a compile-time error to share a mutable array between threads. No need for run time synchronization.</div><br/><div id="36689935" class="c"><input type="checkbox" id="c-36689935" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689516">parent</a><span>|</span><a href="#36689210">next</a><span>|</span><label class="collapse" for="c-36689935">[-]</label><label class="expand" for="c-36689935">[3 more]</label></div><br/><div class="children"><div class="content">Right, that’s my understanding. But OP and a sibling thread here seem pretty sure about the mutex thing.<p>I think there’s some nuance, but not in the general case.<p>Shared memory, lazy statics in async blocks, and asynchronous constructors might have different initialization order mechanics that would require synchronization — but even then, the borrow checker would at least point it out</div><br/><div id="36690201" class="c"><input type="checkbox" id="c-36690201" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36689935">parent</a><span>|</span><a href="#36689210">next</a><span>|</span><label class="collapse" for="c-36690201">[-]</label><label class="expand" for="c-36690201">[2 more]</label></div><br/><div class="children"><div class="content">Without a mutex, you can’t even write code equivalent to that in the article because you cant mutably share as you pointed out. With a mutex you could – and the mutex would prevent data races (but not race conditions in general) – but indeed mutexes are a red herring here (at least in the specific sense of a runtime synchronization primitive).<p>In Java you can’t synchronize defensively because synchronization requires that everybody who has access to the shared resource cooperates with you. And even if you could, you wouldn’t want to, not in this sort of a case.<p>In Rust mutexes own the data they protect, and make it impossible for anyone to access the data without locking the mutex first, but again, an API like this would clearly not bother with dealing with mutexes but rather take a normal compile-time-checked borrow.</div><br/><div id="36690724" class="c"><input type="checkbox" id="c-36690724" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36688766">root</a><span>|</span><a href="#36690201">parent</a><span>|</span><a href="#36689210">next</a><span>|</span><label class="collapse" for="c-36690724">[-]</label><label class="expand" for="c-36690724">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately I can no longer edit my comment, please have a look at my reply: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36690710">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36690710</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36689210" class="c"><input type="checkbox" id="c-36689210" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#36688766">prev</a><span>|</span><a href="#36688896">next</a><span>|</span><label class="collapse" for="c-36689210">[-]</label><label class="expand" for="c-36689210">[10 more]</label></div><br/><div class="children"><div class="content">Out of interest, how should this be handled?<p>Is this a bug in Java which should be fixed (looks like that to me)? My understanding was Java generally doesn&#x27;t do &quot;you did an undefined behaviour, so it&#x27;s your fault&quot;, except for specifically marked very low-level interfaces.</div><br/><div id="36689350" class="c"><input type="checkbox" id="c-36689350" checked=""/><div class="controls bullet"><span class="by">cempaka</span><span>|</span><a href="#36689210">parent</a><span>|</span><a href="#36689338">next</a><span>|</span><label class="collapse" for="c-36689350">[-]</label><label class="expand" for="c-36689350">[3 more]</label></div><br/><div class="children"><div class="content">I can only think of a couple of ways to fix this, none of them ideal from a performance perspective:<p>- Make a defensive copy of the passed-in character array, which would be immediately discarded when it is encoded to bytes. This basically sucks given how often String creation happens in a typical Java program.<p>- Dispense with the whole use of the coder to check for non-equality of Strings, and insist on a character-by-character comparison (possibly from different encodings) for every call to String.equals() where the lengths are the same. Again, this would be a lot of wasted cycles in an extremely common JVM op.<p>I think the right answer here is to add something to the Javadoc about &quot;modifying the input character array concurrently with String construction invites dragons.&quot; :-)</div><br/><div id="36689856" class="c"><input type="checkbox" id="c-36689856" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#36689210">root</a><span>|</span><a href="#36689350">parent</a><span>|</span><a href="#36689338">next</a><span>|</span><label class="collapse" for="c-36689856">[-]</label><label class="expand" for="c-36689856">[2 more]</label></div><br/><div class="children"><div class="content">Another way of fixing it would be, whichever character caused &#x27;StringUTF16.compress&#x27; to fail (we&#x27;d need to return it), make sure that character is kept in the final string (could just assign it at the end, remember it&#x27;s value and location earlier).<p>By merging in the code of StringUTF16.compress and StringUTF16.toBytes into one function (and they are both very small), this wouldn&#x27;t even have to slow things down, once you noticed location &#x27;i&#x27; has char &#x27;c&#x27; which isn&#x27;t LATIN1, you make the new buffer, copy 0..i-1 over, then your known non-LATIN1 &#x27;i&#x27;, then i+1..len.<p>This might be very slightly slower, but would fix (I think) the problem of breaking interning, which feels quite painful.</div><br/><div id="36690243" class="c"><input type="checkbox" id="c-36690243" checked=""/><div class="controls bullet"><span class="by">marvy</span><span>|</span><a href="#36689210">root</a><span>|</span><a href="#36689856">parent</a><span>|</span><a href="#36689338">next</a><span>|</span><label class="collapse" for="c-36690243">[-]</label><label class="expand" for="c-36690243">[1 more]</label></div><br/><div class="children"><div class="content">Clever!  I like this!  I feel a bit jealous that I didn&#x27;t think of it :)<p>It&#x27;s not quite as easy as it seems, because these methods are &quot;intrinsics&quot;.  That is, the pure Java code you see is not always the one that gets used; instead, the JIT compiler can use a faster implementation that uses vectorized assembly or whatever.  (That&#x27;s why you see &quot;@IntrinsicCandidate&quot; on compress() and toBytes() in StringUTF16.java)<p>But I think your idea would also be possible to implement in vectorized assembly, so it still works!<p>The rule for most things (such as ArrayList) in the JDK is: &quot;if you use race conditions to break this thing, that&#x27;s your problem, not ours&quot;.  But String is different: it&#x27;s one of the few things meant to be &quot;rock-solid, can&#x27;t break it even if you try&quot;, so I think this bug in String would qualify as a potential security issue in their mind: there are many places in Java that trust Strings not to act weird, and some of them are even in native code deep in the guts of the VM.<p>On the other hand, String is used all over the place so having to introduce a performance regression to fix this bug would be quite painful.  All of the other proposed solutions in this thread introduce an extra copy, and an extra pass over the string.  Your fix is basically no extra cost, and as a bonus, can be tweaked so each char in the array is read only once.<p>Which means that the bug can now be fixed &quot;guilt-free&quot;, if anyone from the JDK team is reading this thread.  Though they have some pretty clever people there too, so they might have thought of it eventually for all I know.</div><br/></div></div></div></div></div></div><div id="36689338" class="c"><input type="checkbox" id="c-36689338" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#36689210">parent</a><span>|</span><a href="#36689350">prev</a><span>|</span><a href="#36691059">next</a><span>|</span><label class="collapse" for="c-36689338">[-]</label><label class="expand" for="c-36689338">[4 more]</label></div><br/><div class="children"><div class="content">Java definitely does &quot;you wrote thread dangerous code, so it&#x27;s your fault&quot; for APIs not marked as being thread safe.</div><br/><div id="36689490" class="c"><input type="checkbox" id="c-36689490" checked=""/><div class="controls bullet"><span class="by">ccooffee</span><span>|</span><a href="#36689210">root</a><span>|</span><a href="#36689338">parent</a><span>|</span><a href="#36691449">next</a><span>|</span><label class="collapse" for="c-36689490">[-]</label><label class="expand" for="c-36689490">[1 more]</label></div><br/><div class="children"><div class="content">This is yet another way that running untrusted code inside the same JVM is a terrible mess. There&#x27;s a lot of JVM state that gets &quot;locked in&quot; on first use (e.g. &lt;clinit&gt;) and a malicious bit of code could corrupt a LOT of shared data (like the post&#x27;s mentioned string internment zone) even if you sanitize all of your inputs and outputs.<p>I wonder if you could do something nasty with this bug from inside an IntelliJ plugin...</div><br/></div></div><div id="36691449" class="c"><input type="checkbox" id="c-36691449" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36689210">root</a><span>|</span><a href="#36689338">parent</a><span>|</span><a href="#36689490">prev</a><span>|</span><a href="#36691059">next</a><span>|</span><label class="collapse" for="c-36691449">[-]</label><label class="expand" for="c-36691449">[2 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, Java does at least give some guarantees in case of data races -- the observed value will always be one that was explicitly set by one thread. This is different from most other languages, e.g. in C,C++, unsafe Rust it is UB.<p>Of course it can and still will result in invalid states.</div><br/><div id="36691791" class="c"><input type="checkbox" id="c-36691791" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36689210">root</a><span>|</span><a href="#36691449">parent</a><span>|</span><a href="#36691059">next</a><span>|</span><label class="collapse" for="c-36691791">[-]</label><label class="expand" for="c-36691791">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Of course it can and still will result in invalid states.<p>While of course they can&#x27;t stop <i>you</i> from creating &quot;invalid&quot; states of your own types, whether through a data race or just bad coding - Java&#x27;s own types should not have invalid states which can come into existence this way.<p>For example, suppose we&#x27;ve got a Goose type, and it can be Happy or Sad, and when it&#x27;s Sad it has a Reason, when it is Happy there&#x27;s no Reason. We, as Java, should not design this type so that it&#x27;s possible for it to get flipped from Happy to Sad without choosing a Reason. As a result, after a race the Goose might be Happy when you expected Sad, or vice versa, but it can&#x27;t enter the invalid state where it&#x27;s Sad but for no Reason.</div><br/></div></div></div></div></div></div><div id="36691059" class="c"><input type="checkbox" id="c-36691059" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36689210">parent</a><span>|</span><a href="#36689338">prev</a><span>|</span><a href="#36688896">next</a><span>|</span><label class="collapse" for="c-36691059">[-]</label><label class="expand" for="c-36691059">[2 more]</label></div><br/><div class="children"><div class="content">If I would design JVM from the scratch, I&#x27;d introduce frozen arrays. There are so many array copies inside JDK code, it hurts.<p>Whether it&#x27;s possible to retrofit JVM today, I don&#x27;t know.</div><br/><div id="36691457" class="c"><input type="checkbox" id="c-36691457" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36689210">root</a><span>|</span><a href="#36691059">parent</a><span>|</span><a href="#36688896">next</a><span>|</span><label class="collapse" for="c-36691457">[-]</label><label class="expand" for="c-36691457">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if you are referencing this, but there were a proposal: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8261007" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8261007</a></div><br/></div></div></div></div></div></div><div id="36688896" class="c"><input type="checkbox" id="c-36688896" checked=""/><div class="controls bullet"><span class="by">m_0x</span><span>|</span><a href="#36689210">prev</a><span>|</span><a href="#36691030">next</a><span>|</span><label class="collapse" for="c-36688896">[-]</label><label class="expand" for="c-36688896">[3 more]</label></div><br/><div class="children"><div class="content">Every time, without fail, somebody shows a bug about a piece of code that we take for granted (In this case, the String class) the bug is related to concurrent modifications.<p>Concurrency is so hard that even OpenJDK developers can&#x27;t prevent these kind of bugs</div><br/><div id="36689238" class="c"><input type="checkbox" id="c-36689238" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#36688896">parent</a><span>|</span><a href="#36689482">next</a><span>|</span><label class="collapse" for="c-36689238">[-]</label><label class="expand" for="c-36689238">[1 more]</label></div><br/><div class="children"><div class="content">Go has trouble with this too. You can cause undefined behavior with completely safe code by making concurrent modifications to a fat pointer. The writes won&#x27;t be atomic, and the pointer can be interpreted as the wrong type. E.g. in this example, the B.foo method will be called with a C value as the receiver, which tricks it into accessing memory at 0x1000 and segfaulting, but you could also arbitrarily access any memory this way without using unsafe.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;y4z_vs-I1jb" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;y4z_vs-I1jb</a></div><br/></div></div><div id="36689482" class="c"><input type="checkbox" id="c-36689482" checked=""/><div class="controls bullet"><span class="by">bill3478</span><span>|</span><a href="#36688896">parent</a><span>|</span><a href="#36689238">prev</a><span>|</span><a href="#36691030">next</a><span>|</span><label class="collapse" for="c-36689482">[-]</label><label class="expand" for="c-36689482">[1 more]</label></div><br/><div class="children"><div class="content">Is not that OpenJDK developers can&#x27;t prevent these, but there&#x27;s a forbidding cost for doing so.<p>The simplest &quot;safe&quot; way of doing this involves defensively copying the input argument. However, the `compress` function will likely make yet another smaller copy, making the constructor very allocation and CPU intensive.<p>In fact, due to the fixed array size in Java, all thread-safe implementations must either allocate two arrays to hold the two possible encodings, which guarantees one piece of garbage, or iterating the input array twice.<p>For such a core class like String, this is probably unacceptable cost. And the constructor is not documented to be thread-safe, so no one should expect it to.<p>In reality, there are much more impactful data structures to abuse in Java.</div><br/></div></div></div></div><div id="36691030" class="c"><input type="checkbox" id="c-36691030" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36688896">prev</a><span>|</span><a href="#36689508">next</a><span>|</span><label class="collapse" for="c-36691030">[-]</label><label class="expand" for="c-36691030">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very interesting finding. Nowadays Java security is a joke, but back in the day, Java security was a serious topic. Users were able to run downloaded applets in their browser, so protecting the sandbox was important. It&#x27;s very likely that using those kinds of &quot;corrupted&quot; strings would allow to break out of this sandbox, because that protection code definitely relied on strings being sane and correct.<p>I can&#x27;t imagine this behaviour to cause much problem with modern Java, nobody runs untrusted code anyway. But good to know.</div><br/></div></div></div></div></div></div></div></body></html>