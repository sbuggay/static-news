<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691658067940" as="style"/><link rel="stylesheet" href="styles.css?v=1691658067940"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.nelhage.com/post/systems-at-capacity/">Graceful behavior at capacity</a> <span class="domain">(<a href="https://blog.nelhage.com">blog.nelhage.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>35 comments</span></div><br/><div><div id="37068766" class="c"><input type="checkbox" id="c-37068766" checked=""/><div class="controls bullet"><span class="by">tra3</span><span>|</span><a href="#37069793">next</a><span>|</span><label class="collapse" for="c-37068766">[-]</label><label class="expand" for="c-37068766">[17 more]</label></div><br/><div class="children"><div class="content">Most of the microservice code I see is<p><pre><code>  response = fetch(url, payload)
  if (response.error) ...
</code></pre>
but 99% of the folks I ask what is going to happen when the fetch does NOT error out but instead takes 10 seconds look at me like I&#x27;m speaking gibberish.<p>This is the single biggest reason for cascading failures I see.<p>Netflix has dealt with it via their Hystrix library (open source). These days it seems like a proxy like Consul is the way to go. It encapsulates all of the fancy logic (like circuit breakers and flow control) so your service doesn&#x27;t have to.</div><br/><div id="37073388" class="c"><input type="checkbox" id="c-37073388" checked=""/><div class="controls bullet"><span class="by">guideamigo</span><span>|</span><a href="#37068766">parent</a><span>|</span><a href="#37072021">next</a><span>|</span><label class="collapse" for="c-37073388">[-]</label><label class="expand" for="c-37073388">[1 more]</label></div><br/><div class="children"><div class="content">Even better would be the scenario when it is stuck forever.<p>Most languages have no default timeout for sending network requests!</div><br/></div></div><div id="37072021" class="c"><input type="checkbox" id="c-37072021" checked=""/><div class="controls bullet"><span class="by">Sylamore</span><span>|</span><a href="#37068766">parent</a><span>|</span><a href="#37073388">prev</a><span>|</span><a href="#37069080">next</a><span>|</span><label class="collapse" for="c-37072021">[-]</label><label class="expand" for="c-37072021">[1 more]</label></div><br/><div class="children"><div class="content">As a capacity planner I tried to argue in favor of tools like Hystrix being built into our middleware services because when we had large IPPV events cascading failures was the biggest risk to our availability and it happened because 99% of the time our services could process any queues before downstream timeouts occured but during high volume events the queues would grow due to nearly instant demand occurring (normally within 5 minutes of the PPV event start time) and causing the queues to go deeper than our timeouts.  Combine that with the queues not being durable if a process restart was needed and things got real ugly real fast under extreme load.  Automatic retries + deep queues + short timeouts = service issues that take hours to unwind often requiring a coordinated cold restart of the entire middleware pipeline and millions in lost revenue.<p>To compensate we had to scale our systems for the absolute instantaneous peak demand because being legacy systems (pre containers) with a lot of rigid plumbing in them we couldn&#x27;t just scale on demand. Things did not degrade gracefully once you hit the timeout limits in the composite API calls.</div><br/></div></div><div id="37069080" class="c"><input type="checkbox" id="c-37069080" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37068766">parent</a><span>|</span><a href="#37072021">prev</a><span>|</span><a href="#37070001">next</a><span>|</span><label class="collapse" for="c-37069080">[-]</label><label class="expand" for="c-37069080">[13 more]</label></div><br/><div class="children"><div class="content">As an ardent fan of monoliths and how they generally avoid such tar pits, I have to acknowledge that service-oriented architectures have their uses.<p>So do we all have to keep reinventing these wheels, but only after a production outage?<p>Or is it time someone started work on a distributed operating system? Vaguely like Kubernetes but full-featured?<p>I keep seeing the same patterns being re-engineered over and over. Maybe it’s time to refactor these out…</div><br/><div id="37070156" class="c"><input type="checkbox" id="c-37070156" checked=""/><div class="controls bullet"><span class="by">OkayPhysicist</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069080">parent</a><span>|</span><a href="#37072060">next</a><span>|</span><label class="collapse" for="c-37070156">[-]</label><label class="expand" for="c-37070156">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Or is it time someone started work on a distributed operating system?<p>For stuff like this, we&#x27;ve had it since the 80&#x27;s: Erlang&#x27;s (and it&#x27;s sleek offspring, Elixir) BEAM VM. A virtual machine with concurrent, parallel, and distributed systems in mind? Check. A standard library containing batteries-included solutions to most design and technical challenges you&#x27;ll run into while building such systems? Check. Tooling for stuff like deployments, diagnostics of running systems, and the ability to pull open a REPL for hands-in-the-meat debugging? Check, Check, Check.</div><br/></div></div><div id="37072060" class="c"><input type="checkbox" id="c-37072060" checked=""/><div class="controls bullet"><span class="by">Sylamore</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069080">parent</a><span>|</span><a href="#37070156">prev</a><span>|</span><a href="#37070694">next</a><span>|</span><label class="collapse" for="c-37072060">[-]</label><label class="expand" for="c-37072060">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s kind of what HP NonStop is, a distributed operating system operating as a huge cluster.<p>If you followed their coding practices and used their native libraries you could almost always do things like freeze a process, move it to an entirely different CPU (which could be a totally different physical server) then restart it without losing the work in progress, processes could auto-restart and resume from the last checkpoint, add more processes to handle the messages in the queue and all kinds of built into the OS and layered services niceties that everyone keeps reinventing.</div><br/></div></div><div id="37070694" class="c"><input type="checkbox" id="c-37070694" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069080">parent</a><span>|</span><a href="#37072060">prev</a><span>|</span><a href="#37071305">next</a><span>|</span><label class="collapse" for="c-37070694">[-]</label><label class="expand" for="c-37070694">[3 more]</label></div><br/><div class="children"><div class="content">&gt; So do we all have to keep reinventing these wheels, but only after a production outage?<p>We live in a world where programmers&#x27; &quot;consensus&quot; is that checked exceptions are bad and we need to remove them from Java. People generally just don&#x27;t care anything except the happies path.</div><br/><div id="37071575" class="c"><input type="checkbox" id="c-37071575" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37070694">parent</a><span>|</span><a href="#37071305">next</a><span>|</span><label class="collapse" for="c-37071575">[-]</label><label class="expand" for="c-37071575">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the reason to remove checked exceptions from Java. The reason is that exceptions don&#x27;t compose - they don&#x27;t play well with functional style code which otherwise works pretty well in Java.</div><br/><div id="37071598" class="c"><input type="checkbox" id="c-37071598" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37071575">parent</a><span>|</span><a href="#37071305">next</a><span>|</span><label class="collapse" for="c-37071598">[-]</label><label class="expand" for="c-37071598">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Checked exceptions are fine - it&#x27;s just an early returning version of error&#x2F;result-ADTs (which are widely used and loved).<p><i>Java&#x27;s implementation</i> isn&#x27;t generic over exception types, so you&#x27;re forced to make Bad Decisions constantly.</div><br/></div></div></div></div></div></div><div id="37071305" class="c"><input type="checkbox" id="c-37071305" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069080">parent</a><span>|</span><a href="#37070694">prev</a><span>|</span><a href="#37069121">next</a><span>|</span><label class="collapse" for="c-37071305">[-]</label><label class="expand" for="c-37071305">[1 more]</label></div><br/><div class="children"><div class="content">&quot;So do we all have to keep reinventing these wheels, but only after a production outage?&quot;<p>Lotta cynical replies, and mine is going to sound like one of them at first, but I actually mean it in a relatively deep and profound way: Time is hard. You can even see it in pure math, where Logic is all fun and everyone&#x27;s having a great time being clever and making all sorts of exciting systems and inferences in those systems... and then you try to build Temporal Logic and all the pretty just goes flying out the door.<p>Even &quot;what if the reply takes ten seconds&quot; is the beginning. By the very nature of the question itself I can infer the response is expected to be small. What if it is large? What if it might legitimately take more than ten seconds to transfer even under ideal circumstances, <i>but</i> you need to know that it&#x27;s not working as quickly as possible? Is your entry point open to the public? How does it do with slowloris attacks [1]? What if your system simply falls behind due to lack of resources? The difference between 97% capacity and 103% capacity in your real, time-bound systems can knock your socks off in ways you&#x27;d never model in an atemporal system that ignored how long things take to happen.<p>Programming would be grungy enough even if we didn&#x27;t have these considerations, but I&#x27;m not even scratching the surface on the number of ways that adding time as a real-world consideration complexifies a ton of things. Our most common response is often just to ignore it. This is... actually often quite rational, a lot of the failure cases can be feasibly addressed by various human interventions, e.g., while writing your service to be robust to &quot;a slow internal network&quot; might be a good idea, there&#x27;s also a sense in which the only real solution is to speed up the internal network. But still, time is always sitting there crufting things up.<p>One of my favorites is the implicit dependency graph you accidentally start creating once your business systems guys start doing &quot;daily processes&quot; of this and that. We&#x27;re going to do a daily process to run the bills, but that depends on the four daily dumps that feed the billing process to all have been done first. By the way, did you check that the dumps are actually <i>done</i> and not actually in progress as you&#x27;re trying to use them? And those four daily dumps each have some other daily processes behind them, and if you&#x27;re not very careful you&#x27;ll create <i>loops</i> in those processes which introduce all sorts of other problems... in the end, a set of processes that in perfect atemporal logic land wouldn&#x27;t be too difficult to deal with becomes something very easy to sleepwalk into a nightmare world, where your dump is scheduled to run between 2:12 and 2:16 and it damned well better not fail for any reason, in your control or out of it, or we&#x27;re not doing billing today. (Or even the nightmare world where your dump is scheduled to run after 3pm but before 1pm every day... that is, these dependency graphs don&#x27;t have to get very complicated before literally impossible constraints start to appear if you&#x27;re not careful!) Trying to explain this to a large number of teams at every level of engineering capability level (frequently going all the down to &quot;a guy who distrusts and doesn&#x27;t like computers who, against his will, maintains a spreadsheet, which is also one of the vital pillars of our business&quot;) is the sort of thing that may make you want to consider becoming a monk.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Slowloris_(computer_security)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Slowloris_(computer_security)</a></div><br/></div></div><div id="37069121" class="c"><input type="checkbox" id="c-37069121" checked=""/><div class="controls bullet"><span class="by">klooney</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069080">parent</a><span>|</span><a href="#37071305">prev</a><span>|</span><a href="#37070016">next</a><span>|</span><label class="collapse" for="c-37069121">[-]</label><label class="expand" for="c-37069121">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more work, is the simple answer.</div><br/><div id="37069912" class="c"><input type="checkbox" id="c-37069912" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069121">parent</a><span>|</span><a href="#37070016">next</a><span>|</span><label class="collapse" for="c-37069912">[-]</label><label class="expand" for="c-37069912">[4 more]</label></div><br/><div class="children"><div class="content">Once. It&#x27;s more work <i>once</i> instead of over and over. That&#x27;s the point of operating systems, standard libraries, and modules!<p>I see this weird back-lash in modern development against having common, standard platforms. I suspect it comes from the Python and JavaScript world, where having &quot;no batteries included&quot; is seen as a good thing, instead of a guaranteed mess of dozens of half-complete incompatible frameworks.<p>I&#x27;m coming from the perspective of Windows and comparing it to, say, Azure or AWS. All three have some concepts of access control, log collection, component systems, processes, etc...<p>But all three are proprietary. Kubernetes goes a long way, but it isn&#x27;t a user-mode system that can be directly accessed from code. Compare with Service Fabric, which has a substantial SDK component that integrates into the applications.<p>As an example, here&#x27;s a really basic thing that is actually absurdly difficult to solve well: web application session state.<p>If you have sticky load balancing using cookies, then the session state is accessed on one VM something like 99.99% of the time... except for that 1% of the time when it isn&#x27;t. This could be due to a restart, load rebalancing, or whatever.<p>If you put the session state into something external like Redis, then a zone-redundant deployment will eat a ~1ms delay on every page render, every time.<p>Service Fabric uses a model where it keeps three replicas of the state: one in the original web server, and two replicas in elsewhere. This way, reads are <i>in process</i> on the same VM most of the time, resulting in nanosecond latencies. Writing the state can occur asynchronously after the page response is already being sent.<p>I&#x27;d like to see concepts like this, along with all sorts of service-to-service communication patterns, consolidated into an &quot;operating system like platform&quot; designed for the mid-2020s clouds instead of 1990s server farms.</div><br/><div id="37070041" class="c"><input type="checkbox" id="c-37070041" checked=""/><div class="controls bullet"><span class="by">lstamour</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069912">parent</a><span>|</span><a href="#37070052">next</a><span>|</span><label class="collapse" for="c-37070041">[-]</label><label class="expand" for="c-37070041">[1 more]</label></div><br/><div class="children"><div class="content">We’re getting there but it takes time to agree on what the best implementation of a reinvented wheel looks like? A good example is OpenTelemetry, which is an obvious idea in hindsight but looks like it will take about a decade to ship.<p>Or how we move the goalposts when we reach a goal, for example Kubernetes standardized certain aspects of cloud but now that we have that, instead of celebrating we bemoan its complexity and lack of utility at solving actual application or organization challenges such that we still need to use cloud APIs plus container images plus all this other complexity. But hey, we did solve the problem of distributing code to run on machines, it’s just in hindsight it doesn’t seem like it was that hard? We adjust pretty quick to the “new normal” when it’s not even a decade yet since Docker and Kubernetes appeared on the scene.</div><br/></div></div><div id="37070052" class="c"><input type="checkbox" id="c-37070052" checked=""/><div class="controls bullet"><span class="by">thevagrant</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069912">parent</a><span>|</span><a href="#37070041">prev</a><span>|</span><a href="#37070016">next</a><span>|</span><label class="collapse" for="c-37070052">[-]</label><label class="expand" for="c-37070052">[2 more]</label></div><br/><div class="children"><div class="content">&quot; I see this weird back-lash in modern development against having common, standard platforms. &quot;<p>I think it has always been that way.
It comes down to personality types. Many devs I&#x27;ve met  think that the implementation they wrote themselves is simpler and easier to understand vs learning a platform api or existing library.<p>They tend to shrug off when I point out security or other potential problems</div><br/><div id="37072730" class="c"><input type="checkbox" id="c-37072730" checked=""/><div class="controls bullet"><span class="by">parasti</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37070052">parent</a><span>|</span><a href="#37070016">next</a><span>|</span><label class="collapse" for="c-37072730">[-]</label><label class="expand" for="c-37072730">[1 more]</label></div><br/><div class="children"><div class="content">At least in web development rolling your own is usually the pragmatic choice. It won&#x27;t break opaquely upon update, you can fix it yourself, it only does what you need. Library and platform updates have a much higher chance of breaking something because of the large impact surface, feature updates being conflated with security updates, insufficient testing, and such breakages are much harder to resolve because they are a black box to you. Really nothing to do with personalities.</div><br/></div></div></div></div></div></div></div></div><div id="37070016" class="c"><input type="checkbox" id="c-37070016" checked=""/><div class="controls bullet"><span class="by">kneebonian</span><span>|</span><a href="#37068766">root</a><span>|</span><a href="#37069080">parent</a><span>|</span><a href="#37069121">prev</a><span>|</span><a href="#37070001">next</a><span>|</span><label class="collapse" for="c-37070016">[-]</label><label class="expand" for="c-37070016">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Or is it time someone started work on a distributed operating system? Vaguely like Kubernetes but full-featured?<p>May I introduce you to inferno or Plan 9 my friend. Elegant OSes from a more civilized age.</div><br/></div></div></div></div></div></div><div id="37069793" class="c"><input type="checkbox" id="c-37069793" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#37068766">prev</a><span>|</span><a href="#37070729">next</a><span>|</span><label class="collapse" for="c-37069793">[-]</label><label class="expand" for="c-37069793">[2 more]</label></div><br/><div class="children"><div class="content">If your clients don&#x27;t implement an increasing backoff retry with jitter, you can fake it by making your server begin to randomly and increasingly time-out connections or wait to accept them. You can do it a few different ways.<p>For already-open connections:<p>1) Keep the connection open and respond with a tiny amount of data every once in a while, so the connection doesn&#x27;t time out, but make it long enough that a complete request will take forever.. Applications may still re-connect if a successful request-response doesn&#x27;t happen within a timeout.<p>2) Keep the connection open but don&#x27;t respond. The application may time out the connection and re-connect if it receives no data.<p>3) Drop the connection but don&#x27;t let the tcp&#x2F;ip stack send a RST, FIN, or anything else. The applications&#x27; connection will be timed out pretty soon, either by the OS stack or an application timeout.<p>4) Respond to requests with HTTP response codes that will make the client retry. As long as this only happens at the load-balancer level, it will still remove pressure from your application layer.<p>For new connections:<p>1) Play hard to get. During the 3-way handshake, respond with weird states that won&#x27;t cause the connection to drop, but will make the client keep trying to connect, like the handshake is still trying to succeed but experiencing loss.<p>2) Do a normal 3-way handshake, but wait forever on each step to drag it out.<p>All of these options are a terrible idea for user-facing applications. They can cause more issues on your server side due to connections in wait state, and your clients will just see requests hanging, stalling, etc. You could just pretend the problem is with their ISP rather than your end. Or you could throw a 429 or 503 to try to stop the retries, but then they really know it&#x27;s your fault.<p>The best option is to just add capacity. Back in the day we couldn&#x27;t do that; you had the servers you had. So when all 400 machines in our colo were thrashing, we just had to shed load randomly, sometimes using the tricks above. Now with the cloud you can magically add capacity anytime, automatically. Much better option.<p>What&#x27;s often much better is to add another caching layer before the application layer and just return stale responses during pressure events. But sometimes you can&#x27;t, so you resort to either a 429 or 503, or the dirty tricks above.</div><br/><div id="37070824" class="c"><input type="checkbox" id="c-37070824" checked=""/><div class="controls bullet"><span class="by">gillh</span><span>|</span><a href="#37069793">parent</a><span>|</span><a href="#37070729">next</a><span>|</span><label class="collapse" for="c-37070824">[-]</label><label class="expand" for="c-37070824">[1 more]</label></div><br/><div class="children"><div class="content">You should check out the Aperture flow control system - <a href="https:&#x2F;&#x2F;github.com&#x2F;fluxninja&#x2F;aperture">https:&#x2F;&#x2F;github.com&#x2F;fluxninja&#x2F;aperture</a><p>We built a weighted fair queueing system in the Aperture flow control system to help alleviate the API load pressure - <a href="https:&#x2F;&#x2F;docs.fluxninja.com&#x2F;concepts&#x2F;scheduler&#x2F;load-scheduler" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.fluxninja.com&#x2F;concepts&#x2F;scheduler&#x2F;load-scheduler</a><p>And in addition, we are investing in the graceful-js library to handle 429 and 523 codes returned by the Aperture system - <a href="https:&#x2F;&#x2F;github.com&#x2F;fluxninja&#x2F;graceful-js">https:&#x2F;&#x2F;github.com&#x2F;fluxninja&#x2F;graceful-js</a></div><br/></div></div></div></div><div id="37070729" class="c"><input type="checkbox" id="c-37070729" checked=""/><div class="controls bullet"><span class="by">andrewf</span><span>|</span><a href="#37069793">prev</a><span>|</span><a href="#37072770">next</a><span>|</span><label class="collapse" for="c-37070729">[-]</label><label class="expand" for="c-37070729">[1 more]</label></div><br/><div class="children"><div class="content">I agree with all this. &quot;Metastable Failures in Distributed Systems&quot; (2001) is another good read if you&#x27;re facing problems in this vein. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28750103">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28750103</a></div><br/></div></div><div id="37072770" class="c"><input type="checkbox" id="c-37072770" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#37070729">prev</a><span>|</span><a href="#37067955">next</a><span>|</span><label class="collapse" for="c-37072770">[-]</label><label class="expand" for="c-37072770">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Most of the microservice code I see is<p>Not mine. I use circuit breakers. Although, the circuit breaker will never be hit because of the high load as Kubernetes will be already firing up some new pods by that time.</div><br/></div></div><div id="37067955" class="c"><input type="checkbox" id="c-37067955" checked=""/><div class="controls bullet"><span class="by">rdoherty</span><span>|</span><a href="#37072770">prev</a><span>|</span><a href="#37068610">next</a><span>|</span><label class="collapse" for="c-37067955">[-]</label><label class="expand" for="c-37067955">[1 more]</label></div><br/><div class="children"><div class="content">I learned most of this the hard way as a SRE. How systems behave at and over their limits is far more important than how they behave under them. A system that is &#x27;forgiving&#x27; (aka resilient) is worth its weight in gold. Otherwise you get into downward spirals with systems that can&#x27;t recover unless they are rebooted. Great read!</div><br/></div></div><div id="37068610" class="c"><input type="checkbox" id="c-37068610" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#37067955">prev</a><span>|</span><a href="#37068986">next</a><span>|</span><label class="collapse" for="c-37068610">[-]</label><label class="expand" for="c-37068610">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m writing an app that is likely to have, at most, a thousand users, for the next couple of years.<p>I&#x27;m testing it with 12,000 fake users.<p>It works great.</div><br/><div id="37070103" class="c"><input type="checkbox" id="c-37070103" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#37068610">parent</a><span>|</span><a href="#37068986">next</a><span>|</span><label class="collapse" for="c-37070103">[-]</label><label class="expand" for="c-37070103">[2 more]</label></div><br/><div class="children"><div class="content">Tune down your capacities until it breaks at a thousand users (reduce disk, cpu, memory, network, etc).<p>Determine what broke and how. Instrument that.</div><br/><div id="37070950" class="c"><input type="checkbox" id="c-37070950" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#37068610">root</a><span>|</span><a href="#37070103">parent</a><span>|</span><a href="#37068986">next</a><span>|</span><label class="collapse" for="c-37070950">[-]</label><label class="expand" for="c-37070950">[1 more]</label></div><br/><div class="children"><div class="content">Good idea!<p>Thanks!</div><br/></div></div></div></div></div></div><div id="37068986" class="c"><input type="checkbox" id="c-37068986" checked=""/><div class="controls bullet"><span class="by">thewakalix</span><span>|</span><a href="#37068610">prev</a><span>|</span><a href="#37070775">next</a><span>|</span><label class="collapse" for="c-37068986">[-]</label><label class="expand" for="c-37068986">[1 more]</label></div><br/><div class="children"><div class="content">From my armchair, I&#x27;m not sure that &quot;random drop&quot; actually does decrease latency. Most clients will just repeat the request, resulting in an &quot;effective latency&quot; of however many times it gets randomly dropped. The queue is now implicit, and I&#x27;d guess that it&#x27;s less efficient to carry out several request&#x2F;drop cycles than to just leave the client in a straightforward queue.</div><br/></div></div><div id="37070775" class="c"><input type="checkbox" id="c-37070775" checked=""/><div class="controls bullet"><span class="by">gillh</span><span>|</span><a href="#37068986">prev</a><span>|</span><a href="#37070491">next</a><span>|</span><label class="collapse" for="c-37070775">[-]</label><label class="expand" for="c-37070775">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting blog post! Our team has been working intensively in this area for the last couple of years - flow control, load shedding, controllability (PID control), and so on.<p>We have open-sourced our work at - <a href="https:&#x2F;&#x2F;github.com&#x2F;fluxninja&#x2F;aperture">https:&#x2F;&#x2F;github.com&#x2F;fluxninja&#x2F;aperture</a><p>We also did a Twitter Spaces discussion with Kelsey earlier today - <a href="https:&#x2F;&#x2F;twitter.com&#x2F;kelseyhightower&#x2F;status&#x2F;1689355284802629633" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;kelseyhightower&#x2F;status&#x2F;16893552848026296...</a><p>We would love feedback from folks reading this blog post!<p>Disclaimer: I am one of the co-authors of the Aperture project. There are several interesting ideas we have built into this project, and I will be happy to dive into the technical details as well.</div><br/></div></div><div id="37070491" class="c"><input type="checkbox" id="c-37070491" checked=""/><div class="controls bullet"><span class="by">ISL</span><span>|</span><a href="#37070775">prev</a><span>|</span><a href="#37068990">next</a><span>|</span><label class="collapse" for="c-37070491">[-]</label><label class="expand" for="c-37070491">[1 more]</label></div><br/><div class="children"><div class="content">Strategies like these (and kernel schedulers) are often as applicable in life as they are in computer science.</div><br/></div></div><div id="37068990" class="c"><input type="checkbox" id="c-37068990" checked=""/><div class="controls bullet"><span class="by">notacoward</span><span>|</span><a href="#37070491">prev</a><span>|</span><a href="#37071571">next</a><span>|</span><label class="collapse" for="c-37068990">[-]</label><label class="expand" for="c-37068990">[2 more]</label></div><br/><div class="children"><div class="content">FWIW, the single paragraph about &quot;fair allocation&quot; could be its own thesis. This gets into quality of service, active queue management, leaky buckets, deficit round robin, and so on <i>ad infinitum</i>. I did quite a bit of work on this on multiple projects at multiple companies, and it&#x27;s still one of the very few algorithmic areas that I still think about in retirement. I highly recommend following up on some of the terms above for some interesting explorations.</div><br/><div id="37070836" class="c"><input type="checkbox" id="c-37070836" checked=""/><div class="controls bullet"><span class="by">gillh</span><span>|</span><a href="#37068990">parent</a><span>|</span><a href="#37071571">next</a><span>|</span><label class="collapse" for="c-37070836">[-]</label><label class="expand" for="c-37070836">[1 more]</label></div><br/><div class="children"><div class="content">We built a fair scheduler for APIs and it&#x27;s in the open source - <a href="https:&#x2F;&#x2F;docs.fluxninja.com&#x2F;concepts&#x2F;scheduler&#x2F;load-scheduler" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.fluxninja.com&#x2F;concepts&#x2F;scheduler&#x2F;load-scheduler</a><p>I wish more people knew about this project!</div><br/></div></div></div></div><div id="37071571" class="c"><input type="checkbox" id="c-37071571" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#37068990">prev</a><span>|</span><label class="collapse" for="c-37071571">[-]</label><label class="expand" for="c-37071571">[4 more]</label></div><br/><div class="children"><div class="content">Ever since I heard of Little[1] it&#x27;s been surprising to me how few working programmers know that queuing theory is basically a solved problem and has been for longer than most working programmers have been alive.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Little&#x27;s_law" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Little&#x27;s_law</a></div><br/><div id="37072825" class="c"><input type="checkbox" id="c-37072825" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37071571">parent</a><span>|</span><label class="collapse" for="c-37072825">[-]</label><label class="expand" for="c-37072825">[3 more]</label></div><br/><div class="children"><div class="content">Ah. That&#x27;s classic queuing theory. It has a problem.<p>The early work on network congestion came from Kleinrock, who wrote the classic &quot;Queuing theory&quot;. Kleinrock did his PhD thesis at MIT on Western Union Plan 55-A, a telegram switching system which can be thought of as Sendmail built out of relays and paper tape. Message switches look like a classic arrival rate &#x2F; service rate problem. They have little customer-level back-pressure; you can send an email regardless of whether the transmission system is backed up.
So an open-loop analysis works fine.<p>The ARPANET had flow control on each link. Nothing could send a message until there was a buffer ready to receive it. So no packets were lost due to congestion. All overload is stopped at the sender. That approach is immune to congestion collapse, but not to lockup.<p>Then came the pure datagram networks, and TCP&#x2F;IP. Anybody can send an IP datagram any time they want to, regardless of the network status. So overloads and packet loss are possible. TCP uses retransmission to hide that, imperfectly. This introduces a new set of problems, some of which were non-obvious at the time.<p>Classical queuing theory is open-loop. Arrival rate is considered to be independent of wait time. In the real world, it&#x27;s not. Not even for store cashiers. If arrival rate exceeds service rate, the line length does not really grow without bound except in desperate situations. Customers leave without buying and take their business elsewhere. If there is no cashier idle time, the line length will increase only until the customer loss rate increases to match. Many retail managers do not get this.<p>I coined the term &quot;congestion collapse&quot; in 1984.[1] In 1985, I wrote, in my &quot;On Package Switches with Infinite Storage&quot; RFC, &quot;We have thus shown that a datagram network with infinite storage, first-in-first-out queuing, and a finite packet lifetime will, under overload, drop <i>all</i> packets.&quot;[2]<p>Until then, people had been doing mostly classic queuing theory analysis. That&#x27;s not enough.
Back then, memory was very expensive, and people were obsessing over how much memory was needed in a router. It was felt that adding more memory would solve the congestion problem. I pointed out that wouldn&#x27;t work. Now that memory is cheap, that problem appears as &quot;bufferbloat&quot;.<p>Those two RFCs started people thinking about this as a closed-loop problem. Van Jacobson later did much work in this area. I was out of it by 1986. Decades later, people are still fussing with the feedback control problems implicit in that result.<p>As the original poster points out here, this comes up in other situations, especially chains of services. If you get congestion in the middle of the chain, things will not go well, and there&#x27;s a good chance of something that looks like congestion collapse, where throughput goes to nearly zero. It&#x27;s better to push congestion out towards the endpoints.<p>We still don&#x27;t have good solutions to congestion in the middle of a pure datagram network. What saved the Internet was fiber optic backbones and cheap long-haul bandwidth. There was a period in the 1990s when traffic had built up but backbone bandwidth was still expensive. The long-haul links choked and the Internet had &quot;storms&quot;. There used to be an &quot;Internet Weather Center&quot;, where you could check on how congested the major routers were.<p>I also coined the term &quot;fair queuing&quot;. That can be a useful technique for services well above the IP datagram level. Don&#x27;t use a FIFO queue; queue based on who&#x27;s sending. If some source is sending too much, let them compete against themselves for the service. Others can still get through. This provides resilience against denial of service attacks.<p>I put that on a web site of mine some years ago, and for two months someone was pounding on it with useless requests without affecting response time for anybody else. (It wasn&#x27;t an attack, just ineptitude using a public API.)<p>[1] <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc896" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc896</a><p>[2] <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc970" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc970</a></div><br/><div id="37073179" class="c"><input type="checkbox" id="c-37073179" checked=""/><div class="controls bullet"><span class="by">gillh</span><span>|</span><a href="#37071571">root</a><span>|</span><a href="#37072825">parent</a><span>|</span><a href="#37073008">next</a><span>|</span><label class="collapse" for="c-37073179">[-]</label><label class="expand" for="c-37073179">[1 more]</label></div><br/><div class="children"><div class="content">Fascinating historical insight!<p>We have a team of 20 engineers currently working on solving this problem in the context of API requests and service chains. Do you know JMS @ Penn? Asking because he did some work in ATM networks, QoS etc. He is advising us on the project.<p>This is the link to the project: <a href="https:&#x2F;&#x2F;github.com&#x2F;fluxninja&#x2F;aperture">https:&#x2F;&#x2F;github.com&#x2F;fluxninja&#x2F;aperture</a><p>We built a weighted-fair queueing scheduler as well - <a href="https:&#x2F;&#x2F;docs.fluxninja.com&#x2F;concepts&#x2F;scheduler&#x2F;load-scheduler" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.fluxninja.com&#x2F;concepts&#x2F;scheduler&#x2F;load-scheduler</a></div><br/></div></div><div id="37073008" class="c"><input type="checkbox" id="c-37073008" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37071571">root</a><span>|</span><a href="#37072825">parent</a><span>|</span><a href="#37073179">prev</a><span>|</span><label class="collapse" for="c-37073008">[-]</label><label class="expand" for="c-37073008">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for this really helpful informative and educational comment.<p>I would really like to understand how to implement backpressure properly.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>