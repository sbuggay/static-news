<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733994055633" as="style"/><link rel="stylesheet" href="styles.css?v=1733994055633"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://retro64.altervista.org/blog/hi-res-bitmap-graphics-with-commodore-64-basic-2-0-fast-screen-clearing-routine/">Tricking c64 basic into clearing a hi-res screen quickly</a>Â <span class="domain">(<a href="https://retro64.altervista.org">retro64.altervista.org</a>)</span></div><div class="subtext"><span>amichail</span> | <span>7 comments</span></div><br/><div><div id="42397446" class="c"><input type="checkbox" id="c-42397446" checked=""/><div class="controls bullet"><span class="by">haspok</span><span>|</span><a href="#42396284">next</a><span>|</span><label class="collapse" for="c-42397446">[-]</label><label class="expand" for="c-42397446">[1 more]</label></div><br/><div class="children"><div class="content">It took me some time to get why this is faster than simply poking in a for-next loop - nice hack (for those who don&#x27;t know I can recommend one of Ben Eater&#x27;s latest BASIC hacking videos)!<p>But why add only 1 character each time, why not add the string to itself? That would grow it exponentially and would require much fewer steps. Or is string concatenation much slower than character concatenation?</div><br/></div></div><div id="42396284" class="c"><input type="checkbox" id="c-42396284" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42397446">prev</a><span>|</span><a href="#42396870">next</a><span>|</span><label class="collapse" for="c-42396284">[-]</label><label class="expand" for="c-42396284">[4 more]</label></div><br/><div class="children"><div class="content">Back in the day, one of IBM&#x27;s early databases worked by storing memory into the graphics buffer, outside the field of view of the monitor, because writing directly to that memory space was faster on the hardware than anywhere else. (My dad wrote it when working for National Mutual).<p>Tricks like these, intentionally causing overflows, used to be the norm. You&#x27;ve got a tiny bit of hardware, which makes it easier to reason about overall behaviour (until the inevitable BSOD). You can generally tell when its safe to blow up your whole stack. And that kind of thing is <i>fine</i> to do.</div><br/><div id="42396478" class="c"><input type="checkbox" id="c-42396478" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#42396284">parent</a><span>|</span><a href="#42396870">next</a><span>|</span><label class="collapse" for="c-42396478">[-]</label><label class="expand" for="c-42396478">[3 more]</label></div><br/><div class="children"><div class="content">The TI-99&#x2F;4A came with 256 <i>bytes</i> of system RAM. Everything in TI BASIC had to be stored in video RAM -- program code, variables, etc. -- which was not directly accessible to the CPU and had to be accessed through register reads&#x2F;writes to the video chip. This process was slow, and so TI BASIC was slow.<p>The TMS9900 was a fast (for 1979) 16-bit CPU, however, and some fast routines could be tucked away in those 256 bytes of RAM to achieve some interesting effects (for example smooth horizontal scrolling in Parsec, on a machine with no scrolling registers).</div><br/><div id="42396656" class="c"><input type="checkbox" id="c-42396656" checked=""/><div class="controls bullet"><span class="by">vikingerik</span><span>|</span><a href="#42396284">root</a><span>|</span><a href="#42396478">parent</a><span>|</span><a href="#42396623">next</a><span>|</span><label class="collapse" for="c-42396656">[-]</label><label class="expand" for="c-42396656">[1 more]</label></div><br/><div class="children"><div class="content">And on the Atari 2600, the fastest way to write to consecutive video registers is to set the stack pointer to its address and do push instructions.  You take advantage of getting the stack pointer decremented for free on each push.  The stack pointer can be hijacked for this since the machine has no interrupts.<p>The 2600 can also run self-modifying code in RAM, which I did: <a href="http:&#x2F;&#x2F;www.dos486.com&#x2F;atari&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.dos486.com&#x2F;atari&#x2F;</a></div><br/></div></div><div id="42396623" class="c"><input type="checkbox" id="c-42396623" checked=""/><div class="controls bullet"><span class="by">classichasclass</span><span>|</span><a href="#42396284">root</a><span>|</span><a href="#42396478">parent</a><span>|</span><a href="#42396656">prev</a><span>|</span><a href="#42396870">next</a><span>|</span><label class="collapse" for="c-42396623">[-]</label><label class="expand" for="c-42396623">[1 more]</label></div><br/><div class="children"><div class="content">Though at least part of the slowness was TI&#x27;s decision to write BASIC in GPL (an interpreted middle-level language, for those unfamiliar) instead of directly in 9900 assembly, which made it even worse.</div><br/></div></div></div></div></div></div><div id="42396870" class="c"><input type="checkbox" id="c-42396870" checked=""/><div class="controls bullet"><span class="by">ataylor284_</span><span>|</span><a href="#42396284">prev</a><span>|</span><label class="collapse" for="c-42396870">[-]</label><label class="expand" for="c-42396870">[1 more]</label></div><br/><div class="children"><div class="content">One of the great things about C64 BASIC and similar MS BASIC derivatives is it&#x27;s extensibility.  It defines a bunch of pointers, including $0033 this article uses, that control the memory layout.  Manipulating them carefully allows you to free up blocks of memory that BASIC won&#x27;t trash.  Or deliberately &quot;trash&quot; for hacks like this.<p>On top of that, a handful of key internal BASIC routines are called indirectly through pointers.  BASIC itself is in ROM and more or less immutable, but by redirecting those pointers you can have it call out to new code in RAM.</div><br/></div></div></div></div></div></div></div></body></html>