<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714899712614" as="style"/><link rel="stylesheet" href="styles.css?v=1714899712614"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/skeeto/hash-prospector">Automated integer hash function discovery</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>danny00</span> | <span>21 comments</span></div><br/><div><div id="40262369" class="c"><input type="checkbox" id="c-40262369" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40262640">next</a><span>|</span><label class="collapse" for="c-40262369">[-]</label><label class="expand" for="c-40262369">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know this guy personally but I like his code.<p>I particularly like his JSON library [0], option parsing libraries [1], branchless UTF-8 decoder [2], lock-free stack [3], and trie library [4].<p>I also like his taste in licensing (all of the above is released under The Unlicense)<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;pdjson">https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;pdjson</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;optparse">https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;optparse</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;getopt">https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;getopt</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;branchless-utf8">https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;branchless-utf8</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;lstack">https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;lstack</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;trie">https:&#x2F;&#x2F;github.com&#x2F;skeeto&#x2F;trie</a></div><br/></div></div><div id="40262640" class="c"><input type="checkbox" id="c-40262640" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#40262369">prev</a><span>|</span><a href="#40263221">next</a><span>|</span><label class="collapse" for="c-40262640">[-]</label><label class="expand" for="c-40262640">[2 more]</label></div><br/><div class="children"><div class="content">Hi, I&#x27;m the MurmurHash guy. Neat stuff, and I&#x27;m amused that multiply-shift-xor has held up so well for all this time.</div><br/><div id="40262789" class="c"><input type="checkbox" id="c-40262789" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#40262640">parent</a><span>|</span><a href="#40263221">next</a><span>|</span><label class="collapse" for="c-40262789">[-]</label><label class="expand" for="c-40262789">[1 more]</label></div><br/><div class="children"><div class="content">Xor-shift counteracts the two weaknesses of a multiply: the high bits have nothing above them to influence, and the low bits have nothing below them to be influenced by.</div><br/></div></div></div></div><div id="40263221" class="c"><input type="checkbox" id="c-40263221" checked=""/><div class="controls bullet"><span class="by">thomasmg</span><span>|</span><a href="#40262640">prev</a><span>|</span><a href="#40262263">next</a><span>|</span><label class="collapse" for="c-40263221">[-]</label><label class="expand" for="c-40263221">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if using the same constant for both multiplications would reduce code size and so could (slightly) speed up computation?<p>I have updated my StackOverflow answer at <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;664014&#x2F;what-integer-hash-function-are-good-that-accepts-an-integer-hash-key&#x2F;12996028#12996028" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;664014&#x2F;what-integer-hash...</a></div><br/></div></div><div id="40262263" class="c"><input type="checkbox" id="c-40262263" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#40263221">prev</a><span>|</span><a href="#40262928">next</a><span>|</span><label class="collapse" for="c-40262263">[-]</label><label class="expand" for="c-40262263">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often thought about the idea of auto hash finding based on my experiences developing good hash functions^0<p>Cool to see this! I think it would be cool to hook it up with SMHasher3^1 (a much improved, and faster variant of the venerable hash test suite developed by Frank J. T. Wojcik)  to automatically evaluate its output. You could use a subset of tests and fail fast for speed.<p>It would also be cool to expand it to 64 and 128 bit hashes (tho obviously the search space is larger).<p>Somewhat related I created some NodeJS code to measure avalanche under multiplication for 64-bit primes in order to select the values for Rain.<p>[Rain]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dosyago&#x2F;rain">https:&#x2F;&#x2F;github.com&#x2F;dosyago&#x2F;rain</a><p>[SMHasher3]: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;fwojcik&#x2F;smhasher3" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;fwojcik&#x2F;smhasher3</a></div><br/></div></div><div id="40262928" class="c"><input type="checkbox" id="c-40262928" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40262263">prev</a><span>|</span><a href="#40262393">next</a><span>|</span><label class="collapse" for="c-40262928">[-]</label><label class="expand" for="c-40262928">[1 more]</label></div><br/><div class="children"><div class="content">I implemented the 1brc in go a few weeks back [1] and this repo was inspiration to try to find a custom perfect hash function that put each station into its own bucket with no collisions. Then I noticed the rule that you can&#x27;t customize the hash function to the data before the program starts and dropped the idea.<p>I made a test harness to check random constants (start values, multiplication constants, shift&#x2F;rotate amounts, etc) and print out the best constants found so far based on the number of colliding buckets and how many collisions. I think I got it down to 1 bucket with just two colliding values with a ~40% fill rate. Interestingly, I found that the best performing constants included similar values for the number of positions to shift regardless of the other constants, so I ended up hard coding them.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;infogulch&#x2F;1brc-go">https:&#x2F;&#x2F;github.com&#x2F;infogulch&#x2F;1brc-go</a></div><br/></div></div><div id="40262393" class="c"><input type="checkbox" id="c-40262393" checked=""/><div class="controls bullet"><span class="by">throwaway_1237</span><span>|</span><a href="#40262928">prev</a><span>|</span><a href="#40263059">next</a><span>|</span><label class="collapse" for="c-40262393">[-]</label><label class="expand" for="c-40262393">[5 more]</label></div><br/><div class="children"><div class="content">Can someone explain why this is cool and what it’s used for?</div><br/><div id="40262768" class="c"><input type="checkbox" id="c-40262768" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#40262393">parent</a><span>|</span><a href="#40263056">next</a><span>|</span><label class="collapse" for="c-40262768">[-]</label><label class="expand" for="c-40262768">[2 more]</label></div><br/><div class="children"><div class="content">It seems to be a tool that generates instructions for building hash functions, then evaluates the hash functions to see how good they are. The goal metric has been chosen to be that as many output bits as possible should change as randomly as possible with every changed input bit.<p>It outputs C code for the best hash function it generated.<p>So it&#x27;s useful if you want a hash function, and don&#x27;t think any of the existing ones are good enough. Or if you&#x27;re researching hash functions, and want new ideas for structures.<p>Cool? Well, generating code is cool. Doing it randomly is a first step towards genetic programming, which would be even cooler. ... and making computers burn CPU cycles computing (mostly unused) hashes seems to be something we humans want to do since around 15 years ago.</div><br/><div id="40263256" class="c"><input type="checkbox" id="c-40263256" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40262393">root</a><span>|</span><a href="#40262768">parent</a><span>|</span><a href="#40263056">next</a><span>|</span><label class="collapse" for="c-40263256">[-]</label><label class="expand" for="c-40263256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [...] making computers burn CPU cycles computing (mostly unused) hashes seems to be something we humans want to do since around 15 years ago.<p>Keep in mind that there&#x27;s a big difference between cryptographic hash functions and the kind of hash functions investigated here.</div><br/></div></div></div></div><div id="40263056" class="c"><input type="checkbox" id="c-40263056" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40262393">parent</a><span>|</span><a href="#40262768">prev</a><span>|</span><a href="#40262733">next</a><span>|</span><label class="collapse" for="c-40263056">[-]</label><label class="expand" for="c-40263056">[1 more]</label></div><br/><div class="children"><div class="content">Hash functions on integers, so if you want a fast integer hash for a set or map. If the functions diverge sufficiently it also provides fast hashes for a bloom filter.</div><br/></div></div><div id="40262733" class="c"><input type="checkbox" id="c-40262733" checked=""/><div class="controls bullet"><span class="by">alegeaa</span><span>|</span><a href="#40262393">parent</a><span>|</span><a href="#40263056">prev</a><span>|</span><a href="#40263059">next</a><span>|</span><label class="collapse" for="c-40262733">[-]</label><label class="expand" for="c-40262733">[1 more]</label></div><br/><div class="children"><div class="content">I am asking myself the same question.</div><br/></div></div></div></div><div id="40263059" class="c"><input type="checkbox" id="c-40263059" checked=""/><div class="controls bullet"><span class="by">renonce</span><span>|</span><a href="#40262393">prev</a><span>|</span><a href="#40262402">next</a><span>|</span><label class="collapse" for="c-40263059">[-]</label><label class="expand" for="c-40263059">[2 more]</label></div><br/><div class="children"><div class="content">I know I’m comparing oranges to apples here as these functions are not well suited for cryptographic operations, but how does the measured “bias” affect cryptanalysis? Can someone familiar with differential cryptography explain if a hash function with a lower bias defeats cryptanalysis with lower rounds or with less compute? Will this thing help find better cryptographic hash functions?</div><br/><div id="40263258" class="c"><input type="checkbox" id="c-40263258" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40263059">parent</a><span>|</span><a href="#40262402">next</a><span>|</span><label class="collapse" for="c-40263258">[-]</label><label class="expand" for="c-40263258">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Will this thing help find better cryptographic hash functions?<p>Very, very unlikely.</div><br/></div></div></div></div><div id="40262402" class="c"><input type="checkbox" id="c-40262402" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40263059">prev</a><span>|</span><a href="#40263155">next</a><span>|</span><label class="collapse" for="c-40262402">[-]</label><label class="expand" for="c-40262402">[2 more]</label></div><br/><div class="children"><div class="content">Limiting itself to reversible operations gives some mathematical niceties, but also locks out a lot of things.<p>When I did something similar, I was thinking about perfect hashing, where the set of inputs is known ahead of time. The usual approach uses a constant array, but I wanted to - in particular, if the inputs are already small integers, if I could compact them further (obviously this is possible: hash -= hash &gt; &gt; gap_index). I sat down and wrote out a list of ... probably 100? ... primitive operations (some of which are admittedly redundant with each other, but which are useful thinking of separately). And then I got bored and never did anything with the project.</div><br/><div id="40263037" class="c"><input type="checkbox" id="c-40263037" checked=""/><div class="controls bullet"><span class="by">mshroyer</span><span>|</span><a href="#40262402">parent</a><span>|</span><a href="#40263155">next</a><span>|</span><label class="collapse" for="c-40263037">[-]</label><label class="expand" for="c-40263037">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Limiting itself to reversible operations gives some mathematical niceties<p>What are those niceties, why is a reversible operation desirable in this context?</div><br/></div></div></div></div><div id="40263155" class="c"><input type="checkbox" id="c-40263155" checked=""/><div class="controls bullet"><span class="by">pcranaway</span><span>|</span><a href="#40262402">prev</a><span>|</span><a href="#40262522">next</a><span>|</span><label class="collapse" for="c-40263155">[-]</label><label class="expand" for="c-40263155">[1 more]</label></div><br/><div class="children"><div class="content">Is this something like a superoptimizer? looks cool!</div><br/></div></div><div id="40262522" class="c"><input type="checkbox" id="c-40262522" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40263155">prev</a><span>|</span><a href="#40262386">next</a><span>|</span><label class="collapse" for="c-40262522">[-]</label><label class="expand" for="c-40262522">[1 more]</label></div><br/><div class="children"><div class="content">I also have something similar here, with a slower generator (interpreted, not jitted), but better quality functions: <a href="https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;fast-hash&#x2F;tree&#x2F;master&#x2F;hashgen">https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;fast-hash&#x2F;tree&#x2F;master&#x2F;hashgen</a><p>But I found nothing better than the old favorites.</div><br/></div></div><div id="40262386" class="c"><input type="checkbox" id="c-40262386" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40262522">prev</a><span>|</span><a href="#40262191">next</a><span>|</span><label class="collapse" for="c-40262386">[-]</label><label class="expand" for="c-40262386">[1 more]</label></div><br/><div class="children"><div class="content">this is a very cool library, but it needs someone to figure out a good way of validating 64 bit hash functions.</div><br/></div></div><div id="40262191" class="c"><input type="checkbox" id="c-40262191" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40262386">prev</a><span>|</span><a href="#40262149">next</a><span>|</span><label class="collapse" for="c-40262191">[-]</label><label class="expand" for="c-40262191">[1 more]</label></div><br/><div class="children"><div class="content">What would make this really interesting is if you can give it a generator for input data yourself. Very often you don&#x27;t have random binary data but structured in some way. The structure might imply you can get a very nice hash function for it.</div><br/></div></div><div id="40262149" class="c"><input type="checkbox" id="c-40262149" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#40262191">prev</a><span>|</span><label class="collapse" for="c-40262149">[-]</label><label class="expand" for="c-40262149">[1 more]</label></div><br/><div class="children"><div class="content">It would be interesting to generalize this with the operations available in the riscv bitmanip extension-- it might discover some strong functions for use in the future when those instructions are more widely available.<p>carryless multiply would also allow extending the set of reversible operations and are fast on some existent hardware (CRC too, somewhat a wider set of hardware but should be a strict subset of what CLMUL could find).<p>Many applications of hashes only care about the LSB or MSB of the hashes so evaluating the bias on MSB or LSB windows would be interesting (or mod varrious numbers), and some overall unbiased functions will look better or worse for metrics that don&#x27;t gauge the entire output.  (or for non-uniform inputs, for that matter, e.g. ascii text).</div><br/></div></div></div></div></div></div></div></body></html>