<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712134865344" as="style"/><link rel="stylesheet" href="styles.css?v=1712134865344"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://huonw.github.io/blog/2024/03/qr-base10-base64/">10 &gt; 64, in QR Codes</a> <span class="domain">(<a href="https://huonw.github.io">huonw.github.io</a>)</span></div><div class="subtext"><span>yvan</span> | <span>69 comments</span></div><br/><div><div id="39905693" class="c"><input type="checkbox" id="c-39905693" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39895171">next</a><span>|</span><label class="collapse" for="c-39905693">[-]</label><label class="expand" for="c-39905693">[11 more]</label></div><br/><div class="children"><div class="content">This is really great, I didn&#x27;t know you could switch encoding schemes within the same QR code.  There&#x27;s a nifty visualization tool [0] that shows how this can reduce QR code sizes. It can determine the optimal segmentation strategy for any string and display a color-code version with statistics.  Very nice!<p>0: <a href="https:&#x2F;&#x2F;www.nayuki.io&#x2F;page&#x2F;optimal-text-segmentation-for-qr-codes" rel="nofollow">https:&#x2F;&#x2F;www.nayuki.io&#x2F;page&#x2F;optimal-text-segmentation-for-qr-...</a></div><br/><div id="39908974" class="c"><input type="checkbox" id="c-39908974" checked=""/><div class="controls bullet"><span class="by">zamfi</span><span>|</span><a href="#39905693">parent</a><span>|</span><a href="#39906775">next</a><span>|</span><label class="collapse" for="c-39908974">[-]</label><label class="expand" for="c-39908974">[2 more]</label></div><br/><div class="children"><div class="content">Speaking of visualization...that last figure in this post is super interesting in part because you can actually <i>see</i> some of the redundancy in the base64 encoding on the left, in the patterns of vertical lines.<p>In general, better compression means output that looks more like &quot;randomness&quot;—any redundancy implies there was room for more compression—and that figure makes this quite clear visually!</div><br/><div id="39911884" class="c"><input type="checkbox" id="c-39911884" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#39905693">root</a><span>|</span><a href="#39908974">parent</a><span>|</span><a href="#39906775">next</a><span>|</span><label class="collapse" for="c-39911884">[-]</label><label class="expand" for="c-39911884">[1 more]</label></div><br/><div class="children"><div class="content">That’s undoubtedly some redundancy in the underlying data, not in the encoding itself.</div><br/></div></div></div></div><div id="39906775" class="c"><input type="checkbox" id="c-39906775" checked=""/><div class="controls bullet"><span class="by">nick238</span><span>|</span><a href="#39905693">parent</a><span>|</span><a href="#39908974">prev</a><span>|</span><a href="#39895171">next</a><span>|</span><label class="collapse" for="c-39906775">[-]</label><label class="expand" for="c-39906775">[8 more]</label></div><br/><div class="children"><div class="content">Seems like the lede was buried in the article; I know a bit about QR codes: there&#x27;s different modes for alphanum, binary, kanji, etc, and error correcting capacity...but being able to switch character sets in the middle was new to me.</div><br/><div id="39907193" class="c"><input type="checkbox" id="c-39907193" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39905693">root</a><span>|</span><a href="#39906775">parent</a><span>|</span><a href="#39895171">next</a><span>|</span><label class="collapse" for="c-39907193">[-]</label><label class="expand" for="c-39907193">[7 more]</label></div><br/><div class="children"><div class="content">I am not entirely sure why you would want to switch encodings for URLs, personally. If you use alphanumeric encoding and a URL in Base36, you are pretty much information-theoretically optimal.</div><br/><div id="39907343" class="c"><input type="checkbox" id="c-39907343" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#39905693">root</a><span>|</span><a href="#39907193">parent</a><span>|</span><a href="#39907508">next</a><span>|</span><label class="collapse" for="c-39907343">[-]</label><label class="expand" for="c-39907343">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you are pretty much information-theoretically optimal<p>base36 with alphanumeric mode encoding has around 6.38% overhead compared to base10&#x27;s 0.34% overhead in numeric mode. So numeric mode gets you closer to optimal.</div><br/></div></div><div id="39907508" class="c"><input type="checkbox" id="c-39907508" checked=""/><div class="controls bullet"><span class="by">daxterspeed</span><span>|</span><a href="#39905693">root</a><span>|</span><a href="#39907193">parent</a><span>|</span><a href="#39907343">prev</a><span>|</span><a href="#39895171">next</a><span>|</span><label class="collapse" for="c-39907508">[-]</label><label class="expand" for="c-39907508">[5 more]</label></div><br/><div class="children"><div class="content">The issue is that QR&#x27;s alphanumeric segments are uppercase only, and while browsers will automatically lowercase the protocol and domain name, you&#x27;ll have to either have all your paths be uppercase or automatically lowercase paths. On top of that when someone scans the code it will likely be presented with an uppercase URL (if it doesn&#x27;t automatically open in a browser) and that should alert anyone that doesn&#x27;t already know that uppercase domains are equivalent to lowercase domains.<p>Ideally QR codes would have had a segment to encode URIs more efficiently (73-82 characters depending on how the implementation decided to handle the &quot;unreserved marks&quot;), but that ship has long sailed.</div><br/><div id="39908218" class="c"><input type="checkbox" id="c-39908218" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39905693">root</a><span>|</span><a href="#39907508">parent</a><span>|</span><a href="#39895171">next</a><span>|</span><label class="collapse" for="c-39908218">[-]</label><label class="expand" for="c-39908218">[4 more]</label></div><br/><div class="children"><div class="content">Many QR code readers will auto-lowercase URLs that are encoded in alphanumeric encoding.  The rest will recognize uppercase URLs just fine.  Alphanumeric encoding was basically made for URLs.</div><br/><div id="39909052" class="c"><input type="checkbox" id="c-39909052" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39905693">root</a><span>|</span><a href="#39908218">parent</a><span>|</span><a href="#39895171">next</a><span>|</span><label class="collapse" for="c-39909052">[-]</label><label class="expand" for="c-39909052">[3 more]</label></div><br/><div class="children"><div class="content">The QR alphanumeric input encoding does not include basic URL query string characters like &#x27;?&#x27; &#x27;&amp;&#x27; &#x27;=&#x27;</div><br/><div id="39912861" class="c"><input type="checkbox" id="c-39912861" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#39905693">root</a><span>|</span><a href="#39909052">parent</a><span>|</span><a href="#39895171">next</a><span>|</span><label class="collapse" for="c-39912861">[-]</label><label class="expand" for="c-39912861">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been putting URL in QR for like a  decade, mixed case and query string included. How has it never been an issue?</div><br/><div id="39912980" class="c"><input type="checkbox" id="c-39912980" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#39905693">root</a><span>|</span><a href="#39912861">parent</a><span>|</span><a href="#39895171">next</a><span>|</span><label class="collapse" for="c-39912980">[-]</label><label class="expand" for="c-39912980">[1 more]</label></div><br/><div class="children"><div class="content">Because you used bytes mode, not alphanumeric mode</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39895171" class="c"><input type="checkbox" id="c-39895171" checked=""/><div class="controls bullet"><span class="by">komlan</span><span>|</span><a href="#39905693">prev</a><span>|</span><a href="#39912575">next</a><span>|</span><label class="collapse" for="c-39895171">[-]</label><label class="expand" for="c-39895171">[1 more]</label></div><br/><div class="children"><div class="content">This is particularly useful for numeric data that is usually displayed in hex, like UUIDs [1]<p>I used this for digital QR code tickets [2], and it made the codes so much easier to scan, even with bad lighting.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39094251">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39094251</a><p>[2] <a href="https:&#x2F;&#x2F;workspace.google.com&#x2F;marketplace&#x2F;app&#x2F;qr_code_ticket_per_row_for_event_attenda&#x2F;9398047938" rel="nofollow">https:&#x2F;&#x2F;workspace.google.com&#x2F;marketplace&#x2F;app&#x2F;qr_code_ticket_...</a></div><br/></div></div><div id="39912575" class="c"><input type="checkbox" id="c-39912575" checked=""/><div class="controls bullet"><span class="by">richardkiss</span><span>|</span><a href="#39895171">prev</a><span>|</span><a href="#39906228">next</a><span>|</span><label class="collapse" for="c-39912575">[-]</label><label class="expand" for="c-39912575">[1 more]</label></div><br/><div class="children"><div class="content">I discovered the same thing when I was writing a tool the transmit data to a radio-free (no wifi or Bluetooth) airgapped computer and created a de-facto standard called &quot;qrint&quot;. The comment in this file has enough text for a blog post.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Chia-Network&#x2F;hsms&#x2F;blob&#x2F;main&#x2F;hsms&#x2F;util&#x2F;qrint_encoding.py">https:&#x2F;&#x2F;github.com&#x2F;Chia-Network&#x2F;hsms&#x2F;blob&#x2F;main&#x2F;hsms&#x2F;util&#x2F;qri...</a><p>Anyone who wants to use this, feel free.</div><br/></div></div><div id="39906228" class="c"><input type="checkbox" id="c-39906228" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#39912575">prev</a><span>|</span><a href="#39905866">next</a><span>|</span><label class="collapse" for="c-39906228">[-]</label><label class="expand" for="c-39906228">[5 more]</label></div><br/><div class="children"><div class="content">For dealing with larger data I would probably split the input bits into 63 bit chunks, which can be encoded in 19 decimal digits. 63 input bits turn into 19 digits which in turn is encoded in 63.33... output bits on average. This has an overhead of 0.53% instead of 0.34% of pure base10, which I think is acceptable. But then you don&#x27;t have to bring bignum libraries into the picture, as each chunk fits into a 64bit integral type.<p>64bit chunks are a little bit worse, with 4.16% overhead, so it might be worth dealing with the little complexity of 63 bit chunks.<p>I would also output the decimal digits in little-endian order.<p>edit: If you are willing to go for larger chunks then 93bit chunks would be my next candidate, there the overhead is 0.36%, barely more than pure base10&#x27;s 0.34%. I don&#x27;t think it&#x27;s worth going any higher.</div><br/><div id="39908663" class="c"><input type="checkbox" id="c-39908663" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#39906228">parent</a><span>|</span><a href="#39908641">prev</a><span>|</span><a href="#39907000">next</a><span>|</span><label class="collapse" for="c-39908663">[-]</label><label class="expand" for="c-39908663">[2 more]</label></div><br/><div class="children"><div class="content">127 bit integers get 38 digits, which lines up well with 128 bit integers</div><br/><div id="39908816" class="c"><input type="checkbox" id="c-39908816" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#39906228">root</a><span>|</span><a href="#39908663">parent</a><span>|</span><a href="#39907000">next</a><span>|</span><label class="collapse" for="c-39908816">[-]</label><label class="expand" for="c-39908816">[1 more]</label></div><br/><div class="children"><div class="content">No, they get 39 decimal digits (1.7e38 is 39 decimal digits). 127bit chunks would get you 2.36% overhead, which is not bad. However at 93bit chunks can (barely) be encoded in 28 digits (2^93 ~= 9.9e27) and it&#x27;s more efficient at around 0.36% overhead. So once you have 128 bit arithmetic, it&#x27;s still not worth using all or most of those bits per chunk, 93bit chunks is the most efficient under 128 bits.</div><br/></div></div></div></div></div></div><div id="39905866" class="c"><input type="checkbox" id="c-39905866" checked=""/><div class="controls bullet"><span class="by">sfmz</span><span>|</span><a href="#39906228">prev</a><span>|</span><a href="#39905342">next</a><span>|</span><label class="collapse" for="c-39905866">[-]</label><label class="expand" for="c-39905866">[5 more]</label></div><br/><div class="children"><div class="content">I had an idea to embed a webpage in a dataurl and convert that to a QR code; the website would only exist on if you snapped the QR Code.  I was dreaming of code-golf, demoscene, nft and weird business card applications, but the web-browsers ruined my fun because they won&#x27;t display dataURL unless you manually copy&#x2F;paste it into the URL bar.<p><a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40502904" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40502904</a></div><br/><div id="39905938" class="c"><input type="checkbox" id="c-39905938" checked=""/><div class="controls bullet"><span class="by">ptramo</span><span>|</span><a href="#39905866">parent</a><span>|</span><a href="#39905342">next</a><span>|</span><label class="collapse" for="c-39905938">[-]</label><label class="expand" for="c-39905938">[4 more]</label></div><br/><div class="children"><div class="content">Good idea. Built <a href="https:&#x2F;&#x2F;srv.us&#x2F;d" rel="nofollow">https:&#x2F;&#x2F;srv.us&#x2F;d</a> that does (edited):<p><pre><code>    &lt;html&gt;&lt;body&gt;&lt;script&gt;document.body.innerHTML = decodeURI(window.location.hash.substring(1))&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;
</code></pre>
So you can point to <a href="https:&#x2F;&#x2F;srv.us&#x2F;d#&lt;h1&gt;Demo&lt;&#x2F;h1&gt;" rel="nofollow">https:&#x2F;&#x2F;srv.us&#x2F;d#&lt;h1&gt;Demo&lt;&#x2F;h1&gt;</a></div><br/><div id="39906326" class="c"><input type="checkbox" id="c-39906326" checked=""/><div class="controls bullet"><span class="by">sfmz</span><span>|</span><a href="#39905866">root</a><span>|</span><a href="#39905938">parent</a><span>|</span><a href="#39905342">next</a><span>|</span><label class="collapse" for="c-39906326">[-]</label><label class="expand" for="c-39906326">[3 more]</label></div><br/><div class="children"><div class="content">Almost, page doesn&#x27;t have a body yet, so you get a null ref.  I thought of spinning it up or hosting on ipfs, but it still won&#x27;t live forever, somebody will lose interest and stop paying the DNS costs or similar.</div><br/><div id="39906357" class="c"><input type="checkbox" id="c-39906357" checked=""/><div class="controls bullet"><span class="by">ptramo</span><span>|</span><a href="#39905866">root</a><span>|</span><a href="#39906326">parent</a><span>|</span><a href="#39905342">next</a><span>|</span><label class="collapse" for="c-39906357">[-]</label><label class="expand" for="c-39906357">[2 more]</label></div><br/><div class="children"><div class="content">Fixed, thanks! Yes, longevity is an issue with anything online. On the other hand, in this case recovery is not a huge issue for anybody technical enough.</div><br/><div id="39912031" class="c"><input type="checkbox" id="c-39912031" checked=""/><div class="controls bullet"><span class="by">sfmz</span><span>|</span><a href="#39905866">root</a><span>|</span><a href="#39906357">parent</a><span>|</span><a href="#39905342">next</a><span>|</span><label class="collapse" for="c-39912031">[-]</label><label class="expand" for="c-39912031">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking at first it would be better if it takes the entire webpage as a datauri instead of the raw html like this basic business card template:<p>data:text&#x2F;html;base64,PCFET0NUWVBFIGh0bWw+DQo8aHRtbCBsYW5nPSJlbiI+DQogIDxoZWFkPg0KICAgIDxtZXRhIGNoYXJzZXQ9IlVURi04IiAvPg0KICAgIDxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wIiAvPg0KICAgIDx0aXRsZT5GbGV4IENhcmQ8L3RpdGxlPg0KICAgIDxzdHlsZT4NCiAgICAgIGJvZHkgew0KICAgICAgICBmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWY7DQogICAgICAgIG1hcmdpbjogMDsNCiAgICAgICAgcGFkZGluZzogMDsNCiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDsNCiAgICAgICAgZGlzcGxheTogZmxleDsNCiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7DQogICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogICAgICAgIGhlaWdodDogMTAwdmg7DQogICAgICB9DQogICAgICAuY2FyZCB7DQogICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7DQogICAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7DQogICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKTsNCiAgICAgICAgcGFkZGluZzogMjBweDsNCiAgICAgICAgbWF4LXdpZHRoOiAzMDBweDsNCiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyOw0KICAgICAgfQ0KICAgICAgLmNhcmQgaW1nIHsNCiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlOw0KICAgICAgICBtYXgtd2lkdGg6IDE1MHB4Ow0KICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4Ow0KICAgICAgfQ0KICAgICAgLmNhcmQgaDEgew0KICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4Ow0KICAgICAgfQ0KICAgICAgLmNhcmQgcCB7DQogICAgICAgIGNvbG9yOiAjNjY2Ow0KICAgICAgfQ0KICAgIDwvc3R5bGU+DQogIDwvaGVhZD4NCiAgPGJvZHk+DQogICAgPGRpdiBjbGFzcz0iY2FyZCI+DQogICAgICA8aDEgc3R5bGU9ImZvbnQtdmFyaWFudDogc21hbGwtY2FwcyI+RWV5b3JlPC9oMT4NCiAgICAgIDxwPkltYWdpbmVlcjwvcD4NCiAgICAgIDxwPk5pbmJvIGZsb2F0aW5nIGNpdHksIHByZWZlY3R1cmUgOTwvcD4NCiAgICAgIDxwPigxMjMpIDQ1Ni03ODkwPC9wPg0KICAgICAgPHA+am9obkBleGFtcGxlLmNvbTwvcD4NCiAgICA8L2Rpdj4NCiAgPC9ib2R5Pg0KPC9odG1sPg0K<p>but that&#x27;s already about half the max bytes for a QR Code, so maybe its not really that interesting.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39905342" class="c"><input type="checkbox" id="c-39905342" checked=""/><div class="controls bullet"><span class="by">zygentoma</span><span>|</span><a href="#39905866">prev</a><span>|</span><a href="#39905796">next</a><span>|</span><label class="collapse" for="c-39905342">[-]</label><label class="expand" for="c-39905342">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    qrencode -t UTF8 https:&#x2F;&#x2F;www.service.nsw.gov.au&#x2F;campaign&#x2F;service-nsw-mobile-app?data=eyJ0IjoiY292aWQxOV9idXNpbmVzcyIsImJpZCI6IjEyMTMyMSIsImJuYW1lIjoiVGVzdCBOU1cgR292ZXJubWVudCBRUiBjb2RlIiwiYmFkZHJlc3MiOiJCdXNpbmVzcyBhZGRyZXNzIGdvZXMgaGVyZSAifQ==
</code></pre>
vs<p><pre><code>    qrencode -t UTF8 https:&#x2F;&#x2F;www.service.nsw.gov.au&#x2F;campaign&#x2F;service-nsw-mobile-app?data=072685680885510189821994892577900638215789419258463239488533499278955911240512279111633336286737089008384293066931974311305533337894591404330656702603998035920596585517131555967430155259257402711671699276432408209151397638174974409842883898456527289026013404155725275860173673194594939
</code></pre>
The latter one is actually smaller. TIL</div><br/><div id="39905491" class="c"><input type="checkbox" id="c-39905491" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39905342">parent</a><span>|</span><a href="#39905796">next</a><span>|</span><label class="collapse" for="c-39905491">[-]</label><label class="expand" for="c-39905491">[3 more]</label></div><br/><div class="children"><div class="content">Note that the URL also has to be encoded in two segments, so that the decimal part can use a more efficient QR encoding than the alphanumeric base URL.<p>I&#x27;m not sure that qrencode CLI tool will automatically do this for you.<p>&gt; In a URL, the rest of the URL is not purely numeric, so actually seeing the benefits of this encoding requires using two segments:<p>&gt; * one with the “boring” bits of the URL at the start, likely using the Binary mode<p>&gt; * one with the big blob of base10 data, using the Numeric mode</div><br/><div id="39905673" class="c"><input type="checkbox" id="c-39905673" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39905342">root</a><span>|</span><a href="#39905491">parent</a><span>|</span><a href="#39905796">next</a><span>|</span><label class="collapse" for="c-39905673">[-]</label><label class="expand" for="c-39905673">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure that qrencode CLI tool will automatically do this for you.<p>If I&#x27;m looking at the correct repository, it does [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;fukuchi&#x2F;libqrencode&#x2F;blob&#x2F;master&#x2F;split.c">https:&#x2F;&#x2F;github.com&#x2F;fukuchi&#x2F;libqrencode&#x2F;blob&#x2F;master&#x2F;split.c</a></div><br/><div id="39905715" class="c"><input type="checkbox" id="c-39905715" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39905342">root</a><span>|</span><a href="#39905673">parent</a><span>|</span><a href="#39905796">next</a><span>|</span><label class="collapse" for="c-39905715">[-]</label><label class="expand" for="c-39905715">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right! I briefly searched the code but I missed seeing that since they don&#x27;t use the term &quot;segment&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="39905796" class="c"><input type="checkbox" id="c-39905796" checked=""/><div class="controls bullet"><span class="by">ptramo</span><span>|</span><a href="#39905342">prev</a><span>|</span><a href="#39905889">next</a><span>|</span><label class="collapse" for="c-39905796">[-]</label><label class="expand" for="c-39905796">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;zat.is" rel="nofollow">https:&#x2F;&#x2F;zat.is</a> uses uppercase base32 for URL checksums, as alphanumeric QR codes can contain 0–9, A–Z (upper-case only), space, $, %, *, +, -, ., &#x2F;, :. Overhead is only 10% (5.5 bits &#x2F; 5 bits). All links fit in a 33⨯33px image, margins included, so little point in improving on that for URLs so short. The tradeoff is that the checksum to URL mapping is stored in a backend and networking is required to learn anything about the real URL.</div><br/></div></div><div id="39905889" class="c"><input type="checkbox" id="c-39905889" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39905796">prev</a><span>|</span><a href="#39906564">next</a><span>|</span><label class="collapse" for="c-39905889">[-]</label><label class="expand" for="c-39905889">[2 more]</label></div><br/><div class="children"><div class="content">In an ideal world, the QR standard would include a specific URL encoding scheme that exactly matches the URL-safe character set.  But I suppose there&#x27;s no real practical way to make big changes to the QR spec now, what with all the thousands of implementations in the wild.</div><br/><div id="39910882" class="c"><input type="checkbox" id="c-39910882" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#39905889">parent</a><span>|</span><a href="#39906564">next</a><span>|</span><label class="collapse" for="c-39910882">[-]</label><label class="expand" for="c-39910882">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d rather they had just done entropy coding. It&#x27;s good at using a smaller number of bits per character to represent a subset of characters, which is what they&#x27;re trying to do. But it&#x27;s more general, so you wouldn&#x27;t be limited to only those characters.<p>Huffman is probably simple enough. The typical approach is adaptive Huffman, which doesn&#x27;t compress the initial data very well since it needs to adjust to actual character frequencies. So that wouldn&#x27;t work well for QR codes since they&#x27;re short.<p>But you can start adaptive Huffman with a pre-agreed initial tree (as static Huffman does), which would give good compression from the start. There could be several standard pre-agreed Huffman trees, and instead of using bits in the QR code to select a character set, those bits could select one of a few pre-agreed initial Huffman trees.</div><br/></div></div></div></div><div id="39906564" class="c"><input type="checkbox" id="c-39906564" checked=""/><div class="controls bullet"><span class="by">PanMan</span><span>|</span><a href="#39905889">prev</a><span>|</span><a href="#39911690">next</a><span>|</span><label class="collapse" for="c-39906564">[-]</label><label class="expand" for="c-39906564">[5 more]</label></div><br/><div class="children"><div class="content">Cool article. What I&#x27;ve wondered, and the article doesn&#x27;t touch on: In &quot;normal&quot; usage (not damaged QR codes), what&#x27;s the best error correction to use, with a fixed output size (eg a sticker)? Using a higher level, results in more bytes, and thus a larger QR, which, when printed, results in smaller details. 
Is it better to have a low error correction, resulting in large blobs, or to have higher error correction, resulting in smaller details, which I guess will be harder to scan, but more room for correction?</div><br/><div id="39906740" class="c"><input type="checkbox" id="c-39906740" checked=""/><div class="controls bullet"><span class="by">master-lincoln</span><span>|</span><a href="#39906564">parent</a><span>|</span><a href="#39910323">next</a><span>|</span><label class="collapse" for="c-39906740">[-]</label><label class="expand" for="c-39906740">[2 more]</label></div><br/><div class="children"><div class="content">I guess this is a trade off that depends on your use case: from which distance does the qr code need to be scannable, what cameras do we expect to be used for scanning, how likely is what kind of damage to parts of the qr code, ...</div><br/><div id="39907427" class="c"><input type="checkbox" id="c-39907427" checked=""/><div class="controls bullet"><span class="by">spamatica</span><span>|</span><a href="#39906564">root</a><span>|</span><a href="#39906740">parent</a><span>|</span><a href="#39910323">next</a><span>|</span><label class="collapse" for="c-39907427">[-]</label><label class="expand" for="c-39907427">[1 more]</label></div><br/><div class="children"><div class="content">Indeed.
The local bus transit has a digital ticket system with QR codes for tickets. I haven&#x27;t actually tried decoding the codes but just seeing them and interacting with them I can tell they have gone WAY overboard with either the amount of data they try to fit or the amount of error correction. Probably both. They are nearly unscannable due to their size and all the bus drivers just wave you along if you don&#x27;t manage to scan it.</div><br/></div></div></div></div><div id="39910323" class="c"><input type="checkbox" id="c-39910323" checked=""/><div class="controls bullet"><span class="by">dbaupp</span><span>|</span><a href="#39906564">parent</a><span>|</span><a href="#39906740">prev</a><span>|</span><a href="#39911690">next</a><span>|</span><label class="collapse" for="c-39910323">[-]</label><label class="expand" for="c-39910323">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I had had the same question! One of my earlier articles experiments with this: <a href="https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2021&#x2F;09&#x2F;qr-error-correction&#x2F;" rel="nofollow">https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2021&#x2F;09&#x2F;qr-error-correction&#x2F;</a><p>Figure 8 and its surrounding section are the undamaged case.</div><br/><div id="39914942" class="c"><input type="checkbox" id="c-39914942" checked=""/><div class="controls bullet"><span class="by">derf_</span><span>|</span><a href="#39906564">root</a><span>|</span><a href="#39910323">parent</a><span>|</span><a href="#39911690">next</a><span>|</span><label class="collapse" for="c-39914942">[-]</label><label class="expand" for="c-39914942">[1 more]</label></div><br/><div class="children"><div class="content">That was a nice read.<p><i>&gt; I also tested only one background image, so the behaviour may differ greatly with QR codes contained in different surrounds.</i><p>This likely does not matter much. It could theoretically affect binarization near the edges of the code (near module boundaries, depending on how you did the resizing), but in practice as long as the code itself is high-contrast, this is unlikely. The more usual issue is that real images often do not have a proper quiet zone around the code, but that is mostly going to be irrelevant for what you are trying to test here.<p><i>&gt; The QR codes are generated to be perfectly rectangular and aligned to the image pixel grid, which is unlikely to happen in the real world.</i><p>This is a much bigger deal. A large source of decoding errors for larger versions (for a fixed &quot;field of view&quot;) is due to alignment &#x2F; sampling issues. A lot of work goes into trying to find <i>where</i> the code is in the image and identify the grid pattern, and that is just inherently less reliable for larger versions, particularly if there is projective distortion (so the module size is not constant). The periodic alignment patterns try to keep the number of parameters that can be used to fit this grid roughly constant relative to the number of modules in the grid, but locating those patterns is itself error-prone and subject to false positives (they are not nearly as unique-looking as finder patterns), and the initial global transform estimate has to get pretty close for them to work. I am actually happy that damaging these was not causing you more trouble. This is definitely somewhere that ZBar can be improved. It currently does not use the timing patterns at all, for example. I&#x27;m not actually aware of an open-source QR decoder that does.<p>(I&#x27;m the original author of ZBar&#x27;s QR decoder)</div><br/></div></div></div></div></div></div><div id="39911690" class="c"><input type="checkbox" id="c-39911690" checked=""/><div class="controls bullet"><span class="by">bytecodes</span><span>|</span><a href="#39906564">prev</a><span>|</span><a href="#39907168">next</a><span>|</span><label class="collapse" for="c-39911690">[-]</label><label class="expand" for="c-39911690">[2 more]</label></div><br/><div class="children"><div class="content">1. Pretty neat to switch encoding in the middle of the URL. It does look like it works and it does look like a better encoding. This is cool.<p>2. I&#x27;d have called this base-1000. It&#x27;s using 3-digit numbers encoded into 10 bits. Base64 doesn&#x27;t encode into 64 bits, it uses 64 characters encoded into 6 bits. And this encoding uses 000 to 999, encoded into 10 bits. But that messes up the title when you compare apples to apples, 1000 &gt; 64 is just obvious and true.</div><br/><div id="39911848" class="c"><input type="checkbox" id="c-39911848" checked=""/><div class="controls bullet"><span class="by">dbaupp</span><span>|</span><a href="#39911690">parent</a><span>|</span><a href="#39907168">next</a><span>|</span><label class="collapse" for="c-39911848">[-]</label><label class="expand" for="c-39911848">[1 more]</label></div><br/><div class="children"><div class="content">The base 10 is referring to conversion of bytes into a long decimal (base 10) integer, not that it&#x27;s being stored in chunks of 10 bits.<p>But yes, you&#x27;re right, it would be reasonable to think of this as encoding the bytes in base 1000, where each &quot;digit&quot; just happens to be shown to humans as 3 digits.</div><br/></div></div></div></div><div id="39907168" class="c"><input type="checkbox" id="c-39907168" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39911690">prev</a><span>|</span><a href="#39908019">next</a><span>|</span><label class="collapse" for="c-39907168">[-]</label><label class="expand" for="c-39907168">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if anyone uses Base36 any more (or its more obscure sister, Base32), but it uses [0-9, A-Z] as its alphabet. It is URL safe and also smaller than base 10 in character count for each number, and is the smallest standard URL-safe encoding that works with alphanumeric QR codes.<p>I sort of assumed this was common knowledge, but I guess not.</div><br/><div id="39911555" class="c"><input type="checkbox" id="c-39911555" checked=""/><div class="controls bullet"><span class="by">dbaupp</span><span>|</span><a href="#39907168">parent</a><span>|</span><a href="#39907672">next</a><span>|</span><label class="collapse" for="c-39911555">[-]</label><label class="expand" for="c-39911555">[1 more]</label></div><br/><div class="children"><div class="content">I implicitly ignored encoding schemes like base 36 and 32 (and 16, referenced elsewhere in the thread) because they&#x27;re not as good as the schemes referenced in the post. The best you can get that&#x27;s fully URL safe with Alphanumeric is a hypothetical base 39, referenced in a footnote, and only using 39 of the 45 possible characters has 3.9% overhead (even ignoring the 50% overhead of the <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9285.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9285.html</a> encoding).<p>I&#x27;ve added an analysis of many more bases to the article: <a href="https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2024&#x2F;03&#x2F;qr-base10-base64&#x2F;#fn:other-bases" rel="nofollow">https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2024&#x2F;03&#x2F;qr-base10-base64&#x2F;#fn:ot...</a></div><br/></div></div><div id="39907672" class="c"><input type="checkbox" id="c-39907672" checked=""/><div class="controls bullet"><span class="by">91bananas</span><span>|</span><a href="#39907168">parent</a><span>|</span><a href="#39911555">prev</a><span>|</span><a href="#39908019">next</a><span>|</span><label class="collapse" for="c-39907672">[-]</label><label class="expand" for="c-39907672">[2 more]</label></div><br/><div class="children"><div class="content">Tooling is probably what dictates this more than anything. atob() is everywhere.</div><br/><div id="39911591" class="c"><input type="checkbox" id="c-39911591" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#39907168">root</a><span>|</span><a href="#39907672">parent</a><span>|</span><a href="#39908019">next</a><span>|</span><label class="collapse" for="c-39911591">[-]</label><label class="expand" for="c-39911591">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I don&#x27;t get it. Assume I have a standard URL with query params, the web browser doesn&#x27;t understand the decimal encoding – right?<p>Let&#x27;s assume... this:
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;reply?id=39907672&amp;goto=item%3Fid%3D39894148%2339907672">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;reply?id=39907672&amp;goto=item%3Fi...</a><p>The special encoding is just about sending data to the backend?</div><br/></div></div></div></div></div></div><div id="39908019" class="c"><input type="checkbox" id="c-39908019" checked=""/><div class="controls bullet"><span class="by">FullyFunctional</span><span>|</span><a href="#39907168">prev</a><span>|</span><a href="#39906424">next</a><span>|</span><label class="collapse" for="c-39908019">[-]</label><label class="expand" for="c-39908019">[4 more]</label></div><br/><div class="children"><div class="content">This is fascinating, but I was curious about the last two QR codes.  The left one is scannable on my iPhone (iOS 17.4.1) leading to <a href="http:&#x2F;&#x2F;example.com&#x2F;AAE..._w8fL" rel="nofollow">http:&#x2F;&#x2F;example.com&#x2F;AAE..._w8fL</a> whereas the one on the right gets only <a href="http:&#x2F;&#x2F;example.com" rel="nofollow">http:&#x2F;&#x2F;example.com</a> (both Safari and Firefox).  Is this an iOS URL length limitation?</div><br/><div id="39912736" class="c"><input type="checkbox" id="c-39912736" checked=""/><div class="controls bullet"><span class="by">capitainenemo</span><span>|</span><a href="#39908019">parent</a><span>|</span><a href="#39911596">next</a><span>|</span><label class="collapse" for="c-39912736">[-]</label><label class="expand" for="c-39912736">[2 more]</label></div><br/><div class="children"><div class="content">You probably know this, but Firefox and Chrome don&#x27;t have the freedom to run their own browser engines on iOS and are little more than browser skins around the webkit core, so listing multiple browsers for a web issue on iOS usually doesn&#x27;t mean much.</div><br/></div></div><div id="39911596" class="c"><input type="checkbox" id="c-39911596" checked=""/><div class="controls bullet"><span class="by">dbaupp</span><span>|</span><a href="#39908019">parent</a><span>|</span><a href="#39912736">prev</a><span>|</span><a href="#39906424">next</a><span>|</span><label class="collapse" for="c-39911596">[-]</label><label class="expand" for="c-39911596">[1 more]</label></div><br/><div class="children"><div class="content">Good catch! I should&#x27;ve tested. I&#x27;ve added a paragraph to <a href="https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2024&#x2F;03&#x2F;qr-base10-base64&#x2F;#extremes" rel="nofollow">https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2024&#x2F;03&#x2F;qr-base10-base64&#x2F;#extre...</a> about this.</div><br/></div></div></div></div><div id="39906424" class="c"><input type="checkbox" id="c-39906424" checked=""/><div class="controls bullet"><span class="by">buildsjets</span><span>|</span><a href="#39908019">prev</a><span>|</span><a href="#39905842">next</a><span>|</span><label class="collapse" for="c-39906424">[-]</label><label class="expand" for="c-39906424">[1 more]</label></div><br/><div class="children"><div class="content">I need to re-run the math based on this info, but a while back, I wanted to figure out the maximum density of QR codes that could be reliably printed on a sheet of plain paper with a laser printer, then optically scanned and re-digitized.  I recall the answer was about the same as a double-density 5.25&quot; floppy disk, which is 320kb.</div><br/></div></div><div id="39905842" class="c"><input type="checkbox" id="c-39905842" checked=""/><div class="controls bullet"><span class="by">YoshiRulz</span><span>|</span><a href="#39906424">prev</a><span>|</span><a href="#39905743">next</a><span>|</span><label class="collapse" for="c-39905842">[-]</label><label class="expand" for="c-39905842">[2 more]</label></div><br/><div class="children"><div class="content">Thanks to the author&#x27;s previous post, I instantly recognised the `eyJ` prefix as the start of a JSON object!</div><br/><div id="39906544" class="c"><input type="checkbox" id="c-39906544" checked=""/><div class="controls bullet"><span class="by">JadeNB</span><span>|</span><a href="#39905842">parent</a><span>|</span><a href="#39905743">next</a><span>|</span><label class="collapse" for="c-39906544">[-]</label><label class="expand" for="c-39906544">[1 more]</label></div><br/><div class="children"><div class="content">The previous post: [Mechanical sympathy for QR codes: making NSW check-in better](<a href="https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2021&#x2F;10&#x2F;nsw-covid-qr" rel="nofollow">https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2021&#x2F;10&#x2F;nsw-covid-qr</a>).</div><br/></div></div></div></div><div id="39905743" class="c"><input type="checkbox" id="c-39905743" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#39905842">prev</a><span>|</span><a href="#39905660">next</a><span>|</span><label class="collapse" for="c-39905743">[-]</label><label class="expand" for="c-39905743">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not that familiar with QR codes. Anyone know how base16&#x2F;hexadecimal encoding with 0-9A-F fares in comparison? It seems like an obvious encoding to test, especially for simplicity of implementation compared to base64 and base10, and an odd one to miss for comparison?</div><br/><div id="39905823" class="c"><input type="checkbox" id="c-39905823" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39905743">parent</a><span>|</span><a href="#39910403">next</a><span>|</span><label class="collapse" for="c-39905823">[-]</label><label class="expand" for="c-39905823">[1 more]</label></div><br/><div class="children"><div class="content">The QR standard does not have a specific encoding mode [0] for hexademical, it would have to use alphanumeric.  Since you&#x27;d only be using 16 out of 35 possible characters, it would be much less efficient.<p>0: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;QR_code#Information_capacity" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;QR_code#Information_capacity</a></div><br/></div></div><div id="39910403" class="c"><input type="checkbox" id="c-39910403" checked=""/><div class="controls bullet"><span class="by">dbaupp</span><span>|</span><a href="#39905743">parent</a><span>|</span><a href="#39905823">prev</a><span>|</span><a href="#39905810">next</a><span>|</span><label class="collapse" for="c-39910403">[-]</label><label class="expand" for="c-39910403">[2 more]</label></div><br/><div class="children"><div class="content">Ah, it is a good point that it might be worth comparing to, but it is far worse.<p>Abstractly, it requires approximately log(45)&#x2F;log(16) output bits per input bit, an overhead of 37%.<p>Making this more concrete: each input byte is encoded as two hex digits, and two hex digits have to be encoded as two Alphanumeric characters. It thus takes 11 bits in the QR code bit stream to store 8 bits of input.</div><br/><div id="39911557" class="c"><input type="checkbox" id="c-39911557" checked=""/><div class="controls bullet"><span class="by">dbaupp</span><span>|</span><a href="#39905743">root</a><span>|</span><a href="#39910403">parent</a><span>|</span><a href="#39905810">next</a><span>|</span><label class="collapse" for="c-39911557">[-]</label><label class="expand" for="c-39911557">[1 more]</label></div><br/><div class="children"><div class="content">(I&#x27;ve added an analysis of this and other bases to the article: <a href="https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2024&#x2F;03&#x2F;qr-base10-base64&#x2F;#fn:other-bases" rel="nofollow">https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2024&#x2F;03&#x2F;qr-base10-base64&#x2F;#fn:ot...</a>)</div><br/></div></div></div></div><div id="39905810" class="c"><input type="checkbox" id="c-39905810" checked=""/><div class="controls bullet"><span class="by">komlan</span><span>|</span><a href="#39905743">parent</a><span>|</span><a href="#39910403">prev</a><span>|</span><a href="#39906020">next</a><span>|</span><label class="collapse" for="c-39905810">[-]</label><label class="expand" for="c-39905810">[1 more]</label></div><br/><div class="children"><div class="content">Hex is worse, see here [1] for UUIDs<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39094251">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39094251</a></div><br/></div></div><div id="39906020" class="c"><input type="checkbox" id="c-39906020" checked=""/><div class="controls bullet"><span class="by">Karliss</span><span>|</span><a href="#39905743">parent</a><span>|</span><a href="#39905810">prev</a><span>|</span><a href="#39905660">next</a><span>|</span><label class="collapse" for="c-39906020">[-]</label><label class="expand" for="c-39906020">[1 more]</label></div><br/><div class="children"><div class="content">Most compact QR encoding capable of representing hex symbols is alphanumeric mode which requires 5.5 bits per character. Which means the output will be 5.5&#x2F;4 = 1.375 times longer than encoded binary data or 37.5% overhead. That&#x27;s even worse than 8&#x2F;6 =1.33 you get for doing base64 encoding on top of byte mode.</div><br/></div></div></div></div><div id="39905660" class="c"><input type="checkbox" id="c-39905660" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#39905743">prev</a><span>|</span><a href="#39906928">next</a><span>|</span><label class="collapse" for="c-39905660">[-]</label><label class="expand" for="c-39905660">[1 more]</label></div><br/><div class="children"><div class="content">We have a similar problem at work right now, but due to different constraints we&#x27;ve settled on Base85. Slightly denser than Base64, but still just plain old printable ASCII characters and the following characters are still &quot;free&quot; so one can use them as field delimiters in a CSV-style format:<p><pre><code>    &quot;&#x27;,&#x2F;[]\
</code></pre>
Incidentally, this also makes them JSON-Safe.<p>Base94 uses all printable characters, and Base122 uses both printable characters and whitespace.<p>UUIDs encoded in various alphabets:<p><pre><code>    len     algo               value
    24 Base64 padded   wScmB8cVS&#x2F;K05Wk+nORR8Q==
    22 Base64 unpadded osnQ3DUDTDuUQBc9mBRYFw
    20 Base85          rHoLuTk%W0fgpY+`c&gt;xc 
    20 Base94          d(+H&quot;Q&#x2F;hP}i}d9&lt;KeAt)%
    18 Base122         @#FoALt`92vSt@</code></pre></div><br/></div></div><div id="39906928" class="c"><input type="checkbox" id="c-39906928" checked=""/><div class="controls bullet"><span class="by">chpatrick</span><span>|</span><a href="#39905660">prev</a><span>|</span><a href="#39912005">next</a><span>|</span><label class="collapse" for="c-39906928">[-]</label><label class="expand" for="c-39906928">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t the EU covid passport decide to use the text encoding mode because it&#x27;s the only one that scanners supported reliably?</div><br/></div></div><div id="39912005" class="c"><input type="checkbox" id="c-39912005" checked=""/><div class="controls bullet"><span class="by">JoshMandel</span><span>|</span><a href="#39906928">prev</a><span>|</span><a href="#39905843">next</a><span>|</span><label class="collapse" for="c-39912005">[-]</label><label class="expand" for="c-39912005">[1 more]</label></div><br/><div class="children"><div class="content">We used essentially this technique in the SMART Health Cards specification for vaccine and lab result QRs.<p><a href="https:&#x2F;&#x2F;spec.smarthealth.cards&#x2F;#encoding-qrs" rel="nofollow">https:&#x2F;&#x2F;spec.smarthealth.cards&#x2F;#encoding-qrs</a><p>It&#x27;s well supported by scanners but can create unwieldy values for users to copy&#x2F;paste.<p>For more recent work with dynamic content (and the assumption that a web server is involved in the flow), we&#x27;re just limiting the payload size and using ordinary byte mode (<a href="https:&#x2F;&#x2F;docs.smarthealthit.org&#x2F;smart-health-links&#x2F;spec" rel="nofollow">https:&#x2F;&#x2F;docs.smarthealthit.org&#x2F;smart-health-links&#x2F;spec</a>)</div><br/></div></div><div id="39905843" class="c"><input type="checkbox" id="c-39905843" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#39912005">prev</a><span>|</span><a href="#39906528">next</a><span>|</span><label class="collapse" for="c-39905843">[-]</label><label class="expand" for="c-39905843">[3 more]</label></div><br/><div class="children"><div class="content">base10 can be awkward to work with for large data, one can also consider:<p>base8 in numeric mode: 8 input bits -&gt; 3 digits -&gt; 10 output bits, 25% overhead<p>base32 in alphanumeric mode: 5 input bits -&gt; 1 character -&gt; 5.5 output bits, 10% overhead<p>I would prefer base32 out of these too, but it&#x27;s interesting that even base8 beats base64 here.</div><br/><div id="39911589" class="c"><input type="checkbox" id="c-39911589" checked=""/><div class="controls bullet"><span class="by">dbaupp</span><span>|</span><a href="#39905843">parent</a><span>|</span><a href="#39906528">next</a><span>|</span><label class="collapse" for="c-39911589">[-]</label><label class="expand" for="c-39911589">[2 more]</label></div><br/><div class="children"><div class="content">Good point! I&#x27;ve added an analysis of this and other bases to <a href="https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2024&#x2F;03&#x2F;qr-base10-base64&#x2F;#fn:other-bases" rel="nofollow">https:&#x2F;&#x2F;huonw.github.io&#x2F;blog&#x2F;2024&#x2F;03&#x2F;qr-base10-base64&#x2F;#fn:ot...</a></div><br/><div id="39914814" class="c"><input type="checkbox" id="c-39914814" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#39905843">root</a><span>|</span><a href="#39911589">parent</a><span>|</span><a href="#39906528">next</a><span>|</span><label class="collapse" for="c-39914814">[-]</label><label class="expand" for="c-39914814">[1 more]</label></div><br/><div class="children"><div class="content">Doh! I don&#x27;t know why I went with per-byte encoding for octal. Yeah, you can do 11.1% overhead with base8, not much worse than base32, surprisingly.</div><br/></div></div></div></div></div></div><div id="39906528" class="c"><input type="checkbox" id="c-39906528" checked=""/><div class="controls bullet"><span class="by">JadeNB</span><span>|</span><a href="#39905843">prev</a><span>|</span><a href="#39906359">next</a><span>|</span><label class="collapse" for="c-39906528">[-]</label><label class="expand" for="c-39906528">[2 more]</label></div><br/><div class="children"><div class="content">Why does the title have a &quot;&#x27;&quot; that isn&#x27;t in the document (&quot;&#x27;10 &gt; 64, in QR Codes&quot; versus &quot;10 &gt; 64, in QR Codes&quot;)?</div><br/><div id="39911283" class="c"><input type="checkbox" id="c-39911283" checked=""/><div class="controls bullet"><span class="by">dbaupp</span><span>|</span><a href="#39906528">parent</a><span>|</span><a href="#39906359">next</a><span>|</span><label class="collapse" for="c-39911283">[-]</label><label class="expand" for="c-39911283">[1 more]</label></div><br/><div class="children"><div class="content">Hacker News strips leading digits targeted at &quot;listicles&quot; (e.g. &quot;10 ways to fizz buzz&quot; -&gt; &quot;Ways to fizz buzz&quot;), so tricks are required if the digits are actually important.</div><br/></div></div></div></div><div id="39906359" class="c"><input type="checkbox" id="c-39906359" checked=""/><div class="controls bullet"><span class="by">ingen0s</span><span>|</span><a href="#39906528">prev</a><span>|</span><a href="#39906850">next</a><span>|</span><label class="collapse" for="c-39906359">[-]</label><label class="expand" for="c-39906359">[1 more]</label></div><br/><div class="children"><div class="content">you had me at hello</div><br/></div></div><div id="39905701" class="c"><input type="checkbox" id="c-39905701" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#39906850">prev</a><span>|</span><label class="collapse" for="c-39905701">[-]</label><label class="expand" for="c-39905701">[4 more]</label></div><br/><div class="children"><div class="content">Or...     Don&#x27;t encode data in the URL at all.   If your data isn&#x27;t secret or per-user, have it go to <a href="https:&#x2F;&#x2F;yoursite.com&#x2F;gh" rel="nofollow">https:&#x2F;&#x2F;yoursite.com&#x2F;gh</a>.  If it is security sensitive, go to <a href="https:&#x2F;&#x2F;yoursite.com&#x2F;Qhm4Qr55mS" rel="nofollow">https:&#x2F;&#x2F;yoursite.com&#x2F;Qhm4Qr55mS</a><p>2 alphanumerics (=4000 links) is plenty to encode a link to all the major pages of your website&#x2F;service you may want to advertise.    10 alphanumerics (=10^18) is plenty that even if every person in the world had a QR code, nobody could guess one before hitting your rate limiter.<p>The user experience gained by fast reliable scanning is far greater than that enabled by slightly improved offline support (offline functionality requires that the user already has your app installed, and in that case, you could preload any codes that user had access to).</div><br/><div id="39906077" class="c"><input type="checkbox" id="c-39906077" checked=""/><div class="controls bullet"><span class="by">chrisfinazzo</span><span>|</span><a href="#39905701">parent</a><span>|</span><a href="#39905735">next</a><span>|</span><label class="collapse" for="c-39906077">[-]</label><label class="expand" for="c-39906077">[1 more]</label></div><br/><div class="children"><div class="content">To play devil’s advocate for a moment…<p>Wouldn’t this break Deep&#x2F;Universal links which send a user directly to a specific location within an app?<p>I get that there are potential security&#x2F;privacy concerns, but if you are in full control of URL schemes, isn’t that purpose of this feature?</div><br/></div></div><div id="39905735" class="c"><input type="checkbox" id="c-39905735" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39905701">parent</a><span>|</span><a href="#39906077">prev</a><span>|</span><a href="#39910933">next</a><span>|</span><label class="collapse" for="c-39905735">[-]</label><label class="expand" for="c-39905735">[1 more]</label></div><br/><div class="children"><div class="content">As the article mentions, they need to include the data so that the app could work offline, at least to some degree.</div><br/></div></div><div id="39910933" class="c"><input type="checkbox" id="c-39910933" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#39905701">parent</a><span>|</span><a href="#39905735">prev</a><span>|</span><label class="collapse" for="c-39910933">[-]</label><label class="expand" for="c-39910933">[1 more]</label></div><br/><div class="children"><div class="content">In the case of vaccine cards, which the OP uses as the case study, it&#x27;s better to have the entire card offline for both privacy and offline use purposes.</div><br/></div></div></div></div></div></div></div></div></div></body></html>