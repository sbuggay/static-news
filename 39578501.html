<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709456456555" as="style"/><link rel="stylesheet" href="styles.css?v=1709456456555"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://benhoyt.com/writings/go-1brc/">The One Billion Row Challenge in Go: from 1m45s to 4s in nine solutions</a> <span class="domain">(<a href="https://benhoyt.com">benhoyt.com</a>)</span></div><div class="subtext"><span>nalgeon</span> | <span>89 comments</span></div><br/><div><div id="39578699" class="c"><input type="checkbox" id="c-39578699" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#39579060">next</a><span>|</span><label class="collapse" for="c-39578699">[-]</label><label class="expand" for="c-39578699">[2 more]</label></div><br/><div class="children"><div class="content">I found this super interesting - especially as all the data I&#x27;ve written code to manipulate has been small enough that I haven&#x27;t needed to optimize my code, so I&#x27;ve never had to think in this direction.<p>I think my favorite part was the very first section, where he got baseline measurements with `cat`, `wc`, and friends. I wouldn&#x27;t have thought to do that and its such an easy way to get a perspective on what&#x27;s &quot;reasonable&quot;.</div><br/><div id="39578835" class="c"><input type="checkbox" id="c-39578835" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#39578699">parent</a><span>|</span><a href="#39579060">next</a><span>|</span><label class="collapse" for="c-39578835">[-]</label><label class="expand" for="c-39578835">[1 more]</label></div><br/><div class="children"><div class="content">I hate to &quot;me too&quot;, but you also nailed that analysis.</div><br/></div></div></div></div><div id="39579060" class="c"><input type="checkbox" id="c-39579060" checked=""/><div class="controls bullet"><span class="by">faizshah</span><span>|</span><a href="#39578699">prev</a><span>|</span><a href="#39579509">next</a><span>|</span><label class="collapse" for="c-39579060">[-]</label><label class="expand" for="c-39579060">[7 more]</label></div><br/><div class="children"><div class="content">I was curious how long it would take with Polars (for scale), apparently 33s: <a href="https:&#x2F;&#x2F;github.com&#x2F;Butch78&#x2F;1BillionRowChallenge&#x2F;tree&#x2F;main">https:&#x2F;&#x2F;github.com&#x2F;Butch78&#x2F;1BillionRowChallenge&#x2F;tree&#x2F;main</a><p>I’m kind of interested in the opposite problem, what is the simplest solution using a well known library&#x2F;db that approaches the fastest hand optimized solution to this problem?</div><br/><div id="39579093" class="c"><input type="checkbox" id="c-39579093" checked=""/><div class="controls bullet"><span class="by">sharno</span><span>|</span><a href="#39579060">parent</a><span>|</span><a href="#39579212">next</a><span>|</span><label class="collapse" for="c-39579093">[-]</label><label class="expand" for="c-39579093">[3 more]</label></div><br/><div class="children"><div class="content">That’s the question worth asking imo. I was wondering how fast is the idiomatic Java solution</div><br/><div id="39579429" class="c"><input type="checkbox" id="c-39579429" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#39579060">root</a><span>|</span><a href="#39579093">parent</a><span>|</span><a href="#39579212">next</a><span>|</span><label class="collapse" for="c-39579429">[-]</label><label class="expand" for="c-39579429">[2 more]</label></div><br/><div class="children"><div class="content">71 seconds<p><a href="https:&#x2F;&#x2F;questdb.io&#x2F;blog&#x2F;billion-row-challenge-step-by-step&#x2F;">https:&#x2F;&#x2F;questdb.io&#x2F;blog&#x2F;billion-row-challenge-step-by-step&#x2F;</a></div><br/><div id="39579520" class="c"><input type="checkbox" id="c-39579520" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#39579060">root</a><span>|</span><a href="#39579429">parent</a><span>|</span><a href="#39579212">next</a><span>|</span><label class="collapse" for="c-39579520">[-]</label><label class="expand" for="c-39579520">[1 more]</label></div><br/><div class="children"><div class="content">Is that the same hardware? Otherwise it doesn’t say much.</div><br/></div></div></div></div></div></div><div id="39579212" class="c"><input type="checkbox" id="c-39579212" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#39579060">parent</a><span>|</span><a href="#39579093">prev</a><span>|</span><a href="#39579509">next</a><span>|</span><label class="collapse" for="c-39579212">[-]</label><label class="expand" for="c-39579212">[3 more]</label></div><br/><div class="children"><div class="content">Where’s the source data I’d like to attempt ingesting this and processing it with DuckDb.</div><br/><div id="39579346" class="c"><input type="checkbox" id="c-39579346" checked=""/><div class="controls bullet"><span class="by">schu</span><span>|</span><a href="#39579060">root</a><span>|</span><a href="#39579212">parent</a><span>|</span><a href="#39579329">next</a><span>|</span><label class="collapse" for="c-39579346">[-]</label><label class="expand" for="c-39579346">[1 more]</label></div><br/><div class="children"><div class="content">Instructions on how to create it can be found here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc?tab=readme-ov-file#running-the-challenge">https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc?tab=readme-ov-file#run...</a><p>The Python version:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc&#x2F;blob&#x2F;main&#x2F;src&#x2F;main&#x2F;python&#x2F;create_measurements.py">https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc&#x2F;blob&#x2F;main&#x2F;src&#x2F;main&#x2F;pyt...</a></div><br/></div></div><div id="39579329" class="c"><input type="checkbox" id="c-39579329" checked=""/><div class="controls bullet"><span class="by">nhinck3</span><span>|</span><a href="#39579060">root</a><span>|</span><a href="#39579212">parent</a><span>|</span><a href="#39579346">prev</a><span>|</span><a href="#39579509">next</a><span>|</span><label class="collapse" for="c-39579329">[-]</label><label class="expand" for="c-39579329">[1 more]</label></div><br/><div class="children"><div class="content">In the original 1BRC, it&#x27;s a python script that generates the data.</div><br/></div></div></div></div></div></div><div id="39579509" class="c"><input type="checkbox" id="c-39579509" checked=""/><div class="controls bullet"><span class="by">sireat</span><span>|</span><a href="#39579060">prev</a><span>|</span><a href="#39579469">next</a><span>|</span><label class="collapse" for="c-39579509">[-]</label><label class="expand" for="c-39579509">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div><div id="39579469" class="c"><input type="checkbox" id="c-39579469" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#39579509">prev</a><span>|</span><a href="#39579168">next</a><span>|</span><label class="collapse" for="c-39579469">[-]</label><label class="expand" for="c-39579469">[1 more]</label></div><br/><div class="children"><div class="content">I love the nerdery around 1BRC. My axe to grind is that unless you do dangerous stuff DBs are just as fast, less complicated, and more resilient to data updates than application code [0]. Do more in the database!<p>0: <a href="https:&#x2F;&#x2F;geraldonit.com&#x2F;2024&#x2F;01&#x2F;31&#x2F;1-billion-row-challenge-in-sql-and-oracle-database&#x2F;" rel="nofollow">https:&#x2F;&#x2F;geraldonit.com&#x2F;2024&#x2F;01&#x2F;31&#x2F;1-billion-row-challenge-in...</a></div><br/></div></div><div id="39579168" class="c"><input type="checkbox" id="c-39579168" checked=""/><div class="controls bullet"><span class="by">michae2</span><span>|</span><a href="#39579469">prev</a><span>|</span><a href="#39579189">next</a><span>|</span><label class="collapse" for="c-39579168">[-]</label><label class="expand" for="c-39579168">[5 more]</label></div><br/><div class="children"><div class="content">For anyone looking for more examples of 1BRC in Go, we had a friendly competition at work and collected the results here: <a href="https:&#x2F;&#x2F;github.com&#x2F;dhartunian&#x2F;1brcgo&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;dhartunian&#x2F;1brcgo&#x2F;</a><p>In addition to the loop-unrolling and bit-twiddling tricks that also show up in the fastest Java and C++ versions, some Go-specific things I learned were:<p>- unsafe.Pointer can be used to read memory without bounds checks<p>- many functions in the bytes and bits packages in the standard library are written in assembly<p>- debug.SetGCPercent and SetMemoryLimit to turn off GC<p>- runtime.LockOSThread to lock a goroutine to a thread<p>- print is slightly faster than fmt.Printf (but writes to stderr)</div><br/><div id="39579265" class="c"><input type="checkbox" id="c-39579265" checked=""/><div class="controls bullet"><span class="by">benhoyt</span><span>|</span><a href="#39579168">parent</a><span>|</span><a href="#39579189">next</a><span>|</span><label class="collapse" for="c-39579265">[-]</label><label class="expand" for="c-39579265">[4 more]</label></div><br/><div class="children"><div class="content">Oh, I&#x27;d missed those solutions, thanks. You guys got way more hard core than I did -- nice work! Looking forward to reading the code for those solutions this week.<p>Update: for reference, Jason Chu&#x27;s solution (<a href="https:&#x2F;&#x2F;github.com&#x2F;dhartunian&#x2F;1brcgo&#x2F;blob&#x2F;494eabd6ea958cc193648fe34859ac53d86c8743&#x2F;jason.go">https:&#x2F;&#x2F;github.com&#x2F;dhartunian&#x2F;1brcgo&#x2F;blob&#x2F;494eabd6ea958cc193...</a>) seems to be the fastest on my machine, and runs in about 1.3s!</div><br/><div id="39579293" class="c"><input type="checkbox" id="c-39579293" checked=""/><div class="controls bullet"><span class="by">michae2</span><span>|</span><a href="#39579168">root</a><span>|</span><a href="#39579265">parent</a><span>|</span><a href="#39579304">next</a><span>|</span><label class="collapse" for="c-39579293">[-]</label><label class="expand" for="c-39579293">[1 more]</label></div><br/><div class="children"><div class="content">I think we all ended up using unsafe, though there were some solutions without mmap. It would have been interesting if we had adhered to the same constraints you did!</div><br/></div></div><div id="39579304" class="c"><input type="checkbox" id="c-39579304" checked=""/><div class="controls bullet"><span class="by">markoman</span><span>|</span><a href="#39579168">root</a><span>|</span><a href="#39579265">parent</a><span>|</span><a href="#39579293">prev</a><span>|</span><a href="#39579189">next</a><span>|</span><label class="collapse" for="c-39579304">[-]</label><label class="expand" for="c-39579304">[2 more]</label></div><br/><div class="children"><div class="content">Could you say why you find using memory-mapped files to be a portability issue? Thanks.</div><br/><div id="39579326" class="c"><input type="checkbox" id="c-39579326" checked=""/><div class="controls bullet"><span class="by">benhoyt</span><span>|</span><a href="#39579168">root</a><span>|</span><a href="#39579304">parent</a><span>|</span><a href="#39579189">next</a><span>|</span><label class="collapse" for="c-39579326">[-]</label><label class="expand" for="c-39579326">[1 more]</label></div><br/><div class="children"><div class="content">Well, I guess it&#x27;s more that the <i>standard library</i> doesn&#x27;t have a cross-platform way to access them, not that memory-mapped files themselves can&#x27;t be done on (say) Windows. It looks like there&#x27;s a fairly popular 3rd party package that supports at least Linux, macOS, and Windows: <a href="https:&#x2F;&#x2F;github.com&#x2F;edsrzf&#x2F;mmap-go">https:&#x2F;&#x2F;github.com&#x2F;edsrzf&#x2F;mmap-go</a></div><br/></div></div></div></div></div></div></div></div><div id="39579189" class="c"><input type="checkbox" id="c-39579189" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#39579168">prev</a><span>|</span><a href="#39579048">next</a><span>|</span><label class="collapse" for="c-39579189">[-]</label><label class="expand" for="c-39579189">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that if you&#x27;re messing around with large text files from the CLI, awk, grep, etc will be an order-of-magnitude faster if you opt out of unicode parsing.<p>I&#x27;m pretty confident adding LC_ALL=C to the awk solution would get it easily under a minute.</div><br/></div></div><div id="39579048" class="c"><input type="checkbox" id="c-39579048" checked=""/><div class="controls bullet"><span class="by">thangalin</span><span>|</span><a href="#39579189">prev</a><span>|</span><a href="#39578701">next</a><span>|</span><label class="collapse" for="c-39579048">[-]</label><label class="expand" for="c-39579048">[1 more]</label></div><br/><div class="children"><div class="content">Back in 2010, I used PostgreSQL for a web app that queried 270 million rows of climate data from Environment Canada:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=10KEr3sEG80" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=10KEr3sEG80</a><p>I wanted to see how the temperature was changing over time for specific regions using a map-based interface. The following chart was particularly eye-opening:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=iEtvf9xzRB4&amp;t=164s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=iEtvf9xzRB4&amp;t=164s</a><p>The software won a couple of awards and was heavily optimized to produce reports in under a minute. Kudos to the author for getting a parse time of a billion records down to mere seconds.</div><br/></div></div><div id="39578701" class="c"><input type="checkbox" id="c-39578701" checked=""/><div class="controls bullet"><span class="by">JensRantil</span><span>|</span><a href="#39579048">prev</a><span>|</span><a href="#39579024">next</a><span>|</span><label class="collapse" for="c-39578701">[-]</label><label class="expand" for="c-39578701">[6 more]</label></div><br/><div class="children"><div class="content">Second article I&#x27;m reading on implementing this in Go. Since the temperatures are in the range [-99.9, 99.9] with a tenth of precision (~2k values), I am surprised why no one has implemented a parsing of the numbers using a prepopulated lookup table. Should probably speed things up.<p>I submitted a github issue on this for the other implementation I looked at here[1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;shraddhaag&#x2F;1brc&#x2F;issues&#x2F;2">https:&#x2F;&#x2F;github.com&#x2F;shraddhaag&#x2F;1brc&#x2F;issues&#x2F;2</a></div><br/><div id="39578754" class="c"><input type="checkbox" id="c-39578754" checked=""/><div class="controls bullet"><span class="by">pillusmany</span><span>|</span><a href="#39578701">parent</a><span>|</span><a href="#39578954">next</a><span>|</span><label class="collapse" for="c-39578754">[-]</label><label class="expand" for="c-39578754">[4 more]</label></div><br/><div class="children"><div class="content">He already uses custom parsing.<p>How do you search in the lookup table? If you are thinking of a hash map it will be slower than the few operations of his custom parser.</div><br/><div id="39578836" class="c"><input type="checkbox" id="c-39578836" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#39578701">root</a><span>|</span><a href="#39578754">parent</a><span>|</span><a href="#39578954">next</a><span>|</span><label class="collapse" for="c-39578836">[-]</label><label class="expand" for="c-39578836">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re clever about how you initially take apart the input you can just do a single memory load at a computed offset.</div><br/><div id="39579017" class="c"><input type="checkbox" id="c-39579017" checked=""/><div class="controls bullet"><span class="by">praptak</span><span>|</span><a href="#39578701">root</a><span>|</span><a href="#39578836">parent</a><span>|</span><a href="#39578954">next</a><span>|</span><label class="collapse" for="c-39579017">[-]</label><label class="expand" for="c-39579017">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how you can make computing the offset faster than just parsing the number.</div><br/><div id="39579479" class="c"><input type="checkbox" id="c-39579479" checked=""/><div class="controls bullet"><span class="by">PeterisP</span><span>|</span><a href="#39578701">root</a><span>|</span><a href="#39579017">parent</a><span>|</span><a href="#39578954">next</a><span>|</span><label class="collapse" for="c-39579479">[-]</label><label class="expand" for="c-39579479">[1 more]</label></div><br/><div class="children"><div class="content">You could have a much simpler parsing than ordinary parsing if you know&#x2F;assume that you <i>definitely</i> have a valid number from -99.99 to 99.99.<p>For example, you could find whether it starts with a &#x27;-&#x27; and where the delimiter is to know the length of the number string representation (that&#x27;s the &quot;simpler parsing&quot; part), and then don&#x27;t do any work at all to decode the number, simply use these 1-5 bytes of that string (without sign and separator) directly as an index into a very large very sparse memory region in which all the valid values are pre-populated with the proper result.<p>You&#x27;d need to allocate 4 or 8 terabytes of virtual memory address space for that lookup table, but you&#x27;ll touch only a tiny fraction of the memory pages, so it doesn&#x27;t require an unacceptable amount of physical memory.</div><br/></div></div></div></div></div></div></div></div><div id="39578954" class="c"><input type="checkbox" id="c-39578954" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#39578701">parent</a><span>|</span><a href="#39578754">prev</a><span>|</span><a href="#39579024">next</a><span>|</span><label class="collapse" for="c-39578954">[-]</label><label class="expand" for="c-39578954">[1 more]</label></div><br/><div class="children"><div class="content">I did it with custom parsing[0] and treated the numbers as 16 bit integers, the representation in the file is not a constant number of bytes which complicates the table approach. If you end up computing a hash I think it might be slower than just doing the equivalent parsing I do and a four byte constant table will be very large and mostly empty. Maybe a a trie would be good.<p>0: <a href="https:&#x2F;&#x2F;github.com&#x2F;k0nserv&#x2F;brc&#x2F;blob&#x2F;main&#x2F;src&#x2F;main.rs#L279">https:&#x2F;&#x2F;github.com&#x2F;k0nserv&#x2F;brc&#x2F;blob&#x2F;main&#x2F;src&#x2F;main.rs#L279</a></div><br/></div></div></div></div><div id="39579024" class="c"><input type="checkbox" id="c-39579024" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#39578701">prev</a><span>|</span><a href="#39579285">next</a><span>|</span><label class="collapse" for="c-39579024">[-]</label><label class="expand" for="c-39579024">[5 more]</label></div><br/><div class="children"><div class="content">I have a feeling that a naive implementation in Java would be a lot worse than a naive implementation in Go so optimizing matters more there.<p>Had to parse csvs in Java on a very memory constrained system once... we ended up cutting out a feature because it wasn&#x27;t worth it.</div><br/><div id="39579406" class="c"><input type="checkbox" id="c-39579406" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39579024">parent</a><span>|</span><a href="#39579155">next</a><span>|</span><label class="collapse" for="c-39579406">[-]</label><label class="expand" for="c-39579406">[1 more]</label></div><br/><div class="children"><div class="content">Depends what you call “naive”, but the “idiomatic Java solution” from last week’s post (<a href="https:&#x2F;&#x2F;questdb.io&#x2F;blog&#x2F;billion-row-challenge-step-by-step&#x2F;">https:&#x2F;&#x2F;questdb.io&#x2F;blog&#x2F;billion-row-challenge-step-by-step&#x2F;</a>) clocked in at 71 seconds, or 1:11. And just running it on graal was down to 66.<p>“Very memory constrained” would be a massive factor here, 1BRC is not <i>really</i> constrained (let alone very much so), it has 1 billion rows on a 32GB machine.</div><br/></div></div><div id="39579155" class="c"><input type="checkbox" id="c-39579155" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39579024">parent</a><span>|</span><a href="#39579406">prev</a><span>|</span><a href="#39579058">next</a><span>|</span><label class="collapse" for="c-39579155">[-]</label><label class="expand" for="c-39579155">[1 more]</label></div><br/><div class="children"><div class="content">Depends on which Java implementation is used.<p>People keep forgetting Java is like C and C++, plenty of implementations to choose from, each with its own approach to JIT, AOT, GC and escape analysis.</div><br/></div></div><div id="39579058" class="c"><input type="checkbox" id="c-39579058" checked=""/><div class="controls bullet"><span class="by">cangeroo</span><span>|</span><a href="#39579024">parent</a><span>|</span><a href="#39579155">prev</a><span>|</span><a href="#39579285">next</a><span>|</span><label class="collapse" for="c-39579058">[-]</label><label class="expand" for="c-39579058">[2 more]</label></div><br/><div class="children"><div class="content">Regarding Java,
It probably could be done with arrays and object reuse (arenas).
But it&#x27;s slightly less ergonomic.
And the ecosystem isn&#x27;t designed for it, so you&#x27;d have to implement your own memory-efficient parser.</div><br/><div id="39579308" class="c"><input type="checkbox" id="c-39579308" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#39579024">root</a><span>|</span><a href="#39579058">parent</a><span>|</span><a href="#39579285">next</a><span>|</span><label class="collapse" for="c-39579308">[-]</label><label class="expand" for="c-39579308">[1 more]</label></div><br/><div class="children"><div class="content">Yep, but it wasn&#x27;t a critical feature and we were in a rush, so the feature was killed instead.<p>&gt; Depends on which Java implementation is used.<p>... if you have a choice. It was a port of AOSP, so we didn&#x27;t. In any case it wasn&#x27;t the jvm&#x27;s fault, the device just had very little ram.</div><br/></div></div></div></div></div></div><div id="39579285" class="c"><input type="checkbox" id="c-39579285" checked=""/><div class="controls bullet"><span class="by">blue_pants</span><span>|</span><a href="#39579024">prev</a><span>|</span><a href="#39579261">next</a><span>|</span><label class="collapse" for="c-39579285">[-]</label><label class="expand" for="c-39579285">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a nodejs version which takes 23s<p><a href="https:&#x2F;&#x2F;github.com&#x2F;1brc&#x2F;nodejs">https:&#x2F;&#x2F;github.com&#x2F;1brc&#x2F;nodejs</a></div><br/></div></div><div id="39579261" class="c"><input type="checkbox" id="c-39579261" checked=""/><div class="controls bullet"><span class="by">afiodorov</span><span>|</span><a href="#39579285">prev</a><span>|</span><a href="#39578661">next</a><span>|</span><label class="collapse" for="c-39579261">[-]</label><label class="expand" for="c-39579261">[2 more]</label></div><br/><div class="children"><div class="content">My first instinct would be to spin up a local Postgres and keep station data there. A lot of the solutions assume we have enough ram to keep the stats per station, however that&#x27;s a bad assumption when dealing with a lot of data.</div><br/><div id="39579436" class="c"><input type="checkbox" id="c-39579436" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39579261">parent</a><span>|</span><a href="#39578661">next</a><span>|</span><label class="collapse" for="c-39579436">[-]</label><label class="expand" for="c-39579436">[1 more]</label></div><br/><div class="children"><div class="content">This is not a general solution, it’s a specific problem with a specific data shape, and processes specifically 1 billion rows on a 32GB machine.</div><br/></div></div></div></div><div id="39578661" class="c"><input type="checkbox" id="c-39578661" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#39579261">prev</a><span>|</span><a href="#39578598">next</a><span>|</span><label class="collapse" for="c-39578661">[-]</label><label class="expand" for="c-39578661">[30 more]</label></div><br/><div class="children"><div class="content">Nice post.  Interesting that the fastest Java beats the fastest Go, though they are close:<p><pre><code>    AY fastest Go version 2.90s 36.2
    TW fastest Java version 0.953s 110
</code></pre>
I would have expected Go to win.  That JVM works pretty good...</div><br/><div id="39579018" class="c"><input type="checkbox" id="c-39579018" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#39578661">parent</a><span>|</span><a href="#39578675">next</a><span>|</span><label class="collapse" for="c-39579018">[-]</label><label class="expand" for="c-39579018">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only a valid comparison if the &quot;fastest Java&quot; and &quot;fastest Go&quot; implementations are either the same or at the limit of what each language allows.<p>The more interesting comparison anyway is performance of the straightforward, idiomatic code, since that&#x27;s what we all write 99% of the time.<p>Here&#x27;s the key insight from the article: &quot;Processing the input file in parallel provides a huge win over r1, taking the time from 1 minute 45 seconds to 24.3 seconds. For comparison, the previous “optimised non-parallel” version, solution 7, took 25.8 seconds. So for this case, parallelisation is a bit faster than optimisation – and quite a bit simpler.&quot;</div><br/></div></div><div id="39578675" class="c"><input type="checkbox" id="c-39578675" checked=""/><div class="controls bullet"><span class="by">dsff3f3f3f</span><span>|</span><a href="#39578661">parent</a><span>|</span><a href="#39579018">prev</a><span>|</span><a href="#39579013">next</a><span>|</span><label class="collapse" for="c-39578675">[-]</label><label class="expand" for="c-39578675">[9 more]</label></div><br/><div class="children"><div class="content">The Java version does additional optimizations that his Go version doesn&#x27;t do and he mentions that at the end of the post. The Java version is really optimized and is an interesting read.</div><br/><div id="39578714" class="c"><input type="checkbox" id="c-39578714" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578675">parent</a><span>|</span><a href="#39579099">next</a><span>|</span><label class="collapse" for="c-39578714">[-]</label><label class="expand" for="c-39578714">[5 more]</label></div><br/><div class="children"><div class="content">&gt;  The Java version is really optimized and is an interesting read.<p>is there any similar blog post on the Java optimisations?</div><br/><div id="39579422" class="c"><input type="checkbox" id="c-39579422" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578714">parent</a><span>|</span><a href="#39578911">next</a><span>|</span><label class="collapse" for="c-39579422">[-]</label><label class="expand" for="c-39579422">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;questdb.io&#x2F;blog&#x2F;billion-row-challenge-step-by-step&#x2F;">https:&#x2F;&#x2F;questdb.io&#x2F;blog&#x2F;billion-row-challenge-step-by-step&#x2F;</a></div><br/></div></div><div id="39578911" class="c"><input type="checkbox" id="c-39578911" checked=""/><div class="controls bullet"><span class="by">cempaka</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578714">parent</a><span>|</span><a href="#39579422">prev</a><span>|</span><a href="#39578758">next</a><span>|</span><label class="collapse" for="c-39578911">[-]</label><label class="expand" for="c-39578911">[1 more]</label></div><br/><div class="children"><div class="content">Cliff Click did a walkthrough of his solution on YouTube: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;NJNIbgV6j-Y?si=Wj97f-Imw5nfIzF7" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;NJNIbgV6j-Y?si=Wj97f-Imw5nfIzF7</a></div><br/></div></div><div id="39578758" class="c"><input type="checkbox" id="c-39578758" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578714">parent</a><span>|</span><a href="#39578911">prev</a><span>|</span><a href="#39578728">next</a><span>|</span><label class="collapse" for="c-39578758">[-]</label><label class="expand" for="c-39578758">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39467885">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39467885</a> but it looks like there have been improvements since.</div><br/></div></div><div id="39578728" class="c"><input type="checkbox" id="c-39578728" checked=""/><div class="controls bullet"><span class="by">dsff3f3f3f</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578714">parent</a><span>|</span><a href="#39578758">prev</a><span>|</span><a href="#39579099">next</a><span>|</span><label class="collapse" for="c-39578728">[-]</label><label class="expand" for="c-39578728">[1 more]</label></div><br/><div class="children"><div class="content">Not that I know of. I just looked at the code and the commit history but a more in depth article would certainly be interesting.</div><br/></div></div></div></div><div id="39579099" class="c"><input type="checkbox" id="c-39579099" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578675">parent</a><span>|</span><a href="#39578714">prev</a><span>|</span><a href="#39579398">next</a><span>|</span><label class="collapse" for="c-39579099">[-]</label><label class="expand" for="c-39579099">[2 more]</label></div><br/><div class="children"><div class="content">The more accurate statement would be is Go implementatation is incapable of accessing optimizations that exist in Java and then Java is incapable of optimizations performed by C# and C++ implementations.<p>See <a href="https:&#x2F;&#x2F;hotforknowledge.com&#x2F;2024&#x2F;01&#x2F;13&#x2F;1brc-in-dotnet-among-fastest-on-linux-my-optimization-journey&#x2F;#results" rel="nofollow">https:&#x2F;&#x2F;hotforknowledge.com&#x2F;2024&#x2F;01&#x2F;13&#x2F;1brc-in-dotnet-among-...</a></div><br/><div id="39579213" class="c"><input type="checkbox" id="c-39579213" checked=""/><div class="controls bullet"><span class="by">dsff3f3f3f</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579099">parent</a><span>|</span><a href="#39579398">next</a><span>|</span><label class="collapse" for="c-39579213">[-]</label><label class="expand" for="c-39579213">[1 more]</label></div><br/><div class="children"><div class="content">Go is perfectly capable of all of the additional optimizations that are in the fastest Java implementation that is linked in the article.</div><br/></div></div></div></div><div id="39579398" class="c"><input type="checkbox" id="c-39579398" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578675">parent</a><span>|</span><a href="#39579099">prev</a><span>|</span><a href="#39579013">next</a><span>|</span><label class="collapse" for="c-39579398">[-]</label><label class="expand" for="c-39579398">[1 more]</label></div><br/><div class="children"><div class="content">Well the Go guy probably didn&#x27;t read it because &quot;java doesn&#x27;t interest him&quot;</div><br/></div></div></div></div><div id="39579013" class="c"><input type="checkbox" id="c-39579013" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#39578661">parent</a><span>|</span><a href="#39578675">prev</a><span>|</span><a href="#39578716">next</a><span>|</span><label class="collapse" for="c-39579013">[-]</label><label class="expand" for="c-39579013">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Go has ever demonstrated that it deserved to be thought of as casually faster than Java.</div><br/><div id="39579435" class="c"><input type="checkbox" id="c-39579435" checked=""/><div class="controls bullet"><span class="by">Comma2976</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579013">parent</a><span>|</span><a href="#39578716">next</a><span>|</span><label class="collapse" for="c-39579435">[-]</label><label class="expand" for="c-39579435">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;attractivechaos&#x2F;plb2&#x2F;blob&#x2F;master&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;attractivechaos&#x2F;plb2&#x2F;blob&#x2F;master&#x2F;README.m...</a><p>Synthetic benchmarks aside, I think as far as average (spring boots of the world) code goes, Go beats Java almost every time, often in less lines than the usual pom.xml</div><br/><div id="39579493" class="c"><input type="checkbox" id="c-39579493" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579435">parent</a><span>|</span><a href="#39578716">next</a><span>|</span><label class="collapse" for="c-39579493">[-]</label><label class="expand" for="c-39579493">[1 more]</label></div><br/><div class="children"><div class="content">Anyone judging Java performance based on starting up a JVM, running for 30 seconds, and shutting down is brain damaged. I&#x27;m 99 percent certain this benchmark doesn&#x27;t use Epsilon GC either lol<p>&gt;not using GraalVM for Java<p>LOL k<p>&gt;no implementations use multithreading<p>ah, the cherry on top. this benchmark is literally perfectly useless</div><br/></div></div></div></div></div></div><div id="39578716" class="c"><input type="checkbox" id="c-39578716" checked=""/><div class="controls bullet"><span class="by">parkcedar</span><span>|</span><a href="#39578661">parent</a><span>|</span><a href="#39579013">prev</a><span>|</span><a href="#39578689">next</a><span>|</span><label class="collapse" for="c-39578716">[-]</label><label class="expand" for="c-39578716">[3 more]</label></div><br/><div class="children"><div class="content">The fastest Java version is even beating his baseline of `cat` to `&#x2F;dev&#x2F;null`</div><br/><div id="39579068" class="c"><input type="checkbox" id="c-39579068" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578716">parent</a><span>|</span><a href="#39578967">next</a><span>|</span><label class="collapse" for="c-39579068">[-]</label><label class="expand" for="c-39579068">[1 more]</label></div><br/><div class="children"><div class="content">Yes, though it&#x27;s also worth noting that the fastest solutions are all doing their work in parallel which is not a thing for `cat`.</div><br/></div></div><div id="39578967" class="c"><input type="checkbox" id="c-39578967" checked=""/><div class="controls bullet"><span class="by">timeagain</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578716">parent</a><span>|</span><a href="#39579068">prev</a><span>|</span><a href="#39578689">next</a><span>|</span><label class="collapse" for="c-39578967">[-]</label><label class="expand" for="c-39578967">[1 more]</label></div><br/><div class="children"><div class="content">More proof that the JVM is space-age future technology.</div><br/></div></div></div></div><div id="39578827" class="c"><input type="checkbox" id="c-39578827" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39578661">parent</a><span>|</span><a href="#39578689">prev</a><span>|</span><a href="#39578839">next</a><span>|</span><label class="collapse" for="c-39578827">[-]</label><label class="expand" for="c-39578827">[2 more]</label></div><br/><div class="children"><div class="content">Still loses to .NET. On reference host Java still closer to 1.7-2s ballpark (and has to use awkward SWAR to get there) while the fastest solution in C# is 1.2s, beating C++ (code can be ported however).<p>But yes, &quot;I expected Go to win...&quot; is exactly the core of the problem here. Same as with e.g. Swift, which people expect to perform on the level of Rust, when it is even slower than Go. The intuition caused by common misconceptions just does not correspond to reality sadly.</div><br/><div id="39579433" class="c"><input type="checkbox" id="c-39579433" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578827">parent</a><span>|</span><a href="#39578839">next</a><span>|</span><label class="collapse" for="c-39579433">[-]</label><label class="expand" for="c-39579433">[1 more]</label></div><br/><div class="children"><div class="content">It only goes to show how much cargo cult is there in adopting these languages in hipster circles.</div><br/></div></div></div></div><div id="39578839" class="c"><input type="checkbox" id="c-39578839" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#39578661">parent</a><span>|</span><a href="#39578827">prev</a><span>|</span><a href="#39578598">next</a><span>|</span><label class="collapse" for="c-39578839">[-]</label><label class="expand" for="c-39578839">[10 more]</label></div><br/><div class="children"><div class="content">JVM has always been on par if not often faster than hand-written C code.<p>Go&#x27;s advantage has always been that it is good enough at a lot of things.</div><br/><div id="39579443" class="c"><input type="checkbox" id="c-39579443" checked=""/><div class="controls bullet"><span class="by">_ph_</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578839">parent</a><span>|</span><a href="#39579047">next</a><span>|</span><label class="collapse" for="c-39579443">[-]</label><label class="expand" for="c-39579443">[1 more]</label></div><br/><div class="children"><div class="content">One has to differentiate here a bit. Java JIT technology has become really great. Highly optimized native code generation which hugely benefits from the ability to use live profiling data to optimize the code. This is why it often beats static compilers at generating faster code. The static compilers can only optimized on the range of possible data, the JIT can optimize based on the data presented to the program.<p>On the down side, there are quite a few features of the Java language and the JVM, which often make programs slow. Like a lot of details of the object model, lack of value classes, JIT compiling which takes time on startup etc. Also, a lot of Java libraries are pretty heavy weight.<p>Go is quite different here. It is statically compiled, which allows for fast program startup and the language model makes it quite easy to rather naively write programs which perform reasonally fast. The down side is, that the compiler is static and not so heavily optimizing as other static compilers for fast compilation speed. However recently the ability was added to use profiling data for optimizing the compilation.</div><br/></div></div><div id="39579047" class="c"><input type="checkbox" id="c-39579047" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578839">parent</a><span>|</span><a href="#39579443">prev</a><span>|</span><a href="#39579029">next</a><span>|</span><label class="collapse" for="c-39579047">[-]</label><label class="expand" for="c-39579047">[2 more]</label></div><br/><div class="children"><div class="content">I think the reason why this misconception is so widespread is because there is a grain of truth in it, because almost everyone sees Java synonymous with gigantic framework like spring, quarkus etc.<p>In go you&#x27;ve got your standard libraries, these are generally quicker than the Java equivalent simply because they do less in the lifecycle of the operation.<p>This lets Java do funky stuff like enabling full jvm&#x2F;code tracing just by adding a jar file at runtime. But it does come with a performance penalty.</div><br/><div id="39579448" class="c"><input type="checkbox" id="c-39579448" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579047">parent</a><span>|</span><a href="#39579029">next</a><span>|</span><label class="collapse" for="c-39579448">[-]</label><label class="expand" for="c-39579448">[1 more]</label></div><br/><div class="children"><div class="content">Which is a reason why dynamic loading of agents now requires being enabled explicitly.</div><br/></div></div></div></div><div id="39579029" class="c"><input type="checkbox" id="c-39579029" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39578839">parent</a><span>|</span><a href="#39579047">prev</a><span>|</span><a href="#39578598">next</a><span>|</span><label class="collapse" for="c-39579029">[-]</label><label class="expand" for="c-39579029">[6 more]</label></div><br/><div class="children"><div class="content">Please, you&#x27;ve been reading too much PR from the Java side and not looking at benchmarks and real-world performance enough. What you&#x27;re claiming is inherently not possible, cherry-picked benchmarks notwithstanding.</div><br/><div id="39579134" class="c"><input type="checkbox" id="c-39579134" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579029">parent</a><span>|</span><a href="#39579070">next</a><span>|</span><label class="collapse" for="c-39579134">[-]</label><label class="expand" for="c-39579134">[3 more]</label></div><br/><div class="children"><div class="content">Can you explain why it&#x27;s not technically possible.<p>JVM has had decades of experience at optimally translating bytecode to machine code and can take advantage of SIMD, AVX etc when needed. Most hand-written C code is far from optimal.</div><br/><div id="39579281" class="c"><input type="checkbox" id="c-39579281" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579134">parent</a><span>|</span><a href="#39579070">next</a><span>|</span><label class="collapse" for="c-39579281">[-]</label><label class="expand" for="c-39579281">[2 more]</label></div><br/><div class="children"><div class="content">C compilers also have decades of experience optimally translating C code into machine code, and they are arguably more capable of emitting SIMD (good luck trying to use cutting edge AVX-512 intrinsics like vpopcntdq with the JVM). The fact is that there is nothing a JIT compiler can do that an AOT compiler can&#x27;t do, but in the case of AOT, the resources spent compiling the code are amortized to effectively 0, whereas that resource cost is borne upon every program startup for a JIT engine.</div><br/><div id="39579459" class="c"><input type="checkbox" id="c-39579459" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579281">parent</a><span>|</span><a href="#39579070">next</a><span>|</span><label class="collapse" for="c-39579459">[-]</label><label class="expand" for="c-39579459">[1 more]</label></div><br/><div class="children"><div class="content">C compilers only have one opportunity to do that once, at compile time, if the developer was lucky with their data set used to train the PGO output, maybe the outcome is greatly improved.<p>Modern JVMs, not only have the JIT being able to use actual production data, they are able to cache PGO data between execution runs, and reach an optimimal set of heuristics throughout execution time.<p>And on Android, those PGO files are even shared between devices via Play Store.</div><br/></div></div></div></div></div></div><div id="39579070" class="c"><input type="checkbox" id="c-39579070" checked=""/><div class="controls bullet"><span class="by">vanviegen</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579029">parent</a><span>|</span><a href="#39579134">prev</a><span>|</span><a href="#39578598">next</a><span>|</span><label class="collapse" for="c-39579070">[-]</label><label class="expand" for="c-39579070">[2 more]</label></div><br/><div class="children"><div class="content">Sure it&#x27;s possible. The JVM can do guided optimizations at run time. There is no such thing for native executables.</div><br/><div id="39579462" class="c"><input type="checkbox" id="c-39579462" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39578661">root</a><span>|</span><a href="#39579070">parent</a><span>|</span><a href="#39578598">next</a><span>|</span><label class="collapse" for="c-39579462">[-]</label><label class="expand" for="c-39579462">[1 more]</label></div><br/><div class="children"><div class="content">And as I mentioned in another comment, you can even cache PGO data between executions, not needed to start always from zero.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39578598" class="c"><input type="checkbox" id="c-39578598" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#39578661">prev</a><span>|</span><a href="#39579223">next</a><span>|</span><label class="collapse" for="c-39578598">[-]</label><label class="expand" for="c-39578598">[8 more]</label></div><br/><div class="children"><div class="content">&gt; I’m in the same ballpark as Alexander Yastrebov’s Go version. His solution looks similar to mine: break the file into chunks, use a custom hash table (he even uses FNV hashing), and parse temperatures as integers. However, he uses memory-mapped files, which I’d ruled out for portability reasons – I’m guessing that’s why his is a bit faster.<p>I am curious, can it be made even faster than this?</div><br/><div id="39578649" class="c"><input type="checkbox" id="c-39578649" checked=""/><div class="controls bullet"><span class="by">makotech221</span><span>|</span><a href="#39578598">parent</a><span>|</span><a href="#39578678">next</a><span>|</span><label class="collapse" for="c-39578649">[-]</label><label class="expand" for="c-39578649">[5 more]</label></div><br/><div class="children"><div class="content">Dunno about Go, but most c# solutions are around 2s and under <a href="https:&#x2F;&#x2F;hotforknowledge.com&#x2F;2024&#x2F;01&#x2F;13&#x2F;1brc-in-dotnet-among-fastest-on-linux-my-optimization-journey&#x2F;#results" rel="nofollow">https:&#x2F;&#x2F;hotforknowledge.com&#x2F;2024&#x2F;01&#x2F;13&#x2F;1brc-in-dotnet-among-...</a></div><br/><div id="39579087" class="c"><input type="checkbox" id="c-39579087" checked=""/><div class="controls bullet"><span class="by">junto</span><span>|</span><a href="#39578598">root</a><span>|</span><a href="#39578649">parent</a><span>|</span><a href="#39578678">next</a><span>|</span><label class="collapse" for="c-39579087">[-]</label><label class="expand" for="c-39579087">[4 more]</label></div><br/><div class="children"><div class="content">Wow that’s pretty damn fast. C# has made some improvements in the past years or they have some other advantages?</div><br/><div id="39579166" class="c"><input type="checkbox" id="c-39579166" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39578598">root</a><span>|</span><a href="#39579087">parent</a><span>|</span><a href="#39579233">next</a><span>|</span><label class="collapse" for="c-39579166">[-]</label><label class="expand" for="c-39579166">[1 more]</label></div><br/><div class="children"><div class="content">Yes to both.<p>.NET team has been doubling down on performance improvements, people forget CLR also has features to support C like languages (hence Managed  C++ and C++&#x2F;CLI), and many of those capabilities are now surfaced into C# as well.</div><br/></div></div><div id="39579233" class="c"><input type="checkbox" id="c-39579233" checked=""/><div class="controls bullet"><span class="by">Anon4Now</span><span>|</span><a href="#39578598">root</a><span>|</span><a href="#39579087">parent</a><span>|</span><a href="#39579166">prev</a><span>|</span><a href="#39578678">next</a><span>|</span><label class="collapse" for="c-39579233">[-]</label><label class="expand" for="c-39579233">[2 more]</label></div><br/><div class="children"><div class="content">Stephen Toub wrote a book-length blog post about all the performance improvements made in .NET 8 [1]. Add the option to compile to native.<p>[1] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;performance-improvements-in-net-8&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;performance-improvemen...</a></div><br/><div id="39579471" class="c"><input type="checkbox" id="c-39579471" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39578598">root</a><span>|</span><a href="#39579233">parent</a><span>|</span><a href="#39578678">next</a><span>|</span><label class="collapse" for="c-39579471">[-]</label><label class="expand" for="c-39579471">[1 more]</label></div><br/><div class="children"><div class="content">His blogs posts go back all the way to .NET 5, for those curious to some deep dive on performance improvements done on each release.</div><br/></div></div></div></div></div></div></div></div><div id="39578678" class="c"><input type="checkbox" id="c-39578678" checked=""/><div class="controls bullet"><span class="by">krallja</span><span>|</span><a href="#39578598">parent</a><span>|</span><a href="#39578649">prev</a><span>|</span><a href="#39578732">next</a><span>|</span><label class="collapse" for="c-39578678">[-]</label><label class="expand" for="c-39578678">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a layer of pointer indirection when using slices in Go, you may be able to eke out some time by moving to arrays on the stack.</div><br/></div></div><div id="39578732" class="c"><input type="checkbox" id="c-39578732" checked=""/><div class="controls bullet"><span class="by">pram</span><span>|</span><a href="#39578598">parent</a><span>|</span><a href="#39578678">prev</a><span>|</span><a href="#39579223">next</a><span>|</span><label class="collapse" for="c-39578732">[-]</label><label class="expand" for="c-39578732">[1 more]</label></div><br/><div class="children"><div class="content">From looking at the final code it’s probably the performance of copy() as the biggest hurdle.</div><br/></div></div></div></div><div id="39579438" class="c"><input type="checkbox" id="c-39579438" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#39579223">prev</a><span>|</span><a href="#39578766">next</a><span>|</span><label class="collapse" for="c-39579438">[-]</label><label class="expand" for="c-39579438">[1 more]</label></div><br/><div class="children"><div class="content">Nice. I wonder how Rust would fare, given that it has no garbage collector.</div><br/></div></div><div id="39578766" class="c"><input type="checkbox" id="c-39578766" checked=""/><div class="controls bullet"><span class="by">nicois</span><span>|</span><a href="#39579438">prev</a><span>|</span><a href="#39579193">next</a><span>|</span><label class="collapse" for="c-39578766">[-]</label><label class="expand" for="c-39578766">[3 more]</label></div><br/><div class="children"><div class="content">It would be interesting to know how effective Profile Guided Optimisation is here.</div><br/><div id="39579121" class="c"><input type="checkbox" id="c-39579121" checked=""/><div class="controls bullet"><span class="by">benhoyt</span><span>|</span><a href="#39578766">parent</a><span>|</span><a href="#39579096">next</a><span>|</span><label class="collapse" for="c-39579121">[-]</label><label class="expand" for="c-39579121">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately it doesn&#x27;t seem to help at all, I think mainly because (at present) Go&#x27;s PGO basically inlines hot functions, and the important code here is all in one big function.</div><br/></div></div><div id="39579096" class="c"><input type="checkbox" id="c-39579096" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39578766">parent</a><span>|</span><a href="#39579121">prev</a><span>|</span><a href="#39579193">next</a><span>|</span><label class="collapse" for="c-39579096">[-]</label><label class="expand" for="c-39579096">[1 more]</label></div><br/><div class="children"><div class="content">It is only mildly effective because how anemic Go compiler is. And even then it&#x27;s extremely limited. If you want to see actual good implementations - look into what OpenJDK HotSpot and .NET JIT compilers do with runtime profiling and recompilation (.NET calls it Dynamic PGO).</div><br/></div></div></div></div><div id="39579193" class="c"><input type="checkbox" id="c-39579193" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#39578766">prev</a><span>|</span><a href="#39578707">next</a><span>|</span><label class="collapse" for="c-39579193">[-]</label><label class="expand" for="c-39579193">[1 more]</label></div><br/><div class="children"><div class="content">How about kdb+ or shakti</div><br/></div></div><div id="39578707" class="c"><input type="checkbox" id="c-39578707" checked=""/><div class="controls bullet"><span class="by">tonymet</span><span>|</span><a href="#39579193">prev</a><span>|</span><a href="#39578763">next</a><span>|</span><label class="collapse" for="c-39578707">[-]</label><label class="expand" for="c-39578707">[1 more]</label></div><br/><div class="children"><div class="content">i saw the custom hashtable, but why was Map slow?</div><br/></div></div><div id="39578763" class="c"><input type="checkbox" id="c-39578763" checked=""/><div class="controls bullet"><span class="by">m3kw9</span><span>|</span><a href="#39578707">prev</a><span>|</span><a href="#39578837">next</a><span>|</span><label class="collapse" for="c-39578763">[-]</label><label class="expand" for="c-39578763">[4 more]</label></div><br/><div class="children"><div class="content">I’d just pay my way to 4s by upgrading hw</div><br/><div id="39579144" class="c"><input type="checkbox" id="c-39579144" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#39578763">parent</a><span>|</span><a href="#39579146">next</a><span>|</span><label class="collapse" for="c-39579144">[-]</label><label class="expand" for="c-39579144">[2 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t just throw hardware at this one to get to 4s. At least not in 2024.<p>The author&#x27;s naive single-threaded Go solution took 1m45s on an &quot;amd64 laptop with fast SSD drive and 32GB of RAM.&quot;<p>So, you&#x27;d need something 25x faster than his setup in terms of single-threaded performance. Let us know when you&#x27;ve upgraded your hardware to the equivalent of a 75ghz AMD processor with memory and SSD bandwidth to match!</div><br/><div id="39579257" class="c"><input type="checkbox" id="c-39579257" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#39578763">root</a><span>|</span><a href="#39579144">parent</a><span>|</span><a href="#39579146">next</a><span>|</span><label class="collapse" for="c-39579257">[-]</label><label class="expand" for="c-39579257">[1 more]</label></div><br/><div class="children"><div class="content">The nice thing about a GPU soln (ex: python dataframes in cudf, just a few loc) is these generally come down to your IO bandwidth, like a single 2GB&#x2F;s SSD to a 16-32 GB&#x2F;s PCIe to 1-2 GPUs running crazy fast. And then buy more cheap SSDs to chain together before buying more&#x2F;better GPUs :)</div><br/></div></div></div></div><div id="39579146" class="c"><input type="checkbox" id="c-39579146" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#39578763">parent</a><span>|</span><a href="#39579144">prev</a><span>|</span><a href="#39578837">next</a><span>|</span><label class="collapse" for="c-39579146">[-]</label><label class="expand" for="c-39579146">[1 more]</label></div><br/><div class="children"><div class="content">... how?<p>There aren&#x27;t any generally-available CPUs that are substantially faster today than were available ten years ago. Maybe double the speed per core, triple at best.<p>After that, throwing more cores at it also rapidly runs out of steam because parallel code has its own overheads. Any shared state instantly kills performance, no matter the language. Very clever tricks have to be used to get decent scaling past 64 hardware threads (32 cores), and going past 256 is surprisingly difficult. You start having to worry about NUMA, IRQ steering, and core pinning. Bandwidth gets to be an issue, even to L3 and L4 cache, let alone out to main memory.<p>This notion that you can just &quot;dial up&quot; hardware performance to infinity as a fix for any amount of developer laziness needs to die.</div><br/></div></div></div></div><div id="39578837" class="c"><input type="checkbox" id="c-39578837" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39578763">prev</a><span>|</span><a href="#39579393">next</a><span>|</span><label class="collapse" for="c-39578837">[-]</label><label class="expand" for="c-39578837">[6 more]</label></div><br/><div class="children"><div class="content">The effort and long time it took Go to get to something that 3-6x times slower than other, better languages should be an important reminder to everyone assuming it belongs to the same weight class as Rust, C# or Java.</div><br/><div id="39579411" class="c"><input type="checkbox" id="c-39579411" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#39578837">parent</a><span>|</span><a href="#39578987">next</a><span>|</span><label class="collapse" for="c-39579411">[-]</label><label class="expand" for="c-39579411">[1 more]</label></div><br/><div class="children"><div class="content">If you read the article,  you&#x27;ll see he doesn&#x27;t attempt the optimizations that helped those other languages get to 3-6x faster. Your snark is wasted.</div><br/></div></div><div id="39578987" class="c"><input type="checkbox" id="c-39578987" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#39578837">parent</a><span>|</span><a href="#39579411">prev</a><span>|</span><a href="#39578959">next</a><span>|</span><label class="collapse" for="c-39578987">[-]</label><label class="expand" for="c-39578987">[2 more]</label></div><br/><div class="children"><div class="content">That you put Rust among those languages says it all. Do some basic research.</div><br/><div id="39579126" class="c"><input type="checkbox" id="c-39579126" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39578837">root</a><span>|</span><a href="#39578987">parent</a><span>|</span><a href="#39578959">next</a><span>|</span><label class="collapse" for="c-39579126">[-]</label><label class="expand" for="c-39579126">[1 more]</label></div><br/><div class="children"><div class="content">Oh, and what the basic research you speak of constitutes? Surely you looked at ASM emitted by compilers for these languages and HPC-adjacent APIs each of them offers? No? Then let me tell you - Go is pretty much consigned to having to use its special flavour of non-portable bespoke hand-written ASM which is the only way to access SIMD instructions necessary to achieve optimal hardware utilization in the benchmark. This takes a lot of effort and skill, so, as you may have noticed, if you can&#x27;t do it, Go simply cannot come close to better options you can see on the benchmark chart.<p>And yet, this is something that can be trivially done in C#, C++ and Rust (albeit C# has the best UX with crossplat SIMD API introduced in .NET 7, with C++ close second with its own take on this being in preview). Java OTOH manages to be in the same category by having extremely advanced JIT that allows it to have comparable codegen quality even though it lacks comparable SIMD API for now (Panama vectors are problematic currently), so benchmarks implementations using it are forced to do SWAR.<p>My main gripe is of course an extremely common misconception about Go&#x27;s speed which it just does not have the moment you write anything sufficiently advanced or want to express a particular problem in a terser way than writing thousands of open coded loops.</div><br/></div></div></div></div><div id="39578959" class="c"><input type="checkbox" id="c-39578959" checked=""/><div class="controls bullet"><span class="by">donor20</span><span>|</span><a href="#39578837">parent</a><span>|</span><a href="#39578987">prev</a><span>|</span><a href="#39579393">next</a><span>|</span><label class="collapse" for="c-39578959">[-]</label><label class="expand" for="c-39578959">[2 more]</label></div><br/><div class="children"><div class="content">But isn’t the Java version unrolling loops? This seems like some effort on the Java side.</div><br/><div id="39578983" class="c"><input type="checkbox" id="c-39578983" checked=""/><div class="controls bullet"><span class="by">dsff3f3f3f</span><span>|</span><a href="#39578837">root</a><span>|</span><a href="#39578959">parent</a><span>|</span><a href="#39579393">next</a><span>|</span><label class="collapse" for="c-39578983">[-]</label><label class="expand" for="c-39578983">[1 more]</label></div><br/><div class="children"><div class="content">The fast Java version is using all the same optimizations as this Go version and then some. It&#x27;s significantly more complicated.</div><br/></div></div></div></div></div></div><div id="39579393" class="c"><input type="checkbox" id="c-39579393" checked=""/><div class="controls bullet"><span class="by">twophotocollage</span><span>|</span><a href="#39578837">prev</a><span>|</span><label class="collapse" for="c-39579393">[-]</label><label class="expand" for="c-39579393">[1 more]</label></div><br/><div class="children"><div class="content">Impressive! The One Billion Row Challenge in Go showcases the power of optimization. From 1m45s to 4s in nine solutions is a remarkable feat, highlighting the efficiency and innovation within the Go programming community. It&#x27;s inspiring to see such drastic improvements in performance. Great job to all involved!
website: <a href="https:&#x2F;&#x2F;simplified.com&#x2F;ai-collage-maker&#x2F;two-photo-collage" rel="nofollow">https:&#x2F;&#x2F;simplified.com&#x2F;ai-collage-maker&#x2F;two-photo-collage</a></div><br/></div></div></div></div></div></div></div></body></html>