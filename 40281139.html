<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715072455713" as="style"/><link rel="stylesheet" href="styles.css?v=1715072455713"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jacobpadilla.com/articles/recreating-asyncio">How Python asyncio works: recreating it from scratch</a> <span class="domain">(<a href="https://jacobpadilla.com">jacobpadilla.com</a>)</span></div><div class="subtext"><span>jpjacobpadilla</span> | <span>10 comments</span></div><br/><div><div id="40282472" class="c"><input type="checkbox" id="c-40282472" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#40282650">next</a><span>|</span><label class="collapse" for="c-40282472">[-]</label><label class="expand" for="c-40282472">[1 more]</label></div><br/><div class="children"><div class="content">This seems to &quot;busy wait&quot; when sleeping, i.e. the event loop keeps running even if nothing is currently runnable. I remember reading about another toy implementation which handled it correctly (the way I believe it&#x27;s actually done in asyncio) by tracking the next-runnable times of a task in sorted order, and if nothing is currently runnable you can sleep the event loop. And then this was extended so that instead of just next-runnable depending on wall-clock time, the task could have a dependency on a socket or something, so that you can use select w&#x2F;timeout.</div><br/></div></div><div id="40282650" class="c"><input type="checkbox" id="c-40282650" checked=""/><div class="controls bullet"><span class="by">kodablah</span><span>|</span><a href="#40282472">prev</a><span>|</span><a href="#40282739">next</a><span>|</span><label class="collapse" for="c-40282650">[-]</label><label class="expand" for="c-40282650">[1 more]</label></div><br/><div class="children"><div class="content">Asyncio allows you to replace the event loop with an implementation of your own. For Temporal Python we represent workflows as a custom, durable asyncio event loops so things like asyncio.sleep are durable timers (i.e. code can resume on another machine, so you can sleep for weeks). Here is a post explaining how it&#x27;s done: <a href="https:&#x2F;&#x2F;temporal.io&#x2F;blog&#x2F;durable-distributed-asyncio-event-loop" rel="nofollow">https:&#x2F;&#x2F;temporal.io&#x2F;blog&#x2F;durable-distributed-asyncio-event-l...</a>.<p>The biggest problem with asyncio is how easy&#x2F;common it is in Python to be able to block the asyncio thread with synchronous calls, gumming up the whole system. Python sorely needs a static analysis tool that can build a call graph to help detect if a known thread-blocking call is called directly or directly from an async def.</div><br/></div></div><div id="40282739" class="c"><input type="checkbox" id="c-40282739" checked=""/><div class="controls bullet"><span class="by">tda</span><span>|</span><a href="#40282650">prev</a><span>|</span><a href="#40282453">next</a><span>|</span><label class="collapse" for="c-40282739">[-]</label><label class="expand" for="c-40282739">[2 more]</label></div><br/><div class="children"><div class="content">There is a brilliant talk by David Beazley on asyncio. I used it to write a Discrete Even Simulation tool. Pretty cool to be able to make your own implementation of asyncio and replace the system clock with a simulated time</div><br/><div id="40283020" class="c"><input type="checkbox" id="c-40283020" checked=""/><div class="controls bullet"><span class="by">JosephRedfern</span><span>|</span><a href="#40282739">parent</a><span>|</span><a href="#40282453">next</a><span>|</span><label class="collapse" for="c-40283020">[-]</label><label class="expand" for="c-40283020">[1 more]</label></div><br/><div class="children"><div class="content">Link to David Beazley’s asyncio talk:  <a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=Y4Gt3Xjd7G8" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=Y4Gt3Xjd7G8</a></div><br/></div></div></div></div><div id="40282453" class="c"><input type="checkbox" id="c-40282453" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#40282739">prev</a><span>|</span><label class="collapse" for="c-40282453">[-]</label><label class="expand" for="c-40282453">[5 more]</label></div><br/><div class="children"><div class="content">Completely insane that python decided to hijack &quot;def&quot; to be used to create an object that very much is not a function.  At the least they could have gone was create a different keyword</div><br/><div id="40282550" class="c"><input type="checkbox" id="c-40282550" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#40282453">parent</a><span>|</span><a href="#40282995">next</a><span>|</span><label class="collapse" for="c-40282550">[-]</label><label class="expand" for="c-40282550">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a function, it&#x27;s just been transformed into a function with a different return type (that of a generator or coroutine, you can see the type signatures here [1]). You could do something similar in vanilla Python rather than language-level sugar, eg using decorators.<p>[1] <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;typing.html#typing.Generator" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;typing.html#typing.Generat...</a><p>As a caveat, I point out the type signature for academic interest, I prefer to use the simpler Iterable and Awaitable types in type signatures.</div><br/></div></div><div id="40282995" class="c"><input type="checkbox" id="c-40282995" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#40282453">parent</a><span>|</span><a href="#40282550">prev</a><span>|</span><label class="collapse" for="c-40282995">[-]</label><label class="expand" for="c-40282995">[3 more]</label></div><br/><div class="children"><div class="content">They somewhat fixed that with &quot;async def&quot; but the whole thing is a huge tragedy anyway.</div><br/><div id="40283120" class="c"><input type="checkbox" id="c-40283120" checked=""/><div class="controls bullet"><span class="by">cuu508</span><span>|</span><a href="#40282453">root</a><span>|</span><a href="#40282995">parent</a><span>|</span><label class="collapse" for="c-40283120">[-]</label><label class="expand" for="c-40283120">[2 more]</label></div><br/><div class="children"><div class="content">Do you mean they fixed the hijacking by adding  the &quot;async&quot; keyword?<p>By the whole thing do you mean the async functionality in Python in general? What is the tragedy?</div><br/><div id="40283203" class="c"><input type="checkbox" id="c-40283203" checked=""/><div class="controls bullet"><span class="by">jononomo</span><span>|</span><a href="#40282453">root</a><span>|</span><a href="#40283120">parent</a><span>|</span><label class="collapse" for="c-40283203">[-]</label><label class="expand" for="c-40283203">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also curious to know what the tragedy is.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>