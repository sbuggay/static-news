<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714035655433" as="style"/><link rel="stylesheet" href="styles.css?v=1714035655433"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://geeklaunch.io/blog/make-invalid-states-unrepresentable/">Make Invalid States Unrepresentable</a> <span class="domain">(<a href="https://geeklaunch.io">geeklaunch.io</a>)</span></div><div class="subtext"><span>satvikpendem</span> | <span>19 comments</span></div><br/><div><div id="40154659" class="c"><input type="checkbox" id="c-40154659" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40154671">next</a><span>|</span><label class="collapse" for="c-40154659">[-]</label><label class="expand" for="c-40154659">[1 more]</label></div><br/><div class="children"><div class="content">A companion piece to this idea (previously at Oleb’s “making illegal states unrepresentable: <a href="https:&#x2F;&#x2F;oleb.net&#x2F;blog&#x2F;2018&#x2F;03&#x2F;making-illegal-states-unrepresentable&#x2F;" rel="nofollow">https:&#x2F;&#x2F;oleb.net&#x2F;blog&#x2F;2018&#x2F;03&#x2F;making-illegal-states-unrepres...</a>) is “parse, don’t validate”: <a href="https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-validate&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-va...</a><p>A third piece &#x2F; concept I often circle back to is a lot more subtle and difficult to grok: “Names are not type safety” (<a href="https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2020&#x2F;11&#x2F;01&#x2F;names-are-not-type-safety&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2020&#x2F;11&#x2F;01&#x2F;names-are-not-...</a>)</div><br/></div></div><div id="40154671" class="c"><input type="checkbox" id="c-40154671" checked=""/><div class="controls bullet"><span class="by">vsnf</span><span>|</span><a href="#40154659">prev</a><span>|</span><a href="#40154311">next</a><span>|</span><label class="collapse" for="c-40154671">[-]</label><label class="expand" for="c-40154671">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sympathetic to this concept, and it&#x27;s one I employ from time to time in the various codebases I own, but the type of person to advocate for this kind of thing is also the kind of person to write stuff like<p>&gt; Types delineate the set of legally representable states |ℝ| in your application<p>and<p>&gt; |ℝ|≥|ℙ|<p>Which sets off my &quot;math&quot; alarm. The less out-and-out math used to make a point about programming, the better, I think. This article is actually fairly good and doesn&#x27;t get very mathy beyond the intro, but it still jumps out at me and made me wary to continue.</div><br/><div id="40154959" class="c"><input type="checkbox" id="c-40154959" checked=""/><div class="controls bullet"><span class="by">hnbad</span><span>|</span><a href="#40154671">parent</a><span>|</span><a href="#40154311">next</a><span>|</span><label class="collapse" for="c-40154959">[-]</label><label class="expand" for="c-40154959">[1 more]</label></div><br/><div class="children"><div class="content">I second this as I find that usually the solution that is the most mathematically pure is usually also the one completely inadequate at handling the complexities of real-world applications and end up having various extremely impure additions bolted onto them (as shell scripts or Excel spreadsheets on a shared network drive if necessary) because refactoring them into an equally pure solution for the real-world case would take too long.</div><br/></div></div></div></div><div id="40154311" class="c"><input type="checkbox" id="c-40154311" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40154671">prev</a><span>|</span><a href="#40154589">next</a><span>|</span><label class="collapse" for="c-40154311">[-]</label><label class="expand" for="c-40154311">[5 more]</label></div><br/><div class="children"><div class="content">This principle has served me well for a long time, but it’s definitely a trade off space. We want to enforce as many invariants as possible through the type system, but more invariants requires more complexity. Eventually you run into dependent types etc.</div><br/><div id="40154925" class="c"><input type="checkbox" id="c-40154925" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#40154311">parent</a><span>|</span><a href="#40154586">next</a><span>|</span><label class="collapse" for="c-40154925">[-]</label><label class="expand" for="c-40154925">[2 more]</label></div><br/><div class="children"><div class="content">There’s no shame in just having complex constructors to check some invariants in non-structural ways. At least you still capture and enforce the transition.</div><br/><div id="40155086" class="c"><input type="checkbox" id="c-40155086" checked=""/><div class="controls bullet"><span class="by">4ad</span><span>|</span><a href="#40154311">root</a><span>|</span><a href="#40154925">parent</a><span>|</span><a href="#40154586">next</a><span>|</span><label class="collapse" for="c-40155086">[-]</label><label class="expand" for="c-40155086">[1 more]</label></div><br/><div class="children"><div class="content">That only works if your language is value-oriented, but most existing languages use references and mutation extensively.</div><br/></div></div></div></div><div id="40154586" class="c"><input type="checkbox" id="c-40154586" checked=""/><div class="controls bullet"><span class="by">Leo_Germond</span><span>|</span><a href="#40154311">parent</a><span>|</span><a href="#40154925">prev</a><span>|</span><a href="#40155055">next</a><span>|</span><label class="collapse" for="c-40154586">[-]</label><label class="expand" for="c-40154586">[1 more]</label></div><br/><div class="children"><div class="content">I would say it&#x27;s a tool with an optimal point that is located along the &quot;heavy use&quot; side. I think it is interesting to think of them as solidifying your specification. As such if your spec is still changing or it is unclear (e.g. first impl draft, example code...), you should use some lightweight types, whereas a public API should have types that encode basically everything your comments can say about the values, operations, and memory representation of the parameters. That would be the point where I would consider that defining my types is &quot;done&quot; and I would consider switching to e.g. moving the functiona around instead (there are lots of hanging fruits in safe by construction approaches, that might not even require types - can&#x27;t shoot yourself in the foot if I remove the footgun entirely)</div><br/></div></div><div id="40155055" class="c"><input type="checkbox" id="c-40155055" checked=""/><div class="controls bullet"><span class="by">4ad</span><span>|</span><a href="#40154311">parent</a><span>|</span><a href="#40154586">prev</a><span>|</span><a href="#40154589">next</a><span>|</span><label class="collapse" for="c-40155055">[-]</label><label class="expand" for="c-40155055">[1 more]</label></div><br/><div class="children"><div class="content">Invariants need to be encoded one way or another anyway, you can&#x27;t escape that. If your type system is not sophisticated enough this gets tedious and awkward to do in the type system. Dependent types simplify this, they make it much easier to express yourself compared to, say, all the various fancy extensions to System F.<p>That said, there is a vast space between Javascript&#x2F;Python and dependent types. Plain old ADT suffice in 95% of cases, yet the only mainstream language with ADTs is Rust. This is a shame.</div><br/></div></div></div></div><div id="40154589" class="c"><input type="checkbox" id="c-40154589" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40154311">prev</a><span>|</span><a href="#40154453">next</a><span>|</span><label class="collapse" for="c-40154589">[-]</label><label class="expand" for="c-40154589">[1 more]</label></div><br/><div class="children"><div class="content">Classically, this is a problem in hardware logic design. It&#x27;s desirable that logic circuits not be able to lock up in an invalid state. So having a state machine where invalid states cannot be represented is useful.  Hardware without this property tends to need reset buttons.</div><br/></div></div><div id="40154453" class="c"><input type="checkbox" id="c-40154453" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40154589">prev</a><span>|</span><a href="#40150861">next</a><span>|</span><label class="collapse" for="c-40154453">[-]</label><label class="expand" for="c-40154453">[1 more]</label></div><br/><div class="children"><div class="content">One of the grossest large codebase anti-pattern is god state objects. One of the worst I&#x27;ve seen had to do with the state of conference call. Depending on the state, zillions of properties were or weren&#x27;t valid. It was a huge, fucking mess that often allowed invalid states to creep in via edge-cases that led to unrecoverable states.</div><br/></div></div><div id="40150861" class="c"><input type="checkbox" id="c-40150861" checked=""/><div class="controls bullet"><span class="by">FrankWilhoit</span><span>|</span><a href="#40154453">prev</a><span>|</span><a href="#40154643">next</a><span>|</span><label class="collapse" for="c-40150861">[-]</label><label class="expand" for="c-40150861">[5 more]</label></div><br/><div class="children"><div class="content">Strong typing is like violence: if it isn&#x27;t solving all your problems, you must just not be using enough of it.</div><br/><div id="40154400" class="c"><input type="checkbox" id="c-40154400" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40150861">parent</a><span>|</span><a href="#40154592">next</a><span>|</span><label class="collapse" for="c-40154400">[-]</label><label class="expand" for="c-40154400">[3 more]</label></div><br/><div class="children"><div class="content">Forth is tic-tac-toe and dependent typing is global thermonuclear war.</div><br/><div id="40154435" class="c"><input type="checkbox" id="c-40154435" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40150861">root</a><span>|</span><a href="#40154400">parent</a><span>|</span><a href="#40154592">next</a><span>|</span><label class="collapse" for="c-40154435">[-]</label><label class="expand" for="c-40154435">[2 more]</label></div><br/><div class="children"><div class="content">It would then seem, the only winning move, is not to play.</div><br/><div id="40154668" class="c"><input type="checkbox" id="c-40154668" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40150861">root</a><span>|</span><a href="#40154435">parent</a><span>|</span><a href="#40154592">next</a><span>|</span><label class="collapse" for="c-40154668">[-]</label><label class="expand" for="c-40154668">[1 more]</label></div><br/><div class="children"><div class="content">How about a nice game of Go?</div><br/></div></div></div></div></div></div><div id="40154592" class="c"><input type="checkbox" id="c-40154592" checked=""/><div class="controls bullet"><span class="by">Leo_Germond</span><span>|</span><a href="#40150861">parent</a><span>|</span><a href="#40154400">prev</a><span>|</span><a href="#40154643">next</a><span>|</span><label class="collapse" for="c-40154592">[-]</label><label class="expand" for="c-40154592">[1 more]</label></div><br/><div class="children"><div class="content">I love that, going to reuse that one</div><br/></div></div></div></div><div id="40154643" class="c"><input type="checkbox" id="c-40154643" checked=""/><div class="controls bullet"><span class="by">orwin</span><span>|</span><a href="#40150861">prev</a><span>|</span><a href="#40153103">next</a><span>|</span><label class="collapse" for="c-40154643">[-]</label><label class="expand" for="c-40154643">[2 more]</label></div><br/><div class="children"><div class="content">I have a question for the author or anyone smart enough to understand the whole post:<p>what&#x27;s the difference here between state and data? Isn&#x27;t data more generic, and we can have the title &#x27;make invalid data unrepresentable&#x27;?<p>Because I have this instinct to do what I call in my mind and to my friend &#x27;ddd&#x27;, for &#x27;data driven programming&#x27;. It translate by first thinking on my global inputs, outputs, and transformations, then writing the data structure (I learned with C), then prototyping the core functions (basically I write the .h before the .c).<p>Is it the same thing? Let the data write the code (or state, and they&#x27;re the same thing here?) or did I miss something important?</div><br/><div id="40154835" class="c"><input type="checkbox" id="c-40154835" checked=""/><div class="controls bullet"><span class="by">orangeboats</span><span>|</span><a href="#40154643">parent</a><span>|</span><a href="#40153103">next</a><span>|</span><label class="collapse" for="c-40154835">[-]</label><label class="expand" for="c-40154835">[1 more]</label></div><br/><div class="children"><div class="content">The way I understand it, &quot;state&quot; refers to any point in time during the execution of a program.<p>A computer program can be split into 3 large parts: input, process, output. And invalid data, in my opinion, only concerns the first part, whereas invalid states can be found throughout all parts of the program due to e.g. bugs.<p>That makes &quot;make invalid states unrepresentable&quot; more generic than &quot;make invalid data unrepresentable&quot;. Or to put it in another way: invalid data can lead to invalid states, but not all invalid states are due to invalid data.</div><br/></div></div></div></div><div id="40153103" class="c"><input type="checkbox" id="c-40153103" checked=""/><div class="controls bullet"><span class="by">johann8384</span><span>|</span><a href="#40154643">prev</a><span>|</span><label class="collapse" for="c-40153103">[-]</label><label class="expand" for="c-40153103">[1 more]</label></div><br/><div class="children"><div class="content">I thought this was going to be some political thing about states and congress.</div><br/></div></div></div></div></div></div></div></body></html>