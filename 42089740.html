<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731142866730" as="style"/><link rel="stylesheet" href="styles.css?v=1731142866730"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://craftofcoding.wordpress.com/2024/10/21/algol-68-seemed-like-a-good-idea-until-it-wasnt/">Algol-68 seemed like a good idea – until it wasn&#x27;t</a> <span class="domain">(<a href="https://craftofcoding.wordpress.com">craftofcoding.wordpress.com</a>)</span></div><div class="subtext"><span>Bostonian</span> | <span>39 comments</span></div><br/><div><div id="42092456" class="c"><input type="checkbox" id="c-42092456" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42091102">next</a><span>|</span><label class="collapse" for="c-42092456">[-]</label><label class="expand" for="c-42092456">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that ALGOL-68 was that bad. It&#x27;s that the description of it was terrible. There was an attempt to formalize the semantics, and it was a disaster. Nobody knew how to describe language semantics back then, so they invented a new notation. There was an ALGOL-68 report, which was incomprehensible.[1] Then there was &quot;Informal Introduction to ALGOL-68&quot;[2], which was difficult. Finally, there was a &quot;Very Informal Introduction to ALGOL-68&quot;[3], which was somewhat readable.<p>Some sample text from the report:<p><i>A &quot;nest&quot; is a &#x27;NEST&#x27;. The nest &quot;of&quot; a construct is the &quot;NEST&quot; enveloped
by the original of that construct, but not by any &#x27;defining LAYER&#x27;
contained in that original.
(The nest of a construct carries a record of all the declarations forming
the environment in which that construct is to be interpreted.
Those constructs which are contained in a range R, but not in any
smaller range contained within R, may be said to comprise a &quot;reach&quot;. All
constructs in a given reach have the same nest, which is that of the
immediately surrounding reach with the addition of one extra &quot;LAYER&quot;.
The syntax ensures (3.2.1.b, 3.4.1.i,j,k, 3.5.1.e, 5.4.1.1.b) that each &#x27;PROP&#x27;
(4.8.1.E) or &quot;property&quot; in the extra &#x27;LAYER&#x27; is matched by a defining.
indicator (4.8.1.a) contained in a definition in that reach.)</i><p>They&#x27;re trying to get hold of the concept of variable scope and lifetime, back when that was a new idea.<p>They were also trying to invent type theory, which they needed and which didn&#x27;t exist yet. The first 50 pages of the report are all about the notation they invented to be used in the rest of the report. It&#x27;s not a very good notation. It&#x27;s like calculus before Leibniz, when people were trying to use Newton&#x27;s fluxions.[4]
Computer science just didn&#x27;t have enough widely understood abstractions for people to even talk about this stuff clearly.<p>[1] <a href="https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;ALGOL&#x2F;report&#x2F;Algol68_revised_report-AB-600dpi.pdf" rel="nofollow">https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;ALGOL&#x2F;report&#x2F;A...</a><p>[2] <a href="https:&#x2F;&#x2F;www.abebooks.com&#x2F;servlet&#x2F;BookDetailsPL?bi=31962044630" rel="nofollow">https:&#x2F;&#x2F;www.abebooks.com&#x2F;servlet&#x2F;BookDetailsPL?bi=3196204463...</a><p>[3] <a href="https:&#x2F;&#x2F;www.computinghistory.org.uk&#x2F;det&#x2F;8776&#x2F;A-Very-Informal-introduction-to-ALGOL-68&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.computinghistory.org.uk&#x2F;det&#x2F;8776&#x2F;A-Very-Informal...</a><p>[4] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fluxion" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fluxion</a></div><br/><div id="42093056" class="c"><input type="checkbox" id="c-42093056" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42092456">parent</a><span>|</span><a href="#42092983">next</a><span>|</span><label class="collapse" for="c-42093056">[-]</label><label class="expand" for="c-42093056">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I completely agree that the real problem of ALGOL-68 has been the complete lack of suitable documentation for it.<p>Even if Wirth is the author of some important innovations in programming language design, all his programming languages have been significantly inferior to ALGOL-68. Nevertheless, most of them have been more successful precisely because Wirth has written some simple and clear manuals for them, which were easily understood by any programmer.<p>The formal description used in the report about ALGOL-68 could have been very useful for implementers, but because the language included a lot of novelties it  never had any chance of adoption without having, besides a formal description, an extensive tutorial and rationale of the design, accompanied by many programming examples.<p>This is very sad, because ALGOL-68 got a lot of things right, which are wrong in most later programming languages, but because of its reputation of being incomprehensible it has been very seldom a source of inspiration for the designers of programming languages, as it would have deserved.<p>Some popular languages, including C, the Bourne shell and C++, have taken various elements from ALGOL 68, but most of them have been superficial elements, like keywords or details of syntax, instead of taking more important elements.<p>For instance among the ALGOL 68 elements borrowed by C is the keyword &quot;union&quot;, but the unions of C are barely better than the EQUIVALENCE of Fortran, and they are not comparable with the unions of ALGOL 68, which were based on the proposal of John McCarthy and which correspond to what are now more frequently called sum types. The &quot;variant records&quot; of Pascal were also much worse designed by Wirth than the unions introduced earlier in the ALGOL 68 that he had criticized.</div><br/></div></div><div id="42092983" class="c"><input type="checkbox" id="c-42092983" checked=""/><div class="controls bullet"><span class="by">habitue</span><span>|</span><a href="#42092456">parent</a><span>|</span><a href="#42093056">prev</a><span>|</span><a href="#42093006">next</a><span>|</span><label class="collapse" for="c-42092983">[-]</label><label class="expand" for="c-42092983">[3 more]</label></div><br/><div class="children"><div class="content">Dude, this is an amazing comment. Really points out how it looks when someone us ahead of their time:<p><pre><code>  - awkward groping for how to explain things
  - none of the words match how we talk about things now
</code></pre>
Algol-68 was clearly so ahead of its time, it&#x27;s hard to understand anything they&#x27;re saying. They&#x27;re in outer space</div><br/><div id="42093339" class="c"><input type="checkbox" id="c-42093339" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#42092456">root</a><span>|</span><a href="#42092983">parent</a><span>|</span><a href="#42093253">next</a><span>|</span><label class="collapse" for="c-42093339">[-]</label><label class="expand" for="c-42093339">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   - awkward groping for how to explain things
   - none of the words match how we talk about things now
</code></pre>
My life in a nutshell these last few years.<p>Glad to hear it <i>might</i> not be utter incompetence.</div><br/></div></div><div id="42093253" class="c"><input type="checkbox" id="c-42093253" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42092456">root</a><span>|</span><a href="#42092983">parent</a><span>|</span><a href="#42093339">prev</a><span>|</span><a href="#42093006">next</a><span>|</span><label class="collapse" for="c-42093253">[-]</label><label class="expand" for="c-42093253">[1 more]</label></div><br/><div class="children"><div class="content">Comes up all the time. Steam engine valve gear is a pulse-width modulation motor driver. Number 5 Crossbar, the best electromechanical telephone switch, is a distributed redundant microservices architecture. Western Union Plan-55A, for switching telegrams, is a mail server and forwarder. Each of those, in its day, was unique in its space, with its own terminology and theory. Today we see them as instances of common patterns.<p>Right now, large language models are in that state. They work, but why they work and why they fail is barely understood. As more systems are developed in that space and adjacent to it, more general understanding may emerge.</div><br/></div></div></div></div><div id="42093006" class="c"><input type="checkbox" id="c-42093006" checked=""/><div class="controls bullet"><span class="by">twoodfin</span><span>|</span><a href="#42092456">parent</a><span>|</span><a href="#42092983">prev</a><span>|</span><a href="#42092632">next</a><span>|</span><label class="collapse" for="c-42093006">[-]</label><label class="expand" for="c-42093006">[2 more]</label></div><br/><div class="children"><div class="content">I’d love to find [3] as a PDF!</div><br/><div id="42093088" class="c"><input type="checkbox" id="c-42093088" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42092456">root</a><span>|</span><a href="#42093006">parent</a><span>|</span><a href="#42092632">next</a><span>|</span><label class="collapse" for="c-42093088">[-]</label><label class="expand" for="c-42093088">[1 more]</label></div><br/><div class="children"><div class="content">I assume that it has about the same content as the book &quot;Informal introduction to algol 68&quot;, published by the same authors a few years later, and which had at least two editions, e.g. in 1973 and in 1977.<p>Searching the Internet finds some scanned copies of that book.<p>E.g.<p><a href="https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;ALGOL&#x2F;book&#x2F;Lindsey_van_der_Meulen-IItA68-Revised.pdf" rel="nofollow">https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;ALGOL&#x2F;book&#x2F;Lin...</a></div><br/></div></div></div></div></div></div><div id="42091102" class="c"><input type="checkbox" id="c-42091102" checked=""/><div class="controls bullet"><span class="by">mhd</span><span>|</span><a href="#42092456">prev</a><span>|</span><a href="#42090842">next</a><span>|</span><label class="collapse" for="c-42091102">[-]</label><label class="expand" for="c-42091102">[8 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot of hearsay in that articles, and a lot of sentiment rooted in the particulars of that time.<p>Sure, it was a complex thing in the late 60s&#x2F;early 70s. Sure, Wirth came up with something simpler. But I&#x27;m missing a deeper analysis, especially with a more modern view point where basically <i>any</i> language is <i>at least</i> as complex as Algol 68[0].<p>&gt; Arguably Wirth’s Algol-W was a better successor to Algol-60<p>I might not even disagree, but what were the arguments, and how are they holding up?<p>&gt; and arguably did not have the same connections to industry as the likes of Fortran and Cobol<p>Sure. But neither did Algol-W or Pascal. And pretty much anything else in the 20th century.<p>[0]: <a href="http:&#x2F;&#x2F;cowlark.com&#x2F;2009-11-15-go&#x2F;" rel="nofollow">http:&#x2F;&#x2F;cowlark.com&#x2F;2009-11-15-go&#x2F;</a></div><br/><div id="42091314" class="c"><input type="checkbox" id="c-42091314" checked=""/><div class="controls bullet"><span class="by">73kl4453dz</span><span>|</span><a href="#42091102">parent</a><span>|</span><a href="#42091207">next</a><span>|</span><label class="collapse" for="c-42091314">[-]</label><label class="expand" for="c-42091314">[2 more]</label></div><br/><div class="children"><div class="content">Algol 68 was certainly too much language for the tiny machines of 1970, but on a 2020 box it might be fairly decent.</div><br/><div id="42091912" class="c"><input type="checkbox" id="c-42091912" checked=""/><div class="controls bullet"><span class="by">manbart</span><span>|</span><a href="#42091102">root</a><span>|</span><a href="#42091314">parent</a><span>|</span><a href="#42091207">next</a><span>|</span><label class="collapse" for="c-42091912">[-]</label><label class="expand" for="c-42091912">[1 more]</label></div><br/><div class="children"><div class="content">There is a modern implementation if you feel like checking it out firsthand<p><a href="https:&#x2F;&#x2F;jmvdveer.home.xs4all.nl&#x2F;en.algol-68-genie.html" rel="nofollow">https:&#x2F;&#x2F;jmvdveer.home.xs4all.nl&#x2F;en.algol-68-genie.html</a></div><br/></div></div></div></div><div id="42091207" class="c"><input type="checkbox" id="c-42091207" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42091102">parent</a><span>|</span><a href="#42091314">prev</a><span>|</span><a href="#42090842">next</a><span>|</span><label class="collapse" for="c-42091207">[-]</label><label class="expand" for="c-42091207">[5 more]</label></div><br/><div class="children"><div class="content">EWD comes up as a dissenter for Algol-68, and the longer my career as a software developer the more I disagree with him on anything that isn&#x27;t pure math.</div><br/><div id="42091313" class="c"><input type="checkbox" id="c-42091313" checked=""/><div class="controls bullet"><span class="by">mhd</span><span>|</span><a href="#42091102">root</a><span>|</span><a href="#42091207">parent</a><span>|</span><a href="#42091591">next</a><span>|</span><label class="collapse" for="c-42091313">[-]</label><label class="expand" for="c-42091313">[1 more]</label></div><br/><div class="children"><div class="content">Having EWD as a dissenter also seems a rather low bar, to be fair. (One might say he was a bit of a Edsgerlord.)</div><br/></div></div><div id="42091591" class="c"><input type="checkbox" id="c-42091591" checked=""/><div class="controls bullet"><span class="by">le-mark</span><span>|</span><a href="#42091102">root</a><span>|</span><a href="#42091207">parent</a><span>|</span><a href="#42091313">prev</a><span>|</span><a href="#42090842">next</a><span>|</span><label class="collapse" for="c-42091591">[-]</label><label class="expand" for="c-42091591">[3 more]</label></div><br/><div class="children"><div class="content">EWD is apparently Edsger W. Dijkstra for those also unaccustomed to reading him cited by his initials.</div><br/><div id="42091698" class="c"><input type="checkbox" id="c-42091698" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#42091102">root</a><span>|</span><a href="#42091591">parent</a><span>|</span><a href="#42090842">next</a><span>|</span><label class="collapse" for="c-42091698">[-]</label><label class="expand" for="c-42091698">[2 more]</label></div><br/><div class="children"><div class="content">The appellation is in some part due to his custom of writing monographs for himself titled EWD-n[1]. They are a fascinating mix of deep mathematical and philosophical insight and curmudgeonly reflective essaying.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~EWD&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~EWD&#x2F;</a></div><br/><div id="42092971" class="c"><input type="checkbox" id="c-42092971" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#42091102">root</a><span>|</span><a href="#42091698">parent</a><span>|</span><a href="#42090842">next</a><span>|</span><label class="collapse" for="c-42092971">[-]</label><label class="expand" for="c-42092971">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>writing monographs for himself</i><p>One might almost call it a &quot;blog&quot; if it weren&#x27;t for the fact that EWD started ~35 years before Frontier NewsPage.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42090842" class="c"><input type="checkbox" id="c-42090842" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#42091102">prev</a><span>|</span><a href="#42092235">next</a><span>|</span><label class="collapse" for="c-42090842">[-]</label><label class="expand" for="c-42090842">[7 more]</label></div><br/><div class="children"><div class="content">It sounds like a classic case of the Second System effect.  Where the original product was functional but a maybe little too basic, so everybody has an idea of how to improve it.  Many of the ideas are good on their own, but the committee ends up accepting far too many and the thing suffers from terminal feature creep.</div><br/><div id="42090865" class="c"><input type="checkbox" id="c-42090865" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42090842">parent</a><span>|</span><a href="#42092235">next</a><span>|</span><label class="collapse" for="c-42090865">[-]</label><label class="expand" for="c-42090865">[6 more]</label></div><br/><div class="children"><div class="content">Feature creep and Second System effect are all the rage now. Every recent language has them.<p>If you don&#x27;t constantly have three dozen Requests for Implementation brewing, seven of which are going into the next release, you&#x27;re a dead project.</div><br/><div id="42091067" class="c"><input type="checkbox" id="c-42091067" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#42090842">root</a><span>|</span><a href="#42090865">parent</a><span>|</span><a href="#42091017">next</a><span>|</span><label class="collapse" for="c-42091067">[-]</label><label class="expand" for="c-42091067">[4 more]</label></div><br/><div class="children"><div class="content">Perhaps we should make a language with a hard cap on the number of “features” in the language syntax + standard library. For everything you propose to add, you would then also need to propose something to remove.</div><br/><div id="42091269" class="c"><input type="checkbox" id="c-42091269" checked=""/><div class="controls bullet"><span class="by">dotancohen</span><span>|</span><a href="#42090842">root</a><span>|</span><a href="#42091067">parent</a><span>|</span><a href="#42092552">next</a><span>|</span><label class="collapse" for="c-42091269">[-]</label><label class="expand" for="c-42091269">[2 more]</label></div><br/><div class="children"><div class="content">Though in principal I love the idea, it would kill backwards compatibility. But maybe each major version revision should have a vote on keeping or removing some older features.</div><br/><div id="42092075" class="c"><input type="checkbox" id="c-42092075" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42090842">root</a><span>|</span><a href="#42091269">parent</a><span>|</span><a href="#42092552">next</a><span>|</span><label class="collapse" for="c-42092075">[-]</label><label class="expand" for="c-42092075">[1 more]</label></div><br/><div class="children"><div class="content">Only those holding no stakes would play the vote game; anyone actually depending on compatibility would silently (or sometimes not so silently) depart.</div><br/></div></div></div></div><div id="42092552" class="c"><input type="checkbox" id="c-42092552" checked=""/><div class="controls bullet"><span class="by">JadeNB</span><span>|</span><a href="#42090842">root</a><span>|</span><a href="#42091067">parent</a><span>|</span><a href="#42091269">prev</a><span>|</span><a href="#42091017">next</a><span>|</span><label class="collapse" for="c-42092552">[-]</label><label class="expand" for="c-42092552">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For everything you propose to add, you would then also need to propose something to remove.<p>There are surely lots of features the <i>proposer</i> would be willing to remove (although one also has to define how to count the number of features, or else every proposal, no matter how long, will be for one giant feature, and will propose removing one tiny feature in return).  The problem is that what I consider dispensable in return for my essential proposal will conflict with what the next programmer over considers essential ….</div><br/></div></div></div></div><div id="42091017" class="c"><input type="checkbox" id="c-42091017" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42090842">root</a><span>|</span><a href="#42090865">parent</a><span>|</span><a href="#42091067">prev</a><span>|</span><a href="#42092235">next</a><span>|</span><label class="collapse" for="c-42091017">[-]</label><label class="expand" for="c-42091017">[1 more]</label></div><br/><div class="children"><div class="content">Emergent property of humans, it turns out.</div><br/></div></div></div></div></div></div><div id="42092235" class="c"><input type="checkbox" id="c-42092235" checked=""/><div class="controls bullet"><span class="by">ogogmad</span><span>|</span><a href="#42090842">prev</a><span>|</span><a href="#42092004">next</a><span>|</span><label class="collapse" for="c-42092235">[-]</label><label class="expand" for="c-42092235">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve just looked at this snippet, which the blog used back in 2017 to illustrate that Algol 68 was &quot;utter madness&quot;: <a href="https:&#x2F;&#x2F;craftofcoding.wordpress.com&#x2F;2017&#x2F;03&#x2F;06&#x2F;a-brief-look-at-the-utter-madness-of-algol-68&#x2F;" rel="nofollow">https:&#x2F;&#x2F;craftofcoding.wordpress.com&#x2F;2017&#x2F;03&#x2F;06&#x2F;a-brief-look-...</a><p><pre><code>   COMMENT
   Algol 68 program to calculate the Sieve of Eratosthenes
   for some upper limit N
   COMMENT

   PROC eratosthenes = (INT n) []INT:
   (
       [n]INT sieve;

       FOR i TO UPB sieve DO
           sieve[i] := i
       OD;
       INT k = ENTIER sqrt(n);
       sieve[1] := 0;
       FOR i FROM 2 TO k DO
           IF sieve[i] NE 0 THEN
               FOR j FROM i*i BY i TO n DO
                   sieve[j] := 0
               OD
           FI
       OD;
       sieve
   );

   INT n;
   print(&quot;Upper limit to calculate sieve? &quot;);
   read(n);
   print((eratosthenes(n), newline))

</code></pre>
A few things: This code is very readable. The blogger didn&#x27;t understand it because he didn&#x27;t understand what the &quot;Sieve of Eratosthenes&quot; did: It&#x27;s a means of calculating lists of prime numbers. He incorrectly stated that it was used for calculating Fibonacci numbers.<p>Syntax-wise, it looks like some mix of Go, C and Python. Nothing at all unusual. It would be pretty easy to learn to program in this, and comfortable too.<p>[Edit: The blogger later demonstrated a good understanding of the Sieve of Eratosthenes, but still expressed criticism of Algol68: <a href="https:&#x2F;&#x2F;craftofcoding.wordpress.com&#x2F;2021&#x2F;04&#x2F;06&#x2F;algorithm-35-the-sieve-in-algol-68&#x2F;" rel="nofollow">https:&#x2F;&#x2F;craftofcoding.wordpress.com&#x2F;2021&#x2F;04&#x2F;06&#x2F;algorithm-35-...</a>]</div><br/><div id="42092509" class="c"><input type="checkbox" id="c-42092509" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#42092235">parent</a><span>|</span><a href="#42092259">next</a><span>|</span><label class="collapse" for="c-42092509">[-]</label><label class="expand" for="c-42092509">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This code is very readable<p>It really is.<p>&gt; Syntax-wise, it looks like some mix of Go, C and Python. Nothing at all unusual. It would be pretty easy to learn to program in this, and comfortable too.<p>Or maybe a mix of Pascal, PL&#x2F;I, and &#x2F;bin&#x2F;sh.</div><br/><div id="42093236" class="c"><input type="checkbox" id="c-42093236" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42092235">root</a><span>|</span><a href="#42092509">parent</a><span>|</span><a href="#42092259">next</a><span>|</span><label class="collapse" for="c-42093236">[-]</label><label class="expand" for="c-42093236">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;bin&#x2F;sh, i.e. the Bourne shell, has been written by a programmer who was experienced in ALGOL 68, having implemented some significant projects in it.<p>In designing the language interpreted by the shell, he has taken several features directly from ALGOL 68.<p>However he has also done one improvement, renaming the bracket pair keywords &quot;do&quot; and &quot;od&quot; to &quot;do&quot; and &quot;done&quot;, responding thus to the criticism of many programmers towards ALGOL 68, that &quot;od&quot; sounds odd.</div><br/></div></div></div></div><div id="42092259" class="c"><input type="checkbox" id="c-42092259" checked=""/><div class="controls bullet"><span class="by">foobarian</span><span>|</span><a href="#42092235">parent</a><span>|</span><a href="#42092509">prev</a><span>|</span><a href="#42092004">next</a><span>|</span><label class="collapse" for="c-42092259">[-]</label><label class="expand" for="c-42092259">[6 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Algol the crazy language using special characters all over the place as operators?  I could see that being undesirable, but I don&#x27;t see it in that snippet.<p>edit: I&#x27;m thinking of APL.  It looks like it&#x27;s the same kind of functionality as what the Matlab, R or numpy cohort provides.</div><br/><div id="42093172" class="c"><input type="checkbox" id="c-42093172" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#42092235">root</a><span>|</span><a href="#42092259">parent</a><span>|</span><a href="#42092292">next</a><span>|</span><label class="collapse" for="c-42093172">[-]</label><label class="expand" for="c-42093172">[1 more]</label></div><br/><div class="children"><div class="content">Yes, as in your own correction, you were thinking about APL.<p>ALGOL 68 was certainly more readable than C or Pascal, even if it was somewhat more verbose.<p>A very good feature of ALGOL 68 was that all the syntactic structures were enclosed in brackets, so no ambiguities or editing errors were possible, like in C or ALGOL 60.<p>Moreover, each syntactic structure had its own pair of brackets, so you did not have the reading difficulties caused by all bracket pairs being the same, like &quot;()&quot; in LISP, &quot;begin&quot; and &quot;end&quot; in Pascal or &quot;{}&quot; in C.<p>Especially useful is having different bracket pairs for iterations (&quot;do&quot; and &quot;od&quot; in ALGOL 68, renamed as &quot;do&quot; and &quot;done&quot; in the Bourne shell, which sounds better) in comparison with the bracket pairs used for conditional statements (&quot;if&quot; and &quot;fi&quot; in ALGOL 68).<p>In C and derived languages, even the indentation is not enough to understand the code in many cases, especially when the lines are restricted to 80 characters, when you have a long loop body that cannot be seen inside a single page.<p>In ALGOL 68, you have distinct closing brackets for each syntactic structure, so it is easy to recognize their meaning.<p>Using keywords for brackets is more verbose than in C, but much less verbose than using terminating comments. Moreover, now we can use Unicode for program texts, so instead of keywords one could use different pairs of Unicode brackets that are graphically distinct. For instance one can use angular brackets for conditional statements and S-shaped bag delimiter brackets for iterations.</div><br/></div></div><div id="42092292" class="c"><input type="checkbox" id="c-42092292" checked=""/><div class="controls bullet"><span class="by">ogogmad</span><span>|</span><a href="#42092235">root</a><span>|</span><a href="#42092259">parent</a><span>|</span><a href="#42093172">prev</a><span>|</span><a href="#42092004">next</a><span>|</span><label class="collapse" for="c-42092292">[-]</label><label class="expand" for="c-42092292">[4 more]</label></div><br/><div class="children"><div class="content">ALGOL is the main forerunner of C. Anything vaguely C-like is also ALGOL-like.</div><br/><div id="42092513" class="c"><input type="checkbox" id="c-42092513" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#42092235">root</a><span>|</span><a href="#42092292">parent</a><span>|</span><a href="#42092004">next</a><span>|</span><label class="collapse" for="c-42092513">[-]</label><label class="expand" for="c-42092513">[3 more]</label></div><br/><div class="children"><div class="content">As I understand it, B[1] was the immediate predecessor of C.<p>Pascal (and its descendants) and Ada (and VHDL) seem closer syntactically to algol 60 than C is (begin&#x2F;end as block delimiters, no parentheses needed for control structures, := for assignment, etc.) The example code at [1] (using bold keywords) should be understandable to most HN readers 64 years later.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;B_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;B_(programming_language)</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ALGOL_60" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ALGOL_60</a></div><br/><div id="42092638" class="c"><input type="checkbox" id="c-42092638" checked=""/><div class="controls bullet"><span class="by">mmoskal</span><span>|</span><a href="#42092235">root</a><span>|</span><a href="#42092513">parent</a><span>|</span><a href="#42092004">next</a><span>|</span><label class="collapse" for="c-42092638">[-]</label><label class="expand" for="c-42092638">[2 more]</label></div><br/><div class="children"><div class="content">B came from BCPL which came from CPL which came from ALGOL 60. The main thing about ALGOL was structured programming as opposed to goto statements. Compared to that begin&#x2F;end vs braces is a very minor issue.</div><br/><div id="42092926" class="c"><input type="checkbox" id="c-42092926" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#42092235">root</a><span>|</span><a href="#42092638">parent</a><span>|</span><a href="#42092004">next</a><span>|</span><label class="collapse" for="c-42092926">[-]</label><label class="expand" for="c-42092926">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. And they&#x27;re all algol descendants as you note.<p>But there is certainly a difference between c-like syntax (java, javascript...) vs. algol-like syntax (pascal, ada, ...)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42092004" class="c"><input type="checkbox" id="c-42092004" checked=""/><div class="controls bullet"><span class="by">butterisgood</span><span>|</span><a href="#42092235">prev</a><span>|</span><a href="#42091390">next</a><span>|</span><label class="collapse" for="c-42092004">[-]</label><label class="expand" for="c-42092004">[3 more]</label></div><br/><div class="children"><div class="content">And we lost Wirth this year sadly. I hope we can find a language with safety, simplicity, and just enough features to be practical someday.</div><br/><div id="42092959" class="c"><input type="checkbox" id="c-42092959" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#42092004">parent</a><span>|</span><a href="#42091390">next</a><span>|</span><label class="collapse" for="c-42092959">[-]</label><label class="expand" for="c-42092959">[2 more]</label></div><br/><div class="children"><div class="content">I think Wirth said something like &quot;I am a programmer who is a professor, and a professor who is a programmer.&quot; Definitely a huge inspiration to me, both for the elegance and compactness of his system designs as well as the idea that research could and should affect practice, and vice-versa.<p>At least with -fbounds-safety clang is finally catching up with what Pascal (including UCSD, Apple, and Turbo Pascal) and Ada (a rather more complicated descendant of Pascal) compilers had in the 1980s. (Delphi and Free Pascal still have range checking today.)</div><br/><div id="42093321" class="c"><input type="checkbox" id="c-42093321" checked=""/><div class="controls bullet"><span class="by">EVa5I7bHFq9mnYK</span><span>|</span><a href="#42092004">root</a><span>|</span><a href="#42092959">parent</a><span>|</span><a href="#42091390">next</a><span>|</span><label class="collapse" for="c-42093321">[-]</label><label class="expand" for="c-42093321">[1 more]</label></div><br/><div class="children"><div class="content">But you could insert ASM instructions directly into PASCAL code, in case you needed something fast and without bounds checking.</div><br/></div></div></div></div></div></div><div id="42091390" class="c"><input type="checkbox" id="c-42091390" checked=""/><div class="controls bullet"><span class="by">trhway</span><span>|</span><a href="#42092004">prev</a><span>|</span><a href="#42091110">next</a><span>|</span><label class="collapse" for="c-42091390">[-]</label><label class="expand" for="c-42091390">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Algol-68 (or derivatives of) did rise to some prominence in one place – the USSR. The most prominent implementation of the language came from Leningrad State University. It was apparently used to design Russian telephone exchanges.<p>6-pass compiler for Algol-68 :)  The telephone exchange was built on the base of the microcomputer (while developed in USSR&#x2F;Russia, and ultimately that microcomputer was mostly used by the Russian military, the major customer for the exchange who funded the work at some point was Alcatel) which was like Tandem, only 3 instead of 2 systems in parallel because of low quality of electronics, the CPU was USSR-developed &quot;Samson&quot; [1], a kind of Elbrus offshoot. The exchange software was developed in SDL (Z.100, kind of like Erlang-by-European-commitee-in-1980ies) and compiled into Algol-68 which was compiled into that CPU codes.<p>[1] (in Russian) <a href="https:&#x2F;&#x2F;www.computer-museum.ru&#x2F;articles&#x2F;sistemi_kompleksi&#x2F;90&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.computer-museum.ru&#x2F;articles&#x2F;sistemi_kompleksi&#x2F;90...</a></div><br/></div></div><div id="42091110" class="c"><input type="checkbox" id="c-42091110" checked=""/><div class="controls bullet"><span class="by">zgs</span><span>|</span><a href="#42091390">prev</a><span>|</span><label class="collapse" for="c-42091110">[-]</label><label class="expand" for="c-42091110">[2 more]</label></div><br/><div class="children"><div class="content">Algol 68 was to Algol as C++ is to C: trying to do too much resulting in over-complexity.<p>The two page spread showing a graph of the implicit type conversions was a masterpiece.</div><br/><div id="42091338" class="c"><input type="checkbox" id="c-42091338" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#42091110">parent</a><span>|</span><label class="collapse" for="c-42091338">[-]</label><label class="expand" for="c-42091338">[1 more]</label></div><br/><div class="children"><div class="content">But not really - lots of new stuff was added - structures, unions, pointers, function pointers, operator definitions, a heap - all stuff that hadn&#x27;t appeared in a language spec before, things we all see and use every day.<p>The big problem was that the language spec was incomprehensible (I&#x27;ve done a language implementation), trying to embed syntax and semantics into the one spec - the maths guys went a bit overboard there. The other main problem was trying to solve the reserved word problem by defining effectively multiple fonts&#x2F;type faces for different parts of the language .... at a time when even lower case wasn&#x27;t really an option for most people</div><br/></div></div></div></div></div></div></div></div></div></body></html>