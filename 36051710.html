<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684918865747" as="style"/><link rel="stylesheet" href="styles.css?v=1684918865747"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.koehntopp.info/2023/05/17/50-years-in-filesystems-towards-2004-lfs.html">50 years in filesystems: towards 2004 – LFS</a> <span class="domain">(<a href="https://blog.koehntopp.info">blog.koehntopp.info</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>25 comments</span></div><br/><div><div id="36052669" class="c"><input type="checkbox" id="c-36052669" checked=""/><div class="controls bullet"><span class="by">usernew</span><span>|</span><a href="#36053083">next</a><span>|</span><label class="collapse" for="c-36052669">[-]</label><label class="expand" for="c-36052669">[8 more]</label></div><br/><div class="children"><div class="content">Speaking as a guy who&#x27;s done enterprise storage for close to 30 years, the main issue here is IO stack integration.  There&#x27;s almost none.  There are people like Oracle that try to bypass at least some of these disconnected layers that don&#x27;t work well together, but why don&#x27;t the drive vendors do this?  Intel makes a compiler for their CPUs.  Why isn&#x27;t there a WDFS that has built-in LVM?<p>Here&#x27;s the main issue.  You have your application that sits on a filesystem.  The filesystem tries to predict what the application is doing. That sits on a volume manager.  That&#x27;s just a dumb table of pointers.  That sits on top of a disk drive, talking to the RAM on the drive.  Then you have the backend of the disk controller trying to predict what to put in RAM.<p>Oracle knows best what it&#x27;s going to need next from the disk, based on some query it&#x27;s running, if it expects a drop in IO soon where the disk can do background cleanup, if and when it&#x27;s about to do a lot of reads once it&#x27;s done with a lot of writes, in 3 minutes.  The filesystem has no idea. The disk controller has no idea.  Wouldn&#x27;t it be great, more performant, and less wasteful, if the application could tell the disk drive about its behavior using some sort of standard API, and the disk controller could translate that to what the backend disk should do - whether it&#x27;s the various types of spinning rust or different flash types?<p>TRIM is a very basic example of that.  What we need is more things like TRIM for the application IO libraries to tell its intent to the backend controller, and that API is appropriate to be put in the filesystem, and just blindly pass it on all the way to the backend.</div><br/><div id="36052802" class="c"><input type="checkbox" id="c-36052802" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36052669">parent</a><span>|</span><a href="#36054946">next</a><span>|</span><label class="collapse" for="c-36052802">[-]</label><label class="expand" for="c-36052802">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why don&#x27;t the drive vendors do this? Intel makes a compiler for their CPUs. Why isn&#x27;t there a WDFS that has built-in LVM?<p>Given the quality of firmware in RAID controllers and disk drives and... er, everything, actually, I would really rather that they do as little as possible, unless they&#x27;re going to make the firmware open source so we can fix the bugs.</div><br/></div></div><div id="36054946" class="c"><input type="checkbox" id="c-36054946" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#36052669">parent</a><span>|</span><a href="#36052802">prev</a><span>|</span><a href="#36055562">next</a><span>|</span><label class="collapse" for="c-36054946">[-]</label><label class="expand" for="c-36054946">[1 more]</label></div><br/><div class="children"><div class="content">This is a very general issue in computing. You could make many of the same arguments about a web app running on a computer and all the involved modules (graphics, networking, JS VM, app code itself, etc). We have abstractions and interfaces that enforce separations of concerns, which give us many desireable properties, but at the same time there&#x27;s an attraction, especially for performance in exchange for modularity, to do some &quot;layering violations&quot; to take advantage of knowledge of unexposed internals of other modules.<p>I think one way around it and to have the cake but eat it too would be to enable some whole-system program transformations, a bit like what unikernels have started nibbling at the edges of.</div><br/></div></div><div id="36055562" class="c"><input type="checkbox" id="c-36055562" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#36052669">parent</a><span>|</span><a href="#36054946">prev</a><span>|</span><a href="#36053122">next</a><span>|</span><label class="collapse" for="c-36055562">[-]</label><label class="expand" for="c-36055562">[1 more]</label></div><br/><div class="children"><div class="content">NVMe devices can support multiple namespaces and each namespace is assigned a specific command set upon creation, normally NVM with LBA. But there&#x27;s also a key-value command set.<p>Zoned namespaces provide a &quot;trimless&quot; future, as zones are allocated explicitly, written sequentially and must be released explicitly by the host.</div><br/></div></div><div id="36053122" class="c"><input type="checkbox" id="c-36053122" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36052669">parent</a><span>|</span><a href="#36055562">prev</a><span>|</span><a href="#36055080">next</a><span>|</span><label class="collapse" for="c-36053122">[-]</label><label class="expand" for="c-36053122">[1 more]</label></div><br/><div class="children"><div class="content">I did some searching &amp; am a bit shocked: I couldn&#x27;t find any way to adjust io priority other than by altering the entire processes io level. I would have though this would be a semi-commonly used routine to make high&#x2F;regulae&#x2F;low priority QoS for io, but indeed, per your claims, I can&#x27;t seem to find anything.<p>Hypothetically one could maybe spawn a bunch of child processes and give them each their own io priority? Maybe io priority is sticky, and one can change io priority just before doing io work, and the io priority for that work would stay when one changes the io priority before the next operation?<p>I feel like we have a bunch of possible things we could to better qos with what controls we have.<p>Therw are also a variety of madvise hints we can provide, telling the kernel what we will need, what to drop, what we won&#x27;t need, what will be random access (not benefit from lookahead) Vs sequential. These already are some pretty useful knobs. Which I&#x27;d guess are quite broadly underused.</div><br/></div></div><div id="36055080" class="c"><input type="checkbox" id="c-36055080" checked=""/><div class="controls bullet"><span class="by">sacheendra</span><span>|</span><a href="#36052669">parent</a><span>|</span><a href="#36053122">prev</a><span>|</span><a href="#36052817">next</a><span>|</span><label class="collapse" for="c-36055080">[-]</label><label class="expand" for="c-36055080">[1 more]</label></div><br/><div class="children"><div class="content">Storage manufacturers now give the application more control over SSD FTL operations through ZNS. <a href="https:&#x2F;&#x2F;zonedstorage.io&#x2F;docs&#x2F;introduction&#x2F;zns" rel="nofollow">https:&#x2F;&#x2F;zonedstorage.io&#x2F;docs&#x2F;introduction&#x2F;zns</a>. Curious to see how it will be used</div><br/></div></div><div id="36052817" class="c"><input type="checkbox" id="c-36052817" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#36052669">parent</a><span>|</span><a href="#36055080">prev</a><span>|</span><a href="#36054179">next</a><span>|</span><label class="collapse" for="c-36052817">[-]</label><label class="expand" for="c-36052817">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this also the same reason &#x27;prosumer&#x27; storage hardware &#x2F; use of off the shelf stuff mostly doesn&#x27;t exist?  If the storage manufacturers dared provide a low level interface option to the real hardware without the easy to for Windows traditional abstractions then they&#x27;d both get their lunch eaten (by everyone that moves their current excuse for market segmentation into the OS &#x2F; Database daemons) and take a loss at still providing for the majority market share of dumb as bricks Windows that lacks a mature VFS API other than NTFS (it&#x27;s defacto VFS API that MS should just declare all new filesystems implement due to the crushing weight of legacy).</div><br/></div></div><div id="36054179" class="c"><input type="checkbox" id="c-36054179" checked=""/><div class="controls bullet"><span class="by">jgerrish</span><span>|</span><a href="#36052669">parent</a><span>|</span><a href="#36052817">prev</a><span>|</span><a href="#36053083">next</a><span>|</span><label class="collapse" for="c-36054179">[-]</label><label class="expand" for="c-36054179">[1 more]</label></div><br/><div class="children"><div class="content">Smart idea.  There are a bunch of different basic strategies and policies that could be implemented in a series of weekend projects.  Ranged &#x2F; extent reads&#x2F;writes, upcoming allocations, locality-sensitive data,   Short-range vs. Long-range data structures, access frequency estimates, historical file size estimates, etc.<p>This pairs well with microkernel architectures too.  A separate FS policy manager service that is pluggable.  You could write a dozen simple policies in a month and also shore up in terms of open-source defensive patents.<p>Or, if you&#x27;re a commercial house and not worrying about day-to-day operations you could fill your patent portfolio.<p>Smart idea.</div><br/></div></div></div></div><div id="36053083" class="c"><input type="checkbox" id="c-36053083" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36052669">prev</a><span>|</span><a href="#36052390">next</a><span>|</span><label class="collapse" for="c-36053083">[-]</label><label class="expand" for="c-36053083">[1 more]</label></div><br/><div class="children"><div class="content"><i>Also, we’re getting things that can seek a lot faster than disks: Flash Storage.</i><p>NAND FTLs are by necessity log-structured because of the nature of the medium: pages can only be programmed in sequential order in each block, only entire blocks can be erased at once, and ideally you want to evenly use all blocks even when you&#x27;re just updating a single (logical) sector repeatedly.</div><br/></div></div><div id="36052390" class="c"><input type="checkbox" id="c-36052390" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#36053083">prev</a><span>|</span><a href="#36054039">next</a><span>|</span><label class="collapse" for="c-36052390">[-]</label><label class="expand" for="c-36052390">[1 more]</label></div><br/><div class="children"><div class="content">NILFS2 is upstream in Linux - the log structure means snapshots happen for free on every disk operation, so you can get point-in-time rollback without needing to manually create disk snapshots.<p>It does require a userspace daemon running to compact the log, though.</div><br/></div></div><div id="36054039" class="c"><input type="checkbox" id="c-36054039" checked=""/><div class="controls bullet"><span class="by">Perenti</span><span>|</span><a href="#36052390">prev</a><span>|</span><a href="#36052886">next</a><span>|</span><label class="collapse" for="c-36054039">[-]</label><label class="expand" for="c-36054039">[2 more]</label></div><br/><div class="children"><div class="content">The article claims garbage collection was invented in the JVM!  I wonder what that old DEC-20 was doing when it reported to all terminals that garbage collection was ongoing...<p>Or what the mark&#x2F;release garden of eden model of Smalltalk was...</div><br/><div id="36054325" class="c"><input type="checkbox" id="c-36054325" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#36054039">parent</a><span>|</span><a href="#36052886">next</a><span>|</span><label class="collapse" for="c-36054325">[-]</label><label class="expand" for="c-36054325">[1 more]</label></div><br/><div class="children"><div class="content">The article claims JVMs were invented around the same time, and that they happened to include garbage collectors.</div><br/></div></div></div></div><div id="36052886" class="c"><input type="checkbox" id="c-36052886" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#36054039">prev</a><span>|</span><label class="collapse" for="c-36052886">[-]</label><label class="expand" for="c-36052886">[12 more]</label></div><br/><div class="children"><div class="content">Current file systems are impressive - flexible, robust, close the hardware performance. But I&#x27;m disappointed that we are still using such low level models for our day to day computing. Files = everything is an array of bytes and every program&#x2F;library has to interpret and manage those bytes, &quot;manually&quot;, individually, and slightly differently to other programs!<p>It&#x27;s understandable to use &quot;files&quot; when running retro apps, but it&#x27;s way past time that a high level model rendered the concept of files obsolete.<p>(I can be hopeful but I hold not outlook for such better models. Too many backwards compatible apps and too much depends on our existing code.)</div><br/><div id="36053069" class="c"><input type="checkbox" id="c-36053069" checked=""/><div class="controls bullet"><span class="by">ok_computer</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36054223">next</a><span>|</span><label class="collapse" for="c-36053069">[-]</label><label class="expand" for="c-36053069">[2 more]</label></div><br/><div class="children"><div class="content">I think the simplicity and flexibility and lack of overall framework is the benefit. Dead simple bytes that may or may not be arranged in a way that works with the program you’re trying to open them with. Then build the relational model on top of it.<p>Git’s now out of style and we’re onto ____ but my storage is identical. I used to use flickr but now I dump directly to s3 and my jpgs are indistinguishable.<p>Especially so some consortium of tech companies don’t come up with the next-gen db&#x2F;fs with bolt on features that no one’s asking for and telemetry to improve your file recall experience. Or logging into my fs because I need customization. For instance any modern web app is built with overkill tech that adds complexity because in certain scale uses that is necessary.<p>Give me trees of utf-8 encoded flat files any day. Not nested object relational models of stuff that ages faster than milk.</div><br/><div id="36055441" class="c"><input type="checkbox" id="c-36055441" checked=""/><div class="controls bullet"><span class="by">fmap</span><span>|</span><a href="#36052886">root</a><span>|</span><a href="#36053069">parent</a><span>|</span><a href="#36054223">next</a><span>|</span><label class="collapse" for="c-36055441">[-]</label><label class="expand" for="c-36055441">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think many people are arguing against having arbitrary byte arrays for storage and using application specific serialization formats. The real problem with file systems, imo, is that they present a leaky abstraction over something that&#x27;s internally very complex. Any single operation might look simple, but as soon as you start combining operations you&#x27;re going to have a bad time with edge cases.<p>For example, let&#x27;s say you need to ensure that your writes actually ends up on disk: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;12990180&#x2F;what-does-it-take-to-be-durable-on-linux" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;12990180&#x2F;what-does-it-ta...</a><p>The typical file abstraction introduces buffering on top of this, which adds additional edge cases: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;42434872&#x2F;writing-programs-to-cope-with-i-o-errors-causing-lost-writes-on-linux" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;42434872&#x2F;writing-program...</a><p>If you want ordered writes, then you have to handle this through some kind of journalling or at the application level with something like this: <a href="https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~vijayc&#x2F;papers&#x2F;UWCS-TR-2012-1709.pdf" rel="nofollow">https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~vijayc&#x2F;papers&#x2F;UWCS-TR-2012-1709.p...</a><p>And that&#x27;s only something that&#x27;s visible at the application level. There are plenty of similar edge cases below the surface.<p>Even if all of this works correctly, you still have to remember that very few systems give <i>any</i> guarantees about what data ends up on disk. So you often end up using checksums and&#x2F;or error correcting codes in your files.<p>Finally, all this is really only talking about single files and write operations. As soon as you need to coordinate operations between multiple files (e.g., because you&#x27;re using directories) things become more complicated. If you then want to abuse the file system to do something other than read and write arrays of bytes you will have to deal with operations that are even more broken, e.g., file locking: <a href="http:&#x2F;&#x2F;0pointer.de&#x2F;blog&#x2F;projects&#x2F;locking.html" rel="nofollow">http:&#x2F;&#x2F;0pointer.de&#x2F;blog&#x2F;projects&#x2F;locking.html</a><p>---<p>It&#x27;s not an accident that you are using other services to store your files. For example, S3 handles a lot of the complexity around durable storage for you, but at a massive cost in latency compared to what the underlying hardware is capable of.<p>Similarly, application programmers often end up using embedded databases, for exactly the same reason and with exactly the same problem.<p>This is a shame, because your file system has to solve many of the same problems internally anyway. Metadata is usually guaranteed to be consistent and this is implemented through some sort of journaling system. It&#x27;s just that the file system abstraction does not expose any of this and necessitates a lot of duplicate complexity at the application level.<p>---<p>Edit: After re-reading the grandparent comment, it sounds like they are arguing against the &quot;array of bytes&quot; model. I agree that this is usually not what you want at the application level, but it&#x27;s less clear how to build a different abstraction that can be introduced incrementally. Without incremental adoption such a solution just won&#x27;t work.</div><br/></div></div></div></div><div id="36054223" class="c"><input type="checkbox" id="c-36054223" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36053069">prev</a><span>|</span><a href="#36053037">next</a><span>|</span><label class="collapse" for="c-36054223">[-]</label><label class="expand" for="c-36054223">[1 more]</label></div><br/><div class="children"><div class="content">There are roughly three ways you can look at files.<p>The first is the traditional way: a file is a bag of bytes. Operating systems could do a better job of handling bags of bytes (really, they should default to making sure that the bags of bytes are updated atomically--you either see only the old bag of bytes or the new bag of bytes, never a weird mixture of both), but this is the fundamental view that most APIs tend to expose.<p>The second is a file is a collection of fixed-sized blocks, stored at not-necessarily-contiguous offsets. This is where something like mmap comes into play, or sparse storage files. A lot of higher-level formats actually tend to built on this model, and this tends to be how underlying storage thinks of files.<p>The third is that a file is a collection of data structures. It&#x27;s tempting to think that the OS should expose this view of files natively in its API, but this turns out to be a really bad idea. If you limit it to well-supportable primitives, it&#x27;s too simple for many applications, so they need to build their own serialization logic anyways. Cast too wide a net, and now applications have to worry about representing things they can&#x27;t support. Or you take a third option and have a full serialization&#x2F;deserialization framework that allows custom pluggable things, which is a ticking time bomb for security.</div><br/></div></div><div id="36053037" class="c"><input type="checkbox" id="c-36053037" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36054223">prev</a><span>|</span><a href="#36052962">next</a><span>|</span><label class="collapse" for="c-36053037">[-]</label><label class="expand" for="c-36053037">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;stream of bytes&quot; model is what lead to easy data interchange and interoperability. There were plenty of proprietary &quot;structured file&quot; schemes invented in the past, but (fortunately) none of them seem to have become widespread.</div><br/></div></div><div id="36052962" class="c"><input type="checkbox" id="c-36052962" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36053037">prev</a><span>|</span><a href="#36052946">next</a><span>|</span><label class="collapse" for="c-36052962">[-]</label><label class="expand" for="c-36052962">[1 more]</label></div><br/><div class="children"><div class="content">I agree that where are now is bad, but I also think files could be an answer too.<p>What we saw in 9p was a file orientation as well, but files were much smaller grained structures. We can see various kernel interfaces like &#x2F;proc and &#x2F;sys where we have file structures representing bigger objects too.<p>Rather than use the file system structure, apps have been creating their own structures <i>within</i> files. This obstructs homogenous user access to the data!<p>If we could start to access finer grained data, start to have objects as file-system-trees, I think a lot of progress could be made in computing, especially vis-a-vie the rifts of human-computer-interaction. It would give us leverage to see &amp; work the data, broadly. Rather than facing endless different opaque streams of bytes.</div><br/></div></div><div id="36052946" class="c"><input type="checkbox" id="c-36052946" checked=""/><div class="controls bullet"><span class="by">cmiller1</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36052962">prev</a><span>|</span><a href="#36054398">next</a><span>|</span><label class="collapse" for="c-36052946">[-]</label><label class="expand" for="c-36052946">[2 more]</label></div><br/><div class="children"><div class="content">Are you proposing something similar to the Apple Newton Soup? <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Soup_(Apple)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Soup_(Apple)</a></div><br/><div id="36053446" class="c"><input type="checkbox" id="c-36053446" checked=""/><div class="controls bullet"><span class="by">arsome</span><span>|</span><a href="#36052886">root</a><span>|</span><a href="#36052946">parent</a><span>|</span><a href="#36054398">next</a><span>|</span><label class="collapse" for="c-36053446">[-]</label><label class="expand" for="c-36053446">[1 more]</label></div><br/><div class="children"><div class="content">Or perhaps WinFS?<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;WinFS" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;WinFS</a></div><br/></div></div></div></div><div id="36054398" class="c"><input type="checkbox" id="c-36054398" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36052946">prev</a><span>|</span><a href="#36053237">next</a><span>|</span><label class="collapse" for="c-36054398">[-]</label><label class="expand" for="c-36054398">[1 more]</label></div><br/><div class="children"><div class="content">In some mainframes and micros, the filesystem is based on database model, there are no files.</div><br/></div></div><div id="36053237" class="c"><input type="checkbox" id="c-36053237" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36054398">prev</a><span>|</span><a href="#36053289">next</a><span>|</span><label class="collapse" for="c-36053237">[-]</label><label class="expand" for="c-36053237">[1 more]</label></div><br/><div class="children"><div class="content">I think the closest thing to what you are looking for is SQLite.<p>It is basically designed to be an fopen replacement. It is designed to be robust. The relational model is very flexible. It provides great interoperability and backwards compatibility.</div><br/></div></div><div id="36053289" class="c"><input type="checkbox" id="c-36053289" checked=""/><div class="controls bullet"><span class="by">throwawaylinux</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36053237">prev</a><span>|</span><a href="#36054488">next</a><span>|</span><label class="collapse" for="c-36053289">[-]</label><label class="expand" for="c-36053289">[1 more]</label></div><br/><div class="children"><div class="content">Most technology is able to do useful things by building layers of simpler things.<p>Files are not sequences of bytes in day to day computing. They are videos, or databases, or applications. Actually a lot of the time you&#x27;ll be doing your day to day computing, thousands of files are being accessed and you wouldn&#x27;t even know it.</div><br/></div></div><div id="36054488" class="c"><input type="checkbox" id="c-36054488" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36052886">parent</a><span>|</span><a href="#36053289">prev</a><span>|</span><label class="collapse" for="c-36054488">[-]</label><label class="expand" for="c-36054488">[1 more]</label></div><br/><div class="children"><div class="content">this is the same thinking that gave us the &#x27;advanced intelligent network&#x27;<p><i>current ip networks are impressive - flexible, robust, close to line speed. but i&#x27;m disappointed that we are still using such low level models for our day to day computing.  tcp&#x2F;ip = everything is a sequence of packets and every computer has to interpret and manage those packets, &#x27;manually&#x27;, individually, and slightly differently than other computers do!</i><p><i>it&#x27;s understandable to use &#x27;packets&#x27; when running retro apps, but it&#x27;s way past time that a high-level model rendered the concept of packets obsolete</i><p>that&#x27;s not a quote from a pre-stupid-network bellhead 25 years ago but it could have been<p>or the intel iapx432<p><i>current cpu architectures are impressive - flexible, robust, with impressive performance. but i&#x27;m disappointed that we are still using such low level models for our day to day computing.  8086 = everything is a sequence of computations on 16-bit integers and every program&#x2F;library has to interpret and manage those 16-bit integers, &#x27;manually&#x27;, individually, and slightly differently than other programs do!</i><p><i>it&#x27;s understandable to use &#x27;16-bit words&#x27; when running retro apps, but it&#x27;s way past time that a high-level model rendered the concept of untyped words obsolete</i><p>in fact file storage forms the same sort of nexus as the rest of the posix system call interface, the 8086 instruction set, ip packets, bytes, and dollars: many things can store files fairly efficiently, and many things can use them for many different purposes, and the nexus permits those things to evolve independently with minimal coupling to one another<p>(there are many ways the posix concept of files could be improved, which is also true of 8086)<p>if we want to replace files with a better storage interface, it should probably be something dumber rather than something smarter<p>&#x27;it&#x27;s done in the os so it&#x27;s simple&#x27; is the same kind of cognitive error as &#x27;it&#x27;s done in the hardware so it&#x27;s cheap&#x27; <a href="https:&#x2F;&#x2F;yosefk.com&#x2F;blog&#x2F;its-done-in-hardware-so-its-cheap.html" rel="nofollow">https:&#x2F;&#x2F;yosefk.com&#x2F;blog&#x2F;its-done-in-hardware-so-its-cheap.ht...</a> (though see <a href="https:&#x2F;&#x2F;blog.cr.yp.to&#x2F;20190430-vectorize.html" rel="nofollow">https:&#x2F;&#x2F;blog.cr.yp.to&#x2F;20190430-vectorize.html</a> for some 02019 updates on the relative costs of things like dispatching and floating point)<p>actual good systems design amounts to more than &#x27;move the problem somewhere where i don&#x27;t understand what&#x27;s involved in solving it anymore&#x27;</div><br/></div></div></div></div></div></div></div></div></div></body></html>