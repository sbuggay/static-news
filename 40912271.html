<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720688470030" as="style"/><link rel="stylesheet" href="styles.css?v=1720688470030"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing">Real-time audio programming 101: time waits for nothing</a> <span class="domain">(<a href="http://www.rossbencina.com">www.rossbencina.com</a>)</span></div><div class="subtext"><span>ssfrr</span> | <span>84 comments</span></div><br/><div><div id="40929725" class="c"><input type="checkbox" id="c-40929725" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#40930246">next</a><span>|</span><label class="collapse" for="c-40929725">[-]</label><label class="expand" for="c-40929725">[41 more]</label></div><br/><div class="children"><div class="content">(2011) But a great summary and mostly evergreen<p>One practical reality it doesn&#x27;t share is that your audio processing (or generation) code is often going to be running in a bus shared by a ton of other modules and so you don&#x27;t have the luxury of using &quot;5.6ms&quot; as your deadline for a 5.6ms buffer. Your responsibility, often, is to just get as performant as reasonably possible so that <i>everything</i> on the bus can be processed in those 5.6ms. The pressure is usually much higher than the buffer length suggests.</div><br/><div id="40934628" class="c"><input type="checkbox" id="c-40934628" checked=""/><div class="controls bullet"><span class="by">empiricus</span><span>|</span><a href="#40929725">parent</a><span>|</span><a href="#40931294">next</a><span>|</span><label class="collapse" for="c-40934628">[-]</label><label class="expand" for="c-40934628">[2 more]</label></div><br/><div class="children"><div class="content">Notice that games are often able to render each frame in 5ms: which in practice means run multiple short programs for each pixel you see on the 4k screen. So modern computers are able to do huge huge amount of computation in 5ms (in the order of 10^10 flops, 10^8 bytes). If puny kilobytes of audio data cannot be processed in 5ms it means things are terribly wrong.</div><br/><div id="40934773" class="c"><input type="checkbox" id="c-40934773" checked=""/><div class="controls bullet"><span class="by">lomase</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40934628">parent</a><span>|</span><a href="#40931294">next</a><span>|</span><label class="collapse" for="c-40934773">[-]</label><label class="expand" for="c-40934773">[1 more]</label></div><br/><div class="children"><div class="content">The GPU is able to paralelizes the drawing of each pixel.</div><br/></div></div></div></div><div id="40931294" class="c"><input type="checkbox" id="c-40931294" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#40929725">parent</a><span>|</span><a href="#40934628">prev</a><span>|</span><a href="#40931147">next</a><span>|</span><label class="collapse" for="c-40931294">[-]</label><label class="expand" for="c-40931294">[2 more]</label></div><br/><div class="children"><div class="content">In the context of the article, I assume that the driver has arranged sufficient buffering so that the jitter in scheduling across a bus (PCI, USB) is masked with respect to the client code. But you are correct that communications overhead can cut into your compute time if it is not addressed. Some audio APIs (e.g. CoreAudio) allow for configuring the buffering margins, so you can trade off buffer latency against available audio compute %. There is a whole world of debate surrounding how to best schedule audio compute (e.g. interrupt driven vs. delay-locked high precision timers).<p>Assuming the context is a desktop OS (which is the context of TFA), I think that the main source of non-determinism is scheduling jitter (the time between the ideal start of your computation, and the time when the OS gives you the CPU to start the computation). Of course if you can&#x27;t arrange exclusive or max-priority access to a CPU core you&#x27;re also going to be competing with other processes. Then there is non-deterministic execution time on most modern CPUs due to cache timing effects, superscalar out of order instruction scheduling, inter-core synchronisation, and so on. So yeah, you&#x27;re going to need some margin unless you&#x27;re on dedicated hardware with deterministic compute (e.g. a DSP chip).</div><br/><div id="40931549" class="c"><input type="checkbox" id="c-40931549" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931294">parent</a><span>|</span><a href="#40931147">next</a><span>|</span><label class="collapse" for="c-40931549">[-]</label><label class="expand" for="c-40931549">[1 more]</label></div><br/><div class="children"><div class="content">No, I&#x27;m just talking about the common case where you have some other stuff going on before or after your own audio processing code: a software instrument your framework provides, some AudioUnits or gstreamer nodes adding other effects, the whole device chain in the DAW that&#x27;s hosting you, etc. <i>All</i> of those things need to get done within your window so you can&#x27;t use the whole thing for yourself.<p>Most people learning audio programming aren&#x27;t making a standalone audio app where they do all the processing, or at least not an interesting one. They&#x27;re usually either making something like a plugin that ends up in somebody else&#x27;s bus&#x2F;graph, or something like a game or application that creates a bus&#x2F;graph and shoves a bunch of different stuff into it.</div><br/></div></div></div></div><div id="40931147" class="c"><input type="checkbox" id="c-40931147" checked=""/><div class="controls bullet"><span class="by">ssfrr</span><span>|</span><a href="#40929725">parent</a><span>|</span><a href="#40931294">prev</a><span>|</span><a href="#40933948">next</a><span>|</span><label class="collapse" for="c-40931147">[-]</label><label class="expand" for="c-40931147">[28 more]</label></div><br/><div class="children"><div class="content">Definitely good to keep in mind. The thing that I think is really interesting about audio programming is that you need to be <i>deterministically</i> fast. If your DSP callback executes in 1ms 99.99% of the time but sometimes takes 10ms, you’re hosed.<p>I would love to see a modern take on the real-world risk of various operations that are technically nondeterministic. I wouldn’t be surprised if there are cases where the risk of &gt;1ms latency is like 1e-30, and dogmatically following this advice might be overkill.</div><br/><div id="40931880" class="c"><input type="checkbox" id="c-40931880" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931147">parent</a><span>|</span><a href="#40931630">next</a><span>|</span><label class="collapse" for="c-40931880">[-]</label><label class="expand" for="c-40931880">[2 more]</label></div><br/><div class="children"><div class="content">&gt; dogmatically following this advice might be overkill<p>It depends on your appetite for risk and the cost of failure.<p>A big part of the problem is that general purpose computing systems (operating systems and hardware) are not engineered as real-time systems and there are rarely vendor guarantees with respect to real-time behavior. Under such circumstances, my position is that you need to code defensively. For example, if your operating system memory allocator does not guarantee a worst-case bound on execution time, do not use it in a real-time context.</div><br/><div id="40933346" class="c"><input type="checkbox" id="c-40933346" checked=""/><div class="controls bullet"><span class="by">ssfrr</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931880">parent</a><span>|</span><a href="#40931630">next</a><span>|</span><label class="collapse" for="c-40933346">[-]</label><label class="expand" for="c-40933346">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mean to devalue the advice here. I think it&#x27;s spot on, and I unreservedly recommend this article to folks who want to learn about writing reliable audio software.<p>I think in essence I&#x27;m repeating the comments of Justin from Cockos, which you summarize [1]:<p>&gt; It is basically saying that you can reduce the risk of priority inversion to the point where the probability is too low to worry about.<p>In that comment you also say:<p>&gt; 100% certainty can’t be guaranteed without a hard real-time OS. However 5ms is now considered a relatively high latency setting in pro&#x2F;prosumer audio circles<p>Which I interpret as acknowledging that we&#x27;re already forced into the regime of establishing an acceptable level of risk.<p>My point is that I would love to see more data on the actual latency distributions we can expect, so that we can make more informed risk assessments. For example, I know that not all `std::atomic` operations are lock-free, but when the critical section is so small, is it really a problem in practice? I want histograms!<p>[1]: <a href="http:&#x2F;&#x2F;www.rossbencina.com&#x2F;code&#x2F;real-time-audio-programming-101-time-waits-for-nothing#comment-87" rel="nofollow">http:&#x2F;&#x2F;www.rossbencina.com&#x2F;code&#x2F;real-time-audio-programming-...</a></div><br/></div></div></div></div><div id="40931630" class="c"><input type="checkbox" id="c-40931630" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931147">parent</a><span>|</span><a href="#40931880">prev</a><span>|</span><a href="#40932582">next</a><span>|</span><label class="collapse" for="c-40931630">[-]</label><label class="expand" for="c-40931630">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If your DSP callback executes in 1ms 99.99% of the time but sometimes takes 10ms, you’re hosed.<p>I tend to agree, but...<p>From my recollection of using Zoom-- it has this bizarre but workable recovery method for network interruptions. Either the server or the client keeps some amount of the last input audio in a buffer. Then if the server detects connection problems at time &#x27;t&#x27;, it grabs the buffer from t - 1 seconds all the way until the server detects better connectivity. Then it starts a race condition, playing back that amount of the buffer to all clients at something like 1.5 speed. From what I remember, this algo typically wins the race and saves the client from having to repeat themselves.<p>That&#x27;s not happening inside a DSP routine. But my point is that some clever engineer(s) at Zoom realized that missing deadlines in audio delivery does not <i>necessarily</i> mean &quot;hosed.&quot; I&#x27;m also going to rankly speculate that every other video conferencing tool hard-coupled missing deadlines with &quot;hosed,&quot; and that&#x27;s why Zoom is the only one where I&#x27;ve ever experienced the benefit of that feature.</div><br/><div id="40932116" class="c"><input type="checkbox" id="c-40932116" checked=""/><div class="controls bullet"><span class="by">ssfrr</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931630">parent</a><span>|</span><a href="#40932582">next</a><span>|</span><label class="collapse" for="c-40932116">[-]</label><label class="expand" for="c-40932116">[3 more]</label></div><br/><div class="children"><div class="content">The context for this article is writing pro audio software, where that kind of distortion would generally be as bad as a dropout, if not worse.</div><br/><div id="40932706" class="c"><input type="checkbox" id="c-40932706" checked=""/><div class="controls bullet"><span class="by">wizardforhire</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40932116">parent</a><span>|</span><a href="#40932582">next</a><span>|</span><label class="collapse" for="c-40932706">[-]</label><label class="expand" for="c-40932706">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, 5ms is the threshold for noticeability as far as latency in pro-audio. Its like frame-rate for pro-gamers. The problem is your target user is highly specialized out side the the norms by a large margin. What makes audio even more difficult is that sub ms issues can cause phase and frequency distortion that can become even more noticeable than latency alone.</div><br/><div id="40933675" class="c"><input type="checkbox" id="c-40933675" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40932706">parent</a><span>|</span><a href="#40932582">next</a><span>|</span><label class="collapse" for="c-40933675">[-]</label><label class="expand" for="c-40933675">[1 more]</label></div><br/><div class="children"><div class="content">1. you do not need to be a highly specialized target user to detect latency between pressing a key on a MIDI keyboard and the corresponding sound being produced.<p>2. 3ms is typical in-air latency between a typical DAW user and their near-field monitors, so claims about sensitivity to times much lower than 5msec should be taken with some skepticism<p>3. In live contexts, many drum + bass pairings have more than 10ms of air latency between them, so ditto #2<p>4. On the other hand, no good reason to add to latency<p>5. For performance purposes, jitter is much worse than latency. Pipe organ players rapidly learn to deal with even whole seconds of latency, but almost nobody can deal with jitter (essentially, variable, unpredictable latency)<p>6. There are no sub-ms issues that will cause phase and frequency distortion. Those come from DSP errors, not handling of latency, which is just about always a constant, fixed feature of the data signal path. You may be thinking of stuff like comb filtering, but this is not related to the latency in the signal path in a correct setup.</div><br/></div></div></div></div></div></div></div></div><div id="40932582" class="c"><input type="checkbox" id="c-40932582" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931147">parent</a><span>|</span><a href="#40931630">prev</a><span>|</span><a href="#40931479">next</a><span>|</span><label class="collapse" for="c-40932582">[-]</label><label class="expand" for="c-40932582">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know. When it comes to real-time audio... imagine a huge festival with a giant wall of speakers blasting at the audience. If the audio playback glitches and you something like a 22kHz buzz (alternating two samples), that is a lot of fried ears.</div><br/><div id="40933426" class="c"><input type="checkbox" id="c-40933426" checked=""/><div class="controls bullet"><span class="by">ssfrr</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40932582">parent</a><span>|</span><a href="#40932767">next</a><span>|</span><label class="collapse" for="c-40933426">[-]</label><label class="expand" for="c-40933426">[1 more]</label></div><br/><div class="children"><div class="content">But you&#x27;ll never be 100% sure. Most musicians aren&#x27;t willing to pay for NASA-level QA and custom hardware running an RTOS, and even <i>that</i> doesn&#x27;t guarantee perfect software.<p>We&#x27;re always dealing with risk and trade-offs. Maybe you avoid a locking `atomic` synchronization point by implementing a more complicated lock-free ringbuffer, but in the process you introduce some other bug that has you dumping uninitialized memory into the DAC.<p>I think the advice in TFA is totally reasonable and worth following. I&#x27;m just saying that there may be cases where it&#x27;s OK to violate some of these rules. I&#x27;d love to see more data to help inform those decisions.<p>This isn&#x27;t even in opposition to the article, which says explicitly:<p>&gt;Some low-level audio libraries such as JACK or CoreAudio use these techniques internally, but you need to be sure you know what you’re doing, that you understand your thread priorities and the exact scheduler behavior on each target operating system (and OS kernel version). Don’t extrapolate or make assumptions</div><br/></div></div><div id="40932767" class="c"><input type="checkbox" id="c-40932767" checked=""/><div class="controls bullet"><span class="by">wizardforhire</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40932582">parent</a><span>|</span><a href="#40933426">prev</a><span>|</span><a href="#40931479">next</a><span>|</span><label class="collapse" for="c-40932767">[-]</label><label class="expand" for="c-40932767">[4 more]</label></div><br/><div class="children"><div class="content">This scenario is the stuff of nightmares for me!<p>When you have 100k people paying $500 to the sky is the limit, failure is not an option. Increasingly audio engineers and subsequently performers are at the mercy of the latest jr developers who don’t have to live with the failures of their short sightedness. Grimes’ Coachella set case in point. Wholly due to pioneer ignoring their  users for over a decade. Sometimes we don’t have 3 days to copy files to a usb drive but I digress.</div><br/><div id="40933649" class="c"><input type="checkbox" id="c-40933649" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40932767">parent</a><span>|</span><a href="#40933979">next</a><span>|</span><label class="collapse" for="c-40933649">[-]</label><label class="expand" for="c-40933649">[2 more]</label></div><br/><div class="children"><div class="content">Apparently, failure <i>was</i> an option. Just not a very popular one.</div><br/><div id="40933961" class="c"><input type="checkbox" id="c-40933961" checked=""/><div class="controls bullet"><span class="by">fxtentacle</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40933649">parent</a><span>|</span><a href="#40933979">next</a><span>|</span><label class="collapse" for="c-40933961">[-]</label><label class="expand" for="c-40933961">[1 more]</label></div><br/><div class="children"><div class="content">Grimes failure was still pleasant when you compare it to the mayhem you get when the DSP inside the amplifier system glitches for a few samples.<p>What do you think happens a dense crowd of 500+ people suddenly starts to have excruciating ear pain?</div><br/></div></div></div></div><div id="40933979" class="c"><input type="checkbox" id="c-40933979" checked=""/><div class="controls bullet"><span class="by">alanbernstein</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40932767">parent</a><span>|</span><a href="#40933649">prev</a><span>|</span><a href="#40931479">next</a><span>|</span><label class="collapse" for="c-40933979">[-]</label><label class="expand" for="c-40933979">[1 more]</label></div><br/><div class="children"><div class="content">Heh, I thought it was odd you referenced a ten year old show, but I guess she made a similar mistake twice. Her 2014 Coachella set was a total mess.</div><br/></div></div></div></div></div></div><div id="40931479" class="c"><input type="checkbox" id="c-40931479" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931147">parent</a><span>|</span><a href="#40932582">prev</a><span>|</span><a href="#40931459">next</a><span>|</span><label class="collapse" for="c-40931479">[-]</label><label class="expand" for="c-40931479">[1 more]</label></div><br/><div class="children"><div class="content">&gt; deterministically fast<p>Indeed, like all real-time systems you need to think in terms of worst-case time complexity, not amortized complexity.</div><br/></div></div><div id="40931459" class="c"><input type="checkbox" id="c-40931459" checked=""/><div class="controls bullet"><span class="by">rzzzt</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931147">parent</a><span>|</span><a href="#40931479">prev</a><span>|</span><a href="#40931255">next</a><span>|</span><label class="collapse" for="c-40931459">[-]</label><label class="expand" for="c-40931459">[3 more]</label></div><br/><div class="children"><div class="content">Use of Ethernet in real-time systems. Packet loss, collision rate, jitter is &quot;&quot;&quot;good enough&quot;&quot;&quot; so it became an acceptable replacement of eg. ATM.</div><br/><div id="40933897" class="c"><input type="checkbox" id="c-40933897" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931459">parent</a><span>|</span><a href="#40932117">next</a><span>|</span><label class="collapse" for="c-40933897">[-]</label><label class="expand" for="c-40933897">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Most modern Ethernet isn&#x27;t running on shared media (i.e. there are no collisions) and for the most part no packet loss as long as there&#x27;s no congestion. For networks and for the CPU, when you&#x27;re fast enough the jitter matters less, if the cpu or the network &quot;takes a break&quot; (from the application perspective), it tends to be a very short break on really fast networks or cpus. e.g. if a packet gets in front of you in 10Mbps Ethernet that&#x27;s a big deal for an audio application but a packet ahead of you in 10Gbps Ethernet isn&#x27;t much of a delay for audio. 1ms vs. 1us sort of thing.<p>[fixed typo]</div><br/></div></div><div id="40932117" class="c"><input type="checkbox" id="c-40932117" checked=""/><div class="controls bullet"><span class="by">lukeh</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931459">parent</a><span>|</span><a href="#40933897">prev</a><span>|</span><a href="#40931255">next</a><span>|</span><label class="collapse" for="c-40932117">[-]</label><label class="expand" for="c-40932117">[1 more]</label></div><br/><div class="children"><div class="content">Or you use AVB&#x2F;TSN which gives you stronger guarantees, but requires cooperation of all bridges (switches).</div><br/></div></div></div></div><div id="40931255" class="c"><input type="checkbox" id="c-40931255" checked=""/><div class="controls bullet"><span class="by">varispeed</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931147">parent</a><span>|</span><a href="#40931459">prev</a><span>|</span><a href="#40933948">next</a><span>|</span><label class="collapse" for="c-40931255">[-]</label><label class="expand" for="c-40931255">[11 more]</label></div><br/><div class="children"><div class="content">The real fun is optimising maths. Remove all divisions. Create LUTs, approximations, CPU specific tricks. Despite the fact CPUs are magnitudes faster now, they are still slow for real time processing.</div><br/><div id="40933678" class="c"><input type="checkbox" id="c-40933678" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931255">parent</a><span>|</span><a href="#40933915">next</a><span>|</span><label class="collapse" for="c-40933678">[-]</label><label class="expand" for="c-40933678">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Create LUTs<p>This has been slower for most things that raw computation for well over a decade (probably more like two).</div><br/><div id="40933819" class="c"><input type="checkbox" id="c-40933819" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40933678">parent</a><span>|</span><a href="#40933915">next</a><span>|</span><label class="collapse" for="c-40933819">[-]</label><label class="expand" for="c-40933819">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, isn’t hitting memory (especially if it can’t fit in L1-2 cache) one of the biggest sources of latency? Especially that on modern CPUs it is almost impossible to max out the arithmetic units, outside of microbenchmarks?</div><br/></div></div></div></div><div id="40933915" class="c"><input type="checkbox" id="c-40933915" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931255">parent</a><span>|</span><a href="#40933678">prev</a><span>|</span><a href="#40933957">next</a><span>|</span><label class="collapse" for="c-40933915">[-]</label><label class="expand" for="c-40933915">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t really do these any more on a modern CPU. This is stuff I used to do 30 years ago and you might still do if you&#x27;re on a micro-controller or some other tiny system. The CPUs aren&#x27;t slow. Tne main problem is if the OS doesn&#x27;t schedule your process it doesn&#x27;t matter how fast the CPU is.</div><br/></div></div><div id="40933957" class="c"><input type="checkbox" id="c-40933957" checked=""/><div class="controls bullet"><span class="by">Derbasti</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931255">parent</a><span>|</span><a href="#40933915">prev</a><span>|</span><a href="#40931670">next</a><span>|</span><label class="collapse" for="c-40933957">[-]</label><label class="expand" for="c-40933957">[1 more]</label></div><br/><div class="children"><div class="content">This is great fun! But it&#x27;s much more prevalent in embedded DSP than desktop.</div><br/></div></div><div id="40931670" class="c"><input type="checkbox" id="c-40931670" checked=""/><div class="controls bullet"><span class="by">kdjdjjz</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931255">parent</a><span>|</span><a href="#40933957">prev</a><span>|</span><a href="#40933948">next</a><span>|</span><label class="collapse" for="c-40931670">[-]</label><label class="expand" for="c-40931670">[6 more]</label></div><br/><div class="children"><div class="content">Real time does not mean fast, it means deterministic<p>Thus such micro optimizations are seldomly used. Quite the opposite, you try to avoid jitter which could be the result of caches</div><br/><div id="40931898" class="c"><input type="checkbox" id="c-40931898" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931670">parent</a><span>|</span><a href="#40933679">next</a><span>|</span><label class="collapse" for="c-40931898">[-]</label><label class="expand" for="c-40931898">[2 more]</label></div><br/><div class="children"><div class="content">While real-time does not mean fast, micro optimisations are frequently used. No one likes slow DSP audio software.</div><br/><div id="40932565" class="c"><input type="checkbox" id="c-40932565" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931898">parent</a><span>|</span><a href="#40933679">next</a><span>|</span><label class="collapse" for="c-40932565">[-]</label><label class="expand" for="c-40932565">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; No one likes slow DSP audio software.</i><p>And then there&#x27;s Diva at its highest output quality setting... :)</div><br/></div></div></div></div><div id="40933679" class="c"><input type="checkbox" id="c-40933679" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931670">parent</a><span>|</span><a href="#40931898">prev</a><span>|</span><a href="#40933948">next</a><span>|</span><label class="collapse" for="c-40933679">[-]</label><label class="expand" for="c-40933679">[3 more]</label></div><br/><div class="children"><div class="content">Jitter does not matter if deadlines are met. It only matters if it can cause deadlines to be missed (sometimes).</div><br/><div id="40933938" class="c"><input type="checkbox" id="c-40933938" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40933679">parent</a><span>|</span><a href="#40933948">next</a><span>|</span><label class="collapse" for="c-40933938">[-]</label><label class="expand" for="c-40933938">[2 more]</label></div><br/><div class="children"><div class="content">If you have a buffer that&#x27;s being clocked out and your goal is to keep data flowing, the jitter is going to influence how small your buffer can be. Let&#x27;s say you&#x27;re producing 56Khz audio, the best you can do is produce a [sample] exactly at that frequency. If you have 1ms jitter now you need a 1ms buffer so you have delay. If jitter is small enough, like 0.1ns jitter in some SIMD calculation, then for all intent and purpose it doesn&#x27;t matter for an audio application...</div><br/><div id="40934094" class="c"><input type="checkbox" id="c-40934094" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40933938">parent</a><span>|</span><a href="#40933948">next</a><span>|</span><label class="collapse" for="c-40934094">[-]</label><label class="expand" for="c-40934094">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve just restated my point. If the deadlines are met, jitter doesn&#x27;t matter. Ergo, you can&#x27;t meet deadlines if your jitter is too large. Otherwise, it doesn&#x27;t matter.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40933948" class="c"><input type="checkbox" id="c-40933948" checked=""/><div class="controls bullet"><span class="by">Derbasti</span><span>|</span><a href="#40929725">parent</a><span>|</span><a href="#40931147">prev</a><span>|</span><a href="#40930220">next</a><span>|</span><label class="collapse" for="c-40933948">[-]</label><label class="expand" for="c-40933948">[1 more]</label></div><br/><div class="children"><div class="content">When I was working on desktop audio software, our rule of thumb was to keep CPU occupancy below 30%. More than that, and you&#x27;d be sure to get hitching in your audio stream. (This factors in thread contention, other background tasks stealing CPU cycles, file system pauses...)<p>A much different experience from embedded programming, where 99% occupancy is no problem at all.</div><br/></div></div><div id="40930220" class="c"><input type="checkbox" id="c-40930220" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#40929725">parent</a><span>|</span><a href="#40933948">prev</a><span>|</span><a href="#40930246">next</a><span>|</span><label class="collapse" for="c-40930220">[-]</label><label class="expand" for="c-40930220">[7 more]</label></div><br/><div class="children"><div class="content">What do you mean by &quot;bus&quot; and &quot;module&quot; in this context?</div><br/><div id="40930354" class="c"><input type="checkbox" id="c-40930354" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40930220">parent</a><span>|</span><a href="#40930298">next</a><span>|</span><label class="collapse" for="c-40930354">[-]</label><label class="expand" for="c-40930354">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Bus&quot; (as I was using it) is the path from some audio source to some audio destination and a &quot;module&quot; (as used) would be something that takes a buffer of samples on that bus and does something with it.<p>You might <i>sometimes</i> build an app where (through your operating system) you connect directly with an input device and&#x2F;or output device and then do all the audio processing yourself. In this case, you&#x27;d more or less control the whole bus and all the code processing samples on it and have a <i>fairly</i> true sense of your deadline. (The OS and drivers would still be introducing some overhead for mixing or resampling, etc, but that&#x27;s generally of small concern and hard to avoid)<p>Often, though, you&#x27;re either going to be building a bus and applying your own effects <i>and some others</i> (from your OS, from team members, from third party plugins&#x2F;libraries, etc) or you&#x27;re going to be writing some kind of effect&#x2F;generator that gets inserted into somebody else&#x27;s bus in something like a DAW or game. In all these cases, you need to assume that all processing code that <i>isn&#x27;t</i> yours needs all the time that you can leave for it and just make your own code as efficient as is reasonable.</div><br/><div id="40930811" class="c"><input type="checkbox" id="c-40930811" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40930354">parent</a><span>|</span><a href="#40931544">next</a><span>|</span><label class="collapse" for="c-40930811">[-]</label><label class="expand" for="c-40930811">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for clarifying. The terms are highly ambigious (see the sibling answer <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40930298">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40930298</a>), that&#x27;s why I asked. Personally, I would rather use the terms &quot;audio pipeline&quot; or &quot;audio graph&quot; instead of the generic &quot;bus&quot;.<p>&gt;  In all these cases, you need to assume that all processing code that isn&#x27;t yours needs all the time that you can leave for it and just make your own code as efficient as is reasonable.<p>Yes. For audio programmers that is obvious, in particular when it comes to plugins, but for novices it might be worth pointing out!</div><br/></div></div><div id="40931544" class="c"><input type="checkbox" id="c-40931544" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40930354">parent</a><span>|</span><a href="#40930811">prev</a><span>|</span><a href="#40930298">next</a><span>|</span><label class="collapse" for="c-40931544">[-]</label><label class="expand" for="c-40931544">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You might sometimes build an app where (through your operating system) you connect directly with an input device and&#x2F;or output device and then do all the audio processing yourself.<p>In case it is not clear, that is the primary case that is addressed by the linked blog post (source: I wrote the blog post).</div><br/><div id="40931579" class="c"><input type="checkbox" id="c-40931579" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40931544">parent</a><span>|</span><a href="#40930298">next</a><span>|</span><label class="collapse" for="c-40931579">[-]</label><label class="expand" for="c-40931579">[1 more]</label></div><br/><div class="children"><div class="content">And likewise: in case it wasn&#x27;t clear, it&#x27;s a great article! I wasn&#x27;t meaning to criticize it, just add a little further perspective for the common scenario that many first-time audio programming folks encounter.</div><br/></div></div></div></div></div></div><div id="40930298" class="c"><input type="checkbox" id="c-40930298" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40930220">parent</a><span>|</span><a href="#40930354">prev</a><span>|</span><a href="#40930246">next</a><span>|</span><label class="collapse" for="c-40930298">[-]</label><label class="expand" for="c-40930298">[2 more]</label></div><br/><div class="children"><div class="content">A module is a piece of software or hardware which is independent in some way.<p>A bus is a shared medium of communication[1]. Often, busses are time-division multiplexed[2], so if you want to use the bus, but another module is already using it, you need to wait.<p>For example, if your audio buffers are ultimately submitted to a sound card over a PCI bus, the submission may need to wait for any ongoing transactions on the PCI bus, such as messages to a graphics card.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bus_(computing)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bus_(computing)</a><p>[2]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Time-division_multiplexing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Time-division_multiplexing</a></div><br/><div id="40930827" class="c"><input type="checkbox" id="c-40930827" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#40929725">root</a><span>|</span><a href="#40930298">parent</a><span>|</span><a href="#40930246">next</a><span>|</span><label class="collapse" for="c-40930827">[-]</label><label class="expand" for="c-40930827">[1 more]</label></div><br/><div class="children"><div class="content">That is one possible interpretation, but not what they meant. That&#x27;s why I asked because I wasn&#x27;t sure :)</div><br/></div></div></div></div></div></div></div></div><div id="40930246" class="c"><input type="checkbox" id="c-40930246" checked=""/><div class="controls bullet"><span class="by">chaosprint</span><span>|</span><a href="#40929725">prev</a><span>|</span><a href="#40933685">next</a><span>|</span><label class="collapse" for="c-40930246">[-]</label><label class="expand" for="c-40930246">[5 more]</label></div><br/><div class="children"><div class="content">Great resource! For those interested in learning the fundamentals of audio programming, I highly recommend starting with Rust.<p>the cpal library in Rust is excellent for developing cross-platform desktop applications. I&#x27;m currently maintaining this library:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;chaosprint&#x2F;asak">https:&#x2F;&#x2F;github.com&#x2F;chaosprint&#x2F;asak</a><p>It&#x27;s a cross-platform audio recording&#x2F;playback CLI tool with TUI. The source code is very simple to read. PRs are welcomed and I really hope Linux users can help to test and review new PRs :)<p>When developing Glicol(<a href="https:&#x2F;&#x2F;glicol.org" rel="nofollow">https:&#x2F;&#x2F;glicol.org</a>), I documented my experience of &quot;fighting&quot; with real-time audio in the browser in this paper:<p><a href="https:&#x2F;&#x2F;webaudioconf.com&#x2F;_data&#x2F;papers&#x2F;pdf&#x2F;2021&#x2F;2021_8.pdf" rel="nofollow">https:&#x2F;&#x2F;webaudioconf.com&#x2F;_data&#x2F;papers&#x2F;pdf&#x2F;2021&#x2F;2021_8.pdf</a><p>Throughout the process, Paul Adenot&#x27;s work was immensely helpful. I highly recommend his blog:<p><a href="https:&#x2F;&#x2F;blog.paul.cx&#x2F;post&#x2F;profiling-firefox-real-time-media-workloads&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.paul.cx&#x2F;post&#x2F;profiling-firefox-real-time-media-...</a><p>I am currently writing a wasm audio module system, and hope to publish it here soon.</div><br/><div id="40934453" class="c"><input type="checkbox" id="c-40934453" checked=""/><div class="controls bullet"><span class="by">smj-edison</span><span>|</span><a href="#40930246">parent</a><span>|</span><a href="#40933249">next</a><span>|</span><label class="collapse" for="c-40934453">[-]</label><label class="expand" for="c-40934453">[1 more]</label></div><br/><div class="children"><div class="content">I have mixed feelings on cpal: on the one hand, it&#x27;s been really wonderful to have a library that just works on different platforms. On the other hand, it&#x27;s an absolute pain in the butt for doing anything simple. I really wish it would have a simple interface for when I&#x27;m only worried about floating point data (I ended up creating my own library to wrap cpal&#x27;s idiosyncrasies for my mixed midi&#x2F;audio node program: <a href="https:&#x2F;&#x2F;github.com&#x2F;smj-edison&#x2F;clocked">https:&#x2F;&#x2F;github.com&#x2F;smj-edison&#x2F;clocked</a>).</div><br/></div></div><div id="40933249" class="c"><input type="checkbox" id="c-40933249" checked=""/><div class="controls bullet"><span class="by">dmix</span><span>|</span><a href="#40930246">parent</a><span>|</span><a href="#40934453">prev</a><span>|</span><a href="#40930758">next</a><span>|</span><label class="collapse" for="c-40933249">[-]</label><label class="expand" for="c-40933249">[2 more]</label></div><br/><div class="children"><div class="content">Is there a good &quot;toolbox&quot; style cli for audio? Like pitch shifting and time stretching etc</div><br/><div id="40933885" class="c"><input type="checkbox" id="c-40933885" checked=""/><div class="controls bullet"><span class="by">jim-jim-jim</span><span>|</span><a href="#40930246">root</a><span>|</span><a href="#40933249">parent</a><span>|</span><a href="#40930758">next</a><span>|</span><label class="collapse" for="c-40933885">[-]</label><label class="expand" for="c-40933885">[1 more]</label></div><br/><div class="children"><div class="content">sox</div><br/></div></div></div></div><div id="40930758" class="c"><input type="checkbox" id="c-40930758" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#40930246">parent</a><span>|</span><a href="#40933249">prev</a><span>|</span><a href="#40933685">next</a><span>|</span><label class="collapse" for="c-40930758">[-]</label><label class="expand" for="c-40930758">[1 more]</label></div><br/><div class="children"><div class="content">Is it still the case that cpal doesn&#x27;t support &quot;synchronous&quot; duplex audio where the program inputs audio from a source and outputs it to a sink (either with feedback or outputting unrelated audio), with an integer number of periods (as little as 2) of software-level latency if you copy source buffers to the sink? Last time I used it, each stream is opened in input or output mode and opening both does not run with any guaranteed timing relation.</div><br/></div></div></div></div><div id="40933685" class="c"><input type="checkbox" id="c-40933685" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#40930246">prev</a><span>|</span><a href="#40932018">next</a><span>|</span><label class="collapse" for="c-40933685">[-]</label><label class="expand" for="c-40933685">[6 more]</label></div><br/><div class="children"><div class="content">One of my pet peeves is that graphics programming does not generally enjoy this level of rigor like audio does, despite arguably being also real-time. This is doubly true for UI programming, I&#x27;m not aware of any UI toolkits designed with real-time in mind.<p>I would love to see a UI system that has predictable low-latency real-time perf, so you could confidently achieve something like single frame latency on 144Hz display.</div><br/><div id="40933969" class="c"><input type="checkbox" id="c-40933969" checked=""/><div class="controls bullet"><span class="by">Derbasti</span><span>|</span><a href="#40933685">parent</a><span>|</span><a href="#40934344">next</a><span>|</span><label class="collapse" for="c-40933969">[-]</label><label class="expand" for="c-40933969">[1 more]</label></div><br/><div class="children"><div class="content">On the other hand, the throughput requirements on image processing are often far more stringent than in audio. A full-resolution stereo audio stream is only 200kb&#x2F;s = 12 Mb&#x2F;min after all, whereas a video system might have to chew throw many gigabytes in the same time.</div><br/></div></div><div id="40934344" class="c"><input type="checkbox" id="c-40934344" checked=""/><div class="controls bullet"><span class="by">robinsonb5</span><span>|</span><a href="#40933685">parent</a><span>|</span><a href="#40933969">prev</a><span>|</span><a href="#40934799">next</a><span>|</span><label class="collapse" for="c-40934344">[-]</label><label class="expand" for="c-40934344">[1 more]</label></div><br/><div class="children"><div class="content">When I last made a similar point someone pointed out to me that this has gained a higher priority recently thanks to VR. Janky framerate is going to be much more noticeable with a headset than with a traditional monitor, and could even result in lost lunches!</div><br/></div></div><div id="40934799" class="c"><input type="checkbox" id="c-40934799" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#40933685">parent</a><span>|</span><a href="#40934344">prev</a><span>|</span><a href="#40933840">next</a><span>|</span><label class="collapse" for="c-40934799">[-]</label><label class="expand" for="c-40934799">[1 more]</label></div><br/><div class="children"><div class="content">The tiniest audio glitch is instantly noticed and extremely annoying. So extreme efforts are put into preventing them. If your software has audio glitches people will really stop using it.<p>A graphics micro-stutter not so much.<p>&gt; I&#x27;m not aware of any UI toolkits designed with real-time in mind.<p>What would be the point? The human eye can only notice so much FPS (gamers might disagree with their 244 FPS displays).</div><br/></div></div><div id="40933840" class="c"><input type="checkbox" id="c-40933840" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40933685">parent</a><span>|</span><a href="#40934799">prev</a><span>|</span><a href="#40932018">next</a><span>|</span><label class="collapse" for="c-40933840">[-]</label><label class="expand" for="c-40933840">[2 more]</label></div><br/><div class="children"><div class="content">Well, if you allow a bit of a sloppy terminology, graphics are “softer” real-time, than audio - a frame drop is less noticeable than audio glitches.</div><br/><div id="40934163" class="c"><input type="checkbox" id="c-40934163" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#40933685">root</a><span>|</span><a href="#40933840">parent</a><span>|</span><a href="#40932018">next</a><span>|</span><label class="collapse" for="c-40934163">[-]</label><label class="expand" for="c-40934163">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s where realtime and fast differ : you can consider there&#x27;s a &quot;hard&quot;-er real-time at 100ms by example, where you can drop some frames but you don&#x27;t want to block the ui. Be slow but don&#x27;t block the UI.</div><br/></div></div></div></div></div></div><div id="40932018" class="c"><input type="checkbox" id="c-40932018" checked=""/><div class="controls bullet"><span class="by">jmkr</span><span>|</span><a href="#40933685">prev</a><span>|</span><a href="#40931496">next</a><span>|</span><label class="collapse" for="c-40932018">[-]</label><label class="expand" for="c-40932018">[6 more]</label></div><br/><div class="children"><div class="content">As a web developer, learning music and audio programming makes my mind melt.
We often say &quot;real time&quot; when we mean &quot;fast.&quot; But in audio real time means &quot;really fast,
all the time&quot; and somewhat deterministically.<p>If your tempo drifts, then you&#x27;re not going to hear the rhythm correctly.  If you have 
a bit of latency on your instrument, it&#x27;s like turning on a delay pedal where the only 
signal coming through is the delay.<p>One might assume if you just follow audio programming guides then you can do all this, but
you still need to have your system setup to handle real time audio, in addition to your program.<p>It&#x27;s all noticeable.</div><br/><div id="40933539" class="c"><input type="checkbox" id="c-40933539" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40932018">parent</a><span>|</span><a href="#40932559">next</a><span>|</span><label class="collapse" for="c-40933539">[-]</label><label class="expand" for="c-40933539">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We often say &quot;real time&quot; when we mean &quot;fast.&quot; But in audio real time means &quot;really fast, all the time&quot; and somewhat deterministically.<p>As a former developer of real time software, the usage of &quot;real time&quot; to mean &quot;fast&quot; makes me cringe a bit whenever I read it. If there&#x27;s a TCP&#x2F;IP stack in the middle of something, it&#x27;s probably not &quot;real time.&quot;<p>&quot;real time&quot; means there&#x27;s a <i>deadline</i>. Soft real time means missing the deadline is a problem, possibly a bug, and quite bad. Hard real time means the &quot;dead&quot; part of &quot;deadline&quot; could be literal, either in terms of your program (a missed deadline is an irrecoverable error) or the humans that need the program to make the deadline are no longer alive.</div><br/><div id="40933864" class="c"><input type="checkbox" id="c-40933864" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40932018">root</a><span>|</span><a href="#40933539">parent</a><span>|</span><a href="#40932559">next</a><span>|</span><label class="collapse" for="c-40933864">[-]</label><label class="expand" for="c-40933864">[1 more]</label></div><br/><div class="children"><div class="content">And to demonstrate that hard realtime is not about speed, there is a whole hard-real time JVM implementation with GC and everything used in military contexts.<p>Modern computers are ridiculously fast, relatively speaking you don’t need much resources to calculate a missile trajectory, so “simply” 100% sure doing <i>some</i> calculations at a fixed rate, with even a GC cycle that has a deterministic higher bound (e.g. it will go throw the whole, non-resizable heap, but it will surely always take n seconds), you can pass the requirements. Though a desktop computer pretty much already begets the hard part of hard realtime, due to all the stuff that makes it <i>fast</i> - memory caching, CPU pipelining, branch prediction, normal OSs scheduling, etc.</div><br/></div></div></div></div><div id="40932559" class="c"><input type="checkbox" id="c-40932559" checked=""/><div class="controls bullet"><span class="by">hrkfmud50k</span><span>|</span><a href="#40932018">parent</a><span>|</span><a href="#40933539">prev</a><span>|</span><a href="#40934037">next</a><span>|</span><label class="collapse" for="c-40932559">[-]</label><label class="expand" for="c-40932559">[1 more]</label></div><br/><div class="children"><div class="content">if you think that&#x27;s cool then you may also like a &quot;hard&quot; real time programs e.g. ABS brakes <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real-time_computing#Criteria_for_real-time_computing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real-time_computing#Criteria_f...</a></div><br/></div></div><div id="40934037" class="c"><input type="checkbox" id="c-40934037" checked=""/><div class="controls bullet"><span class="by">chalcolithic</span><span>|</span><a href="#40932018">parent</a><span>|</span><a href="#40932559">prev</a><span>|</span><a href="#40931496">next</a><span>|</span><label class="collapse" for="c-40934037">[-]</label><label class="expand" for="c-40934037">[2 more]</label></div><br/><div class="children"><div class="content">You can actually do music&#x2F;audio programming in a browser.
It has some rough edges but it works.</div><br/><div id="40934477" class="c"><input type="checkbox" id="c-40934477" checked=""/><div class="controls bullet"><span class="by">xipix</span><span>|</span><a href="#40932018">root</a><span>|</span><a href="#40934037">parent</a><span>|</span><a href="#40931496">next</a><span>|</span><label class="collapse" for="c-40934477">[-]</label><label class="expand" for="c-40934477">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely you can. With WebAsm SIMD you have near-native DSP performance. Downsides from my experience [1]:<p>- You are at the mercy of the browser. If browser engineers mess up the audio thread or garbage collection, even the most resilient web audio app breaks. It happens.<p>- Security mitigations prevent or restrict use of some useful APIs. For example, SharedArrayBuffer and high resolution clocks.<p>[1] <a href="https:&#x2F;&#x2F;bungee.parabolaresearch.com&#x2F;bungee-web-demo" rel="nofollow">https:&#x2F;&#x2F;bungee.parabolaresearch.com&#x2F;bungee-web-demo</a></div><br/></div></div></div></div></div></div><div id="40931496" class="c"><input type="checkbox" id="c-40931496" checked=""/><div class="controls bullet"><span class="by">marcod</span><span>|</span><a href="#40932018">prev</a><span>|</span><a href="#40929865">next</a><span>|</span><label class="collapse" for="c-40931496">[-]</label><label class="expand" for="c-40931496">[1 more]</label></div><br/><div class="children"><div class="content">Off topic. Anybody else like Thursday Next? Had to think of &quot;Time waits for no man!&quot;</div><br/></div></div><div id="40929865" class="c"><input type="checkbox" id="c-40929865" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#40931496">prev</a><span>|</span><a href="#40929788">next</a><span>|</span><label class="collapse" for="c-40929865">[-]</label><label class="expand" for="c-40929865">[1 more]</label></div><br/><div class="children"><div class="content">A timeless classic! This is the first thing I always recommend to anyone interested in real-time audio programming.</div><br/></div></div><div id="40929788" class="c"><input type="checkbox" id="c-40929788" checked=""/><div class="controls bullet"><span class="by">user_7832</span><span>|</span><a href="#40929865">prev</a><span>|</span><a href="#40933833">next</a><span>|</span><label class="collapse" for="c-40929788">[-]</label><label class="expand" for="c-40929788">[9 more]</label></div><br/><div class="children"><div class="content">Slightly tangential, does anyone know any good (windows based) DSP software? EquilizerAPO is decent in theory but beyond being clunky to use unfortunately doesn&#x27;t even seem to work 90% of the time.</div><br/><div id="40934750" class="c"><input type="checkbox" id="c-40934750" checked=""/><div class="controls bullet"><span class="by">jonathanstrange</span><span>|</span><a href="#40929788">parent</a><span>|</span><a href="#40931500">next</a><span>|</span><label class="collapse" for="c-40934750">[-]</label><label class="expand" for="c-40934750">[1 more]</label></div><br/><div class="children"><div class="content">Do you mean software that can modify audio streams via the Windows audio system (as opposed to an ASIO driver used by DAWs)?<p>DDMF&#x27;s VirtualAudioStream does that. It allows you to create virtual audio devices with chains of arbitrary VST plugins. As for the VST plugins, there are thousands of free and paid plugins for everything. I&#x27;m using VirtualAudio stream to put a Wave&#x27;s noise cancelling and a good compressor between my mic and Zoom. It increases latency, of course.</div><br/></div></div><div id="40931500" class="c"><input type="checkbox" id="c-40931500" checked=""/><div class="controls bullet"><span class="by">rzzzt</span><span>|</span><a href="#40929788">parent</a><span>|</span><a href="#40934750">prev</a><span>|</span><a href="#40931083">next</a><span>|</span><label class="collapse" for="c-40931500">[-]</label><label class="expand" for="c-40931500">[1 more]</label></div><br/><div class="children"><div class="content">Cockos&#x27; JSFX: <a href="https:&#x2F;&#x2F;www.cockos.com&#x2F;jsfx&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cockos.com&#x2F;jsfx&#x2F;</a></div><br/></div></div><div id="40931083" class="c"><input type="checkbox" id="c-40931083" checked=""/><div class="controls bullet"><span class="by">Ylpertnodi</span><span>|</span><a href="#40929788">parent</a><span>|</span><a href="#40931500">prev</a><span>|</span><a href="#40930869">next</a><span>|</span><label class="collapse" for="c-40931083">[-]</label><label class="expand" for="c-40931083">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.airwindows.com&#x2F;consolidated&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.airwindows.com&#x2F;consolidated&#x2F;</a></div><br/></div></div><div id="40930869" class="c"><input type="checkbox" id="c-40930869" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#40929788">parent</a><span>|</span><a href="#40931083">prev</a><span>|</span><a href="#40931563">next</a><span>|</span><label class="collapse" for="c-40930869">[-]</label><label class="expand" for="c-40930869">[1 more]</label></div><br/><div class="children"><div class="content">Graphical: Pure Data, Max&#x2F;MSP<p>Text based: SuperCollider, Csound, Chuck</div><br/></div></div><div id="40931563" class="c"><input type="checkbox" id="c-40931563" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#40929788">parent</a><span>|</span><a href="#40930869">prev</a><span>|</span><a href="#40930202">next</a><span>|</span><label class="collapse" for="c-40931563">[-]</label><label class="expand" for="c-40931563">[2 more]</label></div><br/><div class="children"><div class="content">AudioMulch?</div><br/><div id="40932940" class="c"><input type="checkbox" id="c-40932940" checked=""/><div class="controls bullet"><span class="by">anigbrowl</span><span>|</span><a href="#40929788">root</a><span>|</span><a href="#40931563">parent</a><span>|</span><a href="#40930202">next</a><span>|</span><label class="collapse" for="c-40932940">[-]</label><label class="expand" for="c-40932940">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still a fan ~25 years later</div><br/></div></div></div></div><div id="40930202" class="c"><input type="checkbox" id="c-40930202" checked=""/><div class="controls bullet"><span class="by">chresko</span><span>|</span><a href="#40929788">parent</a><span>|</span><a href="#40931563">prev</a><span>|</span><a href="#40929858">next</a><span>|</span><label class="collapse" for="c-40930202">[-]</label><label class="expand" for="c-40930202">[1 more]</label></div><br/><div class="children"><div class="content">SuperCollider</div><br/></div></div><div id="40929858" class="c"><input type="checkbox" id="c-40929858" checked=""/><div class="controls bullet"><span class="by">bratwurst3000</span><span>|</span><a href="#40929788">parent</a><span>|</span><a href="#40930202">prev</a><span>|</span><a href="#40933833">next</a><span>|</span><label class="collapse" for="c-40929858">[-]</label><label class="expand" for="c-40929858">[1 more]</label></div><br/><div class="children"><div class="content">I think camilla dsp works for windows.</div><br/></div></div></div></div><div id="40933833" class="c"><input type="checkbox" id="c-40933833" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40929788">prev</a><span>|</span><a href="#40933295">next</a><span>|</span><label class="collapse" for="c-40933833">[-]</label><label class="expand" for="c-40933833">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Applications where low latency is especially important are (1) interactive audio systems (such as musical instruments or DJ tools) where the UI needs to be responsive to the performer, and (2) real-time audio effects, where the system needs to process analog input (say from a guitar) and output the processed signal without noticeable delay.<p>It&#x27;s worth noting that these are practically the <i>only</i> case where extreme real-time audio programming measures are necessary.<p>If you&#x27;re making, for example, a video game the requirements aren&#x27;t <i>actually</i> that steep. You can trivially trade latency for consistency. You don&#x27;t need to do all your audio processing inside a 5ms window. You need to provide an audio buffer every 5 milliseconds. You can easily queue up N buffers to smooth out any variance.<p>Highly optimized competitive video games average like ~100ms of audio latency [1]. Some slightly better. Some in the 150ms and even 200ms range. Input latency is hyper optimized, but people rarely pay attention to audio latency. My testing indicates that ~50ms is sufficient.<p>Audio programming is fun. But you can inject latency to smooth out jitter in almost all use cases that don&#x27;t involve a live musical instrument.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JTuZvRF-OgE&amp;t=490s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JTuZvRF-OgE&amp;t=490s</a></div><br/></div></div><div id="40933295" class="c"><input type="checkbox" id="c-40933295" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#40933833">prev</a><span>|</span><a href="#40932349">next</a><span>|</span><label class="collapse" for="c-40933295">[-]</label><label class="expand" for="c-40933295">[3 more]</label></div><br/><div class="children"><div class="content">If you’re worried about glitches during live performances there’s a fool proof solution: play real instruments. ;)</div><br/><div id="40934536" class="c"><input type="checkbox" id="c-40934536" checked=""/><div class="controls bullet"><span class="by">shiroiushi</span><span>|</span><a href="#40933295">parent</a><span>|</span><a href="#40933692">next</a><span>|</span><label class="collapse" for="c-40934536">[-]</label><label class="expand" for="c-40934536">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s great if you don&#x27;t need any amplification at all, or perhaps nothing more than a typical guitar&#x2F;bass amplifier.  Big venues need a lot more hardware than this.</div><br/></div></div><div id="40933692" class="c"><input type="checkbox" id="c-40933692" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40933295">parent</a><span>|</span><a href="#40934536">prev</a><span>|</span><a href="#40932349">next</a><span>|</span><label class="collapse" for="c-40933692">[-]</label><label class="expand" for="c-40933692">[1 more]</label></div><br/><div class="children"><div class="content">... and if the FOH engineer is using a poorly engineered digital console, or even a DAW, for mixing ... ?</div><br/></div></div></div></div><div id="40932349" class="c"><input type="checkbox" id="c-40932349" checked=""/><div class="controls bullet"><span class="by">white_beach</span><span>|</span><a href="#40933295">prev</a><span>|</span><a href="#40929506">next</a><span>|</span><label class="collapse" for="c-40932349">[-]</label><label class="expand" for="c-40932349">[1 more]</label></div><br/><div class="children"><div class="content">i thought glitch music a good</div><br/></div></div><div id="40931786" class="c"><input type="checkbox" id="c-40931786" checked=""/><div class="controls bullet"><span class="by">brcmthrowaway</span><span>|</span><a href="#40929506">prev</a><span>|</span><label class="collapse" for="c-40931786">[-]</label><label class="expand" for="c-40931786">[8 more]</label></div><br/><div class="children"><div class="content">This seems super outdated. Isn&#x27;t CoreAudio HW accelerated now?</div><br/><div id="40933004" class="c"><input type="checkbox" id="c-40933004" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#40931786">parent</a><span>|</span><label class="collapse" for="c-40933004">[-]</label><label class="expand" for="c-40933004">[7 more]</label></div><br/><div class="children"><div class="content">It continues to be relevant. On modern computers, mobile especially, there are are more and more things that can glitch audio from being actually real-time. Probably one of the worst offenders is power management; it is extremely likely that the power management governor has no awareness of upcoming audio deadlines.<p>Obviously the happy case is when all the audio processing is done in a DSP where scheduling is deterministic, but it&#x27;s rare to be able to count on that. Part of the problem is that modern computers are so fast that people expect them to handle audio tasks without breathing hard. But that speed is usually measured as throughput rather than worst-case latency.<p>The advice I&#x27;d give to anybody building audio today is to relentlessly measure all potential sources of scheduling jitter end-to-end. Once you know that, it becomes clearer how to address it.</div><br/><div id="40933164" class="c"><input type="checkbox" id="c-40933164" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#40931786">root</a><span>|</span><a href="#40933004">parent</a><span>|</span><label class="collapse" for="c-40933164">[-]</label><label class="expand" for="c-40933164">[6 more]</label></div><br/><div class="children"><div class="content">How do you measure scheduling jitter of audio drivers and userspace? I hear real-time priority or kernels improve latency? (There was some controversy about Ubuntu Studio or something switching to RT kernels with more missed deadlines than RT-PREEMPT, but I don&#x27;t know how to quantify this stuff.)</div><br/><div id="40933709" class="c"><input type="checkbox" id="c-40933709" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40931786">root</a><span>|</span><a href="#40933164">parent</a><span>|</span><a href="#40933308">next</a><span>|</span><label class="collapse" for="c-40933709">[-]</label><label class="expand" for="c-40933709">[1 more]</label></div><br/><div class="children"><div class="content">cyclictest(8) is the canonical tool for starting out down this pathway. That measures basic kernel stuff relevant to this area of inquiry.<p>However, since actual context switch times depend a lot on working set size, ultimately you can&#x27;t measure this stuff accurately unless you instrument the actual application code you are working with. A sample playback engine is going to have very different performance characteristics than an EQ plugin, even if there is theoretically more actual computation going on in the latter.</div><br/></div></div><div id="40933308" class="c"><input type="checkbox" id="c-40933308" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#40931786">root</a><span>|</span><a href="#40933164">parent</a><span>|</span><a href="#40933709">prev</a><span>|</span><a href="#40933276">next</a><span>|</span><label class="collapse" for="c-40933308">[-]</label><label class="expand" for="c-40933308">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually a very good question. To some extent, performance analysis tools may be able to give you high-accuracy timestamps of things involving context switches and other things that can cause scheduling jitter. If you can get access to things like the fill level of FIFO buffers, even better. You may also be able to do experiments like cutting buffer sizes down to the bone to see how low they can go without glitching.<p>Of course, it&#x27;s not unusual that the many layers of abstraction in modern systems actively frustrate getting real performance data. But dealing with that is part of the requirements of doing real engineering.</div><br/><div id="40933681" class="c"><input type="checkbox" id="c-40933681" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#40931786">root</a><span>|</span><a href="#40933308">parent</a><span>|</span><a href="#40933276">next</a><span>|</span><label class="collapse" for="c-40933681">[-]</label><label class="expand" for="c-40933681">[2 more]</label></div><br/><div class="children"><div class="content">For context switch timestamps would I be using something like perf on Linux?<p>Would buffer level checking entail, eg. checking snd_pcm_avail() when my audio code begins and ends (assuming I&#x27;m talking directly to hardware rather than PipeWire)? Dunno if PipeWire has a similar API considering it&#x27;s a delay-based audio daemon and probably checking snd_pcm_avail when a client requests would slow it down.</div><br/><div id="40933716" class="c"><input type="checkbox" id="c-40933716" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40931786">root</a><span>|</span><a href="#40933681">parent</a><span>|</span><a href="#40933276">next</a><span>|</span><label class="collapse" for="c-40933716">[-]</label><label class="expand" for="c-40933716">[1 more]</label></div><br/><div class="children"><div class="content">Buffer level makes almost no sense.<p>All that matters is&#x2F;are:<p>1. how soon after the device deadline (typically marked by an interrupt) until a kernel thread wakes up to deal with the device? (you have no control over this)<p>2. what is the additional delay until a user-space application thread wakes up to deal with the required data flow? (you have very little control over this, assuming you&#x27;ve done the obvious and used the correct thread scheduling class and priority)<p>3. does user space code read &amp; write data before the next device deadline? (you have a lot of control over this)<p>As noted above, cyclictest is the canonical tool for testing the kernel side of this sort of thing.</div><br/></div></div></div></div></div></div><div id="40933276" class="c"><input type="checkbox" id="c-40933276" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#40931786">root</a><span>|</span><a href="#40933164">parent</a><span>|</span><a href="#40933308">prev</a><span>|</span><label class="collapse" for="c-40933276">[-]</label><label class="expand" for="c-40933276">[1 more]</label></div><br/><div class="children"><div class="content">also interested in the answer to this</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>