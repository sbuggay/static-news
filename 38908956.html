<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704877265414" as="style"/><link rel="stylesheet" href="styles.css?v=1704877265414"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/">The Biggest Smallest PNG</a>Â <span class="domain">(<a href="https://belkadan.com">belkadan.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>9 comments</span></div><br/><div><div id="38935592" class="c"><input type="checkbox" id="c-38935592" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38937043">next</a><span>|</span><label class="collapse" for="c-38935592">[-]</label><label class="expand" for="c-38935592">[3 more]</label></div><br/><div class="children"><div class="content">EDIT: I read the original article in the opposite way and described the largest PNG file with single pixel, oops. It&#x27;s still a good tidbit so here is the original comment.<p>There is a much easier way. You can put an arbitrary number of empty uncompressed blocks, which are normally used for the sync flush (Z_SYNC_FLUSH in zlib). Such blocks do not affect any other block or zlib checksum (but <i>do</i> affect PNG checksum). For example a DEFLATE stream `7801 (00 0000 ffff)* 01 0100 feff xx yyyy yyyy` is always valid and decompresses into a single byte `xx` where `yyyy` is a big-endian representation of `xx + 1`. Also PNG IDAT chunks have to be implicitly concatenated, so you can technically have an arbitrary large PNG file of single pixel if you really want.</div><br/><div id="38936016" class="c"><input type="checkbox" id="c-38936016" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#38935592">parent</a><span>|</span><a href="#38935862">next</a><span>|</span><label class="collapse" for="c-38936016">[-]</label><label class="expand" for="c-38936016">[1 more]</label></div><br/><div class="children"><div class="content">With a bit of math, it should be possible to devise a sequence of zlib flush blocks (and other tricks) that don&#x27;t affect the PNG checksum, either.<p>As for the &quot;other tricks&quot;, you can get 10 bits of do-nothing padding by starting and immediately ending a fixed-huffman block, and various other lengths by starting and immediately ending dynamic huffman blocks. I use the former in unPNG[1] to pad things out to word boundaries, for alignment.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;davidBuchanan314&#x2F;unpng">https:&#x2F;&#x2F;github.com&#x2F;davidBuchanan314&#x2F;unpng</a></div><br/></div></div><div id="38935862" class="c"><input type="checkbox" id="c-38935862" checked=""/><div class="controls bullet"><span class="by">MByte</span><span>|</span><a href="#38935592">parent</a><span>|</span><a href="#38936016">prev</a><span>|</span><a href="#38937043">next</a><span>|</span><label class="collapse" for="c-38935862">[-]</label><label class="expand" for="c-38935862">[1 more]</label></div><br/><div class="children"><div class="content">I think you missed the point of trying to make the largest image dimensions within the smallest file size. It looks like you&#x27;re describing the opposite.</div><br/></div></div></div></div><div id="38937043" class="c"><input type="checkbox" id="c-38937043" checked=""/><div class="controls bullet"><span class="by">vincnetas</span><span>|</span><a href="#38935592">prev</a><span>|</span><a href="#38936651">next</a><span>|</span><label class="collapse" for="c-38937043">[-]</label><label class="expand" for="c-38937043">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll throw another idea in to the air. How about least bytes per pixel (or most pixels per byte) PNG. Is this stable system or does it go to the infinity?<p>So now we have 2064 pixels in 67 bytes. 30.8 pixels per byte or 3.39 pixels per bit</div><br/><div id="38937439" class="c"><input type="checkbox" id="c-38937439" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38937043">parent</a><span>|</span><a href="#38936651">next</a><span>|</span><label class="collapse" for="c-38937439">[-]</label><label class="expand" for="c-38937439">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s bounded, because the underlying DEFLATE algorithm has the maximum compression ratio of 1032:1 [1]. You still need at least one literal code and end-of-block code, but the former can be encoded in a separate block so you can indeed use only two bits per each run of 258 bytes.<p>At one point you will be also bounded by the maximum size of IDAT chunk, which is 2^31 - 1 bytes with a 4-byte-long chunk name included, and after that point you will constantly need 12 bytes of overhead for each additional 2^31 - 5 bytes. And we will eventually hit the maximum permitted dimension of (2^31 - 1) by (2^31 - 1) pixels. Since the long-term overhead (12 bytes) is much smaller than the one-time overhead (&gt;50 bytes), the biggest image will result in the best ratio. Such biggest image needs at least N = (2^31 - 1) * (2^28 + 1) uncompressed bytes of IDAT, as each scanline needs one filter byte and 2^31 - 1 bits pack into 2^28 bytes.<p>We can now compress them down to ceil(N &#x2F; 1032) compressed bytes plus small overhead, which should be divided into ceil((ceil(N &#x2F; 1032) + eps) &#x2F; (2^31 - 5)) = 260,112 IDAT chunks. Each chunk of 2^31 - 5 bytes contains at most ceil((2^31 - 5) * 1032 &#x2F; (2^28 + 1)) + 1 = 8256 scanline boundary, which consists of one filter byte and one unused padding bit. Therefore we should have (2^31 - 5) * 1032 * 8 - 8256 * 9 uncompressed bytes (i.e. pixels) per each chunk, giving the upper bound of ~4127.99997308 pixels per byte. The actual value will be very slightly lower than that due to the one-time overhead---aforementioned significant digits did account for this.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;16794960" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;16794960</a></div><br/></div></div></div></div><div id="38936651" class="c"><input type="checkbox" id="c-38936651" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#38937043">prev</a><span>|</span><a href="#38937087">next</a><span>|</span><label class="collapse" for="c-38936651">[-]</label><label class="expand" for="c-38936651">[1 more]</label></div><br/><div class="children"><div class="content">Might even be useful for instance just to get 2k of ram allocated in an indirect way.</div><br/></div></div><div id="38937087" class="c"><input type="checkbox" id="c-38937087" checked=""/><div class="controls bullet"><span class="by">BonoboIO</span><span>|</span><a href="#38936651">prev</a><span>|</span><a href="#38936999">next</a><span>|</span><label class="collapse" for="c-38937087">[-]</label><label class="expand" for="c-38937087">[1 more]</label></div><br/><div class="children"><div class="content">Also interesting: Biggest image in the smallest space<p><a href="https:&#x2F;&#x2F;www.bamsoftware.com&#x2F;hacks&#x2F;deflate.html" rel="nofollow">https:&#x2F;&#x2F;www.bamsoftware.com&#x2F;hacks&#x2F;deflate.html</a></div><br/></div></div></div></div></div></div></div></body></html>