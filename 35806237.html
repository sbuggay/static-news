<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683190851271" as="style"/><link rel="stylesheet" href="styles.css?v=1683190851271"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fabiensanglard.net/dc/index.php">Driving Compilers</a> <span class="domain">(<a href="https://fabiensanglard.net">fabiensanglard.net</a>)</span></div><div class="subtext"><span>fredoralive</span> | <span>35 comments</span></div><br/><div><div id="35807400" class="c"><input type="checkbox" id="c-35807400" checked=""/><div class="controls bullet"><span class="by">mshockwave</span><span>|</span><a href="#35812584">next</a><span>|</span><label class="collapse" for="c-35807400">[-]</label><label class="expand" for="c-35807400">[18 more]</label></div><br/><div class="children"><div class="content">Glad that the concept of compiler driver gets more exposures. &quot;The `gcc` program itself is actually not a compiler...but a compiler driver&quot; [1] is one of my favorite things to tell newbie compiler engineers.<p>[1]: Clang, on the other hand, is not the case (at least the modern one). The `clang` program is a compiler driver and compiler AND assembler for majority of the platforms.</div><br/><div id="35807505" class="c"><input type="checkbox" id="c-35807505" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#35807400">parent</a><span>|</span><a href="#35807469">next</a><span>|</span><label class="collapse" for="c-35807505">[-]</label><label class="expand" for="c-35807505">[6 more]</label></div><br/><div class="children"><div class="content">&gt; [1]: Clang, on the other hand, is not the case (at least the modern one). The `clang` program is a compiler driver and compiler AND assembler for majority of the platforms.<p>This framing is more likely to cause confusion than not, I think. `clang` is a compiler driver. `clang -cc1` is the compiler, and `clang -cc1as` is the assembler. They may all be the same executable, but the distinction between the tools is basically the first thing that happens. (Also note that the -cc1&#x2F;-cc1as option has to be the very first option, it&#x27;s not recognized in any other position).</div><br/><div id="35809261" class="c"><input type="checkbox" id="c-35809261" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35807505">parent</a><span>|</span><a href="#35807469">next</a><span>|</span><label class="collapse" for="c-35809261">[-]</label><label class="expand" for="c-35809261">[5 more]</label></div><br/><div class="children"><div class="content">i could easily google it but, what&#x27;s LLVM? (me googling it would not translate automatically into me writing up an answer for everybody, however, LLVM seems to be the name of a project that includes clang)</div><br/><div id="35809506" class="c"><input type="checkbox" id="c-35809506" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35809261">parent</a><span>|</span><a href="#35809282">next</a><span>|</span><label class="collapse" for="c-35809506">[-]</label><label class="expand" for="c-35809506">[3 more]</label></div><br/><div class="children"><div class="content">LLVM is a series of projects, of which the core project is an assembly-like language (more specifically a compiler IR (or five)), optimization passes for said language, code generators to convert it to several major assembly languages (or their machine code representation), and a few associated tools that are similar to things provided by GNU binutils.<p>Other projects are included in LLVM. Clang is the C&#x2F;C++ compiler. There is a C standard library, an OpenCL standard library, a C++ standard library (all inventively named lib&lt;language&gt;). There is also a library to support compiler builtins called compiler-rt, and a library to support OpenMP called openmp, and an implementation of C++ parallel executors in pstl. There is also a linker (lld) and a debugger (lldb). There is also a machine code optimizer called bolt, and yet another compiler framework called MLIR. Finally, there are several different Fortran compilers all called flang (don&#x27;t ask).</div><br/><div id="35811085" class="c"><input type="checkbox" id="c-35811085" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35809506">parent</a><span>|</span><a href="#35809282">next</a><span>|</span><label class="collapse" for="c-35811085">[-]</label><label class="expand" for="c-35811085">[2 more]</label></div><br/><div class="children"><div class="content">LLVM is also notably used as the compiler backend for Rust, Swift and (I think) Zig and more. Rust is as fast as C because llvm includes all the optimizations used to make C programs fast, and rust gets to reuse all of those optimizations. Llvm can compile working binaries for all modern platforms (windows, Mac, Linux, FreeBSD, iOS, android, etc) and basically all modern architectures (x86, arm, riscv, wasm, etc). It’s also the official compiler toolchain used by Apple on all their platforms (and apple fund a lot of llvm development). I think Google also uses it for their C&#x2F;C++ code and some Linux distributions use llvm instead of gcc as a compiler toolchain.<p>Llvm is everywhere. There’s a good chance llvm compiled some or all of the software you’re using to read this comment.</div><br/><div id="35812202" class="c"><input type="checkbox" id="c-35812202" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35811085">parent</a><span>|</span><a href="#35809282">next</a><span>|</span><label class="collapse" for="c-35812202">[-]</label><label class="expand" for="c-35812202">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Rust is as fast as C because llvm includes all the optimizations used to make C programs fast, and rust gets to reuse all of those optimizations.<p>I mean, that&#x27;s not the reason Rust is as fast as C. It&#x27;s because Rust semantically doesn&#x27;t include mandatory slower things.<p>The compiler it uses is an implementation detail.</div><br/></div></div></div></div></div></div><div id="35809282" class="c"><input type="checkbox" id="c-35809282" checked=""/><div class="controls bullet"><span class="by">mshockwave</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35809261">parent</a><span>|</span><a href="#35809506">prev</a><span>|</span><a href="#35807469">next</a><span>|</span><label class="collapse" for="c-35809282">[-]</label><label class="expand" for="c-35809282">[1 more]</label></div><br/><div class="children"><div class="content">From <a href="https:&#x2F;&#x2F;llvm.org" rel="nofollow">https:&#x2F;&#x2F;llvm.org</a> : &quot;a collection of modular and reusable compiler and toolchain technologies&quot;</div><br/></div></div></div></div></div></div><div id="35807469" class="c"><input type="checkbox" id="c-35807469" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#35807400">parent</a><span>|</span><a href="#35807505">prev</a><span>|</span><a href="#35807869">next</a><span>|</span><label class="collapse" for="c-35807469">[-]</label><label class="expand" for="c-35807469">[1 more]</label></div><br/><div class="children"><div class="content">clang is the gcc-compatible compiler driver.    
You can access the actual compiler frontend with clang -cc1.</div><br/></div></div><div id="35807869" class="c"><input type="checkbox" id="c-35807869" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#35807400">parent</a><span>|</span><a href="#35807469">prev</a><span>|</span><a href="#35812584">next</a><span>|</span><label class="collapse" for="c-35807869">[-]</label><label class="expand" for="c-35807869">[10 more]</label></div><br/><div class="children"><div class="content">&gt; he `clang` program is a compiler driver and compiler AND assembler<p>um, gcc does all those things.</div><br/><div id="35810229" class="c"><input type="checkbox" id="c-35810229" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35807869">parent</a><span>|</span><a href="#35808366">next</a><span>|</span><label class="collapse" for="c-35810229">[-]</label><label class="expand" for="c-35810229">[1 more]</label></div><br/><div class="children"><div class="content">Um, no. `gcc` is a driver that runs cc1 (a C compiler from the GNU compiler collection), cc1plus (a C++ compiler from the GNU compiler collection), (g)as (an assembler from GNU binutils) and ld (a static linker from GNU binutils) and sometimes other front-ends for other languages, and sometimes other back-ends for other reasons, and sometimes some special middle-ends.<p>All `gcc` does is parse come command-line options and then invoke other programs to do the actual job of preprocessing, compiling, assembling, and linking.</div><br/></div></div><div id="35808366" class="c"><input type="checkbox" id="c-35808366" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35807869">parent</a><span>|</span><a href="#35810229">prev</a><span>|</span><a href="#35809252">next</a><span>|</span><label class="collapse" for="c-35808366">[-]</label><label class="expand" for="c-35808366">[7 more]</label></div><br/><div class="children"><div class="content">gcc uses gas (from binutils) as its assembler, unlike clang.</div><br/><div id="35809924" class="c"><input type="checkbox" id="c-35809924" checked=""/><div class="controls bullet"><span class="by">citizen_friend</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35808366">parent</a><span>|</span><a href="#35809252">next</a><span>|</span><label class="collapse" for="c-35809924">[-]</label><label class="expand" for="c-35809924">[6 more]</label></div><br/><div class="children"><div class="content">As a user, why would I care if the actual compilation occurs:<p>- in the process<p>- in a fork of the process<p>- in a child process<p>The outcome to me is the same.</div><br/><div id="35812746" class="c"><input type="checkbox" id="c-35812746" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35809924">parent</a><span>|</span><a href="#35810255">next</a><span>|</span><label class="collapse" for="c-35812746">[-]</label><label class="expand" for="c-35812746">[1 more]</label></div><br/><div class="children"><div class="content">Because it helps when the process breaks and you don&#x27;t end up being helpless and unable to fix the most important tool you use at your work.<p>Being ignorant is cute until its your job to be an engineer and fix problems.</div><br/></div></div><div id="35810255" class="c"><input type="checkbox" id="c-35810255" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35809924">parent</a><span>|</span><a href="#35812746">prev</a><span>|</span><a href="#35810142">next</a><span>|</span><label class="collapse" for="c-35810255">[-]</label><label class="expand" for="c-35810255">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s right, It&#x27;s all just stuff that happens when you hit F5 in your IDE. It&#x27;s like not needing to know how an internal combustion engine works since all you have to do is tell the driver where you want to go.</div><br/></div></div><div id="35810142" class="c"><input type="checkbox" id="c-35810142" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35809924">parent</a><span>|</span><a href="#35810255">prev</a><span>|</span><a href="#35810168">next</a><span>|</span><label class="collapse" for="c-35810142">[-]</label><label class="expand" for="c-35810142">[1 more]</label></div><br/><div class="children"><div class="content">In the gcc&#x2F;gas distinction, the fact that gas is part of binutils, a completely separate project from gcc, means that there is another package you might have to update to use a new feature.</div><br/></div></div><div id="35810168" class="c"><input type="checkbox" id="c-35810168" checked=""/><div class="controls bullet"><span class="by">fhuygfthdsafrsd</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35809924">parent</a><span>|</span><a href="#35810142">prev</a><span>|</span><a href="#35810227">next</a><span>|</span><label class="collapse" for="c-35810168">[-]</label><label class="expand" for="c-35810168">[1 more]</label></div><br/><div class="children"><div class="content">The parent comment did say:<p>&gt; is one of my favorite things to tell newbie compiler engineers.</div><br/></div></div><div id="35810227" class="c"><input type="checkbox" id="c-35810227" checked=""/><div class="controls bullet"><span class="by">sigjuice</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35809924">parent</a><span>|</span><a href="#35810168">prev</a><span>|</span><a href="#35809252">next</a><span>|</span><label class="collapse" for="c-35810227">[-]</label><label class="expand" for="c-35810227">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.  This is all implementation trivia that is of absolutely no concern to me as a user.</div><br/></div></div></div></div></div></div><div id="35809252" class="c"><input type="checkbox" id="c-35809252" checked=""/><div class="controls bullet"><span class="by">mshockwave</span><span>|</span><a href="#35807400">root</a><span>|</span><a href="#35807869">parent</a><span>|</span><a href="#35808366">prev</a><span>|</span><a href="#35812584">next</a><span>|</span><label class="collapse" for="c-35809252">[-]</label><label class="expand" for="c-35809252">[1 more]</label></div><br/><div class="children"><div class="content">clang packs all three things into a single executable. GCC however will always call out to external executables for compiler (cc1) and assembler (as)</div><br/></div></div></div></div></div></div><div id="35812584" class="c"><input type="checkbox" id="c-35812584" checked=""/><div class="controls bullet"><span class="by">Brightwise</span><span>|</span><a href="#35807400">prev</a><span>|</span><a href="#35807795">next</a><span>|</span><label class="collapse" for="c-35812584">[-]</label><label class="expand" for="c-35812584">[1 more]</label></div><br/><div class="children"><div class="content">Are these SVG graphics with the little boxes and arrows generated? Is this gnuplot?</div><br/></div></div><div id="35807795" class="c"><input type="checkbox" id="c-35807795" checked=""/><div class="controls bullet"><span class="by">genpfault</span><span>|</span><a href="#35812584">prev</a><span>|</span><a href="#35812367">next</a><span>|</span><label class="collapse" for="c-35807795">[-]</label><label class="expand" for="c-35807795">[6 more]</label></div><br/><div class="children"><div class="content">Ah, yes, the Platform[1] platform, the one that uses DLLs and the PE executable format :)<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;fabiensanglard&#x2F;dc&#x2F;blob&#x2F;1b9cbd081fcc530488155022b7fe281e25dcebda&#x2F;index.php#L79">https:&#x2F;&#x2F;github.com&#x2F;fabiensanglard&#x2F;dc&#x2F;blob&#x2F;1b9cbd081fcc530488...</a></div><br/><div id="35807909" class="c"><input type="checkbox" id="c-35807909" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#35807795">parent</a><span>|</span><a href="#35808480">next</a><span>|</span><label class="collapse" for="c-35807909">[-]</label><label class="expand" for="c-35807909">[4 more]</label></div><br/><div class="children"><div class="content">Ahh I think know that one actually. EEE Platform right? Candy crush main menu? Don&#x27;t think people use it willingly these days...</div><br/><div id="35808730" class="c"><input type="checkbox" id="c-35808730" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#35807795">root</a><span>|</span><a href="#35807909">parent</a><span>|</span><a href="#35808278">next</a><span>|</span><label class="collapse" for="c-35808730">[-]</label><label class="expand" for="c-35808730">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Don&#x27;t think people use it willingly these days<p>I do. There isn&#x27;t a viable competitor to productivity tools like Office 365 (and <i>no</i>, LibreOffice and Thunderbird, while decent, do not cut it), ease of gaming (I&#x27;d rather play games natively, than fiddle with Wine), HiDPI support, PowerShell, Visual Studio (sue me: it&#x27;s better than gcc + painful array of binutils + perf), etc.<p><i>Maybe</i> it&#x27;s Stockholm syndrome, but I have Arch installed too (on its own dedicated drive to boot), and I use it a lot less than I do Platform™.</div><br/><div id="35809733" class="c"><input type="checkbox" id="c-35809733" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#35807795">root</a><span>|</span><a href="#35808730">parent</a><span>|</span><a href="#35808278">next</a><span>|</span><label class="collapse" for="c-35809733">[-]</label><label class="expand" for="c-35809733">[1 more]</label></div><br/><div class="children"><div class="content">Well put. I guess in retrospect: I too use the Platform™ willingly, it is quite fun to RE :)</div><br/></div></div></div></div><div id="35808278" class="c"><input type="checkbox" id="c-35808278" checked=""/><div class="controls bullet"><span class="by">rcoveson</span><span>|</span><a href="#35807795">root</a><span>|</span><a href="#35807909">parent</a><span>|</span><a href="#35808730">prev</a><span>|</span><a href="#35808480">next</a><span>|</span><label class="collapse" for="c-35808278">[-]</label><label class="expand" for="c-35808278">[1 more]</label></div><br/><div class="children"><div class="content">Between Stockholm syndrome, sunk-cost fallacy, and the psychological inertia of arguing repeatedly on the Internet in the 2000&#x27;s that it was more 1337 than the Macintosh, it&#x27;s hard to tell what &quot;willing&quot; even means in that context. May as well try to figure out if people who drink alcohol do so &quot;willingly&quot;.</div><br/></div></div></div></div><div id="35808480" class="c"><input type="checkbox" id="c-35808480" checked=""/><div class="controls bullet"><span class="by">heinrich5991</span><span>|</span><a href="#35807795">parent</a><span>|</span><a href="#35807909">prev</a><span>|</span><a href="#35812367">next</a><span>|</span><label class="collapse" for="c-35808480">[-]</label><label class="expand" for="c-35808480">[1 more]</label></div><br/><div class="children"><div class="content">Three different pull requests were opened to fix this typo already, presumably in response to this Hacker News post.</div><br/></div></div></div></div><div id="35812367" class="c"><input type="checkbox" id="c-35812367" checked=""/><div class="controls bullet"><span class="by">wandering-nomad</span><span>|</span><a href="#35807795">prev</a><span>|</span><a href="#35810384">next</a><span>|</span><label class="collapse" for="c-35812367">[-]</label><label class="expand" for="c-35812367">[1 more]</label></div><br/><div class="children"><div class="content">Is the choice of C books mentioned in the beginning of this article still a good recommendation? I find all the books to be little outdated now</div><br/></div></div><div id="35810384" class="c"><input type="checkbox" id="c-35810384" checked=""/><div class="controls bullet"><span class="by">Sirenos</span><span>|</span><a href="#35812367">prev</a><span>|</span><a href="#35807593">next</a><span>|</span><label class="collapse" for="c-35810384">[-]</label><label class="expand" for="c-35810384">[1 more]</label></div><br/><div class="children"><div class="content">Great content! I wish I had this as a beginner. It would have saved me so much pain and time lost in the depths of google search results.</div><br/></div></div><div id="35807593" class="c"><input type="checkbox" id="c-35807593" checked=""/><div class="controls bullet"><span class="by">_trackno5</span><span>|</span><a href="#35810384">prev</a><span>|</span><a href="#35809620">next</a><span>|</span><label class="collapse" for="c-35807593">[-]</label><label class="expand" for="c-35807593">[4 more]</label></div><br/><div class="children"><div class="content">Nice series!<p>One comment though:<p>&gt; The compiler ingests one .c and outputs one .o. It has a low memory footprint. The linker on the other side, must use all the .o files at once to generate the executable. Keeping all these .o in memory would stress the system too much on big projects.<p>This is a really weak argument that does not make a lot of sense.<p>The major advantage of separate object files is avoiding recompilation of modules that haven’t changed.<p>In fact, compilers like Jonathan Blow’s Jai seem to get massive performance improvements by treating everything as a single compilation unit and avoiding writing a bunch of object files only to call the linker on all of them.</div><br/><div id="35808060" class="c"><input type="checkbox" id="c-35808060" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#35807593">parent</a><span>|</span><a href="#35809620">next</a><span>|</span><label class="collapse" for="c-35808060">[-]</label><label class="expand" for="c-35808060">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably the main reason historically that compiling and linking are separate steps. Back in the day, you might not have had enough memory to even load all of the source at the same time. But yeah, that was decades ago.</div><br/><div id="35812213" class="c"><input type="checkbox" id="c-35812213" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#35807593">root</a><span>|</span><a href="#35808060">parent</a><span>|</span><a href="#35809620">next</a><span>|</span><label class="collapse" for="c-35812213">[-]</label><label class="expand" for="c-35812213">[2 more]</label></div><br/><div class="children"><div class="content">On a 32-bit system there&#x27;s definitely still projects out there that can&#x27;t be compiled all in the same address space.</div><br/><div id="35812507" class="c"><input type="checkbox" id="c-35812507" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#35807593">root</a><span>|</span><a href="#35812213">parent</a><span>|</span><a href="#35809620">next</a><span>|</span><label class="collapse" for="c-35812507">[-]</label><label class="expand" for="c-35812507">[1 more]</label></div><br/><div class="children"><div class="content">I very much worked on c++ projects that could not be easily linked on 64bit machines with too little (say, 64gb) of ram, without swapping heavily.</div><br/></div></div></div></div></div></div></div></div><div id="35809620" class="c"><input type="checkbox" id="c-35809620" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#35807593">prev</a><span>|</span><a href="#35806953">next</a><span>|</span><label class="collapse" for="c-35809620">[-]</label><label class="expand" for="c-35809620">[2 more]</label></div><br/><div class="children"><div class="content">Glad to see this covered -- I also had the experience of picking it up the hard way, over many years!<p>My own tips after writing a custom build system for C++<p>- the order of objects and -l flags to the linker matters!  I remember being very surprised &#x2F; frustrated by this.<p>- Sanitizers are built into compilers and trivial to use.  Learn to use AddressSanitizer simply with -fsanitize=address!  Ironically I think many people don&#x27;t use it because their build system doesn&#x27;t have good build variants (dbg, opt, asan), or they don&#x27;t know how to configure the build system.  Plain make generally isn&#x27;t good enough.<p>- Some flags have to be passed to both the compiler and link steps, and others don&#x27;t.  I mostly figured this out by trial and error, and the error messages aren&#x27;t great.<p>- You can compile and link in one driver invocation (c++ -o), or you can build each object separately and link (c++ -c).<p>I thought the former might be faster, and it seems simpler, but there doesn&#x27;t seem to be any real advantage (edit: this post explains why -- it&#x27;s literally subprocessing, which you can do better from a shell or build system).  The latter is more common because it supports parallel and incremental builds.<p>Some options, I think -ftime-trace for Clang, which outputs JSON compile time traces, don&#x27;t even respect the first style of building.<p>- Spending some time with a plain shell script and the compiler isn&#x27;t a bad way to learn.  Now I can finally read all those crappy long error commands from big build systems.  The most common and useful flags are -I to add to the #include path and -D to define a preprocessor symbol.<p>---<p>edit after skimming the whole thing: This is really excellent, should be titled &quot;Compilers: The Missing Manual&quot;.<p>I have actually looked at the manuals, e.g. <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-13.1.0&#x2F;gcc&#x2F;Invoking-GCC.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-13.1.0&#x2F;gcc&#x2F;Invoking-GCC.h...</a>  but they seem to be missing the high level conceptual overview.<p>They also seem to be missing the name &quot;driver&quot;, which is important, even though I have encountered a page about that before.  It seems to be in a separate &quot;GCC Internals&quot; doc:<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.3.2&#x2F;gccint&#x2F;Driver.html#Driver" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.3.2&#x2F;gccint&#x2F;Driver.html#...</a><p>Other notes: I should have been using the -v flag to the driver all along!  That&#x27;s a little embarrassing.<p>Also it&#x27;s good to realize that g++ and gcc are both drivers, and the former sets the -I path to the location of the C++ stdlib and so forth.<p>Looks like lots of great examples of &#x27;readelf&#x27; as well, which I&#x27;ll go over again.<p>It is kind of crazy how people generally pick this up piecemeal over so many years ... A big problem in my mind is that it&#x27;s usually wrapped in GNU make or CMake or IDE configs, which add their own line noise on top of the raw driver invocations.  Which in turn have a ton of logic before the actual tools are invoked.</div><br/><div id="35812765" class="c"><input type="checkbox" id="c-35812765" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#35809620">parent</a><span>|</span><a href="#35806953">next</a><span>|</span><label class="collapse" for="c-35812765">[-]</label><label class="expand" for="c-35812765">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - the order of objects and -l flags to the linker matters! I remember being very surprised &#x2F; frustrated by this.<p>This took so long for me to actually find out... and then beat most build systems into submission because they have no ability to configure priority of linkage.</div><br/></div></div></div></div><div id="35806953" class="c"><input type="checkbox" id="c-35806953" checked=""/><div class="controls bullet"><span class="by">argulane</span><span>|</span><a href="#35809620">prev</a><span>|</span><label class="collapse" for="c-35806953">[-]</label><label class="expand" for="c-35806953">[1 more]</label></div><br/><div class="children"><div class="content">That is a pretty good introduction to the steps that happen when you compile C code.</div><br/></div></div></div></div></div></div></div></body></html>