<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707210060341" as="style"/><link rel="stylesheet" href="styles.css?v=1707210060341"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/corkami/collisions">Hash collisions and exploitations (2019)</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>lnyan</span> | <span>9 comments</span></div><br/><div><div id="39271791" class="c"><input type="checkbox" id="c-39271791" checked=""/><div class="controls bullet"><span class="by">randomstring</span><span>|</span><a href="#39268804">next</a><span>|</span><label class="collapse" for="c-39271791">[-]</label><label class="expand" for="c-39271791">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if you could construct a hash collision for high pagerank sites in the google (or Bing) index. You would need to know what hash algorithm google uses to store URLs. This is assuming that they hash the URLs for their indexing. Which surely they do. MD5 and SHA1 existed when google was founded, but hash collisions weren&#x27;t a big concern until later IIRC. You&#x27;d want a fast algorithm because you&#x27;re having to run your hashing algorithm on every URL you encounter on every page, and that adds up quickly.<p>The max legal length of URLS is 2048, but I wouldn&#x27;t be surprised if there aren&#x27;t plenty of non-compliant URLs longer than that in the wild. If you were limited to 2048 characters, and a valid URL format, I suspect it would be hard if not impossible to build a URL with the same MD5 of an arbitrary high ranking URL like &quot;<a href="https:&#x2F;&#x2F;nytimes.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nytimes.com&#x2F;</a>&quot; But what if you just wanted to piggy back the pagerank of any mid to high rank site? Is there a URL in the top million ranked URLs you could MD5 hash collide?<p>I doubt google would use a URL hash as strong and as slow as MD5. Maybe Page and Brin weren&#x27;t even thinking about cryptographic hashes, and just a good mixing function.</div><br/><div id="39272359" class="c"><input type="checkbox" id="c-39272359" checked=""/><div class="controls bullet"><span class="by">Genbox</span><span>|</span><a href="#39271791">parent</a><span>|</span><a href="#39272148">next</a><span>|</span><label class="collapse" for="c-39272359">[-]</label><label class="expand" for="c-39272359">[1 more]</label></div><br/><div class="children"><div class="content">Google has developed several non-cryptographic hash functions. CityHash, FarmHash, and HighwayHash come to mind. BigQuery provides FarmHash next to the MD5 and SHA-family of cryptographic hash functions. Who knows, maybe they use FarmHash today to index page URLs.</div><br/></div></div><div id="39272148" class="c"><input type="checkbox" id="c-39272148" checked=""/><div class="controls bullet"><span class="by">aaron695</span><span>|</span><a href="#39271791">parent</a><span>|</span><a href="#39272359">prev</a><span>|</span><a href="#39268804">next</a><span>|</span><label class="collapse" for="c-39272148">[-]</label><label class="expand" for="c-39272148">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Is there a URL in the top million ranked URLs you could MD5 hash collide?<p>This is answered in the article. No<p>&quot;Q: Is it possible to make a file get an arbitrary MD2&#x2F;MD4&#x2F;MD5&#x2F;MD6&#x2F;SHA1&#x2F;SHA2&#x2F;SHA3, or the same hash as another file? A: No.&quot;<p>I&#x27;m not sure page ranking works that way.<p>But you could get people to share www.nytimes.com&#x2F;2011&#x2F;05&#x2F;02&#x2F;world&#x2F;asia&#x2F;osama-bin-laden-is-killed.html?garbage=blahblah and collision it with your site crappyproduct.com?rubbish=meh</div><br/></div></div></div></div><div id="39268804" class="c"><input type="checkbox" id="c-39268804" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#39271791">prev</a><span>|</span><label class="collapse" for="c-39268804">[-]</label><label class="expand" for="c-39268804">[5 more]</label></div><br/><div class="children"><div class="content">I personally find it amazing that everything we have made - every photograph, every book, every movie, and everything we will ever make can be given a unique 256 bit fingerprint that has a negligible chance of collision before the heat death of the universe.</div><br/><div id="39269046" class="c"><input type="checkbox" id="c-39269046" checked=""/><div class="controls bullet"><span class="by">nighthawk454</span><span>|</span><a href="#39268804">parent</a><span>|</span><a href="#39270660">next</a><span>|</span><label class="collapse" for="c-39269046">[-]</label><label class="expand" for="c-39269046">[2 more]</label></div><br/><div class="children"><div class="content">an interesting comparison is 2^256 ~= 1e77 ~= 0.001 x the number of atoms in the universe. So in 256 bits we almost have enough combinations to assign every particle _there is_. Considering we&#x27;ve made considerably fewer works than there are particles, you could probably actually get pretty far along collision resistance by just assigning fingerprints randomly. Another way to look at that is UUIDs are only 128 bits (sqrt as many combinations, 1e38) and they&#x27;re pretty resistant. Another amazement is that we can have a deterministic hashing function to select a fingerprint _based on the content_ in a way that preserves collision resistance.<p>For a similar thought experiment, consider the space of all 1920x1080 RGB images , which necessarily contains all films ever made or ever _could_ be made, screenshots of future stock prices (including all the wrong ones), and pictures of your great great great grandchildren (or not). Then figure that randomly sampling that space just gives white noise – suggesting our &#x27;content&#x27; probably isn&#x27;t a large fraction of the total space. :)<p><a href="https:&#x2F;&#x2F;robson.plus&#x2F;white-noise-image-generator&#x2F;" rel="nofollow">https:&#x2F;&#x2F;robson.plus&#x2F;white-noise-image-generator&#x2F;</a></div><br/><div id="39271952" class="c"><input type="checkbox" id="c-39271952" checked=""/><div class="controls bullet"><span class="by">Doxin</span><span>|</span><a href="#39268804">root</a><span>|</span><a href="#39269046">parent</a><span>|</span><a href="#39270660">next</a><span>|</span><label class="collapse" for="c-39271952">[-]</label><label class="expand" for="c-39271952">[1 more]</label></div><br/><div class="children"><div class="content">My ISP hands out IPv6 &#x2F;48 subnets. The upside of this is that every customer of theirs gets enough IP addresses to give every grain of sand on the planet a couple.<p>Big numbers get big quick.</div><br/></div></div></div></div><div id="39270660" class="c"><input type="checkbox" id="c-39270660" checked=""/><div class="controls bullet"><span class="by">ralusek</span><span>|</span><a href="#39268804">parent</a><span>|</span><a href="#39269046">prev</a><span>|</span><label class="collapse" for="c-39270660">[-]</label><label class="expand" for="c-39270660">[2 more]</label></div><br/><div class="children"><div class="content">Yes. Even with 128 bits (uuid), I like that the policy is simply to treat each one as universally unique without needing to check any system for collision</div><br/><div id="39270967" class="c"><input type="checkbox" id="c-39270967" checked=""/><div class="controls bullet"><span class="by">jojobas</span><span>|</span><a href="#39268804">root</a><span>|</span><a href="#39270660">parent</a><span>|</span><label class="collapse" for="c-39270967">[-]</label><label class="expand" for="c-39270967">[1 more]</label></div><br/><div class="children"><div class="content">As Raymond Chen put it, if you&#x27;re worrying about UUID collisions, you need to also worry about way more probably things, such as random memory bit flips.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>