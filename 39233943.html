<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706950856991" as="style"/><link rel="stylesheet" href="styles.css?v=1706950856991"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/SubscriberLink/959562/0578b8e463f790c1/">OpenBSD System-Call Pinning</a> <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>rwmj</span> | <span>50 comments</span></div><br/><div><div id="39235239" class="c"><input type="checkbox" id="c-39235239" checked=""/><div class="controls bullet"><span class="by">yobert</span><span>|</span><a href="#39235320">next</a><span>|</span><label class="collapse" for="c-39235239">[-]</label><label class="expand" for="c-39235239">[25 more]</label></div><br/><div class="children"><div class="content">&gt; The direct-syscalls-inside-the-binary model used by go (and only go, noone else in the history of the unix software does this) provided the biggest resistance against this effort&quot;.<p>I know this annoys unix people. But I have to say I actually really like that Go shakes this up. I believe the C function monopoly just isn&#x27;t healthy for things. You should be able to make a new completely unrelated language. The Go developers were the first in a long time to do this, not because they are stupid, but because they were ambitious.</div><br/><div id="39235475" class="c"><input type="checkbox" id="c-39235475" checked=""/><div class="controls bullet"><span class="by">anonacct37</span><span>|</span><a href="#39235239">parent</a><span>|</span><a href="#39237824">next</a><span>|</span><label class="collapse" for="c-39235475">[-]</label><label class="expand" for="c-39235475">[15 more]</label></div><br/><div class="children"><div class="content">I do like this about go. And on Linux it arguably makes sense (I say arguable because DNS without CGO is still a common cause of issues and incompatibility).<p>But Linux has, to the best of my understanding said &quot;yes, we are ok with users using syscalls&quot;. Linux doesn&#x27;t think that glibc is the only project allowed to interface with the kernel.<p>But for other platforms like OpenBSD and windows they are quite simply relying on implementation details that the vendors consider to be a private and unsupported interface.<p>This whole thing is also separate from &quot;is making libc the only caller of the syscalls instruction&quot; a good and meaningful security improvement.</div><br/><div id="39236901" class="c"><input type="checkbox" id="c-39236901" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39235475">parent</a><span>|</span><a href="#39235728">next</a><span>|</span><label class="collapse" for="c-39236901">[-]</label><label class="expand" for="c-39236901">[3 more]</label></div><br/><div class="children"><div class="content">Most unixes allow for static binaries. And most unixes allow for you to run a static binary compiled for an older OS on a newer OS. In order for that to work, the syscall interface needs to be at least mostly stable.<p>Yes, if you&#x27;re writing netstat or lsof or ps or something, you need tight coupling with the binary and the kernel, and you can argue Linux does that better, but most people aren&#x27;t writing netstat or lsof or ps.</div><br/><div id="39237821" class="c"><input type="checkbox" id="c-39237821" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39236901">parent</a><span>|</span><a href="#39235728">next</a><span>|</span><label class="collapse" for="c-39237821">[-]</label><label class="expand" for="c-39237821">[2 more]</label></div><br/><div class="children"><div class="content">Even those get most of their info from &#x2F;proc and &#x2F;sys rather than special syscalls</div><br/><div id="39238219" class="c"><input type="checkbox" id="c-39238219" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39237821">parent</a><span>|</span><a href="#39235728">next</a><span>|</span><label class="collapse" for="c-39238219">[-]</label><label class="expand" for="c-39238219">[1 more]</label></div><br/><div class="children"><div class="content">On the BSDs they sure don&#x27;t, &#x2F;proc (for its role referred to) and &#x2F;sys are peculiar to Linux, &#x2F;proc is not even mounted by default on FreeBSD, is deprecated and doesn&#x27;t exist on OpenBSD. On OpenBSD&#x2F;FreeBSD most of the info comes out with sysctl(3) or reading kernel memory directly.</div><br/></div></div></div></div></div></div><div id="39235728" class="c"><input type="checkbox" id="c-39235728" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39235475">parent</a><span>|</span><a href="#39236901">prev</a><span>|</span><a href="#39235994">next</a><span>|</span><label class="collapse" for="c-39235728">[-]</label><label class="expand" for="c-39235728">[1 more]</label></div><br/><div class="children"><div class="content">Windows also provides language-independent ways of calling low-level (and pretty high-level) OS interfaces.<p>The library you have to link to access system services is not going to pollute your language environment with bad runtime.</div><br/></div></div><div id="39235994" class="c"><input type="checkbox" id="c-39235994" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39235475">parent</a><span>|</span><a href="#39235728">prev</a><span>|</span><a href="#39238077">next</a><span>|</span><label class="collapse" for="c-39235994">[-]</label><label class="expand" for="c-39235994">[8 more]</label></div><br/><div class="children"><div class="content">&gt; I say arguable because DNS without CGO is still a common cause of issues and incompatibility<p>DNS without CGO works perfectly.  The vendor specific ad hoc mechanisms for extending DNS in a site local context are not well supported.  If they were implemented more sensibly,  then Go,  or any other language,  would have no problem taking advantage of them even without the &quot;C Library Resolver.&quot;<p>Speaking of which,  that &quot;C Library Resolver,&quot; in my opinion, has one of the worst library interfaces in all of unix.  It&#x27;s not at all a hill worth new projects dying on.</div><br/><div id="39237358" class="c"><input type="checkbox" id="c-39237358" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39235994">parent</a><span>|</span><a href="#39236161">next</a><span>|</span><label class="collapse" for="c-39237358">[-]</label><label class="expand" for="c-39237358">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The vendor specific ad hoc mechanisms for extending DNS in a site local context are not well supported<p>DNS is one of those things that OS vendors think should be extendable and configurable. It allows VPN apps to redirect DNS only for certain subdomains, for example, which enables proper split-horizon DNS. I think this is totally reasonable behavior, and it’s undeniably useful. If a particular programming language reimplements DNS on its own, you lose guarantees that the OS is striving to provide to the user.<p>You can make the case that OS’s shouldn’t make these guarantees, and we’re free to disagree on that, but from a practical standpoint it is a very useful feature and it sucks that pure Go apps don’t work with it.</div><br/><div id="39238165" class="c"><input type="checkbox" id="c-39238165" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39237358">parent</a><span>|</span><a href="#39236161">next</a><span>|</span><label class="collapse" for="c-39238165">[-]</label><label class="expand" for="c-39238165">[1 more]</label></div><br/><div class="children"><div class="content">The right way to do this is specify a resolver to use on localhost</div><br/></div></div></div></div><div id="39236161" class="c"><input type="checkbox" id="c-39236161" checked=""/><div class="controls bullet"><span class="by">anonacct37</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39235994">parent</a><span>|</span><a href="#39237358">prev</a><span>|</span><a href="#39238077">next</a><span>|</span><label class="collapse" for="c-39236161">[-]</label><label class="expand" for="c-39236161">[5 more]</label></div><br/><div class="children"><div class="content">&gt; DNS without CGO works perfectly<p>It does not. I know this because it impacts my daily work and the work of others. Honestly if you could make my day and go figure out exactly what&#x27;s going wrong with the pure go DNS implementation it would make my life alot simpler and I wouldn&#x27;t have to maintain shell scripts that update etc&#x2F;hosts to hard code in ipv4 addresses for the APIs I access with terraform.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;hashicorp&#x2F;terraform-provider-google&#x2F;issues&#x2F;6782">https:&#x2F;&#x2F;github.com&#x2F;hashicorp&#x2F;terraform-provider-google&#x2F;issue...</a></div><br/><div id="39236780" class="c"><input type="checkbox" id="c-39236780" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39236161">parent</a><span>|</span><a href="#39238077">next</a><span>|</span><label class="collapse" for="c-39236780">[-]</label><label class="expand" for="c-39236780">[4 more]</label></div><br/><div class="children"><div class="content">It seems like the explanation might be right there in that issue.  The server is occasionally not successfully sending the A record and you&#x27;re getting bad fallback behavior due to the way the dial call is imprecisely constructed and this is masking the underlying problem.  The code,  as written,  is doing exactly what you would expect in this scenario.<p>Should it be your DNS resolver library that takes stock of your OS environment and only make calls for A records and not AAAA records when it &quot;detects&quot; some configuration?<p>Shouldn&#x27;t your application itself have an environment variable or command line option that allows you to specify that your dials should only be done using tcp4?  Wouldn&#x27;t this be immensely useful to have outside of &quot;auto detection&quot; in some library somewhere?</div><br/><div id="39238342" class="c"><input type="checkbox" id="c-39238342" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39236780">parent</a><span>|</span><a href="#39237687">next</a><span>|</span><label class="collapse" for="c-39238342">[-]</label><label class="expand" for="c-39238342">[1 more]</label></div><br/><div class="children"><div class="content">Why should every application be aware of whether it is running on a v4 or v6 network? If the application merely wants to connect to an external service, that is firmly in the OS&#x27;s job to decide.<p>As a user, if ipv6 is flaky today, I want one central place to configure for ipv4 only, I don&#x27;t want to go and change every application&#x27;settings only to revert that tomorrow.</div><br/></div></div><div id="39237687" class="c"><input type="checkbox" id="c-39237687" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39236780">parent</a><span>|</span><a href="#39238342">prev</a><span>|</span><a href="#39237345">next</a><span>|</span><label class="collapse" for="c-39237687">[-]</label><label class="expand" for="c-39237687">[1 more]</label></div><br/><div class="children"><div class="content">Oh.. right.
So we need another configuration for each and every application for something almost always system wide and can change dynamically (like wifi reconnecting) ?</div><br/></div></div></div></div></div></div></div></div><div id="39238077" class="c"><input type="checkbox" id="c-39238077" checked=""/><div class="controls bullet"><span class="by">Varriount</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39235475">parent</a><span>|</span><a href="#39235994">prev</a><span>|</span><a href="#39237824">next</a><span>|</span><label class="collapse" for="c-39238077">[-]</label><label class="expand" for="c-39238077">[2 more]</label></div><br/><div class="children"><div class="content"><i>Does</i> Go use direct syscalls on Windows? Last time I looked, I could have sworn Go&#x27;s source used the standard Windows system DLLs.</div><br/><div id="39238498" class="c"><input type="checkbox" id="c-39238498" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39238077">parent</a><span>|</span><a href="#39237824">next</a><span>|</span><label class="collapse" for="c-39238498">[-]</label><label class="expand" for="c-39238498">[1 more]</label></div><br/><div class="children"><div class="content">On Windows it never did, and on other platforms, other than Linux, it has been forced to accept that isn&#x27;t the way OS vendors play the game.</div><br/></div></div></div></div></div></div><div id="39237824" class="c"><input type="checkbox" id="c-39237824" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#39235239">parent</a><span>|</span><a href="#39235475">prev</a><span>|</span><a href="#39238211">next</a><span>|</span><label class="collapse" for="c-39237824">[-]</label><label class="expand" for="c-39237824">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think syscall-vs-C-function is at all meaningful for someone making a completely unrelated language. The system has to pick <i>some</i> ABI for communicating with the kernel, and syscalls don&#x27;t change that. The ISA generally doesn&#x27;t define how arguments are passed, it&#x27;s really just in the business of providing a fancy jump instruction.<p>Arguably, using the same ABI for userspace C functions and for communicating with the kernel <i>reduces</i> the amount of work required of completely new languages, because they are likely to need C interop support anyway.</div><br/></div></div><div id="39238211" class="c"><input type="checkbox" id="c-39238211" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#39235239">parent</a><span>|</span><a href="#39237824">prev</a><span>|</span><a href="#39235476">next</a><span>|</span><label class="collapse" for="c-39238211">[-]</label><label class="expand" for="c-39238211">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;d like the OpenBSD approach a lot more if the specially privileged syscall library was a language-agnostic library just for syscalls instead of libc.<p>Also, if you&#x27;re gonna add new ELF sections anyway, why not do syscall &quot;relocation&quot; directly (with a similar randomization like ASLR) instead of going through stubs? This &quot;relocation&quot; doesn&#x27;t actually need to change any memory or use any offset tables since the syscall numbers are a farce under the new system anyway. Just make it a map of the location of syscall instructions to implied syscall numbers. Once you&#x27;ve phased out the old syscall model, you can even repurpose RAX as an additional syscall parameter.</div><br/></div></div><div id="39235476" class="c"><input type="checkbox" id="c-39235476" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#39235239">parent</a><span>|</span><a href="#39238211">prev</a><span>|</span><a href="#39235321">next</a><span>|</span><label class="collapse" for="c-39235476">[-]</label><label class="expand" for="c-39235476">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t about Go vs C.  This is about about indirection of system calls through stubs and also in a way about static linking vs. dynamic linking.  Something like this could be done for C and others, but the kernel would have to walk the C stack to ensure that a) the callers of the system calls are run-time library stubs listed in the ELF, and b) that the callers of the <i>stubs</i> are listed in the ELFs (plural).  Clearly this is easier to do if there&#x27;s neither stubs nor dynamic linking, but that&#x27;s not a reason to think Go is somehow superior to the rest.</div><br/></div></div><div id="39235321" class="c"><input type="checkbox" id="c-39235321" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39235239">parent</a><span>|</span><a href="#39235476">prev</a><span>|</span><a href="#39236029">next</a><span>|</span><label class="collapse" for="c-39235321">[-]</label><label class="expand" for="c-39235321">[5 more]</label></div><br/><div class="children"><div class="content">My hot take here is that this split exists because of the way that Linux development works differently than other Unices and other operating systems. Essentially, it&#x27;s an example of Conway&#x27;s Law.<p>As always, things are about API boundaries: what is internal to you, and what is exposed externally to your users.<p>With Linux, well, we all know the rms copypasta: &quot;I&#x27;d just like to interject for a moment.  What you&#x27;re referring to as Linux,
is in fact, GNU&#x2F;Linux, or as I&#x27;ve recently taken to calling it, GNU plus Linux.&quot; This is a joke, but it also points to something real and serious: Linux, being just a kernel, means that they provide a stable kernel API. glibc, being written by a different organization, builds on top of that API and adds its own stable API.<p>By contrast, many other operating systems are developed as a full operating system. They don&#x27;t produce a kernel as a standalone component. As such, they choose some other sort of boundary as the API for the OS. On unices, that&#x27;s often the libc. On Windows, that&#x27;s the Windows API, of which win32 is an example.<p>There are good reasons to not make the kernel your API boundary. Different systems make different choices, and that&#x27;s a good thing, not a bad thing.</div><br/><div id="39236009" class="c"><input type="checkbox" id="c-39236009" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39235321">parent</a><span>|</span><a href="#39236029">next</a><span>|</span><label class="collapse" for="c-39236009">[-]</label><label class="expand" for="c-39236009">[4 more]</label></div><br/><div class="children"><div class="content">&gt; There are good reasons to not make the kernel your API boundary.<p>Good reasons for the developers,  not so much for the end users.</div><br/><div id="39236250" class="c"><input type="checkbox" id="c-39236250" checked=""/><div class="controls bullet"><span class="by">SSLy</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39236009">parent</a><span>|</span><a href="#39236051">next</a><span>|</span><label class="collapse" for="c-39236250">[-]</label><label class="expand" for="c-39236250">[2 more]</label></div><br/><div class="children"><div class="content">WinNT seems to do just fine with that. And it&#x27;s only because of users insisting on using abandonware</div><br/><div id="39237753" class="c"><input type="checkbox" id="c-39237753" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39236250">parent</a><span>|</span><a href="#39236051">next</a><span>|</span><label class="collapse" for="c-39237753">[-]</label><label class="expand" for="c-39237753">[1 more]</label></div><br/><div class="children"><div class="content">Developers works on win32api, not the kernel side NT* whatever stuffs.</div><br/></div></div></div></div><div id="39236051" class="c"><input type="checkbox" id="c-39236051" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39235239">root</a><span>|</span><a href="#39236009">parent</a><span>|</span><a href="#39236250">prev</a><span>|</span><a href="#39236029">next</a><span>|</span><label class="collapse" for="c-39236051">[-]</label><label class="expand" for="c-39236051">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t agree that those two things are at odds.</div><br/></div></div></div></div></div></div><div id="39236029" class="c"><input type="checkbox" id="c-39236029" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#39235239">parent</a><span>|</span><a href="#39235321">prev</a><span>|</span><a href="#39235320">next</a><span>|</span><label class="collapse" for="c-39236029">[-]</label><label class="expand" for="c-39236029">[1 more]</label></div><br/><div class="children"><div class="content">Anything statically linked to the C library will also have direct syscalls in the binary.</div><br/></div></div></div></div><div id="39235320" class="c"><input type="checkbox" id="c-39235320" checked=""/><div class="controls bullet"><span class="by">brynet</span><span>|</span><a href="#39235239">prev</a><span>|</span><a href="#39234660">next</a><span>|</span><label class="collapse" for="c-39235320">[-]</label><label class="expand" for="c-39235320">[1 more]</label></div><br/><div class="children"><div class="content">Library relinking, mimmutable(2), xonly, along with other recent developments such as the removal of indirect syscall(2), make syscall pinning all the more interesting, and raise the bar against attackers significantly.<p>One can only hope that more will eventually find its way into Linux, like with how paid employees at Google have been spending the past ~6 months cloning mimmutable (which HN characters decried as &quot;useless&quot;) to make mseal() for defending Chrome.<p><a href="https:&#x2F;&#x2F;marc.info&#x2F;?l=linux-kernel&amp;w=2&amp;r=1&amp;s=mseal&amp;q=b" rel="nofollow">https:&#x2F;&#x2F;marc.info&#x2F;?l=linux-kernel&amp;w=2&amp;r=1&amp;s=mseal&amp;q=b</a></div><br/></div></div><div id="39234660" class="c"><input type="checkbox" id="c-39234660" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39235320">prev</a><span>|</span><a href="#39234339">next</a><span>|</span><label class="collapse" for="c-39234660">[-]</label><label class="expand" for="c-39234660">[3 more]</label></div><br/><div class="children"><div class="content">From comments:<p>&gt; avoiding [...] errno<p>Note that errno <i>can</i> be optimized by a sufficiently smart compiler, simply by treating it as a register, then annotating various functions with whether it is preserved, clobbered, or conditionally used for return.<p>The libc boundary is quite annoying though; for this case in particular, that it doesn&#x27;t expose the fact that errno is at a fixed offset from the TLS register. And generally, libc is vehemently opposed to the existence of smart compilers, since all libc calls are expected to be treated as opaque barriers.</div><br/><div id="39234846" class="c"><input type="checkbox" id="c-39234846" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39234660">parent</a><span>|</span><a href="#39234883">next</a><span>|</span><label class="collapse" for="c-39234846">[-]</label><label class="expand" for="c-39234846">[1 more]</label></div><br/><div class="children"><div class="content">well, yes, but you need whole-program compilation.</div><br/></div></div></div></div><div id="39234339" class="c"><input type="checkbox" id="c-39234339" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39234660">prev</a><span>|</span><a href="#39236251">next</a><span>|</span><label class="collapse" for="c-39234339">[-]</label><label class="expand" for="c-39234339">[13 more]</label></div><br/><div class="children"><div class="content">System call pinning has been a classic example of an OpenBSD approach to exploit mitigation that exploit developers dunk on; a thread just a couple months ago:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38579913">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38579913</a><p>I think? this is the same work, just now merged into the kernel?</div><br/><div id="39235687" class="c"><input type="checkbox" id="c-39235687" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39234339">parent</a><span>|</span><a href="#39234976">next</a><span>|</span><label class="collapse" for="c-39235687">[-]</label><label class="expand" for="c-39235687">[7 more]</label></div><br/><div class="children"><div class="content">Has that &quot;dunking&quot; manifested in actual exploits?</div><br/><div id="39236301" class="c"><input type="checkbox" id="c-39236301" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39235687">parent</a><span>|</span><a href="#39234976">next</a><span>|</span><label class="collapse" for="c-39236301">[-]</label><label class="expand" for="c-39236301">[6 more]</label></div><br/><div class="children"><div class="content">I dunno. Has it?</div><br/><div id="39236421" class="c"><input type="checkbox" id="c-39236421" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39236301">parent</a><span>|</span><a href="#39234976">next</a><span>|</span><label class="collapse" for="c-39236421">[-]</label><label class="expand" for="c-39236421">[5 more]</label></div><br/><div class="children"><div class="content">Well since <a href="https:&#x2F;&#x2F;www.openbsd.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.openbsd.org&#x2F;</a> still says<p>&gt; Only two remote holes in the default install, in a heck of a long time!<p>I&#x27;m <i>assuming</i> not, but I could always be mistaken.</div><br/><div id="39237629" class="c"><input type="checkbox" id="c-39237629" checked=""/><div class="controls bullet"><span class="by">opnitro</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39236421">parent</a><span>|</span><a href="#39234976">next</a><span>|</span><label class="collapse" for="c-39237629">[-]</label><label class="expand" for="c-39237629">[4 more]</label></div><br/><div class="children"><div class="content">This is a _very_ qualified statement. The default OpenBSD install enables an extremely small amount of services by default, which is why they can claim that. I&#x27;m not saying that&#x27;s wrong, or a bad idea, but obviously a platform that doesn&#x27;t enable many network services is going to have a small amount of remote holes.<p>this is on top of a lot of very careful programming and interesting security research, and this post isn&#x27;t meant to take anything away from the OpenBSD devs.</div><br/><div id="39237708" class="c"><input type="checkbox" id="c-39237708" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39237629">parent</a><span>|</span><a href="#39234976">next</a><span>|</span><label class="collapse" for="c-39237708">[-]</label><label class="expand" for="c-39237708">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The default OpenBSD install enables an extremely small amount of services by default, which is why they can claim that.<p>Probably this issue has been hashed out many times over the decades, but arguably the security gain isn&#x27;t a fortunate or incidental benefit of minimizing default enabled services, nor a cheat like weighted dice, it&#x27;s a very real benefit resulting from an effective, intentional technique. Maybe other OSes should do the same, and then everyone would have that benefit.<p>The other OSes have other priorities, and that&#x27;s fine. Embrace that. Yes, most users (and developers) don&#x27;t want to deal with the compatibility issues. But when you say OpenBSD has few default security holes because they have few default services, that&#x27;s a complement.</div><br/><div id="39238131" class="c"><input type="checkbox" id="c-39238131" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39237708">parent</a><span>|</span><a href="#39234976">next</a><span>|</span><label class="collapse" for="c-39238131">[-]</label><label class="expand" for="c-39238131">[2 more]</label></div><br/><div class="children"><div class="content">SEL4 is <i>proven</i> correct. Formally verified. No security holes in the default install, of any sort, ever. I mean, it doesn&#x27;t do anything. But it has no security holes, with almost mathematical certainty.</div><br/><div id="39238161" class="c"><input type="checkbox" id="c-39238161" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39238131">parent</a><span>|</span><a href="#39234976">next</a><span>|</span><label class="collapse" for="c-39238161">[-]</label><label class="expand" for="c-39238161">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I get it, and obviously the question is where people want a balance. OpenBSD does more than nothing, less than SELinux-secured Linux, which does less than some other things.<p>Also, doesn&#x27;t SEL4 have widespread, practical application? IIRC as the microkernal (maybe under Minix?) on the baseband hardware on cell phones? Maybe I&#x27;m confusing it with something else.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39234976" class="c"><input type="checkbox" id="c-39234976" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39234339">parent</a><span>|</span><a href="#39235687">prev</a><span>|</span><a href="#39235424">next</a><span>|</span><label class="collapse" for="c-39234976">[-]</label><label class="expand" for="c-39234976">[1 more]</label></div><br/><div class="children"><div class="content">There is a paragraph in the article dedicated to this, starting with:<p>&gt; Security researchers have expressed doubt about how useful this check is at preventing compromises.<p>Doesn&#x27;t cite the HN thread, but two other cases.<p>&gt; I think? this is the same work, just now merged into the kernel?<p>That is my understanding, yes. From the article:<p>&gt; In December, De Raadt sent a patch to the OpenBSD mailing list expanding OpenBSD&#x27;s restrictions on the locations from which a process can make system calls. ... Now that patch has been merged, finishing a process which De Raadt said has taken five years.</div><br/></div></div><div id="39235424" class="c"><input type="checkbox" id="c-39235424" checked=""/><div class="controls bullet"><span class="by">PrimeMcFly</span><span>|</span><a href="#39234339">parent</a><span>|</span><a href="#39234976">prev</a><span>|</span><a href="#39236251">next</a><span>|</span><label class="collapse" for="c-39235424">[-]</label><label class="expand" for="c-39235424">[4 more]</label></div><br/><div class="children"><div class="content">&gt; a classic example of an OpenBSD approach to exploit mitigation that exploit developers dunk on<p>Part of why it is hard to take its reputation as as security focused OS seriously.</div><br/><div id="39235592" class="c"><input type="checkbox" id="c-39235592" checked=""/><div class="controls bullet"><span class="by">irdc</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39235424">parent</a><span>|</span><a href="#39236251">next</a><span>|</span><label class="collapse" for="c-39235592">[-]</label><label class="expand" for="c-39235592">[3 more]</label></div><br/><div class="children"><div class="content">In their defence, the OpenBSD developers do put their mon^H^H^Htime where their mouth is and release their work even with dubious features included. How much those features <i>actually</i> matter, instead of how much expert opinion says they matter, can then be judged in the wild.<p>Failed experiments are also a good part of research.</div><br/><div id="39235832" class="c"><input type="checkbox" id="c-39235832" checked=""/><div class="controls bullet"><span class="by">PrimeMcFly</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39235592">parent</a><span>|</span><a href="#39236251">next</a><span>|</span><label class="collapse" for="c-39235832">[-]</label><label class="expand" for="c-39235832">[2 more]</label></div><br/><div class="children"><div class="content">What can also be judged is ignoring expert advice in favor of rolling their own inferior solutions.</div><br/><div id="39237073" class="c"><input type="checkbox" id="c-39237073" checked=""/><div class="controls bullet"><span class="by">user3939382</span><span>|</span><a href="#39234339">root</a><span>|</span><a href="#39235832">parent</a><span>|</span><a href="#39236251">next</a><span>|</span><label class="collapse" for="c-39237073">[-]</label><label class="expand" for="c-39237073">[1 more]</label></div><br/><div class="children"><div class="content">Whose and what expert advice did they ignore?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39236251" class="c"><input type="checkbox" id="c-39236251" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#39234339">prev</a><span>|</span><a href="#39235725">next</a><span>|</span><label class="collapse" for="c-39236251">[-]</label><label class="expand" for="c-39236251">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Security researchers have expressed doubt about how useful this check is at preventing compromises.<p>Well... if they are able to craft a call to a syscall from some random piece of memory you are already f-d and this little hurdle is at most going to be an annoyance.</div><br/></div></div><div id="39235725" class="c"><input type="checkbox" id="c-39235725" checked=""/><div class="controls bullet"><span class="by">marshray</span><span>|</span><a href="#39236251">prev</a><span>|</span><a href="#39235263">next</a><span>|</span><label class="collapse" for="c-39235725">[-]</label><label class="expand" for="c-39235725">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Another benefit is that it requires unique methodology for OpenBSD, which
requirements investment.&quot;<p>Secure in the absence of an attacker?<p>This part:<p><pre><code>    xx:   b8 05 00 00 00          mov    $0x5,%eax
    xx:   0f 05                   syscall 

    This means &quot;perform operation #5, which is open(2)&quot;

    Inside the kernel, we know the system call # and the address of
    the syscall instruction.
</code></pre>
Why can&#x27;t the attacker just jump to an existing syscall instruction? Maybe one followed soon by a return.<p><pre><code>  4) in libc.so&#x27;s table, all the system call stub &quot;syscall instructions&quot;
     are registered.    
</code></pre>
I don&#x27;t know a lot about binary exploitation techniques. Is all this entirely reliant on layout randomization?</div><br/></div></div><div id="39235263" class="c"><input type="checkbox" id="c-39235263" checked=""/><div class="controls bullet"><span class="by">philsnow</span><span>|</span><a href="#39235725">prev</a><span>|</span><a href="#39235450">next</a><span>|</span><label class="collapse" for="c-39235263">[-]</label><label class="expand" for="c-39235263">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Both [msyscall and pinsyscall] can only be invoked once by a given process, which is done by the dynamic linker.<p>How are&#x2F;were static executables handled?  I’m a little fuzzy on how execve notices that a given executable is dynamic (and needs ld.so to run it) or static (in which case.. it just jumps to the _start symbol?).  If the dynamic linker isn’t involved, what calls msyscall&#x2F;pinsyscall?</div><br/><div id="39235314" class="c"><input type="checkbox" id="c-39235314" checked=""/><div class="controls bullet"><span class="by">philsnow</span><span>|</span><a href="#39235263">parent</a><span>|</span><a href="#39235450">next</a><span>|</span><label class="collapse" for="c-39235314">[-]</label><label class="expand" for="c-39235314">[1 more]</label></div><br/><div class="children"><div class="content">Ah, found a good discussion of how it works in Linux <a href="https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2012&#x2F;08&#x2F;13&#x2F;how-statically-linked-programs-run-on-linux" rel="nofollow">https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2012&#x2F;08&#x2F;13&#x2F;how-statically-link...</a><p>Is it materially different in openbsd?</div><br/></div></div></div></div><div id="39235450" class="c"><input type="checkbox" id="c-39235450" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#39235263">prev</a><span>|</span><label class="collapse" for="c-39235450">[-]</label><label class="expand" for="c-39235450">[2 more]</label></div><br/><div class="children"><div class="content">Doesn’t macOS do something like this.</div><br/><div id="39238199" class="c"><input type="checkbox" id="c-39238199" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#39235450">parent</a><span>|</span><label class="collapse" for="c-39238199">[-]</label><label class="expand" for="c-39238199">[1 more]</label></div><br/><div class="children"><div class="content">It does not.</div><br/></div></div></div></div></div></div></div></div></div></body></html>