<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732093259552" as="style"/><link rel="stylesheet" href="styles.css?v=1732093259552"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://underjord.io/how-i-use-erlang-hot-code-updates.html">Using Erlang hot code updates</a> <span class="domain">(<a href="https://underjord.io">underjord.io</a>)</span></div><div class="subtext"><span>lawik</span> | <span>45 comments</span></div><br/><div><div id="42189283" class="c"><input type="checkbox" id="c-42189283" checked=""/><div class="controls bullet"><span class="by">jhgg</span><span>|</span><a href="#42190602">next</a><span>|</span><label class="collapse" for="c-42189283">[-]</label><label class="expand" for="c-42189283">[8 more]</label></div><br/><div class="children"><div class="content">When I worked at Discord, we used BEAM hot code loading pretty extensively, built a bunch of tooling around it to apply and track hot-patches to nodes (which in turn could update the code on &gt;100M processes in the system.) It allowed us to deploy hot-fixes in minutes (full tilt deploy could complete in a matter of seconds) to our stateful real-time system, rather than the usual ~hour long deploy cycle. We generally only used it for &quot;emergency&quot; updates though.<p>The tooling would let us patch multiple modules at a time, which basically wrapped `:rpc.call&#x2F;4` and `Code.eval_string&#x2F;1` to propagate the update across the cluster, which is to say, the hot-patch was entirely deployed over erlang&#x27;s built-in distribution.</div><br/><div id="42189462" class="c"><input type="checkbox" id="c-42189462" checked=""/><div class="controls bullet"><span class="by">davisp</span><span>|</span><a href="#42189283">parent</a><span>|</span><a href="#42191479">next</a><span>|</span><label class="collapse" for="c-42189462">[-]</label><label class="expand" for="c-42189462">[3 more]</label></div><br/><div class="children"><div class="content">This matches my experience. I spent a decade operating Erlang clusters and using hot code upgrades is a superpower for debugging a whole class of hard to track bugs. Although, without the tracking for cluster state it can be its own footgun when a hotpatch gets unpatched during a code deploy.<p>As for relups, I once tried starting a project to make them easier but eventually decided that the number of bazookas pointed at each and every toe made them basically a non-starter for anything that isn’t trivial. And if its trivial it was already covered by the nl (network load, send a local module to all nodes in the cluster and hot load it) style tooling.</div><br/></div></div><div id="42191479" class="c"><input type="checkbox" id="c-42191479" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42189283">parent</a><span>|</span><a href="#42189462">prev</a><span>|</span><a href="#42190602">next</a><span>|</span><label class="collapse" for="c-42191479">[-]</label><label class="expand" for="c-42191479">[4 more]</label></div><br/><div class="children"><div class="content">Can someone explain how this is not genuinely terrifying from a security perspective?</div><br/><div id="42191535" class="c"><input type="checkbox" id="c-42191535" checked=""/><div class="controls bullet"><span class="by">nelsonic</span><span>|</span><a href="#42189283">root</a><span>|</span><a href="#42191479">parent</a><span>|</span><a href="#42191565">next</a><span>|</span><label class="collapse" for="c-42191535">[-]</label><label class="expand" for="c-42191535">[2 more]</label></div><br/><div class="children"><div class="content">Where is the security problem? All code commits and builds can still be signed. All of this is just a more efficient way of deploying changes without dropping existing connections.<p>Are you suggesting that hot code replacement is somehow a attack vector?
Ericsson has been using this method for decades on critical infrastructure to patch switches without dropping live calls&#x2F;connections it works.<p>No need to fear Erlang&#x2F;BEAM.</div><br/><div id="42191567" class="c"><input type="checkbox" id="c-42191567" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42189283">root</a><span>|</span><a href="#42191535">parent</a><span>|</span><a href="#42191565">next</a><span>|</span><label class="collapse" for="c-42191567">[-]</label><label class="expand" for="c-42191567">[1 more]</label></div><br/><div class="children"><div class="content">My interpretation of the GP was that a code change in one node can be automagically propagated out to a cluster of participating Erlang nodes.<p>As a security person, this seems inherently dangerous. I asked why it <i>is</i> safe, because I presumed I’m missing something due to the lack of ever hearing about exploitation in the wild.</div><br/></div></div></div></div><div id="42191565" class="c"><input type="checkbox" id="c-42191565" checked=""/><div class="controls bullet"><span class="by">aunderscored</span><span>|</span><a href="#42189283">root</a><span>|</span><a href="#42191479">parent</a><span>|</span><a href="#42191535">prev</a><span>|</span><a href="#42190602">next</a><span>|</span><label class="collapse" for="c-42191565">[-]</label><label class="expand" for="c-42191565">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the same amount of terrifying as a regular deploy, you need to ensure that you limit access as needed</div><br/></div></div></div></div></div></div><div id="42190602" class="c"><input type="checkbox" id="c-42190602" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42189283">prev</a><span>|</span><a href="#42188905">next</a><span>|</span><label class="collapse" for="c-42190602">[-]</label><label class="expand" for="c-42190602">[1 more]</label></div><br/><div class="children"><div class="content">Code reloading on embedded Nerves devices is fantastic. If you have non-trivial hardware or state you can just hot load new code to test a fix live. Great for integration testing.<p>I literally used hot code reloading a few weeks back to fix a 4-20 mA circuit on a new beta firmware while a client was watching in remote Colorado. Told them I was “fixing a config”. Tested it on our device and then they checked it out over a satellite PLC system. Then I made an update Nerves FW, uploaded it. Made the client happy!<p>Note that I’ve found that using scp to copy the files to &#x2F;tmp and then use Code.compile to work better than copy and paste in IEx. The error messages get proper line numbers.<p>It’s also very simple to write a helper function to compile all the code in &#x2F;tmp and then delete it. I’ve got a similar one in my project that scp’s any changed elixir files in my project over. It’s pretty nice.</div><br/></div></div><div id="42188905" class="c"><input type="checkbox" id="c-42188905" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#42190602">prev</a><span>|</span><a href="#42189039">next</a><span>|</span><label class="collapse" for="c-42188905">[-]</label><label class="expand" for="c-42188905">[5 more]</label></div><br/><div class="children"><div class="content">I used to work on a pretty big elixir project that had many clients with long lived connections that ran jobs that weren&#x27;t easily resumable. Our company had a language agnostic deployment strategy based on docker, etc which meant we couldn&#x27;t do hot code updates even though they would have saved our customers some headache.<p>Honestly I wish we had had the ability to do both. Sometimes a change is so tricky that the argument that &quot;hot code updates are complicated and it&#x27;ll cause more issues than it will solve&quot; is very true, and maybe a deploy that forces everyone to reconnect is best for that sort of change. But often times we&#x27;d deploy some mundane thing where you don&#x27;t have to worry about upgrading state in a running gen server or whatever, and it&#x27;d be nice to have minimal impact.<p>Obviously that&#x27;s even more complexity piled onto the system, but every time I pushed some minor change and caused a retry that (in a perfect world at least...) didn&#x27;t <i>need</i> to retry, I winced a bit.</div><br/><div id="42189011" class="c"><input type="checkbox" id="c-42189011" checked=""/><div class="controls bullet"><span class="by">ElevenLathe</span><span>|</span><a href="#42188905">parent</a><span>|</span><a href="#42189039">next</a><span>|</span><label class="collapse" for="c-42189011">[-]</label><label class="expand" for="c-42189011">[4 more]</label></div><br/><div class="children"><div class="content">I work in gaming and have experienced the opposite side of this: many of our services have more than one &quot;kind&quot; of update, each with its own caveats and gotchas, so that it takes an expert in the whole system (meaning really almost ALL of our systems) to determine which would be the least impactful possible one if nothing goes wrong. Not only is there a lot of complexity and lost productivity in managing this process (&quot;Are we sure this change is zero downtime-able?&quot; &quot;Does it need a schema reload?&quot; etc) but we often get it wrong. The result is that, in practice, anything even remotely questionable gets done during a full downtime where we kick players out.<p>It&#x27;s sometimes helpful to have the option to just restart one little corner of the full system, to minimize impact, but it is helpful to <i>customer</i> experience (if we don&#x27;t screw it up) and very much the opposite for <i>developer</i> experience (it&#x27;s crippling to velocity to need to discuss each change with multiple experts and determine the appropriate type of release).</div><br/><div id="42189179" class="c"><input type="checkbox" id="c-42189179" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#42188905">root</a><span>|</span><a href="#42189011">parent</a><span>|</span><a href="#42189039">next</a><span>|</span><label class="collapse" for="c-42189179">[-]</label><label class="expand" for="c-42189179">[3 more]</label></div><br/><div class="children"><div class="content">No doubt that traditional deployments are much better for dev experience at (sometimes) the cost of customer experience.</div><br/><div id="42189443" class="c"><input type="checkbox" id="c-42189443" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42188905">root</a><span>|</span><a href="#42189179">parent</a><span>|</span><a href="#42189324">next</a><span>|</span><label class="collapse" for="c-42189443">[-]</label><label class="expand" for="c-42189443">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. Hot loading means I can have a very short cycle on an issue, and move onto something else. Having to think about the implications of hot loading is worth it for the rapid cycle time and not having to hold as many changes in my mind at once.</div><br/></div></div><div id="42189324" class="c"><input type="checkbox" id="c-42189324" checked=""/><div class="controls bullet"><span class="by">ElevenLathe</span><span>|</span><a href="#42188905">root</a><span>|</span><a href="#42189179">parent</a><span>|</span><a href="#42189443">prev</a><span>|</span><a href="#42189039">next</a><span>|</span><label class="collapse" for="c-42189324">[-]</label><label class="expand" for="c-42189324">[1 more]</label></div><br/><div class="children"><div class="content">One thing that would help both is deployment automation that could examine the desired changes and work out the best way to deploy them without human input. For distributed systems, this would require rock-solid contracts between individual services for all relevant scenarios, and would also require each update to be specified completely in code (or at least something machine readable), ideally in one commit. This is a level of maturity that seems elusive in gaming.</div><br/></div></div></div></div></div></div></div></div><div id="42189039" class="c"><input type="checkbox" id="c-42189039" checked=""/><div class="controls bullet"><span class="by">hauxir</span><span>|</span><a href="#42188905">prev</a><span>|</span><a href="#42189807">next</a><span>|</span><label class="collapse" for="c-42189039">[-]</label><label class="expand" for="c-42189039">[1 more]</label></div><br/><div class="children"><div class="content">We use hot code upgrades on kosmi.io with great success.<p>It&#x27;s absolute magic and allows for very rapid development and ease of deploying fixes and updates.<p>We do use have to use distillery though and have had to resort to a bunch of custom glue bash scripts which I wish was more standardized because it&#x27;s such a killer feature.<p>Due to Elixirs efficiency, everything is running on a single node despite thousands of concurrents so haven&#x27;t really experienced how it handles multiple nodes.</div><br/></div></div><div id="42189807" class="c"><input type="checkbox" id="c-42189807" checked=""/><div class="controls bullet"><span class="by">edude03</span><span>|</span><a href="#42189039">prev</a><span>|</span><a href="#42189286">next</a><span>|</span><label class="collapse" for="c-42189807">[-]</label><label class="expand" for="c-42189807">[4 more]</label></div><br/><div class="children"><div class="content">Nerves and hot code reloading got me into erlang after I watched a demo of patching code on a flying drone ~8 years ago.<p>While I can&#x27;t imagine hot reloading is super practicle in production, it does highlight that erlang&#x2F;beam&#x2F;otp has great primitives for building reliable production systems.</div><br/><div id="42191350" class="c"><input type="checkbox" id="c-42191350" checked=""/><div class="controls bullet"><span class="by">trq01758</span><span>|</span><a href="#42189807">parent</a><span>|</span><a href="#42190527">next</a><span>|</span><label class="collapse" for="c-42191350">[-]</label><label class="expand" for="c-42191350">[1 more]</label></div><br/><div class="children"><div class="content">Probably not the same video, but the one on this topic on youtube is <a href="https:&#x2F;&#x2F;youtu.be&#x2F;XQS9SECCp1I" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;XQS9SECCp1I</a></div><br/></div></div><div id="42190527" class="c"><input type="checkbox" id="c-42190527" checked=""/><div class="controls bullet"><span class="by">atonse</span><span>|</span><a href="#42189807">parent</a><span>|</span><a href="#42191350">prev</a><span>|</span><a href="#42190737">next</a><span>|</span><label class="collapse" for="c-42190527">[-]</label><label class="expand" for="c-42190527">[1 more]</label></div><br/><div class="children"><div class="content">I have told so many people about that video over the years. It was one of the most amazing demonstrations of a programming language&#x2F;ecosystem that I&#x27;ve ever seen.<p>Yet I&#x27;ve never been able to find it again.</div><br/></div></div><div id="42190737" class="c"><input type="checkbox" id="c-42190737" checked=""/><div class="controls bullet"><span class="by">opnitro</span><span>|</span><a href="#42189807">parent</a><span>|</span><a href="#42190527">prev</a><span>|</span><a href="#42189286">next</a><span>|</span><label class="collapse" for="c-42190737">[-]</label><label class="expand" for="c-42190737">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a link?</div><br/></div></div></div></div><div id="42189286" class="c"><input type="checkbox" id="c-42189286" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#42189807">prev</a><span>|</span><a href="#42188995">next</a><span>|</span><label class="collapse" for="c-42189286">[-]</label><label class="expand" for="c-42189286">[4 more]</label></div><br/><div class="children"><div class="content">You have to be very very very careful when preparing relups.  The alternative on Linux is to launch an entire new server on the same machine, then transfer the session data and the open sockets to it through IPC.  I once asked Joe Armstrong whether this was as good as relups and why Erlang went the relup route.  I don&#x27;t remember the exact words and don&#x27;t want to misquote him, but he basically said it was fine, and Erlang went with relups and hot patching because transferring connections (I guess they would have been hardware interfaces rather than sockets) wasn&#x27;t possible when they designed the hot patch system.<p>Hot patching is a bit unsatisfying because you are still running the same VM afterwards.  WIth socket migration you can launch a new VM if you want to upgrade your Erlang version.  I don&#x27;t know of a way to do it with existing software, but in principle using something like HAProxy with suitable extensions, it should be possible to even migrate connections across machines.</div><br/><div id="42189408" class="c"><input type="checkbox" id="c-42189408" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42189286">parent</a><span>|</span><a href="#42188995">next</a><span>|</span><label class="collapse" for="c-42189408">[-]</label><label class="expand" for="c-42189408">[3 more]</label></div><br/><div class="children"><div class="content">State migration is possible, and yeah, if you want to upgrade BEAM, state migration would be effective, whereas hot loading is not. If your VM gets pretty big, you might need to be careful about memory usage though, the donor VM is likely not going to shrink as fast as the heir VM grows. If you were so inclined, C does allow for hot loading too, but I think it&#x27;d be pretty hard to bend BEAM into something that you could hot load to upgrade.<p>Migrating socket state across machines is possible too, but I don&#x27;t think it&#x27;s anywhere close to mainstream. HAProxy is a lovely tool, but I&#x27;m pretty sure I saw something in its documentation that explicitly states that sort of thing is out of scope; they want to deal with user level sockets.<p>Linux has a TCP Repair feature which can be used as part of socket migration; but you&#x27;ll also need to do something to forward packets to the new destination. Could be arping for the address from a new machine, or something fancier that can switch proportionally or ??? there&#x27;s lots of options, depending on your network.<p>As much as I&#x27;d love to have a use case for TCP migration, it&#x27;s a little bit too esoteric for me ... reconnecting is best avoided when possible, but I&#x27;m counting TCP migration as non-possible for purposes of the rule of thumb.</div><br/><div id="42189536" class="c"><input type="checkbox" id="c-42189536" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#42189286">root</a><span>|</span><a href="#42189408">parent</a><span>|</span><a href="#42188995">next</a><span>|</span><label class="collapse" for="c-42189536">[-]</label><label class="expand" for="c-42189536">[2 more]</label></div><br/><div class="children"><div class="content">TCP migration on the same machine is real and it&#x27;s not that big a deal, if that&#x27;s what you meant by TCP migration.  Doing it across machines is at best a theoretical possibility, I would agree.  I have been wanting to look into CRIU more carefully, but I believe it uses TCP Repair that you mentioned.  I&#x27;m unfamiliar with it though.<p>The saying in the Erlang crowd is that a non-distributed system can&#x27;t be really reliable, since the power cord is a single point of failure.  So a non-painful way to migrate across machines would be great.  It just hasn&#x27;t been important enough (I guess) for make anyone willing to deal with the technical obstacles.<p>I wonder whether other OS&#x27;s have supported anything like that.<p>I worked on a phone switch (programmed in C) a long time ago that let you do both software and hardware upgrades (swap CPU boards etc.) while keeping connections intact, but the hardware was specially designed for that.</div><br/><div id="42189661" class="c"><input type="checkbox" id="c-42189661" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42189286">root</a><span>|</span><a href="#42189536">parent</a><span>|</span><a href="#42188995">next</a><span>|</span><label class="collapse" for="c-42189661">[-]</label><label class="expand" for="c-42189661">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder whether other OS&#x27;s have supported anything like that.<p>I don&#x27;t think I&#x27;ve seen it, but I don&#x27;t see everything, and it&#x27;d be pretty esoteric. From my memory of working with the FreeBSD tcp stack, I suspect it wouldn&#x27;t be too hard to make something like this work there, too; other than the security aspects, but could probably do something like ok to &#x27;repair&#x27; a connection that matches a listen socket you also pass or something. But you&#x27;d really need the use case to make the hassle worth it, and I don&#x27;t think most regular server applications are enough to warrant it.</div><br/></div></div></div></div></div></div></div></div><div id="42188995" class="c"><input type="checkbox" id="c-42188995" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#42189286">prev</a><span>|</span><a href="#42188600">next</a><span>|</span><label class="collapse" for="c-42188995">[-]</label><label class="expand" for="c-42188995">[1 more]</label></div><br/><div class="children"><div class="content">Background to the article: <a href="https:&#x2F;&#x2F;underjord.io&#x2F;unpacking-elixir-iot-embedded-nerves.html" rel="nofollow">https:&#x2F;&#x2F;underjord.io&#x2F;unpacking-elixir-iot-embedded-nerves.ht...</a><p>Seems like they deploy Elixir on embedded Linux. The embedded Linux distro is Nerves which replaces systemd and boots to the BEAM VM instead as process 1, putting Elixir as close to the metal as they can.<p>I know nothing about any of the above (assumption is I&#x27;m fool enough to try and simplify) plus I know I&#x27;ve misused the concepts I wrote but that&#x27;s my point so read the article. All simplifications are salads</div><br/></div></div><div id="42188600" class="c"><input type="checkbox" id="c-42188600" checked=""/><div class="controls bullet"><span class="by">whorleater</span><span>|</span><a href="#42188995">prev</a><span>|</span><a href="#42188480">next</a><span>|</span><label class="collapse" for="c-42188600">[-]</label><label class="expand" for="c-42188600">[1 more]</label></div><br/><div class="children"><div class="content">WhatsApp very long ago used to hot reload across all nodes with a ssh script to incrementally deploy during the day</div><br/></div></div><div id="42188480" class="c"><input type="checkbox" id="c-42188480" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42188600">prev</a><span>|</span><a href="#42189124">next</a><span>|</span><label class="collapse" for="c-42188480">[-]</label><label class="expand" for="c-42188480">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Both have described hot code updates as something that people should learn and use. I imagine Whatsapp’s initial engineering crew would agree. They did pretty well.<p>Yeah. Hot loading is clearly better than anything else when you&#x27;ve got a million clients connected and you want to make a code change. Of course, we didn&#x27;t have any of these fancy &#x27;release&#x27; tools, we just used GNU Make to rsync the code to prod and run erlc. Then you can grab a debug shell and l(module). (we did write utilities to see what code was modified, and to provide the right incantations so we wouldn&#x27;t load if it would kill processes)</div><br/><div id="42188817" class="c"><input type="checkbox" id="c-42188817" checked=""/><div class="controls bullet"><span class="by">rybosome</span><span>|</span><a href="#42188480">parent</a><span>|</span><a href="#42189124">next</a><span>|</span><label class="collapse" for="c-42188817">[-]</label><label class="expand" for="c-42188817">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Hot loading is clearly better than anything else when you&#x27;ve got a million clients connected and you want to make a code change.<p>In the contexts in which I’ve worked, this was solved by issuing a command to the server to enter a lame-duck mode and stop accepting new connections, then restarting the process with updated code after all existing connections ended.<p>This worked in our case because connections had a TTL with a “reasonable” time, couldn’t have been more than an hour. We could always wait it out.<p>I suppose hot reloading is more necessary when you have connections without a set TTL.</div><br/><div id="42189144" class="c"><input type="checkbox" id="c-42189144" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42188480">root</a><span>|</span><a href="#42188817">parent</a><span>|</span><a href="#42189124">next</a><span>|</span><label class="collapse" for="c-42189144">[-]</label><label class="expand" for="c-42189144">[1 more]</label></div><br/><div class="children"><div class="content">That way works, but it means you&#x27;re spending that much more time on a deploy.<p>For a small change, you can hot load your change and be done in minutes. This means you can push several small changes in an hour. Which helps get things done rapidly.<p>It&#x27;s also really nice to be able to see that the change works as expected (or not) at full load right away. If you&#x27;ve got to wait for connections to accumulate on the new server, that takes longer without hot load too.<p>Some changes can&#x27;t be effectively hot loaded[1], and for those you do need to do something to kick out users and let them reconnect elsewhere, and you could do all your updates that way, but it means a lot more client time spent reconnecting.<p>On the one hour TTL. Sometimes that&#x27;s reasonable, but sometimes it&#x27;s really not. Someone downloading a large file on a slow connection is better served by letting the download continue to trickle for hours than forcing them to reconnect and resume. A real time call is better served by letting it run until the participants are done. For someone on a low end phone, staying connected for as long as they can is probably better than forcing a reconnect where they&#x27;ll need to generate new ephemeral keys and do a key exchange exercise.<p>[1] At the very least, BEAM updates and kernel changes are much more easily done by restarting. But not all userspace Erlang changes are easy to make hot loadable, either.</div><br/></div></div></div></div></div></div><div id="42189124" class="c"><input type="checkbox" id="c-42189124" checked=""/><div class="controls bullet"><span class="by">aeturnum</span><span>|</span><a href="#42188480">prev</a><span>|</span><a href="#42188528">next</a><span>|</span><label class="collapse" for="c-42189124">[-]</label><label class="expand" for="c-42189124">[1 more]</label></div><br/><div class="children"><div class="content">IMO Hot Code Updates are a tantalizing tool that can be useful at times but are extremely easy to foot-gun and have little support. I suspect that the reason why no one has built a nice, formal framework for organizing and fanning out hot code changes to erlang nodes is that it&#x27;s very hard to do well, involves making some educated guesses about the halting problem, and generally doesn&#x27;t help you much unless you&#x27;re already in a real bind.<p>Most of the benefits of hot code updates (with better understanding of the boundaries of changes) can be found through judicious rolling restarts that things like k8s make easier these days. Any time you have the capacity to hot patch code on a node, you probably have the capacity to hot patch the node&#x27;s setup as well.<p>That said I think that someone could use the code reloading abilities of erlang to make a genuinely unparalleled production problem diagnostic toolkit - where you can take apart a problem as it is happening in real time. The same kinds of people who are excited about time traveling debugging should be excited about this imo.</div><br/></div></div><div id="42188528" class="c"><input type="checkbox" id="c-42188528" checked=""/><div class="controls bullet"><span class="by">arnon</span><span>|</span><a href="#42189124">prev</a><span>|</span><a href="#42189457">next</a><span>|</span><label class="collapse" for="c-42188528">[-]</label><label class="expand" for="c-42188528">[6 more]</label></div><br/><div class="children"><div class="content">A few years ago, the biggest problem with Erlang&#x27;s hot code updates was getting the files updated on all of the nodes. Has this been solved or improved in any way?</div><br/><div id="42188728" class="c"><input type="checkbox" id="c-42188728" checked=""/><div class="controls bullet"><span class="by">comboy</span><span>|</span><a href="#42188528">parent</a><span>|</span><a href="#42189232">next</a><span>|</span><label class="collapse" for="c-42188728">[-]</label><label class="expand" for="c-42188728">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think updating files is the problem. The biggest issue with hot code updates seems to be that they can create states that cannot be replicated in either release on its own.</div><br/><div id="42188800" class="c"><input type="checkbox" id="c-42188800" checked=""/><div class="controls bullet"><span class="by">ketralnis</span><span>|</span><a href="#42188528">root</a><span>|</span><a href="#42188728">parent</a><span>|</span><a href="#42189026">next</a><span>|</span><label class="collapse" for="c-42188800">[-]</label><label class="expand" for="c-42188800">[1 more]</label></div><br/><div class="children"><div class="content">This is my experience. About 25% of the time I&#x27;d encounter a bug that&#x27;s impossible to reproduce without both versions of the code in memory, and end up restarting the node anyway dropping requests in the process. Whereas if I&#x27;d have architected around not having hot code updates I could built it in a way that never has to drop requests</div><br/></div></div><div id="42189026" class="c"><input type="checkbox" id="c-42189026" checked=""/><div class="controls bullet"><span class="by">faizshah</span><span>|</span><a href="#42188528">root</a><span>|</span><a href="#42188728">parent</a><span>|</span><a href="#42188800">prev</a><span>|</span><a href="#42189232">next</a><span>|</span><label class="collapse" for="c-42189026">[-]</label><label class="expand" for="c-42189026">[1 more]</label></div><br/><div class="children"><div class="content">In general, you can save your team a lot of ops trouble just by periodically restarting your long running services from scratch instead of trying to keep alive a process or container for a long time.<p>I’m still new to the erlang&#x2F;elixir community and I haven’t run it in prod yet but this is my experience coming from Java, Node, and Python.</div><br/></div></div></div></div><div id="42189232" class="c"><input type="checkbox" id="c-42189232" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42188528">parent</a><span>|</span><a href="#42188728">prev</a><span>|</span><a href="#42189457">next</a><span>|</span><label class="collapse" for="c-42189232">[-]</label><label class="expand" for="c-42189232">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s about a thousand different ways to update files on servers?<p>You can build os packages, and push those however you like.<p>You can use rsync.<p>You could push the files over dist, if you want.<p>You could probably do something cool with bittorrent (maybe that trend is over?)<p>If you write Makefiles to push, you can use make -j X to get low effort parallelization, which works ok if your node count isn&#x27;t too big, and you don&#x27;t need as instant as possible updates.<p>Erlang source and beam files don&#x27;t tend to get very large. And most people&#x27;s dist clusters aren&#x27;t very large either; I don&#x27;t think I&#x27;ve seen anyone posting large cluster numbers lately, but I&#x27;d be surprised if anyone was pushing to 10,000 nodes at once. Assuming they&#x27;re well connected, pushing to 10,000 nodes takes some prep, but not that much; if you&#x27;re driving it from your laptop, you probably want an intermediate pusher node in your datacenter, so you can push once from home&#x2F;office internet to the pusher node, and then fork a bunch of pushers in the datacenter to push to the other hosts. If you&#x27;ve got multiple locations and you&#x27;re feeling fancy, have a pusher node at each location, push to the pusher node nearest you; that pushes to the node at each location and from there to individual nodes.<p>Other issues are more pressing; like making sure you write your code so it&#x27;s hotload friendly, and maybe trying to test that to confirm you won&#x27;t use the immense power of hotloading to <i>very</i> rapidly crash all your server processes.</div><br/><div id="42189502" class="c"><input type="checkbox" id="c-42189502" checked=""/><div class="controls bullet"><span class="by">samgranieri</span><span>|</span><a href="#42188528">root</a><span>|</span><a href="#42189232">parent</a><span>|</span><a href="#42189457">next</a><span>|</span><label class="collapse" for="c-42189502">[-]</label><label class="expand" for="c-42189502">[1 more]</label></div><br/><div class="children"><div class="content">I think Twitter once cobbled together a BitTorrent based deployment strategy for Capistrano called murder, that was a cool read from their eng blog back in the day.<p>I wish I had used a pusher node to deploy things when a colleague was using almost all the upstream bandwidth in the office making a video call when my bosses were giving demo and the fix I coded for an issue discovered during the demo could not deploy via Capistrano</div><br/></div></div></div></div></div></div><div id="42189457" class="c"><input type="checkbox" id="c-42189457" checked=""/><div class="controls bullet"><span class="by">samgranieri</span><span>|</span><a href="#42188528">prev</a><span>|</span><a href="#42188989">next</a><span>|</span><label class="collapse" for="c-42189457">[-]</label><label class="expand" for="c-42189457">[1 more]</label></div><br/><div class="children"><div class="content">I tried to do this back in 2017 as an elixir newbie with distillery, but for some reason just went with standard deploys with distillery. Now it’s just using mix release to build elixir apps in a docker image deployed to k8s.</div><br/></div></div><div id="42188989" class="c"><input type="checkbox" id="c-42188989" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42189457">prev</a><span>|</span><label class="collapse" for="c-42188989">[-]</label><label class="expand" for="c-42188989">[8 more]</label></div><br/><div class="children"><div class="content">Hot code update is one of those thing I don&#x27;t understand, just use a rolling deployment, problem solved. You have a new version of the code without loosing any connection.<p>It&#x27;s one of those thing that sound nice on paper but a actually couple your runtime with ci&#x2F;cd, if you have anything else beside Erlang what do you do? You now need a second solution to deploy code.</div><br/><div id="42189251" class="c"><input type="checkbox" id="c-42189251" checked=""/><div class="controls bullet"><span class="by">AlphaWeaver</span><span>|</span><a href="#42188989">parent</a><span>|</span><a href="#42189231">next</a><span>|</span><label class="collapse" for="c-42189251">[-]</label><label class="expand" for="c-42189251">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that rolling deployments guarantee you won&#x27;t lose connections, depending on the type of connection. Imagine your customer is downloading a large file over a single TCP connection, and you want to upgrade the application mid-download.<p>With rolling deployments, your only choice is to wait until that connection drains by completing or failing the download. If that doesn&#x27;t fit your use case, you&#x27;re out of options.<p>If your application is an Erlang app, you could hot code reload an unaffected part of the application while the download finishes. Or, if the part of the application handling the download is an OTP pattern that supports hot code reloading (like a gen_server) you could even make changes to that module and release e.g. speed improvements mid download stream. This is why Erlang shines in applications like telephony, which it was originally designed for.</div><br/><div id="42190576" class="c"><input type="checkbox" id="c-42190576" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42188989">root</a><span>|</span><a href="#42189251">parent</a><span>|</span><a href="#42189231">next</a><span>|</span><label class="collapse" for="c-42190576">[-]</label><label class="expand" for="c-42190576">[3 more]</label></div><br/><div class="children"><div class="content">&gt;<i>With rolling deployments, your only choice is to wait until that connection drains by completing or failing the download. If that doesn&#x27;t fit your use case, you&#x27;re out of options.</i><p>one of the cool things about unix is (and perhaps windows can do this in the right modes, idk), the running copy of a program is a link to the code on the disk (a link is a reference to the file, without the file name). You can delete a running program from the disk and replace it with a new program, but the running copy will continue and not be aware that you&#x27;ve done that. You don&#x27;t need to wait till the program finishes anything.<p>on an every day basis, this is what happens when you run software updates while you are still using your machine, even if your currently active programs get updated. you&#x27;ll sometimes notice this in a program like Firefox, it will lose its ability to open new tabs; that&#x27;s because they go out of their way to do that, they wouldn&#x27;t have to if they wanted to avoid it, just fork existing processes.</div><br/><div id="42190796" class="c"><input type="checkbox" id="c-42190796" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42188989">root</a><span>|</span><a href="#42190576">parent</a><span>|</span><a href="#42190615">next</a><span>|</span><label class="collapse" for="c-42190796">[-]</label><label class="expand" for="c-42190796">[1 more]</label></div><br/><div class="children"><div class="content">&gt; one of the cool things about unix is (and perhaps windows can do this in the right modes, idk), the running copy of a program is a link to the code on the disk (a link is a reference to the file, without the file name). You can delete a running program from the disk and replace it with a new program, but the running copy will continue and not be aware that you&#x27;ve done that. You don&#x27;t need to wait till the program finishes anything.<p>An even cooler thing is the running code is just mmaped into memory. One of the nifty things about mmaped files is if you change the backing file, you change it everywhere.<p>Not my recommended way to hot load code, but it might work in a pinch.<p>unlink, replace, start a new one, have the old one stop listening does work for many things. Some OSes have&#x2F;had issues with dropping a couple pending connections sometimes; or you have to learn the secret handshake to do it right. A bigger problem is if your daemon is sized to fit your memory, you might not be able to run a draining and a filling daemon at once.<p>It also doesn&#x27;t really solve the issue of changing code for existing connections, it&#x27;s a point in time migration. Easier to reason about, for sure, but not always as effective.</div><br/></div></div><div id="42190615" class="c"><input type="checkbox" id="c-42190615" checked=""/><div class="controls bullet"><span class="by">AlphaWeaver</span><span>|</span><a href="#42188989">root</a><span>|</span><a href="#42190576">parent</a><span>|</span><a href="#42190796">prev</a><span>|</span><a href="#42189231">next</a><span>|</span><label class="collapse" for="c-42190615">[-]</label><label class="expand" for="c-42190615">[1 more]</label></div><br/><div class="children"><div class="content">Right, but in this example, to &quot;pick up&quot; the code after you have updated it, you still have to trigger a restart of the program somehow. Controlling that handoff can prove challenging if you&#x27;re just swapping out the underlying binary.</div><br/></div></div></div></div></div></div><div id="42189231" class="c"><input type="checkbox" id="c-42189231" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#42188989">parent</a><span>|</span><a href="#42189251">prev</a><span>|</span><a href="#42189195">next</a><span>|</span><label class="collapse" for="c-42189231">[-]</label><label class="expand" for="c-42189231">[1 more]</label></div><br/><div class="children"><div class="content">The other perspective on this is that, at some level of your system you are always doing a hot code reload: terraform, kubernetes, etc. are taking a new deployment description in and reconciling it with the existing state of the world. Wouldn’t it be nice if this process was just more code in your preferred programming language rather than YAML soup?<p>BEAM encourages you to structure your program as isolated interacting processes and so it’s not that far from a container runtime in itself.</div><br/></div></div><div id="42189195" class="c"><input type="checkbox" id="c-42189195" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#42188989">parent</a><span>|</span><a href="#42189231">prev</a><span>|</span><a href="#42189132">next</a><span>|</span><label class="collapse" for="c-42189195">[-]</label><label class="expand" for="c-42189195">[1 more]</label></div><br/><div class="children"><div class="content">But what if you have long lived stateful connections? And you don&#x27;t want a deploy to take forever?<p>Ofc you can say &quot;don&#x27;t do that&quot; but sometimes it&#x27;s just the way it is...<p>But I agree, 99% of the time a rolling update is easier and works fine.</div><br/></div></div><div id="42189132" class="c"><input type="checkbox" id="c-42189132" checked=""/><div class="controls bullet"><span class="by">nthh</span><span>|</span><a href="#42188989">parent</a><span>|</span><a href="#42189195">prev</a><span>|</span><label class="collapse" for="c-42189132">[-]</label><label class="expand" for="c-42189132">[1 more]</label></div><br/><div class="children"><div class="content">It could be useful if you have an embedded device that you don&#x27;t want to miss data from, but for most deployments I would agree.</div><br/></div></div></div></div></div></div></div></div></div></body></html>