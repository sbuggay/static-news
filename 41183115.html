<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723107666744" as="style"/><link rel="stylesheet" href="styles.css?v=1723107666744"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://icode4.coffee/?p=954">Tony Hawk&#x27;s Pro Strcpy</a> <span class="domain">(<a href="https://icode4.coffee">icode4.coffee</a>)</span></div><div class="subtext"><span>ndiddy</span> | <span>69 comments</span></div><br/><div><div id="41184002" class="c"><input type="checkbox" id="c-41184002" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#41184848">next</a><span>|</span><label class="collapse" for="c-41184002">[-]</label><label class="expand" for="c-41184002">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The more interesting thing about the habibi key is that the public key modulus only has a 4 byte difference compared to the Microsoft RSA public key. For reference the MS key is a 2048 bit RSA key. I’ve asked a few people how this might be possible and the answer I got is “if you change the exponent to something small like 3 you easily factor out a similar key”. This should require that the exponent of the public key is also patched to “3”. However, none of the shell code payloads that use the habibi key ever change the exponent used by the RSA signature verification routine. Presumably it’s still performing the validation using the exponent 65537 so I’m not entirely sure how this works. Perhaps someone more knowledgeable could shed some light on it.<p>A random 2048-bit integer has a moderate chance of being trivially factorizeable (I don&#x27;t know the precise odds but we can infer that it&#x27;s roughly on the order of 2^-32 (for some definition of trivial) without doing any real math). Presumably, they wrote code that did something like this:<p><pre><code>    while true:
        randomly tweak&#x2F;increment 4 bytes of the public modulus 
        spend 1 millisecond trying to factor it
        did it work? if yes, we&#x27;re done here.
        else, try again.
</code></pre>
The resulting public modulus likely has lots of smaller factors (it should be possible to verify this, if anyone knows where I can find the &quot;habibi public key&quot;?). Although an RSA modulus normally has exactly 2 prime factors, the math still works out if you have more (as long as e is coprime).</div><br/><div id="41184309" class="c"><input type="checkbox" id="c-41184309" checked=""/><div class="controls bullet"><span class="by">fxtentacle</span><span>|</span><a href="#41184002">parent</a><span>|</span><a href="#41186811">next</a><span>|</span><label class="collapse" for="c-41184309">[-]</label><label class="expand" for="c-41184309">[2 more]</label></div><br/><div class="children"><div class="content">Let me try to explain that. You start with a random 2048-bit integer. You then change the lower bytes to make it divisible by 3. This is easy because you&#x27;re only working on the public key. Now that the public key is divisible by 3, you use Fermat&#x27;s little theorem which tells you that the private key must be divisible by 3 and have a sum of digits that is divisible by 3. This lets you skip most possible private keys, thereby reducing the compute needed to factorize it by a few orders of magnitude. And maybe you get lucky and they use that RSA implementation which uses exactly 2 prime factors, because then you already know that one of them is 3 and you just divide the public key by 3 to get the other prime factor.<p>EDIT: Wikipedia says &quot;The structure of the RSA public key requires that N be a large semiprime (i.e., a product of two large prime numbers), that 2 &lt; e &lt; N, that e be coprime to φ(N), and that 0 ≤ C &lt; N.&quot; and later &quot;the same algorithm allows anyone who factors N to obtain the private key.&quot;<p>which in the contest of the Xbox hack means that if you force N to be divisible by the prime 3, then the other prime which is used for generating the private key has to be N&#x2F;3 =&gt; You have successfully factored it.<p>EDIT2: Here&#x27;s code for signing with the Habibi key: <a href="https:&#x2F;&#x2F;github.com&#x2F;XboxDev&#x2F;xbedump&#x2F;blob&#x2F;b8cd5cd0f8b1cbc4e64f41daf925a873d34dacf1&#x2F;xboxlib.c#L408">https:&#x2F;&#x2F;github.com&#x2F;XboxDev&#x2F;xbedump&#x2F;blob&#x2F;b8cd5cd0f8b1cbc4e64f...</a><p>As you can see, it&#x27;ll replace the last 4 bytes with 0x89, 0x9c, 0x90, 0x6b and then start by dividing it by 3 and using that to generate a suitable private key.</div><br/><div id="41184634" class="c"><input type="checkbox" id="c-41184634" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#41184002">root</a><span>|</span><a href="#41184309">parent</a><span>|</span><a href="#41186811">next</a><span>|</span><label class="collapse" for="c-41184634">[-]</label><label class="expand" for="c-41184634">[1 more]</label></div><br/><div class="children"><div class="content">Ah, thanks for finding that code.<p>Here&#x27;s the original public modulus as an integer: <a href="http:&#x2F;&#x2F;factordb.com&#x2F;index.php?query=20740119327258723760276023509063017138455993606274883526731955113241109007354362374128996096291046353572306742110305456946824862203867115042369878729703475765112280167498189046437794602966168812419423365196979669431929588951126804648743029387833666031765734337165949634731375592471670294246180877815104812674626967450097045005117546657068700545263064105024888769118032059917845867653040419404003684559882509195398630922824050405379620513589699993980205694266973236095772153476388267418476533663512746243310317853861946430053072890502949319703765023792161144942611323629444409600173894963797156859916567288947565058003" rel="nofollow">http:&#x2F;&#x2F;factordb.com&#x2F;index.php?query=207401193272587237602760...</a> (which can&#x27;t be factored, at least not any time soon)<p>And here&#x27;s the patched version: <a href="http:&#x2F;&#x2F;factordb.com&#x2F;index.php?query=17371852435364932234198289696093135719112415166564334627199356168762835335592424536862497360014159738630046885057635916854759097620974245668452590354310167264683476531173163058898476418183674505913561130980902214026382023954011273122886903301549955103489770026619711887767398427379601400787983076212603189569524432427260515921063513404354797519457735139609222411461524050349340285765258649294004182458325847322598311747736621083339542109085138257913063024645042563940841231676725819951388256701826786497550629695215511595269950707608531548300114399973695889243598772097105699530419181744793002739781116244276221499347" rel="nofollow">http:&#x2F;&#x2F;factordb.com&#x2F;index.php?query=173718524353649322341982...</a><p>And exactly as you say, it&#x27;s divisible by 3, leaving behind a single large prime (so I was wrong about there being more factors)</div><br/></div></div></div></div><div id="41186811" class="c"><input type="checkbox" id="c-41186811" checked=""/><div class="controls bullet"><span class="by">ryan-c</span><span>|</span><a href="#41184002">parent</a><span>|</span><a href="#41184309">prev</a><span>|</span><a href="#41184848">next</a><span>|</span><label class="collapse" for="c-41186811">[-]</label><label class="expand" for="c-41186811">[2 more]</label></div><br/><div class="children"><div class="content">chinese remainder theorem implementations fail if there are duplicate factors</div><br/><div id="41186999" class="c"><input type="checkbox" id="c-41186999" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#41184002">root</a><span>|</span><a href="#41186811">parent</a><span>|</span><a href="#41184848">next</a><span>|</span><label class="collapse" for="c-41186999">[-]</label><label class="expand" for="c-41186999">[1 more]</label></div><br/><div class="children"><div class="content">CRT can only be used for private key ops e.g. signing. The verification side (i.e. the logic that runs on the console) can&#x27;t use CRT.</div><br/></div></div></div></div></div></div><div id="41184848" class="c"><input type="checkbox" id="c-41184848" checked=""/><div class="controls bullet"><span class="by">Jerrrrrrry</span><span>|</span><a href="#41184002">prev</a><span>|</span><a href="#41183751">next</a><span>|</span><label class="collapse" for="c-41184848">[-]</label><label class="expand" for="c-41184848">[1 more]</label></div><br/><div class="children"><div class="content">It may not be possible for me to articulate how fucking insane of an accomplishment this is.<p>Xbox 360...._softmod_.... via the park name on a Tony Hawk game.<p>24 segment ROP chain :&#x27;)<p>His rightful lamentation for the hypervisor, concise functional write up,
 and immediate thoughts of an x360 botnet make this the greatest xbox 360 nostalgia gut-punch of all time.<p>kudos++</div><br/></div></div><div id="41183751" class="c"><input type="checkbox" id="c-41183751" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#41184848">prev</a><span>|</span><a href="#41183905">next</a><span>|</span><label class="collapse" for="c-41183751">[-]</label><label class="expand" for="c-41183751">[24 more]</label></div><br/><div class="children"><div class="content">- <i>&quot;If I was lucky it would be strcpy (opposed to something like strncpy)&quot;</i><p>it really ought to have been strncpy, I&#x27;m sure Tony Hawk who&#x27;s lauded for his advocacy of safety gear would prefer to be associated with safer string copying</div><br/><div id="41184332" class="c"><input type="checkbox" id="c-41184332" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#41183751">parent</a><span>|</span><a href="#41183983">next</a><span>|</span><label class="collapse" for="c-41184332">[-]</label><label class="expand" for="c-41184332">[2 more]</label></div><br/><div class="children"><div class="content">The correct thing to do is to use memcpy and to know the size of both the destination buffer and the source buffer. If the source buffer won’t fit, then you need to take an application-specific action (is truncation ok? do you have to abort the whole operation? Do you re-alloc the destination buffer? etc.) strncpy almost always does the wrong thing.</div><br/><div id="41188236" class="c"><input type="checkbox" id="c-41188236" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184332">parent</a><span>|</span><a href="#41183983">next</a><span>|</span><label class="collapse" for="c-41188236">[-]</label><label class="expand" for="c-41188236">[1 more]</label></div><br/><div class="children"><div class="content">Agree with the general principle of knowing your buffer sizes, but the issue with memcpy (evidenced over many years with various CVEs) is that someone invariably takes a string length and forgets to plus one, leading to non-null-terminated strings.</div><br/></div></div></div></div><div id="41183983" class="c"><input type="checkbox" id="c-41183983" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41183751">parent</a><span>|</span><a href="#41184332">prev</a><span>|</span><a href="#41187697">next</a><span>|</span><label class="collapse" for="c-41183983">[-]</label><label class="expand" for="c-41183983">[18 more]</label></div><br/><div class="children"><div class="content">strncpy is definitely not safer; it produces unterminated strings when it hits <i>n</i><p>basically you should almost never use strncpy; it&#x27;s specifically for fixed-size fields like this:<p><pre><code>    struct dirent { unsigned short inode; char name[14]; };
</code></pre>
and in those cases more often than not the pad byte should be a space rather than a nul<p>strncpy should never have been added to the standard library</div><br/><div id="41184157" class="c"><input type="checkbox" id="c-41184157" checked=""/><div class="controls bullet"><span class="by">sidewndr46</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41183983">parent</a><span>|</span><a href="#41188567">next</a><span>|</span><label class="collapse" for="c-41184157">[-]</label><label class="expand" for="c-41184157">[16 more]</label></div><br/><div class="children"><div class="content">What is the preferred solution here? I usually just use &quot;memset&quot; to zeroize the whole destination string, then tell &quot;strncpy&quot; that my destination is 1 byte shorter than what it really is.<p>The real issue I&#x27;ve ran into is that &quot;strncpy&quot; assumes the source is null-terminated.</div><br/><div id="41184780" class="c"><input type="checkbox" id="c-41184780" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184157">parent</a><span>|</span><a href="#41184370">next</a><span>|</span><label class="collapse" for="c-41184780">[-]</label><label class="expand" for="c-41184780">[1 more]</label></div><br/><div class="children"><div class="content">Use a proper C string library like SDS.<p>Or move up from the 1970&#x27;s Bell Labs, adopt C++ with the respective compiler switches to have bounds checking enabled for <i>operator[]()</i>.<p>Better yet, use something else instead of one of those two, pick whatver is your fancy.</div><br/></div></div><div id="41184370" class="c"><input type="checkbox" id="c-41184370" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184157">parent</a><span>|</span><a href="#41184780">prev</a><span>|</span><a href="#41184973">next</a><span>|</span><label class="collapse" for="c-41184370">[-]</label><label class="expand" for="c-41184370">[2 more]</label></div><br/><div class="children"><div class="content">Use memcpy and do the size check yourself beforehand (taking the appropriate action if it doesn’t fit). Avoid any function starting with str except for strlen. Prefer pointer+length instead of relying on nul-terminated strings.</div><br/><div id="41186476" class="c"><input type="checkbox" id="c-41186476" checked=""/><div class="controls bullet"><span class="by">nrclark</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184370">parent</a><span>|</span><a href="#41184973">next</a><span>|</span><label class="collapse" for="c-41186476">[-]</label><label class="expand" for="c-41186476">[1 more]</label></div><br/><div class="children"><div class="content">You mean strnlen.</div><br/></div></div></div></div><div id="41184973" class="c"><input type="checkbox" id="c-41184973" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184157">parent</a><span>|</span><a href="#41184370">prev</a><span>|</span><a href="#41184276">next</a><span>|</span><label class="collapse" for="c-41184973">[-]</label><label class="expand" for="c-41184973">[3 more]</label></div><br/><div class="children"><div class="content">The sanest solution is, surprisingly, snprintf(dst, sizeof(dst), &quot;%s&quot;, src).</div><br/><div id="41187733" class="c"><input type="checkbox" id="c-41187733" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184973">parent</a><span>|</span><a href="#41184276">next</a><span>|</span><label class="collapse" for="c-41187733">[-]</label><label class="expand" for="c-41187733">[2 more]</label></div><br/><div class="children"><div class="content">please don&#x27;t fill your program with fifty zillion string buffers of arbitrarily chosen sizes and then try to separately pass the right size in seventy zillion string-processing function calls. your code will be hard to read, buggy, and probably insecure</div><br/><div id="41188887" class="c"><input type="checkbox" id="c-41188887" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41187733">parent</a><span>|</span><a href="#41184276">next</a><span>|</span><label class="collapse" for="c-41188887">[-]</label><label class="expand" for="c-41188887">[1 more]</label></div><br/><div class="children"><div class="content">I agree with that statement, but it has nothing to do with snprintf() versus e.g. strcpy_s(), where you have exactly the same requirement to pass the right size.<p>(Separately, there&#x27;s a discussion about how many bytes you are allowed to read from the _source_, but to fix that, you need something like the Linux kernel&#x27;s strscpy(), which isn&#x27;t really widely supported in userspace.)</div><br/></div></div></div></div></div></div><div id="41184276" class="c"><input type="checkbox" id="c-41184276" checked=""/><div class="controls bullet"><span class="by">connicpu</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184157">parent</a><span>|</span><a href="#41184973">prev</a><span>|</span><a href="#41184729">next</a><span>|</span><label class="collapse" for="c-41184276">[-]</label><label class="expand" for="c-41184276">[4 more]</label></div><br/><div class="children"><div class="content">C11 adds `strcpy_s` which takes (dest, destsz, src) and returns an errno_t which will report an error if the src string is longer than destsz, as silent truncation is often not a desirable behavior. It also assigns dest[0]=&#x27;\0&#x27; on error so you don&#x27;t get an unterminated garbage string.</div><br/><div id="41184419" class="c"><input type="checkbox" id="c-41184419" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184276">parent</a><span>|</span><a href="#41184729">next</a><span>|</span><label class="collapse" for="c-41184419">[-]</label><label class="expand" for="c-41184419">[3 more]</label></div><br/><div class="children"><div class="content">Only msvc provides strcpy_s and they don’t conform to the standard. Other libcs don’t provide it. Ignore everything from Annex K and write your own wrappers around memcpy. You should always know the size of your buffers.</div><br/><div id="41184530" class="c"><input type="checkbox" id="c-41184530" checked=""/><div class="controls bullet"><span class="by">connicpu</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184419">parent</a><span>|</span><a href="#41184729">next</a><span>|</span><label class="collapse" for="c-41184530">[-]</label><label class="expand" for="c-41184530">[2 more]</label></div><br/><div class="children"><div class="content">Ah that sucks. Guess C is just stuck like this for the long term. Writing your own functions is still the best advice :&#x27;(</div><br/><div id="41187563" class="c"><input type="checkbox" id="c-41187563" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184530">parent</a><span>|</span><a href="#41184729">next</a><span>|</span><label class="collapse" for="c-41187563">[-]</label><label class="expand" for="c-41187563">[1 more]</label></div><br/><div class="children"><div class="content">on the plus side, c is good at writing your own functions</div><br/></div></div></div></div></div></div></div></div><div id="41184729" class="c"><input type="checkbox" id="c-41184729" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184157">parent</a><span>|</span><a href="#41184276">prev</a><span>|</span><a href="#41186797">next</a><span>|</span><label class="collapse" for="c-41184729">[-]</label><label class="expand" for="c-41184729">[1 more]</label></div><br/><div class="children"><div class="content">memccpy, then use the return value to terminate.</div><br/></div></div><div id="41186797" class="c"><input type="checkbox" id="c-41186797" checked=""/><div class="controls bullet"><span class="by">1over137</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184157">parent</a><span>|</span><a href="#41184729">prev</a><span>|</span><a href="#41184705">next</a><span>|</span><label class="collapse" for="c-41186797">[-]</label><label class="expand" for="c-41186797">[2 more]</label></div><br/><div class="children"><div class="content">strlcpy() is my favourite, alas the GNU folks stubbornly refuse to embrace it, last I checked.</div><br/><div id="41187708" class="c"><input type="checkbox" id="c-41187708" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41186797">parent</a><span>|</span><a href="#41184705">next</a><span>|</span><label class="collapse" for="c-41187708">[-]</label><label class="expand" for="c-41187708">[1 more]</label></div><br/><div class="children"><div class="content">strlcpy is still braindamaged.  The need to return the length of the source string for compatibility with old code means it suffers from the some of the same issues strncpy did.</div><br/></div></div></div></div><div id="41184705" class="c"><input type="checkbox" id="c-41184705" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184157">parent</a><span>|</span><a href="#41186797">prev</a><span>|</span><a href="#41187662">next</a><span>|</span><label class="collapse" for="c-41184705">[-]</label><label class="expand" for="c-41184705">[1 more]</label></div><br/><div class="children"><div class="content">strlcpy?</div><br/></div></div><div id="41187662" class="c"><input type="checkbox" id="c-41187662" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184157">parent</a><span>|</span><a href="#41184705">prev</a><span>|</span><a href="#41188567">next</a><span>|</span><label class="collapse" for="c-41187662">[-]</label><label class="expand" for="c-41187662">[1 more]</label></div><br/><div class="children"><div class="content">for general-purpose string handling in software where failure is an option, i like the qmail stralloc approach<p><pre><code>    if (!addrparse(arg)) { err_syntax(); return; }
    flagbarf = bmfcheck();
    seenmail = 1;
    if (!stralloc_copys(&amp;rcptto,&quot;&quot;)) die_nomem();
    if (!stralloc_copys(&amp;mailfrom,addr.s)) die_nomem();
    if (!stralloc_0(&amp;mailfrom)) die_nomem();
    out(&quot;250 ok\r\n&quot;);
</code></pre>
basically you have a struct with buffer-pointer, length, and capacity fields, like a golang slice, and you modify it with a small number of functions which reallocate the buffer if it isn&#x27;t big enough.  the ones you see here are stralloc_copys, which sets the buffer contents to the contents of a nul-terminated string, and stralloc_0, which appends a nul to the buffer.  there are also functions for appending an arbitrary byte, for copying one stralloc to another, for copying counted strings into strallocs, and for concatenation, for determining whether one is a prefix of another, etc., but depending on the application, you may or may not need to implement these<p>the whole stralloc library is 97 lines of k&amp;r c, so reimplementing the part you need for a given program is pretty trivial.  it&#x27;s in the public domain<p>for most programs, a disadvantage of the particular way that stralloc is implemented in qmail is that you have to check every single copy or concatenation operation for an out-of-memory error, as you see above.  this makes your code a lot longer.  many applications are better off just aborting inside the memory allocation function if they run out of memory; getting out-of-memory handling correct is very difficult, especially if you don&#x27;t devote a massive amount of effort to testing out-of-memory conditions (because they won&#x27;t occur often enough just by chance to test your error-handling path)<p>(another disadvantage of the way stralloc is implemented is that you probably don&#x27;t really want to use unsigned int for the two length fields on lp64 platforms)<p>for some applications you might prefer just using strdup() (or xstrdup()) or non-owning string-view types (a pointer and a length, perhaps into an input file you&#x27;ve mapped into memory), or lisp-style symbol interning (plus some kind of buffer management probably).  arena allocation, if you can afford it, makes dynamic memory allocation for strings a much more reasonable thing to do: no risk of a memory leak, fast allocation, instant deallocation.  but again some applications do poorly with arena allocation<p>but please don&#x27;t fill your program with fifty zillion string buffers of arbitrarily chosen sizes and then try to separately pass the right size in seventy zillion string-processing function calls.  your code will be hard to read, buggy, and probably insecure.  factor string buffer length handling into a small part of your program so that most of your code never has to think about string buffer lengths</div><br/></div></div></div></div><div id="41188567" class="c"><input type="checkbox" id="c-41188567" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41183983">parent</a><span>|</span><a href="#41184157">prev</a><span>|</span><a href="#41187697">next</a><span>|</span><label class="collapse" for="c-41188567">[-]</label><label class="expand" for="c-41188567">[1 more]</label></div><br/><div class="children"><div class="content">strncpy is fine as long as it&#x27;s not used in isolation. My preferred pattern (when I want the truncation) is to use it, and then unconditionally set the last byte of the buffer to null. This will always result in a valid C string.</div><br/></div></div></div></div><div id="41187697" class="c"><input type="checkbox" id="c-41187697" checked=""/><div class="controls bullet"><span class="by">StressedDev</span><span>|</span><a href="#41183751">parent</a><span>|</span><a href="#41183983">prev</a><span>|</span><a href="#41184455">next</a><span>|</span><label class="collapse" for="c-41187697">[-]</label><label class="expand" for="c-41187697">[1 more]</label></div><br/><div class="children"><div class="content">If you are doing Windows C&#x2F;C++ development, you can use the strsafe.h functions (<a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;strsafe&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;strsafe&#x2F;</a>).  When I wrote C&#x2F;C++, I found them easier to use than the standard C functions because they handled all of the usual failure cases (buffer too small, integer overflow, etc.).  It was also easy to check if there was a failure because all of the functions returned a failure code if something went wrong.<p>In this case, StringCchCopyW(), or StringCbCopyW() would be a better choice than strcpy.</div><br/></div></div><div id="41184455" class="c"><input type="checkbox" id="c-41184455" checked=""/><div class="controls bullet"><span class="by">thekevan</span><span>|</span><a href="#41183751">parent</a><span>|</span><a href="#41187697">prev</a><span>|</span><a href="#41183905">next</a><span>|</span><label class="collapse" for="c-41184455">[-]</label><label class="expand" for="c-41184455">[2 more]</label></div><br/><div class="children"><div class="content">I read that he used to drive around and when he saw a skateboarder, he&#x27;d yell &quot;do an ollie&quot; and then give them a new helmet.</div><br/><div id="41188408" class="c"><input type="checkbox" id="c-41188408" checked=""/><div class="controls bullet"><span class="by">dfex</span><span>|</span><a href="#41183751">root</a><span>|</span><a href="#41184455">parent</a><span>|</span><a href="#41183905">next</a><span>|</span><label class="collapse" for="c-41188408">[-]</label><label class="expand" for="c-41188408">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Do a kick-flip&quot;</div><br/></div></div></div></div></div></div><div id="41183905" class="c"><input type="checkbox" id="c-41183905" checked=""/><div class="controls bullet"><span class="by">makin</span><span>|</span><a href="#41183751">prev</a><span>|</span><a href="#41184597">next</a><span>|</span><label class="collapse" for="c-41183905">[-]</label><label class="expand" for="c-41183905">[2 more]</label></div><br/><div class="children"><div class="content">A bit of a shame about the exploit applying to THUG PRO. The mod is played to this day, since the more competitive side of the Tony Hawk franchise has been dead for almost twenty years (with the exception of the THPS1+2 remake, which was but a blip in the scene).<p>The mod itself is over 10 years old now, and I think the original developers are gone, explaining why no one was interested in fixing it when Ryan reported it. But this means that now the mod is unusable, no one is going to want to risk a full privilege exploit taking over their PC.<p>Hopefully this article reaches someone who&#x27;s a bit more interested in patching the mod.</div><br/><div id="41183950" class="c"><input type="checkbox" id="c-41183950" checked=""/><div class="controls bullet"><span class="by">rlabrecque</span><span>|</span><a href="#41183905">parent</a><span>|</span><a href="#41184597">next</a><span>|</span><label class="collapse" for="c-41183950">[-]</label><label class="expand" for="c-41183950">[1 more]</label></div><br/><div class="children"><div class="content">I wish I had the time, because it would be fun. Back when I DID have time, I actually got that thug1 source code almost playable on Windows. That source code was only for the console versions, and the code assumed if it was compiling for windows (and not Xbox windows..) it was only for tools, so a lot of pieces worked completely differently.</div><br/></div></div></div></div><div id="41184597" class="c"><input type="checkbox" id="c-41184597" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#41183905">prev</a><span>|</span><a href="#41183586">next</a><span>|</span><label class="collapse" for="c-41184597">[-]</label><label class="expand" for="c-41184597">[2 more]</label></div><br/><div class="children"><div class="content">FYI, what looks like a section header icon followed by the text &quot;So what&#x27;s the habibi key?&quot; is actually a clickable expanding segment (html details). You should click it if you&#x27;re interested!<p>A question I have is where&#x2F;when&#x2F;how the corresponding <i>private</i> habibi key was released&#x2F;leaked, if the story about it being used exclusively by the linux console group to prevent pirated content from being used is true. OP clearly was able to patch the four byte difference between the MS key and the habibi key to then run &quot;unsigned&quot; (but, actually, signed with the habibi private key) executables, so they clearly got their hands on it.</div><br/><div id="41187682" class="c"><input type="checkbox" id="c-41187682" checked=""/><div class="controls bullet"><span class="by">bri3d</span><span>|</span><a href="#41184597">parent</a><span>|</span><a href="#41183586">next</a><span>|</span><label class="collapse" for="c-41187682">[-]</label><label class="expand" for="c-41187682">[1 more]</label></div><br/><div class="children"><div class="content">The Habibi key is generated by patching the Microsoft key to be divisible by 3, making it quite easy to factor indeed. The private key can be trivially recovered from the public key, and there was nothing really to release or leak. It was basically a little crypto CTF buried in the original 007: Agent Under Fire savegame hack, which was basically a CTF in and of itself (it was reasonably heavily obfuscated, I think both as a middle finger to pirates and as a challenge to other reverse engineers).</div><br/></div></div></div></div><div id="41183586" class="c"><input type="checkbox" id="c-41183586" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#41184597">prev</a><span>|</span><a href="#41183991">next</a><span>|</span><label class="collapse" for="c-41183586">[-]</label><label class="expand" for="c-41183586">[7 more]</label></div><br/><div class="children"><div class="content">This is awesome!<p>I&#x27;ve been doing some PSX decompiling and there are lots of similar things there as well. Interestingly, something like `memmove` is linked in using an SDK library[0], but `strcpy` is a function provided by the BIOS. Later version of the SDK could patch that out for a library version, but as late as 1997 it hadn&#x27;t been.<p>0 - <a href="https:&#x2F;&#x2F;github.com&#x2F;Xeeynamo&#x2F;sotn-decomp&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;psxsdk&#x2F;libc&#x2F;memmove.c">https:&#x2F;&#x2F;github.com&#x2F;Xeeynamo&#x2F;sotn-decomp&#x2F;blob&#x2F;master&#x2F;src&#x2F;main...</a></div><br/><div id="41183767" class="c"><input type="checkbox" id="c-41183767" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41183586">parent</a><span>|</span><a href="#41183991">next</a><span>|</span><label class="collapse" for="c-41183767">[-]</label><label class="expand" for="c-41183767">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love a reimplemeantion in C+SDL2 (and OpenGL 2.1) of the former console games.<p>Now there are the N64 games being ported to PC with decompilers, I can only hope.
Inb4 &quot;there are native PC versions of these, you know&quot;... most recompiled N64 games with the FX&#x27;s  being &#x27;deshaderized&#x27; to pure textures (or simpler FX&#x27;s) can be run in toasters such as cheap netbooks from 2009 and nearly anywhere.<p>They even ported Super Mario 64 to the 3DFX API. I know, the most complex games accesing the N64 framebuffer with complex FX will require OpenGL 3.3 to mimic that microcode; but, as I said before, when the engines run uber-fast on anything post Pentium III, is not something difficult to &#x27;mimic&#x27; these in software while the rest it&#x27;s running GL 2.1 accelerated.</div><br/><div id="41183838" class="c"><input type="checkbox" id="c-41183838" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41183586">root</a><span>|</span><a href="#41183767">parent</a><span>|</span><a href="#41183991">next</a><span>|</span><label class="collapse" for="c-41183838">[-]</label><label class="expand" for="c-41183838">[5 more]</label></div><br/><div class="children"><div class="content">&gt; They even ported Super Mario 64 to the 3DFX API.<p>That&#x27;s... not surprising. UltraHLE ran SM64 like a dream, and the HLE bit referred to the fact that the emulator translated 3D calls to the Glide API rather than attempting to emulate the 3D hardware directly.</div><br/><div id="41184680" class="c"><input type="checkbox" id="c-41184680" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41183586">root</a><span>|</span><a href="#41183838">parent</a><span>|</span><a href="#41183991">next</a><span>|</span><label class="collapse" for="c-41184680">[-]</label><label class="expand" for="c-41184680">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, I knew about that, so this it&#x27;s just transcribing instead of translating. But I&#x27;d guess SGI machines (IRIX) being OpenGL bound (they invented it) the N64 would map the microcode to GL funcs much better.</div><br/><div id="41185964" class="c"><input type="checkbox" id="c-41185964" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41183586">root</a><span>|</span><a href="#41184680">parent</a><span>|</span><a href="#41183991">next</a><span>|</span><label class="collapse" for="c-41185964">[-]</label><label class="expand" for="c-41185964">[3 more]</label></div><br/><div class="children"><div class="content">Glide was modelled after OpenGL, so I&#x27;m guessing the mapping was not that much of a stretch anyway.</div><br/><div id="41187212" class="c"><input type="checkbox" id="c-41187212" checked=""/><div class="controls bullet"><span class="by">rvnx</span><span>|</span><a href="#41183586">root</a><span>|</span><a href="#41185964">parent</a><span>|</span><a href="#41183991">next</a><span>|</span><label class="collapse" for="c-41187212">[-]</label><label class="expand" for="c-41187212">[2 more]</label></div><br/><div class="children"><div class="content">and then you had to use an extra DLL that was essentially translating 3dfx calls to DirectX</div><br/><div id="41189407" class="c"><input type="checkbox" id="c-41189407" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41183586">root</a><span>|</span><a href="#41187212">parent</a><span>|</span><a href="#41183991">next</a><span>|</span><label class="collapse" for="c-41189407">[-]</label><label class="expand" for="c-41189407">[1 more]</label></div><br/><div class="children"><div class="content">That was later. NGlide for sure.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41183991" class="c"><input type="checkbox" id="c-41183991" checked=""/><div class="controls bullet"><span class="by">auto</span><span>|</span><a href="#41183586">prev</a><span>|</span><a href="#41186201">next</a><span>|</span><label class="collapse" for="c-41183991">[-]</label><label class="expand" for="c-41183991">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve read so many flavors of this sort of exploit analysis over the years, and if I get to read 100 more I&#x27;ll be all the happier for it.<p>Great article!</div><br/></div></div><div id="41186201" class="c"><input type="checkbox" id="c-41186201" checked=""/><div class="controls bullet"><span class="by">Reason077</span><span>|</span><a href="#41183991">prev</a><span>|</span><a href="#41186325">next</a><span>|</span><label class="collapse" for="c-41186201">[-]</label><label class="expand" for="c-41186201">[1 more]</label></div><br/><div class="children"><div class="content">In Tony Hawk’s defence, he’s a pro skater, not a security analyst. Limited time behind the keyboard in the late 90s&#x2F;early 2000s grinding on his soon-to-be iconic game series would have been spent making sure 900 McTwists felt really natural, not auditing code for buffer overruns!</div><br/></div></div><div id="41186325" class="c"><input type="checkbox" id="c-41186325" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41186201">prev</a><span>|</span><a href="#41184632">next</a><span>|</span><label class="collapse" for="c-41186325">[-]</label><label class="expand" for="c-41186325">[13 more]</label></div><br/><div class="children"><div class="content">This seems like a great example of having the wrong security mindset in console development. &quot;We&#x27;re the only thing that can write this saved data, so we only have to parse what we wrote&quot; is a very common console mindset, and fundamentally wrong when people can prepare artificially constructed saved data.<p>(Completely separate from that, consoles shouldn&#x27;t be treating users as the adversary, but given that they <i>do</i>, games are failing to have a security mindset consistent with that stance.)</div><br/><div id="41186760" class="c"><input type="checkbox" id="c-41186760" checked=""/><div class="controls bullet"><span class="by">extraduder_ire</span><span>|</span><a href="#41186325">parent</a><span>|</span><a href="#41186430">next</a><span>|</span><label class="collapse" for="c-41186760">[-]</label><label class="expand" for="c-41186760">[1 more]</label></div><br/><div class="children"><div class="content">It is kind of coming true now, since all current consoles both encrypt and sign savegames to lock them to your account, and most (don&#x27;t know about xbox) don&#x27;t even let you copy your saves anywhere but the console and paid cloud storage.</div><br/></div></div><div id="41186430" class="c"><input type="checkbox" id="c-41186430" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#41186325">parent</a><span>|</span><a href="#41186760">prev</a><span>|</span><a href="#41184632">next</a><span>|</span><label class="collapse" for="c-41186430">[-]</label><label class="expand" for="c-41186430">[11 more]</label></div><br/><div class="children"><div class="content">&gt; consoles shouldn&#x27;t be treating users as the adversary<p>I would 100% agree with this when talking about a normal computer, but I kind of feel differently about consoles. How do you prevent cheating in online games if you don&#x27;t restrict what users can do?</div><br/><div id="41186980" class="c"><input type="checkbox" id="c-41186980" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41186430">parent</a><span>|</span><a href="#41184632">next</a><span>|</span><label class="collapse" for="c-41186980">[-]</label><label class="expand" for="c-41186980">[10 more]</label></div><br/><div class="children"><div class="content">1) Play with people you know, or<p>2) Group players by apparent capability and observed behavior, such that cheaters end up only playing with other cheaters.</div><br/><div id="41187511" class="c"><input type="checkbox" id="c-41187511" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41186980">parent</a><span>|</span><a href="#41188511">next</a><span>|</span><label class="collapse" for="c-41187511">[-]</label><label class="expand" for="c-41187511">[8 more]</label></div><br/><div class="children"><div class="content">1. makes matchmaking impossible, which is how 99% of people want to play.<p>2. is a research project that will probably never pan out.</div><br/><div id="41187548" class="c"><input type="checkbox" id="c-41187548" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41187511">parent</a><span>|</span><a href="#41188511">next</a><span>|</span><label class="collapse" for="c-41187548">[-]</label><label class="expand" for="c-41187548">[7 more]</label></div><br/><div class="children"><div class="content">Multiple games have done 2 in production with great success.</div><br/><div id="41187580" class="c"><input type="checkbox" id="c-41187580" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41187548">parent</a><span>|</span><a href="#41188511">next</a><span>|</span><label class="collapse" for="c-41187580">[-]</label><label class="expand" for="c-41187580">[6 more]</label></div><br/><div class="children"><div class="content">No they haven&#x27;t. Maybe they have caught cheaters with _intrusive_ software. But that&#x27;s not &quot;observed behavior and apparent capability&quot;.</div><br/><div id="41187807" class="c"><input type="checkbox" id="c-41187807" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41187580">parent</a><span>|</span><a href="#41188511">next</a><span>|</span><label class="collapse" for="c-41187807">[-]</label><label class="expand" for="c-41187807">[5 more]</label></div><br/><div class="children"><div class="content">Rootkits and other mechanisms are not the only way to catch cheating players. You can also rely on player reports of other players, as well as anomaly detection, and based on those reports, observe player actions to detect obvious cheating. You don&#x27;t have to be <i>perfect</i>, just catch enough people to make it not worth the risk. Use the results to either pair suspected cheaters with other suspected cheaters, or just ban people if you don&#x27;t mind risking that they&#x27;ll hide themselves better and come back.<p>This is not a hypothetical or a research project; some games do exactly this.</div><br/><div id="41187843" class="c"><input type="checkbox" id="c-41187843" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41187807">parent</a><span>|</span><a href="#41188511">next</a><span>|</span><label class="collapse" for="c-41187843">[-]</label><label class="expand" for="c-41187843">[4 more]</label></div><br/><div class="children"><div class="content">This is just ideological gobbledygook. No concrete examples of this working in practice.</div><br/><div id="41187892" class="c"><input type="checkbox" id="c-41187892" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41187843">parent</a><span>|</span><a href="#41188511">next</a><span>|</span><label class="collapse" for="c-41187892">[-]</label><label class="expand" for="c-41187892">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cheating_in_online_games#Anomaly_detection" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cheating_in_online_games#Anoma...</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cheating_in_online_games#Player_supervision" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cheating_in_online_games#Playe...</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cheating_in_online_games#Banning_players" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cheating_in_online_games#Banni...</a><p>&gt; Certain games are known to identify cheaters and &quot;shadow ban&quot; them by placing them in matchmaking with other cheaters only, so as not to let the cheaters know that they have been identified.</div><br/><div id="41188947" class="c"><input type="checkbox" id="c-41188947" checked=""/><div class="controls bullet"><span class="by">alt227</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41187892">parent</a><span>|</span><a href="#41188081">next</a><span>|</span><label class="collapse" for="c-41188947">[-]</label><label class="expand" for="c-41188947">[1 more]</label></div><br/><div class="children"><div class="content">The problem with what you are saying, is that the industry involved is shrouded in secrecy and full of smoke and mirrors.<p>Because the only sources you have provided are anecdotal, its entirely possible you are falling for the illusion.<p>To use your phrases, &#x27;certain games companies&#x27; are known to totally lie about their anti cheat techniques and methods to throw people off the scent of the real methods.<p>Therefore without actually decompiling something to prove whats going on, you have no real idea what techniques are being used at all.</div><br/></div></div><div id="41188081" class="c"><input type="checkbox" id="c-41188081" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41187892">parent</a><span>|</span><a href="#41188947">prev</a><span>|</span><a href="#41188511">next</a><span>|</span><label class="collapse" for="c-41188081">[-]</label><label class="expand" for="c-41188081">[1 more]</label></div><br/><div class="children"><div class="content">The text for the anomaly link basically just says it&#x27;s infeasible for a number of reasons, but it would sure be nice from a privacy standpoint.<p>The banning section mentions companies that employ very invasive software to find and ban cheaters. Read up on how the following softwares actually work:<p>&gt; There are many facets of cheating in online games which make the creation of a system to stop cheating very difficult; however, game developers and third-party software developers have created or are developing[22][23] technologies that attempt to prevent cheating. Such countermeasures are commonly used in video games, with notable anti-cheat software being BattlEye, GameGuard, PunkBuster, Valve Anti-Cheat (specifically used on games on the Steam platform),[citation needed] and EasyAntiCheat.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41188511" class="c"><input type="checkbox" id="c-41188511" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41186325">root</a><span>|</span><a href="#41186980">parent</a><span>|</span><a href="#41187511">prev</a><span>|</span><a href="#41184632">next</a><span>|</span><label class="collapse" for="c-41188511">[-]</label><label class="expand" for="c-41188511">[1 more]</label></div><br/><div class="children"><div class="content">By that point the player base can already be devastated, and it can kill the game. Cycle: Frontiers was an extraction shooter, and the immediate cheating was rampant; the game&#x27;s design meant dying to hackers was devastating -- imagine a hacker forcing you to lose not just this game, but retroactively making you lose the prior 5 games too. This absolutely destroys player morale, near instantly. Even if you ban that hacker instantly, there&#x27;s an extremely high chance those players will never return. Because the rampant cheating went on for so long, the game&#x27;s reputation never recovered. Within a year of release the servers were shut down.<p>A single cheater can often ruin games for hundreds or even thousands of players very easily. For experienced players, seeing a single flying aimbot shithead in your lobby just means there are 10 other cheaters in the lobby too -- ones using subtle ESP&#x2F;wallhacks that can be extremely difficult to detect, by design. Shady websites like G2A or GMG that sell keys (which are almost 100% hot keys, to really make it all come full circle) mean that even if you get banned, buying new keys for a new copy of the game is extremely cheap, especially when many of these games have items that can be sold for IRL cash in various ways, games like Rust. For many parts of the world, selling&#x2F;trading rare items to players can net you plenty of actual income -- and getting banned means nothing as a result. Instant banning cheaters the second they are confirmed leaks information to the cheater and cheat creator, today most games like Warzone or Destiny have to play psyops and shroud their exact detection techniques in part by doing &quot;ban waves&quot; only when they accumulate a mass amount of confirmed cheaters. The cheater that ruined your top score may, necessarily and by design, be allowed to run free for a while.<p>The net result of all this is that designers and -- importantly, even though people on Hacker News don&#x27;t want to hear it -- PLAYERS tend to overwhelmingly prefer <i>prevention</i> instead of <i>reaction</i>. They are both needed. Players are not morons who love installing rootkits. But on the whole, preventative measures tend to be more valuable to players and creators than reactionary ones, even if they are all ultimately imperfect.<p>In a funny twist, games like Tarkov and Rust do have a gameplay mechanic that reduces the long-term psychological devastation of cheaters and is not invasive at all: they reset all content in the game to &quot;neutral&quot; every once in a while, so basically all your stuff gets deleted, and everyone starts over again. (This non-permanence is probably one of the reasons players stick with the game, despite cheaters, which are incredibly infuriating.)<p>Can I ask if you seriously play any online competitive games, at a high level or otherwise? Because I do, and I&#x27;ll be honest: I&#x27;ve been hearing it all for 20 years. These types of approaches <i>have</i> had success (CS&#x27;s player review system, certain shadowban systems, &quot;trip wires&quot; that trigger on impossible game behavior), but there is <i>no</i> single approach that has proven itself to be the ultimate universal solution. There is no universal, wibbly wobbly bullshit stats algorithm you run on your servers to &quot;solve&quot; this. These problems are not solved. I don&#x27;t like it. I don&#x27;t run certain games with certain forms of anticheat. But it is what it is.</div><br/></div></div></div></div></div></div></div></div><div id="41184632" class="c"><input type="checkbox" id="c-41184632" checked=""/><div class="controls bullet"><span class="by">jdlyga</span><span>|</span><a href="#41186325">prev</a><span>|</span><a href="#41184768">next</a><span>|</span><label class="collapse" for="c-41184632">[-]</label><label class="expand" for="c-41184632">[3 more]</label></div><br/><div class="children"><div class="content">Imagine a VSCode plugin that made up trick names and gave you a combo points score at the bottom for your continuous keystrokes. Tony Hawk&#x27;s Pro-grammer</div><br/><div id="41188926" class="c"><input type="checkbox" id="c-41188926" checked=""/><div class="controls bullet"><span class="by">high_priest</span><span>|</span><a href="#41184632">parent</a><span>|</span><a href="#41184898">next</a><span>|</span><label class="collapse" for="c-41188926">[-]</label><label class="expand" for="c-41188926">[1 more]</label></div><br/><div class="children"><div class="content">This describes <a href="https:&#x2F;&#x2F;codestats.net" rel="nofollow">https:&#x2F;&#x2F;codestats.net</a> very well</div><br/></div></div><div id="41184898" class="c"><input type="checkbox" id="c-41184898" checked=""/><div class="controls bullet"><span class="by">i_read_news</span><span>|</span><a href="#41184632">parent</a><span>|</span><a href="#41188926">prev</a><span>|</span><a href="#41184768">next</a><span>|</span><label class="collapse" for="c-41184898">[-]</label><label class="expand" for="c-41184898">[1 more]</label></div><br/><div class="children"><div class="content">I think this would be more fun for VIM keybindings, where there is a higher skill level (to get cooler combos of course).</div><br/></div></div></div></div><div id="41184768" class="c"><input type="checkbox" id="c-41184768" checked=""/><div class="controls bullet"><span class="by">Rebelgecko</span><span>|</span><a href="#41184632">prev</a><span>|</span><a href="#41184094">next</a><span>|</span><label class="collapse" for="c-41184768">[-]</label><label class="expand" for="c-41184768">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing, the other articles on this blog are equally fascinating</div><br/><div id="41187199" class="c"><input type="checkbox" id="c-41187199" checked=""/><div class="controls bullet"><span class="by">Arrath</span><span>|</span><a href="#41184768">parent</a><span>|</span><a href="#41184094">next</a><span>|</span><label class="collapse" for="c-41187199">[-]</label><label class="expand" for="c-41187199">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Running Halo 2 in true HD&quot; was a really, really good read.</div><br/></div></div></div></div><div id="41184094" class="c"><input type="checkbox" id="c-41184094" checked=""/><div class="controls bullet"><span class="by">brcmthrowaway</span><span>|</span><a href="#41184768">prev</a><span>|</span><a href="#41187409">next</a><span>|</span><label class="collapse" for="c-41184094">[-]</label><label class="expand" for="c-41184094">[5 more]</label></div><br/><div class="children"><div class="content">This gives me an opportunity to clarify a myth from my childhood. Was Tony Hawk the first ever to hit a 720?</div><br/><div id="41184202" class="c"><input type="checkbox" id="c-41184202" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#41184094">parent</a><span>|</span><a href="#41187409">next</a><span>|</span><label class="collapse" for="c-41184202">[-]</label><label class="expand" for="c-41184202">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aerial_(skateboarding)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aerial_(skateboarding)</a> says &quot;The 720, two full mid-air rotations, is one of the rarest tricks in skateboarding. It was first done by Tony Hawk in 1985, and it wasn&#x27;t something he planned to do.&quot;<p>(Which is presumably &quot;the first recorded&quot; but I&#x27;m guessing if someone had done it, they&#x27;d have been shouting about it and -probably- the only kind of person who could pull it off would be a pro skater anyway?)</div><br/><div id="41184710" class="c"><input type="checkbox" id="c-41184710" checked=""/><div class="controls bullet"><span class="by">detoured299</span><span>|</span><a href="#41184094">root</a><span>|</span><a href="#41184202">parent</a><span>|</span><a href="#41184773">next</a><span>|</span><label class="collapse" for="c-41184710">[-]</label><label class="expand" for="c-41184710">[1 more]</label></div><br/><div class="children"><div class="content">At that time only a few pro vert skaters would have had the ability to throw 720s, yeah. Nowadays a good number of ams can too.<p>The rarity of seeing a 720 or above has as much to do with the fact that most skaters don’t skate vert - instead skating street or smaller transition - as the trick’s difficulty. Outsiders tend to imagine large spins are the holy grail of skate moves but almost all skaters aren’t interested in them for aesthetic reasons among others.</div><br/></div></div><div id="41184773" class="c"><input type="checkbox" id="c-41184773" checked=""/><div class="controls bullet"><span class="by">voytec</span><span>|</span><a href="#41184094">root</a><span>|</span><a href="#41184202">parent</a><span>|</span><a href="#41184710">prev</a><span>|</span><a href="#41187409">next</a><span>|</span><label class="collapse" for="c-41184773">[-]</label><label class="expand" for="c-41184773">[2 more]</label></div><br/><div class="children"><div class="content">He worked much longer for the 900 but more importantly - he repeated the 900 at the age of 48[0]!<p>[0] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;TnvPt_a7iOQ?t=93" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;TnvPt_a7iOQ?t=93</a></div><br/><div id="41187327" class="c"><input type="checkbox" id="c-41187327" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41184094">root</a><span>|</span><a href="#41184773">parent</a><span>|</span><a href="#41187409">next</a><span>|</span><label class="collapse" for="c-41187327">[-]</label><label class="expand" for="c-41187327">[1 more]</label></div><br/><div class="children"><div class="content">Even more impressive: a 9-year-old did three consecutive 900s in front of Tony Hawk[1].<p>Arguably, this feat is easier for a small child, but still... insane talent at a young age.<p>[1]: <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;1dh6p2h" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;1dh6p2h</a></div><br/></div></div></div></div></div></div></div></div><div id="41183832" class="c"><input type="checkbox" id="c-41183832" checked=""/><div class="controls bullet"><span class="by">nj5rq</span><span>|</span><a href="#41187409">prev</a><span>|</span><label class="collapse" for="c-41183832">[-]</label><label class="expand" for="c-41183832">[1 more]</label></div><br/><div class="children"><div class="content">Very good article.</div><br/></div></div></div></div></div></div></div></body></html>