<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695200461593" as="style"/><link rel="stylesheet" href="styles.css?v=1695200461593"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://eranstiller.com/rabbitmq-vs-kafka-an-architects-dilemma-part-1">RabbitMQ vs. Kafka – An Architect’s Dilemma (Part 1)</a> <span class="domain">(<a href="https://eranstiller.com">eranstiller.com</a>)</span></div><div class="subtext"><span>gslin</span> | <span>125 comments</span></div><br/><div><div id="37579061" class="c"><input type="checkbox" id="c-37579061" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#37576077">next</a><span>|</span><label class="collapse" for="c-37579061">[-]</label><label class="expand" for="c-37579061">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen Tibco Rendezvous used in manufacturing. ~300 megabytes per hour of raw log generated 24&#x2F;7&#x2F;365 by tools and control systems in a factory setting. Probably on the order of 10k+ participants in the pub&#x2F;sub network.<p>If you are running something like a factory where thousands of independent systems need to communicate in some way, this kind of tech starts to look like the <i>only</i> option.<p>If you are orchestrating the concerns of 5-10 services, I think you are making your life harder than it needs to be with ESB-style abstractions. Direct method invocation is much more reliable than whatever any one of these vendors could ever sell you. Put all your services into one exe. If you can&#x27;t be bothered to use one language&#x2F;repo, there are <i>still</i> ways to achieve this.<p>The real architect&#x27;s dilemma is shoving one&#x27;s edifice-constructing ego into a box long enough to produce a useful shack for the business.</div><br/><div id="37581852" class="c"><input type="checkbox" id="c-37581852" checked=""/><div class="controls bullet"><span class="by">opentokix</span><span>|</span><a href="#37579061">parent</a><span>|</span><a href="#37579531">next</a><span>|</span><label class="collapse" for="c-37581852">[-]</label><label class="expand" for="c-37581852">[1 more]</label></div><br/><div class="children"><div class="content">Your usecase is EASY - its EASY!<p>This is a SOLVED usecase.</div><br/></div></div><div id="37579531" class="c"><input type="checkbox" id="c-37579531" checked=""/><div class="controls bullet"><span class="by">kuchenbecker</span><span>|</span><a href="#37579061">parent</a><span>|</span><a href="#37581852">prev</a><span>|</span><a href="#37580088">next</a><span>|</span><label class="collapse" for="c-37579531">[-]</label><label class="expand" for="c-37579531">[3 more]</label></div><br/><div class="children"><div class="content">Our prod cluster generates that about every minute at O(1M) qps.<p>We JUST turned on remote Logs because until now Kafka didn&#x27;t have capacity.</div><br/><div id="37581094" class="c"><input type="checkbox" id="c-37581094" checked=""/><div class="controls bullet"><span class="by">blindriver</span><span>|</span><a href="#37579061">root</a><span>|</span><a href="#37579531">parent</a><span>|</span><a href="#37580106">next</a><span>|</span><label class="collapse" for="c-37581094">[-]</label><label class="expand" for="c-37581094">[1 more]</label></div><br/><div class="children"><div class="content">My previous company&#x27;s Kafka cluster was handing 20 million messages per second 5 years ago, and dozens of petabytes of data per day. Maybe your particular cluster that didn&#x27;t have the capacity to handle 1M qps, but Kafka easily had that capacity years ago.</div><br/></div></div><div id="37580106" class="c"><input type="checkbox" id="c-37580106" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#37579061">root</a><span>|</span><a href="#37579531">parent</a><span>|</span><a href="#37581094">prev</a><span>|</span><a href="#37580088">next</a><span>|</span><label class="collapse" for="c-37580106">[-]</label><label class="expand" for="c-37580106">[1 more]</label></div><br/><div class="children"><div class="content">TIBCO Rendezvous is tech from 1998&#x2F;99, millions of messages per second didn&#x27;t exist at the time. Only NYSE and NASDAQ were capable of producing millions of events back then (still not by minute nor by second).<p>TIBCO Rendezvous was one of the first successful large scale, low latency and near real-time pub&#x2F;sub implementations, and it had a very efficient, Avro like, wire level serialisation format that made messages very compact and efficient to deliver. It was very popular in finance, banking and manufacturing, and is all but legacy now.</div><br/></div></div></div></div><div id="37580088" class="c"><input type="checkbox" id="c-37580088" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#37579061">parent</a><span>|</span><a href="#37579531">prev</a><span>|</span><a href="#37580100">next</a><span>|</span><label class="collapse" for="c-37580088">[-]</label><label class="expand" for="c-37580088">[1 more]</label></div><br/><div class="children"><div class="content">NATS was developed by an ex-TIBCO engineer.</div><br/></div></div><div id="37580100" class="c"><input type="checkbox" id="c-37580100" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#37579061">parent</a><span>|</span><a href="#37580088">prev</a><span>|</span><a href="#37579272">next</a><span>|</span><label class="collapse" for="c-37580100">[-]</label><label class="expand" for="c-37580100">[1 more]</label></div><br/><div class="children"><div class="content">I use NATS to create a secure pipe between buildings and the cloud. I don&#x27;t need speed but I do need routing and I do need a security layer. Nats just works and took very little setup.</div><br/></div></div><div id="37579272" class="c"><input type="checkbox" id="c-37579272" checked=""/><div class="controls bullet"><span class="by">strangemonad</span><span>|</span><a href="#37579061">parent</a><span>|</span><a href="#37580100">prev</a><span>|</span><a href="#37576077">next</a><span>|</span><label class="collapse" for="c-37579272">[-]</label><label class="expand" for="c-37579272">[2 more]</label></div><br/><div class="children"><div class="content">Or NATS</div><br/><div id="37579371" class="c"><input type="checkbox" id="c-37579371" checked=""/><div class="controls bullet"><span class="by">relay23</span><span>|</span><a href="#37579061">root</a><span>|</span><a href="#37579272">parent</a><span>|</span><a href="#37576077">next</a><span>|</span><label class="collapse" for="c-37579371">[-]</label><label class="expand" for="c-37579371">[1 more]</label></div><br/><div class="children"><div class="content">or kafka, or any other publish&#x2F;subscribe system</div><br/></div></div></div></div></div></div><div id="37576077" class="c"><input type="checkbox" id="c-37576077" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37579061">prev</a><span>|</span><a href="#37579235">next</a><span>|</span><label class="collapse" for="c-37576077">[-]</label><label class="expand" for="c-37576077">[27 more]</label></div><br/><div class="children"><div class="content">&gt; one is a message broker, and the other is a distributed streaming platform<p>I think this is an odd way of putting it. One is smart messaging; dumb clients. The other is dumb messaging; smart clients. It turns out the latter (i.e. Kafka) scales wonderfully so you can send more data, but you add complexity to your clients, who can&#x27;t just now pluck messages off a queue to process, or have messages retry upon the first 3 failures, as they could with RabbitMQ.<p>Having said that, Kafka lets you keep all your data, so you don&#x27;t have to worry about losing messages to unexpected interactions between RabbitMQ rules. But having said <i>that</i>, now you have to store all your data.</div><br/><div id="37576666" class="c"><input type="checkbox" id="c-37576666" checked=""/><div class="controls bullet"><span class="by">raducu</span><span>|</span><a href="#37576077">parent</a><span>|</span><a href="#37578539">next</a><span>|</span><label class="collapse" for="c-37576666">[-]</label><label class="expand" for="c-37576666">[7 more]</label></div><br/><div class="children"><div class="content">&gt; who can&#x27;t just now pluck messages off a queue to process<p>The problem is you cannot mark individual messages as read, for a given consumer&amp;partition you can only update the offset for a partition.<p>If a certain message processing takes very long, all other messages in that partition will have to wait.<p>Also, with kafka, the max read concurrency is equal to the number of partitions, for something like rabbitMq it is much higher; but you do get nice message ordering for any given partition in kafka which you do not get in RabbitMq (afik); you are also get some really nice data locality with kafka because unless  the consumers get the partitions re-assigned, all messages for the same key are served on the same physical consumer.</div><br/><div id="37577397" class="c"><input type="checkbox" id="c-37577397" checked=""/><div class="controls bullet"><span class="by">ryanjshaw</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576666">parent</a><span>|</span><a href="#37577015">next</a><span>|</span><label class="collapse" for="c-37577397">[-]</label><label class="expand" for="c-37577397">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The problem is you cannot mark individual messages as read, for a given consumer&amp;partition you can only update the offset for a partition.<p>Hence &quot;smart clients&quot;. If you MUST process every message at least once, you will anyway be tracking messages individually on the client (e.g. a DB or file system plus logic for idempotent message processing) and thus disable auto-offset commits back to the cluster for your consumer.<p>RabbitMQ says &quot;let me track this for you&quot;, Kafka says &quot;you already need to track this so why duplicate the data in the cluster and complicate the protocol&quot;.<p>If you don&#x27;t have reliable persistent storage available and insist on using the Kafka cluster to track offsets, you can track processed offsets in memory and whenever your lowest processed offset moves forward, you have your consumer commit that offset manually as part of its message loop.<p>If your service restarts your downstream commands need to be idempotent of course because you will reconsume messages you may have previously processed, but this would be the case regardless of Kafka or RabbitMQ unless you&#x27;re using distributed transactions (yuck).<p>&gt; If a certain message processing takes very long, all other messages in that partition will have to wait.<p>You can stream messages into a buffer and process them in parallel, and commit the low watermark offset whenever it changes, as described above. I&#x27;ve implemented this in .NET with Channels and saturate the CPUs with no problem.</div><br/><div id="37580566" class="c"><input type="checkbox" id="c-37580566" checked=""/><div class="controls bullet"><span class="by">raducu</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37577397">parent</a><span>|</span><a href="#37577859">next</a><span>|</span><label class="collapse" for="c-37580566">[-]</label><label class="expand" for="c-37580566">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve made very good points about smart clients, but at some point one has to ponder if it&#x27;s worth it or one should just not use kafka in the first place.<p>I&#x27;ve seen databases used as messaging queues and if it was up to me, I&#x27;d never do that. It&#x27;s usually &quot;but we already have kafka + db, why burden ourselves with another messaging technology?&quot;, which is fair.<p>&gt;  You can stream messages into a buffer and process them in parallel, and commit the low watermark offset whenever it changes, as described above. I&#x27;ve implemented this in .NET with Channels and saturate the CPUs with no problem.<p>That is very nice -- certainly seems better than just batch processing of kafka messages, but you&#x27;re still just kicking the can down the road.    
How large do allow the buffer to become and what do you do when it&#x27;s getting too large?<p>You probably use a DLQ.<p>Don&#x27;t get me wrong, I think the buffer idea probably works most of the time.</div><br/><div id="37581117" class="c"><input type="checkbox" id="c-37581117" checked=""/><div class="controls bullet"><span class="by">ryanjshaw</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37580566">parent</a><span>|</span><a href="#37577859">next</a><span>|</span><label class="collapse" for="c-37581117">[-]</label><label class="expand" for="c-37581117">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree. Kafka was another team&#x27;s decision, not mine, so I had to figure it out. RabbitMQ is very convenient in that you don&#x27;t need to read a couple of books on reliable data integration patterns to get something working simply and intuitively.<p>I am fond of Kafka now that I understand it, but I was also an assembly language programmer in a past life so my opinion is probably in the minority.<p>Regarding the buffer size: you need to implement back pressure, especially if you are CPU and not IO bound; it&#x27;s another thing that&#x27;s easy to get wrong with Kafka.</div><br/></div></div></div></div><div id="37577859" class="c"><input type="checkbox" id="c-37577859" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37577397">parent</a><span>|</span><a href="#37580566">prev</a><span>|</span><a href="#37577015">next</a><span>|</span><label class="collapse" for="c-37577859">[-]</label><label class="expand" for="c-37577859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can stream messages into a buffer and process them in parallel, and commit the low watermark offset whenever it changes, as described above. I&#x27;ve implemented this in .NET with Channels and saturate the CPUs with no problem.<p>And there are libraries that will manage all this for you e.g. <a href="https:&#x2F;&#x2F;github.com&#x2F;line&#x2F;decaton">https:&#x2F;&#x2F;github.com&#x2F;line&#x2F;decaton</a></div><br/></div></div></div></div><div id="37577015" class="c"><input type="checkbox" id="c-37577015" checked=""/><div class="controls bullet"><span class="by">math</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576666">parent</a><span>|</span><a href="#37577397">prev</a><span>|</span><a href="#37578539">next</a><span>|</span><label class="collapse" for="c-37577015">[-]</label><label class="expand" for="c-37577015">[2 more]</label></div><br/><div class="children"><div class="content">Worth noting that Kafka is getting queues: <a href="https:&#x2F;&#x2F;cwiki.apache.org&#x2F;confluence&#x2F;display&#x2F;KAFKA&#x2F;KIP-932%3A+Queues+for+Kafka" rel="nofollow noreferrer">https:&#x2F;&#x2F;cwiki.apache.org&#x2F;confluence&#x2F;display&#x2F;KAFKA&#x2F;KIP-932%3A...</a></div><br/><div id="37578321" class="c"><input type="checkbox" id="c-37578321" checked=""/><div class="controls bullet"><span class="by">facorreia</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37577015">parent</a><span>|</span><a href="#37578539">next</a><span>|</span><label class="collapse" for="c-37578321">[-]</label><label class="expand" for="c-37578321">[1 more]</label></div><br/><div class="children"><div class="content">And also Rabbit has streams[1]. There&#x27;s a lot of overlap.<p>[1] <a href="https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;streams.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;streams.html</a></div><br/></div></div></div></div></div></div><div id="37578539" class="c"><input type="checkbox" id="c-37578539" checked=""/><div class="controls bullet"><span class="by">pnpnp</span><span>|</span><a href="#37576077">parent</a><span>|</span><a href="#37576666">prev</a><span>|</span><a href="#37578921">next</a><span>|</span><label class="collapse" for="c-37578539">[-]</label><label class="expand" for="c-37578539">[4 more]</label></div><br/><div class="children"><div class="content">Just my 2c but for anyone unaware, you should check out NATS.<p>It combines the best of both Kafka and RabbitMQ IMO.</div><br/><div id="37578974" class="c"><input type="checkbox" id="c-37578974" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37578539">parent</a><span>|</span><a href="#37578921">next</a><span>|</span><label class="collapse" for="c-37578974">[-]</label><label class="expand" for="c-37578974">[3 more]</label></div><br/><div class="children"><div class="content">I thought NATS didn&#x27;t actually store messages, am I mistaken?<p>Looking at Wikipedia (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NATS_Messaging" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;NATS_Messaging</a>) I see that I&#x27;m technically right, it&#x27;s JetStream that does the storage layer - but it&#x27;s part of the NATS server.<p>From memory, I really liked the philosophy of NATS but found the nomenclature confusing.</div><br/><div id="37580242" class="c"><input type="checkbox" id="c-37580242" checked=""/><div class="controls bullet"><span class="by">pnpnp</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37578974">parent</a><span>|</span><a href="#37578921">next</a><span>|</span><label class="collapse" for="c-37580242">[-]</label><label class="expand" for="c-37580242">[2 more]</label></div><br/><div class="children"><div class="content">I think they call that part of NATS “Jetstream” if I’m not mistaken. I haven’t used it, but I believe it has some form of message persistence.<p>I have used it mostly for message-first services, and found subject-based messaging a breath of fresh air to decouple services. You can do the same thing with RabbitMQ topic exchanges, but it requires quite a bit more hand-waving.</div><br/><div id="37580598" class="c"><input type="checkbox" id="c-37580598" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37580242">parent</a><span>|</span><a href="#37578921">next</a><span>|</span><label class="collapse" for="c-37580598">[-]</label><label class="expand" for="c-37580598">[1 more]</label></div><br/><div class="children"><div class="content">Jetstream does indeed have message persistence: I can issue queries like “get messages on topic since 5 minutes ago” - I do this a ton. However, that seems to be the extent of the storage&#x2F;query API that it exposes for historical messages. I’m quite a big fan, and would recommend it with the caveat that Jetstream is considerably more complex than simple nats and I get the feeling I’m barely scratching the surface with it.</div><br/></div></div></div></div></div></div></div></div><div id="37578921" class="c"><input type="checkbox" id="c-37578921" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#37576077">parent</a><span>|</span><a href="#37578539">prev</a><span>|</span><a href="#37576201">next</a><span>|</span><label class="collapse" for="c-37578921">[-]</label><label class="expand" for="c-37578921">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re getting to the key thing:<p>You don&#x27;t want to classify them by what they do. You want to classify them by what the clients must do&#x2F;experience.</div><br/></div></div><div id="37576201" class="c"><input type="checkbox" id="c-37576201" checked=""/><div class="controls bullet"><span class="by">supermatt</span><span>|</span><a href="#37576077">parent</a><span>|</span><a href="#37578921">prev</a><span>|</span><a href="#37579235">next</a><span>|</span><label class="collapse" for="c-37576201">[-]</label><label class="expand" for="c-37576201">[14 more]</label></div><br/><div class="children"><div class="content">&gt; One is smart messaging; dumb clients. The other is dumb messaging; smart clients.<p>All the smartness of the messaging can be implemented in the smart clients. Then you can expose that as a smart messaging api to dumb clients.<p>The most obvious example is kafka streams which exposes a &quot;simple&quot; api rather than dealing directly with kafka, but obviously you could create a less featurefull wrapper than that.</div><br/><div id="37576403" class="c"><input type="checkbox" id="c-37576403" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576201">parent</a><span>|</span><a href="#37576903">next</a><span>|</span><label class="collapse" for="c-37576403">[-]</label><label class="expand" for="c-37576403">[8 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help but think that this just gives you the worst of both worlds. You are now on the hook managing that non-standard &quot;smart&quot; wrapper which will quickly just become the status quo for the project. Anyone wanting to change how it works needs to understand exactly how &quot;smart&quot; you made it and all the side effects that will come with making a change there.<p>I pushed against knative in our company particularly for that reason. Like we wanna use kafka because [Insert kafka sales pitch], but we don&#x27;t want our developers to utilize any of the kafka features. We&#x27;re just gonna define the kafka client in some yaml format and have our clients handle an http request per message. It didn&#x27;t make sense to me.</div><br/><div id="37576476" class="c"><input type="checkbox" id="c-37576476" checked=""/><div class="controls bullet"><span class="by">supermatt</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576403">parent</a><span>|</span><a href="#37576431">next</a><span>|</span><label class="collapse" for="c-37576476">[-]</label><label class="expand" for="c-37576476">[6 more]</label></div><br/><div class="children"><div class="content">Thats kind of like saying dont use any software libraries because they all use the standard lib indirectly so you may as well just use that?<p>Its just an abstraction layer to make things less effort.</div><br/><div id="37578439" class="c"><input type="checkbox" id="c-37578439" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576476">parent</a><span>|</span><a href="#37576600">next</a><span>|</span><label class="collapse" for="c-37578439">[-]</label><label class="expand" for="c-37578439">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Thats kind of like saying dont use any software libraries because they all use the standard lib indirectly so you may as well just use that?<p>This is decent advice, IMO. The cost of dependency management is often vastly understated.</div><br/><div id="37581733" class="c"><input type="checkbox" id="c-37581733" checked=""/><div class="controls bullet"><span class="by">snoman</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37578439">parent</a><span>|</span><a href="#37576600">next</a><span>|</span><label class="collapse" for="c-37581733">[-]</label><label class="expand" for="c-37581733">[1 more]</label></div><br/><div class="children"><div class="content">That’s Not Invented Here syndrome, and it’s decidedly bad advice.<p>The cost of dependency management may be understated but it’s always less than the cost of reimplementing everything found in established libraries.</div><br/></div></div></div></div><div id="37576600" class="c"><input type="checkbox" id="c-37576600" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576476">parent</a><span>|</span><a href="#37578439">prev</a><span>|</span><a href="#37578862">next</a><span>|</span><label class="collapse" for="c-37576600">[-]</label><label class="expand" for="c-37576600">[2 more]</label></div><br/><div class="children"><div class="content">yeah, don&#x27;t wrap all calls to a standard lib in another homegrown or non-standard single-digit user lib that makes changes in all sort of subtle ways. There are plenty of C++ projects that make their own or wrap stdlib and they are always a big wtf.<p>It&#x27;s one thing to have an abstraction for kafka in your code, it&#x27;s another to wrap the client in a smart client that reimplements something like rabbitmq, and much worse a smart service.</div><br/><div id="37576625" class="c"><input type="checkbox" id="c-37576625" checked=""/><div class="controls bullet"><span class="by">supermatt</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576600">parent</a><span>|</span><a href="#37578862">next</a><span>|</span><label class="collapse" for="c-37576625">[-]</label><label class="expand" for="c-37576625">[1 more]</label></div><br/><div class="children"><div class="content">&gt; don&#x27;t wrap all calls to a standard lib<p>Im not saying to expose the same primitives - what would be the point in that? I am saying that EVERY lib you use will be using the standard lib or some abstraction of it to perform its own utility.<p>&gt; It&#x27;s one thing to have an abstraction for kafka in your code, it&#x27;s another to wrap the client in a smart client, and much worse a smart service.<p>That abstraction is exactly what i am talking about. Why write 50 lines of boilerplate multiple times throughout your code when you can wrap that up in a single function call and expose THAT as your client. You know thats exactly what you will end up doing on any non-trivial project. Or you could use a lib that already does that - such as the &quot;official&quot; kafka streams lib.</div><br/></div></div></div></div><div id="37578862" class="c"><input type="checkbox" id="c-37578862" checked=""/><div class="controls bullet"><span class="by">zaphirplane</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576476">parent</a><span>|</span><a href="#37576600">prev</a><span>|</span><a href="#37576431">next</a><span>|</span><label class="collapse" for="c-37578862">[-]</label><label class="expand" for="c-37578862">[1 more]</label></div><br/><div class="children"><div class="content">mediocre Libraries sink to the bottom over time. Home grown libraries have a different quality and don’t sink easily. This is definitely YMMV for different teams<p>I can imagine home grown libraries having inconsistent api with wild and wonderful assumptions and beware the edge cases</div><br/></div></div></div></div><div id="37576431" class="c"><input type="checkbox" id="c-37576431" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576403">parent</a><span>|</span><a href="#37576476">prev</a><span>|</span><a href="#37576903">next</a><span>|</span><label class="collapse" for="c-37576431">[-]</label><label class="expand" for="c-37576431">[1 more]</label></div><br/><div class="children"><div class="content">This would be my instinct too.</div><br/></div></div></div></div><div id="37576903" class="c"><input type="checkbox" id="c-37576903" checked=""/><div class="controls bullet"><span class="by">NovemberWhiskey</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576201">parent</a><span>|</span><a href="#37576403">prev</a><span>|</span><a href="#37576331">next</a><span>|</span><label class="collapse" for="c-37576903">[-]</label><label class="expand" for="c-37576903">[3 more]</label></div><br/><div class="children"><div class="content">&gt;<i>All the smartness of the messaging can be implemented in the smart clients.</i><p>How do you do, for example, a queue with priorities client side without it being insanity? That&#x27;s a relatively basic AMQP thing. Or managing the number of redeliveries for a message that&#x27;s being repeatedly rejected.<p>You can absolutely try to build some of this with a look-aside shared data store that all clients have to depend on in order to emulate having the capability in the broker, but you just introduced another common point of failure in addition to the messaging infrastructure. Life is too short for this.</div><br/><div id="37581088" class="c"><input type="checkbox" id="c-37581088" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576903">parent</a><span>|</span><a href="#37577339">next</a><span>|</span><label class="collapse" for="c-37581088">[-]</label><label class="expand" for="c-37581088">[1 more]</label></div><br/><div class="children"><div class="content">Those requirements would definitely be examples of those that are fulfilled by smart messaging.</div><br/></div></div><div id="37577339" class="c"><input type="checkbox" id="c-37577339" checked=""/><div class="controls bullet"><span class="by">supermatt</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576903">parent</a><span>|</span><a href="#37581088">prev</a><span>|</span><a href="#37576331">next</a><span>|</span><label class="collapse" for="c-37577339">[-]</label><label class="expand" for="c-37577339">[1 more]</label></div><br/><div class="children"><div class="content">I totally agree that you cant do a lot of AMQP stuff. As you noted, you can build some of it by managing state via transactional producers, etc - but you definitely cant do everything. The biggest gripe for me is actually dynamic &quot;queue&quot; creation, patterns for topics, etc. So I use an MQ for an MQ ;)<p>I&#x27;m just saying you can &quot;dumb down&quot; the client side on kafka by creating an abstraction layer (or one of the many higher level libs that already do that).</div><br/></div></div></div></div><div id="37576331" class="c"><input type="checkbox" id="c-37576331" checked=""/><div class="controls bullet"><span class="by">waynesonfire</span><span>|</span><a href="#37576077">root</a><span>|</span><a href="#37576201">parent</a><span>|</span><a href="#37576903">prev</a><span>|</span><a href="#37579235">next</a><span>|</span><label class="collapse" for="c-37576331">[-]</label><label class="expand" for="c-37576331">[2 more]</label></div><br/><div class="children"><div class="content">And reimplement rabbitmq? Great idea. Let&#x27;s do it in rust too.</div><br/></div></div></div></div></div></div><div id="37579235" class="c"><input type="checkbox" id="c-37579235" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#37576077">prev</a><span>|</span><a href="#37581507">next</a><span>|</span><label class="collapse" for="c-37579235">[-]</label><label class="expand" for="c-37579235">[4 more]</label></div><br/><div class="children"><div class="content">If you want features of RabbitMQ (specifically queue like behavior) but the scalability of Kafka then you probably want Apache Pulsar.<p>To elaborate on that a bit the main things Pulsar gives you are:<p>1. Still underlying distributed stream based architecture, this is what makes it able to do Kafka like things.<p>2. Broker side management of subscription state which allow out of order acknowledgement, this means you can use it like a queue. (Subscriptions sort of act like AMQP mailboxes but without the exchange routing semantics). Vs Kafka which can only do cumulative acknowledgement, i.e head of line blocking.<p>3. Separated &quot;compute&quot; and storage. By storing data in Bookkeeper you can scale your needs to support a lot of consumers separately from how you stash the data those consumers need to read vs Kafka where these 2 are coupled and an imbalance between the two becomes awkward.<p>4. In built offload with transparent pass-through read. When your data falls off the retention cliff for your standard broker cluster the data can be archived to object storage. The broker can transparently handle read request for these earlier messages though, just with higher startup latency to pull the archived ledgers.<p>5. Way more plugability than Kafka, in-fact similar plugability as RabbitMQ. You can implement your own authz&#x2F;authn, a different listener to support a different protocol (there is a Kafka one, MQTT, AMQP etc).<p>6. Much greater metadata scalability. Before the new KRaft implementation the layout of metadata in ZK meant that you couldn&#x27;t feasibly have more than about 10k topics. Especially because of how long the downtime would be on controller failover. Pulsar can easily support much larger numbers of topics which prevents needing to use a firehose design when you would prefer individual topics per tenant&#x2F;customer&#x2F;whatever.</div><br/><div id="37579976" class="c"><input type="checkbox" id="c-37579976" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#37579235">parent</a><span>|</span><a href="#37581507">next</a><span>|</span><label class="collapse" for="c-37579976">[-]</label><label class="expand" for="c-37579976">[3 more]</label></div><br/><div class="children"><div class="content">While pulsar on paper seems a superior solution, in my experience it is very still very immature and very buggy. I really want to use it over kafka but I would not bet my business on it.<p>I am not a fan of Kafka, it&#x27;s kinda old, and the code is a bit messy, a lot of the once only semantic problems 100% solved by Pulser are sorta kinda in Kfaka these days. All the newer stuff like built in RAFT makes it competitive with anything.<p>But, anyone who has used Kafka at scale has to say it 100% does what it says on the box. Many people are used to it&#x27;s idiosyncrasies at scale and can get it to scale.<p>Now RabbitMQ. I have been burnt so badly by it breaking at scale I&#x27;ll never be touching it again. Maybe my fault, maybe not, but replacing it with Kafka solved all my flakey issues and I never looked at it again.</div><br/><div id="37580027" class="c"><input type="checkbox" id="c-37580027" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#37579235">root</a><span>|</span><a href="#37579976">parent</a><span>|</span><a href="#37581507">next</a><span>|</span><label class="collapse" for="c-37580027">[-]</label><label class="expand" for="c-37580027">[2 more]</label></div><br/><div class="children"><div class="content">I have run all 3 at big scale. Kafka is still great as long as everyone using it understands it&#x27;s a stream, not a queue and using it like a queue is going to get them burnt. I don&#x27;t touch RabbitMQ with a 30ft pole anymore, too many lost days or nights to split brains and other chaos.<p>Pulsar has mostly replaced Kafka for me because I don&#x27;t need to worry about people coming along and changing requirements after the fact and saying, actually yeah we do need queue semantics. Or actually yeah we need data larger than the ~48hrs we want to store in Kafka and we don&#x27;t want to teach our application to read from the archive.<p>Pulsar is definitely greener than Kafka in a lot of ways but the underlying stuff is very solid, BookKeeper in particular is tough so you aren&#x27;t really at risk of data loss but you might run into bugs that make brokers do silly things and that can be annoying. Generally speaking though if you validate both the paths you are using and new releases it&#x27;s been fairly OK to me.<p>The big thing was being able to directly connect external clients into Pulsar using the Websocket listener on the proxy and plugging in my own authz&#x2F;authn logic. The eliminated a layer that would otherwise need to be implemented separately.<p>So far I have been happy with Pulsar, if you haven&#x27;t tried it for a while you should give it another go. It will only get mature if people use it. :)</div><br/><div id="37580511" class="c"><input type="checkbox" id="c-37580511" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#37579235">root</a><span>|</span><a href="#37580027">parent</a><span>|</span><a href="#37581507">next</a><span>|</span><label class="collapse" for="c-37580511">[-]</label><label class="expand" for="c-37580511">[1 more]</label></div><br/><div class="children"><div class="content">Your comments seem to closely reflect mine. I&#x27;ll have to take your advice and give it another go. It&#x27;s everything all the others want to be. The architecture with distributed bookkeeper underneath seems so much more advanced.</div><br/></div></div></div></div></div></div></div></div><div id="37581507" class="c"><input type="checkbox" id="c-37581507" checked=""/><div class="controls bullet"><span class="by">pbowyer</span><span>|</span><a href="#37579235">prev</a><span>|</span><a href="#37576239">next</a><span>|</span><label class="collapse" for="c-37581507">[-]</label><label class="expand" for="c-37581507">[1 more]</label></div><br/><div class="children"><div class="content">What these articles always miss is what are the real-world scenarios that use Kafka or RabbitMQ? I&#x27;ve never used one professionally and beyond the async processing cases I come across in web dev (mostly sending emails asynchronously), or seeing devs using one to handle 5 req&#x2F;s which doesn&#x27;t need it, I don&#x27;t have a good feel for when they are really needed - especially for companies at sub-Uber scale.<p>What real-world cases would you use them for?</div><br/></div></div><div id="37576239" class="c"><input type="checkbox" id="c-37576239" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#37581507">prev</a><span>|</span><a href="#37576195">next</a><span>|</span><label class="collapse" for="c-37576239">[-]</label><label class="expand" for="c-37576239">[1 more]</label></div><br/><div class="children"><div class="content">I think this is an excellent article. The only thing I&#x27;d add is that RabbitMQ is an implementation of AQMP (optionally v1.0) as a standardized broker service protocol so is designed to be interchangeable with other extant implementations such as Apache Active MQ and Cupid whereas Kafka is one-of-a-kind software. Beyond that RabbitMQ has standardized client libs and frameworks in Java land if that matters to you - it did matter in the original context of message queue middlewares and SOA from where AMQP originated and where enterprise messaging sees major use. OTOH Kafka, with caveats, is in principle more &quot;web scale&quot; - though that is far from a free ride.</div><br/></div></div><div id="37576195" class="c"><input type="checkbox" id="c-37576195" checked=""/><div class="controls bullet"><span class="by">dividedbyzero</span><span>|</span><a href="#37576239">prev</a><span>|</span><a href="#37576433">next</a><span>|</span><label class="collapse" for="c-37576195">[-]</label><label class="expand" for="c-37576195">[15 more]</label></div><br/><div class="children"><div class="content">NATS (<a href="https:&#x2F;&#x2F;nats.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nats.io&#x2F;</a>) is another option, though I&#x27;m not sure if it&#x27;s still considered a viable Kafka replacement.</div><br/><div id="37576679" class="c"><input type="checkbox" id="c-37576679" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#37576195">parent</a><span>|</span><a href="#37576521">next</a><span>|</span><label class="collapse" for="c-37576679">[-]</label><label class="expand" for="c-37576679">[2 more]</label></div><br/><div class="children"><div class="content">It’s true FOSS, and the server is standalone Go binary that’s so small it can even be embedded. Lots of language bindings for clients. Has persistence, durability, and nicely aligns into a raft-like cluster in a DC without a separate orchestrator.<p>I’m a big fan – never understood why it’s not at the top of the list in these tech reviews.</div><br/><div id="37577086" class="c"><input type="checkbox" id="c-37577086" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37576679">parent</a><span>|</span><a href="#37576521">next</a><span>|</span><label class="collapse" for="c-37577086">[-]</label><label class="expand" for="c-37577086">[1 more]</label></div><br/><div class="children"><div class="content">Rabbitmq is FOSS, has lots of language bindings. It has persistence, durability, and doesn&#x27;t require a separate orchestrator.</div><br/></div></div></div></div><div id="37576521" class="c"><input type="checkbox" id="c-37576521" checked=""/><div class="controls bullet"><span class="by">fuzzy2</span><span>|</span><a href="#37576195">parent</a><span>|</span><a href="#37576679">prev</a><span>|</span><a href="#37576956">next</a><span>|</span><label class="collapse" for="c-37576521">[-]</label><label class="expand" for="c-37576521">[6 more]</label></div><br/><div class="children"><div class="content">NATS is something else, but it&#x27;s awesome. It has awesome throughput and latency out of the box (without Jetstream), while using little resources.<p>I&#x27;d recommend considering it, especially as an alternative to RabbitMQ.</div><br/><div id="37576883" class="c"><input type="checkbox" id="c-37576883" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37576521">parent</a><span>|</span><a href="#37576956">next</a><span>|</span><label class="collapse" for="c-37576883">[-]</label><label class="expand" for="c-37576883">[5 more]</label></div><br/><div class="children"><div class="content">I only tested NATS using JetStream and I struggled with the throughput in Python. I probably used it wrong. But your comment may imply that jetstream is slow.</div><br/><div id="37581439" class="c"><input type="checkbox" id="c-37581439" checked=""/><div class="controls bullet"><span class="by">fuzzy2</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37576883">parent</a><span>|</span><a href="#37581162">next</a><span>|</span><label class="collapse" for="c-37581439">[-]</label><label class="expand" for="c-37581439">[1 more]</label></div><br/><div class="children"><div class="content">I didn’t mean to imply that Jetstream is slow. It’s just that I did my benchmarks without it. On a local PC, with 10 KiB messages sent (synchronously) in a loop, I could transfer 3.2 GiB over 5 seconds with 0.2 nanoseconds latency. Performing the same test with RabbitMQ, I got even better throughput out of the box, but way worse latency.<p>Those numbers are for server 2.9.6 and .NET client 1.0.8.</div><br/></div></div><div id="37581162" class="c"><input type="checkbox" id="c-37581162" checked=""/><div class="controls bullet"><span class="by">pgorczak</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37576883">parent</a><span>|</span><a href="#37581439">prev</a><span>|</span><a href="#37577485">next</a><span>|</span><label class="collapse" for="c-37581162">[-]</label><label class="expand" for="c-37581162">[1 more]</label></div><br/><div class="children"><div class="content">I’m not familiar with the Python lib but it could be waiting for streams to acknowledge each message reception&#x2F;persistence before sending the next one. Some clients allow transactions to run in parallel e.g. with futures.</div><br/></div></div><div id="37577485" class="c"><input type="checkbox" id="c-37577485" checked=""/><div class="controls bullet"><span class="by">to11mtm</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37576883">parent</a><span>|</span><a href="#37581162">prev</a><span>|</span><a href="#37576985">next</a><span>|</span><label class="collapse" for="c-37577485">[-]</label><label class="expand" for="c-37577485">[1 more]</label></div><br/><div class="children"><div class="content">I think sometimes the client bindings are&#x2F;were in need of improvement.<p>As an example, the C# API was originally very &#x27;go-like&#x27; and written to .NET Framework, didn&#x27;t take advantage of a lot of newer features... to the point a 3rd party client was able to get somewhere between 3-4x the throughput. This is now finally being rectified with a new C# client, however it wouldn&#x27;t surprise me if other languages have similar pains.<p>I haven&#x27;t tested JetStream but my general understanding is that you do have to be mindful of the different options for publishing; especially in the case of JetStream, a synchronous publish call can be relatively time consuming; it&#x27;s better to async publish and (ab)use the future for flow control as needed.</div><br/></div></div><div id="37576985" class="c"><input type="checkbox" id="c-37576985" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37576883">parent</a><span>|</span><a href="#37577485">prev</a><span>|</span><a href="#37576956">next</a><span>|</span><label class="collapse" for="c-37576985">[-]</label><label class="expand" for="c-37576985">[1 more]</label></div><br/><div class="children"><div class="content">we used it for some low latency stuff in python. it was about 10ms to enqueue at worst. However we were using raw NATS, and had a clear SLA that meant that the queue was allowed to be offline or messages lost, so long as we notified the right services.</div><br/></div></div></div></div></div></div><div id="37576956" class="c"><input type="checkbox" id="c-37576956" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#37576195">parent</a><span>|</span><a href="#37576521">prev</a><span>|</span><a href="#37576427">next</a><span>|</span><label class="collapse" for="c-37576956">[-]</label><label class="expand" for="c-37576956">[1 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m not buying a message bus in as a service, then NATS is great for pub&#x2F;sub and or message passing system<p>it is simple to configure, has good documentation, and excellent integration into most languages. It guarantees uptime, and thats about it. It clusters really well, so you can swap out instances, or scale in&#x2F;out as you need.</div><br/></div></div><div id="37576427" class="c"><input type="checkbox" id="c-37576427" checked=""/><div class="controls bullet"><span class="by">vorpalhex</span><span>|</span><a href="#37576195">parent</a><span>|</span><a href="#37576956">prev</a><span>|</span><a href="#37576433">next</a><span>|</span><label class="collapse" for="c-37576427">[-]</label><label class="expand" for="c-37576427">[5 more]</label></div><br/><div class="children"><div class="content">Different set of promises. NATS is great but has a different tradeoff bargain from Rabbit or Kafka.</div><br/><div id="37579462" class="c"><input type="checkbox" id="c-37579462" checked=""/><div class="controls bullet"><span class="by">kumarvvr</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37576427">parent</a><span>|</span><a href="#37576433">next</a><span>|</span><label class="collapse" for="c-37579462">[-]</label><label class="expand" for="c-37579462">[4 more]</label></div><br/><div class="children"><div class="content">Could you expand on this a bit more? I am curious.</div><br/><div id="37579716" class="c"><input type="checkbox" id="c-37579716" checked=""/><div class="controls bullet"><span class="by">vorpalhex</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37579462">parent</a><span>|</span><a href="#37576433">next</a><span>|</span><label class="collapse" for="c-37579716">[-]</label><label class="expand" for="c-37579716">[3 more]</label></div><br/><div class="children"><div class="content">NATs has a decent-ish guide here: <a href="https:&#x2F;&#x2F;docs.nats.io&#x2F;nats-concepts&#x2F;overview&#x2F;compare-nats" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.nats.io&#x2F;nats-concepts&#x2F;overview&#x2F;compare-nats</a><p>A few things they get wrong mostly about Rabbit:<p>+ RabbitMQ does support replay, and also has a memory only mode which will support persistance in a cluster<p>+ RabbitMQ doesn&#x27;t have that sensitive of a latency between cluster members (no more sensitive than NATS in some setups).<p>+ RabbitMQ also supports Prometheus<p>A good (but incomplete) rule of thumb:<p>+ Kafka is a distributed Append-Only-Log that looks like a message bus. It allows time travel but has very simple server semantics.<p>+ RabbitMQ is a true message broker with all the abilities and patterns therein. It comes with more complexity.<p>+ NATs is primarily a straight forward streaming messaging platform.<p>Also consider Redis&#x27; message queue mode, zeromq, mqtt brokers (Eclipse Mosquitto) and the option of just not using a message broker&#x2F;queue system. Even as someone who really likes the pubsub pattern, there&#x27;s a good chance you don&#x27;t need it and you may be heading to a distributed monolith antipattern.</div><br/><div id="37580933" class="c"><input type="checkbox" id="c-37580933" checked=""/><div class="controls bullet"><span class="by">mherdeg</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37579716">parent</a><span>|</span><a href="#37580082">next</a><span>|</span><label class="collapse" for="c-37580933">[-]</label><label class="expand" for="c-37580933">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this link -- really interesting.<p>I like the suggestion to rethink whether you actually need to be doing asynchronous computing with a message broker&#x2F;queue&#x2F;stream or whether you can represent your work another way.</div><br/></div></div><div id="37580082" class="c"><input type="checkbox" id="c-37580082" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#37576195">root</a><span>|</span><a href="#37579716">parent</a><span>|</span><a href="#37580933">prev</a><span>|</span><a href="#37576433">next</a><span>|</span><label class="collapse" for="c-37580082">[-]</label><label class="expand" for="c-37580082">[1 more]</label></div><br/><div class="children"><div class="content">&gt; distributed monolith antipattern<p>Beauty is in the eye of the beholder, I guess. (I would definitely not consider a distributed monolith an antipattern)<p>Also wanted to add NSQ to your very good list.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37576433" class="c"><input type="checkbox" id="c-37576433" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37576195">prev</a><span>|</span><a href="#37577110">next</a><span>|</span><label class="collapse" for="c-37576433">[-]</label><label class="expand" for="c-37576433">[16 more]</label></div><br/><div class="children"><div class="content">One is a tomato, the other is an orange. From a distance they might look alike but they really are two completely different tools. This is a pretty solid explanation of the differences with good illustrations.<p>Rabbit can do everything Kafka does - and much more - in a more configurable manner. Kafka is highly optimized for essentially one use case and does that well. Nothing in life is free, there are trade-offs everywhere. I am not privy to which one is theoretically faster - but once you reach that question methinks the particular workload is the deciding factor.</div><br/><div id="37576905" class="c"><input type="checkbox" id="c-37576905" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#37576433">parent</a><span>|</span><a href="#37579294">next</a><span>|</span><label class="collapse" for="c-37576905">[-]</label><label class="expand" for="c-37576905">[3 more]</label></div><br/><div class="children"><div class="content">Rabbit is an arse to scale past one broker. It was possible, but a pain, that might have changed.<p>Kafka is just a pain full stop.</div><br/><div id="37577529" class="c"><input type="checkbox" id="c-37577529" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576905">parent</a><span>|</span><a href="#37577114">next</a><span>|</span><label class="collapse" for="c-37577529">[-]</label><label class="expand" for="c-37577529">[1 more]</label></div><br/><div class="children"><div class="content">At a previous company, about 10 years ago, we had roughly 10 RabbitMQ instances (brokers), all isolated. The system was essentially partitioned by queue server. We had a directory-ish service that would associate clients with their assigned node. It worked well, except if a client got too large we might have to move them to another queue.</div><br/></div></div><div id="37577114" class="c"><input type="checkbox" id="c-37577114" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576905">parent</a><span>|</span><a href="#37577529">prev</a><span>|</span><a href="#37579294">next</a><span>|</span><label class="collapse" for="c-37577114">[-]</label><label class="expand" for="c-37577114">[1 more]</label></div><br/><div class="children"><div class="content">The official rabbitmq controller for kubernetes is a breeze. Scales wonderfully without almost any effort.</div><br/></div></div></div></div><div id="37579294" class="c"><input type="checkbox" id="c-37579294" checked=""/><div class="controls bullet"><span class="by">relay23</span><span>|</span><a href="#37576433">parent</a><span>|</span><a href="#37576905">prev</a><span>|</span><a href="#37576468">next</a><span>|</span><label class="collapse" for="c-37579294">[-]</label><label class="expand" for="c-37579294">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Rabbit can do everything Kafka does - and much more - in a more configurable manner.
Sure, if you&#x27;re doing like 10&#x27;s of MB&#x2F;s. RMQ is fast compared to AK if you&#x27;re not adding durability, persistence, etc. Try to run gigabytes per second through it though, or stretch across regions, or meet RTO when the broker gets overloaded and crashes.. Get your shovel ready! ;)<p>Kafka itself is dumb but scalable and resilient, it&#x27;s the client ecosystem that&#x27;s massive compared to RabbitMQ. Count 10 stream processing, connectivity, ingestion or log harvesting platforms that use RMQ as it&#x27;s backend, then name 10 languages that have supported libraries for RMQ.. then compare that to Kafka.</div><br/></div></div><div id="37576468" class="c"><input type="checkbox" id="c-37576468" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#37576433">parent</a><span>|</span><a href="#37579294">prev</a><span>|</span><a href="#37577110">next</a><span>|</span><label class="collapse" for="c-37576468">[-]</label><label class="expand" for="c-37576468">[11 more]</label></div><br/><div class="children"><div class="content">I am not an expert in either and have only worked with Kafka. At a past job I had to write a connector job to parse and sanitize some extremely dirty, unstructured data and pass it along somewhere else. RabbitMQ supports this? What is the one use case of kafka? I think you have it backwards.</div><br/><div id="37576539" class="c"><input type="checkbox" id="c-37576539" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576468">parent</a><span>|</span><a href="#37577110">next</a><span>|</span><label class="collapse" for="c-37576539">[-]</label><label class="expand" for="c-37576539">[10 more]</label></div><br/><div class="children"><div class="content">&gt; parse and sanitize some extremely dirty, unstructured data and pass it along somewhere else<p>can you be more specific? that to me sounds like hello world for either of these tools. &quot;santize data&quot; is an application level concern that neither rabbit or kafka would handle. as far as &quot;pass along somewhere else&quot; again both tools can do.</div><br/><div id="37576643" class="c"><input type="checkbox" id="c-37576643" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576539">parent</a><span>|</span><a href="#37577110">next</a><span>|</span><label class="collapse" for="c-37576643">[-]</label><label class="expand" for="c-37576643">[9 more]</label></div><br/><div class="children"><div class="content">It was a Sink Connector. I don’t know what it was or wasn’t supposed to do but I was asked to do it, as is often the case in tech. I could have done any number of transformations in that process though, which I’m not sure rabbitmq supports</div><br/><div id="37576802" class="c"><input type="checkbox" id="c-37576802" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576643">parent</a><span>|</span><a href="#37577110">next</a><span>|</span><label class="collapse" for="c-37576802">[-]</label><label class="expand" for="c-37576802">[8 more]</label></div><br/><div class="children"><div class="content">It sounds to me like you aren&#x27;t really even sure what you built. I have operated both rabbit and kafka at scale I definitely do not have it backwards :)</div><br/><div id="37576914" class="c"><input type="checkbox" id="c-37576914" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576802">parent</a><span>|</span><a href="#37577110">next</a><span>|</span><label class="collapse" for="c-37576914">[-]</label><label class="expand" for="c-37576914">[7 more]</label></div><br/><div class="children"><div class="content">No, I’m not, because it was years ago, and I’m asking for clarification because what was said immediately sounded wrong to me (I’ve managed a lot of rabbitmq deployments) and you’ve not really given one other than an appeal to authority. guess I have my answer. Can’t find anything that suggests rabbitmq natively supports anything like sink connectors. thanks.</div><br/><div id="37577089" class="c"><input type="checkbox" id="c-37577089" checked=""/><div class="controls bullet"><span class="by">supermatt</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576914">parent</a><span>|</span><a href="#37577034">next</a><span>|</span><label class="collapse" for="c-37577089">[-]</label><label class="expand" for="c-37577089">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Can’t find anything that suggests rabbitmq natively supports anything like sink connectors<p>Kafka doesnt natively support them either. That would be Kafka Connect. I guess you could use it as an MQ, but it wouldnt be a very good one. Its more used as a data integration platform. If you want more MQ-like functionality OOTB on top of Kafka you would want to use something like Kafka Streams instead.</div><br/><div id="37577437" class="c"><input type="checkbox" id="c-37577437" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37577089">parent</a><span>|</span><a href="#37577034">next</a><span>|</span><label class="collapse" for="c-37577437">[-]</label><label class="expand" for="c-37577437">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this clarification, this is what I was after.</div><br/></div></div></div></div><div id="37577034" class="c"><input type="checkbox" id="c-37577034" checked=""/><div class="controls bullet"><span class="by">FINDarkside</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576914">parent</a><span>|</span><a href="#37577089">prev</a><span>|</span><a href="#37576980">next</a><span>|</span><label class="collapse" for="c-37577034">[-]</label><label class="expand" for="c-37577034">[1 more]</label></div><br/><div class="children"><div class="content">So let me get this straight. You&#x27;ve used Kafka once, RabbitMQ never. You don&#x27;t really know what you did with Kafka. But you somehow know that RabbitMQ cannot do the thing which you don&#x27;t really remember anymore. Doesn&#x27;t make much sense to be honest.<p>Nobody can really have any sources for RabbitMQ being able to do it if you don&#x27;t know what it supposedly cannot do. The way you descibed it, is that you simply read data and then did something with the data and passed it to somewhere else. RabbitMQ obviously can do it.</div><br/></div></div><div id="37576980" class="c"><input type="checkbox" id="c-37576980" checked=""/><div class="controls bullet"><span class="by">NovemberWhiskey</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576914">parent</a><span>|</span><a href="#37577034">prev</a><span>|</span><a href="#37577110">next</a><span>|</span><label class="collapse" for="c-37576980">[-]</label><label class="expand" for="c-37576980">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I am not an expert in either and have only worked with Kafka.</i><p>&gt; <i>I’ve managed a lot of rabbitmq deployments</i><p>... ?</div><br/><div id="37577420" class="c"><input type="checkbox" id="c-37577420" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576980">parent</a><span>|</span><a href="#37577448">next</a><span>|</span><label class="collapse" for="c-37577420">[-]</label><label class="expand" for="c-37577420">[1 more]</label></div><br/><div class="children"><div class="content">You do not need to be an expert in something&#x27;s internal workings to manage&#x2F;monitor a deployment. Surely this does not need to be explained further.</div><br/></div></div><div id="37577448" class="c"><input type="checkbox" id="c-37577448" checked=""/><div class="controls bullet"><span class="by">lnenad</span><span>|</span><a href="#37576433">root</a><span>|</span><a href="#37576980">parent</a><span>|</span><a href="#37577420">prev</a><span>|</span><a href="#37577110">next</a><span>|</span><label class="collapse" for="c-37577448">[-]</label><label class="expand" for="c-37577448">[1 more]</label></div><br/><div class="children"><div class="content">A classic exchange on the internet.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37577110" class="c"><input type="checkbox" id="c-37577110" checked=""/><div class="controls bullet"><span class="by">rafaelturk</span><span>|</span><a href="#37576433">prev</a><span>|</span><a href="#37579004">next</a><span>|</span><label class="collapse" for="c-37577110">[-]</label><label class="expand" for="c-37577110">[7 more]</label></div><br/><div class="children"><div class="content">Nice post! RabbitMq is battle tested, exceptionally fast and low resources app. Capable of handling millions of transactions&#x2F;second. RabbitMQ will handle vast majority of usecases.
I&#x27;m puzzled why often startups, or even banks use Kafka, soley because is hype. Kafka on the order hand requires massive CPUs, Memory, often requiring its own K8S cluster just to be alive.</div><br/><div id="37578524" class="c"><input type="checkbox" id="c-37578524" checked=""/><div class="controls bullet"><span class="by">ceencee</span><span>|</span><a href="#37577110">parent</a><span>|</span><a href="#37578806">next</a><span>|</span><label class="collapse" for="c-37578524">[-]</label><label class="expand" for="c-37578524">[2 more]</label></div><br/><div class="children"><div class="content">Pretty much every bank uses kafka ad the central messaging layer. What people are missing in almost every post here is the write once read many without data duplication and with different offsets is the killer app for Kafka beyond just the near infinite scale which is also super appealing. The failure modes are way way better than Rabbit as well.  Note: I owned the streaming platform for a top 5 bank in the us.</div><br/><div id="37578821" class="c"><input type="checkbox" id="c-37578821" checked=""/><div class="controls bullet"><span class="by">leetbulb</span><span>|</span><a href="#37577110">root</a><span>|</span><a href="#37578524">parent</a><span>|</span><a href="#37578806">next</a><span>|</span><label class="collapse" for="c-37578821">[-]</label><label class="expand" for="c-37578821">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;m sorry to others, but if you require the guarantees and compliance that Kafka provides, Kafka wins, especially at this kind of scale. I&#x27;d love to see RabbitMQ scaled out to handle hundreds of trillions of events per day and able to retain years worth of highly durable, immutable, and replayable event storage.<p>Ultimately, this comparison is apples vs oranges...</div><br/></div></div></div></div><div id="37578806" class="c"><input type="checkbox" id="c-37578806" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#37577110">parent</a><span>|</span><a href="#37578524">prev</a><span>|</span><a href="#37577159">next</a><span>|</span><label class="collapse" for="c-37578806">[-]</label><label class="expand" for="c-37578806">[1 more]</label></div><br/><div class="children"><div class="content">Rabbitmq sucks to scale. clustering and partitioning were terrible for a long time, maybe still is. Clusters dying in split brained ways, nodes crashing terribly &#x2F; unrecoverable if they exceed iops or storage limits. You couldn’t pay me enough to run a high volume rMQ cluster again.<p>Never mind that the persistent durable log pattern of kakfa enables a lot replay type use cases that are very beneficial in financial systems specifically.<p>It’s not solely because of hype at all, it’s objectively better for many use cases.</div><br/></div></div><div id="37577159" class="c"><input type="checkbox" id="c-37577159" checked=""/><div class="controls bullet"><span class="by">rafaelturk</span><span>|</span><a href="#37577110">parent</a><span>|</span><a href="#37578806">prev</a><span>|</span><a href="#37579004">next</a><span>|</span><label class="collapse" for="c-37577159">[-]</label><label class="expand" for="c-37577159">[3 more]</label></div><br/><div class="children"><div class="content">If your have a clean event-driven architecture, ie messages are completely agnostic and decoupled from one-another you don&#x27;t need Kafka.</div><br/><div id="37578531" class="c"><input type="checkbox" id="c-37578531" checked=""/><div class="controls bullet"><span class="by">ceencee</span><span>|</span><a href="#37577110">root</a><span>|</span><a href="#37577159">parent</a><span>|</span><a href="#37580291">next</a><span>|</span><label class="collapse" for="c-37578531">[-]</label><label class="expand" for="c-37578531">[1 more]</label></div><br/><div class="children"><div class="content">This is a ridiculous statement if you really build an EDA. Kafka is what enables the decoupling.</div><br/></div></div><div id="37580291" class="c"><input type="checkbox" id="c-37580291" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#37577110">root</a><span>|</span><a href="#37577159">parent</a><span>|</span><a href="#37578531">prev</a><span>|</span><a href="#37579004">next</a><span>|</span><label class="collapse" for="c-37580291">[-]</label><label class="expand" for="c-37580291">[1 more]</label></div><br/><div class="children"><div class="content">Event-driven architecture is an architectural <i>principle</i>, and Kafka, RabbitMQ&#x2F;ActiveMQ, Pulsar, NATS and so forth are <i>implementations</i> that support the event-driven architectural principle. Yet, all of them range in a variety, complexity and extent of features they provide which may or may not be a good fit for a particular use case.<p>Traditional message brokers (RabbitMQ and similar) do support the event-driven architecture, yet the data they handle is <i>ephemeral</i>. Once a message has been processed, it is gone forever. Connecting a new raw data source is not an established practice and requires a technical «adapter» of sorts to be built. High concurrency levels is problematic for scenarios where the strict message processing ordering is required: the traditional message brokers do not handle it well in highly parallel scenarios <i>out of the box</i>.<p>Kafka and similar also support event-driven architectures, yet they allow the data to be processed <i>multiple times</i> – by existing (i.e. a data replay) and, most importantly, <i>new or unknown at the time consumers</i> (note: this is distinct from the data replay!). This is allows to plug existing data source(s) into a data streaming platform (Kafka) and <i>incrementally</i> add new data consumers and processors over the time with the datasets being available intact. This is an important distinction. Kafka and similar also improve on the strict processing order guarantee by allowing a message source (a Kafka topic) to be <i>explicitly</i> partitioned out and guaranteeing that the message order will be retained and enforced for a consumer group receiving messages from that partition.<p>To recap, traditional message brokers are a good fit for handling the ephemeral data, and data streaming platforms are a good fit for connecting data sources and allowing the data to be ingested multiple times. Both implement and support event-driven architectures in a variety of scenarios.</div><br/></div></div></div></div></div></div><div id="37579004" class="c"><input type="checkbox" id="c-37579004" checked=""/><div class="controls bullet"><span class="by">dventimi</span><span>|</span><a href="#37577110">prev</a><span>|</span><a href="#37581569">next</a><span>|</span><label class="collapse" for="c-37579004">[-]</label><label class="expand" for="c-37579004">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Apache Kafka is not an implementation of a message broker. Instead, it is a distributed streaming platform. Unlike RabbitMQ, which is based on queues and exchanges, Kafka’s storage layer is implemented using a partitioned transaction log. Kafka also...<p>This seems like an important passage, drawing the crucial and long-awaited distinction between RabbitMQ and Kafka, and yet without having defined a &quot;partitioned transaction log&quot; the author strands the reader without any help in absorbing the distinction.</div><br/><div id="37581518" class="c"><input type="checkbox" id="c-37581518" checked=""/><div class="controls bullet"><span class="by">estiller</span><span>|</span><a href="#37579004">parent</a><span>|</span><a href="#37580628">next</a><span>|</span><label class="collapse" for="c-37581518">[-]</label><label class="expand" for="c-37581518">[1 more]</label></div><br/><div class="children"><div class="content">Hi, this is the article author here. Thanks for the feedback! I&#x27;ve written this article 3.5 years ago, and it could definitely deserve a shake-up. I agree this should be cleared up a bit.</div><br/></div></div><div id="37580628" class="c"><input type="checkbox" id="c-37580628" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#37579004">parent</a><span>|</span><a href="#37581518">prev</a><span>|</span><a href="#37581569">next</a><span>|</span><label class="collapse" for="c-37580628">[-]</label><label class="expand" for="c-37580628">[1 more]</label></div><br/><div class="children"><div class="content">This is sadly commonplace in tech blogs: rather than taking a great opportunity to hook the reader, the writer will drop a vocab term in bold and move on.</div><br/></div></div></div></div><div id="37581569" class="c"><input type="checkbox" id="c-37581569" checked=""/><div class="controls bullet"><span class="by">estiller</span><span>|</span><a href="#37579004">prev</a><span>|</span><a href="#37581844">next</a><span>|</span><label class="collapse" for="c-37581569">[-]</label><label class="expand" for="c-37581569">[1 more]</label></div><br/><div class="children"><div class="content">Hi everyone, this is the article author here. I was genuinely surprised to see the article pop up here 3.5 years after I wrote it.<p>Thank you for all the feedback! Given the advances in the past few years in this area, this article could use a serious update. A comparison to NATS and Pulsar is warranted, along with some extra explanations for some of the technical terms in the article.<p>I&#x27;ll carefully review the feedback here and try to make an update at some point soon.</div><br/></div></div><div id="37581844" class="c"><input type="checkbox" id="c-37581844" checked=""/><div class="controls bullet"><span class="by">opentokix</span><span>|</span><a href="#37581569">prev</a><span>|</span><a href="#37576564">next</a><span>|</span><label class="collapse" for="c-37581844">[-]</label><label class="expand" for="c-37581844">[1 more]</label></div><br/><div class="children"><div class="content">Wow, this is the type of trash one can expect from someone calling themselves &quot;Architect&quot;</div><br/></div></div><div id="37576564" class="c"><input type="checkbox" id="c-37576564" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37581844">prev</a><span>|</span><a href="#37576233">next</a><span>|</span><label class="collapse" for="c-37576564">[-]</label><label class="expand" for="c-37576564">[11 more]</label></div><br/><div class="children"><div class="content">I’m personally a fan of Kafka. I think the design of persisting the messages, and tracking offsets for progress instead of message acknowledgments is a much cleaner and more versatile design.<p>You can get all the same advantages of message acknowledgments, but now you can also replay queues, let different applications use the messages (handy for cross cutting event&#x2F;notification systems) and you get better scaling properties-which doesn’t hurt at the small scale, and provides further scaling when you need it.</div><br/><div id="37576743" class="c"><input type="checkbox" id="c-37576743" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37576564">parent</a><span>|</span><a href="#37577065">next</a><span>|</span><label class="collapse" for="c-37576743">[-]</label><label class="expand" for="c-37576743">[5 more]</label></div><br/><div class="children"><div class="content">&gt; You can get all the same advantages of message acknowledgments, but now you can also replay queues<p>with rmq you can reject&#x2F;nack a message and have it put back on the queue. rmq is not well suited for long term historical retention inside queues a-la kafka&#x27;s logs but it is possible to do.<p>&gt; let different applications use the messages (handy for cross cutting event&#x2F;notification systems)<p>rmq also does a publish once and fanout to multiple queues to support this. data is replicated so that could be a deal breaker, but it is possible.<p>how often have you had to diagnose a stuck consumer or some other kind of offset glitch where a consumer is unable to resume where it left off?<p>not knocking kafka here but I do think it is a tool you should reach for when you need to solve a very hyper focused problem, while rabbit is a tool more suited to most cases where queuing is required. kafka is a code smell in a lot of organizations from my experience - most do not need it.</div><br/><div id="37576824" class="c"><input type="checkbox" id="c-37576824" checked=""/><div class="controls bullet"><span class="by">raducu</span><span>|</span><a href="#37576564">root</a><span>|</span><a href="#37576743">parent</a><span>|</span><a href="#37577065">next</a><span>|</span><label class="collapse" for="c-37576824">[-]</label><label class="expand" for="c-37576824">[4 more]</label></div><br/><div class="children"><div class="content">&gt; afka is a code smell in a lot of organizations from my experience - most do not need it.<p>Kafka is really nice if you don&#x27;t care that much about latency during peak load and you don&#x27;t have absurd processing times for messages.</div><br/><div id="37578587" class="c"><input type="checkbox" id="c-37578587" checked=""/><div class="controls bullet"><span class="by">ceencee</span><span>|</span><a href="#37576564">root</a><span>|</span><a href="#37576824">parent</a><span>|</span><a href="#37578684">next</a><span>|</span><label class="collapse" for="c-37578587">[-]</label><label class="expand" for="c-37578587">[1 more]</label></div><br/><div class="children"><div class="content">Kafka can sustain sub 20ms at millions or even billions per second scale. Processing time delays is bad consumer code and partition design smell. Aka , your consumer shouldnt depend on a slower resource within an ordering domain. This can also be mitigated with an async consumer</div><br/></div></div><div id="37578684" class="c"><input type="checkbox" id="c-37578684" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37576564">root</a><span>|</span><a href="#37576824">parent</a><span>|</span><a href="#37578587">prev</a><span>|</span><a href="#37579246">next</a><span>|</span><label class="collapse" for="c-37578684">[-]</label><label class="expand" for="c-37578684">[1 more]</label></div><br/><div class="children"><div class="content">These sound like consumer issues to me.<p>Kafka had been extremely reliable with latency, even under load in my experience.<p>If you’ve got badly lagging consumers that are trying to read from very old points in the topic while everyone else is at the head, you’ll definitely see some increased resource usage, but again, that’s mostly a consumer issue, and I’ve need seen performance degrades that much.</div><br/></div></div><div id="37579246" class="c"><input type="checkbox" id="c-37579246" checked=""/><div class="controls bullet"><span class="by">monksy</span><span>|</span><a href="#37576564">root</a><span>|</span><a href="#37576824">parent</a><span>|</span><a href="#37578684">prev</a><span>|</span><a href="#37577065">next</a><span>|</span><label class="collapse" for="c-37579246">[-]</label><label class="expand" for="c-37579246">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re concerned about latency you might want to consider zeromq. Stream processing doesn&#x27;t really have a time expectation to it.</div><br/></div></div></div></div></div></div><div id="37577065" class="c"><input type="checkbox" id="c-37577065" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#37576564">parent</a><span>|</span><a href="#37576743">prev</a><span>|</span><a href="#37576787">next</a><span>|</span><label class="collapse" for="c-37577065">[-]</label><label class="expand" for="c-37577065">[4 more]</label></div><br/><div class="children"><div class="content">&gt; now you can also replay queues<p>yeahnah, that leads to people treating queues like databases (I&#x27;m looking at you new york times, you know what you did wrong)<p>its either a queue, or a pubsub, either way its ephemeral. Once its gone, it should stay gone. thats what database, object stores or filesystems are for.<p>Kafka is a beast, has lots of bells and whistles and grinds to a halt when you look at it funny. Yes, it can scale, but also it can just sulk.<p>rabbit has it&#x27;s own set of problems, and frankly it&#x27;s probably not choose either anymore.</div><br/><div id="37581084" class="c"><input type="checkbox" id="c-37581084" checked=""/><div class="controls bullet"><span class="by">serallak</span><span>|</span><a href="#37576564">root</a><span>|</span><a href="#37577065">parent</a><span>|</span><a href="#37577565">next</a><span>|</span><label class="collapse" for="c-37581084">[-]</label><label class="expand" for="c-37581084">[1 more]</label></div><br/><div class="children"><div class="content">What would you choose today ?</div><br/></div></div><div id="37577565" class="c"><input type="checkbox" id="c-37577565" checked=""/><div class="controls bullet"><span class="by">officialchicken</span><span>|</span><a href="#37576564">root</a><span>|</span><a href="#37577065">parent</a><span>|</span><a href="#37581084">prev</a><span>|</span><a href="#37576787">next</a><span>|</span><label class="collapse" for="c-37577565">[-]</label><label class="expand" for="c-37577565">[2 more]</label></div><br/><div class="children"><div class="content">&gt; (I&#x27;m looking at you new york times, you know what you did wrong)<p>You&#x27;re going to have to be a tiny bit more specific here. NYT is THE factory of wrongness for sure. In every dimension. Are we talking &quot;yellow cake&quot; wrong, or somewhere else on the severity of f&#x27;up scale...</div><br/><div id="37581179" class="c"><input type="checkbox" id="c-37581179" checked=""/><div class="controls bullet"><span class="by">joking</span><span>|</span><a href="#37576564">root</a><span>|</span><a href="#37577565">parent</a><span>|</span><a href="#37576787">next</a><span>|</span><label class="collapse" for="c-37581179">[-]</label><label class="expand" for="c-37581179">[1 more]</label></div><br/><div class="children"><div class="content">They wrote a post on how they disabled the deletion and compaction of the data in Kafka and used it as the source of truth.</div><br/></div></div></div></div></div></div><div id="37576787" class="c"><input type="checkbox" id="c-37576787" checked=""/><div class="controls bullet"><span class="by">raducu</span><span>|</span><a href="#37576564">parent</a><span>|</span><a href="#37577065">prev</a><span>|</span><a href="#37576233">next</a><span>|</span><label class="collapse" for="c-37576787">[-]</label><label class="expand" for="c-37576787">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can get all the same advantages of message acknowledgments.<p>Maybe 95% of cases, but not all.<p>Long message processing time really kills kafka in a way it doesn&#x27;t kill Rabbit Mq. Combine it with inherent read paralelism being limited to the number of partitions. Add in high variability of message rates and bingo, that&#x27;s like 90% of the issues I&#x27;ve had with kafka over the years.</div><br/></div></div></div></div><div id="37576233" class="c"><input type="checkbox" id="c-37576233" checked=""/><div class="controls bullet"><span class="by">bicijay</span><span>|</span><a href="#37576564">prev</a><span>|</span><a href="#37579249">next</a><span>|</span><label class="collapse" for="c-37576233">[-]</label><label class="expand" for="c-37576233">[3 more]</label></div><br/><div class="children"><div class="content">Message ordering is an illusion. Unless you track&#x2F;store the messages on the client and are willing to deal with stuck queues due to failures in one &quot;poisoned&quot; message.</div><br/><div id="37576721" class="c"><input type="checkbox" id="c-37576721" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#37576233">parent</a><span>|</span><a href="#37577138">next</a><span>|</span><label class="collapse" for="c-37576721">[-]</label><label class="expand" for="c-37576721">[1 more]</label></div><br/><div class="children"><div class="content">There are different kinds of order. Yes, there’s no total order in a distributed system, but you can have certain partial order guarantees. It’s nice if something is added before it’s updated, for instance.</div><br/></div></div><div id="37577138" class="c"><input type="checkbox" id="c-37577138" checked=""/><div class="controls bullet"><span class="by">rafaelturk</span><span>|</span><a href="#37576233">parent</a><span>|</span><a href="#37576721">prev</a><span>|</span><a href="#37579249">next</a><span>|</span><label class="collapse" for="c-37577138">[-]</label><label class="expand" for="c-37577138">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t agree more, messages should be completely agnostic from one-another. If you have a decent event-driven architecture, you don&#x27;t need kafka. and you can be happy with Redis or RabbitMQ</div><br/></div></div></div></div><div id="37576786" class="c"><input type="checkbox" id="c-37576786" checked=""/><div class="controls bullet"><span class="by">purpleblue</span><span>|</span><a href="#37579249">prev</a><span>|</span><a href="#37576108">next</a><span>|</span><label class="collapse" for="c-37576786">[-]</label><label class="expand" for="c-37576786">[1 more]</label></div><br/><div class="children"><div class="content">If someone is asking if they should decide between RabbitMQ vs Kafka, they should 100% use RabbitMQ. It means they have no idea what they&#x27;re dealing with, the architectural differences, and the investment that the company needs in order to use Kafka.<p>So use RabbitMQ.</div><br/></div></div><div id="37576108" class="c"><input type="checkbox" id="c-37576108" checked=""/><div class="controls bullet"><span class="by">BWStearns</span><span>|</span><a href="#37576786">prev</a><span>|</span><a href="#37576067">next</a><span>|</span><label class="collapse" for="c-37576108">[-]</label><label class="expand" for="c-37576108">[4 more]</label></div><br/><div class="children"><div class="content">My comment is mostly about part 2 of this post, but wrt message ordering being a kafka &quot;win&quot; I&#x27;d raise the point that in the actual use case of &quot;a consumer fails in some way to process the message&quot; you can still end up with out of order processing of the consumer&#x27;s input since you might want to dump them into a DLQ or something. The fact that the message isn&#x27;t reappended to the topic by default for processing is kind of an academic point no?<p>Unrelatedly, I&#x27;ve been looking at Pulsar lately. Anyone have experience with Pulsar and either RMQ&#x2F;Kafka want to throw out some opinions from having tried both?</div><br/><div id="37578467" class="c"><input type="checkbox" id="c-37578467" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#37576108">parent</a><span>|</span><a href="#37576067">next</a><span>|</span><label class="collapse" for="c-37578467">[-]</label><label class="expand" for="c-37578467">[3 more]</label></div><br/><div class="children"><div class="content">Pulsar can have both MQ semantics and pub&#x2F;sub semantics. In pub&#x2F;sub it&#x27;s sorta like &quot;Kafka with all bits people found it necessary to build later already built in&quot;, e.g., a proxy, schema registry, connectors, replication,  tiered storage, all out of the box.<p>It also has lightweight streaming functions built-in, but they operate per record, so good for lightweight transforms&#x2F;routing, not for stream aggregations etc.<p>It has more moving parts also, brokers are decoupled from storage, which is handled by BookKeeper, and replication between two clusters requires a ZooKeeper that both clusters can access, in addition to the ZK used by the brokers and bookies.<p>And it&#x27;s a reasonably new project, so last time I looked into it, some of the documentation was incorrect, especially around managing bookies.</div><br/><div id="37579303" class="c"><input type="checkbox" id="c-37579303" checked=""/><div class="controls bullet"><span class="by">relay23</span><span>|</span><a href="#37576108">root</a><span>|</span><a href="#37578467">parent</a><span>|</span><a href="#37576067">next</a><span>|</span><label class="collapse" for="c-37579303">[-]</label><label class="expand" for="c-37579303">[2 more]</label></div><br/><div class="children"><div class="content">Massive and complex platform.. at a certain point why not just run 2 different platforms that are best of breed for each.</div><br/><div id="37580945" class="c"><input type="checkbox" id="c-37580945" checked=""/><div class="controls bullet"><span class="by">olavgg</span><span>|</span><a href="#37576108">root</a><span>|</span><a href="#37579303">parent</a><span>|</span><a href="#37576067">next</a><span>|</span><label class="collapse" for="c-37580945">[-]</label><label class="expand" for="c-37580945">[1 more]</label></div><br/><div class="children"><div class="content">You can just run Pulsar standalone which is super-simple, it is a great start and scales just fine for one machine. Once you outscale one machine, you can refactor Pulsar into a distributed setup. The advantage is that everything is still familiar.</div><br/></div></div></div></div></div></div></div></div><div id="37576067" class="c"><input type="checkbox" id="c-37576067" checked=""/><div class="controls bullet"><span class="by">supermatt</span><span>|</span><a href="#37576108">prev</a><span>|</span><a href="#37580993">next</a><span>|</span><label class="collapse" for="c-37576067">[-]</label><label class="expand" for="c-37576067">[1 more]</label></div><br/><div class="children"><div class="content">The same MQ patterns as mentioned in the article (exactly once, consumer groups) can also be done in kafka, contrary to what the article suggests.</div><br/></div></div><div id="37580993" class="c"><input type="checkbox" id="c-37580993" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#37576067">prev</a><span>|</span><a href="#37580057">next</a><span>|</span><label class="collapse" for="c-37580993">[-]</label><label class="expand" for="c-37580993">[1 more]</label></div><br/><div class="children"><div class="content">seems like there is a missing option?<p>- Message retention (like Kafka)<p>- Easy consumer scale out (like RabbitMQ)<p>- No particular ordering guarantees (like RabbitMQ)</div><br/></div></div><div id="37579141" class="c"><input type="checkbox" id="c-37579141" checked=""/><div class="controls bullet"><span class="by">cma256</span><span>|</span><a href="#37580057">prev</a><span>|</span><a href="#37577051">next</a><span>|</span><label class="collapse" for="c-37579141">[-]</label><label class="expand" for="c-37579141">[1 more]</label></div><br/><div class="children"><div class="content">The great thing about Kafka is the ability to batch operations.  Collect a set of messages in memory and, when its time to commit, submit a bulk operation.  If something fails you just rebuild the buffer from the last committed offset.  Pretty neat piece of technology.</div><br/></div></div><div id="37577051" class="c"><input type="checkbox" id="c-37577051" checked=""/><div class="controls bullet"><span class="by">postalrat</span><span>|</span><a href="#37579141">prev</a><span>|</span><a href="#37576096">next</a><span>|</span><label class="collapse" for="c-37577051">[-]</label><label class="expand" for="c-37577051">[6 more]</label></div><br/><div class="children"><div class="content">Redis isn&#x27;t an option?</div><br/><div id="37580975" class="c"><input type="checkbox" id="c-37580975" checked=""/><div class="controls bullet"><span class="by">akvadrako</span><span>|</span><a href="#37577051">parent</a><span>|</span><a href="#37579031">next</a><span>|</span><label class="collapse" for="c-37580975">[-]</label><label class="expand" for="c-37580975">[1 more]</label></div><br/><div class="children"><div class="content">Or postgres. If you are under 1000 messages a second it functions well as a transactional queue.</div><br/></div></div><div id="37579031" class="c"><input type="checkbox" id="c-37579031" checked=""/><div class="controls bullet"><span class="by">blindriver</span><span>|</span><a href="#37577051">parent</a><span>|</span><a href="#37580975">prev</a><span>|</span><a href="#37577134">next</a><span>|</span><label class="collapse" for="c-37579031">[-]</label><label class="expand" for="c-37579031">[2 more]</label></div><br/><div class="children"><div class="content">Redis is a cache, it&#x27;s not a queue.<p>Can you do something similar? I guess, just like you can use a highlighter to paint your house. But the semantics are not correct.</div><br/><div id="37579311" class="c"><input type="checkbox" id="c-37579311" checked=""/><div class="controls bullet"><span class="by">relay23</span><span>|</span><a href="#37577051">root</a><span>|</span><a href="#37579031">parent</a><span>|</span><a href="#37577134">next</a><span>|</span><label class="collapse" for="c-37579311">[-]</label><label class="expand" for="c-37579311">[1 more]</label></div><br/><div class="children"><div class="content">There is Redis Streams, but certainly not without it&#x27;s problems. Super obscure, not a lot of client support.</div><br/></div></div></div></div><div id="37577134" class="c"><input type="checkbox" id="c-37577134" checked=""/><div class="controls bullet"><span class="by">noitpmeder</span><span>|</span><a href="#37577051">parent</a><span>|</span><a href="#37579031">prev</a><span>|</span><a href="#37577118">next</a><span>|</span><label class="collapse" for="c-37577134">[-]</label><label class="expand" for="c-37577134">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d also like someone with experience to contrast redis for these use cases.</div><br/></div></div><div id="37577118" class="c"><input type="checkbox" id="c-37577118" checked=""/><div class="controls bullet"><span class="by">rafaelturk</span><span>|</span><a href="#37577051">parent</a><span>|</span><a href="#37577134">prev</a><span>|</span><a href="#37576096">next</a><span>|</span><label class="collapse" for="c-37577118">[-]</label><label class="expand" for="c-37577118">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Don&#x27;t why is not mentioned in the article, maybe because is more barebones.</div><br/></div></div></div></div><div id="37576096" class="c"><input type="checkbox" id="c-37576096" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#37577051">prev</a><span>|</span><a href="#37575974">next</a><span>|</span><label class="collapse" for="c-37576096">[-]</label><label class="expand" for="c-37576096">[7 more]</label></div><br/><div class="children"><div class="content">If you use Confluent Kafka, the billing is pretty high.  About 4 years ago it was much cheaper, but then they completely revamped the pricing to something ridiculous.  I found that switching to Google Pub&#x2F;Sub, at least if it meets your needs, is cheaper.</div><br/><div id="37576264" class="c"><input type="checkbox" id="c-37576264" checked=""/><div class="controls bullet"><span class="by">AndyPa32</span><span>|</span><a href="#37576096">parent</a><span>|</span><a href="#37578043">next</a><span>|</span><label class="collapse" for="c-37576264">[-]</label><label class="expand" for="c-37576264">[3 more]</label></div><br/><div class="children"><div class="content">Yes, I can confirm that. Confluent is the most expensive part of our current infrastructure.</div><br/><div id="37576527" class="c"><input type="checkbox" id="c-37576527" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#37576096">root</a><span>|</span><a href="#37576264">parent</a><span>|</span><a href="#37579336">next</a><span>|</span><label class="collapse" for="c-37576527">[-]</label><label class="expand" for="c-37576527">[1 more]</label></div><br/><div class="children"><div class="content">Can you switch away from it?  Or do you need its advanced features?</div><br/></div></div><div id="37579336" class="c"><input type="checkbox" id="c-37579336" checked=""/><div class="controls bullet"><span class="by">relay23</span><span>|</span><a href="#37576096">root</a><span>|</span><a href="#37576264">parent</a><span>|</span><a href="#37576527">prev</a><span>|</span><a href="#37578043">next</a><span>|</span><label class="collapse" for="c-37579336">[-]</label><label class="expand" for="c-37579336">[1 more]</label></div><br/><div class="children"><div class="content">Sounds about right.</div><br/></div></div></div></div><div id="37578043" class="c"><input type="checkbox" id="c-37578043" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#37576096">parent</a><span>|</span><a href="#37576264">prev</a><span>|</span><a href="#37579323">next</a><span>|</span><label class="collapse" for="c-37578043">[-]</label><label class="expand" for="c-37578043">[2 more]</label></div><br/><div class="children"><div class="content">I see they offer Kafka&#x27;s exactly-once delivery: <a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;data-analytics&#x2F;cloud-pub-sub-exactly-once-delivery-feature-is-now-ga" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;data-analytics&#x2F;cloud-...</a></div><br/><div id="37579334" class="c"><input type="checkbox" id="c-37579334" checked=""/><div class="controls bullet"><span class="by">relay23</span><span>|</span><a href="#37576096">root</a><span>|</span><a href="#37578043">parent</a><span>|</span><a href="#37579323">next</a><span>|</span><label class="collapse" for="c-37579334">[-]</label><label class="expand" for="c-37579334">[1 more]</label></div><br/><div class="children"><div class="content">Kafka doesn&#x27;t guarantee exactly once delivery at all, unless you&#x27;re using Kafka Streams and even then your final output topic still won&#x27;t get exactly once, the consumer group protocol doesn&#x27;t allow for it.</div><br/></div></div></div></div><div id="37579323" class="c"><input type="checkbox" id="c-37579323" checked=""/><div class="controls bullet"><span class="by">relay23</span><span>|</span><a href="#37576096">parent</a><span>|</span><a href="#37578043">prev</a><span>|</span><a href="#37575974">next</a><span>|</span><label class="collapse" for="c-37579323">[-]</label><label class="expand" for="c-37579323">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s cheaper until you get to a sizeable workload, and the P90+ latency is ridiculous.. the kafka api is weak and when you&#x27;re not using kafka api you&#x27;re limited on integration tools unless you want to be super locked in to GCP.</div><br/></div></div></div></div><div id="37579368" class="c"><input type="checkbox" id="c-37579368" checked=""/><div class="controls bullet"><span class="by">jonstewart</span><span>|</span><a href="#37575974">prev</a><span>|</span><label class="collapse" for="c-37579368">[-]</label><label class="expand" for="c-37579368">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure there remain good use cases for message buses that you have to run yourself, where there really are millions of messages that can&#x27;t be batched up and need real-time and whatnot. But you can get pretty far with:<p>1. Write a bunch of records to an S3 object.
2. Trigger a lambda to process — infinite scale out!<p>and if a queue really is needed due to constrained consumers, then:<p>1. Write a bunch of records to an S3 object.
2. The lambda trigger puts a message into an SQS queue with the S3 object&#x27;s URI.
3. An auto-scaling group gets the message off the queue and processes the data in the object.<p>If ordering&#x27;s important, then the SQS queue can be made FIFO. That has pretty low numbers in messages&#x2F;second, but since records are being batched into S3 objects you can still have fairly high throughput.<p>It used to be that the elegance of queues for such systems would tempt developers into the operational slough of despond that is running these types of systems. Again, I&#x27;m sure it&#x27;s warranted for some applications, but S3, Lambda, and SQS as above work nicely together.</div><br/></div></div></div></div></div></div></div></body></html>