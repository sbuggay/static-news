<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715331711272" as="style"/><link rel="stylesheet" href="styles.css?v=1715331711272"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/tembo-io/pgmq">Show HN: An SQS Alternative on Postgres</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>chuckhend</span> | <span>94 comments</span></div><br/><div><div id="40316776" class="c"><input type="checkbox" id="c-40316776" checked=""/><div class="controls bullet"><span class="by">anentropic</span><span>|</span><a href="#40308926">next</a><span>|</span><label class="collapse" for="c-40316776">[-]</label><label class="expand" for="c-40316776">[1 more]</label></div><br/><div class="children"><div class="content">One of the appeals of doing MQ in Postgres is being able to submit events atomically in same db transaction as the stuff that raised the event<p>Looking at <a href="https:&#x2F;&#x2F;github.com&#x2F;tembo-io&#x2F;pgmq&#x2F;tree&#x2F;main&#x2F;tembo-pgmq-python">https:&#x2F;&#x2F;github.com&#x2F;tembo-io&#x2F;pgmq&#x2F;tree&#x2F;main&#x2F;tembo-pgmq-python</a> ...how do I integrate the queue ops with my other db access code?<p>Or is it better not to use the client lib in that scenario and use the SQL functions directly?
<a href="https:&#x2F;&#x2F;github.com&#x2F;tembo-io&#x2F;pgmq?tab=readme-ov-file#send-two-messages">https:&#x2F;&#x2F;github.com&#x2F;tembo-io&#x2F;pgmq?tab=readme-ov-file#send-two...</a></div><br/></div></div><div id="40308926" class="c"><input type="checkbox" id="c-40308926" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#40316776">prev</a><span>|</span><a href="#40315765">next</a><span>|</span><label class="collapse" for="c-40308926">[-]</label><label class="expand" for="c-40308926">[21 more]</label></div><br/><div class="children"><div class="content">&gt; Guaranteed &quot;exactly once&quot; delivery of messages to a consumer within a visibility timeout<p>That&#x27;s not going to be true. It might be true when things are running well, but when it fails, it&#x27;ll either be at most once or at least once. You don&#x27;t build for the steady state, you build against the failure mode. That&#x27;s an important deciding factor in whether you choose a system: you can accept duplicates gracefully or you can accept some amount of data loss.<p>Without reviewing all of the code, it&#x27;s not possible to say what this actually is, but since it seems like it&#x27;s up to the implementor to set up replication, I suspect this is an at-most-once queue (if the client receives a response before the server has replicated the data and the server is destroyed, the data is lost). But depending on the diligence of the developer, it could be that this provides no real guarantees (0-N deliveries).</div><br/><div id="40309227" class="c"><input type="checkbox" id="c-40309227" checked=""/><div class="controls bullet"><span class="by">cjen</span><span>|</span><a href="#40308926">parent</a><span>|</span><a href="#40312136">next</a><span>|</span><label class="collapse" for="c-40309227">[-]</label><label class="expand" for="c-40309227">[3 more]</label></div><br/><div class="children"><div class="content">It will be true because of the &quot;within a visibility timeout&quot; right? Of course that makes the claim way less interesting.<p>I took a peek at the code and it looks like their visibility timeout is pretty much a lock on a message. So it&#x27;s not exactly once for any meaningful definition, but it does prevent the same message from being consumed multiple times within the visibility timeout.</div><br/><div id="40313151" class="c"><input type="checkbox" id="c-40313151" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40309227">parent</a><span>|</span><a href="#40312136">next</a><span>|</span><label class="collapse" for="c-40313151">[-]</label><label class="expand" for="c-40313151">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it does prevent the same message from being consumed multiple times within the visibility timeout.<p>... When there is no failure of the underlying system. The expectation of any queue is that messages are only delivered once. But that&#x27;s not what&#x27;s interesting: what matters is what happens when there&#x27;s a system failure: either the message gets delivered more than once, the message gets delivered zero times, or a little of column A and a little of column B (which is the worst of both worlds and is a bug). If you have one queue node, it can fail and lose your data. If you have multiple queue nodes, you can have a network partition. In all cases, it&#x27;s possible to not know whether the message was processed or not <i>at some point</i></div><br/><div id="40313493" class="c"><input type="checkbox" id="c-40313493" checked=""/><div class="controls bullet"><span class="by">thethimble</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40313151">parent</a><span>|</span><a href="#40312136">next</a><span>|</span><label class="collapse" for="c-40313493">[-]</label><label class="expand" for="c-40313493">[1 more]</label></div><br/><div class="children"><div class="content">The Two Generals Problem is a great thought experiment that describes how distributed consensus is impossible when communication between nodes has the possibility of failing.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two_Generals%27_Problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two_Generals%27_Problem</a></div><br/></div></div></div></div></div></div><div id="40312136" class="c"><input type="checkbox" id="c-40312136" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40308926">parent</a><span>|</span><a href="#40309227">prev</a><span>|</span><a href="#40309101">next</a><span>|</span><label class="collapse" for="c-40312136">[-]</label><label class="expand" for="c-40312136">[7 more]</label></div><br/><div class="children"><div class="content">If the message never reaches the queue (network error, database is down, app is down, etc), then yes that is a 0 delivery scenario. Once the message reaches the queue though, it is guaranteed that only a single consumer can read the message for the duration of the visibility timeout. FOR UPDATE guarantees only a single consumer can read the record, and the visibility timeout means we don&#x27;t have to hold a lock. After that visibility timeout expires, it is an at-least-once scenario. Any suggestion for how we could change the verbiage on the readme to make that more clear?</div><br/><div id="40312194" class="c"><input type="checkbox" id="c-40312194" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40312136">parent</a><span>|</span><a href="#40315696">next</a><span>|</span><label class="collapse" for="c-40312194">[-]</label><label class="expand" for="c-40312194">[2 more]</label></div><br/><div class="children"><div class="content">You are talking about distributed systems, nobody expects to read &quot;exactly once&quot; delivery. If I read that on the docs, I consider that a huge red flag.<p>And the fact is that what you describe is a performance optimization, I still have to write my code so that it is idempotent, so that optimization does not affect me in any other way, because exactly once is not a thing.<p>All of this to say, I&#x27;m not even sure it&#x27;s worth mentioning?</div><br/><div id="40316485" class="c"><input type="checkbox" id="c-40316485" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40312194">parent</a><span>|</span><a href="#40315696">next</a><span>|</span><label class="collapse" for="c-40316485">[-]</label><label class="expand" for="c-40316485">[1 more]</label></div><br/><div class="children"><div class="content">You should let the Apache Flink team know, they mention exactly-once processing on their home page (under &quot;correctness guarantees&quot;) and in their list of features.<p>[0] <a href="https:&#x2F;&#x2F;flink.apache.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flink.apache.org&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;flink.apache.org&#x2F;what-is-flink&#x2F;flink-applications&#x2F;#building-blocks-for-streaming-applications" rel="nofollow">https:&#x2F;&#x2F;flink.apache.org&#x2F;what-is-flink&#x2F;flink-applications&#x2F;#b...</a></div><br/></div></div></div></div><div id="40315696" class="c"><input type="checkbox" id="c-40315696" checked=""/><div class="controls bullet"><span class="by">tyre</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40312136">parent</a><span>|</span><a href="#40312194">prev</a><span>|</span><a href="#40313231">next</a><span>|</span><label class="collapse" for="c-40315696">[-]</label><label class="expand" for="c-40315696">[1 more]</label></div><br/><div class="children"><div class="content">&gt; FOR UPDATE guarantees only a single consumer can read the record, and the visibility timeout means we don&#x27;t have to hold a lock<p>This is not always true!<p>Postgres does snapshot isolation within transactions that begins on the first statement within a transaction. This means that some isolation levels like REPEATABLE READ can feel misleadingly âsaferâ but actually break your guarantee. From the docs:<p>&gt; Note also that if one is relying on explicit locking to prevent concurrent changes, one should either use Read Committed mode, or in Repeatable Read mode be careful to obtain locks before performing queries. A lock obtained by a repeatable read transaction guarantees that no other transactions modifying the table are still running, but if the snapshot seen by the transaction predates obtaining the lock, it might predate some now-committed changes in the table. A repeatable read transaction&#x27;s snapshot is actually frozen at the start of its first query or data-modification command (SELECT, INSERT, UPDATE, DELETE, or MERGE), so it is possible to obtain locks explicitly before the snapshot is frozen.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;applevel-consistency.html#NON-SERIALIZABLE-CONSISTENCY" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;applevel-consistency...</a></div><br/></div></div><div id="40313231" class="c"><input type="checkbox" id="c-40313231" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40312136">parent</a><span>|</span><a href="#40315696">prev</a><span>|</span><a href="#40313138">next</a><span>|</span><label class="collapse" for="c-40313231">[-]</label><label class="expand" for="c-40313231">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Once the message reaches the queue though, it is guaranteed that only a single consumer can read the message for the duration of the visibility timeout.<p>But does the message get persisted and replicated before <i>any</i> consumer gets the message (and after the submission of the message is acked)? If it&#x27;s a single node, the answer is simply &quot;no&quot;: the hard drive can melt before anyone reads the message and the data is lost. It&#x27;s not &quot;exactly once&quot; if nobody gets the message.<p>And if the message is persisted and replicated, but there&#x27;s subsequently a network partition, do multiple consumers get to read the message? What happens if writing the confirmation from the consumer fails, does the visibility timeout still expire?<p>&gt; After that visibility timeout expires, it is an at-least-once scenario.<p>That&#x27;s not really what &quot;at least once&quot; refers to. That&#x27;s normal operation, and sets the normal expectations of how the system should work under normal conditions. What matters is what happens under <i>abnormal</i> conditions.</div><br/></div></div><div id="40313138" class="c"><input type="checkbox" id="c-40313138" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40312136">parent</a><span>|</span><a href="#40313231">prev</a><span>|</span><a href="#40309101">next</a><span>|</span><label class="collapse" for="c-40313138">[-]</label><label class="expand" for="c-40313138">[2 more]</label></div><br/><div class="children"><div class="content">As u&#x2F;Fire-Dragon-DoL says, you can have an exactly-once guarantee within this small system, but you can&#x27;t extend it beyond that.  And even then, I don&#x27;t think you can have it.  If the DB is full, you can&#x27;t get new messages and they might get dropped, and if the threads picking up events get stuck or die then messages might go unprocessed and once again the guarantee is violated.  And if processing an event requires having external side-effects that cannot be rolled back then you&#x27;re violating the at-most-once part of the exactly-once guarantee.</div><br/><div id="40313424" class="c"><input type="checkbox" id="c-40313424" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40313138">parent</a><span>|</span><a href="#40309101">next</a><span>|</span><label class="collapse" for="c-40313424">[-]</label><label class="expand" for="c-40313424">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can have an exactly-once guarantee within this small system<p>It&#x27;s actually harder to do this in a small system. I submit a message to the queue, and it&#x27;s saved and acknowledged. Then the hard drive fails before the message is requested by a consumer. It&#x27;s gone. Zero deliveries, or &quot;at most once&quot;.<p>&gt; If the DB is full, you can&#x27;t get new messages and they might get dropped<p>In this case, I&#x27;d expect the producer to receive a failure, so technically there&#x27;s nothing to deliver.<p>&gt; if the threads picking up events get stuck or die<p>While this obviously affects delivery, this is a concurrency bug and not a fundamental design choice. The failures folks usually refer to in this context are ones that are outside of your control, like hardware failures or power outages.</div><br/></div></div></div></div></div></div><div id="40309101" class="c"><input type="checkbox" id="c-40309101" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#40308926">parent</a><span>|</span><a href="#40312136">prev</a><span>|</span><a href="#40309615">next</a><span>|</span><label class="collapse" for="c-40309101">[-]</label><label class="expand" for="c-40309101">[4 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s not going to be true. It might be true when things are running well, but when it fails, it&#x27;ll either be at most once or at least once.<p>Silly question as somebody not very deep in the details on this.<p>It&#x27;s not easy to make distributed systems idempotent across the board (POST vs PUT, etc.)<p>Distributed rollbacks are also hard once you reach interacting with 3rd party APIs, databases, cache, etc.<p>What is the trick in your &quot;on message received handler&quot; from the queue to achieve &quot;exactly once&quot;? Some kind of &quot;message hash ID&quot; and then you check in Redis if it has already been processed either fully successfully, partially, or with failures? That has drawbacks&#x2F;problems too, no? Is it an impossible problem?</div><br/><div id="40309863" class="c"><input type="checkbox" id="c-40309863" checked=""/><div class="controls bullet"><span class="by">samtheprogram</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40309101">parent</a><span>|</span><a href="#40313334">next</a><span>|</span><label class="collapse" for="c-40309863">[-]</label><label class="expand" for="c-40309863">[2 more]</label></div><br/><div class="children"><div class="content">You donât achieve exactly once at the protocol&#x2F;queue level, but at the service&#x2F;consumer level. This is why SQS guarantees at-least-once.<p>Itâs generally what you described, but the term Iâve seen is ânonceâ which is essentially an ID on the message thatâs unique, and you can check against an in-memory data store or similar to see if youâve already processed the message, and simply return &#x2F; stop processing the message&#x2F;job if so.</div><br/><div id="40310008" class="c"><input type="checkbox" id="c-40310008" checked=""/><div class="controls bullet"><span class="by">mcqueenjordan</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40309863">parent</a><span>|</span><a href="#40313334">next</a><span>|</span><label class="collapse" for="c-40310008">[-]</label><label class="expand" for="c-40310008">[1 more]</label></div><br/><div class="children"><div class="content">And just to add a small clarification since I had to double take: this isn&#x27;t exactly-once delivery (which isn&#x27;t possible), this is exactly-once processing. But even exactly-once processing generally has issues, so it&#x27;s better to assume at least once processing as the thing to design for and try to make everything within your processing ~idempotent.</div><br/></div></div></div></div><div id="40313334" class="c"><input type="checkbox" id="c-40313334" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40309101">parent</a><span>|</span><a href="#40309863">prev</a><span>|</span><a href="#40309615">next</a><span>|</span><label class="collapse" for="c-40313334">[-]</label><label class="expand" for="c-40313334">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What is the trick in your &quot;on message received handler&quot; from the queue to achieve &quot;exactly once&quot;?<p>There&#x27;s no trick. The problem isn&#x27;t &quot;how to build a robust enough system&quot; it&#x27;s &quot;how can you possibly know whether the message was successfully processed or not&quot;. If you have one node that stores data for the queue, loss of that node means the data is gone. You don&#x27;t know you don&#x27;t have it. If you have multiple nodes running the queue and they stop talking to each other, how do you know whether one of the other nodes already allowed someone to process a particular message (e.g., in the face of a network partition), or <i>didn&#x27;t</i> let someone else process the message (e.g., that node experienced hardware failure).<p>At some point, you find yourself staring down the Byzantine generals problem. You can make systems pretty robust (and some folks have made extremely robust systems), but there&#x27;s not really a completely watertight solution. And in most cases, the cost of watertightness simply isn&#x27;t worth it compared to just making your system idempotent or accepting some reasonably small amount of data loss.</div><br/></div></div></div></div><div id="40309615" class="c"><input type="checkbox" id="c-40309615" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#40308926">parent</a><span>|</span><a href="#40309101">prev</a><span>|</span><a href="#40309143">next</a><span>|</span><label class="collapse" for="c-40309615">[-]</label><label class="expand" for="c-40309615">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious about the same thing.. I use a deadletter queue in sqs and even sns and here I can see an archiver but it&#x27;s not clear if I need to rollout my own deadletter behaviour here.. not sure I would be too confident in it either..<p>A nice novel project here but I&#x27;m a bit skeptical of its application for me at least.</div><br/><div id="40312098" class="c"><input type="checkbox" id="c-40312098" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40309615">parent</a><span>|</span><a href="#40309143">next</a><span>|</span><label class="collapse" for="c-40312098">[-]</label><label class="expand" for="c-40312098">[1 more]</label></div><br/><div class="children"><div class="content">pgmq.archive() gives us an API to retain messages on your queue, its an alternative to pgmq.delete(). For me as a long-time Redis user, message retention was always important and was always extra work to implement.<p>DLQ isn&#x27;t a built-in feature to PGMQ yet. We run PGMQ our SaaS at Tembo.io, and the way we implement the DLQ is by checking the message&#x27;s read_ct value. When it exceeds some value, we send the message to another queue rather than processing it. Successfully processed messages end up getting pgmq.archive()&#x27;d.<p>Soon, we will be integrating <a href="https:&#x2F;&#x2F;github.com&#x2F;tembo-io&#x2F;pg_tier">https:&#x2F;&#x2F;github.com&#x2F;tembo-io&#x2F;pg_tier</a> into pgmq so that the archive table is put directly into cloud storage&#x2F;S3.</div><br/></div></div></div></div><div id="40309143" class="c"><input type="checkbox" id="c-40309143" checked=""/><div class="controls bullet"><span class="by">Justsignedup</span><span>|</span><a href="#40308926">parent</a><span>|</span><a href="#40309615">prev</a><span>|</span><a href="#40313094">next</a><span>|</span><label class="collapse" for="c-40309143">[-]</label><label class="expand" for="c-40309143">[3 more]</label></div><br/><div class="children"><div class="content">To be honest. I like the at least once constraint. It causes you to think of background jobs in a idempotent way and makes for better designs. So ultimately I never found the removal of it a mitzva.<p>Also if you don&#x27;t have the constraint and say it works and you need to change systems for any reason, now you gotta rewrite your workers.</div><br/><div id="40313189" class="c"><input type="checkbox" id="c-40313189" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40309143">parent</a><span>|</span><a href="#40313094">next</a><span>|</span><label class="collapse" for="c-40313189">[-]</label><label class="expand" for="c-40313189">[2 more]</label></div><br/><div class="children"><div class="content">I agree. But it can be useful to have a guarantee, even for a specified period of time, that the message will only be seen once. For example, if the processing of that message is very expensive, such as if that message results in API requests to a very expensive SaaS service. It may be idempotent to process that message more times than necessary, but doing so may be cost prohibitive if you are billed per request. I think this is a case where using the VT to help you only process that message one time could help out quite a bit.</div><br/><div id="40313839" class="c"><input type="checkbox" id="c-40313839" checked=""/><div class="controls bullet"><span class="by">pipe_connector</span><span>|</span><a href="#40308926">root</a><span>|</span><a href="#40313189">parent</a><span>|</span><a href="#40313094">next</a><span>|</span><label class="collapse" for="c-40313839">[-]</label><label class="expand" for="c-40313839">[1 more]</label></div><br/><div class="children"><div class="content">Agreed that this property is useful for efficiency. The danger comes from users believing this property is a guarantee and making correctness decisions based on it. There is no such thing as a distributed lock or exclusive hold.</div><br/></div></div></div></div></div></div><div id="40313094" class="c"><input type="checkbox" id="c-40313094" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40308926">parent</a><span>|</span><a href="#40309143">prev</a><span>|</span><a href="#40315765">next</a><span>|</span><label class="collapse" for="c-40313094">[-]</label><label class="expand" for="c-40313094">[1 more]</label></div><br/><div class="children"><div class="content">Quite.  The problem with a visibility timeout is that there can be delays in handling a message, and if the original winner fails to do it in time then some other process&#x2F;thread will, yes, but if processing has external side-effects that can&#x27;t be undone then the at-most-once guarantee will definitely be violated.  And if you run out of storage space and messages have to get dropped then you&#x27;ll definitely violate the at-least-once guarantee.</div><br/></div></div></div></div><div id="40315765" class="c"><input type="checkbox" id="c-40315765" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40308926">prev</a><span>|</span><a href="#40308958">next</a><span>|</span><label class="collapse" for="c-40315765">[-]</label><label class="expand" for="c-40315765">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps we were all just not good at database&#x27;ing, but at a previous job, &quot;using RDBMS as a queue&quot; became a meme&#x2F;shorthand for &quot;terrible idea that needs to be stamped out immediately&quot;.<p>Does Postgres have some features that make it not entirely unsuitable to use for queuing?</div><br/><div id="40315974" class="c"><input type="checkbox" id="c-40315974" checked=""/><div class="controls bullet"><span class="by">ttymck</span><span>|</span><a href="#40315765">parent</a><span>|</span><a href="#40308958">next</a><span>|</span><label class="collapse" for="c-40315974">[-]</label><label class="expand" for="c-40315974">[1 more]</label></div><br/><div class="children"><div class="content">For update skip locked</div><br/></div></div></div></div><div id="40308958" class="c"><input type="checkbox" id="c-40308958" checked=""/><div class="controls bullet"><span class="by">pyuser583</span><span>|</span><a href="#40315765">prev</a><span>|</span><a href="#40311898">next</a><span>|</span><label class="collapse" for="c-40308958">[-]</label><label class="expand" for="c-40308958">[11 more]</label></div><br/><div class="children"><div class="content">What advantages does this have over RabbitMQ?<p>My experience is Postgres queuing makes sense you must extract or persist in the same Postgres instance.<p>Otherwise, thereâs no advantage over standard MQ systems.<p>Is there something I donât know.</div><br/><div id="40309041" class="c"><input type="checkbox" id="c-40309041" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40308958">parent</a><span>|</span><a href="#40309802">next</a><span>|</span><label class="collapse" for="c-40309041">[-]</label><label class="expand" for="c-40309041">[3 more]</label></div><br/><div class="children"><div class="content">One big advantage of using queue inside DB is that you can actually use queue operations in the same transaction as your data operations. It makes everything incredibly simpler when it comes to failure modes.<p>IMO 90% of software which uses external queues is buggy when it comes to edge cases.</div><br/><div id="40309473" class="c"><input type="checkbox" id="c-40309473" checked=""/><div class="controls bullet"><span class="by">zbentley</span><span>|</span><a href="#40308958">root</a><span>|</span><a href="#40309041">parent</a><span>|</span><a href="#40311843">next</a><span>|</span><label class="collapse" for="c-40309473">[-]</label><label class="expand" for="c-40309473">[1 more]</label></div><br/><div class="children"><div class="content">A fair point. If you do need an external queue for any reason (legacy&#x2F;already have one, advanced routing semantics, integrations for external stream processors, etc.) the &quot;Transactional Outbox&quot; pattern provides a way to have your cake and eat it too here--but only for produce operations.<p>In this pattern, publishers write to an RDBMS table on publish, and then best-effort publish to the message broker after RDBMS transaction commit, deleting the row on publish success (optionally doing this in a failure-swallowing&#x2F;background-threaded way). An external scheduled job polls the &quot;publishes&quot; table and republishes any rows that failed to make it to the message broker later on. When coupled with inbound message deduplication (a feature many message brokers now support to some degree) and&#x2F;or consumer idempotency, this is a pretty robust way to reduce the reliability hit of an external message broker being in your transaction processing path.<p>It&#x27;s not a panacea, in that it doesn&#x27;t help with transactional processing&#x2F;consumption and imposes some extra DB load, but is fairly easy to adopt in an ad-hoc&#x2F;don&#x27;t-have-to-rewrite-the-whole-app way.<p><a href="https:&#x2F;&#x2F;microservices.io&#x2F;patterns&#x2F;data&#x2F;transactional-outbox.html" rel="nofollow">https:&#x2F;&#x2F;microservices.io&#x2F;patterns&#x2F;data&#x2F;transactional-outbox....</a></div><br/></div></div><div id="40311843" class="c"><input type="checkbox" id="c-40311843" checked=""/><div class="controls bullet"><span class="by">ilkhan4</span><span>|</span><a href="#40308958">root</a><span>|</span><a href="#40309041">parent</a><span>|</span><a href="#40309473">prev</a><span>|</span><a href="#40309802">next</a><span>|</span><label class="collapse" for="c-40311843">[-]</label><label class="expand" for="c-40311843">[1 more]</label></div><br/><div class="children"><div class="content">Sure, not having to spin up a separate server is nice, but this aspect is underappreciated, imo. We eliminated a whole class of errors and edge cases at my day job just by switching the event enqueue to the same DB transaction as the things that triggered them. It does create a bottleneck at the DB, but as others have commented, you probably aren&#x27;t going to need the scalability as much as you think you do.</div><br/></div></div></div></div><div id="40309802" class="c"><input type="checkbox" id="c-40309802" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40308958">parent</a><span>|</span><a href="#40309041">prev</a><span>|</span><a href="#40310518">next</a><span>|</span><label class="collapse" for="c-40309802">[-]</label><label class="expand" for="c-40309802">[4 more]</label></div><br/><div class="children"><div class="content">Simplicity is one of the reasons we started this project. IMO, far less maintenance overhead to running Postgres compared to RabbitMQ, especially if you are already running Postgres in your application stack. If PGMQ fits your requirements, then you do not need to introduce a new technically.<p>There&#x27;s definitely use cases where PGMQ wont compare to RabbitMQ, or Kafka, though.</div><br/><div id="40310150" class="c"><input type="checkbox" id="c-40310150" checked=""/><div class="controls bullet"><span class="by">ethagnawl</span><span>|</span><a href="#40308958">root</a><span>|</span><a href="#40309802">parent</a><span>|</span><a href="#40310518">next</a><span>|</span><label class="collapse" for="c-40310150">[-]</label><label class="expand" for="c-40310150">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s definitely use cases where PGMQ wont compare to RabbitMQ, or Kafka, though.<p>I&#x27;d be curious to know more about which sorts of use cases fall into this category.</div><br/><div id="40310363" class="c"><input type="checkbox" id="c-40310363" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40308958">root</a><span>|</span><a href="#40310150">parent</a><span>|</span><a href="#40314453">next</a><span>|</span><label class="collapse" for="c-40310363">[-]</label><label class="expand" for="c-40310363">[1 more]</label></div><br/><div class="children"><div class="content">PGMQ doesn&#x27;t give you a way to deliver the same message to concurrent consumers the same way that you can with Kafka via consumer groups.<p>To get this with PGMQ, you&#x27;d need to do something like creating multiple queues, then send messages to all the queues within a transaction. e.g. `begin; pgmq.send(&#x27;queue_a&#x27;...); pgmq.send(&#x27;queue_b&#x27;...); commit;`</div><br/></div></div><div id="40314453" class="c"><input type="checkbox" id="c-40314453" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#40308958">root</a><span>|</span><a href="#40310150">parent</a><span>|</span><a href="#40310363">prev</a><span>|</span><a href="#40310518">next</a><span>|</span><label class="collapse" for="c-40314453">[-]</label><label class="expand" for="c-40314453">[1 more]</label></div><br/><div class="children"><div class="content">PGMQ doesn&#x27;t <i>seem</i> to have functionality for returning a payload to the task submitter.<p>For example, lets say the task is something like:<p><pre><code>    Run a SELECT query on database FOO, returning the results
</code></pre>
There would be workarounds (ie store the results in a &quot;results&quot; table or similar) but just being able to directly return the result in a message to the caller is conceptually simpler.</div><br/></div></div></div></div></div></div><div id="40310518" class="c"><input type="checkbox" id="c-40310518" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#40308958">parent</a><span>|</span><a href="#40309802">prev</a><span>|</span><a href="#40309609">next</a><span>|</span><label class="collapse" for="c-40310518">[-]</label><label class="expand" for="c-40310518">[1 more]</label></div><br/><div class="children"><div class="content">The advantage is: if you already have PostreSQL running, you don&#x27;t have to add RabbitMQ or any other technology.</div><br/></div></div><div id="40309609" class="c"><input type="checkbox" id="c-40309609" checked=""/><div class="controls bullet"><span class="by">borplk</span><span>|</span><a href="#40308958">parent</a><span>|</span><a href="#40310518">prev</a><span>|</span><a href="#40312243">next</a><span>|</span><label class="collapse" for="c-40309609">[-]</label><label class="expand" for="c-40309609">[1 more]</label></div><br/><div class="children"><div class="content">(Not the author)<p>The advantage of using your DB as a queue is that a traditional DB is easier to interact with (for example using SQL queries to view or edit the state of your queue).<p>In most business applications the message payload is a &quot;job_id&quot; pointing to a DB table so you always need and have to go back to the database to do something useful anyway. With this setup it&#x27;s one less thing to worry about and you can take full advantage of SQL and traditional database features.<p>The only downside and bottleneck of having your DB act as a queue is if the workers processes are hitting the DB too frequently to reserve their next job.<p>Most applications will not reach the level of scale for that to be a problem.<p>However if it does become a problem there is an elegant solution where you can continously populate a real queue by querying the DB and putting items in it (&quot;feeder process&quot;). Now you can let the workers reserve their jobs from the real queue so the DB is not being hit as frequently.<p>The workers will still interact with the DB as part of doing their work of course. However they will not ask their &quot;give me my next job ID&quot; question to the DB. They get it from the real queue which is more efficient for that kind of QPOP operation.<p>This solution has the best of both worlds you get the best features of something like Postgres to be the storage backend for your jobs without the downside of hammering the DB to get the next available job (but in general the DB alone can scale quite well for 95% of the businesses out there).</div><br/></div></div></div></div><div id="40311898" class="c"><input type="checkbox" id="c-40311898" checked=""/><div class="controls bullet"><span class="by">RedShift1</span><span>|</span><a href="#40308958">prev</a><span>|</span><a href="#40315376">next</a><span>|</span><label class="collapse" for="c-40311898">[-]</label><label class="expand" for="c-40311898">[3 more]</label></div><br/><div class="children"><div class="content">This seems like a lot of fluff for basically SELECT ... FROM queue FOR UPDATE SKIP LOCKED? Why is is the extension needed when all it does is run some management type SQL?</div><br/><div id="40313780" class="c"><input type="checkbox" id="c-40313780" checked=""/><div class="controls bullet"><span class="by">acaloiar</span><span>|</span><a href="#40311898">parent</a><span>|</span><a href="#40314144">next</a><span>|</span><label class="collapse" for="c-40313780">[-]</label><label class="expand" for="c-40313780">[1 more]</label></div><br/><div class="children"><div class="content">A similar argument can be made of many primitives and their corresponding higher order applications.<p>Why build higher order concept Y when it&#x27;s simply built on primitive X?<p>Why build the C programming language when C compilers simply generate assembly or machine code?<p>---<p>A sensible answer is that new abstractions make lower level primitives easier to manage.</div><br/></div></div><div id="40314144" class="c"><input type="checkbox" id="c-40314144" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#40311898">parent</a><span>|</span><a href="#40313780">prev</a><span>|</span><a href="#40315376">next</a><span>|</span><label class="collapse" for="c-40314144">[-]</label><label class="expand" for="c-40314144">[1 more]</label></div><br/><div class="children"><div class="content">SQS API compatibility?</div><br/></div></div></div></div><div id="40315376" class="c"><input type="checkbox" id="c-40315376" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#40311898">prev</a><span>|</span><a href="#40308817">next</a><span>|</span><label class="collapse" for="c-40315376">[-]</label><label class="expand" for="c-40315376">[5 more]</label></div><br/><div class="children"><div class="content">&gt; TIMESTAMP WITH TIME ZONE<p>I&#x27;m yet to find a use case for &quot;WITH TIME ZONE&quot;, in all cases it&#x27;s better to use &quot;WITHOUT TIME ZONE&quot;. All it does is displays the date in sql client local timezone, which should never matter for well done service. Would be glad to learn otherwise.</div><br/><div id="40315875" class="c"><input type="checkbox" id="c-40315875" checked=""/><div class="controls bullet"><span class="by">boromisp</span><span>|</span><a href="#40315376">parent</a><span>|</span><a href="#40316277">next</a><span>|</span><label class="collapse" for="c-40315875">[-]</label><label class="expand" for="c-40315875">[2 more]</label></div><br/><div class="children"><div class="content">Timestamp with time zone is the type for an &quot;absolute timestamp&quot;.<p>Timestamp without time zone is for local time, and sometimes abused as &quot;time in utc without being explicit about it&quot;.<p>The naming describes the expected input, not what is stored. The time zone name or offset is not stored with timestamptz.<p>Always use timestamptz, unless you have a specific use case for local time.</div><br/><div id="40316150" class="c"><input type="checkbox" id="c-40316150" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40315376">root</a><span>|</span><a href="#40315875">parent</a><span>|</span><a href="#40316277">next</a><span>|</span><label class="collapse" for="c-40316150">[-]</label><label class="expand" for="c-40316150">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is quite confusing and I dread to think how many have got it wrong and store local times like the GP.<p>But it&#x27;s also not as simple as &quot;always use WITH TIME ZONE&quot;. That also leads to a mistake.<p>The reason is (just to reiterate what you said) the TIMESTAMP WITH TIME ZONE does not store the time zone! If you ever want to get local time back (e.g. ask a question like &quot;how many users log on before lunch time&quot;) then you need to store either local time in a TIMESTAMP WITHOUT TIME ZONE field, or the time zone, and get local time like: SELECT recorded_at AT TIME ZONE time_zone AS local_time ... (I prefer the latter).</div><br/></div></div></div></div><div id="40316277" class="c"><input type="checkbox" id="c-40316277" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40315376">parent</a><span>|</span><a href="#40315875">prev</a><span>|</span><a href="#40316104">next</a><span>|</span><label class="collapse" for="c-40316277">[-]</label><label class="expand" for="c-40316277">[1 more]</label></div><br/><div class="children"><div class="content">Look carefully. The SQL client does not just &quot;display it in local time&quot;, it displays it with a UTC offset. You can be sure whenever you see a UTC offset that UTC is fully recoverable. In this way the TIMESTAMP WITH TIME ZONE field is context independent. It&#x27;s just UTC.<p>Conversely, if there is no offset, time zone, or something to distinguish it as UTC (like the Z in ISO8601) then you are just storing &quot;local time&quot;, that is the time on the clock in someone&#x27;s kitchen, somewhere. This is the TIMESTAMP WITHOUT TIME ZONE field and is highly context dependent (in particular, what clock was used?)</div><br/></div></div><div id="40316104" class="c"><input type="checkbox" id="c-40316104" checked=""/><div class="controls bullet"><span class="by">ddorian43</span><span>|</span><a href="#40315376">parent</a><span>|</span><a href="#40316277">prev</a><span>|</span><a href="#40308817">next</a><span>|</span><label class="collapse" for="c-40316104">[-]</label><label class="expand" for="c-40316104">[1 more]</label></div><br/><div class="children"><div class="content">Actually, it&#x27;s the complete opposite. You always want WITH TIMEZONE.</div><br/></div></div></div></div><div id="40308817" class="c"><input type="checkbox" id="c-40308817" checked=""/><div class="controls bullet"><span class="by">conroy</span><span>|</span><a href="#40315376">prev</a><span>|</span><a href="#40314507">next</a><span>|</span><label class="collapse" for="c-40308817">[-]</label><label class="expand" for="c-40308817">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious how this performs compared to River <a href="https:&#x2F;&#x2F;riverqueue.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;riverqueue.com&#x2F;</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38349716">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38349716</a></div><br/><div id="40309753" class="c"><input type="checkbox" id="c-40309753" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40308817">parent</a><span>|</span><a href="#40314507">next</a><span>|</span><label class="collapse" for="c-40309753">[-]</label><label class="expand" for="c-40309753">[1 more]</label></div><br/><div class="children"><div class="content">I think it would be tough to compare. There are client libraries for several languages, but the project is mostly a SQL API to the queue operations like send, read, archive, delete using the same semantics as SQS&#x2F;RSMQ.<p>Any language that can connect to Postgres can use PGMQ, whereas it seems River is Go only?</div><br/></div></div></div></div><div id="40314507" class="c"><input type="checkbox" id="c-40314507" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#40308817">prev</a><span>|</span><a href="#40308921">next</a><span>|</span><label class="collapse" for="c-40314507">[-]</label><label class="expand" for="c-40314507">[1 more]</label></div><br/><div class="children"><div class="content">As a data point, there&#x27;s a similar Go based project called Neoq:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;acaloiaro&#x2F;neoq">https:&#x2F;&#x2F;github.com&#x2F;acaloiaro&#x2F;neoq</a></div><br/></div></div><div id="40308921" class="c"><input type="checkbox" id="c-40308921" checked=""/><div class="controls bullet"><span class="by">thangngoc89</span><span>|</span><a href="#40314507">prev</a><span>|</span><a href="#40310321">next</a><span>|</span><label class="collapse" for="c-40308921">[-]</label><label class="expand" for="c-40308921">[10 more]</label></div><br/><div class="children"><div class="content">Iâm wondering if there are language agnostic queues where the queue consumers and publishers could be written in different languages?</div><br/><div id="40309221" class="c"><input type="checkbox" id="c-40309221" checked=""/><div class="controls bullet"><span class="by">rco8786</span><span>|</span><a href="#40308921">parent</a><span>|</span><a href="#40309443">next</a><span>|</span><label class="collapse" for="c-40309221">[-]</label><label class="expand" for="c-40309221">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what this is. You write your own consumer&#x2F;publisher code however you want, and interact with the queues via SQL queries.</div><br/></div></div><div id="40309443" class="c"><input type="checkbox" id="c-40309443" checked=""/><div class="controls bullet"><span class="by">SideburnsOfDoom</span><span>|</span><a href="#40308921">parent</a><span>|</span><a href="#40309221">prev</a><span>|</span><a href="#40310321">next</a><span>|</span><label class="collapse" for="c-40309443">[-]</label><label class="expand" for="c-40309443">[8 more]</label></div><br/><div class="children"><div class="content">That&#x27;s normal, yes. Name a queuing system, and with very few exceptions it will have clients for a variety of languages.<p>It is also normal to exchange messages with contant as json, protobuf or similar format, which again can be processed by any language that aims to be widely used.<p>In fact, are there any queues that aren&#x27;t language-agnostic? I had the idea that ZeroMQ was a C&#x2F;C++ only thing, but I checked the docs and it&#x27;s got the usual plethora of language bindings <a href="https:&#x2F;&#x2F;zeromq.org&#x2F;get-started&#x2F;" rel="nofollow">https:&#x2F;&#x2F;zeromq.org&#x2F;get-started&#x2F;</a><p>So right now I can&#x27;t name <i>any</i> queue systems that are single language.  They&#x27;re <i>all</i> aimed at interop.</div><br/><div id="40314461" class="c"><input type="checkbox" id="c-40314461" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#40308921">root</a><span>|</span><a href="#40309443">parent</a><span>|</span><a href="#40309742">next</a><span>|</span><label class="collapse" for="c-40314461">[-]</label><label class="expand" for="c-40314461">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Name a queuing system, and with very few exceptions it will have clients for a variety of languages.<p>RQ seems to be one of those exceptions, as even after many years it looks to be Python only. :(<p><a href="https:&#x2F;&#x2F;python-rq.org" rel="nofollow">https:&#x2F;&#x2F;python-rq.org</a></div><br/><div id="40315416" class="c"><input type="checkbox" id="c-40315416" checked=""/><div class="controls bullet"><span class="by">thangngoc89</span><span>|</span><a href="#40308921">root</a><span>|</span><a href="#40314461">parent</a><span>|</span><a href="#40309742">next</a><span>|</span><label class="collapse" for="c-40315416">[-]</label><label class="expand" for="c-40315416">[3 more]</label></div><br/><div class="children"><div class="content">RQ uses Python&#x27;s Pickle and it doesn&#x27;t have any serialization protocol so it stays Python only.</div><br/><div id="40316386" class="c"><input type="checkbox" id="c-40316386" checked=""/><div class="controls bullet"><span class="by">SideburnsOfDoom</span><span>|</span><a href="#40308921">root</a><span>|</span><a href="#40315416">parent</a><span>|</span><a href="#40315552">next</a><span>|</span><label class="collapse" for="c-40316386">[-]</label><label class="expand" for="c-40316386">[1 more]</label></div><br/><div class="children"><div class="content">Most queuing systems that I have used, you can send text or bytes, so the most common denominator is DTOs encoded as json, encoded as UTF-8 text.<p>You could do likewise, (i.e. send text containing a representation of what you want) and this would allow other  languages to consume? But that&#x27;s an edge case (sending text) of an edge case (RQ).</div><br/></div></div><div id="40315552" class="c"><input type="checkbox" id="c-40315552" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#40308921">root</a><span>|</span><a href="#40315416">parent</a><span>|</span><a href="#40316386">prev</a><span>|</span><a href="#40309742">next</a><span>|</span><label class="collapse" for="c-40315552">[-]</label><label class="expand" for="c-40315552">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s a right pain. :(</div><br/></div></div></div></div></div></div><div id="40309742" class="c"><input type="checkbox" id="c-40309742" checked=""/><div class="controls bullet"><span class="by">thangngoc89</span><span>|</span><a href="#40308921">root</a><span>|</span><a href="#40309443">parent</a><span>|</span><a href="#40314461">prev</a><span>|</span><a href="#40310321">next</a><span>|</span><label class="collapse" for="c-40309742">[-]</label><label class="expand" for="c-40309742">[3 more]</label></div><br/><div class="children"><div class="content">Interesting. I&#x27;ve been looking at a much more simpler system than Celery queue to publish jobs from Golang and consume jobs from Python side (AI&#x2F;ML stuff). This threads gave a lot of names and links for further investigation.</div><br/><div id="40310675" class="c"><input type="checkbox" id="c-40310675" checked=""/><div class="controls bullet"><span class="by">anamexis</span><span>|</span><a href="#40308921">root</a><span>|</span><a href="#40309742">parent</a><span>|</span><a href="#40310321">next</a><span>|</span><label class="collapse" for="c-40310675">[-]</label><label class="expand" for="c-40310675">[2 more]</label></div><br/><div class="children"><div class="content">As mentioned, there are a plethora of queuing systems that have cross platform clients.<p>If youâre interested specifically in a background job system, you may want to check out Faktory. Itâs Mike Perhamâs language-agnostic follow-up to Sidekiq.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;contribsys&#x2F;faktory">https:&#x2F;&#x2F;github.com&#x2F;contribsys&#x2F;faktory</a></div><br/><div id="40315420" class="c"><input type="checkbox" id="c-40315420" checked=""/><div class="controls bullet"><span class="by">thangngoc89</span><span>|</span><a href="#40308921">root</a><span>|</span><a href="#40310675">parent</a><span>|</span><a href="#40310321">next</a><span>|</span><label class="collapse" for="c-40315420">[-]</label><label class="expand" for="c-40315420">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the recommendation. I&#x27;ve checked this out and looks like a good alternative with much simpler configuration and less foot-gun than Celery.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40310321" class="c"><input type="checkbox" id="c-40310321" checked=""/><div class="controls bullet"><span class="by">dostoevsky013</span><span>|</span><a href="#40308921">prev</a><span>|</span><a href="#40310942">next</a><span>|</span><label class="collapse" for="c-40310321">[-]</label><label class="expand" for="c-40310321">[3 more]</label></div><br/><div class="children"><div class="content">Iâm not sure what are the benefits for the micro service architecture. Do you expect other services&#x2F;domains to connect to your database to listen for events? How does it scale if you have several micro services that need to publish events?<p>Or do you expect to a dedicated database to be maintained for this queue? Worth comparing it with other queue systems that persist messages and can help you to scale message processing like kafka with topic partitions.<p>Found this article on how Revolut uses Postgres for events processing: <a href="https:&#x2F;&#x2F;medium.com&#x2F;revolut&#x2F;recording-more-events-but-where-will-we-store-them-4b1dad457cf5" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;revolut&#x2F;recording-more-events-but-where-w...</a></div><br/><div id="40315980" class="c"><input type="checkbox" id="c-40315980" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#40310321">parent</a><span>|</span><a href="#40310547">next</a><span>|</span><label class="collapse" for="c-40315980">[-]</label><label class="expand" for="c-40315980">[1 more]</label></div><br/><div class="children"><div class="content">Who said anything about microservice architecture?<p>If you&#x27;re building a new MVP that needs background processing, you have a queue, and your monolith listens to the queue. Sticking to one database during the MVP keeps things simple until you validate both the product and expected scale. You can migrate to something heavier later if the product gets traction.</div><br/></div></div><div id="40310547" class="c"><input type="checkbox" id="c-40310547" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40310321">parent</a><span>|</span><a href="#40315980">prev</a><span>|</span><a href="#40310942">next</a><span>|</span><label class="collapse" for="c-40310547">[-]</label><label class="expand" for="c-40310547">[1 more]</label></div><br/><div class="children"><div class="content">We talk a little bit in <a href="https:&#x2F;&#x2F;tembo.io&#x2F;blog&#x2F;managed-postgres-rust" rel="nofollow">https:&#x2F;&#x2F;tembo.io&#x2F;blog&#x2F;managed-postgres-rust</a> about how we use PGMQ to run our SaaS at Tembo.io. We could have ran a Redis instance and used RSMQ, but it simplified our architecture to stick with Postgres rather than bringing in Redis.<p>As for scaling - normal Postgres scaling rules apply. max_connections will determine how many concurrent applications can connect. The queue workload (many insert, read, update, delete) is very OLTP-like IMO, and Postgres handles that very well. We wrote some about dealing with bloat in this blog: <a href="https:&#x2F;&#x2F;tembo.io&#x2F;blog&#x2F;optimizing-postgres-auto-vacuum" rel="nofollow">https:&#x2F;&#x2F;tembo.io&#x2F;blog&#x2F;optimizing-postgres-auto-vacuum</a></div><br/></div></div></div></div><div id="40310942" class="c"><input type="checkbox" id="c-40310942" checked=""/><div class="controls bullet"><span class="by">bdcravens</span><span>|</span><a href="#40310321">prev</a><span>|</span><a href="#40309216">next</a><span>|</span><label class="collapse" for="c-40310942">[-]</label><label class="expand" for="c-40310942">[1 more]</label></div><br/><div class="children"><div class="content">Note there are a number of background job processors for specific languages&#x2F;frameworks that use Postgresql as the broker. For example GoodJob and the upcoming SolidQueue in Ruby and Rails.</div><br/></div></div><div id="40309216" class="c"><input type="checkbox" id="c-40309216" checked=""/><div class="controls bullet"><span class="by">rco8786</span><span>|</span><a href="#40310942">prev</a><span>|</span><a href="#40312700">next</a><span>|</span><label class="collapse" for="c-40309216">[-]</label><label class="expand" for="c-40309216">[3 more]</label></div><br/><div class="children"><div class="content">This is neat. Would be cool if there was support for a dead letter or retry queue. The idea of deleting an event transactionally with the result of processing said event is pretty nice.</div><br/><div id="40310227" class="c"><input type="checkbox" id="c-40310227" checked=""/><div class="controls bullet"><span class="by">jpambrun</span><span>|</span><a href="#40309216">parent</a><span>|</span><a href="#40312700">next</a><span>|</span><label class="collapse" for="c-40310227">[-]</label><label class="expand" for="c-40310227">[2 more]</label></div><br/><div class="children"><div class="content">Retries are baked in as message re-becomes visible after a configurable time. For dead letter you can move to another queue on the nth retry.</div><br/><div id="40311062" class="c"><input type="checkbox" id="c-40311062" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40309216">root</a><span>|</span><a href="#40310227">parent</a><span>|</span><a href="#40312700">next</a><span>|</span><label class="collapse" for="c-40311062">[-]</label><label class="expand" for="c-40311062">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly how we do this in our SaaS at Tembo.io. We check read_ct, and move the message if &gt;= N. I think it would be awesome if this were a built-in feature though.</div><br/></div></div></div></div></div></div><div id="40310499" class="c"><input type="checkbox" id="c-40310499" checked=""/><div class="controls bullet"><span class="by">airocker</span><span>|</span><a href="#40312700">prev</a><span>|</span><a href="#40313329">next</a><span>|</span><label class="collapse" for="c-40310499">[-]</label><label class="expand" for="c-40310499">[1 more]</label></div><br/><div class="children"><div class="content">I think it will be better if you create events automatically based on commit events in wal.</div><br/></div></div><div id="40313329" class="c"><input type="checkbox" id="c-40313329" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40310499">prev</a><span>|</span><a href="#40309273">next</a><span>|</span><label class="collapse" for="c-40313329">[-]</label><label class="expand" for="c-40313329">[2 more]</label></div><br/><div class="children"><div class="content">This is strictly polling, no push or long poll support?</div><br/><div id="40314133" class="c"><input type="checkbox" id="c-40314133" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40313329">parent</a><span>|</span><a href="#40309273">next</a><span>|</span><label class="collapse" for="c-40314133">[-]</label><label class="expand" for="c-40314133">[1 more]</label></div><br/><div class="children"><div class="content">There is a long poll, <a href="https:&#x2F;&#x2F;tembo-io.github.io&#x2F;pgmq&#x2F;api&#x2F;sql&#x2F;functions&#x2F;#read_with_poll" rel="nofollow">https:&#x2F;&#x2F;tembo-io.github.io&#x2F;pgmq&#x2F;api&#x2F;sql&#x2F;functions&#x2F;#read_with...</a><p>We have been talking about a push using Postgres &#x27;notify&#x27;, or even via an http, but we don&#x27;t have a solid design for it yet.</div><br/></div></div></div></div><div id="40313800" class="c"><input type="checkbox" id="c-40313800" checked=""/><div class="controls bullet"><span class="by">jilles</span><span>|</span><a href="#40309273">prev</a><span>|</span><a href="#40311554">next</a><span>|</span><label class="collapse" for="c-40313800">[-]</label><label class="expand" for="c-40313800">[1 more]</label></div><br/><div class="children"><div class="content">Can someone tell me what the usefulness of this is compared to RabbitMQ or Kafka?</div><br/></div></div><div id="40311554" class="c"><input type="checkbox" id="c-40311554" checked=""/><div class="controls bullet"><span class="by">cynicalsecurity</span><span>|</span><a href="#40313800">prev</a><span>|</span><a href="#40309579">next</a><span>|</span><label class="collapse" for="c-40311554">[-]</label><label class="expand" for="c-40311554">[8 more]</label></div><br/><div class="children"><div class="content">But why? Why not have a proper SQS service? What&#x27;s the obsession with Postgres?</div><br/><div id="40316046" class="c"><input type="checkbox" id="c-40316046" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#40311554">parent</a><span>|</span><a href="#40315030">next</a><span>|</span><label class="collapse" for="c-40316046">[-]</label><label class="expand" for="c-40316046">[1 more]</label></div><br/><div class="children"><div class="content">When you&#x27;re building an MVP, you want to keep the architecture as utterly simple as possible. SQS helps at scale, but your product may never reach scale. In the meantime, you vendor-locked into AWS, with all its attendant needs like setting up auth to AWS, account vending, etc. If your MVP already needs stuff like object storage, and you&#x27;re setting up AWS anyway, then sure, prefer SQS. But a lot of MVPs are better set up as monolith + Postgres to start with and only complicating the architecture after product traction is found.</div><br/></div></div><div id="40315030" class="c"><input type="checkbox" id="c-40315030" checked=""/><div class="controls bullet"><span class="by">redact207</span><span>|</span><a href="#40311554">parent</a><span>|</span><a href="#40316046">prev</a><span>|</span><a href="#40312454">next</a><span>|</span><label class="collapse" for="c-40315030">[-]</label><label class="expand" for="c-40315030">[2 more]</label></div><br/><div class="children"><div class="content">I agree in general, but there will always be certain requirements and team structures where stuff like this makes sense.<p>For me, I work in a small team of 6 devs on an ever growing app and feature set. I 100% will leverage managed services where cost and complexity allow. SQS is one of the most stable and cheapest AWS service, and the ability to just use it and not have to sysops it means we can spend more time building features.</div><br/><div id="40315276" class="c"><input type="checkbox" id="c-40315276" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#40311554">root</a><span>|</span><a href="#40315030">parent</a><span>|</span><a href="#40312454">next</a><span>|</span><label class="collapse" for="c-40315276">[-]</label><label class="expand" for="c-40315276">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Iâve relied heavily on SQS for years and never regretted it. I question the comparison to SQS for this add on â itâs not really in the same ballpark.</div><br/></div></div></div></div><div id="40312454" class="c"><input type="checkbox" id="c-40312454" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40311554">parent</a><span>|</span><a href="#40315030">prev</a><span>|</span><a href="#40313177">next</a><span>|</span><label class="collapse" for="c-40312454">[-]</label><label class="expand" for="c-40312454">[1 more]</label></div><br/><div class="children"><div class="content">IMO, it is most valuable when you are looking for ways of reducing complexity. For a lot of projects, if you&#x27;re already running Postgres then it is maybe not worth the added complexity of bringing in another technology.</div><br/></div></div><div id="40313177" class="c"><input type="checkbox" id="c-40313177" checked=""/><div class="controls bullet"><span class="by">jpambrun</span><span>|</span><a href="#40311554">parent</a><span>|</span><a href="#40312454">prev</a><span>|</span><a href="#40313180">next</a><span>|</span><label class="collapse" for="c-40313177">[-]</label><label class="expand" for="c-40313177">[1 more]</label></div><br/><div class="children"><div class="content">Why use a service that comes with lock-in and poor developer experience when I can use the database I already have?</div><br/></div></div><div id="40313180" class="c"><input type="checkbox" id="c-40313180" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40311554">parent</a><span>|</span><a href="#40313177">prev</a><span>|</span><a href="#40311630">next</a><span>|</span><label class="collapse" for="c-40313180">[-]</label><label class="expand" for="c-40313180">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40307454#40311843">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40307454#40311843</a></div><br/></div></div><div id="40311630" class="c"><input type="checkbox" id="c-40311630" checked=""/><div class="controls bullet"><span class="by">poisonborz</span><span>|</span><a href="#40311554">parent</a><span>|</span><a href="#40313180">prev</a><span>|</span><a href="#40309579">next</a><span>|</span><label class="collapse" for="c-40311630">[-]</label><label class="expand" for="c-40311630">[1 more]</label></div><br/><div class="children"><div class="content">no dependence on a third party</div><br/></div></div></div></div><div id="40309579" class="c"><input type="checkbox" id="c-40309579" checked=""/><div class="controls bullet"><span class="by">ltbarcly3</span><span>|</span><a href="#40311554">prev</a><span>|</span><a href="#40312217">next</a><span>|</span><label class="collapse" for="c-40309579">[-]</label><label class="expand" for="c-40309579">[4 more]</label></div><br/><div class="children"><div class="content">Another one of these!  It&#x27;s interesting how many times this has been made and abandoned and made again.<p><a href="https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;PGQ_Tutorial" rel="nofollow">https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;PGQ_Tutorial</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;florentx&#x2F;pgqueue">https:&#x2F;&#x2F;github.com&#x2F;florentx&#x2F;pgqueue</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;cirello-io&#x2F;pgqueue">https:&#x2F;&#x2F;github.com&#x2F;cirello-io&#x2F;pgqueue</a><p>Hundreds of them!  We have a home grown one called PGQ at work here also.<p>It&#x27;s a good idea and easy to implement, but still valuable to have implemented already.  Cool project.</div><br/><div id="40309937" class="c"><input type="checkbox" id="c-40309937" checked=""/><div class="controls bullet"><span class="by">arecurrence</span><span>|</span><a href="#40309579">parent</a><span>|</span><a href="#40309672">next</a><span>|</span><label class="collapse" for="c-40309937">[-]</label><label class="expand" for="c-40309937">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve written a few of these and should probably release a package at some point but each version has been somewhat domain specific.<p>The last time we measured an immediate 99% performance improvement over SNS+SQS.  It was so dramatic that we were able to reduce job resources simply due to the queue implementation change.<p>There&#x27;s a lot of useful and almost trivial features you can throw in as well.  SQS hasn&#x27;t changed much in a long time.</div><br/></div></div><div id="40309672" class="c"><input type="checkbox" id="c-40309672" checked=""/><div class="controls bullet"><span class="by">mattbillenstein</span><span>|</span><a href="#40309579">parent</a><span>|</span><a href="#40309937">prev</a><span>|</span><a href="#40312160">next</a><span>|</span><label class="collapse" for="c-40309672">[-]</label><label class="expand" for="c-40309672">[1 more]</label></div><br/><div class="children"><div class="content">Ha, I wrote one too - <a href="https:&#x2F;&#x2F;github.com&#x2F;mattbillenstein&#x2F;pg-queue&#x2F;blob&#x2F;main&#x2F;pg-queue.sql">https:&#x2F;&#x2F;github.com&#x2F;mattbillenstein&#x2F;pg-queue&#x2F;blob&#x2F;main&#x2F;pg-que...</a><p>Roughly follows the semantics of beanstalkd which I used once upon a time and quite liked.</div><br/></div></div></div></div><div id="40312217" class="c"><input type="checkbox" id="c-40312217" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#40309579">prev</a><span>|</span><a href="#40309029">next</a><span>|</span><label class="collapse" for="c-40312217">[-]</label><label class="expand" for="c-40312217">[2 more]</label></div><br/><div class="children"><div class="content">Seems an unusual choice that this does not have an HTTP interface.<p>HTTP is really the perfect client agnostic super simple way to interface with a message queue.</div><br/><div id="40316061" class="c"><input type="checkbox" id="c-40316061" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#40312217">parent</a><span>|</span><a href="#40309029">next</a><span>|</span><label class="collapse" for="c-40316061">[-]</label><label class="expand" for="c-40316061">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary, creating new HTTP connections introduces an irreducible source of latency compared to establishing and reusing a persistent connection.<p>You may end up building a single-tenant architecture where each tenant gets its own database and there are relatively few consumers that are able to respond quicker due to sticking with a long-lived connection model.</div><br/></div></div></div></div><div id="40309029" class="c"><input type="checkbox" id="c-40309029" checked=""/><div class="controls bullet"><span class="by">seveibar</span><span>|</span><a href="#40312217">prev</a><span>|</span><label class="collapse" for="c-40309029">[-]</label><label class="expand" for="c-40309029">[10 more]</label></div><br/><div class="children"><div class="content">People considering this project should also probably consider Graphile Worker[1] I&#x27;ve scaled Graphile Worker to 10m daily jobs just fine<p>The behavior of this library is a bit different and in some ways a bit lower level. If you are using something like this, expect to get very intimate with it as you scale- a lot of times your custom workload would really benefit from a custom index and it&#x27;s handy to understand how the underlying system works.<p>[1] <a href="https:&#x2F;&#x2F;worker.graphile.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;worker.graphile.org&#x2F;</a></div><br/><div id="40315847" class="c"><input type="checkbox" id="c-40315847" checked=""/><div class="controls bullet"><span class="by">brycelarkin</span><span>|</span><a href="#40309029">parent</a><span>|</span><a href="#40309265">next</a><span>|</span><label class="collapse" for="c-40315847">[-]</label><label class="expand" for="c-40315847">[1 more]</label></div><br/><div class="children"><div class="content">Do you add jobs inside a transaction? Or with a root connection? There doesn&#x27;t seem to be an out of the box way to add jobs in a transaction.</div><br/></div></div><div id="40309265" class="c"><input type="checkbox" id="c-40309265" checked=""/><div class="controls bullet"><span class="by">philefstat</span><span>|</span><a href="#40309029">parent</a><span>|</span><a href="#40315847">prev</a><span>|</span><a href="#40311903">next</a><span>|</span><label class="collapse" for="c-40309265">[-]</label><label class="expand" for="c-40309265">[1 more]</label></div><br/><div class="children"><div class="content">have also used&#x2F;introduced this to several places I&#x27;ve worked and it&#x27;s been great each time. My only qualm is it&#x27;s not particularly easy to modify the exponential back off timing without hacky solutions. Have you ever found a good way to do that?</div><br/></div></div><div id="40311903" class="c"><input type="checkbox" id="c-40311903" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#40309029">parent</a><span>|</span><a href="#40309265">prev</a><span>|</span><a href="#40315635">next</a><span>|</span><label class="collapse" for="c-40311903">[-]</label><label class="expand" for="c-40311903">[6 more]</label></div><br/><div class="children"><div class="content">Is there something like that in the jvm world?</div><br/><div id="40311948" class="c"><input type="checkbox" id="c-40311948" checked=""/><div class="controls bullet"><span class="by">RedShift1</span><span>|</span><a href="#40309029">root</a><span>|</span><a href="#40311903">parent</a><span>|</span><a href="#40312084">next</a><span>|</span><label class="collapse" for="c-40311948">[-]</label><label class="expand" for="c-40311948">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need anything specific. SELECT ... FROM queue FOR UPDATE SKIP LOCKED is the secret sauce.</div><br/><div id="40312289" class="c"><input type="checkbox" id="c-40312289" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#40309029">root</a><span>|</span><a href="#40311948">parent</a><span>|</span><a href="#40313872">next</a><span>|</span><label class="collapse" for="c-40312289">[-]</label><label class="expand" for="c-40312289">[1 more]</label></div><br/><div class="children"><div class="content">Would be nice to get some goodies for free, like overview, pausing, state, statistics etc. :-)</div><br/></div></div><div id="40313872" class="c"><input type="checkbox" id="c-40313872" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#40309029">root</a><span>|</span><a href="#40311948">parent</a><span>|</span><a href="#40312289">prev</a><span>|</span><a href="#40312084">next</a><span>|</span><label class="collapse" for="c-40313872">[-]</label><label class="expand" for="c-40313872">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly how pgmq is implemented, + the usage of VT.</div><br/></div></div></div></div><div id="40312084" class="c"><input type="checkbox" id="c-40312084" checked=""/><div class="controls bullet"><span class="by">wmfiv</span><span>|</span><a href="#40309029">root</a><span>|</span><a href="#40311903">parent</a><span>|</span><a href="#40311948">prev</a><span>|</span><a href="#40315635">next</a><span>|</span><label class="collapse" for="c-40312084">[-]</label><label class="expand" for="c-40312084">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.jobrunr.io&#x2F;&#x2F;en&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.jobrunr.io&#x2F;&#x2F;en&#x2F;</a> seems to be popular at the moment.</div><br/><div id="40316155" class="c"><input type="checkbox" id="c-40316155" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#40309029">root</a><span>|</span><a href="#40312084">parent</a><span>|</span><a href="#40315635">next</a><span>|</span><label class="collapse" for="c-40316155">[-]</label><label class="expand" for="c-40316155">[1 more]</label></div><br/><div class="children"><div class="content">That looks pretty good! Too bad that the OSS version limits the number of jobs quite a bit.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>