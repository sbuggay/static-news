<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705395658247" as="style"/><link rel="stylesheet" href="styles.css?v=1705395658247"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://chapel-lang.org/blog/posts/intro-to-gpus/">Introduction to GPU Programming in Chapel</a> <span class="domain">(<a href="https://chapel-lang.org">chapel-lang.org</a>)</span></div><div class="subtext"><span>pjmlp</span> | <span>10 comments</span></div><br/><div><div id="39009566" class="c"><input type="checkbox" id="c-39009566" checked=""/><div class="controls bullet"><span class="by">subharmonicon</span><span>|</span><a href="#38962735">next</a><span>|</span><label class="collapse" for="c-39009566">[-]</label><label class="expand" for="c-39009566">[1 more]</label></div><br/><div class="children"><div class="content">Happy to see this here. I was following Chapel pretty closely back around 2010-2012, but hadn’t paid much attention to its recent evolution.<p>They mention vendor neutrality but I don’t see a mention of which OSes this is supported on, or if they have any form of support for Metal on macOS (e.g. through one of the cross-compilation routes like through SPIRV).</div><br/></div></div><div id="38962735" class="c"><input type="checkbox" id="c-38962735" checked=""/><div class="controls bullet"><span class="by">ColonelPhantom</span><span>|</span><a href="#39009566">prev</a><span>|</span><a href="#39009933">next</a><span>|</span><label class="collapse" for="c-38962735">[-]</label><label class="expand" for="c-38962735">[6 more]</label></div><br/><div class="children"><div class="content">Seems like it currently supports only CUDA and ROCm. Are there plans to support any other GPU vendors, such as Intel?<p>The example also seems a little bit high on &#x27;magic&#x27;. Chapel is told to execute on GPU, yet it somehow decides &quot;this loop is order-dependent so it should run on the CPU anyway&quot;? It&#x27;s not a bad approach necessarily, but I don&#x27;t think you can get any such implicit serialization when directly programming CUDA C++ or similar. (I think Futhark, another language for high-level parallel computing, also doesn&#x27;t suffer from this kind of thing, thanks to being purely functional.)</div><br/><div id="38963545" class="c"><input type="checkbox" id="c-38963545" checked=""/><div class="controls bullet"><span class="by">e-kayrakli</span><span>|</span><a href="#38962735">parent</a><span>|</span><a href="#38970918">next</a><span>|</span><label class="collapse" for="c-38963545">[-]</label><label class="expand" for="c-38963545">[2 more]</label></div><br/><div class="children"><div class="content">Re Intel support: That&#x27;s definitely in our plans. However, there are also many other areas that we are actively working on to add more features, fix bugs and improve performance. When prioritizing we typically make decisions based on what our current and potential users might need in the language. Frankly, we are not seeing a big push for Intel GPU support so far. So, currently it is not near the top of our priorities. If you (or other readers) have any input on that matter where lack of Intel support might be a blocker for testing Chapel and&#x2F;or its GPU support out, definitely let us know.<p>Re implicit serialization: To clarify; the serialization based on order-dependence is not implicit. The users should use `for` loop if their loop is order-dependent and `foreach` (and `forall`) if their loop is order-independent. In other words, the Chapel compiler doesn&#x27;t make decisions about order-dependence. In particular for GPU execution: a `for` loop will never turn into a GPU kernel.<p>There are however some cases where a `foreach` does not turn into a kernel. You may be referring to those cases, but that&#x27;s not related to order-dependence. Some Chapel features cannot execute on GPU. If your `foreach` loop&#x27;s body uses any of those features then it will not be launched as a kernel even though `foreach` signals order-independence. Now, a subset of such features that makes an order-independent loop GPU-ineligible are there because we haven&#x27;t gotten a chance to properly address them, yet. Another subset of such features will remain thwarters for a longer time and maybe forever. For example, your `foreach` loop could be calling an extern host function.</div><br/><div id="39009672" class="c"><input type="checkbox" id="c-39009672" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38962735">root</a><span>|</span><a href="#38963545">parent</a><span>|</span><a href="#38970918">next</a><span>|</span><label class="collapse" for="c-39009672">[-]</label><label class="expand" for="c-39009672">[1 more]</label></div><br/><div class="children"><div class="content">What about Apple Silicon &#x2F; Metal support?</div><br/></div></div></div></div><div id="38970918" class="c"><input type="checkbox" id="c-38970918" checked=""/><div class="controls bullet"><span class="by">bradcray</span><span>|</span><a href="#38962735">parent</a><span>|</span><a href="#38963545">prev</a><span>|</span><a href="#38970665">next</a><span>|</span><label class="collapse" for="c-38970918">[-]</label><label class="expand" for="c-38970918">[2 more]</label></div><br/><div class="children"><div class="content">@ColonelPhantom:  Thanks very much for your questions.  The following are answers I&#x27;m relaying from Engin Kayraklioglu, who heads up the Chapel GPU effort:<p>Re Intel support: That&#x27;s definitely in our plans. However, there are also many other areas where we are actively working on to add more features, fix bugs, and improve performance. When prioritizing, we typically make decisions based on what our current and potential users might need in the language. Frankly, we are not seeing a big push for Intel GPU support so far. So, currently it is not near the top of our priorities. If you (or other readers) have any input on that matter where lack of Intel support might be a blocker for testing Chapel and&#x2F;or its GPU support out, definitely let us know.<p>Re implicit serialization: To clarify; the serialization based on order-dependence is not implicit. The users should use a `for` loop if their loop is order-dependent and `foreach` (and `forall`) if their loop is order-independent. In other words, the Chapel compiler doesn&#x27;t make decisions about order-dependence. In particular, for GPU execution a `for` loop will never turn into a GPU kernel.<p>There are, however, some cases where a `foreach` does not turn into a kernel. You may be referring to those cases, but that&#x27;s not related to order-dependence. Some Chapel features cannot execute on a GPU. If your `foreach` loop&#x27;s body uses any of those features then it will not be launched as a kernel even though `foreach` signals order-independence. Now, a subset of such features that makes an order-independent loop GPU-ineligible are there because we haven&#x27;t gotten a chance to properly address them, yet. Another subset of such features will remain thwarters for a longer time and maybe forever. For example, your `foreach` loop could be calling an external host function.</div><br/><div id="38981366" class="c"><input type="checkbox" id="c-38981366" checked=""/><div class="controls bullet"><span class="by">bradcray</span><span>|</span><a href="#38962735">root</a><span>|</span><a href="#38970918">parent</a><span>|</span><a href="#38970665">next</a><span>|</span><label class="collapse" for="c-38981366">[-]</label><label class="expand" for="c-38981366">[1 more]</label></div><br/><div class="children"><div class="content">Sorry for what now appears to be a double-post.  Engin had just registered for HN, hadn&#x27;t seen his reply going through, so asked me to relay it.<p>Re-reading this Q+A this morning, I also wanted to clarify one thing, which is that when a &#x27;foreach&#x27; or &#x27;forall&#x27; does end up being executed on the CPU, that doesn&#x27;t mean it has been serialized.  &#x27;foreach&#x27; loops on the CPU are candidates for vectorization while &#x27;forall&#x27; loops typically result in multicore task-parallelism with each task also being a candidate for vectorization.</div><br/></div></div></div></div></div></div><div id="39009933" class="c"><input type="checkbox" id="c-39009933" checked=""/><div class="controls bullet"><span class="by">why_only_15</span><span>|</span><a href="#38962735">prev</a><span>|</span><a href="#39010422">next</a><span>|</span><label class="collapse" for="c-39009933">[-]</label><label class="expand" for="c-39009933">[1 more]</label></div><br/><div class="children"><div class="content">Do you have any thoughts on adding tensor core support? Tensor cores are most of what modern GPUs are used for but are devilishly hard to program well (they totally break most of CUDA&#x27;s abstractions).</div><br/></div></div><div id="39010422" class="c"><input type="checkbox" id="c-39010422" checked=""/><div class="controls bullet"><span class="by">atemerev</span><span>|</span><a href="#39009933">prev</a><span>|</span><label class="collapse" for="c-39010422">[-]</label><label class="expand" for="c-39010422">[1 more]</label></div><br/><div class="children"><div class="content">I always liked Chapel. It is one of the very few HPC-first languages (the only other one I know of is Regent). And probably the most convenient way to port or write numeric code in heterogeneous computing environments (the only other choices are C++ or Fortran).</div><br/></div></div></div></div></div></div></div></body></html>