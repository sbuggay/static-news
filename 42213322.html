<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732352514043" as="style"/><link rel="stylesheet" href="styles.css?v=1732352514043"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kubuszok.com/2019/from-string-to-ast-parsing/">From string to AST: parsing (2019)</a> <span class="domain">(<a href="https://kubuszok.com">kubuszok.com</a>)</span></div><div class="subtext"><span>sph</span> | <span>27 comments</span></div><br/><div><div id="42215533" class="c"><input type="checkbox" id="c-42215533" checked=""/><div class="controls bullet"><span class="by">KPGv2</span><span>|</span><a href="#42215683">next</a><span>|</span><label class="collapse" for="c-42215533">[-]</label><label class="expand" for="c-42215533">[1 more]</label></div><br/><div class="children"><div class="content">This was a really great read! I&#x27;m wrote the tree sitter grammar for the Unison programming language, and discovered I really like the work involved in pattern matching that writing tokenizers and parsers comes down to. It also gives you an in-depth understanding of how the language works that you&#x27;ve writing a parser for, and how tooling works.<p>Like if you have an AST with the ability to map onto code that is displayed in your IDE, the algorithm for an IDE to refactor a variable name is to traverse up the AST until you get to the variable&#x27;s declaration and then traverse all sibling trees, changing each matching name, but stopping a traversal whenever you encounter a new binding with same name. Code folding is to identify the categories of node that are &quot;foldable&quot; and then you hide every child of that node. Etc. It&#x27;s all tree traversal algorithms.<p>It gives you a deep appreciation for how powerful the tooling can be thanks to proper parsing.</div><br/></div></div><div id="42215683" class="c"><input type="checkbox" id="c-42215683" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#42215533">prev</a><span>|</span><a href="#42216080">next</a><span>|</span><label class="collapse" for="c-42215683">[-]</label><label class="expand" for="c-42215683">[1 more]</label></div><br/><div class="children"><div class="content">&gt; quadruple G=(N,Σ,P,S), where T is a finite set of nonterminal symbols, Σ a finite set of terminal symbols, P is a set of production rules and S is a start symbol.<p>I think &quot;T&quot; is supposed to be &quot;N&quot; in that sentence[1], based solely upon the further use of &quot;N&quot; nomenclature in subsequent paragraphs<p>1: <i>he said, 5 years too late into a forum just discussing the article</i></div><br/></div></div><div id="42216080" class="c"><input type="checkbox" id="c-42216080" checked=""/><div class="controls bullet"><span class="by">atan2</span><span>|</span><a href="#42215683">prev</a><span>|</span><a href="#42214198">next</a><span>|</span><label class="collapse" for="c-42216080">[-]</label><label class="expand" for="c-42216080">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice to review some of this theory after a week of coding my own interpreter. I have been studying about compilers at pikuma.com the whole week and reading this article after coding a parser is a great way of reviewing what I&#x27;ve implemented.</div><br/></div></div><div id="42214198" class="c"><input type="checkbox" id="c-42214198" checked=""/><div class="controls bullet"><span class="by">marxisttemp</span><span>|</span><a href="#42216080">prev</a><span>|</span><a href="#42214897">next</a><span>|</span><label class="collapse" for="c-42214198">[-]</label><label class="expand" for="c-42214198">[1 more]</label></div><br/><div class="children"><div class="content">I somewhat regularly stop to marvel that one of the greatest anarchist thinkers of our time is also responsible for foundational theories in linguistics that also correspond intimately with the foundational theories of computing. God bless Noam.</div><br/></div></div><div id="42214897" class="c"><input type="checkbox" id="c-42214897" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#42214198">prev</a><span>|</span><a href="#42213857">next</a><span>|</span><label class="collapse" for="c-42214897">[-]</label><label class="expand" for="c-42214897">[1 more]</label></div><br/><div class="children"><div class="content">Theory without examples is like traveling without a memory.</div><br/></div></div><div id="42213857" class="c"><input type="checkbox" id="c-42213857" checked=""/><div class="controls bullet"><span class="by">ckok</span><span>|</span><a href="#42214897">prev</a><span>|</span><a href="#42213856">next</a><span>|</span><label class="collapse" for="c-42213857">[-]</label><label class="expand" for="c-42213857">[14 more]</label></div><br/><div class="children"><div class="content">I think this makes it sound a lot more difficult than it has to be, with the formal theory.<p>When it&#x27;s really one of the most simple things if you divide it in parts and look at it from a tokenizer (string to list of tokens) and parser on top. Where the tokenizer can usually be very simple: a loop, large switch on the current character, where a choice is made on &quot;what can this be&quot;, and making it into a formal token or error. Then a simple recursive parser that can almost be a 1 to 1 copy of the (E)BNF.</div><br/><div id="42213970" class="c"><input type="checkbox" id="c-42213970" checked=""/><div class="controls bullet"><span class="by">jrop</span><span>|</span><a href="#42213857">parent</a><span>|</span><a href="#42214369">next</a><span>|</span><label class="collapse" for="c-42213970">[-]</label><label class="expand" for="c-42213970">[1 more]</label></div><br/><div class="children"><div class="content">I love writing parsers like this. Add in Pratt Parsing for operator precedence and writing parsers can be really easy.</div><br/></div></div><div id="42214369" class="c"><input type="checkbox" id="c-42214369" checked=""/><div class="controls bullet"><span class="by">detourdog</span><span>|</span><a href="#42213857">parent</a><span>|</span><a href="#42213970">prev</a><span>|</span><a href="#42217425">next</a><span>|</span><label class="collapse" for="c-42214369">[-]</label><label class="expand" for="c-42214369">[2 more]</label></div><br/><div class="children"><div class="content">I got the impression the author was trying to add higher level reasoning to the chosen term for string to AST parsing.<p>I felt that they were pointing out how the cognitive load of understanding is effected by word choice.</div><br/></div></div><div id="42217425" class="c"><input type="checkbox" id="c-42217425" checked=""/><div class="controls bullet"><span class="by">joz1-k</span><span>|</span><a href="#42213857">parent</a><span>|</span><a href="#42214369">prev</a><span>|</span><a href="#42214382">next</a><span>|</span><label class="collapse" for="c-42217425">[-]</label><label class="expand" for="c-42217425">[3 more]</label></div><br/><div class="children"><div class="content">I had exactly the same feeling as you after reading the article. And interestingly, all production parsers for all major languages are hand-written recursive descent parsers.
On the other hand, if you inspect the actual code for these production parsers (even for newer languages like Swift, Scala, Kotlin, or Rust), the complexity and amount of code is still quite staggering.</div><br/><div id="42217771" class="c"><input type="checkbox" id="c-42217771" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42213857">root</a><span>|</span><a href="#42217425">parent</a><span>|</span><a href="#42214382">next</a><span>|</span><label class="collapse" for="c-42217771">[-]</label><label class="expand" for="c-42217771">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t a large portion of the code to get friendlier messages for the user?</div><br/><div id="42219697" class="c"><input type="checkbox" id="c-42219697" checked=""/><div class="controls bullet"><span class="by">joz1-k</span><span>|</span><a href="#42213857">root</a><span>|</span><a href="#42217771">parent</a><span>|</span><a href="#42214382">next</a><span>|</span><label class="collapse" for="c-42219697">[-]</label><label class="expand" for="c-42219697">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that explains a lot of the complexity. Another reason is type checking&#x2F;inferring and making the AST detailed enough for code analysis tools, such as code hinting in IDEs.</div><br/></div></div></div></div></div></div><div id="42214382" class="c"><input type="checkbox" id="c-42214382" checked=""/><div class="controls bullet"><span class="by">antononcube</span><span>|</span><a href="#42213857">parent</a><span>|</span><a href="#42217425">prev</a><span>|</span><a href="#42214756">next</a><span>|</span><label class="collapse" for="c-42214382">[-]</label><label class="expand" for="c-42214382">[5 more]</label></div><br/><div class="children"><div class="content">It seems you are describing how functional parsers (aka parser combinators) work.<p>(BTW, there is a &quot;Parser combinators&quot; section in the featured post&#x2F;article.)</div><br/><div id="42219503" class="c"><input type="checkbox" id="c-42219503" checked=""/><div class="controls bullet"><span class="by">ckok</span><span>|</span><a href="#42213857">root</a><span>|</span><a href="#42214382">parent</a><span>|</span><a href="#42216058">next</a><span>|</span><label class="collapse" for="c-42219503">[-]</label><label class="expand" for="c-42219503">[1 more]</label></div><br/><div class="children"><div class="content">I believe the proper term for what i am describing is a recursive descent parser. With which it is also quite doable to generate proper error handling and even recovery. Some form of this is used in almost every production language I think.<p>It has been years since I&#x27;ve written a proper parser but before that every time I had to write one I tried the latest and greatest first. ANTLR, coco&#x2F;r, combinators. All the generated ones seemed to have a fatal flaw that hand writing didnt have. For example good error handling seemed almost impossible, very slow due to Infinite look ahead or they were almost impossible to debug to find an error in the input schema.<p>In the end hand crafting seems to be faster and simpler. Ymmv.<p>My point about the article was mostly that all the formal theory is nice but all it does is scare away people, while parsing is probably the simplest thing about writing a compiler.</div><br/></div></div><div id="42216058" class="c"><input type="checkbox" id="c-42216058" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42213857">root</a><span>|</span><a href="#42214382">parent</a><span>|</span><a href="#42219503">prev</a><span>|</span><a href="#42214756">next</a><span>|</span><label class="collapse" for="c-42216058">[-]</label><label class="expand" for="c-42216058">[3 more]</label></div><br/><div class="children"><div class="content">The bad news about those is that it&#x27;s easy to mindlessly create a parser that runs on exponential time.<p>The good news is that this happens in the grammar definition. So once you define your language well, you don&#x27;t have to watch for it anymore.</div><br/><div id="42216739" class="c"><input type="checkbox" id="c-42216739" checked=""/><div class="controls bullet"><span class="by">antononcube</span><span>|</span><a href="#42213857">root</a><span>|</span><a href="#42216058">parent</a><span>|</span><a href="#42214756">next</a><span>|</span><label class="collapse" for="c-42216739">[-]</label><label class="expand" for="c-42216739">[2 more]</label></div><br/><div class="children"><div class="content">Insightful!<p>Do you know of any &quot;large scale&quot; research on this? I.e. analysis of multiple related projects and&#x2F;or of &quot;real life stories.&quot;<p>(I agree regardless.)</div><br/><div id="42217732" class="c"><input type="checkbox" id="c-42217732" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42213857">root</a><span>|</span><a href="#42216739">parent</a><span>|</span><a href="#42214756">next</a><span>|</span><label class="collapse" for="c-42217732">[-]</label><label class="expand" for="c-42217732">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about any real-world study. But there are people complaining about it from time to time, and it&#x27;s quite obvious from the theory.</div><br/></div></div></div></div></div></div></div></div><div id="42214756" class="c"><input type="checkbox" id="c-42214756" checked=""/><div class="controls bullet"><span class="by">DemocracyFTW2</span><span>|</span><a href="#42213857">parent</a><span>|</span><a href="#42214382">prev</a><span>|</span><a href="#42215962">next</a><span>|</span><label class="collapse" for="c-42214756">[-]</label><label class="expand" for="c-42214756">[1 more]</label></div><br/><div class="children"><div class="content">IMHO it gets even better when you can use regular expressions and write a &#x27;modal&#x27; parser where each mode is responsible for a certain sub-grammar, like string literals. JavaScript added the sticky flag (y) to make this even simpler.</div><br/></div></div></div></div><div id="42213856" class="c"><input type="checkbox" id="c-42213856" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#42213857">prev</a><span>|</span><a href="#42214179">next</a><span>|</span><label class="collapse" for="c-42213856">[-]</label><label class="expand" for="c-42213856">[4 more]</label></div><br/><div class="children"><div class="content">&gt; All is set and done<p>For the record, the phrase is &#x27;when all is <i>said</i> and done&#x27;[1].<p>[1]: <a href="https:&#x2F;&#x2F;en.wiktionary.org&#x2F;wiki&#x2F;when_all_is_said_and_done" rel="nofollow">https:&#x2F;&#x2F;en.wiktionary.org&#x2F;wiki&#x2F;when_all_is_said_and_done</a></div><br/><div id="42214371" class="c"><input type="checkbox" id="c-42214371" checked=""/><div class="controls bullet"><span class="by">detourdog</span><span>|</span><a href="#42213856">parent</a><span>|</span><a href="#42215504">next</a><span>|</span><label class="collapse" for="c-42214371">[-]</label><label class="expand" for="c-42214371">[1 more]</label></div><br/><div class="children"><div class="content">I thought it was a nice pun:)</div><br/></div></div><div id="42215504" class="c"><input type="checkbox" id="c-42215504" checked=""/><div class="controls bullet"><span class="by">KPGv2</span><span>|</span><a href="#42213856">parent</a><span>|</span><a href="#42214371">prev</a><span>|</span><a href="#42215964">next</a><span>|</span><label class="collapse" for="c-42215504">[-]</label><label class="expand" for="c-42215504">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I was extremely triggered.</div><br/></div></div></div></div><div id="42214179" class="c"><input type="checkbox" id="c-42214179" checked=""/><div class="controls bullet"><span class="by">antononcube</span><span>|</span><a href="#42213856">prev</a><span>|</span><a href="#42215413">next</a><span>|</span><label class="collapse" for="c-42214179">[-]</label><label class="expand" for="c-42214179">[2 more]</label></div><br/><div class="children"><div class="content">Very long write-up! If you read it and like the content, you might consider ditching Python and start using Raku a lot and often.</div><br/></div></div></div></div></div></div></div></body></html>