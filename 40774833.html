<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719478854745" as="style"/><link rel="stylesheet" href="styles.css?v=1719478854745"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://developers.redhat.com/articles/2022/09/17/gccs-new-fortification-level">GCC&#x27;s new fortification level: The gains and costs</a> <span class="domain">(<a href="https://developers.redhat.com">developers.redhat.com</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>48 comments</span></div><br/><div><div id="40805633" class="c"><input type="checkbox" id="c-40805633" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#40805669">next</a><span>|</span><label class="collapse" for="c-40805633">[-]</label><label class="expand" for="c-40805633">[15 more]</label></div><br/><div class="children"><div class="content">&gt; the program continued using the same pointer, not the realloc call result, since the old pointer did not change<p>&gt; In this context, it is a bug in the application<p>This is a non-intuitive result by the normal lens C pointers are viewed by; these two pointers compared equal, how could using one differ from using the other? Pointer provenance rears its ugly head here though; one of those &quot;pointers that have the same value&quot;&#x27;s provenance is different to the other. By the standard, they _are_ allowed to be treated differently, and honestly the standard requires it.<p><a href="https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2020&#x2F;12&#x2F;14&#x2F;provenance.html" rel="nofollow">https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2020&#x2F;12&#x2F;14&#x2F;provenance.html</a> is pretty accessible, and shockingly on point: &quot;just because two pointers point to the same address, does not mean they are equal in the sense that they can be used interchangeably&quot;.<p>EDIT: spelling</div><br/><div id="40805770" class="c"><input type="checkbox" id="c-40805770" checked=""/><div class="controls bullet"><span class="by">mahkoh</span><span>|</span><a href="#40805633">parent</a><span>|</span><a href="#40806610">next</a><span>|</span><label class="collapse" for="c-40805770">[-]</label><label class="expand" for="c-40805770">[6 more]</label></div><br/><div class="children"><div class="content">Provenance might be used as justification now but the actual rules are simpler and stricter. After freeing (or reallocing) a pointer, the application must not inspect the pointer value anymore. Even `new_pointer == old_pointer` is not allowed.<p>IIRC, one justification for this was to account for systems with non-flat memory where inspecting the value of the old pointer might cause a processor exception.</div><br/><div id="40808412" class="c"><input type="checkbox" id="c-40808412" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40805770">parent</a><span>|</span><a href="#40806244">next</a><span>|</span><label class="collapse" for="c-40808412">[-]</label><label class="expand" for="c-40808412">[1 more]</label></div><br/><div class="children"><div class="content">Would it be acceptable to save the old address as a uintptr_t before the realloc(), and compare it with the new one after?</div><br/></div></div><div id="40806244" class="c"><input type="checkbox" id="c-40806244" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40805770">parent</a><span>|</span><a href="#40808412">prev</a><span>|</span><a href="#40806143">next</a><span>|</span><label class="collapse" for="c-40806244">[-]</label><label class="expand" for="c-40806244">[1 more]</label></div><br/><div class="children"><div class="content">Wow, look, move semantics! An advanced compiler could even check for that...</div><br/></div></div><div id="40806143" class="c"><input type="checkbox" id="c-40806143" checked=""/><div class="controls bullet"><span class="by">RustyRussell</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40805770">parent</a><span>|</span><a href="#40806244">prev</a><span>|</span><a href="#40805808">next</a><span>|</span><label class="collapse" for="c-40806143">[-]</label><label class="expand" for="c-40806143">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Even `new_pointer == old_pointer` is not allowed.<p>This is legal. But dereferencing old_pointer even after this check had passed is undefined.</div><br/><div id="40807009" class="c"><input type="checkbox" id="c-40807009" checked=""/><div class="controls bullet"><span class="by">anttihaapala</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40806143">parent</a><span>|</span><a href="#40805808">next</a><span>|</span><label class="collapse" for="c-40807009">[-]</label><label class="expand" for="c-40807009">[1 more]</label></div><br/><div class="children"><div class="content">No, it is not, and it has never been OK for as long as C has been standardized by ANSI or ISO.<p>C89 says that &quot;The value of a pointer that refers to freed space is indeterminate.&quot; and that behavior is undefined &quot;upon use ... of indeterminately-valued objects&quot;, hence a compiled program can e.g. behave as if `new_pointer == old_pointer` even though the object was relocated in memory.</div><br/></div></div></div></div><div id="40805808" class="c"><input type="checkbox" id="c-40805808" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40805770">parent</a><span>|</span><a href="#40806143">prev</a><span>|</span><a href="#40806610">next</a><span>|</span><label class="collapse" for="c-40805808">[-]</label><label class="expand" for="c-40805808">[1 more]</label></div><br/><div class="children"><div class="content">It also makes sense for an allocator that can satisfy new allocations with recently freed allocations.</div><br/></div></div></div></div><div id="40806610" class="c"><input type="checkbox" id="c-40806610" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#40805633">parent</a><span>|</span><a href="#40805770">prev</a><span>|</span><a href="#40805669">next</a><span>|</span><label class="collapse" for="c-40806610">[-]</label><label class="expand" for="c-40806610">[8 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t mean that but maybe it actually should. The fact these perfectly good intuitions don&#x27;t apply because of completely irrelevant reasons is a huge cause of friction and bugs.<p>Your article contains the perfect example:<p>&gt; UB on integer overflow is a compiler-only concept<p>&gt; every target supported by the compiler will do the obvious thing and just produce an overflowing result<p>Pretty much every computer that matters works the way you expect it to: the value will overflow, some flag will be set, etc. The compiler couldn&#x27;t care less though. The compiler decrees that it shall be undefined. You know it works but it doesn&#x27;t because the compiler refuses to do what you expect it to do because it&#x27;s &quot;undefined&quot;.<p>Well then just define it for god&#x27;s sake. I&#x27;m so tired of the uncertainty. Tired of playing these games with the compiler. Undefined? I don&#x27;t even want to read that word ever again.<p>Let&#x27;s define this right now.<p><pre><code>  -fwrapv
</code></pre>
There. It is now defined to be what everyone expects and wants. Now the optimizer won&#x27;t be getting &quot;clever&quot; with this and generating complete garbage code as result. The compiler&#x27;s optimizer is no longer your enemy in this case. It won&#x27;t be erroneously optimizing entire loops to some random constant anymore. One would think they&#x27;d emit a warning instead in these cases but no.<p>Strict aliasing is yet another massive pain that you need to deal with because of compilers and their &quot;optimizations&quot;. People have actually told me to &quot;launder&quot; pointers through asm statements so the compiler can&#x27;t make nonsense assumptions about that stuff.<p><i>This is C.</i> We do things like write memory allocators. Of course we&#x27;re going to alias stuff. I have a structure type, I have a byte buffer with the data, of course I want to overlay the type on the byte buffer and just access it directly. Why is it that the compiler just doesn&#x27;t let me reinterpret memory however I want? Compiler has no business making my life hell because of this.<p>Turns out the C standard prescribes some &quot;strict aliasing&quot; nonsense because Fortran has it or some other reason nobody really cares about. If you&#x27;re doing anything at all in C you&#x27;re probably violating this.<p><pre><code>  -fno-strict-aliasing
</code></pre>
There. You can now do what you want to do without the compiler getting all clever about it and ruining your day with nonsense code generation. Now it won&#x27;t be reordering your code into nonsense just because it can &quot;prove&quot; that two pointers can&#x27;t be equal even though you literally assigned one pointer to the other.<p>Over time I&#x27;ve built up this little collection of C compiler flags and they&#x27;ve become unconditional overrides in all my makefiles. No matter what users pass in via CFLAGS or whatever, these little things still get disabled. I have no idea what the performance impact is and honestly I don&#x27;t care.<p>There&#x27;s quite a lot of documented compiler flags, I couldn&#x27;t evaulate every single one of them. If anyone here knows of any other useful flags that define the undefined, please reply to this comment. I&#x27;ll add them to my makefiles without thinking twice.</div><br/><div id="40808539" class="c"><input type="checkbox" id="c-40808539" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40806610">parent</a><span>|</span><a href="#40807983">next</a><span>|</span><label class="collapse" for="c-40808539">[-]</label><label class="expand" for="c-40808539">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It won&#x27;t be erroneously optimizing entire loops to some random constant anymore. One would think they&#x27;d emit a warning instead in these cases but no.<p>It also won&#x27;t be optimizing other loops that you want it to optimize. Turns out it&#x27;s a tradeoff and lots of people choose C and C++ exactly because of this focus on speed..<p>&gt; This is C. We do things like write memory allocators. Of course we&#x27;re going to alias stuff. I have a structure type, I have a byte buffer with the data, of course I want to overlay the type on the byte buffer and just access it directly. Why is it that the compiler just doesn&#x27;t let me reinterpret memory however I want? Compiler has no business making my life hell because of this.<p>char is allowed to alias other types. Other types of aliasing are rarely needed and you can always memcpy the contents if you really do need to.<p>&gt; Turns out the C standard prescribes some &quot;strict aliasing&quot; nonsense because Fortran has it or some other reason nobody really cares about. If you&#x27;re doing anything at all in C you&#x27;re probably violating this.<p>No prescribes it because otherwise it would need to load from memory on every pointer dereference after something completely different has been written to. This is obviously undesirable if you care even one bit about performance.<p>None of these things are the compiler fighting you. In fact it is trying to help you. But you seem to want something closer to high-level assmebler and you can have that: don&#x27;t use and optimizing compiler or use flags to change the language semantics to your taste. That doesn&#x27;t make the default semantics bad though.<p>&gt; I have no idea what the performance impact is and honestly I don&#x27;t care.<p>Then C and C++ are simply not made for you. There are plenty of &quot;safe&quot; languages for people who don&#x27;t care about the perfomance impact.<p>&gt; If anyone here knows of any other useful flags that define the undefined, please reply to this comment. I&#x27;ll add them to my makefiles without thinking twice.<p>Try -O0.</div><br/></div></div><div id="40807983" class="c"><input type="checkbox" id="c-40807983" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40806610">parent</a><span>|</span><a href="#40808539">prev</a><span>|</span><a href="#40807099">next</a><span>|</span><label class="collapse" for="c-40807983">[-]</label><label class="expand" for="c-40807983">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I have no idea what the performance impact is and honestly I don&#x27;t care.<p>Then why are you writing C? You could be writing some other, higher-level language instead if performance is not your top priority.<p>Perhaps you use C because you must interact with other C code; many languages have quite usable C FFI. If you must use C because your code is part of another project (e.g. the Linux kernel), you don&#x27;t have control over the flags anyway. If you must use C because of low memory availability (e.g. a microcontroller), then perhaps fine — but that&#x27;s quite niche. (And there&#x27;s always Rust.)</div><br/><div id="40808138" class="c"><input type="checkbox" id="c-40808138" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40807983">parent</a><span>|</span><a href="#40807099">next</a><span>|</span><label class="collapse" for="c-40808138">[-]</label><label class="expand" for="c-40808138">[1 more]</label></div><br/><div class="children"><div class="content">C was hardly a performance juggernaut in the 1980&#x27;s, any junior Assembly coder could easily outperform the outcome of the C compilers.<p>It was by exploring UB to the extreme those compilers optimizers do nowadays, that such language finally got the fame it has 40 years later.<p>&quot;Oh, it was quite a while ago. I kind of stopped when C came out. That was a big blow. We were making so much good progress on optimizations and transformations. We were getting rid of just one nice problem after another. When C came out, at one of the SIGPLAN compiler conferences, there was a debate between Steve Johnson from Bell Labs, who was supporting C, and one of our people, Bill Harrison, who was working on a project that I had at that time supporting automatic optimization...The nubbin of the debate was Steve&#x27;s defense of not having to build optimizers anymore because the programmer would take care of it. That it was really a programmer&#x27;s issue.... Seibel: Do you think C is a reasonable language if they had restricted its use to operating-system kernels? Allen: Oh, yeah. That would have been fine. And, in fact, you need to have something like that, something where experts can really fine-tune without big bottlenecks because those are key problems to solve. By 1960, we had a long list of amazing languages: Lisp, APL, Fortran, COBOL, Algol 60. These are higher-level than C. We have seriously regressed, since C developed. C has destroyed our ability to advance the state of the art in automatic optimization, automatic parallelization, automatic mapping of a high-level language to the machine. This is one of the reasons compilers are ... basically not taught much anymore in the colleges and universities.&quot;<p>-- Fran Allen interview, Excerpted from: Peter Seibel. Coders at Work: Reflections on the Craft of Programming</div><br/></div></div></div></div><div id="40807099" class="c"><input type="checkbox" id="c-40807099" checked=""/><div class="controls bullet"><span class="by">mistercow</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40806610">parent</a><span>|</span><a href="#40807983">prev</a><span>|</span><a href="#40805669">next</a><span>|</span><label class="collapse" for="c-40807099">[-]</label><label class="expand" for="c-40807099">[4 more]</label></div><br/><div class="children"><div class="content">It’s been a long time since I worked with C, but my recollection was that a) strict aliasing allows for optimizations that are actually worthwhile, and b) it’s really easy to type pun in a defined way using unions anyway.</div><br/><div id="40808549" class="c"><input type="checkbox" id="c-40808549" checked=""/><div class="controls bullet"><span class="by">brucketeero</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40807099">parent</a><span>|</span><a href="#40808262">next</a><span>|</span><label class="collapse" for="c-40808549">[-]</label><label class="expand" for="c-40808549">[1 more]</label></div><br/><div class="children"><div class="content">The optimizations can easily be gained back by &quot;manual&quot; loading and storing to temporary local variables.<p>The classical:<p><pre><code>  int foo(float *f, int *x) {
    *x = 2;
    *f = 3.0f;
    return *x; &#x2F;&#x2F; oh no, without typed based aliasing I have to load x again!
  }
</code></pre>
Can obviously be rewritten to:<p><pre><code>  int foo(float *f, int *x) {
    int z = 2;
    *x = z;
    *f = 3.0f;
    return z; &#x2F;&#x2F; ah, thank you programmer, z has not had its address taken, it&#x27;s obviously 2.
  }</code></pre></div><br/></div></div><div id="40808262" class="c"><input type="checkbox" id="c-40808262" checked=""/><div class="controls bullet"><span class="by">abainbridge</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40807099">parent</a><span>|</span><a href="#40808549">prev</a><span>|</span><a href="#40805669">next</a><span>|</span><label class="collapse" for="c-40808262">[-]</label><label class="expand" for="c-40808262">[2 more]</label></div><br/><div class="children"><div class="content">&gt; strict aliasing allows for optimizations that are actually worthwhile<p>I don&#x27;t think there are many sensible, real world examples.<p>A nice explanation of the optimizations the strict-aliasing rule allows: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;99010&#x2F;66088" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;99010&#x2F;66088</a><p>The example given is:<p><pre><code>    typedef struct Msg {
        unsigned int a;
        unsigned int b;
    } Msg;

    void SendWord(uint32_t);

    int main(void) {
        &#x2F;&#x2F; Get a 32-bit buffer from the system
        uint32_t* buff = malloc(sizeof(Msg));

        &#x2F;&#x2F; Alias that buffer through message
        Msg* msg = (Msg*)(buff);

        &#x2F;&#x2F; Send a bunch of messages
        for (int i = 0; i &lt; 10; ++i) {
            msg-&gt;a = i;
            msg-&gt;b = i+1;
            SendWord(buff[0]);
            SendWord(buff[1]);
        }
    }
</code></pre>
The explanation is: with strict aliasing the compiler doesn&#x27;t have to think about inserting instructions to reload the contents of buff every iteration of the loop.<p>The problem I have is that when we re-write the example to use a union, the generated code is the same regardless of whether we pass -fno-strict-aliasing or not. So this isn&#x27;t a working example of an optimization enabled by strict aliasing. It makes no difference whether I build it with clang or gcc, for x86-64 or arm7. I don&#x27;t think I did it wrong. We still have a memory load instruction in the loop. See <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;9xzq87d1r" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;9xzq87d1r</a><p>Knowing whether a C compiler will make an optimization or not is all but impossible. The simplest and most reliable solution in this case is to do the loop hoisting optimization manually:<p><pre><code>        uint32_t buff0 = buff[0];
        unit32_t buff1 = buff[1];
        for (int i = 0; i &lt; 10; ++i) {
            msg-&gt;a = i;
            msg-&gt;b = i+1;
            SendWord(buff0);
            SendWord(buff1);
        }
</code></pre>
Doing so removes the load instruction from the loop. See <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ecGrvb3se" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ecGrvb3se</a><p>Note 1: The first thing that goes wrong for Stackoverflow example is that the compiler spots that malloc returns uninitialized data, so it can omit the reloading of buff in the loop anyway. In fact it removes the malloc too. Here&#x27;s clang 18 doing that <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;97a8K73ss" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;97a8K73ss</a>. I had to replace malloc with an undefined GetBuff() function, so the compiler couldn&#x27;t assume the returned data was unintialized.<p>Note 2: Once we&#x27;re calling GetBuff() instead of malloc(), the compiler has to assume that SendWord(buff[0]) could change buff, and therefore it has to reload it in the loop even with strict-aliasing enabled.</div><br/><div id="40808455" class="c"><input type="checkbox" id="c-40808455" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#40805633">root</a><span>|</span><a href="#40808262">parent</a><span>|</span><a href="#40805669">next</a><span>|</span><label class="collapse" for="c-40808455">[-]</label><label class="expand" for="c-40808455">[1 more]</label></div><br/><div class="children"><div class="content">How does the version with buf0 and buf1 work? It looks like it sends always the same two values...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40805669" class="c"><input type="checkbox" id="c-40805669" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#40805633">prev</a><span>|</span><a href="#40805339">next</a><span>|</span><label class="collapse" for="c-40805669">[-]</label><label class="expand" for="c-40805669">[1 more]</label></div><br/><div class="children"><div class="content">For a comprehensive set of recommended compiler options for hardening C and C++ programs, see this OpenSSF guide:
<a href="https:&#x2F;&#x2F;best.openssf.org&#x2F;Compiler-Hardening-Guides&#x2F;Compiler-Options-Hardening-Guide-for-C-and-C++.html" rel="nofollow">https:&#x2F;&#x2F;best.openssf.org&#x2F;Compiler-Hardening-Guides&#x2F;Compiler-...</a></div><br/></div></div><div id="40805339" class="c"><input type="checkbox" id="c-40805339" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40805669">prev</a><span>|</span><a href="#40805040">next</a><span>|</span><label class="collapse" for="c-40805339">[-]</label><label class="expand" for="c-40805339">[12 more]</label></div><br/><div class="children"><div class="content">The `realloc` problem isn&#x27;t the only one - it also breaks many formerly-well-defined programs that use `malloc_usable_size`.<p>Instead of fixing this, the developers behind the &quot;dynamic object size&quot; push have been <i>changing the documentation</i> to declare any use of `malloc_usable_size` buggy even though it used to be explicitly documented as safe.<p>I suspect that GCC&#x27;s optimization passes will break even C-standard-compliant use of `realloc`, similar to how ASAN can break due to dynamic equality checks between pointers of different provenance.<p>Life would be <i>much</i> simpler for many of us if the standards committee bothered to standardize a function that says &quot;give me a buffer of semi-arbitrary size and tell me how big it is; I promise to resize it later&quot;, which is <i>very</i> widely intended. An explicit &quot;realloc in place only, else fail&quot; would also make many more useful programs feasible to write.</div><br/><div id="40805585" class="c"><input type="checkbox" id="c-40805585" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#40805339">parent</a><span>|</span><a href="#40808589">prev</a><span>|</span><a href="#40805040">next</a><span>|</span><label class="collapse" for="c-40805585">[-]</label><label class="expand" for="c-40805585">[10 more]</label></div><br/><div class="children"><div class="content">&gt; give me a buffer of semi-arbitrary size and tell me how big it is; I promise to resize it later<p>I&#x27;m not sure how you could use this usefully. If you don&#x27;t care what size you get, why would you allocate in the first place? And if you do have a minimum size you need right now, and a need for it to be bigger later, isn&#x27;t that what a malloc&#x2F;realloc dance is for?</div><br/><div id="40805695" class="c"><input type="checkbox" id="c-40805695" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40805585">parent</a><span>|</span><a href="#40805680">next</a><span>|</span><label class="collapse" for="c-40805695">[-]</label><label class="expand" for="c-40805695">[3 more]</label></div><br/><div class="children"><div class="content">Cases where the exact buffer size doesn&#x27;t matter are <i>ubiquitous</i>, for example:<p>* read a file(-like) in streaming mode. Whenever the buffer is empty, fill it. The actual allocated size does not matter at all for most kinds of file.<p>* push objects onto a vector when the capacity is used up, reallocate at a larger size and keep pushing. The actual allocated capacity doesn&#x27;t matter at any point.<p>* implement a bloom filter for approximate set membership. If the allocator happens to give you a little more than your mathematical estimation for the chances you want, you might as well use it.<p>In fact, I dare say: <i>every</i> allocation size that is neither `0` or `sizeof(T)` doesn&#x27;t fundamentally care about the size (a given <i>implementation</i> may care, but if the standard bothered to implement useful new functionality we would change the implementations).<p>This is unlike, say, my desire for skewed-alignment allocators, which is but not particularly useful for most programs.</div><br/><div id="40808597" class="c"><input type="checkbox" id="c-40808597" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40805695">parent</a><span>|</span><a href="#40806219">next</a><span>|</span><label class="collapse" for="c-40808597">[-]</label><label class="expand" for="c-40808597">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In fact, I dare say: every allocation size that is neither `0` or `sizeof(T)` doesn&#x27;t fundamentally care about the size<p>Not true? When you copy an array that is passed to you, you want the copy to the the same size. No more (that wastes memory) and no less (then you don&#x27;t have a copy), just as with sizeof(T).</div><br/></div></div><div id="40806219" class="c"><input type="checkbox" id="c-40806219" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40805695">parent</a><span>|</span><a href="#40808597">prev</a><span>|</span><a href="#40805680">next</a><span>|</span><label class="collapse" for="c-40806219">[-]</label><label class="expand" for="c-40806219">[1 more]</label></div><br/><div class="children"><div class="content">I hadn&#x27;t thought about the `sizeof(T)` point before, and I can think of a handful of exceptions, but it&#x27;s a great and expressive rule of thumb.</div><br/></div></div></div></div><div id="40805680" class="c"><input type="checkbox" id="c-40805680" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40805585">parent</a><span>|</span><a href="#40805695">prev</a><span>|</span><a href="#40808466">next</a><span>|</span><label class="collapse" for="c-40805680">[-]</label><label class="expand" for="c-40805680">[5 more]</label></div><br/><div class="children"><div class="content">Example: reading a file line-by-line. You don’t, can’t, know how big a line is. Your best option is to allocate some random chunk of memory, like 4 kilobytes, read 4 kilobytes from the file into memory, and see if you happened across a newline in there. If you did, shuffle everything around a little &#x2F; realloc &#x2F; ringbuffer shenanigans; do your favourite. If you didn’t, make the buffer bigger (by 1.5x? 2x? Log2x?), and try again.<p>This dance is super common with variable length protocols over unframed streams - ie, most things over tcp. So this is an exceptionally common pattern in IO operations.<p>Other common times this pattern happens: finding all items in a list that satisfy a predicate; tracking items a user has added to an interface; cycle detection in graphs; …</div><br/><div id="40806015" class="c"><input type="checkbox" id="c-40806015" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40805680">parent</a><span>|</span><a href="#40808466">next</a><span>|</span><label class="collapse" for="c-40806015">[-]</label><label class="expand" for="c-40806015">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this or the sibling would be improved with a function that gave you an arbitrarily sized allocation where you also need to query the size of that allocation though? In all the cases you need to know what the size of the buffer is, even though you don&#x27;t care whether it&#x27;s 1kb, 4kb, or 8kb (although I imagine you&#x27;d care if you got 16b or 16gb)</div><br/><div id="40806180" class="c"><input type="checkbox" id="c-40806180" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40806015">parent</a><span>|</span><a href="#40806228">next</a><span>|</span><label class="collapse" for="c-40806180">[-]</label><label class="expand" for="c-40806180">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about querying the size, it&#x27;s about what the allocator has available without having to ask the operating system for new pages.<p>It&#x27;s got a contiguous block of 6371 bytes? Cool I&#x27;ll take that, the specific size didn&#x27;t matter that much.</div><br/></div></div><div id="40806228" class="c"><input type="checkbox" id="c-40806228" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40806015">parent</a><span>|</span><a href="#40806180">prev</a><span>|</span><a href="#40808466">next</a><span>|</span><label class="collapse" for="c-40806228">[-]</label><label class="expand" for="c-40806228">[2 more]</label></div><br/><div class="children"><div class="content">E.g. &quot;Give me something in the ballpark of 4 KiB; more is OK, but tell me how much&quot;.<p>It would allow the allocator to return a chunk it has handy, instead of cutting it to size and fragmenting things, only to be asked to make the chunk larger a few microseconds later.<p>It will save both on housekeeping and fragmentation handling if the caller knows that the chunk will <i>likely</i> need to grow.</div><br/><div id="40806510" class="c"><input type="checkbox" id="c-40806510" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40806228">parent</a><span>|</span><a href="#40808466">next</a><span>|</span><label class="collapse" for="c-40806510">[-]</label><label class="expand" for="c-40806510">[1 more]</label></div><br/><div class="children"><div class="content">C++23 added `allocate_at_least`: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;allocator_traits&#x2F;allocate_at_least" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;allocator_traits&#x2F;al...</a><p>I&#x27;m not sure if any standard libraries have an implementation that takes advantage of the &quot;at least&quot; yet.</div><br/></div></div></div></div></div></div></div></div><div id="40808466" class="c"><input type="checkbox" id="c-40808466" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#40805339">root</a><span>|</span><a href="#40805585">parent</a><span>|</span><a href="#40805680">prev</a><span>|</span><a href="#40805040">next</a><span>|</span><label class="collapse" for="c-40808466">[-]</label><label class="expand" for="c-40808466">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a performance optimization for growing datastructures. If you can use all the space that was actually allocated, you can (on average) call realloc less often when the container is growing dynamically.</div><br/></div></div></div></div></div></div><div id="40805040" class="c"><input type="checkbox" id="c-40805040" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40805339">prev</a><span>|</span><a href="#40805731">next</a><span>|</span><label class="collapse" for="c-40805040">[-]</label><label class="expand" for="c-40805040">[4 more]</label></div><br/><div class="children"><div class="content">I would imagine false positives could be a huge problem. The behavior if a violation is detected is to gracefully terminate the program, so you could end up with more (but less exploitable) crashes than without FORTIFY_SOURCE.</div><br/><div id="40805049" class="c"><input type="checkbox" id="c-40805049" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40805040">parent</a><span>|</span><a href="#40805731">next</a><span>|</span><label class="collapse" for="c-40805049">[-]</label><label class="expand" for="c-40805049">[3 more]</label></div><br/><div class="children"><div class="content">Just to clarify: false positives in the sense that memory safety is violated intentionally as described in the article with relation to realloc and similar hacks, which would normally not cause problems.</div><br/><div id="40806874" class="c"><input type="checkbox" id="c-40806874" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#40805040">root</a><span>|</span><a href="#40805049">parent</a><span>|</span><a href="#40805731">next</a><span>|</span><label class="collapse" for="c-40806874">[-]</label><label class="expand" for="c-40806874">[2 more]</label></div><br/><div class="children"><div class="content">If you use a pointer that’s been realloc’d, then I would not be surprised at all if gcc simply deletes the call to realloc.</div><br/><div id="40807928" class="c"><input type="checkbox" id="c-40807928" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40805040">root</a><span>|</span><a href="#40806874">parent</a><span>|</span><a href="#40805731">next</a><span>|</span><label class="collapse" for="c-40807928">[-]</label><label class="expand" for="c-40807928">[1 more]</label></div><br/><div class="children"><div class="content">I would be surprised in the general case. Realloc does have side effects and the size parameter can be known at runtime only, etc.</div><br/></div></div></div></div></div></div></div></div><div id="40805731" class="c"><input type="checkbox" id="c-40805731" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#40805040">prev</a><span>|</span><a href="#40804924">next</a><span>|</span><label class="collapse" for="c-40805731">[-]</label><label class="expand" for="c-40805731">[2 more]</label></div><br/><div class="children"><div class="content">Title should be: GCC&#x27;s new (2022) fortification level... ;)</div><br/><div id="40806137" class="c"><input type="checkbox" id="c-40806137" checked=""/><div class="controls bullet"><span class="by">Fnoord</span><span>|</span><a href="#40805731">parent</a><span>|</span><a href="#40804924">next</a><span>|</span><label class="collapse" for="c-40806137">[-]</label><label class="expand" for="c-40806137">[1 more]</label></div><br/><div class="children"><div class="content">Article is from September 17, 2022, back then it was new. The HN title should -as HN guidelines state- include the year (2022) if it is not equal to the current one.</div><br/></div></div></div></div><div id="40804924" class="c"><input type="checkbox" id="c-40804924" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#40805731">prev</a><span>|</span><a href="#40803717">next</a><span>|</span><label class="collapse" for="c-40804924">[-]</label><label class="expand" for="c-40804924">[6 more]</label></div><br/><div class="children"><div class="content">Just curious, does anyone run with _FORTIFY_SOURCE=3 in production? Did you catch any overflows because of it, and most importantly, is there a noticeable performance degradation?</div><br/><div id="40805357" class="c"><input type="checkbox" id="c-40805357" checked=""/><div class="controls bullet"><span class="by">forbiddenlake</span><span>|</span><a href="#40804924">parent</a><span>|</span><a href="#40805083">next</a><span>|</span><label class="collapse" for="c-40805357">[-]</label><label class="expand" for="c-40805357">[1 more]</label></div><br/><div class="children"><div class="content">Arch Linux switched to it last year<p><a href="https:&#x2F;&#x2F;rfc.archlinux.page&#x2F;0017-increase-fortification-level&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rfc.archlinux.page&#x2F;0017-increase-fortification-level...</a></div><br/></div></div><div id="40805083" class="c"><input type="checkbox" id="c-40805083" checked=""/><div class="controls bullet"><span class="by">9659</span><span>|</span><a href="#40804924">parent</a><span>|</span><a href="#40805357">prev</a><span>|</span><a href="#40803717">next</a><span>|</span><label class="collapse" for="c-40805083">[-]</label><label class="expand" for="c-40805083">[4 more]</label></div><br/><div class="children"><div class="content">This brings up a question.  I think we can all agree that detecting an overrun shows a fault in the system.  But does it create an error?<p>Could this could be changed to where the overflow does not cause an abort; rather the next read of that location, without a corresponding legal write causes the abort.  A buffer overrun does not mean the answer is wrong, but the use of memory that was overrun will.<p>In that case, production or not, you would want an abort.  The answer is wrong!<p>(Perhaps this makes no sense.  If so, sorry, the idea just came to me after reading the article.)</div><br/><div id="40805139" class="c"><input type="checkbox" id="c-40805139" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40804924">root</a><span>|</span><a href="#40805083">parent</a><span>|</span><a href="#40803717">next</a><span>|</span><label class="collapse" for="c-40805139">[-]</label><label class="expand" for="c-40805139">[3 more]</label></div><br/><div class="children"><div class="content">Overrunning the buffer means your program&#x27;s behaviour is undefined. Continuing to function at all, much less doing what you wanted, merely means you got lucky with the compiler this time.</div><br/><div id="40807774" class="c"><input type="checkbox" id="c-40807774" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40804924">root</a><span>|</span><a href="#40805139">parent</a><span>|</span><a href="#40803717">next</a><span>|</span><label class="collapse" for="c-40807774">[-]</label><label class="expand" for="c-40807774">[2 more]</label></div><br/><div class="children"><div class="content">I tend to argue that continuing to function after a memory overrun is _unlucky_ because it&#x27;s better to have it fail loudly so you know to fix it instead of it potentially not noticing subtly incorrect behavior.</div><br/><div id="40808634" class="c"><input type="checkbox" id="c-40808634" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40804924">root</a><span>|</span><a href="#40807774">parent</a><span>|</span><a href="#40803717">next</a><span>|</span><label class="collapse" for="c-40808634">[-]</label><label class="expand" for="c-40808634">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also much easier to fix when you know where the overrun occurs compared to getting an abort on a random access later.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40803717" class="c"><input type="checkbox" id="c-40803717" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40804924">prev</a><span>|</span><a href="#40806772">next</a><span>|</span><label class="collapse" for="c-40803717">[-]</label><label class="expand" for="c-40803717">[3 more]</label></div><br/><div class="children"><div class="content">(2022)</div><br/><div id="40804274" class="c"><input type="checkbox" id="c-40804274" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#40803717">parent</a><span>|</span><a href="#40806772">next</a><span>|</span><label class="collapse" for="c-40804274">[-]</label><label class="expand" for="c-40804274">[2 more]</label></div><br/><div class="children"><div class="content">It also doesn’t deliver what it promises, as it doesn’t discuss the cost well. The only thing it states is that it increases code size, but it doesn’t given give numbers, and the header <i>“The gains of improved security coverage outweigh the cost”</i> doesn’t describe its content, which says:<p><i>“We need a proper study of performance and code size to understand the magnitude of the impact created by _FORTIFY_SOURCE=3 additional runtime code generation. However the performance and code size overhead may well be worth it due to the magnitude of improvement in security coverage.”</i></div><br/><div id="40805097" class="c"><input type="checkbox" id="c-40805097" checked=""/><div class="controls bullet"><span class="by">RustyRussell</span><span>|</span><a href="#40803717">root</a><span>|</span><a href="#40804274">parent</a><span>|</span><a href="#40806772">next</a><span>|</span><label class="collapse" for="c-40805097">[-]</label><label class="expand" for="c-40805097">[1 more]</label></div><br/><div class="children"><div class="content">Yes, came here to say this too. Of course it varies, but some measurements would be nice!</div><br/></div></div></div></div></div></div><div id="40806772" class="c"><input type="checkbox" id="c-40806772" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#40803717">prev</a><span>|</span><a href="#40805235">next</a><span>|</span><label class="collapse" for="c-40806772">[-]</label><label class="expand" for="c-40806772">[1 more]</label></div><br/><div class="children"><div class="content">I wish these compiler protocols and interfaces were better documented. They just assume you&#x27;re using glibc for support. I want to fully integrate them with my freestanding nolibc C projects but I can&#x27;t figure out how to do it.<p>The compiler&#x27;s stack canaries were simple enough. The only issue was the ugly symbols. I requested that a feature be added to override the symbol generated by the compiler so I could use good names instead.<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=113694" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=113694</a><p>Things like instrumentation and sanitizers though? No idea. Even asked about it on Stack Overflow and got no answers to this day.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;77688456" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;77688456</a><p>I assume these object sizing builtins make use of function attributes such as malloc, alloc_align and alloc_size. I&#x27;ve added all of those attributes to my memory allocator but I&#x27;m not quite sure if they&#x27;re doing anything useful.</div><br/></div></div><div id="40805235" class="c"><input type="checkbox" id="c-40805235" checked=""/><div class="controls bullet"><span class="by">ngneer</span><span>|</span><a href="#40806772">prev</a><span>|</span><a href="#40806272">next</a><span>|</span><label class="collapse" for="c-40805235">[-]</label><label class="expand" for="c-40805235">[2 more]</label></div><br/><div class="children"><div class="content">I would encourage the community to find a unit of measurement for security. Every defense can be breached, so every defense has an active region, much like transistors. Question is how to quantify.</div><br/><div id="40806801" class="c"><input type="checkbox" id="c-40806801" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40805235">parent</a><span>|</span><a href="#40806272">next</a><span>|</span><label class="collapse" for="c-40806801">[-]</label><label class="expand" for="c-40806801">[1 more]</label></div><br/><div class="children"><div class="content">Only in movies can every defense be breached. It is in fact possible to write code that can’t be hacked.</div><br/></div></div></div></div><div id="40806272" class="c"><input type="checkbox" id="c-40806272" checked=""/><div class="controls bullet"><span class="by">jiveturkey</span><span>|</span><a href="#40805235">prev</a><span>|</span><label class="collapse" for="c-40806272">[-]</label><label class="expand" for="c-40806272">[1 more]</label></div><br/><div class="children"><div class="content">article date 2022<p>the new feature appeared in 2021</div><br/></div></div></div></div></div></div></div></body></html>