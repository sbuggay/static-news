<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685178069953" as="style"/><link rel="stylesheet" href="styles.css?v=1685178069953"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/">Modern SAT solvers: fast, neat and underused (2018)</a> <span class="domain">(<a href="https://codingnest.com">codingnest.com</a>)</span></div><div class="subtext"><span>weird_user</span> | <span>74 comments</span></div><br/><div><div id="36089867" class="c"><input type="checkbox" id="c-36089867" checked=""/><div class="controls bullet"><span class="by">tgamblin</span><span>|</span><a href="#36088210">next</a><span>|</span><label class="collapse" for="c-36089867">[-]</label><label class="expand" for="c-36089867">[5 more]</label></div><br/><div class="children"><div class="content">Love this article and the push to build awareness of what modern SAT solvers can do.<p>It&#x27;s worth mentioning that there are higher level abstractions that are <i>far</i> more accessible than SAT.  If I were teaching a course on this, I would start with either Answer Set Programming (ASP) or Satisfiability Modulo Theories (SMT).  The most widely used solvers for those are clingo [0] and Z3 [1]:<p>With ASP, you write in a much clearer Prolog-like syntax that does not require nearly as much encoding effort as your typical SAT problem.  Z3 is similar -- you can code up problems in a simple Python API, or write them in the smtlib language.<p>Both of these make it easy to add various types of optimization, constraints, etc. to your problem, and they&#x27;re much better as modeling languages than straight SAT.  Underneath, they have solvers that leverage all the modern CDCL tricks.<p>We wrote up a paper [2] on how to formulate a modern dependency solver in ASP; it&#x27;s helped tremendously for adding new types of features like options, variants, and complex compiler&#x2F;arch dependencies to Spack [3].  You could not get good solutions to some of these problems without a capable and expressive solver.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;potassco&#x2F;clingo">https:&#x2F;&#x2F;github.com&#x2F;potassco&#x2F;clingo</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;Z3Prover&#x2F;z3">https:&#x2F;&#x2F;github.com&#x2F;Z3Prover&#x2F;z3</a><p>[2] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2210.08404" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2210.08404</a>, <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.5555&#x2F;3571885.3571931" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.5555&#x2F;3571885.3571931</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;spack&#x2F;spack">https:&#x2F;&#x2F;github.com&#x2F;spack&#x2F;spack</a></div><br/><div id="36091392" class="c"><input type="checkbox" id="c-36091392" checked=""/><div class="controls bullet"><span class="by">wgetch</span><span>|</span><a href="#36089867">parent</a><span>|</span><a href="#36090251">next</a><span>|</span><label class="collapse" for="c-36091392">[-]</label><label class="expand" for="c-36091392">[1 more]</label></div><br/><div class="children"><div class="content">The work on [2] is fascinating to me, both because of the problem domain and as a case study on the effective application of ASP. I will be reading this paper carefully to pore over the details.</div><br/></div></div><div id="36090251" class="c"><input type="checkbox" id="c-36090251" checked=""/><div class="controls bullet"><span class="by">BorisTheBrave</span><span>|</span><a href="#36089867">parent</a><span>|</span><a href="#36091392">prev</a><span>|</span><a href="#36088210">next</a><span>|</span><label class="collapse" for="c-36090251">[-]</label><label class="expand" for="c-36090251">[3 more]</label></div><br/><div class="children"><div class="content">Do you have a recommendation for how to get into ASP? I&#x27;ve read the clingo docs, but it has never clicked.</div><br/><div id="36090614" class="c"><input type="checkbox" id="c-36090614" checked=""/><div class="controls bullet"><span class="by">tgamblin</span><span>|</span><a href="#36089867">root</a><span>|</span><a href="#36090251">parent</a><span>|</span><a href="#36088210">next</a><span>|</span><label class="collapse" for="c-36090614">[-]</label><label class="expand" for="c-36090614">[2 more]</label></div><br/><div class="children"><div class="content">I read Potassco&#x27;s Answer Set Solving in Practice book [0] but it&#x27;s pretty dense. I suspect it would be easier to digest if you read it while also following their course materials, which are all online [1].<p>These days I recommend people start with the Lifschitz book [2] <i>and</i> read through the Potassco book [0].  Lifschitz&#x27;s book is a much gentler introduction to ASP and logic programming in general and its examples are in ASP code (not math). It&#x27;s also more geared towards the programming side than the solving side, which is probably better for most people until they really want to understand what clingo&#x2F;gringo&#x2F;clasp are doing and what their limitations are.<p>There are other more applied courses, like Adam Smith&#x27;s Applied ASP course at UCSC [3].  The problems in that course look like a lot of fun.<p>[0] <a href="https:&#x2F;&#x2F;potassco.org&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;potassco.org&#x2F;book&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;teaching.potassco.org" rel="nofollow">https:&#x2F;&#x2F;teaching.potassco.org</a><p>[2] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;vl&#x2F;teaching&#x2F;378&#x2F;ASP.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;vl&#x2F;teaching&#x2F;378&#x2F;ASP.pdf</a>, <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Answer-Set-Programming-Vladimir-Lifschitz&#x2F;dp&#x2F;3030246574" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Answer-Set-Programming-Vladimir-Lifsc...</a><p>[3] <a href="https:&#x2F;&#x2F;canvas.ucsc.edu&#x2F;courses&#x2F;1338" rel="nofollow">https:&#x2F;&#x2F;canvas.ucsc.edu&#x2F;courses&#x2F;1338</a></div><br/><div id="36091296" class="c"><input type="checkbox" id="c-36091296" checked=""/><div class="controls bullet"><span class="by">wgetch</span><span>|</span><a href="#36089867">root</a><span>|</span><a href="#36090614">parent</a><span>|</span><a href="#36088210">next</a><span>|</span><label class="collapse" for="c-36091296">[-]</label><label class="expand" for="c-36091296">[1 more]</label></div><br/><div class="children"><div class="content">I second the recommendation to start with Lifschitz and move on to the Potassco book from there. To add: One does not need to know Prolog to get into ASP, the semantics are unique and more minimal. That said, I personally struggled with ASP before it clicked, it takes time to grasp the lingo and grok the semantics if you have never worked with something similar. Best to have a guide that introduces the concepts one at a time (&quot;What do you mean, there&#x27;s more than one type of negation?!&quot;)</div><br/></div></div></div></div></div></div></div></div><div id="36088210" class="c"><input type="checkbox" id="c-36088210" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#36089867">prev</a><span>|</span><a href="#36087907">next</a><span>|</span><label class="collapse" for="c-36088210">[-]</label><label class="expand" for="c-36088210">[18 more]</label></div><br/><div class="children"><div class="content">&gt; ... modern SAT solvers are fast, neat and criminally underused by the industry.<p>Modern SAT solvers are fast, neat and criminally <i>undertaught</i> by the universities. Seriously, why isn&#x27;t this taught at the undergraduate level in CS70 [1] discrete math type courses or CS170 [2] analysis of algorithms type courses?<p>[1] <a href="https:&#x2F;&#x2F;www2.eecs.berkeley.edu&#x2F;Courses&#x2F;CS70&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www2.eecs.berkeley.edu&#x2F;Courses&#x2F;CS70&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;www2.eecs.berkeley.edu&#x2F;Courses&#x2F;CS170&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www2.eecs.berkeley.edu&#x2F;Courses&#x2F;CS170&#x2F;</a></div><br/><div id="36093017" class="c"><input type="checkbox" id="c-36093017" checked=""/><div class="controls bullet"><span class="by">sam0x17</span><span>|</span><a href="#36088210">parent</a><span>|</span><a href="#36088755">next</a><span>|</span><label class="collapse" for="c-36093017">[-]</label><label class="expand" for="c-36093017">[1 more]</label></div><br/><div class="children"><div class="content">We learned SAT solvers and got to implement one in one of our courses. Completely forget which one it was though.</div><br/></div></div><div id="36088755" class="c"><input type="checkbox" id="c-36088755" checked=""/><div class="controls bullet"><span class="by">tanx16</span><span>|</span><a href="#36088210">parent</a><span>|</span><a href="#36093017">prev</a><span>|</span><a href="#36089043">next</a><span>|</span><label class="collapse" for="c-36088755">[-]</label><label class="expand" for="c-36088755">[10 more]</label></div><br/><div class="children"><div class="content">This is… not true. CS170 specifically teaches about reducing NP problems to SAT (you can find this in the Algorithms textbook linked in the class syllabus). I recall solving one of the projects by using MiniSat after converting a problem to 3-SAT. FWIW, the textbook is excellent and the course was very useful.</div><br/><div id="36090021" class="c"><input type="checkbox" id="c-36090021" checked=""/><div class="controls bullet"><span class="by">tgamblin</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36088755">parent</a><span>|</span><a href="#36090368">next</a><span>|</span><label class="collapse" for="c-36090021">[-]</label><label class="expand" for="c-36090021">[3 more]</label></div><br/><div class="children"><div class="content">I definitely recall doing reductions from SAT in Algorithms courses.  I think that is a common part of most curricula.<p>I don&#x27;t recall being taught any practical <i>uses</i> of SAT. It was introduced only in the context of Cook&#x27;s theorem, as the problem you needed to reduce to other problems in order to show NP-completeness.<p>I think most people now learn SAT in that theoretical context, not as a tool to solve problems.</div><br/><div id="36090426" class="c"><input type="checkbox" id="c-36090426" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36090021">parent</a><span>|</span><a href="#36090368">next</a><span>|</span><label class="collapse" for="c-36090426">[-]</label><label class="expand" for="c-36090426">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I definitely recall doing reductions to SAT in Algorithms courses.<p>&gt; It was introduced only in the context of Cook&#x27;s theorem, as the problem you needed to reduce other problems to in order to show NP-completeness.<p>Are you referring to reductions <i>from</i> SAT, or <i>to</i> SAT? You seem to be mentioning both?</div><br/><div id="36090668" class="c"><input type="checkbox" id="c-36090668" checked=""/><div class="controls bullet"><span class="by">tgamblin</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36090426">parent</a><span>|</span><a href="#36090368">next</a><span>|</span><label class="collapse" for="c-36090668">[-]</label><label class="expand" for="c-36090668">[1 more]</label></div><br/><div class="children"><div class="content">Yep, <i>from</i> SAT. Edited. Guess I typed that too fast :)</div><br/></div></div></div></div></div></div><div id="36090368" class="c"><input type="checkbox" id="c-36090368" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36088755">parent</a><span>|</span><a href="#36090021">prev</a><span>|</span><a href="#36089783">next</a><span>|</span><label class="collapse" for="c-36090368">[-]</label><label class="expand" for="c-36090368">[4 more]</label></div><br/><div class="children"><div class="content">To clarify, you&#x27;re specifically talking about reductions <i>to</i> SAT, not <i>from</i> SAT, right?<p>Note the former is used as a solution technique for feeding into SAT solvers, where the latter&#x27;s goal is basically the exact opposite (to show NP-hardness and hence algorithmic intractability). Formal methods courses do the former, but algorithms courses usually use SAT for the latter.</div><br/><div id="36091240" class="c"><input type="checkbox" id="c-36091240" checked=""/><div class="controls bullet"><span class="by">tanx16</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36090368">parent</a><span>|</span><a href="#36090600">next</a><span>|</span><label class="collapse" for="c-36091240">[-]</label><label class="expand" for="c-36091240">[1 more]</label></div><br/><div class="children"><div class="content">In the particular project I was talking about (see <a href="https:&#x2F;&#x2F;inst.eecs.berkeley.edu&#x2F;~cs170&#x2F;sp20&#x2F;assets&#x2F;project&#x2F;spec.pdf" rel="nofollow">https:&#x2F;&#x2F;inst.eecs.berkeley.edu&#x2F;~cs170&#x2F;sp20&#x2F;assets&#x2F;project&#x2F;sp...</a> for a similar project) a solution is to reduce the problem to SAT and feed it into a SAT solver. Outside of the project, we were also taught the other way around (demonstrate NP-hardness). See <a href="https:&#x2F;&#x2F;people.eecs.berkeley.edu&#x2F;~vazirani&#x2F;algorithms&#x2F;chap8.pdf" rel="nofollow">https:&#x2F;&#x2F;people.eecs.berkeley.edu&#x2F;~vazirani&#x2F;algorithms&#x2F;chap8....</a>.</div><br/></div></div><div id="36090600" class="c"><input type="checkbox" id="c-36090600" checked=""/><div class="controls bullet"><span class="by">waldrews</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36090368">parent</a><span>|</span><a href="#36091240">prev</a><span>|</span><a href="#36089783">next</a><span>|</span><label class="collapse" for="c-36090600">[-]</label><label class="expand" for="c-36090600">[2 more]</label></div><br/><div class="children"><div class="content">is the first use of former&#x2F;latter consistent with the second?</div><br/><div id="36090730" class="c"><input type="checkbox" id="c-36090730" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36090600">parent</a><span>|</span><a href="#36089783">next</a><span>|</span><label class="collapse" for="c-36090730">[-]</label><label class="expand" for="c-36090730">[1 more]</label></div><br/><div class="children"><div class="content">I think so? Which part of it sounds inconsistent?</div><br/></div></div></div></div></div></div></div></div><div id="36089043" class="c"><input type="checkbox" id="c-36089043" checked=""/><div class="controls bullet"><span class="by">lower</span><span>|</span><a href="#36088210">parent</a><span>|</span><a href="#36088755">prev</a><span>|</span><a href="#36088257">next</a><span>|</span><label class="collapse" for="c-36089043">[-]</label><label class="expand" for="c-36089043">[4 more]</label></div><br/><div class="children"><div class="content">I used to teach formal methods at university, including a course with a lot of SAT examples. We tried to make it as practical as possible, with many examples and exercises in Java (where you just generate your formulas and call a solve method). Thing is, most students seemed to hate it passionately, just like with reductions to SAT in complexity theory.</div><br/><div id="36089861" class="c"><input type="checkbox" id="c-36089861" checked=""/><div class="controls bullet"><span class="by">_0ffh</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36089043">parent</a><span>|</span><a href="#36089385">next</a><span>|</span><label class="collapse" for="c-36089861">[-]</label><label class="expand" for="c-36089861">[2 more]</label></div><br/><div class="children"><div class="content">I wrote a bespoke backtracking solver for a specific class of problems. Would love to use Z3 or something, but frankly, I wouldn&#x27;t know how to systematically translate problem instances to solver constraints. It&#x27;s essentially a kind of very complex job-shop scheduling problem with lots of dynamic inter-dependencies. Many of the problems are hard to even solve without dead-locking, while we also naturally strive to minimize overall processing time. Where would I find ressources to help me get a grip on my specific problem [1]? Could I reasonably hope that Z3 or another general solver might be faster than a moderately well designed bespoke solver in a compiled language? (My solver combines a bunch of greedy heuristics with a backtracker in case it runs into a dead-lock, which is often.)<p>[1] Rough problem outline: Input goods must be transformed through a complex series of assembly&#x2F;machining&#x2F;processing lines to output goods; each line transforms one or two inputs into an (intermediary or end-) product; an assembly line produces it&#x27;s product in a fixed number of time units and cannot be stopped or delayed; finished intermediary products arrive at the end of an assembly line, which must be cleared by then; there are a limited number of temporary storage spaces where intermediary products can be moved to&#x2F;from in a fixed number of time units; some assembly lines must wait for two intermediary products to be completed to start a job combining them into another intermediary or end product; end products must then be moved to their destinations.</div><br/><div id="36090312" class="c"><input type="checkbox" id="c-36090312" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36089861">parent</a><span>|</span><a href="#36089385">next</a><span>|</span><label class="collapse" for="c-36090312">[-]</label><label class="expand" for="c-36090312">[1 more]</label></div><br/><div class="children"><div class="content">The pdf linked on this site is the biggest collection of SMT examples I know of: <a href="https:&#x2F;&#x2F;sat-smt.codes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sat-smt.codes&#x2F;</a><p>I’m no SMT expert, but the way I’ve done it is to make some representation in Python Z3, and then write some function or class that generates those. I was solving MLB eliminations (more complex than it sounds) and I think I used arrays of ints for number of wins. So I’d pull MLB data, turn that into schedule objects which turned themselves into z3 constraints.</div><br/></div></div></div></div><div id="36089385" class="c"><input type="checkbox" id="c-36089385" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#36088210">root</a><span>|</span><a href="#36089043">parent</a><span>|</span><a href="#36089861">prev</a><span>|</span><a href="#36088257">next</a><span>|</span><label class="collapse" for="c-36089385">[-]</label><label class="expand" for="c-36089385">[1 more]</label></div><br/><div class="children"><div class="content">What example use-cases did you use? Just curious.</div><br/></div></div></div></div><div id="36089280" class="c"><input type="checkbox" id="c-36089280" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#36088210">parent</a><span>|</span><a href="#36088257">prev</a><span>|</span><a href="#36087907">next</a><span>|</span><label class="collapse" for="c-36089280">[-]</label><label class="expand" for="c-36089280">[1 more]</label></div><br/><div class="children"><div class="content">Both my Alma Maters had courses that used these extensively, and also planners like (Pl|Tr|L)ingeling. We also covered reducability and SAT in multiple courses in both.<p>These should also be taught in an advanced PL course, e.g liquid, dependent etc types.</div><br/></div></div></div></div><div id="36087907" class="c"><input type="checkbox" id="c-36087907" checked=""/><div class="controls bullet"><span class="by">jjoonathan</span><span>|</span><a href="#36088210">prev</a><span>|</span><a href="#36087873">next</a><span>|</span><label class="collapse" for="c-36087907">[-]</label><label class="expand" for="c-36087907">[28 more]</label></div><br/><div class="children"><div class="content">I seem to recall that a poorly scaling sat solver in conda-forge broke so badly in 2020 that it shifted the tectonic plates underneath the entire academic python ecosystem away from conda and towards pip.<p><pre><code>    Solving Environment | &#x2F; - | \</code></pre></div><br/><div id="36088276" class="c"><input type="checkbox" id="c-36088276" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36087907">parent</a><span>|</span><a href="#36088297">next</a><span>|</span><label class="collapse" for="c-36088276">[-]</label><label class="expand" for="c-36088276">[10 more]</label></div><br/><div class="children"><div class="content">That was always a bit of a red herring, from my understanding.  Yes, if you poorly model something into an ad hoc SAT solver, expect slowness.<p>Which is a bit of the general idea of these being underused.  If you can get your problem into a SAT form or three, than feed it to a state of the art solver, it can work amazingly well.  But, you will be spending a lot of time moving to and from the SAT formulation.</div><br/><div id="36088483" class="c"><input type="checkbox" id="c-36088483" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088276">parent</a><span>|</span><a href="#36088297">next</a><span>|</span><label class="collapse" for="c-36088483">[-]</label><label class="expand" for="c-36088483">[9 more]</label></div><br/><div class="children"><div class="content">Do you know of any python dependency managers that do this?</div><br/><div id="36092511" class="c"><input type="checkbox" id="c-36092511" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088483">parent</a><span>|</span><a href="#36092102">next</a><span>|</span><label class="collapse" for="c-36092511">[-]</label><label class="expand" for="c-36092511">[1 more]</label></div><br/><div class="children"><div class="content">dnf is (or rather, was) written in Python and uses a SAT solver to solve dependencies for package installs in Fedora.</div><br/></div></div><div id="36092102" class="c"><input type="checkbox" id="c-36092102" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088483">parent</a><span>|</span><a href="#36092511">prev</a><span>|</span><a href="#36088707">next</a><span>|</span><label class="collapse" for="c-36092102">[-]</label><label class="expand" for="c-36092102">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t mamba basically Vonda “with a faster silver”?</div><br/></div></div><div id="36088707" class="c"><input type="checkbox" id="c-36088707" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088483">parent</a><span>|</span><a href="#36092102">prev</a><span>|</span><a href="#36091974">next</a><span>|</span><label class="collapse" for="c-36088707">[-]</label><label class="expand" for="c-36088707">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t.  That said, I think the problems are typically small enough that you don&#x27;t gain much by hunting for a good SAT formulation?  Python doesn&#x27;t do anything that any other dependency manager does.  (Does it?)</div><br/><div id="36089613" class="c"><input type="checkbox" id="c-36089613" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088707">parent</a><span>|</span><a href="#36091974">next</a><span>|</span><label class="collapse" for="c-36089613">[-]</label><label class="expand" for="c-36089613">[3 more]</label></div><br/><div class="children"><div class="content">DNF uses a SAT solver. It’s even listed first among the motivations for creating DNF:<p>&gt; DNF is a fork of Yum 3.4 that uses libsolv via hawkey for a backend. The main goals of the project are:<p>&gt; * using a SAT solver for dependency resolving<p>&gt; ...<p><a href="https:&#x2F;&#x2F;fedoraproject.org&#x2F;wiki&#x2F;Features&#x2F;DNF" rel="nofollow">https:&#x2F;&#x2F;fedoraproject.org&#x2F;wiki&#x2F;Features&#x2F;DNF</a></div><br/><div id="36090750" class="c"><input type="checkbox" id="c-36090750" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36089613">parent</a><span>|</span><a href="#36091974">next</a><span>|</span><label class="collapse" for="c-36090750">[-]</label><label class="expand" for="c-36090750">[2 more]</label></div><br/><div class="children"><div class="content">Fun, I&#x27;ll have to look at that.  The major implication, though, is that yum does the same thing without an explicit sat formulation.  Right?<p>Edit: I will note that the linked doc is silly old.  And it seems that the original proposed replacement for YUM was Hawkeye, and is deprecated?  But DNF is still steaming ahead?  I didn&#x27;t find any obvious links talking about performance.  Did the SAT idea pan out?  I&#x27;d almost think it was a bust, with some of these wikis. :(</div><br/><div id="36092518" class="c"><input type="checkbox" id="c-36092518" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36090750">parent</a><span>|</span><a href="#36091974">next</a><span>|</span><label class="collapse" for="c-36092518">[-]</label><label class="expand" for="c-36092518">[1 more]</label></div><br/><div class="children"><div class="content">yum used ad-hoc Python code.  It was also incredibly slow and often couldn&#x27;t find a solution.</div><br/></div></div></div></div></div></div></div></div><div id="36091974" class="c"><input type="checkbox" id="c-36091974" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088483">parent</a><span>|</span><a href="#36088707">prev</a><span>|</span><a href="#36088789">next</a><span>|</span><label class="collapse" for="c-36091974">[-]</label><label class="expand" for="c-36091974">[1 more]</label></div><br/><div class="children"><div class="content">libsolv is underneath suse and some more Linux distributions.  I think conda at some point switched there, too.</div><br/></div></div><div id="36088789" class="c"><input type="checkbox" id="c-36088789" checked=""/><div class="controls bullet"><span class="by">beecafe</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088483">parent</a><span>|</span><a href="#36091974">prev</a><span>|</span><a href="#36088297">next</a><span>|</span><label class="collapse" for="c-36088789">[-]</label><label class="expand" for="c-36088789">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;mamba-org&#x2F;mamba">https:&#x2F;&#x2F;github.com&#x2F;mamba-org&#x2F;mamba</a></div><br/></div></div></div></div></div></div><div id="36088297" class="c"><input type="checkbox" id="c-36088297" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#36087907">parent</a><span>|</span><a href="#36088276">prev</a><span>|</span><a href="#36091966">next</a><span>|</span><label class="collapse" for="c-36088297">[-]</label><label class="expand" for="c-36088297">[9 more]</label></div><br/><div class="children"><div class="content">From this and Dart, I think one of the lessons here is that SAT solvers are the wrong technique for solving dependencies. SAT solvers find “better” solutions by some metric, but humans using package managers want something which is both simpler and faster.</div><br/><div id="36088498" class="c"><input type="checkbox" id="c-36088498" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088297">parent</a><span>|</span><a href="#36091011">next</a><span>|</span><label class="collapse" for="c-36088498">[-]</label><label class="expand" for="c-36088498">[6 more]</label></div><br/><div class="children"><div class="content">As an example:<p>Schaefer&#x27;s dichotomy theorem shows that, when possible, just make sure to use Horn clauses when possible.<p>Takes a bit of thinking but is superior to huristics or SAT solvers if you can refactor to allow for it.</div><br/><div id="36088932" class="c"><input type="checkbox" id="c-36088932" checked=""/><div class="controls bullet"><span class="by">weavermarquez</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088498">parent</a><span>|</span><a href="#36088618">next</a><span>|</span><label class="collapse" for="c-36088932">[-]</label><label class="expand" for="c-36088932">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if related, to Schaefer&#x27;s theorem, but I dove into Answer Set Programming [1] recently, which follows this approach, enabling the use of fast-ish SMT solvers, which are a <i>generalization</i> of SAT solvers! Boolean&#x2F;Propositional Logic is to Predicate Logic as SAT is to SMT. There&#x27;s a very nice course about it from the developers of Potassco, one of the best open source Answer Set Programming framework [2].<p>The syntax looks like Prolog, but predicate negations are a first class citizen, avoids infinite loops.<p>Prolog&#x27;s approach is like a depth first search through a search tree -- ASP is like a nondeterministic turing machine, exploring all branches simultaneously from the bottom up.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Answer_set_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Answer_set_programming</a><p>[2] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PL7DBaibuDD9O4I05DiQfilqPUgpClMKYu">https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PL7DBaibuDD9O4I05DiQfi...</a></div><br/></div></div><div id="36088618" class="c"><input type="checkbox" id="c-36088618" checked=""/><div class="controls bullet"><span class="by">xavxav</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088498">parent</a><span>|</span><a href="#36088932">prev</a><span>|</span><a href="#36091011">next</a><span>|</span><label class="collapse" for="c-36088618">[-]</label><label class="expand" for="c-36088618">[4 more]</label></div><br/><div class="children"><div class="content">Wait, this is very relevant to some work I’ve been doing recently, how do you conclude that Horn clauses should be preferred from Schaefer’s theorem?</div><br/><div id="36088881" class="c"><input type="checkbox" id="c-36088881" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088618">parent</a><span>|</span><a href="#36088795">next</a><span>|</span><label class="collapse" for="c-36088881">[-]</label><label class="expand" for="c-36088881">[2 more]</label></div><br/><div class="children"><div class="content">Take a look at <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Boolean_satisfiability_problem#Schaefer&#x27;s_dichotomy_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Boolean_satisfiability_problem...</a> (based on Schaefer&#x27;s &quot;The complexity of satisfiability problems&quot;). Horn clause satisfiability problems (HORN SAT) fall in P-c.</div><br/><div id="36093047" class="c"><input type="checkbox" id="c-36093047" checked=""/><div class="controls bullet"><span class="by">xavxav</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088881">parent</a><span>|</span><a href="#36088795">next</a><span>|</span><label class="collapse" for="c-36093047">[-]</label><label class="expand" for="c-36093047">[1 more]</label></div><br/><div class="children"><div class="content">Oh right this is just Horn clauses, not CHCs</div><br/></div></div></div></div><div id="36088795" class="c"><input type="checkbox" id="c-36088795" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088618">parent</a><span>|</span><a href="#36088881">prev</a><span>|</span><a href="#36091011">next</a><span>|</span><label class="collapse" for="c-36088795">[-]</label><label class="expand" for="c-36088795">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it just that Horn clauses are easy to understand, and they are guaranteed to be fast.</div><br/></div></div></div></div></div></div><div id="36091011" class="c"><input type="checkbox" id="c-36091011" checked=""/><div class="controls bullet"><span class="by">tgamblin</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088297">parent</a><span>|</span><a href="#36088498">prev</a><span>|</span><a href="#36091966">next</a><span>|</span><label class="collapse" for="c-36091011">[-]</label><label class="expand" for="c-36091011">[2 more]</label></div><br/><div class="children"><div class="content">Dart as in the language?  Dart uses a SAT solver: <a href="https:&#x2F;&#x2F;github.com&#x2F;dart-lang&#x2F;pub&#x2F;blob&#x2F;master&#x2F;doc&#x2F;solver.md">https:&#x2F;&#x2F;github.com&#x2F;dart-lang&#x2F;pub&#x2F;blob&#x2F;master&#x2F;doc&#x2F;solver.md</a></div><br/><div id="36091092" class="c"><input type="checkbox" id="c-36091092" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36091011">parent</a><span>|</span><a href="#36091966">next</a><span>|</span><label class="collapse" for="c-36091092">[-]</label><label class="expand" for="c-36091092">[1 more]</label></div><br/><div class="children"><div class="content">My gut is that was the point?  That Dart uses a SAT solver to no discernible advantage.<p>I will also note that this amuses me to no end.  If you have enough dependencies that you need the speed of a SAT solver.... how many dependencies do you have?  And why are they changing so dang much?</div><br/></div></div></div></div></div></div><div id="36091966" class="c"><input type="checkbox" id="c-36091966" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#36087907">parent</a><span>|</span><a href="#36088297">prev</a><span>|</span><a href="#36087935">next</a><span>|</span><label class="collapse" for="c-36091966">[-]</label><label class="expand" for="c-36091966">[1 more]</label></div><br/><div class="children"><div class="content">the problem was<i>not</i> using a sat solver but <i>how</i> they used it.<p>many package dependency managers use sat solvers since suse spearheaded this in 2007&#x2F;2008 with libsolv, which is blazing fast for large repositories.<p><a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;version-sat" rel="nofollow">https:&#x2F;&#x2F;research.swtch.com&#x2F;version-sat</a></div><br/></div></div><div id="36087935" class="c"><input type="checkbox" id="c-36087935" checked=""/><div class="controls bullet"><span class="by">teruakohatu</span><span>|</span><a href="#36087907">parent</a><span>|</span><a href="#36091966">prev</a><span>|</span><a href="#36089623">next</a><span>|</span><label class="collapse" for="c-36087935">[-]</label><label class="expand" for="c-36087935">[2 more]</label></div><br/><div class="children"><div class="content">Conda is still unbearably slow. Mamba is a vastly better mostly drop-in replacement.</div><br/><div id="36089477" class="c"><input type="checkbox" id="c-36089477" checked=""/><div class="controls bullet"><span class="by">ubj</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36087935">parent</a><span>|</span><a href="#36089623">next</a><span>|</span><label class="collapse" for="c-36089477">[-]</label><label class="expand" for="c-36089477">[1 more]</label></div><br/><div class="children"><div class="content">Second this. Not only is it faster, but the error messages in Mamba are much more helpful and sane.</div><br/></div></div></div></div><div id="36089623" class="c"><input type="checkbox" id="c-36089623" checked=""/><div class="controls bullet"><span class="by">notatallshaw</span><span>|</span><a href="#36087907">parent</a><span>|</span><a href="#36087935">prev</a><span>|</span><a href="#36088088">next</a><span>|</span><label class="collapse" for="c-36089623">[-]</label><label class="expand" for="c-36089623">[1 more]</label></div><br/><div class="children"><div class="content">Also there had been a growing trend for most popular packages to offer precompiled wheels on PyPI instead of just sdist releases.<p>This meant that people who had moved to Conda because they couldn&#x27;t get Pip to install important packages into their environment took another look and found that actually they could get things installed using Pip now.<p>At the same time Pip also got a resolver allowing you to have install time confidence you&#x27;re not installing conflicting package, and recently (Pip 23.1+) the resolver&#x27;s backtracking got pretty good.<p>That said Conda mostly solved this (and once mamba is the default resolver engine things will be really fast), Pip is not ever going to be a package manager, and Poetry still isn&#x27;t an environment manager, and most other Python package&#x2F;installer alternatives to Conda won&#x27;t do things like install your Jupyterlab&#x27;s nodejs dependency.<p>After many years I now almost exclusively use Pip to install into an environment, but still nothing beats Conda for bootstraping the non-Python-package requirement&#x27;s (such as Python itself) nor for getting things working when you are in a weird environment that you can&#x27;t install OS dev libraries into.</div><br/></div></div><div id="36088088" class="c"><input type="checkbox" id="c-36088088" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#36087907">parent</a><span>|</span><a href="#36089623">prev</a><span>|</span><a href="#36087873">next</a><span>|</span><label class="collapse" for="c-36088088">[-]</label><label class="expand" for="c-36088088">[4 more]</label></div><br/><div class="children"><div class="content">Great! Conda honestly can&#x27;t die fast enough.</div><br/><div id="36088738" class="c"><input type="checkbox" id="c-36088738" checked=""/><div class="controls bullet"><span class="by">Macuyiko</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088088">parent</a><span>|</span><a href="#36087873">next</a><span>|</span><label class="collapse" for="c-36088738">[-]</label><label class="expand" for="c-36088738">[3 more]</label></div><br/><div class="children"><div class="content">Curious to hear about your preferred alternative. Poetry?</div><br/><div id="36089850" class="c"><input type="checkbox" id="c-36089850" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088738">parent</a><span>|</span><a href="#36088857">next</a><span>|</span><label class="collapse" for="c-36089850">[-]</label><label class="expand" for="c-36089850">[1 more]</label></div><br/><div class="children"><div class="content">Poetry, pip, nix or sending out butterflies to bend cosmic rays to write bits into memory. It really doesn&#x27;t matter as long as it&#x27;s not the hellscape that is conda.</div><br/></div></div><div id="36088857" class="c"><input type="checkbox" id="c-36088857" checked=""/><div class="controls bullet"><span class="by">fock</span><span>|</span><a href="#36087907">root</a><span>|</span><a href="#36088738">parent</a><span>|</span><a href="#36089850">prev</a><span>|</span><a href="#36087873">next</a><span>|</span><label class="collapse" for="c-36088857">[-]</label><label class="expand" for="c-36088857">[1 more]</label></div><br/><div class="children"><div class="content">spack</div><br/></div></div></div></div></div></div></div></div><div id="36087873" class="c"><input type="checkbox" id="c-36087873" checked=""/><div class="controls bullet"><span class="by">hackandthink</span><span>|</span><a href="#36087907">prev</a><span>|</span><a href="#36092445">next</a><span>|</span><label class="collapse" for="c-36087873">[-]</label><label class="expand" for="c-36087873">[2 more]</label></div><br/><div class="children"><div class="content">Compiling Scala without a SAT solver is probably too difficult.<p>The CNF Converter is a gem.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;scala&#x2F;scala&#x2F;blob&#x2F;v2.13.5&#x2F;src&#x2F;compiler&#x2F;scala&#x2F;tools&#x2F;nsc&#x2F;transform&#x2F;patmat&#x2F;Solving.scala#L50">https:&#x2F;&#x2F;github.com&#x2F;scala&#x2F;scala&#x2F;blob&#x2F;v2.13.5&#x2F;src&#x2F;compiler&#x2F;sca...</a></div><br/><div id="36092530" class="c"><input type="checkbox" id="c-36092530" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#36087873">parent</a><span>|</span><a href="#36092445">next</a><span>|</span><label class="collapse" for="c-36092530">[-]</label><label class="expand" for="c-36092530">[1 more]</label></div><br/><div class="children"><div class="content">Can you expand a bit on why &#x2F; which bits of Scala compilation this is used for?</div><br/></div></div></div></div><div id="36092445" class="c"><input type="checkbox" id="c-36092445" checked=""/><div class="controls bullet"><span class="by">scg</span><span>|</span><a href="#36087873">prev</a><span>|</span><a href="#36092558">next</a><span>|</span><label class="collapse" for="c-36092445">[-]</label><label class="expand" for="c-36092445">[1 more]</label></div><br/><div class="children"><div class="content">Mirror: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230108202435&#x2F;https:&#x2F;&#x2F;codingnest.com&#x2F;modern-sat-solvers-fast-neat-underused-part-1-of-n&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230108202435&#x2F;https:&#x2F;&#x2F;codingnes...</a></div><br/></div></div><div id="36092558" class="c"><input type="checkbox" id="c-36092558" checked=""/><div class="controls bullet"><span class="by">bertman</span><span>|</span><a href="#36092445">prev</a><span>|</span><a href="#36088435">next</a><span>|</span><label class="collapse" for="c-36092558">[-]</label><label class="expand" for="c-36092558">[1 more]</label></div><br/><div class="children"><div class="content">Related post (and highly recommended!) from yesterday:<p>The Silent (R)evolution of SAT
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36079115" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36079115</a></div><br/></div></div><div id="36088435" class="c"><input type="checkbox" id="c-36088435" checked=""/><div class="controls bullet"><span class="by">c0balt</span><span>|</span><a href="#36092558">prev</a><span>|</span><a href="#36092466">next</a><span>|</span><label class="collapse" for="c-36088435">[-]</label><label class="expand" for="c-36088435">[1 more]</label></div><br/><div class="children"><div class="content">Just wanted to shoutout Armin Biere, one of the top contributors in this field: <a href="https:&#x2F;&#x2F;github.com&#x2F;arminbiere">https:&#x2F;&#x2F;github.com&#x2F;arminbiere</a><p>He has a few open source SAT solvers and tooling that provide good and proven examples on modern SAT solver techniques.</div><br/></div></div><div id="36092466" class="c"><input type="checkbox" id="c-36092466" checked=""/><div class="controls bullet"><span class="by">rojeee</span><span>|</span><a href="#36088435">prev</a><span>|</span><a href="#36090057">next</a><span>|</span><label class="collapse" for="c-36092466">[-]</label><label class="expand" for="c-36092466">[1 more]</label></div><br/><div class="children"><div class="content">This brings back memories. In early 2000s, I wrote my undergrad thesis on a survey of SAT solving techniques. I believe the most capable general solver at the time was called DPLL and used a backtracking approach. My key insight at the time was that if you knew the &quot;shape&quot; of the SAT problem (you had domain specific insight) then you could take some shortcuts by using a custom algorithm. Eg this clause is always false and reduce the search space.</div><br/></div></div><div id="36090057" class="c"><input type="checkbox" id="c-36090057" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#36092466">prev</a><span>|</span><a href="#36087906">next</a><span>|</span><label class="collapse" for="c-36090057">[-]</label><label class="expand" for="c-36090057">[1 more]</label></div><br/><div class="children"><div class="content">Has there been any effort to formalise the subset of NP that lends itself to SAT resolution (is there something between x^n and n^x)?<p>For example, what are the defining characteristics of a graphs for which the travelling salesman problem is resolvable without resorting to brute force?</div><br/></div></div><div id="36087906" class="c"><input type="checkbox" id="c-36087906" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#36090057">prev</a><span>|</span><a href="#36091303">next</a><span>|</span><label class="collapse" for="c-36087906">[-]</label><label class="expand" for="c-36087906">[1 more]</label></div><br/><div class="children"><div class="content">Conda uses a SAT solver. It is still very slow on degenerate cases and I’m not sure if work to replace it with Microsoft’s SAT solver has started.<p><a href="https:&#x2F;&#x2F;www.anaconda.com&#x2F;blog&#x2F;understanding-and-improving-condas-performance" rel="nofollow">https:&#x2F;&#x2F;www.anaconda.com&#x2F;blog&#x2F;understanding-and-improving-co...</a></div><br/></div></div><div id="36091303" class="c"><input type="checkbox" id="c-36091303" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#36087906">prev</a><span>|</span><a href="#36089032">next</a><span>|</span><label class="collapse" for="c-36091303">[-]</label><label class="expand" for="c-36091303">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As an example, the often-talked-about dependency management problem, is also NP-Complete and thus translates into SAT[2][3], and SAT could be translated into dependency manager.<p>This reminds me of make[0] and of being made aware that make[0] is a SAT solver.  I think it was when I attended a conference.  Unfortunately I cannot find an authoritative source to quote, so will rely on, and be grateful to, the HN community to correct me should this be wrong.<p>0 - <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;make&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;make&#x2F;</a></div><br/></div></div><div id="36089032" class="c"><input type="checkbox" id="c-36089032" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#36091303">prev</a><span>|</span><a href="#36089830">next</a><span>|</span><label class="collapse" for="c-36089032">[-]</label><label class="expand" for="c-36089032">[3 more]</label></div><br/><div class="children"><div class="content">SAT? I had to look it up, so...<p>Boolean satisfiability problem<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Boolean_satisfiability_problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Boolean_satisfiability_problem</a><p>&quot;In logic and computer science, the Boolean satisfiability problem (sometimes called propositional satisfiability problem and abbreviated SATISFIABILITY, SAT or B-SAT) is the problem of determining if there exists an interpretation that satisfies a given Boolean formula. In other words, it asks whether the variables of a given Boolean formula can be consistently replaced by the values TRUE or FALSE in such a way that the formula evaluates to TRUE.&quot;</div><br/><div id="36089461" class="c"><input type="checkbox" id="c-36089461" checked=""/><div class="controls bullet"><span class="by">hackernewds</span><span>|</span><a href="#36089032">parent</a><span>|</span><a href="#36089830">next</a><span>|</span><label class="collapse" for="c-36089461">[-]</label><label class="expand" for="c-36089461">[2 more]</label></div><br/><div class="children"><div class="content">Ah I thought initially that these were solving SAT questions. Easy to make mistake, or perhaps just me.</div><br/><div id="36090263" class="c"><input type="checkbox" id="c-36090263" checked=""/><div class="controls bullet"><span class="by">balls187</span><span>|</span><a href="#36089032">root</a><span>|</span><a href="#36089461">parent</a><span>|</span><a href="#36089830">next</a><span>|</span><label class="collapse" for="c-36090263">[-]</label><label class="expand" for="c-36090263">[1 more]</label></div><br/><div class="children"><div class="content">No, I also had no idea about this type of problem and immediately thought this article was about the placement tests administered in the US.</div><br/></div></div></div></div></div></div><div id="36089830" class="c"><input type="checkbox" id="c-36089830" checked=""/><div class="controls bullet"><span class="by">abecedarius</span><span>|</span><a href="#36089032">prev</a><span>|</span><a href="#36087853">next</a><span>|</span><label class="collapse" for="c-36089830">[-]</label><label class="expand" for="c-36089830">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, here&#x27;s a little console-mode puzzle game of SAT problems, if you want to solve some manually. The &quot;board&quot; is not exactly like the example table in the post, since that one was for Sudoku in particular. This grid represents variables as rows and clauses as columns.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;darius&#x2F;sturm&#x2F;blob&#x2F;master&#x2F;satgame.py">https:&#x2F;&#x2F;github.com&#x2F;darius&#x2F;sturm&#x2F;blob&#x2F;master&#x2F;satgame.py</a> (Python 2)</div><br/></div></div><div id="36087853" class="c"><input type="checkbox" id="c-36087853" checked=""/><div class="controls bullet"><span class="by">comfypotato</span><span>|</span><a href="#36089830">prev</a><span>|</span><a href="#36092539">next</a><span>|</span><label class="collapse" for="c-36087853">[-]</label><label class="expand" for="c-36087853">[2 more]</label></div><br/><div class="children"><div class="content">But what do you mean “fast”? If your problem ends up on the steep side of the exponential curve, it’s going to take a while to solve.<p>I had a lot of fun making my own CDCL solver in Rust, and I’ve really enjoyed messing with Z3 for some theoretical computer science. On all of my explorations, there was a very tangible problem size beyond which the solve time was unusable.<p>In the case of Z3 with most real world problems, the typical problem size is beyond this limit.</div><br/><div id="36088634" class="c"><input type="checkbox" id="c-36088634" checked=""/><div class="controls bullet"><span class="by">xavxav</span><span>|</span><a href="#36087853">parent</a><span>|</span><a href="#36092539">next</a><span>|</span><label class="collapse" for="c-36088634">[-]</label><label class="expand" for="c-36088634">[1 more]</label></div><br/><div class="children"><div class="content">Z3 is actually not a particularly good SAT solver, you really want to use a dedicated tool for pure SAT problems. On the other hand if your problem is in a richer class like QBF or SMT then z3 shines and often you can use encoding tricks to scale problems significantly</div><br/></div></div></div></div><div id="36092539" class="c"><input type="checkbox" id="c-36092539" checked=""/><div class="controls bullet"><span class="by">ur-whale</span><span>|</span><a href="#36087853">prev</a><span>|</span><a href="#36089473">next</a><span>|</span><label class="collapse" for="c-36092539">[-]</label><label class="expand" for="c-36092539">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;archive.is&#x2F;zE6eQ" rel="nofollow">https:&#x2F;&#x2F;archive.is&#x2F;zE6eQ</a></div><br/></div></div><div id="36089473" class="c"><input type="checkbox" id="c-36089473" checked=""/><div class="controls bullet"><span class="by">joko42</span><span>|</span><a href="#36092539">prev</a><span>|</span><a href="#36088463">next</a><span>|</span><label class="collapse" for="c-36089473">[-]</label><label class="expand" for="c-36089473">[4 more]</label></div><br/><div class="children"><div class="content">There was a time when people thought SAT and formal logic is the way to building AI. Now you don&#x27;t hear anything about it. I wonder what happened?</div><br/><div id="36089688" class="c"><input type="checkbox" id="c-36089688" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#36089473">parent</a><span>|</span><a href="#36089949">next</a><span>|</span><label class="collapse" for="c-36089688">[-]</label><label class="expand" for="c-36089688">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;AI Winter&quot; was largely caused by people realizing building better logic, chess, or similar analytical engines proves to be a poor model for human like intelligence. The current renaissance is due to Machine Learning &#x2F; Deep Learning based essentially on statistical models.<p>In the specific context of language there was a famous debate between Chompsky and Norvig that touches on these themes: <a href="http:&#x2F;&#x2F;norvig.com&#x2F;chomsky.html" rel="nofollow">http:&#x2F;&#x2F;norvig.com&#x2F;chomsky.html</a><p>I believe events of recent years have not been kind to Chompsky&#x27;s side of this debate. I&#x27;m less bullish on large language models turning into AGI than many people here, but I think if we do develop AGI it&#x27;s a certainty it will be a based on probabilistic models, not logically consistent formalisms alone.</div><br/></div></div><div id="36089949" class="c"><input type="checkbox" id="c-36089949" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#36089473">parent</a><span>|</span><a href="#36089688">prev</a><span>|</span><a href="#36089560">next</a><span>|</span><label class="collapse" for="c-36089949">[-]</label><label class="expand" for="c-36089949">[1 more]</label></div><br/><div class="children"><div class="content">It requires large amounts of formalised and human defined domain specific knowledge, for every domain that you work with.<p>The overheads are huge, and it&#x27;s very bad at dealing with fuzzy situations.</div><br/></div></div></div></div><div id="36088463" class="c"><input type="checkbox" id="c-36088463" checked=""/><div class="controls bullet"><span class="by">justicz</span><span>|</span><a href="#36089473">prev</a><span>|</span><a href="#36090119">next</a><span>|</span><label class="collapse" for="c-36088463">[-]</label><label class="expand" for="c-36088463">[1 more]</label></div><br/><div class="children"><div class="content">I really love the clarity + practicality of this article. Super well-written.</div><br/></div></div><div id="36090119" class="c"><input type="checkbox" id="c-36090119" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#36088463">prev</a><span>|</span><label class="collapse" for="c-36090119">[-]</label><label class="expand" for="c-36090119">[1 more]</label></div><br/><div class="children"><div class="content">Does&#x27;t Rust use a SAT solver for aspects of its type system?</div><br/></div></div></div></div></div></div></div></body></html>