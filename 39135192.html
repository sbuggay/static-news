<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706259658538" as="style"/><link rel="stylesheet" href="styles.css?v=1706259658538"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.agileconnection.com/article/two-sides-software-testing-checking-and-exploring">Two sides of software testing: Checking and exploring (2011)</a> <span class="domain">(<a href="https://www.agileconnection.com">www.agileconnection.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>24 comments</span></div><br/><div><div id="39139655" class="c"><input type="checkbox" id="c-39139655" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39136456">next</a><span>|</span><label class="collapse" for="c-39139655">[-]</label><label class="expand" for="c-39139655">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;If they can&#x27;t tell me what the software is supposed to do, I can&#x27;t test it,&quot; Francine, the test manager, scowled. &quot;So, I tell them that I won&#x27;t start testing until they produce a detailed requirements document.&quot;<p>I think this attitude could only work if you expected end-users to do the same: no user interactions except things explicitly written in the manual.</div><br/></div></div><div id="39136456" class="c"><input type="checkbox" id="c-39136456" checked=""/><div class="controls bullet"><span class="by">rqtwteye</span><span>|</span><a href="#39139655">prev</a><span>|</span><a href="#39137181">next</a><span>|</span><label class="collapse" for="c-39136456">[-]</label><label class="expand" for="c-39136456">[11 more]</label></div><br/><div class="children"><div class="content">Exploratory testing by experienced testers is extremely valuable. I am a dev but have done some testing. I could break the systems in various ways because I had a pretty good feel for what can go wrong.<p>Beginner users are also very good because they do stuff you never expected.</div><br/><div id="39136610" class="c"><input type="checkbox" id="c-39136610" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39136456">parent</a><span>|</span><a href="#39136624">next</a><span>|</span><label class="collapse" for="c-39136610">[-]</label><label class="expand" for="c-39136610">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Beginner users are also very good because they do stuff you never expected.<p>People using software for a while undergo operant conditioning: consciously or subconsciously they quickly learn to internalise what makes the software &#x27;angry&#x27;, and learn to avoid that.  That makes them more productive users, but also less useful as explorers.<p>See <a href="https:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;861" rel="nofollow">https:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;861</a><p>&gt; Have you ever used a new program or system and found it to be obnoxiously buggy, but then after a while you didn’t notice the bugs anymore? If so, then congratulations: you have been trained by the computer to avoid some of its problems. For example, I used to have a laptop that would lock up to the point where the battery needed to be removed when I scrolled down a web page for too long (I’m guessing the video driver’s logic for handling a full command queue was defective). Messing with the driver version did not solve the problem and I soon learned to take little breaks when scrolling down a long web page. To this day I occasionally feel a twinge of guilt or fear when rapidly scrolling a web page.<p>&gt; The extent to which we technical people have become conditioned by computers became apparent to me when one of my kids, probably three years old at the time, sat down at a Windows machine and within minutes rendered the GUI unresponsive. Even after watching which keys he pressed, I was unable to reproduce this behavior, at least partially because decades of training in how to use a computer have made it very hard for me to use one in such an inappropriate fashion. By now, this child (at 8 years old) has been brought into the fold: like millions of other people he can use a Windows machine for hours at a time without killing it.</div><br/><div id="39140192" class="c"><input type="checkbox" id="c-39140192" checked=""/><div class="controls bullet"><span class="by">julian_t</span><span>|</span><a href="#39136456">root</a><span>|</span><a href="#39136610">parent</a><span>|</span><a href="#39136624">next</a><span>|</span><label class="collapse" for="c-39140192">[-]</label><label class="expand" for="c-39140192">[1 more]</label></div><br/><div class="children"><div class="content">I think this is true whenever we learn to interact with a system. When I was learning the saxophone I had real trouble getting one note to sound properly, and it seemed to me that there was a leak on that pad. My teacher couldn&#x27;t get my instrument to misbehave at all. He said there probably was something slightly wrong with that pad, but over the years he&#x27;d learned to play &#x27;with&#x27; an instrument, adjusting for its particular behavior. The same goes for things like driving a temperamental car.</div><br/></div></div></div></div><div id="39136624" class="c"><input type="checkbox" id="c-39136624" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#39136456">parent</a><span>|</span><a href="#39136610">prev</a><span>|</span><a href="#39137181">next</a><span>|</span><label class="collapse" for="c-39136624">[-]</label><label class="expand" for="c-39136624">[8 more]</label></div><br/><div class="children"><div class="content">I’ve met Elisabeth, and i think she’s a fantastic thought leader for exploratory testing.<p>Sadly my efforts to promote this practice were met with a dismissive response: “QA leads to lower quality, according to this study”. I just didn’t have the energy to try to change this person’s opinion.<p>I have seen exploratory testing in concert with good developer testing work extremely well. Old school SQA isn’t really my thing, but modern exploratory testers are tremendously valuable.</div><br/><div id="39139456" class="c"><input type="checkbox" id="c-39139456" checked=""/><div class="controls bullet"><span class="by">jdlshore</span><span>|</span><a href="#39136456">root</a><span>|</span><a href="#39136624">parent</a><span>|</span><a href="#39138104">next</a><span>|</span><label class="collapse" for="c-39139456">[-]</label><label class="expand" for="c-39139456">[1 more]</label></div><br/><div class="children"><div class="content">Elisabeth is the author of the article they may have been unknowingly quoting: “Better Testing, Worse Quality.”</div><br/></div></div><div id="39138104" class="c"><input type="checkbox" id="c-39138104" checked=""/><div class="controls bullet"><span class="by">shiroiuma</span><span>|</span><a href="#39136456">root</a><span>|</span><a href="#39136624">parent</a><span>|</span><a href="#39139456">prev</a><span>|</span><a href="#39137181">next</a><span>|</span><label class="collapse" for="c-39138104">[-]</label><label class="expand" for="c-39138104">[6 more]</label></div><br/><div class="children"><div class="content">&gt;“QA leads to lower quality, according to this study”.<p>Was this produced by the same people who published a study claiming that flossing your teeth is bad for you, or the study that claimed that wearing a bicycle helmet is dangerous?</div><br/><div id="39138366" class="c"><input type="checkbox" id="c-39138366" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#39136456">root</a><span>|</span><a href="#39138104">parent</a><span>|</span><a href="#39137181">next</a><span>|</span><label class="collapse" for="c-39138366">[-]</label><label class="expand" for="c-39138366">[5 more]</label></div><br/><div class="children"><div class="content">&quot;QA&quot; isn&#x27;t as precise as wear a helmet while riding your bicycle or floss your teeth every night before going to sleep.  It refers to vague practices that vary greatly from organization to organization and team to team.<p>There are several anti-patterns that sometimes fit under this vagueness:<p>- Throw garbage over the fence.  I.e. low quality products thrown over the fence to a QA team.<p>- Over-reliance on manual testing.<p>- Quality is somebody else&#x27;s problem (sort of related to the first anti-pattern but not exactly the same).<p>Even the term &quot;Quality&quot; is usually too vague to make sense of.  What is quality exactly?  How do you tell if your product is higher or lower quality than the competing product?  Organizations tend to declare they&#x27;re the best, regardless of practices and with no real benchmark.</div><br/><div id="39139349" class="c"><input type="checkbox" id="c-39139349" checked=""/><div class="controls bullet"><span class="by">shiroiuma</span><span>|</span><a href="#39136456">root</a><span>|</span><a href="#39138366">parent</a><span>|</span><a href="#39137181">next</a><span>|</span><label class="collapse" for="c-39139349">[-]</label><label class="expand" for="c-39139349">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how having a QA team can actually result in <i>worse</i> quality though.  Even for your &quot;throw garbage over the fence&quot; (something I&#x27;ve seen first-hand actually), the QA team is improving quality by finding the bugs in all the garbage thrown over the fence.  Sure, getting the dev teams to stop throwing garbage would be better, but if management doesn&#x27;t want to do that for some weird reason, and wants QA to serve as the bug-fixing org in place of having devs actually test their code before merging to master, not having the QA team at all would be measurably worse.<p>It&#x27;s a bit like the bike helmet controversy.  The anti-helmet people from Netherlands all claim that helmets somehow force cyclists to ride faster or more dangerously, or force car drivers to take greater risks around them.  (Incidentally, this is very similar to the anti-seatbelt arguments I heard decades ago.)  The helmet isn&#x27;t the problem here though, even if there&#x27;s any truth to these claims: it&#x27;s the humans.  The helmet will absolutely protect your skull better when it impacts concrete than no helmet.</div><br/><div id="39140005" class="c"><input type="checkbox" id="c-39140005" checked=""/><div class="controls bullet"><span class="by">NomDePlum</span><span>|</span><a href="#39136456">root</a><span>|</span><a href="#39139349">parent</a><span>|</span><a href="#39139494">next</a><span>|</span><label class="collapse" for="c-39140005">[-]</label><label class="expand" for="c-39140005">[1 more]</label></div><br/><div class="children"><div class="content">In most cases I&#x27;d agree. QA teams&#x2F;testers can be very professional.<p>However, having a team that is responsible for Quality can absolutely lower the quality of a product. For starters that team is now, at least in terms of perception and more importantly organisational politics, responsible for quality, so by definition others are not held as responsible. That can have all sorts of perverse side-effects.<p>Secondly, if the QA team is not very good, then it&#x27;s just a time sink. Misreported defects, queries about functionality, increased communication, supposed environmental issues all generated spuriously, then take away time from development and other teams. Lost time is not replaceable, and limited time drives down quality.<p>Lastly, having a separate team lengthens feedback and issues are spotted later in the cycle, this drives quality down too.<p>My preference is always to keep testing within the team, automate it and make the developers think about and appreciate good testing. Good testers, can absolutely contribute, and exploratory testing can be highly valuable, particularly for systems users directly interact with, but they are, in my experience, pretty rare.</div><br/></div></div><div id="39139494" class="c"><input type="checkbox" id="c-39139494" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#39136456">root</a><span>|</span><a href="#39139349">parent</a><span>|</span><a href="#39140005">prev</a><span>|</span><a href="#39137181">next</a><span>|</span><label class="collapse" for="c-39139494">[-]</label><label class="expand" for="c-39139494">[2 more]</label></div><br/><div class="children"><div class="content">The problem is that these are systems.  I.e. you&#x27;re right that in a given system if all else is constant the presence of some QA&#x2F;testing step should improve quality.  But everything else is not constant.<p>But yeah, point taken on the bike helmet arguments, though I think that&#x27;s a little more clear cut.<p>I think QA (manual software testing by professional testers) has an important role in producing quality software but there are organizational corner cases where the idea of &quot;QA&quot; in software promotes the wrong thinking&#x2F;approach to quality that results in an overall poor outcome.  Quality in software starts before a single line of code is written and has to be in mind throughout the development process so you shouldn&#x27;t fall into a trap that somehow slapping &quot;Quality Assurance&quot; on top of bad engineering can create quality after the fact.</div><br/><div id="39139706" class="c"><input type="checkbox" id="c-39139706" checked=""/><div class="controls bullet"><span class="by">shiroiuma</span><span>|</span><a href="#39136456">root</a><span>|</span><a href="#39139494">parent</a><span>|</span><a href="#39137181">next</a><span>|</span><label class="collapse" for="c-39139706">[-]</label><label class="expand" for="c-39139706">[1 more]</label></div><br/><div class="children"><div class="content">Just because some people get the wrong idea when something exists, doesn&#x27;t mean the existence of that thing is an actual problem or detriment.  It&#x27;s true, slapping &quot;QA&quot; on top of bad engineering isn&#x27;t going to create quality.  However, &quot;having quality in mind throughout the development process&quot; isn&#x27;t going to guarantee it either, especially in a large and complex codebase with modules from many different teams.  A QA org is useful for doing things like full-system testing, which can catch bugs that those individual teams might miss because they aren&#x27;t testing the entire system.  It&#x27;s also useful to have dedicated testers because they&#x27;ll test things out in ways the devs never thought of.  Again, this isn&#x27;t a replacement for quality engineering at the outset, but that&#x27;s a management problem.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39137181" class="c"><input type="checkbox" id="c-39137181" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#39136456">prev</a><span>|</span><a href="#39139278">next</a><span>|</span><label class="collapse" for="c-39137181">[-]</label><label class="expand" for="c-39137181">[5 more]</label></div><br/><div class="children"><div class="content">The article presents two forms of testing, but it implies checking is only possible with a complete specification of the program.<p>But that&#x27;s not true: one can check incomplete specifications, both positive and negative.<p>To the extent one has <i>any</i> specification, one can automate testing, and in doing so execute far more test cases than any manual exploration ever could.  To a significant extent, testing is about sheer volume of tests, not cleverness in constructing the tests.</div><br/><div id="39139795" class="c"><input type="checkbox" id="c-39139795" checked=""/><div class="controls bullet"><span class="by">tveyben</span><span>|</span><a href="#39137181">parent</a><span>|</span><a href="#39137585">next</a><span>|</span><label class="collapse" for="c-39139795">[-]</label><label class="expand" for="c-39139795">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To a significant extent, testing is about sheer volume of tests<p>Well, quantity != quality<p>Just because you have 1E10 test cases does not mean you have a large coverage…<p>One cleverly constructed testcase might return more insights regarding the product than 100 testcases made just to increase the number of test cases.<p>Goodhart&#x27;s law: &quot;When a measure becomes a target, it ceases to be a good measure&quot; comes to mind…</div><br/></div></div><div id="39137585" class="c"><input type="checkbox" id="c-39137585" checked=""/><div class="controls bullet"><span class="by">omgwtfbyobbq</span><span>|</span><a href="#39137181">parent</a><span>|</span><a href="#39139795">prev</a><span>|</span><a href="#39139278">next</a><span>|</span><label class="collapse" for="c-39137585">[-]</label><label class="expand" for="c-39137585">[3 more]</label></div><br/><div class="children"><div class="content">In my experience, manual and automated testing are necessary together, and neither is sufficient alone.<p>Manual testing alone usually can&#x27;t cover enough ground, and automated testing alone usually can&#x27;t generate inputs with sufficient cardinality to cover enough of what the software does.</div><br/><div id="39137633" class="c"><input type="checkbox" id="c-39137633" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39137181">root</a><span>|</span><a href="#39137585">parent</a><span>|</span><a href="#39139278">next</a><span>|</span><label class="collapse" for="c-39137633">[-]</label><label class="expand" for="c-39137633">[2 more]</label></div><br/><div class="children"><div class="content">Property-based and fuzz testing can generate a lot of inputs. You may have to run them overnight or longer sometimes though.<p>And if you pair property-based testing with model-based testing you can detect a lot of errors that manual testing will likely never discover, just due to time.<p><a href="https:&#x2F;&#x2F;hypothesis.readthedocs.io&#x2F;en&#x2F;latest&#x2F;stateful.html" rel="nofollow">https:&#x2F;&#x2F;hypothesis.readthedocs.io&#x2F;en&#x2F;latest&#x2F;stateful.html</a> - one example</div><br/><div id="39137762" class="c"><input type="checkbox" id="c-39137762" checked=""/><div class="controls bullet"><span class="by">omgwtfbyobbq</span><span>|</span><a href="#39137181">root</a><span>|</span><a href="#39137633">parent</a><span>|</span><a href="#39139278">next</a><span>|</span><label class="collapse" for="c-39137762">[-]</label><label class="expand" for="c-39137762">[1 more]</label></div><br/><div class="children"><div class="content">Nice! That would perfect for fully automated testing if a user didn&#x27;t need to specify any primitive actions. I&#x27;m sure it still saves a ton of time&#x2F;catches many bugs.</div><br/></div></div></div></div></div></div></div></div><div id="39139278" class="c"><input type="checkbox" id="c-39139278" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#39137181">prev</a><span>|</span><a href="#39138140">next</a><span>|</span><label class="collapse" for="c-39139278">[-]</label><label class="expand" for="c-39139278">[1 more]</label></div><br/><div class="children"><div class="content">Exploratory testing has been a huge way for me to build user friendly products. But I guess when you work in a large project that you are not paid to do exploratory testing, therefore product usability can end up terrible with end users hating ever using the thing!</div><br/></div></div><div id="39138140" class="c"><input type="checkbox" id="c-39138140" checked=""/><div class="controls bullet"><span class="by">satisfice</span><span>|</span><a href="#39139278">prev</a><span>|</span><a href="#39136806">next</a><span>|</span><label class="collapse" for="c-39138140">[-]</label><label class="expand" for="c-39138140">[3 more]</label></div><br/><div class="children"><div class="content">According to the guys who introduced the terminology of &quot;checking&quot; as a term of art in 2010 (Michael Bolton and me), checking is not a &quot;form&quot; of testing. It&#x27;s not testing in and of itself. But it is a part of testing.<p>We introduced the terminology because we think it&#x27;s important for the craft of testing that we reserve the word &quot;testing&quot; for an essentially human process. Testing is what people do.<p>Testing is evaluating a product by learning about it via exploring, experiencing, and experimenting.<p>Checking is a mechanical process of operating a product and evaluating its output algorithmically.<p>A tester frequently performs a check. And all automation that is called a &quot;test&quot; is actually a check by this definition.<p>All testing is exploratory to some degree. Much of testing involves performing a check at some point.<p>This way of thinking leads to a richer and deeper craft of testing than the alternative popular notion.<p>See: 
<a href="https:&#x2F;&#x2F;www.satisfice.com&#x2F;blog&#x2F;archives&#x2F;1509" rel="nofollow">https:&#x2F;&#x2F;www.satisfice.com&#x2F;blog&#x2F;archives&#x2F;1509</a>
<a href="https:&#x2F;&#x2F;www.satisfice.com&#x2F;blog&#x2F;archives&#x2F;856" rel="nofollow">https:&#x2F;&#x2F;www.satisfice.com&#x2F;blog&#x2F;archives&#x2F;856</a></div><br/><div id="39139811" class="c"><input type="checkbox" id="c-39139811" checked=""/><div class="controls bullet"><span class="by">tveyben</span><span>|</span><a href="#39138140">parent</a><span>|</span><a href="#39138170">next</a><span>|</span><label class="collapse" for="c-39139811">[-]</label><label class="expand" for="c-39139811">[1 more]</label></div><br/><div class="children"><div class="content">I’m glad to see you here James, I was just about to make a comment linking to you’re site ;-)<p>&#x2F;A happy exploratory tester</div><br/></div></div><div id="39138170" class="c"><input type="checkbox" id="c-39138170" checked=""/><div class="controls bullet"><span class="by">CipherPilot</span><span>|</span><a href="#39138140">parent</a><span>|</span><a href="#39139811">prev</a><span>|</span><a href="#39136806">next</a><span>|</span><label class="collapse" for="c-39138170">[-]</label><label class="expand" for="c-39138170">[1 more]</label></div><br/><div class="children"><div class="content">While I understand the motivation for disambiguating &quot;checking&quot; from &quot;testing&quot; conceptually, I have some concerns about how this framework may play out in practice. What constitutes a &quot;mechanical&quot; check vs a human &quot;exploration&quot;, for example, could likely be a source of endless debate. And is it truly useful to separate the two when most testing undoubtedly involves elements of both? A more pragmatic definition may be preferable to one that sets up a dubious distinction prone to subjective interpretation. Nonetheless, I appreciate the attempt to enrich discussion around strategic testing methodologies at a time when clear terminology is needed to match the complexity of modern software systems.</div><br/></div></div></div></div><div id="39136806" class="c"><input type="checkbox" id="c-39136806" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#39138140">prev</a><span>|</span><label class="collapse" for="c-39136806">[-]</label><label class="expand" for="c-39136806">[2 more]</label></div><br/><div class="children"><div class="content">This is not the topic I expected from the title :)</div><br/><div id="39138716" class="c"><input type="checkbox" id="c-39138716" checked=""/><div class="controls bullet"><span class="by">frogulis</span><span>|</span><a href="#39136806">parent</a><span>|</span><label class="collapse" for="c-39138716">[-]</label><label class="expand" for="c-39138716">[1 more]</label></div><br/><div class="children"><div class="content">Really? It was exactly what I expected. What did you expect?</div><br/></div></div></div></div></div></div></div></div></div></body></html>