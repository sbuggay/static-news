<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704704462120" as="style"/><link rel="stylesheet" href="styles.css?v=1704704462120"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/sysprog21/shecc">Shecc: A self-hosting and educational C optimizing compiler</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>eatonphil</span> | <span>18 comments</span></div><br/><div><div id="38908697" class="c"><input type="checkbox" id="c-38908697" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#38906022">next</a><span>|</span><label class="collapse" for="c-38908697">[-]</label><label class="expand" for="c-38908697">[4 more]</label></div><br/><div class="children"><div class="content">I keep vacillating on whether to use Go or Rust for my next cli or desktop tool (eg., for desktop egui in Rust). However, every time I see C or start to write it, I just see in it too much fun. In Go I see boredem, and Rust, frustration.<p>I&#x27;m not writing production software for a large audience, at best tools for myself which a few others might use.<p>Yet, it also seems a waste to be using what many now regard as out dated tech.<p>It would be a great thing if a C-2030 could be arranged with a new standard library and a move-semantics compiler mode (say).</div><br/><div id="38909393" class="c"><input type="checkbox" id="c-38909393" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#38908697">parent</a><span>|</span><a href="#38908883">next</a><span>|</span><label class="collapse" for="c-38909393">[-]</label><label class="expand" for="c-38909393">[1 more]</label></div><br/><div class="children"><div class="content">Rust is frustrating if you try to write code in it like you would in languages you already know, and assume the borrow checker is just an annoyance you’re supposed to `clone()` your way out of.<p>If you try and learn what the ownership rules in the compiler are trying to teach you—admittedly less comprehensibly at times than you might prefer—about software design, it is an <i>incredibly</i> fun and rewarding language that will shape the way you write software in every other language.</div><br/></div></div><div id="38908883" class="c"><input type="checkbox" id="c-38908883" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#38908697">parent</a><span>|</span><a href="#38909393">prev</a><span>|</span><a href="#38906022">next</a><span>|</span><label class="collapse" for="c-38908883">[-]</label><label class="expand" for="c-38908883">[2 more]</label></div><br/><div class="children"><div class="content">... and arrays that don&#x27;t decay to pointers. (Which, in my opinion, is C&#x27;s real million-dollar mistake, not null pointers.)<p>Oh, and less undefined behaviors.</div><br/><div id="38909096" class="c"><input type="checkbox" id="c-38909096" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#38908697">root</a><span>|</span><a href="#38908883">parent</a><span>|</span><a href="#38906022">next</a><span>|</span><label class="collapse" for="c-38909096">[-]</label><label class="expand" for="c-38909096">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s seems fixable with a standard library, if you define,<p><pre><code>    typedef struct { byte *data; u64 len; } array;
    typedef struct { byte *data; u64 len; u64 cap; } vec;

    typedef struct { byte *data; u64 len; } string;
</code></pre>
etc.<p>Then developers will adhere to those apis, <i>so long as</i>, one&#x27;s own array-struct decays to the above, so there can be standard library fns against the above, eg.,<p><pre><code>    sort(array *a); 
</code></pre>
etc.</div><br/></div></div></div></div></div></div><div id="38906022" class="c"><input type="checkbox" id="c-38906022" checked=""/><div class="controls bullet"><span class="by">jserv</span><span>|</span><a href="#38908697">prev</a><span>|</span><a href="#38906058">next</a><span>|</span><label class="collapse" for="c-38906022">[-]</label><label class="expand" for="c-38906022">[1 more]</label></div><br/><div class="children"><div class="content">Shecc is a self-compiling compiler for 32-bit Arm and RISC-V architectures, focusing on a subset of the C language and incorporating basic optimization techniques. It generates executable Linux ELF binaries for ARMv7-A and RV32IM and includes a minimal C standard library for GNU&#x2F;Linux I&#x2F;O. Written in ANSI C, it is broadly compatible and features an integrated machine code generator, removing the need for external tools. The compiler uses a two-pass process for syntax checking and translating operations into machine code, and has a register allocation system for RISC-style architectures. Additionally, it includes an architecture-independent, SSA-based middle-end for enhanced optimizations.</div><br/></div></div><div id="38906058" class="c"><input type="checkbox" id="c-38906058" checked=""/><div class="controls bullet"><span class="by">yklcs</span><span>|</span><a href="#38906022">prev</a><span>|</span><a href="#38906267">next</a><span>|</span><label class="collapse" for="c-38906058">[-]</label><label class="expand" for="c-38906058">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been working on a C compiler with the goal of ANSI C compliance, and most of the projects described as a &quot;C compiler&quot; seem to only support an arbitrary subset of C. This project seems to support more than most educational&#x2F;toy CCs, but I still believe there’s value in implementing full standard C.</div><br/><div id="38909227" class="c"><input type="checkbox" id="c-38909227" checked=""/><div class="controls bullet"><span class="by">jserv</span><span>|</span><a href="#38906058">parent</a><span>|</span><a href="#38906441">next</a><span>|</span><label class="collapse" for="c-38909227">[-]</label><label class="expand" for="c-38909227">[1 more]</label></div><br/><div class="children"><div class="content">I am a faculty member at a university, and the main reason I initiated this project was to create a practical learning environment for my students. I have noticed that many tools labeled as &#x27;C compilers&#x27; only partially implement the C language, which has been a source of frustration for me. My goal is to demonstrate how to build a basic C compiler and enhance it to include some key features of the C99 standard, as well as optimization strategies commonly found in contemporary optimizing compilers. Despite its modest size, this project is robust and capable of self-hosting, meaning that students have the opportunity to develop an optimizing compiler that can compile its own code, progressively refining it for improved instruction per cycle (IPC) and better code density. Unable to find an existing one that met these expectations, I wrote a new one with my students.</div><br/></div></div><div id="38906441" class="c"><input type="checkbox" id="c-38906441" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38906058">parent</a><span>|</span><a href="#38909227">prev</a><span>|</span><a href="#38906765">next</a><span>|</span><label class="collapse" for="c-38906441">[-]</label><label class="expand" for="c-38906441">[1 more]</label></div><br/><div class="children"><div class="content">To me, a useful cutoff would be to define &quot;C compiler&quot; as anything that can compile TCC (the tiny c compiler, that can more-or-less compile the old C versions of GCC).<p>Maybe it&#x27;s legitimate to say &quot;TCC must be a single-file amalgam first and you have to use an external preprocessor&quot;.</div><br/></div></div><div id="38906765" class="c"><input type="checkbox" id="c-38906765" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#38906058">parent</a><span>|</span><a href="#38906441">prev</a><span>|</span><a href="#38906267">next</a><span>|</span><label class="collapse" for="c-38906765">[-]</label><label class="expand" for="c-38906765">[6 more]</label></div><br/><div class="children"><div class="content">What&#x27;re you thinking of doing with the preprocessor? Accept the complexity and build that too, run a pre-existing one, implement a subset of it, other...</div><br/><div id="38908547" class="c"><input type="checkbox" id="c-38908547" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38906058">root</a><span>|</span><a href="#38906765">parent</a><span>|</span><a href="#38906267">next</a><span>|</span><label class="collapse" for="c-38908547">[-]</label><label class="expand" for="c-38908547">[5 more]</label></div><br/><div class="children"><div class="content">IIRC C preprocessor is not very hard to implement according to the specification if you don&#x27;t worry too much about performance.</div><br/><div id="38909107" class="c"><input type="checkbox" id="c-38909107" checked=""/><div class="controls bullet"><span class="by">jserv</span><span>|</span><a href="#38906058">root</a><span>|</span><a href="#38908547">parent</a><span>|</span><a href="#38909339">next</a><span>|</span><label class="collapse" for="c-38909107">[-]</label><label class="expand" for="c-38909107">[2 more]</label></div><br/><div class="children"><div class="content">Yes, consider the case of shecc. It requires just a handful of C code lines to interpret directives set in the C preprocessor. Unlike relying on existing tools like cpp, as, or ld, shecc stands alone as a minimalist cross-compiler. This design could be particularly beneficial for students delving into the study of compiler construction. See <a href="https:&#x2F;&#x2F;github.com&#x2F;sysprog21&#x2F;shecc&#x2F;blob&#x2F;master&#x2F;src&#x2F;lexer.c#L245-L360">https:&#x2F;&#x2F;github.com&#x2F;sysprog21&#x2F;shecc&#x2F;blob&#x2F;master&#x2F;src&#x2F;lexer.c#L...</a></div><br/><div id="38909216" class="c"><input type="checkbox" id="c-38909216" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38906058">root</a><span>|</span><a href="#38909107">parent</a><span>|</span><a href="#38909339">next</a><span>|</span><label class="collapse" for="c-38909216">[-]</label><label class="expand" for="c-38909216">[1 more]</label></div><br/><div class="children"><div class="content">I largely meant a <i>standard-complaint</i> implementation though, which shecc doesn&#x27;t claim to be. ;-) In comparison I can easily see that this lexer is not suitable for preprocessor because C requires a superset of numeral tokens [1] during the preprocessing phase.<p>[1] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;translation_phases#Phase_3" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;translation_phases#...</a></div><br/></div></div></div></div><div id="38909339" class="c"><input type="checkbox" id="c-38909339" checked=""/><div class="controls bullet"><span class="by">defen</span><span>|</span><a href="#38906058">root</a><span>|</span><a href="#38908547">parent</a><span>|</span><a href="#38909107">prev</a><span>|</span><a href="#38906267">next</a><span>|</span><label class="collapse" for="c-38909339">[-]</label><label class="expand" for="c-38909339">[2 more]</label></div><br/><div class="children"><div class="content">The C preprocessor is hilariously underspecified in the standard, so implementing the standard doesn&#x27;t guarantee that you&#x27;ll be able to handle real-world C programs (even ones that don&#x27;t use GNU or clang extensions).</div><br/><div id="38909378" class="c"><input type="checkbox" id="c-38909378" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38906058">root</a><span>|</span><a href="#38909339">parent</a><span>|</span><a href="#38906267">next</a><span>|</span><label class="collapse" for="c-38909378">[-]</label><label class="expand" for="c-38909378">[1 more]</label></div><br/><div class="children"><div class="content">K&amp;R preprocessor was indeed underspecified and allowed lots of variations---much of those issues can be seen in the GCC manual [1]---, but the current ISO C is much better at that job AFAIK. I think `## __VA_ARGS__` is the only popular preprocessor extension [2] at this moment, as the standard replacement (`__VA_OPT__`) is still very new.<p>[1] <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Incompatibilities.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Incompatibilities.html</a><p>[2] Assuming that we don&#x27;t count things like `#pragma` or `#include_next`, which can be added without affecting other preprocessing jobs.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38906267" class="c"><input type="checkbox" id="c-38906267" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#38906058">prev</a><span>|</span><a href="#38907375">next</a><span>|</span><label class="collapse" for="c-38906267">[-]</label><label class="expand" for="c-38906267">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a really nice bit of work. I&#x27;m impressed at the number of really cool small C compilers out there now.</div><br/></div></div><div id="38907375" class="c"><input type="checkbox" id="c-38907375" checked=""/><div class="controls bullet"><span class="by">charlieyu1</span><span>|</span><a href="#38906267">prev</a><span>|</span><label class="collapse" for="c-38907375">[-]</label><label class="expand" for="c-38907375">[2 more]</label></div><br/><div class="children"><div class="content">TIL about Intermediate Representation. Makes it easier to understand.</div><br/><div id="38909140" class="c"><input type="checkbox" id="c-38909140" checked=""/><div class="controls bullet"><span class="by">jserv</span><span>|</span><a href="#38907375">parent</a><span>|</span><label class="collapse" for="c-38909140">[-]</label><label class="expand" for="c-38909140">[1 more]</label></div><br/><div class="children"><div class="content">While initializing shecc, it automatically creates a visualized control-flow graph and dominator tree. These can be visualized using Graphviz. To view them, execute the command &quot;make check-snapshots&quot; and then inspect the created CFG.dot and DOM.dot files.</div><br/></div></div></div></div></div></div></div></div></div></body></html>