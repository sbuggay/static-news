<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720602064561" as="style"/><link rel="stylesheet" href="styles.css?v=1720602064561"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://thiscontext.com/2023/07/26/dynamic-translation-of-smalltalk-to-webassembly/">Dynamic translation of Smalltalk to WebAssembly</a> <span class="domain">(<a href="https://thiscontext.com">thiscontext.com</a>)</span></div><div class="subtext"><span>lioeters</span> | <span>23 comments</span></div><br/><div><div id="40917104" class="c"><input type="checkbox" id="c-40917104" checked=""/><div class="controls bullet"><span class="by">stevedekorte</span><span>|</span><a href="#40915447">next</a><span>|</span><label class="collapse" for="c-40917104">[-]</label><label class="expand" for="c-40917104">[4 more]</label></div><br/><div class="children"><div class="content">Great to see work like this being done. Javascript is often a &quot;good enough&quot; language, but an efficient Smalltalk (or Self) language with support for things like system images, become:, coroutines, and other advanced features would open up a lot of advanced programming techniques like fast portable images, transparent futures, cooperative concurrency without async&#x2F;await on every call, etc.</div><br/><div id="40917859" class="c"><input type="checkbox" id="c-40917859" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#40917104">parent</a><span>|</span><a href="#40915447">next</a><span>|</span><label class="collapse" for="c-40917859">[-]</label><label class="expand" for="c-40917859">[3 more]</label></div><br/><div class="children"><div class="content">On a similar note, you can now run Scheme in the browser via wasm: <a href="https:&#x2F;&#x2F;spritely.institute&#x2F;hoot&#x2F;" rel="nofollow">https:&#x2F;&#x2F;spritely.institute&#x2F;hoot&#x2F;</a><p>The current release can do coroutines via the delimited continuation support, but the next release will have ready-to-use lightweight threads (aka &quot;fibers&quot;) that integrate with JS promises. No async&#x2F;await marked functions&#x2F;calls.</div><br/><div id="40921831" class="c"><input type="checkbox" id="c-40921831" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#40917104">root</a><span>|</span><a href="#40917859">parent</a><span>|</span><a href="#40919427">next</a><span>|</span><label class="collapse" for="c-40921831">[-]</label><label class="expand" for="c-40921831">[1 more]</label></div><br/><div class="children"><div class="content">Effect-ts is also built on the same principles (fibers) if one wants to stay in TS land.<p><a href="https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;guides&#x2F;runtime" rel="nofollow">https:&#x2F;&#x2F;effect.website&#x2F;docs&#x2F;guides&#x2F;runtime</a></div><br/></div></div><div id="40919427" class="c"><input type="checkbox" id="c-40919427" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#40917104">root</a><span>|</span><a href="#40917859">parent</a><span>|</span><a href="#40921831">prev</a><span>|</span><a href="#40915447">next</a><span>|</span><label class="collapse" for="c-40919427">[-]</label><label class="expand" for="c-40919427">[1 more]</label></div><br/><div class="children"><div class="content">As an Obj-C guy, if I declare a method as input only and no return, it can run async in the run loop.<p>I <i>assume</i> Smalltalk can do the same?</div><br/></div></div></div></div></div></div><div id="40915447" class="c"><input type="checkbox" id="c-40915447" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40917104">prev</a><span>|</span><a href="#40917376">next</a><span>|</span><label class="collapse" for="c-40915447">[-]</label><label class="expand" for="c-40915447">[16 more]</label></div><br/><div class="children"><div class="content">&gt; I don’t expect the WASM translations to be much (or any) faster at the moment, but I do expect them to get faster over time, as the WASM engines in web browsers improve (just as JS engines have).<p>I haven&#x27;t been following WASM progress, do people generally share this optimism for WASM performance improvement over time, relative to JS? I was under the vague impression that all the &quot;obvious&quot; optimizations had already been done (i.e. JIT, and more recently, SIMD support)</div><br/><div id="40916496" class="c"><input type="checkbox" id="c-40916496" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#40915447">parent</a><span>|</span><a href="#40916267">next</a><span>|</span><label class="collapse" for="c-40916496">[-]</label><label class="expand" for="c-40916496">[1 more]</label></div><br/><div class="children"><div class="content">I think it depends on what you are doing... I think there are huge opportunities for interop performance as well as just optimized process paths for certain things. I&#x27;m not that deep on the technical side, more of an avid observer.  It just seems that as long as many things in WASM are slower than general performance for say Java or C#, that there is definitely room to improve things.<p>As an example, looking at the in-the-box Garbage Collection support that&#x27;s being flushed out, as an example will improve languages that rely on GC (C#, Java, Go, etc) without having to include an implementation for the runtime.<p>Another point where there&#x27;s potential for massive gains are the browser UI interop as well, and I think there&#x27;s been a lot of effort to work within&#x2F;around current limitations, but obviously there&#x27;s room to improve.</div><br/></div></div><div id="40916267" class="c"><input type="checkbox" id="c-40916267" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#40915447">parent</a><span>|</span><a href="#40916496">prev</a><span>|</span><a href="#40917304">next</a><span>|</span><label class="collapse" for="c-40916267">[-]</label><label class="expand" for="c-40916267">[6 more]</label></div><br/><div class="children"><div class="content">There seems to be alot of work going into WASM itself, much of it is performance related:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;proposals">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;proposals</a></div><br/><div id="40916774" class="c"><input type="checkbox" id="c-40916774" checked=""/><div class="controls bullet"><span class="by">mjhay</span><span>|</span><a href="#40915447">root</a><span>|</span><a href="#40916267">parent</a><span>|</span><a href="#40917304">next</a><span>|</span><label class="collapse" for="c-40916774">[-]</label><label class="expand" for="c-40916774">[5 more]</label></div><br/><div class="children"><div class="content">If only you could directly access the DOM or other browser APIs. I understand the GC proposal might help with this (?).</div><br/><div id="40919521" class="c"><input type="checkbox" id="c-40919521" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#40915447">root</a><span>|</span><a href="#40916774">parent</a><span>|</span><a href="#40923196">next</a><span>|</span><label class="collapse" for="c-40919521">[-]</label><label class="expand" for="c-40919521">[3 more]</label></div><br/><div class="children"><div class="content">I found a discussion with some explanations to why that is and what other solutions could be looked at:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;design&#x2F;issues&#x2F;1184">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;design&#x2F;issues&#x2F;1184</a></div><br/><div id="40923206" class="c"><input type="checkbox" id="c-40923206" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#40915447">root</a><span>|</span><a href="#40919521">parent</a><span>|</span><a href="#40920937">next</a><span>|</span><label class="collapse" for="c-40923206">[-]</label><label class="expand" for="c-40923206">[1 more]</label></div><br/><div class="children"><div class="content"><i>”The main reason is that direct access to the DOM requires the ability to pass references to DOM&#x2F;JS objects through Wasm. Consequently, when GC happens for JavaScript, the collector must be able to find and update such references on the live Wasm stack, in Wasm globals, or in other places controlled by the Wasm engine. Hence the engine effectively needs to support GC in some form.<p>However, the new proposal for reference types that we split off from the GC proposal tries to give a more nuanced answer to that. It introduces reference types without any functionality for allocating anything within Wasm itself. In an embedding where host references are garbage-collected that still requires a Wasm implementation to understand GC. But in other embeddings it does not need to.”</i></div><br/></div></div><div id="40920937" class="c"><input type="checkbox" id="c-40920937" checked=""/><div class="controls bullet"><span class="by">mjhay</span><span>|</span><a href="#40915447">root</a><span>|</span><a href="#40919521">parent</a><span>|</span><a href="#40923206">prev</a><span>|</span><a href="#40923196">next</a><span>|</span><label class="collapse" for="c-40920937">[-]</label><label class="expand" for="c-40920937">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. That helps with my confusion a lot.</div><br/></div></div></div></div><div id="40923196" class="c"><input type="checkbox" id="c-40923196" checked=""/><div class="controls bullet"><span class="by">mason_mpls</span><span>|</span><a href="#40915447">root</a><span>|</span><a href="#40916774">parent</a><span>|</span><a href="#40919521">prev</a><span>|</span><a href="#40917304">next</a><span>|</span><label class="collapse" for="c-40923196">[-]</label><label class="expand" for="c-40923196">[1 more]</label></div><br/><div class="children"><div class="content">As someone who wants WASM to free us all from JS. Is this even worth it if DOM bindings for WASM will never get a released? I’ve been following this since 2018 and it seems like we’re still at square 1 with DOM bindings. Incredibly frustrating.</div><br/></div></div></div></div></div></div><div id="40917304" class="c"><input type="checkbox" id="c-40917304" checked=""/><div class="controls bullet"><span class="by">Oreb</span><span>|</span><a href="#40915447">parent</a><span>|</span><a href="#40916267">prev</a><span>|</span><a href="#40917895">next</a><span>|</span><label class="collapse" for="c-40917304">[-]</label><label class="expand" for="c-40917304">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  I was under the vague impression that all the &quot;obvious&quot; optimizations had already been done (i.e. JIT, and more recently, SIMD support)<p>Aren’t threads still missing? That seems like a pretty major optimization, now that almost any CPU you can buy has multiple cores.</div><br/><div id="40917378" class="c"><input type="checkbox" id="c-40917378" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#40915447">root</a><span>|</span><a href="#40917304">parent</a><span>|</span><a href="#40917895">next</a><span>|</span><label class="collapse" for="c-40917378">[-]</label><label class="expand" for="c-40917378">[3 more]</label></div><br/><div class="children"><div class="content">Yes, but they&#x27;re very close to being standardized and have multiple existing implementations among different browser engines and also non-browser runtimes. (Of course, I don&#x27;t think the threading proposal is exactly what OP had in mind for the case of general WASM perf improvements, but you are right it is in practice a big performance barrier in the bigger scheme.)</div><br/><div id="40917509" class="c"><input type="checkbox" id="c-40917509" checked=""/><div class="controls bullet"><span class="by">garaetjjte</span><span>|</span><a href="#40915447">root</a><span>|</span><a href="#40917378">parent</a><span>|</span><a href="#40917895">next</a><span>|</span><label class="collapse" for="c-40917509">[-]</label><label class="expand" for="c-40917509">[2 more]</label></div><br/><div class="children"><div class="content">Shared memory is standardized, you can run WASM threads in the browser through web workers. WASI threads standardization is in limbo because apparently component model is very important and nobody knows how threads will interact with that.</div><br/><div id="40918114" class="c"><input type="checkbox" id="c-40918114" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#40915447">root</a><span>|</span><a href="#40917509">parent</a><span>|</span><a href="#40917895">next</a><span>|</span><label class="collapse" for="c-40918114">[-]</label><label class="expand" for="c-40918114">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I should have been more explicit: the raw WASM proposal only really defines how shared memory and cross-thread atomics work where it&#x27;s assumed each thread runs a wasm module (with shared memory regions that are appropriately mapped.) It does not specify how the host environment actually spawns or manages threads or what hostcalls are available for that.<p>That said I think in the browser something like emscripten can do something akin to &quot;use web workers with shared array buffers&quot; to back it all up so that threading APIs roughly work, but yes, WASI currently has nothing for this.</div><br/></div></div></div></div></div></div></div></div><div id="40917895" class="c"><input type="checkbox" id="c-40917895" checked=""/><div class="controls bullet"><span class="by">connicpu</span><span>|</span><a href="#40915447">parent</a><span>|</span><a href="#40917304">prev</a><span>|</span><a href="#40915600">next</a><span>|</span><label class="collapse" for="c-40917895">[-]</label><label class="expand" for="c-40917895">[1 more]</label></div><br/><div class="children"><div class="content">From my understanding, most of the WASM performance improvement expectations have been around the cost of calling browser APIs from within WASM. The performance itself is basically near native speed with a small overhead for the cost of bounds checking&#x2F;wrapping the memory block. Last I checked, most WASM apps are calling DOM APIs through a javascript middleman, which obviously sucks for performance. But native importing of DOM APIs is something that I believe was being worked on and could be here soon?</div><br/></div></div><div id="40915752" class="c"><input type="checkbox" id="c-40915752" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#40915447">parent</a><span>|</span><a href="#40915600">prev</a><span>|</span><a href="#40915718">next</a><span>|</span><label class="collapse" for="c-40915752">[-]</label><label class="expand" for="c-40915752">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;d be surprised. I&#x27;m sure there are improvements to be made out there (e.g. maybe the sandbox could be faster) but the crazy leaps we&#x27;ve seen in JS performance are primarily because the complexity in the language makes for a very complex implementation with plenty of inefficiencies. By comparison WASM is already pretty close to the metal.</div><br/></div></div></div></div><div id="40917376" class="c"><input type="checkbox" id="c-40917376" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#40915447">prev</a><span>|</span><label class="collapse" for="c-40917376">[-]</label><label class="expand" for="c-40917376">[2 more]</label></div><br/><div class="children"><div class="content">Craig Latta&#x27;s Caffeine work live coding with Smalltalk and SqueakJS is amazing.<p><a href="https:&#x2F;&#x2F;observablehq.com&#x2F;@ccrraaiigg&#x2F;caffeine" rel="nofollow">https:&#x2F;&#x2F;observablehq.com&#x2F;@ccrraaiigg&#x2F;caffeine</a><p>&gt;Caffeine integrates SqueakJS, a JavaScript implementation of the Squeak Smalltalk virtual machine, with several JavaScript runtime environments, including web frontends (web browsers, with DOM, DevTools, and Observable integration), backends (Node]S), and Web Workers.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ccrraaiigg">https:&#x2F;&#x2F;github.com&#x2F;ccrraaiigg</a><p>Craig Latta - Caffeine - 26 May 2021:<p><a href="https:&#x2F;&#x2F;vimeo.com&#x2F;591827638" rel="nofollow">https:&#x2F;&#x2F;vimeo.com&#x2F;591827638</a><p>&gt;Caffeine ( caffeine.js.org ) is a livecoded integration of the SqueakJS Smalltalk virtual machine with the Web platform and its many frameworks. Craig Latta will show the current state of Caffeine development through live manipulation and combination of those frameworks. The primary vehicle is a Caffeine app called Worldly, combining the A-Frame VR framework, screen-sharing, and the Chrome Debugging Protocol into an immersive virtual-reality workspace.<p>&gt;Craig Latta ( blackpagedigital.com ) is a livecoding composer from California. He studied music at Berkeley, where he learned Smalltalk as an improvisation practice. He has worked as a research computer scientist at Atari Games, IBM&#x27;s Watson lab, and Lam Research. In 2016 he began combining Smalltalk technologies with the Web platform, with an emphasis on spatial computing. He is currently exploring spatial audio for immersive workspaces.<p>SqueakJS – A Squeak VM in JavaScript (squeak.js.org)
115 points by gjvc on Oct 27, 2021 | hide | past | favorite | 24 comments<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29018465">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29018465</a><p>DonHopkins on Oct 27, 2021 | prev | next [–]<p>One thing that&#x27;s amazing about SqueakJS (and one reason this VM inside another VM runs so fast) is the way Vanessa Freudenberg elegantly and efficiently created a hybrid Smalltalk garbage collector that works with the JavaScript garbage collector.<p>SqueakJS: A Modern and Practical Smalltalk That Runs in Any Browser<p><a href="https:&#x2F;&#x2F;freudenbergs.de&#x2F;vanessa&#x2F;publications&#x2F;Freudenberg-2014-SqueakJS.pdf" rel="nofollow">https:&#x2F;&#x2F;freudenbergs.de&#x2F;vanessa&#x2F;publications&#x2F;Freudenberg-201...</a><p>&gt;The fact that SqueakJS represents Squeak objects as plain JavaScript objects and integrates with the JavaScript garbage collection (GC) allows existing JavaScript code to interact with Squeak objects. This has proven useful during development as we could re-use existing JavaScript tools to inspect and manipulate Squeak objects as they appear in the VM. This means that SqueakJS is not only a “Squeak in the browser”, but also that it provides practical support for using Smalltalk in a JavaScript environment.<p>&gt;[...] a hybrid garbage collection scheme to allow Squeak object enumeration without a dedicated object table, while delegating as much work as possible to the JavaScript GC, [...]<p>&gt;2.3 Cleaning up Garbage<p>&gt;Many core functions in Squeak depend on the ability to enumerate objects of a specific class using the firstInstance and nextInstance primitive methods. In Squeak, this is easily implemented since all objects are contiguous in memory, so one can simply scan from the beginning and return the next available instance. This is not possible in a hosted implementation where the host does not provide enumeration, as is the case for Java and JavaScript. Potato used a weak-key object table to keep track of objects to enumerate them. Other implementations, like the R&#x2F;SqueakVM, use the host garbage collector to trigger a full GC and yield all objects of a certain type. These are then temporarily kept in a list for enumeration. In JavaScript, neither weak references, nor access to the GC is generally available, so neither option was possible for SqueakJS. Instead, we designed a hybrid GC scheme that provides enumeration while not requiring weak pointer support, and still retaining the benefit of the native host GC.<p>&gt;SqueakJS manages objects in an old and new space, akin to a semi-space GC. When an image is loaded, all objects are created in the old space. Because an image is just a snapshot of the object memory when it was saved, all objects are consecutive in the image. When we convert them into JavaScript objects, we create a linked list of all objects. This means, that as long as an object is in the SqueakJS old-space, it cannot be garbage collected by the JavaScript VM. New objects are created in a virtual new space. However, this space does not really exist for the SqueakJS VM, because it simply consists of Squeak objects that are not part of the old-space linked list. New objects that are dereferenced are simply collected by the JavaScript GC.<p>&gt;When full GC is triggered in SqueakJS (for example because the nextInstance primitive has been called on an object that does not have a next link) a two-phase collection is started. In the first pass, any new objects that are referenced from surviving objects are added to the end of the linked list, and thus become part of the old space. In a second pass, any objects that are already in the linked list, but were not referenced from surviving objects are removed from the list, and thus become eligible for ordinary JavaScript GC. Note also, that we append objects to the old list in the order of their creation, simply by ordering them by their object identifiers (IDs). In Squeak, these are the memory offsets of the object. To be able to save images that can again be opened with the standard Squeak VM, we generate object IDs that correspond to the offset the object would have in an image. This way, we can serialize our old object space and thus save binary compatible Squeak images from SqueakJS.<p>&gt;To implement Squeak’s weak references, a similar scheme can be employed: any weak container is simply added to a special list of root objects that do not let their references survive. If, during a full GC, a Squeak object is found to be only referenced from one of those weak roots, that reference is removed, and the Squeak object is again garbage collected by the JavaScript GC.<p>DonHopkins on Oct 27, 2021 | parent | next [–]<p>Also:
The Evolution of Smalltalk: From Smalltalk-72 through Squeak. DANIEL INGALLS, Independent Consultant, USA<p><a href="https:&#x2F;&#x2F;smalltalkzoo.thechm.org&#x2F;papers&#x2F;EvolutionOfSmalltalk.pdf" rel="nofollow">https:&#x2F;&#x2F;smalltalkzoo.thechm.org&#x2F;papers&#x2F;EvolutionOfSmalltalk....</a><p>&gt;A.5 Squeak<p>&gt;Although Squeak is still available for most computers, SqueakJS has become the easiest way to run Squeak for most users. It runs in just about any web browser, which helps in schools that do not allow the installation of non-standard software.<p>&gt;The germ of the SqueakJS project began not long after I was hired at Sun Microsystems. I felt I should learn Java; casting about for a suitable project, I naturally chose to implement a Squeak VM. This I did; the result still appears to run at <a href="http:&#x2F;&#x2F;weather-dimensions.com&#x2F;Dan&#x2F;SqueakOnJava.jar" rel="nofollow">http:&#x2F;&#x2F;weather-dimensions.com&#x2F;Dan&#x2F;SqueakOnJava.jar</a> .<p>&gt;This VM is known in the Squeak community as &quot;Potato&quot; because of some difficulty clearing names with the trademark people at Sun. Much later, when I got the Smalltalk-72 interpreter running in JavaScript, Bert and I were both surprised at how fast it ran. Bert said, &quot;Hmm, I wonder if it’s time to consider trying to run Squeak in JavaScript.&quot; I responded with &quot;Hey, JavaScript is pretty similar to Java; you could just start with my Potato code and have something running in no time.&quot;<p>&gt;&quot;No time&quot; turned into a bit more than a week, but the result was enough to get Bert excited. The main weakness in Potato had been the memory model, and Bert came up with a beautiful scheme to leverage the native JavaScript storage management while providing the kind of control that was needed in the Squeak VM. Anyone interested in hosting a managed-memory language system in JavaScript should read his paper on SqueakJS, presented at the Dynamic Languages Symposium [Freudenberg et al. 2014].<p>&gt;From there on Bert has continued to put more attention on performance and reliability, and SqueakJS now boasts the ability to run every Squeak image since the first release in 1996. To run the system live, visit this url: <a href="https:&#x2F;&#x2F;smalltalkzoo.thechm.org&#x2F;HOPL-Squeak.html?launch" rel="nofollow">https:&#x2F;&#x2F;smalltalkzoo.thechm.org&#x2F;HOPL-Squeak.html?launch</a><p>codefrau on Nov 5, 2021 | root | parent | next [–]<p>Dan published an updated version of that paper here:<p><a href="https:&#x2F;&#x2F;smalltalkzoo.thechm.org&#x2F;papers&#x2F;EvolutionOfSmalltalk.pdf" rel="nofollow">https:&#x2F;&#x2F;smalltalkzoo.thechm.org&#x2F;papers&#x2F;EvolutionOfSmalltalk....</a><p>Would be great if you could cite that one next time. The main improvement for me is not being deadnamed. There are other corrections as well.</div><br/><div id="40917424" class="c"><input type="checkbox" id="c-40917424" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#40917376">parent</a><span>|</span><label class="collapse" for="c-40917424">[-]</label><label class="expand" for="c-40917424">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s some stuff Vanessa and I discussed about Self and her SqueakJS paper:<p>DonHopkins 6 months ago | parent | context | favorite | on: Croquet: Live, network-transparent 3D gaming<p>Excellent article -- Liam Proven does it again!
Speaking of a big Plate of Shrimp -- <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rJE2gPQ_Yp8" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rJE2gPQ_Yp8</a> ...<p>The incredible Smalltalk developer Vanessa Freudenberg -- who besides being Croquet&#x27;s devops person, also developed Squeak Smalltalk, EToys, Croquet, and the SqueakJS VM written in JavaScript, and worked extensively with Alan Kay -- was just tweeting (yeah, it&#x27;s ok to deadname Twitter!) about reviving Croquet from 20 years ago:<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;codefrau&#x2F;status&#x2F;1738778761104068754" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;codefrau&#x2F;status&#x2F;1738778761104068754</a><p>Vanessa Freudenberg @codefrau<p>I&#x27;ve been having fun reviving the Croquet from 20 years ago using @SqueakJS . It&#x27;s not perfect yet, but a lot of the old demos work (sans collaboration, so far). This is pretty close to the version Alan Kay used to give his Turing Award lecture in 2004:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;codefrau&#x2F;jasmine">https:&#x2F;&#x2F;github.com&#x2F;codefrau&#x2F;jasmine</a><p>Live version: <a href="https:&#x2F;&#x2F;codefrau.github.io&#x2F;jasmine" rel="nofollow">https:&#x2F;&#x2F;codefrau.github.io&#x2F;jasmine</a><p>This is a version of Croquet Jasmine running on the SqueakJS virtual machine. Here is an early demo of the system from 2003. Alan Kay used it for his Turing Award lecture in 2004. While working on that demo, David Smith posted some blog entries (1, 2, 3, 4, 5), with screenshots uploaded to his Flickr album.<p>This is work-in-progress. Contributions are very welcome.<p>— Vanessa Freudenberg, December 2023<p>Dan Ingalls @daningalls<p>Yay Vanessa! This is awesome. These are mileposts in our history that now live again!<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;codefrau&#x2F;status&#x2F;1526618670134308864" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;codefrau&#x2F;status&#x2F;1526618670134308864</a><p>Vanessa Freudenberg @codefrau 7:40 PM · May 17, 2022<p>My company @CroquetIO announced #MicroverseBuilder today.<p>Each microverse is &quot;just&quot; a static web page that you can deploy anywhere, but it is fully 3D multiplayer, and can be live-coded. Portals show and link to other developer&#x27;s worlds.<p>This is our vision of the #DemocratizedMetaverse as opposed to the &quot;Megaverses&quot; owned by Big Tech.<p>It runs on #CroquetOS inside your browser, which provides the client-side real-time synchronized JS VMs that you already know from my other posts.<p>#MicroverseBuilder is in closed alpha right now because we don&#x27;t have enough #devrel people yet (we&#x27;re hiring!) but you can join our Discord in the mean time and the open beta is not far away.<p>We are also looking for summer interns! #internships<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=CvvuAbjh11U" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=CvvuAbjh11U</a><p>And of course #CroquetOS itself is already available for you to build multiplayer apps, as is our #WorldcoreEngine, the game engine underlying #MicroverseBuilder.<p>Learn more at <a href="https:&#x2F;&#x2F;croquet.io&#x2F;docs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;croquet.io&#x2F;docs&#x2F;</a> and let&#x27;s get hacking :)<p>And as of today, #MicroverseBuilder is Open Source!<p>lproven 6 months ago | next [–]<p>Thanks Don!
This is my original submission from back at the time:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35302162">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35302162</a><p>HN really needs a better automatic-deduplication engine. E.g. If the same link is posted again months later, mark the original post as new again with an upvote, and the caption (if changed) as a comment...<p>codefrau 6 months ago | prev [–]<p>Haha, thanks for the plug, Don!<p>I just fleshed out the README for my Croquet resurrection yesterday so others may have an easier time trying it. It maybe even contribute :)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;codefrau&#x2F;jasmine">https:&#x2F;&#x2F;github.com&#x2F;codefrau&#x2F;jasmine</a><p>DonHopkins 6 months ago | parent [–]<p>Vanessa, it has always amazed me how you managed to square the circle and pull a rabbit out of a hat by the way you got garbage collection to work efficiently in SqueakJS, making Smalltalk and JavaScript cooperate without ending up with two competing garbage collectors battling it out. (Since you can&#x27;t enumerate &quot;pointers&quot; with JavaScript references by just incrementing them.)<p><a href="https:&#x2F;&#x2F;freudenbergs.de&#x2F;vanessa&#x2F;publications&#x2F;Freudenberg-2014-SqueakJS.pdf" rel="nofollow">https:&#x2F;&#x2F;freudenbergs.de&#x2F;vanessa&#x2F;publications&#x2F;Freudenberg-201...</a><p>&gt;The fact that SqueakJS represents Squeak objects as plain JavaScript objects and integrates with the JavaScript garbage collection (GC) allows existing JavaScript code to interact with Squeak objects. [...]<p>&gt;• a hybrid garbage collection scheme to allow Squeak object enumeration without a dedicated object table, while delegating as much work as possible to the JavaScript GC,<p>Have you ever thought about implementing a Smalltalk VM in WebAssembly, and how you could use the new reference types for that?<p><a href="https:&#x2F;&#x2F;bytecodealliance.org&#x2F;articles&#x2F;reference-types-in-wasmtime" rel="nofollow">https:&#x2F;&#x2F;bytecodealliance.org&#x2F;articles&#x2F;reference-types-in-was...</a><p>codefrau 6 months ago | root | parent [–]<p>I would like to speed up some parts of SqueakJS using web assembly. For example BitBlt would be a prime target.
For the overall VM, however, I’ll leave that to others (I know Craig Latta has been making progress).<p>I just love coding and debugging in a dynamic high-level language. The only thing we could potentially gain from WASM is speed, but we would lose a lot in readability, flexibility, and to be honest, fun.<p>I’d much rather make the SqueakJS JIT produce code that the JavaScript JIT can optimize well. That would potentially give us more speed than even WASM.<p>Peep my brain dumps and experiments at <a href="https:&#x2F;&#x2F;squeak.js.org&#x2F;docs&#x2F;jit.md.html" rel="nofollow">https:&#x2F;&#x2F;squeak.js.org&#x2F;docs&#x2F;jit.md.html</a><p>DonHopkins 6 months ago | root | parent | next [–]<p>&gt;Where this scheme gets interesting is when the execution progressed somewhat deep into a nested call chain and we then need to deal with contexts. It could be that execution is interrupted by a process switch, or that the code reads some fields of thisContext, or worse, writes into a field of thisContext. Other “interesting” occasions are garbage collections, or when we want to snapshot the image. Let&#x27;s look at these in turn.
This sounds similar to Self&#x27;s &quot;dynamic deoptimization&quot; that it uses to forge virtual stack frames representing calls into inlined code, for the purposes of the debugger showing you the return stack that you would have were the functions not inlined.<p>I always thought that should be called &quot;dynamic pessimization&quot;.<p>Debugging Optimized Code with Dynamic Deoptimization. Urs Hölzle, Craig Chambers, and David Ungar, SIGPLAN Notices 27(7), July, 1992.<p><a href="https:&#x2F;&#x2F;bibliography.selflanguage.org&#x2F;dynamic-deoptimization.html" rel="nofollow">https:&#x2F;&#x2F;bibliography.selflanguage.org&#x2F;dynamic-deoptimization...</a><p>That paper really blew my mind and cemented my respect for Self, in how they were able to deliver on such idealistic promises of simplicity and performance, and then oh by the way, you can also debug it too.<p>codefrau 6 months ago | root | parent | next [–]<p>Absolutely. And you know Lars Bak went from Self to Strongtalk to Sun’s Java Hotspot VM to Google’s V8 JavaScript engine.
My plan is to do as little as necessary to leverage the enormous engineering achievements in modern JS runtimes.<p>DonHopkins 6 months ago | root | parent | prev [–]<p>Glad I asked! Fun holiday reading to curl up with a cat to read. Thanks!<p>I love Caffeine, and I use Craig&#x27;s table every day! Not a look-up table, more like a big desk, which I bought from him when he left Amsterdam. ;)<p>---<p>Vanessa&gt; Our guiding principle will be to keep our own optimizations to a minimum in order to have quick compiles, but structure the generated code in a way so that the host JIT can perform its own optimizations well.<p>Don&gt; That&#x27;s the beautiful thing about layering the SqueakJS VM on top of the JS VM: you&#x27;ve already paid for it, it works really well, so you might as well use it to its full extent!<p>Very different set of trade-offs than implementing Self in C++.<p>Vanessa&gt; Precisely. My plan is to do as little as necessary to leverage the enormous engineering achievements in modern JS runtimes.</div><br/></div></div></div></div></div></div></div></div></div></body></html>