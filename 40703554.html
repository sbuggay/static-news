<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718701258927" as="style"/><link rel="stylesheet" href="styles.css?v=1718701258927"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://skarnet.org/software/nsss/">Nsss: A secure NSS-like implementation for static linking</a> <span class="domain">(<a href="https://skarnet.org">skarnet.org</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>26 comments</span></div><br/><div><div id="40706444" class="c"><input type="checkbox" id="c-40706444" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40708083">next</a><span>|</span><label class="collapse" for="c-40706444">[-]</label><label class="expand" for="c-40706444">[4 more]</label></div><br/><div class="children"><div class="content">&gt; That daemon should be set up by the system administrator.<p>One of the reasons why nsswitch runs in the client process is that the modules may very well need access to files that are only readable by the user (kerberos tickets...) or in other ways depend on the authority of the user process. Running this as a system-wide daemon makes such things hard to do as it requires reimplementing security checks that simply work in the in-process case and may very well lead to the daemon having to run with particularly high privileges (read arbitrary files, inspect arbitrary processes...).</div><br/><div id="40707932" class="c"><input type="checkbox" id="c-40707932" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40706444">parent</a><span>|</span><a href="#40708083">next</a><span>|</span><label class="collapse" for="c-40707932">[-]</label><label class="expand" for="c-40707932">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, but this is not really a good design.  The user&#x27;s credentials need to be available to services like nscd.  One way to do this is to run such services <i>per-user</i>, which then has the benefit of still being a least-privilege implementation.</div><br/><div id="40711195" class="c"><input type="checkbox" id="c-40711195" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40706444">root</a><span>|</span><a href="#40707932">parent</a><span>|</span><a href="#40708083">next</a><span>|</span><label class="collapse" for="c-40711195">[-]</label><label class="expand" for="c-40711195">[2 more]</label></div><br/><div class="children"><div class="content">That is mostly working system except the nss module might depend on stuff like environment variables or SELinux contexts. Also, when you introduce per-user services you are deep into the “reinventing systemd” territory. Interesting idea would be to spawn the service per-process on the first call that needs it as a child of that process, but it is questionable while it is really worth it in contrast to normal NSSwitch implementation.</div><br/><div id="40711305" class="c"><input type="checkbox" id="c-40711305" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40706444">root</a><span>|</span><a href="#40711195">parent</a><span>|</span><a href="#40708083">next</a><span>|</span><label class="collapse" for="c-40711305">[-]</label><label class="expand" for="c-40711305">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not reinventing systemd.  On systemd systems, use systemd.  On non-systemd systems, launch the process on demand from a privileged process that can do it (e.g., here `nscd` on a non-systemd system would have a call to start an instance on behalf of some UID, and the client library would call that when it can&#x27;t contact the per-user instance).</div><br/></div></div></div></div></div></div></div></div><div id="40708083" class="c"><input type="checkbox" id="c-40708083" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40706444">prev</a><span>|</span><a href="#40705554">next</a><span>|</span><label class="collapse" for="c-40708083">[-]</label><label class="expand" for="c-40708083">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - musl only connects to nscd when it cannot find an answer in its files backend<p>ISTM that this should be fixed in Musl, that it should only check `files` first when it comes first in `&#x2F;etc&#x2F;nsswitch.conf`.<p>Also, if IPC to `nscd` were fast enough, then maybe nss should just always call `nscd`.  Maybe this should be configurable in `&#x2F;etc&#x2F;nsswitch.conf`, then nss should only ever look in `files` when `nscd` is unreachable.<p>TFA essentially is this, but not in Musl.  It&#x27;s a fine workaround, but it ought to be implemented in Musl.<p>&gt; - The nscd protocol does not support enumeration, so primitives such as getpwent() cannot be implemented over nscd.<p>Backend-agnostic enumeration isn&#x27;t really useful.  If you need to enumerate then you need code to talk to the specific backend(s) that you care about (e.g., files, LDAP, etc.).</div><br/></div></div><div id="40705554" class="c"><input type="checkbox" id="c-40705554" checked=""/><div class="controls bullet"><span class="by">jwrteqhrwj</span><span>|</span><a href="#40708083">prev</a><span>|</span><a href="#40704836">next</a><span>|</span><label class="collapse" for="c-40705554">[-]</label><label class="expand" for="c-40705554">[3 more]</label></div><br/><div class="children"><div class="content">skalibs version 2.14.0.0 or later. It&#x27;s a build-time requirement. It&#x27;s also a run-time requirement if you link against the shared version of the skalibs library.<p>s6 version 2.12.0.0 or later. It&#x27;s a run-time requirement only, to run the nsssd service (and can be done without if you have a suitable replacement for s6-ipcserver).<p>I love that the anti-systemd crowd is implementing their own systemd.</div><br/><div id="40707432" class="c"><input type="checkbox" id="c-40707432" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#40705554">parent</a><span>|</span><a href="#40706017">next</a><span>|</span><label class="collapse" for="c-40707432">[-]</label><label class="expand" for="c-40707432">[1 more]</label></div><br/><div class="children"><div class="content">ska (and djb) libs have its own little world which, in some aspects, is weirder than systemd.<p>A most striking example is their time approach - they refuse to acknowledge 64-bit timeval and claim &quot;those APIs will become obsolete in 2038&quot; [0]; instead, they  promote the TAI time, which is uses Unix epoch, except with bit 63 set and adjusted by leap seconds offset (whose value changes every few years or so, so old code needs to be patched or all timestamps would be a few seconds off). And this is not just internals; it&#x27;s visible to users for example in log file names [1]<p>Now, I don&#x27;t care if it&#x27;s TAI or UTC, but I do think the working well with others is very important. And choosing a timestamp which is incompatible with basically every other piece of software out there is.. suboptimal.<p>[0] <a href="https:&#x2F;&#x2F;skarnet.org&#x2F;software&#x2F;skalibs&#x2F;libstddjb&#x2F;tai.html" rel="nofollow">https:&#x2F;&#x2F;skarnet.org&#x2F;software&#x2F;skalibs&#x2F;libstddjb&#x2F;tai.html</a><p>[1] <a href="https:&#x2F;&#x2F;skarnet.org&#x2F;software&#x2F;s6&#x2F;s6-log.html" rel="nofollow">https:&#x2F;&#x2F;skarnet.org&#x2F;software&#x2F;s6&#x2F;s6-log.html</a></div><br/></div></div><div id="40706017" class="c"><input type="checkbox" id="c-40706017" checked=""/><div class="controls bullet"><span class="by">deknos</span><span>|</span><a href="#40705554">parent</a><span>|</span><a href="#40707432">prev</a><span>|</span><a href="#40704836">next</a><span>|</span><label class="collapse" for="c-40706017">[-]</label><label class="expand" for="c-40706017">[1 more]</label></div><br/><div class="children"><div class="content">well, of course to reach feature parity you have to implement it somehow. the question how they do it is a different can of worms.<p>i am glad they stopped complaining and do their own thing. i mean, this is opensource and free software about.</div><br/></div></div></div></div><div id="40704836" class="c"><input type="checkbox" id="c-40704836" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#40705554">prev</a><span>|</span><a href="#40705617">next</a><span>|</span><label class="collapse" for="c-40704836">[-]</label><label class="expand" for="c-40704836">[6 more]</label></div><br/><div class="children"><div class="content">&gt; configurable user&#x2F;group&#x2F;shadow database access, providing getpwnam() et al. functionality by communicating over a Unix domain socket with a daemon<p>If this were compatible with the nscd protocol, you could use the daemon with unmodified musl (or appropriately configured glibc)… feels a bit like a missed opportunity?</div><br/><div id="40705011" class="c"><input type="checkbox" id="c-40705011" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#40704836">parent</a><span>|</span><a href="#40705617">next</a><span>|</span><label class="collapse" for="c-40705011">[-]</label><label class="expand" for="c-40705011">[5 more]</label></div><br/><div class="children"><div class="content">&gt; * The nscd protocol does not support enumeration, so primitives such as getpwent() cannot be implemented over nscd.</div><br/><div id="40706278" class="c"><input type="checkbox" id="c-40706278" checked=""/><div class="controls bullet"><span class="by">unilynx</span><span>|</span><a href="#40704836">root</a><span>|</span><a href="#40705011">parent</a><span>|</span><a href="#40708424">next</a><span>|</span><label class="collapse" for="c-40706278">[-]</label><label class="expand" for="c-40706278">[3 more]</label></div><br/><div class="children"><div class="content">but the protocol could still be a superset, and musl wouldn&#x27;t invoke the new parts of the protocol.</div><br/><div id="40706771" class="c"><input type="checkbox" id="c-40706771" checked=""/><div class="controls bullet"><span class="by">creshal</span><span>|</span><a href="#40704836">root</a><span>|</span><a href="#40706278">parent</a><span>|</span><a href="#40708424">next</a><span>|</span><label class="collapse" for="c-40706771">[-]</label><label class="expand" for="c-40706771">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to see if there&#x27;s some fundamental limitations of the protocol that prevent this, but nscd and its protocol are woefully underdocumented, and it&#x27;s not even stable, technically, since it&#x27;s part of glibc and the server and client can change their protocol whenever they want.<p>Making a new, properly documented protocol, independent from That One Libc You Want To Get Rid Of Anyway, is probably a good idea.</div><br/><div id="40711227" class="c"><input type="checkbox" id="c-40711227" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#40704836">root</a><span>|</span><a href="#40706771">parent</a><span>|</span><a href="#40708424">next</a><span>|</span><label class="collapse" for="c-40711227">[-]</label><label class="expand" for="c-40711227">[1 more]</label></div><br/><div class="children"><div class="content">musl implements it, it&#x27;s not &quot;part of glibc&quot; anymore in the sense of glibc having final control over the protocol. So it&#x27;s stable for all intents and purposes.<p>The protocol has a version number (so no fundamental limitation), and is implemented in 500 + 170 lines of code:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;pikhq&#x2F;musl-nscd&#x2F;blob&#x2F;master&#x2F;src&#x2F;socket_handle.c">https:&#x2F;&#x2F;github.com&#x2F;pikhq&#x2F;musl-nscd&#x2F;blob&#x2F;master&#x2F;src&#x2F;socket_ha...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;pikhq&#x2F;musl-nscd&#x2F;blob&#x2F;master&#x2F;src&#x2F;write_val.c">https:&#x2F;&#x2F;github.com&#x2F;pikhq&#x2F;musl-nscd&#x2F;blob&#x2F;master&#x2F;src&#x2F;write_val...</a><p>Code isn&#x27;t docs, but reading 670 lines of code is not &quot;woefully underdocumented&quot;.  Yes, a spec would be great.  So, write one.<p>Especially since the work for the &quot;new&quot; protocol is the same - or is that equally underdocumented?</div><br/></div></div></div></div></div></div><div id="40708424" class="c"><input type="checkbox" id="c-40708424" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40704836">root</a><span>|</span><a href="#40705011">parent</a><span>|</span><a href="#40706278">prev</a><span>|</span><a href="#40705617">next</a><span>|</span><label class="collapse" for="c-40708424">[-]</label><label class="expand" for="c-40708424">[1 more]</label></div><br/><div class="children"><div class="content">Backend-agnostic enumeration is not useful.</div><br/></div></div></div></div></div></div><div id="40705617" class="c"><input type="checkbox" id="c-40705617" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#40704836">prev</a><span>|</span><a href="#40705386">next</a><span>|</span><label class="collapse" for="c-40705617">[-]</label><label class="expand" for="c-40705617">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this just same as sssd? You got daemon with various backends, and then nss wrapper lib to query that daemon.</div><br/><div id="40705788" class="c"><input type="checkbox" id="c-40705788" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#40705617">parent</a><span>|</span><a href="#40705386">next</a><span>|</span><label class="collapse" for="c-40705788">[-]</label><label class="expand" for="c-40705788">[1 more]</label></div><br/><div class="children"><div class="content">SSSD is an abstraction on top of NSS and PAM.</div><br/></div></div></div></div><div id="40714291" class="c"><input type="checkbox" id="c-40714291" checked=""/><div class="controls bullet"><span class="by">ximm</span><span>|</span><a href="#40705386">prev</a><span>|</span><a href="#40706006">next</a><span>|</span><label class="collapse" for="c-40714291">[-]</label><label class="expand" for="c-40714291">[2 more]</label></div><br/><div class="children"><div class="content">Most of the problems they list for nsswitch also apply to PAM, or am I missing something?</div><br/><div id="40714346" class="c"><input type="checkbox" id="c-40714346" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#40714291">parent</a><span>|</span><a href="#40706006">next</a><span>|</span><label class="collapse" for="c-40714346">[-]</label><label class="expand" for="c-40714346">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot more code calls getXbyY vs code that calls PAM.</div><br/></div></div></div></div><div id="40706006" class="c"><input type="checkbox" id="c-40706006" checked=""/><div class="controls bullet"><span class="by">deknos</span><span>|</span><a href="#40714291">prev</a><span>|</span><a href="#40706063">next</a><span>|</span><label class="collapse" for="c-40706006">[-]</label><label class="expand" for="c-40706006">[1 more]</label></div><br/><div class="children"><div class="content">does this have the 2038 issue?</div><br/></div></div><div id="40706063" class="c"><input type="checkbox" id="c-40706063" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40706006">prev</a><span>|</span><a href="#40704535">next</a><span>|</span><label class="collapse" for="c-40706063">[-]</label><label class="expand" for="c-40706063">[1 more]</label></div><br/><div class="children"><div class="content">nsswitch != Network Security Services (NSS)</div><br/></div></div><div id="40704535" class="c"><input type="checkbox" id="c-40704535" checked=""/><div class="controls bullet"><span class="by">creshal</span><span>|</span><a href="#40706063">prev</a><span>|</span><label class="collapse" for="c-40704535">[-]</label><label class="expand" for="c-40704535">[4 more]</label></div><br/><div class="children"><div class="content">Ohh, this looks nice. I&#x27;ve been wondering for a while why nobody had yet come up with a non-insane alternative to nss (whatever systemd cooked up need not apply), since the fundamental problem is fairly easy, if you&#x27;re not in the position of the original NSS authors (i.e., &quot;we just invented dynamic library loading and can&#x27;t come up with a better example usecase&quot;).</div><br/><div id="40705344" class="c"><input type="checkbox" id="c-40705344" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#40704535">parent</a><span>|</span><label class="collapse" for="c-40705344">[-]</label><label class="expand" for="c-40705344">[3 more]</label></div><br/><div class="children"><div class="content">&gt; whatever systemd cooked up need not apply<p>systemd uses nss like everything else.<p>&gt; since the fundamental problem is fairly easy<p>Very insightful.  The problem is actually pretty complicated and requires runtime initialization, unless you forego all of the services NSS provides.</div><br/><div id="40705791" class="c"><input type="checkbox" id="c-40705791" checked=""/><div class="controls bullet"><span class="by">agwa</span><span>|</span><a href="#40704535">root</a><span>|</span><a href="#40705344">parent</a><span>|</span><a href="#40706803">next</a><span>|</span><label class="collapse" for="c-40705791">[-]</label><label class="expand" for="c-40705791">[1 more]</label></div><br/><div class="children"><div class="content">&gt; systemd uses nss like everything else.<p>systemd has an nss alternative: <a href="https:&#x2F;&#x2F;systemd.io&#x2F;USER_GROUP_API&#x2F;" rel="nofollow">https:&#x2F;&#x2F;systemd.io&#x2F;USER_GROUP_API&#x2F;</a></div><br/></div></div><div id="40706803" class="c"><input type="checkbox" id="c-40706803" checked=""/><div class="controls bullet"><span class="by">creshal</span><span>|</span><a href="#40704535">root</a><span>|</span><a href="#40705344">parent</a><span>|</span><a href="#40705791">prev</a><span>|</span><label class="collapse" for="c-40706803">[-]</label><label class="expand" for="c-40706803">[1 more]</label></div><br/><div class="children"><div class="content">NSS is overcomplicated for 90% of use cases, and as another poster pointed out, that didn&#x27;t stop systemd from trying to make it worse.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>