<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725699671405" as="style"/><link rel="stylesheet" href="styles.css?v=1725699671405"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/tech/OSThreadsAlwaysExpensive">Operating system threads are always going to be (more) expensive</a>Â <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>ingve</span> | <span>5 comments</span></div><br/><div><div id="41472527" class="c"><input type="checkbox" id="c-41472527" checked=""/><div class="controls bullet"><span class="by">darkhelmet</span><span>|</span><a href="#41472532">next</a><span>|</span><label class="collapse" for="c-41472527">[-]</label><label class="expand" for="c-41472527">[1 more]</label></div><br/><div class="children"><div class="content">We took a shot at doing ultra-fast kernel threads on FreeBSD a few decades ago. For various reasons, it was reverted and removed a few major versions later.<p>If you look a the old KSE work, the general gist was that if you were about to block in a syscall then you&#x27;d effectively get a signal-style longjmp back to your userland thread scheduler.  You&#x27;d pick another thread and continue running all in the same process&#x2F;task context.<p>There were many problems with what we did and how we did it, but the unavoidable fundamental problem at the time was that it inverted assumptions about costs of low level primitives.  Important(TM) software was optimized for the world where threads and blocking were expensive and things like pthread mutex operations were cheap.  Our changes made threads and blocking trivially cheap but added non-trivial overhead to pthread mutex etc operations.  Applications that made extensive use of pthread mutexes to coordinate work dispatching on a precious small pool of expensive threads were hit with devastating performance losses.  Most critically, MySQL. We&#x27;d optimized for hundreds of thousands of threads rather than the case of multiplexing work over a few threads.<p>It became apparent that this was going to be an eternal uphill battle and we eventually pulled the plug to do it the same way as Linux.  We made a lot of mistakes with all of this.</div><br/></div></div><div id="41472532" class="c"><input type="checkbox" id="c-41472532" checked=""/><div class="controls bullet"><span class="by">fefe23</span><span>|</span><a href="#41472527">prev</a><span>|</span><a href="#41472224">next</a><span>|</span><label class="collapse" for="c-41472532">[-]</label><label class="expand" for="c-41472532">[1 more]</label></div><br/><div class="children"><div class="content">This argument is basically hand waving, and it&#x27;s factually wrong.<p>Yes, switching from user to kernel mode and back is expensive. But let&#x27;s count the syscalls.<p>Model 1: Threads.
1 blocking read(), 1 blocking write().
Plus cost for the OS scheduler.<p>Model 2:
1 &quot;I want to read&quot;, 1 &quot;can I read now?&quot;, 1 actual read, 1 &quot;I want to write now&quot;, 1 &quot;can I write now?&quot;, 1 actual write.
Multiply as necessary if the read or write are only partial.
Add IPC cost as necessary if you have more than one thread handling async events.<p>Measuring by the syscall overhead, blocking I&#x2F;O is much more efficient.<p>There are other costs to it, though, so it usually consumes more resources per handled socket and turns out to be more expensive than async I&#x2F;O. But it&#x27;s not the syscall cost causing it.</div><br/></div></div><div id="41472224" class="c"><input type="checkbox" id="c-41472224" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41472532">prev</a><span>|</span><label class="collapse" for="c-41472224">[-]</label><label class="expand" for="c-41472224">[2 more]</label></div><br/><div class="children"><div class="content">Depends, given that operating systems like Solaris, macOS, Windows, also have userspace thread like APIs (tasks, dispach queues, concurrent runtime), that do the kernel&#x2F;userspace M:N mapping in a language agnostic way.</div><br/><div id="41472509" class="c"><input type="checkbox" id="c-41472509" checked=""/><div class="controls bullet"><span class="by">ArdentAardvark</span><span>|</span><a href="#41472224">parent</a><span>|</span><label class="collapse" for="c-41472509">[-]</label><label class="expand" for="c-41472509">[1 more]</label></div><br/><div class="children"><div class="content">The post literally mentions that a few paragraphs down in further detail.<p>&gt; The less that doing things with threads crosses the CPU&#x27;s security boundary into (and out of) the kernel, the faster the threads go but the less we can really describe them as &#x27;OS threads&#x27; and the harder it is to get things like forced thread preemption. And this applies not just for the &#x27;OS threads&#x27; themselves but also to their activities. If you want &#x27;OS threads&#x27; that perform &#x27;synchronous IO through simple system calls&#x27;, those IO operations are also transitioning into and out of the kernel. If you work to get around this purely through software, I suspect that what you wind up with is something that looks a lot like &#x27;green&#x27; (user-space) threads with asynchronous IO once you peer behind the scenes of the abstractions that programs are seeing.</div><br/></div></div></div></div></div></div></div></div></div></body></html>