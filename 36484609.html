<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687856459805" as="style"/><link rel="stylesheet" href="styles.css?v=1687856459805"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://determinate.systems/posts/magic-nix-cache">The Magic Nix Cache, a GitHub Action for speeding up your Nix workflows</a> <span class="domain">(<a href="https://determinate.systems">determinate.systems</a>)</span></div><div class="subtext"><span>biggestlou</span> | <span>60 comments</span></div><br/><div><div id="36484745" class="c"><input type="checkbox" id="c-36484745" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36486226">next</a><span>|</span><label class="collapse" for="c-36484745">[-]</label><label class="expand" for="c-36484745">[12 more]</label></div><br/><div class="children"><div class="content">Graham Christensen here, cofounder of DetSys. Happy to answer any questions! The Magic Nix Cache has been a huge boon to us internally, and we&#x27;re really excited to share it with the world today.</div><br/><div id="36487915" class="c"><input type="checkbox" id="c-36487915" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#36484745">parent</a><span>|</span><a href="#36486735">next</a><span>|</span><label class="collapse" for="c-36487915">[-]</label><label class="expand" for="c-36487915">[8 more]</label></div><br/><div class="children"><div class="content">As someone who has led a ~2yr adoption of Nix in an enterprise scenario, I&#x27;m really glad for more projects that help with bridging the gap between Nix and containers&#x2F;k8s.<p>You can get fast startups if you&#x27;re willing to define your containers upfront (dockerTools, nix2container) and&#x2F;or adopt a dynamic container-server (nixery, flakehub). And you can get reasonably fast substitutions if your binary cache is on MinIO in the same cluster as the workers.<p>But I feel like there&#x27;s still room for a &quot;magic&quot; &#x2F;nix&#x2F;store that skips the copying and decompression stage altogether— something that works using standard nix invocations (like Magic Nix Cache), but presents itself as a Kubernetes Volume, so that in cases where a path already exists on-node, the existing files (in the cache pod) are simply mounted&#x2F;served directly into whatever container ran a nix command.<p>I don&#x27;t feel like I really know enough about either k8s or nix to assess the practicality of such a thing, but the thought of lightning-fast substitutions for arbitrary Nix workflows is massively appealing.</div><br/><div id="36488737" class="c"><input type="checkbox" id="c-36488737" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36484745">root</a><span>|</span><a href="#36487915">parent</a><span>|</span><a href="#36490108">prev</a><span>|</span><a href="#36488113">next</a><span>|</span><label class="collapse" for="c-36488737">[-]</label><label class="expand" for="c-36488737">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But I feel like there&#x27;s still room for a &quot;magic&quot; &#x2F;nix&#x2F;store that skips the copying and decompression stage altogether— something that works using standard nix invocations (like Magic Nix Cache), but presents itself as a Kubernetes Volume, so that in cases where a path already exists on-node, the existing files (in the cache pod) are simply mounted&#x2F;served directly into whatever container ran a nix command.<p>Mostly a digression since it&#x27;s not Nix, but I&#x27;ve wondered a bit about this sort of thing when building AUR packages on Arch Linux. The very last step of the builder is to compress the package, which in the vast majority of my uses is followed immediately by installing it, which of course decompresses the package. I&#x27;ve wondered why there isn&#x27;t some (non-default) option to say &quot;I don&#x27;t need to keep the package itself around; just install it as soon as its built&quot;. I&#x27;m sure for my specific use case there&#x27;s a simpler solution, but I&#x27;ve always wondered if there&#x27;s a hacky way to get around things more generally by making a tool that can mimic the expected compression API but then creates a &quot;fake&quot; compressed artifact that no-ops (or maybe puts in a valid header followed by non-compressed data) and then injects that implementation into the PATH. You&#x27;d be able to invoke it with something like `fakecompress --zstd makepkg -si`, and it would invoke `makepkg -si` with the no-op zstd implementation.</div><br/><div id="36489663" class="c"><input type="checkbox" id="c-36489663" checked=""/><div class="controls bullet"><span class="by">pizzapill</span><span>|</span><a href="#36484745">root</a><span>|</span><a href="#36488737">parent</a><span>|</span><a href="#36488833">next</a><span>|</span><label class="collapse" for="c-36489663">[-]</label><label class="expand" for="c-36489663">[1 more]</label></div><br/><div class="children"><div class="content">I know you wanted to make a general point but in Arch you can just change PKGEXT=&#x27;.pkg.tar&#x27; in &#x2F;etc&#x2F;makepkg.conf and the compression stage is skipped.<p><a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;makepkg" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;makepkg</a><p>Tar would also be the answer to how to do fake compression (keeping files together and in order in one file) IF you can choose the &quot;compression&quot; library&#x2F;tool.</div><br/></div></div><div id="36488833" class="c"><input type="checkbox" id="c-36488833" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#36484745">root</a><span>|</span><a href="#36488737">parent</a><span>|</span><a href="#36489663">prev</a><span>|</span><a href="#36488113">next</a><span>|</span><label class="collapse" for="c-36488833">[-]</label><label class="expand" for="c-36488833">[1 more]</label></div><br/><div class="children"><div class="content">Ironically, Python has moved in the other direction, with now <i>requiring</i> a wheel be built before installing it, when wheel itself was originally an optional bolt-on to setuptools.</div><br/></div></div></div></div><div id="36488113" class="c"><input type="checkbox" id="c-36488113" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36484745">root</a><span>|</span><a href="#36487915">parent</a><span>|</span><a href="#36488737">prev</a><span>|</span><a href="#36489732">next</a><span>|</span><label class="collapse" for="c-36488113">[-]</label><label class="expand" for="c-36488113">[2 more]</label></div><br/><div class="children"><div class="content">It is great to hear about your work in the space!<p>Several years ago I looked at implementing a custom component for k8s which would exchange nix store paths instead of containers, substitute, and bind mount them in at run time. It was an interesting experiment, but was Quite Difficult to pull off for someone who wasn&#x27;t already familiar with k8s.<p>I&#x27;ve seen some projects similar to what you&#x27;re describing though: the lightning-fast substitutions. It was incredible! They had the benefit of a fabulously fat network connection, though, and I&#x27;m not sure the experience translates very well. We will see!</div><br/><div id="36488198" class="c"><input type="checkbox" id="c-36488198" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#36484745">root</a><span>|</span><a href="#36488113">parent</a><span>|</span><a href="#36489732">next</a><span>|</span><label class="collapse" for="c-36488198">[-]</label><label class="expand" for="c-36488198">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! The domain is robotics, and we gave a brief conference talk last fall about our experiences so far, if you&#x27;re interested— although it&#x27;s mostly directed at a Nix-unaware audience, you can get a glimpse of our workflow that&#x27;s heavily oriented around hourly builds delivered as Nix flake tags: <a href="https:&#x2F;&#x2F;vimeo.com&#x2F;767139940" rel="nofollow noreferrer">https:&#x2F;&#x2F;vimeo.com&#x2F;767139940</a><p>Definitely there&#x27;s an obviousness to the concept of &quot;magic&quot; Nix stores in various spaces, and I know the tvix project seeks to realize some of this as well— reusing OCI tools to supply the build sandbox, leveraging existing container orchestrators for job management and queuing, all those goodies. So I&#x27;m excited to keep watching the space.</div><br/></div></div></div></div><div id="36489732" class="c"><input type="checkbox" id="c-36489732" checked=""/><div class="controls bullet"><span class="by">alex_hirner</span><span>|</span><a href="#36484745">root</a><span>|</span><a href="#36487915">parent</a><span>|</span><a href="#36488113">prev</a><span>|</span><a href="#36486735">next</a><span>|</span><label class="collapse" for="c-36489732">[-]</label><label class="expand" for="c-36489732">[1 more]</label></div><br/><div class="children"><div class="content">Any pointer to flakehub?</div><br/></div></div></div></div><div id="36486735" class="c"><input type="checkbox" id="c-36486735" checked=""/><div class="controls bullet"><span class="by">zetalyrae</span><span>|</span><a href="#36484745">parent</a><span>|</span><a href="#36487915">prev</a><span>|</span><a href="#36486226">next</a><span>|</span><label class="collapse" for="c-36486735">[-]</label><label class="expand" for="c-36486735">[3 more]</label></div><br/><div class="children"><div class="content">Does it work with nix-shell? I don&#x27;t know how to use flakes yet.</div><br/><div id="36486772" class="c"><input type="checkbox" id="c-36486772" checked=""/><div class="controls bullet"><span class="by">biggestlou</span><span>|</span><a href="#36484745">root</a><span>|</span><a href="#36486735">parent</a><span>|</span><a href="#36486766">next</a><span>|</span><label class="collapse" for="c-36486772">[-]</label><label class="expand" for="c-36486772">[1 more]</label></div><br/><div class="children"><div class="content">Yes! The Action isn&#x27;t directly aware of what Nix itself is doing or which commands are being run; it&#x27;s only aware of the Nix store. So whether you&#x27;re using flakes or channels it works the same.</div><br/></div></div><div id="36486766" class="c"><input type="checkbox" id="c-36486766" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36484745">root</a><span>|</span><a href="#36486735">parent</a><span>|</span><a href="#36486772">prev</a><span>|</span><a href="#36486226">next</a><span>|</span><label class="collapse" for="c-36486766">[-]</label><label class="expand" for="c-36486766">[1 more]</label></div><br/><div class="children"><div class="content">Great question. Yes. Anything that Nix builds during your workflow will get cached. Give it a try and let me know how it goes?</div><br/></div></div></div></div></div></div><div id="36486226" class="c"><input type="checkbox" id="c-36486226" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36484745">prev</a><span>|</span><a href="#36486119">next</a><span>|</span><label class="collapse" for="c-36486226">[-]</label><label class="expand" for="c-36486226">[1 more]</label></div><br/><div class="children"><div class="content">One project cut their CI time from 18m to 3m: <a href="https:&#x2F;&#x2F;github.com&#x2F;awkward-squad&#x2F;hasql-interpolate&#x2F;actions">https:&#x2F;&#x2F;github.com&#x2F;awkward-squad&#x2F;hasql-interpolate&#x2F;actions</a>. I wonder who will see the biggest cut!<p>Note that when PRs merge to the default branch, their cache doesn&#x27;t come with them. This is how GitHub Action&#x27;s cache works, as a security measure. However: subsequent rebuilds will, and PRs off the default branch will too.</div><br/></div></div><div id="36486119" class="c"><input type="checkbox" id="c-36486119" checked=""/><div class="controls bullet"><span class="by">miduil</span><span>|</span><a href="#36486226">prev</a><span>|</span><a href="#36489221">next</a><span>|</span><label class="collapse" for="c-36486119">[-]</label><label class="expand" for="c-36486119">[8 more]</label></div><br/><div class="children"><div class="content">Nice, really hope I&#x27;ll find some sweet way to cache similarish with GitLab-CI. Also kinda been thinking about how cool it&#x27;d be to run Kubernetes with Nix natively (so instead of a docker layer registry you have nix paths mounted together to overlayfs)</div><br/><div id="36486172" class="c"><input type="checkbox" id="c-36486172" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36486119">parent</a><span>|</span><a href="#36487985">next</a><span>|</span><label class="collapse" for="c-36486172">[-]</label><label class="expand" for="c-36486172">[3 more]</label></div><br/><div class="children"><div class="content">I think it should be pretty straightforward to make the Magic Nix Cache work on GitLab, too. They have a similar caching API. We&#x27;ll take a look!</div><br/><div id="36486533" class="c"><input type="checkbox" id="c-36486533" checked=""/><div class="controls bullet"><span class="by">randomblast</span><span>|</span><a href="#36486119">root</a><span>|</span><a href="#36486172">parent</a><span>|</span><a href="#36487985">next</a><span>|</span><label class="collapse" for="c-36486533">[-]</label><label class="expand" for="c-36486533">[2 more]</label></div><br/><div class="children"><div class="content">Is the same true for Azure Pipelines? Given Actions forked from Pipelines I&#x27;d imagine it would be straightforward.</div><br/><div id="36486569" class="c"><input type="checkbox" id="c-36486569" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36486119">root</a><span>|</span><a href="#36486533">parent</a><span>|</span><a href="#36487985">next</a><span>|</span><label class="collapse" for="c-36486569">[-]</label><label class="expand" for="c-36486569">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure... want to open a ticket? :)</div><br/></div></div></div></div></div></div><div id="36487985" class="c"><input type="checkbox" id="c-36487985" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#36486119">parent</a><span>|</span><a href="#36486172">prev</a><span>|</span><a href="#36486586">next</a><span>|</span><label class="collapse" for="c-36487985">[-]</label><label class="expand" for="c-36487985">[1 more]</label></div><br/><div class="children"><div class="content">This is what I&#x27;m using with gitlab: <a href="https:&#x2F;&#x2F;github.com&#x2F;takeda&#x2F;nix-cde&#x2F;blob&#x2F;master&#x2F;contrib&#x2F;gitlab-runner&#x2F;nix-builder.yaml">https:&#x2F;&#x2F;github.com&#x2F;takeda&#x2F;nix-cde&#x2F;blob&#x2F;master&#x2F;contrib&#x2F;gitlab...</a><p>It caches on two levels (instance&#x27;s &#x2F;nix&#x2F;store on EBS and then also binary cache on S3).</div><br/></div></div><div id="36486586" class="c"><input type="checkbox" id="c-36486586" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#36486119">parent</a><span>|</span><a href="#36487985">prev</a><span>|</span><a href="#36489221">next</a><span>|</span><label class="collapse" for="c-36486586">[-]</label><label class="expand" for="c-36486586">[3 more]</label></div><br/><div class="children"><div class="content">I just spun up a gitlab-runner on NixOS (super easy due to how NixOS works)</div><br/><div id="36486598" class="c"><input type="checkbox" id="c-36486598" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36486119">root</a><span>|</span><a href="#36486586">parent</a><span>|</span><a href="#36486647">next</a><span>|</span><label class="collapse" for="c-36486598">[-]</label><label class="expand" for="c-36486598">[1 more]</label></div><br/><div class="children"><div class="content">Nice! Yeah, we&#x27;re obviously big fans of NixOS over here :). In cases where build infrastructure is highly ephemeral, this sort of cache would make a lot of sense. We&#x27;d love to help get it working there!</div><br/></div></div><div id="36486647" class="c"><input type="checkbox" id="c-36486647" checked=""/><div class="controls bullet"><span class="by">miduil</span><span>|</span><a href="#36486119">root</a><span>|</span><a href="#36486586">parent</a><span>|</span><a href="#36486598">prev</a><span>|</span><a href="#36489221">next</a><span>|</span><label class="collapse" for="c-36486647">[-]</label><label class="expand" for="c-36486647">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, you are just trading security with those runners though. I want the cache to be secure and not being able to take over other repos&#x2F;branches&#x2F;tags ci-jobs.</div><br/></div></div></div></div></div></div><div id="36489221" class="c"><input type="checkbox" id="c-36489221" checked=""/><div class="controls bullet"><span class="by">wereHamster</span><span>|</span><a href="#36486119">prev</a><span>|</span><a href="#36487450">next</a><span>|</span><label class="collapse" for="c-36489221">[-]</label><label class="expand" for="c-36489221">[2 more]</label></div><br/><div class="children"><div class="content">Just this past week I thought about setting up custom github runners on NixOS machines so that Nix is pre-installed (doesn&#x27;t need to be installed via a github action) and so that the Nix store can be shared between runs. Though I don&#x27;t really want to manage the machines, so I might give this new github action a try…</div><br/><div id="36489745" class="c"><input type="checkbox" id="c-36489745" checked=""/><div class="controls bullet"><span class="by">yakshaving_jgt</span><span>|</span><a href="#36489221">parent</a><span>|</span><a href="#36487450">next</a><span>|</span><label class="collapse" for="c-36489745">[-]</label><label class="expand" for="c-36489745">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in this then.<p><a href="https:&#x2F;&#x2F;github-runners.www-cachix-org.pages.dev&#x2F;github-runners-for-nix-nixos" rel="nofollow noreferrer">https:&#x2F;&#x2F;github-runners.www-cachix-org.pages.dev&#x2F;github-runne...</a></div><br/></div></div></div></div><div id="36487450" class="c"><input type="checkbox" id="c-36487450" checked=""/><div class="controls bullet"><span class="by">SirensOfTitan</span><span>|</span><a href="#36489221">prev</a><span>|</span><a href="#36487111">next</a><span>|</span><label class="collapse" for="c-36487450">[-]</label><label class="expand" for="c-36487450">[3 more]</label></div><br/><div class="children"><div class="content">Slightly off-topic, but how do folks around here create production packages in nix?  I use nix for my dev shells and machine configuration, but haven&#x27;t yet built production packages using it.<p>More concretely, let&#x27;s say you have a python backend that uses poetry.  Do you just use `poetry install` in your derivation for python-deps?  Do you use something like poetry2nix or node2nix and do all of your package management in nix?</div><br/><div id="36487642" class="c"><input type="checkbox" id="c-36487642" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36487450">parent</a><span>|</span><a href="#36487913">next</a><span>|</span><label class="collapse" for="c-36487642">[-]</label><label class="expand" for="c-36487642">[1 more]</label></div><br/><div class="children"><div class="content">&quot;It depends.&quot; poetry2nix is pretty good! Generally, exporting to an OCI image, or targeting a production environment that can run Nix closures natively is the way we go about it. Many of our services use buildLayeredImage[0] and target Fly.io.<p>0: <a href="https:&#x2F;&#x2F;grahamc.com&#x2F;blog&#x2F;nix-and-layered-docker-images&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;grahamc.com&#x2F;blog&#x2F;nix-and-layered-docker-images&#x2F;</a></div><br/></div></div><div id="36487913" class="c"><input type="checkbox" id="c-36487913" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#36487450">parent</a><span>|</span><a href="#36487642">prev</a><span>|</span><a href="#36487111">next</a><span>|</span><label class="collapse" for="c-36487913">[-]</label><label class="expand" for="c-36487913">[1 more]</label></div><br/><div class="children"><div class="content">So I so far use it for dev environment and also for CI pipeline (the benefit is that Nix allows caching between runs, it helps with things like:<p>- getting dev environment on CI to be identical to user dev
- with minor changes the project is not rebuilt or or rebuilt minimally
- the caching works across branches, so for example merging a feature branch to master, if nothing changes the build on master will be very quick<p>I created something similar to nix-cache for gitlab, but I had to create a dedicated runner running NixOS.<p>If I could use NixOS for deployment, at that point I would just point the same binary cache to the machine and use the same derivation to build the app. Because the app was already build by CI, it would just download the compiled version. No need for artifactory or similar. In that scenario (you using poetry) you probably would just use poetry2nix to generate the application.<p>If the OS is not NixOS, but you still want to deploy via nix, then IMO this[2] looks interesting, basically it packages everything in self extracting archive. That you can extract and then run the app.<p>Other alternatives are these bundlers[3], which includes building toArx (works in a way similar to the previous one but pretends everything is in a single file), RPM, DEB, docker (you would have more control over it if you would use the code directly instead of a bundler though)<p>And the last option (probably the most obvious one) is that you can simply just use the tool to build the package. Since you&#x27;re using poetry, then you can generate a wheel from it.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;takeda&#x2F;nix-cde&#x2F;blob&#x2F;master&#x2F;contrib&#x2F;gitlab-runner&#x2F;nix-builder.yaml">https:&#x2F;&#x2F;github.com&#x2F;takeda&#x2F;nix-cde&#x2F;blob&#x2F;master&#x2F;contrib&#x2F;gitlab...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;Ninlives&#x2F;relocatable.nix">https:&#x2F;&#x2F;github.com&#x2F;Ninlives&#x2F;relocatable.nix</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;bundlers&#x2F;blob&#x2F;master&#x2F;flake.nix">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;bundlers&#x2F;blob&#x2F;master&#x2F;flake.nix</a></div><br/></div></div></div></div><div id="36487111" class="c"><input type="checkbox" id="c-36487111" checked=""/><div class="controls bullet"><span class="by">Karupan</span><span>|</span><a href="#36487450">prev</a><span>|</span><a href="#36486234">next</a><span>|</span><label class="collapse" for="c-36487111">[-]</label><label class="expand" for="c-36487111">[7 more]</label></div><br/><div class="children"><div class="content">As a complete nix noob, will this help with caching node dependencies? We have a few projects that take over 20mins for a `yarn install &amp;&amp; yarn build`. I’ve read setting up
Nix for node isn’t that straightforward, but that was a couple of years back. Has anything changed with respect to node projects?</div><br/><div id="36487212" class="c"><input type="checkbox" id="c-36487212" checked=""/><div class="controls bullet"><span class="by">biggestlou</span><span>|</span><a href="#36487111">parent</a><span>|</span><a href="#36489031">next</a><span>|</span><label class="collapse" for="c-36487212">[-]</label><label class="expand" for="c-36487212">[2 more]</label></div><br/><div class="children"><div class="content">You may find something like node2nix helpful (<a href="https:&#x2F;&#x2F;github.com&#x2F;svanderburg&#x2F;node2nix">https:&#x2F;&#x2F;github.com&#x2F;svanderburg&#x2F;node2nix</a>). This converts your package.json into a Nix expression that can then be cached. You&#x27;re right that it does require some setup and a bit of Nix knowledge but could yield significant benefits and take a good chunk out of that 20 minutes.<p>Another option might be to use pnpm instead of Yarn and cache your pnpm dependencies. pnpm actually works a bit like Nix in that it creates a pnpm-lock.yaml file with content-based hashes for the full package.json dependency tree. This enables it to quickly determine which parts of the dependency tree it needs to build and which are already available.</div><br/><div id="36488079" class="c"><input type="checkbox" id="c-36488079" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#36487111">root</a><span>|</span><a href="#36487212">parent</a><span>|</span><a href="#36489031">next</a><span>|</span><label class="collapse" for="c-36488079">[-]</label><label class="expand" for="c-36488079">[1 more]</label></div><br/><div class="children"><div class="content">Nowadays, there&#x27;s buildNpmPackage [1]. It&#x27;s included in Nixpkgs, actively maintained, and easier to work with IMO.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;doc&#x2F;languages-frameworks&#x2F;javascript.section.md#buildnpmpackage-javascript-buildnpmpackage">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;doc&#x2F;languages-f...</a></div><br/></div></div></div></div><div id="36489031" class="c"><input type="checkbox" id="c-36489031" checked=""/><div class="controls bullet"><span class="by">wereHamster</span><span>|</span><a href="#36487111">parent</a><span>|</span><a href="#36487212">prev</a><span>|</span><a href="#36487361">next</a><span>|</span><label class="collapse" for="c-36489031">[-]</label><label class="expand" for="c-36489031">[1 more]</label></div><br/><div class="children"><div class="content">I have given up installing node dependencies via Nix. I use Nix to make nodejs available but then install node deps with npm&#x2F;yarn&#x2F;pnpm.<p>Node packages sometimes pull additional files from the internet in a postinstall script, or do other funky stuff that&#x27;s incompatible with Nix. So the idea that you can construct a pure derivation from a package-lock.json or yarn.lock file is a pipe dream.</div><br/></div></div><div id="36487361" class="c"><input type="checkbox" id="c-36487361" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#36487111">parent</a><span>|</span><a href="#36489031">prev</a><span>|</span><a href="#36487474">next</a><span>|</span><label class="collapse" for="c-36487361">[-]</label><label class="expand" for="c-36487361">[2 more]</label></div><br/><div class="children"><div class="content">In order to support resolving dependencies to multiple versions (eg A and B depend on C but at incompatible versions), what npm does is drop the version override for C inside the nested node_modules directory (node_modules&#x2F;A&#x2F;node_modules&#x2F;C, for example).<p>That means that node_modules (as created by a package-lock.json) can&#x27;t really be cached or be built from caches since it depends on the particular version solution found by npm for a particular project.<p>So there&#x27;s only so much that Nix <i>can</i> do. It can cache it about as well as using a naive caching scheme with actions&#x2F;upload-artifact or similar (create a tarball of your node_modules and just cache it across runs, update when you need to).<p>Basically node_modules is inherently large. If you want better performance for caching dependencies use a better programming language environment.</div><br/><div id="36490402" class="c"><input type="checkbox" id="c-36490402" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#36487111">root</a><span>|</span><a href="#36487361">parent</a><span>|</span><a href="#36487474">next</a><span>|</span><label class="collapse" for="c-36490402">[-]</label><label class="expand" for="c-36490402">[1 more]</label></div><br/><div class="children"><div class="content">Or fewer dependencies!</div><br/></div></div></div></div><div id="36487474" class="c"><input type="checkbox" id="c-36487474" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#36487111">parent</a><span>|</span><a href="#36487361">prev</a><span>|</span><a href="#36486234">next</a><span>|</span><label class="collapse" for="c-36487474">[-]</label><label class="expand" for="c-36487474">[1 more]</label></div><br/><div class="children"><div class="content">That is supported officially:<p><pre><code>  - uses: actions&#x2F;cache@v3
    with:
      # npm cache files are stored in `~&#x2F;.npm` on Linux&#x2F;macOS
      path: ~&#x2F;.npm
      key: ${{ runner.os }}-${{ hashFiles(&#x27;**&#x2F;package-lock.json&#x27;) }}</code></pre></div><br/></div></div></div></div><div id="36486234" class="c"><input type="checkbox" id="c-36486234" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#36487111">prev</a><span>|</span><a href="#36487047">next</a><span>|</span><label class="collapse" for="c-36486234">[-]</label><label class="expand" for="c-36486234">[8 more]</label></div><br/><div class="children"><div class="content">How does the Magic Nix Cache know which parts of my build are deterministic and which aren&#x27;t?<p>I suppose maybe it will only work if I split my build up into multiple steps such that Nix will know to skip those first steps. If Nix knows that, I suppose the Magic Nix Cache also knows?</div><br/><div id="36488093" class="c"><input type="checkbox" id="c-36488093" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#36486234">parent</a><span>|</span><a href="#36486275">next</a><span>|</span><label class="collapse" for="c-36488093">[-]</label><label class="expand" for="c-36488093">[1 more]</label></div><br/><div class="children"><div class="content">Nix builds things in sandbox (no network access, no file system access etc) this can make creating derivation for application that has build with side effects a frustrating experience, but that brings reproducibility (or at least gets us really close there) so generally this is not a concern.<p>As for splitting build into steps. I am not entirely sure what are you trying to do, but you should not need to do that. Each package in Nix has a hash, which is generated from things like hash of the source code, of the dependencies, compile flags, system architecture etc. This means that you could have multiple versions of the same package in &#x2F;nix&#x2F;store with different compile options or different dependencies. When you need a given dependency you know all the information to generate the hash and can easily know if you need to build it or you can use cached version. This is what makes binary cache a pretty much plug and play and don&#x27;t need to worry what files to cache or whether you should split build into stages.</div><br/></div></div><div id="36486275" class="c"><input type="checkbox" id="c-36486275" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36486234">parent</a><span>|</span><a href="#36488093">prev</a><span>|</span><a href="#36488977">next</a><span>|</span><label class="collapse" for="c-36486275">[-]</label><label class="expand" for="c-36486275">[1 more]</label></div><br/><div class="children"><div class="content">Nix&#x27;s design gives good guarantees about reproducibility. It may not be bit-perfect, but in general it is _very_ good. Maybe the Zero to Nix article on Caching, and its linked pages will help? <a href="https:&#x2F;&#x2F;zero-to-nix.com&#x2F;concepts&#x2F;caching" rel="nofollow noreferrer">https:&#x2F;&#x2F;zero-to-nix.com&#x2F;concepts&#x2F;caching</a><p>The long and short of it is a merkle tree of hashed inputs :).</div><br/></div></div><div id="36488977" class="c"><input type="checkbox" id="c-36488977" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36486234">parent</a><span>|</span><a href="#36486275">prev</a><span>|</span><a href="#36486269">next</a><span>|</span><label class="collapse" for="c-36488977">[-]</label><label class="expand" for="c-36488977">[1 more]</label></div><br/><div class="children"><div class="content">You tell it; when you define a derivation, you are promising it is at least logically deterministic.</div><br/></div></div><div id="36486269" class="c"><input type="checkbox" id="c-36486269" checked=""/><div class="controls bullet"><span class="by">biggestlou</span><span>|</span><a href="#36486234">parent</a><span>|</span><a href="#36488977">prev</a><span>|</span><a href="#36487047">next</a><span>|</span><label class="collapse" for="c-36486269">[-]</label><label class="expand" for="c-36486269">[4 more]</label></div><br/><div class="children"><div class="content">Could you possibly clarify what you mean by &quot;skip those first steps?&quot; Which steps are you referring to?</div><br/><div id="36486374" class="c"><input type="checkbox" id="c-36486374" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#36486234">root</a><span>|</span><a href="#36486269">parent</a><span>|</span><a href="#36487047">next</a><span>|</span><label class="collapse" for="c-36486374">[-]</label><label class="expand" for="c-36486374">[3 more]</label></div><br/><div class="children"><div class="content">Presumably, the Magic Nix Cache speeds up your build by caching the output of the &quot;first steps&quot; (really leaves in a tree of inputs). Otherwise, how would it work? So by steps, I am referring to the steps that your Nix derivation consists of.</div><br/><div id="36486513" class="c"><input type="checkbox" id="c-36486513" checked=""/><div class="controls bullet"><span class="by">biggestlou</span><span>|</span><a href="#36486234">root</a><span>|</span><a href="#36486374">parent</a><span>|</span><a href="#36487047">next</a><span>|</span><label class="collapse" for="c-36486513">[-]</label><label class="expand" for="c-36486513">[2 more]</label></div><br/><div class="children"><div class="content">When Nix &quot;realises&quot; a derivation, it realises the entire dependency tree (here, &quot;realises&quot; means either building or fetching, depending on whether a dependency is already in the Nix store). For every single derivation (dependency) in the tree, Nix first calculates what the store path for that dependency <i>would</i> be and then uses that to determine if it&#x27;s already stored in the Nix store. So it would look at, say, a glibc dependency in a derivation and determine that the Nix store path would be &#x2F;nix&#x2F;store&#x2F;7kn2mkg0g49lfflkdip7i39q3zsck4pc-glibc. If that&#x27;s already in the Nix store then it doesn&#x27;t need to build that. And it applies this logic throughout the entire dependency tree. In some cases, the entire dependency tree has already been built and written to the Nix store, in which Nix knows that it doesn&#x27;t have to build <i>anything</i>. So Nix&#x27;s caching logic doesn&#x27;t apply only to the &quot;first steps&quot; of a Nix build (or realisation, to be more specific); it applies to <i>all</i> steps.</div><br/><div id="36486526" class="c"><input type="checkbox" id="c-36486526" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36486234">root</a><span>|</span><a href="#36486513">parent</a><span>|</span><a href="#36487047">next</a><span>|</span><label class="collapse" for="c-36486526">[-]</label><label class="expand" for="c-36486526">[1 more]</label></div><br/><div class="children"><div class="content">Check out <a href="https:&#x2F;&#x2F;zero-to-nix.com&#x2F;concepts&#x2F;closures" rel="nofollow noreferrer">https:&#x2F;&#x2F;zero-to-nix.com&#x2F;concepts&#x2F;closures</a> and <a href="https:&#x2F;&#x2F;zero-to-nix.com&#x2F;concepts&#x2F;realisation" rel="nofollow noreferrer">https:&#x2F;&#x2F;zero-to-nix.com&#x2F;concepts&#x2F;realisation</a>, which I think add more color to this (and also is largely authored by biggestlou here.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36487047" class="c"><input type="checkbox" id="c-36487047" checked=""/><div class="controls bullet"><span class="by">dlahoda</span><span>|</span><a href="#36486234">prev</a><span>|</span><a href="#36484656">next</a><span>|</span><label class="collapse" for="c-36487047">[-]</label><label class="expand" for="c-36487047">[11 more]</label></div><br/><div class="children"><div class="content">i replaced cloud autoscaled docker runners with fixed set of machines with nix store cache pee machine. 10x imrovement.</div><br/><div id="36487055" class="c"><input type="checkbox" id="c-36487055" checked=""/><div class="controls bullet"><span class="by">grhmc</span><span>|</span><a href="#36487047">parent</a><span>|</span><a href="#36487325">next</a><span>|</span><label class="collapse" for="c-36487055">[-]</label><label class="expand" for="c-36487055">[2 more]</label></div><br/><div class="children"><div class="content">Yep, that works great for cases where you trust all your contributors. We do the same for some projects internally, too. However, for public projects where you don&#x27;t it gets a bit ... dicier. Glad to hear that&#x27;s working for you!</div><br/><div id="36489974" class="c"><input type="checkbox" id="c-36489974" checked=""/><div class="controls bullet"><span class="by">dlahoda</span><span>|</span><a href="#36487047">root</a><span>|</span><a href="#36487055">parent</a><span>|</span><a href="#36487325">next</a><span>|</span><label class="collapse" for="c-36489974">[-]</label><label class="expand" for="c-36489974">[1 more]</label></div><br/><div class="children"><div class="content">we have public oss project. i guess we were not attacked yet.<p>prs from forks run only main workflows, and these run nix which is kind of isolated enough.<p>i guess one could attack with some infinite nix store bomb.</div><br/></div></div></div></div><div id="36487325" class="c"><input type="checkbox" id="c-36487325" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36487047">parent</a><span>|</span><a href="#36487055">prev</a><span>|</span><a href="#36484656">next</a><span>|</span><label class="collapse" for="c-36487325">[-]</label><label class="expand" for="c-36487325">[8 more]</label></div><br/><div class="children"><div class="content">Are you saying you replaced Docker with Nix? I am still trying to understand the use case for Nix. Can someone explain? Is it a complete replacement for Docker?</div><br/><div id="36488235" class="c"><input type="checkbox" id="c-36488235" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#36487047">root</a><span>|</span><a href="#36487325">parent</a><span>|</span><a href="#36487927">next</a><span>|</span><label class="collapse" for="c-36488235">[-]</label><label class="expand" for="c-36488235">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really hard to explain it because Nix is a paradigm shift (I think that&#x27;s why it is hard initially grasp it).<p>But you can use it for things like:<p>- declare your application with all dependencies explicitly, so when someone else wants to build it they can (I would argue this is the primary purpose and rest is just built on top of that)<p>- common dev environment (so other developers can get the same dev environment as you with all exact same build tools)<p>- build toolchain (for example if you do embedded environment)<p>- you could use it as a replacement for homebrew&#x2F;mac ports<p>- a configuration file holding your .dot files (home manager)<p>- if you use NixOS (OS that was built around Nix) then you have OS with a built-in configuration management (i.e. salt&#x2F;puppet&#x2F;ansible&#x2F;chef) that is truly declarative<p>I think this[1] also shows some crazy stuff you can do with it.<p>Regarding question around Docker, the great thing is that if you define your application as a nix derivation, then you can easily generate docker that just contains your application and dependencies (the docker in that case is just a deployment unit). The reproducible environment is what docker promised, but practically failed to deliver. Instead of deliver reproducibility, it actually delivered repeatability.<p>[1] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;6Le0IbPRzOE?t=109" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;6Le0IbPRzOE?t=109</a></div><br/><div id="36488376" class="c"><input type="checkbox" id="c-36488376" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36487047">root</a><span>|</span><a href="#36488235">parent</a><span>|</span><a href="#36487927">next</a><span>|</span><label class="collapse" for="c-36488376">[-]</label><label class="expand" for="c-36488376">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for the explanation. Let me see if I understood. The basic draw is that it offers a programming language-agnostic specification for dependency management, replacing language-specific specifications like requirements.txt. Then you pair it with a containerization technology like Docker or Podman. And if you use NixOS, you can skip the last part?</div><br/><div id="36488677" class="c"><input type="checkbox" id="c-36488677" checked=""/><div class="controls bullet"><span class="by">takeda</span><span>|</span><a href="#36487047">root</a><span>|</span><a href="#36488376">parent</a><span>|</span><a href="#36487927">next</a><span>|</span><label class="collapse" for="c-36488677">[-]</label><label class="expand" for="c-36488677">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Thank you for the explanation. Let me see if I understood. The basic draw is that it offers a programming language-agnostic specification for dependency management, replacing language-specific specifications like requirements.txt<p>Yes, actually I got interested in Nix because with requirements.txt I could only define python dependencies, and I had no control over for example installing postgresql C library that psycopg2 depends on.<p>&gt; Then you pair it with a containerization technology like Docker or Podman<p>You don&#x27;t have to, but you can, given that in most places containers are being used a lot of people use nix that way.<p>&gt; And if you use NixOS, you can skip the last part?<p>Yes, although keep in mind that for example the requirement is to use Kubernetes then you would have to use Kubernetes. But if you need to create for example an EC2 instance. You can use Ubuntu + ansible or you could use NixOS.<p>Honestly I don&#x27;t have much experience with NixOS as at my workplace we are mandated to use specific distro for everything.<p>Edit: I forgot to add additional benefits with using NixOS compared to Ubuntu + ansible for example. All updates are atomic. You either end up with the new configuration or the old configuration, there&#x27;s no in-between as it would happen with ansible. Second big benefit is easy way to rollback.</div><br/></div></div></div></div></div></div><div id="36487927" class="c"><input type="checkbox" id="c-36487927" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#36487047">root</a><span>|</span><a href="#36487325">parent</a><span>|</span><a href="#36488235">prev</a><span>|</span><a href="#36484656">next</a><span>|</span><label class="collapse" for="c-36487927">[-]</label><label class="expand" for="c-36487927">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Is it a complete replacement for Docker?<p>Docker mainly does two things: there&#x27;s Docker images as a way of sharing some container-image, and the container runtime to allow running those images for tasks or services in isolated&#x2F;fresh ways.<p>Docker images make it easy to distribute software which runs the same everywhere.<p>Nix is a package manager which tackles that problem, but without using container images: Nix is for distributing software so it has the same behaviour everywhere.<p>Nix users are often very enthusiastic about Nix because it also enables all sorts of neat developer experiences. e.g. Nix is great for setting up development environments.<p>In terms of Nix-vs-Docker, Nix is also capable of building Docker&#x2F;OCI images. So, you could use Nix instead of writing a Dockerfile.</div><br/><div id="36489275" class="c"><input type="checkbox" id="c-36489275" checked=""/><div class="controls bullet"><span class="by">dusanh</span><span>|</span><a href="#36487047">root</a><span>|</span><a href="#36487927">parent</a><span>|</span><a href="#36484656">next</a><span>|</span><label class="collapse" for="c-36489275">[-]</label><label class="expand" for="c-36489275">[3 more]</label></div><br/><div class="children"><div class="content">Does it make sense to use nix during the image build process to precisely define dependencies I want to have in the resulting container? Or perhaps in other words, can I use nix and docker together, to have a precisely defined environment I can share with others devs as a result?</div><br/><div id="36490310" class="c"><input type="checkbox" id="c-36490310" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#36487047">root</a><span>|</span><a href="#36489275">parent</a><span>|</span><a href="#36489995">next</a><span>|</span><label class="collapse" for="c-36490310">[-]</label><label class="expand" for="c-36490310">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does it make sense to use nix during the image build process to precisely define dependencies I want to have in the resulting container?<p>Using a dockerfile with a step like &quot;RUN nix ...&quot;? You can, but it strikes me as a cumbersome way of doing things. Mitchell H describes this way of doing things here: <a href="https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;nix-with-dockerfiles" rel="nofollow noreferrer">https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;nix-with-dockerfiles</a><p>Whereas, I&#x27;d reckon the more idiomatic thing to do is to build the Docker image with Nix code. -- You&#x27;re going to get a precisely defined environment to share across workstation&#x2F;CI&#x2F;etc. Some example Nix code for building Docker images is here <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;pkgs&#x2F;build-support&#x2F;docker&#x2F;examples.nix">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;pkgs&#x2F;build-supp...</a></div><br/></div></div><div id="36489995" class="c"><input type="checkbox" id="c-36489995" checked=""/><div class="controls bullet"><span class="by">dlahoda</span><span>|</span><a href="#36487047">root</a><span>|</span><a href="#36489275">parent</a><span>|</span><a href="#36490310">prev</a><span>|</span><a href="#36484656">next</a><span>|</span><label class="collapse" for="c-36489995">[-]</label><label class="expand" for="c-36489995">[1 more]</label></div><br/><div class="children"><div class="content">yes. nix builds linux filesystem with all dependencies and puts it into oci image.<p>so locally i use process-compose to avoiding waiting docker builds.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36484656" class="c"><input type="checkbox" id="c-36484656" checked=""/><div class="controls bullet"><span class="by">bketelsen</span><span>|</span><a href="#36487047">prev</a><span>|</span><a href="#36486160">next</a><span>|</span><label class="collapse" for="c-36484656">[-]</label><label class="expand" for="c-36484656">[1 more]</label></div><br/><div class="children"><div class="content">this looks awesome, can&#x27;t wait to try it out.</div><br/></div></div><div id="36487894" class="c"><input type="checkbox" id="c-36487894" checked=""/><div class="controls bullet"><span class="by">sgammon</span><span>|</span><a href="#36486160">prev</a><span>|</span><label class="collapse" for="c-36487894">[-]</label><label class="expand" for="c-36487894">[5 more]</label></div><br/><div class="children"><div class="content">this is awesome. i&#x27;ve yet to try Nix, but we are starting a remote cache service and we&#x27;d love to be compatible with Nix&#x27; caching mechanism<p>we&#x27;re at <a href="https:&#x2F;&#x2F;less.build" rel="nofollow noreferrer">https:&#x2F;&#x2F;less.build</a> if you want to take a peek -- we will look at adding S3 support! :)</div><br/><div id="36488462" class="c"><input type="checkbox" id="c-36488462" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#36487894">parent</a><span>|</span><a href="#36487899">next</a><span>|</span><label class="collapse" for="c-36488462">[-]</label><label class="expand" for="c-36488462">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m all for faster builds...but how does your product differ from using something like <a href="https:&#x2F;&#x2F;ccache.dev&#x2F;manual&#x2F;4.7.html#_remote_storage_backends" rel="nofollow noreferrer">https:&#x2F;&#x2F;ccache.dev&#x2F;manual&#x2F;4.7.html#_remote_storage_backends</a> ? (I ask specifically because you advertise being a drop in ccache replacement, or similar)</div><br/><div id="36489346" class="c"><input type="checkbox" id="c-36489346" checked=""/><div class="controls bullet"><span class="by">sgammon</span><span>|</span><a href="#36487894">root</a><span>|</span><a href="#36488462">parent</a><span>|</span><a href="#36487899">next</a><span>|</span><label class="collapse" for="c-36489346">[-]</label><label class="expand" for="c-36489346">[2 more]</label></div><br/><div class="children"><div class="content">we are drop-in compatible with ccache, in the sense that you can plug ccache right in (as an HTTP backend), and gain features like authorization policies, analytics, and global caching backed by Cloudflare.<p>that&#x27;s where we are beginning and then we&#x27;re working to add spicier features on from there. but first and foremost, we want to serve the ccache&#x2F;gradle cache crowd with a fantastic protocol-agnostic backend which &quot;just works&quot; and pays for itself in terms of time saved.<p>and thanks for asking :) we are very new</div><br/><div id="36489782" class="c"><input type="checkbox" id="c-36489782" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#36487894">root</a><span>|</span><a href="#36489346">parent</a><span>|</span><a href="#36487899">next</a><span>|</span><label class="collapse" for="c-36489782">[-]</label><label class="expand" for="c-36489782">[1 more]</label></div><br/><div class="children"><div class="content">Ah, cool. Not my usecase, but neat all the same.</div><br/></div></div></div></div></div></div><div id="36487899" class="c"><input type="checkbox" id="c-36487899" checked=""/><div class="controls bullet"><span class="by">sgammon</span><span>|</span><a href="#36487894">parent</a><span>|</span><a href="#36488462">prev</a><span>|</span><label class="collapse" for="c-36487899">[-]</label><label class="expand" for="c-36487899">[1 more]</label></div><br/><div class="children"><div class="content">side note i am happy anytime build caching is on the front page of hckrnews for any reason</div><br/></div></div></div></div></div></div></div></div></div></body></html>