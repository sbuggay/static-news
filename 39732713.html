<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711184455146" as="style"/><link rel="stylesheet" href="styles.css?v=1711184455146"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://maskray.me/blog/2024-03-17-c++-exit-time-destructors">C++ Exit-Time Destructors</a> <span class="domain">(<a href="https://maskray.me">maskray.me</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>17 comments</span></div><br/><div><div id="39798394" class="c"><input type="checkbox" id="c-39798394" checked=""/><div class="controls bullet"><span class="by">martijntje</span><span>|</span><a href="#39797710">next</a><span>|</span><label class="collapse" for="c-39798394">[-]</label><label class="expand" for="c-39798394">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting to see that the complexity of c++ is so great that even the code in standards proposals contains undefined behaviour. The no_destroy class triggers UB when .get() is called, because it fails to launder the returned pointer. This is required since c++17.</div><br/></div></div><div id="39797710" class="c"><input type="checkbox" id="c-39797710" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#39798394">prev</a><span>|</span><a href="#39796942">next</a><span>|</span><label class="collapse" for="c-39797710">[-]</label><label class="expand" for="c-39797710">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;d be great if we could come together and specify some of these dark corners like what should happen to static destructors and at_thread_exit handlers at dlclose time.<p>Since it&#x27;s unspecified, musl&#x27;s behavior is just as correct as glibc&#x27;s or BSD&#x27;s or ...</div><br/></div></div><div id="39796942" class="c"><input type="checkbox" id="c-39796942" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39797710">prev</a><span>|</span><a href="#39797675">next</a><span>|</span><label class="collapse" for="c-39796942">[-]</label><label class="expand" for="c-39796942">[9 more]</label></div><br/><div class="children"><div class="content">Great write-up! I was just spelunking in this part of the language recently.<p>Worth noting that global constructors and destructors are generally sucky for a bunch of reasons. Don’t use them unless you <i>really</i> have to. Avoid them in libraries.<p>Reason to avoid global constructors: there’s no laziness to them; they definitely run on program start even if the global is never used. For small projects, no big deal. For large projects it means a large startup time penalty. Successful projects get big eventually, so if you’re playing the long game you want to assume you’re a big project. If you’re a library writer, it’s probable that you’ll be linked into something big. If you don’t have global ctors then your clients will thank you.<p>Atexit anything is just pointless, IMO. The best way for a process to exit is to just exit. Trying to “destruct” your state at exit risks race conditions and weird bugs but buys you very little. Even things like flushing or syncing a file probably don’t belong in atexit since you should assume your program will run a long time so you want important stuff flushed and synced way before the exit happens. Also, global dtors are implemented by having a global ctor that does __cxa_atexit, so see previous paragraph.<p>And as with all programming advice, your mileage may vary and some advice is best ignored. If global ctors&#x2F;dtors achieve what you want and&#x2F;or startup time isn’t an issue, then do what you feel, bro</div><br/><div id="39798412" class="c"><input type="checkbox" id="c-39798412" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#39796942">parent</a><span>|</span><a href="#39797593">next</a><span>|</span><label class="collapse" for="c-39798412">[-]</label><label class="expand" for="c-39798412">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Even things like flushing or syncing a file probably don’t belong in atexit since you should assume your program will run a long time so you want important stuff flushed and synced way before the exit happens.<p>I definitely want buffers to be flushed to disk if the user Ctrl-C&#x27;s the program. The OS only ensures that the resources are released <i>at the OS level</i>, but does nothing to prevent the persistent application state becoming inconsistent at the application level.<p>The really hardcore way to do this is to structure your whole program so that <i>all</i> state is recorded as deltas appended to a WAL, with a background thread&#x2F;process periodically merging this into &quot;current state&quot; -- in that case, even pulling the power cord can&#x27;t leave your application in an inconsistent state. But that&#x27;s a whole lot of work, and just best-effort flushing buffers on exit gets you 80% of the way there.</div><br/></div></div><div id="39797593" class="c"><input type="checkbox" id="c-39797593" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#39796942">parent</a><span>|</span><a href="#39798412">prev</a><span>|</span><a href="#39797675">next</a><span>|</span><label class="collapse" for="c-39797593">[-]</label><label class="expand" for="c-39797593">[7 more]</label></div><br/><div class="children"><div class="content">Yes. If you have an atexit or global destructor on a program expected to run on anything Unixlike or Windows &gt;= NT, you’re just making things slower for the user. Unless you’re on AmigaOS, let the kernel do its job; it can release your resources much faster than you can.</div><br/><div id="39797726" class="c"><input type="checkbox" id="c-39797726" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39796942">root</a><span>|</span><a href="#39797593">parent</a><span>|</span><a href="#39798285">next</a><span>|</span><label class="collapse" for="c-39797726">[-]</label><label class="expand" for="c-39797726">[5 more]</label></div><br/><div class="children"><div class="content">&gt; If you have an atexit or global destructor on a program expected to run on anything Unixlike or Windows &gt;= NT, you’re just making things slower for the user. Unless you’re on AmigaOS, let the kernel do its job; it can release your resources much faster than you can.<p>This is a pretty myopic view of things? There are lots of other things you might wish to do when the program terminates besides releasing resources...</div><br/><div id="39797840" class="c"><input type="checkbox" id="c-39797840" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39796942">root</a><span>|</span><a href="#39797726">parent</a><span>|</span><a href="#39798285">next</a><span>|</span><label class="collapse" for="c-39797840">[-]</label><label class="expand" for="c-39797840">[4 more]</label></div><br/><div class="children"><div class="content">Like what?</div><br/><div id="39798113" class="c"><input type="checkbox" id="c-39798113" checked=""/><div class="controls bullet"><span class="by">gsliepen</span><span>|</span><a href="#39796942">root</a><span>|</span><a href="#39797840">parent</a><span>|</span><a href="#39797942">next</a><span>|</span><label class="collapse" for="c-39798113">[-]</label><label class="expand" for="c-39798113">[1 more]</label></div><br/><div class="children"><div class="content">At a previous job I was using destructors to ensure motors and other actuators in a telescope would shut down properly, and in the right order. This was very important, because incorrect shutdown could cause damage to equipment and potentially people.<p>This was actually my main reason for using C++ to program the control software: the fact that constructors and destructors run deterministically, especially when something bad happens and an exception is thrown. And while the <i>language</i> doesn&#x27;t specify in which order they run for global variables in different compilation units, you still know how they are ordered with respect to `main()`, and if you pay attention to how the linker works, you can actually <i>know</i> how they will all be ordered.</div><br/></div></div><div id="39797942" class="c"><input type="checkbox" id="c-39797942" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39796942">root</a><span>|</span><a href="#39797840">parent</a><span>|</span><a href="#39798113">prev</a><span>|</span><a href="#39798285">next</a><span>|</span><label class="collapse" for="c-39797942">[-]</label><label class="expand" for="c-39797942">[2 more]</label></div><br/><div class="children"><div class="content">Like <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;9334778" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;9334778</a></div><br/><div id="39798142" class="c"><input type="checkbox" id="c-39798142" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39796942">root</a><span>|</span><a href="#39797942">parent</a><span>|</span><a href="#39798285">next</a><span>|</span><label class="collapse" for="c-39798142">[-]</label><label class="expand" for="c-39798142">[1 more]</label></div><br/><div class="children"><div class="content">Or signaling external systems, or removing lockfiles, …<p>Anything the kernel does not do on program exit, which is most things.</div><br/></div></div></div></div></div></div></div></div><div id="39798285" class="c"><input type="checkbox" id="c-39798285" checked=""/><div class="controls bullet"><span class="by">nmcveity</span><span>|</span><a href="#39796942">root</a><span>|</span><a href="#39797593">parent</a><span>|</span><a href="#39797726">prev</a><span>|</span><a href="#39797675">next</a><span>|</span><label class="collapse" for="c-39798285">[-]</label><label class="expand" for="c-39798285">[1 more]</label></div><br/><div class="children"><div class="content">But sometimes not fast enough. IIRC, you can wait for a HPROCESS in Win32 with the WaitForSingleObject call but that is signaled when the application code finishes _not_ when the OS has finished it&#x27;s clean up. So if the process you were waiting on was an application that would write, say, &quot;a.txt&quot; and you wanted to wait until that process was done so that you can read &quot;a.txt&quot;, it is possible that you fail to open that file because the OS had not released the file resource.<p>Of course, I wouldn&#x27;t put that clean up in an atexit.</div><br/></div></div></div></div></div></div><div id="39797675" class="c"><input type="checkbox" id="c-39797675" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39796942">prev</a><span>|</span><a href="#39797049">next</a><span>|</span><label class="collapse" for="c-39797675">[-]</label><label class="expand" for="c-39797675">[4 more]</label></div><br/><div class="children"><div class="content">Side note: dynamic library unloading (and, for that manner, multiple loading of the same library; see `dlmopen`) is finicky because the language has no concept of ownership of things like function pointers and pointers to static data. It&#x27;s easy to imagine a better language, though this would of course require a lot of low-level implementation work!</div><br/><div id="39797713" class="c"><input type="checkbox" id="c-39797713" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39797675">parent</a><span>|</span><a href="#39797945">next</a><span>|</span><label class="collapse" for="c-39797713">[-]</label><label class="expand" for="c-39797713">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the language has no concept of ownership of things like function pointers and pointers to static data. It&#x27;s easy to imagine a better language<p>I actually have both a hard time imagining a better language (not saying it&#x27;s impossible, just that it&#x27;s not trivial for me to see) and also how ownership would resolve this issue. Could you elaborate?</div><br/></div></div><div id="39797945" class="c"><input type="checkbox" id="c-39797945" checked=""/><div class="controls bullet"><span class="by">lldb</span><span>|</span><a href="#39797675">parent</a><span>|</span><a href="#39797713">prev</a><span>|</span><a href="#39797049">next</a><span>|</span><label class="collapse" for="c-39797945">[-]</label><label class="expand" for="c-39797945">[2 more]</label></div><br/><div class="children"><div class="content">I tested this recently and it definitely works as expected in c++ - destructors of static lifetime variables are called when the library is unloaded.</div><br/><div id="39798185" class="c"><input type="checkbox" id="c-39798185" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39797675">root</a><span>|</span><a href="#39797945">parent</a><span>|</span><a href="#39797049">next</a><span>|</span><label class="collapse" for="c-39798185">[-]</label><label class="expand" for="c-39798185">[1 more]</label></div><br/><div class="children"><div class="content">Only in trivial cases.  The problem is when another part of the program holds a function pointer into the library which has been unloaded.  This can happen in particular when you combine libraries and threads:<p>libvirt has long been linked with -Wl,-z -Wl,nodelete to avoid this:<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;libvirt&#x2F;libvirt&#x2F;-&#x2F;commit&#x2F;8e44e5593eb9b89fbc0b54fde15f130707a0d81e" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;libvirt&#x2F;libvirt&#x2F;-&#x2F;commit&#x2F;8e44e5593eb9b89f...</a><p>Another case in libnbd which really demonstrates how hard this is:<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;nbdkit&#x2F;libnbd&#x2F;-&#x2F;commit&#x2F;368e3d0d5a8871aad5e1d3e9b96dc52f03cdfc7b" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;nbdkit&#x2F;libnbd&#x2F;-&#x2F;commit&#x2F;368e3d0d5a8871aad5...</a></div><br/></div></div></div></div></div></div><div id="39797049" class="c"><input type="checkbox" id="c-39797049" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39797675">prev</a><span>|</span><label class="collapse" for="c-39797049">[-]</label><label class="expand" for="c-39797049">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Potential race conditions: Destructors might execute during thread termination, while other threads still attempt to access the object. Examples: webkit<p>Haven’t looked into the bug closely but I will say that WebKit compiles with thread safety on statics turned off, which means they are in a non-standard language mode with far more races.</div><br/></div></div></div></div></div></div></div></body></html>