<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716886857253" as="style"/><link rel="stylesheet" href="styles.css?v=1716886857253"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://uyha.github.io/technical/dbus-systemd.html">DBus and Systemd</a>Â <span class="domain">(<a href="https://uyha.github.io">uyha.github.io</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>26 comments</span></div><br/><div><div id="40498327" class="c"><input type="checkbox" id="c-40498327" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40498213">next</a><span>|</span><label class="collapse" for="c-40498327">[-]</label><label class="expand" for="c-40498327">[9 more]</label></div><br/><div class="children"><div class="content">We need another variation of the rule: &quot;Any sufficiently advanced desktop operating system contains an informal, buggy implementation of half of Smalltalk&quot;<p>DBus, COM, various UNIX IPC mechanisms &amp; co. are a lot of bureaucracy to do a very simple job: connecting two things and letting them communicate, without caring about the semantics of messaging, or protocols.<p>DBus is crucial to making a fully-featured desktop, but that&#x27;s a lot of work to send some typed data to another process. Despite the complexity and ceremony, more and more thing depend on DBus because communication among disparate actors is such a useful concept.<p>We have spent the last 60 years in this field focused on honing methods of computation, while communication is something that&#x27;s tacked on at the end. Now, deep in the Internet age, with fast-enough multicore networked machines, we need a lot of boilerplate to do something all our software depends on. [1] It should be the other way around: communication should be as easy, for the programmer, as adding two integers.<p>(I am working on this space, as I have been obsessed with this question for a long while.)<p>---<p>1: even a number-crunching monolith written in high-performance C++ needs to <i>communicate</i> its result to the user or some other remote service. How many lines of code to do that?</div><br/><div id="40498436" class="c"><input type="checkbox" id="c-40498436" checked=""/><div class="controls bullet"><span class="by">cjk2</span><span>|</span><a href="#40498327">parent</a><span>|</span><a href="#40498399">next</a><span>|</span><label class="collapse" for="c-40498436">[-]</label><label class="expand" for="c-40498436">[5 more]</label></div><br/><div class="children"><div class="content">I quote Fowler&#x27;s ancient First Law of Distributed Object Design: &quot;don&#x27;t distribute your objects&quot;.<p>Any distribution results in masked complexity and many hard to reason about scenarios even if the language or platform supports it transparently.<p>Ergo, just because you can doesn&#x27;t mean you should, unless you want to discover them all, usually at an inconvenient point in the future when everything is broken and there&#x27;s cash bleeding out of your org somewhere.</div><br/><div id="40498461" class="c"><input type="checkbox" id="c-40498461" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40498327">root</a><span>|</span><a href="#40498436">parent</a><span>|</span><a href="#40498399">next</a><span>|</span><label class="collapse" for="c-40498461">[-]</label><label class="expand" for="c-40498461">[4 more]</label></div><br/><div class="children"><div class="content">&gt; don&#x27;t distribute your objects<p>I guess people writing microservices or services connected via the Internet didn&#x27;t get the memo.</div><br/><div id="40498496" class="c"><input type="checkbox" id="c-40498496" checked=""/><div class="controls bullet"><span class="by">dayjaby</span><span>|</span><a href="#40498327">root</a><span>|</span><a href="#40498461">parent</a><span>|</span><a href="#40498554">next</a><span>|</span><label class="collapse" for="c-40498496">[-]</label><label class="expand" for="c-40498496">[1 more]</label></div><br/><div class="children"><div class="content">The author of that rule explains that (well-crafted) microservices don&#x27;t disobey that rule: <a href="https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;distributed-objects-microservices.html" rel="nofollow">https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;distributed-objects-micros...</a></div><br/></div></div><div id="40498554" class="c"><input type="checkbox" id="c-40498554" checked=""/><div class="controls bullet"><span class="by">cjk2</span><span>|</span><a href="#40498327">root</a><span>|</span><a href="#40498461">parent</a><span>|</span><a href="#40498496">prev</a><span>|</span><a href="#40498473">next</a><span>|</span><label class="collapse" for="c-40498554">[-]</label><label class="expand" for="c-40498554">[1 more]</label></div><br/><div class="children"><div class="content">I spend all day every day working with those.<p>I have yet to find a single microservices architecture that could not be solved cheaper and simpler in some other way with less side effects. Plus there are some disparity between APIs and object distribution.<p>(Note I only work on non-google scale stuff where it is probably appropriate)<p>Edit: good example recently, I saw one where they implemented a complex distributed reservation pattern across microservices that gets about 100 transactions a day. They could have done it in one process with proper transaction isolation in a DB fine for about 1&#x2F;100th of the total cost.</div><br/></div></div><div id="40498473" class="c"><input type="checkbox" id="c-40498473" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40498327">root</a><span>|</span><a href="#40498461">parent</a><span>|</span><a href="#40498554">prev</a><span>|</span><a href="#40498399">next</a><span>|</span><label class="collapse" for="c-40498473">[-]</label><label class="expand" for="c-40498473">[1 more]</label></div><br/><div class="children"><div class="content">Microservices aren&#x27;t about distributed objects, they&#x27;re about small services which communicate via explicit IPC (such as HTTP or gRPC).</div><br/></div></div></div></div></div></div><div id="40498399" class="c"><input type="checkbox" id="c-40498399" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40498327">parent</a><span>|</span><a href="#40498436">prev</a><span>|</span><a href="#40498213">next</a><span>|</span><label class="collapse" for="c-40498399">[-]</label><label class="expand" for="c-40498399">[3 more]</label></div><br/><div class="children"><div class="content">Frankly, I completely disagree. There was a lot of research into distributed objects back in the 80s&#x2F;90s; languages which allow objects to seamlessly move between nodes. And there&#x27;s a very good reason IMO why that never took off. Communication between processes is always fallible and subject to blocking indefinitely, and when such communication happens implicitly and all over the place, the result is a disaster. IPC must be explicit, not implicit.<p>IPC must also be language-agnostic, which means serialization and deserialization, which means there will always be some manual &quot;impedance matching&quot; between your program&#x27;s domain model and the IPC protocol&#x27;s messages.<p>Could things be better? Sure, yeah, I guess. Languages with a single implicit event loop and with native support for JSON-like trees of values (such as JavaScript) will have an easier time than languages with neither (such as C++). But I don&#x27;t think there&#x27;s really some magical 10x better solution out there if only we had all &quot;seen the light&quot; and used SmallTalk.</div><br/><div id="40498455" class="c"><input type="checkbox" id="c-40498455" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40498327">root</a><span>|</span><a href="#40498399">parent</a><span>|</span><a href="#40498213">next</a><span>|</span><label class="collapse" for="c-40498455">[-]</label><label class="expand" for="c-40498455">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Communication between processes is always fallible and subject to blocking indefinitely<p>You speak as if you have never heard of Carl Hewitt&#x27;s research, Erlang or Elixir before.</div><br/><div id="40498468" class="c"><input type="checkbox" id="c-40498468" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40498327">root</a><span>|</span><a href="#40498455">parent</a><span>|</span><a href="#40498213">next</a><span>|</span><label class="collapse" for="c-40498468">[-]</label><label class="expand" for="c-40498468">[1 more]</label></div><br/><div class="children"><div class="content">You mentioned SmallTalk, not Erlang.<p>I wasn&#x27;t aware that Erlang did IPC implicitly.</div><br/></div></div></div></div></div></div></div></div><div id="40498213" class="c"><input type="checkbox" id="c-40498213" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#40498327">prev</a><span>|</span><a href="#40498421">next</a><span>|</span><label class="collapse" for="c-40498213">[-]</label><label class="expand" for="c-40498213">[6 more]</label></div><br/><div class="children"><div class="content">I wish DBus used a pseudo-filesystem approach with plaintext commands in a Plan9 manner - so you could call DBus object methods just by opening a file and writing&#x2F;reading from it.<p>There are probably reasons why DBus is implemented the way it is, but it just doesn&#x27;t <i>feel</i> elegant at all.</div><br/><div id="40498350" class="c"><input type="checkbox" id="c-40498350" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40498213">parent</a><span>|</span><a href="#40498332">next</a><span>|</span><label class="collapse" for="c-40498350">[-]</label><label class="expand" for="c-40498350">[4 more]</label></div><br/><div class="children"><div class="content">Would you prefer DBus to be implemented in the kernel then, or would you think that the DBus daemon should expose that pseudo-filesystem using FUSE? Neither of those things seems completely optimal to me to be honest.<p>And it somehow feels very non-Linux that an open syscall or a readdir syscall should be able to block indefinitely as the desktop environment shows a permission syscall...</div><br/><div id="40498383" class="c"><input type="checkbox" id="c-40498383" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40498213">root</a><span>|</span><a href="#40498350">parent</a><span>|</span><a href="#40498332">next</a><span>|</span><label class="collapse" for="c-40498383">[-]</label><label class="expand" for="c-40498383">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Would you prefer DBus to be implemented in the kernel<p>Wasn&#x27;t Greg KH himself trying to explore this? I think it was called Bus1.</div><br/><div id="40498694" class="c"><input type="checkbox" id="c-40498694" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40498213">root</a><span>|</span><a href="#40498383">parent</a><span>|</span><a href="#40498410">next</a><span>|</span><label class="collapse" for="c-40498694">[-]</label><label class="expand" for="c-40498694">[1 more]</label></div><br/><div class="children"><div class="content">kdbus etc. was all about making &quot;faster&quot; dbus back when the original dbus-daemon implementation was &quot;too slow (for our corporate sponsors[1])&quot; so there was unresearched push to put dbus into kernel. Involved special things, including even new syscalls (some I think even got refactored out and actually became part of the ABI).<p>Ultimately it got nuked because the code was considered problematic, and performance turned out to not require kernel code.<p>[1] AFAIK mainly automotive companies that were porting, for some reason, QNX IPC over to D-Bus instead of updating a pre-existing &quot;QNX IPC on Linux&quot; code, and I think Binder didn&#x27;t surface fast enough for this porting effort.</div><br/></div></div><div id="40498410" class="c"><input type="checkbox" id="c-40498410" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40498213">root</a><span>|</span><a href="#40498383">parent</a><span>|</span><a href="#40498694">prev</a><span>|</span><a href="#40498332">next</a><span>|</span><label class="collapse" for="c-40498410">[-]</label><label class="expand" for="c-40498410">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that kdbus was mostly a new transport mechanism, so that the dbus daemon didn&#x27;t have to implement all of dbus&#x27;s features on top of unix sockets? I don&#x27;t think there was an attempt to put the whole daemon in kernel space, and there certainly wasn&#x27;t talk of exposing DBus as a VFS AFAIK<p>Though I haven&#x27;t read about kdbus in a long time, so I might be misremembering or have misunderstood something back when I read about it.<p>Regardless, I was asking what bheadmaster would&#x27;ve preferred, and if the answer is &quot;the dbus daemon should have been implemented in kernel space and that&#x27;s what kdbus was trying to do&quot; then that&#x27;s fine.</div><br/></div></div></div></div></div></div><div id="40498332" class="c"><input type="checkbox" id="c-40498332" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40498213">parent</a><span>|</span><a href="#40498350">prev</a><span>|</span><a href="#40498421">next</a><span>|</span><label class="collapse" for="c-40498332">[-]</label><label class="expand" for="c-40498332">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the unix way &#x2F;s<p>COM (dbus) + Registry &amp; services (systemd)</div><br/></div></div></div></div><div id="40498421" class="c"><input type="checkbox" id="c-40498421" checked=""/><div class="controls bullet"><span class="by">micw</span><span>|</span><a href="#40498213">prev</a><span>|</span><a href="#40498458">next</a><span>|</span><label class="collapse" for="c-40498421">[-]</label><label class="expand" for="c-40498421">[1 more]</label></div><br/><div class="children"><div class="content">I learned a bit about dbus when I was scripting the controller of my home battery (victron energy, I use their &quot;venus os&quot; linux on a raspberry pi). I like the discoverability of dbus. One can just query the bus and talk with all registered services, using any client.<p>But it also seems to have significant flaws. One is that there seems not to be any valid timeout&#x2F;keepalive concept for dbus over TCP. If a registered component is disconnected without gracefully  signing off, the resource keeps registered for a long time and cannot easily replaced if the client re-connects after a while.</div><br/></div></div><div id="40498458" class="c"><input type="checkbox" id="c-40498458" checked=""/><div class="controls bullet"><span class="by">cjk2</span><span>|</span><a href="#40498421">prev</a><span>|</span><a href="#40498409">next</a><span>|</span><label class="collapse" for="c-40498458">[-]</label><label class="expand" for="c-40498458">[1 more]</label></div><br/><div class="children"><div class="content">This always feels like DBus=DCOM, systemd=Service manager, journald=Event log.<p>And that makes me feel a little dirty.</div><br/></div></div><div id="40498409" class="c"><input type="checkbox" id="c-40498409" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40498458">prev</a><span>|</span><a href="#40498426">next</a><span>|</span><label class="collapse" for="c-40498409">[-]</label><label class="expand" for="c-40498409">[5 more]</label></div><br/><div class="children"><div class="content">What about &#x27;standalone&#x27; dbus, without systemd?<p>Is it even possible anymore to build dbus without systemd as a dependency?</div><br/><div id="40498441" class="c"><input type="checkbox" id="c-40498441" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40498409">parent</a><span>|</span><a href="#40498564">next</a><span>|</span><label class="collapse" for="c-40498441">[-]</label><label class="expand" for="c-40498441">[2 more]</label></div><br/><div class="children"><div class="content">One of the ideas behind dbus (and one of the ideas behind systemd! They&#x27;re sorta linked in this way) is that services should be able to activate on request, like httpd but for local IPC. You could make a stand-alone dbus, but you&#x27;d have to either give up on socket activation, or re-implement half of the systemd service manager to make the dbus server responsible for spawning socket activated daemons.<p>Both of those are totally possible and would probably be interesting for non-Linux systems.</div><br/><div id="40498515" class="c"><input type="checkbox" id="c-40498515" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40498409">root</a><span>|</span><a href="#40498441">parent</a><span>|</span><a href="#40498564">next</a><span>|</span><label class="collapse" for="c-40498515">[-]</label><label class="expand" for="c-40498515">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also the case that there exist non-systemd based linuxes.<p>I mean sure, the self-start is important feature, but I&#x27;d rather have a dbus with which I need to start services manually, then have no dbus at all :(<p>Also, why the fuck can&#x27;t systemd run in chroot.</div><br/></div></div></div></div><div id="40498564" class="c"><input type="checkbox" id="c-40498564" checked=""/><div class="controls bullet"><span class="by">Foxboron</span><span>|</span><a href="#40498409">parent</a><span>|</span><a href="#40498441">prev</a><span>|</span><a href="#40498445">next</a><span>|</span><label class="collapse" for="c-40498564">[-]</label><label class="expand" for="c-40498564">[1 more]</label></div><br/><div class="children"><div class="content">A lot of Linux distributions has moved away from the dbus implementation that was merged into systemd to the `dbus-broker` project which has an optional dependency on systemd.<p>So the answer is &quot;yes&quot;, alternative projects exists.</div><br/></div></div><div id="40498445" class="c"><input type="checkbox" id="c-40498445" checked=""/><div class="controls bullet"><span class="by">nazarewk</span><span>|</span><a href="#40498409">parent</a><span>|</span><a href="#40498564">prev</a><span>|</span><a href="#40498426">next</a><span>|</span><label class="collapse" for="c-40498445">[-]</label><label class="expand" for="c-40498445">[1 more]</label></div><br/><div class="children"><div class="content">There is an alternative implementation called dbus-broker.<p>Even found an issue on running it without systemd <a href="https:&#x2F;&#x2F;github.com&#x2F;bus1&#x2F;dbus-broker&#x2F;issues&#x2F;183">https:&#x2F;&#x2F;github.com&#x2F;bus1&#x2F;dbus-broker&#x2F;issues&#x2F;183</a></div><br/></div></div></div></div><div id="40498426" class="c"><input type="checkbox" id="c-40498426" checked=""/><div class="controls bullet"><span class="by">DesiLurker</span><span>|</span><a href="#40498409">prev</a><span>|</span><label class="collapse" for="c-40498426">[-]</label><label class="expand" for="c-40498426">[3 more]</label></div><br/><div class="children"><div class="content">I wonder what happened to Bus1 [1] and other kdbus type proposals. Would be useful to have an android binder like ipc subsystem.<p>1. <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;697191&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;697191&#x2F;</a>
2. <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;580194&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;580194&#x2F;</a></div><br/><div id="40498739" class="c"><input type="checkbox" id="c-40498739" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#40498426">parent</a><span>|</span><a href="#40498674">next</a><span>|</span><label class="collapse" for="c-40498739">[-]</label><label class="expand" for="c-40498739">[1 more]</label></div><br/><div class="children"><div class="content">Linux did get memfd, which was originally a component of kdbus.<p>kdbus seems to have failed because of arguments over attaching process capabilities to messages: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;641275&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;641275&#x2F;</a> And most if not all of the performance improvements were later realized with an improved user space D-Bus implementation (sd-bus?).<p>bus1 seems to have followed a similar trajectory--what remains of the effort is a better D-Bus implementation in user space: <a href="https:&#x2F;&#x2F;github.com&#x2F;bus1&#x2F;dbus-broker">https:&#x2F;&#x2F;github.com&#x2F;bus1&#x2F;dbus-broker</a></div><br/></div></div><div id="40498674" class="c"><input type="checkbox" id="c-40498674" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40498426">parent</a><span>|</span><a href="#40498739">prev</a><span>|</span><label class="collapse" for="c-40498674">[-]</label><label class="expand" for="c-40498674">[1 more]</label></div><br/><div class="children"><div class="content">Binder is honestly much better than D-Bus, but for various reasons I don&#x27;t think we&#x27;re going to see it much on desktop (though you can, in fact, use it there - and it originates from exactly such use).<p>The kdbus finally died when Linus sat down and proved that:<p>1) then-current userspace d-bus code was simply horrible<p>which led to kdbus being mainly about speed&#x2F;latency, but...<p>2) Linus spent a weekend and got an userspace dbus server 80&#x2F;20 solution that achieved better performance than kdbus<p>and<p>3) kdbus introduced no real new benefits that weren&#x27;t ultimately triggered by &quot;dbus is too slow&quot;, unlike Binder which involves fancy scheduling tricks to pass CPU quanta from one process to another along with RPC call.<p>Thus the final nail in coffin of kdbus (which was previously hampered by being considered too problematic to merge) was hammered in.</div><br/></div></div></div></div></div></div></div></div></div></body></html>