<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720774863287" as="style"/><link rel="stylesheet" href="styles.css?v=1720774863287"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/amakelov/mandala">Show HN: Mandala – Automatically save, query and version Python computations</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>amakelov</span> | <span>15 comments</span></div><br/><div><div id="40941864" class="c"><input type="checkbox" id="c-40941864" checked=""/><div class="controls bullet"><span class="by">ledauphin</span><span>|</span><a href="#40941398">next</a><span>|</span><label class="collapse" for="c-40941864">[-]</label><label class="expand" for="c-40941864">[3 more]</label></div><br/><div class="children"><div class="content">We have a framework at &lt;job&gt; to do memoization as well as distributed compute - in fact the memoization was mostly a happy side effect of the need to transfer serialized function arguments to other machines.<p>Your addition of code&#x2F;runtime dependencies intrigues me. I will probably take a look at your code to try to understand this better.<p>I somehow doubt there&#x27;s enough overlap for us to open source our work and try to merge with yours, but it&#x27;s really cool to see other people working on similar concepts. I predict we&#x27;ll see a lot more frameworks like these that lean on mathematical principles like functional purity in the future.</div><br/><div id="40941886" class="c"><input type="checkbox" id="c-40941886" checked=""/><div class="controls bullet"><span class="by">amakelov</span><span>|</span><a href="#40941864">parent</a><span>|</span><a href="#40941398">next</a><span>|</span><label class="collapse" for="c-40941886">[-]</label><label class="expand" for="c-40941886">[2 more]</label></div><br/><div class="children"><div class="content">This blog port gives an overview of the core dependency tracking logic: <a href="https:&#x2F;&#x2F;amakelov.github.io&#x2F;blog&#x2F;deps&#x2F;" rel="nofollow">https:&#x2F;&#x2F;amakelov.github.io&#x2F;blog&#x2F;deps&#x2F;</a></div><br/><div id="40941925" class="c"><input type="checkbox" id="c-40941925" checked=""/><div class="controls bullet"><span class="by">ledauphin</span><span>|</span><a href="#40941864">root</a><span>|</span><a href="#40941886">parent</a><span>|</span><a href="#40941398">next</a><span>|</span><label class="collapse" for="c-40941925">[-]</label><label class="expand" for="c-40941925">[1 more]</label></div><br/><div class="children"><div class="content">thank you!</div><br/></div></div></div></div></div></div><div id="40941398" class="c"><input type="checkbox" id="c-40941398" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#40941864">prev</a><span>|</span><a href="#40942995">next</a><span>|</span><label class="collapse" for="c-40941398">[-]</label><label class="expand" for="c-40941398">[2 more]</label></div><br/><div class="children"><div class="content">Does it survive restarts? You mention that they are exported as dataframes, can they be reimported? Does this mean we can run mandala on many machines, and merge data frames together to get collective memoization?<p>Do you support persisting into external stores?<p>You mention incpy in readme, have you discussed this project with Philip Guo? <a href="https:&#x2F;&#x2F;pg.ucsd.edu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pg.ucsd.edu&#x2F;</a><p>What is the memory and cpu overhead?<p>How does the framework handle dependencies on external libraries or system-level changes that might affect reproducibility?<p>How do you rollback state when it has memoized a broken computation? How does one decide which memoizations to invalidate vs keep?</div><br/><div id="40941520" class="c"><input type="checkbox" id="c-40941520" checked=""/><div class="controls bullet"><span class="by">amakelov</span><span>|</span><a href="#40941398">parent</a><span>|</span><a href="#40942995">next</a><span>|</span><label class="collapse" for="c-40941520">[-]</label><label class="expand" for="c-40941520">[1 more]</label></div><br/><div class="children"><div class="content">In order,<p>1. Yes, you can choose to create a persistent storage by passing `db_path` to `Storage()`. The current implementation is just an SQLite file. To run on many machines, you don&#x27;t really need to be able to re-import from a dataframe (dumping to a dataframe is meant to be an exit point from `mandala` so that you can do downstream analyses in a format more familiar than `ComputationFrame`) - `ComputationFrame`s can be merged via the union (`|`) operator, see here <a href="https:&#x2F;&#x2F;amakelov.github.io&#x2F;mandala&#x2F;blog&#x2F;01_cf&#x2F;#tidy-tools-merging-computationframes" rel="nofollow">https:&#x2F;&#x2F;amakelov.github.io&#x2F;mandala&#x2F;blog&#x2F;01_cf&#x2F;#tidy-tools-me...</a> for an example. Storages don&#x27;t support merging yet, but it&#x27;s certainly possible!<p>2. Already answered in 1.<p>3. Nope, but I&#x27;d be happy to (though I feel like `mandala` took memoization in a substantially different direction). Are you in a position to make an introduction?<p>4. This project is currently not optimized for performance, though I&#x27;ve used it in projects spanning millions of memoized calls. The typical use case is to decorate functions that take a long time to compute, so the overhead of memoization amortizes. A very quick benchmark on my laptop shows ~6ms per call for in-memory storage, ~9ms for a persistent storage, with a simple arithmetic function that otherwise takes ~0 time.<p>5. Great question - currently, the dependency tracer is restricted to user-chosen functions to avoid tracking function calls an imported library makes. You <i>could</i> use a bit of magic (import-time automatic decoration) to track all functions in a file or a directory (not implemented right now). The reasoning is that, for a typical multi-month ML project, you usually have a single conda environment so you want to ignore library changes. Similarly, system-level (e.g. environment variables) are also not tracked. I think a very useful feature would be to at least record the versions of each imported library, so that storages can be ported between environments with some guarantees (or warnings).<p>6. 
- If an `@op` call was memoized, the underlying Python function call succeeded, so in this sense it can&#x27;t be &quot;broken&quot;; it&#x27;s however possible that there was a bug. In this case, you can delete the affected calls and all values that depend on them (if you keep these values, you&#x27;re left with &quot;zombie&quot; values that don&#x27;t have a proper computational history). The `ComputationFrame` supports declarative deletion - you build a ComputationFrame that captures the calls you want to delete, and call `.delete_calls()` -  though there&#x27;s still no example of this in the tutorial :) 
Alternatively, you can change the affected function and mark this as a new version. Then you should be able to delete all calls using the previous version (though, not supported at this moment).<p>- How the cache is invalidated is detailed here: <a href="https:&#x2F;&#x2F;github.com&#x2F;amakelov&#x2F;mandala?tab=readme-ov-file#how-is-the-op-cache-invalidated">https:&#x2F;&#x2F;github.com&#x2F;amakelov&#x2F;mandala?tab=readme-ov-file#how-i...</a></div><br/></div></div></div></div><div id="40942995" class="c"><input type="checkbox" id="c-40942995" checked=""/><div class="controls bullet"><span class="by">culebron21</span><span>|</span><a href="#40941398">prev</a><span>|</span><a href="#40941529">next</a><span>|</span><label class="collapse" for="c-40942995">[-]</label><label class="expand" for="c-40942995">[1 more]</label></div><br/><div class="children"><div class="content">Congratulations, good job! The chaos of notebooks needs some tracking indeed.<p>7 years ago I made a project with 100 calculation dependencies, (in Python &amp; SQL scripts) and the only thing that allowed not to loose track was Makefile + GraphViz.<p>I wanted to make something similar in Rust -- a static visualized of dependencies between structs. Things turned out way harder than expected.</div><br/></div></div><div id="40941529" class="c"><input type="checkbox" id="c-40941529" checked=""/><div class="controls bullet"><span class="by">taliesinb</span><span>|</span><a href="#40942995">prev</a><span>|</span><a href="#40941725">next</a><span>|</span><label class="collapse" for="c-40941529">[-]</label><label class="expand" for="c-40941529">[2 more]</label></div><br/><div class="children"><div class="content">Cool! Looks pretty professional.<p>I explored a similar idea once (also implemented in Python, via decorators) to help speed up some neuroscience research that involved a lot of hyperparameter sweeps. It&#x27;s named after a Borges story about a man cursed to remember everything: <a href="https:&#x2F;&#x2F;github.com&#x2F;taliesinb&#x2F;funes">https:&#x2F;&#x2F;github.com&#x2F;taliesinb&#x2F;funes</a><p>Maybe one day we&#x27;ll have a global version of this, where all non-private computations are cached on a global distributed store somehow via content-based hashing.</div><br/><div id="40941563" class="c"><input type="checkbox" id="c-40941563" checked=""/><div class="controls bullet"><span class="by">amakelov</span><span>|</span><a href="#40941529">parent</a><span>|</span><a href="#40941725">next</a><span>|</span><label class="collapse" for="c-40941563">[-]</label><label class="expand" for="c-40941563">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Indeed, the ultimate (but very ambitious from the point of view of coordination and infrastructure) vision would be to build the &quot;planetary computer&quot; where everyone can contribute and every computation is transparently reproducible. While researching `mandala`, I ran into some ideas along those lines from the folks at Protocol Labs, e.g. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=PBo1lEZ_Iik" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=PBo1lEZ_Iik</a>, though I&#x27;m not aware of the current status.</div><br/></div></div></div></div><div id="40941725" class="c"><input type="checkbox" id="c-40941725" checked=""/><div class="controls bullet"><span class="by">vrtnis</span><span>|</span><a href="#40941529">prev</a><span>|</span><a href="#40941540">next</a><span>|</span><label class="collapse" for="c-40941725">[-]</label><label class="expand" for="c-40941725">[3 more]</label></div><br/><div class="children"><div class="content">Very cool! looking forward to trying it out - the graphs reminded me of a toy project I&#x27;d done a while back to better understand deterministic and reproducible execution in python as seen in marimo.io notebooks <a href="https:&#x2F;&#x2F;github.com&#x2F;vrtnis&#x2F;python-notebook-simulator">https:&#x2F;&#x2F;github.com&#x2F;vrtnis&#x2F;python-notebook-simulator</a></div><br/><div id="40941739" class="c"><input type="checkbox" id="c-40941739" checked=""/><div class="controls bullet"><span class="by">amakelov</span><span>|</span><a href="#40941725">parent</a><span>|</span><a href="#40941540">next</a><span>|</span><label class="collapse" for="c-40941739">[-]</label><label class="expand" for="c-40941739">[2 more]</label></div><br/><div class="children"><div class="content">Ah, yes, the notorious state problem in notebooks. In your project, do you find the dependencies statically or dynamically?</div><br/><div id="40941976" class="c"><input type="checkbox" id="c-40941976" checked=""/><div class="controls bullet"><span class="by">vrtnis</span><span>|</span><a href="#40941725">root</a><span>|</span><a href="#40941739">parent</a><span>|</span><a href="#40941540">next</a><span>|</span><label class="collapse" for="c-40941976">[-]</label><label class="expand" for="c-40941976">[1 more]</label></div><br/><div class="children"><div class="content">Statically - basically just parsing the code into an AST and then walking through the tree to collect information about variable usage and definitions.</div><br/></div></div></div></div></div></div><div id="40941540" class="c"><input type="checkbox" id="c-40941540" checked=""/><div class="controls bullet"><span class="by">omneity</span><span>|</span><a href="#40941725">prev</a><span>|</span><label class="collapse" for="c-40941540">[-]</label><label class="expand" for="c-40941540">[3 more]</label></div><br/><div class="children"><div class="content">Very cool concept, thanks for sharing this.<p>Is mandala designed for notebook-style interactive environments only or also when running python scripts more traditionally, in which case could this be integrated in a gitops like environment? (push to git, new run in CI&#x2F;CD, export log metrics as an artifact with an easy way to compare to previous runs)</div><br/><div id="40941623" class="c"><input type="checkbox" id="c-40941623" checked=""/><div class="controls bullet"><span class="by">amakelov</span><span>|</span><a href="#40941540">parent</a><span>|</span><label class="collapse" for="c-40941623">[-]</label><label class="expand" for="c-40941623">[2 more]</label></div><br/><div class="children"><div class="content">Great question - personally, I mostly use it from notebooks, and I think it&#x27;s a great fit for that. Bundling experiment tracking with incremental computation makes a lot of sense in a notebook (or any other interactive) environment, because it solves the problem of state: if all your computations are end-to-end memoized, re-running the entire notebook is cheap (I routinely do this &quot;retracing&quot; to just get to some results I want to look at).<p>That being said, nothing prevents you from running this in a script too, and there are benefits of doing this as well. If your script mostly composes `@op` calls (possibly with some light control flow logic as needed), you get resumability &quot;for free&quot; on the level of individual `@op` calls after a crash. However, the workflow you&#x27;re describing may run into some features that aren&#x27;t implemented (yet) if your runs write to different storages. `mandala` makes it easy to get a &quot;holistic&quot; picture of a single `Storage` and compare things there. Comparing across storages will be more awkward. But it shouldn&#x27;t be too hard to write a function that merges storages (and it&#x27;s a very natural thing to do, as they&#x27;re basically big tables).</div><br/><div id="40941670" class="c"><input type="checkbox" id="c-40941670" checked=""/><div class="controls bullet"><span class="by">omneity</span><span>|</span><a href="#40941540">root</a><span>|</span><a href="#40941623">parent</a><span>|</span><label class="collapse" for="c-40941670">[-]</label><label class="expand" for="c-40941670">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the in-depth explanation! I’ll keep an eye on it :)<p>Fine-grained crash recovery does sound like a great application as well.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>