<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738400470282" as="style"/><link rel="stylesheet" href="styles.css?v=1738400470282"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://purplesyringa.moe/blog/falsehoods-programmers-believe-about-null-pointers/">Falsehoods programmers believe about null pointers</a> <span class="domain">(<a href="https://purplesyringa.moe">purplesyringa.moe</a>)</span></div><div class="subtext"><span>HeliumHydride</span> | <span>60 comments</span></div><br/><div><div id="42895289" class="c"><input type="checkbox" id="c-42895289" checked=""/><div class="controls bullet"><span class="by">metalcrow</span><span>|</span><a href="#42894593">next</a><span>|</span><label class="collapse" for="c-42895289">[-]</label><label class="expand" for="c-42895289">[10 more]</label></div><br/><div class="children"><div class="content">&gt; asking for forgiveness (dereferencing a null pointer and then recovering) instead of permission (checking if the pointer is null before dereferencing it) is an optimization. Comparing all pointers with null would slow down execution when the pointer isn’t null, i.e. in the majority of cases. In contrast, signal handling is zero-cost until the signal is generated, which happens exceedingly rarely in well-written programs.<p>Is this actually a real optimization? I understand the principal, that you can bypass explicit checks by using exception handlers and then massage the stack&#x2F;registers back to a running state, but does this actually optimize speed? A null pointer check is literally a single TEST on a register, followed by a conditional jump the branch predictor is 99.9% of the time going to know what to do with. How much processing time is using an exception actually going to save?    Or is there a better example?</div><br/><div id="42895468" class="c"><input type="checkbox" id="c-42895468" checked=""/><div class="controls bullet"><span class="by">nickff</span><span>|</span><a href="#42895289">parent</a><span>|</span><a href="#42895485">next</a><span>|</span><label class="collapse" for="c-42895468">[-]</label><label class="expand" for="c-42895468">[2 more]</label></div><br/><div class="children"><div class="content">The OP is offering terrible advice based on a falsehood they believe about null pointers. In many applications (including the STM32H743 microcontroller that I am currently working on), address zero (which is how &quot;NULL&quot; is defined by default in my IDE) points to RAM or FLASH. In my current application, NULL is ITCM (instruction tightly coupled memory), and it&#x27;s where I&#x27;ve put my interrupt vector table. If I read it, I don&#x27;t get an error, but I may get dangerously wrong data.</div><br/><div id="42896689" class="c"><input type="checkbox" id="c-42896689" checked=""/><div class="controls bullet"><span class="by">pfyra</span><span>|</span><a href="#42895289">root</a><span>|</span><a href="#42895468">parent</a><span>|</span><a href="#42895485">next</a><span>|</span><label class="collapse" for="c-42896689">[-]</label><label class="expand" for="c-42896689">[1 more]</label></div><br/><div class="children"><div class="content">I work with the same mcu. You can set up the MPU to catch null pointer dererences so they don&#x27;t pass silently.</div><br/></div></div></div></div><div id="42895485" class="c"><input type="checkbox" id="c-42895485" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#42895289">parent</a><span>|</span><a href="#42895468">prev</a><span>|</span><a href="#42896071">next</a><span>|</span><label class="collapse" for="c-42895485">[-]</label><label class="expand" for="c-42895485">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Is this actually a real optimization?<p>No... And yes.<p>No: <i>Because throwing and catching the null pointer exception is hideously slow compared to doing a null check.</i> In Java &#x2F; C#, the exception is an allocated object, and the stack is walked to generate a stack trace. This is in addition to any additional lower-level overhead (panic) that I don&#x27;t understand the details well enough to explain.<p>Yes: If, in practice, the pointer is never null, (and thus a null pointer is truly an <i>exceptional</i> situation,) carefully-placed exception handlers are an optimization. Although, yes, the code will technically be faster because it&#x27;s not doing null checks, <i>the most important optimization is developer time and code cleanliness.</i> The developer doesn&#x27;t waste time adding redundant null checks, and the next developer finds code that is easier to read because it isn&#x27;t littered with redundant null checks.</div><br/><div id="42895785" class="c"><input type="checkbox" id="c-42895785" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#42895289">root</a><span>|</span><a href="#42895485">parent</a><span>|</span><a href="#42895919">next</a><span>|</span><label class="collapse" for="c-42895785">[-]</label><label class="expand" for="c-42895785">[1 more]</label></div><br/><div class="children"><div class="content">“Most important optimization is developer time and code cleaniness”<p>True for 99% of programming jobs, but if you are worried about the speed of null checks, you are in that 1%.<p>In high frequency trading, if you aren’t first your last and this is the exact type of code optimizations you need for the “happy path”</div><br/></div></div><div id="42895919" class="c"><input type="checkbox" id="c-42895919" checked=""/><div class="controls bullet"><span class="by">wging</span><span>|</span><a href="#42895289">root</a><span>|</span><a href="#42895485">parent</a><span>|</span><a href="#42895785">prev</a><span>|</span><a href="#42896071">next</a><span>|</span><label class="collapse" for="c-42895919">[-]</label><label class="expand" for="c-42895919">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re actually paying a significant cost generating stack traces for NPEs, there&#x27;s a JVM option to deal with that (-XX:-OmitStackTraceInFastThrow). It still generates a stack trace the first time; if you&#x27;re able to go search for that first one it shouldn&#x27;t be a problem for debugging.</div><br/></div></div></div></div><div id="42896071" class="c"><input type="checkbox" id="c-42896071" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42895289">parent</a><span>|</span><a href="#42895485">prev</a><span>|</span><a href="#42895394">next</a><span>|</span><label class="collapse" for="c-42896071">[-]</label><label class="expand" for="c-42896071">[1 more]</label></div><br/><div class="children"><div class="content">Sure, the cost of the check is small, and if you actually hit a null pointer, the cost is much higher if it&#x27;s flagged by the MMU instead of a simple check.<p>But you&#x27;re saving probably two bytes in the instruction stream for the test and conditional jump (more if you don&#x27;t have variable length instructions), and maybe that adds up over your whole program so you can keep meaningfully more code in cache.</div><br/></div></div><div id="42895394" class="c"><input type="checkbox" id="c-42895394" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42895289">parent</a><span>|</span><a href="#42896071">prev</a><span>|</span><a href="#42895581">next</a><span>|</span><label class="collapse" for="c-42895394">[-]</label><label class="expand" for="c-42895394">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A null pointer check is literally a single TEST on a register<p>On every pointer deref in your entire program. Not for release mode.</div><br/></div></div><div id="42895581" class="c"><input type="checkbox" id="c-42895581" checked=""/><div class="controls bullet"><span class="by">Aloisius</span><span>|</span><a href="#42895289">parent</a><span>|</span><a href="#42895394">prev</a><span>|</span><a href="#42895380">next</a><span>|</span><label class="collapse" for="c-42895581">[-]</label><label class="expand" for="c-42895581">[1 more]</label></div><br/><div class="children"><div class="content">OpenJVM does it, iirc. If the handler is triggered too often at a location, it will swap back to emitting null checks though since it is rather expensive.<p>Of course, there&#x27;s a big difference between doing it in a VM and doing it in a random piece of software.</div><br/></div></div><div id="42895380" class="c"><input type="checkbox" id="c-42895380" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42895289">parent</a><span>|</span><a href="#42895581">prev</a><span>|</span><a href="#42894593">next</a><span>|</span><label class="collapse" for="c-42895380">[-]</label><label class="expand" for="c-42895380">[1 more]</label></div><br/><div class="children"><div class="content">Signal handling is done anyway. The cost of null pointer checks is a net overhead, if minuscule.</div><br/></div></div></div></div><div id="42894593" class="c"><input type="checkbox" id="c-42894593" checked=""/><div class="controls bullet"><span class="by">alain94040</span><span>|</span><a href="#42895289">prev</a><span>|</span><a href="#42894896">next</a><span>|</span><label class="collapse" for="c-42894593">[-]</label><label class="expand" for="c-42894593">[6 more]</label></div><br/><div class="children"><div class="content">I would add one more: the address you are dereferencing could be non-zero, it could be an offset from 0 because the code is accessing a field in a structure or method in a class. That offset can be quite large, so if you see an error accessing address 0x420, it&#x27;s probably because you do have a null pointer and are trying to access a field. As a bonus, the offending offset may give you a hint as to which field and therefore where in your code the bad dereferencing is happening.</div><br/><div id="42894923" class="c"><input type="checkbox" id="c-42894923" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#42894593">parent</a><span>|</span><a href="#42894742">next</a><span>|</span><label class="collapse" for="c-42894923">[-]</label><label class="expand" for="c-42894923">[1 more]</label></div><br/><div class="children"><div class="content">One interesting failure mode is if (like the Linux kernel) a function returns a union of a pointer or a negative errno value, dereferencing a negative errno gives an offset (below or above zero) <i>different</i> from the field being accessed.</div><br/></div></div><div id="42894742" class="c"><input type="checkbox" id="c-42894742" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#42894593">parent</a><span>|</span><a href="#42894923">prev</a><span>|</span><a href="#42894896">next</a><span>|</span><label class="collapse" for="c-42894742">[-]</label><label class="expand" for="c-42894742">[4 more]</label></div><br/><div class="children"><div class="content">Now this is a really interesting one. I’m assuming this trivially applies to index array access as well?</div><br/><div id="42894861" class="c"><input type="checkbox" id="c-42894861" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#42894593">root</a><span>|</span><a href="#42894742">parent</a><span>|</span><a href="#42894873">next</a><span>|</span><label class="collapse" for="c-42894861">[-]</label><label class="expand" for="c-42894861">[1 more]</label></div><br/><div class="children"><div class="content">I think this technically wouldn&#x27;t be a null pointer anymore. As array indexing `p[n]` is defined as `*(p + n)` so first you create a new pointer by doing math on a null pointer (which is UB in C) then dereferencing this new pointer (which doesn&#x27;t even really exist because you have already committed UB).</div><br/></div></div><div id="42894873" class="c"><input type="checkbox" id="c-42894873" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42894593">root</a><span>|</span><a href="#42894742">parent</a><span>|</span><a href="#42894861">prev</a><span>|</span><a href="#42894896">next</a><span>|</span><label class="collapse" for="c-42894873">[-]</label><label class="expand" for="c-42894873">[2 more]</label></div><br/><div class="children"><div class="content">In C, and this article seems to be almost exclusively about C, a[b] is basically sugar for (*((a) + (b)))<p>C does actually have arrays (don&#x27;t let people tell you it doesn&#x27;t) but they decay to pointers at ABI fringes and the index operation is, as we just saw, merely a pointer addition, it&#x27;s not anything more sophisticated - so the arrays count for very little in practice.</div><br/><div id="42895210" class="c"><input type="checkbox" id="c-42895210" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#42894593">root</a><span>|</span><a href="#42894873">parent</a><span>|</span><a href="#42894896">next</a><span>|</span><label class="collapse" for="c-42895210">[-]</label><label class="expand" for="c-42895210">[1 more]</label></div><br/><div class="children"><div class="content">Not just basically sugar, the classic parlor trick is doing 3[arr] or whatever</div><br/></div></div></div></div></div></div></div></div><div id="42894896" class="c"><input type="checkbox" id="c-42894896" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42894593">prev</a><span>|</span><a href="#42895465">next</a><span>|</span><label class="collapse" for="c-42894896">[-]</label><label class="expand" for="c-42894896">[10 more]</label></div><br/><div class="children"><div class="content">&quot;falsehoods &#x27;falsehoods programmers believe about X&#x27; authors believe about X&quot;...<p>All you need to know about null pointers in C or C++ is that dereferencing them gives undefined behaviour. That&#x27;s it. The buck stops there. Anything else is you trying to be smart about it.
These articles are annoying because they try to sound smart by going through generally useless technicalities the average programmer shouldn&#x27;t even be considering in the first place.</div><br/><div id="42894978" class="c"><input type="checkbox" id="c-42894978" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42894896">parent</a><span>|</span><a href="#42895339">next</a><span>|</span><label class="collapse" for="c-42894978">[-]</label><label class="expand" for="c-42894978">[7 more]</label></div><br/><div class="children"><div class="content">Useless, but interesting. I used to work with somebody who would ask: What happens with this code?<p><pre><code>    #include &lt;iostream&gt;

    int main() {
        const char *p = 0;
        std::cout &lt;&lt; p;
    }
</code></pre>
You might answer &quot;it&#x27;s undefined behavior, so there is no point reasoning about what happens.&quot; Is it undefined behavior?<p>The idea behind this question was to probe at the candidate&#x27;s knowledge of the sorts of things discussed in the article: virtual memory, signals, undefined behavior, machine dependence, compiler optimizations. And edge cases in iostream.<p>I didn&#x27;t like this question, but I see the point.<p>FWIW, on my machine, clang produces a program that segfaults, while gcc produces a program that doesn&#x27;t. With &quot;-O2&quot;, gcc produces a program that doesn&#x27;t attempt any output.</div><br/><div id="42895172" class="c"><input type="checkbox" id="c-42895172" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#42894896">root</a><span>|</span><a href="#42894978">parent</a><span>|</span><a href="#42896557">next</a><span>|</span><label class="collapse" for="c-42895172">[-]</label><label class="expand" for="c-42895172">[1 more]</label></div><br/><div class="children"><div class="content">I think that reasoning about things is a good idea and looking at failure modes is an engineers job.  However, I gather that the standard says &quot;undefined&quot;, so a correct answer to what &quot;happens with this code&quot; might be: &quot;wankery&quot; (on the part of the questioner).  You even demonstrate that undefined status with concrete examples.<p>In another discipline you might ask what happens what happens when you stress a material near to or beyond its plastic limit?  It&#x27;s quite hard to find that limit precisely, without imposing lots of constraints.  For example take a small metal thing eg a paper clip and bend it repeatedly.  Eventually it will snap due to quite a few effects - work hardening, plastic limit and all that stuff.  Your body heat will affect it, along with ambient temperature.  That&#x27;s before we worry about the material itself which a paper clip will be pretty straightforwards ... ish!<p>OK, let&#x27;s take a deeper look at that crystalline metallic structure ... or let&#x27;s see what happens with concrete or concrete with steel in it, ooh let&#x27;s stress that stuff and bend it in strange ways.<p>Anyway, my point is: if you have something as simple as a standard that says: &quot;this will go weird if you do it&quot; then accept that fact and move on - don&#x27;t try to be clever.</div><br/></div></div><div id="42896557" class="c"><input type="checkbox" id="c-42896557" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#42894896">root</a><span>|</span><a href="#42894978">parent</a><span>|</span><a href="#42895172">prev</a><span>|</span><a href="#42895094">next</a><span>|</span><label class="collapse" for="c-42896557">[-]</label><label class="expand" for="c-42896557">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I didn&#x27;t like this question, but I see the point.<p>These would be fine interviewing questions if it&#x27;s meant to start a conversation. Even if I do think it&#x27;s a bit obtuse from a SWE&#x27;s perspective (&quot;it&#x27;s undefined behavior, don&#x27;t do this&quot;) vs. a Computer scientists&#x27; perspective you took.<p>It&#x27;s just a shame that these days companies seem to want precise answers to such trivia. As if there&#x27;s an objective answer. Which there is, but not without a deep understanding of your given compiler (and how many companies need that, on the spot, under pressure in a timed interview setting?)</div><br/></div></div><div id="42895094" class="c"><input type="checkbox" id="c-42895094" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42894896">root</a><span>|</span><a href="#42894978">parent</a><span>|</span><a href="#42896557">prev</a><span>|</span><a href="#42895339">next</a><span>|</span><label class="collapse" for="c-42895094">[-]</label><label class="expand" for="c-42895094">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m assuming it&#x27;s meant to be:<p><pre><code>  std::cout &lt;&lt; *p;
</code></pre>
?<p>I still think discussing it is largely pointless. It&#x27;s UB and the compiler can do about anything, as your example shows. Unless you want to discuss compiler internals, there&#x27;s no point. Maybe the compiler assumes the code can&#x27;t execute and removes it all - ok that&#x27;s valid. Maybe it segfaults because some optimisation doesn&#x27;t get triggered - ok that&#x27;s valid. It could change between compiler flags and compiler versions. From the POV of the programmer it&#x27;s effectively arbitrary what the result is.<p>Where it gets harmful IMO is when programmers <i>think</i> they understand UB because they&#x27;ve seen a few articles, and start getting smart about it. &quot;I checked the code gen and the compiler does X which means I can do Y, Z&quot;. No. Please stop. You will pay the price in bugs later.</div><br/><div id="42895166" class="c"><input type="checkbox" id="c-42895166" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42894896">root</a><span>|</span><a href="#42895094">parent</a><span>|</span><a href="#42896585">next</a><span>|</span><label class="collapse" for="c-42895166">[-]</label><label class="expand" for="c-42895166">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m assuming it&#x27;s meant to be: [...]<p>Nope, I mean inserting the character pointer (&quot;string&quot;) into the stream, not the character to which it maybe points.<p>Your second paragraph demonstrates, I think, why my former colleague asked the question. And I agree with your third paragraph.</div><br/><div id="42895338" class="c"><input type="checkbox" id="c-42895338" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42894896">root</a><span>|</span><a href="#42895166">parent</a><span>|</span><a href="#42896585">next</a><span>|</span><label class="collapse" for="c-42895338">[-]</label><label class="expand" for="c-42895338">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I got confused for a minute why printing a character pointer is UB. I was thinking of printing the address, which is valid. But of course char* has a different overload because it&#x27;s a string. You can tell how much I use std::string and std::string_view lol.<p>I reckon we are generally in agreement. Perhaps I am not the best person to comment on the purpose of discussing UB, since I already know all the ins and outs of it... &quot;Been there done that&quot; kind of thing.</div><br/></div></div></div></div><div id="42896585" class="c"><input type="checkbox" id="c-42896585" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#42894896">root</a><span>|</span><a href="#42895094">parent</a><span>|</span><a href="#42895166">prev</a><span>|</span><a href="#42895339">next</a><span>|</span><label class="collapse" for="c-42896585">[-]</label><label class="expand" for="c-42896585">[1 more]</label></div><br/><div class="children"><div class="content">&gt;No. Please stop. You will pay the price in bugs later.<p>indeed. It is called UB because that&#x27;s basically code for compilers devs to say &quot;welp don&#x27;t have to worry about changing this&quot; while updating the compiler. What can work in, say, GCC 12 may not work in GCC 14. Or even GCC 12.0.2 if you&#x27;re unlucky enough. Or you suddenly need to port the code to another platform for clang&#x2F;MSVC and are probably screwed.</div><br/></div></div></div></div></div></div><div id="42895339" class="c"><input type="checkbox" id="c-42895339" checked=""/><div class="controls bullet"><span class="by">SR2Z</span><span>|</span><a href="#42894896">parent</a><span>|</span><a href="#42894978">prev</a><span>|</span><a href="#42895446">next</a><span>|</span><label class="collapse" for="c-42895339">[-]</label><label class="expand" for="c-42895339">[1 more]</label></div><br/><div class="children"><div class="content">Haha all of the examples in the article are basically &quot;here&#x27;s some really old method for making address 0 a valid pointer.&quot;<p>This isn&#x27;t like timezones or zip codes where there are lots of unavoidable footguns - pretty much everyone at every layer of the stack thinks that a zero pointer should never point to valid data and should result in, at the very least, a segfault.</div><br/></div></div><div id="42895446" class="c"><input type="checkbox" id="c-42895446" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#42894896">parent</a><span>|</span><a href="#42895339">prev</a><span>|</span><a href="#42895465">next</a><span>|</span><label class="collapse" for="c-42895446">[-]</label><label class="expand" for="c-42895446">[1 more]</label></div><br/><div class="children"><div class="content">Not quite.<p>Trivially, `&amp;<i>E` is equivalent to `E`, even if `E` is a null pointer (C23 standard, footnote 114 from section 6.5.3.2 paragraph 4, page 80). So since `&amp;</i>` is a no-op that&#x27;s not UB.<p>Also `*(a+b)` where `a` is NULL but `b` is a nonzero integer never dereferences the NULL pointer, but is still undefined behavior since conversions from null pointers to pointers of other types still do not compare equal to pointers to any actual objects or functions (6.3.2.3 paragraph 3) and addition or subtraction of pointers into array objects with integers that produce results that don&#x27;t point into the same array object are UB (6.5.6).</div><br/></div></div></div></div><div id="42895465" class="c"><input type="checkbox" id="c-42895465" checked=""/><div class="controls bullet"><span class="by">heraclius1729</span><span>|</span><a href="#42894896">prev</a><span>|</span><a href="#42895025">next</a><span>|</span><label class="collapse" for="c-42895465">[-]</label><label class="expand" for="c-42895465">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In both cases, asking for forgiveness (dereferencing a null pointer and then recovering) instead of permission (checking if the pointer is null before dereferencing it) is an optimization. Comparing all pointers with null would slow down execution when the pointer isn’t null, i.e. in the majority of cases. In contrast, signal handling is zero-cost until the signal is generated, which happens exceedingly rarely in well-written programs.<p>At least from a C&#x2F;C++ perspective, I can&#x27;t help but feel like this isn&#x27;t great advice. There isn&#x27;t a &quot;null dereference&quot; signal that gets sent--it&#x27;s just a standard SIGSEGV that cannot be distinguished easily from other memory access violations (memprotect, buffer overflows, etc). In principle I suppose you could write a fairly sophisticated signal handler that accounts for this--but at the end of the day it <i>must</i> replace the pointer with a not null one, as the memory read will be immediately retried when the handler returns. You&#x27;ll get stuck in an infinite loop (READ, throw SIGSEGV, handler doesn&#x27;t resolve the issue, READ, throw SIGSEGV, &amp;c.) unless you do something to the value of that pointer.<p>All this to avoid the cost of an if-statement that almost always has the same result (not null), which is perfect conditions for the CPU branch predictor.<p>I&#x27;m not saying that it is definitely better to just do the check. But without any data to suggest that it is actually more performant, I don&#x27;t really buy this.<p>EDIT: Actually, this is made a bit worse by the fact that dereferencing nullptr is undefined behavior. Most implementations set the nullptr to 0 and mark that page as unreadable, but that isn&#x27;t a sure thing. The author says as much later in this article, which makes the above point even weirder.</div><br/></div></div><div id="42895025" class="c"><input type="checkbox" id="c-42895025" checked=""/><div class="controls bullet"><span class="by">caspper69</span><span>|</span><a href="#42895465">prev</a><span>|</span><a href="#42894736">next</a><span>|</span><label class="collapse" for="c-42895025">[-]</label><label class="expand" for="c-42895025">[1 more]</label></div><br/><div class="children"><div class="content">The article wasn&#x27;t terrible. I give it a C+ (no pun intended).<p>Too general, too much trivia without explaining the underlying concepts. Questionable recommendations (without covering potential pitfalls).<p>I have to say that the discourse here is refreshing. I got a headache reading the 190+ comments on the &#x2F;r&#x2F;prog post of this article. They are a lively bunch though.</div><br/></div></div><div id="42894736" class="c"><input type="checkbox" id="c-42894736" checked=""/><div class="controls bullet"><span class="by">Hizonner</span><span>|</span><a href="#42895025">prev</a><span>|</span><a href="#42895343">next</a><span>|</span><label class="collapse" for="c-42894736">[-]</label><label class="expand" for="c-42894736">[18 more]</label></div><br/><div class="children"><div class="content">&gt; Instead of translating what you’d like the hardware to perform to C literally, treat C as a higher-level language, because it is one.<p>Alternately, <i>stop writing code in C</i>.</div><br/><div id="42896693" class="c"><input type="checkbox" id="c-42896693" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42894736">parent</a><span>|</span><a href="#42895371">next</a><span>|</span><label class="collapse" for="c-42896693">[-]</label><label class="expand" for="c-42896693">[1 more]</label></div><br/><div class="children"><div class="content">Or catch them using a sanitizer: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;z9WKs5aYv" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;z9WKs5aYv</a></div><br/></div></div><div id="42895371" class="c"><input type="checkbox" id="c-42895371" checked=""/><div class="controls bullet"><span class="by">1over137</span><span>|</span><a href="#42894736">parent</a><span>|</span><a href="#42896693">prev</a><span>|</span><a href="#42894932">next</a><span>|</span><label class="collapse" for="c-42895371">[-]</label><label class="expand" for="c-42895371">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m excited about -fbounds-safety coming soon: <a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;commit&#x2F;64360899c76c">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;commit&#x2F;64360899c76c</a></div><br/></div></div><div id="42894932" class="c"><input type="checkbox" id="c-42894932" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42894736">parent</a><span>|</span><a href="#42895371">prev</a><span>|</span><a href="#42895395">next</a><span>|</span><label class="collapse" for="c-42894932">[-]</label><label class="expand" for="c-42894932">[8 more]</label></div><br/><div class="children"><div class="content">IMO one of the most disappointing things about C: it smells like it should be a straightforward translation to assembly, but actually completely is not because of the &quot;virtual machine&quot; magic the Standard uses which opens the door to almost anything.<p>Oh you would like a byte? Is that going to be a 7 bit, 8 bit, 12 bit, or 64 bit byte? It&#x27;s not specified, yay! Have fun trying to write robust code.</div><br/><div id="42895007" class="c"><input type="checkbox" id="c-42895007" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894932">parent</a><span>|</span><a href="#42895976">next</a><span>|</span><label class="collapse" for="c-42895007">[-]</label><label class="expand" for="c-42895007">[1 more]</label></div><br/><div class="children"><div class="content">Abstract. It&#x27;s an Abstract machine, not a Virtual machine.</div><br/></div></div><div id="42895976" class="c"><input type="checkbox" id="c-42895976" checked=""/><div class="controls bullet"><span class="by">keldaris</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894932">parent</a><span>|</span><a href="#42895007">prev</a><span>|</span><a href="#42895432">next</a><span>|</span><label class="collapse" for="c-42895976">[-]</label><label class="expand" for="c-42895976">[2 more]</label></div><br/><div class="children"><div class="content">Luckily, little of it matters if you simply write C for your actual target platforms, whatever they may be. C thankfully discourages the very notion of &quot;general purpose&quot; code, so unless you&#x27;re writing a compiler, I&#x27;ve never really understood why some C programmers actually care about the standard as such.<p>In reality, if you&#x27;re writing C in 2025, you have a finite set of specific target platforms and a finite set of compilers you care about. Those are what matter. Whether my code is robust with respect to some 80s hardware that did weird things with integers, I have no idea and really couldn&#x27;t care less.</div><br/><div id="42896330" class="c"><input type="checkbox" id="c-42896330" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42895976">parent</a><span>|</span><a href="#42895432">next</a><span>|</span><label class="collapse" for="c-42896330">[-]</label><label class="expand" for="c-42896330">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve never really understood why some C programmers actually care about the standard as such.<p>Because I want the <i>next version</i> of the compiler to agree with me about what my code means.<p>The standard is an agreement: If you write code which conforms to it, the compiler will agree with you about what it means and not, say, optimize your important conditionals away because some &quot;Can&#x27;t Happen&quot; optimization was triggered and the &quot;dead&quot; code got removed. This gets rather important as compilers get better about optimization.</div><br/></div></div></div></div><div id="42895432" class="c"><input type="checkbox" id="c-42895432" checked=""/><div class="controls bullet"><span class="by">zajio1am</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894932">parent</a><span>|</span><a href="#42895976">prev</a><span>|</span><a href="#42894955">next</a><span>|</span><label class="collapse" for="c-42895432">[-]</label><label class="expand" for="c-42895432">[1 more]</label></div><br/><div class="children"><div class="content">Size of byte is implementation-defined, not unspecified. Why is that a problem for writing robust code? It is okay to assume implementation-defined behavior as long as you are targeting a subset of systems where these assumptions hold, and if you check them at build-time.</div><br/></div></div><div id="42894955" class="c"><input type="checkbox" id="c-42894955" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894932">parent</a><span>|</span><a href="#42895432">prev</a><span>|</span><a href="#42894951">next</a><span>|</span><label class="collapse" for="c-42894955">[-]</label><label class="expand" for="c-42894955">[1 more]</label></div><br/><div class="children"><div class="content">Ahem, it&#x27;s specified to not be 7.</div><br/></div></div><div id="42894951" class="c"><input type="checkbox" id="c-42894951" checked=""/><div class="controls bullet"><span class="by">HeliumHydride</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894932">parent</a><span>|</span><a href="#42894955">prev</a><span>|</span><a href="#42895395">next</a><span>|</span><label class="collapse" for="c-42894951">[-]</label><label class="expand" for="c-42894951">[2 more]</label></div><br/><div class="children"><div class="content">C++ has made efforts to fix some of this. Recently, they enforced that signed integers must be two&#x27;s complement. There is a proposal currently to fix the size of bytes to 8 bits.</div><br/><div id="42895045" class="c"><input type="checkbox" id="c-42895045" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894951">parent</a><span>|</span><a href="#42895395">next</a><span>|</span><label class="collapse" for="c-42895045">[-]</label><label class="expand" for="c-42895045">[1 more]</label></div><br/><div class="children"><div class="content">Yes, which is excellent (although 50 years too late, I&#x27;ll try not to be too cynical...).<p>The problem is that C++ is a huge language which is complex and surely not easy to implement. If I want a small, easy language for my next microprocessor project, it probably won&#x27;t be C++20. It seems like C is a good fit, but really it&#x27;s not because it&#x27;s a high level language with a myriad of weird semantics. AFAIK we don&#x27;t have a simple &quot;portable assembler + a few niceties&quot; language. We either use assembly (too low level), or C (slightly too high level and full of junk).</div><br/></div></div></div></div></div></div><div id="42895395" class="c"><input type="checkbox" id="c-42895395" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42894736">parent</a><span>|</span><a href="#42894932">prev</a><span>|</span><a href="#42894761">next</a><span>|</span><label class="collapse" for="c-42895395">[-]</label><label class="expand" for="c-42895395">[1 more]</label></div><br/><div class="children"><div class="content">No. I don’t think I will.</div><br/></div></div><div id="42894761" class="c"><input type="checkbox" id="c-42894761" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42894736">parent</a><span>|</span><a href="#42895395">prev</a><span>|</span><a href="#42895706">next</a><span>|</span><label class="collapse" for="c-42894761">[-]</label><label class="expand" for="c-42894761">[5 more]</label></div><br/><div class="children"><div class="content">impossible<p>no serious alternative</div><br/><div id="42896977" class="c"><input type="checkbox" id="c-42896977" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894761">parent</a><span>|</span><a href="#42896822">next</a><span>|</span><label class="collapse" for="c-42896977">[-]</label><label class="expand" for="c-42896977">[1 more]</label></div><br/><div class="children"><div class="content">Rust and Zig are the serious alternatives for cases where you need a &quot;zero cost&quot; language. If you don&#x27;t (plenty of C code doesn&#x27;t) there are endless serious alternatives.<p>I think you could argue that Zig is still very new so you might not want to use it for that reason, but otherwise there is no reason to use C for new projects in 2025.</div><br/></div></div><div id="42896822" class="c"><input type="checkbox" id="c-42896822" checked=""/><div class="controls bullet"><span class="by">xandrius</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894761">parent</a><span>|</span><a href="#42896977">prev</a><span>|</span><a href="#42894842">next</a><span>|</span><label class="collapse" for="c-42896822">[-]</label><label class="expand" for="c-42896822">[1 more]</label></div><br/><div class="children"><div class="content">No true scotsman either.</div><br/></div></div><div id="42894842" class="c"><input type="checkbox" id="c-42894842" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42894736">root</a><span>|</span><a href="#42894761">parent</a><span>|</span><a href="#42896822">prev</a><span>|</span><a href="#42895706">next</a><span>|</span><label class="collapse" for="c-42894842">[-]</label><label class="expand" for="c-42894842">[2 more]</label></div><br/><div class="children"><div class="content">For <i>very</i> small platforms, where it&#x27;s a struggle to have a C compiler because a &quot;long int&quot; of 32 bits is already a huge challenge to implement, let alone &quot;long long int&quot; - stop using high level languages. Figure out the few dozen machine code instructions you want for your program, write them down, review, translate to binary, done.<p>For the bigger systems where that&#x27;s not appropriate, you&#x27;ll value a more expressive language. I recommend Rust particularly, even though Rust isn&#x27;t available everywhere there&#x27;s an excellent chance it covers every platform you actually care about.</div><br/></div></div></div></div><div id="42895706" class="c"><input type="checkbox" id="c-42895706" checked=""/><div class="controls bullet"><span class="by">kerkeslager</span><span>|</span><a href="#42894736">parent</a><span>|</span><a href="#42894761">prev</a><span>|</span><a href="#42895343">next</a><span>|</span><label class="collapse" for="c-42895706">[-]</label><label class="expand" for="c-42895706">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just not an option in a lot of cases, and it&#x27;s not a <i>good</i> option in other cases.<p>Like it or not, C can run on more systems than anything else, and it&#x27;s by far the easiest language for doing a lot of low-level things. The ease of, for example, accessing pointers, does make it easier to shoot yourself in the foot, but when you need to do that <i>all the time</i> it&#x27;s pretty hard to justify the tradeoffs of another language.<p>Before you say &quot;Rust&quot;: I&#x27;ve used it extensively, it&#x27;s a great language, and probably an ideal replacement for C in a lot of cases (such as writing a browser). But it is absolutely unacceptable for the garbage collector work I&#x27;m using C for, because I&#x27;m doing complex stuff with memory which cannot reasonably be done under the tyranny of the borrow checker. I did spend about six weeks of my life trying to translate my work into Rust and I can see a path to doing it, but you spend so much time bypassing the borrow checker that you&#x27;re clearly not getting much value from it, and you&#x27;re getting a massive amount of faffing that makes it very difficult to see what the code is actually doing.<p>I know HN loves to correct people on things they know nothing about, so if you are about to Google &quot;garbage collector in Rust&quot; to show me that it can be done, just stop. I know it can be done, because I did it; I&#x27;m saying it&#x27;s <i>not worth it</i>.</div><br/></div></div></div></div><div id="42895343" class="c"><input type="checkbox" id="c-42895343" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42894736">prev</a><span>|</span><a href="#42895048">next</a><span>|</span><label class="collapse" for="c-42895343">[-]</label><label class="expand" for="c-42895343">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Falsehoods programmers believe&quot; is the &quot;considered harmful&quot; of the modern dogma cult.</div><br/><div id="42895882" class="c"><input type="checkbox" id="c-42895882" checked=""/><div class="controls bullet"><span class="by">butter999</span><span>|</span><a href="#42895343">parent</a><span>|</span><a href="#42895048">next</a><span>|</span><label class="collapse" for="c-42895882">[-]</label><label class="expand" for="c-42895882">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a genre. It&#x27;s neither dogmatic, modern, nor unique to programming.</div><br/></div></div></div></div><div id="42895320" class="c"><input type="checkbox" id="c-42895320" checked=""/><div class="controls bullet"><span class="by">Blikkentrekker</span><span>|</span><a href="#42895048">prev</a><span>|</span><a href="#42895418">next</a><span>|</span><label class="collapse" for="c-42895320">[-]</label><label class="expand" for="c-42895320">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>In ye olden times, the C standard was considered guidelines rather than a ruleset, undefined behavior was closer to implementation-defined behavior than dark magic, and optimizers were stupid enough to make that distinction irrelevant. On a majority of platforms, dereferencing a null pointer compiled and behaved exactly like dereferencing a value at address 0.</i><p>&gt; <i>For all intents and purposes, UB as we understand it today with spooky action at a distance didn’t exist.</i><p>The first official C standard was from 1989, the second real change was in 1995, and the infamous “nasal daemons” quote was from 1992. So evidently the first C standard was already interpreted that way, that compilers were really allowed to do anything in the face of undefined behavior.
As far as I know</div><br/></div></div><div id="42895418" class="c"><input type="checkbox" id="c-42895418" checked=""/><div class="controls bullet"><span class="by">megous</span><span>|</span><a href="#42895320">prev</a><span>|</span><a href="#42894620">next</a><span>|</span><label class="collapse" for="c-42895418">[-]</label><label class="expand" for="c-42895418">[2 more]</label></div><br/><div class="children"><div class="content">Dereferencing a null pointer is how I boot half of my systems. :D On Rockchip platforms address 0 is start of DRAM, and a location where [U-Boot] SPL is loaded after DRAM is initialized. :)</div><br/><div id="42895487" class="c"><input type="checkbox" id="c-42895487" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#42895418">parent</a><span>|</span><a href="#42894620">next</a><span>|</span><label class="collapse" for="c-42895487">[-]</label><label class="expand" for="c-42895487">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not a null pointer. Address `0` can be valid. A null pointer critically <i>does not compare equal to any non-null pointer, including a pointer to address 0 on platforms where that&#x27;s allowed</i>.<p>&gt; An integer constant expression with the value `0` , such an expression cast to type `void *` , or the predefined constant `nullptr` is called a null pointer constant ^69) . If a null pointer constant or a value of the type `nullptr_t` (which is necessarily the value `nullptr` ) is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a  pointer to any object or function.<p>C 23 standard 6.3.2.3.3<p>Also this is point 6 in the article.</div><br/></div></div></div></div><div id="42894620" class="c"><input type="checkbox" id="c-42894620" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#42895418">prev</a><span>|</span><a href="#42894903">next</a><span>|</span><label class="collapse" for="c-42894620">[-]</label><label class="expand" for="c-42894620">[3 more]</label></div><br/><div class="children"><div class="content">Nowadays, UB is used pretty much as a license to make optimizer go brrrr. But back in the day, I think it was used to allow implementations wiggle room on whether a particular construct was erroneous or not -- in contrast to other specifications like &quot;it is an error&quot; (always erroneous) or &quot;implementation-defined behavior&quot; (always legitimate; compiler must emit <i>something</i> sensible, exactly what is not specified). In the null pointer case, it makes sense for kernel-mode code to potentially indirect to address 0 (or 0xffffffff, or whatever your architecture designates as null), while user-space code can be reasonably considered never to legitimately access that address because the virtual memory never maps it as a valid address. So accessing null is an error in one case and perfectly cromulent in the other. So the standard shrugs its shoulders and says &quot;it&#x27;s undefined&quot;.</div><br/><div id="42894867" class="c"><input type="checkbox" id="c-42894867" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42894620">parent</a><span>|</span><a href="#42894903">next</a><span>|</span><label class="collapse" for="c-42894867">[-]</label><label class="expand" for="c-42894867">[2 more]</label></div><br/><div class="children"><div class="content">The original motivation was to permit implementations to do the reasonable, friendly thing, and trap whenever the program dereferences a null pointer. Since C compilers want to reorder or elide memory accesses, you can&#x27;t really define explicit semantics for that (e.g. you want it to be ok to move the memory access before or after a sequence point) - the JVM has to do a lot of work to ensure that it throws NullPointerException at the correct point when it happens, and this slows down all programs even though no-one sane has their program intentionally trigger one. But the intention was to permit Java-like behaviour where your code would crash with a specific error immediately-ish, maybe not on the exact line where you dereferenced null but close to it. Ironically compiler writers then took that standard and used it to do the exact opposite, making null dereference far more dangerous than even just unconditionally reading memory address 0.</div><br/><div id="42896701" class="c"><input type="checkbox" id="c-42896701" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42894620">root</a><span>|</span><a href="#42894867">parent</a><span>|</span><a href="#42894903">next</a><span>|</span><label class="collapse" for="c-42896701">[-]</label><label class="expand" for="c-42896701">[1 more]</label></div><br/><div class="children"><div class="content">Compiler writers did both: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;z9WKs5aYv" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;z9WKs5aYv</a></div><br/></div></div></div></div></div></div><div id="42894903" class="c"><input type="checkbox" id="c-42894903" checked=""/><div class="controls bullet"><span class="by">rstuart4133</span><span>|</span><a href="#42894620">prev</a><span>|</span><a href="#42894821">next</a><span>|</span><label class="collapse" for="c-42894903">[-]</label><label class="expand" for="c-42894903">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In ye olden times, the C standard was considered guidelines rather than a ruleset, undefined behavior was closer to implementation-defined behavior than dark magic, and optimizers were stupid enough to make that distinction irrelevant. On a majority of platforms, dereferencing a null pointer compiled and behaved exactly like dereferencing a value at address 0.<p>Let me unpack that for you.  Old compilers didn&#x27;t recognise undefined behaviour, and so compiled the code that triggered undefined behaviour in exactly the same way they compiled all other code.  The result was implementation defined, as the article says.<p>Modern compilers can recognise undefined behaviour.  When they recognise it they don&#x27;t warn the programmer &quot;hey, you are doing something non-portable here&quot;.  Instead they may take advantage of it in any way they damned well please.  Most of those ways will be contrary to what the programmer is expecting, consequently yielding a buggy program.<p>But not in all circumstances.  The icing on the cake is some undefined behaviour (like dereferencing null pointers) is tolerated (ie treated in the old way), and some not.   In fact most large C programs will rely on undefined behaviour of some sort, such as what happens when integers overflow or signed is converted to unsigned.<p>Despite that, what is acceptable undefined behaviour and what is not isn&#x27;t defined by the standard, or anywhere else really.  So the behaviour of most large C programs is it legally allowed to to change if you use a different compiler, a different version of the same compiler, or just different optimisation flags.  Consequently most C programs depend on the compiler writers do the same thing with some undefined behaviour, despite there being no guarantees that will happen.<p>This state of affairs, which is to say having a language standard that doesn&#x27;t standardise major features of the language, is apparently considered perfectly acceptable by the C standards committee.</div><br/><div id="42896731" class="c"><input type="checkbox" id="c-42896731" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42894903">parent</a><span>|</span><a href="#42896165">next</a><span>|</span><label class="collapse" for="c-42896731">[-]</label><label class="expand" for="c-42896731">[1 more]</label></div><br/><div class="children"><div class="content">Note that in most scenarios compiler do not &quot;recognize UB&quot; and then don&#x27;t tell you about it. Instead, they do not know whether there will be UB or not at run-time and simply assume that you know what you are doing.<p>I also like to point out that not all modern compilers behave the same way. GCC will (in the case it is clear there will be a null pointer dereference) compile it into a trap, while clang will cause chaos: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;M158Gvnc4" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;M158Gvnc4</a><p>Both have sanitizers to detect this scenarios.</div><br/></div></div><div id="42896165" class="c"><input type="checkbox" id="c-42896165" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#42894903">parent</a><span>|</span><a href="#42896731">prev</a><span>|</span><a href="#42894821">next</a><span>|</span><label class="collapse" for="c-42896165">[-]</label><label class="expand" for="c-42896165">[1 more]</label></div><br/><div class="children"><div class="content">I see at least two possible reasons why it happened: 1. &quot;Don&#x27;t do something counterproductive&quot; or &quot;Don&#x27;t get your priorities wrong&quot; do not usually need to be said explicitly, 2. Standards &quot;culture&quot; values precision so much that they&#x27;d balk at writing fuzzy things like &quot;Do typical null pointer things when trying to deref a null pointer&quot;.<p>Then later 3. &quot;But we implemented it that way for the benchmarks, can&#x27;t regress there!&quot;</div><br/></div></div></div></div><div id="42894821" class="c"><input type="checkbox" id="c-42894821" checked=""/><div class="controls bullet"><span class="by">EtCepeyd</span><span>|</span><a href="#42894903">prev</a><span>|</span><label class="collapse" for="c-42894821">[-]</label><label class="expand" for="c-42894821">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Dereferencing a null pointer always triggers “UB”.<p>Calling this a &quot;falsehood&quot; is utter bullshit.</div><br/></div></div></div></div></div></div></div></body></html>