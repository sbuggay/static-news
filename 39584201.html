<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709544595014" as="style"/><link rel="stylesheet" href="styles.css?v=1709544595014"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.wescottdesign.com/articles/Sampling/sampling.pdf">Sampling: What Nyquist didn&#x27;t say, and what to do about it (2018) [pdf]</a> <span class="domain">(<a href="https://www.wescottdesign.com">www.wescottdesign.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>45 comments</span></div><br/><div><div id="39586766" class="c"><input type="checkbox" id="c-39586766" checked=""/><div class="controls bullet"><span class="by">greesil</span><span>|</span><a href="#39585666">next</a><span>|</span><label class="collapse" for="c-39586766">[-]</label><label class="expand" for="c-39586766">[1 more]</label></div><br/><div class="children"><div class="content">I ran into this problem with a codec chip. We had to run the output at 48 khz, and the input and output clock had to be the same. Well we didn&#x27;t have enough CPU to process the input at 48 khz, we only cared about 8 khz bandwidth for human speech. Boxcar averaging then decimating produced way too much aliasing, so much that the ML classifiers wouldn&#x27;t work. The solution was putting a honking large FIR anti aliasing filter on the codec, like 100 taps, because -that- chip had oodles of CPU to spare as it turned out.<p>Why FIR? It had a super sharp cutoff and of course linear phase. If I&#x27;d known about Bessel filters at the time I&#x27;d have tried those out. Live and learn and ship it.</div><br/></div></div><div id="39585666" class="c"><input type="checkbox" id="c-39585666" checked=""/><div class="controls bullet"><span class="by">diydsp</span><span>|</span><a href="#39586766">prev</a><span>|</span><a href="#39586244">next</a><span>|</span><label class="collapse" for="c-39585666">[-]</label><label class="expand" for="c-39585666">[1 more]</label></div><br/><div class="children"><div class="content">Many brilliant points.  Particularly about Bessel filters instead of Butterworth.  And also about lowering Fc and increasing Fs, rather than increasing order.  And also about considering time domain as well as frequency domain.<p>The dense interview question I use to assess this area of knowledge: &quot;How do you choose the stopband attenuation of a filter?&quot;  You can assess a lot from the interviewee&#x27;s response.  Stopband attenuation, with respective to the input signal magnitude at the stopband frequency, or start of the stopband, is the most relevant term for determining the magnitude of noise in the sampled signal.  And that is the upper bound on the performance of the downstream algorithm.</div><br/></div></div><div id="39586244" class="c"><input type="checkbox" id="c-39586244" checked=""/><div class="controls bullet"><span class="by">salty_biscuits</span><span>|</span><a href="#39585666">prev</a><span>|</span><a href="#39585707">next</a><span>|</span><label class="collapse" for="c-39586244">[-]</label><label class="expand" for="c-39586244">[1 more]</label></div><br/><div class="children"><div class="content">The biggest one I have run into is that the bandwith doesn&#x27;t need to be contiguous. If you know the the important bits of the signal are contained in certain frequency bands then you can get much lower sampling rates. Basically why things like l1 reconstruction work.</div><br/></div></div><div id="39585707" class="c"><input type="checkbox" id="c-39585707" checked=""/><div class="controls bullet"><span class="by">f5ve</span><span>|</span><a href="#39586244">prev</a><span>|</span><a href="#39586082">next</a><span>|</span><label class="collapse" for="c-39585707">[-]</label><label class="expand" for="c-39585707">[21 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re thinking &quot;The highest rate I need my signal to be able to replicate is X, so I should set my sampling rate to 2X,&quot; then you&#x27;re wrong and this article gives several reasons why.<p>As far as I can tell, though, it doesn&#x27;t mention what may be the <i>most</i> important reason (especially to the folks here at hackernews): resampling and processing.<p>This is why professional grade audio processing operates at a sample rate many multiples higher than human hearing.  It&#x27;s not because of the quality difference between, say, 192 and 96 kHz, but rather if you&#x27;re resampling or iterating a process dozens of times at those rates, eventually artifacts will form and make their way into the range of human hearing (20 kHz).</div><br/><div id="39585886" class="c"><input type="checkbox" id="c-39585886" checked=""/><div class="controls bullet"><span class="by">shampto3</span><span>|</span><a href="#39585707">parent</a><span>|</span><a href="#39585762">next</a><span>|</span><label class="collapse" for="c-39585886">[-]</label><label class="expand" for="c-39585886">[10 more]</label></div><br/><div class="children"><div class="content">You’re right, but I fear this idea has become prevalent in audiophile communities where they only want to listen to files that are 96kHz or higher.<p>In my opinion, having a high sample rate only really matters during the production phase and does not have a noticeable effect on the final form factor. If the producer uses high sample rate during the creation process, I see no reason why the listener would care if the file they’re listening to is higher than even 44.1kHz unless they are planning on using it for their own production.</div><br/><div id="39586216" class="c"><input type="checkbox" id="c-39586216" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39585886">parent</a><span>|</span><a href="#39586138">next</a><span>|</span><label class="collapse" for="c-39586216">[-]</label><label class="expand" for="c-39586216">[4 more]</label></div><br/><div class="children"><div class="content">People should prefer 48k over 44.1 but not for fidelity. It would just make the world a better place if 44.1k audio files died out. The reasons it was chosen are invalid today and we&#x27;re stuck with it, and now every audio stack needs to be able to convert between 44.1&#x2F;88.2 and 48&#x2F;96 which is a solved problem, but has a tradeoff between fidelity and performance that makes resampling algorithms a critical design feature of those stacks.<p>All because Sony and Philips wanted 80 minutes of stereo audio on CDs decades ago.</div><br/><div id="39587597" class="c"><input type="checkbox" id="c-39587597" checked=""/><div class="controls bullet"><span class="by">dfe</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39586216">parent</a><span>|</span><a href="#39588169">next</a><span>|</span><label class="collapse" for="c-39587597">[-]</label><label class="expand" for="c-39587597">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PCM_adaptor" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PCM_adaptor</a><p>It&#x27;s very likely that the 44.1 kHz rate comes from the PCM adaptors that were designed to take PCM audio and convert it to something that a video tape recorder would accept.<p>I watched a YouTube a few months ago about these adaptors and the presenter did the calculations showing how the 44.1 kHz 16-bit sample rate lines up with the video fields.  There was a valid engineering reason for this sampling rate.<p>However, the stories about one of the Sony executives having a particular piece of music in mind are true, and have to do with the diameter of the disk being enlarged compared to what Philips originally had in mind.  By that time the bitrate was already decided.<p>I still agree that 48 kHz is a better choice today, especially after reading this paper.</div><br/><div id="39587697" class="c"><input type="checkbox" id="c-39587697" checked=""/><div class="controls bullet"><span class="by">FabHK</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39587597">parent</a><span>|</span><a href="#39588169">next</a><span>|</span><label class="collapse" for="c-39587697">[-]</label><label class="expand" for="c-39587697">[1 more]</label></div><br/><div class="children"><div class="content">Beethoven&#x27;s 9th.<p>&gt; Kees Immink, Philips&#x27; chief engineer, who developed the CD, recalls that a commercial tug-of-war between the development partners, Sony and Philips, led to a settlement in a neutral 12-cm diameter format. The 1951 performance of the Ninth Symphony conducted by Furtwängler was brought forward as the perfect excuse for the change,[76][77] and was put forth in a Philips news release celebrating the 25th anniversary of the Compact Disc as the reason for the 74-minute length.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Symphony_No._9_(Beethoven)#Compact_disc_format" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Symphony_No._9_(Beethoven)#Com...</a></div><br/></div></div></div></div><div id="39588169" class="c"><input type="checkbox" id="c-39588169" checked=""/><div class="controls bullet"><span class="by">taejavu</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39586216">parent</a><span>|</span><a href="#39587597">prev</a><span>|</span><a href="#39586138">next</a><span>|</span><label class="collapse" for="c-39588169">[-]</label><label class="expand" for="c-39588169">[1 more]</label></div><br/><div class="children"><div class="content">What _is_ the reason people should prefer 48k over 44.1k though?</div><br/></div></div></div></div><div id="39586138" class="c"><input type="checkbox" id="c-39586138" checked=""/><div class="controls bullet"><span class="by">hunter2_</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39585886">parent</a><span>|</span><a href="#39586216">prev</a><span>|</span><a href="#39585923">next</a><span>|</span><label class="collapse" for="c-39586138">[-]</label><label class="expand" for="c-39586138">[4 more]</label></div><br/><div class="children"><div class="content">The same could be said about bit depth: 24 bits offers far less quantization artifacts than 16 bits, and those artifacts can readily show up during production processes such as dynamic range compression, but they are extremely well hidden by dithering with noise shaping which gets applied during mastering so ultimately listeners are fine either way.<p>However, any type of subsequent processing in the digital domain, even just a volume change by the listener if it&#x27;s applied digitally in the 16 bit realm (i.e., without first upscaling to 24 bits), completely destroys the benefit of dithering. For that reason, we might say that additional processing isn&#x27;t confined to the recording studio and can happen at the end user level.<p>I&#x27;m unsure whether this same logic applies to sampling frequency, but probably? I guess post-mastering processing of amplitude is far more common than time-based changes, but maybe DJs doing beat matching?</div><br/><div id="39586637" class="c"><input type="checkbox" id="c-39586637" checked=""/><div class="controls bullet"><span class="by">hamstergene</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39586138">parent</a><span>|</span><a href="#39588167">next</a><span>|</span><label class="collapse" for="c-39586637">[-]</label><label class="expand" for="c-39586637">[1 more]</label></div><br/><div class="children"><div class="content">I detect some fallacy here.<p>The real benefit is not using 6x network bandwidth, storage, memory, processing power and more battery of the mobile device. That benefit is not going anywhere, no matter what.<p>Post-processing is applied to the signal which is physically impossible to distinguish from the source. It is true that it often needs higher resolution, and DSPs will upsample internally and then back and operate on floats. But to claim without evidence, that post-processing may give human listener back the ability to tell apart whether 192&#x2F;24 medium was used instead of 48&#x2F;16, would be to reintroduce the same quality-loss paranoia, just with an extra step. If one couldn&#x27;t hear the difference before an effect was applied...they won&#x27;t hear it after.<p>As for DJs, they do use high-res assets when producing mixes. That&#x27;s still mastering stage, technically.</div><br/></div></div><div id="39588167" class="c"><input type="checkbox" id="c-39588167" checked=""/><div class="controls bullet"><span class="by">thaanpaa</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39586138">parent</a><span>|</span><a href="#39586637">prev</a><span>|</span><a href="#39588112">next</a><span>|</span><label class="collapse" for="c-39588167">[-]</label><label class="expand" for="c-39588167">[1 more]</label></div><br/><div class="children"><div class="content">With music, in particular, if you use any analog sources while recording, the signal will contain so much noise that any dithering signal will be far below the floor and will most likely be completely redundant. I know that people claim to hear a difference, but they also claim to hear a difference between gold and copper contacts.</div><br/></div></div><div id="39588112" class="c"><input type="checkbox" id="c-39588112" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39586138">parent</a><span>|</span><a href="#39588167">prev</a><span>|</span><a href="#39585923">next</a><span>|</span><label class="collapse" for="c-39588112">[-]</label><label class="expand" for="c-39588112">[1 more]</label></div><br/><div class="children"><div class="content">Bit depth is only useful at reducing the noise floor, the lower the bit rate the higher the noise.<p>That’s why producers (mixing many tracks in a session) want to use high bit rate stems, because they are summing the noise from n tracks.<p>It’s a pointless exercise for DJs or anyone listening to a single source to use a higher bit depth.</div><br/></div></div></div></div></div></div><div id="39585762" class="c"><input type="checkbox" id="c-39585762" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39585707">parent</a><span>|</span><a href="#39585886">prev</a><span>|</span><a href="#39586670">next</a><span>|</span><label class="collapse" for="c-39585762">[-]</label><label class="expand" for="c-39585762">[5 more]</label></div><br/><div class="children"><div class="content">Not just eventually: many effects, such as basically any non-linear mapping like a distortion, will create overtones that will immediately alias down if you are not oversampling. You either need to use some DSP tricks or oversample (usually a mix of both) to avoid this happening, which often happens in just one step of an effects chain.</div><br/><div id="39588418" class="c"><input type="checkbox" id="c-39588418" checked=""/><div class="controls bullet"><span class="by">scns</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39585762">parent</a><span>|</span><a href="#39585914">next</a><span>|</span><label class="collapse" for="c-39588418">[-]</label><label class="expand" for="c-39588418">[1 more]</label></div><br/><div class="children"><div class="content">A great explanation by Dan Worrall:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-jCwIsT0X8M" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-jCwIsT0X8M</a></div><br/></div></div><div id="39585914" class="c"><input type="checkbox" id="c-39585914" checked=""/><div class="controls bullet"><span class="by">markkitti</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39585762">parent</a><span>|</span><a href="#39588418">prev</a><span>|</span><a href="#39586670">next</a><span>|</span><label class="collapse" for="c-39585914">[-]</label><label class="expand" for="c-39585914">[3 more]</label></div><br/><div class="children"><div class="content">Even the term &quot;oversampling&quot; implies that sampling beyond Nyquist rate is excessive. I think you would agree that one is not being excessive. It is necessary to sample well beyond accepted &quot;Nyquist rate&quot; in order to reconstruct the signal.</div><br/><div id="39587517" class="c"><input type="checkbox" id="c-39587517" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39585914">parent</a><span>|</span><a href="#39585935">next</a><span>|</span><label class="collapse" for="c-39587517">[-]</label><label class="expand" for="c-39587517">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d phrase it differently.<p>Your signal contains all kinds of frequencies: Those you care about and those you don&#x27;t want in your recording. You can&#x27;t just sample at the Nyquist rate of the interesting frequency and expect all the other frequencies to vanish. They will mess with the frequencies you are actually interested in.</div><br/></div></div><div id="39585935" class="c"><input type="checkbox" id="c-39585935" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39585914">parent</a><span>|</span><a href="#39587517">prev</a><span>|</span><a href="#39586670">next</a><span>|</span><label class="collapse" for="c-39585935">[-]</label><label class="expand" for="c-39585935">[1 more]</label></div><br/><div class="children"><div class="content">That is the term, however. You see it in many contexts where a higher sample rate is traded for some other desirable attribute. (For example, it&#x27;s often desirable for an ADC to sample faster than the higher frequency content you care about in an analog signal, for the reasons detailed in the paper as well as because it can give you a lower noise ADC. delta-sigma converters being an extreme case of this, helped by a seperate trick of noise shaping).<p>It&#x27;s worth noting it&#x27;s a tradeoff, even in pure processing: almost all non-linear transfer functions will create an infinite number of overtones, so it&#x27;s impossible to avoid aliasing completely: you can only reduce them to some threshold which is acceptable to the application.</div><br/></div></div></div></div></div></div><div id="39586670" class="c"><input type="checkbox" id="c-39586670" checked=""/><div class="controls bullet"><span class="by">flyinghamster</span><span>|</span><a href="#39585707">parent</a><span>|</span><a href="#39585762">prev</a><span>|</span><a href="#39585748">next</a><span>|</span><label class="collapse" for="c-39586670">[-]</label><label class="expand" for="c-39586670">[1 more]</label></div><br/><div class="children"><div class="content">Also, when the sampling rates get extreme (software-defined radio), it is well worth moving to complex samples. Doing so allows you to use a sampling rate equal to your theoretical maximum bandwidth, instead of 2x. That&#x27;s not such a big deal at audio bandwidth, but when your Airspy is slinging a 6 MHz chunk of spectrum, it becomes a huge deal.</div><br/></div></div><div id="39585748" class="c"><input type="checkbox" id="c-39585748" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39585707">parent</a><span>|</span><a href="#39586670">prev</a><span>|</span><a href="#39586196">next</a><span>|</span><label class="collapse" for="c-39585748">[-]</label><label class="expand" for="c-39585748">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, a lot of people think “Nyquist” is a synonym for 2 and stop thinking further.</div><br/><div id="39588070" class="c"><input type="checkbox" id="c-39588070" checked=""/><div class="controls bullet"><span class="by">Espressosaurus</span><span>|</span><a href="#39585707">root</a><span>|</span><a href="#39585748">parent</a><span>|</span><a href="#39586196">next</a><span>|</span><label class="collapse" for="c-39588070">[-]</label><label class="expand" for="c-39588070">[1 more]</label></div><br/><div class="children"><div class="content">Heh. Then they don&#x27;t actually understand what it implies.<p>Which makes sense I suppose.</div><br/></div></div></div></div><div id="39586196" class="c"><input type="checkbox" id="c-39586196" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39585707">parent</a><span>|</span><a href="#39585748">prev</a><span>|</span><a href="#39586538">next</a><span>|</span><label class="collapse" for="c-39586196">[-]</label><label class="expand" for="c-39586196">[1 more]</label></div><br/><div class="children"><div class="content">Another factor which I don&#x27;t see mentioned is that the tech audio signal is not always directly going to your ear. Is it possible for the sound bouncing around the room to break such assumptions?</div><br/></div></div></div></div><div id="39586082" class="c"><input type="checkbox" id="c-39586082" checked=""/><div class="controls bullet"><span class="by">nofu7ur3</span><span>|</span><a href="#39585707">prev</a><span>|</span><a href="#39585772">next</a><span>|</span><label class="collapse" for="c-39586082">[-]</label><label class="expand" for="c-39586082">[6 more]</label></div><br/><div class="children"><div class="content">&gt; ...there is no point to distributing music in 24-bit&#x2F;192kHz format. Its playback fidelity is slightly inferior to 16&#x2F;44.1 or 16&#x2F;48....<p>from &quot;24&#x2F;192 Music Downloads ...and why they make no sense&quot; (2012) [1]<p>[1] <a href="https:&#x2F;&#x2F;people.xiph.org&#x2F;~xiphmont&#x2F;demo&#x2F;neil-young.html" rel="nofollow">https:&#x2F;&#x2F;people.xiph.org&#x2F;~xiphmont&#x2F;demo&#x2F;neil-young.html</a></div><br/><div id="39586281" class="c"><input type="checkbox" id="c-39586281" checked=""/><div class="controls bullet"><span class="by">hamstergene</span><span>|</span><a href="#39586082">parent</a><span>|</span><a href="#39586488">next</a><span>|</span><label class="collapse" for="c-39586281">[-]</label><label class="expand" for="c-39586281">[1 more]</label></div><br/><div class="children"><div class="content">This could be a useful disclaimer, to say &quot;we are talking about recording and processing and NOT about playback&quot;.<p>Audiophiles demand streaming services to provide 192&#x2F;24 because they see the music being originally mastered at high sample rates, and from that conclude that listening to 48&#x2F;16 is a loss of &quot;original recorded quality&quot;.<p>I can totally envision audiophiles picking up the Wescott&#x27;s article and using it as &quot;scientific&quot; argument to distribute more Hi-Res music, and some half-technical manager buying that. They won&#x27;t even read it.</div><br/></div></div><div id="39586488" class="c"><input type="checkbox" id="c-39586488" checked=""/><div class="controls bullet"><span class="by">shin_lao</span><span>|</span><a href="#39586082">parent</a><span>|</span><a href="#39586281">prev</a><span>|</span><a href="#39585772">next</a><span>|</span><label class="collapse" for="c-39586488">[-]</label><label class="expand" for="c-39586488">[4 more]</label></div><br/><div class="children"><div class="content">High sample rate isn&#x27;t useful for playback, but 24-bit is great for nuance in low intensity sound.</div><br/><div id="39587840" class="c"><input type="checkbox" id="c-39587840" checked=""/><div class="controls bullet"><span class="by">throwaway0665</span><span>|</span><a href="#39586082">root</a><span>|</span><a href="#39586488">parent</a><span>|</span><a href="#39587538">next</a><span>|</span><label class="collapse" for="c-39587840">[-]</label><label class="expand" for="c-39587840">[1 more]</label></div><br/><div class="children"><div class="content">The noise floor of 16-bit music is imperceptible so for mastered music at least 24-bits is useless. Both a higher sample rate and bit depth can be useful for recording purposes - provided the room is perfectly treated and there are no external sources of noise.</div><br/></div></div><div id="39587538" class="c"><input type="checkbox" id="c-39587538" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#39586082">root</a><span>|</span><a href="#39586488">parent</a><span>|</span><a href="#39587840">prev</a><span>|</span><a href="#39585772">next</a><span>|</span><label class="collapse" for="c-39587538">[-]</label><label class="expand" for="c-39587538">[2 more]</label></div><br/><div class="children"><div class="content">so for stuff which didn&#x27;t properly use the dynamic range of the standard codecs?<p>Are human ears even capable of hearing 24 bits of dynamic range?</div><br/><div id="39587970" class="c"><input type="checkbox" id="c-39587970" checked=""/><div class="controls bullet"><span class="by">FabHK</span><span>|</span><a href="#39586082">root</a><span>|</span><a href="#39587538">parent</a><span>|</span><a href="#39585772">next</a><span>|</span><label class="collapse" for="c-39587970">[-]</label><label class="expand" for="c-39587970">[1 more]</label></div><br/><div class="children"><div class="content">Rule of thumb:<p>We know that 2^10 ≈ 10^3, so 2^24 ≈ 10^(3&#x2F;10*24) = 10^7.2. This 7.2 is about amplitude, but what we hear is power which is quadratic in amplitude, so take a factor of 2, and you&#x27;re talking 14.4 bel, or 144 decibel for 24 bit (and 2&#x2F;3 of that, 96 db, for 16 bit).<p>(In reality it&#x27;s a bit more complicated, but that&#x27;s a good rough guide, see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Audio_bit_depth#Quantization" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Audio_bit_depth#Quantization</a>)</div><br/></div></div></div></div></div></div></div></div><div id="39585772" class="c"><input type="checkbox" id="c-39585772" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39586082">prev</a><span>|</span><a href="#39587000">next</a><span>|</span><label class="collapse" for="c-39585772">[-]</label><label class="expand" for="c-39585772">[1 more]</label></div><br/><div class="children"><div class="content">I have referred so many people to this paper over the years. It does a great job of dispelling a lot of misunderstandings people have about Nyquist&#x27;s theorem.</div><br/></div></div><div id="39587000" class="c"><input type="checkbox" id="c-39587000" checked=""/><div class="controls bullet"><span class="by">iamcreasy</span><span>|</span><a href="#39585772">prev</a><span>|</span><a href="#39587414">next</a><span>|</span><label class="collapse" for="c-39587000">[-]</label><label class="expand" for="c-39587000">[2 more]</label></div><br/><div class="children"><div class="content">So, we first need to find the highest motion frequency a sensor might experience in the experiment, and then make sure the sampling rate it at least twice that to avoid aliasing?<p>Meaning, if an IMU sensor is mounted on a very slow moving, such as 2cm&#x2F;s, RC vehicle then the sampling rate can be very slow. But if the sensor is on a fast moving drone, we need to estimate the highest frequency of the motion and make sure our sampling rate is at least double that?</div><br/><div id="39587411" class="c"><input type="checkbox" id="c-39587411" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#39587000">parent</a><span>|</span><a href="#39587414">next</a><span>|</span><label class="collapse" for="c-39587411">[-]</label><label class="expand" for="c-39587411">[1 more]</label></div><br/><div class="children"><div class="content">Yes, pretty much, but it depends. Your 2 cm&#x2F;s RC vehicle might still experience high-frequency vibrations (in the range of the motor rpm) and you might want to sample that.</div><br/></div></div></div></div><div id="39587414" class="c"><input type="checkbox" id="c-39587414" checked=""/><div class="controls bullet"><span class="by">jeanl</span><span>|</span><a href="#39587000">prev</a><span>|</span><a href="#39585753">next</a><span>|</span><label class="collapse" for="c-39587414">[-]</label><label class="expand" for="c-39587414">[3 more]</label></div><br/><div class="children"><div class="content">For a mini-surprise, check the prime factors of 44100.</div><br/><div id="39587806" class="c"><input type="checkbox" id="c-39587806" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39587414">parent</a><span>|</span><a href="#39585753">next</a><span>|</span><label class="collapse" for="c-39587806">[-]</label><label class="expand" for="c-39587806">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a multiple of 7?<p>It doesn&#x27;t have big factors?<p>I don&#x27;t know what I&#x27;m supposed to be surprised about.</div><br/><div id="39587827" class="c"><input type="checkbox" id="c-39587827" checked=""/><div class="controls bullet"><span class="by">mppm</span><span>|</span><a href="#39587414">root</a><span>|</span><a href="#39587806">parent</a><span>|</span><a href="#39585753">next</a><span>|</span><label class="collapse" for="c-39587827">[-]</label><label class="expand" for="c-39587827">[1 more]</label></div><br/><div class="children"><div class="content">44100 = 210^2 = (2 * 3 * 5 * 7)^2</div><br/></div></div></div></div></div></div><div id="39585753" class="c"><input type="checkbox" id="c-39585753" checked=""/><div class="controls bullet"><span class="by">anonymous-panda</span><span>|</span><a href="#39587414">prev</a><span>|</span><label class="collapse" for="c-39585753">[-]</label><label class="expand" for="c-39585753">[8 more]</label></div><br/><div class="children"><div class="content">It’s interesting to me how frequently people will talk about sampling performance profilers and not know about Nyquist.<p>Given a CPU runs at many GHz but SW sampling profilers run at ~1 or even maximum 10khz, it’s really hard to write software if you’re targeting processing at MHz rates.</div><br/><div id="39585780" class="c"><input type="checkbox" id="c-39585780" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39585753">parent</a><span>|</span><label class="collapse" for="c-39585780">[-]</label><label class="expand" for="c-39585780">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you mean here, but I would say that sampling profilers are a good example of Nyquist applied correctly for the most part: your signal (the distribution of where your software is spending its time) is likely to have an extremely low bandwidth (as in, it&#x27;s basically static), so why try to sample super rapidly? It&#x27;s much more of a question of whether you get enough samples to represent that distribution accurately, not how quickly you get those samples.</div><br/><div id="39585934" class="c"><input type="checkbox" id="c-39585934" checked=""/><div class="controls bullet"><span class="by">anonymous-panda</span><span>|</span><a href="#39585753">root</a><span>|</span><a href="#39585780">parent</a><span>|</span><a href="#39586851">next</a><span>|</span><label class="collapse" for="c-39585934">[-]</label><label class="expand" for="c-39585934">[5 more]</label></div><br/><div class="children"><div class="content">You’re talking about profiling a normal running program. If you’re profiling a benchmark that’s always executing the hot path, where exactly the hot path contribution lies becomes less clear. This is because you run into aliasing with the samples being collected at unhelpful points. Maybe if you run long enough you start to see a picture but at 1khz you’re going to have to run for a very long time. The other way aliasing comes into effect is that it becomes to see the impact of “individually cheap” but often executed pieces of code (eg a simple bounds check may not show up even if it’s responsible for a 20% slowdown because the probability of your sampler hitting it is small when that bounds check takes nanoseconds to execute vs your ms profiler sample rate.<p>Basically a 1ms sampler can pick out a signal that’s 2ms or longer in periodicity if sampled once (all faster signals will get aliased). To get to 1ghz (once a nanosecond) would require capturing 1 million times more samples and you’re still dealing with aliasing screwing up the picture you’re getting (although maybe with stack sampling you get disambiguation to combat aliasing? Not sure).</div><br/><div id="39585972" class="c"><input type="checkbox" id="c-39585972" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39585753">root</a><span>|</span><a href="#39585934">parent</a><span>|</span><a href="#39587752">next</a><span>|</span><label class="collapse" for="c-39585972">[-]</label><label class="expand" for="c-39585972">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think what you&#x27;re talking about is aliasing: it&#x27;s more to do with the statistics of sampling. Though even then I still don&#x27;t quite get what you mean: if a bounds check is 20% of your runtime then you&#x27;re going to see it in your samples pretty quickly. If it&#x27;s a small enough fraction of your runtime that you don&#x27;t expect to see it in millions of samples, then why is it relevant to your performance? Now, if you&#x27;re worried about latency outliers, I can see why sampling may not be a useful tool, but again I don&#x27;t think the reason for that is really aliasing.</div><br/></div></div><div id="39587752" class="c"><input type="checkbox" id="c-39587752" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#39585753">root</a><span>|</span><a href="#39585934">parent</a><span>|</span><a href="#39585972">prev</a><span>|</span><a href="#39586346">next</a><span>|</span><label class="collapse" for="c-39587752">[-]</label><label class="expand" for="c-39587752">[1 more]</label></div><br/><div class="children"><div class="content">One possible issue is that if sampling is even slightly biased, it can incorrectly estimate the relative frequency of different points&#x2F;functions in tight inner function calls (which can&#x27;t happen with infrequently called functions with a long runtime)?</div><br/></div></div><div id="39586346" class="c"><input type="checkbox" id="c-39586346" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#39585753">root</a><span>|</span><a href="#39585934">parent</a><span>|</span><a href="#39587752">prev</a><span>|</span><a href="#39586851">next</a><span>|</span><label class="collapse" for="c-39586346">[-]</label><label class="expand" for="c-39586346">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a simple bounds check may not show up even if it’s responsible for a 20% slowdown because the probability of your sampler hitting it is small when that bounds check takes nanoseconds to execute vs your ms profiler sample rate.<p>Surely for this to happen you&#x27;d have to be putting a lot of effort into getting a perfect 1ms sampling rate, and even a little bit of variation in that would be more than enough to handle aliasing issues.</div><br/><div id="39587322" class="c"><input type="checkbox" id="c-39587322" checked=""/><div class="controls bullet"><span class="by">anonymous-panda</span><span>|</span><a href="#39585753">root</a><span>|</span><a href="#39586346">parent</a><span>|</span><a href="#39586851">next</a><span>|</span><label class="collapse" for="c-39587322">[-]</label><label class="expand" for="c-39587322">[1 more]</label></div><br/><div class="children"><div class="content">It’s been a few years but if I recall correctly the fact that there’s variation in the sampling itself makes the aliasing worse not better. At the very least should be no different.</div><br/></div></div></div></div></div></div><div id="39586851" class="c"><input type="checkbox" id="c-39586851" checked=""/><div class="controls bullet"><span class="by">gct</span><span>|</span><a href="#39585753">root</a><span>|</span><a href="#39585780">parent</a><span>|</span><a href="#39585934">prev</a><span>|</span><label class="collapse" for="c-39586851">[-]</label><label class="expand" for="c-39586851">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact static is very broadband</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>