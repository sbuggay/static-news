<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732870866314" as="style"/><link rel="stylesheet" href="styles.css?v=1732870866314"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2411.16544">Float Self-Tagging</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>laurenth</span> | <span>44 comments</span></div><br/><div><div id="42257006" class="c"><input type="checkbox" id="c-42257006" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#42267503">next</a><span>|</span><label class="collapse" for="c-42257006">[-]</label><label class="expand" for="c-42257006">[9 more]</label></div><br/><div class="children"><div class="content">Really cool solution! One question: maybe I missed it, but there&#x27;s no <i>technical</i> reason the tag bits could not use the entire range of exponent bits, no? Other than the fact that having up to 2048 tags would be ridiculously branchy, I guess.<p>Here&#x27;s a variation I just thought of, which probably has a few footguns I&#x27;m overlooking right now: use the seven highest exponent bits instead of three. Then we can directly read the most significant byte of a double, skipping the need for a rotation altogether.<p>After reading the most significant byte, subtract 16 (or 0b00010000) from it, then mask out the sign. To test for unboxed doubles, test if the resulting value is bigger than 15. If so, it is an unboxed double, otherwise the lower four bits of the byte are available as alternative tags (so 16 tags).<p>Effectively, we adjusted the exponent range 2⁻⁷⁶⁷..2⁻⁵¹¹ into the 0b(0)0000000 - 0b(0)0001111 range and made them boxed doubles. <i>Every</i> other double, which is 15&#x2F;16th of all possible doubles, is now unboxed. This includes subnormals, zero, all NaN encodings (so it even can exist in superposition with a NaN or NuN tagging system I guess?) and both infinities.<p>To be clear, this is off the top of my head so maybe I made a few crucial mistakes here.</div><br/><div id="42258378" class="c"><input type="checkbox" id="c-42258378" checked=""/><div class="controls bullet"><span class="by">omelancon</span><span>|</span><a href="#42257006">parent</a><span>|</span><a href="#42257008">next</a><span>|</span><label class="collapse" for="c-42258378">[-]</label><label class="expand" for="c-42258378">[7 more]</label></div><br/><div class="children"><div class="content">Hi, I&#x27;m one of the authors of the paper. Thanks for your questions and comments!<p>There are many reasons why 3-bit tags work well in practice. Importantly, it allows aligning heap objects on 64-bit machine words. Dereferencing a tagged pointer can then be done in a single machine instruction, a MOV offset by the tag.<p>One of our goals is to make self-tagging as straightforward to implement in existing systems as possible. Thus requiring to move away from the ubiquitous 3-bit tag scheme is definitely a no-go.<p>Another goal is performance, obviously. It turns out that if the transformation from self-tagged float to IEEE754 float requires more than a few (2-3) machine instructions, it is no longer as advantageous. Thus the choice of tags 000, 011 and 100, which encoding&#x2F;decoding is a single bitwise rotation.<p>Also keep in mind that assigning more tags to self-tagging to capture floats that are never used in practice just adds a strain on other objects. That&#x27;s why we include a usage analysis of floats to guide tag selection in our paper.<p>In fact, we are currently working on an improved version that uses a single tag to capture all &quot;useful&quot; values. Capturing 3&#x2F;8 of floats seems unnecessary, especially since one of the tag is only meant to capture +-0.0. The trick is to rotate the tag to bits 2-3-4 of the exponent instead of 1-2-3 and add an offset to the exponent to &quot;shift&quot; the range of captured values.<p>But in the end, it feels like we are barely scratching the surface and that a lot of fine-tuning can still be done by toying with tag placement and transformation. But I think the next step is a quality over quantity improvement: capture less floats but capture the right ones.</div><br/><div id="42258908" class="c"><input type="checkbox" id="c-42258908" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#42257006">root</a><span>|</span><a href="#42258378">parent</a><span>|</span><a href="#42269097">next</a><span>|</span><label class="collapse" for="c-42258908">[-]</label><label class="expand" for="c-42258908">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for the explanation! I was not aware of the context behind the choice of three-bit tags.<p>&gt; <i>The trick is to rotate the tag to bits 2-3-4 of the exponent instead of 1-2-3 and add an offset to the exponent to &quot;shift&quot; the range of captured values.</i><p>Maybe I misunderstand, but isn&#x27;t that a similar idea to what I just described? Adding an offset to &quot;rotate&quot; the ranges of the exponent by a segment, putting the one with zero in the high side? The main difference being that you stick to the upper four bits of the exponent, and that I suggested using one of the upper three bit sequences to mark bits 4-5-6-7 as tag bits? (I mistakenly included the sign bit before and claimed this unboxes 15&#x2F;16ths of all doubles, it&#x27;s actually 7&#x2F;8ths) Which probably has consequences for minimizing instructions, like you mentioned.<p>&gt; <i>But I think the next step is a quality over quantity improvement: capture less floats but capture the right ones.</i><p>I suspect that ensuring NaN and Infinity are in there will be crucial to avoid performance cliffs in certain types of code; I have seen production code where it is known that initiated values are always finite, so either of those two are then used as ways to &quot;tag&quot; a float value as &quot;missing&quot; or something to that degree.<p>Anyway, looking forward to future results of your research!</div><br/><div id="42266451" class="c"><input type="checkbox" id="c-42266451" checked=""/><div class="controls bullet"><span class="by">omelancon</span><span>|</span><a href="#42257006">root</a><span>|</span><a href="#42258908">parent</a><span>|</span><a href="#42269097">next</a><span>|</span><label class="collapse" for="c-42266451">[-]</label><label class="expand" for="c-42266451">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Maybe I misunderstand, but isn&#x27;t that a similar idea to what I just described? Adding an offset to &quot;rotate&quot; the ranges of the exponent by a segment...</i><p>Yes it is similar. It seems to me that there really isn&#x27;t that many useful operations that can be applied to the exponent beside adding an offset. But that&#x27;s only a suspicion, do not take my word for it.<p>&gt; <i>I suspect that ensuring NaN and Infinity are in there will be crucial to avoid performance cliffs...</i><p>This is a reasonable assumption. There are in fact ways to rotate and add an offset such that the exponent can overflows&#x2F;underflows to capture exponents 0 and 0x7ff (for inf and nan) with a single well-positioned tag. Making it work in practice is not as simple, but we are working on it.</div><br/></div></div></div></div><div id="42269097" class="c"><input type="checkbox" id="c-42269097" checked=""/><div class="controls bullet"><span class="by">jacobp100</span><span>|</span><a href="#42257006">root</a><span>|</span><a href="#42258378">parent</a><span>|</span><a href="#42258908">prev</a><span>|</span><a href="#42267041">next</a><span>|</span><label class="collapse" for="c-42269097">[-]</label><label class="expand" for="c-42269097">[1 more]</label></div><br/><div class="children"><div class="content">Just to add some JS engine info - every engine stores numbers as 32 bit integers if possible, which is usually done by tagging a pointer. Also, JSC needs pointers to be represented exactly as-is, because it will scan the stack for anything that looks like a pointer, and retain it when running the GC</div><br/></div></div><div id="42267041" class="c"><input type="checkbox" id="c-42267041" checked=""/><div class="controls bullet"><span class="by">funny_falcon</span><span>|</span><a href="#42257006">root</a><span>|</span><a href="#42258378">parent</a><span>|</span><a href="#42269097">prev</a><span>|</span><a href="#42257008">next</a><span>|</span><label class="collapse" for="c-42267041">[-]</label><label class="expand" for="c-42267041">[3 more]</label></div><br/><div class="children"><div class="content">Just correction: CRuby uses “Float Self-Tagging” for years.</div><br/><div id="42268729" class="c"><input type="checkbox" id="c-42268729" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42257006">root</a><span>|</span><a href="#42267041">parent</a><span>|</span><a href="#42257008">next</a><span>|</span><label class="collapse" for="c-42268729">[-]</label><label class="expand" for="c-42268729">[2 more]</label></div><br/><div class="children"><div class="content">This is your 4th comment claiming this: it&#x27;s not true.<p>You&#x27;re right that Ruby uses tags, ex. Objective-C does also and has for a while.<p>The innovation here is its a tag <i>without the tag bits</i>. That&#x27;s why its self-tagging, not tagging.</div><br/><div id="42269659" class="c"><input type="checkbox" id="c-42269659" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#42257006">root</a><span>|</span><a href="#42268729">parent</a><span>|</span><a href="#42257008">next</a><span>|</span><label class="collapse" for="c-42269659">[-]</label><label class="expand" for="c-42269659">[1 more]</label></div><br/><div class="children"><div class="content">In another comment, this user links a CRuby commit that they claim adds it. It seems legit.<p>Linked commit contains code for rotating tagged floats so bits 60..62 go to the least significant positions, and a comment about a range of unboxed floats between 1.7...e-77 and 1.7...e77, plus special casing 0.0<p>e.g. this excerpt:<p><pre><code>    #if USE_FLONUM
    #define RUBY_BIT_ROTL(v, n) (((v) &lt;&lt; (n)) | ((v) &gt;&gt; ((sizeof(v) * 8) - n)))
    #define RUBY_BIT_ROTR(v, n) (((v) &gt;&gt; (n)) | ((v) &lt;&lt; ((sizeof(v) * 8) - n)))
    
    static inline double
    rb_float_value(VALUE v)
    {
      if (FLONUM_P(v)) {
 if (v == (VALUE)0x8000000000000002) {
     return 0.0;
 }
 else {
     union {
  double d;
  VALUE v;
     } t;

     VALUE b63 = (v &gt;&gt; 63);
     &#x2F;* e: xx1... -&gt; 011... *&#x2F;
     &#x2F;*    xx0... -&gt; 100... *&#x2F;
     &#x2F;*      ^b63           *&#x2F;
     t.v = RUBY_BIT_ROTR(((b63 ^ 1) &lt;&lt; 1) | b63 | (v &amp; ~0x03), 3);
     return t.d;
 }
      }
      else {
 return ((struct RFloat *)v)-&gt;float_value;
      }
    }</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="42257008" class="c"><input type="checkbox" id="c-42257008" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#42257006">parent</a><span>|</span><a href="#42258378">prev</a><span>|</span><a href="#42267503">next</a><span>|</span><label class="collapse" for="c-42257008">[-]</label><label class="expand" for="c-42257008">[1 more]</label></div><br/><div class="children"><div class="content">Also, funny enough, this idea and variations of it look surprisingly easy to implement in JS itself using typed arrays. I won&#x27;t any claims of impact on performance though...<p>You need a Float64Array for the values (plus a Uint32Array&#x2F;Uint8Array using the same buffer to be able to manipulate the integer bits, which <i>technically</i> also requires knowledge of endianness since it&#x27;s <i>technically</i> not in the JS spec and some funny mobile hardware still exists out there). Mocking a heap is easy enough: the &quot;heap&quot; can be a plain array, the &quot;pointers&quot; indices into the array. Using a Map&lt;value, index&gt; would you &quot;intern&quot; duplicate values (i.e. ensure doubles outside the unboxed range are only &quot;heap&quot; allocated once).</div><br/></div></div></div></div><div id="42267503" class="c"><input type="checkbox" id="c-42267503" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#42257006">prev</a><span>|</span><a href="#42261548">next</a><span>|</span><label class="collapse" for="c-42267503">[-]</label><label class="expand" for="c-42267503">[1 more]</label></div><br/><div class="children"><div class="content">I doubt this is actually faster than NaN or why they call NuN tagging. The code sequences they cite for encoding and decoding are worse than what I expect NuN tagging to give you.<p>If they want to convince me that their thing is faster, they should do a comparison against a production implementation of NuN tagging. Note that the specifics of getting it right involve wacky register allocation tricks on x86 and super careful instruction selection on arm.<p>It seems that they use some very nonstandard JS implementation of NaN tagging as a strawman comparison.<p>(Source: I wrote a lot of the NuN tagging optimizations in JavaScriptCore, but I didn’t invent the technique.)</div><br/></div></div><div id="42261548" class="c"><input type="checkbox" id="c-42261548" checked=""/><div class="controls bullet"><span class="by">pavpanchekha</span><span>|</span><a href="#42267503">prev</a><span>|</span><a href="#42263230">next</a><span>|</span><label class="collapse" for="c-42261548">[-]</label><label class="expand" for="c-42261548">[21 more]</label></div><br/><div class="children"><div class="content">I loved this clever, weird, awesome paper, so a short summary.<p>In many dynamic languages some values are stored on the heap (&quot;boxed&quot;) and represented as a pointer, while others are represented as an immediate value (&quot;unboxed&quot; or &quot;immediate&quot;). Pointer tagging is a common way to do that: the low bit of the value tells you the value&#x27;s type, and some types are immediate while others are boxed.<p>Naturally, the tag bits have a fixed value, so can&#x27;t be used to store data. So for example your language might offer 61-bit integer immediates instead of 64-bit integers; the other three bits are used for tags. Possibly, larger integers are stored on the heap and treated as a different type (for example Python 2.X had separate int and long types for these cases).<p>However, it&#x27;s hard to use this strategy for floats, because floats need all 64 bits (or 32 bits for single-precision, same difference). There&#x27;s a trick called &quot;NaN boxing&quot; which makes use of the large number of NaNs in the float representation, but read the paper if you want more on that.<p>The authors&#x27; insight is that, suppose you have a three-bit tag and 011 is the tag for floats. By totally random chance, _some_ floats will end in 011; you can represent those as immediates with those tag bits. Obviously, that&#x27;s unlikely, though you can raise the chances by using, like, 010, 011, 100, and 101 all as float tags. Still, the low bits are a bad choice. But what about high bits? Most floats have one of a couple high bit patterns, because most floats are either 0 or between, say, 1e-100 and 1e100. Floats outside that range can be boxed but since they&#x27;re really rare it&#x27;s not a big cost to box them.<p>So basically, we use high bits as our tag bits and map all the common float prefixes to float tags. This allows unboxing the vast majority of floats, which leads to <i>big</i> speedups on float-heavy benchmarks.<p>A personal note: I&#x27;ve been working in numerics and floating-point for a decade now and have had to deal with float boxing both from a research point of view (lots of runtime analysis systems for floats), from a user point of view (using unboxed float vectors for significant speedup in my own software), and from a teaching point of view (discussing boxing in my compilers class, using NaN-boxing as an example of cleverness).<p>This idea is so simple, so crazy, so stupid, and works so well, but I never thought of it. Bravo to the authors.</div><br/><div id="42262159" class="c"><input type="checkbox" id="c-42262159" checked=""/><div class="controls bullet"><span class="by">daanx</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42261743">next</a><span>|</span><label class="collapse" for="c-42262159">[-]</label><label class="expand" for="c-42262159">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This idea is so simple, so crazy, so stupid, and works so well, but I never thought of it. Bravo to the authors.<p>Thanks for the nice summary -- looking forward to read the paper!<p>The same idea of self-tagging is actually also used in Koka language [1] runtime system where by default the Koka compiler only heap allocates float64&#x27;s when their absolute value is outside the range [2e-511,2e512) and not 0, infinity, or NaN (see [2]). This saves indeed many (many!) heap allocations for float intensive programs.<p>Since Koka only uses 1 bit to distinguish pointers from values, another slightly faster option is to only box negative float64&#x27;s but of course, negative numbers are still quite common so it saves less allocations in general.<p>[1] <a href="https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-value-types" rel="nofollow">https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-value-typ...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;koka-lang&#x2F;koka&#x2F;blob&#x2F;dev&#x2F;kklib&#x2F;src&#x2F;box.c#L309">https:&#x2F;&#x2F;github.com&#x2F;koka-lang&#x2F;koka&#x2F;blob&#x2F;dev&#x2F;kklib&#x2F;src&#x2F;box.c#L...</a><p>ps. If you enjoy reading about tagging, I recently wrote a note on efficiently supporting seamless large integer arithmetic (as used in Koka as well) and discuss how certain hardware instructions could really help to speed this up [3]:<p>[3] <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2022&#x2F;07&#x2F;int.pdf" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2022&#x2F;0...</a> (ML workshop 2022)</div><br/></div></div><div id="42261743" class="c"><input type="checkbox" id="c-42261743" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42262159">prev</a><span>|</span><a href="#42261761">next</a><span>|</span><label class="collapse" for="c-42261743">[-]</label><label class="expand" for="c-42261743">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>This allows unboxing the vast majority of floats, which leads to big speedups on float-heavy benchmarks.</i><p>NaN-boxing allows <i>all</i> floats to be unboxed though. The main benefit of the self-tagging approach seems to be that by boxing <i>some</i> floats, we can make space for 64-bit pointers which are too large for NaN-boxing.<p>The surprising part of the paper is that &quot;<i>some</i> floats&quot; is only a small minority of values - not, say, 50% of them.</div><br/><div id="42263029" class="c"><input type="checkbox" id="c-42263029" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261743">parent</a><span>|</span><a href="#42262562">next</a><span>|</span><label class="collapse" for="c-42263029">[-]</label><label class="expand" for="c-42263029">[3 more]</label></div><br/><div class="children"><div class="content">A small minority, but apparently it includes all the floats you’re likely to use. It seems the insight is that you only need 8 bits of exponent in most cases. (And single-precision floating point only has 8 bits of exponent.)<p><i>Most</i> double-precision floats are never used because they have high exponents.</div><br/><div id="42271178" class="c"><input type="checkbox" id="c-42271178" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42263029">parent</a><span>|</span><a href="#42265259">next</a><span>|</span><label class="collapse" for="c-42271178">[-]</label><label class="expand" for="c-42271178">[1 more]</label></div><br/><div class="children"><div class="content">Got take, but a double with only 8 bits of exponent actually seems kind of nice, you get the extra precision but it can be cast down to a single and you only lose precision; you don’t have values that are outside the range of singles.</div><br/></div></div><div id="42265259" class="c"><input type="checkbox" id="c-42265259" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42263029">parent</a><span>|</span><a href="#42271178">prev</a><span>|</span><a href="#42262562">next</a><span>|</span><label class="collapse" for="c-42265259">[-]</label><label class="expand" for="c-42265259">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>A small minority, but apparently it includes all the floats you’re likely to use.</i><p>Sorry, I meant a small minority need to be boxed - all the floats you&#x27;re likely to use can remain unboxed.</div><br/></div></div></div></div><div id="42262562" class="c"><input type="checkbox" id="c-42262562" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261743">parent</a><span>|</span><a href="#42263029">prev</a><span>|</span><a href="#42261761">next</a><span>|</span><label class="collapse" for="c-42262562">[-]</label><label class="expand" for="c-42262562">[3 more]</label></div><br/><div class="children"><div class="content">50% means you only get 1 tag bit.<p>also you totally can fit 64 bit pointers inside a NaN. 46 bit pointers are only 48 bits and you have 53 bits of NaN payload. (you also could get an extra 3 bits if you only allow storing 8 byte aligned pointers unboxed)</div><br/><div id="42262621" class="c"><input type="checkbox" id="c-42262621" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42262562">parent</a><span>|</span><a href="#42261761">next</a><span>|</span><label class="collapse" for="c-42262621">[-]</label><label class="expand" for="c-42262621">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>50% means you only get 1 tag bit.</i><p>That&#x27;s enough to distinguish between &quot;unboxed float&quot; and &quot;something else&quot;, where the latter can have additional tag bits.<p>&gt; <i>[64-bit] pointers are only 48 bits and you have 53 bits of NaN payload.</i><p>The paper specifically talks about support for &quot;high memory addresses that do not fit in 48 bits&quot;. If you don&#x27;t have to handle those high addresses, I don&#x27;t think this approach has any benefits compared to NaN-boxing.</div><br/><div id="42265532" class="c"><input type="checkbox" id="c-42265532" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42262621">parent</a><span>|</span><a href="#42261761">next</a><span>|</span><label class="collapse" for="c-42265532">[-]</label><label class="expand" for="c-42265532">[1 more]</label></div><br/><div class="children"><div class="content">Of note is that even if you have some massive ≥2^48 data sources, you could still quite likely get away with having NaN-boxed pointers to within the low-size heap, with an extra indirection for massive data. This only would break apart if you managed to reach around 2^45 distinct referenceable objects, which you probably shouldn&#x27;t ever have (esp. in a GCd language).</div><br/></div></div></div></div></div></div></div></div><div id="42261761" class="c"><input type="checkbox" id="c-42261761" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42261743">prev</a><span>|</span><a href="#42264503">next</a><span>|</span><label class="collapse" for="c-42261761">[-]</label><label class="expand" for="c-42261761">[8 more]</label></div><br/><div class="children"><div class="content">Do all float operations need to reconfirm those bits afterwards though? I suppose if you have some sort of JIT you can end up with a bunch of unboxed floats and would only pay the cost on boundaries though</div><br/><div id="42262058" class="c"><input type="checkbox" id="c-42262058" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261761">parent</a><span>|</span><a href="#42263129">next</a><span>|</span><label class="collapse" for="c-42262058">[-]</label><label class="expand" for="c-42262058">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>reconfirm those bits afterwards</i><p>Thanks - I hadn&#x27;t thought about that but it seems to be the main downside of this approach. The benefit of NaN-boxing is that it reassigns values that are otherwise unused - floating-point calculations will never generate NaNs with those bit patterns.</div><br/><div id="42263237" class="c"><input type="checkbox" id="c-42263237" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42262058">parent</a><span>|</span><a href="#42263129">next</a><span>|</span><label class="collapse" for="c-42263237">[-]</label><label class="expand" for="c-42263237">[1 more]</label></div><br/><div class="children"><div class="content">An additional wrinkle is that NaNs are a bit unstable and can have large performance penalties. You can&#x27;t let the NaNs ever escape into arithmetic and you may even have issues even storing them in a register.</div><br/></div></div></div></div><div id="42263129" class="c"><input type="checkbox" id="c-42263129" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261761">parent</a><span>|</span><a href="#42262058">prev</a><span>|</span><a href="#42264475">next</a><span>|</span><label class="collapse" for="c-42263129">[-]</label><label class="expand" for="c-42263129">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but there should be some optimisation opportunities.<p>Off the top of my head: Any multiply by a constant less than 1.0 will never overflow the unboxed range (but might underflow) and there should be times when it&#x27;s provably better to check the inputs are inside a range, rather than checking the outputs.<p>It&#x27;s worth pointing out that these overflow&#x2F;underflow checks will be very cold (on typical code). They won&#x27;t waste much in the way of branch-prediction resources.<p>I wonder if it&#x27;s worth taking advantage of floating point overflow&#x2F;underflow exceptions. I think a multiplication by 2^767 will trigger an exception if the value would overflow, and the corresponding multiply by 2^-765 will catch underflows.<p>It&#x27;s tempting to allocate two more tags for floats (001 and 010), covering the entire range from -2^257 to +2^257. It will be rare to actually see those small floats near zero, but it could be worth eliminating the possibility of underflows.</div><br/></div></div><div id="42264475" class="c"><input type="checkbox" id="c-42264475" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261761">parent</a><span>|</span><a href="#42263129">prev</a><span>|</span><a href="#42261994">next</a><span>|</span><label class="collapse" for="c-42264475">[-]</label><label class="expand" for="c-42264475">[2 more]</label></div><br/><div class="children"><div class="content">You check the tag before doing float operations</div><br/><div id="42265279" class="c"><input type="checkbox" id="c-42265279" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42264475">parent</a><span>|</span><a href="#42261994">next</a><span>|</span><label class="collapse" for="c-42265279">[-]</label><label class="expand" for="c-42265279">[1 more]</label></div><br/><div class="children"><div class="content">And afterwards, because floating-point arithmetic can change the value of the tag. This isn&#x27;t necessary with NaN-boxing, because it uses NaN bit patterns that the hardware never generates.</div><br/></div></div></div></div><div id="42261994" class="c"><input type="checkbox" id="c-42261994" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261761">parent</a><span>|</span><a href="#42264475">prev</a><span>|</span><a href="#42264503">next</a><span>|</span><label class="collapse" for="c-42261994">[-]</label><label class="expand" for="c-42261994">[2 more]</label></div><br/><div class="children"><div class="content">Only when they have to be boxed, but yes if you are talking about that.</div><br/><div id="42263056" class="c"><input type="checkbox" id="c-42263056" checked=""/><div class="controls bullet"><span class="by">ndjdjddjsjj</span><span>|</span><a href="#42261548">root</a><span>|</span><a href="#42261994">parent</a><span>|</span><a href="#42264503">next</a><span>|</span><label class="collapse" for="c-42263056">[-]</label><label class="expand" for="c-42263056">[1 more]</label></div><br/><div class="children"><div class="content">You need to check after the floating point operation though just in case. Or after the boundary where you pass the float to something else expecting this scheme.</div><br/></div></div></div></div></div></div><div id="42264503" class="c"><input type="checkbox" id="c-42264503" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42261761">prev</a><span>|</span><a href="#42263093">next</a><span>|</span><label class="collapse" for="c-42264503">[-]</label><label class="expand" for="c-42264503">[1 more]</label></div><br/><div class="children"><div class="content">Nice explanation but it took me a while to understand the trick. They are hidding the tag in the &quot;exponent&quot; of the float, not in the &quot;mantisa&quot;!</div><br/></div></div><div id="42263093" class="c"><input type="checkbox" id="c-42263093" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42264503">prev</a><span>|</span><a href="#42261690">next</a><span>|</span><label class="collapse" for="c-42263093">[-]</label><label class="expand" for="c-42263093">[1 more]</label></div><br/><div class="children"><div class="content">It’s clever, but not random chance. That would be too much of a coincidence. They rotate the floats to make it happen the way they want.<p>It’s hardly random that only 8 bits of exponent are needed for many calculations.</div><br/></div></div><div id="42261690" class="c"><input type="checkbox" id="c-42261690" checked=""/><div class="controls bullet"><span class="by">jonnycomputer</span><span>|</span><a href="#42261548">parent</a><span>|</span><a href="#42263093">prev</a><span>|</span><a href="#42263016">next</a><span>|</span><label class="collapse" for="c-42261690">[-]</label><label class="expand" for="c-42261690">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the clear explanation!</div><br/></div></div></div></div><div id="42263230" class="c"><input type="checkbox" id="c-42263230" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#42261548">prev</a><span>|</span><a href="#42262354">next</a><span>|</span><label class="collapse" for="c-42263230">[-]</label><label class="expand" for="c-42263230">[3 more]</label></div><br/><div class="children"><div class="content">&gt; For instance, NaN-tagging prevents (or largely complicates) optimizations relying on stack allocations. The stack uses high memory addresses that do not fit in 48 bits unless encoded relative to the location of the stack segment.<p>Er, what?  The paper says they tested on a Xeon CPU, so x86-64, running Linux.  On traditional x86-64, all pointers fit in 48 bits, period.  Stack memory is no exception.  More recently the architecture was extended to allow 56-bit pointers, but my impression is that Linux (like other OSes) keeps them disabled by default in userspace.  According to the documentation [1]:<p>&gt; Not all user space is ready to handle wide addresses. [..] To mitigate this, we are not going to allocate virtual address space above 47-bit by default.<p>So how would the stack end up above 47 bits?  Is the documentation out of date?<p>[1] <a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;arch&#x2F;x86&#x2F;x86_64&#x2F;5level-paging.html" rel="nofollow">https:&#x2F;&#x2F;docs.kernel.org&#x2F;arch&#x2F;x86&#x2F;x86_64&#x2F;5level-paging.html</a></div><br/><div id="42268783" class="c"><input type="checkbox" id="c-42268783" checked=""/><div class="controls bullet"><span class="by">4ad</span><span>|</span><a href="#42263230">parent</a><span>|</span><a href="#42267487">next</a><span>|</span><label class="collapse" for="c-42268783">[-]</label><label class="expand" for="c-42268783">[1 more]</label></div><br/><div class="children"><div class="content">The address space size limitations doesn&#x27;t mean that only the least significants bits are used, the memory hole is in the middle of the address space[1].<p>I don&#x27;t know what Linux does specifically (or under what configurations), but one some other operating systems the user space stack is in the higher half[2].<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86-64#Canonical_form_addresses" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86-64#Canonical_form_addresse...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;uts&#x2F;i86pc&#x2F;os&#x2F;startup.c#L408-L475">https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;...</a></div><br/></div></div><div id="42267487" class="c"><input type="checkbox" id="c-42267487" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#42263230">parent</a><span>|</span><a href="#42268783">prev</a><span>|</span><a href="#42262354">next</a><span>|</span><label class="collapse" for="c-42267487">[-]</label><label class="expand" for="c-42267487">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I think they’re just wrong about this.</div><br/></div></div></div></div><div id="42262354" class="c"><input type="checkbox" id="c-42262354" checked=""/><div class="controls bullet"><span class="by">plagiarist</span><span>|</span><a href="#42263230">prev</a><span>|</span><a href="#42267058">next</a><span>|</span><label class="collapse" for="c-42262354">[-]</label><label class="expand" for="c-42262354">[4 more]</label></div><br/><div class="children"><div class="content">The idea in the paper is really cool.<p>People who enjoyed this might also like to read how Apple used tagged pointers for short strings in Objective-C [0]. I think that&#x27;s when I first learned about tagged pointers. NaN-boxing was mindblowing for me. I love this kind of stuff.<p>[0] <a href="https:&#x2F;&#x2F;mikeash.com&#x2F;pyblog&#x2F;friday-qa-2015-07-31-tagged-pointer-strings.html" rel="nofollow">https:&#x2F;&#x2F;mikeash.com&#x2F;pyblog&#x2F;friday-qa-2015-07-31-tagged-point...</a></div><br/><div id="42262832" class="c"><input type="checkbox" id="c-42262832" checked=""/><div class="controls bullet"><span class="by">wging</span><span>|</span><a href="#42262354">parent</a><span>|</span><a href="#42267058">next</a><span>|</span><label class="collapse" for="c-42262832">[-]</label><label class="expand" for="c-42262832">[3 more]</label></div><br/><div class="children"><div class="content">Another cool thing that seems related: exploiting alignment to free up N bits in a &#x27;pointer&#x27; representation, because your values have to be aligned. The JVM does this to expand the set of possible addresses representable in 32 bits: <a href="https:&#x2F;&#x2F;shipilev.net&#x2F;jvm&#x2F;anatomy-quarks&#x2F;23-compressed-references&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shipilev.net&#x2F;jvm&#x2F;anatomy-quarks&#x2F;23-compressed-refere...</a><p>So, for example, with 3 bits of alignment required, the first valid address for a pointer to point to after 0x0 is 0x8, and after that is 0x10, but you represent those as 0x1 and 0x2 respectively, and use a shift to get back the actual address (0x1 &lt;&lt; 3 = 0x8, actual address). I think this is gestured at in section 1.1 of the paper, sort of, except they envision using the space thus freed for tags, rather than additional bits. (Which only makes sense if your address is 32 bits anyway, rather than 64 as in the paper: no one has 67-bit addresses. So saving 3 bits doesn&#x27;t buy you anything. I think.)<p>&gt; Aligning all heap-allocated values to 64-bit machine words conveniently frees the low bits of pointers to store a 3-bit tag.</div><br/><div id="42262934" class="c"><input type="checkbox" id="c-42262934" checked=""/><div class="controls bullet"><span class="by">plagiarist</span><span>|</span><a href="#42262354">root</a><span>|</span><a href="#42262832">parent</a><span>|</span><a href="#42267058">next</a><span>|</span><label class="collapse" for="c-42262934">[-]</label><label class="expand" for="c-42262934">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting which runtimes exploit the extra space for what reasons! Definitely makes more sense to have the extra address space on 32 bits compared to 64. I wonder if the extra addresses are specific to JVM &#x2F; not something that works well in the C family?</div><br/><div id="42263485" class="c"><input type="checkbox" id="c-42263485" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42262354">root</a><span>|</span><a href="#42262934">parent</a><span>|</span><a href="#42267058">next</a><span>|</span><label class="collapse" for="c-42263485">[-]</label><label class="expand" for="c-42263485">[1 more]</label></div><br/><div class="children"><div class="content">Well in C you have non-aligned pointers, because you can have pointers to things that aren&#x27;t objects and might not be aligned (e.g. individual chars or shorts). In Java everything is at least 8-byte-aligned, you can&#x27;t store a loose char&#x2F;short&#x2F;int on the heap (it has to go in a boxed object that&#x27;s 8-byte-aligned, though the compiler will do this semi-automatically) and you can&#x27;t take a pointer to an individual element of an array.<p>If you applied the C standard strictly, you could use a JVM-style representation for pointers to longs, pointers, and structs that start with longs and pointers, so you could theoretically have an implementation where those pointers were shorter. But you&#x27;d have to convert back and forth when casting to and from void* (and char*), and in practice C people expect to be able to cast a long* to int, cast that to void*, and get the same result as casting long* to void*, even though doing that and using it is undefined behaviour according to the standard.</div><br/></div></div></div></div></div></div></div></div><div id="42267058" class="c"><input type="checkbox" id="c-42267058" checked=""/><div class="controls bullet"><span class="by">funny_falcon</span><span>|</span><a href="#42262354">prev</a><span>|</span><label class="collapse" for="c-42267058">[-]</label><label class="expand" for="c-42267058">[5 more]</label></div><br/><div class="children"><div class="content">CRuby uses this technique on 64bit platforms for years.<p>Edit: the commit
<a href="https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;commit&#x2F;b3b5e626ad69bf22be3228f847f94e1b68f40888">https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;commit&#x2F;b3b5e626ad69bf22be3228f8...</a></div><br/><div id="42267267" class="c"><input type="checkbox" id="c-42267267" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#42267058">parent</a><span>|</span><label class="collapse" for="c-42267267">[-]</label><label class="expand" for="c-42267267">[4 more]</label></div><br/><div class="children"><div class="content">&gt; CRuby uses this technique on 64bit platforms for years.<p>What do you mean by &quot;this technique&quot;?<p>The paper says that CRuby uses tagged objects but could benefit from the innovation being discussed here, a specific bit pattern used to tag floats. See the following quote:<p>&gt; Therefore, implementations that represent floats as tagged pointers could benefit from it with minimal implementation effort. Such popular implementations include CPython [11], CRuby [32] and Google’s V8 [33].</div><br/><div id="42267838" class="c"><input type="checkbox" id="c-42267838" checked=""/><div class="controls bullet"><span class="by">funny_falcon</span><span>|</span><a href="#42267058">root</a><span>|</span><a href="#42267267">parent</a><span>|</span><a href="#42267628">next</a><span>|</span><label class="collapse" for="c-42267838">[-]</label><label class="expand" for="c-42267838">[2 more]</label></div><br/><div class="children"><div class="content">In fact, CRuby successfully combined “Self Tagging” with pointer tagging. Here&#x27;s the commit:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;commit&#x2F;b3b5e626ad69bf22be3228f847f94e1b68f40888">https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;commit&#x2F;b3b5e626ad69bf22be3228f8...</a></div><br/><div id="42269649" class="c"><input type="checkbox" id="c-42269649" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#42267058">root</a><span>|</span><a href="#42267838">parent</a><span>|</span><a href="#42267628">next</a><span>|</span><label class="collapse" for="c-42269649">[-]</label><label class="expand" for="c-42269649">[1 more]</label></div><br/><div class="children"><div class="content">Seems legit.<p>Linked commit contains code for rotating tagged floats so bits 60..62 go to the least significant positions, and a comment about a range of unboxed floats between 1.7...e-77 and 1.7...e77, plus special casing 0.0.</div><br/></div></div></div></div><div id="42267628" class="c"><input type="checkbox" id="c-42267628" checked=""/><div class="controls bullet"><span class="by">funny_falcon</span><span>|</span><a href="#42267058">root</a><span>|</span><a href="#42267267">parent</a><span>|</span><a href="#42267838">prev</a><span>|</span><label class="collapse" for="c-42267628">[-]</label><label class="expand" for="c-42267628">[1 more]</label></div><br/><div class="children"><div class="content">I mean, CRuby does “Float Self Tagging” for years. Paper just has the mistake about CRuby.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>