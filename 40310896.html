<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715331711272" as="style"/><link rel="stylesheet" href="styles.css?v=1715331711272"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://brooker.co.za/blog/2024/05/09/nagle.html">It&#x27;s always TCP_NODELAY</a> <span class="domain">(<a href="https://brooker.co.za">brooker.co.za</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>207 comments</span></div><br/><div><div id="40312343" class="c"><input type="checkbox" id="c-40312343" checked=""/><div class="controls bullet"><span class="by">ironman1478</span><span>|</span><a href="#40316445">next</a><span>|</span><label class="collapse" for="c-40312343">[-]</label><label class="expand" for="c-40312343">[29 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve fixed multiple latency issues due to nagle&#x27;s multiple times in my career. It&#x27;s the first thing I jump to. I feel like the logic behind it is sound, but it just doesn&#x27;t work for some workloads. It should be something that an engineer needs to be forced to set while creating a socket, instead of letting the OS choose a default. I think that&#x27;s the main issue. Not that it&#x27;s a good &#x2F; bad option but that there is a setting that people might not know about that manipulates how data is sent over the wire so aggressively.</div><br/><div id="40314121" class="c"><input type="checkbox" id="c-40314121" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#40312343">parent</a><span>|</span><a href="#40313415">next</a><span>|</span><label class="collapse" for="c-40314121">[-]</label><label class="expand" for="c-40314121">[11 more]</label></div><br/><div class="children"><div class="content">Same here. I have a hobby that on any RPC framework I encounter, I file a Github issue &quot;did you think of TCP_NODELAY or can this framework do only 20 calls per second?&quot;.<p>So far, it&#x27;s found a bug every single time.<p>Some examples: <a href="https:&#x2F;&#x2F;cloud-haskell.atlassian.net&#x2F;browse&#x2F;DP-108" rel="nofollow">https:&#x2F;&#x2F;cloud-haskell.atlassian.net&#x2F;browse&#x2F;DP-108</a> or <a href="https:&#x2F;&#x2F;github.com&#x2F;agentm&#x2F;curryer&#x2F;issues&#x2F;3">https:&#x2F;&#x2F;github.com&#x2F;agentm&#x2F;curryer&#x2F;issues&#x2F;3</a><p>I disagree on the &quot;not a good &#x2F; bad option&quot; though.<p>It&#x27;s a kernel-side heuristic for &quot;magically fixing&quot; badly behaved applications.<p>As the article states, no sensible application does 1-byte network write() syscalls. Software that does that should be fixed.<p>It makes sense only in the case when you are the kernel sysadmin and somehow cannot fix the software that runs on the machine, maybe for team-political reasons. I claim that&#x27;s pretty rare.<p>For all other cases, it makes sane software extra complicated: You need to explicitly opt-out of odd magic that makes poorly-written software have slightly more throughput, and that makes correctly-written software have huge, surprising latency.<p>John Nagle says here and in linked threads that Delayed Acks are even worse. I agree. But the Send&#x2F;Send&#x2F;Receive receive pattern that Nagle&#x27;s Algorithm degrades is a totally valid and common use case, including anything that does pipelined RPC over TCP.<p>Both Delayed Acks and Nagle&#x27;s Algorithm should be opt-in, in my opinion. It should be called TCP_DELAY, which you can opt-into if you can&#x27;t be asked to implement basic userspace buffering.<p>People shouldn&#x27;t &#x2F;need&#x2F; to know about these. Make the default case be the unsurprising one.</div><br/><div id="40315529" class="c"><input type="checkbox" id="c-40315529" checked=""/><div class="controls bullet"><span class="by">pzs</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314121">parent</a><span>|</span><a href="#40314784">next</a><span>|</span><label class="collapse" for="c-40315529">[-]</label><label class="expand" for="c-40315529">[4 more]</label></div><br/><div class="children"><div class="content">&quot;As the article states, no sensible application does 1-byte network write() syscalls.&quot; - the problem that this flag was meant to solve was that when a user was typing at a remote terminal, which used to be a pretty common use case in the 80&#x27;s (think telnet), there was one byte available to send at a time over a network with a bandwidth (and latency) severely limited compared to today&#x27;s networks. The user was happy to see that the typed character arrived to the other side. This problem is no longer significant, and the world has changed so that this flag has become a common issue in many current use cases.<p>Was terminal software poorly written? I don&#x27;t feel comfortable to make such judgement. It was designed for a constrained environment with different priorities.<p>Anyway, I agree with the rest of your comment.</div><br/><div id="40315606" class="c"><input type="checkbox" id="c-40315606" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40315529">parent</a><span>|</span><a href="#40314784">next</a><span>|</span><label class="collapse" for="c-40315606">[-]</label><label class="expand" for="c-40315606">[3 more]</label></div><br/><div class="children"><div class="content">&gt; when a user was typing at a remote terminal, which used to be a pretty common use case in the 80&#x27;s<p>Still is for some. I’m probably working in a terminal on an ssh connection to a remote system for 80% of my work day.</div><br/><div id="40315651" class="c"><input type="checkbox" id="c-40315651" checked=""/><div class="controls bullet"><span class="by">dgoldstein0</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40315606">parent</a><span>|</span><a href="#40315889">next</a><span>|</span><label class="collapse" for="c-40315651">[-]</label><label class="expand" for="c-40315651">[1 more]</label></div><br/><div class="children"><div class="content">sure, but we do so with much better networks than in the 80s.  The extra overhead is not going to matter when even a bad network nowadays is measured in megabits per second per user.  The 80s had no such luxury.</div><br/></div></div><div id="40315889" class="c"><input type="checkbox" id="c-40315889" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40315606">parent</a><span>|</span><a href="#40315651">prev</a><span>|</span><a href="#40314784">next</a><span>|</span><label class="collapse" for="c-40315889">[-]</label><label class="expand" for="c-40315889">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re working on a distributed system, most of the traffic is not going to be your SSH session though.</div><br/></div></div></div></div></div></div><div id="40314784" class="c"><input type="checkbox" id="c-40314784" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314121">parent</a><span>|</span><a href="#40315529">prev</a><span>|</span><a href="#40314540">next</a><span>|</span><label class="collapse" for="c-40314784">[-]</label><label class="expand" for="c-40314784">[2 more]</label></div><br/><div class="children"><div class="content">&gt; As the article states, no sensible application does 1-byte network write() syscalls. Software that does that should be fixed.<p>Yes! And worse, those that <i>do</i> are not gonna be “fixed” by delays either. In this day and age with fast internets, a syscall per byte will bottleneck the CPU way before it’ll saturate the network path. The cpu limit when I’ve been tuning buffers have been somewhere in the 4k-32k range for 10Gbps ish.<p>&gt; Both Delayed Acks and Nagle&#x27;s Algorithm should be opt-in, in my opinion.<p>Agreed, it causes more problems than it solves and is very outdated. Now, the challenge is rolling out such a change as smoothly as possible, which requires coordination and a lot of trivia knowledge of legacy systems. Migrations are never trivial.</div><br/><div id="40315441" class="c"><input type="checkbox" id="c-40315441" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314784">parent</a><span>|</span><a href="#40314540">next</a><span>|</span><label class="collapse" for="c-40315441">[-]</label><label class="expand" for="c-40315441">[1 more]</label></div><br/><div class="children"><div class="content">I doubt the libc default in established systems can change now, but newer languages and libraries can learn the lesson and do the right thing. For instance, Go sets TCP_NODELAY by default: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34181846">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34181846</a></div><br/></div></div></div></div><div id="40314540" class="c"><input type="checkbox" id="c-40314540" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314121">parent</a><span>|</span><a href="#40314784">prev</a><span>|</span><a href="#40316036">next</a><span>|</span><label class="collapse" for="c-40314540">[-]</label><label class="expand" for="c-40314540">[1 more]</label></div><br/><div class="children"><div class="content">The problem with making it opt in is that the point of the protocol was to fix apps that, while they perform fine for the developer on his LAN, would be hell on internet routers.  So the people who benefit are the ones who don&#x27;t know what they are doing and only use the defaults.</div><br/></div></div><div id="40316036" class="c"><input type="checkbox" id="c-40316036" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314121">parent</a><span>|</span><a href="#40314540">prev</a><span>|</span><a href="#40314406">next</a><span>|</span><label class="collapse" for="c-40316036">[-]</label><label class="expand" for="c-40316036">[1 more]</label></div><br/><div class="children"><div class="content">Would one not also get clobbered by all the sys calls for doing many small packets? It feels like coalescing in userspace is a much better strategy all round if that&#x27;s desired, but I&#x27;m not super experienced.</div><br/></div></div><div id="40314406" class="c"><input type="checkbox" id="c-40314406" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314121">parent</a><span>|</span><a href="#40316036">prev</a><span>|</span><a href="#40314222">next</a><span>|</span><label class="collapse" for="c-40314406">[-]</label><label class="expand" for="c-40314406">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the reminder to set this on the new framework I’m working on. :)</div><br/></div></div><div id="40314222" class="c"><input type="checkbox" id="c-40314222" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314121">parent</a><span>|</span><a href="#40314406">prev</a><span>|</span><a href="#40313415">next</a><span>|</span><label class="collapse" for="c-40314222">[-]</label><label class="expand" for="c-40314222">[1 more]</label></div><br/><div class="children"><div class="content">Oh hey! It’s been a while how’re you?!</div><br/></div></div></div></div><div id="40313415" class="c"><input type="checkbox" id="c-40313415" checked=""/><div class="controls bullet"><span class="by">Sebb767</span><span>|</span><a href="#40312343">parent</a><span>|</span><a href="#40314121">prev</a><span>|</span><a href="#40312559">next</a><span>|</span><label class="collapse" for="c-40313415">[-]</label><label class="expand" for="c-40313415">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It should be something that an engineer needs to be forced to set while creating a socket, instead of letting the OS choose a default.<p>If the intention is mostly to fix applications with bad `write`-behavior, this would make setting TCP_DELAY a pretty exotic option - you would need a software engineer to be both smart enough to know to set this option, but not smart enough to distribute their write-calls well and&#x2F;or not go for writing their own (probably better fitted) application-specific version of Nagles.</div><br/></div></div><div id="40312559" class="c"><input type="checkbox" id="c-40312559" checked=""/><div class="controls bullet"><span class="by">Bluecobra</span><span>|</span><a href="#40312343">parent</a><span>|</span><a href="#40313415">prev</a><span>|</span><a href="#40312489">next</a><span>|</span><label class="collapse" for="c-40312559">[-]</label><label class="expand" for="c-40312559">[5 more]</label></div><br/><div class="children"><div class="content">I agree, it has been fairly well known to disable Nagle&#x27;s Algorithm in HFT&#x2F;low latency trading circles for quite some time now (like &gt; 15 years).  It&#x27;s one of the first things I look for.</div><br/><div id="40312752" class="c"><input type="checkbox" id="c-40312752" checked=""/><div class="controls bullet"><span class="by">Scubabear68</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40312559">parent</a><span>|</span><a href="#40315231">next</a><span>|</span><label class="collapse" for="c-40312752">[-]</label><label class="expand" for="c-40312752">[2 more]</label></div><br/><div class="children"><div class="content">I was setting TCP_NODELAY at Bear Stearns for custom networking code circa 1994 or so.</div><br/><div id="40315428" class="c"><input type="checkbox" id="c-40315428" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40312752">parent</a><span>|</span><a href="#40315231">next</a><span>|</span><label class="collapse" for="c-40315428">[-]</label><label class="expand" for="c-40315428">[1 more]</label></div><br/><div class="children"><div class="content">This is why I love this place</div><br/></div></div></div></div><div id="40315231" class="c"><input type="checkbox" id="c-40315231" checked=""/><div class="controls bullet"><span class="by">Reason077</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40312559">parent</a><span>|</span><a href="#40312752">prev</a><span>|</span><a href="#40313024">next</a><span>|</span><label class="collapse" for="c-40315231">[-]</label><label class="expand" for="c-40315231">[1 more]</label></div><br/><div class="children"><div class="content">Surely serious HFT systems bypass TCP altogether now days. In that world, every millisecond of latency can potentially cost a lot of money.<p>These are the guys that use microwave links to connect to exchanges because fibre-optics have too much latency.</div><br/></div></div><div id="40313024" class="c"><input type="checkbox" id="c-40313024" checked=""/><div class="controls bullet"><span class="by">mcoliver</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40312559">parent</a><span>|</span><a href="#40315231">prev</a><span>|</span><a href="#40312489">next</a><span>|</span><label class="collapse" for="c-40313024">[-]</label><label class="expand" for="c-40313024">[1 more]</label></div><br/><div class="children"><div class="content">Same in M&amp;E &#x2F; vfx</div><br/></div></div></div></div><div id="40312489" class="c"><input type="checkbox" id="c-40312489" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#40312343">parent</a><span>|</span><a href="#40312559">prev</a><span>|</span><a href="#40313010">next</a><span>|</span><label class="collapse" for="c-40312489">[-]</label><label class="expand" for="c-40312489">[5 more]</label></div><br/><div class="children"><div class="content">What you really want is for the delay to be n microseconds, but there’s no good way to do that except putting your own user space buffering in front of the system calls (user space works better, unless you have something like io_uring amortizing system call times)</div><br/><div id="40314937" class="c"><input type="checkbox" id="c-40314937" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40312489">parent</a><span>|</span><a href="#40314216">next</a><span>|</span><label class="collapse" for="c-40314937">[-]</label><label class="expand" for="c-40314937">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;d probably be amazing how many poorly coded games would work better if something like...<p>TCP_60FPSBUFFER<p>Would wait for ~16mS after the first packet is queued and batch the data stream up.</div><br/><div id="40315292" class="c"><input type="checkbox" id="c-40315292" checked=""/><div class="controls bullet"><span class="by">dishsoap</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314937">parent</a><span>|</span><a href="#40316245">next</a><span>|</span><label class="collapse" for="c-40315292">[-]</label><label class="expand" for="c-40315292">[1 more]</label></div><br/><div class="children"><div class="content">Most games use UDP.</div><br/></div></div><div id="40316245" class="c"><input type="checkbox" id="c-40316245" checked=""/><div class="controls bullet"><span class="by">Chaosvex</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40314937">parent</a><span>|</span><a href="#40315292">prev</a><span>|</span><a href="#40314216">next</a><span>|</span><label class="collapse" for="c-40316245">[-]</label><label class="expand" for="c-40316245">[1 more]</label></div><br/><div class="children"><div class="content">Adding delay to multiplayer games? That&#x27;s worse.</div><br/></div></div></div></div><div id="40314216" class="c"><input type="checkbox" id="c-40314216" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40312489">parent</a><span>|</span><a href="#40314937">prev</a><span>|</span><a href="#40313010">next</a><span>|</span><label class="collapse" for="c-40314216">[-]</label><label class="expand" for="c-40314216">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d rather have portable TCP_CORK</div><br/></div></div></div></div><div id="40313010" class="c"><input type="checkbox" id="c-40313010" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40312343">parent</a><span>|</span><a href="#40312489">prev</a><span>|</span><a href="#40314997">next</a><span>|</span><label class="collapse" for="c-40313010">[-]</label><label class="expand" for="c-40313010">[2 more]</label></div><br/><div class="children"><div class="content">The logic is really for things like Telnet sessions. IIRC that was the whole motivation.</div><br/><div id="40314210" class="c"><input type="checkbox" id="c-40314210" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40313010">parent</a><span>|</span><a href="#40314997">next</a><span>|</span><label class="collapse" for="c-40314210">[-]</label><label class="expand" for="c-40314210">[1 more]</label></div><br/><div class="children"><div class="content">And for block writes!<p>The Nagler turns a series of 4KB pages over TCP into a stream of MTU sized packets, rather than a short packet aligned to the end of each page.</div><br/></div></div></div></div><div id="40314997" class="c"><input type="checkbox" id="c-40314997" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#40312343">parent</a><span>|</span><a href="#40313010">prev</a><span>|</span><a href="#40314628">next</a><span>|</span><label class="collapse" for="c-40314997">[-]</label><label class="expand" for="c-40314997">[1 more]</label></div><br/><div class="children"><div class="content">Same here.  My first job out of college was at a database company.  Queries at the client side of the client-server based database were slow.  It was thought the database server was slow as hardware back then was pretty pathetic.  I traced it down to the network driver and found out the default setting of TCP_NODELAY was off.  I looked like a hero when turning on that option and the db benchmarks jumped up.</div><br/></div></div><div id="40314628" class="c"><input type="checkbox" id="c-40314628" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40312343">parent</a><span>|</span><a href="#40314997">prev</a><span>|</span><a href="#40313306">next</a><span>|</span><label class="collapse" for="c-40314628">[-]</label><label class="expand" for="c-40314628">[1 more]</label></div><br/><div class="children"><div class="content">With some vendors you have to solve it like a policy problem, via a LD_PRELOAD shim.</div><br/></div></div><div id="40313306" class="c"><input type="checkbox" id="c-40313306" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#40312343">parent</a><span>|</span><a href="#40314628">prev</a><span>|</span><a href="#40316445">next</a><span>|</span><label class="collapse" for="c-40313306">[-]</label><label class="expand" for="c-40313306">[2 more]</label></div><br/><div class="children"><div class="content">You’re right re: making delay explicit, but also crappy use the space networking tools don’t show whether no_delay is enabled on sockets.<p>Last time I had to do some Linux stuff, maybe 10 years ago you had to write a systemtap program. I guess it’s EBNF now. But I bet the userspace tools still suck.</div><br/><div id="40314786" class="c"><input type="checkbox" id="c-40314786" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#40312343">root</a><span>|</span><a href="#40313306">parent</a><span>|</span><a href="#40316445">next</a><span>|</span><label class="collapse" for="c-40314786">[-]</label><label class="expand" for="c-40314786">[1 more]</label></div><br/><div class="children"><div class="content">&gt; use the space<p>Userspace. Sorry, was using voice dictation.</div><br/></div></div></div></div></div></div><div id="40316445" class="c"><input type="checkbox" id="c-40316445" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#40312343">prev</a><span>|</span><a href="#40314017">next</a><span>|</span><label class="collapse" for="c-40316445">[-]</label><label class="expand" for="c-40316445">[1 more]</label></div><br/><div class="children"><div class="content">~15 years ago I played an MMO that was very real-time, and yet all of the communication was TCP. Literally you&#x27;d click a button, and you would not even see your action play out until a response packet came back.<p>All of the kids playing this game (me included) eventually figured out you could turn on TCP_NODELAY to make the game buttery smooth - especially for those in California close to the game servers.</div><br/></div></div><div id="40314017" class="c"><input type="checkbox" id="c-40314017" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#40316445">prev</a><span>|</span><a href="#40312569">next</a><span>|</span><label class="collapse" for="c-40314017">[-]</label><label class="expand" for="c-40314017">[2 more]</label></div><br/><div class="children"><div class="content">The takeaway is odd. Clearly Nagle&#x27;s Algorithm was an attempt at batched writes. It doesn&#x27;t matter what your hardware or network or application or use-case or anything is; in some cases, batched writes are better.<p>Lots of computing today uses batched writes. Network applications benefit from it too. Newer higher-level protocols like QUIC do batching of writes, effectively moving all of TCP&#x27;s independent connection and error handling into userspace, so the protocol can move as much data into the application as fast as it can, and let the application (rather than a host tcp&#x2F;ip stack, router, etc) worry about the connection and error handling of individual streams.<p>Once our networks become saturated the way they were in the old days, Nagle&#x27;s algorithm will return in the form of a QUIC modification, probably deeper in the application code, to wait to send a QUIC packet until some criteria is reached. Everything in technology is re-invented once either hardware or software reaches a bottleneck (and they always will as their capabilities don&#x27;t grow at the same rate).<p>(the other case besides bandwidth where Nagle&#x27;s algorithm is useful is if you&#x27;re saturating Packets Per Second (PPS) from tiny packets)</div><br/><div id="40315211" class="c"><input type="checkbox" id="c-40315211" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40314017">parent</a><span>|</span><a href="#40312569">next</a><span>|</span><label class="collapse" for="c-40315211">[-]</label><label class="expand" for="c-40315211">[1 more]</label></div><br/><div class="children"><div class="content">Yes but it seems this particular implementation is using a heuristic for how to batch that made some assumptions that didn&#x27;t pan out.</div><br/></div></div></div></div><div id="40312569" class="c"><input type="checkbox" id="c-40312569" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#40314017">prev</a><span>|</span><a href="#40311952">next</a><span>|</span><label class="collapse" for="c-40312569">[-]</label><label class="expand" for="c-40312569">[6 more]</label></div><br/><div class="children"><div class="content">What about the opposite, disable delayed acks.<p>The problem is the pathological behavior when tinygram prevention interacts with delayed acks. There is an exposed option to turn off tinygram prevention(TCP_NODELAY), how would you tun off delayed acks instead? Say if you wanted to benchmark all four combinations and see what works best.<p>doing a little research I found:<p>linux has the TCP_QUICKACK socket option but you have to set it every time you receive.
there is also &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_delack_min and &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_ato_min<p>freebsd has net.inet.tcp.delayed_ack
and net.inet.tcp.delacktime</div><br/><div id="40316176" class="c"><input type="checkbox" id="c-40316176" checked=""/><div class="controls bullet"><span class="by">Culonavirus</span><span>|</span><a href="#40312569">parent</a><span>|</span><a href="#40313027">next</a><span>|</span><label class="collapse" for="c-40316176">[-]</label><label class="expand" for="c-40316176">[1 more]</label></div><br/><div class="children"><div class="content">Apparently you have time to &quot;do a little research&quot; but not to read the entire article you&#x27;re reacting to? It specifically mentions TCP_QUICKACK.</div><br/></div></div><div id="40313027" class="c"><input type="checkbox" id="c-40313027" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#40312569">parent</a><span>|</span><a href="#40316176">prev</a><span>|</span><a href="#40312712">next</a><span>|</span><label class="collapse" for="c-40313027">[-]</label><label class="expand" for="c-40313027">[1 more]</label></div><br/><div class="children"><div class="content">TCP_QUICKACK does fix the worst version of the problem, but doesn&#x27;t fix the entire problem. Nagles algorithm will still wait for up to one round-trip time before sending data (at least as specified in the RFC), which is extra latency with nearly no added value.</div><br/></div></div><div id="40312712" class="c"><input type="checkbox" id="c-40312712" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40312569">parent</a><span>|</span><a href="#40313027">prev</a><span>|</span><a href="#40312844">next</a><span>|</span><label class="collapse" for="c-40312712">[-]</label><label class="expand" for="c-40312712">[1 more]</label></div><br/><div class="children"><div class="content">&gt; linux has the TCP_QUICKACK socket option but you have to set it every time you receive<p>Right. What were they thinking? Why would you want it off only some of the time?</div><br/></div></div><div id="40312844" class="c"><input type="checkbox" id="c-40312844" checked=""/><div class="controls bullet"><span class="by">batmanthehorse</span><span>|</span><a href="#40312569">parent</a><span>|</span><a href="#40312712">prev</a><span>|</span><a href="#40311952">next</a><span>|</span><label class="collapse" for="c-40312844">[-]</label><label class="expand" for="c-40312844">[2 more]</label></div><br/><div class="children"><div class="content">In CentOS&#x2F;RedHat you can add `quickack 1` to the end of a route to tell it to disable delayed acks for that route.</div><br/><div id="40314667" class="c"><input type="checkbox" id="c-40314667" checked=""/><div class="controls bullet"><span class="by">rbjorklin</span><span>|</span><a href="#40312569">root</a><span>|</span><a href="#40312844">parent</a><span>|</span><a href="#40311952">next</a><span>|</span><label class="collapse" for="c-40314667">[-]</label><label class="expand" for="c-40314667">[1 more]</label></div><br/><div class="children"><div class="content">And with systemd &gt;= 253 you can set it as part of the network config to have it be applied automatically.
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;issues&#x2F;25906">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;issues&#x2F;25906</a></div><br/></div></div></div></div></div></div><div id="40311952" class="c"><input type="checkbox" id="c-40311952" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#40312569">prev</a><span>|</span><a href="#40311226">next</a><span>|</span><label class="collapse" for="c-40311952">[-]</label><label class="expand" for="c-40311952">[34 more]</label></div><br/><div class="children"><div class="content">In a world where bandwidth was limited, and the packet size minimum was 64 bytes plus an inter-frame gap (it still is for most Ethernet networks), sending a TCP packet for literally every byte wasted a huge amount of bandwidth.  The same goes for sending empty acks.<p>On the other hand, my general position is: it&#x27;s not TCP_NODELAY, it&#x27;s TCP.</div><br/><div id="40312012" class="c"><input type="checkbox" id="c-40312012" checked=""/><div class="controls bullet"><span class="by">metadaemon</span><span>|</span><a href="#40311952">parent</a><span>|</span><a href="#40313196">next</a><span>|</span><label class="collapse" for="c-40312012">[-]</label><label class="expand" for="c-40312012">[26 more]</label></div><br/><div class="children"><div class="content">I&#x27;d just love a protocol that has a built in mechanism for realizing the other side of the pipe disconnected for any reason.</div><br/><div id="40312287" class="c"><input type="checkbox" id="c-40312287" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312012">parent</a><span>|</span><a href="#40313634">next</a><span>|</span><label class="collapse" for="c-40312287">[-]</label><label class="expand" for="c-40312287">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s possible in circuit switched networking with various types of supervision, but packet switched networking has taken over because it&#x27;s much less expensive to implement.<p>Attempts to add connection monitoring usually make things worse --- if you need to reroute a cable, and one or both ends of the cable will detect a cable disconnection and close user sockets, that&#x27;s not great, now you do a quick change with a small period of data loss but otherwise minor interruption; all of the established connections will be dropped.</div><br/></div></div><div id="40313634" class="c"><input type="checkbox" id="c-40313634" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312012">parent</a><span>|</span><a href="#40312287">prev</a><span>|</span><a href="#40313706">next</a><span>|</span><label class="collapse" for="c-40313634">[-]</label><label class="expand" for="c-40313634">[6 more]</label></div><br/><div class="children"><div class="content">To re-word everyone else&#x27;s comments - &quot;Disconnected&quot; is not well-defined in any network.</div><br/><div id="40314275" class="c"><input type="checkbox" id="c-40314275" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40313634">parent</a><span>|</span><a href="#40313706">next</a><span>|</span><label class="collapse" for="c-40314275">[-]</label><label class="expand" for="c-40314275">[5 more]</label></div><br/><div class="children"><div class="content">&gt; To re-word everyone else&#x27;s comments - &quot;Disconnected&quot; is not well-defined in any network.<p>Parent said disconnected pipe, not network. It&#x27;s sufficiently well-definable there.</div><br/><div id="40315242" class="c"><input type="checkbox" id="c-40315242" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40314275">parent</a><span>|</span><a href="#40313706">next</a><span>|</span><label class="collapse" for="c-40315242">[-]</label><label class="expand" for="c-40315242">[4 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a distinction without a difference in this case. You can&#x27;t know if the reason your water stopped is because the water is shut off, the pipe broke, or it&#x27;s just slow.<p>When all you have to go on is &quot;I stopped getting packets&quot; the best you can do is give up after a bit. TCP keepsalives do kinda suck and are full of interesting choices that don&#x27;t seem to have passed the test of time. But they are there and if you control both sides of the connection you can be sure they work.</div><br/><div id="40315301" class="c"><input type="checkbox" id="c-40315301" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40315242">parent</a><span>|</span><a href="#40313706">next</a><span>|</span><label class="collapse" for="c-40315301">[-]</label><label class="expand" for="c-40315301">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a crucial difference in fact, which is that the peer you&#x27;re defining connectedness to is a single well-defined peer that is directly connected to you, which &quot;The Network&quot; is not.<p>As for the analogy, uh, this ain&#x27;t water. Monitor the line voltage or the fiber brightness or something, it&#x27;ll tell you very quickly if the other endpoint is disconnected. It&#x27;s up to the physical layer to provide a mechanism to detect disconnection, but it&#x27;s not somehow impossible or rocket science...</div><br/><div id="40315602" class="c"><input type="checkbox" id="c-40315602" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40315301">parent</a><span>|</span><a href="#40313706">next</a><span>|</span><label class="collapse" for="c-40315602">[-]</label><label class="expand" for="c-40315602">[2 more]</label></div><br/><div class="children"><div class="content">Well, isn&#x27;t that already how it works? If I physically unplug my ethernet cable, won&#x27;t TCP-related syscalls start failing immediately?</div><br/><div id="40315673" class="c"><input type="checkbox" id="c-40315673" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40315602">parent</a><span>|</span><a href="#40313706">next</a><span>|</span><label class="collapse" for="c-40315673">[-]</label><label class="expand" for="c-40315673">[1 more]</label></div><br/><div class="children"><div class="content">Probably, but I don&#x27;t know how the physical layers work underneath. But regardless, it&#x27;s trivial to just monitor <i>something</i> constantly to ensure the connection is still there, you just need the hardware and protocol support.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40313706" class="c"><input type="checkbox" id="c-40313706" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312012">parent</a><span>|</span><a href="#40313634">prev</a><span>|</span><a href="#40313625">next</a><span>|</span><label class="collapse" for="c-40313706">[-]</label><label class="expand" for="c-40313706">[1 more]</label></div><br/><div class="children"><div class="content">These types of keepalives are usually best handled at the application protocol layer where you can design in more knobs and respond in different ways. Otherwise you may see unexpected interactions between different keepalive mechanisms in different parts of the protocol stack.</div><br/></div></div><div id="40313625" class="c"><input type="checkbox" id="c-40313625" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312012">parent</a><span>|</span><a href="#40313706">prev</a><span>|</span><a href="#40312067">next</a><span>|</span><label class="collapse" for="c-40313625">[-]</label><label class="expand" for="c-40313625">[1 more]</label></div><br/><div class="children"><div class="content">Several of the &quot;reliable UDP&quot; protocols I have worked on in the past have had a heartbeat mechanism that is specifically for detecting this.  If you haven&#x27;t sent a packet down the wire in 10-100 milliseconds, you will send an extra packet just to say you&#x27;re still there.<p>It&#x27;s very useful to do this in intra-datacenter protocols.</div><br/></div></div><div id="40312067" class="c"><input type="checkbox" id="c-40312067" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312012">parent</a><span>|</span><a href="#40313625">prev</a><span>|</span><a href="#40312143">next</a><span>|</span><label class="collapse" for="c-40312067">[-]</label><label class="expand" for="c-40312067">[10 more]</label></div><br/><div class="children"><div class="content">Like TCP keepalives?</div><br/><div id="40312554" class="c"><input type="checkbox" id="c-40312554" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312067">parent</a><span>|</span><a href="#40312143">next</a><span>|</span><label class="collapse" for="c-40312554">[-]</label><label class="expand" for="c-40312554">[9 more]</label></div><br/><div class="children"><div class="content">If the feature already technically exists in TCP, it&#x27;s either broken or disabled by default, which is pretty much the same as not having it.</div><br/><div id="40315626" class="c"><input type="checkbox" id="c-40315626" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312554">parent</a><span>|</span><a href="#40312776">next</a><span>|</span><label class="collapse" for="c-40315626">[-]</label><label class="expand" for="c-40315626">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re conflating all optional TCP features of all operating systems, network devices, and RFCs together. This lack of nuance fails to appreciate that different applications have different needs for how they use TCP: ( server | client ) x ( one way | chatty bidirectional | idle tinygram | mixed ). If a feature needs to be used on a particular connection, then use it. ;)</div><br/></div></div><div id="40312776" class="c"><input type="checkbox" id="c-40312776" checked=""/><div class="controls bullet"><span class="by">voxic11</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312554">parent</a><span>|</span><a href="#40315626">prev</a><span>|</span><a href="#40312143">next</a><span>|</span><label class="collapse" for="c-40312776">[-]</label><label class="expand" for="c-40312776">[7 more]</label></div><br/><div class="children"><div class="content">keepalives are an optional TCP feature so they are not necessarily supported by all TCP implementations and therefor default to off even when supported.</div><br/><div id="40313968" class="c"><input type="checkbox" id="c-40313968" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312776">parent</a><span>|</span><a href="#40316202">next</a><span>|</span><label class="collapse" for="c-40313968">[-]</label><label class="expand" for="c-40313968">[3 more]</label></div><br/><div class="children"><div class="content">Where is it off? Most linux distros have it on it’s just the default kickoff timer is ridiculously long (like 2 hours iirc). Besides, TCP keepalives won&#x27;t help with the issue at hand and were put in for totally different purpose (gc&#x27;ing idle connections). Most of the time you don&#x27;t even need them because the other side will send RST packet if it already closed the socket.</div><br/><div id="40314566" class="c"><input type="checkbox" id="c-40314566" checked=""/><div class="controls bullet"><span class="by">halter73</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40313968">parent</a><span>|</span><a href="#40316202">next</a><span>|</span><label class="collapse" for="c-40314566">[-]</label><label class="expand" for="c-40314566">[2 more]</label></div><br/><div class="children"><div class="content">AFAIK, all Linux distros plus Windows and macOS have TCP keepalives off by default as mandated by the RFC 1122. Even when they are optionally turned on using SO_KEEPALIVE, the interval defaults to two hours because that is the minimum default interval allowed by spec. That can then be optionally reduced with something like &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_time (system wide) or TCP_KEEPIDLE (per socket).<p>By default, completely idle TCP connections will stay alive indefinitely from the perspective of both peers even if their physical connection is severed.<p><pre><code>            Implementors MAY include &quot;keep-alives&quot; in their TCP
            implementations, although this practice is not universally
            accepted.  If keep-alives are included, the application MUST
            be able to turn them on or off for each TCP connection, and
            they MUST default to off.

            Keep-alive packets MUST only be sent when no data or
            acknowledgement packets have been received for the
            connection within an interval.  This interval MUST be
            configurable and MUST default to no less than two hours.
</code></pre>
[0]: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc1122#page-101" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc1122#page-101</a></div><br/><div id="40314638" class="c"><input type="checkbox" id="c-40314638" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40314566">parent</a><span>|</span><a href="#40316202">next</a><span>|</span><label class="collapse" for="c-40314638">[-]</label><label class="expand" for="c-40314638">[1 more]</label></div><br/><div class="children"><div class="content">OK you&#x27;re right - it&#x27;s coming back to me now. I&#x27;ve been spoiled by software that enables keep-alive on sockets.</div><br/></div></div></div></div></div></div><div id="40316202" class="c"><input type="checkbox" id="c-40316202" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312776">parent</a><span>|</span><a href="#40313968">prev</a><span>|</span><a href="#40312143">next</a><span>|</span><label class="collapse" for="c-40316202">[-]</label><label class="expand" for="c-40316202">[3 more]</label></div><br/><div class="children"><div class="content">So we need a protocol with some kind of non-optional default-enabled keepalive.</div><br/><div id="40316334" class="c"><input type="checkbox" id="c-40316334" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40316202">parent</a><span>|</span><a href="#40312143">next</a><span>|</span><label class="collapse" for="c-40316334">[-]</label><label class="expand" for="c-40316334">[2 more]</label></div><br/><div class="children"><div class="content">Now your connections start to randomly fail in production because the implementation defaults to 20ms and your local tests never caught that.</div><br/><div id="40316723" class="c"><input type="checkbox" id="c-40316723" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40316334">parent</a><span>|</span><a href="#40312143">next</a><span>|</span><label class="collapse" for="c-40316723">[-]</label><label class="expand" for="c-40316723">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure there&#x27;s some middle ground between &quot;never time out&quot; and &quot;time out after 20ms&quot; that works reasonably well for most use cases</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40312143" class="c"><input type="checkbox" id="c-40312143" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312012">parent</a><span>|</span><a href="#40312067">prev</a><span>|</span><a href="#40312416">next</a><span>|</span><label class="collapse" for="c-40312143">[-]</label><label class="expand" for="c-40312143">[3 more]</label></div><br/><div class="children"><div class="content">If a socket is closed properly there&#x27;ll be a FIN and the other side can learn about it by polling the socket.<p>If the network connection is lost due to external circumstances (say your modem crashes) then how would that information propagate from the point of failure to the remote end <i>on an idle connection</i>? Either you actively probe (keepalives) and risk false positives or you wait until you hear again from the other side, risking false negatives.</div><br/><div id="40314327" class="c"><input type="checkbox" id="c-40314327" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312143">parent</a><span>|</span><a href="#40312448">next</a><span>|</span><label class="collapse" for="c-40314327">[-]</label><label class="expand" for="c-40314327">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If the network connection is lost due to external circumstances (say your modem crashes) then how would that information propagate from the point of failure to the remote end <i>on an idle connection</i>?<p>Observe the line voltage? If it gets cut then you have a problem...<p>&gt; Either you actively probe (keepalives) and risk false positives<p>What false positives? Are you thinking there&#x27;s an adversary on the other side?</div><br/></div></div><div id="40312448" class="c"><input type="checkbox" id="c-40312448" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312143">parent</a><span>|</span><a href="#40314327">prev</a><span>|</span><a href="#40312416">next</a><span>|</span><label class="collapse" for="c-40312448">[-]</label><label class="expand" for="c-40312448">[1 more]</label></div><br/><div class="children"><div class="content">It gets even worse - routing changes causing traffic to blackhole would still be undetectable without a timeout mechanism, since probes and responses would be lost.</div><br/></div></div></div></div><div id="40312416" class="c"><input type="checkbox" id="c-40312416" checked=""/><div class="controls bullet"><span class="by">noselasd</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312012">parent</a><span>|</span><a href="#40312143">prev</a><span>|</span><a href="#40312314">next</a><span>|</span><label class="collapse" for="c-40312416">[-]</label><label class="expand" for="c-40312416">[1 more]</label></div><br/><div class="children"><div class="content">SCTP has hearbeats to detect that.</div><br/></div></div><div id="40312430" class="c"><input type="checkbox" id="c-40312430" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40312012">parent</a><span>|</span><a href="#40312314">prev</a><span>|</span><a href="#40313196">next</a><span>|</span><label class="collapse" for="c-40312430">[-]</label><label class="expand" for="c-40312430">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s really really hard. For a full, guaranteed way to do this we&#x27;d need circuit switching (or circuit switching emulation). It&#x27;s pretty expensive to do in packet networks - each flow would need to be tracked by each middle box, so a lot more RAM at every hop, and probably a lot more processing power. If we go with circuit establishment, its also kind of expensive and breaks the whole &quot;distributed, decentralized, self-healing network&quot; property of the Internet.<p>It&#x27;s possible to do better than TCP these days, bandwidth is much much less constrained than it was when TCP was designed, but it&#x27;s still a hard problem to do detection of pipe disconnected for <i>any</i> reason other than timeouts (which we already have).</div><br/></div></div></div></div><div id="40313196" class="c"><input type="checkbox" id="c-40313196" checked=""/><div class="controls bullet"><span class="by">niutech</span><span>|</span><a href="#40311952">parent</a><span>|</span><a href="#40312012">prev</a><span>|</span><a href="#40311226">next</a><span>|</span><label class="collapse" for="c-40313196">[-]</label><label class="expand" for="c-40313196">[7 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t QUIC (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;QUIC" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;QUIC</a>) solve the TCP issues like latency?</div><br/><div id="40314107" class="c"><input type="checkbox" id="c-40314107" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40313196">parent</a><span>|</span><a href="#40314023">next</a><span>|</span><label class="collapse" for="c-40314107">[-]</label><label class="expand" for="c-40314107">[3 more]</label></div><br/><div class="children"><div class="content">As someone who needed high throughput and looked to QUIC because of control of buffers, I recommend against it at this time. It’s got tons of performance problems depending on impl and the API is different.<p>I don’t think QUIC is bad, or even overengineered, really. It delivers useful features, in theory, that are quite well designed for the modern web centric world. Instead I got a much larger appreciation for TCP, and how well it works everywhere: on commodity hardware, middleboxes, autotuning, NIC offloading etc etc. Never underestimate battletested tech.<p>In that sense, the lack of TCP_NODELAY is an exception to the rule that TCP performs well out of the box (golang is already doing this by default). As such, I think it’s time to change the default. Not using buffers correctly is a programming error, imo, and can be patched.</div><br/><div id="40316096" class="c"><input type="checkbox" id="c-40316096" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40314107">parent</a><span>|</span><a href="#40314023">next</a><span>|</span><label class="collapse" for="c-40316096">[-]</label><label class="expand" for="c-40316096">[2 more]</label></div><br/><div class="children"><div class="content">Was this ever implemented though? I found [1] but it was frozen due to age and was never worked on, it seems.<p>(Edit: doing some more reading, it seems TCP_NODELAY was always the default in Golang. Enable TCP_NODELAY =&gt; &quot;disable Nagle&#x27;s algorithm&quot;)<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57530">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57530</a></div><br/><div id="40316180" class="c"><input type="checkbox" id="c-40316180" checked=""/><div class="controls bullet"><span class="by">bboreham</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40316096">parent</a><span>|</span><a href="#40314023">next</a><span>|</span><label class="collapse" for="c-40316180">[-]</label><label class="expand" for="c-40316180">[1 more]</label></div><br/><div class="children"><div class="content">Yes. That issue is confusingly titled, but consists solely of a quote from the author of the code talking about what they were thinking at the time they did it.</div><br/></div></div></div></div></div></div><div id="40314023" class="c"><input type="checkbox" id="c-40314023" checked=""/><div class="controls bullet"><span class="by">jallmann</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40313196">parent</a><span>|</span><a href="#40314107">prev</a><span>|</span><a href="#40313810">next</a><span>|</span><label class="collapse" for="c-40314023">[-]</label><label class="expand" for="c-40314023">[1 more]</label></div><br/><div class="children"><div class="content">The specific issues that this article discusses (eg Nagle&#x27;s algorithm) will be present in most packet-switched transport protocols, especially ones that rely on acknowledgements for reliability. The QUIC RFC mentions this: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9000#section-13" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9000#section-13</a><p>Packet overhead, ack frequency, etc are the tip of the iceberg though. QUIC addresses some of the biggest issues with TCP such as head-of-line blocking but still shares the more finicky issues, such as different flow and congestion control algorithms interacting poorly.</div><br/></div></div><div id="40313810" class="c"><input type="checkbox" id="c-40313810" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40313196">parent</a><span>|</span><a href="#40314023">prev</a><span>|</span><a href="#40311226">next</a><span>|</span><label class="collapse" for="c-40313810">[-]</label><label class="expand" for="c-40313810">[2 more]</label></div><br/><div class="children"><div class="content">Quic is mostly used between client and data center, but not between two datacenter computers. TCP is the better choice once inside the datacenter.<p>Reasons:<p><i>Security Updates</i><p>Phones run old kernels and new apps. So it makes a lot of sense to put something that needs updated a lot like the network stack into user space, and quic does well here.<p>Data center computers run older apps on newer kernels, so it makes sense to put the network stack into the kernel where updates and operational tweaks can happen independent of the app release cycle.<p><i>Encryption Overhead</i><p>The overhead of TLS is not always needed inside a data center, where it is always needed on a phone.<p><i>Head of Line Blocking</i><p>Super important on a throttled or bad phone connection, not a big deal when all of your datacenter servers have 10G connections to everything else.<p>In my opinion TCP is a battle hardened technology that just works even when things go bad. That it contains a setting with perhaps a poor default is a small thing in comparison to its good record for stability in most situations. It&#x27;s also comforting to know I can tweak kernel parameters if I need something special for my particular use case.</div><br/><div id="40314044" class="c"><input type="checkbox" id="c-40314044" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#40311952">root</a><span>|</span><a href="#40313810">parent</a><span>|</span><a href="#40311226">next</a><span>|</span><label class="collapse" for="c-40314044">[-]</label><label class="expand" for="c-40314044">[1 more]</label></div><br/><div class="children"><div class="content">Many performance-sensitive in-datacenter applications have moved away from TCP to reliable datagram protocols. Here&#x27;s what that looks like at AWS: <a href="https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;document&#x2F;9167399" rel="nofollow">https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;document&#x2F;9167399</a></div><br/></div></div></div></div></div></div></div></div><div id="40311226" class="c"><input type="checkbox" id="c-40311226" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#40311952">prev</a><span>|</span><a href="#40311681">next</a><span>|</span><label class="collapse" for="c-40311226">[-]</label><label class="expand" for="c-40311226">[35 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t by the reasoning for never needing Nagle anymore. Sure, telnet isn&#x27;t a thing today, but I bet there are still plenty of apps which do equivalent of:<p><pre><code>     write(fd, &quot;Host: &quot;)
     write(fd, hostname)
     write(fd, &quot;\r\n&quot;)
     write(fd, &quot;Content-type: &quot;)
     etc...

</code></pre>
this may not be 40x overhead, but it&#x27;d still 5x or so.</div><br/><div id="40311526" class="c"><input type="checkbox" id="c-40311526" checked=""/><div class="controls bullet"><span class="by">temac</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311514">next</a><span>|</span><label class="collapse" for="c-40311526">[-]</label><label class="expand" for="c-40311526">[11 more]</label></div><br/><div class="children"><div class="content">Fix the apps. Nobody expect magical perf if you do that when writing to files, even though the OS also has its own buffers. There is no reason to expect otherwise when writing to a socket and actually nagle already doesn&#x27;t save you from syscall overhead.</div><br/><div id="40316466" class="c"><input type="checkbox" id="c-40316466" checked=""/><div class="controls bullet"><span class="by">citrin_ru</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311526">parent</a><span>|</span><a href="#40311674">next</a><span>|</span><label class="collapse" for="c-40316466">[-]</label><label class="expand" for="c-40316466">[1 more]</label></div><br/><div class="children"><div class="content">I agree that such code should be fixed but having hard time persuading developers to fix their code. Many of them don&#x27;t know what is a syscall, how making a syscall triggers sending of an IP packet, how a library call translates to a syscall e. t. c. Worse they don&#x27;t want to know this, they write say Java code (or some other high level language) and argue that libraries&#x2F;JDK&#x2F;kernel should handle all &#x27;low level&#x27; stuff.<p>To get optimal performance for request-response protocols like HTTP one should send a full request which includes a request line, all headers and a POST body using a single write syscall (unless POST body is large and it make sense to write it in chunks). Unfortunately not all HTTP libraries work this way and a library user cannot fix this problem without switching a library which is: 1. not always easy 2. it is not widely known which libraries are efficient and which are not. Even if you have an own HTTP library it&#x27;s not always trivial to fix: e. g. in Java a way to fix this problem while keeping code readable and idiomatic is too wrap socket into BufferedOutputStream which adds one more memory-to-memory copy for all data you are sending on top of at least one memory-to-memory copy you already have without a buffered stream; so it&#x27;s not an obvious performance win for an application which already saturates memory bandwidth.</div><br/></div></div><div id="40311674" class="c"><input type="checkbox" id="c-40311674" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311526">parent</a><span>|</span><a href="#40316466">prev</a><span>|</span><a href="#40313813">next</a><span>|</span><label class="collapse" for="c-40311674">[-]</label><label class="expand" for="c-40311674">[1 more]</label></div><br/><div class="children"><div class="content">Nagle doesn&#x27;t save the derpy side from syscall overhead, but it would save the other side.<p>It&#x27;s not just apps doing this stuff, it also lives in system libraries. I&#x27;m still mad at the Android HTTPS library for sending chunked uploads as so many tinygrams. I don&#x27;t remember exactly, but I think it&#x27;s reasonable packetization for the data chunk (if it picked a reasonable size anyway), then one packet for \r\n, one for the size, and another for another \r\n. There&#x27;s no reason for that, but it doesn&#x27;t hurt the client enough that I can convince them to avoid the system library so they can fix it and the server can manage more throughput. Ugh. (It might be that it&#x27;s just the TLS packetization that was this bogus and the TCP packetization was fine, it&#x27;s been a while)<p>If you take a pcap for some specific issue, there&#x27;s always so many of these other terrible things in there. &lt;&#x2F;rant&gt;</div><br/></div></div><div id="40313813" class="c"><input type="checkbox" id="c-40313813" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311526">parent</a><span>|</span><a href="#40311674">prev</a><span>|</span><a href="#40311995">next</a><span>|</span><label class="collapse" for="c-40313813">[-]</label><label class="expand" for="c-40313813">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Fix the apps. Nobody expect magical perf if you do that when writing to files,<p>We write to files line-by-line or even character-by-character and expect the library or OS to &quot;magically&quot; buffer it into fast file writes. Same with memory. We expect multiple small mallocs to be smartly coalesced by the platform.</div><br/><div id="40315693" class="c"><input type="checkbox" id="c-40315693" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40313813">parent</a><span>|</span><a href="#40314923">next</a><span>|</span><label class="collapse" for="c-40315693">[-]</label><label class="expand" for="c-40315693">[1 more]</label></div><br/><div class="children"><div class="content">If you <i>expect</i> a POSIX-y OS to buffer write(2) calls, you&#x27;re sadly misguided. Whether or not that happens depends on nature of the device file you&#x27;re writing to.<p>OTOH, if you&#x27;re using fwrite(3), as you likely should be actual file I&#x2F;O, then your expectation is entirely reasonable.<p>Similarly with memory. If you expect brk(2) to handle multiple small allocations &quot;sensibly&quot; you&#x27;re going to be disappointed. If you use malloc(3) then your expectation is entirely reasonable.</div><br/></div></div><div id="40314923" class="c"><input type="checkbox" id="c-40314923" checked=""/><div class="controls bullet"><span class="by">_carbyau_</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40313813">parent</a><span>|</span><a href="#40315693">prev</a><span>|</span><a href="#40314483">next</a><span>|</span><label class="collapse" for="c-40314923">[-]</label><label class="expand" for="c-40314923">[1 more]</label></div><br/><div class="children"><div class="content">True to a degree. But that is a singular platform wholly controlled by the OS.<p>Once you put packets out into the world you&#x27;re in a shared space.<p>I assume every conceivable variation of argument has been made both for and against Nagles at this point but it essentially revolves around a shared networking resource and what policy is in place for fair use.<p>Nagles fixes a particular case but interferes overall. If you fix the &quot;particular case app&quot; the issue goes away.</div><br/></div></div><div id="40314483" class="c"><input type="checkbox" id="c-40314483" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40313813">parent</a><span>|</span><a href="#40314923">prev</a><span>|</span><a href="#40311995">next</a><span>|</span><label class="collapse" for="c-40314483">[-]</label><label class="expand" for="c-40314483">[1 more]</label></div><br/><div class="children"><div class="content">Yes, your libraries should fix that.  The OS (as in the kernel) should not try to do any abstraction.<p>Alas, kernels really like to offer abstractions.</div><br/></div></div></div></div><div id="40311995" class="c"><input type="checkbox" id="c-40311995" checked=""/><div class="controls bullet"><span class="by">meinersbur</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311526">parent</a><span>|</span><a href="#40313813">prev</a><span>|</span><a href="#40314805">next</a><span>|</span><label class="collapse" for="c-40311995">[-]</label><label class="expand" for="c-40311995">[1 more]</label></div><br/><div class="children"><div class="content">Those are the apps are quickly written and do not care if they unnecessarily congest the network. The ones that do get properly maintained can set TCP_NODELAY. Seems like a reasonable default to me.</div><br/></div></div><div id="40314805" class="c"><input type="checkbox" id="c-40314805" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311526">parent</a><span>|</span><a href="#40311995">prev</a><span>|</span><a href="#40312615">next</a><span>|</span><label class="collapse" for="c-40314805">[-]</label><label class="expand" for="c-40314805">[1 more]</label></div><br/><div class="children"><div class="content">Everybody expects magical perf if you do that when writing files. We have RAM buffers and write caches for a reason, even on fast SSDs. We expect it so much that macOS doesn&#x27;t flush to disk even when you call fsync() (files get flushed to the disk&#x27;s write buffer instead).<p>There&#x27;s some overhead to calling write() in a loop, but it&#x27;s certainly not as bad as when a call to write() would actually make the data traverse whatever output stream you call it on.</div><br/></div></div><div id="40312615" class="c"><input type="checkbox" id="c-40312615" checked=""/><div class="controls bullet"><span class="by">ale42</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311526">parent</a><span>|</span><a href="#40314805">prev</a><span>|</span><a href="#40314648">next</a><span>|</span><label class="collapse" for="c-40312615">[-]</label><label class="expand" for="c-40312615">[1 more]</label></div><br/><div class="children"><div class="content">Apps can always misbehave, you never know what people implement, and you don&#x27;t always have source code to patch. I don&#x27;t think the role of the OS is to let the apps do whatever they wish, but it should give the possibility of doing it if it&#x27;s needed. So I&#x27;d rather say, if you know you&#x27;re properly doing things and you&#x27;re latency sensitive, just TCP_NODELAY on all your sockets and you&#x27;re fine, and nobody will blame you about doing it.</div><br/></div></div><div id="40314648" class="c"><input type="checkbox" id="c-40314648" checked=""/><div class="controls bullet"><span class="by">blahgeek</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311526">parent</a><span>|</span><a href="#40312615">prev</a><span>|</span><a href="#40311514">next</a><span>|</span><label class="collapse" for="c-40314648">[-]</label><label class="expand" for="c-40314648">[1 more]</label></div><br/><div class="children"><div class="content">We actually have the similar behavior when writing to files: contents are buffered in page cache and are written to disk later in batch, unless user explicitly call &quot;sync&quot;.</div><br/></div></div></div></div><div id="40311514" class="c"><input type="checkbox" id="c-40311514" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311526">prev</a><span>|</span><a href="#40312100">next</a><span>|</span><label class="collapse" for="c-40311514">[-]</label><label class="expand" for="c-40311514">[6 more]</label></div><br/><div class="children"><div class="content">The comment about telnet had me wondering what openssh does, and it sets TCP_NODELAY on every connection, even for interactive sessions.  (Confirmed by both reading the code and observing behaviour in &#x27;strace&#x27;).</div><br/><div id="40311645" class="c"><input type="checkbox" id="c-40311645" checked=""/><div class="controls bullet"><span class="by">c0l0</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311514">parent</a><span>|</span><a href="#40312100">next</a><span>|</span><label class="collapse" for="c-40311645">[-]</label><label class="expand" for="c-40311645">[5 more]</label></div><br/><div class="children"><div class="content"><i>Especially</i> for interactive sessions, it absolutely should! :)</div><br/><div id="40313200" class="c"><input type="checkbox" id="c-40313200" checked=""/><div class="controls bullet"><span class="by">syncsynchalt</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311645">parent</a><span>|</span><a href="#40312100">next</a><span>|</span><label class="collapse" for="c-40313200">[-]</label><label class="expand" for="c-40313200">[4 more]</label></div><br/><div class="children"><div class="content">Ironic since Nagle&#x27;s Algorithm (which TCP_NODELAY disables) was invented for interactive sessions.<p>It&#x27;s hard to imagine interactive sessions making more than the tiniest of blips on a modern network.</div><br/><div id="40314488" class="c"><input type="checkbox" id="c-40314488" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40313200">parent</a><span>|</span><a href="#40312100">next</a><span>|</span><label class="collapse" for="c-40314488">[-]</label><label class="expand" for="c-40314488">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t video calling an interactive session?</div><br/><div id="40315195" class="c"><input type="checkbox" id="c-40315195" checked=""/><div class="controls bullet"><span class="by">semi</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40314488">parent</a><span>|</span><a href="#40312100">next</a><span>|</span><label class="collapse" for="c-40315195">[-]</label><label class="expand" for="c-40315195">[2 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s more two independent byte streams. You want low latency but what is transfered doesnt really impact the other side, you just constantly want to push the next frame</div><br/><div id="40315205" class="c"><input type="checkbox" id="c-40315205" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40315195">parent</a><span>|</span><a href="#40312100">next</a><span>|</span><label class="collapse" for="c-40315205">[-]</label><label class="expand" for="c-40315205">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, that makes sense!<p>It&#x27;s interesting that it&#x27;s very much an interactive experience for the end-user.  But for the logic of the computer, it&#x27;s not interactive at all.<p>You can make the contrast even stronger: if both video streams are transmitted over UDP, you don&#x27;t even need to sent ACKs etc.  To be truly one-directional from a technical point of view.<p>Then compare that to transferring a file via TCP.  For the user this is as one-directional and non-interactive as it gets, but the computers constantly talk back and forth.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40312100" class="c"><input type="checkbox" id="c-40312100" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311514">prev</a><span>|</span><a href="#40311672">next</a><span>|</span><label class="collapse" for="c-40312100">[-]</label><label class="expand" for="c-40312100">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s actually super common anymore when you consider that doing asynchronous I&#x2F;O, the only sane way to do that is put it into a buffer rather than blocking at every small write(2).<p>Then you consider that asynchronous I&#x2F;O is usually necessary both on server (otherwise you don&#x27;t scale well) and client (because blocking on network calls is terrible experience, especially in today&#x27;s world of frequent network changes, falling out of network range, etc.)</div><br/></div></div><div id="40311672" class="c"><input type="checkbox" id="c-40311672" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40312100">prev</a><span>|</span><a href="#40311601">next</a><span>|</span><label class="collapse" for="c-40311672">[-]</label><label class="expand" for="c-40311672">[3 more]</label></div><br/><div class="children"><div class="content">We shouldn&#x27;t penalize the internet at large because some developers write terrible code.</div><br/><div id="40312170" class="c"><input type="checkbox" id="c-40312170" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311672">parent</a><span>|</span><a href="#40311601">next</a><span>|</span><label class="collapse" for="c-40312170">[-]</label><label class="expand" for="c-40312170">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it how SMTP is working though?</div><br/><div id="40313072" class="c"><input type="checkbox" id="c-40313072" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40312170">parent</a><span>|</span><a href="#40311601">next</a><span>|</span><label class="collapse" for="c-40313072">[-]</label><label class="expand" for="c-40313072">[1 more]</label></div><br/><div class="children"><div class="content">No?</div><br/></div></div></div></div></div></div><div id="40311601" class="c"><input type="checkbox" id="c-40311601" checked=""/><div class="controls bullet"><span class="by">grishka</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311672">prev</a><span>|</span><a href="#40311468">next</a><span>|</span><label class="collapse" for="c-40311601">[-]</label><label class="expand" for="c-40311601">[1 more]</label></div><br/><div class="children"><div class="content">And they really shouldn&#x27;t do this. Even disregarding the network aspect of it, this is still bad for performance because syscalls are kinda expensive.</div><br/></div></div><div id="40311468" class="c"><input type="checkbox" id="c-40311468" checked=""/><div class="controls bullet"><span class="by">otterley</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311601">prev</a><span>|</span><a href="#40311646">next</a><span>|</span><label class="collapse" for="c-40311468">[-]</label><label class="expand" for="c-40311468">[1 more]</label></div><br/><div class="children"><div class="content">Marc addresses that: “That’s going to make some “write every byte” code slower than it would otherwise be, but those applications should be fixed anyway if we care about efficiency.”</div><br/></div></div><div id="40311646" class="c"><input type="checkbox" id="c-40311646" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311468">prev</a><span>|</span><a href="#40311479">next</a><span>|</span><label class="collapse" for="c-40311646">[-]</label><label class="expand" for="c-40311646">[4 more]</label></div><br/><div class="children"><div class="content">Does this matter?  Yes, there&#x27;s a lot of waste.  But you also have a 1Gbps link.  Every second that you don&#x27;t use the full 1Gbps is also waste, right?</div><br/><div id="40311741" class="c"><input type="checkbox" id="c-40311741" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311646">parent</a><span>|</span><a href="#40311479">next</a><span>|</span><label class="collapse" for="c-40311741">[-]</label><label class="expand" for="c-40311741">[3 more]</label></div><br/><div class="children"><div class="content">This is why I always pad out the end of my html files with a megabyte of &amp;nbsp;. A half empty pipe is a half wasted pipe.</div><br/><div id="40312967" class="c"><input type="checkbox" id="c-40312967" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311741">parent</a><span>|</span><a href="#40312955">next</a><span>|</span><label class="collapse" for="c-40312967">[-]</label><label class="expand" for="c-40312967">[1 more]</label></div><br/><div class="children"><div class="content">I am finally starting to understand some of these OpenOffice&#x2F;LibreOffice commit messages like <a href="https:&#x2F;&#x2F;github.com&#x2F;LibreOffice&#x2F;core&#x2F;commit&#x2F;a0b6744d3d77">https:&#x2F;&#x2F;github.com&#x2F;LibreOffice&#x2F;core&#x2F;commit&#x2F;a0b6744d3d77</a></div><br/></div></div><div id="40312955" class="c"><input type="checkbox" id="c-40312955" checked=""/><div class="controls bullet"><span class="by">dessimus</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311741">parent</a><span>|</span><a href="#40312967">prev</a><span>|</span><a href="#40311479">next</a><span>|</span><label class="collapse" for="c-40312955">[-]</label><label class="expand" for="c-40312955">[1 more]</label></div><br/><div class="children"><div class="content">Just be sure HTTP Compression is off though, or you&#x27;re still half-wasting the pipe.<p>Better to just dump randomized uncompressible data into html comments.</div><br/></div></div></div></div></div></div><div id="40311479" class="c"><input type="checkbox" id="c-40311479" checked=""/><div class="controls bullet"><span class="by">Arnt</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311646">prev</a><span>|</span><a href="#40311653">next</a><span>|</span><label class="collapse" for="c-40311479">[-]</label><label class="expand" for="c-40311479">[1 more]</label></div><br/><div class="children"><div class="content">Those aren&#x27;t the ones you debug, so they won&#x27;t be seen by OP. Those are the ones you don&#x27;t need to debug because Nagle saves you.</div><br/></div></div><div id="40311653" class="c"><input type="checkbox" id="c-40311653" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311479">prev</a><span>|</span><a href="#40312541">next</a><span>|</span><label class="collapse" for="c-40311653">[-]</label><label class="expand" for="c-40311653">[2 more]</label></div><br/><div class="children"><div class="content">I imagine the write calls show up pretty easily as a bottleneck in a flamegraph.</div><br/><div id="40311725" class="c"><input type="checkbox" id="c-40311725" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#40311226">root</a><span>|</span><a href="#40311653">parent</a><span>|</span><a href="#40312541">next</a><span>|</span><label class="collapse" for="c-40311725">[-]</label><label class="expand" for="c-40311725">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t. Maybe if you&#x27;re really good you notice the higher overhead but you expect to be spending time writing to the network. The actual impact shows up when the bandwidth consumption is way up on packet and TCP headers which won&#x27;t show on a flamegraph that easily.</div><br/></div></div></div></div><div id="40312541" class="c"><input type="checkbox" id="c-40312541" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311653">prev</a><span>|</span><a href="#40311891">next</a><span>|</span><label class="collapse" for="c-40312541">[-]</label><label class="expand" for="c-40312541">[1 more]</label></div><br/><div class="children"><div class="content">TCP_CORK handles this better than nagle tho.</div><br/></div></div><div id="40311891" class="c"><input type="checkbox" id="c-40311891" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40312541">prev</a><span>|</span><a href="#40312092">next</a><span>|</span><label class="collapse" for="c-40311891">[-]</label><label class="expand" for="c-40311891">[1 more]</label></div><br/><div class="children"><div class="content">The discussion here mostly seems to miss the point. The argument is to <i>change the default</i>, not to eliminate the behavior altogether.</div><br/></div></div><div id="40312092" class="c"><input type="checkbox" id="c-40312092" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40311891">prev</a><span>|</span><a href="#40311803">next</a><span>|</span><label class="collapse" for="c-40312092">[-]</label><label class="expand" for="c-40312092">[1 more]</label></div><br/><div class="children"><div class="content">shouldn&#x27;t autocorking help with even without nagle?</div><br/></div></div><div id="40311803" class="c"><input type="checkbox" id="c-40311803" checked=""/><div class="controls bullet"><span class="by">loopdoend</span><span>|</span><a href="#40311226">parent</a><span>|</span><a href="#40312092">prev</a><span>|</span><a href="#40311681">next</a><span>|</span><label class="collapse" for="c-40311803">[-]</label><label class="expand" for="c-40311803">[1 more]</label></div><br/><div class="children"><div class="content">Ah yeah I fixed this exact bug in net-http in Ruby core a decade ago.</div><br/></div></div></div></div><div id="40311681" class="c"><input type="checkbox" id="c-40311681" checked=""/><div class="controls bullet"><span class="by">batmanthehorse</span><span>|</span><a href="#40311226">prev</a><span>|</span><a href="#40311969">next</a><span>|</span><label class="collapse" for="c-40311681">[-]</label><label class="expand" for="c-40311681">[31 more]</label></div><br/><div class="children"><div class="content">Does anyone know of a good way to enable TCP_NODELAY on sockets when you don&#x27;t have access to the source for that application? I can&#x27;t find any kernel settings to make it permanent, or commands to change it after the fact.<p>I&#x27;ve been able to disable delayed acks using `quickack 1` in the routing table, but it seems particularly hard to enable TCP_NODELAY from outside the application.<p>I&#x27;ve been having exactly the problem described here lately, when communicating between an application I own and a closed source application it interacts with.</div><br/><div id="40311763" class="c"><input type="checkbox" id="c-40311763" checked=""/><div class="controls bullet"><span class="by">coldpie</span><span>|</span><a href="#40311681">parent</a><span>|</span><a href="#40313201">next</a><span>|</span><label class="collapse" for="c-40311763">[-]</label><label class="expand" for="c-40311763">[24 more]</label></div><br/><div class="children"><div class="content">Would some kind of LD_PRELOAD interception for socket(2) work? Call the real function, then do setsockopt or whatever, and return the modified socket.</div><br/><div id="40311925" class="c"><input type="checkbox" id="c-40311925" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40311763">parent</a><span>|</span><a href="#40313201">next</a><span>|</span><label class="collapse" for="c-40311925">[-]</label><label class="expand" for="c-40311925">[23 more]</label></div><br/><div class="children"><div class="content">&gt; Would some kind of LD_PRELOAD interception for socket(2) work?<p>That would only work if the call goes through libc, and it&#x27;s not statically linked. However, it&#x27;s becoming more and more common to do system calls directly, bypassing libc; the Go language is infamous for doing that, but there&#x27;s also things like the rustix crate for Rust (<a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;rustix" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;rustix</a>), which does direct system calls by default.</div><br/><div id="40312273" class="c"><input type="checkbox" id="c-40312273" checked=""/><div class="controls bullet"><span class="by">zbowling</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40311925">parent</a><span>|</span><a href="#40313201">next</a><span>|</span><label class="collapse" for="c-40312273">[-]</label><label class="expand" for="c-40312273">[22 more]</label></div><br/><div class="children"><div class="content">And go is wrong for doing that, at least on Linux. It bypasses optimizations in the vDSO in some cases. On Fuchsia, we made direct syscalls not through the vDSO illegal and it was funny the hacks to go that required. The system ABI of Linux really isn&#x27;t the syscall interface, its the system libc. That&#x27;s because the C ABI (and the behaviors of the triple it was compiled for) and its isms for that platform are the linga franca of that system. Going around that to call syscalls directly, at least for the 90% of useful syscalls on the system that are wrapped by libc, is asinine and creates odd bugs, makes crash reporters heuristical unwinders, debuggers, etc all more painful to write. It also prevents the system vendor from implementing user mode optimizations that avoid mode and context switches when necessary. We tried to solve these issues in Fuchsia, but for Linux, Darwin, and hell, even Windows, if you are making direct syscalls and it&#x27;s not for something really special and bespoke, you are just flat-out wrong.</div><br/><div id="40312341" class="c"><input type="checkbox" id="c-40312341" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40313694">next</a><span>|</span><label class="collapse" for="c-40312341">[-]</label><label class="expand" for="c-40312341">[8 more]</label></div><br/><div class="children"><div class="content">&gt; The system ABI of Linux really isn&#x27;t the syscall interface, its the system libc.<p>You might have reasons to prefer to use libc; some software has reason to not use libc. Those preferences are in conflict, but one of them is not automatically right and the other wrong in all circumstances.<p>Many UNIX systems <i>did</i> follow the premise that you <i>must</i> use libc and the syscall interface is unstable. Linux pointedly did not, and decided to have a stable syscall ABI instead. This means it&#x27;s possible to have multiple C libraries, as well as other libraries, which have different needs or goals and interface with the system differently. That&#x27;s a <i>useful</i> property of Linux.<p>There are a couple of established mechanism on Linux for intercepting syscalls: ptrace, and BPF. If you want to intercept all uses of a syscall, intercept the syscall. If you want to intercept a particular glibc function <i>in programs using glibc</i>, or for that matter a musl function in a program using musl, go ahead and use LD_PRELOAD. But the Linux syscall interface is a valid and stable interface to the system, and that&#x27;s why LD_PRELOAD is not a complete solution.</div><br/><div id="40312397" class="c"><input type="checkbox" id="c-40312397" checked=""/><div class="controls bullet"><span class="by">zbowling</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312341">parent</a><span>|</span><a href="#40312627">next</a><span>|</span><label class="collapse" for="c-40312397">[-]</label><label class="expand" for="c-40312397">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s true that Linux has a stable-ish syscall table. What is funny is that this caused a whole series of Samsung Android phones to reboot randomly with some apps because Samsung added a syscall at the same position someone else did in upstream linux and folks staticly linking their own libc to avoid boionc libc were rebooting phones when calling certain functions because the Samsung syscall causing kernel panics when called wrong. Goes back to it being a bad idea to subvert your system libc. Now, distro vendors do give out multiple versions of a libc that all work with your kernel. This generally works. When we had to fix ABI issues this happened a few times. But I wouldn&#x27;t trust building our libc and assuming that libc is portable to any linux machine to copy it to.</div><br/><div id="40312773" class="c"><input type="checkbox" id="c-40312773" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312397">parent</a><span>|</span><a href="#40312627">next</a><span>|</span><label class="collapse" for="c-40312773">[-]</label><label class="expand" for="c-40312773">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s true that Linux has a stable-ish syscall table.<p>It&#x27;s not &quot;stable-ish&quot;, it&#x27;s fully stable. Once a syscall is added to the syscall table on a released version of the official Linux kernel, it might later be replaced by a &quot;not implemented&quot; stub (which always returns -ENOSYS), but it will never be reused for anything else. There&#x27;s even reserved space on some architectures for the STREAMS syscalls, which were AFAIK never on any released version of the Linux kernel.<p>The exception is when creating a new architecture; for instance, the syscall table for 32-bit x86 and 64-bit x86 has a completely different order.</div><br/><div id="40313569" class="c"><input type="checkbox" id="c-40313569" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312773">parent</a><span>|</span><a href="#40312627">next</a><span>|</span><label class="collapse" for="c-40313569">[-]</label><label class="expand" for="c-40313569">[3 more]</label></div><br/><div class="children"><div class="content">I think what they meant (judging by the example you ignored) is that the table changes (even if append-only) and you don&#x27;t know which version you actually have when you statically compile your own version. Thus, your syscalls might be using a newer version of the table but it a) not actually be implemented, or b) implemented with something bespoke.</div><br/><div id="40315154" class="c"><input type="checkbox" id="c-40315154" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40313569">parent</a><span>|</span><a href="#40312627">next</a><span>|</span><label class="collapse" for="c-40315154">[-]</label><label class="expand" for="c-40315154">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Thus, your syscalls might be using a newer version of the table but it a) not actually be implemented,<p>That&#x27;s the same case as when a syscall is later removed: it returns -ENOSYS. The correct way is to do the call normally as if it were implemented, and if it returns -ENOSYS, you know that this syscall does not exist in the currently running kernel, and you should try something else. That is the same no matter whether it&#x27;s compiled statically or dynamically; even a dynamic glibc has fallback paths for some missing syscalls (glibc has a minimum required kernel version, so it does not need to have fallback paths for features introduced a long time ago).<p>&gt; or b) implemented with something bespoke.<p>There&#x27;s nothing you can do to protect against a modified kernel which does something different from the upstream Linux kernel. Even going through libc doesn&#x27;t help, since whoever modified the Linux kernel to do something unexpected could also have modified the C library to do something unexpected, or libc could trip over the unexpected kernel changes.<p>One example of this happening is with seccomp filters. They can be used to make a syscall fail with an unexpected error code, and this can confuse the C library. More specifically, a seccomp filter which forces the clone3 syscall to always return -EPERM breaks newer libc versions which try the clone3 syscall first, and then fallback to the older clone syscall if clone3 returned -ENOSYS (which indicates an older kernel that does not have the clone3 syscall); this breaks for instance running newer Linux distributions within older Docker versions.</div><br/><div id="40316165" class="c"><input type="checkbox" id="c-40316165" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40315154">parent</a><span>|</span><a href="#40312627">next</a><span>|</span><label class="collapse" for="c-40316165">[-]</label><label class="expand" for="c-40316165">[1 more]</label></div><br/><div class="children"><div class="content">Every kernel I’ve ever used has been different from an upstream kernel, with custom patches applied. It’s literally open source, anyone can do anything to it that they want. If you are using libc, you’d have a reasonable expectation not to need to know the details of those changes. If you call the kernel directly via syscall, then yeah, there is nothing you can do about someone making modifications to open source software.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40312627" class="c"><input type="checkbox" id="c-40312627" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312341">parent</a><span>|</span><a href="#40312397">prev</a><span>|</span><a href="#40313694">next</a><span>|</span><label class="collapse" for="c-40312627">[-]</label><label class="expand" for="c-40312627">[2 more]</label></div><br/><div class="children"><div class="content">The complication with the linux syscall interface is that it turns the worse is better up to 11. Like setuid works on a per thread basis, which is seriously not what you want, so every program&#x2F;runtime must do this fun little thread stop and start and thunk dance.</div><br/><div id="40312908" class="c"><input type="checkbox" id="c-40312908" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312627">parent</a><span>|</span><a href="#40313694">next</a><span>|</span><label class="collapse" for="c-40312908">[-]</label><label class="expand" for="c-40312908">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, agreed. One of the items on my <i>long</i> TODO list is adding `setuid_process` and `setgid_process` and similar, so that perhaps a decade later when new runtimes can count on the presence of those syscalls, they can stop duplicating that mechanism in userspace.</div><br/></div></div></div></div></div></div><div id="40313694" class="c"><input type="checkbox" id="c-40313694" checked=""/><div class="controls bullet"><span class="by">pie_flavor</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40312341">prev</a><span>|</span><a href="#40312371">next</a><span>|</span><label class="collapse" for="c-40313694">[-]</label><label class="expand" for="c-40313694">[1 more]</label></div><br/><div class="children"><div class="content">You seem to be saying &#x27;it was incorrect on Fuchsia, so it&#x27;s incorrect on Linux&#x27;. No, it&#x27;s correct on Linux, and incorrect on every other platform, as each platform&#x27;s documentation is very clear on. Go did it incorrectly on FreeBSD, but that&#x27;s Go being Go; they did it in the first place because it&#x27;s a Linux-first system and it&#x27;s correct on Linux. And glibc does not have any special privilege, the vdso optimizations it takes advantage of are just as easily taken advantage of by the Go compiler. There&#x27;s no reason to bucket Linux with Windows on the subject of syscalls when the Linux manpages are very clear that syscalls are there to be used and exhaustively documents them, while MSDN is very clear that the system interface is kernel32.dll and ntdll.dll, and shuffles the syscall numbers every so often so you don&#x27;t get any funny ideas.</div><br/></div></div><div id="40312371" class="c"><input type="checkbox" id="c-40312371" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40313694">prev</a><span>|</span><a href="#40313808">next</a><span>|</span><label class="collapse" for="c-40312371">[-]</label><label class="expand" for="c-40312371">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The system ABI of Linux really isn&#x27;t the syscall interface, its the system libc.<p>Which one? The Linux Kernel doesn&#x27;t provide a libc. What if you&#x27;re a static executable?<p>Even on Operating Systems with a libc provided by the kernel, it&#x27;s almost always allowed to upgrade the kernel without upgrading the userland (including libc); that works because the interface between userland and kernel is syscalls.<p>That certainly ties something that makes syscalls to a narrow range of kernel versions, but it&#x27;s not as if dynamically linking libc means your program will be compatible forever either.</div><br/><div id="40312628" class="c"><input type="checkbox" id="c-40312628" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312371">parent</a><span>|</span><a href="#40313808">next</a><span>|</span><label class="collapse" for="c-40312628">[-]</label><label class="expand" for="c-40312628">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That certainly ties something that makes syscalls to a narrow range of kernel versions<p>I don&#x27;t think that&#x27;s right, wouldn&#x27;t it be the earliest kernel supporting that call and onwards? The Linux ABI intentionally never breaks userland.</div><br/><div id="40312987" class="c"><input type="checkbox" id="c-40312987" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312628">parent</a><span>|</span><a href="#40313808">next</a><span>|</span><label class="collapse" for="c-40312987">[-]</label><label class="expand" for="c-40312987">[1 more]</label></div><br/><div class="children"><div class="content">In the case where you&#x27;re running an Operating System that provides a libc and is OK with removing older syscalls, there&#x27;s a beginning and an end to support.<p>Looking at FreeBSD under &#x2F;usr&#x2F;include&#x2F;sys&#x2F;syscall.h, there&#x27;s a good number of retired syscalls.<p>On Linux under &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h I see a fair number of missing numbers --- not sure what those are about, but 222, 223, 251, 285, and 387-392 are missing. (on Debian 12.1 with linux-image-6.1.0-12-amd64 version 6.1.52-1, if it matters)</div><br/></div></div></div></div></div></div><div id="40313808" class="c"><input type="checkbox" id="c-40313808" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40312371">prev</a><span>|</span><a href="#40313747">next</a><span>|</span><label class="collapse" for="c-40313808">[-]</label><label class="expand" for="c-40313808">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And go is wrong for doing that, at least on Linux. It bypasses optimizations in the vDSO in some cases.<p>Go&#x27;s runtime <i>does</i> go through the vDSO for syscalls that support it, though (e.g., [0]). Of course, it won&#x27;t magically adapt to new functions added in later kernel versions, but neither will a statically-linked libc. And it&#x27;s not like it&#x27;s a regular occurrence for Linux to new functions to the vDSO, in any case.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;runtime&#x2F;time_linux_amd64.s">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;runtime&#x2F;time_li...</a></div><br/></div></div><div id="40313747" class="c"><input type="checkbox" id="c-40313747" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40313808">prev</a><span>|</span><a href="#40312528">next</a><span>|</span><label class="collapse" for="c-40313747">[-]</label><label class="expand" for="c-40313747">[1 more]</label></div><br/><div class="children"><div class="content">Linux doesn&#x27;t even have consensus on what libc to use, and ABI breakage between glibc and musl is not unheard of. (Probably not for syscalls but for other things.)</div><br/></div></div><div id="40312528" class="c"><input type="checkbox" id="c-40312528" checked=""/><div class="controls bullet"><span class="by">assassinator42</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40313747">prev</a><span>|</span><a href="#40313019">next</a><span>|</span><label class="collapse" for="c-40312528">[-]</label><label class="expand" for="c-40312528">[1 more]</label></div><br/><div class="children"><div class="content">The proliferation of Docker containers seems to go against that. Those really only work well since the kernel has a stable syscall ABI.
So much so that you see Microsoft switching to a stable syscall ABI with Windows 11.</div><br/></div></div><div id="40313019" class="c"><input type="checkbox" id="c-40313019" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40312528">prev</a><span>|</span><a href="#40312653">next</a><span>|</span><label class="collapse" for="c-40313019">[-]</label><label class="expand" for="c-40313019">[3 more]</label></div><br/><div class="children"><div class="content">It should be possible to use vDSO without libc, although probably a lot of work.</div><br/><div id="40313836" class="c"><input type="checkbox" id="c-40313836" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40313019">parent</a><span>|</span><a href="#40312653">next</a><span>|</span><label class="collapse" for="c-40313836">[-]</label><label class="expand" for="c-40313836">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that much work; after all, every libc needs to have its own implementation. The kernel maps the vDSO into memory for you, and gives you the base address as an entry in the auxiliary vector.<p>But using it does require some basic knowledge of the ELF format on the current platform, in order to parse the symbol table. (Alongside knowledge of which functions are available in the first place.)</div><br/><div id="40314140" class="c"><input type="checkbox" id="c-40314140" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40313836">parent</a><span>|</span><a href="#40312653">next</a><span>|</span><label class="collapse" for="c-40314140">[-]</label><label class="expand" for="c-40314140">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard work to NOT have the damn vDSO invade your address space. Only kludge part of Linux, well, apart from Nagle&#x27;s, dlopen, and that weird zero copy kernel patch that mmap&#x27;d -each- socket recv(!) for a while.</div><br/></div></div></div></div></div></div><div id="40312653" class="c"><input type="checkbox" id="c-40312653" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40313019">prev</a><span>|</span><a href="#40312530">next</a><span>|</span><label class="collapse" for="c-40312653">[-]</label><label class="expand" for="c-40312653">[1 more]</label></div><br/><div class="children"><div class="content">Those are very strong words...</div><br/></div></div><div id="40312530" class="c"><input type="checkbox" id="c-40312530" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312273">parent</a><span>|</span><a href="#40312653">prev</a><span>|</span><a href="#40313201">next</a><span>|</span><label class="collapse" for="c-40312530">[-]</label><label class="expand" for="c-40312530">[2 more]</label></div><br/><div class="children"><div class="content">Linux is also weird because there are syscalls not supported in most (any?) libc - things like io_uring, and netlink fall into this.</div><br/><div id="40312799" class="c"><input type="checkbox" id="c-40312799" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40312530">parent</a><span>|</span><a href="#40313201">next</a><span>|</span><label class="collapse" for="c-40312799">[-]</label><label class="expand" for="c-40312799">[1 more]</label></div><br/><div class="children"><div class="content">Futex for a very long time was only accessible via syscall.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40313201" class="c"><input type="checkbox" id="c-40313201" checked=""/><div class="controls bullet"><span class="by">jdadj</span><span>|</span><a href="#40311681">parent</a><span>|</span><a href="#40311763">prev</a><span>|</span><a href="#40311907">next</a><span>|</span><label class="collapse" for="c-40313201">[-]</label><label class="expand" for="c-40313201">[1 more]</label></div><br/><div class="children"><div class="content">Depending on the specifics, you might be able to add socat in the middle.<p>Instead of:
your_app —&gt; server<p>you’d have:
your_app -&gt; localhost_socat -&gt; server<p>socat has command line options for setting tcp_nodelay.  You’d need to convince your closed source app to connect to localhost, though.  But if it’s doing a dns lookup, you could probably convince it to connect to localhost with an &#x2F;etc&#x2F;hosts entry<p>Since your app would be talking to socat over a local socket, the app’s tcp_nodelay wouldn’t have any effect.</div><br/></div></div><div id="40311907" class="c"><input type="checkbox" id="c-40311907" checked=""/><div class="controls bullet"><span class="by">praptak</span><span>|</span><a href="#40311681">parent</a><span>|</span><a href="#40313201">prev</a><span>|</span><a href="#40311946">next</a><span>|</span><label class="collapse" for="c-40311907">[-]</label><label class="expand" for="c-40311907">[1 more]</label></div><br/><div class="children"><div class="content">Attach debugger (ptrace), call setsockopt?</div><br/></div></div><div id="40311946" class="c"><input type="checkbox" id="c-40311946" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#40311681">parent</a><span>|</span><a href="#40311907">prev</a><span>|</span><a href="#40311712">next</a><span>|</span><label class="collapse" for="c-40311946">[-]</label><label class="expand" for="c-40311946">[1 more]</label></div><br/><div class="children"><div class="content">opening `&#x2F;proc&#x2F;&lt;pid&gt;&#x2F;fd&#x2F;&lt;fd number&gt;` and setting the socket option may work (not tested)</div><br/></div></div><div id="40311712" class="c"><input type="checkbox" id="c-40311712" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#40311681">parent</a><span>|</span><a href="#40311946">prev</a><span>|</span><a href="#40312960">next</a><span>|</span><label class="collapse" for="c-40311712">[-]</label><label class="expand" for="c-40311712">[2 more]</label></div><br/><div class="children"><div class="content">LD_PRELOAD.</div><br/><div id="40311921" class="c"><input type="checkbox" id="c-40311921" checked=""/><div class="controls bullet"><span class="by">batmanthehorse</span><span>|</span><a href="#40311681">root</a><span>|</span><a href="#40311712">parent</a><span>|</span><a href="#40312960">next</a><span>|</span><label class="collapse" for="c-40311921">[-]</label><label class="expand" for="c-40311921">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, found this: <a href="https:&#x2F;&#x2F;github.com&#x2F;sschroe&#x2F;libnodelay">https:&#x2F;&#x2F;github.com&#x2F;sschroe&#x2F;libnodelay</a></div><br/></div></div></div></div><div id="40312960" class="c"><input type="checkbox" id="c-40312960" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#40311681">parent</a><span>|</span><a href="#40311712">prev</a><span>|</span><a href="#40311969">next</a><span>|</span><label class="collapse" for="c-40312960">[-]</label><label class="expand" for="c-40312960">[1 more]</label></div><br/><div class="children"><div class="content">you could try ebpf and hook on the socket syscall. might be harder than LD_PRELOAD as suggested by other commenters though</div><br/></div></div></div></div><div id="40311969" class="c"><input type="checkbox" id="c-40311969" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#40311681">prev</a><span>|</span><a href="#40312209">next</a><span>|</span><label class="collapse" for="c-40311969">[-]</label><label class="expand" for="c-40311969">[2 more]</label></div><br/><div class="children"><div class="content">Relevant Oxide and Friends podcast episode <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mqvVmYhclAg" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mqvVmYhclAg</a></div><br/><div id="40312771" class="c"><input type="checkbox" id="c-40312771" checked=""/><div class="controls bullet"><span class="by">matthavener</span><span>|</span><a href="#40311969">parent</a><span>|</span><a href="#40312209">next</a><span>|</span><label class="collapse" for="c-40312771">[-]</label><label class="expand" for="c-40312771">[1 more]</label></div><br/><div class="children"><div class="content">This was a great episode and the really drove home the importance of visualization.</div><br/></div></div></div></div><div id="40312209" class="c"><input type="checkbox" id="c-40312209" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#40311969">prev</a><span>|</span><a href="#40311522">next</a><span>|</span><label class="collapse" for="c-40312209">[-]</label><label class="expand" for="c-40312209">[5 more]</label></div><br/><div class="children"><div class="content">Not if you use a modern language that enables TCP_NODELAY by default, like Go. :-)</div><br/><div id="40312266" class="c"><input type="checkbox" id="c-40312266" checked=""/><div class="controls bullet"><span class="by">andrewfromx</span><span>|</span><a href="#40312209">parent</a><span>|</span><a href="#40314520">next</a><span>|</span><label class="collapse" for="c-40312266">[-]</label><label class="expand" for="c-40312266">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34179426">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34179426</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57530">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57530</a><p>huh, TIL.</div><br/></div></div><div id="40314520" class="c"><input type="checkbox" id="c-40314520" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40312209">parent</a><span>|</span><a href="#40312266">prev</a><span>|</span><a href="#40314394">next</a><span>|</span><label class="collapse" for="c-40314520">[-]</label><label class="expand" for="c-40314520">[2 more]</label></div><br/><div class="children"><div class="content">Why do you need a whole language for that?  Couldn&#x27;t you just use a &#x27;modern&#x27; networking library?</div><br/><div id="40314652" class="c"><input type="checkbox" id="c-40314652" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#40312209">root</a><span>|</span><a href="#40314520">parent</a><span>|</span><a href="#40314394">next</a><span>|</span><label class="collapse" for="c-40314652">[-]</label><label class="expand" for="c-40314652">[1 more]</label></div><br/><div class="children"><div class="content">Sure, like the one in <a href="https:&#x2F;&#x2F;9fans.github.io&#x2F;plan9port&#x2F;" rel="nofollow">https:&#x2F;&#x2F;9fans.github.io&#x2F;plan9port&#x2F;</a>. :-)</div><br/></div></div></div></div><div id="40314394" class="c"><input type="checkbox" id="c-40314394" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#40312209">parent</a><span>|</span><a href="#40314520">prev</a><span>|</span><a href="#40311522">next</a><span>|</span><label class="collapse" for="c-40314394">[-]</label><label class="expand" for="c-40314394">[1 more]</label></div><br/><div class="children"><div class="content">Node.js also does this since at least 2020.</div><br/></div></div></div></div><div id="40311522" class="c"><input type="checkbox" id="c-40311522" checked=""/><div class="controls bullet"><span class="by">obelos</span><span>|</span><a href="#40312209">prev</a><span>|</span><a href="#40313160">next</a><span>|</span><label class="collapse" for="c-40311522">[-]</label><label class="expand" for="c-40311522">[17 more]</label></div><br/><div class="children"><div class="content">Not every time. Sometimes it&#x27;s DNS.</div><br/><div id="40311882" class="c"><input type="checkbox" id="c-40311882" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40311522">parent</a><span>|</span><a href="#40311675">next</a><span>|</span><label class="collapse" for="c-40311882">[-]</label><label class="expand" for="c-40311882">[8 more]</label></div><br/><div class="children"><div class="content">Once it was a failing line card in router zeroing last bit in IPv4 addresses, resulting in ticket about &quot;only even IPv4 addresses are accessible&quot; ...</div><br/><div id="40311972" class="c"><input type="checkbox" id="c-40311972" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#40311522">root</a><span>|</span><a href="#40311882">parent</a><span>|</span><a href="#40311675">next</a><span>|</span><label class="collapse" for="c-40311972">[-]</label><label class="expand" for="c-40311972">[7 more]</label></div><br/><div class="children"><div class="content">For some reason this reminded me of the &quot;500mi email&quot; bug [1], maybe a similar level of initial apparent absurdity?<p>[1] <a href="https:&#x2F;&#x2F;www.ibiblio.org&#x2F;harris&#x2F;500milemail.html" rel="nofollow">https:&#x2F;&#x2F;www.ibiblio.org&#x2F;harris&#x2F;500milemail.html</a></div><br/><div id="40316565" class="c"><input type="checkbox" id="c-40316565" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40311522">root</a><span>|</span><a href="#40311972">parent</a><span>|</span><a href="#40312198">next</a><span>|</span><label class="collapse" for="c-40316565">[-]</label><label class="expand" for="c-40316565">[1 more]</label></div><br/><div class="children"><div class="content">I can definitely confirm our initial reaction was &quot;WTF&quot; followed with idea that the dev team is making fun of us... but we went in and run traceroutes and there it was :O<p>Was fixed in incredible coincidence manner, too - the <i>CTO</i> of the network link provider was in their offices (in the same building as me) and felt bored. Apparently having went through all the levels from hauling cables in datacenter up to CTO level, after short look at traceroutes he just picked a phone, called NOC, and ordered a line card replacement on the router :D</div><br/></div></div><div id="40312198" class="c"><input type="checkbox" id="c-40312198" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#40311522">root</a><span>|</span><a href="#40311972">parent</a><span>|</span><a href="#40316565">prev</a><span>|</span><a href="#40311675">next</a><span>|</span><label class="collapse" for="c-40312198">[-]</label><label class="expand" for="c-40312198">[5 more]</label></div><br/><div class="children"><div class="content">The most absurd thing to me about the 500 mile email situation is that sendmail just happily started up and soldiered on after being given a completely alien config file.  Could be read as another example of &quot;be liberal in what you accept&quot; going awry, but sendmail&#x27;s wretched config format is really a volume of war stories all its own...</div><br/><div id="40313867" class="c"><input type="checkbox" id="c-40313867" checked=""/><div class="controls bullet"><span class="by">rincebrain</span><span>|</span><a href="#40311522">root</a><span>|</span><a href="#40312198">parent</a><span>|</span><a href="#40312475">next</a><span>|</span><label class="collapse" for="c-40313867">[-]</label><label class="expand" for="c-40313867">[1 more]</label></div><br/><div class="children"><div class="content">My favorite example of that was a while ago, &quot;vixie-cron will read a cron stanza from a core dump written to &#x2F;etc&#x2F;cron.d&quot; when you could convince it to write a core dump there. The other crons wouldn&#x27;t touch that, but vixie-cron happily chomped through the core dump for &quot;* * * * * root chmod u+s &#x2F;tmp&#x2F;uhoh&quot; etc.</div><br/></div></div><div id="40312475" class="c"><input type="checkbox" id="c-40312475" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#40311522">root</a><span>|</span><a href="#40312198">parent</a><span>|</span><a href="#40313867">prev</a><span>|</span><a href="#40311675">next</a><span>|</span><label class="collapse" for="c-40312475">[-]</label><label class="expand" for="c-40312475">[3 more]</label></div><br/><div class="children"><div class="content">Configuration changes are one of those areas where having some kind of &quot;are you sure? (y&#x2F;n)&quot; check can really pay off. It wouldn&#x27;t have helped in this case, because there wasn&#x27;t really any change management process to speak of, but we haven&#x27;t fully learned the lesson yet.</div><br/><div id="40313298" class="c"><input type="checkbox" id="c-40313298" checked=""/><div class="controls bullet"><span class="by">unconed</span><span>|</span><a href="#40311522">root</a><span>|</span><a href="#40312475">parent</a><span>|</span><a href="#40311675">next</a><span>|</span><label class="collapse" for="c-40313298">[-]</label><label class="expand" for="c-40313298">[2 more]</label></div><br/><div class="children"><div class="content">Confirmations are mostly useless unless you explicitly spell out the implications of the change. They are also inferior to being able to undo changes.<p>That&#x27;s a lesson many don&#x27;t know.</div><br/><div id="40315753" class="c"><input type="checkbox" id="c-40315753" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#40311522">root</a><span>|</span><a href="#40313298">parent</a><span>|</span><a href="#40311675">next</a><span>|</span><label class="collapse" for="c-40315753">[-]</label><label class="expand" for="c-40315753">[1 more]</label></div><br/><div class="children"><div class="content">Your time from commit to live is proportional to your rollback to a known good state. Maybe to a power of the rollback time.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40311675" class="c"><input type="checkbox" id="c-40311675" checked=""/><div class="controls bullet"><span class="by">skunkworker</span><span>|</span><a href="#40311522">parent</a><span>|</span><a href="#40311882">prev</a><span>|</span><a href="#40312089">next</a><span>|</span><label class="collapse" for="c-40311675">[-]</label><label class="expand" for="c-40311675">[1 more]</label></div><br/><div class="children"><div class="content">Don’t forget BGP or running out of disk space without an alert.</div><br/></div></div><div id="40312089" class="c"><input type="checkbox" id="c-40312089" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40311522">parent</a><span>|</span><a href="#40311675">prev</a><span>|</span><a href="#40312876">next</a><span>|</span><label class="collapse" for="c-40312089">[-]</label><label class="expand" for="c-40312089">[1 more]</label></div><br/><div class="children"><div class="content">When it fails, it&#x27;s DNS. When it just stops moving, it&#x27;s either TCP_NODELAY or stream buffering.<p>Really complex systems (the Web) also fail because of caching.</div><br/></div></div><div id="40312876" class="c"><input type="checkbox" id="c-40312876" checked=""/><div class="controls bullet"><span class="by">Sohcahtoa82</span><span>|</span><a href="#40311522">parent</a><span>|</span><a href="#40312089">prev</a><span>|</span><a href="#40311665">next</a><span>|</span><label class="collapse" for="c-40312876">[-]</label><label class="expand" for="c-40312876">[2 more]</label></div><br/><div class="children"><div class="content">I chuckle whenever I see this meme, because in my experience, the issue is usually DHCP.</div><br/><div id="40316153" class="c"><input type="checkbox" id="c-40316153" checked=""/><div class="controls bullet"><span class="by">anilakar</span><span>|</span><a href="#40311522">root</a><span>|</span><a href="#40312876">parent</a><span>|</span><a href="#40311665">next</a><span>|</span><label class="collapse" for="c-40316153">[-]</label><label class="expand" for="c-40316153">[1 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s usually DHCP that sets the wrong DNS servers.<p>It&#x27;s funny that some folks claim DNS outage is a legitimate issue in systems whose both ends they control. I get it; reimplementing functionality is rarely a good sign, but since you already know your own addresses in the first place, you should also have an internal mechanism for sharing them.</div><br/></div></div></div></div><div id="40311665" class="c"><input type="checkbox" id="c-40311665" checked=""/><div class="controls bullet"><span class="by">jeffrallen</span><span>|</span><a href="#40311522">parent</a><span>|</span><a href="#40312876">prev</a><span>|</span><a href="#40312247">next</a><span>|</span><label class="collapse" for="c-40311665">[-]</label><label class="expand" for="c-40311665">[1 more]</label></div><br/><div class="children"><div class="content">Once every 50 years and 2 billion kilometers, it&#x27;s a failing memory chip. But you can usually just patch around them, so no big deal.</div><br/></div></div><div id="40312247" class="c"><input type="checkbox" id="c-40312247" checked=""/><div class="controls bullet"><span class="by">rickydroll</span><span>|</span><a href="#40311522">parent</a><span>|</span><a href="#40311665">prev</a><span>|</span><a href="#40312609">next</a><span>|</span><label class="collapse" for="c-40312247">[-]</label><label class="expand" for="c-40312247">[1 more]</label></div><br/><div class="children"><div class="content">Not every time. Sometimes, the power cord is only connected at one end.</div><br/></div></div><div id="40312609" class="c"><input type="checkbox" id="c-40312609" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#40311522">parent</a><span>|</span><a href="#40312247">prev</a><span>|</span><a href="#40312221">next</a><span>|</span><label class="collapse" for="c-40312609">[-]</label><label class="expand" for="c-40312609">[1 more]</label></div><br/><div class="children"><div class="content">One time for me it was: the glass was dirty.<p>Some router near a construction site had dust settle into the gap between the laser and the fiber, and it attenuated the signal enough to see 40-50% packet loss.<p>We figured out where the loss was and had our NOC email the relevant transit provider. A day later we got an email back from the tech they dispatched with the story.</div><br/></div></div><div id="40312221" class="c"><input type="checkbox" id="c-40312221" checked=""/><div class="controls bullet"><span class="by">drivers99</span><span>|</span><a href="#40311522">parent</a><span>|</span><a href="#40312609">prev</a><span>|</span><a href="#40313160">next</a><span>|</span><label class="collapse" for="c-40312221">[-]</label><label class="expand" for="c-40312221">[1 more]</label></div><br/><div class="children"><div class="content">Or SELinux</div><br/></div></div></div></div><div id="40313160" class="c"><input type="checkbox" id="c-40313160" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#40311522">prev</a><span>|</span><a href="#40312363">next</a><span>|</span><label class="collapse" for="c-40313160">[-]</label><label class="expand" for="c-40313160">[4 more]</label></div><br/><div class="children"><div class="content">This is an interesting thing that points out why abstraction layers can be bad without proper message passing mechanisms.<p>This could be fixed if there was a way for the application at L7 to tell the TCP stack at L4 &quot;hey, I&#x27;m an interactive shell so I expect to have a lot of tiny packets, you should leave TCP_NODELAY on for these packets&quot; so that it can be off by default but on for that application to reduce overhead.<p>Of course nowadays it&#x27;s probably an unnecessary optimization anyway, but back in &#x27;84 it would have been super handy.</div><br/><div id="40313817" class="c"><input type="checkbox" id="c-40313817" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40313160">parent</a><span>|</span><a href="#40314533">next</a><span>|</span><label class="collapse" for="c-40313817">[-]</label><label class="expand" for="c-40313817">[2 more]</label></div><br/><div class="children"><div class="content">&quot;I&#x27;m an interactive shell so I expect to have a lot of tiny packets&quot; is what the delay is <i>for</i>.  If you want to turn it off for those, you should turn it off for everything.<p>(If you&#x27;re worried about programs that buffer badly, then you could compensate with a 1ms delay.  But not this round trip stuff.)</div><br/></div></div><div id="40314533" class="c"><input type="checkbox" id="c-40314533" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40313160">parent</a><span>|</span><a href="#40313817">prev</a><span>|</span><a href="#40312363">next</a><span>|</span><label class="collapse" for="c-40314533">[-]</label><label class="expand" for="c-40314533">[1 more]</label></div><br/><div class="children"><div class="content">The take-away I get is that abstraction layers (in the kernel) can be bad.<p>Operating system kernels should enable secure multiplexing of resources.  Abstraction and portability should be done via libraries.<p>See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exokernel" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exokernel</a></div><br/></div></div></div></div><div id="40312363" class="c"><input type="checkbox" id="c-40312363" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#40313160">prev</a><span>|</span><a href="#40315540">next</a><span>|</span><label class="collapse" for="c-40312363">[-]</label><label class="expand" for="c-40312363">[2 more]</label></div><br/><div class="children"><div class="content">I do wish that TCP_NODELAY was the default, and there was a TCP_DELAY option instead. That&#x27;d be a world in which people who <i>want</i> the batch-style behavior (optimizing for throughput and fewer packets at the expense of latency) could still opt into it.</div><br/><div id="40312638" class="c"><input type="checkbox" id="c-40312638" checked=""/><div class="controls bullet"><span class="by">mzs</span><span>|</span><a href="#40312363">parent</a><span>|</span><a href="#40315540">next</a><span>|</span><label class="collapse" for="c-40312638">[-]</label><label class="expand" for="c-40312638">[1 more]</label></div><br/><div class="children"><div class="content">So do I, but I with there was a new one TCP_RTTDELAY. It would take a byte that would be what 128th of RTT you want to use for Nagle instead of one RTT or full* buffer. 0 would be the default, behaving as you and I prefer.<p>* &quot;Given the vast amount of work a modern server can do in even a few hundred microseconds, delaying sending data for even one RTT isn’t clearly a win.&quot;<p>I don&#x27;t think that&#x27;s such an issue anymore either, given that the server produces so much data it fills the output buffer quickly anyway, the data is then immediately sent before the delay runs its course.</div><br/></div></div></div></div><div id="40315540" class="c"><input type="checkbox" id="c-40315540" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#40312363">prev</a><span>|</span><a href="#40311950">next</a><span>|</span><label class="collapse" for="c-40315540">[-]</label><label class="expand" for="c-40315540">[1 more]</label></div><br/><div class="children"><div class="content">From my blog &gt; 10 years ago but sadly still relevant:
&quot;Sockets should have a flushHint() API call.&quot;: <a href="https:&#x2F;&#x2F;forwardscattering.org&#x2F;post&#x2F;3" rel="nofollow">https:&#x2F;&#x2F;forwardscattering.org&#x2F;post&#x2F;3</a></div><br/></div></div><div id="40311950" class="c"><input type="checkbox" id="c-40311950" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#40315540">prev</a><span>|</span><a href="#40311441">next</a><span>|</span><label class="collapse" for="c-40311950">[-]</label><label class="expand" for="c-40311950">[9 more]</label></div><br/><div class="children"><div class="content">John Nagle has posted insightful comments about the historical background for this many times, for example <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9048947">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9048947</a> referenced in the article. He&#x27;s a prolific HN commenter (#11 on the leaderboard) so it can be hard to find everything, but some more comments searchable via <a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;query=%22delayed%20ack%22%20%22animats%22&amp;sort=byDate&amp;type=comment" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;que...</a> or <a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;query=%22tcp_nodelay%22%20%22animats%22&amp;sort=byDate&amp;type=comment" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;que...</a></div><br/><div id="40312687" class="c"><input type="checkbox" id="c-40312687" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40311950">parent</a><span>|</span><a href="#40313397">next</a><span>|</span><label class="collapse" for="c-40312687">[-]</label><label class="expand" for="c-40312687">[2 more]</label></div><br/><div class="children"><div class="content">The sending pattern matters. Send&#x2F;Receive&#x2F;Send&#x2F;Receive won&#x27;t trigger the problem, because the request will go out immediately and the reply will provide an ACK and allow another request. Bulk transfers won&#x27;t cause the problem, because if you fill the outgoing block size, there&#x27;s no delay.<p>But Send&#x2F;Send&#x2F;Receive will. This comes up a lot in game systems, where most of the traffic is small events going one way.</div><br/><div id="40315958" class="c"><input type="checkbox" id="c-40315958" checked=""/><div class="controls bullet"><span class="by">pipe01</span><span>|</span><a href="#40311950">root</a><span>|</span><a href="#40312687">parent</a><span>|</span><a href="#40313397">next</a><span>|</span><label class="collapse" for="c-40315958">[-]</label><label class="expand" for="c-40315958">[1 more]</label></div><br/><div class="children"><div class="content">I would imagine that games that require exotic sending patterns would use UDP, giving them more control over the protocol</div><br/></div></div></div></div><div id="40313397" class="c"><input type="checkbox" id="c-40313397" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#40311950">parent</a><span>|</span><a href="#40312687">prev</a><span>|</span><a href="#40311441">next</a><span>|</span><label class="collapse" for="c-40313397">[-]</label><label class="expand" for="c-40313397">[6 more]</label></div><br/><div class="children"><div class="content">I love it when Nagle&#x27;s algorithm comes up on HN. Inevitably someone, not knowing &quot;Animats&quot; is John Nagle, responds a comment from Animats with a &quot;knowing better&quot; tone. &gt;smile&lt;<p>(I also really like Animats&#x27; comments, too.)</div><br/><div id="40316710" class="c"><input type="checkbox" id="c-40316710" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#40311950">root</a><span>|</span><a href="#40313397">parent</a><span>|</span><a href="#40313626">next</a><span>|</span><label class="collapse" for="c-40316710">[-]</label><label class="expand" for="c-40316710">[1 more]</label></div><br/><div class="children"><div class="content">It is like when someone here accused Andres Freund (PostgreSQL core dev who recently became famous due to the xz backdoor) of Dunning–Kruger when he had commented on something related to PostgreSQL&#x27;s architecture which he had spent many many hours working on personally (I think it was pluggable storage).<p>Maybe you just tried to educate the leading expert in the world on his own expertise. :D</div><br/></div></div><div id="40313626" class="c"><input type="checkbox" id="c-40313626" checked=""/><div class="controls bullet"><span class="by">geoelectric</span><span>|</span><a href="#40311950">root</a><span>|</span><a href="#40313397">parent</a><span>|</span><a href="#40316710">prev</a><span>|</span><a href="#40315573">next</a><span>|</span><label class="collapse" for="c-40313626">[-]</label><label class="expand" for="c-40313626">[3 more]</label></div><br/><div class="children"><div class="content">I have to confess that when I saw this post, I quickly skimmed the threads to check if someone was trying to educate Animats on TCP. Think I&#x27;ve only seen that happen in the wild once or twice, but it absolutely made my day when it did.</div><br/><div id="40315413" class="c"><input type="checkbox" id="c-40315413" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#40311950">root</a><span>|</span><a href="#40313626">parent</a><span>|</span><a href="#40315573">next</a><span>|</span><label class="collapse" for="c-40315413">[-]</label><label class="expand" for="c-40315413">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always the highlight of my day when it happens, almost as nice as when someone chimes in to educate John Carmack on 3D graphics and VR technology.</div><br/></div></div></div></div><div id="40315573" class="c"><input type="checkbox" id="c-40315573" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40311950">root</a><span>|</span><a href="#40313397">parent</a><span>|</span><a href="#40313626">prev</a><span>|</span><a href="#40311441">next</a><span>|</span><label class="collapse" for="c-40315573">[-]</label><label class="expand" for="c-40315573">[1 more]</label></div><br/><div class="children"><div class="content">I always check if the man himself makes an appearance every time I see that. He has posted a few comments in here already.</div><br/></div></div></div></div></div></div><div id="40311441" class="c"><input type="checkbox" id="c-40311441" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#40311950">prev</a><span>|</span><a href="#40311836">next</a><span>|</span><label class="collapse" for="c-40311441">[-]</label><label class="expand" for="c-40311441">[2 more]</label></div><br/><div class="children"><div class="content">We used to call them &quot;packlets.&quot;<p>His &quot;tinygrams&quot; is pretty good too, but that sort of implies UDP (D -&gt; datagrams)</div><br/><div id="40312358" class="c"><input type="checkbox" id="c-40312358" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#40311441">parent</a><span>|</span><a href="#40311836">next</a><span>|</span><label class="collapse" for="c-40312358">[-]</label><label class="expand" for="c-40312358">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We used to call them &quot;packlets.&quot;<p>setsockopt(fd, IPPROTO_TCP, TCP_MAKE_IT_GO, &amp;go, sizeof(go));</div><br/></div></div></div></div><div id="40311836" class="c"><input type="checkbox" id="c-40311836" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#40311441">prev</a><span>|</span><a href="#40314525">next</a><span>|</span><label class="collapse" for="c-40311836">[-]</label><label class="expand" for="c-40311836">[6 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t it have &quot;if payload is 1 byte (or less than X) then wait, otherwise don&#x27;t&quot; condition?</div><br/><div id="40311981" class="c"><input type="checkbox" id="c-40311981" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#40311836">parent</a><span>|</span><a href="#40312424">next</a><span>|</span><label class="collapse" for="c-40311981">[-]</label><label class="expand" for="c-40311981">[1 more]</label></div><br/><div class="children"><div class="content">Some network stacks like those in Solaris and HP&#x2F;UX let you tune the &quot;Nagle limit&quot; in just such a fashion, up to disabling it entirely by setting it to 1.  I&#x27;m not aware of it being tunable on Linux, though you can manually control the buffering using TCP_CORK. <a href="https:&#x2F;&#x2F;baus.net&#x2F;on-tcp_cork&#x2F;" rel="nofollow">https:&#x2F;&#x2F;baus.net&#x2F;on-tcp_cork&#x2F;</a> has some nice details.</div><br/></div></div><div id="40312424" class="c"><input type="checkbox" id="c-40312424" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#40311836">parent</a><span>|</span><a href="#40311981">prev</a><span>|</span><a href="#40312156">next</a><span>|</span><label class="collapse" for="c-40312424">[-]</label><label class="expand" for="c-40312424">[1 more]</label></div><br/><div class="children"><div class="content">How is what you&#x27;re describing not just Nagle&#x27;s algorithm?<p>If you mean TCP_NODELAY, you should use it with TCP_CORK, which prevents partial frames. TCP_CORK the socket, do your writes to the kernel via send, and then once you have an application level &quot;message&quot; ready to send out — i.e., once you&#x27;re at the point where you&#x27;re going to go to sleep and wait for the other end to respond, unset TCP_CORK &amp; then go back to your event loop &amp; sleep. The &quot;uncork&quot; at the end + nodelay sends the final partial frame, if there is one.</div><br/></div></div><div id="40312156" class="c"><input type="checkbox" id="c-40312156" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40311836">parent</a><span>|</span><a href="#40312424">prev</a><span>|</span><a href="#40312172">next</a><span>|</span><label class="collapse" for="c-40312156">[-]</label><label class="expand" for="c-40312156">[1 more]</label></div><br/><div class="children"><div class="content">There is a socket option, SO_SNDLOWAT. It&#x27;s not implement Linux according to the manual page. The description in UNIX Network Programming and TCP Illustrated conflict, too. So it&#x27;s probably not useful.</div><br/></div></div><div id="40312172" class="c"><input type="checkbox" id="c-40312172" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#40311836">parent</a><span>|</span><a href="#40312156">prev</a><span>|</span><a href="#40312269">next</a><span>|</span><label class="collapse" for="c-40312172">[-]</label><label class="expand" for="c-40312172">[1 more]</label></div><br/><div class="children"><div class="content">You can buffer in userspace. Don&#x27;t do small writes to the socket and no bytes will be sent. Don&#x27;t do two consecutive small writes and nagle won&#x27;t kick in.</div><br/></div></div><div id="40312269" class="c"><input type="checkbox" id="c-40312269" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40311836">parent</a><span>|</span><a href="#40312172">prev</a><span>|</span><a href="#40314525">next</a><span>|</span><label class="collapse" for="c-40312269">[-]</label><label class="expand" for="c-40312269">[1 more]</label></div><br/><div class="children"><div class="content">FreeBSD has accept filters, which let you do something like wait for a complete HTTP header (inaccurate from memory summary.) Not sure about the sending side.</div><br/></div></div></div></div><div id="40314525" class="c"><input type="checkbox" id="c-40314525" checked=""/><div class="controls bullet"><span class="by">projectileboy</span><span>|</span><a href="#40311836">prev</a><span>|</span><a href="#40312871">next</a><span>|</span><label class="collapse" for="c-40314525">[-]</label><label class="expand" for="c-40314525">[1 more]</label></div><br/><div class="children"><div class="content">The real issue in modern data centers is TCP. Of course at present, we need to know about these little annoyances at the application layer, but what we really need is innovation in the data center at level 4. And yes I know that many people are looking into this and have been for years, but the economic motivation clearly has not yet been strong enough. But that may change if the public&#x27;s appetite for LLM-based tooling causes data centers to increase 10x (which seems likely).</div><br/></div></div><div id="40312871" class="c"><input type="checkbox" id="c-40312871" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#40314525">prev</a><span>|</span><a href="#40314063">next</a><span>|</span><label class="collapse" for="c-40312871">[-]</label><label class="expand" for="c-40312871">[1 more]</label></div><br/><div class="children"><div class="content">Nagle and no delay are like like 90+% of the latency bugs I’ve dealt with.<p>Two reasonable ideas that mix terribly in practice.</div><br/></div></div><div id="40314063" class="c"><input type="checkbox" id="c-40314063" checked=""/><div class="controls bullet"><span class="by">ryjo</span><span>|</span><a href="#40312871">prev</a><span>|</span><a href="#40315062">next</a><span>|</span><label class="collapse" for="c-40314063">[-]</label><label class="expand" for="c-40314063">[1 more]</label></div><br/><div class="children"><div class="content">I just ran into this this week implementing a socket library in CLIPS. I used Berkley sockets, and before that I had only worked with higher-level languages&#x2F;frameworks that abstracts a lot of these concerns away. I was quite confused when Firefox would show a &quot;connection reset by peer.&quot; It didn&#x27;t occur to me it could be an issue &quot;lower&quot; in the stack. `tcpdump` helped me to observe the port and I saw that the server never sent anything before my application closed the connection.</div><br/></div></div><div id="40315062" class="c"><input type="checkbox" id="c-40315062" checked=""/><div class="controls bullet"><span class="by">ramblemonkey</span><span>|</span><a href="#40314063">prev</a><span>|</span><a href="#40313860">next</a><span>|</span><label class="collapse" for="c-40315062">[-]</label><label class="expand" for="c-40315062">[2 more]</label></div><br/><div class="children"><div class="content">What if we changed the kernel or tcp stack to hold on to the packet for only a short time before sending it out. This could allow you to balance the latency against the network cost of many small packets. The tcp stack could even do it dynamically if needed.</div><br/><div id="40316446" class="c"><input type="checkbox" id="c-40316446" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#40315062">parent</a><span>|</span><a href="#40313860">next</a><span>|</span><label class="collapse" for="c-40316446">[-]</label><label class="expand" for="c-40316446">[1 more]</label></div><br/><div class="children"><div class="content">Genius</div><br/></div></div></div></div><div id="40313860" class="c"><input type="checkbox" id="c-40313860" checked=""/><div class="controls bullet"><span class="by">kaoD</span><span>|</span><a href="#40315062">prev</a><span>|</span><a href="#40313514">next</a><span>|</span><label class="collapse" for="c-40313860">[-]</label><label class="expand" for="c-40313860">[2 more]</label></div><br/><div class="children"><div class="content">As a counterpoint, here&#x27;s the story of how for me it wasn&#x27;t TCP_NODELAY: for some reason my Nodejs TCP service was talking a few seconds to reply to my requests in localhost (Windows machine). After the connection was established everything was pretty normal but it consistently took a few seconds to establish the connection.<p>I even downloaded netcat for Windows to go as bare ones as possible... and the exact same thing happened.<p>I rewrote a POC service in Rust and... oh wow, the same thing happens.<p>It took me a very long time of not finding anything on the internet (and getting yelled at in Stack Overflow, or rather one of its sister sites) and painstakingly debugging (including writing my own tiny client with tons of debug statements) until I realized &quot;localhost&quot; was resolving first to IPv6 loopback in Windows and, only after quietly timing out there (because I was only listening on IPv4 loopback), it did try and instantly connect through IPv4.</div><br/><div id="40316448" class="c"><input type="checkbox" id="c-40316448" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40313860">parent</a><span>|</span><a href="#40313514">next</a><span>|</span><label class="collapse" for="c-40316448">[-]</label><label class="expand" for="c-40316448">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen this too, but luckily someone one the internet gave me a pointer to the exact problem so I didn&#x27;t have to go deep to figure out.</div><br/></div></div></div></div><div id="40313514" class="c"><input type="checkbox" id="c-40313514" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#40313860">prev</a><span>|</span><a href="#40314546">next</a><span>|</span><label class="collapse" for="c-40313514">[-]</label><label class="expand" for="c-40313514">[1 more]</label></div><br/><div class="children"><div class="content">I was curious whether I had to change anything in my applications after reading that so did a bit of research.<p>Both Node.js and Curl use TCP_NODELAY by default from a long time.</div><br/></div></div><div id="40314546" class="c"><input type="checkbox" id="c-40314546" checked=""/><div class="controls bullet"><span class="by">maple3142</span><span>|</span><a href="#40313514">prev</a><span>|</span><a href="#40314892">next</a><span>|</span><label class="collapse" for="c-40314546">[-]</label><label class="expand" for="c-40314546">[5 more]</label></div><br/><div class="children"><div class="content">Not sure if this is a bit off topic or not, but I recently encountered a problem where my program are continuously calling write to a socket in a loop that loops N times, with each of them sending about a few hundred bytes of data representing an application-level message. The loop can be understanded as some &quot;batched messages&quot; to server. After that, the program will try to receive data from server and do some processing.<p>The problem is that if N is above certain limit (e.g. 4), the server will resulting in some error saying that the data is truncated somehow. I want to make N larger because the round-trip latency is already high enough, so being blocked by this is pretty annoying. Eventually, I found an answer on stackoverflow saying that setting TCP_NODELAY can fix this, and it actually magically enable be to increase N to a larger number like 64 or 128 without causing issues. Still not sure why TCP_NODELAY can fix this issue and why this problem happens in the first place.</div><br/><div id="40314646" class="c"><input type="checkbox" id="c-40314646" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#40314546">parent</a><span>|</span><a href="#40314610">next</a><span>|</span><label class="collapse" for="c-40314646">[-]</label><label class="expand" for="c-40314646">[3 more]</label></div><br/><div class="children"><div class="content">My guess would be that the server assumes that every call to recv() terminates on a message boundary.<p>With TCP_NODELAY and small messages, this works out fine. Every message is contained in a single packet, and the userspace buffer being read into is large enough to contain it. As such, whenever the kernel has any data to give to userspace, it has an integer number of messages to give. Nothing requires the kernel to respect that, but it will not go out of its way to break it.<p>In contrast, without TCP_NODELAY, messages get concatenated and then fragmented based on where packet boundaries occur. Now, the natural end point for a call to recv() is not the message boundary, but the packet boundary.<p>The server is supposed to see that it is in the middle of a message, and make another call to recv() to get the rest of it; but clearly it does not do that.</div><br/><div id="40315045" class="c"><input type="checkbox" id="c-40315045" checked=""/><div class="controls bullet"><span class="by">caf</span><span>|</span><a href="#40314546">root</a><span>|</span><a href="#40314646">parent</a><span>|</span><a href="#40314610">next</a><span>|</span><label class="collapse" for="c-40315045">[-]</label><label class="expand" for="c-40315045">[2 more]</label></div><br/><div class="children"><div class="content">Otherwise known as the &quot;TCP is a stream-based abstraction, not a packet-based abstraction&quot; bug.<p>A related one is failing to process the second of two complete commands that happen to arrive in the same recv() call.</div><br/><div id="40315925" class="c"><input type="checkbox" id="c-40315925" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#40314546">root</a><span>|</span><a href="#40315045">parent</a><span>|</span><a href="#40314610">next</a><span>|</span><label class="collapse" for="c-40315925">[-]</label><label class="expand" for="c-40315925">[1 more]</label></div><br/><div class="children"><div class="content">I find these bugs to be a sign that the app is not using a good wrapper but just mostly gets lucky that the packet isn’t split randomly on the way.</div><br/></div></div></div></div></div></div><div id="40314610" class="c"><input type="checkbox" id="c-40314610" checked=""/><div class="controls bullet"><span class="by">blahgeek</span><span>|</span><a href="#40314546">parent</a><span>|</span><a href="#40314646">prev</a><span>|</span><a href="#40314892">next</a><span>|</span><label class="collapse" for="c-40314610">[-]</label><label class="expand" for="c-40314610">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The problem is that if N is above certain limit (e.g. 4), the server will resulting in some error saying that the data is truncated somehow.<p>Maybe your server expects full application-level messages from single &quot;recv&quot; call? This is is not correct. A message may be spited across multiple recv buffers.</div><br/></div></div></div></div><div id="40314352" class="c"><input type="checkbox" id="c-40314352" checked=""/><div class="controls bullet"><span class="by">meisel</span><span>|</span><a href="#40314892">prev</a><span>|</span><a href="#40311944">next</a><span>|</span><label class="collapse" for="c-40314352">[-]</label><label class="expand" for="c-40314352">[1 more]</label></div><br/><div class="children"><div class="content">Is this something I should also adjust on my personal Ubuntu machine for better network performance?</div><br/></div></div><div id="40311944" class="c"><input type="checkbox" id="c-40311944" checked=""/><div class="controls bullet"><span class="by">elhosots</span><span>|</span><a href="#40314352">prev</a><span>|</span><a href="#40313633">next</a><span>|</span><label class="collapse" for="c-40311944">[-]</label><label class="expand" for="c-40311944">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like the root of my vncviewer &#x2F; server interaction bugs i experience with some vnc viewer&#x2F;server combo’s between ubuntu linux and freebsd… (tight&#x2F;tiger)</div><br/></div></div><div id="40313633" class="c"><input type="checkbox" id="c-40313633" checked=""/><div class="controls bullet"><span class="by">gafferongames</span><span>|</span><a href="#40311944">prev</a><span>|</span><a href="#40313031">next</a><span>|</span><label class="collapse" for="c-40313633">[-]</label><label class="expand" for="c-40313633">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always TCP_NODELAY. Except when it&#x27;s head of line blocking, then it&#x27;s not.</div><br/></div></div><div id="40313031" class="c"><input type="checkbox" id="c-40313031" checked=""/><div class="controls bullet"><span class="by">tempaskhn</span><span>|</span><a href="#40313633">prev</a><span>|</span><a href="#40313978">next</a><span>|</span><label class="collapse" for="c-40313031">[-]</label><label class="expand" for="c-40313031">[1 more]</label></div><br/><div class="children"><div class="content">Wow, never would have thought of that.</div><br/></div></div><div id="40313978" class="c"><input type="checkbox" id="c-40313978" checked=""/><div class="controls bullet"><span class="by">pandemicsyn</span><span>|</span><a href="#40313031">prev</a><span>|</span><a href="#40315585">next</a><span>|</span><label class="collapse" for="c-40313978">[-]</label><label class="expand" for="c-40313978">[1 more]</label></div><br/><div class="children"><div class="content">I was gonna say its always lro offload but my experience is dated.</div><br/></div></div><div id="40315585" class="c"><input type="checkbox" id="c-40315585" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40313978">prev</a><span>|</span><label class="collapse" for="c-40315585">[-]</label><label class="expand" for="c-40315585">[1 more]</label></div><br/><div class="children"><div class="content">Apropos repost from 2015:<p>&gt; That still irks me. The real problem is not tinygram prevention. It&#x27;s ACK delays, and that stupid fixed timer. They both went into TCP around the same time, but independently. I did tinygram prevention (the Nagle algorithm) and Berkeley did delayed ACKs, both in the early 1980s. The combination of the two is awful. Unfortunately by the time I found about delayed ACKs, I had changed jobs, was out of networking, and doing a product for Autodesk on non-networked PCs.<p>&gt; Delayed ACKs are a win only in certain circumstances - mostly character echo for Telnet. (When Berkeley installed delayed ACKs, they were doing a lot of Telnet from terminal concentrators in student terminal rooms to host VAX machines doing the work. For that particular situation, it made sense.) The delayed ACK timer is scaled to expected human response time. A delayed ACK is a bet that the other end will reply to what you just sent almost immediately. Except for some RPC protocols, this is unlikely. So the ACK delay mechanism loses the bet, over and over, delaying the ACK, waiting for a packet on which the ACK can be piggybacked, not getting it, and then sending the ACK, delayed. There&#x27;s nothing in TCP to automatically turn this off. However, Linux (and I think Windows) now have a TCP_QUICKACK socket option. Turn that on unless you have a very unusual application.<p>&gt; Turning on TCP_NODELAY has similar effects, but can make throughput worse for small writes. If you write a loop which sends just a few bytes (worst case, one byte) to a socket with &quot;write()&quot;, and the Nagle algorithm is disabled with TCP_NODELAY, each write becomes one IP packet. This increases traffic by a factor of 40, with IP and TCP headers for each payload. Tinygram prevention won&#x27;t let you send a second packet if you have one in flight, unless you have enough data to fill the maximum sized packet. It accumulates bytes for one round trip time, then sends everything in the queue. That&#x27;s almost always what you &gt; want. If you have TCP_NODELAY set, you need to be much more aware of buffering and flushing issues.<p>&gt; None of this matters for bulk one-way transfers, which is most HTTP today. (I&#x27;ve never looked at the impact of this on the SSL handshake, where it might matter.)<p>&gt; Short version: set TCP_QUICKACK. If you find a case where that makes things worse, let me know.<p>&gt; John Nagle<p>(2015)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10608356">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10608356</a><p>---<p>Support platform survey:<p>TCP_QUICKACK: Linux (must set again every every recv())<p>TCP_NODELAY: Linux, Apple, Windows, Solaris, FreeBSD, OpenBSD, and NetBSD<p>References:<p><a href="https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;tcp.7.html" rel="nofollow">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;tcp.7.html</a><p><a href="https:&#x2F;&#x2F;opensource.apple.com&#x2F;source&#x2F;xnu&#x2F;xnu-1504.9.17&#x2F;bsd&#x2F;netinet&#x2F;tcp.h.auto.html" rel="nofollow">https:&#x2F;&#x2F;opensource.apple.com&#x2F;source&#x2F;xnu&#x2F;xnu-1504.9.17&#x2F;bsd&#x2F;ne...</a><p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;winsock&#x2F;ipproto-tcp-socket-options" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;winsock&#x2F;ippr...</a><p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;E88353_01&#x2F;html&#x2F;E37851&#x2F;esc-tcp-4p.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;E88353_01&#x2F;html&#x2F;E37851&#x2F;esc-tcp-4p....</a><p><a href="https:&#x2F;&#x2F;man.freebsd.org&#x2F;cgi&#x2F;man.cgi?query=tcp" rel="nofollow">https:&#x2F;&#x2F;man.freebsd.org&#x2F;cgi&#x2F;man.cgi?query=tcp</a><p><a href="https:&#x2F;&#x2F;man.openbsd.org&#x2F;tcp" rel="nofollow">https:&#x2F;&#x2F;man.openbsd.org&#x2F;tcp</a><p><a href="https:&#x2F;&#x2F;man.netbsd.org&#x2F;NetBSD-8.0&#x2F;tcp.4" rel="nofollow">https:&#x2F;&#x2F;man.netbsd.org&#x2F;NetBSD-8.0&#x2F;tcp.4</a></div><br/></div></div></div></div></div></div></div></body></html>