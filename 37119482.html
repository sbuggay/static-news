<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692090071808" as="style"/><link rel="stylesheet" href="styles.css?v=1692090071808"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://stefan-marr.de/downloads/oopsla23-larose-et-al-ast-vs-bytecode-interpreters-in-the-age-of-meta-compilation.pdf">AST vs. Bytecode: Interpreters in the Age of Meta-Compilation [pdf]</a> <span class="domain">(<a href="https://stefan-marr.de">stefan-marr.de</a>)</span></div><div class="subtext"><span>mpweiher</span> | <span>8 comments</span></div><br/><div><div id="37130533" class="c"><input type="checkbox" id="c-37130533" checked=""/><div class="controls bullet"><span class="by">punnerud</span><span>|</span><label class="collapse" for="c-37130533">[-]</label><label class="expand" for="c-37130533">[7 more]</label></div><br/><div class="children"><div class="content">Fun fact, Python give you access to AST:
<a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;ast.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;ast.html</a><p>You can easily check that Python Dict is just keys and pointers to values:
Dict(expr* keys, expr* values)</div><br/><div id="37130634" class="c"><input type="checkbox" id="c-37130634" checked=""/><div class="controls bullet"><span class="by">sottol</span><span>|</span><a href="#37130533">parent</a><span>|</span><label class="collapse" for="c-37130634">[-]</label><label class="expand" for="c-37130634">[6 more]</label></div><br/><div class="children"><div class="content">These features are always nice for meta-magic and monkey-patching but those are usually exactly the reasons why a language can only be optimized so much. It&#x27;s often a worthwhile tradeoff but needs to be carefully considered.</div><br/><div id="37131543" class="c"><input type="checkbox" id="c-37131543" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#37130533">root</a><span>|</span><a href="#37130634">parent</a><span>|</span><a href="#37130749">next</a><span>|</span><label class="collapse" for="c-37131543">[-]</label><label class="expand" for="c-37131543">[1 more]</label></div><br/><div class="children"><div class="content">These features with the option to declare not to use them in a piece of code  that are the reasons why language don&#x27;t have to make trade-offs.<p>Common Lisp has  good balance in this regard.</div><br/></div></div><div id="37130749" class="c"><input type="checkbox" id="c-37130749" checked=""/><div class="controls bullet"><span class="by">amno</span><span>|</span><a href="#37130533">root</a><span>|</span><a href="#37130634">parent</a><span>|</span><a href="#37131543">prev</a><span>|</span><label class="collapse" for="c-37130749">[-]</label><label class="expand" for="c-37130749">[4 more]</label></div><br/><div class="children"><div class="content">Is &quot;meta-magic&quot; and &quot;monkey-patching&quot; what we mortals call code generation and which is an useful technique to automate coding and which can both save time and generate safer and more correct code or is it something else?</div><br/><div id="37131136" class="c"><input type="checkbox" id="c-37131136" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37130533">root</a><span>|</span><a href="#37130749">parent</a><span>|</span><a href="#37130773">next</a><span>|</span><label class="collapse" for="c-37131136">[-]</label><label class="expand" for="c-37131136">[1 more]</label></div><br/><div class="children"><div class="content">There are many ways to do code generation. For example, you can have one program write out text files that a compiler reads to create another program. Or you can have a program change itself while it&#x27;s running. These represent two extremes on a static to dynamic continuum. Most &quot;dynamic&quot; languages like Ruby and Python take the latter approach. This approach is hard to reason about, for both an optimizing runtime and a human, and is one reason Python and Ruby have such poor performance.<p>A better approach is a language with phases. There is a description of the general idea on the home page of one of the authors: <a href="https:&#x2F;&#x2F;www.kent.ac.uk&#x2F;computing&#x2F;people&#x2F;3165&#x2F;kaleba-sophie" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.kent.ac.uk&#x2F;computing&#x2F;people&#x2F;3165&#x2F;kaleba-sophie</a><p>Their work seems to focus on discovering phases. IMO it&#x27;s better if the language allows the programmer to express phases as a language concept. There are a few languages that support this. Racket is the best example I know of.<p>Many programs already implicitly have phases. For example, a typical web app has one phase at what is traditionally thought of at compile time, then another at startup when it reads it&#x27;s configuration, and then another phase when it starts running. We smoosh together the last two phases into one &quot;run time&quot; because our languages usually don&#x27;t support phases, but actually the configuration is known earlier: at deployment time. So we could run that phase as part of the CI &#x2F; CD process and catch configuration errors earlier. Once you start thinking of phases you see them everywhere. They&#x27;re in data science (loading data vs exploring data), front-end web apps (&quot;hydration&quot;), etc. I think it&#x27;s a large productivity gain that is unexplored in commercial programming.</div><br/></div></div><div id="37130773" class="c"><input type="checkbox" id="c-37130773" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#37130533">root</a><span>|</span><a href="#37130749">parent</a><span>|</span><a href="#37131136">prev</a><span>|</span><a href="#37130771">next</a><span>|</span><label class="collapse" for="c-37130773">[-]</label><label class="expand" for="c-37130773">[1 more]</label></div><br/><div class="children"><div class="content">It’s something else. Monkey patching comes from Ruby, since classes are open, you can change implementations at runtime. I’m not quite as familiar with meta magic, but I believe it has similar characteristics. Sorta like dynamically injected accessors via autoload in perl.<p>There are cool tricks, but they come at a cost. Both for the reader of code, and the compiler of code.</div><br/></div></div><div id="37130771" class="c"><input type="checkbox" id="c-37130771" checked=""/><div class="controls bullet"><span class="by">fake-name</span><span>|</span><a href="#37130533">root</a><span>|</span><a href="#37130749">parent</a><span>|</span><a href="#37130773">prev</a><span>|</span><label class="collapse" for="c-37130771">[-]</label><label class="expand" for="c-37130771">[1 more]</label></div><br/><div class="children"><div class="content">Not quite.<p>Meta-magic <i>can</i> include code-gen, but monkey-patching can include effectively doing ast-ast transforms to change the behaviour of existing code without having to actually edit the code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>