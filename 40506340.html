<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716973278411" as="style"/><link rel="stylesheet" href="styles.css?v=1716973278411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mail.openjdk.org/pipermail/jdk-dev/2024-May/009028.html">Proposal to change default annotation processing policy in JDK 23</a> <span class="domain">(<a href="https://mail.openjdk.org">mail.openjdk.org</a>)</span></div><div class="subtext"><span>mfiguiere</span> | <span>38 comments</span></div><br/><div><div id="40509373" class="c"><input type="checkbox" id="c-40509373" checked=""/><div class="controls bullet"><span class="by">giamma</span><span>|</span><a href="#40509411">next</a><span>|</span><label class="collapse" for="c-40509373">[-]</label><label class="expand" for="c-40509373">[2 more]</label></div><br/><div class="children"><div class="content">&quot;This policy of implicitly running annotation processors by default may have been reasonable when the feature was introduced in JDK 6 circa 2006, but from 
a current perspective, in the interest of making build output more 
robust against annotation processors unintentionally being placed on the 
class path, the policy should not be the default anymore.&quot;<p>This makes sense, especially in light of the growing number of supply chain attacks. However, given how many libraries a typical Java application has in the classpath, most of which are transitive dependencies of popular frameworks, I foresee many build jobs not producing working binaries anymore when JDK23 is adopted. Plus, I&#x27;d love to be proven wrong, but I could bet that most people will fix the issue by simply adding the &quot;all-on&quot; switch to the command line instead of carefully evaluating which annotation processors are really needed by their codebase. So I am afraid that in the long term this change will not improve security or reduce build times. Unless maybe JDK 23 comes with some tool to print a catalogue of the annotation processors found in the classpath, with their respective purpose and documentation, so that developers can make an educated guess about what they need or don&#x27;t need.</div><br/><div id="40509683" class="c"><input type="checkbox" id="c-40509683" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#40509373">parent</a><span>|</span><a href="#40509411">next</a><span>|</span><label class="collapse" for="c-40509683">[-]</label><label class="expand" for="c-40509683">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but I could bet that most people will fix the issue by simply adding the &quot;all-on&quot; switch to the command line<p>Definitely this. This is a dev experience problem.<p>&gt; Unless maybe JDK 23 comes with some tool to print a catalogue of the annotation processors found in the classpath, with their respective purpose and documentation, so that developers can make an educated guess about what they need or don&#x27;t need.<p>My thoughts on as to how a solution to the dev-x problem might look like go in the same direction: have a way to provide a file with an accept list, another file with a deny list (vetoing accept list entries when matching both) and, this would be the key devx feature, a mode to automatically populate the accept list file from the full scan. Teams who&#x27;d be tempted to run the &quot;all-on&quot; mode could keep it running on auto-populate accept file, put the auto-populated accept file in versioning and see additions to the processor zoo in commits. And de-trusting a processor (or speeding up the build) would be as easy as copying a line to the deny file.<p>Minor improvement that would probably come up at some point: the auto-generated accept file should better <i>not</i> automatically exclude entries exluded by the deny file so that replacing the deny with a subset from accept remains a straight-forward option, but chances are you might encounter some situations where some dev environments have a processor that other build environments don&#x27;t have (this would not exist in a perfect world..) and that would cause undesirable changes to the auto-generated accept file. So you&#x27;d want a stronger deny option that forbids already during the scan, either with some special syntax in the deny file or (better I think) an optional file for &quot;even higher priority deny&quot;.<p>As to auto-generating documentation for the educated guess: clearly a trade-off between content and conciseness. My vote would be offering a way for processors that want to be helpful (or misleading, in the attack scenario!) to supply text for trailing line comments in the auto-generated accept file. For teams who do want to use the auto option. (trailing line comments are such an under-utilized magic compromise for conciseness&#x2F;volume conflicts, probably because they aren&#x27;t for readers running their editors with auto-wrap)</div><br/></div></div></div></div><div id="40509411" class="c"><input type="checkbox" id="c-40509411" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#40509373">prev</a><span>|</span><a href="#40509550">next</a><span>|</span><label class="collapse" for="c-40509411">[-]</label><label class="expand" for="c-40509411">[2 more]</label></div><br/><div class="children"><div class="content">&gt; As of the April 2024 JDK security updates, support for the &quot;-proc:full&quot; option has been backported to 17u (17.0.11) and 11u (11.0.23) for both Oracle JDK and OpenJDK distributions.<p>Someone tell me again how LTS isn&#x27;t a think for OpenJDK.</div><br/><div id="40509722" class="c"><input type="checkbox" id="c-40509722" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#40509411">parent</a><span>|</span><a href="#40509550">next</a><span>|</span><label class="collapse" for="c-40509722">[-]</label><label class="expand" for="c-40509722">[1 more]</label></div><br/><div class="children"><div class="content">I read this as &quot;the updated versions can now tolerate the option that makes future versions behave the same without calling out an error: invalid flag&quot;<p>This is exactly how you want an LTS to be supported long term.</div><br/></div></div></div></div><div id="40509550" class="c"><input type="checkbox" id="c-40509550" checked=""/><div class="controls bullet"><span class="by">foobarkey</span><span>|</span><a href="#40509411">prev</a><span>|</span><a href="#40506954">next</a><span>|</span><label class="collapse" for="c-40509550">[-]</label><label class="expand" for="c-40509550">[1 more]</label></div><br/><div class="children"><div class="content">Mixed feelings about this one, now every project has to start tweaking compiler options for lombok etc, I kind of like how it works out of the box.<p>I guess if you have a crazy project and a lot of transitive dependencies there is a small chance some processor lands on the classpath accidently and starts processing things, but I have not ran into this in practice</div><br/></div></div><div id="40506954" class="c"><input type="checkbox" id="c-40506954" checked=""/><div class="controls bullet"><span class="by">MarkSweep</span><span>|</span><a href="#40509550">prev</a><span>|</span><a href="#40509664">next</a><span>|</span><label class="collapse" for="c-40506954">[-]</label><label class="expand" for="c-40506954">[31 more]</label></div><br/><div class="children"><div class="content">I assume this is to prevent a file-dropping attack, similar to DLL injection.<p>How hard is this to exploit in practice? Does javac include the current directory in the class path? Does it look in other directories that are easy for other users to drop files in?<p>Also, how much are people running javac directly? I would guess a lot of people use build tools like Gradle or Ant that limit the class path, right?</div><br/><div id="40507405" class="c"><input type="checkbox" id="c-40507405" checked=""/><div class="controls bullet"><span class="by">rzwitserloot</span><span>|</span><a href="#40506954">parent</a><span>|</span><a href="#40508728">next</a><span>|</span><label class="collapse" for="c-40507405">[-]</label><label class="expand" for="c-40507405">[20 more]</label></div><br/><div class="children"><div class="content">How hard is this to exploit in practice? Very - this is a silly update in OpenJDK&#x27;s war against things like Project Lombok.<p>It _seems_ easy to exploit: Just.. get any jar file containing an annotation processor on the classpath and it will be executed as part of `javac` - and almost every java build tool calls javac under the hood.<p>However, this is misleading: _if_ somebody with malicious intent manages to either sneak a jar file into the build dependencies somehow, or manages to libxz-style take control of a commonly used dependency, the damage is done. That jar will also be on the classpath when running the app. So now we&#x27;re running compromised code. Java is not a sandboxed thing, running malicious code inside a JVM is a bit like an XSS web attack: The game is lost. Totally and utterly.<p>The fact that javac runs annotation processors by default until JDK23 does mean that a compromised build chain now runs _during the build_, whereas starting with JDK23 they&#x27;ll only run when you run the app.<p>This doesn&#x27;t seem impactful to me; I&#x27;m having a hard time figuring out scenarios where this is meaningfully less bad. Developers tend to run the app they are writing. The odds a developer will build a source tree and never actually run what they built, seems insufficient to consider this a meaningful contribution to security.<p>CI servers might be a useful place to look for &#x27;systems that will run the build but will not run the app&#x27;, except - no. Just about every CI tool will run some tests, thus, running the app, thus, running the malicious code.<p>Which gets us back to: OpenJDK&#x27;s backwards-compatibility breaking crusade. The OpenJDK team has also broken reflection (you can no longer access anything in another module that wasn&#x27;t explicitly exported without command line switches, even though reflection used to be able to do this. Reflection has &#x27;CARE! You are accessing APis that were not designed to be messed with!&#x27; written on the tin. It&#x27;s.. the point of it). - same reasoning. &quot;For security&quot; without being particularly clear about how that update contributes to security. It&#x27;s not about &#x27;it is impossible to use reflection to cause serious damage&#x27; (it is very possible to do that, in fact). It&#x27;s more about: .... if you are running malicious code inside a JVM, we&#x27;ve got much, much bigger problems.<p>It&#x27;s sort of like stating that security is improved by ensuring that it is no longer possible to open the front door from inside the house without a key. Seems nice - but, they&#x27;re... already inside the house.</div><br/><div id="40509340" class="c"><input type="checkbox" id="c-40509340" checked=""/><div class="controls bullet"><span class="by">martypitt</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40509427">next</a><span>|</span><label class="collapse" for="c-40509340">[-]</label><label class="expand" for="c-40509340">[1 more]</label></div><br/><div class="children"><div class="content">Slightly OT, but sincere thanks from me to you for creating Lombok.<p>It&#x27;s a tool that sparks strong opinions, which is a testament to its significance and the impact it has made. You&#x27;ve created something that people are passionate about, whether they&#x27;re for or against it.<p>Personally, I&#x27;m firmly in Team Lombok. I believe the negative feedback it receives is disproportionate.<p>For those of us who use it, Lombok significantly improves our coding experience. For those who don&#x27;t, it&#x27;s entirely optional and doesn&#x27;t interfere with their workflow.<p>Thanks again for creating something that made me enjoy coding in Java :)</div><br/></div></div><div id="40509427" class="c"><input type="checkbox" id="c-40509427" checked=""/><div class="controls bullet"><span class="by">frant-hartm</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40509340">prev</a><span>|</span><a href="#40508514">next</a><span>|</span><label class="collapse" for="c-40509427">[-]</label><label class="expand" for="c-40509427">[1 more]</label></div><br/><div class="children"><div class="content">There are multiple attack vectors via the supply chain that this new settings prevents.<p>Sure, if the compromised library is one of your core libraries that runs during build, test and runtime, then this does not help. But there are<p><pre><code>  test libraries only
  compile time only libraries (hello lombok?)
  transitive dependencies that may not be used during runtime (or run only in rare code paths)

</code></pre>
Sometimes compromising the build environment is more valuable than the app&#x27;s runtime environment - e.g. it may allow the attacker to compromise all apps.<p>Explicitly enabling a particular annotation processor I want to run is small price to pay for the increased security.</div><br/></div></div><div id="40508514" class="c"><input type="checkbox" id="c-40508514" checked=""/><div class="controls bullet"><span class="by">MichaelNolan</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40509427">prev</a><span>|</span><a href="#40509854">next</a><span>|</span><label class="collapse" for="c-40508514">[-]</label><label class="expand" for="c-40508514">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OpenJDK&#x27;s backwards-compatibility breaking crusade. The OpenJDK team has also broken reflection (you can no longer access anything in another module that wasn&#x27;t explicitly exported<p>I’ve been out of the Java world recently, but my understanding is that an application developer can still do anything they want. All of these new restrictions are for library developers. To be clear the library developer can still do anything, they just have to make it explicit.<p>This is the opposite of a backwards compatibility breaking crusade. This is a crusade to make sure application developers don’t accidentally depend on libraries that are either breaking encapsulation or depending on JDK internals. This should improve backwards compatibility.</div><br/></div></div><div id="40509854" class="c"><input type="checkbox" id="c-40509854" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40508514">prev</a><span>|</span><a href="#40508888">next</a><span>|</span><label class="collapse" for="c-40509854">[-]</label><label class="expand" for="c-40509854">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OpenJDK&#x27;s backwards-compatibility breaking crusade.<p>First, Java has always been very explicit about where it offers backward compatibility and where it does not. You cannot break backward compatibility where it must not be expected. These are classes that carry a warning saying: these are internal classes that offer no kind of backward compatibility and can be changed at any time and without warning; by depending on them you are accepting upon yourself the responsibility to respond to any change. Nevertheless, in most situations we are offering plenty of advance warning.<p>Second, the &quot;crusade&quot; isn&#x27;t done to break anything or against anyone, but because these internal and not-backward-compatibility-breaking changes are necessary to offer Java users the features they&#x27;re asking for. We&#x27;re talking about changes to the very core assumptions of the platform, which could violate any invariant and have a global impact, that could have been made by any code in any transitive library. In order to offer certain features the platform must know which of its invariants it may trust (for example, the JIT compiler cannot perform certain optimisations that assume strings are immutable because even though it is an invariant of the platform, some third-level dependency could have decided that actually strings would be mutable in any application that consumes this library).<p>Because more people want the features that require integrity [1] than those who want the ability for any transitive dependency to secretly change the rules of the game, our &quot;crusade&quot; is to give our users what they&#x27;re asking for. Of course, when the user base is this large, different people have contradictory wishes, and so a minority of users may be disappointed that we&#x27;ve decided to give other users what they asked for.<p>&gt; It&#x27;s sort of like stating that security is improved by ensuring that it is no longer possible to open the front door from inside the house without a key. Seems nice - but, they&#x27;re... already inside the house.<p>Yeah, one, this is not about security but about integrity -- as explained in the motivation [1] -- which is, indeed, essential for security but for other important things as well, and two, your security analysis is just wrong. That is why for security is best to rely on security experts and not on people unfamiliar with the field who go by what seems to make sense to them or not.<p>[1]: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8305968" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8305968</a></div><br/></div></div><div id="40508888" class="c"><input type="checkbox" id="c-40508888" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40509854">prev</a><span>|</span><a href="#40507774">next</a><span>|</span><label class="collapse" for="c-40508888">[-]</label><label class="expand" for="c-40508888">[3 more]</label></div><br/><div class="children"><div class="content">Had some developers not starting to Monkey patch this wouldn&#x27;t be needed, Java isn&#x27;t Ruby.<p>Go is now going to do a similar approach, because internals and not being public symbols apparently isn&#x27;t clear enough.</div><br/><div id="40509698" class="c"><input type="checkbox" id="c-40509698" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40508888">parent</a><span>|</span><a href="#40507774">next</a><span>|</span><label class="collapse" for="c-40509698">[-]</label><label class="expand" for="c-40509698">[2 more]</label></div><br/><div class="children"><div class="content">Public&#x2F;private does nothing to change the problems a developer has to deal with. On the JVM side the most widely &quot;hacked&quot; private API was sun.misc.Unsafe, which just could not be implemented using pure Java and Oracle did not design public replacement APIs until the restrictions on it where anounced.<p>&gt; because internals and not being public symbols apparently isn&#x27;t clear enough.<p>You might as well tell a starving person that eating bread is illegal.</div><br/><div id="40509873" class="c"><input type="checkbox" id="c-40509873" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40509698">parent</a><span>|</span><a href="#40507774">next</a><span>|</span><label class="collapse" for="c-40509873">[-]</label><label class="expand" for="c-40509873">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Oracle did not design public replacement APIs until the restrictions on it where anounced.<p>The very opposite is true. All the remaining required replacements for Unsafe were put in place in JDK 22, and access to Unsafe has been unrestricted and unencumbered in any way until the upcoming JDK 23 [1]. It is precisely because we know people have come to depend on Unsafe that we had <i>not</i> started to restrict its use until all replacements were delivered.<p>[1]: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;471" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;471</a></div><br/></div></div></div></div></div></div><div id="40507774" class="c"><input type="checkbox" id="c-40507774" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40508888">prev</a><span>|</span><a href="#40509277">next</a><span>|</span><label class="collapse" for="c-40507774">[-]</label><label class="expand" for="c-40507774">[1 more]</label></div><br/><div class="children"><div class="content">Annotation processors on the compile classpath are not automatically added to the build output&#x27;s runtime classpath. The status quo doesn&#x27;t change, because annotation processors also don&#x27;t do anything when running the app (e.g. with java and not javac), on any Java version.</div><br/></div></div><div id="40509277" class="c"><input type="checkbox" id="c-40509277" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40507774">prev</a><span>|</span><a href="#40508742">next</a><span>|</span><label class="collapse" for="c-40509277">[-]</label><label class="expand" for="c-40509277">[1 more]</label></div><br/><div class="children"><div class="content">Is the OpenJDK behavior different from Oracle JDK?</div><br/></div></div><div id="40508742" class="c"><input type="checkbox" id="c-40508742" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40509277">prev</a><span>|</span><a href="#40507436">next</a><span>|</span><label class="collapse" for="c-40508742">[-]</label><label class="expand" for="c-40508742">[1 more]</label></div><br/><div class="children"><div class="content">This seems a real vulnerability if you&#x27;re using legacy infrastructure - If you&#x27;re running your build process on a highly privileged build machine, like a single large Jenkins instance. These machines might have a bunch of subprojects - and a bunch of credentials to login to other prod systems for deployment purposes.<p>This is not the reason that I prefer containerized build solutions, but it is a real concern, outside of the little bubble that is the startup ecosystem.<p>Edit: It occurs to me that since I just gave a talk on this, it behooves me to link it: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;dswPHnfGwlY" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;dswPHnfGwlY</a></div><br/></div></div><div id="40507436" class="c"><input type="checkbox" id="c-40507436" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40508742">prev</a><span>|</span><a href="#40508934">next</a><span>|</span><label class="collapse" for="c-40507436">[-]</label><label class="expand" for="c-40507436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That jar will also be on the classpath when running the app.<p>No. In many maven config, runtime classpath is not the same as compile time</div><br/></div></div><div id="40508934" class="c"><input type="checkbox" id="c-40508934" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507405">parent</a><span>|</span><a href="#40507436">prev</a><span>|</span><a href="#40508728">next</a><span>|</span><label class="collapse" for="c-40508934">[-]</label><label class="expand" for="c-40508934">[8 more]</label></div><br/><div class="children"><div class="content">&gt; this is a silly update in OpenJDK&#x27;s war against things like Project Lombok<p>Project Lombok <i>doesn’t</i> use the normal annotation processing system, as that is deliberately “add-only” - you can’t change a class’s implementation, unlike what lombok does. They instead hack into the javac compiler to be able to modify class files, which is a very different mechanism (and prone to break with any javac update, which they don’t control) and I think it’s quite easy to see why it’s not loved (though this “war” bullshit is just propaganda from the creator’s ego or whatever).<p>Also, default being strict is a good stance (both in case of the reflection restrictions) — you can access everything with just a few command line flags, so I don’t really see all the complaints. The point is, you <i>have to know</i> about whether some module in your system accesses another in a non-standard way. Like, are firewalls overly strict because they only allow traffic through port 22 when specified to do so? Should they start with allow-all?</div><br/><div id="40509754" class="c"><input type="checkbox" id="c-40509754" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40508934">parent</a><span>|</span><a href="#40509147">next</a><span>|</span><label class="collapse" for="c-40509754">[-]</label><label class="expand" for="c-40509754">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They instead hack into the javac compiler to be able to modify class files, which is a very different mechanism<p>They only do that because there is no public Java API to do the things they want to do. If a public Java API to do the same things were made available, I’m sure they’d gladly migrate to doing that instead</div><br/></div></div><div id="40509147" class="c"><input type="checkbox" id="c-40509147" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40508934">parent</a><span>|</span><a href="#40509754">prev</a><span>|</span><a href="#40508728">next</a><span>|</span><label class="collapse" for="c-40509147">[-]</label><label class="expand" for="c-40509147">[6 more]</label></div><br/><div class="children"><div class="content">He knows what Lombok does. He’s the author.</div><br/><div id="40509464" class="c"><input type="checkbox" id="c-40509464" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40509147">parent</a><span>|</span><a href="#40509665">next</a><span>|</span><label class="collapse" for="c-40509464">[-]</label><label class="expand" for="c-40509464">[2 more]</label></div><br/><div class="children"><div class="content">Kind of - the point remains. Lombok requires to alter the compiler (hook into), not (just) the annotation processing, itself.  I&#x27;d be okayish if Lombok was a mere post compilation&#x2F;enhancement too, but it isn&#x27;t. It&#x27;s a per-compilation step</div><br/><div id="40509784" class="c"><input type="checkbox" id="c-40509784" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40509464">parent</a><span>|</span><a href="#40509665">next</a><span>|</span><label class="collapse" for="c-40509784">[-]</label><label class="expand" for="c-40509784">[1 more]</label></div><br/><div class="children"><div class="content">I’m not refuting the point. Just giving kaba0 context that they are explaining how a library works to its author.</div><br/></div></div></div></div><div id="40509665" class="c"><input type="checkbox" id="c-40509665" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40509147">parent</a><span>|</span><a href="#40509464">prev</a><span>|</span><a href="#40508728">next</a><span>|</span><label class="collapse" for="c-40509665">[-]</label><label class="expand" for="c-40509665">[3 more]</label></div><br/><div class="children"><div class="content">Well, then he just prefers telling lies. Annotation processors can’t modify classes, this is a fact. The primary purpose of Lombok is <i>adding</i> new methods like getX and setX to <i>the same class</i> based on fields. It’s pretty easy to conclude that Lombok is thus not an ordinary annotation processor, and actually uses sun.misc.unsafe to go into the <i>private</i> internals of javac to modify the AST, which has become possible only by specifying some additional arguments, notifying the end-user that some libraries on the class path might do something that can’t be promised to work ad eternity. This is a completely reasonable decision on the Java team’s part (and quite narcissistic to conclude that it is due to your lib..), as many of the breaking changes between 8 and 9 were actually due to libraries doing exactly that. These changes helps uphold Java’s strong backwards compatibility guarantees.</div><br/><div id="40509797" class="c"><input type="checkbox" id="c-40509797" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40509665">parent</a><span>|</span><a href="#40508728">next</a><span>|</span><label class="collapse" for="c-40509797">[-]</label><label class="expand" for="c-40509797">[2 more]</label></div><br/><div class="children"><div class="content">I wasn’t refuting anything and in fact I’m onboard with these changes. I do not like Lombok and _in my opinion_ it’s for the laziest of devs. I just wanted to give you context that you are explaining how a library works to its author.</div><br/><div id="40509882" class="c"><input type="checkbox" id="c-40509882" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40509797">parent</a><span>|</span><a href="#40508728">next</a><span>|</span><label class="collapse" for="c-40509882">[-]</label><label class="expand" for="c-40509882">[1 more]</label></div><br/><div class="children"><div class="content">Well, I was sort of explaining it to the wider audience, but fair enough, I wasn’t actually aware it was the author.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40508728" class="c"><input type="checkbox" id="c-40508728" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40506954">parent</a><span>|</span><a href="#40507405">prev</a><span>|</span><a href="#40507283">next</a><span>|</span><label class="collapse" for="c-40508728">[-]</label><label class="expand" for="c-40508728">[1 more]</label></div><br/><div class="children"><div class="content">I assume this is to have more control over compilation process.<p>Without annotation processor, you can expect your code to be compiled and behaved in an obvious way.<p>With annotation processor all bets are off, your code and code that results from compilation are completely different entities.<p>So with this switch being explicit, you might enforce politics like lack of annotation processors for better clarity.<p>While security theoretically might be better, in practice with modern build tools there are enough ways to cause code execution, so it probably doesn&#x27;t matter much.</div><br/></div></div><div id="40507283" class="c"><input type="checkbox" id="c-40507283" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#40506954">parent</a><span>|</span><a href="#40508728">prev</a><span>|</span><a href="#40507218">next</a><span>|</span><label class="collapse" for="c-40507283">[-]</label><label class="expand" for="c-40507283">[4 more]</label></div><br/><div class="children"><div class="content">Not sure how much that would help.  As far as I understand if you have access to putting stuff in the class path surely you can just override Java classes and run arbitrary code that way.</div><br/><div id="40507414" class="c"><input type="checkbox" id="c-40507414" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507283">parent</a><span>|</span><a href="#40507218">next</a><span>|</span><label class="collapse" for="c-40507414">[-]</label><label class="expand" for="c-40507414">[3 more]</label></div><br/><div class="children"><div class="content">I think the difference is that annotation processors run arbitrary code <i>at compile time</i>.<p>An org might have e.g. a CI with a build environment that’s not as well-sandboxed as the test environment for the built app, because a Java compiler isn’t generally expected to (and other than through annotations, usually doesn’t) expose arbitrary code execution abilities to the payload of code being compiled.</div><br/><div id="40509844" class="c"><input type="checkbox" id="c-40509844" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507414">parent</a><span>|</span><a href="#40507718">next</a><span>|</span><label class="collapse" for="c-40509844">[-]</label><label class="expand" for="c-40509844">[1 more]</label></div><br/><div class="children"><div class="content">&gt; An org might have e.g. a CI with a build environment that’s not as well-sandboxed as the test environment for the built app, because a Java compiler isn’t generally expected to (and other than through annotations, usually doesn’t) expose arbitrary code execution abilities to the payload of code being compiled.<p>Is that kind of setup common though? I’ve never seen anybody running sandboxed tests but non-sandboxed compiles. In my personal experience, either one has ability to sandbox and one sandboxes everything, or one lacks that ability and sandboxes nothing<p>I have seen compile and unit tests run directly on a Jenkins agent (with a lot of ability for the job to mangle the agent config), but then spinning up a Docker container for integration tests - but in that case the motivation for the Docker container isn’t sandboxing, and the Docker container is often given lots of privileges (like access to the Docker socket)</div><br/></div></div><div id="40507718" class="c"><input type="checkbox" id="c-40507718" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507414">parent</a><span>|</span><a href="#40509844">prev</a><span>|</span><a href="#40507218">next</a><span>|</span><label class="collapse" for="c-40507718">[-]</label><label class="expand" for="c-40507718">[1 more]</label></div><br/><div class="children"><div class="content">Is it actually common practice these days to have Java repositories that do not contain the build scripts, packaging, etc?<p>The last time I looked at maven, it seemed easy enough to have it run arbitrary code directly during the build.</div><br/></div></div></div></div></div></div><div id="40507218" class="c"><input type="checkbox" id="c-40507218" checked=""/><div class="controls bullet"><span class="by">senorrib</span><span>|</span><a href="#40506954">parent</a><span>|</span><a href="#40507283">prev</a><span>|</span><a href="#40509664">next</a><span>|</span><label class="collapse" for="c-40507218">[-]</label><label class="expand" for="c-40507218">[5 more]</label></div><br/><div class="children"><div class="content">Using Gradle, ant or Maven still means, in the end, you’re calling javac. All it takes for this to be exploited is for the files to be dropped anywhere in the classpath.</div><br/><div id="40508666" class="c"><input type="checkbox" id="c-40508666" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40507218">parent</a><span>|</span><a href="#40509664">next</a><span>|</span><label class="collapse" for="c-40508666">[-]</label><label class="expand" for="c-40508666">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an annotation processor. They generally require annotations in your own source code to kick in.<p>As a security risk this is pretty minor. About on the same level as any software project with any dependencies risking running arbitrary code unless you audit those dependencies. This is of course a very real risk and it has affected a bunch of projects. But it&#x27;s not really stopping people from using things like cargo, npm, etc.<p>Overall, it makes sense to make the use of annotation processors a bit more explicit. With Kotlin this is kind of how it works as well. You have things like ksp that you have to configure explicitly if you want to use them. Additionally there are compiler plugins that you can configure if you need them. It&#x27;s not a big deal to configure this explicitly. I actually prefer it over magic discovery mechanisms that are hard to debug when they don&#x27;t work.<p>So, good change that probably simplifies the build process a little.</div><br/><div id="40509167" class="c"><input type="checkbox" id="c-40509167" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40508666">parent</a><span>|</span><a href="#40509664">next</a><span>|</span><label class="collapse" for="c-40509167">[-]</label><label class="expand" for="c-40509167">[3 more]</label></div><br/><div class="children"><div class="content">&gt; They generally require annotations in your own source code to kick in<p>Right but you don’t know which annotation processor will actually run. Anybody could look for javax.persistence.Entity and do something. There’s no guarantee only your JPA provider will be running and looking at them.</div><br/><div id="40509221" class="c"><input type="checkbox" id="c-40509221" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40509167">parent</a><span>|</span><a href="#40509664">next</a><span>|</span><label class="collapse" for="c-40509221">[-]</label><label class="expand" for="c-40509221">[2 more]</label></div><br/><div class="children"><div class="content">In exactly the same way, unless you audit your dependencies, you have no idea what you are going to run. It all boils down to whether you trust your dependencies. The only difference here is that this is a compile time dependency, not a run-time dependency. But unless you checked it, there are no guarantees.</div><br/><div id="40509351" class="c"><input type="checkbox" id="c-40509351" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#40506954">root</a><span>|</span><a href="#40509221">parent</a><span>|</span><a href="#40509664">next</a><span>|</span><label class="collapse" for="c-40509351">[-]</label><label class="expand" for="c-40509351">[1 more]</label></div><br/><div class="children"><div class="content">Sure. Hypothetically, I have checked them. I have checked what I’m actually using, but the compiler is still executing things I didn’t know about.<p>I only use CatUtils from org.catpache.commons. I’ve audited this single class that I use. I know it’s safe. It only contains a Map&lt;String, String&gt; of Latin cat names to their common English name, but what I didn’t know was the compiler magically running an annotation processor behind my back and it’s now modified all of my classes to throw MeowException whenever toString returns “dog”.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40509664" class="c"><input type="checkbox" id="c-40509664" checked=""/><div class="controls bullet"><span class="by">nfrankel</span><span>|</span><a href="#40506954">prev</a><span>|</span><label class="collapse" for="c-40509664">[-]</label><label class="expand" for="c-40509664">[1 more]</label></div><br/><div class="children"><div class="content">The Java team is still breaking things despite numerous pleas of the community pleading not to do so? Color me surprised.<p>The Security Manager send its regards.</div><br/></div></div></div></div></div></div></div></body></html>