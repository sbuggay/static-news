<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738054866593" as="style"/><link rel="stylesheet" href="styles.css?v=1738054866593"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/">Bilinear down/upsampling, aligning pixel grids, and that infamous GPU half pixel (2021)</a> <span class="domain">(<a href="https://bartwronski.com">bartwronski.com</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>19 comments</span></div><br/><div><div id="42843514" class="c"><input type="checkbox" id="c-42843514" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#42845150">next</a><span>|</span><label class="collapse" for="c-42843514">[-]</label><label class="expand" for="c-42843514">[2 more]</label></div><br/><div class="children"><div class="content">Great article. That half pixel offset is crucial for understanding proper rasterization of detailed 3D meshes. No seams, no holes, no overlaps on shared triangle edges rely on exactly where the pixel centers are. This carries over to image processing and sampling. There are a few of us that lose sleep over these tiny details -- I am happy when I see kindred spirits with the same attention to detail.</div><br/></div></div><div id="42845150" class="c"><input type="checkbox" id="c-42845150" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#42843514">prev</a><span>|</span><a href="#42844899">next</a><span>|</span><label class="collapse" for="c-42845150">[-]</label><label class="expand" for="c-42845150">[2 more]</label></div><br/><div class="children"><div class="content">On a similar note, yesterday I stumbled across a 4-days old video related to dithering which is really worth watching. &quot;<i>Surface-Stable Fractal Dithering</i>&quot; [0] by &quot;Rune Skovbo Johansen, indie game developer and procedural generation enthusiast&quot;<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HPqGaIMVuLs" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HPqGaIMVuLs</a></div><br/><div id="42845201" class="c"><input type="checkbox" id="c-42845201" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42845150">parent</a><span>|</span><a href="#42844899">next</a><span>|</span><label class="collapse" for="c-42845201">[-]</label><label class="expand" for="c-42845201">[1 more]</label></div><br/><div class="children"><div class="content">It was also covered here 4 days ago[1], again I might add.<p>Very cool effect, and one of my absolute favorite games.<p>[1]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42808889">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42808889</a></div><br/></div></div></div></div><div id="42844899" class="c"><input type="checkbox" id="c-42844899" checked=""/><div class="controls bullet"><span class="by">lcnielsen</span><span>|</span><a href="#42845150">prev</a><span>|</span><a href="#42848889">next</a><span>|</span><label class="collapse" for="c-42844899">[-]</label><label class="expand" for="c-42844899">[1 more]</label></div><br/><div class="children"><div class="content">I spent a substantial part of my Ph.D. dealing with this stuff, existing frameworks and algorithms were not suitable for our exact use-case and implementation. I had more bugs&#x2F;artefacts than I&#x27;d like to admit due to some off-by-less-than-0.5 in some particular direction in some particular frame...</div><br/></div></div><div id="42848889" class="c"><input type="checkbox" id="c-42848889" checked=""/><div class="controls bullet"><span class="by">johncostella</span><span>|</span><a href="#42844899">prev</a><span>|</span><a href="#42843390">next</a><span>|</span><label class="collapse" for="c-42848889">[-]</label><label class="expand" for="c-42848889">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m biased, but Magic Kernel Sharp does a good job for many applications. :)<p><a href="https:&#x2F;&#x2F;johncostella.com&#x2F;magic&#x2F;" rel="nofollow">https:&#x2F;&#x2F;johncostella.com&#x2F;magic&#x2F;</a></div><br/></div></div><div id="42843390" class="c"><input type="checkbox" id="c-42843390" checked=""/><div class="controls bullet"><span class="by">calibas</span><span>|</span><a href="#42848889">prev</a><span>|</span><a href="#42843077">next</a><span>|</span><label class="collapse" for="c-42843390">[-]</label><label class="expand" for="c-42843390">[6 more]</label></div><br/><div class="children"><div class="content">Bilinear is nice for performance, but if you&#x27;re concerned about image quality you generally want to use bicubic resampling instead.</div><br/><div id="42845166" class="c"><input type="checkbox" id="c-42845166" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#42843390">parent</a><span>|</span><a href="#42843077">next</a><span>|</span><label class="collapse" for="c-42845166">[-]</label><label class="expand" for="c-42845166">[5 more]</label></div><br/><div class="children"><div class="content">Or Lanczos resampling.</div><br/><div id="42846801" class="c"><input type="checkbox" id="c-42846801" checked=""/><div class="controls bullet"><span class="by">daneel_w</span><span>|</span><a href="#42843390">root</a><span>|</span><a href="#42845166">parent</a><span>|</span><a href="#42845224">next</a><span>|</span><label class="collapse" for="c-42846801">[-]</label><label class="expand" for="c-42846801">[1 more]</label></div><br/><div class="children"><div class="content">For upscaling, sure. For downscaling it has a tendency to both amplify and distort (rather than preserve) detail and sharpness, &quot;imagining&quot; detail that never existed, leaving you with a worse result. Bicubic and sometimes even bilinear does a better job, truer to the original, when you&#x27;re scaling down.</div><br/></div></div><div id="42845224" class="c"><input type="checkbox" id="c-42845224" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42843390">root</a><span>|</span><a href="#42845166">parent</a><span>|</span><a href="#42846801">prev</a><span>|</span><a href="#42843077">next</a><span>|</span><label class="collapse" for="c-42845224">[-]</label><label class="expand" for="c-42845224">[3 more]</label></div><br/><div class="children"><div class="content">Lanczos if you want sharpness above all else. There&#x27;s also the well-known Mitchell-Netravali filters[1], based on piece-wise cubic splines and with two tunable paramerers.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mitchell%E2%80%93Netravali_filters" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mitchell%E2%80%93Netravali_fil...</a></div><br/><div id="42846740" class="c"><input type="checkbox" id="c-42846740" checked=""/><div class="controls bullet"><span class="by">jorvi</span><span>|</span><a href="#42843390">root</a><span>|</span><a href="#42845224">parent</a><span>|</span><a href="#42846201">next</a><span>|</span><label class="collapse" for="c-42846740">[-]</label><label class="expand" for="c-42846740">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the fine details of  it but afaik FSR &lt;3.0 is Lanczos with a few tricks to both speed it up and make the visuals more stable.</div><br/></div></div><div id="42846201" class="c"><input type="checkbox" id="c-42846201" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#42843390">root</a><span>|</span><a href="#42845224">parent</a><span>|</span><a href="#42846740">prev</a><span>|</span><a href="#42843077">next</a><span>|</span><label class="collapse" for="c-42846201">[-]</label><label class="expand" for="c-42846201">[1 more]</label></div><br/><div class="children"><div class="content">Whenever I want to upscale, I use an Edge-Directed algorithm, such as SuperXBR.  Diagonal lines stay diagonal and don&#x27;t turn into blurry boxes.</div><br/></div></div></div></div></div></div></div></div><div id="42843077" class="c"><input type="checkbox" id="c-42843077" checked=""/><div class="controls bullet"><span class="by">Demiurge</span><span>|</span><a href="#42843390">prev</a><span>|</span><a href="#42842288">next</a><span>|</span><label class="collapse" for="c-42843077">[-]</label><label class="expand" for="c-42843077">[1 more]</label></div><br/><div class="children"><div class="content">what would it look like with nearest, or gaussian filters? Would be interesting to see the same sample graphs with different kernels.</div><br/></div></div><div id="42844953" class="c"><input type="checkbox" id="c-42844953" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#42842288">prev</a><span>|</span><label class="collapse" for="c-42844953">[-]</label><label class="expand" for="c-42844953">[4 more]</label></div><br/><div class="children"><div class="content">Good article, but IMO none of the discussed downsampling methods are actually ideal.<p>The ideal is trilinear sampling instead of bilinear. Easy to do with GPU APIs, in D3D11 it’s  ID3D11DeviceContext.GenerateMips API call to generate full set of mip levels of the input texture, then generate each output pixel with trilinear sampler. When doing non-uniform downsampling, use anisotropic sampler instead of trilinear.<p>Not sure high level image processing libraries like the mentioned numpy, PIL or TensorFlow are doing anything like that, though.</div><br/><div id="42845168" class="c"><input type="checkbox" id="c-42845168" checked=""/><div class="controls bullet"><span class="by">bartwr</span><span>|</span><a href="#42844953">parent</a><span>|</span><a href="#42849427">next</a><span>|</span><label class="collapse" for="c-42845168">[-]</label><label class="expand" for="c-42845168">[2 more]</label></div><br/><div class="children"><div class="content">Original author here and it&#x27;s been a while since I have read such word salad nonsense, sorry. Why people who have no idea or expertise comment on articles?
GenerateMips API constructs a mip chain by using box&#x2F;bilinear (equivalent for factors of two) log N times.<p>Trilinear interpolates across <i>three</i> dimensions, such as 3D textures or mip chains. It is not a method for downsampling, but a method for filtering that interpolates two bilinear results, such as two bilinear filters of mip levels that were generated with &quot;some&quot; downsampling filter (which can be anything from box to Lanczos).<p>Anisotropic is a hybrid between trilinear across a smaller interpolation axis under perspective projection of a 3D asset and multiple taps along the longer axis. (More expensive)</div><br/><div id="42845441" class="c"><input type="checkbox" id="c-42845441" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#42844953">root</a><span>|</span><a href="#42845168">parent</a><span>|</span><a href="#42849427">next</a><span>|</span><label class="collapse" for="c-42845441">[-]</label><label class="expand" for="c-42845441">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Trilinear interpolates across three dimensions, such as 3D textures or mip chains<p>I meant trilinear interpolation across the mip chain.<p>&gt; generated with &quot;some&quot; downsampling filter (which can be anything from box to Lanczos)<p>In practice, whichever method is implemented in user-mode half of GPU drivers is pretty good.<p>&gt; It is not a method for downsampling<p>No, but it can be applied for downsampling as well.<p>&gt; under perspective projection of a 3D asset<p>Texture samplers don’t know or care about projections. They only take 2D texture coordinates, and screen-space derivatives of these. This is precisely what enables to use texture samplers to downsample images.<p>The only caveat, if you do that by dispatching a compute shader as opposed to rendering a full-screen triangle, you’ll have to supply screen-space derivatives manually in the arguments of Texture2D.SampleGrad method. When doing non-uniform downsampling without perspective projections, these ddx&#x2F;ddy numbers are the same for all output pixels, and are trivial to compute on CPU before dispatching the shader.<p>&gt; More expensive<p>On modern computers, the performance overhead of anisotropic sampling compared to trilinear is just barely measurable.</div><br/></div></div></div></div><div id="42849427" class="c"><input type="checkbox" id="c-42849427" checked=""/><div class="controls bullet"><span class="by">mschuetz</span><span>|</span><a href="#42844953">parent</a><span>|</span><a href="#42845168">prev</a><span>|</span><label class="collapse" for="c-42849427">[-]</label><label class="expand" for="c-42849427">[1 more]</label></div><br/><div class="children"><div class="content">Trilinear requires an image pyramid. Without downsampling to create that image pyramid, you can&#x27;t even do trilinear sampling, so your argument strikes me as odd and circular. Like telling developers of APIs such as  ID3D11DeviceContext.GenerateMips to simply use  ID3D11DeviceContext.GenerateMips instead of developing  ID3D11DeviceContext.GenerateMips. Also, I never took this article to be about 3D rendering and utilizing mip maps for trilinear interpolation. More about 2D image scaling.<p>Have you never downscaled and upscaled images in a non-3D-rendering context?</div><br/></div></div></div></div></div></div></div></div></div></body></html>