<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710579650748" as="style"/><link rel="stylesheet" href="styles.css?v=1710579650748"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mbuffett.com/posts/compressing-chess-moves/">Compressing chess moves for fun and profit</a> <span class="domain">(<a href="https://mbuffett.com">mbuffett.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>129 comments</span></div><br/><div><div id="39717990" class="c"><input type="checkbox" id="c-39717990" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#39717999">next</a><span>|</span><label class="collapse" for="c-39717990">[-]</label><label class="expand" for="c-39717990">[51 more]</label></div><br/><div class="children"><div class="content">The optimum compression seems to be an index into the list of all legal moves.<p>But one can do better on average, by assuming that moves are not uniformly distributed. Let an engine assign each legal move m some probability p of being played. The worse the move, the lower the probability we assign to it. Then a more optimal code for move m is -log p bits, corresponding to an entropy (expected surprise) of sum -p log p bits for the distribution over legal moves.<p>Related: accurately estimating the number of legal positions of chess [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;tromp&#x2F;ChessPositionRanking">https:&#x2F;&#x2F;github.com&#x2F;tromp&#x2F;ChessPositionRanking</a></div><br/><div id="39718730" class="c"><input type="checkbox" id="c-39718730" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39720796">next</a><span>|</span><label class="collapse" for="c-39718730">[-]</label><label class="expand" for="c-39718730">[17 more]</label></div><br/><div class="children"><div class="content">Though, that engine evaluation is going to be absurdly expensive, when you&#x27;re compressing&#x2F;decompressing billions of games.<p>I think everyone&#x27;s optimizing the wrong thing! The size of a useful, real-world chess database would be dominated by its search indexes—indexes that allow fast, random-access lookup  of every position that occurs in every game. (Or even better: fuzzy searching for nearby, &quot;similar&quot; positions). This is the difficult, open-ended algorithmic problem. Disk space is cheap!<p>(Out of curiosity, does anyone here actually <i>know</i> how to solve the &quot;fuzzy search of chess positions&quot; problem?)</div><br/><div id="39719150" class="c"><input type="checkbox" id="c-39719150" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718730">parent</a><span>|</span><a href="#39719728">next</a><span>|</span><label class="collapse" for="c-39719150">[-]</label><label class="expand" for="c-39719150">[4 more]</label></div><br/><div class="children"><div class="content">Agreed. Ultimately, the most common reason for needing to store a bunch of games is you want a chess database so you can look up a given position.<p>So probably some kind of tree structure so you can look up games by sequence of moves since opening. And something like zobrist hashing for looking up a given position (regardless of sequence).<p>Some of these ultra-small encodings would be counterproductive for this purpose.</div><br/><div id="39719333" class="c"><input type="checkbox" id="c-39719333" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719150">parent</a><span>|</span><a href="#39719728">next</a><span>|</span><label class="collapse" for="c-39719333">[-]</label><label class="expand" for="c-39719333">[3 more]</label></div><br/><div class="children"><div class="content">- <i>&quot;And something like zobrist hashing for looking up a given position&quot;</i><p>Which gets particularly good if you combine it with some hack like a Bloom filter. There&#x27;s a trick, I don&#x27;t remember if it has a name, where you can effect a time&#x2F;space tradeoff by partitioning a search set and building a separate Bloom filter for each partition. A lookup is a constant-time query of each Bloom filter, plus a linear scan of each partition that signaled a match.<p>(This is a reasonable thing to do, because (0) the size of chess databases can get extremely large and (1) the queries are human UX interactions that need to be responsive).</div><br/><div id="39719588" class="c"><input type="checkbox" id="c-39719588" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719333">parent</a><span>|</span><a href="#39719728">next</a><span>|</span><label class="collapse" for="c-39719588">[-]</label><label class="expand" for="c-39719588">[2 more]</label></div><br/><div class="children"><div class="content">I mean, chess engines use transposition tables to store encountered positions. In this case you can use the zobrist hash as the index to a hash table and it&#x27;s an O(1) lookup for a given position.<p>Typically that&#x27;s going to be the best way to index into full games. Since you can point to an entry via a game tree search (eg; each node of the tree is a position that you can use as an index to a big transposition table).<p>You can probably use a bloom filter to check if a given position has ever been encountered (eg; as a layer on top of the transposition table) though. For something like storing 10 billion positions w&#x2F; a 10^-6 false positive probability (w&#x2F; reasonable number of hashes) you&#x27;re looking at 30+GiB bloom filters.</div><br/><div id="39719750" class="c"><input type="checkbox" id="c-39719750" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719588">parent</a><span>|</span><a href="#39719728">next</a><span>|</span><label class="collapse" for="c-39719750">[-]</label><label class="expand" for="c-39719750">[1 more]</label></div><br/><div class="children"><div class="content">Right! The hash table you&#x27;re describing is O(1) lookup, but its memory size is a constant multiple larger than the Bloom filter. A Bloom filter doesn&#x27;t tell you anything about where the needle is–only whether the needle exists; so, if used for <i>lookup</i>, it reduces to O(n) brute-force search. In between the two, you can create an array of <i>M</i> partitions of the haystack, each with their own Bloom filter: this structure has something like O(M + n&#x2F;M) lookup, but with the smaller memory size of the Bloom filter.<p>When I implemented this, I deliberately avoided constructing the hash table you&#x27;re describing, because (to my recollection) it was larger than my remaining disk space! :)</div><br/></div></div></div></div></div></div></div></div><div id="39719728" class="c"><input type="checkbox" id="c-39719728" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718730">parent</a><span>|</span><a href="#39719150">prev</a><span>|</span><a href="#39723015">next</a><span>|</span><label class="collapse" for="c-39719728">[-]</label><label class="expand" for="c-39719728">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Out of curiosity, does anyone here actually know how to solve the &quot;fuzzy search of chess positions&quot; problem?<p>A classification based indexing would help here. The data points of the index would be not just the position of the pieces, but their relative as well. Things like the squares under attack, pinned weaker pieces, and maybe some evaluation of control of the board (again maybe via some attacking based metric).<p>This seems like the kind of thing that could be done by analyzing a larger dataset of games to create a set of functional categorizations.<p>Once the data points themselves have been identified, actually indexing them is the easy part.<p>Solving this more generally for the “<i>find me games like X…</i>” is much trickier without locking down that X to something concrete.</div><br/><div id="39719995" class="c"><input type="checkbox" id="c-39719995" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719728">parent</a><span>|</span><a href="#39723015">next</a><span>|</span><label class="collapse" for="c-39719995">[-]</label><label class="expand" for="c-39719995">[2 more]</label></div><br/><div class="children"><div class="content">For example: &quot;this position, but a few of the pieces can be in different places&quot;. (Maybe penalizing pawn moves with a higher weight—a pawn move is in practice a &quot;larger change&quot; to a position than a piece move).<p>This version is easy to formalize: it&#x27;s just querying a bitstring x \in {0,1}^N, a bitboard vector representation of a chess position, and asking if there&#x27;s any other needles within a short Hamming distance. I haven&#x27;t a clue how to solve that (or if it&#x27;s solvable at all).</div><br/><div id="39723212" class="c"><input type="checkbox" id="c-39723212" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719995">parent</a><span>|</span><a href="#39723015">next</a><span>|</span><label class="collapse" for="c-39723212">[-]</label><label class="expand" for="c-39723212">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if shingle hashes might help a lot here...<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MinHash" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MinHash</a></div><br/></div></div></div></div></div></div><div id="39723015" class="c"><input type="checkbox" id="c-39723015" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718730">parent</a><span>|</span><a href="#39719728">prev</a><span>|</span><a href="#39721821">next</a><span>|</span><label class="collapse" for="c-39723015">[-]</label><label class="expand" for="c-39723015">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Though, that engine evaluation is going to be absurdly expensive, when you&#x27;re compressing&#x2F;decompressing billions of games.<p>It only has to be accurate enough to be beneficial though. Even a knowledge about two sets of more frequent and less frequent moves would be much better than the baseline.</div><br/></div></div><div id="39721821" class="c"><input type="checkbox" id="c-39721821" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718730">parent</a><span>|</span><a href="#39723015">prev</a><span>|</span><a href="#39723896">next</a><span>|</span><label class="collapse" for="c-39721821">[-]</label><label class="expand" for="c-39721821">[1 more]</label></div><br/><div class="children"><div class="content">Yeah unfortunately the blog post didn&#x27;t really explain the use case well enough. There has to be a reason they want to waste space storing the redundant indicators of check and checkmate for instance.</div><br/></div></div><div id="39723896" class="c"><input type="checkbox" id="c-39723896" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718730">parent</a><span>|</span><a href="#39721821">prev</a><span>|</span><a href="#39718852">next</a><span>|</span><label class="collapse" for="c-39723896">[-]</label><label class="expand" for="c-39723896">[1 more]</label></div><br/><div class="children"><div class="content">I had built a demo like that a few months ago, it relied on pg_tgrm GIST indexes of the position&#x27;s FEN string encoding and only a few bits of metadata per position. You could push it by &quot;learning&quot; some representation and perhaps relying on bloom filters or summat clever like that maybe...</div><br/></div></div><div id="39718852" class="c"><input type="checkbox" id="c-39718852" checked=""/><div class="controls bullet"><span class="by">ant6n</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718730">parent</a><span>|</span><a href="#39723896">prev</a><span>|</span><a href="#39720796">next</a><span>|</span><label class="collapse" for="c-39718852">[-]</label><label class="expand" for="c-39718852">[6 more]</label></div><br/><div class="children"><div class="content">You just need to enumerate for all possible states, the possible transitions and evaluate the probabilities for them. How many could there possibly be? Store in a small database and look em up on the fly. Easy peasy.</div><br/><div id="39719175" class="c"><input type="checkbox" id="c-39719175" checked=""/><div class="controls bullet"><span class="by">anonymous-panda</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718852">parent</a><span>|</span><a href="#39718910">next</a><span>|</span><label class="collapse" for="c-39719175">[-]</label><label class="expand" for="c-39719175">[1 more]</label></div><br/><div class="children"><div class="content">I know you’re joking, but it wouldn’t really be that hard in terms of a lookup for played positions which is what OP asked for - you could have Bitboards for the relevant info so finding a state would be a refined search starting with the busy&#x2F;occupied Bitboard. Since you’re only storing games that have been played rather than all positions, the size of the index shouldn’t be outrageously large compared with other things already being stored.</div><br/></div></div><div id="39718910" class="c"><input type="checkbox" id="c-39718910" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718852">parent</a><span>|</span><a href="#39719175">prev</a><span>|</span><a href="#39719280">next</a><span>|</span><label class="collapse" for="c-39718910">[-]</label><label class="expand" for="c-39718910">[3 more]</label></div><br/><div class="children"><div class="content">- <i>&quot;and evaluate the probabilities for them&quot;</i><p>I don&#x27;t know any good, <i>fast</i> heuristics for predicting this (likelihood of a human choosing a specific chess move). Do you? Chess engine evaluation is computationally quite heavy.</div><br/><div id="39719017" class="c"><input type="checkbox" id="c-39719017" checked=""/><div class="controls bullet"><span class="by">svnt</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718910">parent</a><span>|</span><a href="#39720369">next</a><span>|</span><label class="collapse" for="c-39719017">[-]</label><label class="expand" for="c-39719017">[1 more]</label></div><br/><div class="children"><div class="content">Parent was making a joke. The best upper bound found for the number of chess positions is 4.8x10^44.<p><a href="https:&#x2F;&#x2F;tromp.github.io&#x2F;chess&#x2F;chess.html" rel="nofollow">https:&#x2F;&#x2F;tromp.github.io&#x2F;chess&#x2F;chess.html</a></div><br/></div></div><div id="39720369" class="c"><input type="checkbox" id="c-39720369" checked=""/><div class="controls bullet"><span class="by">ant6n</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718910">parent</a><span>|</span><a href="#39719017">prev</a><span>|</span><a href="#39719280">next</a><span>|</span><label class="collapse" for="c-39720369">[-]</label><label class="expand" for="c-39720369">[1 more]</label></div><br/><div class="children"><div class="content">You don’t need to make perfect predictions. There could actually be a lookup for a few common board states (say a couple million, to cover the first couple moves). Beyond that just use a simple scoring function, for example the value of your vs opponent pieces, whether any of your pieces (notably king) are in danger, whether u won, etc. This means u get better scores for the more likely winning moves, for capturing valuable pieces and for avoiding the loss of your own.<p>U could also play two or so turns of minimax, or perhaps use a neural network to evaluate the various reachable board states.<p>So for a given state, enumerate possible transitions, score the resulting states, and map to some sort of probability distribution, then use some prefix code (think Huffman tree[+]) based on the distribution of probabilities to encode the transition.<p>It’s perhaps not super fast, and not super accurate but if you can weed out the 50% of dumb moves, that already saves a bit.<p>[+] an easier and better approach is to map the probabilities into an interval between 0 and 1, and keep using fractional bits to „zoom in“ until one of the subintervals is uniquely defined, then recurse on that. Some of the common compression algorithms uses that (but I don’t remember the specifics, those intro courses were a long time ago).</div><br/></div></div></div></div><div id="39719280" class="c"><input type="checkbox" id="c-39719280" checked=""/><div class="controls bullet"><span class="by">crystaln</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718852">parent</a><span>|</span><a href="#39718910">prev</a><span>|</span><a href="#39720796">next</a><span>|</span><label class="collapse" for="c-39719280">[-]</label><label class="expand" for="c-39719280">[1 more]</label></div><br/><div class="children"><div class="content">Realizing this is a joke, however you only move one piece at a time and there are limited valid moves. Standard chess notation depends on this.</div><br/></div></div></div></div></div></div><div id="39720796" class="c"><input type="checkbox" id="c-39720796" checked=""/><div class="controls bullet"><span class="by">jstanley</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39718730">prev</a><span>|</span><a href="#39718249">next</a><span>|</span><label class="collapse" for="c-39720796">[-]</label><label class="expand" for="c-39720796">[5 more]</label></div><br/><div class="children"><div class="content">If you turn an arbitrary byte string into a list of indexes into legal chess moves, then you can encode arbitrary data as chess games!<p>(My implementation: <a href="https:&#x2F;&#x2F;incoherency.co.uk&#x2F;chess-steg&#x2F;" rel="nofollow">https:&#x2F;&#x2F;incoherency.co.uk&#x2F;chess-steg&#x2F;</a> and explanation at <a href="https:&#x2F;&#x2F;incoherency.co.uk&#x2F;blog&#x2F;stories&#x2F;chess-steg.html" rel="nofollow">https:&#x2F;&#x2F;incoherency.co.uk&#x2F;blog&#x2F;stories&#x2F;chess-steg.html</a> )</div><br/><div id="39721871" class="c"><input type="checkbox" id="c-39721871" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39720796">parent</a><span>|</span><a href="#39718249">next</a><span>|</span><label class="collapse" for="c-39721871">[-]</label><label class="expand" for="c-39721871">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s really cute.<p>I&#x27;m surprised stalemate detection is harder than checkmate detection. Aren&#x27;t they the same except checkmate has the extra step of detecting check?</div><br/><div id="39723638" class="c"><input type="checkbox" id="c-39723638" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39721871">parent</a><span>|</span><a href="#39718249">next</a><span>|</span><label class="collapse" for="c-39723638">[-]</label><label class="expand" for="c-39723638">[3 more]</label></div><br/><div class="children"><div class="content">Not quite - stalemate is <i>no legal move whatsoever for any of your pieces</i>, and checkmate is <i>king is in check and no legal move stops check</i>.</div><br/><div id="39723807" class="c"><input type="checkbox" id="c-39723807" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39723638">parent</a><span>|</span><a href="#39718249">next</a><span>|</span><label class="collapse" for="c-39723807">[-]</label><label class="expand" for="c-39723807">[2 more]</label></div><br/><div class="children"><div class="content">But given that a legal move by definition ends with the king not in check, the distinction often kind of goes away. In implementation terms, I think you basically have to just look at every possible move of every piece and see if any of them end without being in check.<p>Stalemate can and almost always does involve pieces that can&#x27;t move because they would create check.</div><br/><div id="39724165" class="c"><input type="checkbox" id="c-39724165" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39723807">parent</a><span>|</span><a href="#39718249">next</a><span>|</span><label class="collapse" for="c-39724165">[-]</label><label class="expand" for="c-39724165">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s true, I see what you&#x27;re saying. I guess knowing the king is already in check allows for optimisations, since you have to either move the king, capture the attacker or block the line of attack, and nothing else is legal. And if you&#x27;re double-checked you have to move the king, no matter what. As opposed to stalemate where you really do have to check the moves of every piece.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39718249" class="c"><input type="checkbox" id="c-39718249" checked=""/><div class="controls bullet"><span class="by">bicijay</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39720796">prev</a><span>|</span><a href="#39718212">next</a><span>|</span><label class="collapse" for="c-39718249">[-]</label><label class="expand" for="c-39718249">[4 more]</label></div><br/><div class="children"><div class="content">Sometimes i wonder, how i got so far im my software developer career...</div><br/><div id="39718491" class="c"><input type="checkbox" id="c-39718491" checked=""/><div class="controls bullet"><span class="by">vecter</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718249">parent</a><span>|</span><a href="#39718384">next</a><span>|</span><label class="collapse" for="c-39718491">[-]</label><label class="expand" for="c-39718491">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Software&quot;, like &quot;science&quot;, is a broad term. Just like there are many kinds of scientists and you could be, say, a biologist or a physicist, there are many entirely disparate fields of software engineering. At the end of the day, software itself is just a means to an ends: solving a problem. Solving some of these problems like the one that GP discussed have more to do with math than programming. The programming is mostly the implementation of the math. So if you&#x27;re not versed in that math, of course you wouldn&#x27;t understand the code that&#x27;s being written to implement it.<p>Building machine learning systems is vastly different from building operating systems which is vastly different from embedded systems which is vastly different from networking which is vastly different what most of us do (myself included), which is building CRUD apps. We&#x27;re just solving different problems. Of course there are common themes to writing good code, just like there are common themes to performing science, but the code and solutions will look almost nothing alike.</div><br/></div></div><div id="39718384" class="c"><input type="checkbox" id="c-39718384" checked=""/><div class="controls bullet"><span class="by">Operyl</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718249">parent</a><span>|</span><a href="#39718491">prev</a><span>|</span><a href="#39719686">next</a><span>|</span><label class="collapse" for="c-39718384">[-]</label><label class="expand" for="c-39718384">[1 more]</label></div><br/><div class="children"><div class="content">Because there are so many fields of software development, and you don’t need to be good in all of them. Don’t put yourself down for not understanding, you can always put some time into algorithms again if you need to :).</div><br/></div></div><div id="39719686" class="c"><input type="checkbox" id="c-39719686" checked=""/><div class="controls bullet"><span class="by">acomar</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718249">parent</a><span>|</span><a href="#39718384">prev</a><span>|</span><a href="#39718212">next</a><span>|</span><label class="collapse" for="c-39719686">[-]</label><label class="expand" for="c-39719686">[1 more]</label></div><br/><div class="children"><div class="content">most of the optimizations discussed are actually kind of obvious if you know how chess notation works in the first place. like the reason the starting move &quot;Nf3&quot; makes any sense is because only 1 knight of all 4 on the board can possibly move to f3 on the first move. what the OP is doing is trying to take that kind of information density and trying to represent it, first by assigning bits to each part of a possible move and then by paring it down where the space of legal moves excludes entire categories of possibilities. there&#x27;s another article that goes much further into how much optimization is possible here: <a href="https:&#x2F;&#x2F;lichess.org&#x2F;@&#x2F;lichess&#x2F;blog&#x2F;developer-update-275-improved-game-compression&#x2F;Wqa7GiAA" rel="nofollow">https:&#x2F;&#x2F;lichess.org&#x2F;@&#x2F;lichess&#x2F;blog&#x2F;developer-update-275-impr...</a></div><br/></div></div></div></div><div id="39718212" class="c"><input type="checkbox" id="c-39718212" checked=""/><div class="controls bullet"><span class="by">porphyra</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39718249">prev</a><span>|</span><a href="#39719144">next</a><span>|</span><label class="collapse" for="c-39718212">[-]</label><label class="expand" for="c-39718212">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, compression is just the dual problem of prediction, so the better you are at predicting the next move, the better you can compress.</div><br/></div></div><div id="39719144" class="c"><input type="checkbox" id="c-39719144" checked=""/><div class="controls bullet"><span class="by">groby_b</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39718212">prev</a><span>|</span><a href="#39718297">next</a><span>|</span><label class="collapse" for="c-39719144">[-]</label><label class="expand" for="c-39719144">[3 more]</label></div><br/><div class="children"><div class="content">Lichess covered that :)<p><a href="https:&#x2F;&#x2F;lichess.org&#x2F;@&#x2F;lichess&#x2F;blog&#x2F;developer-update-275-improved-game-compression&#x2F;Wqa7GiAA" rel="nofollow">https:&#x2F;&#x2F;lichess.org&#x2F;@&#x2F;lichess&#x2F;blog&#x2F;developer-update-275-impr...</a></div><br/><div id="39721111" class="c"><input type="checkbox" id="c-39721111" checked=""/><div class="controls bullet"><span class="by">joshka</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719144">parent</a><span>|</span><a href="#39718297">next</a><span>|</span><label class="collapse" for="c-39721111">[-]</label><label class="expand" for="c-39721111">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s neat, so it looks like ln2(216) =~ 7.7 bits to encode any valid move, and then compresses to even better!</div><br/><div id="39721586" class="c"><input type="checkbox" id="c-39721586" checked=""/><div class="controls bullet"><span class="by">groby_b</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39721111">parent</a><span>|</span><a href="#39718297">next</a><span>|</span><label class="collapse" for="c-39721586">[-]</label><label class="expand" for="c-39721586">[1 more]</label></div><br/><div class="children"><div class="content">Yep. There&#x27;s a paper somewhere claiming that the lower bound is ~5.1 bits&#x2F;move, based on an exhaustive analysis of existing games.<p><a href="https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Encoding_Moves" rel="nofollow">https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Encoding_Moves</a> sort-of mentions it (search for 5.11), but I can&#x27;t for the life of me find the actual analysis.</div><br/></div></div></div></div></div></div><div id="39718297" class="c"><input type="checkbox" id="c-39718297" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39719144">prev</a><span>|</span><a href="#39718752">next</a><span>|</span><label class="collapse" for="c-39718297">[-]</label><label class="expand" for="c-39718297">[3 more]</label></div><br/><div class="children"><div class="content">So, Huffman encoding but for chess moves?</div><br/><div id="39718314" class="c"><input type="checkbox" id="c-39718314" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718297">parent</a><span>|</span><a href="#39718752">next</a><span>|</span><label class="collapse" for="c-39718314">[-]</label><label class="expand" for="c-39718314">[2 more]</label></div><br/><div class="children"><div class="content">Kinda, but with a different dynamically determined dictionary for each successive position.</div><br/><div id="39718875" class="c"><input type="checkbox" id="c-39718875" checked=""/><div class="controls bullet"><span class="by">transitionnel</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718314">parent</a><span>|</span><a href="#39718752">next</a><span>|</span><label class="collapse" for="c-39718875">[-]</label><label class="expand" for="c-39718875">[1 more]</label></div><br/><div class="children"><div class="content">This is the kind of discussion that will get us micro-cybernetics in that ~1 year window.</div><br/></div></div></div></div></div></div><div id="39718752" class="c"><input type="checkbox" id="c-39718752" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39718297">prev</a><span>|</span><a href="#39718674">next</a><span>|</span><label class="collapse" for="c-39718752">[-]</label><label class="expand" for="c-39718752">[10 more]</label></div><br/><div class="children"><div class="content">Im confused, how does probability help here when you need to encode the possibility of all legal moves?</div><br/><div id="39718820" class="c"><input type="checkbox" id="c-39718820" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718752">parent</a><span>|</span><a href="#39718874">next</a><span>|</span><label class="collapse" for="c-39718820">[-]</label><label class="expand" for="c-39718820">[2 more]</label></div><br/><div class="children"><div class="content">You use variable-length encodings—shorter encodings for more likely moves, longer encodings for ones that happen infrequently.<p>This is the thing the parent comment was referring to,<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Huffman_coding" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Huffman_coding</a></div><br/></div></div><div id="39718874" class="c"><input type="checkbox" id="c-39718874" checked=""/><div class="controls bullet"><span class="by">jprete</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718752">parent</a><span>|</span><a href="#39718820">prev</a><span>|</span><a href="#39719068">next</a><span>|</span><label class="collapse" for="c-39718874">[-]</label><label class="expand" for="c-39718874">[1 more]</label></div><br/><div class="children"><div class="content">Using the probability distribution of moves at any given position, so that more likely moves take less space, will result in saving space on average.<p>This is the same as Huffman coding, just applied to a different domain.<p>For that matter, it might also resemble LLM compression of input text, although LLM compression is intentionally lossy and the above schemes are not.</div><br/></div></div><div id="39719068" class="c"><input type="checkbox" id="c-39719068" checked=""/><div class="controls bullet"><span class="by">neon5077</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718752">parent</a><span>|</span><a href="#39718874">prev</a><span>|</span><a href="#39718674">next</a><span>|</span><label class="collapse" for="c-39719068">[-]</label><label class="expand" for="c-39719068">[6 more]</label></div><br/><div class="children"><div class="content">Look up Huffman codes on Wikipedia.<p>In short, you put the most likely or most common values at the front of the dictionary. Values 0-255 take up one byte, 256-65535 take two bytes, etc. The lower your index, the fewer bits are needed to represent the corresponding state.</div><br/><div id="39719386" class="c"><input type="checkbox" id="c-39719386" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719068">parent</a><span>|</span><a href="#39719191">next</a><span>|</span><label class="collapse" for="c-39719386">[-]</label><label class="expand" for="c-39719386">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re missing an important detail of Huffman codes: they need to be prefix-free so you can actually tell when one value ends and another begins.<p>A simplified example: suppose you have four letters in your alphabet that you want to represent in binary. You can&#x27;t just represent these as A=0, B=1, C=10, and D=01, since it&#x27;s impossible to tell whether &quot;01011&quot; is meant to represent ABABB or DDA or ACBB.<p>(Hamming codes on the other hand are intended for error correction, where you want maximally distant code words to minimize the chance that bitflips cause decoding errors.)</div><br/><div id="39720123" class="c"><input type="checkbox" id="c-39720123" checked=""/><div class="controls bullet"><span class="by">neon5077</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719386">parent</a><span>|</span><a href="#39719191">next</a><span>|</span><label class="collapse" for="c-39720123">[-]</label><label class="expand" for="c-39720123">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really think that&#x27;s too relevant to the core concept of using fewer bits for the most common codes.<p>That&#x27;s really a problem inherent to binary streams in general, not just Huffman encoding.</div><br/><div id="39720850" class="c"><input type="checkbox" id="c-39720850" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39720123">parent</a><span>|</span><a href="#39719191">next</a><span>|</span><label class="collapse" for="c-39720850">[-]</label><label class="expand" for="c-39720850">[1 more]</label></div><br/><div class="children"><div class="content">It was a minor point re: this claim:<p>&gt; Values 0-255 take up one byte, 256-65535 take two bytes<p>If you wanted to encode more than 256 values, then at best you&#x27;d be able to specify values 0-254 taking one byte, e.g. if you used 0xff as a special prefix to represent &quot;use another byte for all other values&quot;, but that particular encoding means that you&#x27;d only be able to encode another 256 values with a second byte.</div><br/></div></div></div></div></div></div><div id="39719191" class="c"><input type="checkbox" id="c-39719191" checked=""/><div class="controls bullet"><span class="by">angry_albatross</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719068">parent</a><span>|</span><a href="#39719386">prev</a><span>|</span><a href="#39718674">next</a><span>|</span><label class="collapse" for="c-39719191">[-]</label><label class="expand" for="c-39719191">[2 more]</label></div><br/><div class="children"><div class="content">I think you mean Huffman codes, not Hamming codes.</div><br/><div id="39720045" class="c"><input type="checkbox" id="c-39720045" checked=""/><div class="controls bullet"><span class="by">neon5077</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39719191">parent</a><span>|</span><a href="#39718674">next</a><span>|</span><label class="collapse" for="c-39720045">[-]</label><label class="expand" for="c-39720045">[1 more]</label></div><br/><div class="children"><div class="content">Yup.</div><br/></div></div></div></div></div></div></div></div><div id="39718674" class="c"><input type="checkbox" id="c-39718674" checked=""/><div class="controls bullet"><span class="by">dmurray</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39718752">prev</a><span>|</span><a href="#39721082">next</a><span>|</span><label class="collapse" for="c-39718674">[-]</label><label class="expand" for="c-39718674">[2 more]</label></div><br/><div class="children"><div class="content">With a different engine for weaker players, whose moves would generally need a longer representation to encode. For most use cases where you&#x27;re encoding a ton of PGNs, you also encode some information about the playing strength of the players, so you get that for free.</div><br/><div id="39723324" class="c"><input type="checkbox" id="c-39723324" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39718674">parent</a><span>|</span><a href="#39721082">next</a><span>|</span><label class="collapse" for="c-39723324">[-]</label><label class="expand" for="c-39723324">[1 more]</label></div><br/><div class="children"><div class="content">This probably isn&#x27;t necessary. Anyone past beginner is still <i>sometimes</i> playing one of the best moves for each move, and when they don&#x27;t it is probably not bad in a predictable way.</div><br/></div></div></div></div><div id="39721082" class="c"><input type="checkbox" id="c-39721082" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39718674">prev</a><span>|</span><a href="#39721460">next</a><span>|</span><label class="collapse" for="c-39721082">[-]</label><label class="expand" for="c-39721082">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Let an engine assign each legal move m some probability p of being played.</i><p>This assumes you&#x27;re storing moves of players who are good at chess!</div><br/><div id="39723314" class="c"><input type="checkbox" id="c-39723314" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39721082">parent</a><span>|</span><a href="#39721460">next</a><span>|</span><label class="collapse" for="c-39723314">[-]</label><label class="expand" for="c-39723314">[2 more]</label></div><br/><div class="children"><div class="content">No, it just saves more space when the players are good. (Note the engine assigns <i>each</i> legal move a probability.)</div><br/><div id="39723833" class="c"><input type="checkbox" id="c-39723833" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#39717990">root</a><span>|</span><a href="#39723314">parent</a><span>|</span><a href="#39721460">next</a><span>|</span><label class="collapse" for="c-39723833">[-]</label><label class="expand" for="c-39723833">[1 more]</label></div><br/><div class="children"><div class="content">They said one can do better on average this way. That conclusion does rest on an assumption.<p>Anyway, I wrote it in the form of a joke, but I was trying to suggest that for optimal compression, you may need to model how a player actually plays, not how they should ideally do it.</div><br/></div></div></div></div></div></div><div id="39721460" class="c"><input type="checkbox" id="c-39721460" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39721082">prev</a><span>|</span><a href="#39722460">next</a><span>|</span><label class="collapse" for="c-39721460">[-]</label><label class="expand" for="c-39721460">[1 more]</label></div><br/><div class="children"><div class="content">Yep, make an LLM but for chess moves.</div><br/></div></div><div id="39722460" class="c"><input type="checkbox" id="c-39722460" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#39717990">parent</a><span>|</span><a href="#39721460">prev</a><span>|</span><a href="#39717999">next</a><span>|</span><label class="collapse" for="c-39722460">[-]</label><label class="expand" for="c-39722460">[1 more]</label></div><br/><div class="children"><div class="content">what you&#x27;re describing is arithmetic coding, correct?</div><br/></div></div></div></div><div id="39717999" class="c"><input type="checkbox" id="c-39717999" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39717990">prev</a><span>|</span><a href="#39718124">next</a><span>|</span><label class="collapse" for="c-39717999">[-]</label><label class="expand" for="c-39717999">[7 more]</label></div><br/><div class="children"><div class="content">FTA: <i>“But they don’t account for the majority of what I’m storing, which are PGNs.”</i><p>If they’re storing chess games, why do they try to compress individual moves?<p>If you compress games, you can get much better compression. For example, in any board position, deterministically order all legal moves (they’re already ignoring some illegal moves in their setup, so I think ignoring all is within the rules of the game), and write down the number of the move made.<p>At game start, that will be an integer between 1 and 20 (16 different pawn moves, 4 different knight moves). Black’s reply similarly will be an integer between 1 and 20. For white’s second move, the maximum will depend on the first move.<p>To compress an entire game, use arithmetic encoding (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Arithmetic_coding" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Arithmetic_coding</a>). If there are, on average, <i>n</i> legal moves per position, that will use <i>2log n</i> bits per move.<p><a href="https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Chess_Position" rel="nofollow">https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Chess_Position</a>: <i>“The maximum number of moves per chess position seems 218”</i>, so that will give you less than 8 bits per move. In real life, it probably will be less than 6.<p>The only reason I see why this wouldn’t be an option is performance. Decoding would require move generation and thus be more complex.<p>To improve on that, make a deterministic predictor of how likely moves are and use that to improve on the arithmetic encoder. That probably isn’t worth it, though because of the increased decoding complexity.</div><br/><div id="39719350" class="c"><input type="checkbox" id="c-39719350" checked=""/><div class="controls bullet"><span class="by">marcusbuffett</span><span>|</span><a href="#39717999">parent</a><span>|</span><a href="#39722132">next</a><span>|</span><label class="collapse" for="c-39719350">[-]</label><label class="expand" for="c-39719350">[5 more]</label></div><br/><div class="children"><div class="content">I did end up doing something like this: <a href="https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-further&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-furt...</a><p>You’re spot on about the performance reason I didn’t want to do this originally, but I did some testing and turns out move generation in the library I use is Blazing Fast and wouldn’t be a bottleneck</div><br/><div id="39723179" class="c"><input type="checkbox" id="c-39723179" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39717999">root</a><span>|</span><a href="#39719350">parent</a><span>|</span><a href="#39721207">next</a><span>|</span><label class="collapse" for="c-39723179">[-]</label><label class="expand" for="c-39723179">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t seem to have a public repository for the code described in your posts (presumably a part of Chessbook?), but you might be using a textbook arithmetic coding algorithm which maintains both lower and upper bounds and does a renormalization by comparing topmost bits. If it&#x27;s the case rANS would be much simpler to write and more efficient [1]. If your AC code is already well-optimized, there is not much reason to switch though.<p>[1] Fabian Giesen&#x27;s sample implementation is already as good as is, and also contains a good alias table implementation if you want multi-symbol inputs: <a href="https:&#x2F;&#x2F;github.com&#x2F;rygorous&#x2F;ryg_rans&#x2F;blob&#x2F;master&#x2F;rans_byte.h">https:&#x2F;&#x2F;github.com&#x2F;rygorous&#x2F;ryg_rans&#x2F;blob&#x2F;master&#x2F;rans_byte.h</a></div><br/></div></div><div id="39721207" class="c"><input type="checkbox" id="c-39721207" checked=""/><div class="controls bullet"><span class="by">joshka</span><span>|</span><a href="#39717999">root</a><span>|</span><a href="#39719350">parent</a><span>|</span><a href="#39723179">prev</a><span>|</span><a href="#39719502">next</a><span>|</span><label class="collapse" for="c-39721207">[-]</label><label class="expand" for="c-39721207">[1 more]</label></div><br/><div class="children"><div class="content">I just added your blog to my RSS reader and noticed that your blog title in the RSS is a bit weird (in case you were unaware):<p><pre><code>    &lt;title&gt;Posts on A blog&lt;&#x2F;title&gt;
    &lt;link&gt;https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;&lt;&#x2F;link&gt;
    &lt;description&gt;Recent content in Posts on A blog&lt;&#x2F;description&gt;</code></pre></div><br/></div></div><div id="39719502" class="c"><input type="checkbox" id="c-39719502" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#39717999">root</a><span>|</span><a href="#39719350">parent</a><span>|</span><a href="#39721207">prev</a><span>|</span><a href="#39722132">next</a><span>|</span><label class="collapse" for="c-39719502">[-]</label><label class="expand" for="c-39719502">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also that PGN allows you to encode illegal moves, which is important if your dataset contains over-the-board games.<p>That you only got to about 10-12 bits per move is actually kind of sad in a way, because it means you&#x27;re not doing substantially better than the approach where you record a move as just (delete-piece-at ____, recreate-that-piece-at ____) 12-bit pairs, where castles are implicitly only recorded by moving the king further than usual and underpromotion has to be explicitly recorded with an extra 12-bit move that is otherwise semantically impossible.</div><br/><div id="39723039" class="c"><input type="checkbox" id="c-39723039" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39717999">root</a><span>|</span><a href="#39719502">parent</a><span>|</span><a href="#39722132">next</a><span>|</span><label class="collapse" for="c-39723039">[-]</label><label class="expand" for="c-39723039">[1 more]</label></div><br/><div class="children"><div class="content">Such games should be infrequent enough that you don&#x27;t need to optimize for them. A single unused code (or for arithmetic coding, a single symbol with a very low but non-zero frequency) can be used as an escape for a full non-optimized move format.</div><br/></div></div></div></div></div></div><div id="39722132" class="c"><input type="checkbox" id="c-39722132" checked=""/><div class="controls bullet"><span class="by">VikingCoder</span><span>|</span><a href="#39717999">parent</a><span>|</span><a href="#39719350">prev</a><span>|</span><a href="#39718124">next</a><span>|</span><label class="collapse" for="c-39722132">[-]</label><label class="expand" for="c-39722132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At game start, that will be an integer between 1 and 20 (16 different pawn moves, 4 different knight moves).<p>And offer draw.<p>And resign.<p>Just to complete that thought.</div><br/></div></div></div></div><div id="39718124" class="c"><input type="checkbox" id="c-39718124" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#39717999">prev</a><span>|</span><a href="#39718040">next</a><span>|</span><label class="collapse" for="c-39718124">[-]</label><label class="expand" for="c-39718124">[2 more]</label></div><br/><div class="children"><div class="content">Related follow-up from same author:<p><i>Compressing Chess Moves Even Further, To 3.7 Bits Per Move</i><p><a href="https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-further&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-furt...</a></div><br/><div id="39722029" class="c"><input type="checkbox" id="c-39722029" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#39718124">parent</a><span>|</span><a href="#39718040">next</a><span>|</span><label class="collapse" for="c-39722029">[-]</label><label class="expand" for="c-39722029">[1 more]</label></div><br/><div class="children"><div class="content">Awesome. Amusingly they didn&#x27;t actually mention the final move size anywhere except the title.</div><br/></div></div></div></div><div id="39718040" class="c"><input type="checkbox" id="c-39718040" checked=""/><div class="controls bullet"><span class="by">nmilo</span><span>|</span><a href="#39718124">prev</a><span>|</span><a href="#39718062">next</a><span>|</span><label class="collapse" for="c-39718040">[-]</label><label class="expand" for="c-39718040">[6 more]</label></div><br/><div class="children"><div class="content">Not sure the author&#x27;s use case the naive solution seems like just using 6 bits for the piece&#x27;s original position, 6 bits for the destination, and 2 bits to designate promotion type, for 14 total bits. Everything else can be found from the board state, and I can&#x27;t imagine a scenario where you have a move, want to convert to algebraic notation, and also don&#x27;t know what the board is.</div><br/><div id="39719105" class="c"><input type="checkbox" id="c-39719105" checked=""/><div class="controls bullet"><span class="by">jprete</span><span>|</span><a href="#39718040">parent</a><span>|</span><a href="#39718308">next</a><span>|</span><label class="collapse" for="c-39719105">[-]</label><label class="expand" for="c-39719105">[3 more]</label></div><br/><div class="children"><div class="content">I had very similar thoughts but I think one can do much better, even.<p>Each move only needs four bits to identify the piece because each side only has 16 pieces at maximum. The game replayer would need to keep track of each pawn&#x27;s starting file though (including after promotions).<p>Variable-length encodings of the move options help a lot. Pawns only need two bits because there are never more than four legal moves for a pawn - except for promotions, but just handle those specially for those exact cases (if a pawn moves to the last rank then encode the promotion with two bits, otherwise encode the next move). Knights and kings each need three bits for the move - encode each king-castling option as a move to the appropriate rear diagonal (normally off the board so not otherwise legal). Bishops and rooks need four bits (rank and direction). Queens only need five (three bits for rank, two for direction).<p>This way you can get down to between six and nine bits per move.</div><br/><div id="39719241" class="c"><input type="checkbox" id="c-39719241" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39718040">root</a><span>|</span><a href="#39719105">parent</a><span>|</span><a href="#39718308">next</a><span>|</span><label class="collapse" for="c-39719241">[-]</label><label class="expand" for="c-39719241">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The game replayer would need to keep track of each pawn&#x27;s starting file though (including after promotions).<p>That seems unnecessary. Don’t index the pieces based on their type and where they started — index them based on their current location. So the piece the lexicographically first (rank, file) is piece 0, and 4 bits trivially identifies a piece once you know the color.</div><br/><div id="39719288" class="c"><input type="checkbox" id="c-39719288" checked=""/><div class="controls bullet"><span class="by">jprete</span><span>|</span><a href="#39718040">root</a><span>|</span><a href="#39719241">parent</a><span>|</span><a href="#39718308">next</a><span>|</span><label class="collapse" for="c-39719288">[-]</label><label class="expand" for="c-39719288">[1 more]</label></div><br/><div class="children"><div class="content">True, I hadn&#x27;t thought of that.</div><br/></div></div></div></div></div></div><div id="39718308" class="c"><input type="checkbox" id="c-39718308" checked=""/><div class="controls bullet"><span class="by">andruby</span><span>|</span><a href="#39718040">parent</a><span>|</span><a href="#39719105">prev</a><span>|</span><a href="#39719141">next</a><span>|</span><label class="collapse" for="c-39718308">[-]</label><label class="expand" for="c-39718308">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking the same thing. Often both squares will be close to each other, so I&#x27;m sure that a generic compression (eg zstd) can even reduce it even further by taking advantage of that proximity.</div><br/></div></div><div id="39719141" class="c"><input type="checkbox" id="c-39719141" checked=""/><div class="controls bullet"><span class="by">groby_b</span><span>|</span><a href="#39718040">parent</a><span>|</span><a href="#39718308">prev</a><span>|</span><a href="#39718062">next</a><span>|</span><label class="collapse" for="c-39719141">[-]</label><label class="expand" for="c-39719141">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that the board state requirement makes searching for specific moves hard.<p>But if you allow board state, you can do less than 14. 3 bits for the type of piece, 6 for the destination, 2 extra bits. (Promotion if destination is last&#x2F;first line, disambiguation for pawns in en passant)<p>You&#x27;re still at about twice the theoretical minimum, I think. I vaguely recall an upper bound of 6 bits?</div><br/></div></div></div></div><div id="39718062" class="c"><input type="checkbox" id="c-39718062" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#39718040">prev</a><span>|</span><a href="#39718449">next</a><span>|</span><label class="collapse" for="c-39718062">[-]</label><label class="expand" for="c-39718062">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kinda complex.<p>I think my initial stab would be to encoding the source position (6 bits) and end position (6 bits) for a constant 12 bits per move.<p>You don&#x27;t need to store whether it&#x27;s a capture, you can figure that out from the game state. You don&#x27;t need to store disambiguations, there are none in that format. You don&#x27;t need to store check&#x2F;mate, you can figure that out from the game state.<p>The only wrinkles (that I can tell) are castles and promotions. But you can get around this by the fact that kings and pawns have limited movement, so their legal destination squares are highly constrained.<p>So you could signal a promotion by encoding the destination with opposite rank, and using the file to encode which piece. Promoting to a rook on c8 gets its destination encoded as a1 - &quot;a&quot; for a rook, and &quot;1&quot; to indicate a promotion.<p>Similarly, you could encode a castle by encoding the king&#x27;s move with opposite destination rank. Castling the king to f1 gets encoded as f8, and to g1 as g8.</div><br/><div id="39721072" class="c"><input type="checkbox" id="c-39721072" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#39718062">parent</a><span>|</span><a href="#39718170">next</a><span>|</span><label class="collapse" for="c-39721072">[-]</label><label class="expand" for="c-39721072">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Similarly, you could encode a castle by encoding the king&#x27;s move with opposite destination rank. Castling the king to f1 gets encoded as f8, and to g1 as g8.<p>You are overcomplicating this. For castling just record it as the King&#x27;s source and destination. E.g., White kingside castling is e1g1, White castling queenside is e1c1, Black castling kingside is e8g8, and white castling queenside is e8c8.<p>All king moves other than castling move the king at most one file, so when you see a king on e1 and the move is e1g1 or e1c2 which is a move of two files you can infer that it must be castling.<p>For promotion, I suggest splitting it into two cases: promotion to a queen and promotion to something else. I saw a post once on Reddit from someone who analyzed promotions from all games in the Lichess database, and 98.7% were to queens, so we&#x27;ll make that case the simplest.<p>I suggest that pawns that promote to a queen are simply recorded as moving to the promotion square. It is implicit that they promote to a queen. For example a pawn at b7 that moves straight forward and promotes to a queen would be recorded as b7b8. A pawn at b7 that captures on a8 and promotes to a queen would be recorded as b7a8.<p>For pawns that promote to a rook, record the move as a move to a square one rank back from the promotion square. For example b7b8 promoting to rook would be recorded as b7b7, and b7a8 promoting to a rook would be recorded as b7a7.<p>Similarly for promotions to bishops. Record the destination two ranks back. So b7b8 promoting to bishop would be b7b6. Similar for knights but three ranks back, so b7a5 for a pawn at b7 that captures on a8 and promotes to a knight.</div><br/><div id="39721297" class="c"><input type="checkbox" id="c-39721297" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#39718062">root</a><span>|</span><a href="#39721072">parent</a><span>|</span><a href="#39718170">next</a><span>|</span><label class="collapse" for="c-39721297">[-]</label><label class="expand" for="c-39721297">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All king moves other than castling move the king at most one file, so when you see a king on e1 and the move is e1g1 or e1c2 which is a move of two files you can infer that it must be castling.<p>Yeah. For some reason I had a brain fart and thought that the two castles moved the king 1 and 2 files, instead of 2 and 3 files, and that made me think you needed to disambiguate a 1 file castle with a 1 file move.<p>Which is clearly dumb. I blame insufficient coffee.</div><br/></div></div></div></div><div id="39718170" class="c"><input type="checkbox" id="c-39718170" checked=""/><div class="controls bullet"><span class="by">porkbrain</span><span>|</span><a href="#39718062">parent</a><span>|</span><a href="#39721072">prev</a><span>|</span><a href="#39718449">next</a><span>|</span><label class="collapse" for="c-39718170">[-]</label><label class="expand" for="c-39718170">[4 more]</label></div><br/><div class="children"><div class="content">As for promotion: in a valid chess position you could promote a single pawn at three files simultaneously. One by moving forward and then left and right capture. Additionally, you could have two pawns promoting on the same square, again with capture. And you can have a combination of both.<p>Encode a white&#x27;s move exd8=N with white pawns on e7 and c7 and three black queens on f8, d8 and b8.</div><br/><div id="39718390" class="c"><input type="checkbox" id="c-39718390" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#39718062">root</a><span>|</span><a href="#39718170">parent</a><span>|</span><a href="#39718423">next</a><span>|</span><label class="collapse" for="c-39718390">[-]</label><label class="expand" for="c-39718390">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you could promote a single pawn at three files simultaneously. One by moving forward and then left and right capture.<p>Ooh, didn&#x27;t think of that, thanks. Still there&#x27;s enough constraint in the legal destination squares to work around that. There&#x27;s at least half the board that&#x27;s inaccessible to a pawn about to promote, which should be enough to encode any of the 3 legal destination squares and 5 possible promotion targets.<p>Edit: maybe keep the destination file as-is, and use the destination rank to encode the promotion piece?<p>&gt; Additionally, you could have two pawns promoting on the same square<p>The source square should disambiguate between those though, right?</div><br/></div></div><div id="39718423" class="c"><input type="checkbox" id="c-39718423" checked=""/><div class="controls bullet"><span class="by">nmilo</span><span>|</span><a href="#39718062">root</a><span>|</span><a href="#39718170">parent</a><span>|</span><a href="#39718390">prev</a><span>|</span><a href="#39722048">next</a><span>|</span><label class="collapse" for="c-39718423">[-]</label><label class="expand" for="c-39718423">[1 more]</label></div><br/><div class="children"><div class="content">You can encode a promotion as the destination file plus rank 1-4 for the 4 different kinds, since pawns can&#x27;t move backwards</div><br/></div></div><div id="39722048" class="c"><input type="checkbox" id="c-39722048" checked=""/><div class="controls bullet"><span class="by">fsniper</span><span>|</span><a href="#39718062">root</a><span>|</span><a href="#39718170">parent</a><span>|</span><a href="#39718423">prev</a><span>|</span><a href="#39718449">next</a><span>|</span><label class="collapse" for="c-39722048">[-]</label><label class="expand" for="c-39722048">[1 more]</label></div><br/><div class="children"><div class="content">Promotions could be compressed to<p>Source position -&gt; 6 bits
destination position as (
forward left &#x2F; forward &#x2F; forward right  -&gt; 2 bits
Target piece info Queen&#x2F;Bishop&#x2F;Knight&#x2F;Rook 2 bits
)</div><br/></div></div></div></div></div></div><div id="39718449" class="c"><input type="checkbox" id="c-39718449" checked=""/><div class="controls bullet"><span class="by">sdenton4</span><span>|</span><a href="#39718062">prev</a><span>|</span><a href="#39717927">next</a><span>|</span><label class="collapse" for="c-39718449">[-]</label><label class="expand" for="c-39718449">[9 more]</label></div><br/><div class="children"><div class="content">Use StockFish to predict the next move, and only store the diff between the actual move and the prediction.<p>Or, better, get a ranked list of all possible moves from stockfish, and use a variable-length integer to encode the position in the list. Then the best move takes ~1 bit, and worse moves take more bits. (And we can do fun things like compute how bad a player is by how big their game is after compression.)</div><br/><div id="39718781" class="c"><input type="checkbox" id="c-39718781" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39718449">parent</a><span>|</span><a href="#39718580">next</a><span>|</span><label class="collapse" for="c-39718781">[-]</label><label class="expand" for="c-39718781">[2 more]</label></div><br/><div class="children"><div class="content">The more advanced your predictor is, the slower your compressor gets. OP has 600 Million moves to encode, how long does it take to ask Stockfish for its opinion on 600M board states? (and then again, every time you want to decompress) (not a rhetorical question btw, I know little about chess engines)<p>I suspect the sweet spot here would be to use a much worse chess engine for the predictions, giving faster compression&#x2F;decompression at the expense of the compression ratio.</div><br/><div id="39719088" class="c"><input type="checkbox" id="c-39719088" checked=""/><div class="controls bullet"><span class="by">marcusbuffett</span><span>|</span><a href="#39718449">root</a><span>|</span><a href="#39718781">parent</a><span>|</span><a href="#39718580">next</a><span>|</span><label class="collapse" for="c-39719088">[-]</label><label class="expand" for="c-39719088">[1 more]</label></div><br/><div class="children"><div class="content">Your intuition here is right on the money. I wrote a subsequent post with pretty much that exact approach: <a href="https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-further&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-furt...</a></div><br/></div></div></div></div><div id="39718580" class="c"><input type="checkbox" id="c-39718580" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#39718449">parent</a><span>|</span><a href="#39718781">prev</a><span>|</span><a href="#39721452">next</a><span>|</span><label class="collapse" for="c-39718580">[-]</label><label class="expand" for="c-39718580">[5 more]</label></div><br/><div class="children"><div class="content">I almost agree, but as other comment says, it&#x27;s probaby better to use the StocFish points to generate a probability and then use Huffman encoding.</div><br/><div id="39718801" class="c"><input type="checkbox" id="c-39718801" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39718449">root</a><span>|</span><a href="#39718580">parent</a><span>|</span><a href="#39721452">next</a><span>|</span><label class="collapse" for="c-39718801">[-]</label><label class="expand" for="c-39718801">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;d probably want to use something like CABAC rather than Huffman, since it deals better with dynamic probabilities. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Context-adaptive_binary_arithmetic_coding" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Context-adaptive_binary_arithm...</a></div><br/><div id="39720714" class="c"><input type="checkbox" id="c-39720714" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#39718449">root</a><span>|</span><a href="#39718801">parent</a><span>|</span><a href="#39721452">next</a><span>|</span><label class="collapse" for="c-39720714">[-]</label><label class="expand" for="c-39720714">[3 more]</label></div><br/><div class="children"><div class="content">It looks like a very interesting comparison. I still not sure how to tranform StockFish points to probabilities. (Perhaps proportional to exp(-difference&#x2F;temperature), where temperature is a magical number or perhaps it&#x27;s like something&#x2F;elo??? There are too many parameters to tweak.)</div><br/><div id="39720749" class="c"><input type="checkbox" id="c-39720749" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39718449">root</a><span>|</span><a href="#39720714">parent</a><span>|</span><a href="#39721452">next</a><span>|</span><label class="collapse" for="c-39720749">[-]</label><label class="expand" for="c-39720749">[2 more]</label></div><br/><div class="children"><div class="content">Given OP&#x27;s dataset, you could probably figure out how to map them, experimentally (e.g. by making a histogram)</div><br/><div id="39721828" class="c"><input type="checkbox" id="c-39721828" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#39718449">root</a><span>|</span><a href="#39720749">parent</a><span>|</span><a href="#39721452">next</a><span>|</span><label class="collapse" for="c-39721828">[-]</label><label class="expand" for="c-39721828">[1 more]</label></div><br/><div class="children"><div class="content">I was imagining downloading the lichess database and trying different strategies to compress it, It&#x27;s too much work for me, but I&#x27;d love to read a blog post if somsome does that.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39721452" class="c"><input type="checkbox" id="c-39721452" checked=""/><div class="controls bullet"><span class="by">V-2</span><span>|</span><a href="#39718449">parent</a><span>|</span><a href="#39718580">prev</a><span>|</span><a href="#39717927">next</a><span>|</span><label class="collapse" for="c-39721452">[-]</label><label class="expand" for="c-39721452">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Use StockFish to predict the next move, and only store the diff between the actual move and the prediction.<p>This ties the algorithm down to one specific version of Stockfish, and configured identically (stuff like the hashtable size etc.), because all such factors will have an impact on Stockfish&#x27;s evaluations. One factor changes, and you can&#x27;t decompress the backup.</div><br/></div></div></div></div><div id="39717927" class="c"><input type="checkbox" id="c-39717927" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#39718449">prev</a><span>|</span><a href="#39723036">next</a><span>|</span><label class="collapse" for="c-39717927">[-]</label><label class="expand" for="c-39717927">[1 more]</label></div><br/><div class="children"><div class="content">Related, compressing bingo cards:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;diku-dk&#x2F;openbanko">https:&#x2F;&#x2F;github.com&#x2F;diku-dk&#x2F;openbanko</a><p>Among other things, contains:<p>Theoretically optimal compression of excessive amounts of bingo cards<p>GPU-accelerated massively parallel bingo simulation using Futhark<p>I suspect the research was triggered by a late professor of Computer Science who unironically calculated how many (Danish) bingo cards there are: <a href="https:&#x2F;&#x2F;sprutskalle.dk&#x2F;blog&#x2F;wp-content&#x2F;uploads&#x2F;bankoplader.pdf" rel="nofollow">https:&#x2F;&#x2F;sprutskalle.dk&#x2F;blog&#x2F;wp-content&#x2F;uploads&#x2F;bankoplader.p...</a> -- to see the mathematical rigour played out on such a casual question is nothing but inspirational.</div><br/></div></div><div id="39723036" class="c"><input type="checkbox" id="c-39723036" checked=""/><div class="controls bullet"><span class="by">billforsternz</span><span>|</span><a href="#39717927">prev</a><span>|</span><a href="#39723063">next</a><span>|</span><label class="collapse" for="c-39723036">[-]</label><label class="expand" for="c-39723036">[2 more]</label></div><br/><div class="children"><div class="content">I went through this process many years ago and documented it here <a href="https:&#x2F;&#x2F;triplehappy.wordpress.com&#x2F;2015&#x2F;10&#x2F;26&#x2F;chess-move-compression&#x2F;" rel="nofollow">https:&#x2F;&#x2F;triplehappy.wordpress.com&#x2F;2015&#x2F;10&#x2F;26&#x2F;chess-move-comp...</a><p>Basically I demonstrate how you can compress to much less than one byte per move, but settle instead on a one byte per move scheme that is also very performant, something you&#x27;d have to sacrifice for optimal compression. I used this one byte representation to good effect in my chess GUI Tarrasch <a href="https:&#x2F;&#x2F;triplehappy.com" rel="nofollow">https:&#x2F;&#x2F;triplehappy.com</a></div><br/><div id="39723057" class="c"><input type="checkbox" id="c-39723057" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39723036">parent</a><span>|</span><a href="#39723063">next</a><span>|</span><label class="collapse" for="c-39723057">[-]</label><label class="expand" for="c-39723057">[1 more]</label></div><br/><div class="children"><div class="content">There was also a lengthy off-topic discussion about the compressed board representation this year [1].<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39065595">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39065595</a></div><br/></div></div></div></div><div id="39723063" class="c"><input type="checkbox" id="c-39723063" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#39723036">prev</a><span>|</span><a href="#39717889">next</a><span>|</span><label class="collapse" for="c-39723063">[-]</label><label class="expand" for="c-39723063">[2 more]</label></div><br/><div class="children"><div class="content">If you actually want good compression, this is definitely not the proper way to go.<p>The proper way to go is to compute all available moves on a given position, assign them a probability distribution and then perform arithmetic coding using it.<p>If you want simplicity, assign an uniform distribution. For optimal compression, use an engine such as Stockfish to evaluate how strong the moves are, and then apply a statistical model that converts move strength to weights to make a probability distribution for; also use an opening books for the openings and tablebases for the endgames.<p>My wild guess is that it will probably result in something like 3-4 bits per move on average.<p>If you instead want a simple encoding, then encode in 4 bits the piece that moved based on any order on the chessboard squares, then in 6 bits the destination square for 10 bits per move.</div><br/></div></div><div id="39717889" class="c"><input type="checkbox" id="c-39717889" checked=""/><div class="controls bullet"><span class="by">sfeng</span><span>|</span><a href="#39723063">prev</a><span>|</span><a href="#39721632">next</a><span>|</span><label class="collapse" for="c-39717889">[-]</label><label class="expand" for="c-39717889">[4 more]</label></div><br/><div class="children"><div class="content">I would love to see this benchmarked against just running LZW compression on a list of the moves. I think the repeated nature of the moves means the entropy is actually rather low. It should be possible to come up with a compression dictionary which can save a lot more space than just a tight packing like this.</div><br/><div id="39718406" class="c"><input type="checkbox" id="c-39718406" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#39717889">parent</a><span>|</span><a href="#39717930">next</a><span>|</span><label class="collapse" for="c-39718406">[-]</label><label class="expand" for="c-39718406">[1 more]</label></div><br/><div class="children"><div class="content">LZW would do very badly on a list of binary chess moves.<p>Huffman (and even more so arithmetic encoding or ANS (asymmetric numeral systems [0]) would be significantly better, if you&#x27;re careful how you encode data.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asymmetric_numeral_systems" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asymmetric_numeral_systems</a></div><br/></div></div><div id="39717930" class="c"><input type="checkbox" id="c-39717930" checked=""/><div class="controls bullet"><span class="by">kondro</span><span>|</span><a href="#39717889">parent</a><span>|</span><a href="#39718406">prev</a><span>|</span><a href="#39718365">next</a><span>|</span><label class="collapse" for="c-39717930">[-]</label><label class="expand" for="c-39717930">[1 more]</label></div><br/><div class="children"><div class="content">Or a trained zstd dictionary.</div><br/></div></div><div id="39718365" class="c"><input type="checkbox" id="c-39718365" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#39717889">parent</a><span>|</span><a href="#39717930">prev</a><span>|</span><a href="#39721632">next</a><span>|</span><label class="collapse" for="c-39718365">[-]</label><label class="expand" for="c-39718365">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the repeated nature of the moves<p>On a single game? I don’t think the goal is to pack all plays together and unpack them every time. Every game must be individually accessible as I understand.</div><br/></div></div></div></div><div id="39721632" class="c"><input type="checkbox" id="c-39721632" checked=""/><div class="controls bullet"><span class="by">aj7</span><span>|</span><a href="#39717889">prev</a><span>|</span><a href="#39723394">next</a><span>|</span><label class="collapse" for="c-39721632">[-]</label><label class="expand" for="c-39721632">[2 more]</label></div><br/><div class="children"><div class="content">Position to position. 12 bits. Plus occasionally, an extra 12 bits for promotion. Promotion found by impossible position prefix. Whether it’s a capture, check, castle, what piece, etc. all interpreted by a reader program.  What am I missing here?</div><br/><div id="39721825" class="c"><input type="checkbox" id="c-39721825" checked=""/><div class="controls bullet"><span class="by">Dave_Rosenthal</span><span>|</span><a href="#39721632">parent</a><span>|</span><a href="#39723394">next</a><span>|</span><label class="collapse" for="c-39721825">[-]</label><label class="expand" for="c-39721825">[1 more]</label></div><br/><div class="children"><div class="content">+1 You&#x27;re not missing anything. And there are plenty of very simple ways to just use a few &quot;special destinations&quot; to encode any move including possible promotions in a constant 12 bits per move and be very fast to encode&#x2F;decode. The proposal in the article is just silly.<p>But really the whole thing is silly. 100 million games is a lot of chess, but at 1KB per &quot;inefficient&quot; PGN you are talking a whopping 100GB--big deal. (At 12 bits and, say, 80 half-moves on average, you are talking ~12GB.) Plus the article says that he is &quot;IO-constrained&quot; but shrinking game size isn&#x27;t going to help with random lookups--a PGN is already below the page size.<p>If you really did care about best compression you would simply assign all legal moves an index and use a heuristic (chess engine) to figure out which moves were likely (i.e. good). In chess, it&#x27;s not uncommon that good players are usually picking between only a few reasonable candidate moves. I wouldn&#x27;t be surprised if good compression of human games yielded something like 2-3 bits per move.</div><br/></div></div></div></div><div id="39723394" class="c"><input type="checkbox" id="c-39723394" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#39721632">prev</a><span>|</span><a href="#39719934">next</a><span>|</span><label class="collapse" for="c-39723394">[-]</label><label class="expand" for="c-39723394">[1 more]</label></div><br/><div class="children"><div class="content">Funny, I was just working on this same thing last week. I ended up using 16 bits per move. As other comments here note, you could do it in fewer bits, but everything is a trade-off: with speed, size, and what the goal of your compression is. For me, fixed-size, two bytes per move seems good.<p>Also, I don&#x27;t bother with storing capture, or check, because those you can infer from the game state. Again, depends on how you be using the result - I just wanted to be able to re-play the game state.</div><br/></div></div><div id="39719934" class="c"><input type="checkbox" id="c-39719934" checked=""/><div class="controls bullet"><span class="by">robrenaud</span><span>|</span><a href="#39723394">prev</a><span>|</span><a href="#39721589">next</a><span>|</span><label class="collapse" for="c-39719934">[-]</label><label class="expand" for="c-39719934">[3 more]</label></div><br/><div class="children"><div class="content">Only tangentially related, but I think the mid&#x2F;late game is a much more interesting&#x2F;useful&#x2F;hard avenue for chess tools.<p>Chess.com&#x27;s opening explorer is pretty good, which it seems like this is kind of trying to compete against.<p>What I struggle with is the post game review, where I make a dubious move but I don&#x27;t actually understand the reason why it&#x27;s bad.  Sure, the engine shows better moves and the refutation to my move, but I often don&#x27;t know why.  The automatically generated explanation is usually pretty poor.<p>I wish I had even a poor copy of Danya giving me commentary.<p>Perhaps I should just lean in and try to implement something like this, but focus it more on coaching than commentary.<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2212.08195.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2212.08195.pdf</a></div><br/><div id="39721469" class="c"><input type="checkbox" id="c-39721469" checked=""/><div class="controls bullet"><span class="by">V-2</span><span>|</span><a href="#39719934">parent</a><span>|</span><a href="#39720885">next</a><span>|</span><label class="collapse" for="c-39721469">[-]</label><label class="expand" for="c-39721469">[1 more]</label></div><br/><div class="children"><div class="content">I think that AI, overhyped as it may be, will truly get to shine when it comes to this aspect of chess - basically, tutoring.</div><br/></div></div><div id="39720885" class="c"><input type="checkbox" id="c-39720885" checked=""/><div class="controls bullet"><span class="by">jaryd</span><span>|</span><a href="#39719934">parent</a><span>|</span><a href="#39721469">prev</a><span>|</span><a href="#39721589">next</a><span>|</span><label class="collapse" for="c-39720885">[-]</label><label class="expand" for="c-39720885">[1 more]</label></div><br/><div class="children"><div class="content">You could check to see if one of his games has that position using <a href="https:&#x2F;&#x2F;fenfinder.com" rel="nofollow">https:&#x2F;&#x2F;fenfinder.com</a> (site I built). Of course it&#x27;s a long shot given the huge possibility-space of unique positions, but hey, one can hope :).</div><br/></div></div></div></div><div id="39721589" class="c"><input type="checkbox" id="c-39721589" checked=""/><div class="controls bullet"><span class="by">V-2</span><span>|</span><a href="#39719934">prev</a><span>|</span><a href="#39723418">next</a><span>|</span><label class="collapse" for="c-39721589">[-]</label><label class="expand" for="c-39721589">[2 more]</label></div><br/><div class="children"><div class="content">PGN is a highly redundant format, but it has the inherent advantage of being human readable. The problem is interesting, but I think it falls on the side of &quot;fun&quot; more than &quot;profit&quot;. Storage is cheap, and PGN files are still small. An average PGN is still below 1 kilobyte. So one movie in BlueRay quality = about 20 million games. That&#x27;s a lot. The practical problem is not storage, it&#x27;s computation. Basically, querying the game database quickly. Compression gets in the way of that.<p>For example, I&#x27;ve just played a game, now I want to go through the opening and fetch all games from the database that went through the same initial moves&#x2F;positions (that&#x27;s not the same thing, as a game may arrive at the same position through a different order of moves; AKA transposition). Let&#x27;s say, all the way until move 15 or 20, because it will only be at that point that a decent game finally becomes unique by deviating from all the recorded games in the database (AKA a novelty was played).<p>Or I want to find all games where an endgame of a Queen and a pawn against a lonely Queen occurred. There is actually a query language for that, named (surprise, surprise) Chess Query Language: <a href="https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Chess_Query_Language" rel="nofollow">https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Chess_Query_Language</a><p>I feel that whatever a superior alternative to PGN might be, its strength would likely be better queryability rather than higher storage efficiency as such.</div><br/><div id="39722126" class="c"><input type="checkbox" id="c-39722126" checked=""/><div class="controls bullet"><span class="by">marcusbuffett</span><span>|</span><a href="#39721589">parent</a><span>|</span><a href="#39723418">next</a><span>|</span><label class="collapse" for="c-39722126">[-]</label><label class="expand" for="c-39722126">[1 more]</label></div><br/><div class="children"><div class="content">The problem I’m facing with storing roughly 600 million shorter PGNs is that the database is 100GB or so, and I’m grabbing thousands of them sort of at random. This makes the query IO bound, even though the finding the pages they’re on is virtually instant with the indexes. So a smaller database means less pages read when I do these large reads, ideally. I also have other ideas on ordering the database in a smarter way, but hoping this part helps.</div><br/></div></div></div></div><div id="39723418" class="c"><input type="checkbox" id="c-39723418" checked=""/><div class="controls bullet"><span class="by">andy_threos_io</span><span>|</span><a href="#39721589">prev</a><span>|</span><a href="#39720958">next</a><span>|</span><label class="collapse" for="c-39723418">[-]</label><label class="expand" for="c-39723418">[1 more]</label></div><br/><div class="children"><div class="content">With a better coding you don&#x27;t need more than 8 bits for a move (less for some).<p>The implementation should store a state machine for the game, a struct for each pieces, and also the board with index to the pieces (occupation).<p>There is only 16 pieces for each player, the two players move one another.<p>The Naive would be that you index the pieces (4 bits) and store the movement after that,<p>Pawns 2 bits for movement  (2 forward,  2 diagonal)<p>King 4 bits for movement (normal move 1 + 3 bits,  castle 1 + 1 bits)<p>Knight 3 bits for movement  (8 possible move)<p>Rook 4 bits for movement ( 1 bit orientation horizontal&#x2F;vertical 3 bit new position )<p>Bishop 4 bits for movement ( 1 bit orientation  left&#x2F;right diagonal 3 bit new position)<p>Queen 5 bits for movement ( 2 bit orientation horizontal&#x2F;vertical&#x2F;  left&#x2F;right diagonal  3 bits for new position)<p>This way you need<p>Pawn 4 (index) + 2 (movement) = 6 bits<p>King 4 (index) + 4 (movement) = 8 bits<p>Knight 4 (index) + 3 (movement) = 7 bits<p>Rook, Bishop  4 (index) + 4 (movement) = 8 bits<p>Queen 4 (index) + 5 (movement) = 9 bits<p>But you can encode the pieces index in another way, that the Queen got 3 bit index and other pieces got longer index (Pawn 5 bits)<p>index bits + movement
000 + 5 movement   Queen     -&gt; 8 bits<p>00100 + 3 movement  King Normal   -&gt; 8 bits<p>00101 + 1 movement  King castle  -&gt; 6 bits<p>0011x + 3 movement  Knight (2)  -&gt; 8 bits<p>01xxx + 2 movement   Pawn (8)   -&gt; 7 bits<p>10x + 4 movement  Bishop (2) -&gt; 7 bits<p>11x + 4 movement  Rook (2) -&gt; 7 bits<p>Also other bit allocations are possible, I don&#x27;t know if it&#x27;s worth it to make the Pawns index 1 bit longer, but in this way the max 8 bits required for a movement. (You need the state machine for the &quot;decompression&quot;, also have to track that the black and white Pawns are moving in the opposite direction. )<p>There can be further compression, if you check the possible move for the piece.
ex. the first possible Knight movement is only 1 place, so no need to store the
movement. But this need more calculation.</div><br/></div></div><div id="39720958" class="c"><input type="checkbox" id="c-39720958" checked=""/><div class="controls bullet"><span class="by">dhsysusbsjsi</span><span>|</span><a href="#39723418">prev</a><span>|</span><a href="#39721905">next</a><span>|</span><label class="collapse" for="c-39720958">[-]</label><label class="expand" for="c-39720958">[2 more]</label></div><br/><div class="children"><div class="content">What I haven’t seen discussed here much is optimising for developer maintenance. I think the author’s solution is great for this; it’s easy to understand and each move has a bit pattern. Easy to debug. Somebody taking over in the future will understand this compression.<p>If on the other hand you can squeeze another 10% storage from Huffman encoded inverse tree lookup tables that only neckbeards understand, you’re limiting your pool of people able to do maintenance on this system in the future when the author is long gone.</div><br/><div id="39722042" class="c"><input type="checkbox" id="c-39722042" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#39720958">parent</a><span>|</span><a href="#39721905">next</a><span>|</span><label class="collapse" for="c-39722042">[-]</label><label class="expand" for="c-39722042">[1 more]</label></div><br/><div class="children"><div class="content">Hopefully you just use a library for the Huffman tables and there&#x27;s not much to maintain.</div><br/></div></div></div></div><div id="39721905" class="c"><input type="checkbox" id="c-39721905" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#39720958">prev</a><span>|</span><a href="#39718114">next</a><span>|</span><label class="collapse" for="c-39721905">[-]</label><label class="expand" for="c-39721905">[1 more]</label></div><br/><div class="children"><div class="content">Lichess&#x27;s equivalent blog post, using an even fancier technique.<p><a href="https:&#x2F;&#x2F;lichess.org&#x2F;@&#x2F;lichess&#x2F;blog&#x2F;developer-update-275-improved-game-compression&#x2F;Wqa7GiAA" rel="nofollow">https:&#x2F;&#x2F;lichess.org&#x2F;@&#x2F;lichess&#x2F;blog&#x2F;developer-update-275-impr...</a></div><br/></div></div><div id="39718114" class="c"><input type="checkbox" id="c-39718114" checked=""/><div class="controls bullet"><span class="by">evertedsphere</span><span>|</span><a href="#39721905">prev</a><span>|</span><a href="#39720989">next</a><span>|</span><label class="collapse" for="c-39718114">[-]</label><label class="expand" for="c-39718114">[3 more]</label></div><br/><div class="children"><div class="content">Some thoughts I had while reading this, probably not very original: the fact that chess moves are not random and usually adhere to opening theory to some degree means you could get some value out of using something like a trie of some small finite depth, trained on a database of games, to compress common opening lines much better, at the cost of making things like 1. a4 a5 2. h4 h5 that aren&#x27;t in the trie much costlier to represent. A practical way to actually do this would likely look like applying arithmetic coding to all of the possible length-N prefixes of the game.<p>The mid- or lategame are also far from random and could probably be compressed in small &quot;chunks&quot; via a coder that would (effectively) learn to predict patterns of e.g. capture being followed by a recapture and cause such chunks to require fewer bits to represent.<p>I&#x27;m not very knowledgeable about compression algorithms, though; I&#x27;m sure others will be able to provide corrections or references.</div><br/><div id="39718588" class="c"><input type="checkbox" id="c-39718588" checked=""/><div class="controls bullet"><span class="by">andruby</span><span>|</span><a href="#39718114">parent</a><span>|</span><a href="#39718271">next</a><span>|</span><label class="collapse" for="c-39718588">[-]</label><label class="expand" for="c-39718588">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what the author seems to have done and describes in their subsequent post: <a href="https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-further&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-furt...</a> (published yesterday)</div><br/></div></div><div id="39718271" class="c"><input type="checkbox" id="c-39718271" checked=""/><div class="controls bullet"><span class="by">Spark_Ed</span><span>|</span><a href="#39718114">parent</a><span>|</span><a href="#39718588">prev</a><span>|</span><a href="#39720989">next</a><span>|</span><label class="collapse" for="c-39718271">[-]</label><label class="expand" for="c-39718271">[1 more]</label></div><br/><div class="children"><div class="content">You can reference specific move numbers from specific master games to compress. But you still need to compress how you store those master games. What you&#x27;re describing for mid&#x2F;late game might make more sense like this: you use a fixed version of stockfish to suggest moves (depth and version should be locked to static values so it reproduces the same engine move each time). If it&#x27;s within the first 8 suggestions, you can flag that it&#x27;s an engine move with 4 bits. Decompression time is significantly larger, but it maximizes the space for cpu trade-off.</div><br/></div></div></div></div><div id="39720989" class="c"><input type="checkbox" id="c-39720989" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#39718114">prev</a><span>|</span><a href="#39721911">next</a><span>|</span><label class="collapse" for="c-39720989">[-]</label><label class="expand" for="c-39720989">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I run a site that stores a ton of chess lines, something like 100 million in total.</i><p>Because there are so many, one approach would be to sort the list of lines lexicographically to group similar ones together, then compress the result with a sliding window compression algorithm.<p>The sliding window compression will avoid storing repeated parts a second time, and the first part of the lines will be repeated a lot because of the sorting. There may also be some other repeated sequences.<p>This assumes that it&#x27;s OK to sort the lines, though, which might or might not be true.</div><br/></div></div><div id="39721911" class="c"><input type="checkbox" id="c-39721911" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#39720989">prev</a><span>|</span><a href="#39719252">next</a><span>|</span><label class="collapse" for="c-39721911">[-]</label><label class="expand" for="c-39721911">[1 more]</label></div><br/><div class="children"><div class="content">I had my own idea compressing chess moves, using one byte per move, because I think the number of legal moves can never exceed 256.<p>Further compression may be possible due to the number of legal moves may be much less, so some of the previously numbers may be used for common sequences of moves.<p>(It would also be possible to use some of the unused numbers to indicate e.g. resigning, agreement of a draw, and unfinished games.)</div><br/></div></div><div id="39719252" class="c"><input type="checkbox" id="c-39719252" checked=""/><div class="controls bullet"><span class="by">andjd</span><span>|</span><a href="#39721911">prev</a><span>|</span><a href="#39719420">next</a><span>|</span><label class="collapse" for="c-39719252">[-]</label><label class="expand" for="c-39719252">[3 more]</label></div><br/><div class="children"><div class="content">I would be curious how this compares to a more-or-less off-the-shelf text compression algorithm like gzip.  My guess is that over the entire database, this would be more efficient than the OP&#x27;s ad-hoc implementation or any alternative mentioned here.</div><br/><div id="39720359" class="c"><input type="checkbox" id="c-39720359" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#39719252">parent</a><span>|</span><a href="#39719583">next</a><span>|</span><label class="collapse" for="c-39720359">[-]</label><label class="expand" for="c-39720359">[1 more]</label></div><br/><div class="children"><div class="content">Unlikely.  Gzip and the like will do well with getting rid of the inherent redundancy of ascii coding but it&#x27;s a general algorithm and can&#x27;t take advantage of known structure.</div><br/></div></div><div id="39719583" class="c"><input type="checkbox" id="c-39719583" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39719252">parent</a><span>|</span><a href="#39720359">prev</a><span>|</span><a href="#39719420">next</a><span>|</span><label class="collapse" for="c-39719583">[-]</label><label class="expand" for="c-39719583">[1 more]</label></div><br/><div class="children"><div class="content">That’s my first thought as well. Plain old gzip should do pretty well and provides a baseline to beat.</div><br/></div></div></div></div><div id="39719420" class="c"><input type="checkbox" id="c-39719420" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39719252">prev</a><span>|</span><a href="#39718294">next</a><span>|</span><label class="collapse" for="c-39719420">[-]</label><label class="expand" for="c-39719420">[2 more]</label></div><br/><div class="children"><div class="content">Thinking about this has made me realize I really don’t know anything about compression other than which arguments to pass to tar to get it to compress, haha.<p>How would a typical compression algorithm do, losslessly compressing the whole game?<p>Can you lossily compress the game? If so, you would end up, after decompressing, with a game that had some ambiguous moves, right? But, only one is valid all the way through. Why not lossily compress and then step through each game, checking if each move is valid? Is that even still considered lossy?<p>Hypothetically you could end up with multiple valid games I guess… but they are just games, haha, who cares if a few are wrong?</div><br/><div id="39720338" class="c"><input type="checkbox" id="c-39720338" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#39719420">parent</a><span>|</span><a href="#39718294">next</a><span>|</span><label class="collapse" for="c-39720338">[-]</label><label class="expand" for="c-39720338">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not lossy if you can always recover the correct data.<p>Rather than use a general algorithm, your compressor would have to reason: I&#x27;d have to spend a bit to disambiguate x &amp; y, but only x is a valid board state, so I won&#x27;t bother and the decompressor also knows I won&#x27;t bother so it will all work out.<p>This sort of implicit coding can work, but it is fragile.</div><br/></div></div></div></div><div id="39718294" class="c"><input type="checkbox" id="c-39718294" checked=""/><div class="controls bullet"><span class="by">zitterbewegung</span><span>|</span><a href="#39719420">prev</a><span>|</span><a href="#39717969">next</a><span>|</span><label class="collapse" for="c-39718294">[-]</label><label class="expand" for="c-39718294">[1 more]</label></div><br/><div class="children"><div class="content">Right now I think you could compress chess games for fun and profit .<p>Since chess databases have come along higher level chess players can look pretty far ahead. We are reaching the point where if you study your opponent you can pregame it but studying what openings they make and prepping for openings.<p>But now we have come to the point if you can memorize large portions of chess databases you know optimal play given the database because if anyone has played the game and gets any advantage out of it people will play the line. It would be interesting to take the chess databases see their compression ratio and then how long would it take to lose against swordfish.</div><br/></div></div><div id="39717969" class="c"><input type="checkbox" id="c-39717969" checked=""/><div class="controls bullet"><span class="by">velcrovan</span><span>|</span><a href="#39718294">prev</a><span>|</span><a href="#39719259">next</a><span>|</span><label class="collapse" for="c-39717969">[-]</label><label class="expand" for="c-39717969">[1 more]</label></div><br/><div class="children"><div class="content">Was discussed recent-ish-ly (Sep 2023) — this was positions, not moves:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37525348">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37525348</a><p>Site linked there seems to be offline, so here&#x27;s the archive copy: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230928072950&#x2F;https:&#x2F;&#x2F;www.ezzeriesa.com&#x2F;index&#x2F;Writing%20efa7772a3ae64a8193c7ef981ac619fc&#x2F;Compressing%20chess%20positions%20for%20fun%20and%20profit%20df1fdb5364eb42fdac11eb23b25e9605.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230928072950&#x2F;https:&#x2F;&#x2F;www.ezzer...</a></div><br/></div></div><div id="39719259" class="c"><input type="checkbox" id="c-39719259" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#39717969">prev</a><span>|</span><a href="#39722497">next</a><span>|</span><label class="collapse" for="c-39719259">[-]</label><label class="expand" for="c-39719259">[3 more]</label></div><br/><div class="children"><div class="content">Has anyone tried columnar compression of full game states instead of bit packing moves?<p>64 squares * (Empty | (Black | White) * (King | Queen | Bishop | Knight | Rook | Pawn)) + (Black | White) * (Can castle queenside | Can castle kingside)<p>It could be encoded as 64 4-bit int columns + 4 bool columns = 260 bits, most of which don&#x27;t change between moves. Normal columnar encoding and compression strategies could probably reduce that to a few bits per board state.</div><br/><div id="39719332" class="c"><input type="checkbox" id="c-39719332" checked=""/><div class="controls bullet"><span class="by">marcusbuffett</span><span>|</span><a href="#39719259">parent</a><span>|</span><a href="#39722497">next</a><span>|</span><label class="collapse" for="c-39719332">[-]</label><label class="expand" for="c-39719332">[2 more]</label></div><br/><div class="children"><div class="content">I have actually, alongside my work of compressing moves. My compression scheme averages about 150 bits per position, or about 35% of the standard text notation in EPD format.<p>The thing I optimized for is that there’s very often repeated blank spaces or repeated pawns on the same rank.<p>Also instead of storing castling status separately, it’s stored as a separate piece on the appropriate rook.<p>These take advantage of the fact that there’s 6 pieces, so 3 bits to encode them leaves two options remaining. One is PawnRepeating and the other is RookCastleAvailable, in my scheme.<p>There’s probably improvements to be made. I’ll write a post on it when it’s finalized.</div><br/><div id="39719744" class="c"><input type="checkbox" id="c-39719744" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#39719259">root</a><span>|</span><a href="#39719332">parent</a><span>|</span><a href="#39722497">next</a><span>|</span><label class="collapse" for="c-39719744">[-]</label><label class="expand" for="c-39719744">[1 more]</label></div><br/><div class="children"><div class="content">Using the extra available piece indexes for &quot;rook that can castle&quot; and &quot;pawn that moved two squares&quot; is a great idea. So e.g. moving the king would not only change the squares where the king moved from and to, but would also convert both of the rooks from &quot;rook that can castle&quot; to &quot;rook that can&#x27;t castle&quot;. Same for a pawn that moved two squares and can be captured by en passant.<p>I guess you also need some way to encode which player&#x27;s turn it is. Though maybe you could eliminate that by flipping the board on black&#x27;s move and always encoding from the perspective of the last player&#x27;s move?<p>I&#x27;m curious about whether a naive columnar encoding scheme could beat a more complex encoding scheme, after compression. Not columnar in the sense of ranks and files, but columnar in the sense of data science storage formats (e.g. parquet), where each &#x27;column&#x27; is the state of a specific square across different board states. Given 64 such columns, a game state is a single row. The hypothesis being that if you&#x27;re encoding all the game states of a large number of games (say 1000), after RLE and compression etc you would see a net compression better than more complex encoding schemes. Given a big block of game states like this, then a single &#x27;game&#x27; would be a list of offsets into the game states. This would probably also compress very nicely in columnar format.<p>Now I want to try it...</div><br/></div></div></div></div></div></div><div id="39722497" class="c"><input type="checkbox" id="c-39722497" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#39719259">prev</a><span>|</span><a href="#39717931">next</a><span>|</span><label class="collapse" for="c-39722497">[-]</label><label class="expand" for="c-39722497">[1 more]</label></div><br/><div class="children"><div class="content">I feel like zstd trained on a randomized sampling of games from the database would come very close to (or better than) this with nearly zero effort.</div><br/></div></div><div id="39717931" class="c"><input type="checkbox" id="c-39717931" checked=""/><div class="controls bullet"><span class="by">srameshc</span><span>|</span><a href="#39722497">prev</a><span>|</span><a href="#39718646">next</a><span>|</span><label class="collapse" for="c-39717931">[-]</label><label class="expand" for="c-39717931">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you&#x27;re into chess, I&#x27;ve made a repertoire builder 
 embeds the link chessbook.com, It&#x27;s a great way to learn and practice chess.</div><br/></div></div><div id="39718646" class="c"><input type="checkbox" id="c-39718646" checked=""/><div class="controls bullet"><span class="by">bluedino</span><span>|</span><a href="#39717931">prev</a><span>|</span><a href="#39718029">next</a><span>|</span><label class="collapse" for="c-39718646">[-]</label><label class="expand" for="c-39718646">[2 more]</label></div><br/><div class="children"><div class="content">Anyone know of a discussion of say, 8 bit chess computers and their techniques and tricks?</div><br/><div id="39719416" class="c"><input type="checkbox" id="c-39719416" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#39718646">parent</a><span>|</span><a href="#39718029">next</a><span>|</span><label class="collapse" for="c-39719416">[-]</label><label class="expand" for="c-39719416">[1 more]</label></div><br/><div class="children"><div class="content">Is this what you are looking for?<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36431917">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36431917</a> - Video Chess disassembled and commented (2023-06-22)<p><a href="https:&#x2F;&#x2F;nanochess.org&#x2F;video_chess.html" rel="nofollow">https:&#x2F;&#x2F;nanochess.org&#x2F;video_chess.html</a><p>Video Chess for Atari 2600 worked with just 128 bytes of memory.</div><br/></div></div></div></div><div id="39718029" class="c"><input type="checkbox" id="c-39718029" checked=""/><div class="controls bullet"><span class="by">davguerrero</span><span>|</span><a href="#39718646">prev</a><span>|</span><a href="#39718223">next</a><span>|</span><label class="collapse" for="c-39718029">[-]</label><label class="expand" for="c-39718029">[5 more]</label></div><br/><div class="children"><div class="content">For optimal compression, look into Huffman coding: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Huffman_coding" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Huffman_coding</a></div><br/><div id="39719113" class="c"><input type="checkbox" id="c-39719113" checked=""/><div class="controls bullet"><span class="by">marcusbuffett</span><span>|</span><a href="#39718029">parent</a><span>|</span><a href="#39718642">next</a><span>|</span><label class="collapse" for="c-39719113">[-]</label><label class="expand" for="c-39719113">[1 more]</label></div><br/><div class="children"><div class="content">I mention Huffman in my follow-up post: <a href="https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-further&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;compressing-chess-moves-even-furt...</a> , but chose arithmetic encoding instead.</div><br/></div></div><div id="39718642" class="c"><input type="checkbox" id="c-39718642" checked=""/><div class="controls bullet"><span class="by">andruby</span><span>|</span><a href="#39718029">parent</a><span>|</span><a href="#39719113">prev</a><span>|</span><a href="#39718223">next</a><span>|</span><label class="collapse" for="c-39718642">[-]</label><label class="expand" for="c-39718642">[3 more]</label></div><br/><div class="children"><div class="content">I think Huffman would be good, but I don&#x27;t think it would be optimal (as in, the smallest possible amount of bits)</div><br/><div id="39719809" class="c"><input type="checkbox" id="c-39719809" checked=""/><div class="controls bullet"><span class="by">canucker2016</span><span>|</span><a href="#39718029">root</a><span>|</span><a href="#39718642">parent</a><span>|</span><a href="#39718223">next</a><span>|</span><label class="collapse" for="c-39719809">[-]</label><label class="expand" for="c-39719809">[2 more]</label></div><br/><div class="children"><div class="content">Huffman requires minimum one bit IIRC whereas Arithmetic coding or ANS ( <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asymmetric_numeral_systems" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asymmetric_numeral_systems</a> ) can use fewer if there&#x27;s a skewed distribution.<p>Arithmetic coding has been avoided in practical situations due to patents, but many of those have expired ( see the patent section of <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Arithmetic_coding" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Arithmetic_coding</a> or maybe not, lawyers tend to advise not even reading about patent specifics )</div><br/><div id="39720420" class="c"><input type="checkbox" id="c-39720420" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#39718029">root</a><span>|</span><a href="#39719809">parent</a><span>|</span><a href="#39718223">next</a><span>|</span><label class="collapse" for="c-39720420">[-]</label><label class="expand" for="c-39720420">[1 more]</label></div><br/><div class="children"><div class="content">The core tech patents have expired.  They did have some interesting ones around hardware implementations, iirc.<p>Overall the chilling effect was interesting - I found that many people doing academic work around compression didn&#x27;t really know much about it, didn&#x27;t teach it, just because it was a mess.<p>The core idea is elegant, and easily implemented.</div><br/></div></div></div></div></div></div></div></div><div id="39718223" class="c"><input type="checkbox" id="c-39718223" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#39718029">prev</a><span>|</span><label class="collapse" for="c-39718223">[-]</label><label class="expand" for="c-39718223">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how this compares to using zstd with a dictionary.</div><br/></div></div></div></div></div></div></div></body></html>