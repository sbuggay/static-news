<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728205269160" as="style"/><link rel="stylesheet" href="styles.css?v=1728205269160"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://vondra.me/posts/playing-with-bolt-and-postgres/">Playing with BOLT and Postgres</a> <span class="domain">(<a href="https://vondra.me">vondra.me</a>)</span></div><div class="subtext"><span>aquastorm</span> | <span>39 comments</span></div><br/><div><div id="41753331" class="c"><input type="checkbox" id="c-41753331" checked=""/><div class="controls bullet"><span class="by">albntomat0</span><span>|</span><a href="#41753759">next</a><span>|</span><label class="collapse" for="c-41753331">[-]</label><label class="expand" for="c-41753331">[3 more]</label></div><br/><div class="children"><div class="content">I posted this in a comment already, but the results here line up with the original BOLT paper.<p>“For the GCC and Clang compilers, our evaluation shows that BOLT speeds up their binaries by up to 20.4% on top of FDO and LTO, and up to 52.1% if the binaries are built without FDO and LTO.”<p>“Up to” though is always hard to evaluate.</div><br/><div id="41755021" class="c"><input type="checkbox" id="c-41755021" checked=""/><div class="controls bullet"><span class="by">genewitch</span><span>|</span><a href="#41753331">parent</a><span>|</span><a href="#41754708">next</a><span>|</span><label class="collapse" for="c-41755021">[-]</label><label class="expand" for="c-41755021">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Up to&quot; is one of those &quot;technically correct&quot;, it&#x27;s probably more genuine and ethical to give a range in the same circumstances. If 95% of binaries get at least 18%. but the remaining 5% get much less than that, and that&#x27;s important, then say that, maybe.<p>When i see stuff like this, i usually infer that 95% gets a median of 0% speedup, and a couple of cases get 20.4% or whatever. But giving a chart of speedups for each sort of thing that it speeds up (or doesn&#x27;t) doesn&#x27;t make for good copy, i think.</div><br/></div></div><div id="41754708" class="c"><input type="checkbox" id="c-41754708" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41753331">parent</a><span>|</span><a href="#41755021">prev</a><span>|</span><a href="#41753759">next</a><span>|</span><label class="collapse" for="c-41754708">[-]</label><label class="expand" for="c-41754708">[1 more]</label></div><br/><div class="children"><div class="content">Up to 10000% I think<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;870&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;870&#x2F;</a></div><br/></div></div></div></div><div id="41753759" class="c"><input type="checkbox" id="c-41753759" checked=""/><div class="controls bullet"><span class="by">mhio</span><span>|</span><a href="#41753331">prev</a><span>|</span><a href="#41752673">next</a><span>|</span><label class="collapse" for="c-41753759">[-]</label><label class="expand" for="c-41753759">[2 more]</label></div><br/><div class="children"><div class="content">Would the profiles and resulting binaries be highly CPU specific? I couldn&#x27;t find any cross hardware notes in the original paper.<p>The example&#x27;s I&#x27;m thinking of are CPU&#x27;s with vastly different L1&#x2F;L2&#x2F;L3 cache profiles. Epyc vs Xeon. Maybe Zen 3 v Zen 5.<p>Just wondering if it looks great on a benchmark machine (and a hyperscaler with a common hardware fleet) but might not look as great when distributing common binaries to the world. Doing profiling&#x2F;optimising after release seems dicey.</div><br/><div id="41755590" class="c"><input type="checkbox" id="c-41755590" checked=""/><div class="controls bullet"><span class="by">pgaddict</span><span>|</span><a href="#41753759">parent</a><span>|</span><a href="#41752673">next</a><span>|</span><label class="collapse" for="c-41755590">[-]</label><label class="expand" for="c-41755590">[1 more]</label></div><br/><div class="children"><div class="content">Interesting question. I think most optimizations described in the BOLT paper are fairly hardware agnostic - branch prediction does not depend the architecture, etc. But I&#x27;m not an expert on microarchitectures.</div><br/></div></div></div></div><div id="41752673" class="c"><input type="checkbox" id="c-41752673" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#41753759">prev</a><span>|</span><a href="#41755297">next</a><span>|</span><label class="collapse" for="c-41752673">[-]</label><label class="expand" for="c-41752673">[5 more]</label></div><br/><div class="children"><div class="content">My first instinct is that the effect is too large to be real. But that should be something other people could reproduce and verify. The second thought is that it might overfit the benchmark code here, but they address it in the post. But any kind of double-digit improvement to Postgres performance would be very interesting.</div><br/><div id="41752912" class="c"><input type="checkbox" id="c-41752912" checked=""/><div class="controls bullet"><span class="by">pgaddict</span><span>|</span><a href="#41752673">parent</a><span>|</span><a href="#41753114">next</a><span>|</span><label class="collapse" for="c-41752912">[-]</label><label class="expand" for="c-41752912">[3 more]</label></div><br/><div class="children"><div class="content">(author here)<p>I agree the +40% effect feels a bit too good, but it only applies to the simple OLTP queries on in-memory data, so the inefficiencies may have unexpectedly large impact. I agree 30-40% would be a massive speedup, and I expected it to disappear with a more diverse profile, but it did not ...<p>The TPC-H speedups (~5-10%) seem much more plausible, considering the binary layout effects we sometimes observe during benchmarking.<p>Anyway, I&#x27;d welcome other people trying to reproduce these tests.</div><br/><div id="41753246" class="c"><input type="checkbox" id="c-41753246" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#41752673">root</a><span>|</span><a href="#41752912">parent</a><span>|</span><a href="#41753114">next</a><span>|</span><label class="collapse" for="c-41753246">[-]</label><label class="expand" for="c-41753246">[2 more]</label></div><br/><div class="children"><div class="content">I looked and there is no mention of BOLT yet in the pgsql-hackers mailing list, that might be the more appropriate place to get more attention on this. Though there are certainly a few PostgreSQL developers reading here as well.</div><br/><div id="41753357" class="c"><input type="checkbox" id="c-41753357" checked=""/><div class="controls bullet"><span class="by">pgaddict</span><span>|</span><a href="#41752673">root</a><span>|</span><a href="#41753246">parent</a><span>|</span><a href="#41753114">next</a><span>|</span><label class="collapse" for="c-41753357">[-]</label><label class="expand" for="c-41753357">[1 more]</label></div><br/><div class="children"><div class="content">True. At the moment I don&#x27;t have anything very &quot;actionable&quot; beyond &quot;it&#x27;s magically faster&quot;, so I wanted to investigate this a bit more before posting to -hackers. For example, after reading the paper I realized BOLT has &quot;-report-bad-layout&quot; option to report cases of bad layout, so I wonder if we could identify places where to reorganize the code.<p>OTOH my blog is syndicated to <a href="https:&#x2F;&#x2F;planet.postgresql.org" rel="nofollow">https:&#x2F;&#x2F;planet.postgresql.org</a>, so it&#x27;s not particularly hidden from the other devs.</div><br/></div></div></div></div></div></div></div></div><div id="41755297" class="c"><input type="checkbox" id="c-41755297" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#41752673">prev</a><span>|</span><a href="#41752439">next</a><span>|</span><label class="collapse" for="c-41755297">[-]</label><label class="expand" for="c-41755297">[1 more]</label></div><br/><div class="children"><div class="content">For distros, you&#x27;re probably talking about small programs with shared libraries. I talked to the Bolt guy at an LLVM meeting and Bolt is set up for big statically linked programs like what you&#x27;d see at Facebook or Google (which has Propeller). It may have changed but even though they were upstreaming Bolt to LLVM, they didn&#x27;t really have support for small programs with shared libraries.</div><br/></div></div><div id="41752439" class="c"><input type="checkbox" id="c-41752439" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#41755297">prev</a><span>|</span><a href="#41753214">next</a><span>|</span><label class="collapse" for="c-41752439">[-]</label><label class="expand" for="c-41752439">[12 more]</label></div><br/><div class="children"><div class="content">10% - 20% performance improvement for PostgreSQL &quot;for free&quot; is amazing. It almost sounds too good to be true.</div><br/><div id="41753320" class="c"><input type="checkbox" id="c-41753320" checked=""/><div class="controls bullet"><span class="by">albntomat0</span><span>|</span><a href="#41752439">parent</a><span>|</span><a href="#41753214">next</a><span>|</span><label class="collapse" for="c-41753320">[-]</label><label class="expand" for="c-41753320">[11 more]</label></div><br/><div class="children"><div class="content">There’s a section of the article at the end about how Postgres doesn’t have LTO enabled by default.  I’m assuming they’re not doing PGO&#x2F;FDO either?<p>From the Bolt paper: “For the GCC and Clang compilers, our evaluation shows that BOLT speeds up their binaries by up to 20.4% on top of FDO and LTO, and up to 52.1% if the binaries are built without FDO and LTO.”</div><br/><div id="41753378" class="c"><input type="checkbox" id="c-41753378" checked=""/><div class="controls bullet"><span class="by">touisteur</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753320">parent</a><span>|</span><a href="#41753463">next</a><span>|</span><label class="collapse" for="c-41753378">[-]</label><label class="expand" for="c-41753378">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wondered how people actually get the profiles for Profile-Guided-Optimization. Unit tests probably won&#x27;t actuate high-performance paths. You&#x27;d need a set of performance-stress tests. Is there a write-up on how everyone does it in the wild ?</div><br/><div id="41753431" class="c"><input type="checkbox" id="c-41753431" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753378">parent</a><span>|</span><a href="#41753463">next</a><span>|</span><label class="collapse" for="c-41753431">[-]</label><label class="expand" for="c-41753431">[8 more]</label></div><br/><div class="children"><div class="content">You might be surprised how much speedup you can get from (say) just running a test suite as PGO samples. If I had to guess this is probably because compilers spend a lot of time optimising cold paths which they otherwise would have no information about</div><br/><div id="41753458" class="c"><input type="checkbox" id="c-41753458" checked=""/><div class="controls bullet"><span class="by">pgaddict</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753431">parent</a><span>|</span><a href="#41753729">next</a><span>|</span><label class="collapse" for="c-41753458">[-]</label><label class="expand" for="c-41753458">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, getting the profile is obviously a very important step. Because if it wasn&#x27;t, why collect the profile at all? We could just do &quot;regular&quot; LTO.<p>I&#x27;m not sure there&#x27;s one correct way to collect the profile, though. ISTM we could either (a) collect one very &quot;general&quot; profile, to optimize for arbitrary workload, or (b) profile a single isolated workload, and optimize for it. In the blog I tried to do (b) first, and then merged the various profiles to do (a). But it&#x27;s far from perfect, I think.<p>But even with the very &quot;rough&quot; profile from &quot;make installcheck&quot; (which is the basic set of regression tests), is still helps a lot. Which is nice. I agree it&#x27;s probably because even that basic profile is sufficient for identifying the hot&#x2F;cold paths.</div><br/><div id="41754071" class="c"><input type="checkbox" id="c-41754071" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753458">parent</a><span>|</span><a href="#41754270">next</a><span>|</span><label class="collapse" for="c-41754071">[-]</label><label class="expand" for="c-41754071">[2 more]</label></div><br/><div class="children"><div class="content">I think you have to be a bit careful here, since if the profiles are too different from what you&#x27;ll actually see in production, you can end up regressing performance instead of improving it. E.g., imagine you use one kind of compression in test and another in production, and the FDO decides that your production compression code doesn&#x27;t need optimization at all.<p>If you set up continuous profiling though (which you can use to get flamegraphs for production) you can use that same dataset for FDO.</div><br/><div id="41755563" class="c"><input type="checkbox" id="c-41755563" checked=""/><div class="controls bullet"><span class="by">pgaddict</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41754071">parent</a><span>|</span><a href="#41754270">next</a><span>|</span><label class="collapse" for="c-41755563">[-]</label><label class="expand" for="c-41755563">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I was worried using the &quot;wrong&quot; profile might result in regressions. But I haven&#x27;t really seen that in my tests, even when using profiles from quite different workloads (like OLTP vs. analytics, different TPC-H queries, etc.). So I guess most optimizations are fairly generic, etc.</div><br/></div></div></div></div><div id="41754270" class="c"><input type="checkbox" id="c-41754270" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753458">parent</a><span>|</span><a href="#41754071">prev</a><span>|</span><a href="#41753729">next</a><span>|</span><label class="collapse" for="c-41754270">[-]</label><label class="expand" for="c-41754270">[1 more]</label></div><br/><div class="children"><div class="content">There are some projects (not sure if available to use in anger) to generate PGO data use using AI.</div><br/></div></div></div></div><div id="41753729" class="c"><input type="checkbox" id="c-41753729" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753431">parent</a><span>|</span><a href="#41753458">prev</a><span>|</span><a href="#41753463">next</a><span>|</span><label class="collapse" for="c-41753729">[-]</label><label class="expand" for="c-41753729">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not how it works. BOLT is mainly about figuring out the most likely instructions that will run after branches and putting them close together in the binary. Unlikely instructions like error and exception paths can be put at the end of the binary. Putting the most used instructions close together leverages prefetching and cache so that unused instructions aren&#x27;t what is being prefetched and cached.<p>In short it is better memory access patterns for instructions.</div><br/><div id="41754063" class="c"><input type="checkbox" id="c-41754063" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753729">parent</a><span>|</span><a href="#41754264">next</a><span>|</span><label class="collapse" for="c-41754063">[-]</label><label class="expand" for="c-41754063">[1 more]</label></div><br/><div class="children"><div class="content">I suspect you know this based on the detail in your comment and just missed it, but parent is talking about FDO, not BOLT.</div><br/></div></div><div id="41754264" class="c"><input type="checkbox" id="c-41754264" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753729">parent</a><span>|</span><a href="#41754063">prev</a><span>|</span><a href="#41753463">next</a><span>|</span><label class="collapse" for="c-41754264">[-]</label><label class="expand" for="c-41754264">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but I&#x27;m not talking about BOLT</div><br/></div></div></div></div></div></div></div></div><div id="41753463" class="c"><input type="checkbox" id="c-41753463" checked=""/><div class="controls bullet"><span class="by">pgaddict</span><span>|</span><a href="#41752439">root</a><span>|</span><a href="#41753320">parent</a><span>|</span><a href="#41753378">prev</a><span>|</span><a href="#41753214">next</a><span>|</span><label class="collapse" for="c-41753463">[-]</label><label class="expand" for="c-41753463">[1 more]</label></div><br/><div class="children"><div class="content">With the LTO, I think it&#x27;s more complicated - it depends on the packagers &#x2F; distributions, and e.g. on Ubuntu we apparently get -flto for years.</div><br/></div></div></div></div></div></div><div id="41753214" class="c"><input type="checkbox" id="c-41753214" checked=""/><div class="controls bullet"><span class="by">Avamander</span><span>|</span><a href="#41752439">prev</a><span>|</span><a href="#41753513">next</a><span>|</span><label class="collapse" for="c-41753214">[-]</label><label class="expand" for="c-41753214">[9 more]</label></div><br/><div class="children"><div class="content">How easy would it be to have an entire distro (re)built with BOLT? Say for example Gentoo?</div><br/><div id="41755047" class="c"><input type="checkbox" id="c-41755047" checked=""/><div class="controls bullet"><span class="by">genewitch</span><span>|</span><a href="#41753214">parent</a><span>|</span><a href="#41753240">next</a><span>|</span><label class="collapse" for="c-41755047">[-]</label><label class="expand" for="c-41755047">[1 more]</label></div><br/><div class="children"><div class="content">based on what &quot;fishgoesblub&quot; commented, building - read: `emerge -e @world` - a gentoo system with profiling forced, and then using it in that &quot;degraded&quot; state for a while ought to be able to inform PGO, right? if there&#x27;s a really good speedup from putting hot code together, the hottest code after moderate use should suffice to speed up things, and this could continually be improved.<p>I&#x27;m also certain that if there were a way to anonymously share profiling data upstream (or to the maintainers), that would decrease the &quot;degradation&quot; from the first step, above. I am 100% spitballing here. I&#x27;m a dedicated gentoo sysadmin, but i know only a small bit about optimization of the sort being discussed here. So it is possible that every user would have to do the &quot;unprofiled profiler&quot; build first, which, if one cares, is probably a net negative to the planet, unless the idea pans out, then it&#x27;s a huge positive for the planet - man hours, electricity, wear&#x2F;endurance on parts, etc.</div><br/></div></div><div id="41753240" class="c"><input type="checkbox" id="c-41753240" checked=""/><div class="controls bullet"><span class="by">fishgoesblub</span><span>|</span><a href="#41753214">parent</a><span>|</span><a href="#41755047">prev</a><span>|</span><a href="#41753513">next</a><span>|</span><label class="collapse" for="c-41753240">[-]</label><label class="expand" for="c-41753240">[7 more]</label></div><br/><div class="children"><div class="content">It would be difficult as every package&#x2F;program would need a step to generate the profile data by executing and running the program like the user would.</div><br/><div id="41753462" class="c"><input type="checkbox" id="c-41753462" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41753214">root</a><span>|</span><a href="#41753240">parent</a><span>|</span><a href="#41753513">next</a><span>|</span><label class="collapse" for="c-41753462">[-]</label><label class="expand" for="c-41753462">[6 more]</label></div><br/><div class="children"><div class="content">Is it theoretically possible to perform the profile generation+apply steps dynamically at runtime?</div><br/><div id="41753953" class="c"><input type="checkbox" id="c-41753953" checked=""/><div class="controls bullet"><span class="by">tjalfi</span><span>|</span><a href="#41753214">root</a><span>|</span><a href="#41753462">parent</a><span>|</span><a href="#41755574">next</a><span>|</span><label class="collapse" for="c-41753953">[-]</label><label class="expand" for="c-41753953">[3 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t want to support it, but similar things have been done before.<p>Alexia Massalin&#x27;s Synthesis[0] (pdf) operating system did JIT-like optimizations for system calls. Here&#x27;s a LWN article[1] with a summary. Anyone who&#x27;s interested in operating systems should read this thesis.<p>HP&#x27;s Dynamo[2] runtime optimizer did JIT-like optimizations on PA-RISC binaries; it was released in 2000. DynamoRIO[3] is an open source descendant. Also, DEC had a similar tool for the Alpha, but I&#x27;ve forgotten the name.<p>[0] <a href="https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;document?repid=rep1&amp;type=pdf&amp;doi=1467a614509e49995a213a138f86c81b43f4cd56" rel="nofollow">https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;document?repid=rep1&amp;type=pdf&amp;d...</a><p>[1] <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;270081&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;270081&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;349299.349303" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;349299.349303</a><p>[3] <a href="https:&#x2F;&#x2F;dynamorio.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dynamorio.org&#x2F;</a></div><br/><div id="41754666" class="c"><input type="checkbox" id="c-41754666" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#41753214">root</a><span>|</span><a href="#41753953">parent</a><span>|</span><a href="#41754345">next</a><span>|</span><label class="collapse" for="c-41754666">[-]</label><label class="expand" for="c-41754666">[1 more]</label></div><br/><div class="children"><div class="content">Nat Freidman developed &quot;GNU Rope&quot;[1] from 1998 which, if memory serves, was inspired by a tool that did the same thing in IRIX (cord, I believe).<p>[1] <a href="http:&#x2F;&#x2F;lwn.net&#x2F;1998&#x2F;1029&#x2F;als&#x2F;rope.html" rel="nofollow">http:&#x2F;&#x2F;lwn.net&#x2F;1998&#x2F;1029&#x2F;als&#x2F;rope.html</a></div><br/></div></div><div id="41754345" class="c"><input type="checkbox" id="c-41754345" checked=""/><div class="controls bullet"><span class="by">hikarikuen</span><span>|</span><a href="#41753214">root</a><span>|</span><a href="#41753953">parent</a><span>|</span><a href="#41754666">prev</a><span>|</span><a href="#41755574">next</a><span>|</span><label class="collapse" for="c-41754345">[-]</label><label class="expand" for="c-41754345">[1 more]</label></div><br/><div class="children"><div class="content">This is getting way outside the traditional compiler model, but I believe the .NET JIT has been adding more support for this in the last couple versions. One aspect of it is covered at <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;performance-improvements-in-net-8&#x2F;#tiering-and-dynamic-pgo" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;performance-improvemen...</a></div><br/></div></div></div></div><div id="41755574" class="c"><input type="checkbox" id="c-41755574" checked=""/><div class="controls bullet"><span class="by">pgaddict</span><span>|</span><a href="#41753214">root</a><span>|</span><a href="#41753462">parent</a><span>|</span><a href="#41753953">prev</a><span>|</span><a href="#41753773">next</a><span>|</span><label class="collapse" for="c-41755574">[-]</label><label class="expand" for="c-41755574">[1 more]</label></div><br/><div class="children"><div class="content">I believe some JIT systems already do PGO &#x2F; might be extended to do what BOLT does.</div><br/></div></div><div id="41753773" class="c"><input type="checkbox" id="c-41753773" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41753214">root</a><span>|</span><a href="#41753462">parent</a><span>|</span><a href="#41755574">prev</a><span>|</span><a href="#41753513">next</a><span>|</span><label class="collapse" for="c-41753773">[-]</label><label class="expand" for="c-41753773">[1 more]</label></div><br/><div class="children"><div class="content">It would be hard to trust the result.</div><br/></div></div></div></div></div></div></div></div><div id="41753513" class="c"><input type="checkbox" id="c-41753513" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#41753214">prev</a><span>|</span><a href="#41754663">next</a><span>|</span><label class="collapse" for="c-41753513">[-]</label><label class="expand" for="c-41753513">[2 more]</label></div><br/><div class="children"><div class="content">Does it work with rustc binaries?</div><br/><div id="41754168" class="c"><input type="checkbox" id="c-41754168" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#41753513">parent</a><span>|</span><a href="#41754663">next</a><span>|</span><label class="collapse" for="c-41754168">[-]</label><label class="expand" for="c-41754168">[1 more]</label></div><br/><div class="children"><div class="content">Already done. <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;116352">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;116352</a></div><br/></div></div></div></div><div id="41754663" class="c"><input type="checkbox" id="c-41754663" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#41753513">prev</a><span>|</span><a href="#41753719">next</a><span>|</span><label class="collapse" for="c-41754663">[-]</label><label class="expand" for="c-41754663">[2 more]</label></div><br/><div class="children"><div class="content">completely out of the loop here so asking, what is BOLT, how does it actually improve postgres? what do the optimizations do under the hood? and how do we know they haven&#x27;t disabled something mission critical?</div><br/><div id="41754699" class="c"><input type="checkbox" id="c-41754699" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41754663">parent</a><span>|</span><a href="#41753719">next</a><span>|</span><label class="collapse" for="c-41754699">[-]</label><label class="expand" for="c-41754699">[1 more]</label></div><br/><div class="children"><div class="content">Literally the second sentence</div><br/></div></div></div></div><div id="41753719" class="c"><input type="checkbox" id="c-41753719" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41754663">prev</a><span>|</span><label class="collapse" for="c-41753719">[-]</label><label class="expand" for="c-41753719">[2 more]</label></div><br/><div class="children"><div class="content">On the subject of completely free speedups to databases, someone sent a patch to MySQL many years ago that loads the text into hugepages, to reduce iTLB misses. It has large speedups and no negative consequences so of course it was ignored. The number of well-known techniques that FOSS projects refuse to adopt is large.</div><br/><div id="41754222" class="c"><input type="checkbox" id="c-41754222" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#41753719">parent</a><span>|</span><label class="collapse" for="c-41754222">[-]</label><label class="expand" for="c-41754222">[1 more]</label></div><br/><div class="children"><div class="content">MySQL has adopted a lot of performance work from FB, Google, and others. Though I suspect they want their implementation for license reasons.</div><br/></div></div></div></div></div></div></div></div></div></body></html>