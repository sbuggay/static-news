<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728637262492" as="style"/><link rel="stylesheet" href="styles.css?v=1728637262492"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ibraheem.ca/posts/designing-papaya/">Designing a Fast Concurrent Hash Table</a> <span class="domain">(<a href="https://ibraheem.ca">ibraheem.ca</a>)</span></div><div class="subtext"><span>burntsushi</span> | <span>22 comments</span></div><br/><div><div id="41801441" class="c"><input type="checkbox" id="c-41801441" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#41801799">next</a><span>|</span><label class="collapse" for="c-41801441">[-]</label><label class="expand" for="c-41801441">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to see this put through it&#x27;s paces with the following:<p>I have a strategy for benchmarking such data-structures, I call it the &quot;birthday benchmark&quot;.<p>Unfortunately I&#x27;m not proficient enough in Rust to have put it into practice there, but the strategy is this:<p>Generate a stream of random bytes, pre-generation is advised to avoid dominating the benchmark.<p>Consume the stream in blocks of n bytes.<p>Try to find a duplicated block.<p>Given the &quot;birthday paradox &#x2F; birthday attack&quot;, this is actually much quicker than it might first appear. Simple single-thread basic hashset can find duplicates at a 6-byte length match in around 3 seconds on my hardware, and a specialised data-structure takes this to less than a second.<p>A good concurrent hashtable should improve that greatly even further, because this ought to be a very parallelizable problem, especially if you&#x27;re not constrained to finding the first such duplicate in the stream, but allow yourself to find any duplicate, nor are constrained to keep track of both sides of the pair, and are content with simply knowing you have found one.</div><br/><div id="41801581" class="c"><input type="checkbox" id="c-41801581" checked=""/><div class="controls bullet"><span class="by">vlmutolo</span><span>|</span><a href="#41801441">parent</a><span>|</span><a href="#41802616">next</a><span>|</span><label class="collapse" for="c-41801581">[-]</label><label class="expand" for="c-41801581">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Generate a stream of random bytes, pre-generation is advised to avoid dominating the benchmark.<p>Current PRNGs are pretty fast. The Xoroshiro RNG &quot;shootout&quot; benchmark [0] lists some self-reported speeds. They claim 8+ GB&#x2F;s for even their slowest, highest-quality PRNG. The general-purpose one they recommend is 10GB&#x2F;s, and 32GB&#x2F;s when vectorized.<p>The vectorized versions get close to current DRAM speeds. I think I&#x27;d prefer that over reading from a giant table, given that the table reads will have significant implications for caching and disrupt that aspect of the benchmark.<p>[0]: <a href="https:&#x2F;&#x2F;prng.di.unimi.it&#x2F;#shootout" rel="nofollow">https:&#x2F;&#x2F;prng.di.unimi.it&#x2F;#shootout</a></div><br/><div id="41802574" class="c"><input type="checkbox" id="c-41802574" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#41801441">root</a><span>|</span><a href="#41801581">parent</a><span>|</span><a href="#41802616">next</a><span>|</span><label class="collapse" for="c-41802574">[-]</label><label class="expand" for="c-41802574">[5 more]</label></div><br/><div class="children"><div class="content">Thanks for that suggestion, I shall explore faster PRNGS and vactorization too then.<p>My domain is c#, where it&#x27;s perhaps unsurprising that it&#x27;s a lot faster to have an array in memory than go via the default Random, which is I believe is Xoroshiro ( at least in .net 6+ ). It certainly can generate data quickly with Random.GetBytes(), but repeated calls to Random.NextInt64() are much slower.<p>Another issue I found with generating random numbers and trying to multi-thread is thread safety  &#x2F; synchronisation. If each thread is doing it&#x27;s own random generation then it&#x27;s difficult to compare results between using 1 thread and 2 threads, because it&#x27;s no longer the same single stream of random data measured across each benchmark, so the meta-randomness of how early you &quot;should&quot; hit a dupe becomes a factor.<p>Having pre-generated numbers and single thread responsible for handing out those numbers makes it easier, you can either have a thread-safe counter, or can increment a larger increment plus an offset for each thread number. The first &quot;real&quot; dupe is still in the same place in the original pre-generated data.<p>You can then compare the incremental gains, for example, of each thread having their own hashtable would get you logarithmic gains (I think that&#x27;s the right way to express it, but essentially it&#x27;s gaining just by having First Dupe = Min(First Dupe across N threads) vs an actual thread-safe concurrent hash-table, where you should[1] still see First dupe but sped up by a greater factor than just a naive work but not state sharing.<p>I recognise there are potential memory caching issues at play with the pregeneration approach, but for larger bit counts the actual work should hopefully dominate, particularly since look-up values aren&#x27;t revisited by design.<p>[1] &quot;Should&quot;, because there&#x27;s a small chance in many algorithms that due to concurrency and race conditions you actually miss the duplicate. Either multiple runs should be tried looking for bi-modal data, or accept that the next dupe shouldn&#x27;t be so long after the first, and be happy the speed-up is greater than the slow-down caused by very occassional race condition misses. The chance of a such a race condition is absolutely minuscule at the 48bit level, if we assume we are using say, 8 threads, and assume for a race condition to occur, the same 48-number would have to be concurrently being handled&#x2F;generated by 2 different threads.</div><br/><div id="41805720" class="c"><input type="checkbox" id="c-41805720" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41801441">root</a><span>|</span><a href="#41802574">parent</a><span>|</span><a href="#41804168">next</a><span>|</span><label class="collapse" for="c-41805720">[-]</label><label class="expand" for="c-41805720">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If each thread is doing it&#x27;s own random generation then it&#x27;s difficult to compare results between using 1 thread and 2 threads, because it&#x27;s no longer the same single stream of random data<p>Most modern RNGs support a &quot;jump&quot; operation that takes care of this; PCG has the best standard API I&#x27;ve ever seen. Alternatively, with <i>any</i> RNG you can interleave (call `next` numthreads times before selecting a number) but that&#x27;s slower.</div><br/></div></div><div id="41804168" class="c"><input type="checkbox" id="c-41804168" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41801441">root</a><span>|</span><a href="#41802574">parent</a><span>|</span><a href="#41805720">prev</a><span>|</span><a href="#41803625">next</a><span>|</span><label class="collapse" for="c-41804168">[-]</label><label class="expand" for="c-41804168">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, vectorization is very simple—just running multiple instsnces of Xoroshiro (or one of the weaker variants) inside a vector works quite well. Fitting the resulting peg into the hole of a preexisting API is difficult, but that’s always a problem.</div><br/></div></div><div id="41803625" class="c"><input type="checkbox" id="c-41803625" checked=""/><div class="controls bullet"><span class="by">Iwan-Zotow</span><span>|</span><a href="#41801441">root</a><span>|</span><a href="#41802574">parent</a><span>|</span><a href="#41804168">prev</a><span>|</span><a href="#41802616">next</a><span>|</span><label class="collapse" for="c-41803625">[-]</label><label class="expand" for="c-41803625">[2 more]</label></div><br/><div class="children"><div class="content">&gt; which is I believe is Xoroshiro ( at least in .net 6+ )<p>Xoshiro I believe is in .NET 6, close cousin<p><a href="https:&#x2F;&#x2F;blogs.siliconorchid.com&#x2F;post&#x2F;coding-inspiration&#x2F;randomness-in-dotnet&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blogs.siliconorchid.com&#x2F;post&#x2F;coding-inspiration&#x2F;rand...</a></div><br/><div id="41803685" class="c"><input type="checkbox" id="c-41803685" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#41801441">root</a><span>|</span><a href="#41803625">parent</a><span>|</span><a href="#41802616">next</a><span>|</span><label class="collapse" for="c-41803685">[-]</label><label class="expand" for="c-41803685">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for that correction, I hadn&#x27;t appreciated the subtle difference there.</div><br/></div></div></div></div></div></div></div></div><div id="41802616" class="c"><input type="checkbox" id="c-41802616" checked=""/><div class="controls bullet"><span class="by">bloppe</span><span>|</span><a href="#41801441">parent</a><span>|</span><a href="#41801581">prev</a><span>|</span><a href="#41802980">next</a><span>|</span><label class="collapse" for="c-41802616">[-]</label><label class="expand" for="c-41802616">[1 more]</label></div><br/><div class="children"><div class="content">This is a write-heavy workload. Papaya is optimized for read-heavy workloads.<p>It&#x27;s an interesting benchmark, but the kind of people who would want to use Papaya probably wouldn&#x27;t be very interested in it.</div><br/></div></div><div id="41802980" class="c"><input type="checkbox" id="c-41802980" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41801441">parent</a><span>|</span><a href="#41802616">prev</a><span>|</span><a href="#41801799">next</a><span>|</span><label class="collapse" for="c-41802980">[-]</label><label class="expand" for="c-41802980">[1 more]</label></div><br/><div class="children"><div class="content">Do you have other examples of interesting workloads? Benchmarking is difficult, lol.</div><br/></div></div></div></div><div id="41801799" class="c"><input type="checkbox" id="c-41801799" checked=""/><div class="controls bullet"><span class="by">_nalply</span><span>|</span><a href="#41801441">prev</a><span>|</span><a href="#41806653">next</a><span>|</span><label class="collapse" for="c-41801799">[-]</label><label class="expand" for="c-41801799">[4 more]</label></div><br/><div class="children"><div class="content">Have also a look at concurrent_map. It is a concurrent BTreeMap, this means it maintains key order (not insertion order but the keys implement Ord).<p><a href="https:&#x2F;&#x2F;lib.rs&#x2F;crates&#x2F;concurrent-map" rel="nofollow">https:&#x2F;&#x2F;lib.rs&#x2F;crates&#x2F;concurrent-map</a><p>I am using it for a transactional in-memory key-value store experiment.</div><br/><div id="41803131" class="c"><input type="checkbox" id="c-41803131" checked=""/><div class="controls bullet"><span class="by">ibraheemdev</span><span>|</span><a href="#41801799">parent</a><span>|</span><a href="#41803771">next</a><span>|</span><label class="collapse" for="c-41803131">[-]</label><label class="expand" for="c-41803131">[1 more]</label></div><br/><div class="children"><div class="content">Looks very interesting, but seems to serve a pretty different use case:<p>&gt; This is an ordered data structure, and supports very high throughput iteration over lexicographically sorted ranges of values. If you are looking for simple point operation performance, you may find a better option among one of the many concurrent hashmap implementations that are floating around. Pay for what you actually use :)</div><br/></div></div><div id="41803771" class="c"><input type="checkbox" id="c-41803771" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#41801799">parent</a><span>|</span><a href="#41803131">prev</a><span>|</span><a href="#41806653">next</a><span>|</span><label class="collapse" for="c-41803771">[-]</label><label class="expand" for="c-41803771">[2 more]</label></div><br/><div class="children"><div class="content">If you just need a key-value data concurrent data structure it should be much faster and scale better to have a hash map instead of something that is keeping a sorted order.</div><br/><div id="41806303" class="c"><input type="checkbox" id="c-41806303" checked=""/><div class="controls bullet"><span class="by">_nalply</span><span>|</span><a href="#41801799">root</a><span>|</span><a href="#41803771">parent</a><span>|</span><a href="#41806653">next</a><span>|</span><label class="collapse" for="c-41806303">[-]</label><label class="expand" for="c-41806303">[1 more]</label></div><br/><div class="children"><div class="content">Different use cases. An ordered map shines if you need some ordering of keys. One use case is an ordered index, for example if you have an age index and need to list only adult people. A hashmap won&#x27;t work here, I think.<p>So just use a DBMS, but if you don&#x27;t want, perhaps this ordered concurrent map.</div><br/></div></div></div></div></div></div><div id="41806653" class="c"><input type="checkbox" id="c-41806653" checked=""/><div class="controls bullet"><span class="by">mareko</span><span>|</span><a href="#41801799">prev</a><span>|</span><a href="#41800158">next</a><span>|</span><label class="collapse" for="c-41806653">[-]</label><label class="expand" for="c-41806653">[1 more]</label></div><br/><div class="children"><div class="content">What a fascinating and detailed post. Thanks so much for sharing!<p>I wonder whether it&#x27;s possible to achieve similar performance but with a simpler design that uses scalable reader-writer locks. They can be made a lot more efficient than what&#x27;s commonly out there using the C-SNZI lock-free data structure:<p><a href="https:&#x2F;&#x2F;people.csail.mit.edu&#x2F;mareko&#x2F;spaa09-scalablerwlocks.pdf" rel="nofollow">https:&#x2F;&#x2F;people.csail.mit.edu&#x2F;mareko&#x2F;spaa09-scalablerwlocks.p...</a></div><br/></div></div><div id="41800158" class="c"><input type="checkbox" id="c-41800158" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#41806653">prev</a><span>|</span><a href="#41806349">next</a><span>|</span><label class="collapse" for="c-41800158">[-]</label><label class="expand" for="c-41800158">[1 more]</label></div><br/><div class="children"><div class="content">This looks pretty good in terms of its tradeoffs and tricks used. Makes good use of the Metadata, as in <a href="https:&#x2F;&#x2F;greg7mdp.github.io&#x2F;parallel-hashmap&#x2F;" rel="nofollow">https:&#x2F;&#x2F;greg7mdp.github.io&#x2F;parallel-hashmap&#x2F;</a></div><br/></div></div><div id="41806349" class="c"><input type="checkbox" id="c-41806349" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#41800158">prev</a><span>|</span><a href="#41802951">next</a><span>|</span><label class="collapse" for="c-41806349">[-]</label><label class="expand" for="c-41806349">[1 more]</label></div><br/><div class="children"><div class="content">C++ STL&#x2F;Boost and&#x2F;or Python probably already have such a beast that could be adapted&#x2F;cannibalized for some use-cases.</div><br/></div></div><div id="41802951" class="c"><input type="checkbox" id="c-41802951" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41806349">prev</a><span>|</span><a href="#41804257">next</a><span>|</span><label class="collapse" for="c-41802951">[-]</label><label class="expand" for="c-41802951">[2 more]</label></div><br/><div class="children"><div class="content">Are there &quot;batch&quot;-esque workloads where we want extreme throughput, but can tolerate a large latency (10-100 micros)?</div><br/><div id="41804947" class="c"><input type="checkbox" id="c-41804947" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41802951">parent</a><span>|</span><a href="#41804257">next</a><span>|</span><label class="collapse" for="c-41804947">[-]</label><label class="expand" for="c-41804947">[1 more]</label></div><br/><div class="children"><div class="content">There’s an interesting optimization along those lines in Valkey <a href="https:&#x2F;&#x2F;valkey.io&#x2F;blog&#x2F;unlock-one-million-rps-part2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;valkey.io&#x2F;blog&#x2F;unlock-one-million-rps-part2&#x2F;</a></div><br/></div></div></div></div><div id="41804257" class="c"><input type="checkbox" id="c-41804257" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#41802951">prev</a><span>|</span><label class="collapse" for="c-41804257">[-]</label><label class="expand" for="c-41804257">[3 more]</label></div><br/><div class="children"><div class="content">&quot;In some ways, they are the holy grail of concurrent data structures. On the other hand, a concurrent hash table is an inelegant blob of shared mutable data, often a marker of a poorly architectured program.&quot;<p>I find the last bit particularly objectionable. If you&#x27;re in some language slanging objects around all day, then sticking a untyped, bespoke substitute for an object probably isn&#x27;t the right move. But on the long path down my programming career, I recognize objects make so many things harder and more confusing than necessary. I definitely prescribe to Rich Hickey saying I would rather have 1 data structure and 100 functions that operate on it far easier to work with and understand than 10 data structure and 10 functions. Clojure absolutely is a joy to work with and reason about, and it only gets better the faster you get out of typed object land. Hashmaps are the purest abstraction over an associative data structure, and I will take one over a pile of classes with brittle, snowflake interfaces any day.</div><br/><div id="41806501" class="c"><input type="checkbox" id="c-41806501" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41804257">parent</a><span>|</span><label class="collapse" for="c-41806501">[-]</label><label class="expand" for="c-41806501">[2 more]</label></div><br/><div class="children"><div class="content">&gt; classes with brittle, snowflake interfaces<p>That is <i>exactly</i> the opposite experience that I have, to the point I feel like it&#x27;s from a different universe.<p>Perhaps difference in domain, but every time I have to use Python or JS I hate the lack of explicit types with defined interfaces as discoverability during coding is zero. And you end up with code that, after dependency updates or similar, you never know if it&#x27;ll crash until you run it.</div><br/><div id="41807082" class="c"><input type="checkbox" id="c-41807082" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41804257">root</a><span>|</span><a href="#41806501">parent</a><span>|</span><label class="collapse" for="c-41807082">[-]</label><label class="expand" for="c-41807082">[1 more]</label></div><br/><div class="children"><div class="content">in my experience there&#x27;s always so much more to data structures that you can shoehorn into member functions.<p>I agree type hints are a godsend for discoverability, but please, show me all operations this type can be a parameter for.<p>I want &quot;discoverability&quot; on the argument lists of all libraries.<p>and I find lsp with type hints useful for that.<p>and multi methods!  can I have multiple dispatch?  but first parameter based dispatch &quot;oop&quot; only?  meh.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>