<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733734861769" as="style"/><link rel="stylesheet" href="styles.css?v=1733734861769"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/e-dant/salmagundi">Show HN: A portable hash map in C</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>e-dant</span> | <span>44 comments</span></div><br/><div><div id="42361871" class="c"><input type="checkbox" id="c-42361871" checked=""/><div class="controls bullet"><span class="by">gritzko</span><span>|</span><a href="#42360417">next</a><span>|</span><label class="collapse" for="c-42361871">[-]</label><label class="expand" for="c-42361871">[2 more]</label></div><br/><div class="children"><div class="content">I recently coded a linear-probing hash map in C and I highly recommend you to use fuzz tests. These evolve naturally from unit tests: next step table unit tests, next step property test, next step fuzzing, all steps are incremental, hence easy.<p>Having a fuzz test was in-va-lu-ab-le. I caught several bugs right there. The delete function was particularly tricky.<p>I ended up with two fuzz tests as my hash table has a key feature: convergence. Having same contents, it would have exactly same bits in the buffer. In other words, it is independent of the insertion&#x2F;deletion order. For this, I added another fuzz test. I would add a third one if I  realize there is an important invariant I did not fuzz test. That is not much work, but so much useful!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;abc&#x2F;fuzz&#x2F;HASH.cpp">https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;abc&#x2F;fuzz&#x2F;HASH....</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;abc&#x2F;fuzz&#x2F;HASHd.c">https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;abc&#x2F;fuzz&#x2F;HASHd...</a><p>P.S. In your case, I recommend clang&#x27;s libfuzzer with ASAN.<p><a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LibFuzzer.html#fuzzer-usage" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LibFuzzer.html#fuzzer-usage</a></div><br/><div id="42362138" class="c"><input type="checkbox" id="c-42362138" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42361871">parent</a><span>|</span><a href="#42360417">next</a><span>|</span><label class="collapse" for="c-42362138">[-]</label><label class="expand" for="c-42362138">[1 more]</label></div><br/><div class="children"><div class="content">fuzz testing vs HN-popular-post testing, go!</div><br/></div></div></div></div><div id="42360417" class="c"><input type="checkbox" id="c-42360417" checked=""/><div class="controls bullet"><span class="by">drfuchs</span><span>|</span><a href="#42361871">prev</a><span>|</span><a href="#42360562">next</a><span>|</span><label class="collapse" for="c-42360417">[-]</label><label class="expand" for="c-42360417">[3 more]</label></div><br/><div class="children"><div class="content">A bug, I believe: If you &quot;put&quot; three colliding strings A and then B and then C, and then &quot;delete&quot; B, you won&#x27;t be able to find C anymore.</div><br/><div id="42360455" class="c"><input type="checkbox" id="c-42360455" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#42360417">parent</a><span>|</span><a href="#42360562">next</a><span>|</span><label class="collapse" for="c-42360455">[-]</label><label class="expand" for="c-42360455">[2 more]</label></div><br/><div class="children"><div class="content">Good catch! Yes, that looks like a bug :)</div><br/><div id="42362450" class="c"><input type="checkbox" id="c-42362450" checked=""/><div class="controls bullet"><span class="by">attractivechaos</span><span>|</span><a href="#42360417">root</a><span>|</span><a href="#42360455">parent</a><span>|</span><a href="#42360562">next</a><span>|</span><label class="collapse" for="c-42362450">[-]</label><label class="expand" for="c-42362450">[1 more]</label></div><br/><div class="children"><div class="content">You are implementing a closed hash table with linear probing. You need tombstones to mark deleted items, or better, move other items to replace deleted items [1]. Currently your library doesn&#x27;t have either mechanism.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Linear_probing#Deletion" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Linear_probing#Deletion</a></div><br/></div></div></div></div></div></div><div id="42360562" class="c"><input type="checkbox" id="c-42360562" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#42360417">prev</a><span>|</span><a href="#42361832">next</a><span>|</span><label class="collapse" for="c-42360562">[-]</label><label class="expand" for="c-42360562">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing. Simplicity is a good thing.<p>In order to speed it up by reducing the number of malloc() calls, it may be worth adding a simple arena memory allocation measure: by allocating one larger block (e.g. 1 MB) initially and then doubling the memory size each time you run out, all malloc()&#x2F;calloc() calls can become local salmagundi_alloc() calls that are just macro invocations that return an arena buffer pointer and also increment said pointer as a side effect.<p>I also recommend you have a look at Chris Hanson&#x27;s book &quot;C: Interfaces and Implementations&quot;, which has a few neat C API tricks that your code could benefit from (e.g. for reducing name space pollution, for avoiding null pointer argument errors, API method naming etc.).</div><br/><div id="42362436" class="c"><input type="checkbox" id="c-42362436" checked=""/><div class="controls bullet"><span class="by">attractivechaos</span><span>|</span><a href="#42360562">parent</a><span>|</span><a href="#42361832">next</a><span>|</span><label class="collapse" for="c-42362436">[-]</label><label class="expand" for="c-42362436">[1 more]</label></div><br/><div class="children"><div class="content">If you double a memory block with realloc, the memory may be relocated to a different address (at least on MacOS). Then all pointers pointing to the old block will be invalid. This can be addressed by adding new blocks to a list. It will be more complex than a minimal arena allocator.<p>Furthermore, a typical arena allocator only grows but doesn&#x27;t shrink. A deleted item from the memory block will still hold the memory and will not be released. You will need a more sophisticated allocator for deletion. For fixed sized items, memory pool may be an option.</div><br/></div></div></div></div><div id="42361832" class="c"><input type="checkbox" id="c-42361832" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42360562">prev</a><span>|</span><a href="#42361513">next</a><span>|</span><label class="collapse" for="c-42361832">[-]</label><label class="expand" for="c-42361832">[1 more]</label></div><br/><div class="children"><div class="content">Row 100 of hm_put() clears all contents of the item struct, thus losing the pointer to where the previous value was stored. But then row 107 needs this pointer to pass it to realloc().<p>Additionally, in case of overwrite, the memory previously allocated for the key is leaked.<p>All in all, I  don&#x27;t think row 100 is really needed, and removing it wouldn&#x27;t do any harm.<p>Finally, deletes are hard in hash maps. Either you decide that deletes are not allowed, or you implement them with tombstones or re-insertions. A half-backed solution is not an option.<p>Hope these suggestions help you.</div><br/></div></div><div id="42361513" class="c"><input type="checkbox" id="c-42361513" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#42361832">prev</a><span>|</span><a href="#42363325">next</a><span>|</span><label class="collapse" for="c-42361513">[-]</label><label class="expand" for="c-42361513">[1 more]</label></div><br/><div class="children"><div class="content">Considering there seems to be at least a one memory bug (hm_put&#x2F;key from another comment), I would strongly recommend running the tests in valgrind or similar if you haven&#x27;t already. Doing C without it usually ends in some kind of disaster for me.</div><br/></div></div><div id="42363325" class="c"><input type="checkbox" id="c-42363325" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#42361513">prev</a><span>|</span><a href="#42360148">next</a><span>|</span><label class="collapse" for="c-42363325">[-]</label><label class="expand" for="c-42363325">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious about the #ifdef guard, which is of a form I&#x27;ve never encountered.<p><pre><code>  #ifndef BD9DF82A4540BB19368E48E4747C0706
  #define BD9DF82A4540BB19368E48E4747C0706
</code></pre>
Does some IDE do that for you? Did you just pick a random sequence? Why not just a variant of #ifndef _salmagundi_h  that is more common?<p>Other than that, I strongly echo other&#x27;s advice about avoiding so many mallocs.</div><br/><div id="42364118" class="c"><input type="checkbox" id="c-42364118" checked=""/><div class="controls bullet"><span class="by">tobyhinloopen</span><span>|</span><a href="#42363325">parent</a><span>|</span><a href="#42360148">next</a><span>|</span><label class="collapse" for="c-42364118">[-]</label><label class="expand" for="c-42364118">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with `#pragma once`? (honest question, i only do C and C++ as a hobby)</div><br/></div></div></div></div><div id="42360148" class="c"><input type="checkbox" id="c-42360148" checked=""/><div class="controls bullet"><span class="by">vintagedave</span><span>|</span><a href="#42363325">prev</a><span>|</span><a href="#42361428">next</a><span>|</span><label class="collapse" for="c-42360148">[-]</label><label class="expand" for="c-42360148">[5 more]</label></div><br/><div class="children"><div class="content">This is neat, and remarkably small. I personally need more comments in order to follow, say, the growth logic. I see it rehashes but I don&#x27;t see how it doesn&#x27;t potentially overwrite entries on the way.<p>Algorithm for hash collisions is just to find the next empty slot (linear probing)? What happens when the original entry is removed, are the ones in subsequent slots cycled backwards? I don&#x27;t see that...<p>Also the name is new to me! TIL &#x27;salmagundi&#x27; is an English word (not even a loan-word) for a type of salad made of many ingredients: an excellent name for a hash map that can contain many effectively random items.</div><br/><div id="42360267" class="c"><input type="checkbox" id="c-42360267" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#42360148">parent</a><span>|</span><a href="#42361428">next</a><span>|</span><label class="collapse" for="c-42360267">[-]</label><label class="expand" for="c-42360267">[4 more]</label></div><br/><div class="children"><div class="content">I like the exercise of trying to find the simplest reasonable solution to some problem.<p>Many of my toy and hobby projects are exactly that. Some make allowances for the sake of performance and generality.<p>The hash map, though, is up there with sorting algorithms in the breadth of wild implementations. Salmagundi is unlikely to be the fastest, or the smartest. But it’s cute and portable.</div><br/><div id="42360303" class="c"><input type="checkbox" id="c-42360303" checked=""/><div class="controls bullet"><span class="by">vintagedave</span><span>|</span><a href="#42360148">root</a><span>|</span><a href="#42360267">parent</a><span>|</span><a href="#42361428">next</a><span>|</span><label class="collapse" for="c-42360303">[-]</label><label class="expand" for="c-42360303">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s neat. I like it!<p>I edited my comment with some more questions, btw, likely as you were answering - apologies if that ended up confusing.</div><br/><div id="42360401" class="c"><input type="checkbox" id="c-42360401" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#42360148">root</a><span>|</span><a href="#42360303">parent</a><span>|</span><a href="#42361428">next</a><span>|</span><label class="collapse" for="c-42360401">[-]</label><label class="expand" for="c-42360401">[2 more]</label></div><br/><div class="children"><div class="content">There’s no slot cycling logic. When a k,v pair at some index is deleted, and a different k,v pair has a matching hash, there’s a (small?) penalty in the hm_get logic that will eventually the right k,v pair.<p>I need a bit more clarification on your first question. There should be no mutation of the underlying map when it grows — we’re just allocating more room for entries and adjusting the old map’s item “ownership” — moving pointers-&gt;items around.</div><br/><div id="42360502" class="c"><input type="checkbox" id="c-42360502" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#42360148">root</a><span>|</span><a href="#42360401">parent</a><span>|</span><a href="#42361428">next</a><span>|</span><label class="collapse" for="c-42360502">[-]</label><label class="expand" for="c-42360502">[1 more]</label></div><br/><div class="children"><div class="content">Nevermind — there are ways for deleting colliding items to cause other colliding items to be “forgotten”, and one solution would be to implement slot cycling on deletion</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42361428" class="c"><input type="checkbox" id="c-42361428" checked=""/><div class="controls bullet"><span class="by">tralarpa</span><span>|</span><a href="#42360148">prev</a><span>|</span><a href="#42361773">next</a><span>|</span><label class="collapse" for="c-42361428">[-]</label><label class="expand" for="c-42361428">[2 more]</label></div><br/><div class="children"><div class="content">My C is quite rusty, so apologies for stupid questions.<p>In the hm_put function, when you overwrite, why do you malloc and copy the key again, and what happens with the old key pointer and the old value pointer? (no free for the key and the memset zeros everything?)</div><br/><div id="42361492" class="c"><input type="checkbox" id="c-42361492" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#42361428">parent</a><span>|</span><a href="#42361773">next</a><span>|</span><label class="collapse" for="c-42361492">[-]</label><label class="expand" for="c-42361492">[1 more]</label></div><br/><div class="children"><div class="content">Nice catch :)<p>Looks like the key logic is missing an overwrite case, the value is reallocated on overwrite.</div><br/></div></div></div></div><div id="42361773" class="c"><input type="checkbox" id="c-42361773" checked=""/><div class="controls bullet"><span class="by">alanmoraes</span><span>|</span><a href="#42361428">prev</a><span>|</span><a href="#42362340">next</a><span>|</span><label class="collapse" for="c-42361773">[-]</label><label class="expand" for="c-42361773">[1 more]</label></div><br/><div class="children"><div class="content">In the code example, I guess the variable `k_sz` is undefined in the call `hm_get(map, k, k_sz)`. Hope that helps.</div><br/></div></div><div id="42362340" class="c"><input type="checkbox" id="c-42362340" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#42361773">prev</a><span>|</span><a href="#42362237">next</a><span>|</span><label class="collapse" for="c-42362340">[-]</label><label class="expand" for="c-42362340">[2 more]</label></div><br/><div class="children"><div class="content">I want to thank everyone here who pointed out deficiencies in this little library.<p>Good catches :)</div><br/><div id="42362738" class="c"><input type="checkbox" id="c-42362738" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#42362340">parent</a><span>|</span><a href="#42362237">next</a><span>|</span><label class="collapse" for="c-42362738">[-]</label><label class="expand" for="c-42362738">[1 more]</label></div><br/><div class="children"><div class="content">Not getting all defensive is a superpower!</div><br/></div></div></div></div><div id="42362237" class="c"><input type="checkbox" id="c-42362237" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#42362340">prev</a><span>|</span><a href="#42360141">next</a><span>|</span><label class="collapse" for="c-42362237">[-]</label><label class="expand" for="c-42362237">[1 more]</label></div><br/><div class="children"><div class="content">If you’re interested in this, I wrote a blogpost on a simple c hash table without deletion.<p><a href="https:&#x2F;&#x2F;www.davidpriver.com&#x2F;c-hash-table.html" rel="nofollow">https:&#x2F;&#x2F;www.davidpriver.com&#x2F;c-hash-table.html</a></div><br/></div></div><div id="42360141" class="c"><input type="checkbox" id="c-42360141" checked=""/><div class="controls bullet"><span class="by">EricRiese</span><span>|</span><a href="#42362237">prev</a><span>|</span><a href="#42362224">next</a><span>|</span><label class="collapse" for="c-42360141">[-]</label><label class="expand" for="c-42360141">[2 more]</label></div><br/><div class="children"><div class="content">I followed the link in the docs to the page on the hash function. There&#x27;s a DJB-2 algorithm on that page, but no DJB-1</div><br/><div id="42360230" class="c"><input type="checkbox" id="c-42360230" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#42360141">parent</a><span>|</span><a href="#42362224">next</a><span>|</span><label class="collapse" for="c-42360230">[-]</label><label class="expand" for="c-42360230">[1 more]</label></div><br/><div class="children"><div class="content">Huh — I must have written djb1 in error</div><br/></div></div></div></div><div id="42362224" class="c"><input type="checkbox" id="c-42362224" checked=""/><div class="controls bullet"><span class="by">TheDudeMan</span><span>|</span><a href="#42360141">prev</a><span>|</span><a href="#42360571">next</a><span>|</span><label class="collapse" for="c-42362224">[-]</label><label class="expand" for="c-42362224">[2 more]</label></div><br/><div class="children"><div class="content">I suggest improving the probing a little.  Something like<p><pre><code>  idx = (idx + 1) % map-&gt;cap;
</code></pre>
becomes<p><pre><code>  iterCount++;
  idx = (idx + iterCount) % map-&gt;cap;</code></pre></div><br/><div id="42362253" class="c"><input type="checkbox" id="c-42362253" checked=""/><div class="controls bullet"><span class="by">meisel</span><span>|</span><a href="#42362224">parent</a><span>|</span><a href="#42360571">next</a><span>|</span><label class="collapse" for="c-42362253">[-]</label><label class="expand" for="c-42362253">[1 more]</label></div><br/><div class="children"><div class="content">It could be improved even more, performance wise. The potentially expensive modulo could be avoided entirely with an if statement. Or, only use powers of 2 for the capacity, and then you can also use bit wise ops</div><br/></div></div></div></div><div id="42360571" class="c"><input type="checkbox" id="c-42360571" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#42362224">prev</a><span>|</span><a href="#42362992">next</a><span>|</span><label class="collapse" for="c-42360571">[-]</label><label class="expand" for="c-42360571">[15 more]</label></div><br/><div class="children"><div class="content">Purely out of interest, and probably my bad, but what is:<p><pre><code>    (void)k_sz;
</code></pre>
doing? I&#x27;ve seen fussy people  doing:<p><pre><code>     (void) printf( &quot;hello&quot; );
</code></pre>
but not what you have written. As I say, probably ignorance on my part.</div><br/><div id="42360655" class="c"><input type="checkbox" id="c-42360655" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#42360571">parent</a><span>|</span><a href="#42360614">next</a><span>|</span><label class="collapse" for="c-42360655">[-]</label><label class="expand" for="c-42360655">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an idiom for telling the compiler “don&#x27;t give a warning on this argument not being used, I know about it”. Not all compilers will heed it. Other choices include e.g. __attribute__((unused)) (GNU), [[maybe_unused]] (C++17&#x2F;C23) or just not giving it a name (nonstandard, but very commonly supported).</div><br/><div id="42360732" class="c"><input type="checkbox" id="c-42360732" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360655">parent</a><span>|</span><a href="#42360759">next</a><span>|</span><label class="collapse" for="c-42360732">[-]</label><label class="expand" for="c-42360732">[2 more]</label></div><br/><div class="children"><div class="content">&gt; or just not giving it a name (nonstandard, but very commonly supported)<p>It&#x27;s only supported by gcc 11+ and clang 11+ (both from ~2021) because it was a suggested C2x extension. It&#x27;s been accepted in C23 so other compilers will eventually support it, but I wouldn&#x27;t hold my breath regarding when that happens.</div><br/><div id="42360764" class="c"><input type="checkbox" id="c-42360764" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360732">parent</a><span>|</span><a href="#42360759">next</a><span>|</span><label class="collapse" for="c-42360764">[-]</label><label class="expand" for="c-42360764">[1 more]</label></div><br/><div class="children"><div class="content">Ah, of course, in C mode it&#x27;s different. (I nearly always use C++ mode, where at least GCC 10 happily takes it.)</div><br/></div></div></div></div><div id="42360759" class="c"><input type="checkbox" id="c-42360759" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360655">parent</a><span>|</span><a href="#42360732">prev</a><span>|</span><a href="#42360614">next</a><span>|</span><label class="collapse" for="c-42360759">[-]</label><label class="expand" for="c-42360759">[7 more]</label></div><br/><div class="children"><div class="content">OK, thank you. But why do the functions have those unused parameters?</div><br/><div id="42360783" class="c"><input type="checkbox" id="c-42360783" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360759">parent</a><span>|</span><a href="#42360614">next</a><span>|</span><label class="collapse" for="c-42360783">[-]</label><label class="expand" for="c-42360783">[6 more]</label></div><br/><div class="children"><div class="content">I would assume that is because the hash table takes in a “hash this key” function pointer and a “compare these keys” function pointer, and those must contain the size for variable-length keys. So even if your user-supplied functions know the length, or only care about the first byte, they have to conform to that API, and then you get an unused parameter.</div><br/><div id="42360829" class="c"><input type="checkbox" id="c-42360829" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360783">parent</a><span>|</span><a href="#42360614">next</a><span>|</span><label class="collapse" for="c-42360829">[-]</label><label class="expand" for="c-42360829">[5 more]</label></div><br/><div class="children"><div class="content">Have functions with different names and different numbers of parameters?</div><br/><div id="42360880" class="c"><input type="checkbox" id="c-42360880" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360829">parent</a><span>|</span><a href="#42361515">next</a><span>|</span><label class="collapse" for="c-42360880">[-]</label><label class="expand" for="c-42360880">[2 more]</label></div><br/><div class="children"><div class="content">And then have a union between the two different kinds of pointers, and a tag to tell which one is in use, then test that tag everywhere? Why? What good does it bring for that extra complexity?</div><br/><div id="42360985" class="c"><input type="checkbox" id="c-42360985" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360880">parent</a><span>|</span><a href="#42361515">next</a><span>|</span><label class="collapse" for="c-42360985">[-]</label><label class="expand" for="c-42360985">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t the name of the function select for the types and use of the parameters? But I haven&#x27;t written in C for a long time, and this I think could be done more clearly in C++.</div><br/></div></div></div></div><div id="42361515" class="c"><input type="checkbox" id="c-42361515" checked=""/><div class="controls bullet"><span class="by">detaro</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360829">parent</a><span>|</span><a href="#42360880">prev</a><span>|</span><a href="#42360901">next</a><span>|</span><label class="collapse" for="c-42361515">[-]</label><label class="expand" for="c-42361515">[1 more]</label></div><br/><div class="children"><div class="content">The point is that you can pass any of the hash functions (or your own compatible) to the datastructure, so it&#x27;ll obviously call of them with the same set of parameters. And hash functions that need all of them will ignore them.</div><br/></div></div><div id="42360901" class="c"><input type="checkbox" id="c-42360901" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42360571">root</a><span>|</span><a href="#42360829">parent</a><span>|</span><a href="#42361515">prev</a><span>|</span><a href="#42360614">next</a><span>|</span><label class="collapse" for="c-42360901">[-]</label><label class="expand" for="c-42360901">[1 more]</label></div><br/><div class="children"><div class="content">That would be a bad API design.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42360614" class="c"><input type="checkbox" id="c-42360614" checked=""/><div class="controls bullet"><span class="by">lang4d</span><span>|</span><a href="#42360571">parent</a><span>|</span><a href="#42360655">prev</a><span>|</span><a href="#42360600">next</a><span>|</span><label class="collapse" for="c-42360614">[-]</label><label class="expand" for="c-42360614">[1 more]</label></div><br/><div class="children"><div class="content">That would be one way to silence an unused variable warning</div><br/></div></div><div id="42360600" class="c"><input type="checkbox" id="c-42360600" checked=""/><div class="controls bullet"><span class="by">ryanpetrich</span><span>|</span><a href="#42360571">parent</a><span>|</span><a href="#42360614">prev</a><span>|</span><a href="#42360642">next</a><span>|</span><label class="collapse" for="c-42360600">[-]</label><label class="expand" for="c-42360600">[1 more]</label></div><br/><div class="children"><div class="content">This is to suppress a compiler warning that the k_sz argument is unused.</div><br/></div></div><div id="42360642" class="c"><input type="checkbox" id="c-42360642" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#42360571">parent</a><span>|</span><a href="#42360600">prev</a><span>|</span><a href="#42360617">next</a><span>|</span><label class="collapse" for="c-42360642">[-]</label><label class="expand" for="c-42360642">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7354786&#x2F;what-does-void-variable-name-do-at-the-beginning-of-a-c-function" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7354786&#x2F;what-does-void-v...</a></div><br/></div></div><div id="42360617" class="c"><input type="checkbox" id="c-42360617" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#42360571">parent</a><span>|</span><a href="#42360642">prev</a><span>|</span><a href="#42362992">next</a><span>|</span><label class="collapse" for="c-42360617">[-]</label><label class="expand" for="c-42360617">[1 more]</label></div><br/><div class="children"><div class="content">It silences &#x27;unused variable&#x27; warnings.</div><br/></div></div></div></div><div id="42362992" class="c"><input type="checkbox" id="c-42362992" checked=""/><div class="controls bullet"><span class="by">anacrolix</span><span>|</span><a href="#42360571">prev</a><span>|</span><label class="collapse" for="c-42362992">[-]</label><label class="expand" for="c-42362992">[2 more]</label></div><br/><div class="children"><div class="content">Fuck sake, it&#x27;s char * not char*</div><br/><div id="42364131" class="c"><input type="checkbox" id="c-42364131" checked=""/><div class="controls bullet"><span class="by">tobyhinloopen</span><span>|</span><a href="#42362992">parent</a><span>|</span><label class="collapse" for="c-42364131">[-]</label><label class="expand" for="c-42364131">[1 more]</label></div><br/><div class="children"><div class="content">My auto-formatter always changes it like that and I just don&#x27;t understand why `char *foo` is better than `char* foo`.<p>I consider `char*` to be the type of `foo`. What&#x27;s the rationale of having `char *foo`?</div><br/></div></div></div></div></div></div></div></div></div></body></html>