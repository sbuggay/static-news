<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710406854150" as="style"/><link rel="stylesheet" href="styles.css?v=1710406854150"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/veryl-lang/veryl">Veryl: A Modern Hardware Description Language</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>hasheddan</span> | <span>41 comments</span></div><br/><div><div id="39701076" class="c"><input type="checkbox" id="c-39701076" checked=""/><div class="controls bullet"><span class="by">dalance</span><span>|</span><a href="#39699212">next</a><span>|</span><label class="collapse" for="c-39701076">[-]</label><label class="expand" for="c-39701076">[3 more]</label></div><br/><div class="children"><div class="content">Hi, Im&#x27; developer of Veryl.
So I&#x27;ll try to write the answer to &quot;why new HDL?&quot;.<p>I use SystemVerilog from 10+ years ago, and developed many large ASICs.
But development environment of SystemVerilog was poor than software development.
So I wrote some SystemVerilog tools to improve the environment like below:
<a href="https:&#x2F;&#x2F;github.com&#x2F;dalance&#x2F;svlint">https:&#x2F;&#x2F;github.com&#x2F;dalance&#x2F;svlint</a><p>After writing it, I felt that more improvement is difficult because the specification of SystemVerilog is too complicated.
(For example, even commercial EDA tool vendors can&#x27;t cover all specification...)<p>Therefore I decided to develop a new language replacing SystemVerilog.
I focus that the new language can be used by production ASIC development.
I&#x27;m plan to develop a part of a new project in my company by using Veryl.</div><br/><div id="39701145" class="c"><input type="checkbox" id="c-39701145" checked=""/><div class="controls bullet"><span class="by">fayalalebrun</span><span>|</span><a href="#39701076">parent</a><span>|</span><a href="#39699212">next</a><span>|</span><label class="collapse" for="c-39701145">[-]</label><label class="expand" for="c-39701145">[2 more]</label></div><br/><div class="children"><div class="content">I probably don&#x27;t have nearly as much experience as you do, but I have used VHDL, Verilog, and modern HDLs like Chisel and SpinalHDL. I think the main advantage of a modern HDL is to have the full power of a traditional programming language when it comes to generating hardware. This especially helps when making deeply parameterizable and reusable hardware in a fraction of the lines compared to SystemVerilog, and which sometimes is impossible to do in Verilog.<p>From a first impression, your language doesn&#x27;t look all that different from SystemVerilog. Does it have any features that make parameterization easier than SystemVerilog? Can I, for example, easily generate hardware using higher order functions and other functional programming features like those available in Rust and Scala?</div><br/><div id="39701224" class="c"><input type="checkbox" id="c-39701224" checked=""/><div class="controls bullet"><span class="by">dalance</span><span>|</span><a href="#39701076">root</a><span>|</span><a href="#39701145">parent</a><span>|</span><a href="#39699212">next</a><span>|</span><label class="collapse" for="c-39701224">[-]</label><label class="expand" for="c-39701224">[1 more]</label></div><br/><div class="children"><div class="content">I plan to introduce generics to enable module&#x2F;interface&#x2F;package as type parameter.
But I&#x27;m not aiming Chisel like programability.<p>I tried to use Chisel in a large codebase to judge it can be used as SystemVerilog alternative in my company.
So I found many problems which causes difficulty to apply ASIC development flow.
I think that differences of semantics from SystemVerilog causes a part of these problems.<p>So I aim that Veryl has the almost same semantics as SystemVerilog.
I think this ease to interoperate with SystemVerilog codebase too.</div><br/></div></div></div></div></div></div><div id="39699212" class="c"><input type="checkbox" id="c-39699212" checked=""/><div class="controls bullet"><span class="by">polalavik</span><span>|</span><a href="#39701076">prev</a><span>|</span><a href="#39699380">next</a><span>|</span><label class="collapse" for="c-39699212">[-]</label><label class="expand" for="c-39699212">[6 more]</label></div><br/><div class="children"><div class="content">I was going through all the alternative HDLs the other day to see what’s out there. So many one off projects to appeal to this language or that language, but none solving real problems in the space.<p>The problem? Modeling large systems with modules with large I&#x2F;O (DSPs or something else) and verifying those things is hard and not well suited for a complex verbose language.<p>Fight me, but I really think a mathworks simulink type visual modeling environment is a better way to approach this problem (and I hate mathworks with a passion, this isn’t a plug for matlab). That type of environment coupled with a way to generate high quality HDL is what I really want. I know mathworks has HDL coder and it’s ok, but still doesn’t quite do everything and you have the pay the enormous mathworks fee and can’t crowdsource platform updates as well as a well managed open source project might be able offer.<p>So when I see stuff like this I think “cool” but also “why???”</div><br/><div id="39699524" class="c"><input type="checkbox" id="c-39699524" checked=""/><div class="controls bullet"><span class="by">omgJustTest</span><span>|</span><a href="#39699212">parent</a><span>|</span><a href="#39699942">next</a><span>|</span><label class="collapse" for="c-39699524">[-]</label><label class="expand" for="c-39699524">[3 more]</label></div><br/><div class="children"><div class="content">If you are doing hardware verification, more than using IP blocks in the space, verification tasks are typically oriented around<p>1. Design : architectures need to be well constructed<p>2. Well derived tests on case-elements&#x2F;state-conditions : asserting that a specific signal-value achieves a specific state at a specific time is not hard, but coming up with the conditions are.<p>3. Placement &amp; technology specific details of delays, glitch management &amp; etc.<p>Event-driven simulators are essentially doing a lot of simple things correctly, so the language doesn&#x27;t need to be full-featured, ideally it is as efficient as possible in computation, since checking the verification takes the most time for complex systems.<p>Additionally after logic has been verified, there are many physical implementation details that have to be layered on top of this, including placement &amp; route optimizations.<p>Veryl to me looks like a SystemVerilog competitor in Rust-like language aspects.</div><br/><div id="39700189" class="c"><input type="checkbox" id="c-39700189" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#39699212">root</a><span>|</span><a href="#39699524">parent</a><span>|</span><a href="#39699942">next</a><span>|</span><label class="collapse" for="c-39700189">[-]</label><label class="expand" for="c-39700189">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Additionally after logic has been verified, there are many physical implementation details that have to be layered on top of this, including placement &amp; route optimizations<p>Software designed chip fabrication.  Please someone make this happen in my lifetime.</div><br/><div id="39700771" class="c"><input type="checkbox" id="c-39700771" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#39699212">root</a><span>|</span><a href="#39700189">parent</a><span>|</span><a href="#39699942">next</a><span>|</span><label class="collapse" for="c-39700771">[-]</label><label class="expand" for="c-39700771">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Software designed chip fabrication. Please someone make this happen in my lifetime.<p>That&#x27;s already a thing. See, for instance, <a href="https:&#x2F;&#x2F;platform.efabless.com&#x2F;shuttles&#x2F;MPW-8" rel="nofollow">https:&#x2F;&#x2F;platform.efabless.com&#x2F;shuttles&#x2F;MPW-8</a><p>Most of it uses the same languages, and many of the same tools, as FPGA design.</div><br/></div></div></div></div></div></div><div id="39699942" class="c"><input type="checkbox" id="c-39699942" checked=""/><div class="controls bullet"><span class="by">stefanpie</span><span>|</span><a href="#39699212">parent</a><span>|</span><a href="#39699524">prev</a><span>|</span><a href="#39699380">next</a><span>|</span><label class="collapse" for="c-39699942">[-]</label><label class="expand" for="c-39699942">[2 more]</label></div><br/><div class="children"><div class="content">Funnily enough, Matlab offers a high-level synthesis (HLS) tool to lower Matlab code and Simulink models to Verilog [1]. I have not personally used it, but the last I heard, it works well enough for those who need it and Matlab puts in the work to support it. However, HLS is another whole can of worms, and it can be confusing when discussing new HDLs and the distinction between an HLS tools and high-level HDL dialects.<p>[1] <a href="https:&#x2F;&#x2F;www.mathworks.com&#x2F;discovery&#x2F;high-level-synthesis.html" rel="nofollow">https:&#x2F;&#x2F;www.mathworks.com&#x2F;discovery&#x2F;high-level-synthesis.htm...</a></div><br/><div id="39701388" class="c"><input type="checkbox" id="c-39701388" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39699212">root</a><span>|</span><a href="#39699942">parent</a><span>|</span><a href="#39699380">next</a><span>|</span><label class="collapse" for="c-39701388">[-]</label><label class="expand" for="c-39701388">[1 more]</label></div><br/><div class="children"><div class="content">Matlab HLS is fantastic due to the restricted problem space. The C-to-hardware HLS stuff often has more mixed results.</div><br/></div></div></div></div></div></div><div id="39699380" class="c"><input type="checkbox" id="c-39699380" checked=""/><div class="controls bullet"><span class="by">ijuz</span><span>|</span><a href="#39699212">prev</a><span>|</span><a href="#39699924">next</a><span>|</span><label class="collapse" for="c-39699380">[-]</label><label class="expand" for="c-39699380">[1 more]</label></div><br/><div class="children"><div class="content">I do not see the point, there is not much syntactical sugar.<p>Basically all non-systemverilog HDL languages suffer from the issue that they make development maybe simpler, but on the other side it will be much harder to test the code, because the systemverilog output has to be simulated.
Additionally of course, synthesis and timing reports will tell you line numbers in generated systemverilog files instead of the line number of randomHDL.</div><br/></div></div><div id="39699924" class="c"><input type="checkbox" id="c-39699924" checked=""/><div class="controls bullet"><span class="by">kimmeld</span><span>|</span><a href="#39699380">prev</a><span>|</span><a href="#39699601">next</a><span>|</span><label class="collapse" for="c-39699924">[-]</label><label class="expand" for="c-39699924">[17 more]</label></div><br/><div class="children"><div class="content">System Verilog is the C++ of chip design. It sucks, but it’s everywhere and tied into everything. Like C++ there are so many ways to write dangerous code. We do need a new chip design language but it’s going to take something special to move the needle.</div><br/><div id="39700142" class="c"><input type="checkbox" id="c-39700142" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#39699924">parent</a><span>|</span><a href="#39700560">next</a><span>|</span><label class="collapse" for="c-39700142">[-]</label><label class="expand" for="c-39700142">[14 more]</label></div><br/><div class="children"><div class="content">30 years or so ago, there were a handful of programming languages in regular use:  C&#x2F;C++&#x2F;Assembly&#x2F;Ada&#x2F;Fortran&#x2F;Pascal.  Now there&#x27;s 100x more that people use professionally.<p>I always wondered what would happen if hardware engineers bothered to learn compiler theory.  Maybe this could have been a solved problem decades ago.</div><br/><div id="39700265" class="c"><input type="checkbox" id="c-39700265" checked=""/><div class="controls bullet"><span class="by">vrinsd</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700142">parent</a><span>|</span><a href="#39701196">next</a><span>|</span><label class="collapse" for="c-39700265">[-]</label><label class="expand" for="c-39700265">[11 more]</label></div><br/><div class="children"><div class="content">This is a pretty heavy handed statement -- there are plenty of &quot;hardware engineers&quot; who know plenty about compiler theory and&#x2F;or have contributed significantly to it.  A similarly flippant comment might be &quot;if software engineers only understood hardware better we might have smartphones that last a month on a charge and never crash&quot;.<p>The challenge with hardware is that unlike &quot;traditional&quot; software which compiles to a fixed instruction set architecture, with hardware you might literally be defining the ISA as part of your design.<p>In hardware you can go from LEGO style gluing pre-existing building blocks to creating the building blocks and THEN gluing it together, with everything in-between.<p>The real crux of the problem is likely our modern implementation of economics -- a CS graduate who has base-level experience can bank roll a crazy salary that some guy who might have a BSEE, MSEE and PhD in Electrical Engineering (&quot;hardware&quot;) will be lucky to get a job offer that&#x27;s even enough to cover costs of education.<p>Until the &quot;industry&quot; values hardware and those who want to improve it, you&#x27;ll likely see slow progress.<p>P.S.<p>VHDL (a commonly-used hardware description language) is more or less ADA.  Personally I think the choice of ADA syntax was NOT a positive for hardware design but the type-safety and verbosity being a very apt fit for software.</div><br/><div id="39700569" class="c"><input type="checkbox" id="c-39700569" checked=""/><div class="controls bullet"><span class="by">fpgamlirfanboy</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700265">parent</a><span>|</span><a href="#39700384">next</a><span>|</span><label class="collapse" for="c-39700569">[-]</label><label class="expand" for="c-39700569">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Until the &quot;industry&quot; values hardware<p>industries don&#x27;t value things, markets value things. RTL work doesn&#x27;t pay well because the products don&#x27;t sell into markets that scale like software. with the exception of NVIDIA and whatever you call Apple&#x27;s teams that actually do&#x2F;tweak hardware, no hardware product has the margins and scale of software. that&#x27;s not culture, that&#x27;s physics.<p>&gt; who know plenty about compiler theory and&#x2F;or have contributed significantly to it<p>also maybe some RTL people know about compiler stuff (phi nodes&#x2F;dataflow analysis&#x2F;reg alloc&#x2F;etc) but most definitely do not know anything except verilog&#x2F;vhdl and perl&#x2F;python.</div><br/><div id="39700708" class="c"><input type="checkbox" id="c-39700708" checked=""/><div class="controls bullet"><span class="by">vrinsd</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700569">parent</a><span>|</span><a href="#39700384">next</a><span>|</span><label class="collapse" for="c-39700708">[-]</label><label class="expand" for="c-39700708">[2 more]</label></div><br/><div class="children"><div class="content">I won&#x27;t get into a debate about semantics, but even your employer is a prime example -- Xilinx profit margin per device is staggering by semiconductor standards but they won&#x27;t pay what they could.  The market doesn&#x27;t always make that dictation, the company does.<p>And that&#x27;s an example but there are other &quot;high-margin&quot; hardware organizations (besides Apple) who still pay HW&#x2F;EEs lower than SW&#x2F;SREs.<p>And if you&#x27;ve been in engineering long enough you&#x27;ll meet some pretty brilliant people, but their names might not be household or widely known.  Lumping engineering into &quot;RTL people&quot; is pretty dismissive.<p>Claude Shannon, father of information theory, is less widely known for his MS work on &#x27;Shannon Decomposition&#x27; which FPGA companies used for a long time to break combinitorial logic functions to multiplexor (MUX) based implementation.  That&#x27;s not &quot;compiler theory&quot; but that&#x27;s a building block of a type of logic synthesis which compilers used.  Shannon isn&#x27;t a &quot;compiler guy&quot;, just a smart dude who&#x27;s intelligence wasn&#x27;t bounded by one domain or discipline.</div><br/></div></div></div></div><div id="39700384" class="c"><input type="checkbox" id="c-39700384" checked=""/><div class="controls bullet"><span class="by">anfilt</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700265">parent</a><span>|</span><a href="#39700569">prev</a><span>|</span><a href="#39700470">next</a><span>|</span><label class="collapse" for="c-39700384">[-]</label><label class="expand" for="c-39700384">[2 more]</label></div><br/><div class="children"><div class="content">Despite how verbose it is, I honestly like working with VHDL more than Verilog.</div><br/><div id="39700633" class="c"><input type="checkbox" id="c-39700633" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700384">parent</a><span>|</span><a href="#39700470">next</a><span>|</span><label class="collapse" for="c-39700633">[-]</label><label class="expand" for="c-39700633">[1 more]</label></div><br/><div class="children"><div class="content">And Ada is really an underappreciated language.  Still not perfect, but Spark makes it super interesting.</div><br/></div></div></div></div><div id="39700470" class="c"><input type="checkbox" id="c-39700470" checked=""/><div class="controls bullet"><span class="by">pillusmany</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700265">parent</a><span>|</span><a href="#39700384">prev</a><span>|</span><a href="#39700490">next</a><span>|</span><label class="collapse" for="c-39700470">[-]</label><label class="expand" for="c-39700470">[2 more]</label></div><br/><div class="children"><div class="content">Big software companies create and open source stuff which makes them more productive.<p>Why doesn&#x27;t this dynamic work in hardware?<p>Wouldn&#x27;t &quot;valuing hardware&quot; improve their competitiveness?</div><br/><div id="39700601" class="c"><input type="checkbox" id="c-39700601" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700470">parent</a><span>|</span><a href="#39700490">next</a><span>|</span><label class="collapse" for="c-39700601">[-]</label><label class="expand" for="c-39700601">[1 more]</label></div><br/><div class="children"><div class="content">Well... no.<p>I believe this to be a cultural difference as well as an economic one.<p>The marginal cost of open source software is $0.  But if you license an ARM core, you&#x27;re paying money for it (like Apple is doing for the M-series processors).  ARM has to make money somehow for the development of it&#x27;s core.<p>Open source software reduced risk -- though it took a while.  And the reduction of risk was valued by most companies who wrote software, or relied upon it for it&#x27;s profit stream.  Major software corporations at the time (IBM, Microsoft) only increased the risk in the 1980&#x2F;90&#x27;s, because they were mostly rent seeking.<p>Most problems were seen over and over and over again, hence they could be solved with software.  And when the Microsoft failed to solve them, the open source community did.<p>In hardware there&#x27;s only a handful of companies, and open sourcing anything might lead to a competitive disadvantage.  So whatever tooling AMD has, they&#x27;re not going to share with Intel.<p>Also when you&#x27;re paying ARM for a license, you&#x27;re getting a good core, and a lot of good support.</div><br/></div></div></div></div><div id="39700490" class="c"><input type="checkbox" id="c-39700490" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700265">parent</a><span>|</span><a href="#39700470">prev</a><span>|</span><a href="#39701196">next</a><span>|</span><label class="collapse" for="c-39700490">[-]</label><label class="expand" for="c-39700490">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;if software engineers only understood hardware better we might have smartphones that last a month on a charge and never crash&quot;.<p>I mean... is that wrong, though?  In 2024, C++ will still segfault -- 45 years after it&#x27;s creation in 1979.  No one steering the language seems to be bothered by it.  Even Bjarne Stroustrup works in the financial industry now raking in the large paychecks.<p>Turns out, I&#x27;m pretty cynical of software as well.<p>Look, I&#x27;m not saying &quot;Software is the utmost gloriousness that will save humanity!&quot;  But what I am saying is that hardware does seem to have fallen well behind software in terms of tooling.  VHDL and Verilog are still the tools used to describe hardware today as they were 30 years ago.<p>If you can fix the barrier to entry into hardware, you&#x27;ll probably increase the demand for custom hardware.</div><br/><div id="39700731" class="c"><input type="checkbox" id="c-39700731" checked=""/><div class="controls bullet"><span class="by">vrinsd</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700490">parent</a><span>|</span><a href="#39701258">prev</a><span>|</span><a href="#39701196">next</a><span>|</span><label class="collapse" for="c-39700731">[-]</label><label class="expand" for="c-39700731">[1 more]</label></div><br/><div class="children"><div class="content">Your example about Bjarne says it all -- it was financially more in his interest to leave academia &#x2F; standards comittee &#x2F; &quot;hardcore work&quot; for something more financially lucarative.<p>There&#x27;s maybe another bigger point here that a lot of &quot;great tools&quot; or &quot;good ideas turned into reality&quot; happened either because the person&#x2F;people working on it were so motivated and&#x2F;or they were in the right environment that supported this type of creativity.<p>Sadly, most hardware-oriented organizations are the exact opposite of creativity or &quot;great ideas&quot; because if they fail the physical cost to fix something is staggering.<p>In software you can try something, if it doesn&#x27;t work, call it a learning experience, re-factor, potentially re-use and have another go at it.<p>In hardware if you do that few people will high five you for a valiant effort.<p>Historically academia was a place that could &quot;birth&quot; new ideas, help explore them with a pure intent to see how it worked out.  These days I think people are dying to finish with school and not live a pauper&#x27;s life.</div><br/></div></div></div></div></div></div><div id="39701196" class="c"><input type="checkbox" id="c-39701196" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700142">parent</a><span>|</span><a href="#39700265">prev</a><span>|</span><a href="#39700934">next</a><span>|</span><label class="collapse" for="c-39701196">[-]</label><label class="expand" for="c-39701196">[1 more]</label></div><br/><div class="children"><div class="content">This is really a list of the survivors. Tcl was big in the early 1990&#x27;s, and Objective-C was around on NeXT and other boxes. Perl was rapidly becoming the glue that holds the web together. Lisp was embedded into a lot of programs, as it is now for extensibility. It&#x27;s also overstating Fortran&#x27;s role, which is much like todays niche.<p>It&#x27;s very hard to have an objective view of what programming language success and popularity looks like over that long a time, but I think that today there is a much narrower happy path. Either you&#x27;re a dynamically typed multiparadgram language that&#x27;s mostly imperative and OO in practice (Ruby, Python, Javascript), a statically typed object imperative language with brackets (C#, Go, Java), or Rust (where a lot of people don&#x27;t realize how good GCs got instead). Not a ton of Haskell or SML inspired new languages.<p>By contrast in the 1980-1990s there were serious questions about which of Pascal, C, Objective-C, Smalltalk, C++, was going to win out for the dominant language a system is built in. Stuff like Display PostScript depended in a deep way on exposing programing languages to the engineers who had to work with it that were pretty alien.</div><br/></div></div><div id="39700934" class="c"><input type="checkbox" id="c-39700934" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700142">parent</a><span>|</span><a href="#39701196">prev</a><span>|</span><a href="#39700560">next</a><span>|</span><label class="collapse" for="c-39700934">[-]</label><label class="expand" for="c-39700934">[1 more]</label></div><br/><div class="children"><div class="content">You mean if compiler theorists learned about parallel processing...</div><br/></div></div></div></div><div id="39700560" class="c"><input type="checkbox" id="c-39700560" checked=""/><div class="controls bullet"><span class="by">fpgamlirfanboy</span><span>|</span><a href="#39699924">parent</a><span>|</span><a href="#39700142">prev</a><span>|</span><a href="#39699601">next</a><span>|</span><label class="collapse" for="c-39700560">[-]</label><label class="expand" for="c-39700560">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It sucks, but it’s everywhere and tied into everything.<p>meh lots of places aren&#x27;t actually programming system verilog - they&#x27;re using python&#x2F;perl to generate it. that&#x27;s not the same thing.</div><br/><div id="39700588" class="c"><input type="checkbox" id="c-39700588" checked=""/><div class="controls bullet"><span class="by">kimmeld</span><span>|</span><a href="#39699924">root</a><span>|</span><a href="#39700560">parent</a><span>|</span><a href="#39699601">next</a><span>|</span><label class="collapse" for="c-39700588">[-]</label><label class="expand" for="c-39700588">[1 more]</label></div><br/><div class="children"><div class="content">Mangling the quote about regexes…
<a href="http:&#x2F;&#x2F;regex.info&#x2F;blog&#x2F;2006-09-15&#x2F;247" rel="nofollow">http:&#x2F;&#x2F;regex.info&#x2F;blog&#x2F;2006-09-15&#x2F;247</a><p>Some people when confronted with a problem, think “I know, I’ll use a different language to generate another language.” Now they have two problems.</div><br/></div></div></div></div></div></div><div id="39699601" class="c"><input type="checkbox" id="c-39699601" checked=""/><div class="controls bullet"><span class="by">fpgamlirfanboy</span><span>|</span><a href="#39699924">prev</a><span>|</span><a href="#39700185">next</a><span>|</span><label class="collapse" for="c-39699601">[-]</label><label class="expand" for="c-39699601">[12 more]</label></div><br/><div class="children"><div class="content">i&#x27;ll hop on the dismissive bandwagon but not for the same reason as everyone else: not a single one of these HDLs ever (ever) amount to more than perl scripts.<p>why? how? how could that possibly be? this one is written in rust...?<p>because not a single one of them, ever (ever) <i>emits a netlist</i>. they all emit verilog (or vhdl). hence: overengineered perl scripts (which actual employed RTL engineers use heavily...).</div><br/><div id="39700307" class="c"><input type="checkbox" id="c-39700307" checked=""/><div class="controls bullet"><span class="by">vrinsd</span><span>|</span><a href="#39699601">parent</a><span>|</span><a href="#39700988">next</a><span>|</span><label class="collapse" for="c-39700307">[-]</label><label class="expand" for="c-39700307">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because in order to turn your &quot;design&quot; into an ASIC or an FPGA, you need to go from whatever high-level language (insert new-HDL-du-jour) into a netlist compatible with your physical part.<p>The only scalable&#x2F;vendor&#x2F;device-neutral way to do that is to back-end your &quot;new&quot; HDL with Verilog&#x2F;SystemVerilog&#x2F;VHDL, especially if you want to simulate your design.<p>A long time ago people used to design chips and CPLDs&#x2F;FPGAs in schematic-capture (which actually does have its place) which is basically one-step removed from being a netlist.<p>Among other challenges if you wanted to change to a new device (say a bigger part) or a part from a different vendor, there wasn&#x27;t really &quot;neutral&quot; way to do this until HDLs came around.<p>To really change the status quo, you&#x27;d have to own EVERYTHING from the point of design entry to the physical device and all steps between.<p>Even with both &quot;major&quot; FPGA vendors now with their own synthesis and sometimes simulation capability they can barely and&#x2F;or reliably make that minimum bar work.</div><br/><div id="39700551" class="c"><input type="checkbox" id="c-39700551" checked=""/><div class="controls bullet"><span class="by">fpgamlirfanboy</span><span>|</span><a href="#39699601">root</a><span>|</span><a href="#39700307">parent</a><span>|</span><a href="#39700988">next</a><span>|</span><label class="collapse" for="c-39700551">[-]</label><label class="expand" for="c-39700551">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The only scalable&#x2F;vendor&#x2F;device-neutral way to do that is to back-end your &quot;new&quot; HDL with Verilog&#x2F;SystemVerilog&#x2F;VHDL<p>i mean like the guy below says, but in the opposite tone, that&#x27;s like saying building a C emitter is the same as building a compiler. like i just don&#x27;t agree (for C, because C isn&#x27;t some abstract device model and isn&#x27;t (easily) optimizable) because you are forever yoked to the assumptions&#x2F;affordances of the target language (which is ultimately a language and not an IR&#x2F;netlist&#x2F;whatever).<p>&gt; The only scalable&#x2F;vendor&#x2F;device-neutral way<p>blif is a thing, eblif, xml, etc. are there points of ingress in vivado or intel&#x27;s thing for any of these? i don&#x27;t remember but regardless i agree they&#x27;re probably not well-supported.<p>&gt; To really change the status quo, you&#x27;d have to own EVERYTHING from the point of design entry to the physical device and all steps between.<p>nah that&#x27;s not true. LLVM&#x2F;GCC&#x2F;etc. FOSS compilers that grew up in the last ~20-30 years prove you don&#x27;t need to own the last mile to change the status quo. if you build it, device manufacturers will come.<p>the truth is simply that performant logic synthesis, tech mapping, place and route, etc are just all much harder to implement than XYZ compiler pass. but it could be done given maybe 20*5 highly competent engineer years? i dunno pulling it out of my ass but i know i could write some of that stuff and i&#x27;m not <i>that</i> smart. maybe i&#x27;m underestimating by 2x (40*5) but that&#x27;s still less than most &quot;exciting&quot; startups that raise series A today. it just takes diligence and &quot;hard&quot; technical skills (familiarity with the relevant optimization literature).<p>&gt; Even with both &quot;major&quot; FPGA vendors now with their own synthesis and sometimes simulation capability they can barely and&#x2F;or reliably make that minimum bar work.<p>not sure what&#x27;s the minimum bar you&#x27;re referring to but sure i agree - i work at one of em (the one that didn&#x27;t file divorce papers recently...) and i still readily admit the toolchain is trash. which is why i wish some consortium would get together and replace it (because i would love to be able to program&#x2F;design on our own parts using a modern tool suite). and no circt&#x2F;yosys&#x2F;vtr whatever aren&#x27;t there probably won&#x27;t ever be (yosys in particular is terribly disappointing for all the waves&#x2F;claims it makes).</div><br/><div id="39700767" class="c"><input type="checkbox" id="c-39700767" checked=""/><div class="controls bullet"><span class="by">vrinsd</span><span>|</span><a href="#39699601">root</a><span>|</span><a href="#39700551">parent</a><span>|</span><a href="#39700988">next</a><span>|</span><label class="collapse" for="c-39700767">[-]</label><label class="expand" for="c-39700767">[2 more]</label></div><br/><div class="children"><div class="content">LLVM&#x2F;GCC target fixed ISA devices.  Even GPUs can be represented in this paradigm of having a core set of instructions and registers for SIMD&#x2F;SMT.  What FPGA or random ASIC could LLVM front-end?  How do you go from LLVM-IR to something that can live in an FPGA?<p>You can either do what most &quot;high-level&quot; or &quot;new HDL&quot; tools do which is emit some form of &quot;RTL&quot; (Verilog&#x2F;VHDL) or you can stick a place-holder design in the FPGA and then your LLVM-IR is basically emitting instructions for an &quot;overlay&quot; type of design.<p>And if we are being pedantic you can use Verilog or VHDL to write a purely STRUCTURAL netlist which includes hard instantiating &quot;basic building block&quot; primatives.  i.e. have your RTL instantiate an ISERDES or OSERDES block (which I suspect will mean something to you).<p>But even with a &quot;netlist&quot; based design in RTL you still have to technology map that into building blocks of your hardware and that whole process becomes so complex people have just migrated to writing &quot;behavorial&quot; RTL (or translating to it from some other language, i.e. Vivado HLS).<p>Lastly, Vivado does support EDIF netlists as do most FPGA tools (whether they advertise it or not) but if you don&#x27;t have a way to do a technology mapping stage from your high-level RTL into building blocks (which is effectively part of the &quot;synthesis&quot; steps), then what did you accomplish?</div><br/><div id="39700808" class="c"><input type="checkbox" id="c-39700808" checked=""/><div class="controls bullet"><span class="by">fpgamlirfanboy</span><span>|</span><a href="#39699601">root</a><span>|</span><a href="#39700767">parent</a><span>|</span><a href="#39700988">next</a><span>|</span><label class="collapse" for="c-39700808">[-]</label><label class="expand" for="c-39700808">[1 more]</label></div><br/><div class="children"><div class="content">&gt; LLVM&#x2F;GCC target fixed ISA devices. Even GPUs can be represented in this paradigm of having a core set of instructions and registers for SIMD&#x2F;SMT. What FPGA or random ASIC could LLVM front-end? How do you go from LLVM-IR to something that can live in an FPGA?<p>You completely missed my point, which was not that RTL and an ISA are comparable in any way but that many of the target codegen backends for both those compilers were contributed by the owners of the ISAs themselves. I said that in response to your claim that you need to own the whole stack to &quot;change the status quo&quot;. You don&#x27;t, you just (mighty big just) need to present a compelling enough value proposition in your stack for the device manufacturers to contribute the remainder of the stack.</div><br/></div></div></div></div></div></div></div></div><div id="39700988" class="c"><input type="checkbox" id="c-39700988" checked=""/><div class="controls bullet"><span class="by">fayalalebrun</span><span>|</span><a href="#39699601">parent</a><span>|</span><a href="#39700307">prev</a><span>|</span><a href="#39700255">next</a><span>|</span><label class="collapse" for="c-39700988">[-]</label><label class="expand" for="c-39700988">[1 more]</label></div><br/><div class="children"><div class="content">Chisel does emit FIRRTL. Which can be made into a bitstream directly by Yosys.</div><br/></div></div><div id="39700255" class="c"><input type="checkbox" id="c-39700255" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#39699601">parent</a><span>|</span><a href="#39700988">prev</a><span>|</span><a href="#39700185">next</a><span>|</span><label class="collapse" for="c-39700255">[-]</label><label class="expand" for="c-39700255">[6 more]</label></div><br/><div class="children"><div class="content">for a software analogy, a lot of programming languages compile to C; that doesn&#x27;t make them perl scripts!</div><br/><div id="39700552" class="c"><input type="checkbox" id="c-39700552" checked=""/><div class="controls bullet"><span class="by">fpgamlirfanboy</span><span>|</span><a href="#39699601">root</a><span>|</span><a href="#39700255">parent</a><span>|</span><a href="#39700185">next</a><span>|</span><label class="collapse" for="c-39700552">[-]</label><label class="expand" for="c-39700552">[5 more]</label></div><br/><div class="children"><div class="content">&gt; that doesn&#x27;t make them perl scripts!<p>but it doesn&#x27;t make them compilers either :shrug:</div><br/><div id="39700574" class="c"><input type="checkbox" id="c-39700574" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#39699601">root</a><span>|</span><a href="#39700552">parent</a><span>|</span><a href="#39700185">next</a><span>|</span><label class="collapse" for="c-39700574">[-]</label><label class="expand" for="c-39700574">[4 more]</label></div><br/><div class="children"><div class="content">of course it does! what else would you call something like chicken scheme [<a href="https:&#x2F;&#x2F;call-cc.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;call-cc.org&#x2F;</a>], ats [<a href="https:&#x2F;&#x2F;ats-lang.sourceforge.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ats-lang.sourceforge.net&#x2F;</a>], or ghc [<a href="https:&#x2F;&#x2F;www.haskell.org&#x2F;ghc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.haskell.org&#x2F;ghc&#x2F;</a>]? they are not &quot;scripts&quot;, they are full-blown compilers that happen to use C as their compilation target, and then leverage C compilers to generate code for a variety of architecures. it&#x27;s a very sensible way to do things.</div><br/><div id="39700605" class="c"><input type="checkbox" id="c-39700605" checked=""/><div class="controls bullet"><span class="by">fpgamlirfanboy</span><span>|</span><a href="#39699601">root</a><span>|</span><a href="#39700574">parent</a><span>|</span><a href="#39700657">next</a><span>|</span><label class="collapse" for="c-39700605">[-]</label><label class="expand" for="c-39700605">[1 more]</label></div><br/><div class="children"><div class="content">ghc doesn&#x27;t target C since 7.0. the other two i couldn&#x27;t be bothered to care even less about. when you can point to a production grade &quot;&quot;&quot;compiler&quot;&quot;&quot; that targets C (instead of emitting ir or asm directly) then i&#x27;ll be happy to discuss the merits&#x2F;virtues of source to source translation instead of compilation.</div><br/></div></div><div id="39700657" class="c"><input type="checkbox" id="c-39700657" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#39699601">root</a><span>|</span><a href="#39700574">parent</a><span>|</span><a href="#39700605">prev</a><span>|</span><a href="#39700185">next</a><span>|</span><label class="collapse" for="c-39700657">[-]</label><label class="expand" for="c-39700657">[2 more]</label></div><br/><div class="children"><div class="content">Umm, everyone calls them transpilers?</div><br/><div id="39701000" class="c"><input type="checkbox" id="c-39701000" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#39699601">root</a><span>|</span><a href="#39700657">parent</a><span>|</span><a href="#39700185">next</a><span>|</span><label class="collapse" for="c-39701000">[-]</label><label class="expand" for="c-39701000">[1 more]</label></div><br/><div class="children"><div class="content">transpilers are a subset of compilers though. they span the gamut from things like coffeescript that do fairly simple syntax transformations, to full fledged languages whose compilation target happens to be a high level language like C or javascript, but which otherwise implement most of what you would expect in a &quot;compiler&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39700185" class="c"><input type="checkbox" id="c-39700185" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#39699601">prev</a><span>|</span><label class="collapse" for="c-39700185">[-]</label><label class="expand" for="c-39700185">[1 more]</label></div><br/><div class="children"><div class="content">I highly recommend looking into Clash as an alternate HDL. It&#x27;s a GHC Haskell backend - exceedingly cool.<p>And there&#x27;s a book: &quot;Retrocomputing in Clash&quot;</div><br/></div></div></div></div></div></div></div></body></html>