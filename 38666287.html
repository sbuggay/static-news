<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702803670708" as="style"/><link rel="stylesheet" href="styles.css?v=1702803670708"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/tlack/atree">Atree: A simple and efficient pointer-free tree implementation</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>spenczar5</span> | <span>99 comments</span></div><br/><div><div id="38666887" class="c"><input type="checkbox" id="c-38666887" checked=""/><div class="controls bullet"><span class="by">tlack</span><span>|</span><a href="#38668061">next</a><span>|</span><label class="collapse" for="c-38666887">[-]</label><label class="expand" for="c-38666887">[33 more]</label></div><br/><div class="children"><div class="content">Always surprising to click through a link on HN and discover it is one&#x27;s own work. For a time I was very interested in lightweight array-based implementations of common data structures and this one seemed particularly handy.</div><br/><div id="38666916" class="c"><input type="checkbox" id="c-38666916" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#38666887">parent</a><span>|</span><a href="#38668309">next</a><span>|</span><label class="collapse" for="c-38666916">[-]</label><label class="expand" for="c-38666916">[31 more]</label></div><br/><div class="children"><div class="content">It sounds a little like it didn’t work out as well as you hoped. How did it fare?<p>I am interested because I have some scientific software (astrodynamics - propagating orbits in space) that would really benefit from a cache-friendly tree, and this seemed promising.</div><br/><div id="38666977" class="c"><input type="checkbox" id="c-38666977" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38666916">parent</a><span>|</span><a href="#38667904">next</a><span>|</span><label class="collapse" for="c-38666977">[-]</label><label class="expand" for="c-38666977">[22 more]</label></div><br/><div class="children"><div class="content">It does? Feels like an O(n) scan every time you need to query the children of a node is a nonstarter for most applications (the readme is strangely optimistic about this point). Plenty of cache friendly tree implementations out there, and this one seems actually cache hostile with few benefits in my mind aside from ease of implementation.<p>Also, I write a lot of code that runs on a gpu, and the claim that this tree is somehow gpu friendly I find particularly dubious.</div><br/><div id="38667683" class="c"><input type="checkbox" id="c-38667683" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38666977">parent</a><span>|</span><a href="#38667193">next</a><span>|</span><label class="collapse" for="c-38667683">[-]</label><label class="expand" for="c-38667683">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Feels like an O(n) scan every time you need to query the children of a node is a nonstarter for most applications (the readme is strangely optimistic about this point).<p>The trick is that querying the children of N different nodes is usually <i>still</i> a single O(N) scan, so if you operate on it array-style (which APL heavily encourages anyway), it&#x27;s amortized constant time. Of course that&#x27;s not <i>always</i> viable, but APL programmers tend to be surprisingly good at making array operations out of things you wouldn&#x27;t expect to use arrays for.<p>&gt; cache hostile<p>If you additionally enforce that all parent indexes point to lower numbers, a preorder traversal is a linear scan forward, and a postorder traversal with child order reversed (which you can usually correct for one way or another) is a linear scan backward.<p>(This assumes you only need dependency ordering, ie the parent node uses or supplies data to&#x2F;from its children; if you need a true sequential traversal, the array has to be sorted according to that traversal (but is still a valid Apter Tree).)<p>&gt; the claim that this tree is somehow gpu friendly I find particularly dubious<p>Yeah, array programming is generally kind of hit-or-miss at that and this does <i>look</i> like a miss.</div><br/><div id="38668003" class="c"><input type="checkbox" id="c-38668003" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667683">parent</a><span>|</span><a href="#38670976">next</a><span>|</span><label class="collapse" for="c-38668003">[-]</label><label class="expand" for="c-38668003">[3 more]</label></div><br/><div class="children"><div class="content">The linear scan you are talking about I don&#x27;t think gives you any sort of ordered traversal right? Unless I&#x27;m missing something.</div><br/><div id="38668430" class="c"><input type="checkbox" id="c-38668430" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38668003">parent</a><span>|</span><a href="#38670976">next</a><span>|</span><label class="collapse" for="c-38668430">[-]</label><label class="expand" for="c-38668430">[2 more]</label></div><br/><div class="children"><div class="content">For a <i>arbitrary</i> Apter Tree, a linear scan is unordered. You can impose additional constraints to get a ordered traversal (in the same way that, eg, you can sort a assoc-list&#x2F;JSON-style key-value table by keys to get a key-order traversal), and the result is still a valid Apter Tree (respectively valid list of key-value pairs).</div><br/><div id="38669532" class="c"><input type="checkbox" id="c-38669532" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38668430">parent</a><span>|</span><a href="#38670976">next</a><span>|</span><label class="collapse" for="c-38669532">[-]</label><label class="expand" for="c-38669532">[1 more]</label></div><br/><div class="children"><div class="content">Yes but that is not what is presented (a B+ tree is not a B tree even with minor modifications) and it changes the complexity of your other update operations drastically. The thing that grates me (as someone that has written a dozen or so different tree structures) is that this one is presented as a particularly good one, and I think it excels at almost nothing, hence its obscurity.</div><br/></div></div></div></div></div></div><div id="38670976" class="c"><input type="checkbox" id="c-38670976" checked=""/><div class="controls bullet"><span class="by">toasted-subs</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667683">parent</a><span>|</span><a href="#38668003">prev</a><span>|</span><a href="#38667193">next</a><span>|</span><label class="collapse" for="c-38670976">[-]</label><label class="expand" for="c-38670976">[1 more]</label></div><br/><div class="children"><div class="content">Whenever somebody says cache friendly without additional context I assume they got code from somebody else without understanding what makes things &quot;cache-friendly&quot;.</div><br/></div></div></div></div><div id="38667193" class="c"><input type="checkbox" id="c-38667193" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38666977">parent</a><span>|</span><a href="#38667683">prev</a><span>|</span><a href="#38667507">next</a><span>|</span><label class="collapse" for="c-38667193">[-]</label><label class="expand" for="c-38667193">[4 more]</label></div><br/><div class="children"><div class="content">For me, N is small. Its also N-ary, not binary, which crosses off a bunch of the first options. Anyway, I am not sure this will work, just worth trying. Empirical numbers beat theory every time :)</div><br/><div id="38667989" class="c"><input type="checkbox" id="c-38667989" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667193">parent</a><span>|</span><a href="#38667507">next</a><span>|</span><label class="collapse" for="c-38667989">[-]</label><label class="expand" for="c-38667989">[3 more]</label></div><br/><div class="children"><div class="content">You are using N in a different sense than I am. Unless I&#x27;m reading the tree description incorrectly, N is the size of the tree itself, not the number of children.</div><br/><div id="38668105" class="c"><input type="checkbox" id="c-38668105" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667989">parent</a><span>|</span><a href="#38667507">next</a><span>|</span><label class="collapse" for="c-38668105">[-]</label><label class="expand" for="c-38668105">[2 more]</label></div><br/><div class="children"><div class="content">Oh, I was being sloppy and mixed N into the ariness: I meant N elements, each with a variable number of children (as many as 8).</div><br/><div id="38668216" class="c"><input type="checkbox" id="c-38668216" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38668105">parent</a><span>|</span><a href="#38667507">next</a><span>|</span><label class="collapse" for="c-38668216">[-]</label><label class="expand" for="c-38668216">[1 more]</label></div><br/><div class="children"><div class="content">I would hazard a guess that a regular n-ary tree would outperform the OP tree in many usage scenarios with no extra effort, and with a number of B+ tree variants being strictly better at the cost of more effort.</div><br/></div></div></div></div></div></div></div></div><div id="38667507" class="c"><input type="checkbox" id="c-38667507" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38666977">parent</a><span>|</span><a href="#38667193">prev</a><span>|</span><a href="#38667351">next</a><span>|</span><label class="collapse" for="c-38667507">[-]</label><label class="expand" for="c-38667507">[10 more]</label></div><br/><div class="children"><div class="content">Vector programming requires you to change your way of thinking; instead of computing something for 1 element, you compute it for N elements.</div><br/><div id="38667963" class="c"><input type="checkbox" id="c-38667963" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667507">parent</a><span>|</span><a href="#38667351">next</a><span>|</span><label class="collapse" for="c-38667963">[-]</label><label class="expand" for="c-38667963">[9 more]</label></div><br/><div class="children"><div class="content">I do lots of simd and shader programming, but regardless of register width, O(n) is not O(1)</div><br/><div id="38668968" class="c"><input type="checkbox" id="c-38668968" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667963">parent</a><span>|</span><a href="#38668578">next</a><span>|</span><label class="collapse" for="c-38668968">[-]</label><label class="expand" for="c-38668968">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think looking at asymptotic behavor makes a lot of sense in situations where n is small and bounded.  Big O says nothing about such cases.</div><br/><div id="38669539" class="c"><input type="checkbox" id="c-38669539" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38668968">parent</a><span>|</span><a href="#38668578">next</a><span>|</span><label class="collapse" for="c-38669539">[-]</label><label class="expand" for="c-38669539">[5 more]</label></div><br/><div class="children"><div class="content">Sorry, do you not have trees for which the size of the tree is large. Do all your trees fit inside a few cache lines of storage?</div><br/><div id="38669885" class="c"><input type="checkbox" id="c-38669885" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38669539">parent</a><span>|</span><a href="#38668578">next</a><span>|</span><label class="collapse" for="c-38669885">[-]</label><label class="expand" for="c-38669885">[4 more]</label></div><br/><div class="children"><div class="content">I deal with very large tree structures (~100 GB) in my search engine, but even there the dominant factor for performance isn&#x27;t big O, but reducing block reads, access patterns and keeping relevant data in the disk cache.<p>Big O isn&#x27;t irrelevant, but it is not the full story either.  There&#x27;s a solid reason why hash tables are a thing in memory but aren&#x27;t really a thing on disk.</div><br/><div id="38670439" class="c"><input type="checkbox" id="c-38670439" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38669885">parent</a><span>|</span><a href="#38668578">next</a><span>|</span><label class="collapse" for="c-38670439">[-]</label><label class="expand" for="c-38670439">[3 more]</label></div><br/><div class="children"><div class="content">Do you understand the data structure being proposed in the original post, and are you claiming that scanning 100GB of data every time you want to perform a childof operation is acceptable? Please, use the proposed tree for your application since big o isn&#x27;t the full story to you lol</div><br/><div id="38670928" class="c"><input type="checkbox" id="c-38670928" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38670439">parent</a><span>|</span><a href="#38668578">next</a><span>|</span><label class="collapse" for="c-38670928">[-]</label><label class="expand" for="c-38670928">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure why you&#x27;re suggesting those claims were made. The parent appears to be talking about non-asymptotic behavior. Very often algorithms with worse big O perform better; its use-case specific. Hyper focus on big O isnt productive, but fairly common due to how CS curriculums focus on it. In some cases it takes unexpectedly long for the big-O to impact performance, as other factors dominate.<p>The parent commenter writes a wonderful blog that covers their experience with building and optimizing a search engine, well worth a read.<p><a href="https:&#x2F;&#x2F;www.marginalia.nu&#x2F;log&#x2F;87_absurd_success&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.marginalia.nu&#x2F;log&#x2F;87_absurd_success&#x2F;</a></div><br/><div id="38671139" class="c"><input type="checkbox" id="c-38671139" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38670928">parent</a><span>|</span><a href="#38668578">next</a><span>|</span><label class="collapse" for="c-38671139">[-]</label><label class="expand" for="c-38671139">[1 more]</label></div><br/><div class="children"><div class="content">Yes and I&#x27;m pointing out that non-asymptotic behavior doesn&#x27;t apply when N here is <i>the total number of nodes in the tree</i>.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38668578" class="c"><input type="checkbox" id="c-38668578" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667963">parent</a><span>|</span><a href="#38668968">prev</a><span>|</span><a href="#38667351">next</a><span>|</span><label class="collapse" for="c-38668578">[-]</label><label class="expand" for="c-38668578">[2 more]</label></div><br/><div class="children"><div class="content">The point is that you shouldn&#x27;t try to get all the children of a single node, but rather all the children of all the nodes, which is still O(n) and not O(n^2).</div><br/><div id="38669543" class="c"><input type="checkbox" id="c-38669543" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38668578">parent</a><span>|</span><a href="#38667351">next</a><span>|</span><label class="collapse" for="c-38669543">[-]</label><label class="expand" for="c-38669543">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t make any sense to me.</div><br/></div></div></div></div></div></div></div></div><div id="38667173" class="c"><input type="checkbox" id="c-38667173" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38666977">parent</a><span>|</span><a href="#38667351">prev</a><span>|</span><a href="#38667904">next</a><span>|</span><label class="collapse" for="c-38667173">[-]</label><label class="expand" for="c-38667173">[1 more]</label></div><br/><div class="children"><div class="content">There are use cases where that doesn’t matter, such as some compilers where it makes a full pass over the source code for every optimisation type.</div><br/></div></div></div></div><div id="38667904" class="c"><input type="checkbox" id="c-38667904" checked=""/><div class="controls bullet"><span class="by">tlack</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38666916">parent</a><span>|</span><a href="#38666977">prev</a><span>|</span><a href="#38670066">next</a><span>|</span><label class="collapse" for="c-38667904">[-]</label><label class="expand" for="c-38667904">[6 more]</label></div><br/><div class="children"><div class="content">I still like that setup for using trees in low level languages.<p>But personally I’ve been working at higher levels of the stack the last few years, where these kinds of decisions seem less important.<p>And on another level, it seems like coders in general aren’t that interested in vector oriented languages and techniques which makes their study somewhat isolating.</div><br/><div id="38669303" class="c"><input type="checkbox" id="c-38669303" checked=""/><div class="controls bullet"><span class="by">loxias</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667904">parent</a><span>|</span><a href="#38667997">next</a><span>|</span><label class="collapse" for="c-38669303">[-]</label><label class="expand" for="c-38669303">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Isolating&quot; is where the performance (innovation) is.<p>I used a very similar setup, first time I needed to implement a tree. Now, I&#x27;m a fan of Eytzinger layout.  (referenced in a previous comment in this thread)<p>Yeah, most coders in general don&#x27;t seem to be as interested in this stuff, but it&#x27;s still necessary.  They&#x27;ll want more performance.</div><br/><div id="38670554" class="c"><input type="checkbox" id="c-38670554" checked=""/><div class="controls bullet"><span class="by">caslon</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38669303">parent</a><span>|</span><a href="#38667997">next</a><span>|</span><label class="collapse" for="c-38670554">[-]</label><label class="expand" for="c-38670554">[2 more]</label></div><br/><div class="children"><div class="content">Why do they need more performance? Hardware gets faster all the time, and the most popular implementations of the most popular programming languages have so much low-hanging fruit you can get a 10x improvement by rolling your cat on the keyboard.<p>I don&#x27;t think programmers actually care about performance as much as they care for convenience. Every year the stack moves a bit higher, and everyone is okay with websites taking days to load on brand new phones with Gigabit wireless connections. There are <i>companies</i> that care about performance on the margin, like stock trading firms, but to get into one of them, you have to get pretty lucky, or come from a pretty special background. Even the banks are using Python more and more, these days.</div><br/><div id="38670967" class="c"><input type="checkbox" id="c-38670967" checked=""/><div class="controls bullet"><span class="by">loxias</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38670554">parent</a><span>|</span><a href="#38667997">next</a><span>|</span><label class="collapse" for="c-38670967">[-]</label><label class="expand" for="c-38670967">[1 more]</label></div><br/><div class="children"><div class="content">Shrug.<p>People will always care about performance because they will always want more functionality.<p>I bet you care about the performance of your database or how fast your pages load.  You want your streaming videos to be skip-free and your phone calls to sound lifelike.  Performance will <i>always</i> matter.  Because while people like me will be always trying to squeeze more, &quot;the other side&quot; will always be ready to use it for some new feature.</div><br/></div></div></div></div></div></div><div id="38667997" class="c"><input type="checkbox" id="c-38667997" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667904">parent</a><span>|</span><a href="#38669303">prev</a><span>|</span><a href="#38669708">next</a><span>|</span><label class="collapse" for="c-38667997">[-]</label><label class="expand" for="c-38667997">[1 more]</label></div><br/><div class="children"><div class="content">It is always like that when you venture off the well trodden path. I am studying low latency emulation and it&#x27;s also isolating.</div><br/></div></div><div id="38669708" class="c"><input type="checkbox" id="c-38669708" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38667904">parent</a><span>|</span><a href="#38667997">prev</a><span>|</span><a href="#38670066">next</a><span>|</span><label class="collapse" for="c-38669708">[-]</label><label class="expand" for="c-38669708">[1 more]</label></div><br/><div class="children"><div class="content">&gt; working at higher levels of the stack the last few years, where these kinds of decisions seem less important.<p>but then accumulated outcome of this is the slowness you see in web software!</div><br/></div></div></div></div><div id="38670066" class="c"><input type="checkbox" id="c-38670066" checked=""/><div class="controls bullet"><span class="by">runeblaze</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38666916">parent</a><span>|</span><a href="#38667904">prev</a><span>|</span><a href="#38669263">next</a><span>|</span><label class="collapse" for="c-38670066">[-]</label><label class="expand" for="c-38670066">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I worked also on scientific software (phylogenetics, which is all about biological evolutionary trees) and the tree structure is like Atree (<a href="https:&#x2F;&#x2F;github.com&#x2F;RuneBlaze&#x2F;internode&#x2F;blob&#x2F;main&#x2F;src&#x2F;tree.rs#L125">https:&#x2F;&#x2F;github.com&#x2F;RuneBlaze&#x2F;internode&#x2F;blob&#x2F;main&#x2F;src&#x2F;tree.rs...</a>).<p>It does help (roughly ~5x vs. pointer-chasing trees, probably can be further optimized) for my workload, but at the same time quite some time was spent just making sure the tree is correct.</div><br/></div></div><div id="38669263" class="c"><input type="checkbox" id="c-38669263" checked=""/><div class="controls bullet"><span class="by">loxias</span><span>|</span><a href="#38666887">root</a><span>|</span><a href="#38666916">parent</a><span>|</span><a href="#38670066">prev</a><span>|</span><a href="#38668309">next</a><span>|</span><label class="collapse" for="c-38669263">[-]</label><label class="expand" for="c-38669263">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested in the same stuff&#x2F;area.  There&#x27;s a lot of great results to read, check out cache-oblivious B-trees by Dr. Demaine (or honestly anything by him.)  This link is a good distillation of some of the concepts.  <a href="https:&#x2F;&#x2F;algorithmica.org&#x2F;en&#x2F;eytzinger" rel="nofollow noreferrer">https:&#x2F;&#x2F;algorithmica.org&#x2F;en&#x2F;eytzinger</a><p>I&#x27;m _also_ interested in scientific software, but that&#x27;s more a hobby than a job. =)<p>For propagating a large number of orbits in space, I&#x27;m really curious what the Correct (tm) numerical algorithm is, mind sharing more?  I love that space right at the intersection of lots of math + need to understand how computers <i>really</i> work.  Once upon a time I implemented fast multipole method for the n-body problem, but I certainly don&#x27;t claim to deeply understand it, anymore. :)</div><br/></div></div></div></div><div id="38668309" class="c"><input type="checkbox" id="c-38668309" checked=""/><div class="controls bullet"><span class="by">8372049</span><span>|</span><a href="#38666887">parent</a><span>|</span><a href="#38666916">prev</a><span>|</span><a href="#38668061">next</a><span>|</span><label class="collapse" for="c-38668309">[-]</label><label class="expand" for="c-38668309">[1 more]</label></div><br/><div class="children"><div class="content">Friendly heads up, &quot;pseudo&quot; is frequently misspelled &quot;psuedo&quot; in the readme.</div><br/></div></div></div></div><div id="38668061" class="c"><input type="checkbox" id="c-38668061" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#38666887">prev</a><span>|</span><a href="#38667395">next</a><span>|</span><label class="collapse" for="c-38668061">[-]</label><label class="expand" for="c-38668061">[2 more]</label></div><br/><div class="children"><div class="content">This is the representation I usually see used for the tree of nodes for skinning 3D models. There each node has a transform, and the most common operation is to recompute the world transform for all nodes, formed by composing the transform for each node with the one for all of its parents. If the array is sorted so that parents always precede their children, that&#x27;s just a straight loop over the arrays<p><pre><code>   for i = 0, num_nodes do
     if parents[i] == -1 then
       world_xforms[i] = xforms[i]
     else
       world_xforms[i] = world_xforms[parents[i]] * xforms[i]</code></pre></div><br/><div id="38670817" class="c"><input type="checkbox" id="c-38670817" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#38668061">parent</a><span>|</span><a href="#38667395">next</a><span>|</span><label class="collapse" for="c-38670817">[-]</label><label class="expand" for="c-38670817">[1 more]</label></div><br/><div class="children"><div class="content">I would hope your joint hierarchy is at least depth sorted or the loop as shown would not work. The proposed ATree has no order invariants...</div><br/></div></div></div></div><div id="38667395" class="c"><input type="checkbox" id="c-38667395" checked=""/><div class="controls bullet"><span class="by">rav</span><span>|</span><a href="#38668061">prev</a><span>|</span><a href="#38671112">next</a><span>|</span><label class="collapse" for="c-38667395">[-]</label><label class="expand" for="c-38667395">[2 more]</label></div><br/><div class="children"><div class="content">Lots of comments about iterating over children being O(N) for this style of trees. It&#x27;s actually easy to generalize the atree design by e.g. adding pointers for &quot;first child&quot; and &quot;next sibling&quot; and potentially removing the parent pointers, if that&#x27;s what you need in your application. I think the &quot;Operations in psuedocode&quot; section should simply state that there&#x27;s no O(1) way to access children of a node - instead of recommending the O(N) approach, you should recommend changing the data structure to support the operations you need.<p>Storing nodes in arrays and using indices for pointers is a must whenever you&#x27;re implementing algorithms on trees. I typically prefer using an array of structs, putting the key and the parent index next to each other, instead of putting them in separate arrays. If you need to access the children of a node, then be sure to consider if you can save memory by having a separate structure for leaves - remember that over half of the nodes will be leaves, so using space to store a child pointer on both internal nodes and leaves can be wasteful use of memory.</div><br/><div id="38670048" class="c"><input type="checkbox" id="c-38670048" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38667395">parent</a><span>|</span><a href="#38671112">next</a><span>|</span><label class="collapse" for="c-38670048">[-]</label><label class="expand" for="c-38670048">[1 more]</label></div><br/><div class="children"><div class="content">One way to maintain leaves efficiently (amortised O(1) time and space to add&#x2F;remove) is to keep 2 extra vectors that &quot;point at each other&quot;: L[] is a vector containing the indices of all leaves, and LP[] is a vector such that LP[i] stores the index within L[] of the value i if i is a leaf, and -1 otherwise. That is, for i a non-leaf, LP[i] == -1, while for i a leaf, L[LP[i]] == i.<p>To find the indices of all leaves: That&#x27;s just L[].<p>To add a leaf i: Append i to L[], and set LP[i] to L.length - 1.<p>To remove a leaf i in constant time:<p><pre><code>    j = L[L.length - 1]
    L[LP[i]] = j
    LP[j] = i
    LP[i] = -1.
    DropLastElement(L[])</code></pre></div><br/></div></div></div></div><div id="38671112" class="c"><input type="checkbox" id="c-38671112" checked=""/><div class="controls bullet"><span class="by">sinuhe69</span><span>|</span><a href="#38667395">prev</a><span>|</span><a href="#38667919">next</a><span>|</span><label class="collapse" for="c-38671112">[-]</label><label class="expand" for="c-38671112">[2 more]</label></div><br/><div class="children"><div class="content">What is a array index if not a “pointer”? In fact, access an array member involves a pointer arithmetic:
array_p + index * data_size<p>The fact that traditional tree implementation requires malloc is solely based on the wish to dynamically provide and remove of nodes. If the tree can have a limited size with no frequent delete operation, an array implementation is fine. Otherwise, expand an array can be a very costly or even an impossible operation in some circumstances.<p>And full scanning is not efficient.</div><br/><div id="38671358" class="c"><input type="checkbox" id="c-38671358" checked=""/><div class="controls bullet"><span class="by">kleiba</span><span>|</span><a href="#38671112">parent</a><span>|</span><a href="#38667919">next</a><span>|</span><label class="collapse" for="c-38671358">[-]</label><label class="expand" for="c-38671358">[1 more]</label></div><br/><div class="children"><div class="content">The difference lies in the CPU cache.</div><br/></div></div></div></div><div id="38667919" class="c"><input type="checkbox" id="c-38667919" checked=""/><div class="controls bullet"><span class="by">matt3210</span><span>|</span><a href="#38671112">prev</a><span>|</span><a href="#38670956">next</a><span>|</span><label class="collapse" for="c-38667919">[-]</label><label class="expand" for="c-38667919">[7 more]</label></div><br/><div class="children"><div class="content">An integer which references another data location is a pointer.  This project only replaces system pointers with home grown pointers</div><br/><div id="38668350" class="c"><input type="checkbox" id="c-38668350" checked=""/><div class="controls bullet"><span class="by">8372049</span><span>|</span><a href="#38667919">parent</a><span>|</span><a href="#38669168">next</a><span>|</span><label class="collapse" for="c-38668350">[-]</label><label class="expand" for="c-38668350">[1 more]</label></div><br/><div class="children"><div class="content">I think in this context, &quot;pointer-free&quot; is meant to imply (spatial) locality of reference, no additional memory allocations, address-independent and presumably memory safety (but I didn&#x27;t read the code and may be wrong about the last one).</div><br/></div></div><div id="38669168" class="c"><input type="checkbox" id="c-38669168" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#38667919">parent</a><span>|</span><a href="#38668350">prev</a><span>|</span><a href="#38670780">next</a><span>|</span><label class="collapse" for="c-38669168">[-]</label><label class="expand" for="c-38669168">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not exactly so right on the hardware level. Many architectures, including the ubiquitous x64, have an ability to add a direct offset to a memory-access operation (like mov), or efficiently compute the address with an offset and element size (like lea). This removes an extra pointer deteference, which may be hugely expensive.<p>With a cache-friendly structure like array, the one dereference you may need for the array access has a high chance to be served from L2 or L1, saving you a lot of clocks, because RAM has huge latency.</div><br/></div></div><div id="38670780" class="c"><input type="checkbox" id="c-38670780" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#38667919">parent</a><span>|</span><a href="#38669168">prev</a><span>|</span><a href="#38668615">next</a><span>|</span><label class="collapse" for="c-38670780">[-]</label><label class="expand" for="c-38670780">[1 more]</label></div><br/><div class="children"><div class="content">This is typically referred to as a handle rather than a pointer. Handles can permit more flexibility than pointers.</div><br/></div></div><div id="38668615" class="c"><input type="checkbox" id="c-38668615" checked=""/><div class="controls bullet"><span class="by">huhtenberg</span><span>|</span><a href="#38667919">parent</a><span>|</span><a href="#38670780">prev</a><span>|</span><a href="#38670956">next</a><span>|</span><label class="collapse" for="c-38668615">[-]</label><label class="expand" for="c-38668615">[3 more]</label></div><br/><div class="children"><div class="content">Oh, please.<p>There are technically correct nitpicks with some merit and there are trivial remarks like yours. It is perfectly clear what &quot;pointer-free&quot; was referring to in the post title.</div><br/><div id="38670114" class="c"><input type="checkbox" id="c-38670114" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38667919">root</a><span>|</span><a href="#38668615">parent</a><span>|</span><a href="#38671104">next</a><span>|</span><label class="collapse" for="c-38670114">[-]</label><label class="expand" for="c-38670114">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a legitimate criticism. The claimed benefit of &quot;vector processing is faster than pointer chasing&quot; will materialise only when the most common access pattern is to read or write all node values, since in that case the accessed values are contiguous -- but that&#x27;s a consequence of the data structure being a struct-of-arrays (instead of the more common array-of-structs), which is wholly independent of the pointers-or-indices question. For any of the (very common) other access patterns, like a preorder traversal, &quot;index-chasing&quot; needs to happen, and that will be exactly as bad as pointer-chasing would be if the entire memory block had been reserved ahead of time in the same way.<p>The only real advantages of indices over pointers are serialisability and ease of debugging.</div><br/></div></div><div id="38671104" class="c"><input type="checkbox" id="c-38671104" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#38667919">root</a><span>|</span><a href="#38668615">parent</a><span>|</span><a href="#38670114">prev</a><span>|</span><a href="#38670956">next</a><span>|</span><label class="collapse" for="c-38671104">[-]</label><label class="expand" for="c-38671104">[1 more]</label></div><br/><div class="children"><div class="content">Is it? Please tell me because I had the same question.<p>From the programmer&#x27;s PoV, having no pointers gives little to no benefit. From the CPU&#x27;s PoV, (in c&#x2F;c++) indices become pointers anyway. Maybe the compiler can optimise more easily, but that&#x27;s not obvious.<p>Cache coherence is the key goal,  but you can do that with pointers easily enough.</div><br/></div></div></div></div></div></div><div id="38670956" class="c"><input type="checkbox" id="c-38670956" checked=""/><div class="controls bullet"><span class="by">bicsi</span><span>|</span><a href="#38667919">prev</a><span>|</span><a href="#38667412">next</a><span>|</span><label class="collapse" for="c-38670956">[-]</label><label class="expand" for="c-38670956">[1 more]</label></div><br/><div class="children"><div class="content">I find it a bit odd how this tree representation as a parents array (which is, by the way, I think the most basic representation in any CS course), got so much traction on HN. I think this goes to show how far a good presentation can drive a trivial idea. On top of that, it just casually presents suboptimal procedures for a lot of essential operations, without diving into too much details about the impact of the suboptimality. Good PR I guess…</div><br/></div></div><div id="38667412" class="c"><input type="checkbox" id="c-38667412" checked=""/><div class="controls bullet"><span class="by">zeroCalories</span><span>|</span><a href="#38670956">prev</a><span>|</span><a href="#38667332">next</a><span>|</span><label class="collapse" for="c-38667412">[-]</label><label class="expand" for="c-38667412">[5 more]</label></div><br/><div class="children"><div class="content">Looks nice. That said, if you want to reduce mallocs and encourage data locality, maybe you could try a more traditional tree implementation using a pool of nodes similar to thread pools. I&#x27;ve found that most of my problems related to those were solved by such techniques.</div><br/><div id="38667576" class="c"><input type="checkbox" id="c-38667576" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#38667412">parent</a><span>|</span><a href="#38667332">next</a><span>|</span><label class="collapse" for="c-38667576">[-]</label><label class="expand" for="c-38667576">[4 more]</label></div><br/><div class="children"><div class="content">A custom pool for objects is often a good idea. Pre-allocate “enough” memory and dish them out as appropriate, releasing back to the pool when the reference count goes to zero.<p>You can also use the pool to bound the maximum size you’re able to allow.</div><br/><div id="38670146" class="c"><input type="checkbox" id="c-38670146" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#38667412">root</a><span>|</span><a href="#38667576">parent</a><span>|</span><a href="#38667938">next</a><span>|</span><label class="collapse" for="c-38670146">[-]</label><label class="expand" for="c-38670146">[1 more]</label></div><br/><div class="children"><div class="content">Man, if only something already did this. We could call it Oak... Or maybe Java? :)</div><br/></div></div><div id="38667938" class="c"><input type="checkbox" id="c-38667938" checked=""/><div class="controls bullet"><span class="by">mathiasgredal</span><span>|</span><a href="#38667412">root</a><span>|</span><a href="#38667576">parent</a><span>|</span><a href="#38670146">prev</a><span>|</span><a href="#38667332">next</a><span>|</span><label class="collapse" for="c-38667938">[-]</label><label class="expand" for="c-38667938">[2 more]</label></div><br/><div class="children"><div class="content">Why is this better than an arena style allocator?</div><br/><div id="38670070" class="c"><input type="checkbox" id="c-38670070" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38667412">root</a><span>|</span><a href="#38667938">parent</a><span>|</span><a href="#38667332">next</a><span>|</span><label class="collapse" for="c-38670070">[-]</label><label class="expand" for="c-38670070">[1 more]</label></div><br/><div class="children"><div class="content">It <i>is</i> an arena-style allocator.<p>At least, if someone asked me to explain what an arena allocator is&#x2F;does, I would say essentially what they wrote -- likely without the &quot;disappears automatically once all references disappear&quot; part, which is IMHO just a clever nice-to-have.</div><br/></div></div></div></div></div></div></div></div><div id="38667332" class="c"><input type="checkbox" id="c-38667332" checked=""/><div class="controls bullet"><span class="by">icsa</span><span>|</span><a href="#38667412">prev</a><span>|</span><a href="#38667084">next</a><span>|</span><label class="collapse" for="c-38667332">[-]</label><label class="expand" for="c-38667332">[1 more]</label></div><br/><div class="children"><div class="content">See Aaron Hsu&#x27;s excellent descriptions (using APL):<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hzPd3umu78g" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hzPd3umu78g</a>
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=X5_5MtOYNos" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=X5_5MtOYNos</a></div><br/></div></div><div id="38667084" class="c"><input type="checkbox" id="c-38667084" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#38667332">prev</a><span>|</span><a href="#38670957">next</a><span>|</span><label class="collapse" for="c-38667084">[-]</label><label class="expand" for="c-38667084">[2 more]</label></div><br/><div class="children"><div class="content">One change I&#x27;d make to this structure would be to pack all the children of a node together. That way you could find out the list of all children of a node with a binary search, and they&#x27;d have some cache-friendly properties.<p>Inserting a child would need a memmove in O(N), but if edits are rare after an initial build it wouldn&#x27;t be that bad.</div><br/><div id="38668629" class="c"><input type="checkbox" id="c-38668629" checked=""/><div class="controls bullet"><span class="by">snovv_crash</span><span>|</span><a href="#38667084">parent</a><span>|</span><a href="#38670957">next</a><span>|</span><label class="collapse" for="c-38668629">[-]</label><label class="expand" for="c-38668629">[1 more]</label></div><br/><div class="children"><div class="content">You could also have extra space allocated for where extra data should go. By aggressively rebalancing you should only need to do a full reallocation when the tree is actually getting pretty full.</div><br/></div></div></div></div><div id="38670957" class="c"><input type="checkbox" id="c-38670957" checked=""/><div class="controls bullet"><span class="by">irreducible</span><span>|</span><a href="#38667084">prev</a><span>|</span><a href="#38669735">next</a><span>|</span><label class="collapse" for="c-38670957">[-]</label><label class="expand" for="c-38670957">[2 more]</label></div><br/><div class="children"><div class="content">For anyone interested, I sketched out a basic implementation of this in Rust.
<a href="https:&#x2F;&#x2F;github.com&#x2F;irreducible-io&#x2F;apter-tree">https:&#x2F;&#x2F;github.com&#x2F;irreducible-io&#x2F;apter-tree</a></div><br/><div id="38670992" class="c"><input type="checkbox" id="c-38670992" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#38670957">parent</a><span>|</span><a href="#38669735">next</a><span>|</span><label class="collapse" for="c-38670992">[-]</label><label class="expand" for="c-38670992">[1 more]</label></div><br/><div class="children"><div class="content">Petgraph uses a similar design (two vecs) for storing graphs <a href="https:&#x2F;&#x2F;docs.rs&#x2F;petgraph&#x2F;latest&#x2F;petgraph&#x2F;graph&#x2F;struct.Graph.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;petgraph&#x2F;latest&#x2F;petgraph&#x2F;graph&#x2F;struct.Graph....</a></div><br/></div></div></div></div><div id="38669735" class="c"><input type="checkbox" id="c-38669735" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#38670957">prev</a><span>|</span><a href="#38667253">next</a><span>|</span><label class="collapse" for="c-38669735">[-]</label><label class="expand" for="c-38669735">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people commenting about &quot;an index into an array is also a pointer&quot;, I thought people commonly referred to integer indexes of this kind as handles, or index-handles? (like in this article [1]).<p>This way of representing trees reminds me of two classic data structures: heaps [2] and disjoint-sets [3].<p>--<p>1: <a href="https:&#x2F;&#x2F;floooh.github.io&#x2F;2018&#x2F;06&#x2F;17&#x2F;handles-vs-pointers.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;floooh.github.io&#x2F;2018&#x2F;06&#x2F;17&#x2F;handles-vs-pointers.html</a><p>2: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Heap_(data_structure)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Heap_(data_structure)</a><p>3: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Disjoint-set_data_structure" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Disjoint-set_data_structure</a></div><br/></div></div><div id="38667253" class="c"><input type="checkbox" id="c-38667253" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#38669735">prev</a><span>|</span><a href="#38667129">next</a><span>|</span><label class="collapse" for="c-38667253">[-]</label><label class="expand" for="c-38667253">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Pointers are annoying anyway.<p>But the parent indices <i>are</i> pointers. Not in the index-into-all-memory sense but in the offset-into-array sense. They’re smaller, type safe, inherently well packed, and can’t point outside the instance of the data structure in question if they’re bounds checked. But I would still think of them as a sort of pointer.<p>So this is just a tree, with only parent pointer, in SOA form, and iterable (in no particular order). Which is maybe useful if you want that specific data structure.<p>And it’s utterly useless if you want, say, a tree with children and need better-than-O(n) access to children. Which you probably do need. Of course, you can add child pointers in SOA form if you want.<p>(SOA is Struct Of Arrays)</div><br/><div id="38667298" class="c"><input type="checkbox" id="c-38667298" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#38667253">parent</a><span>|</span><a href="#38667300">next</a><span>|</span><label class="collapse" for="c-38667298">[-]</label><label class="expand" for="c-38667298">[7 more]</label></div><br/><div class="children"><div class="content">I think you could achieve something close to (I haven&#x27;t sat down and thought about it) O(logN) with sorted arrays? You&#x27;d have the downside of inserting things in the middle, but I think that would be lost in cache efficiency elsewhere for many use cases.</div><br/><div id="38667518" class="c"><input type="checkbox" id="c-38667518" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#38667253">root</a><span>|</span><a href="#38667298">parent</a><span>|</span><a href="#38667300">next</a><span>|</span><label class="collapse" for="c-38667518">[-]</label><label class="expand" for="c-38667518">[6 more]</label></div><br/><div class="children"><div class="content">A sorted array to less inefficiently iterate children of a node?  This is getting ridiculous.<p>The “no pointers” thing is cache efficient for three reasons:<p>1. Indices can be smaller than pointers.<p>2. The data is packed in memory. This means that cachelines will be full of relevant data, and adjacent cache lines (which are a bit faster than faraway lines) get used.<p>3. SOA form is more or less cache efficient depending on what you’re doing with it.<p>And that’s <i>it</i>.<p>If you need child pointers, use child pointers. If you want a cache-efficient tree, use a cache-efficient tree, e.g. a B-tree or an appropriate variant.</div><br/><div id="38667857" class="c"><input type="checkbox" id="c-38667857" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#38667253">root</a><span>|</span><a href="#38667518">parent</a><span>|</span><a href="#38667300">next</a><span>|</span><label class="collapse" for="c-38667857">[-]</label><label class="expand" for="c-38667857">[5 more]</label></div><br/><div class="children"><div class="content">Sorted arrays can be navigated like a tree. For sufficiently randomised data, the middle element is approximately the middle of your data. You can use binary search. You can implement range iteration very efficiently. It&#x27;s not wholly ridiculous.</div><br/><div id="38667945" class="c"><input type="checkbox" id="c-38667945" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#38667253">root</a><span>|</span><a href="#38667857">parent</a><span>|</span><a href="#38667300">next</a><span>|</span><label class="collapse" for="c-38667945">[-]</label><label class="expand" for="c-38667945">[4 more]</label></div><br/><div class="children"><div class="content">Binary search into a sorted array is slow.  Intro algorithms classes might count <i>operations</i>, and you discover that about log_2(n) operations are needed, which is optimal in a certain sense.<p>But those operations are horrible operations. Until you are log_2(cache line size &#x2F; element size) steps from the leaves, you are hitting a different cache line each time, and you’re doing a branch such that the next cache line you want depends on the branch result.<p>So this is like log_2(n)-3 serial (cache miss, compare, branch, compute address operations). (Assume 8-byte entries — it’s much worse with bigger entries.) This not even close to optimal.<p>You will find that, for reasonably large data sets (maybe a few hundred elements or more?), any cache-optimized searchable data structure will beat binary search by a large factor. And for small arrays (or the last stage of an optimized large structure), you want a vectorized linear search.<p>Binary search is mostly nice because sorted arrays are elegant and binary search can be implemented in very little code.  And it’s easy to explain and analyze.</div><br/><div id="38669485" class="c"><input type="checkbox" id="c-38669485" checked=""/><div class="controls bullet"><span class="by">senderista</span><span>|</span><a href="#38667253">root</a><span>|</span><a href="#38667945">parent</a><span>|</span><a href="#38669571">next</a><span>|</span><label class="collapse" for="c-38669485">[-]</label><label class="expand" for="c-38669485">[1 more]</label></div><br/><div class="children"><div class="content">Eytzinger (&quot;heap&quot;) layout packs the pivots as efficiently as possible, so cache misses are confined to the lower levels of the tree. But ordered iteration is slower, and of course it only works for static data. I agree that for dynamic structures I have yet to find anything more cache-efficient than a B-tree.</div><br/></div></div><div id="38669571" class="c"><input type="checkbox" id="c-38669571" checked=""/><div class="controls bullet"><span class="by">GrumpySloth</span><span>|</span><a href="#38667253">root</a><span>|</span><a href="#38667945">parent</a><span>|</span><a href="#38669485">prev</a><span>|</span><a href="#38667300">next</a><span>|</span><label class="collapse" for="c-38669571">[-]</label><label class="expand" for="c-38669571">[2 more]</label></div><br/><div class="children"><div class="content">Measurements suggest that binary search is at least competitive with linear search and is often the winner, so it’s a reasonable default[1].<p>But naive binary search can also be improved upon by dividing the searched space into 3 subranges instead of 2[2].<p>[1]: &lt;<a href="https:&#x2F;&#x2F;www.pvk.ca&#x2F;Blog&#x2F;2012&#x2F;07&#x2F;03&#x2F;binary-search-star-eliminates-star-branch-mispredictions&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pvk.ca&#x2F;Blog&#x2F;2012&#x2F;07&#x2F;03&#x2F;binary-search-star-elimin...</a>&gt;<p>[2]: &lt;<a href="https:&#x2F;&#x2F;www.pvk.ca&#x2F;Blog&#x2F;2012&#x2F;07&#x2F;30&#x2F;binary-search-is-a-pathological-case-for-caches&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pvk.ca&#x2F;Blog&#x2F;2012&#x2F;07&#x2F;30&#x2F;binary-search-is-a-pathol...</a>&gt;</div><br/><div id="38670179" class="c"><input type="checkbox" id="c-38670179" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#38667253">root</a><span>|</span><a href="#38669571">parent</a><span>|</span><a href="#38667300">next</a><span>|</span><label class="collapse" for="c-38670179">[-]</label><label class="expand" for="c-38670179">[1 more]</label></div><br/><div class="children"><div class="content">To clarify, I’m not saying that binary search is a bad way to search a sorted array. I’m saying that, if you have a bunch of data, you intend to preprocess that data and then search it repeatedly, that sorting it and binary searching is not a great solution.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38667129" class="c"><input type="checkbox" id="c-38667129" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#38667253">prev</a><span>|</span><a href="#38669681">next</a><span>|</span><label class="collapse" for="c-38667129">[-]</label><label class="expand" for="c-38667129">[1 more]</label></div><br/><div class="children"><div class="content">I feel like atree in TFA is just giving a name to something I do all the time when it makes sense to so. For example, I used something similar recently when building a ECS entity tree for a game engine.</div><br/></div></div><div id="38669681" class="c"><input type="checkbox" id="c-38669681" checked=""/><div class="controls bullet"><span class="by">mamcx</span><span>|</span><a href="#38667129">prev</a><span>|</span><a href="#38669262">next</a><span>|</span><label class="collapse" for="c-38669681">[-]</label><label class="expand" for="c-38669681">[1 more]</label></div><br/><div class="children"><div class="content">Oh, cool.<p>I made my own attempt at the same kind of idea at <a href="https:&#x2F;&#x2F;elmalabarista.com&#x2F;blog&#x2F;2022-flat-tree&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elmalabarista.com&#x2F;blog&#x2F;2022-flat-tree&#x2F;</a>.<p>Is pretty simple actually. What I have observed (and my tree exploit) is that most tree are &quot;too much&quot; and I only have cared by pre-order tree and &quot;sequentially&quot; scan is the major op.<p>So, the major takeaway is that if your case is simple, Go! Go! Vec!</div><br/></div></div><div id="38669262" class="c"><input type="checkbox" id="c-38669262" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#38669681">prev</a><span>|</span><a href="#38667034">next</a><span>|</span><label class="collapse" for="c-38669262">[-]</label><label class="expand" for="c-38669262">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious about the performance of separating the data from the pointers. On one hand, homogenous arrays pack better. On the other, the traditional version that packages the data and child pointers next to each other might have better cache locality.</div><br/></div></div><div id="38667034" class="c"><input type="checkbox" id="c-38667034" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38669262">prev</a><span>|</span><a href="#38667274">next</a><span>|</span><label class="collapse" for="c-38667034">[-]</label><label class="expand" for="c-38667034">[10 more]</label></div><br/><div class="children"><div class="content">A pointer is simply an index into an array which is RAM.</div><br/><div id="38669545" class="c"><input type="checkbox" id="c-38669545" checked=""/><div class="controls bullet"><span class="by">senderista</span><span>|</span><a href="#38667034">parent</a><span>|</span><a href="#38667788">next</a><span>|</span><label class="collapse" for="c-38669545">[-]</label><label class="expand" for="c-38669545">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s all just names, all the way down.<p><a href="https:&#x2F;&#x2F;www.dropbox.com&#x2F;s&#x2F;mmi46lxk8ipoci0&#x2F;Principles%20of%20Computer%20System%20Design.pdf?dl=0" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.dropbox.com&#x2F;s&#x2F;mmi46lxk8ipoci0&#x2F;Principles%20of%20...</a></div><br/></div></div><div id="38667788" class="c"><input type="checkbox" id="c-38667788" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#38667034">parent</a><span>|</span><a href="#38669545">prev</a><span>|</span><a href="#38667539">next</a><span>|</span><label class="collapse" for="c-38667788">[-]</label><label class="expand" for="c-38667788">[3 more]</label></div><br/><div class="children"><div class="content">But they point into <i>your</i> RAM, which means you can&#x27;t store them on disk or pass them over the network.</div><br/><div id="38668433" class="c"><input type="checkbox" id="c-38668433" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#38667034">root</a><span>|</span><a href="#38667788">parent</a><span>|</span><a href="#38667911">next</a><span>|</span><label class="collapse" for="c-38668433">[-]</label><label class="expand" for="c-38668433">[1 more]</label></div><br/><div class="children"><div class="content">SoA form also lets you trivially store additional data at every node, eg. if an algorithm needs a flag for each node, you just alloc an array for it.</div><br/></div></div><div id="38667911" class="c"><input type="checkbox" id="c-38667911" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38667034">root</a><span>|</span><a href="#38667788">parent</a><span>|</span><a href="#38668433">prev</a><span>|</span><a href="#38667539">next</a><span>|</span><label class="collapse" for="c-38667911">[-]</label><label class="expand" for="c-38667911">[1 more]</label></div><br/><div class="children"><div class="content">A minor but legitimate benefit.</div><br/></div></div></div></div><div id="38667539" class="c"><input type="checkbox" id="c-38667539" checked=""/><div class="controls bullet"><span class="by">zappb</span><span>|</span><a href="#38667034">parent</a><span>|</span><a href="#38667788">prev</a><span>|</span><a href="#38667207">next</a><span>|</span><label class="collapse" for="c-38667539">[-]</label><label class="expand" for="c-38667539">[1 more]</label></div><br/><div class="children"><div class="content">Pointers are a bit more abstract than that. Since each program has a virtual address space, and said address space is made up of memory pages, even raw pointers need to be translated to the physical address via TLBs. In that sense, indices into arrays are more like pointers than the other way around.</div><br/></div></div><div id="38667207" class="c"><input type="checkbox" id="c-38667207" checked=""/><div class="controls bullet"><span class="by">lelandbatey</span><span>|</span><a href="#38667034">parent</a><span>|</span><a href="#38667539">prev</a><span>|</span><a href="#38667274">next</a><span>|</span><label class="collapse" for="c-38667207">[-]</label><label class="expand" for="c-38667207">[4 more]</label></div><br/><div class="children"><div class="content">Conceptually, yes. There are a lot of finer points to this concept though. One of the points most relevanthere is that accessing &quot;RAM&quot; is not _actually_ an O(1) operation, due to CPU caches which can speed up sequential access of &quot;close together&quot; data. Thus, if you manually ensure that data is &quot;close together&quot; (by putting it all in an array together), you can massively speed up your program in the real world because now all your keys&#x2F;data can be squeezed into the cache at once.</div><br/><div id="38667383" class="c"><input type="checkbox" id="c-38667383" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38667034">root</a><span>|</span><a href="#38667207">parent</a><span>|</span><a href="#38667274">next</a><span>|</span><label class="collapse" for="c-38667383">[-]</label><label class="expand" for="c-38667383">[3 more]</label></div><br/><div class="children"><div class="content">You can allocate your data the same way, especially using custom allocators in C++.  And every reference requires some arithmetic too, if you&#x27;re worrying about that.<p>But my point is that storing them in another array doesn&#x27;t buy you a lot if you allow deallocations (you can then still have a use-after-free, or even read the wrong object) while if you don&#x27;t deallocate you might as well just use pointers.<p>Just trying to understand the benefit of going to all this work.  I can see the point in old FORTRAN code before FORTRAN 90</div><br/><div id="38667514" class="c"><input type="checkbox" id="c-38667514" checked=""/><div class="controls bullet"><span class="by">lelandbatey</span><span>|</span><a href="#38667034">root</a><span>|</span><a href="#38667383">parent</a><span>|</span><a href="#38667274">next</a><span>|</span><label class="collapse" for="c-38667514">[-]</label><label class="expand" for="c-38667514">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s mostly just an experiment, example, proof-of-concept or other &quot;toy&quot; implementation demonstrating&#x2F;exploring the idea.</div><br/><div id="38667956" class="c"><input type="checkbox" id="c-38667956" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38667034">root</a><span>|</span><a href="#38667514">parent</a><span>|</span><a href="#38667274">next</a><span>|</span><label class="collapse" for="c-38667956">[-]</label><label class="expand" for="c-38667956">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, no judgement on that.<p>But I’ve worked with indexed classes (mixin class) to avoid pointers in the past and have never found them worth the effort.  Since someone else is mentioning it here on HN I’m asking if there is an advantage over pointers that I don’t realise — if so I might be glad to take advantage of it myself.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38667274" class="c"><input type="checkbox" id="c-38667274" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#38667034">prev</a><span>|</span><a href="#38667615">next</a><span>|</span><label class="collapse" for="c-38667274">[-]</label><label class="expand" for="c-38667274">[4 more]</label></div><br/><div class="children"><div class="content">Interesting the casual references to languages K, J and Q. I have never heard of them, and they are hard to google. Anyone know?</div><br/><div id="38667352" class="c"><input type="checkbox" id="c-38667352" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#38667274">parent</a><span>|</span><a href="#38667363">next</a><span>|</span><label class="collapse" for="c-38667352">[-]</label><label class="expand" for="c-38667352">[1 more]</label></div><br/><div class="children"><div class="content">Oh boy, they are weird. They are all related to APL. Extremely terse, dense languges. Got some traction in actuarial and financial circles.<p>Arthur Whitney is the origin of much of that family of languages. Bryan Cantrill’s interview with him is good: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;1515964.1531242" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;1515964.1531242</a></div><br/></div></div><div id="38667363" class="c"><input type="checkbox" id="c-38667363" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38667274">parent</a><span>|</span><a href="#38667352">prev</a><span>|</span><a href="#38667983">next</a><span>|</span><label class="collapse" for="c-38667363">[-]</label><label class="expand" for="c-38667363">[1 more]</label></div><br/><div class="children"><div class="content">K and Q are the languages behind KDB.<p>K is the lower-level language and is a variant of APL. Q is the higher-level one, bringing in elements of SQL.<p>J is another APL-like programming language, unrelated to KDB, by the actual creator of APL.<p>All are easy to google by adding &quot;programming language&quot; to your query, and each has a wikipedia page.</div><br/></div></div><div id="38667983" class="c"><input type="checkbox" id="c-38667983" checked=""/><div class="controls bullet"><span class="by">laszlokorte</span><span>|</span><a href="#38667274">parent</a><span>|</span><a href="#38667363">prev</a><span>|</span><a href="#38667615">next</a><span>|</span><label class="collapse" for="c-38667983">[-]</label><label class="expand" for="c-38667983">[1 more]</label></div><br/><div class="children"><div class="content">They are array languages. If you have never heart of array languages check out the code_report youtube channel.</div><br/></div></div></div></div><div id="38667615" class="c"><input type="checkbox" id="c-38667615" checked=""/><div class="controls bullet"><span class="by">readthenotes1</span><span>|</span><a href="#38667274">prev</a><span>|</span><a href="#38667166">next</a><span>|</span><label class="collapse" for="c-38667615">[-]</label><label class="expand" for="c-38667615">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of data structures used to represent data on the old tape devices</div><br/></div></div><div id="38667166" class="c"><input type="checkbox" id="c-38667166" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38667615">prev</a><span>|</span><a href="#38667745">next</a><span>|</span><label class="collapse" for="c-38667166">[-]</label><label class="expand" for="c-38667166">[1 more]</label></div><br/><div class="children"><div class="content">I was about to comment that this reminds me of Aaron Hsu’s Dyalog compiler, but it’s mentioned right there in the README as one of the inspirations.<p>IMHO, compilers are about an order of magnitude slower than they could be, and this type of tree representation could be one key element for fixing that.<p>One interesting approach would be to combine egg[1] with this style of vectorised trees for efficient optimisation passes.<p>[1] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2004.03082.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2004.03082.pdf</a></div><br/></div></div><div id="38667745" class="c"><input type="checkbox" id="c-38667745" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#38667166">prev</a><span>|</span><a href="#38666895">next</a><span>|</span><label class="collapse" for="c-38667745">[-]</label><label class="expand" for="c-38667745">[1 more]</label></div><br/><div class="children"><div class="content">Wow this is pretty similar to how I used to store hierarchical data back in my qbasic days to solve minimax problems. Didn&#x27;t know it was called steven or whatever.</div><br/></div></div><div id="38666901" class="c"><input type="checkbox" id="c-38666901" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#38666895">prev</a><span>|</span><a href="#38667182">next</a><span>|</span><label class="collapse" for="c-38666901">[-]</label><label class="expand" for="c-38666901">[5 more]</label></div><br/><div class="children"><div class="content">It might be of interest to anyone that there&#x27;s an implicit binary tree data structure dubbed Eytzinger&#x27;s tree&#x2F;method that only requires a single vector.<p><a href="https:&#x2F;&#x2F;opendatastructures.org&#x2F;ods-cpp&#x2F;10_1_Implicit_Binary_Tree.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;opendatastructures.org&#x2F;ods-cpp&#x2F;10_1_Implicit_Binary_...</a><p>I dare say that no tree data structure beats Eytzinger&#x27;s method in cache locality.</div><br/><div id="38667302" class="c"><input type="checkbox" id="c-38667302" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#38666901">parent</a><span>|</span><a href="#38669880">next</a><span>|</span><label class="collapse" for="c-38667302">[-]</label><label class="expand" for="c-38667302">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I dare say that no tree data structure beats Eytzinger&#x27;s method in cache locality<p>Cache locality is good toward the leaves and bad everywhere else.  This is why binary search on a sorted array is actually quite slow.<p>ORC in Linux, for example, was first prototyped as a sorted array of little structures. It got <i>much</i> faster by adding an auxiliary index giving O(1) access to a credible starting point for a search.</div><br/><div id="38668749" class="c"><input type="checkbox" id="c-38668749" checked=""/><div class="controls bullet"><span class="by">funcDropShadow</span><span>|</span><a href="#38666901">root</a><span>|</span><a href="#38667302">parent</a><span>|</span><a href="#38669880">next</a><span>|</span><label class="collapse" for="c-38668749">[-]</label><label class="expand" for="c-38668749">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Cache locality is good toward the leaves and bad everywhere else.<p>1. That depends on the operation performed. I&#x27;d say cache-locality is near perfect for depth-traversal.<p>2. Whether the effective performance of the cache is good or bad depends on the alternative. If the alternative is adding two 64 bit pointer to every 32 bit value in the tree node. And each of those node may be spread through out the heap. Then this representation starts to look quite good.</div><br/></div></div></div></div><div id="38669880" class="c"><input type="checkbox" id="c-38669880" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#38666901">parent</a><span>|</span><a href="#38667302">prev</a><span>|</span><a href="#38667197">next</a><span>|</span><label class="collapse" for="c-38669880">[-]</label><label class="expand" for="c-38669880">[1 more]</label></div><br/><div class="children"><div class="content">Van Emde Boas trees are asymptotically cache optimal. In practice when cache sizes are known they may be slower than other tree types however.</div><br/></div></div><div id="38667197" class="c"><input type="checkbox" id="c-38667197" checked=""/><div class="controls bullet"><span class="by">ulatich</span><span>|</span><a href="#38666901">parent</a><span>|</span><a href="#38669880">prev</a><span>|</span><a href="#38667182">next</a><span>|</span><label class="collapse" for="c-38667197">[-]</label><label class="expand" for="c-38667197">[1 more]</label></div><br/><div class="children"><div class="content">There is also the “Binary Ostensibly-Implicit Tree”. Like Eytzinger‘s tree&#x2F;method but without the need to pad memory. Generalises to n-ary trees too.</div><br/></div></div></div></div></div></div></div></div></div></body></html>