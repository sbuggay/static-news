<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687597258424" as="style"/><link rel="stylesheet" href="styles.css?v=1687597258424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://johnnysswlab.com/make-your-programs-run-faster-by-better-using-the-data-cache/">Make your programs run faster by better using the data cache (2020)</a> <span class="domain">(<a href="https://johnnysswlab.com">johnnysswlab.com</a>)</span></div><div class="subtext"><span>eatonphil</span> | <span>42 comments</span></div><br/><div><div id="36455622" class="c"><input type="checkbox" id="c-36455622" checked=""/><div class="controls bullet"><span class="by">jacknews</span><span>|</span><a href="#36454943">next</a><span>|</span><label class="collapse" for="c-36455622">[-]</label><label class="expand" for="c-36455622">[11 more]</label></div><br/><div class="children"><div class="content">It seems to me there is scope for a language feature of &#x27;managed memory&#x27; where you declare the data you need and how it is to be accessed (or access can be determined from the program), and let the language&#x2F;compiler figure out how to organize it for safety and performance.<p>For example if you declare an array of structures, the compiler&#x2F;language should be able to turn that into a structure of arrays under the hood if that is the way the data is accessed.<p>Not sure how that could work in practice, I guess you&#x27;d start with hints, but it seems like something to research. Indeed I&#x27;m sure there&#x27;s already some research in this area.</div><br/><div id="36456181" class="c"><input type="checkbox" id="c-36456181" checked=""/><div class="controls bullet"><span class="by">jakeinspace</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36456348">next</a><span>|</span><label class="collapse" for="c-36456181">[-]</label><label class="expand" for="c-36456181">[2 more]</label></div><br/><div class="children"><div class="content">I’m working on a masters thesis doing essentially this, for the problem of prefetching. There are a lot of existing papers demonstrating techniques for smarter prefetching for non- sequential data structures like trees and graphs. That can be done with some success purely at the hardware level, but having language- level semantic information helps a lot for dealing with complex data structures. What I’m working on is a cache controller modification to allow the running program or OS to tell the cache controller how best to prefetch specific pieces of data.</div><br/><div id="36456452" class="c"><input type="checkbox" id="c-36456452" checked=""/><div class="controls bullet"><span class="by">jacknews</span><span>|</span><a href="#36455622">root</a><span>|</span><a href="#36456181">parent</a><span>|</span><a href="#36456348">next</a><span>|</span><label class="collapse" for="c-36456452">[-]</label><label class="expand" for="c-36456452">[1 more]</label></div><br/><div class="children"><div class="content">&quot;having language- level semantic information helps a lot for dealing with complex data structures.&quot;<p>Yes that&#x27;s what I&#x27;m thinking - much of the current stuff seems to be trying to guess what the code is doing from a low level (eg branch prediction) whereas the language itself could tell.</div><br/></div></div></div></div><div id="36456348" class="c"><input type="checkbox" id="c-36456348" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36456181">prev</a><span>|</span><a href="#36455775">next</a><span>|</span><label class="collapse" for="c-36456348">[-]</label><label class="expand" for="c-36456348">[1 more]</label></div><br/><div class="children"><div class="content">See SHAPES[1] for a method of selecting data layout without sacrificing the abstraction programmers are typically used to having in OOP.<p>The idea is that a &quot;layout&quot; is decoupled from the object that stores the data. Layouts are attached to a memory pool which is used to allocate objects. The same object representation can have its data laid out in multiple ways depending on which pool allocates it.<p>[1]<a href="https:&#x2F;&#x2F;www.doc.ic.ac.uk&#x2F;%7Escd&#x2F;ShapesOnwards.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.doc.ic.ac.uk&#x2F;%7Escd&#x2F;ShapesOnwards.pdf</a></div><br/></div></div><div id="36455775" class="c"><input type="checkbox" id="c-36455775" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36456348">prev</a><span>|</span><a href="#36456129">next</a><span>|</span><label class="collapse" for="c-36455775">[-]</label><label class="expand" for="c-36455775">[1 more]</label></div><br/><div class="children"><div class="content">I frequently having a hard time deciding which transpose to use when there are multiple consumers that each want a different shape</div><br/></div></div><div id="36456129" class="c"><input type="checkbox" id="c-36456129" checked=""/><div class="controls bullet"><span class="by">01100011</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36455775">prev</a><span>|</span><a href="#36456281">next</a><span>|</span><label class="collapse" for="c-36456129">[-]</label><label class="expand" for="c-36456129">[1 more]</label></div><br/><div class="children"><div class="content">Legion is also doing something like that: <a href="https:&#x2F;&#x2F;legion.stanford.edu&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;legion.stanford.edu&#x2F;</a></div><br/></div></div><div id="36456281" class="c"><input type="checkbox" id="c-36456281" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36456129">prev</a><span>|</span><a href="#36455788">next</a><span>|</span><label class="collapse" for="c-36456281">[-]</label><label class="expand" for="c-36456281">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve previously written about the idea of serialised access patterns. If we could somehow represent all the patterns of the data we&#x27;re accessing, we could optimise layout.</div><br/></div></div><div id="36455788" class="c"><input type="checkbox" id="c-36455788" checked=""/><div class="controls bullet"><span class="by">ttymck</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36456281">prev</a><span>|</span><a href="#36456172">next</a><span>|</span><label class="collapse" for="c-36455788">[-]</label><label class="expand" for="c-36455788">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a database</div><br/></div></div><div id="36456172" class="c"><input type="checkbox" id="c-36456172" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36455788">prev</a><span>|</span><a href="#36456001">next</a><span>|</span><label class="collapse" for="c-36456172">[-]</label><label class="expand" for="c-36456172">[1 more]</label></div><br/><div class="children"><div class="content">Halide is pretty specialized and only somewhat related to this, but I really like the concept: <a href="https:&#x2F;&#x2F;halide-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;halide-lang.org&#x2F;</a><p>A tldr is: define your logical algorithm and its implementation separately, so you can freely tweak the implementation to optimize it without risking correctness.</div><br/></div></div><div id="36456001" class="c"><input type="checkbox" id="c-36456001" checked=""/><div class="controls bullet"><span class="by">jzwinck</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36456172">prev</a><span>|</span><a href="#36456113">next</a><span>|</span><label class="collapse" for="c-36456001">[-]</label><label class="expand" for="c-36456001">[1 more]</label></div><br/><div class="children"><div class="content">The Jai programming language has some support for that.</div><br/></div></div><div id="36456113" class="c"><input type="checkbox" id="c-36456113" checked=""/><div class="controls bullet"><span class="by">mati365</span><span>|</span><a href="#36455622">parent</a><span>|</span><a href="#36456001">prev</a><span>|</span><a href="#36454943">next</a><span>|</span><label class="collapse" for="c-36456113">[-]</label><label class="expand" for="c-36456113">[1 more]</label></div><br/><div class="children"><div class="content">OpenMP is doing something like that</div><br/></div></div></div></div><div id="36454943" class="c"><input type="checkbox" id="c-36454943" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36455622">prev</a><span>|</span><a href="#36456035">next</a><span>|</span><label class="collapse" for="c-36454943">[-]</label><label class="expand" for="c-36454943">[18 more]</label></div><br/><div class="children"><div class="content">Recently I worked on a simulation analysis which taught me several things:<p>- To get the most out of Python, you really need efficient libraries like Numpy. I started off my project in pure Python and some Pandas. But soon I realized it was painfully slow and looked for better solutions.<p>- Polars looked like a good Pandas alternative, but some googling revealed that it could be slower than Numpy. Although it&#x27;s easy to work with dataframes (e.g., you can select a column by calling its name), I converted all my code to use Numpy and suddenly saw huge speed boost. But that wasn&#x27;t the end of it. I was now in a rabbit hole...<p>- Vectorization helped a lot with speed as well. I learnt that using the right tool (in this case, Numpy) guides you to do better and vectorize operations, whereas Pandas didn&#x27;t enforce that technique on me. Despite the initial hurdle, I realized that vectorization made my code much more readable and easier to follow.<p>- I then parallelized my code to utilized all 10 cores of the M1 Pro chip. Seeing that CPU graph get full was just pleasing. For this, I used Python&#x27;s ProcessPoolExecutor, which is better than ThreadPoolExecutor.<p>- At this point, my simulations had gone from taking several hours to a couple minutes! Pretty impressive, but then I noticed that increasing the resolution of some variables resulted in RAM issues. I have 32GB of RAM and working with huge matrices was just not feasible. I remembered that the OS community has been using quantization techniques to reduce the memory footprint of LLMs. The way they work often involves going from np.float32 to np.float16. To my surprise, doing this solved my RAM issues without much effect on the accuracy of the results.<p>- Looking for further improvements, I discovered Dask and used it instead of ProcessPoolExecutor (although, I still used `schedulor=&quot;processes&quot;` in Dask). Unlike ProcessPoolExecutor, Dask didn&#x27;t utilize all my CPU cores all the time, but somehow I found it more capable of handling parallel computation.<p>- But increasing the resolution of parameters even further would still cause problems. Specifically, I noticed that my Python code would halt. Doing CTRL-Z would stop the program, but the RAM wouldn&#x27;t get released. In this case, I had to manually `pkill -f python` to throw away all the Python objects that were taking up RAM space.<p>- This is where I discovered garbage collection. Using `import gc`, I was able to `del &lt;obj&gt;` at key parts of my code and immediately do `gc.collect()` to collect garbage. This was the first time I ever did this and I was pleased to see my program run again w&#x2F;o RAM issues.<p>- I then optimized some search algorithms in my code which further sped up the program while also reducing the RAM usage.<p>- I converted all Numpy arrays to ds.array for further improvements, but some functionalities were not immediately available and I went back to Numpy.<p>- Looking for further improvements, I thought about running my Python code on GPU. I tried `import cupy as np` but got to problems that I couldn&#x27;t solve.<p>- So I tried converting all numpy arrays to Pytorch tensors. Pytorch is available on M1 Mac so I thought why not? Unfor, I got memory limits errors. Reducing the resolution of parameters fixed that, but then I got a mysterious error for which I couldn&#x27;t find any help:<p><pre><code>    -[_MTLCommandBuffer addCompletedHandler:]:871: failed assertion `Completed handler provided after commit call&#x27;

</code></pre>
If you know what this means, please let me know!<p>This was an educational journey and I learnt much. I think projects like this are the best way to learn new stuff.</div><br/><div id="36455617" class="c"><input type="checkbox" id="c-36455617" checked=""/><div class="controls bullet"><span class="by">sigg3</span><span>|</span><a href="#36454943">parent</a><span>|</span><a href="#36455513">next</a><span>|</span><label class="collapse" for="c-36455617">[-]</label><label class="expand" for="c-36455617">[4 more]</label></div><br/><div class="children"><div class="content">You ignored an important lesson IMO.<p>Use the right tool for the job.<p>Your entire journey here is battling with Python and not the problem space. Your improvements are solely measured by how your code leaves Python problem solving space, so you end up writing what&#x27;s probably unpythonic and unmaintainable Python.<p>Why?<p>Rewrite in Go, Rust or C++ or whatever.<p>If you need to go faster than Python, don&#x27;t use Python. Python is great for everything else. Its overhead and sluggish execution are consequences of its greatest strength.</div><br/><div id="36456481" class="c"><input type="checkbox" id="c-36456481" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455617">parent</a><span>|</span><a href="#36456487">next</a><span>|</span><label class="collapse" for="c-36456481">[-]</label><label class="expand" for="c-36456481">[1 more]</label></div><br/><div class="children"><div class="content">Exactly my thought. Whenever I see wild optimization goose chases it&#x27;s Python causing all the issues.<p>The problem is that a lot is still possible to optimize &quot;in Python&quot; although as you say the code becomes less and less readable to your average Python developer, so that people don&#x27;t notice they just picked the wrong tool for the job.<p>You need more speed? Use multiprocessing? Allocate memory appropriately? Rust, or if you like pain, C or C++.</div><br/></div></div><div id="36456487" class="c"><input type="checkbox" id="c-36456487" checked=""/><div class="controls bullet"><span class="by">Etherlord87</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455617">parent</a><span>|</span><a href="#36456481">prev</a><span>|</span><a href="#36455513">next</a><span>|</span><label class="collapse" for="c-36456487">[-]</label><label class="expand" for="c-36456487">[2 more]</label></div><br/><div class="children"><div class="content">You need to tell that to the authors TensorFlow.</div><br/><div id="36456635" class="c"><input type="checkbox" id="c-36456635" checked=""/><div class="controls bullet"><span class="by">pzo</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36456487">parent</a><span>|</span><a href="#36455513">next</a><span>|</span><label class="collapse" for="c-36456635">[-]</label><label class="expand" for="c-36456635">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t Tensorflow has C++ API? I think tensorflow and pytorch under the hood using c++&#x2F;c. Tensorflow has even official Rust bindings. The same applies to libraries like Open3d and OpenCV - although mostly people consume their python API under the hood is very optimized C++ code parallelized for many CPU and SIMD instructions.</div><br/></div></div></div></div></div></div><div id="36455513" class="c"><input type="checkbox" id="c-36455513" checked=""/><div class="controls bullet"><span class="by">winstonewert</span><span>|</span><a href="#36454943">parent</a><span>|</span><a href="#36455617">prev</a><span>|</span><a href="#36455023">next</a><span>|</span><label class="collapse" for="c-36455513">[-]</label><label class="expand" for="c-36455513">[2 more]</label></div><br/><div class="children"><div class="content">I used to do this sort of thing in Python. But then I realized that if I wrote my code in something like C++, I had fast code without running through all these hoops. Then I learned Rust which has many of advantages of Python in terms of higher-level niceties. Today, its just way easier to write some Rust code for a simulation then go through all the hoops to make Python code fast enough.</div><br/><div id="36456295" class="c"><input type="checkbox" id="c-36456295" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455513">parent</a><span>|</span><a href="#36455023">next</a><span>|</span><label class="collapse" for="c-36456295">[-]</label><label class="expand" for="c-36456295">[1 more]</label></div><br/><div class="children"><div class="content">As the adage goes, to write fast Python first learn to code in C (or Rust if you prefer that).</div><br/></div></div></div></div><div id="36455023" class="c"><input type="checkbox" id="c-36455023" checked=""/><div class="controls bullet"><span class="by">wudangmonk</span><span>|</span><a href="#36454943">parent</a><span>|</span><a href="#36455513">prev</a><span>|</span><a href="#36456336">next</a><span>|</span><label class="collapse" for="c-36455023">[-]</label><label class="expand" for="c-36455023">[5 more]</label></div><br/><div class="children"><div class="content">This is honest question for those that use python for these compute intensive tasks and is not meant as a critique.<p>If you ultimately end up having to use c&#x2F;c++&#x2F;fortran native libraries and work around pretty much everything python. What is the point of using python instead of c&#x2F;c++?</div><br/><div id="36455056" class="c"><input type="checkbox" id="c-36455056" checked=""/><div class="controls bullet"><span class="by">jameson71</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455023">parent</a><span>|</span><a href="#36455294">next</a><span>|</span><label class="collapse" for="c-36455056">[-]</label><label class="expand" for="c-36455056">[1 more]</label></div><br/><div class="children"><div class="content">The code outside the critical path is easier and quicker</div><br/></div></div><div id="36455294" class="c"><input type="checkbox" id="c-36455294" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455023">parent</a><span>|</span><a href="#36455056">prev</a><span>|</span><a href="#36455111">next</a><span>|</span><label class="collapse" for="c-36455294">[-]</label><label class="expand" for="c-36455294">[1 more]</label></div><br/><div class="children"><div class="content">Others answered this correctly. Python is more like a glue language that is easy to use. I ended up using type annotations in my code and in the end it looked a lot like a typed language. But the nice thing about Python is that types, manual garbage collection, etc. are not necessary for most applications.</div><br/></div></div><div id="36455111" class="c"><input type="checkbox" id="c-36455111" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455023">parent</a><span>|</span><a href="#36455294">prev</a><span>|</span><a href="#36455375">next</a><span>|</span><label class="collapse" for="c-36455111">[-]</label><label class="expand" for="c-36455111">[1 more]</label></div><br/><div class="children"><div class="content">think of python wrapping other tools the same way bash does.</div><br/></div></div><div id="36455375" class="c"><input type="checkbox" id="c-36455375" checked=""/><div class="controls bullet"><span class="by">keithalewis</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455023">parent</a><span>|</span><a href="#36455111">prev</a><span>|</span><a href="#36456336">next</a><span>|</span><label class="collapse" for="c-36455375">[-]</label><label class="expand" for="c-36455375">[1 more]</label></div><br/><div class="children"><div class="content">Tricycle riders will never become Formula 1 drivers.</div><br/></div></div></div></div><div id="36456336" class="c"><input type="checkbox" id="c-36456336" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#36454943">parent</a><span>|</span><a href="#36455023">prev</a><span>|</span><a href="#36455296">next</a><span>|</span><label class="collapse" for="c-36456336">[-]</label><label class="expand" for="c-36456336">[1 more]</label></div><br/><div class="children"><div class="content">All this reminds me of writing a Go (the board game) engine in Python. There&#x27;s a lot of looping involved to identify groups and their liberties, and to detect Kos, etc. I profiled my Python code and optimized the algorithm, and it was faster. Then I rewrote my Python &quot;Board&quot; class in Rust and called it from the rest of my Python code, and it was faster again.<p>Then I wrote the same algorithms in Julia, and it was as fast as the Python &#x2F; Rust solution. Then I learned that Julia lives up to its claim.<p>If you&#x27;re reaching for Numpy &#x2F; Pandas as an optimization, and not as a convenience, then consider rewriting your code in Julia.</div><br/></div></div><div id="36455296" class="c"><input type="checkbox" id="c-36455296" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#36454943">parent</a><span>|</span><a href="#36456336">prev</a><span>|</span><a href="#36455145">next</a><span>|</span><label class="collapse" for="c-36455296">[-]</label><label class="expand" for="c-36455296">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused by some of this.  Specifically, pandas columns are essentially just a thin wrapper around record arrays in numpy right?  How could it be that much faster to use numpy over pandas if it&#x27;s effectively the same thing?</div><br/><div id="36455950" class="c"><input type="checkbox" id="c-36455950" checked=""/><div class="controls bullet"><span class="by">anywhichway</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455296">parent</a><span>|</span><a href="#36455145">next</a><span>|</span><label class="collapse" for="c-36455950">[-]</label><label class="expand" for="c-36455950">[1 more]</label></div><br/><div class="children"><div class="content">Right, each pandas column is a numpy array (or optionally pyarrow in pandas 2.0), but numpy is going to be faster for things that needs to be vectorized across columns, such as matrix operations.</div><br/></div></div></div></div><div id="36455145" class="c"><input type="checkbox" id="c-36455145" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#36454943">parent</a><span>|</span><a href="#36455296">prev</a><span>|</span><a href="#36455053">next</a><span>|</span><label class="collapse" for="c-36455145">[-]</label><label class="expand" for="c-36455145">[2 more]</label></div><br/><div class="children"><div class="content">this is a great journey! what volume of data were you analyzing?<p>more you could try:<p>- span multiple machines, with lambda&#x2F;ec2-spot and s3<p>- write c&#x2F;cpp, call via python subprocess or cffi<p>- pytorch gpu on ec2-spot</div><br/><div id="36455278" class="c"><input type="checkbox" id="c-36455278" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36454943">root</a><span>|</span><a href="#36455145">parent</a><span>|</span><a href="#36455053">next</a><span>|</span><label class="collapse" for="c-36455278">[-]</label><label class="expand" for="c-36455278">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the input! I&#x27;ll look them up.<p>Depending on the resolution of my parameters, I&#x27;m dealing with a 32-40GB-ish data.</div><br/></div></div></div></div><div id="36455053" class="c"><input type="checkbox" id="c-36455053" checked=""/><div class="controls bullet"><span class="by">jameson71</span><span>|</span><a href="#36454943">parent</a><span>|</span><a href="#36455145">prev</a><span>|</span><a href="#36456035">next</a><span>|</span><label class="collapse" for="c-36455053">[-]</label><label class="expand" for="c-36455053">[1 more]</label></div><br/><div class="children"><div class="content">And then after all that you discovered Java?</div><br/></div></div></div></div><div id="36456035" class="c"><input type="checkbox" id="c-36456035" checked=""/><div class="controls bullet"><span class="by">etoulas</span><span>|</span><a href="#36454943">prev</a><span>|</span><a href="#36454800">next</a><span>|</span><label class="collapse" for="c-36456035">[-]</label><label class="expand" for="c-36456035">[3 more]</label></div><br/><div class="children"><div class="content">This might be a silly question but are there similar optimizations that apply to Java?</div><br/><div id="36456431" class="c"><input type="checkbox" id="c-36456431" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36456035">parent</a><span>|</span><a href="#36456144">next</a><span>|</span><label class="collapse" for="c-36456431">[-]</label><label class="expand" for="c-36456431">[1 more]</label></div><br/><div class="children"><div class="content">Well it&#x27;s kind of tough because the JVM does a lot of this for you! The JVM will try to pack &quot;related&quot; memory closer together. It can even do really cool things for tree structures (like a Node class) and linked lists - which is why you see java perform so well on these types of data structure benchmarks.<p>In Java we have to worry about different things, like the number of fields on an object and object header sizes. A lot of advice in the article is still good to keep in mind when optimizing code on the JVM, though, like keeping frequently accessed fields next to each other.</div><br/></div></div><div id="36456144" class="c"><input type="checkbox" id="c-36456144" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#36456035">parent</a><span>|</span><a href="#36456431">prev</a><span>|</span><a href="#36454800">next</a><span>|</span><label class="collapse" for="c-36456144">[-]</label><label class="expand" for="c-36456144">[1 more]</label></div><br/><div class="children"><div class="content">Some things you have no control over, like padding and alignment or explicit stack allocation (not counting non-managed memory &#x2F; Unsafe). But the rest should apply just the same.</div><br/></div></div></div></div><div id="36454800" class="c"><input type="checkbox" id="c-36454800" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36456035">prev</a><span>|</span><a href="#36454965">next</a><span>|</span><label class="collapse" for="c-36454800">[-]</label><label class="expand" for="c-36454800">[4 more]</label></div><br/><div class="children"><div class="content">This is a list of microoptimizations. Designing the architecture of your whole program to be cache friendly was not addressed here, but is arguably more important.</div><br/><div id="36454846" class="c"><input type="checkbox" id="c-36454846" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#36454800">parent</a><span>|</span><a href="#36454965">next</a><span>|</span><label class="collapse" for="c-36454846">[-]</label><label class="expand" for="c-36454846">[3 more]</label></div><br/><div class="children"><div class="content">Besides SoAs vs AoSs (which is my understanding is the most impactful thing you can do to make many use cases more cache friendly), are there other things you might suggest? Or articles?</div><br/><div id="36456084" class="c"><input type="checkbox" id="c-36456084" checked=""/><div class="controls bullet"><span class="by">jzwinck</span><span>|</span><a href="#36454800">root</a><span>|</span><a href="#36454846">parent</a><span>|</span><a href="#36456037">next</a><span>|</span><label class="collapse" for="c-36456084">[-]</label><label class="expand" for="c-36456084">[1 more]</label></div><br/><div class="children"><div class="content">Reduce your working set. Make frequently used data and instructions as small and contiguous as possible. Reuse memory, e.g. store two large objects in a variant if you don&#x27;t need them at the same time, or instead of calling free() keep the pointer until you need space again. Don&#x27;t let templates bloat your instruction count. Be open to creating custom data structures when the standard library ones aren&#x27;t optimal for you.</div><br/></div></div><div id="36456037" class="c"><input type="checkbox" id="c-36456037" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36454800">root</a><span>|</span><a href="#36454846">parent</a><span>|</span><a href="#36456084">prev</a><span>|</span><a href="#36454965">next</a><span>|</span><label class="collapse" for="c-36456037">[-]</label><label class="expand" for="c-36456037">[1 more]</label></div><br/><div class="children"><div class="content">For example properly understanding the trade offs with IPC to influence both the architecture of the components of your system and when and how you talk to the other components. Having to switch to the kernel or to other processes can get your data kicked out of caches.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>