<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697878857372" as="style"/><link rel="stylesheet" href="styles.css?v=1697878857372"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://willcrichton.net/notes/k-corrset/">Recent adventures in performance optimization with Rust</a> <span class="domain">(<a href="https://willcrichton.net">willcrichton.net</a>)</span></div><div class="subtext"><span>rrampage</span> | <span>59 comments</span></div><br/><div><div id="37965080" class="c"><input type="checkbox" id="c-37965080" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#37964574">next</a><span>|</span><label class="collapse" for="c-37965080">[-]</label><label class="expand" for="c-37965080">[1 more]</label></div><br/><div class="children"><div class="content">I like it how he demonstrates the thought process.  It seems quite a mechanical recipe that can be applied to a lot of similar problems:<p>Step 1:. A slow but easy implementation.  It allows to make sure the algorithm is correct, and later allows validating the faster variants.<p>Step 2: Algorithm and datastructure optimization, guided by profiling.<p>Step 3: Micro optimization, again guided by profiling.  A standard bag of tricks is applied.  I didn&#x27;t see cache friendlyness&#x2F;tiling in here, which surprised me.<p>Step 4: Parallelism, first by SIMD then by threads.<p>I am very much not downing the author: This is a great teaching of the process, it&#x27;s a lot of hard brainy work, and we didn&#x27;t see everything he tried but which failed.  So thank you, author.<p>My point is: it is not magic.  It is engineering.  It  is a skill that can be aquired, thought, even planned and measured.</div><br/></div></div><div id="37964574" class="c"><input type="checkbox" id="c-37964574" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37965080">prev</a><span>|</span><a href="#37964982">next</a><span>|</span><label class="collapse" for="c-37964574">[-]</label><label class="expand" for="c-37964574">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s crazy to me how the author spends most of his time finding out what hides in his abstractions, and then changing that. Especially those macros, and a few random crates used, make this code quite hard to reason about.</div><br/><div id="37965206" class="c"><input type="checkbox" id="c-37965206" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#37964574">parent</a><span>|</span><a href="#37964982">next</a><span>|</span><label class="collapse" for="c-37965206">[-]</label><label class="expand" for="c-37965206">[1 more]</label></div><br/><div class="children"><div class="content">Much of the speed up was from using the right data structure for the task, e.g. Vec rather than HashMap and BitSet rather than HashSet.</div><br/></div></div></div></div><div id="37964982" class="c"><input type="checkbox" id="c-37964982" checked=""/><div class="controls bullet"><span class="by">returningfory2</span><span>|</span><a href="#37964574">prev</a><span>|</span><a href="#37964892">next</a><span>|</span><label class="collapse" for="c-37964982">[-]</label><label class="expand" for="c-37964982">[1 more]</label></div><br/><div class="children"><div class="content">There’s an optimization technique I’ve used that I think could be useful for this kind of problem. It’s similar in spirit to the post.<p>The post deals a lot both with strings and maps with strings as keys. One idea is to intern these strings using an interer like [1] which returns string keys as monotonically increasing integers starting at 0. Then instead of a map you can just have a regular vector with the interned key as the index into the vector. This gives you the map functionality with very good performance.<p>[1] <a href="https:&#x2F;&#x2F;docs.rs&#x2F;string-interner&#x2F;latest&#x2F;string_interner&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;string-interner&#x2F;latest&#x2F;string_interner&#x2F;</a></div><br/></div></div><div id="37964892" class="c"><input type="checkbox" id="c-37964892" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#37964982">prev</a><span>|</span><a href="#37964446">next</a><span>|</span><label class="collapse" for="c-37964892">[-]</label><label class="expand" for="c-37964892">[1 more]</label></div><br/><div class="children"><div class="content">I think the intent is fine, it&#x27;s an interesting problem to want to find the question or set of questions that is the best predictor of the other questions.<p>But I&#x27;d have thought there must be heuristics to help narrow the search.<p>For example you could calculate how each question correlates to all the other questions[1]. If you picked the set of k questions with the best correlation, then you have a good sense of which will be in the actual &quot;k-corr set&quot;.<p>You could widen your search a little bit, but by chopping out any questions which correlate poorly to the overall score, you narrow your search greatly, going from 200 choose 5 to 10 choose 5 is a speedup factor of a million, and you&#x27;ve probably considered all the sets that are likely to be in the final bucket.<p>It&#x27;s been a while since I&#x27;ve worked in the domain, but OP might also want to check out <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Item_response_theory" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Item_response_theory</a> and <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Classical_test_theory" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Classical_test_theory</a>.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Point-biserial_correlation_coefficient" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Point-biserial_correlation_coe...</a></div><br/></div></div><div id="37964446" class="c"><input type="checkbox" id="c-37964446" checked=""/><div class="controls bullet"><span class="by">rajangdavis</span><span>|</span><a href="#37964892">prev</a><span>|</span><a href="#37964469">next</a><span>|</span><label class="collapse" for="c-37964446">[-]</label><label class="expand" for="c-37964446">[1 more]</label></div><br/><div class="children"><div class="content">I liked that the author included his thought process through out each change.</div><br/></div></div><div id="37964469" class="c"><input type="checkbox" id="c-37964469" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37964446">prev</a><span>|</span><a href="#37964845">next</a><span>|</span><label class="collapse" for="c-37964469">[-]</label><label class="expand" for="c-37964469">[7 more]</label></div><br/><div class="children"><div class="content">Basically &quot;Analyzing Data 180,000x Faster with AOT strongly typed compiled language&quot; versus using a dynamically typed interpreted one.</div><br/><div id="37965209" class="c"><input type="checkbox" id="c-37965209" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#37964469">parent</a><span>|</span><a href="#37964726">next</a><span>|</span><label class="collapse" for="c-37965209">[-]</label><label class="expand" for="c-37965209">[1 more]</label></div><br/><div class="children"><div class="content">The difference between baseline Python and baseline Rust is only 8x here, because most of the heavy lifting in the Python version is done by native code.</div><br/></div></div><div id="37964726" class="c"><input type="checkbox" id="c-37964726" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#37964469">parent</a><span>|</span><a href="#37965209">prev</a><span>|</span><a href="#37964933">next</a><span>|</span><label class="collapse" for="c-37964726">[-]</label><label class="expand" for="c-37964726">[2 more]</label></div><br/><div class="children"><div class="content">Roughly half the article could have been done without leaving python though. I don&#x27;t know if python has a good bitset implementation, but at the very least everything before that could have been done in python. So it is more &quot;comparing manually optimized code against unoptimized crap&quot;</div><br/><div id="37964770" class="c"><input type="checkbox" id="c-37964770" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37964469">root</a><span>|</span><a href="#37964726">parent</a><span>|</span><a href="#37964933">next</a><span>|</span><label class="collapse" for="c-37964770">[-]</label><label class="expand" for="c-37964770">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, then there is the implementation thing, if cython or PyPy have been used instead.</div><br/></div></div></div></div><div id="37964933" class="c"><input type="checkbox" id="c-37964933" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#37964469">parent</a><span>|</span><a href="#37964726">prev</a><span>|</span><a href="#37964936">next</a><span>|</span><label class="collapse" for="c-37964933">[-]</label><label class="expand" for="c-37964933">[1 more]</label></div><br/><div class="children"><div class="content">No it&#x27;s basically &quot;how to analyse and improve the performance of Rust code&quot; with a &quot;btw, I prototype in python&quot;.</div><br/></div></div><div id="37964936" class="c"><input type="checkbox" id="c-37964936" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#37964469">parent</a><span>|</span><a href="#37964933">prev</a><span>|</span><a href="#37964845">next</a><span>|</span><label class="collapse" for="c-37964936">[-]</label><label class="expand" for="c-37964936">[2 more]</label></div><br/><div class="children"><div class="content">&quot;interpreted language&quot; and &quot;compiled language&quot; are category errors.</div><br/><div id="37965056" class="c"><input type="checkbox" id="c-37965056" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37964469">root</a><span>|</span><a href="#37964936">parent</a><span>|</span><a href="#37964845">next</a><span>|</span><label class="collapse" for="c-37965056">[-]</label><label class="expand" for="c-37965056">[1 more]</label></div><br/><div class="children"><div class="content">True, but since the same example can&#x27;t be done with a Rust based bytecode interpreter, or a Python AOT compiler, due to lack of implementations to use for benchmarking purposes, the remark remains valid.</div><br/></div></div></div></div></div></div><div id="37964845" class="c"><input type="checkbox" id="c-37964845" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#37964469">prev</a><span>|</span><a href="#37964583">next</a><span>|</span><label class="collapse" for="c-37964845">[-]</label><label class="expand" for="c-37964845">[2 more]</label></div><br/><div class="children"><div class="content">The author found that HashMap::get was taking most of the time and didn&#x27;t swap the hashing function??<p>It&#x27;s well known that Rust&#x27;s default HashMap hashing function is slow because it&#x27;s designed to be safe against DoS [1]. If you want your HashMap to be faster, just use a faster hashing function like ahash[2], which can be up to 40% faster.<p>[1] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch08-03-hash-maps.html#hashing-functions" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch08-03-hash-maps.html#hashin...</a><p>[2] <a href="https:&#x2F;&#x2F;docs.rs&#x2F;ahash&#x2F;0.7.4&#x2F;ahash&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;ahash&#x2F;0.7.4&#x2F;ahash&#x2F;</a></div><br/><div id="37964919" class="c"><input type="checkbox" id="c-37964919" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#37964845">parent</a><span>|</span><a href="#37964583">next</a><span>|</span><label class="collapse" for="c-37964919">[-]</label><label class="expand" for="c-37964919">[1 more]</label></div><br/><div class="children"><div class="content">They did swap the hashing function<p>&gt; Note that everywhere we refer to HashMap is actually an alias for fxhash::FxHashMap, which is just std::collections::HashMap with a more efficient hashing algorithm</div><br/></div></div></div></div><div id="37964583" class="c"><input type="checkbox" id="c-37964583" checked=""/><div class="controls bullet"><span class="by">eutectic</span><span>|</span><a href="#37964845">prev</a><span>|</span><a href="#37964295">next</a><span>|</span><label class="collapse" for="c-37964583">[-]</label><label class="expand" for="c-37964583">[2 more]</label></div><br/><div class="children"><div class="content">Obviously not the point of the post, but this doesn&#x27;t seem like a very reasonable thing to calculate, statistically speaking.<p>Also, I wonder if there is some way to use branch-and-bound to look at fewer combinations.</div><br/><div id="37964820" class="c"><input type="checkbox" id="c-37964820" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#37964583">parent</a><span>|</span><a href="#37964295">next</a><span>|</span><label class="collapse" for="c-37964820">[-]</label><label class="expand" for="c-37964820">[1 more]</label></div><br/><div class="children"><div class="content">This is a legitimate problem we  encounter in healthcare data analytics space where it will be great to find the minimum list of Diagnosis&#x2F;procedure codes that correlate most with a particular disease, etc.</div><br/></div></div></div></div><div id="37964295" class="c"><input type="checkbox" id="c-37964295" checked=""/><div class="controls bullet"><span class="by">tayo42</span><span>|</span><a href="#37964583">prev</a><span>|</span><a href="#37964719">next</a><span>|</span><label class="collapse" for="c-37964295">[-]</label><label class="expand" for="c-37964295">[15 more]</label></div><br/><div class="children"><div class="content">&gt; the point of this post isn’t to compare highly-optimized Python to highly-optimized Rust. The point is to compare “standard-Jupyter-notebook” Python to highly-optimized Rust.<p>I guess the title gets clicks, but I&#x27;m curious how good python gets. I&#x27;m under the impression pandas is pretty fast despite it being python</div><br/><div id="37964347" class="c"><input type="checkbox" id="c-37964347" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#37964295">parent</a><span>|</span><a href="#37964466">next</a><span>|</span><label class="collapse" for="c-37964347">[-]</label><label class="expand" for="c-37964347">[3 more]</label></div><br/><div class="children"><div class="content">Pandas can be pretty fast, but DuckDB and Polars are both faster than Pandas. DuckDB supports vectorized and parallelized operations on Pandas dataframes, while Polars is written in Rust.<p>I feel though the killer is that inner loop where dataframe operations are being performed across a large number of iterations, and there&#x27;s significant overhead there.<p>For-loops are usually not the most performant solution in Python.<p>I could be wrong, I feel that there&#x27;s a SQL way to answer that question, in which case DuckDB might be able to exploit vectorization, parallelization, indexing and query optimization across the dataset in one fell swoop.</div><br/><div id="37964932" class="c"><input type="checkbox" id="c-37964932" checked=""/><div class="controls bullet"><span class="by">eskaytwo</span><span>|</span><a href="#37964295">root</a><span>|</span><a href="#37964347">parent</a><span>|</span><a href="#37964588">next</a><span>|</span><label class="collapse" for="c-37964932">[-]</label><label class="expand" for="c-37964932">[1 more]</label></div><br/><div class="children"><div class="content">DuckDB can also operate on Polars data frames, and return the results to Polars data frames.</div><br/></div></div><div id="37964588" class="c"><input type="checkbox" id="c-37964588" checked=""/><div class="controls bullet"><span class="by">twelvechairs</span><span>|</span><a href="#37964295">root</a><span>|</span><a href="#37964347">parent</a><span>|</span><a href="#37964932">prev</a><span>|</span><a href="#37964466">next</a><span>|</span><label class="collapse" for="c-37964588">[-]</label><label class="expand" for="c-37964588">[1 more]</label></div><br/><div class="children"><div class="content">Numba is another excellent Python option for speedier python solutions</div><br/></div></div></div></div><div id="37964466" class="c"><input type="checkbox" id="c-37964466" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#37964295">parent</a><span>|</span><a href="#37964347">prev</a><span>|</span><a href="#37964339">next</a><span>|</span><label class="collapse" for="c-37964466">[-]</label><label class="expand" for="c-37964466">[1 more]</label></div><br/><div class="children"><div class="content">as a rule of thumb, pure python code is often 1000x slower than naively written unoptimized native code.<p>code in pandas can be very slow (standard pure-python speed) or &quot;fast-for-python&quot; depending on if you are going with or against the grain. a pandas dataframe is basically a bunch of numpy arrays, one array per column.  if you do columnar calculations that can be reduced to numpy operations, like summing over a column, then numpy will execute the operation in native code, and it will be fast-for-python, but there will still be some overhead due to wrapping things in python, as well as perhaps temporary array allocation etc.<p>if you do something against the grain, such as expressing all your pandas calculations as on row-wise operations instead of column-wise operations, or using &quot;apply(lambda x: pure_python_expression_of(x))&quot;, then pandas cannot execute it efficiently, as the operations are going against the grain of how things are stored in memory, and the operations cannot be reduced to native code primitives on the column arrays that are implemented in numpy.<p>another alternative to switching to rust is using cython to define a native python module. by starting with python code and using many of the same optimization rules of thumb in this post (static typing! avoid frequent tiny allocation, preallocate stuff! avoid hashing complex things, prefer arrays with indexes!), you can translate idiomatic (and very slow) pure python code into simple code that looks closer to array-oriented fortran-in-C, that runs very fast and compiles to a native python module that is easy to integrate.</div><br/></div></div><div id="37964339" class="c"><input type="checkbox" id="c-37964339" checked=""/><div class="controls bullet"><span class="by">eskaytwo</span><span>|</span><a href="#37964295">parent</a><span>|</span><a href="#37964466">prev</a><span>|</span><a href="#37964479">next</a><span>|</span><label class="collapse" for="c-37964339">[-]</label><label class="expand" for="c-37964339">[1 more]</label></div><br/><div class="children"><div class="content">Pandas is ok for numerical, but Polars (rust-based) is absolutely the way to go for big datasets. 
The article is fascinating if you&#x27;re a Python developer and you need to stray off the path of things Polars can do.</div><br/></div></div><div id="37964479" class="c"><input type="checkbox" id="c-37964479" checked=""/><div class="controls bullet"><span class="by">iwonthecase</span><span>|</span><a href="#37964295">parent</a><span>|</span><a href="#37964339">prev</a><span>|</span><a href="#37964488">next</a><span>|</span><label class="collapse" for="c-37964479">[-]</label><label class="expand" for="c-37964479">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Pandas would provide a pretty big improvement, but I wonder how much of an improvement one could get even by just replacing the c-style loop:<p>&gt; for qs in combinations(all_qs, K):<p>&gt; &gt;  ...<p>&gt; &gt;  corrs.append({&#x27;qs&#x27;: qs, &#x27;r&#x27;: r})<p>&gt;<p>&gt; corrs.sort_values(...)<p>with a python style list comprehension:<p>&gt; def build_q(combination):<p>&gt; &gt;  ...<p>&gt; &gt;  return {&#x27;qs&#x27;: qs, &#x27;r&#x27;: r}<p>&gt;<p>&gt; max(build_q(c) for c in combinations(all_qs, K), key = lambda v: v[&#x27;r&#x27;])</div><br/></div></div><div id="37964488" class="c"><input type="checkbox" id="c-37964488" checked=""/><div class="controls bullet"><span class="by">firecraker</span><span>|</span><a href="#37964295">parent</a><span>|</span><a href="#37964479">prev</a><span>|</span><a href="#37964357">next</a><span>|</span><label class="collapse" for="c-37964488">[-]</label><label class="expand" for="c-37964488">[1 more]</label></div><br/><div class="children"><div class="content">I suppose there are already many articles showing how to speed calculations by avoiding&#x2F;optimizing pandas.<p>It does feel a little unfair a comparison. Everyone knows that for loops are slow in python.. as is much of the core library. But pushing analysis to c using pythonic APIs (numpy&#x2F;numba&#x2F;pytorch) is fairly trivial</div><br/></div></div><div id="37964357" class="c"><input type="checkbox" id="c-37964357" checked=""/><div class="controls bullet"><span class="by">georgeecollins</span><span>|</span><a href="#37964295">parent</a><span>|</span><a href="#37964488">prev</a><span>|</span><a href="#37964706">next</a><span>|</span><label class="collapse" for="c-37964357">[-]</label><label class="expand" for="c-37964357">[5 more]</label></div><br/><div class="children"><div class="content">I like Python too but let&#x27;s face it, it is not performant.  Why do we have to pretend otherwise?</div><br/><div id="37964408" class="c"><input type="checkbox" id="c-37964408" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#37964295">root</a><span>|</span><a href="#37964357">parent</a><span>|</span><a href="#37964409">next</a><span>|</span><label class="collapse" for="c-37964408">[-]</label><label class="expand" for="c-37964408">[2 more]</label></div><br/><div class="children"><div class="content">I think everybody agrees and is not pretending otherwise.<p>But my thing is, I think the problem could be solved in a different way in Python where we can use performant libraries to get an answer in a reasonable time.<p>The author says the naive Python implementation with a for-loop takes 36 milliseconds per iteration, and the problem requires 2.5 billion iterations (= 2.9 years, which is unreasonable) while optimized Rust takes 8 mins (corrected).<p>I believe we can solve the problem in Python in a reasonable amount of time (not 2.9 years) by expressing it differently. And I believe we can do it in Python without trying to optimize Python operations like the author is doing with Rust.<p>Imagine your boss came up to you and said I need the answer by this week and that you could only use Python, you would need to come up with a way to solve it. I wouldn&#x27;t start by trying to optimizing Python&#x27;s for-loop -- I would break out of the loop paradigm altogether and use arrays, database indices, optimized dataframe libraries (probably written in C++ or Rust) to get there. Because Python is not fast -- everyone knows this -- Python programmers will often think of other ways (generally reaching for libraries) to solve the problem.</div><br/><div id="37964552" class="c"><input type="checkbox" id="c-37964552" checked=""/><div class="controls bullet"><span class="by">bibmbop</span><span>|</span><a href="#37964295">root</a><span>|</span><a href="#37964408">parent</a><span>|</span><a href="#37964409">next</a><span>|</span><label class="collapse" for="c-37964552">[-]</label><label class="expand" for="c-37964552">[1 more]</label></div><br/><div class="children"><div class="content">8 minutes.</div><br/></div></div></div></div><div id="37964409" class="c"><input type="checkbox" id="c-37964409" checked=""/><div class="controls bullet"><span class="by">tetsuhamu</span><span>|</span><a href="#37964295">root</a><span>|</span><a href="#37964357">parent</a><span>|</span><a href="#37964408">prev</a><span>|</span><a href="#37964706">next</a><span>|</span><label class="collapse" for="c-37964409">[-]</label><label class="expand" for="c-37964409">[2 more]</label></div><br/><div class="children"><div class="content">The industry agreed to standardize on Python for the task of describing compute-graphs that get executed by compute engines implemented in something other than Python. Python is not meant to be used for the computation itself.</div><br/><div id="37965020" class="c"><input type="checkbox" id="c-37965020" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37964295">root</a><span>|</span><a href="#37964409">parent</a><span>|</span><a href="#37964706">next</a><span>|</span><label class="collapse" for="c-37965020">[-]</label><label class="expand" for="c-37965020">[1 more]</label></div><br/><div class="children"><div class="content">And then other people came along, using other languages, and realised we could do the same compute, with a fraction of the hardware, in about the same time, in the languages they’re already using, which really diminishes the appeal of Python, which boils down to:<p>“Setup some infra, and get someone who knows how to operate it, and then write new code in python, and babysit it as it ossifies into a core piece of infrastructure”<p>_or_ optimise it in a language you’re already using, or is semi-common in your stack already, and then move on with things.</div><br/></div></div></div></div></div></div><div id="37964706" class="c"><input type="checkbox" id="c-37964706" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#37964295">parent</a><span>|</span><a href="#37964357">prev</a><span>|</span><a href="#37964337">next</a><span>|</span><label class="collapse" for="c-37964706">[-]</label><label class="expand" for="c-37964706">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this seems like <i>really</i> unoptimized Python.  It would be far more useful to see tricks for torturing Python&#x2F;Pandas to make things faster and how far you can take it.<p>The author wrote in a strongly typed, ahead of time compiled language, ran a profiler to help wipe out hotspots for optimization, and the program is now dramatically faster than unoptimized Python.<p>Yay?  I guess?</div><br/></div></div><div id="37964337" class="c"><input type="checkbox" id="c-37964337" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#37964295">parent</a><span>|</span><a href="#37964706">prev</a><span>|</span><a href="#37964719">next</a><span>|</span><label class="collapse" for="c-37964337">[-]</label><label class="expand" for="c-37964337">[1 more]</label></div><br/><div class="children"><div class="content">I would also be curious given the Rust implementation gets a decent amount of iteration - 30x faster natively though aint bad.</div><br/></div></div></div></div><div id="37964719" class="c"><input type="checkbox" id="c-37964719" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#37964295">prev</a><span>|</span><a href="#37964443">next</a><span>|</span><label class="collapse" for="c-37964719">[-]</label><label class="expand" for="c-37964719">[1 more]</label></div><br/><div class="children"><div class="content">I love demo apps like this. You can see some idiomatic code and then watch it descend into chaos but you can see the pathway. Otherwise you sometimes see the end result and you don&#x27;t know why it is what it is, but the pathway makes it comprehensible. Thanks for writing it.</div><br/></div></div><div id="37964443" class="c"><input type="checkbox" id="c-37964443" checked=""/><div class="controls bullet"><span class="by">latenightcoding</span><span>|</span><a href="#37964719">prev</a><span>|</span><a href="#37964678">next</a><span>|</span><label class="collapse" for="c-37964443">[-]</label><label class="expand" for="c-37964443">[3 more]</label></div><br/><div class="children"><div class="content">The Mojo PR team on their way to hire OP to publish these sort of articles at Modular.</div><br/><div id="37964468" class="c"><input type="checkbox" id="c-37964468" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#37964443">parent</a><span>|</span><a href="#37964678">next</a><span>|</span><label class="collapse" for="c-37964468">[-]</label><label class="expand" for="c-37964468">[2 more]</label></div><br/><div class="children"><div class="content">I keep wondering if Mojo will take over the world or somehow become Betamax.</div><br/><div id="37964586" class="c"><input type="checkbox" id="c-37964586" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#37964443">root</a><span>|</span><a href="#37964468">parent</a><span>|</span><a href="#37964678">next</a><span>|</span><label class="collapse" for="c-37964586">[-]</label><label class="expand" for="c-37964586">[1 more]</label></div><br/><div class="children"><div class="content">Clearly Betamax. It certainly has it&#x27;s uses and it&#x27;s development is led by the right people but there&#x27;s no magic.<p>It&#x27;s just another LLVM frontend.<p>Also I&#x27;m slightly annoyed by the fact that they kept talking about great GPU performance in their marketing material and all you can find in the docs is: &quot;it&#x27;s coming. probably. only to Nvidia hardware btw.&quot;</div><br/></div></div></div></div></div></div><div id="37964678" class="c"><input type="checkbox" id="c-37964678" checked=""/><div class="controls bullet"><span class="by">sremani</span><span>|</span><a href="#37964443">prev</a><span>|</span><a href="#37964459">next</a><span>|</span><label class="collapse" for="c-37964678">[-]</label><label class="expand" for="c-37964678">[2 more]</label></div><br/><div class="children"><div class="content">Moore&#x27;s law is dead, that means developers who will not waste CPU cycles will be in demand for the next generation of compute intensive development. Big Data needs big compute so obviously these kinds of articles are not only pertinent but is the way ahead.<p>I would not be surprised if we do rewrites of all the past 20 year code in to Rust or Go or any other performant language.<p>Lets agree on this, you are smart and the author is right.<p>I am sorry people who are complaining are not seeing where the ball is going.</div><br/><div id="37965092" class="c"><input type="checkbox" id="c-37965092" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#37964678">parent</a><span>|</span><a href="#37964459">next</a><span>|</span><label class="collapse" for="c-37965092">[-]</label><label class="expand" for="c-37965092">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure why you’re being downvoted, even if you’re aren’t correct about the law we’re seeing rising costs of cloud computing. We’ve cut our Azure cloud spending almost in half by being more efficient and rewriting core computing elements in performant languages. We’ve gone with C++ because that’s also what we use for our embedded solar plant programming but we did make a few proof of concepts using Rust and liked what we learned. I think we’ll eventually begin to move more or our C&#x2F;C++ into Rust as Rust matures, but we’re also not in a rush to do so.<p>But to get back to what you’re talking about here, we recently spoke with Lunar about their transition from a Node backend to a Java backend and then finally to a Go backend and how they can’t imagine building anything without Go going forward. Very interesting considering that the JVM is quite performant itself. I’m not sure we’re going to follow them down the Go rabbit hole, I think we’ll remain on a Node backend for non-performant stuff since it lets us use one language for most things. But I do think your predictions are right.</div><br/></div></div></div></div><div id="37964459" class="c"><input type="checkbox" id="c-37964459" checked=""/><div class="controls bullet"><span class="by">raminf</span><span>|</span><a href="#37964678">prev</a><span>|</span><a href="#37964751">next</a><span>|</span><label class="collapse" for="c-37964459">[-]</label><label class="expand" for="c-37964459">[9 more]</label></div><br/><div class="children"><div class="content">Comparing highly optimized code (including total algorithm rewrite and relying on unsafe and SIMD operations) without doing the same on the other side is a pointless exercise.<p>It&#x27;s like showing how much faster you can get your handcrafted assembly code to run vs a bash script.</div><br/><div id="37964674" class="c"><input type="checkbox" id="c-37964674" checked=""/><div class="controls bullet"><span class="by">carstimon</span><span>|</span><a href="#37964459">parent</a><span>|</span><a href="#37964582">next</a><span>|</span><label class="collapse" for="c-37964674">[-]</label><label class="expand" for="c-37964674">[1 more]</label></div><br/><div class="children"><div class="content">To add on to the defense in another comment,<p>I don&#x27;t think the point of the article is a rust-v-python comparison. Sure, unoptimized-python2rust2optimized rust was a part of the clickbait 180,000x title but... 
- the author explicitly says the python2rust bit is only a factor of 8.
- the Python bit is just one section of a pretty long article
- the author says they typically start implementing something in Python so... why wouldn&#x27;t they include their initial implementation?<p>I don&#x27;t think this article should be dismissed just for including a simple python implementation- that isn&#x27;t the point.</div><br/></div></div><div id="37964582" class="c"><input type="checkbox" id="c-37964582" checked=""/><div class="controls bullet"><span class="by">mtkd</span><span>|</span><a href="#37964459">parent</a><span>|</span><a href="#37964674">prev</a><span>|</span><a href="#37964578">next</a><span>|</span><label class="collapse" for="c-37964582">[-]</label><label class="expand" for="c-37964582">[1 more]</label></div><br/><div class="children"><div class="content">The author was clear what he was setting out to demonstrate in the piece<p>This format is likely very useful for anyone working on such large sets using Jupyter&#x2F;Python and waiting days for scripts to complete -- there is nothing wrong with those final tricky optimisations when applied to single-use scripts<p>I found it a useful reminder that there is often more to be squeezed out on inner loops with a few mins more thought</div><br/></div></div><div id="37964578" class="c"><input type="checkbox" id="c-37964578" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#37964459">parent</a><span>|</span><a href="#37964582">prev</a><span>|</span><a href="#37965014">next</a><span>|</span><label class="collapse" for="c-37964578">[-]</label><label class="expand" for="c-37964578">[5 more]</label></div><br/><div class="children"><div class="content">articles like this aren&#x27;t pointless, i don&#x27;t think it is meant to be framed as a fair comparison of &quot;rust-the-language is 5 orders of magnitude faster than python-the-language&quot;. this article does offer examples of how to use a profiler and some ideas of what kind of things can be bottlenecks and how to eliminate them, and also helps people who only ever work with very slow programming tech stacks to understand what kind of speedups can be attainable in practice when using a tech stack that can use a machine&#x27;s resources efficiently. it&#x27;s a good write up and can be educational in a variety of ways for some segments of readers.  if you only ever do pure python programming, and that informs your beliefs of what &quot;fast&quot; and &quot;slow&quot; programs feel like, seeing what performance cheap modern CPUs are actually capable of when used effectively is a bit like being exposed to alien technology.</div><br/><div id="37964760" class="c"><input type="checkbox" id="c-37964760" checked=""/><div class="controls bullet"><span class="by">refactor_master</span><span>|</span><a href="#37964459">root</a><span>|</span><a href="#37964578">parent</a><span>|</span><a href="#37965055">next</a><span>|</span><label class="collapse" for="c-37964760">[-]</label><label class="expand" for="c-37964760">[3 more]</label></div><br/><div class="children"><div class="content">Intentional or not, it does come off as kind of “disruptive” in the negative sense of the word, ie “you’re all doing it wrong in field X. Let me show you how to work faster”.<p>But in a real scenario there are often so many other constraints that “optimized code” is far from the top. Salaries are also expensive, so if you factor in the lifetime cost of writing and maintaining a bit of exotic Rust for an exotic problem, it might actually be cheaper to buy a bigger machine and brute force the problem.<p>Sure, we could all benefit from learning a bit of Rust then, but if you’re in the Python data space you know that it’s almost as crowded as frontend frameworks, and learning Rust comes across as a yet-another-framework problem, that few of us really feel like we have time for.<p>Personally I’m stuck maintaining a wizard’s (who has now left the company) solo project which initially seemed like a great solution, but has caused more grief in maintenance and bugs than any existing not-as-custom-tailored community solution out there. So if I were to tell my manager “I’ve spent a week to rewrite this job that spends 40 minutes at 2 AM to spend 1 millisecond at 2 AM, from a language that everyone uses to a language that only I use” I’m not sure he’d appreciate it.</div><br/><div id="37964887" class="c"><input type="checkbox" id="c-37964887" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#37964459">root</a><span>|</span><a href="#37964760">parent</a><span>|</span><a href="#37965055">next</a><span>|</span><label class="collapse" for="c-37964887">[-]</label><label class="expand" for="c-37964887">[2 more]</label></div><br/><div class="children"><div class="content">i agree that in typical business situations often the main constraints to solve for aren&#x27;t squeezing the most compute out of a CPU, it&#x27;s rarely the bottleneck (although of course some people can no doubt chime in from contexts where compute is frequently the bottleneck and what they spend most of their time fretting about).<p>good engineering should figure out what the main constraints are, and solve for those, while doing a &quot;good enough&quot; job for everything else and no more -- like you allude to, the main bottlenecks to solve for are usually things like reducing engineering effort, reducing schedule, reducing long term maintenance cost of the overall system (not just this isolated component) - especially how easy it is to hire someone who can understand and fix the thing.<p>but, this article isn&#x27;t a &quot;how to make good whole-system engineering tradeoffs for the long-term benefit or your employer &#x2F; client&quot; article, it&#x27;s an article showing how to write fast rust code.</div><br/><div id="37965029" class="c"><input type="checkbox" id="c-37965029" checked=""/><div class="controls bullet"><span class="by">refactor_master</span><span>|</span><a href="#37964459">root</a><span>|</span><a href="#37964887">parent</a><span>|</span><a href="#37965055">next</a><span>|</span><label class="collapse" for="c-37965029">[-]</label><label class="expand" for="c-37965029">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but, this article isn&#x27;t a &quot;how to make good whole-system engineering tradeoffs for the long-term benefit or your employer &#x2F; client&quot; article, it&#x27;s an article showing how to write fast rust code.<p>As you can probably tell from my sentiment above, it doesn’t help the author’s cause by basing the premise on a strawman. If the intention was to push Rust for Python users, this article shoots far, really far, but completely misses the mark. Nobody was telling themselves that Python was the fastest language out there.</div><br/></div></div></div></div></div></div><div id="37965055" class="c"><input type="checkbox" id="c-37965055" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#37964459">root</a><span>|</span><a href="#37964578">parent</a><span>|</span><a href="#37964760">prev</a><span>|</span><a href="#37965014">next</a><span>|</span><label class="collapse" for="c-37965055">[-]</label><label class="expand" for="c-37965055">[1 more]</label></div><br/><div class="children"><div class="content">I very much disagree with your assessment. I will agree that the title is extremely clickbaity, but the author goes into how the move from Python to Rust only accounts for a .8 increase, which is impressive but we all know Python isn’t performant so. Aside from the clickbait title I think the article is extremely interesting and rather relevant, as it takes you through the craze or optimising Rust code.<p>I guess you could make a point out of how the author didn’t need to bring Python into the article, but on the flip side, they clearly state that they typically prototype in Python. So it would also be an incomplete article if they left out the initial implementation for the problem they are solving.</div><br/></div></div></div></div></div></div><div id="37964751" class="c"><input type="checkbox" id="c-37964751" checked=""/><div class="controls bullet"><span class="by">yelnatz</span><span>|</span><a href="#37964459">prev</a><span>|</span><a href="#37964343">next</a><span>|</span><label class="collapse" for="c-37964751">[-]</label><label class="expand" for="c-37964751">[2 more]</label></div><br/><div class="children"><div class="content">Anyone else think this code is ugly as hell?</div><br/></div></div><div id="37964343" class="c"><input type="checkbox" id="c-37964343" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#37964751">prev</a><span>|</span><a href="#37964368">next</a><span>|</span><label class="collapse" for="c-37964343">[-]</label><label class="expand" for="c-37964343">[6 more]</label></div><br/><div class="children"><div class="content">Using the unsafe keyword... somehow makes me wonder where else unsafe is used...</div><br/><div id="37964597" class="c"><input type="checkbox" id="c-37964597" checked=""/><div class="controls bullet"><span class="by">throwaway5959</span><span>|</span><a href="#37964343">parent</a><span>|</span><a href="#37964549">next</a><span>|</span><label class="collapse" for="c-37964597">[-]</label><label class="expand" for="c-37964597">[1 more]</label></div><br/><div class="children"><div class="content">Nothing wrong with using unsafe if performance is essential and it’s wrapped up with good testing and kept safely tucked away in a library.</div><br/></div></div><div id="37964549" class="c"><input type="checkbox" id="c-37964549" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37964343">parent</a><span>|</span><a href="#37964597">prev</a><span>|</span><a href="#37964663">next</a><span>|</span><label class="collapse" for="c-37964549">[-]</label><label class="expand" for="c-37964549">[2 more]</label></div><br/><div class="children"><div class="content">Only to remove a bounds check that&#x27;s guaranteed to be unneeded (well, that&#x27;s what the author says, but it&#x27;s not unbelievable).</div><br/><div id="37964748" class="c"><input type="checkbox" id="c-37964748" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#37964343">root</a><span>|</span><a href="#37964549">parent</a><span>|</span><a href="#37964663">next</a><span>|</span><label class="collapse" for="c-37964748">[-]</label><label class="expand" for="c-37964748">[1 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t even know it still would be relevant after the simd step.</div><br/></div></div></div></div><div id="37964663" class="c"><input type="checkbox" id="c-37964663" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#37964343">parent</a><span>|</span><a href="#37964549">prev</a><span>|</span><a href="#37964375">next</a><span>|</span><label class="collapse" for="c-37964663">[-]</label><label class="expand" for="c-37964663">[1 more]</label></div><br/><div class="children"><div class="content">In this case, it actually didn&#x27;t bring this much speedup. The program would have been plenty fast even without.</div><br/></div></div></div></div><div id="37964368" class="c"><input type="checkbox" id="c-37964368" checked=""/><div class="controls bullet"><span class="by">b20000</span><span>|</span><a href="#37964343">prev</a><span>|</span><label class="collapse" for="c-37964368">[-]</label><label class="expand" for="c-37964368">[3 more]</label></div><br/><div class="children"><div class="content">want to write fast rust? write your code in C or C++</div><br/><div id="37964587" class="c"><input type="checkbox" id="c-37964587" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37964368">parent</a><span>|</span><a href="#37964370">next</a><span>|</span><label class="collapse" for="c-37964587">[-]</label><label class="expand" for="c-37964587">[1 more]</label></div><br/><div class="children"><div class="content">you&#x27;re getting downvoted because you said it in a weird way, but fundamentally I have to agree. Both C and C++, if written idiomatically, have less syntactic sugar and macros are less accepted, so that their code ends up hiding a lot less complexity than rust code.<p>Fairly complex code like what the author showed turns out to use a bunch of different random things nobody expected.</div><br/></div></div></div></div></div></div></div></div></div></body></html>