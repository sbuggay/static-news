<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685350863662" as="style"/><link rel="stylesheet" href="styles.css?v=1685350863662"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/libuv/libuv/pull/3952">Libuv – Linux: io_uring support</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>truth_seeker</span> | <span>71 comments</span></div><br/><div><div id="36107336" class="c"><input type="checkbox" id="c-36107336" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#36108035">next</a><span>|</span><label class="collapse" for="c-36107336">[-]</label><label class="expand" for="c-36107336">[10 more]</label></div><br/><div class="children"><div class="content">My employer, ISC, sponsored this work because we use libuv in BIND9 and we would like everyone to benefit more from the new io_uring hotness.</div><br/><div id="36107972" class="c"><input type="checkbox" id="c-36107972" checked=""/><div class="controls bullet"><span class="by">0x000xca0xfe</span><span>|</span><a href="#36107336">parent</a><span>|</span><a href="#36108035">next</a><span>|</span><label class="collapse" for="c-36107972">[-]</label><label class="expand" for="c-36107972">[9 more]</label></div><br/><div class="children"><div class="content">Awesome, do you have any data for performance or RAM usage of epoll vs. io_uring in a real-world scenario for BIND9?</div><br/><div id="36109721" class="c"><input type="checkbox" id="c-36109721" checked=""/><div class="controls bullet"><span class="by">destructionator</span><span>|</span><a href="#36107336">root</a><span>|</span><a href="#36107972">parent</a><span>|</span><a href="#36108200">next</a><span>|</span><label class="collapse" for="c-36109721">[-]</label><label class="expand" for="c-36109721">[7 more]</label></div><br/><div class="children"><div class="content">This test doesn&#x27;t include epoll in any significant fashion at all, and also doesn&#x27;t apply to network operations. The libuv thing is specifically about disk files, which linux doesn&#x27;t really support with epoll (epoll just always considers them ready, regardless of if the requested page is in cache or not, meaning it is not helpful for the async case. by contrast, a socket without data immediately available in the kernel&#x27;s buffer will not show readiness).<p>Since you <i>can&#x27;t tell</i> if a disk io function would have to actually hit the disk or use the cache on older linuxes, libuv just always dispatches said operations to a worker thread pool which then calls the normal function. When it returns, it sends a message back to the other thread to indicate its completion.<p>If data is already present in the cache, this adds significant overhead vs just calling `read` directly - instead calling `read`, it will post a request to the worker thread queue (which may require synchronization, im not sure exactly how the impl does it tbh), wake the worker thread which calls `read`, which does not block significantly since the data is indeed already present, then it posts an event back to the main thread (which, sure, it is listening for this event on `epoll`, along with whatever else it is listening to, but that&#x27;s an insignificant detail at this point) which calls the on-complete handler. All that work instead of just transferring the data from the cache to the result. Significant slowdown.<p>If the data is not already present in the cache, it does exactly those same steps, except this time `read` actually does block for some time, so the main thread can continue with other work in the mean time. (Of course, if the main thread has no other work to do, you&#x27;ve gained nothing from this!)<p>Hence why I said in my other comment that you ought not draw any general conclusion from this. This speedup has nothing to do with epoll vs io_uring (except maybe that linux file i&#x2F;o is not really epoll compatible) and everything to do with libuv&#x27;s <i>block device</i> implementation specifically. It is totally inapplicable to network loads entirely.<p>edit: in the first version I said &quot;disk file&quot; but it is technically block devices, of which disk files are just the most common example, but of course &#x2F;dev&#x2F;zero is a block device that is not a disk file.... and worth noting that &#x2F;dev&#x2F;zero is never going to actually load off a disk meaning it is &quot;in the cache&quot; all the time.</div><br/><div id="36109818" class="c"><input type="checkbox" id="c-36109818" checked=""/><div class="controls bullet"><span class="by">eklitzke</span><span>|</span><a href="#36107336">root</a><span>|</span><a href="#36109721">parent</a><span>|</span><a href="#36108200">next</a><span>|</span><label class="collapse" for="c-36109818">[-]</label><label class="expand" for="c-36109818">[6 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t really make sense to have an API to tell if reading from a file would block or not because page cache data can be evicted at any time. Even if there was an API that could tell you your next read would be non-blocking, there could be a race where the page cache entry could be evicted before you could do the read.</div><br/><div id="36110090" class="c"><input type="checkbox" id="c-36110090" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#36107336">root</a><span>|</span><a href="#36109818">parent</a><span>|</span><a href="#36110698">next</a><span>|</span><label class="collapse" for="c-36110090">[-]</label><label class="expand" for="c-36110090">[2 more]</label></div><br/><div class="children"><div class="content">That sort of race condition is only relevant if it affects correctness. Here it means a read might be unexpectedly slow, but you&#x27;ll still get the same data.<p>99.9% of the time the data will <i>not</i> be evicted prior to the read, so it&#x27;s still going to be a win overall.</div><br/><div id="36111390" class="c"><input type="checkbox" id="c-36111390" checked=""/><div class="controls bullet"><span class="by">sgtnoodle</span><span>|</span><a href="#36107336">root</a><span>|</span><a href="#36110090">parent</a><span>|</span><a href="#36110698">next</a><span>|</span><label class="collapse" for="c-36111390">[-]</label><label class="expand" for="c-36111390">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re writing a latency sensitive program, 99.9% might as well be 0% though; you&#x27;re going to end up with an asynchronous anyway.</div><br/></div></div></div></div><div id="36110698" class="c"><input type="checkbox" id="c-36110698" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36107336">root</a><span>|</span><a href="#36109818">parent</a><span>|</span><a href="#36110090">prev</a><span>|</span><a href="#36108200">next</a><span>|</span><label class="collapse" for="c-36110698">[-]</label><label class="expand" for="c-36110698">[3 more]</label></div><br/><div class="children"><div class="content">Depends how you define that API. It could do something like &quot;check if available, and if so, pin it until the next read (which will happen right now)&quot;. Not saying that&#x27;s a good idea, but if such API was needed, it is possible.</div><br/><div id="36110865" class="c"><input type="checkbox" id="c-36110865" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#36107336">root</a><span>|</span><a href="#36110698">parent</a><span>|</span><a href="#36108200">next</a><span>|</span><label class="collapse" for="c-36110865">[-]</label><label class="expand" for="c-36110865">[2 more]</label></div><br/><div class="children"><div class="content">A nonblocking read which fails if the data isn&#x27;t cached and it&#x27;d have to perform io would generally be easier to get correct.</div><br/><div id="36111246" class="c"><input type="checkbox" id="c-36111246" checked=""/><div class="controls bullet"><span class="by">_nalply</span><span>|</span><a href="#36107336">root</a><span>|</span><a href="#36110865">parent</a><span>|</span><a href="#36108200">next</a><span>|</span><label class="collapse" for="c-36111246">[-]</label><label class="expand" for="c-36111246">[1 more]</label></div><br/><div class="children"><div class="content">Please let me try to understand you.<p>The nonblocking read just failed. The task initiates IO then because the IO is async it lets other tasks run while waiting for data. Later, when the IO finished, the task can read the memory.<p>Is this what you mean?<p>I think there must be a data race somewhere or io_uring would be superfluous. Everything consisting of at least two interruptible steps at the lowest level in the CPU but where people expect no change in state is subject to some data race. It&#x27;s really difficult to get this 100% correct. Something works fine for 99.99% of the time. Such a situation can be very nasty to get it right.<p>Perhaps the step &quot;Later, when the IO finished, the task can read the memory&quot; cannot be done atomically.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36108200" class="c"><input type="checkbox" id="c-36108200" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#36107336">root</a><span>|</span><a href="#36107972">parent</a><span>|</span><a href="#36109721">prev</a><span>|</span><a href="#36108035">next</a><span>|</span><label class="collapse" for="c-36108200">[-]</label><label class="expand" for="c-36108200">[1 more]</label></div><br/><div class="children"><div class="content">Not yet :-)</div><br/></div></div></div></div></div></div><div id="36108035" class="c"><input type="checkbox" id="c-36108035" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#36107336">prev</a><span>|</span><a href="#36107194">next</a><span>|</span><label class="collapse" for="c-36108035">[-]</label><label class="expand" for="c-36108035">[5 more]</label></div><br/><div class="children"><div class="content">The 8x speedup seems to come from a microbenchmark that requires no real async work from the kernel (so I think is mostly going to be stressing out context switches and the threadpool data structures in the non-uring case) but I’m still excited about the improvements to async io from io_uring.<p>Question I’ve not figured out yet: how can one trace io_uring operations? The api seems kinda incompatible with ptrace (which is what strace uses) but maybe there is an appropriate place to attach an ebpf? Or maybe users of io_uring will have to add their own tracing?</div><br/><div id="36108278" class="c"><input type="checkbox" id="c-36108278" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36108035">parent</a><span>|</span><a href="#36108120">next</a><span>|</span><label class="collapse" for="c-36108278">[-]</label><label class="expand" for="c-36108278">[1 more]</label></div><br/><div class="children"><div class="content">Yes: the title of this post should be &quot;libuv: introduce io_uring support&quot;, not what it is now.</div><br/></div></div><div id="36108120" class="c"><input type="checkbox" id="c-36108120" checked=""/><div class="controls bullet"><span class="by">truth_seeker</span><span>|</span><a href="#36108035">parent</a><span>|</span><a href="#36108278">prev</a><span>|</span><a href="#36108375">next</a><span>|</span><label class="collapse" for="c-36108120">[-]</label><label class="expand" for="c-36108120">[1 more]</label></div><br/><div class="children"><div class="content">Observability on how kernel handles io_uring request - <a href="https:&#x2F;&#x2F;github.com&#x2F;axboe&#x2F;liburing&#x2F;issues&#x2F;467">https:&#x2F;&#x2F;github.com&#x2F;axboe&#x2F;liburing&#x2F;issues&#x2F;467</a></div><br/></div></div><div id="36108375" class="c"><input type="checkbox" id="c-36108375" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#36108035">parent</a><span>|</span><a href="#36108120">prev</a><span>|</span><a href="#36107194">next</a><span>|</span><label class="collapse" for="c-36108375">[-]</label><label class="expand" for="c-36108375">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The 8x speedup seems to come from a microbenchmark that requires no real async work from the kernel<p>which is nice because you can measure the actual library overhead without the noise from real kernel work.</div><br/><div id="36108385" class="c"><input type="checkbox" id="c-36108385" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#36108035">root</a><span>|</span><a href="#36108375">parent</a><span>|</span><a href="#36107194">next</a><span>|</span><label class="collapse" for="c-36108385">[-]</label><label class="expand" for="c-36108385">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, might have been better to reword it as a &quot;8x reduction in overhead&quot; or something to make it more clear that it&#x27;s highly unlikely you&#x27;ll see this in real workloads.</div><br/></div></div></div></div></div></div><div id="36107194" class="c"><input type="checkbox" id="c-36107194" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36108035">prev</a><span>|</span><a href="#36107070">next</a><span>|</span><label class="collapse" for="c-36107194">[-]</label><label class="expand" for="c-36107194">[2 more]</label></div><br/><div class="children"><div class="content">And this is after node.js v20 already had some very impressive more compute-centric wins! <a href="https:&#x2F;&#x2F;blog.rafaelgss.dev&#x2F;state-of-nodejs-performance-2023" rel="nofollow">https:&#x2F;&#x2F;blog.rafaelgss.dev&#x2F;state-of-nodejs-performance-2023</a></div><br/><div id="36107245" class="c"><input type="checkbox" id="c-36107245" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#36107194">parent</a><span>|</span><a href="#36107070">next</a><span>|</span><label class="collapse" for="c-36107245">[-]</label><label class="expand" for="c-36107245">[1 more]</label></div><br/><div class="children"><div class="content">Very excited for the performance implications for Node in general. Node is going to be very speedy in v21.</div><br/></div></div></div></div><div id="36107070" class="c"><input type="checkbox" id="c-36107070" checked=""/><div class="controls bullet"><span class="by">xiphias2</span><span>|</span><a href="#36107194">prev</a><span>|</span><a href="#36106986">next</a><span>|</span><label class="collapse" for="c-36107070">[-]</label><label class="expand" for="c-36107070">[5 more]</label></div><br/><div class="children"><div class="content">Maybe this is an arrogant question, but why adding asyncio to these libraries in general in all OSs is slow?<p>I would think that writing the kernel part would be the hardest, but it&#x27;s usually the event loop implementations that don&#x27;t use what the Windows&#x2F;MacOS&#x2F;Linux kenels offer.</div><br/><div id="36107109" class="c"><input type="checkbox" id="c-36107109" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#36107070">parent</a><span>|</span><a href="#36111538">next</a><span>|</span><label class="collapse" for="c-36107109">[-]</label><label class="expand" for="c-36107109">[2 more]</label></div><br/><div class="children"><div class="content">We tried to add io_uring support to libnbd (and indeed still hope to do so).  There&#x27;s a bit of an &quot;impedance mismatch&quot; between existing event-driven code and io_uring, not impossible, but also not completely easy to just convert code.  Especially when you want to keep the non-io_uring code working (for old Linux, BSD etc).<p>To give an example, libnbd does a lot of send and recv system calls interleaved, for sending requests and receiving replies, with a complicated state machine to keep track of when we would block.  It&#x27;s still not obvious how to convert this to an io_uring style where you have to add the send&#x2F;recv requests to the submission queue and then separately pick up the responses from the completion queue.  It&#x27;s a particular problem dealing with possible errors and keeping the API the same (if you just call exit when you hit any error, it&#x27;s a lot easier).<p>If you&#x27;re writing all new code then io_uring is a great choice.</div><br/><div id="36108455" class="c"><input type="checkbox" id="c-36108455" checked=""/><div class="controls bullet"><span class="by">xiphias2</span><span>|</span><a href="#36107070">root</a><span>|</span><a href="#36107109">parent</a><span>|</span><a href="#36111538">next</a><span>|</span><label class="collapse" for="c-36108455">[-]</label><label class="expand" for="c-36108455">[1 more]</label></div><br/><div class="children"><div class="content">I was playing with Tokio &#x2F; Rust on MacOS and hit an about max 500k requests &#x2F; second limit where the CPU was mostly doing send &#x2F; recieve calls, not using MacOS asyncio system calls.<p>I know it&#x27;s a different library, and asyncio is not as flexible as io_uring, but at least batching send &#x2F; recv calls from different sockets would be good to be able to do.</div><br/></div></div></div></div><div id="36111538" class="c"><input type="checkbox" id="c-36111538" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#36107070">parent</a><span>|</span><a href="#36107109">prev</a><span>|</span><a href="#36108344">next</a><span>|</span><label class="collapse" for="c-36111538">[-]</label><label class="expand" for="c-36111538">[1 more]</label></div><br/><div class="children"><div class="content">It is because there in general needs to be pretty big structural changes in the programs to make use of it properly.</div><br/></div></div><div id="36108344" class="c"><input type="checkbox" id="c-36108344" checked=""/><div class="controls bullet"><span class="by">woooooo</span><span>|</span><a href="#36107070">parent</a><span>|</span><a href="#36111538">prev</a><span>|</span><a href="#36106986">next</a><span>|</span><label class="collapse" for="c-36108344">[-]</label><label class="expand" for="c-36108344">[1 more]</label></div><br/><div class="children"><div class="content">Liburing is pretty recent, and it started with a really limited set of syscalls it supports.<p>Everyone is adopting it pretty quickly, actually.</div><br/></div></div></div></div><div id="36106986" class="c"><input type="checkbox" id="c-36106986" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#36107070">prev</a><span>|</span><a href="#36107452">next</a><span>|</span><label class="collapse" for="c-36106986">[-]</label><label class="expand" for="c-36106986">[9 more]</label></div><br/><div class="children"><div class="content">Does this mean that NodeJS apps will gain 8x throughout?</div><br/><div id="36107150" class="c"><input type="checkbox" id="c-36107150" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#36106986">parent</a><span>|</span><a href="#36107147">next</a><span>|</span><label class="collapse" for="c-36107150">[-]</label><label class="expand" for="c-36107150">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know why you’re being downvoted, because for most people that don’t work with low level syscalls this is the kind of question they have.<p>From what I understand, some async operations will be faster in node on newer versions of the linux kernel, when node uses a version of libuv that contains this PR.</div><br/></div></div><div id="36107147" class="c"><input type="checkbox" id="c-36107147" checked=""/><div class="controls bullet"><span class="by">biorach</span><span>|</span><a href="#36106986">parent</a><span>|</span><a href="#36107150">prev</a><span>|</span><a href="#36111399">next</a><span>|</span><label class="collapse" for="c-36107147">[-]</label><label class="expand" for="c-36107147">[1 more]</label></div><br/><div class="children"><div class="content">If the app&#x27;s workload is quite similar to whatever benchmark showed the 8x improvement, then yes.<p>Otherwise,  i.e. in the real world,  it&#x27;s very unlikely to be that much.  High throughout workloads should see improvement, but each application is different.</div><br/></div></div><div id="36111399" class="c"><input type="checkbox" id="c-36111399" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#36106986">parent</a><span>|</span><a href="#36107147">prev</a><span>|</span><a href="#36107654">next</a><span>|</span><label class="collapse" for="c-36111399">[-]</label><label class="expand" for="c-36111399">[1 more]</label></div><br/><div class="children"><div class="content">No.</div><br/></div></div><div id="36107654" class="c"><input type="checkbox" id="c-36107654" checked=""/><div class="controls bullet"><span class="by">truth_seeker</span><span>|</span><a href="#36106986">parent</a><span>|</span><a href="#36111399">prev</a><span>|</span><a href="#36107452">next</a><span>|</span><label class="collapse" for="c-36107654">[-]</label><label class="expand" for="c-36107654">[5 more]</label></div><br/><div class="children"><div class="content">Only if they are highly I&#x2F;O bound.<p>For example, implementing tcp&#x2F;http&#x2F;udp proxy servers. Static file servers too can benefit greatly.</div><br/><div id="36107896" class="c"><input type="checkbox" id="c-36107896" checked=""/><div class="controls bullet"><span class="by">bhaney</span><span>|</span><a href="#36106986">root</a><span>|</span><a href="#36107654">parent</a><span>|</span><a href="#36107758">next</a><span>|</span><label class="collapse" for="c-36107896">[-]</label><label class="expand" for="c-36107896">[3 more]</label></div><br/><div class="children"><div class="content">Based on an exchange in the PR, it sounds like they have to be specifically bound on file I&#x2F;O to see an improvement, not network I&#x2F;O.<p>&gt; is this PR just for files or also for network operations?<p>&gt; Just file operations for now.</div><br/><div id="36108041" class="c"><input type="checkbox" id="c-36108041" checked=""/><div class="controls bullet"><span class="by">truth_seeker</span><span>|</span><a href="#36106986">root</a><span>|</span><a href="#36107896">parent</a><span>|</span><a href="#36107758">next</a><span>|</span><label class="collapse" for="c-36108041">[-]</label><label class="expand" for="c-36108041">[2 more]</label></div><br/><div class="children"><div class="content">Ouch ! I missed that comment.<p>Not sure, why they ignored socket, it would be have been great addition to NodeJS&#x2F;Python stack. Let&#x27;s hope they make it happen in near future release schedule.</div><br/><div id="36108590" class="c"><input type="checkbox" id="c-36108590" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36106986">root</a><span>|</span><a href="#36108041">parent</a><span>|</span><a href="#36107758">next</a><span>|</span><label class="collapse" for="c-36108590">[-]</label><label class="expand" for="c-36108590">[1 more]</label></div><br/><div class="children"><div class="content">io_uring was made primarily for filesystem operations and is most optimized for that use case. Other file descriptor types have to be explicitly handled by the kernel side of the io_uring implementation, and while network calls are among those that have been, they still all require different handling in some cases.</div><br/></div></div></div></div></div></div><div id="36107758" class="c"><input type="checkbox" id="c-36107758" checked=""/><div class="controls bullet"><span class="by">Misdicorl</span><span>|</span><a href="#36106986">root</a><span>|</span><a href="#36107654">parent</a><span>|</span><a href="#36107896">prev</a><span>|</span><a href="#36107452">next</a><span>|</span><label class="collapse" for="c-36107758">[-]</label><label class="expand" for="c-36107758">[1 more]</label></div><br/><div class="children"><div class="content">Nit: Syscall bound, not necessarily I&#x2F;O bound.</div><br/></div></div></div></div></div></div><div id="36107452" class="c"><input type="checkbox" id="c-36107452" checked=""/><div class="controls bullet"><span class="by">ithinkso</span><span>|</span><a href="#36106986">prev</a><span>|</span><a href="#36107982">next</a><span>|</span><label class="collapse" for="c-36107452">[-]</label><label class="expand" for="c-36107452">[17 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the same &#x27;for&#x27; in the title that I don&#x27;t understand in the &#x27;Windows subsystem for Linux&#x27;. English is not my native language but it is only recently that I started to notice this usage of for. Has it always been used like this?<p>Github post does it normally: &#x27;Add io_uring support for several asynchronous file operations:&#x27;</div><br/><div id="36108067" class="c"><input type="checkbox" id="c-36108067" checked=""/><div class="controls bullet"><span class="by">inktype</span><span>|</span><a href="#36107452">parent</a><span>|</span><a href="#36111625">next</a><span>|</span><label class="collapse" for="c-36108067">[-]</label><label class="expand" for="c-36108067">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, &quot;x y for z&quot; can be parsed in multiple ways that result in opposite meanings.<p>Explaining with examples:<p>* [io_uring support] [for libuv]: &quot;libuv has io_uring support&quot;<p>* [io_uring] [support for libuv]: &quot;io_uring has support for libuv&quot;<p>* [Windows subsystem] [for Linux]: &quot;Linux has a Windows subsystem&quot;<p>* [Windows] [subsystem for Linux]: &quot;Windows has a subsystem for Linux&quot;<p>[x] [y for z] &#x2F; &quot;x has y for z&quot; is much more common.</div><br/></div></div><div id="36111625" class="c"><input type="checkbox" id="c-36111625" checked=""/><div class="controls bullet"><span class="by">rkagerer</span><span>|</span><a href="#36107452">parent</a><span>|</span><a href="#36108067">prev</a><span>|</span><a href="#36107977">next</a><span>|</span><label class="collapse" for="c-36111625">[-]</label><label class="expand" for="c-36111625">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t feel bad.  <i>Windows Subsystem for Linux</i> was just a horrible name.<p>They couldn&#x27;t even be bothered to put an apostrophe on the end of Windows.</div><br/></div></div><div id="36107977" class="c"><input type="checkbox" id="c-36107977" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#36107452">parent</a><span>|</span><a href="#36111625">prev</a><span>|</span><a href="#36108055">next</a><span>|</span><label class="collapse" for="c-36107977">[-]</label><label class="expand" for="c-36107977">[1 more]</label></div><br/><div class="children"><div class="content">I guess the first thing to note is that ‘for’ is the kind of old common word that tends to have a lot of meanings. Nevertheless:<p>1. I think they are not the same senses. In ‘windows subsystem for Linux’, the word means ‘having as a function’ like in the phrase ‘spanner for 1&#x2F;4 inch hex bolts’.<p>2. I think the sense in the title is more like ‘to the benefit of’ (or perhaps ‘affecting’ or ‘having the reason’) like ‘lunch for employees’ or ‘supports for the lintel’<p>3. I checked a couple of dictionaries and they had the sense but definitions for words like these can be pretty hard to read even for a native speaker.</div><br/></div></div><div id="36108055" class="c"><input type="checkbox" id="c-36108055" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#36107452">parent</a><span>|</span><a href="#36107977">prev</a><span>|</span><a href="#36107970">next</a><span>|</span><label class="collapse" for="c-36108055">[-]</label><label class="expand" for="c-36108055">[1 more]</label></div><br/><div class="children"><div class="content">Unless the title has been changed since your comment, it&#x27;s not the same &quot;for&quot; as &quot;Windows Services for Linux&quot;. In that, the first thing now has been modified to support the second thing. In &quot;io_ring support for libuv&quot;, the second thing has been modified so it works with the first thing.<p>For what it&#x27;s worth, I&#x27;m a native English speaker and I agree they both sound the wrong way round to me! But I can convince myself that they do also make sense the way round they were intended.</div><br/></div></div><div id="36107970" class="c"><input type="checkbox" id="c-36107970" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#36107452">parent</a><span>|</span><a href="#36108055">prev</a><span>|</span><a href="#36107959">next</a><span>|</span><label class="collapse" for="c-36107970">[-]</label><label class="expand" for="c-36107970">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s just that &quot;Windows X for Y&quot; where Y is a possibly trademarked entity works better for Microsoft in general. Maybe it wasn&#x27;t risky for Linux, but if they ever want an other &quot;Windows subsystem for Z&quot;, where Z is a trademarked name, then this puts them in the clear.</div><br/></div></div><div id="36107503" class="c"><input type="checkbox" id="c-36107503" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#36107452">parent</a><span>|</span><a href="#36107959">prev</a><span>|</span><a href="#36107982">next</a><span>|</span><label class="collapse" for="c-36107503">[-]</label><label class="expand" for="c-36107503">[10 more]</label></div><br/><div class="children"><div class="content">&quot;X for Y&quot; isn&#x27;t a new thing (&quot;Windows for Workgroups&quot;, 1993) but I think the phrasing is possibly more common in the tech world than outside it.</div><br/><div id="36107570" class="c"><input type="checkbox" id="c-36107570" checked=""/><div class="controls bullet"><span class="by">ithinkso</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107503">parent</a><span>|</span><a href="#36107560">next</a><span>|</span><label class="collapse" for="c-36107570">[-]</label><label class="expand" for="c-36107570">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not it, X for Y sounds completely normal as in &#x27;food for kids&#x27; or something. But I have read the title as if io_uring added support for libuv.</div><br/><div id="36107644" class="c"><input type="checkbox" id="c-36107644" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107570">parent</a><span>|</span><a href="#36107768">next</a><span>|</span><label class="collapse" for="c-36107644">[-]</label><label class="expand" for="c-36107644">[1 more]</label></div><br/><div class="children"><div class="content">That would be &quot;io_uring: support for libuv&quot;. Which is a common way to write headlines, so assuming the headline was missing punctuation was reasonable.<p>(in case the title changes later, it&#x27;s currently &quot;io_uring support for libuv&quot;)</div><br/></div></div><div id="36107768" class="c"><input type="checkbox" id="c-36107768" checked=""/><div class="controls bullet"><span class="by">earthling8118</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107570">parent</a><span>|</span><a href="#36107644">prev</a><span>|</span><a href="#36107918">next</a><span>|</span><label class="collapse" for="c-36107768">[-]</label><label class="expand" for="c-36107768">[1 more]</label></div><br/><div class="children"><div class="content">I think this is a slightly different case than the WSL one. The headline is accurate, but perhaps a bit jarring. It might have been better to say &quot;io_uring support in libuv&quot; but I would say using from is not incorrect.</div><br/></div></div><div id="36107918" class="c"><input type="checkbox" id="c-36107918" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107570">parent</a><span>|</span><a href="#36107768">prev</a><span>|</span><a href="#36107922">next</a><span>|</span><label class="collapse" for="c-36107918">[-]</label><label class="expand" for="c-36107918">[1 more]</label></div><br/><div class="children"><div class="content">Hm? The word “for” has the same meaning here as in “food for kids”. Read it as (io_uring support) for (libuv). “Io_uring support” is being provided. Provided for what? Provided for libuv.</div><br/></div></div><div id="36107922" class="c"><input type="checkbox" id="c-36107922" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107570">parent</a><span>|</span><a href="#36107918">prev</a><span>|</span><a href="#36107615">next</a><span>|</span><label class="collapse" for="c-36107922">[-]</label><label class="expand" for="c-36107922">[1 more]</label></div><br/><div class="children"><div class="content">Looking at it again I think the problem is that both X and Y are of the same type which makes the overall sentence confusing, even though it is technically correct.<p>In a more normal construction (&quot;food voucher support for kids&quot;) it is obvious from context that the kids are being given the support, because the converse would be nonsensical.</div><br/></div></div><div id="36107615" class="c"><input type="checkbox" id="c-36107615" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107570">parent</a><span>|</span><a href="#36107922">prev</a><span>|</span><a href="#36107560">next</a><span>|</span><label class="collapse" for="c-36107615">[-]</label><label class="expand" for="c-36107615">[1 more]</label></div><br/><div class="children"><div class="content">I’m a native speaker, read it wrong at first, and had to think step by step. “well, libuv is a JS-related library, io_ring is an OS level concept, so its probably a change to libuv”, and still had uncertainty and opened GitHub to double check.<p>You make a really good point I never heard before: X for Y is an ambiguous construct  with two names referring to the same class of object, without an obvious relationship. Ex. Barack for Don is easy, but only if you know American politics, a reference to “a predecessor”. But “Jon for Mary” is inscrutable.</div><br/></div></div></div></div><div id="36107560" class="c"><input type="checkbox" id="c-36107560" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107503">parent</a><span>|</span><a href="#36107570">prev</a><span>|</span><a href="#36107571">next</a><span>|</span><label class="collapse" for="c-36107560">[-]</label><label class="expand" for="c-36107560">[2 more]</label></div><br/><div class="children"><div class="content">What about &quot;German for Engineers&quot;? is that the same &quot;for&quot;? I&#x27;m thinking of a ficticious language course for engineers..</div><br/><div id="36107671" class="c"><input type="checkbox" id="c-36107671" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107560">parent</a><span>|</span><a href="#36107571">next</a><span>|</span><label class="collapse" for="c-36107671">[-]</label><label class="expand" for="c-36107671">[1 more]</label></div><br/><div class="children"><div class="content">While &quot;Engineers for Ukraine&quot; is probably about building drones and shipping them to the Russian border region.</div><br/></div></div></div></div><div id="36107571" class="c"><input type="checkbox" id="c-36107571" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#36107452">root</a><span>|</span><a href="#36107503">parent</a><span>|</span><a href="#36107560">prev</a><span>|</span><a href="#36107982">next</a><span>|</span><label class="collapse" for="c-36107571">[-]</label><label class="expand" for="c-36107571">[1 more]</label></div><br/><div class="children"><div class="content">Toys for Tots, food for thought.</div><br/></div></div></div></div></div></div><div id="36107982" class="c"><input type="checkbox" id="c-36107982" checked=""/><div class="controls bullet"><span class="by">moralestapia</span><span>|</span><a href="#36107452">prev</a><span>|</span><a href="#36112007">next</a><span>|</span><label class="collapse" for="c-36107982">[-]</label><label class="expand" for="c-36107982">[3 more]</label></div><br/><div class="children"><div class="content">libuv is such an underrated piece of technology!<p>If you haven&#x27;t yet, please go check it out, write a program with it and be amazed.<p>So glad to be a contributor.</div><br/><div id="36111012" class="c"><input type="checkbox" id="c-36111012" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36107982">parent</a><span>|</span><a href="#36110738">next</a><span>|</span><label class="collapse" for="c-36111012">[-]</label><label class="expand" for="c-36111012">[1 more]</label></div><br/><div class="children"><div class="content">Underrated by whom? Is Deno giving up C goodness for Rusty goodness a mistake? I don&#x27;t think so but it seems to be another time that a big improvement comes with a big drawback.<p>To me libuv seems highly rated and it deserves to be highly rated. I&#x27;m not sure how to quantify it exactly to say whether it&#x27;s fairly rated, underrated, or overrated, but it seems like it&#x27;s in the ballpark as far as ratings go.</div><br/></div></div><div id="36110738" class="c"><input type="checkbox" id="c-36110738" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36107982">parent</a><span>|</span><a href="#36111012">prev</a><span>|</span><a href="#36112007">next</a><span>|</span><label class="collapse" for="c-36110738">[-]</label><label class="expand" for="c-36110738">[1 more]</label></div><br/><div class="children"><div class="content">libuv brought .NET to Linux. Will never forget that.<p>Without libuv that story would not have been such a success.<p>Thank you!</div><br/></div></div></div></div><div id="36112007" class="c"><input type="checkbox" id="c-36112007" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#36107982">prev</a><span>|</span><a href="#36109668">next</a><span>|</span><label class="collapse" for="c-36112007">[-]</label><label class="expand" for="c-36112007">[1 more]</label></div><br/><div class="children"><div class="content">really cool to read that thread and see neovim devs looking at it as well. we need a sort of open source hall of fame and axboe should be there for sure</div><br/></div></div><div id="36109668" class="c"><input type="checkbox" id="c-36109668" checked=""/><div class="controls bullet"><span class="by">Ahmad498</span><span>|</span><a href="#36112007">prev</a><span>|</span><a href="#36109657">next</a><span>|</span><label class="collapse" for="c-36109668">[-]</label><label class="expand" for="c-36109668">[1 more]</label></div><br/><div class="children"><div class="content">This is ready for review now. Linux v5.13 is the minimum required, otherwise libuv falls back to the thread pool.</div><br/></div></div><div id="36109657" class="c"><input type="checkbox" id="c-36109657" checked=""/><div class="controls bullet"><span class="by">destructionator</span><span>|</span><a href="#36109668">prev</a><span>|</span><a href="#36106985">next</a><span>|</span><label class="collapse" for="c-36109657">[-]</label><label class="expand" for="c-36109657">[1 more]</label></div><br/><div class="children"><div class="content">libuv&#x27;s implementation of &quot;async&quot; disk i&#x2F;o brings massive overhead (somewhat necessarily on linux, totally unnecessarily on other systems), so just about anything (including just switching to straight blocking read&#x2F;write&#x2F;seek&#x2F;etc syscalls) would result in a significant speed increase.<p>This isn&#x27;t to say that io_uring is bad, just don&#x27;t draw too much a conclusion from any benchmark of their old impl beyond the context of their old impl specifically.</div><br/></div></div><div id="36106985" class="c"><input type="checkbox" id="c-36106985" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36109657">prev</a><span>|</span><a href="#36109230">next</a><span>|</span><label class="collapse" for="c-36106985">[-]</label><label class="expand" for="c-36106985">[4 more]</label></div><br/><div class="children"><div class="content">8x throughput in what benchmark?</div><br/><div id="36107094" class="c"><input type="checkbox" id="c-36107094" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#36106985">parent</a><span>|</span><a href="#36109230">next</a><span>|</span><label class="collapse" for="c-36107094">[-]</label><label class="expand" for="c-36107094">[3 more]</label></div><br/><div class="children"><div class="content">Reading small chunks from &#x2F;dev&#x2F;zero.  Avoiding lots of small syscalls is the best case for io_uring, but also not uncommon in real code.</div><br/><div id="36107162" class="c"><input type="checkbox" id="c-36107162" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#36106985">root</a><span>|</span><a href="#36107094">parent</a><span>|</span><a href="#36109230">next</a><span>|</span><label class="collapse" for="c-36107162">[-]</label><label class="expand" for="c-36107162">[2 more]</label></div><br/><div class="children"><div class="content">The commenter mentioning reading small chunks from <i>&#x2F;dev&#x2F;zero</i> says specifically GREATER than the stated x8 throughput, which makes me think it&#x27;s x8 in the general sense.<p>I could be mistaken though, it seems odd not to post any sort of numbers&#x2F;benchmarks.</div><br/><div id="36109336" class="c"><input type="checkbox" id="c-36109336" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#36106985">root</a><span>|</span><a href="#36107162">parent</a><span>|</span><a href="#36109230">next</a><span>|</span><label class="collapse" for="c-36109336">[-]</label><label class="expand" for="c-36109336">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll eat my files if this gives 8x on normal applications reading normal sized files from real SSDs or HDDs.<p>The commenter mentions &quot;greater than 8x&quot; on a very artificial benchmark of reading &#x2F;dev&#x2F;zero. The original PR author than copies that to the PR description as &quot;8x has been observed&quot; (lossily dropping the greater, but not adding any additional datapoints).<p>The reality will be that disk IO dwarfs the overhead of syscalls and threadpools in all real cases.<p>That all that&#x27;s being saved here: the overhead of having to manage a threadpool, and make a few more syscalls.<p>Compared to reading a few MB off disk, that overhead will not be noticed, and definitely won&#x27;t be 8x.</div><br/></div></div></div></div></div></div></div></div><div id="36109230" class="c"><input type="checkbox" id="c-36109230" checked=""/><div class="controls bullet"><span class="by">MichaelMoser123</span><span>|</span><a href="#36106985">prev</a><span>|</span><a href="#36106478">next</a><span>|</span><label class="collapse" for="c-36109230">[-]</label><label class="expand" for="c-36109230">[2 more]</label></div><br/><div class="children"><div class="content">very impressive!<p>Just one questions: what about older versions of linux that don&#x27;t have io_uring, does it fall back gracefully to older system calls or are these older versions of linux no longer supported?</div><br/><div id="36111937" class="c"><input type="checkbox" id="c-36111937" checked=""/><div class="controls bullet"><span class="by">truth_seeker</span><span>|</span><a href="#36109230">parent</a><span>|</span><a href="#36106478">next</a><span>|</span><label class="collapse" for="c-36111937">[-]</label><label class="expand" for="c-36111937">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Auto Fallback to older Linux api is in place already.</div><br/></div></div></div></div><div id="36106478" class="c"><input type="checkbox" id="c-36106478" checked=""/><div class="controls bullet"><span class="by">truth_seeker</span><span>|</span><a href="#36109230">prev</a><span>|</span><a href="#36107212">next</a><span>|</span><label class="collapse" for="c-36106478">[-]</label><label class="expand" for="c-36106478">[2 more]</label></div><br/><div class="children"><div class="content">Libraries, VMs, Runtimes backed by libuv :<p><a href="https:&#x2F;&#x2F;github.com&#x2F;libuv&#x2F;libuv&#x2F;blob&#x2F;v1.x&#x2F;LINKS.md">https:&#x2F;&#x2F;github.com&#x2F;libuv&#x2F;libuv&#x2F;blob&#x2F;v1.x&#x2F;LINKS.md</a></div><br/><div id="36110755" class="c"><input type="checkbox" id="c-36110755" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36106478">parent</a><span>|</span><a href="#36107212">next</a><span>|</span><label class="collapse" for="c-36110755">[-]</label><label class="expand" for="c-36110755">[1 more]</label></div><br/><div class="children"><div class="content">Impressive. Especially the DNS resolvers.<p>At least the .NET entry is however no longer correct</div><br/></div></div></div></div><div id="36107212" class="c"><input type="checkbox" id="c-36107212" checked=""/><div class="controls bullet"><span class="by">heyoni</span><span>|</span><a href="#36106478">prev</a><span>|</span><a href="#36111526">next</a><span>|</span><label class="collapse" for="c-36107212">[-]</label><label class="expand" for="c-36107212">[2 more]</label></div><br/><div class="children"><div class="content">Does this potentially mean you could write a sql driver using libuv in python and benefit from async calls performance without the main python scripts using any async libraries or conventions?</div><br/><div id="36107518" class="c"><input type="checkbox" id="c-36107518" checked=""/><div class="controls bullet"><span class="by">truth_seeker</span><span>|</span><a href="#36107212">parent</a><span>|</span><a href="#36111526">next</a><span>|</span><label class="collapse" for="c-36107518">[-]</label><label class="expand" for="c-36107518">[1 more]</label></div><br/><div class="children"><div class="content">asyncio event loop in Python uses `uvloop` which in based on `libuv`</div><br/></div></div></div></div><div id="36111526" class="c"><input type="checkbox" id="c-36111526" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36107212">prev</a><span>|</span><a href="#36108803">next</a><span>|</span><label class="collapse" for="c-36111526">[-]</label><label class="expand" for="c-36111526">[1 more]</label></div><br/><div class="children"><div class="content">This is really good. Thank you!<p>I&#x27;ve been studying how to create an asynchronous runtime that works across threads. My goal: neither CPU and IO bound work slow down event loops.<p>How do you write code that elegantly defines a state machine across threads&#x2F;parallelism&#x2F;async IO?
How do you efficiently define choreographies between microservices, threads, servers and flows?<p>I&#x27;ve only written two Rust programs but in Rust you presumably you can use Rayon (CPU scheduling) and Tokio (IO scheduling)<p>I wrote about using the LMAX Disruptor ringbuffer pattern between threads.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;ideas4#51-rewrite-synchronous-code-into-lmax-disruptor-thread-pools---event-loops-that-dont-block-on-cpu-usage">https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;ideas4#51-rewrite-synchronous-c...</a><p>I am designing a state machine formulation syntax that is thread safe and parallelises effectively. It looks like EBNF syntax or a bash pipeline. Parallel steps go in curly brackets. There is an implied interthread ringbuffer between pipes. It is inspired by prolog, whereby there can be multiple conditions or &quot;facts&quot; before a stateline &quot;fires&quot; and transitions. Transitions always go from left to right but within a stateline (what is between a pipe symbol) can fire in any order. A bit like a countdown latch.<p><pre><code>  states = state1 | {state1a state1b state1c} {state2a state2b state2c} | state3
</code></pre>
You can can think of each fact as an &quot;await&quot; but all at the same time.<p><pre><code>  initial_state.await = { state1a.await state1b.await state1c.await }.await { state2a.await state2b.await state2c.await } | state3.await
</code></pre>
In io_uring and LMAX Disruptor, you split all IO into two halves: submit and handle. Here is a liburing state machine that can send and receive in parallel.<p><pre><code>   accept | { submit_recv! | recv | submit_send } { submit_send! | send | submit_recv }
</code></pre>
I want there to be ring buffers between groups of states. So we have full duplex sending and receiving.<p>Here is a state machine for async&#x2F;await between threads:<p><pre><code>  next_free_thread = 2
  task(A) thread(1) assignment(A, 1) = running_on(A, 1) | 
  paused(A, 1)

  running_on(A, 1)
  thread(1)
  assignment(A, 1)
  thread_free(next_free_thread) = fork(A, B)
                                | send_task_to_thread(B, next_free_thread)
                                |   running_on(B, 2)
                                    paused(B, 1)
                                    running_on(A, 1)
                               | { yield(B, returnvalue) | paused(B, 2) }
                                 { await(A, B, returnvalue) | paused(A, 1) }
                               | send_returnvalue(B, A, returnvalue)</code></pre></div><br/></div></div><div id="36108803" class="c"><input type="checkbox" id="c-36108803" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#36111526">prev</a><span>|</span><a href="#36107135">next</a><span>|</span><label class="collapse" for="c-36108803">[-]</label><label class="expand" for="c-36108803">[3 more]</label></div><br/><div class="children"><div class="content">Add &quot;On Linux&quot; to the title.</div><br/><div id="36109021" class="c"><input type="checkbox" id="c-36109021" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#36108803">parent</a><span>|</span><a href="#36107135">next</a><span>|</span><label class="collapse" for="c-36109021">[-]</label><label class="expand" for="c-36109021">[2 more]</label></div><br/><div class="children"><div class="content">io_uring, as mentioned in the title, implies Linux.</div><br/><div id="36111681" class="c"><input type="checkbox" id="c-36111681" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#36108803">root</a><span>|</span><a href="#36109021">parent</a><span>|</span><a href="#36107135">next</a><span>|</span><label class="collapse" for="c-36111681">[-]</label><label class="expand" for="c-36111681">[1 more]</label></div><br/><div class="children"><div class="content">The title was changed by the time you replied.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>