<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687424459210" as="style"/><link rel="stylesheet" href="styles.css?v=1687424459210"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://phaazon.net/blog/more-hindsight-vim-helix-kakoune">Even more hindsight on Vim, Helix and Kakoune</a> <span class="domain">(<a href="https://phaazon.net">phaazon.net</a>)</span></div><div class="subtext"><span>cosmojg</span> | <span>49 comments</span></div><br/><div><div id="36427490" class="c"><input type="checkbox" id="c-36427490" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36429221">next</a><span>|</span><label class="collapse" for="c-36427490">[-]</label><label class="expand" for="c-36427490">[1 more]</label></div><br/><div class="children"><div class="content">Related ongoing thread:<p><i>Why Kakoune – The quest for a better code editor (2016)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36424256">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36424256</a> - June 2023 (56 comments)</div><br/></div></div><div id="36429221" class="c"><input type="checkbox" id="c-36429221" checked=""/><div class="controls bullet"><span class="by">dansalvato</span><span>|</span><a href="#36427490">prev</a><span>|</span><a href="#36427680">next</a><span>|</span><label class="collapse" for="c-36429221">[-]</label><label class="expand" for="c-36429221">[2 more]</label></div><br/><div class="children"><div class="content">I gave Helix a shot, and I immediately ran into a wall due to an undocumented limitation where in a language configuration, indentation can only be up to 8 spaces. (I&#x27;m working on an Assembly project with an indentation of 12 spaces to make more room for labels.)<p>I checked the source code to figure out what the heck was going on, and I found this: <a href="https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&#x2F;blob&#x2F;207829eefee51095d1c7b424cf11cab694fbf52b&#x2F;helix-core&#x2F;src&#x2F;indent.rs#L39-L59">https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&#x2F;blob&#x2F;207829eefee51095d...</a><p>Pretty often, my projects have weirdly specific needs like this. I think (Neo)Vim&#x27;s greatest strength is that it always absolutely has some way of covering a weirdly specific need, whether a one-off command or a project configuration. But that seems to be against Helix&#x27;s philosophy.<p>If Helix can&#x27;t be <i>the</i> editor, then I can&#x27;t justify taking the time to learn it. It makes me sad, though, because I really like what it&#x27;s going for.</div><br/><div id="36429531" class="c"><input type="checkbox" id="c-36429531" checked=""/><div class="controls bullet"><span class="by">Sirenos</span><span>|</span><a href="#36429221">parent</a><span>|</span><a href="#36427680">next</a><span>|</span><label class="collapse" for="c-36429531">[-]</label><label class="expand" for="c-36429531">[1 more]</label></div><br/><div class="children"><div class="content">That looks very hacky. Is there a reason for this limitation that you&#x27;ve found makes sense?</div><br/></div></div></div></div><div id="36427680" class="c"><input type="checkbox" id="c-36427680" checked=""/><div class="controls bullet"><span class="by">bccdee</span><span>|</span><a href="#36429221">prev</a><span>|</span><a href="#36427477">next</a><span>|</span><label class="collapse" for="c-36427680">[-]</label><label class="expand" for="c-36427680">[6 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t like Kakoune&#x27;s model of extensibility. It&#x27;s one of the reasons I switched back to Vim after using Kakoune as my main editor for several months. The configuration system is esoteric, fiddly, and (as of 4 years ago or so, when I last used it) not thoroughly documented.<p>I think Helix made a good choice by building in LSP support and other things that would otherwise require extensions, and by having a &quot;you don&#x27;t really need it&quot; policy for things like panes, which you can just do with tmux. And I think Neovim made a good choice by exporting a configuration&#x2F;extension API in a very standard, commonplace extension language like Lua. I disagree that Neovim&#x27;s Lua API is really a different language. It&#x27;s just an API; Kakoune has one too, albeit of a more esoteric sort.<p>Incidentally, I started using Helix a month or two ago and I&#x27;ve been liking it a lot. Having the language server stuff already integrated is a fantastic convenience. I could probably switch to using hx exclusively if I really wanted, even with no extension system whatsoever. The only thing I want that they haven&#x27;t implemented yet is easymotion jumps, and there&#x27;s an MR for that already [0].<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&#x2F;pull&#x2F;3791">https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&#x2F;pull&#x2F;3791</a></div><br/><div id="36428020" class="c"><input type="checkbox" id="c-36428020" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36427680">parent</a><span>|</span><a href="#36427477">next</a><span>|</span><label class="collapse" for="c-36428020">[-]</label><label class="expand" for="c-36428020">[5 more]</label></div><br/><div class="children"><div class="content">Wait, no panes? What about things like diffing two files? There are also plenty of other situations too where I’ve definitely wanted splits in the same client, so I can see multiple files at once but also copy between them (which requires shared registers), write macros that switch between the panes (which… well, I suppose Kakoune’s composability approach might be able to support such a concept, but I get the impression Helix really wouldn’t), <i>&amp;c.</i><p>Wow, <a href="https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&#x2F;issues&#x2F;405">https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&#x2F;issues&#x2F;405</a>, indeed no side-by-side diffing and the approach being suggested would be hopelessly crippled for even two-way diff (let alone three- or four-way diff, which are probably just total non-starters), since it would only support editing one of the documents!<p>Seriously, my mind is boggling at considering a “you don’t really need it” policy for at least splits. I really do need it: even on my base task load, tmux would be inadequate in painful ways multiple times per month; and I regularly (sometimes daily for weeks, though other times not for months on end) do things for which it would be completely debilitating so that I couldn’t possibly use Helix and would <i>have</i> to go back to Vim.</div><br/><div id="36429435" class="c"><input type="checkbox" id="c-36429435" checked=""/><div class="controls bullet"><span class="by">archseer</span><span>|</span><a href="#36427680">root</a><span>|</span><a href="#36428020">parent</a><span>|</span><a href="#36428199">next</a><span>|</span><label class="collapse" for="c-36429435">[-]</label><label class="expand" for="c-36429435">[1 more]</label></div><br/><div class="children"><div class="content">Splits are provided, tabs and terminals aren&#x27;t. Diff mode is work in progress.</div><br/></div></div><div id="36428199" class="c"><input type="checkbox" id="c-36428199" checked=""/><div class="controls bullet"><span class="by">lytedev</span><span>|</span><a href="#36427680">root</a><span>|</span><a href="#36428020">parent</a><span>|</span><a href="#36429435">prev</a><span>|</span><a href="#36428173">next</a><span>|</span><label class="collapse" for="c-36428199">[-]</label><label class="expand" for="c-36428199">[1 more]</label></div><br/><div class="children"><div class="content">Helix has splits and the issue you linked for side-by-side diffs is still open!</div><br/></div></div><div id="36428173" class="c"><input type="checkbox" id="c-36428173" checked=""/><div class="controls bullet"><span class="by">pipe_connector</span><span>|</span><a href="#36427680">root</a><span>|</span><a href="#36428020">parent</a><span>|</span><a href="#36428199">prev</a><span>|</span><a href="#36427477">next</a><span>|</span><label class="collapse" for="c-36428173">[-]</label><label class="expand" for="c-36428173">[2 more]</label></div><br/><div class="children"><div class="content">You can still use a dedicated diff tool for these situations if they come up regularly. In my experience they are better than vim anyhow.</div><br/><div id="36428652" class="c"><input type="checkbox" id="c-36428652" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#36427680">root</a><span>|</span><a href="#36428173">parent</a><span>|</span><a href="#36427477">next</a><span>|</span><label class="collapse" for="c-36428652">[-]</label><label class="expand" for="c-36428652">[1 more]</label></div><br/><div class="children"><div class="content">Vim is not a very good diff tool (e.g. no word diff, tho there&#x27;s a plugin) but it&#x27;s good enough for most cases and it&#x27;s nice to never have to switch the way you work.</div><br/></div></div></div></div></div></div></div></div><div id="36427477" class="c"><input type="checkbox" id="c-36427477" checked=""/><div class="controls bullet"><span class="by">softirq</span><span>|</span><a href="#36427680">prev</a><span>|</span><a href="#36427268">next</a><span>|</span><label class="collapse" for="c-36427477">[-]</label><label class="expand" for="c-36427477">[13 more]</label></div><br/><div class="children"><div class="content">All I care about when it comes to editors is availability (on every platform, can be used in a terminal), longevity, and the community for third party plugins. Vim still checks all of those boxes and the only real other contender is still Emacs.<p>Vim is super crusty, Kakoune and helix have better takes on the unix philosophy, integrations. VSCode is easier for absolute beginners to click around in. IntelliJ has better semantic parsing. But none of that matters. None of that holds me back from being successful. I just need an editor I can type code in that I will never have to give up, that will just <i>be there</i>, and I can use at the next job. In fact Vim&#x27;s quick editing is just a nice to have, it&#x27;s never been the difference between me killing it and getting killed at work. That&#x27;s why I&#x27;m sticking with Vim.</div><br/><div id="36428979" class="c"><input type="checkbox" id="c-36428979" checked=""/><div class="controls bullet"><span class="by">tsuujin</span><span>|</span><a href="#36427477">parent</a><span>|</span><a href="#36427782">next</a><span>|</span><label class="collapse" for="c-36428979">[-]</label><label class="expand" for="c-36428979">[1 more]</label></div><br/><div class="children"><div class="content">I was drawn to helix specifically because it is excellent without the need for plugins.<p>LSP and tree-sitter grammars carry so many of the features I had to add to vim and emacs—over years of configuring—that I feel like I’m not missing anything important; despite having an emacs config large enough to justify its own repo outside all my other dotfiles.<p>My whole helix config is telling helix what theme I want and the path to my nix formatter, and it feels nice.</div><br/></div></div><div id="36427782" class="c"><input type="checkbox" id="c-36427782" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36427477">parent</a><span>|</span><a href="#36428979">prev</a><span>|</span><a href="#36427268">next</a><span>|</span><label class="collapse" for="c-36427782">[-]</label><label class="expand" for="c-36427782">[11 more]</label></div><br/><div class="children"><div class="content">Why do you care so much about availability of an app that is unusable without a lot of plugins? At which point, you can copy plugin code with the editor app to a place you need it available in</div><br/><div id="36428272" class="c"><input type="checkbox" id="c-36428272" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36427782">parent</a><span>|</span><a href="#36427831">next</a><span>|</span><label class="collapse" for="c-36428272">[-]</label><label class="expand" for="c-36428272">[7 more]</label></div><br/><div class="children"><div class="content">The point of an editor having tons of plugins is captured in one phrase: the long tail [1]. A mature tool with a healthy ecosystem of plugins will have every user installing a unique  (or nearly unique) suite of plugins. Attempting to have the base tool itself support all those millions of different use cases and configurations is a lost cause.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Long_Tail_(book)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Long_Tail_(book)</a></div><br/><div id="36428459" class="c"><input type="checkbox" id="c-36428459" checked=""/><div class="controls bullet"><span class="by">bourneavent</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36428272">parent</a><span>|</span><a href="#36428349">next</a><span>|</span><label class="collapse" for="c-36428459">[-]</label><label class="expand" for="c-36428459">[1 more]</label></div><br/><div class="children"><div class="content">Except I&#x27;m sure that book fails to mention many examples where the long tail worked and instead focuses on where the long tail failed and biases it&#x27;s own story around that.<p>Jetbrains suite of IDEs are basically long tails and they have huge utility in many areas that exceed other editors.</div><br/></div></div><div id="36428349" class="c"><input type="checkbox" id="c-36428349" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36428272">parent</a><span>|</span><a href="#36428459">prev</a><span>|</span><a href="#36427831">next</a><span>|</span><label class="collapse" for="c-36428349">[-]</label><label class="expand" for="c-36428349">[5 more]</label></div><br/><div class="children"><div class="content">You&#x27;re just reinforcing my point instead of addressing it, the tail of plugins you need is not available everywhere</div><br/><div id="36428498" class="c"><input type="checkbox" id="c-36428498" checked=""/><div class="controls bullet"><span class="by">ScoobleDoodle</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36428349">parent</a><span>|</span><a href="#36427831">next</a><span>|</span><label class="collapse" for="c-36428498">[-]</label><label class="expand" for="c-36428498">[4 more]</label></div><br/><div class="children"><div class="content">The plug-ins are for the home environment, customized to be ideal and cover all bases.  Like a home office.<p>The core functionality being available everywhere means a familiar and efficient, even if not ideal and complete, suite is available everywhere else: servers, other computers, a new system.  For transient &#x2F; temporary use.  Like on a business trip, a flight, or the conference.</div><br/><div id="36429112" class="c"><input type="checkbox" id="c-36429112" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36428498">parent</a><span>|</span><a href="#36427831">next</a><span>|</span><label class="collapse" for="c-36429112">[-]</label><label class="expand" for="c-36429112">[3 more]</label></div><br/><div class="children"><div class="content">Except it&#x27;s neither familiar nor efficient because, e.g., you&#x27;re using your custom keybindings in your &quot;home office&quot; (and there are a dozen of more things that become integral to your editing experience), all of which would break down your basics.<p>Just like you wouldn&#x27;t use a random laptop during a business trip and expect to be efficient, you&#x27;d bring your own!</div><br/><div id="36429301" class="c"><input type="checkbox" id="c-36429301" checked=""/><div class="controls bullet"><span class="by">davidatbu</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36429112">parent</a><span>|</span><a href="#36427831">next</a><span>|</span><label class="collapse" for="c-36429301">[-]</label><label class="expand" for="c-36429301">[2 more]</label></div><br/><div class="children"><div class="content">A data point: I&#x27;m a plugin-heavy neovim user, and I wholeheartedly testify that familiarity with vi modal editing is incredibly useful when ssh-ing into remote systems, and I don&#x27;t have my plugins.</div><br/><div id="36429479" class="c"><input type="checkbox" id="c-36429479" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36429301">parent</a><span>|</span><a href="#36427831">next</a><span>|</span><label class="collapse" for="c-36429479">[-]</label><label class="expand" for="c-36429479">[1 more]</label></div><br/><div class="children"><div class="content">Not to disagree, but these days vscode (and probably others, but vscode is the best I&#x27;ve tried) mostly alleviates that need with remote editing. It also has a few objective benefits, like eliminating typing latency (e.g. if your remote machine is on the other side of the globe), and letting you keep all your local settings and extensions (mostly).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36427831" class="c"><input type="checkbox" id="c-36427831" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36427782">parent</a><span>|</span><a href="#36428272">prev</a><span>|</span><a href="#36429373">next</a><span>|</span><label class="collapse" for="c-36427831">[-]</label><label class="expand" for="c-36427831">[2 more]</label></div><br/><div class="children"><div class="content">“Unusable without any plugins” is quite a description to throw in there as an assumption.</div><br/><div id="36428447" class="c"><input type="checkbox" id="c-36428447" checked=""/><div class="controls bullet"><span class="by">bourneavent</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36427831">parent</a><span>|</span><a href="#36429373">next</a><span>|</span><label class="collapse" for="c-36428447">[-]</label><label class="expand" for="c-36428447">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s barely useable. I rely a lot on code completion, search capabilities and syntax checking while I code. It just saves a lot of time from having to execute the compiler and wait for it to check everything.<p>With good &quot;plugins&quot; or &quot;features&quot; all of these things happen async.</div><br/></div></div></div></div><div id="36429373" class="c"><input type="checkbox" id="c-36429373" checked=""/><div class="controls bullet"><span class="by">goodpoint</span><span>|</span><a href="#36427477">root</a><span>|</span><a href="#36427782">parent</a><span>|</span><a href="#36427831">prev</a><span>|</span><a href="#36427268">next</a><span>|</span><label class="collapse" for="c-36429373">[-]</label><label class="expand" for="c-36429373">[1 more]</label></div><br/><div class="children"><div class="content">Vim is not an &quot;app&quot;.</div><br/></div></div></div></div></div></div><div id="36427268" class="c"><input type="checkbox" id="c-36427268" checked=""/><div class="controls bullet"><span class="by">cosmojg</span><span>|</span><a href="#36427477">prev</a><span>|</span><a href="#36427539">next</a><span>|</span><label class="collapse" for="c-36427268">[-]</label><label class="expand" for="c-36427268">[1 more]</label></div><br/><div class="children"><div class="content">The author, Dimitri Sabadie (@phaazon[1]), is a prominent Kakoune contributor[2]. In this article, he offers his thoughts on Helix[3], how it compares and contrasts with Kakoune, and how both Helix and Kakoune improve on the tried-and-true Vi-inspired formula which continues to drive the popularity of keyboard-centric editors like Vim and Neovim.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;phaazon">https:&#x2F;&#x2F;github.com&#x2F;phaazon</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;phaazon&#x2F;kak-tree-sitter">https:&#x2F;&#x2F;github.com&#x2F;phaazon&#x2F;kak-tree-sitter</a><p>[3] <a href="https:&#x2F;&#x2F;helix-editor.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;helix-editor.com&#x2F;</a></div><br/></div></div><div id="36427539" class="c"><input type="checkbox" id="c-36427539" checked=""/><div class="controls bullet"><span class="by">kemiller</span><span>|</span><a href="#36427268">prev</a><span>|</span><a href="#36427866">next</a><span>|</span><label class="collapse" for="c-36427539">[-]</label><label class="expand" for="c-36427539">[3 more]</label></div><br/><div class="children"><div class="content">I really want to like helix.  I do like helix.  The batteries included ethos is awesome.  Multi-select is tantalizingly close to something really interesting.  Buts its macro&#x2F;keybinding vocabulary isn’t quiiiiite there yet.  And tbh I’m not sold on multi-selection as the only paradigm.</div><br/><div id="36427776" class="c"><input type="checkbox" id="c-36427776" checked=""/><div class="controls bullet"><span class="by">knodi123</span><span>|</span><a href="#36427539">parent</a><span>|</span><a href="#36427866">next</a><span>|</span><label class="collapse" for="c-36427776">[-]</label><label class="expand" for="c-36427776">[2 more]</label></div><br/><div class="children"><div class="content">&gt; something really inter<p>?</div><br/><div id="36427933" class="c"><input type="checkbox" id="c-36427933" checked=""/><div class="controls bullet"><span class="by">kemiller</span><span>|</span><a href="#36427539">root</a><span>|</span><a href="#36427776">parent</a><span>|</span><a href="#36427866">next</a><span>|</span><label class="collapse" for="c-36427933">[-]</label><label class="expand" for="c-36427933">[1 more]</label></div><br/><div class="children"><div class="content">esting.</div><br/></div></div></div></div></div></div><div id="36427866" class="c"><input type="checkbox" id="c-36427866" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#36427539">prev</a><span>|</span><a href="#36428209">next</a><span>|</span><label class="collapse" for="c-36427866">[-]</label><label class="expand" for="c-36427866">[2 more]</label></div><br/><div class="children"><div class="content">I found the discussion on extensibility vs composability to be really fascinating. The author is right that extensibility gives you less freedom <i>between</i> tools. You can&#x27;t take magit to vim or helix, because it is an Emacs extension. And each tool has it&#x27;s own way of extending it, which means you need to learn essentially a new API (if not an entire language) to extend a tool.<p>However extensibility makes it much easier to move <i>within</i> a tool. The authors sample kakoune config for doing splits is a great example. Since Kak doesn&#x27;t support splits natively, you have to learn 3 separate tools do the spliting in a WM. In something like Emacs there is only one thing to learn to manage splits on all platforms. And it is using the same extension mechanisms you use for everything else.<p>I found this the paragraph just before the conclusion to be an interesting demonstration of these trade-offs:<p>&gt; All of that to say that, the take of Helix is pretty good here, because all of those UNIX problems are not there in that editor: everything runs in the same process, inside the same memory region.<p>The author spends a lot of time praising composability over extensibility, but then admits that Helix has some real advantages because it is <i>not</i> composed with tree-sitter or lsp, it has those built in. Essentially it was <i>extended</i> with those features, they become part of editor, instead of trying to interact with them in a uniform way.<p>This reminded me of the xi-retrospective section[1] on modular software. composability works better on the small scale, but struggles when you have many independent things interacting with each other. It is fine for simple things like &quot;using the shell to sort lines&quot; or &quot;bring your own fuzzy finder&quot;, but with more complicated integration it starts to falter.<p>[1]<a href="https:&#x2F;&#x2F;raphlinus.github.io&#x2F;xi&#x2F;2020&#x2F;06&#x2F;27&#x2F;xi-retrospective.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;raphlinus.github.io&#x2F;xi&#x2F;2020&#x2F;06&#x2F;27&#x2F;xi-retrospective.h...</a></div><br/><div id="36428427" class="c"><input type="checkbox" id="c-36428427" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36427866">parent</a><span>|</span><a href="#36428209">next</a><span>|</span><label class="collapse" for="c-36428427">[-]</label><label class="expand" for="c-36428427">[1 more]</label></div><br/><div class="children"><div class="content">I found <a href="https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;everything_is_file.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;everything_is_file.html</a> a very compelling read today, on similar topics.  Specifically, having a base set of abstractions that everything &quot;speaks&quot; is a huge boon that is often hard to articulate.  Annoying, as the drawbacks and sheer number of edges is often much more easily described.<p>TO that end, Emacs&#x27; &quot;everything is open to everything else&quot; works surprisingly well, once you get used to it.  Especially so if you go with not introducing new primitives to makes things happen in the process.  Even &quot;async&quot; is relatively easy once you get used to the sentinel approach.<p>Can you imagine a better way?  Almost certainly.  I have yet to see one survive the test of so many contributors, though.</div><br/></div></div></div></div><div id="36428209" class="c"><input type="checkbox" id="c-36428209" checked=""/><div class="controls bullet"><span class="by">qolop</span><span>|</span><a href="#36427866">prev</a><span>|</span><a href="#36429047">next</a><span>|</span><label class="collapse" for="c-36428209">[-]</label><label class="expand" for="c-36428209">[2 more]</label></div><br/><div class="children"><div class="content">I really want to use helix but was turned off by the lack of Copilot support and the developers&#x27; contempt and holier than thou attitude towards people who use AI assisted coding.</div><br/><div id="36428755" class="c"><input type="checkbox" id="c-36428755" checked=""/><div class="controls bullet"><span class="by">mumblingdrunk</span><span>|</span><a href="#36428209">parent</a><span>|</span><a href="#36429047">next</a><span>|</span><label class="collapse" for="c-36428755">[-]</label><label class="expand" for="c-36428755">[1 more]</label></div><br/><div class="children"><div class="content">I never got the impression that the developers had an attitude.  The discussion I&#x27;ve seen has been mostly people making demands or saying Helix will fail if it doesn&#x27;t support AI tool integration right now, but none of the devs are interested in using that kind of tooling with Helix, so they don&#x27;t implement it.
When they have poked fun at someone, it has been because that someone is very quick to demand the feature, but unwilling to submit a PR.<p>There is an open PR for getting copilot support, though it&#x27;s currently just a hotfix and likely won&#x27;t be accepted into core.  You can still patch your own version and compile it.</div><br/></div></div></div></div><div id="36429047" class="c"><input type="checkbox" id="c-36429047" checked=""/><div class="controls bullet"><span class="by">jhoechtl</span><span>|</span><a href="#36428209">prev</a><span>|</span><a href="#36427938">next</a><span>|</span><label class="collapse" for="c-36429047">[-]</label><label class="expand" for="c-36429047">[1 more]</label></div><br/><div class="children"><div class="content">Where is Emacs? Version 29 will be an absolutely great release!</div><br/></div></div><div id="36427938" class="c"><input type="checkbox" id="c-36427938" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36429047">prev</a><span>|</span><a href="#36428572">next</a><span>|</span><label class="collapse" for="c-36427938">[-]</label><label class="expand" for="c-36427938">[1 more]</label></div><br/><div class="children"><div class="content">The text editing examples are great illustrations of the power of the editor, but hard to follow in this static format that doesn&#x27;t show transition from one state to another, so a little pic going back&amp;worth might be better; also the cursor should be highlighted more instead of being just hardly visible gray</div><br/></div></div><div id="36428572" class="c"><input type="checkbox" id="c-36428572" checked=""/><div class="controls bullet"><span class="by">reil_convnet</span><span>|</span><a href="#36427938">prev</a><span>|</span><a href="#36427765">next</a><span>|</span><label class="collapse" for="c-36428572">[-]</label><label class="expand" for="c-36428572">[1 more]</label></div><br/><div class="children"><div class="content">I have been using Helix editor for last three months {was a sublime user earlier} and am really liking it. Its LSP is faster than Sublime, needs minimal setup and very similar to vim.
I knew Vim from my engineering days but the configuration part of Vim kept me away from using it and thus using sublime. Helix solved that specific problem.</div><br/></div></div><div id="36427765" class="c"><input type="checkbox" id="c-36427765" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36428572">prev</a><span>|</span><a href="#36428306">next</a><span>|</span><label class="collapse" for="c-36427765">[-]</label><label class="expand" for="c-36427765">[4 more]</label></div><br/><div class="children"><div class="content">&gt; However, if you type w, the cursor will move to the end of the word while the anchor will move to its beginning, visually selecting the word<p>Would be cool, but all it does is move the cursor to the end, anchor remains in the middle of the word (if you start from the middle)</div><br/><div id="36428441" class="c"><input type="checkbox" id="c-36428441" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36427765">parent</a><span>|</span><a href="#36428073">next</a><span>|</span><label class="collapse" for="c-36428441">[-]</label><label class="expand" for="c-36428441">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m amused, as I immediately think, &quot;er&#x2F;expand-region&quot; covers this like a champ.  Complete with C-g leaving the cursor where you started, if you change your mind.</div><br/></div></div><div id="36428073" class="c"><input type="checkbox" id="c-36428073" checked=""/><div class="controls bullet"><span class="by">lwhsiao</span><span>|</span><a href="#36427765">parent</a><span>|</span><a href="#36428441">prev</a><span>|</span><a href="#36428239">next</a><span>|</span><label class="collapse" for="c-36428073">[-]</label><label class="expand" for="c-36428073">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right. One way to select a word from the middle in helix is `miw`.</div><br/></div></div><div id="36428239" class="c"><input type="checkbox" id="c-36428239" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#36427765">parent</a><span>|</span><a href="#36428073">prev</a><span>|</span><a href="#36428306">next</a><span>|</span><label class="collapse" for="c-36428239">[-]</label><label class="expand" for="c-36428239">[1 more]</label></div><br/><div class="children"><div class="content">You can use `bw` or `be` to do that</div><br/></div></div></div></div><div id="36428306" class="c"><input type="checkbox" id="c-36428306" checked=""/><div class="controls bullet"><span class="by">rewgs</span><span>|</span><a href="#36427765">prev</a><span>|</span><a href="#36427569">next</a><span>|</span><label class="collapse" for="c-36428306">[-]</label><label class="expand" for="c-36428306">[2 more]</label></div><br/><div class="children"><div class="content">I arrived at modal editors via Helix. I had bounced off (neo)vim multiple times, primarily due to the verb-object editing scheme, and initially found Helix to be a godsend.<p>That said, I had an editing paradigm too opinionated even for Helix, so I mangled my Helix config into what I thought at the time was my dream editor.<p>Over time, though, I started to &quot;see the light&quot; of Vim&#x27;s ways. I&#x27;d run into this or that use-case, realize that I had mapped the key for it to something that fit my custom paradigm ideas, and one by one, switched back to the defaults. Eventually, my Helix config became more Vim-y. So I switched to Neovim and didn&#x27;t look back.<p>I got really into the plugins and customization, and while yes, I still do have a good bit of plugins and a somewhat large config, it&#x27;s become more and more stock with time.<p>It took me a <i>long</i> time to <i>get</i> it, but the Vim model really is truly brilliant. I still appreciate Helix (and by extension, Kakoune), and I&#x27;m happy I went through the weird twisty road that I did, but ultimately I found that the ways in which those two differ from Vim were indicative of me &quot;clinging&quot; to old editing habits from more &quot;standard&quot; editors. It took truly diving in and accepting that maybe, just maybe, I <i>didn&#x27;t</i> have better ideas than a 50-year old editor that&#x27;s stood the test of time, to see it.</div><br/><div id="36429497" class="c"><input type="checkbox" id="c-36429497" checked=""/><div class="controls bullet"><span class="by">anhner</span><span>|</span><a href="#36428306">parent</a><span>|</span><a href="#36427569">next</a><span>|</span><label class="collapse" for="c-36429497">[-]</label><label class="expand" for="c-36429497">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for writing this. The last sentence really got me thinking.</div><br/></div></div></div></div><div id="36427569" class="c"><input type="checkbox" id="c-36427569" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#36428306">prev</a><span>|</span><a href="#36429118">next</a><span>|</span><label class="collapse" for="c-36427569">[-]</label><label class="expand" for="c-36427569">[2 more]</label></div><br/><div class="children"><div class="content">Argh! I’ve been finally getting around to learning vi (vim), and now you are telling me that is so last century, I need Kakoune?<p>At least Vim “mode” seems to be supported everywhere. Surely I get more bang for “time investment” than these others?</div><br/><div id="36427616" class="c"><input type="checkbox" id="c-36427616" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#36427569">parent</a><span>|</span><a href="#36429118">next</a><span>|</span><label class="collapse" for="c-36427616">[-]</label><label class="expand" for="c-36427616">[1 more]</label></div><br/><div class="children"><div class="content">vi is ubiquitous, so it&#x27;s still a useful thing to have learned. Especially for fresh linux installs, or in default VM environments, it&#x27;s useful to be able to use vi.<p>Though, IME the cost of learning something like kakoune or helix&#x27;s motion (having already learned vi) is quite low. -- The value-add of vi&#x27;s modal editing doesn&#x27;t go away just because something even nicer comes along; it does mean you get the chance to use something even nicer.</div><br/></div></div></div></div><div id="36429118" class="c"><input type="checkbox" id="c-36429118" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#36427569">prev</a><span>|</span><a href="#36428132">next</a><span>|</span><label class="collapse" for="c-36429118">[-]</label><label class="expand" for="c-36429118">[1 more]</label></div><br/><div class="children"><div class="content">On vis, there&#x27;s a noticeable lag on pressing &quot;ESC&quot; on older systems.</div><br/></div></div><div id="36428132" class="c"><input type="checkbox" id="c-36428132" checked=""/><div class="controls bullet"><span class="by">rizky05</span><span>|</span><a href="#36429118">prev</a><span>|</span><label class="collapse" for="c-36428132">[-]</label><label class="expand" for="c-36428132">[6 more]</label></div><br/><div class="children"><div class="content">I want terminal editor that does not need me remembering keyboard shortcuts to edit things. Mouse should be optional, and editing without mouse should be the default. But every editing operation should be easy to access and sensible - You don&#x27;t have to read any docs to navigate&#x2F;edit&#x2F;search&#x2F;replace.<p>When opening that editor, you should not be greeted with tutorial. It should be simple to do things so that tutorial is not even necessary.<p>You can say, I want VSCode that runs in terminal, but one that does not hog my cpu&#x2F;memory. It should feels instant to do anything, without any loading time if possible.</div><br/><div id="36428307" class="c"><input type="checkbox" id="c-36428307" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#36428132">parent</a><span>|</span><a href="#36429316">next</a><span>|</span><label class="collapse" for="c-36428307">[-]</label><label class="expand" for="c-36428307">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I want terminal editor that does not need me remembering keyboard shortcuts to edit things.<p>Keyboard shortcuts are essential to increase efficiency and speed.  For example, ctrl-c, ctrl-v, ctrl-z, ctrl-s, ctrl-p, ctrl-a etc.  People learn these early on if they regularly have to input&#x2F;edit text to speed up their workflow.  Otherwise, they would have to resort to pointing and clicking through menus to accomplish the same thing.<p>The longer you use an editor, the more of these shortcuts you commit to (muscle) memory, so, even if the commonly used editing operation is easily accessable via the GUI interface, people are going to choose the keyboard shortcut to do the same thing since it&#x27;s faster.<p>&gt; When opening that editor, you should not be greeted with tutorial. It should be simple to do things so that tutorial is not even necessary.<p>You could navigate with the mouse or arrow keys in either vim or emacs.  The only thing you would have to learn is how to save the file.  You may not even have to learn that because both vim and emacs display a dialog box asking you whether or not you want to save the file if you try to exit the editor without saving first.</div><br/></div></div><div id="36429316" class="c"><input type="checkbox" id="c-36429316" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#36428132">parent</a><span>|</span><a href="#36428307">prev</a><span>|</span><a href="#36428806">next</a><span>|</span><label class="collapse" for="c-36429316">[-]</label><label class="expand" for="c-36429316">[1 more]</label></div><br/><div class="children"><div class="content">How would you use a terminal editor without a mouse and without remembering keyboard shortcuts?<p>Nano is considered one of the smallest &#x2F; simplest editors, and it shows you the keyboard shortcuts on the bottom of the window, is that what you&#x27;re wanting?</div><br/></div></div><div id="36428806" class="c"><input type="checkbox" id="c-36428806" checked=""/><div class="controls bullet"><span class="by">friend_and_foe</span><span>|</span><a href="#36428132">parent</a><span>|</span><a href="#36429316">prev</a><span>|</span><a href="#36428167">next</a><span>|</span><label class="collapse" for="c-36428806">[-]</label><label class="expand" for="c-36428806">[1 more]</label></div><br/><div class="children"><div class="content">Well, then Helix&#x2F;Kakouine&#x2F;Vim&#x2F;Neovim isn&#x27;t for you.<p>Doing things with a mouse is accessible <i>to you</i> because you&#x27;ve already learned how to do it. It&#x27;s not innately more intuitive or self describing in any way, the learning curve is just behind you.<p>I used GUI editors for a long time. I&#x27;d operate my computer with my right index finger and resisted any attempt to change that interface. I&#x27;d learn the usual Ctrl shortcuts and what not, that was about it. One day I finally dove into Helix specifically and not only am I not looking back, I am finding and using software specifically based on whether it uses vim like key interface. If it can&#x27;t it takes like 50% points off the software, going back to the mouse is just so painful I don&#x27;t know how I ever tolerated it. I feel like a chicken operating a typewriter.</div><br/></div></div><div id="36428167" class="c"><input type="checkbox" id="c-36428167" checked=""/><div class="controls bullet"><span class="by">DiggyJohnson</span><span>|</span><a href="#36428132">parent</a><span>|</span><a href="#36428806">prev</a><span>|</span><a href="#36428444">next</a><span>|</span><label class="collapse" for="c-36428167">[-]</label><label class="expand" for="c-36428167">[1 more]</label></div><br/><div class="children"><div class="content">Nano supports mouse, right?</div><br/></div></div><div id="36428444" class="c"><input type="checkbox" id="c-36428444" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36428132">parent</a><span>|</span><a href="#36428167">prev</a><span>|</span><label class="collapse" for="c-36428444">[-]</label><label class="expand" for="c-36428444">[1 more]</label></div><br/><div class="children"><div class="content">Tutorial &quot;optional&quot; is just weasel words for &quot;works like things I already know.&quot;  Problem is, especially in expert tooling, that everyone seems to know something else.</div><br/></div></div></div></div></div></div></div></div></div></body></html>