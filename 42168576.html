<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731920460311" as="style"/><link rel="stylesheet" href="styles.css?v=1731920460311"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nrk.neocities.org/articles/chibihash">ChibiHash: Small, Fast 64 bit hash function</a>Â <span class="domain">(<a href="https://nrk.neocities.org">nrk.neocities.org</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>4 comments</span></div><br/><div><div id="42169830" class="c"><input type="checkbox" id="c-42169830" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#42170385">next</a><span>|</span><label class="collapse" for="c-42169830">[-]</label><label class="expand" for="c-42169830">[1 more]</label></div><br/><div class="children"><div class="content">SMHasher&#x2F;Murmurhash author here - I don&#x27;t see anything fundamentally wrong with this hash function, it uses basically the same operations as the Murmur family (and a lot of other hashes at this point).<p>The handling of the &quot;tail&quot; of the key (the last &lt; 32 bytes) is slightly odd (the &quot;if (l &amp; 1) { mix 1 byte of key }&quot; happens before 8-byte chunks and 2-byte chunks), but if it passes SMHasher it should be fine for general use.</div><br/></div></div><div id="42170385" class="c"><input type="checkbox" id="c-42170385" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42169830">prev</a><span>|</span><a href="#42170306">next</a><span>|</span><label class="collapse" for="c-42170385">[-]</label><label class="expand" for="c-42170385">[1 more]</label></div><br/><div class="children"><div class="content">While the benefit of processing chunks of 8 bytes is obvious, what&#x27;s the purpose of grouping those into macrogroups of 4? Does it  trigger any implicit parallelism I failed to spot? Or is it just to end this phase with the 4 h[] having had the same amount of entropy, and thus starting the next one with h[0]?<p>&gt; The way it loads the 8 bytes is also important. The correct way is to load via shift+or
&gt; This is free of any UB, works on any alignment and on any machine regardless of it&#x27;s endianness. It&#x27;s also fast, gcc and clang recognize this pattern and optimize it into a single mov instruction on x86 targets.<p>Is a single MOV instruction still fast when the 8 bytes begin on an odd address?</div><br/></div></div><div id="42170306" class="c"><input type="checkbox" id="c-42170306" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#42170385">prev</a><span>|</span><label class="collapse" for="c-42170306">[-]</label><label class="expand" for="c-42170306">[1 more]</label></div><br/><div class="children"><div class="content">How does it compare to CRC64, for the purpose of detecting errors?</div><br/></div></div></div></div></div></div></div></body></html>