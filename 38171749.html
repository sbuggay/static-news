<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699520478082" as="style"/><link rel="stylesheet" href="styles.css?v=1699520478082"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://devblogs.microsoft.com/oldnewthing/20231103-00/?p=108966">Why does unsafe multithreaded std:unordered_map crash more than std:map?</a> <span class="domain">(<a href="https://devblogs.microsoft.com">devblogs.microsoft.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>51 comments</span></div><br/><div><div id="38200990" class="c"><input type="checkbox" id="c-38200990" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#38199717">next</a><span>|</span><label class="collapse" for="c-38200990">[-]</label><label class="expand" for="c-38200990">[14 more]</label></div><br/><div class="children"><div class="content">A fascinating design decision of Hashtable in .NET is its support for multiple readers AND a single writer.<p>In C++ or Rust, we get multiple readers OR a single writer. Shared ref or exclusive mut, pick one. But in .NET we have AND not OR: one writer AND multiple readers, all concurrent.<p>This works because .NET&#x27;s GC can tolerate the race. A writer may trigger a table rehash, and a reader will read either the old or new table. If the reader loads the old table, it won&#x27;t be deallocated until it&#x27;s done: the GC will keep it alive.<p>Any cool uses of this one writer AND multiple readers?<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.collections.hashtable" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.collecti...</a></div><br/><div id="38202454" class="c"><input type="checkbox" id="c-38202454" checked=""/><div class="controls bullet"><span class="by">afc</span><span>|</span><a href="#38200990">parent</a><span>|</span><a href="#38202498">next</a><span>|</span><label class="collapse" for="c-38202454">[-]</label><label class="expand" for="c-38202454">[1 more]</label></div><br/><div class="children"><div class="content">How about many readers and <i>zero</i> writers? :)<p>For my text editor, I went with an immutable balanced tree. I was surprised by how easily I was about to implement all operations I needed with reasonable runtime complexity (log N mostly, operations like &quot;give me a copy with element at position i removed&quot;): <a href="https:&#x2F;&#x2F;github.com&#x2F;alefore&#x2F;edge&#x2F;blob&#x2F;master&#x2F;src&#x2F;language&#x2F;const_tree.h">https:&#x2F;&#x2F;github.com&#x2F;alefore&#x2F;edge&#x2F;blob&#x2F;master&#x2F;src&#x2F;language&#x2F;con...</a><p>I use this throughout my editor. For example, I load a file into a sequence of lines represented here: <a href="https:&#x2F;&#x2F;github.com&#x2F;alefore&#x2F;edge&#x2F;blob&#x2F;8fdf7f76ffa167497a7e9e9228b26b1f2dcf95e9&#x2F;src&#x2F;language&#x2F;text&#x2F;line_sequence.h#L21">https:&#x2F;&#x2F;github.com&#x2F;alefore&#x2F;edge&#x2F;blob&#x2F;8fdf7f76ffa167497a7e9e9...</a><p>I found that the good performance, relatively straightforward implementation and <i>very strong thread safety</i> (making the data immutable means a whole class of problems just disappears) works very well.</div><br/></div></div><div id="38202498" class="c"><input type="checkbox" id="c-38202498" checked=""/><div class="controls bullet"><span class="by">adhesive_wombat</span><span>|</span><a href="#38200990">parent</a><span>|</span><a href="#38202454">prev</a><span>|</span><a href="#38201385">next</a><span>|</span><label class="collapse" for="c-38202498">[-]</label><label class="expand" for="c-38202498">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Shared ref or exclusive mut<p>There&#x27;s std::shared_mutex, which allows multiple readers and a writer.</div><br/><div id="38202605" class="c"><input type="checkbox" id="c-38202605" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38200990">root</a><span>|</span><a href="#38202498">parent</a><span>|</span><a href="#38201385">next</a><span>|</span><label class="collapse" for="c-38202605">[-]</label><label class="expand" for="c-38202605">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly the scenario your parent is describing. You can have (multiple) readers <i>or</i> a single writer. You cannot have both.<p>The analogous Rust type is std::sync::RwLock&lt;T&gt; (but as with Mutex, RwLock is a wrapper, so it is actually protecting something inside it, not just providing the raw mutex type).<p>If you&#x27;ve been using std::shared_mutex assuming you can have both then, I guess it&#x27;s good luck that you didn&#x27;t cause a deadlock of some sort, but at least this API unlike most C++ APIs isn&#x27;t just &quot;LOL, if you use this wrong it&#x27;s Undefined Behaviour, all bets are off, goodbye&quot; in the respect that matters to you.</div><br/></div></div></div></div><div id="38201385" class="c"><input type="checkbox" id="c-38201385" checked=""/><div class="controls bullet"><span class="by">iknowstuff</span><span>|</span><a href="#38200990">parent</a><span>|</span><a href="#38202498">prev</a><span>|</span><a href="#38201067">next</a><span>|</span><label class="collapse" for="c-38201385">[-]</label><label class="expand" for="c-38201385">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;lib.rs&#x2F;crates&#x2F;dashmap" rel="nofollow noreferrer">https:&#x2F;&#x2F;lib.rs&#x2F;crates&#x2F;dashmap</a></div><br/><div id="38201568" class="c"><input type="checkbox" id="c-38201568" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#38200990">root</a><span>|</span><a href="#38201385">parent</a><span>|</span><a href="#38201067">next</a><span>|</span><label class="collapse" for="c-38201568">[-]</label><label class="expand" for="c-38201568">[1 more]</label></div><br/><div class="children"><div class="content">First time seeing dashmap, but a cursory inspection shows it works via sharded locks:<p><pre><code>    pub struct DashMap&lt;K, V, S = RandomState&gt; {
        shift: usize,
        shards: Box&lt;[RwLock&lt;HashMap&lt;K, V, S&gt;&gt;]&gt;,
        hasher: S,
    }
</code></pre>
so an array of RwLocks.<p>That&#x27;s quite different than what .NET offers, which is multiple readers and a single writer with NO locks outside of the allocator&#x2F;GC.<p>I&#x27;m not shilling for .NET (I&#x27;ve never written a .NET app) but it does have a really cool hash table.</div><br/></div></div></div></div><div id="38201067" class="c"><input type="checkbox" id="c-38201067" checked=""/><div class="controls bullet"><span class="by">leosanchez</span><span>|</span><a href="#38200990">parent</a><span>|</span><a href="#38201385">prev</a><span>|</span><a href="#38201259">next</a><span>|</span><label class="collapse" for="c-38201067">[-]</label><label class="expand" for="c-38201067">[2 more]</label></div><br/><div class="children"><div class="content">Is it same for Dictionary? .People hardly use Hashtable these day</div><br/><div id="38202068" class="c"><input type="checkbox" id="c-38202068" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#38200990">root</a><span>|</span><a href="#38201067">parent</a><span>|</span><a href="#38201259">next</a><span>|</span><label class="collapse" for="c-38202068">[-]</label><label class="expand" for="c-38202068">[1 more]</label></div><br/><div class="children"><div class="content">No, the documentation for Dictionary doesn’t make this guarantee, it’s explicit that readers are only allowed as long as the collection isn’t modified: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.collections.generic.dictionary-2?view=net-7.0#thread-safety" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.collecti...</a><p>Maybe that guarantee was too strong and prevented a more efficient implementation.</div><br/></div></div></div></div><div id="38201259" class="c"><input type="checkbox" id="c-38201259" checked=""/><div class="controls bullet"><span class="by">abacate</span><span>|</span><a href="#38200990">parent</a><span>|</span><a href="#38201067">prev</a><span>|</span><a href="#38199717">next</a><span>|</span><label class="collapse" for="c-38201259">[-]</label><label class="expand" for="c-38201259">[6 more]</label></div><br/><div class="children"><div class="content">You can easily write a concurrent hash table in C++ or Rust. I fail to understand your point.</div><br/><div id="38201412" class="c"><input type="checkbox" id="c-38201412" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#38200990">root</a><span>|</span><a href="#38201259">parent</a><span>|</span><a href="#38199717">next</a><span>|</span><label class="collapse" for="c-38201412">[-]</label><label class="expand" for="c-38201412">[5 more]</label></div><br/><div class="children"><div class="content">How? I honestly don&#x27;t know how to do it in C++ or Rust, without using exotic techniques like hazard pointers.</div><br/><div id="38202050" class="c"><input type="checkbox" id="c-38202050" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38200990">root</a><span>|</span><a href="#38201412">parent</a><span>|</span><a href="#38201510">next</a><span>|</span><label class="collapse" for="c-38202050">[-]</label><label class="expand" for="c-38202050">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;docs.rs&#x2F;arc-swap&#x2F;latest&#x2F;arc_swap&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;arc-swap&#x2F;latest&#x2F;arc_swap&#x2F;</a> Is a basic rcu mechanism that doesn’t have the exotic requirements of urcu (but probably not as efficient). If you make the interior nodes of your data structure Arc (assuming they are large or expensive enough to warrant it), then updating is relatively fast. Of course you also want to be careful here to batch as many changes at once if you’re doing this at all frequently.<p>But ultimately I don’t recall anything special about the runtime semantics the first time I came across this technique which if I recall correctly came from the brilliant folk at Azul Systems for their JVM. You just need a way to atomically adjust certain nodes. And if I recall correctly Azul’s supported N concurrent writers that were all wait free (ie every thread participated in forward progress)</div><br/></div></div><div id="38201510" class="c"><input type="checkbox" id="c-38201510" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#38200990">root</a><span>|</span><a href="#38201412">parent</a><span>|</span><a href="#38202050">prev</a><span>|</span><a href="#38201670">next</a><span>|</span><label class="collapse" for="c-38201510">[-]</label><label class="expand" for="c-38201510">[2 more]</label></div><br/><div class="children"><div class="content">This seems to be an implementation built on RCU, iiuc: <a href="https:&#x2F;&#x2F;github.com&#x2F;urcu&#x2F;userspace-rcu&#x2F;blob&#x2F;master&#x2F;src&#x2F;rculfhash.c">https:&#x2F;&#x2F;github.com&#x2F;urcu&#x2F;userspace-rcu&#x2F;blob&#x2F;master&#x2F;src&#x2F;rculfh...</a></div><br/><div id="38201672" class="c"><input type="checkbox" id="c-38201672" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#38200990">root</a><span>|</span><a href="#38201510">parent</a><span>|</span><a href="#38201670">next</a><span>|</span><label class="collapse" for="c-38201672">[-]</label><label class="expand" for="c-38201672">[1 more]</label></div><br/><div class="children"><div class="content">This looks rough: it spawns background &quot;worker threads&quot; for tasks like lazy resizing; and even with that it still sometimes takes locks (see resize_mutex).</div><br/></div></div></div></div><div id="38201670" class="c"><input type="checkbox" id="c-38201670" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38200990">root</a><span>|</span><a href="#38201412">parent</a><span>|</span><a href="#38201510">prev</a><span>|</span><a href="#38199717">next</a><span>|</span><label class="collapse" for="c-38201670">[-]</label><label class="expand" for="c-38201670">[1 more]</label></div><br/><div class="children"><div class="content">An atomic reference count seems sufficient, but I could be wrong.</div><br/></div></div></div></div></div></div></div></div><div id="38199717" class="c"><input type="checkbox" id="c-38199717" checked=""/><div class="controls bullet"><span class="by">xuhu</span><span>|</span><a href="#38200990">prev</a><span>|</span><a href="#38201453">next</a><span>|</span><label class="collapse" for="c-38199717">[-]</label><label class="expand" for="c-38199717">[3 more]</label></div><br/><div class="children"><div class="content">From the article: std::map inserts are O(log n) while std::unordered_map inserts are O(1) and rehashes are O(n). Concurrent rehashes have a high chance of crashing, but I don&#x27;t see how it follows that overall unordered_map crashes more than std::map.<p>Maybe it&#x27;s beacause std::map tree nodes don&#x27;t get reallocated while unordered_map hash buckets do ?</div><br/><div id="38199907" class="c"><input type="checkbox" id="c-38199907" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38199717">parent</a><span>|</span><a href="#38201269">next</a><span>|</span><label class="collapse" for="c-38199907">[-]</label><label class="expand" for="c-38199907">[1 more]</label></div><br/><div class="children"><div class="content">Rehashing the table affects every element. Rebalancing the tree only affects a few elements, and probably not one being concurrently accessed.</div><br/></div></div><div id="38201269" class="c"><input type="checkbox" id="c-38201269" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#38199717">parent</a><span>|</span><a href="#38199907">prev</a><span>|</span><a href="#38201453">next</a><span>|</span><label class="collapse" for="c-38201269">[-]</label><label class="expand" for="c-38201269">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s walk through it in more detail.<p>Suppose you have two threads doing writes at a rate of r per second. Suppose that it takes time t to do an operation. Suppose that concurrent operations have a probability p of crashing. What rate do crashes happen at?<p>Well, the one thread spends time t * r per second in the operation. The other spends the same. So you spend time (r * t)^2 per second with concurrent accesses, and crashes happen at a rate p * (r * t)^2.<p>Now let&#x27;s look at the normal case for a hash insert. t is small and constant in the size of the collection. p is proportional to 1&#x2F;n. And therefore collisions happen at a rate of O((r * t)^2 &#x2F; n).<p>Now let&#x27;s think about the red-black tree. Exact numbers are calculated. While the writing part is at most O(log(n)). But on average you spend time O(log(n)) finding where to write, and only write O(1) nodes. Think half the time you only write once, 1&#x2F;4 of the time you write once, rebalance once. 1&#x2F;8 of the time you write once and rebalance twice. The result is complicated to analyze, but it works out as worse than the regular hash operation by a constant factor. So crashes happen at a rate O((r * t)^2 &#x2F; n) with worse constants.<p>Now let&#x27;s look at the resize operation. This works very differently. The first thread encounters resize every n operations, for a rate r&#x2F;n. A resize takes time O(t * n). If any write comes in during that resize, the other thread will also do a resize, and they will crash. So the odds that we crash is the time of the operation, times the rate at which writes come, which is O(r * t * n). Multiplying this by the rate we get a probability of O(r&#x2F;n * r * t * n) = O(r^2 * t).<p>The previous equation was smaller by a factor of t&#x2F;n. But remember, t is a very small time (operations are fast) and n tends to be reasonably large (the size of the collection). The result is that race conditions happen dramatically more often for resizes of hashes than any other operation.</div><br/></div></div></div></div><div id="38201453" class="c"><input type="checkbox" id="c-38201453" checked=""/><div class="controls bullet"><span class="by">Racing0461</span><span>|</span><a href="#38199717">prev</a><span>|</span><a href="#38199710">next</a><span>|</span><label class="collapse" for="c-38201453">[-]</label><label class="expand" for="c-38201453">[1 more]</label></div><br/><div class="children"><div class="content">As soon as i saw microsoft.com, i knew this was gonna be a raymond chen article.</div><br/></div></div><div id="38199710" class="c"><input type="checkbox" id="c-38199710" checked=""/><div class="controls bullet"><span class="by">PessimalDecimal</span><span>|</span><a href="#38201453">prev</a><span>|</span><a href="#38201420">next</a><span>|</span><label class="collapse" for="c-38199710">[-]</label><label class="expand" for="c-38199710">[3 more]</label></div><br/><div class="children"><div class="content">What would be a good way to test the author&#x27;s hunch? Just instrument std::unordered_map and trace an execution until a crash occurs?</div><br/><div id="38199876" class="c"><input type="checkbox" id="c-38199876" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38199710">parent</a><span>|</span><a href="#38201420">next</a><span>|</span><label class="collapse" for="c-38199876">[-]</label><label class="expand" for="c-38199876">[2 more]</label></div><br/><div class="children"><div class="content">Ship v1. Collect crash reports. Switch collections. Ship v1.1. Collect crash reports. Compare.</div><br/><div id="38200038" class="c"><input type="checkbox" id="c-38200038" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38199710">root</a><span>|</span><a href="#38199876">parent</a><span>|</span><a href="#38201420">next</a><span>|</span><label class="collapse" for="c-38200038">[-]</label><label class="expand" for="c-38200038">[1 more]</label></div><br/><div class="children"><div class="content">Ship v1.2. Apologize to your users.</div><br/></div></div></div></div></div></div><div id="38201420" class="c"><input type="checkbox" id="c-38201420" checked=""/><div class="controls bullet"><span class="by">hindsightbias</span><span>|</span><a href="#38199710">prev</a><span>|</span><a href="#38200118">next</a><span>|</span><label class="collapse" for="c-38201420">[-]</label><label class="expand" for="c-38201420">[3 more]</label></div><br/><div class="children"><div class="content">This article needs a mutex.</div><br/><div id="38201687" class="c"><input type="checkbox" id="c-38201687" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#38201420">parent</a><span>|</span><a href="#38200118">next</a><span>|</span><label class="collapse" for="c-38201687">[-]</label><label class="expand" for="c-38201687">[2 more]</label></div><br/><div class="children"><div class="content">when you&#x27;re done with the read lock, may i please acquire it?</div><br/><div id="38201897" class="c"><input type="checkbox" id="c-38201897" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#38201420">root</a><span>|</span><a href="#38201687">parent</a><span>|</span><a href="#38200118">next</a><span>|</span><label class="collapse" for="c-38201897">[-]</label><label class="expand" for="c-38201897">[1 more]</label></div><br/><div class="children"><div class="content">Mom says it&#x27;s my turn on the read lock</div><br/></div></div></div></div></div></div><div id="38200118" class="c"><input type="checkbox" id="c-38200118" checked=""/><div class="controls bullet"><span class="by">mathiasgredal</span><span>|</span><a href="#38201420">prev</a><span>|</span><a href="#38199817">next</a><span>|</span><label class="collapse" for="c-38200118">[-]</label><label class="expand" for="c-38200118">[11 more]</label></div><br/><div class="children"><div class="content">Anyone making multithreaded code in c++ should be using thread sanitizer. Whether or not a specific datastruture crashes more in multithreaded code will not matter, since tsan will issue a warning on all unsafe accesses.</div><br/><div id="38202484" class="c"><input type="checkbox" id="c-38202484" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#38200118">parent</a><span>|</span><a href="#38200581">next</a><span>|</span><label class="collapse" for="c-38202484">[-]</label><label class="expand" for="c-38202484">[1 more]</label></div><br/><div class="children"><div class="content">Thread sanitizer doesn&#x27;t understand fences. It seems relacy is the only one that does.<p>If anyone knows how to make relacy run a somewhat fair scheduler please let me know - it told me a server thread that waited for work never made any progress, but it also never gave a client thread any cycles to submit work so that wasn&#x27;t very informative.<p>(edit: just occurred to me I can probably fake it adequately by having a yield that makes the current thread start playing the role of the other service, coroutine style)</div><br/></div></div><div id="38200581" class="c"><input type="checkbox" id="c-38200581" checked=""/><div class="controls bullet"><span class="by">moregrist</span><span>|</span><a href="#38200118">parent</a><span>|</span><a href="#38202484">prev</a><span>|</span><a href="#38200428">next</a><span>|</span><label class="collapse" for="c-38200581">[-]</label><label class="expand" for="c-38200581">[5 more]</label></div><br/><div class="children"><div class="content">Unfortunately tsan is a pretty big performance hit (5x-15x with 5x-10x increase in memory) and has a non-zero false positive rate. So it’s not a “use almost always during development thing” like the address sanitizer is.<p>That said, it’s can be <i>really</i> helpful when you suspect a race condition.</div><br/><div id="38200783" class="c"><input type="checkbox" id="c-38200783" checked=""/><div class="controls bullet"><span class="by">1over137</span><span>|</span><a href="#38200118">root</a><span>|</span><a href="#38200581">parent</a><span>|</span><a href="#38201114">next</a><span>|</span><label class="collapse" for="c-38200783">[-]</label><label class="expand" for="c-38200783">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, it has a near-zero false positive rate though.</div><br/></div></div><div id="38201114" class="c"><input type="checkbox" id="c-38201114" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#38200118">root</a><span>|</span><a href="#38200581">parent</a><span>|</span><a href="#38200783">prev</a><span>|</span><a href="#38200428">next</a><span>|</span><label class="collapse" for="c-38201114">[-]</label><label class="expand" for="c-38201114">[3 more]</label></div><br/><div class="children"><div class="content">After enough YOE you can perform tsan-like static analysis just by reading the code.</div><br/><div id="38201424" class="c"><input type="checkbox" id="c-38201424" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#38200118">root</a><span>|</span><a href="#38201114">parent</a><span>|</span><a href="#38201222">next</a><span>|</span><label class="collapse" for="c-38201424">[-]</label><label class="expand" for="c-38201424">[1 more]</label></div><br/><div class="children"><div class="content">Maybe if you work on a tiny codebase.</div><br/></div></div><div id="38201222" class="c"><input type="checkbox" id="c-38201222" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#38200118">root</a><span>|</span><a href="#38201114">parent</a><span>|</span><a href="#38201424">prev</a><span>|</span><a href="#38200428">next</a><span>|</span><label class="collapse" for="c-38201222">[-]</label><label class="expand" for="c-38201222">[1 more]</label></div><br/><div class="children"><div class="content">YOE = years of experience</div><br/></div></div></div></div></div></div><div id="38200428" class="c"><input type="checkbox" id="c-38200428" checked=""/><div class="controls bullet"><span class="by">uluyol</span><span>|</span><a href="#38200118">parent</a><span>|</span><a href="#38200581">prev</a><span>|</span><a href="#38201522">next</a><span>|</span><label class="collapse" for="c-38200428">[-]</label><label class="expand" for="c-38200428">[2 more]</label></div><br/><div class="children"><div class="content">Just a minor point: while tsan is extremely helpful, it is not guaranteed to catch all data races.</div><br/><div id="38201488" class="c"><input type="checkbox" id="c-38201488" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#38200118">root</a><span>|</span><a href="#38200428">parent</a><span>|</span><a href="#38201522">next</a><span>|</span><label class="collapse" for="c-38201488">[-]</label><label class="expand" for="c-38201488">[1 more]</label></div><br/><div class="children"><div class="content">Matches my experience. It does sometimes warn about race in 3rd party library (that are actual race usually, even though there might not be issues in practice) but then you can add suppression when fixing upstream is not an option.</div><br/></div></div></div></div><div id="38201522" class="c"><input type="checkbox" id="c-38201522" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#38200118">parent</a><span>|</span><a href="#38200428">prev</a><span>|</span><a href="#38200815">next</a><span>|</span><label class="collapse" for="c-38201522">[-]</label><label class="expand" for="c-38201522">[1 more]</label></div><br/><div class="children"><div class="content">Tsan doesn’t understand mach semaphores unfortunately.</div><br/></div></div></div></div><div id="38199817" class="c"><input type="checkbox" id="c-38199817" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38200118">prev</a><span>|</span><a href="#38200618">next</a><span>|</span><label class="collapse" for="c-38199817">[-]</label><label class="expand" for="c-38199817">[2 more]</label></div><br/><div class="children"><div class="content">Why does running red lights crash more than driving the wrong way down a one-way street? Discuss among yourselves ...</div><br/></div></div><div id="38200618" class="c"><input type="checkbox" id="c-38200618" checked=""/><div class="controls bullet"><span class="by">moregrist</span><span>|</span><a href="#38199817">prev</a><span>|</span><a href="#38200656">next</a><span>|</span><label class="collapse" for="c-38200618">[-]</label><label class="expand" for="c-38200618">[11 more]</label></div><br/><div class="children"><div class="content">I’m stunned that this article exists and was published by Microsoft. Unsafe access to either is clearly undefined behavior. Discussing which one is more or less undefined is like discussing whether it’s safer to run with scissors or a knife: it doesn’t really matter because you’re going to cut yourself badly and possibly in life-changing ways.<p>Please protect your STL data structures with a mutex. Please keep your thread communications sane. There’s no reason to think through why one is more prone to explosion than another; any conclusions you draw are at best only relevant to your current compiler and STL implementation, and maybe only during some phases of the moon.</div><br/><div id="38200688" class="c"><input type="checkbox" id="c-38200688" checked=""/><div class="controls bullet"><span class="by">pinum</span><span>|</span><a href="#38200618">parent</a><span>|</span><a href="#38201484">next</a><span>|</span><label class="collapse" for="c-38200688">[-]</label><label class="expand" for="c-38200688">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The customer understood that their code was broken either way. They just were curious why unordered_map seems to demonstrate the problem more clearly.&quot;<p>Seems reasonable to me. It&#x27;s an interesting question even if any given answer is only valid under narrow conditions.</div><br/></div></div><div id="38201484" class="c"><input type="checkbox" id="c-38201484" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#38200618">parent</a><span>|</span><a href="#38200688">prev</a><span>|</span><a href="#38200718">next</a><span>|</span><label class="collapse" for="c-38201484">[-]</label><label class="expand" for="c-38201484">[1 more]</label></div><br/><div class="children"><div class="content">Raymond Chen has been at Microsoft since 92 on the shell team and has worked on  OS&#x2F;2, Windows 95, DirectX and others but is more well known for his 2003 blog &quot;The Old New Thing&quot; which does nerdy deep dives into the internals of Windows &#x2F; Microsoft-verse and the various ways customers abuse it.<p>Have you ever wondered 
what’s up with the CF_SYLK and CF_DIF clipboard formats? [0]<p>Or why did the message on the Start menu change from Start to Ship It! for one build? [1]<p>Or how about filling in some gaps in the story of Space Cadet Pinball on 64-bit Windows [2]<p>[0] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20200226-00&#x2F;?p=103489" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20200226-00&#x2F;?p=10...</a><p>[1] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20200505-00&#x2F;?p=103727" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20200505-00&#x2F;?p=10...</a><p>[2] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20220106-00&#x2F;?p=106122" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20220106-00&#x2F;?p=10...</a></div><br/></div></div><div id="38200718" class="c"><input type="checkbox" id="c-38200718" checked=""/><div class="controls bullet"><span class="by">yalok</span><span>|</span><a href="#38200618">parent</a><span>|</span><a href="#38201484">prev</a><span>|</span><a href="#38201678">next</a><span>|</span><label class="collapse" for="c-38200718">[-]</label><label class="expand" for="c-38200718">[2 more]</label></div><br/><div class="children"><div class="content">Why stunned? The author reiterates 2 times that neither maps should be used in unsafe way.<p>Look at this from the point of code analysis - if &quot;a bit more thread-safe&quot; map is used - you have less chances to detect the problem in local testing &amp; and may be surprised in prod. And, you may be even more surprised when switching to unordered map.<p>Usually, any big app has a huge tail of very rare crashes that nobody has time to fix, ever. Those rare crashes are indistinguishable from some system&#x2F;hardware related faults (system  OOM, system trying to kill an app, battery dying, bit flipping due to radiation&#x2F;faulty silicon).  And that&#x27;s the point - if you are planning to change map to unordered map - look at the crashes list around map invocations and try to understand, if any of them are due to multithreading and not system&#x2F;hw...</div><br/><div id="38201200" class="c"><input type="checkbox" id="c-38201200" checked=""/><div class="controls bullet"><span class="by">yellowstuff</span><span>|</span><a href="#38200618">root</a><span>|</span><a href="#38200718">parent</a><span>|</span><a href="#38201678">next</a><span>|</span><label class="collapse" for="c-38201200">[-]</label><label class="expand" for="c-38201200">[1 more]</label></div><br/><div class="children"><div class="content">Clearly the author should have stated a third time not to violate thread safety, to prevent the article from being misinterpreted.</div><br/></div></div></div></div><div id="38201678" class="c"><input type="checkbox" id="c-38201678" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38200618">parent</a><span>|</span><a href="#38200718">prev</a><span>|</span><a href="#38201688">next</a><span>|</span><label class="collapse" for="c-38201678">[-]</label><label class="expand" for="c-38201678">[1 more]</label></div><br/><div class="children"><div class="content">The counterargument to the IMHO highly destructive attitude of &quot;learned ignorance&quot; that you&#x27;re espousing is easily summed up in one sentence: &quot;If you don&#x27;t break anything, you&#x27;ll never learn how to fix anything.&quot;<p>Asking and answering &quot;why&quot; is an important educational process. I&#x27;ve met other developers like you, and quite frankly they&#x27;ve always been mediocre to abysmal in their work, especially when debugging, because they&#x27;ve almost completely lost the ability to reason and hypothesise.</div><br/></div></div><div id="38201688" class="c"><input type="checkbox" id="c-38201688" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#38200618">parent</a><span>|</span><a href="#38201678">prev</a><span>|</span><a href="#38201011">next</a><span>|</span><label class="collapse" for="c-38201688">[-]</label><label class="expand" for="c-38201688">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like discussing if you have a better chance surviving against a Tiger or a Lion when armed with a machete.  I&#x27;m not jumping into the arena with either one, but it can still make for good conversation.</div><br/></div></div><div id="38201011" class="c"><input type="checkbox" id="c-38201011" checked=""/><div class="controls bullet"><span class="by">ironman1478</span><span>|</span><a href="#38200618">parent</a><span>|</span><a href="#38201688">prev</a><span>|</span><a href="#38200870">next</a><span>|</span><label class="collapse" for="c-38201011">[-]</label><label class="expand" for="c-38201011">[1 more]</label></div><br/><div class="children"><div class="content">The article isn&#x27;t an endorsement of using thread unsafe structures without protection in a multithreaded context. It&#x27;s simply analyzing why the bug was less prevalent with one data structure vs. another. It&#x27;s an interesting question.</div><br/></div></div><div id="38200870" class="c"><input type="checkbox" id="c-38200870" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#38200618">parent</a><span>|</span><a href="#38201011">prev</a><span>|</span><a href="#38201446">next</a><span>|</span><label class="collapse" for="c-38200870">[-]</label><label class="expand" for="c-38200870">[1 more]</label></div><br/><div class="children"><div class="content">This is essentially a personal blog of a long-term Microsoft employee on all sorts of interesting technical topics.<p>It isn&#x27;t an official Microsoft publication.</div><br/></div></div><div id="38201446" class="c"><input type="checkbox" id="c-38201446" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#38200618">parent</a><span>|</span><a href="#38200870">prev</a><span>|</span><a href="#38200812">next</a><span>|</span><label class="collapse" for="c-38201446">[-]</label><label class="expand" for="c-38201446">[1 more]</label></div><br/><div class="children"><div class="content">One of today&#x27;s lucky 10,000! Raymond Chen is a gem. His blog has many good features, I&#x27;ll let you discover then for yourself.<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1053&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;1053&#x2F;</a></div><br/></div></div></div></div><div id="38200656" class="c"><input type="checkbox" id="c-38200656" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#38200618">prev</a><span>|</span><a href="#38202106">next</a><span>|</span><label class="collapse" for="c-38200656">[-]</label><label class="expand" for="c-38200656">[1 more]</label></div><br/><div class="children"><div class="content">yet another reason to switch to rust</div><br/></div></div><div id="38202106" class="c"><input type="checkbox" id="c-38202106" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#38200656">prev</a><span>|</span><label class="collapse" for="c-38202106">[-]</label><label class="expand" for="c-38202106">[1 more]</label></div><br/><div class="children"><div class="content">Given that “crash” in C++ has a 99% chance to mean “security issue”, and given that I have seen people “pragmatically” go with a solution that “crashes less” in the wild, I’m convinced that nothing good comes out of this line of reasoning.</div><br/></div></div></div></div></div></div></div></body></html>