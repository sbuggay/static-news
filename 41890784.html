<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729414851290" as="style"/><link rel="stylesheet" href="styles.css?v=1729414851290"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2310.09423">QUIC is not quick enough over fast internet</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>carlos-menezes</span> | <span>209 comments</span></div><br/><div><div id="41893322" class="c"><input type="checkbox" id="c-41893322" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#41891721">next</a><span>|</span><label class="collapse" for="c-41893322">[-]</label><label class="expand" for="c-41893322">[9 more]</label></div><br/><div class="children"><div class="content">Industry will do absolutely anything, except making lightweight sites.<p>We had instant internet in the late 90s, if you were lucky enough to have a fast connection. The pages were small and there were barely any javascript. You can still find such fast loading lightweight pages today and the experience is almost surreal.<p>It feels like the page has completely loaded before you even released the mousebutton.<p>If only the user experience were better it might have been tolerable but we didn&#x27;t get that either.</div><br/><div id="41893360" class="c"><input type="checkbox" id="c-41893360" checked=""/><div class="controls bullet"><span class="by">OtomotO</span><span>|</span><a href="#41893322">parent</a><span>|</span><a href="#41893919">next</a><span>|</span><label class="collapse" for="c-41893360">[-]</label><label class="expand" for="c-41893360">[4 more]</label></div><br/><div class="children"><div class="content">I am currently de-javascripting a React app of some project I am working on.<p>It&#x27;s a blast. It&#x27;s faster and way more resilient. No more state desync between frontend and backend.<p>I admit there is a minimum of javascript (currently a few hundred lines) for convenience.<p>I&#x27;ll add a bit more to add the illusion this is still a SPA.<p>I&#x27;ll kill about 40k lines of React that way and about 20k lines of Kotlin.<p>I&#x27;ll have to rewrite about 30k lines of backend code though.<p>Still, I love it.</div><br/><div id="41893417" class="c"><input type="checkbox" id="c-41893417" checked=""/><div class="controls bullet"><span class="by">NetOpWibby</span><span>|</span><a href="#41893322">root</a><span>|</span><a href="#41893360">parent</a><span>|</span><a href="#41893847">next</a><span>|</span><label class="collapse" for="c-41893417">[-]</label><label class="expand" for="c-41893417">[1 more]</label></div><br/><div class="children"><div class="content">Nature is healing. Love to see it.</div><br/></div></div><div id="41893847" class="c"><input type="checkbox" id="c-41893847" checked=""/><div class="controls bullet"><span class="by">pushupentry1219</span><span>|</span><a href="#41893322">root</a><span>|</span><a href="#41893360">parent</a><span>|</span><a href="#41893417">prev</a><span>|</span><a href="#41893919">next</a><span>|</span><label class="collapse" for="c-41893847">[-]</label><label class="expand" for="c-41893847">[2 more]</label></div><br/><div class="children"><div class="content">Honestly I used to be on the strict noscript JavaScript hate train.<p>But if your site works fast. Loads fast. With _a little_ JS that actually improves the functionality+usability in? I think that&#x27;s completely fine. Minimal JS for the win.</div><br/><div id="41893980" class="c"><input type="checkbox" id="c-41893980" checked=""/><div class="controls bullet"><span class="by">OtomotO</span><span>|</span><a href="#41893322">root</a><span>|</span><a href="#41893847">parent</a><span>|</span><a href="#41893919">next</a><span>|</span><label class="collapse" for="c-41893980">[-]</label><label class="expand" for="c-41893980">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely.<p>I want the basic functionality to work without JS.<p>But we have a working application and users are not hating it and used to it.<p>We rely on modals heavily. And for that I added (custom) JS. It&#x27;s way simpler than alternatives and some things we do are not even possible without JS&#x2F;WASM (via JS apis to manipulate the DOM) today.<p>I am pragmatic.<p>But as you mentioned it, personally I also use NoScript a lot and if a site refuses to load without JS it&#x27;s a hard sell to me if I don&#x27;t know it already.</div><br/></div></div></div></div></div></div><div id="41893919" class="c"><input type="checkbox" id="c-41893919" checked=""/><div class="controls bullet"><span class="by">kodama-lens</span><span>|</span><a href="#41893322">parent</a><span>|</span><a href="#41893360">prev</a><span>|</span><a href="#41893625">next</a><span>|</span><label class="collapse" for="c-41893919">[-]</label><label class="expand" for="c-41893919">[1 more]</label></div><br/><div class="children"><div class="content">When I was finishing university I bought into the framework-based web-development hype. I thought that &quot;enterprise&quot; web-development has to be done this way. So I got some experience by migrating my homepage to a static VUE.JS version.
Binding view and state by passing the variables name as a sting felt off, extending the build env seemed unnecessary complex and everything was slow and has to be done a certain way. 
But since everyone is using this, this must be right I thought.<p>I got over this view and just finished the new version of my page. Raw HTML with some static-site-generator templating. The HTML size went down 90%, the JS usage went down 97% and build time is now 2s instead of 20s. The user experience is better and i get 30% more hits since the new version.<p>The web could be so nice of we used less of it.</div><br/></div></div><div id="41893625" class="c"><input type="checkbox" id="c-41893625" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41893322">parent</a><span>|</span><a href="#41893919">prev</a><span>|</span><a href="#41891721">next</a><span>|</span><label class="collapse" for="c-41893625">[-]</label><label class="expand" for="c-41893625">[3 more]</label></div><br/><div class="children"><div class="content">Lightweight sites don&#x27;t make for shinny CVs.<p>Even on the backend, now the golden goose is to sell microservices, via headless SaaS products connected via APIs, that certainly is going to perform.<p><a href="https:&#x2F;&#x2F;macharchitecture.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;macharchitecture.com&#x2F;</a><p>However if those are the shovels people are going to buy, then those are the ones we have to stockpile, so is the IT world.</div><br/><div id="41893767" class="c"><input type="checkbox" id="c-41893767" checked=""/><div class="controls bullet"><span class="by">Zanfa</span><span>|</span><a href="#41893322">root</a><span>|</span><a href="#41893625">parent</a><span>|</span><a href="#41891721">next</a><span>|</span><label class="collapse" for="c-41893767">[-]</label><label class="expand" for="c-41893767">[2 more]</label></div><br/><div class="children"><div class="content">My feeling is that the microservice fad has passed… for now. But I’m sure it’ll be resurrected in a few years with a different name.</div><br/><div id="41893799" class="c"><input type="checkbox" id="c-41893799" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41893322">root</a><span>|</span><a href="#41893767">parent</a><span>|</span><a href="#41891721">next</a><span>|</span><label class="collapse" for="c-41893799">[-]</label><label class="expand" for="c-41893799">[1 more]</label></div><br/><div class="children"><div class="content">Nah, it is only really taking off now in enterprise consulting, with products going SaaS and what used to extension points via libraries, is now only possible via Webhooks and API calls, that naturally have to be done somewhere, either microservices or serverless.</div><br/></div></div></div></div></div></div></div></div><div id="41891721" class="c"><input type="checkbox" id="c-41891721" checked=""/><div class="controls bullet"><span class="by">cletus</span><span>|</span><a href="#41893322">prev</a><span>|</span><a href="#41891238">next</a><span>|</span><label class="collapse" for="c-41891721">[-]</label><label class="expand" for="c-41891721">[34 more]</label></div><br/><div class="children"><div class="content">At Google, I worked on a pure JS Speedtest. At the time, Ookla was still Flash-based so wouldn&#x27;t work on Chromebooks. That was a problem for installers to verify an installation. I learned a lot about how TCP (I realize QUIC is UDP) responds to various factors.<p>I look at this article and consider the result pretty much as expected. Why? Because it pushes the flow control out of the kernel (and possibly network adapters) into userspace. TCP has flow-control and sequencing. QUICK makes you manage that yourself (sort of).<p>Now there can be good reasons to do that. TCP congestion control is famously out-of-date with modern connection speeds, leading to newer algorithms like BRR [1] but it comes at a cost.<p>But here&#x27;s my biggest takeaway from all that and it&#x27;s something so rarely accounted for in network testing, testing Web applications and so on: latency.<p>Anyone who lives in Asia or Australia should relate to this. 100ms RTT latency can be devastating. It can take something that is completely responsive to utterly unusable. It slows down the bandwidth a connection can support (because of the windows) and make it less responsive to errors and congestion control efforts (both up and down).<p>I would strongly urge anyone testing a network or Web application to run tests where they randomly add 100ms to the latency [2].<p>My point in bringing this up is that the overhead of QUIC may not practically matter because your effective bandwidth over a single TCP connection (or QUICK stream) may be MUCH lower than your actual raw bandwidth. Put another way, 45% extra data may still be a win because managing your own congestion control <i>might</i> give you higher effective speed over between two parties.<p>[1]: <a href="https:&#x2F;&#x2F;atoonk.medium.com&#x2F;tcp-bbr-exploring-tcp-congestion-control-84c9c11dc3a9" rel="nofollow">https:&#x2F;&#x2F;atoonk.medium.com&#x2F;tcp-bbr-exploring-tcp-congestion-c...</a><p>[2]: <a href="https:&#x2F;&#x2F;bencane.com&#x2F;simulating-network-latency-for-testing-in-linux-environments-29daad98efcc" rel="nofollow">https:&#x2F;&#x2F;bencane.com&#x2F;simulating-network-latency-for-testing-i...</a></div><br/><div id="41892102" class="c"><input type="checkbox" id="c-41892102" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41891768">next</a><span>|</span><label class="collapse" for="c-41892102">[-]</label><label class="expand" for="c-41892102">[3 more]</label></div><br/><div class="children"><div class="content">I did a bunch of real world testing of my file transfer app[1]. Went in with the expectation that Quic would be amazing. Came out frustrated for many reasons and switched back to TCP. It’s obvious in hindsight, but with TCP you say “hey kernel send this giant buffer please” whereas UDP is packet switched! So even pushing zeroes has a massive CPU cost on most OSs and consumer hardware, from all the mode switches. Yes, there are ways around it but no they’re not easy nor ready in my experience. Plus it limits your choice of languages&#x2F;libraries&#x2F;platforms.<p>(Fun bonus story: I noticed significant drops in throughput when using battery on a MacBook. Something to do with the efficiency cores I assume.)<p>Secondly, quic does congestion control poorly (I was using quic-go so mileage may vary). No tuning really helped, and TCP streams would take more bandwidth if both were present.<p>Third, the APIs are weird man. So, quic itself has multiple streams, which makes it non-drop in replacement with TCP. However, the idea is to have HTTP&#x2F;3 be drop-in replaceable at a higher level (which I can’t speak to because I didn’t do). But worth keeping in mind if you’re working on the stream level.<p>In conclusion I came out pretty much defeated but also with a newfound respect for all the optimizations and resilience of our old friend tcp. It’s really an amazing piece of tech. And it’s just there, for free, always provided by the OS. Even some of the main issues with tcp are not design faults but conservative&#x2F;legacy defaults (buffer limits on Linux, Nagle, etc). I really just wish we could improve it instead of reinventing the wheel..<p>[1]: <a href="https:&#x2F;&#x2F;payload.app&#x2F;" rel="nofollow">https:&#x2F;&#x2F;payload.app&#x2F;</a></div><br/><div id="41893050" class="c"><input type="checkbox" id="c-41893050" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892102">parent</a><span>|</span><a href="#41892805">next</a><span>|</span><label class="collapse" for="c-41893050">[-]</label><label class="expand" for="c-41893050">[1 more]</label></div><br/><div class="children"><div class="content">One does not need to send and should not send one packet per syscall.</div><br/></div></div><div id="41892805" class="c"><input type="checkbox" id="c-41892805" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892102">parent</a><span>|</span><a href="#41893050">prev</a><span>|</span><a href="#41891768">next</a><span>|</span><label class="collapse" for="c-41892805">[-]</label><label class="expand" for="c-41892805">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (Fun bonus story: I noticed significant drops in throughput when using battery on a MacBook. Something to do with the efficiency cores I assume.)<p>That sounds like the thread priority&#x2F;QoS was incorrect, but it could be WiFi or something.</div><br/></div></div></div></div><div id="41891768" class="c"><input type="checkbox" id="c-41891768" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41892102">prev</a><span>|</span><a href="#41893658">next</a><span>|</span><label class="collapse" for="c-41891768">[-]</label><label class="expand" for="c-41891768">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Because it pushes the flow control out of the kernel (and possibly network adapters) into userspace<p>That’s not an inherent property of the QUIC protocol, it is just an implementation decision - one that was very necessary for QUIC to get off the ground, but now it exists, maybe it should be revisited? There is no technical obstacle to implementing QUIC in the kernel, and if the performance benefits are significant, almost surely someone is going to do it sooner or later.</div><br/><div id="41893160" class="c"><input type="checkbox" id="c-41893160" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891768">parent</a><span>|</span><a href="#41891973">next</a><span>|</span><label class="collapse" for="c-41893160">[-]</label><label class="expand" for="c-41893160">[1 more]</label></div><br/><div class="children"><div class="content">Looks like it’s being worked on: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;989623&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;989623&#x2F;</a></div><br/></div></div><div id="41891973" class="c"><input type="checkbox" id="c-41891973" checked=""/><div class="controls bullet"><span class="by">lttlrck</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891768">parent</a><span>|</span><a href="#41893160">prev</a><span>|</span><a href="#41891946">next</a><span>|</span><label class="collapse" for="c-41891973">[-]</label><label class="expand" for="c-41891973">[8 more]</label></div><br/><div class="children"><div class="content">For Linux that&#x27;s true. But Microsoft never added SCTP to Windows; not being beholden to Microsoft and older OS must have been part of the calculus?</div><br/><div id="41892046" class="c"><input type="checkbox" id="c-41892046" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891973">parent</a><span>|</span><a href="#41892802">next</a><span>|</span><label class="collapse" for="c-41892046">[-]</label><label class="expand" for="c-41892046">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But Microsoft never added SCTP to Windows<p>Windows already has an in-kernel QUIC implementation (msquic.sys), used for SMB&#x2F;CIFS and in-kernel HTTP. I don’t think it is accessible from user-space - I believe user-space code uses a separate copy of the same QUIC stack that runs in user-space (msquic.dll), but there is no reason in-principle why Microsoft couldn’t expose the kernel-mode implementation to user space</div><br/></div></div><div id="41892802" class="c"><input type="checkbox" id="c-41892802" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891973">parent</a><span>|</span><a href="#41892046">prev</a><span>|</span><a href="#41891946">next</a><span>|</span><label class="collapse" for="c-41892802">[-]</label><label class="expand" for="c-41892802">[6 more]</label></div><br/><div class="children"><div class="content">No one ever uses SCTP. It&#x27;s pretty unclear to me why any OSes do include it; free OSes seem to like junk drawers of network protocols even though they add to the security surface in kernel land.</div><br/><div id="41892986" class="c"><input type="checkbox" id="c-41892986" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892802">parent</a><span>|</span><a href="#41893981">next</a><span>|</span><label class="collapse" for="c-41892986">[-]</label><label class="expand" for="c-41892986">[1 more]</label></div><br/><div class="children"><div class="content">The telecom sector uses SCTP in lots of places.</div><br/></div></div><div id="41893981" class="c"><input type="checkbox" id="c-41893981" checked=""/><div class="controls bullet"><span class="by">lstodd</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892802">parent</a><span>|</span><a href="#41892986">prev</a><span>|</span><a href="#41892937">next</a><span>|</span><label class="collapse" for="c-41893981">[-]</label><label class="expand" for="c-41893981">[1 more]</label></div><br/><div class="children"><div class="content">4g&#x2F;LTE runs on it. So you use it too, via your phone.</div><br/></div></div><div id="41892937" class="c"><input type="checkbox" id="c-41892937" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892802">parent</a><span>|</span><a href="#41893981">prev</a><span>|</span><a href="#41893372">next</a><span>|</span><label class="collapse" for="c-41892937">[-]</label><label class="expand" for="c-41892937">[2 more]</label></div><br/><div class="children"><div class="content">Does anyone even build SCTP support directly into the kernel?  Looks like Debian builds it as a module, which I&#x27;m sure I never have and never will load.  Security risk seems pretty minimal there.<p>(And if someone can somehow coerce me into loading it, I have bigger problems.)</div><br/><div id="41893439" class="c"><input type="checkbox" id="c-41893439" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892937">parent</a><span>|</span><a href="#41893372">next</a><span>|</span><label class="collapse" for="c-41893439">[-]</label><label class="expand" for="c-41893439">[1 more]</label></div><br/><div class="children"><div class="content">Linux and FreeBSD have had it for ages. Anything industrial too. Solaris, QNX, Cisco IOS.<p>SCTP is essential for certain older telco protocols and in certain protocols developed for LTE it was added. End users probably don&#x27;t use it much, but the harsware their connections are going through will speak SCTP at some level.</div><br/></div></div></div></div><div id="41893372" class="c"><input type="checkbox" id="c-41893372" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892802">parent</a><span>|</span><a href="#41892937">prev</a><span>|</span><a href="#41891946">next</a><span>|</span><label class="collapse" for="c-41893372">[-]</label><label class="expand" for="c-41893372">[1 more]</label></div><br/><div class="children"><div class="content">And most of those protocols can be disabled under sysctl.conf.</div><br/></div></div></div></div></div></div><div id="41891946" class="c"><input type="checkbox" id="c-41891946" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891768">parent</a><span>|</span><a href="#41891973">prev</a><span>|</span><a href="#41893658">next</a><span>|</span><label class="collapse" for="c-41891946">[-]</label><label class="expand" for="c-41891946">[1 more]</label></div><br/><div class="children"><div class="content">Is this something you could use ebpf for?</div><br/></div></div></div></div><div id="41893658" class="c"><input type="checkbox" id="c-41893658" checked=""/><div class="controls bullet"><span class="by">attentive</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41891768">prev</a><span>|</span><a href="#41893802">next</a><span>|</span><label class="collapse" for="c-41893658">[-]</label><label class="expand" for="c-41893658">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I look at this article and consider the result pretty much as expected. Why? Because it pushes the flow control out of the kernel (and possibly network adapters) into userspace. TCP has flow-control and sequencing. QUICK makes you manage that yourself (sort of).<p>This implies that user space is slow. Yet, some(most?) of the fastest high-performance  TCP&#x2F;IP stacks are made in user space.</div><br/><div id="41893862" class="c"><input type="checkbox" id="c-41893862" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41893658">parent</a><span>|</span><a href="#41893816">next</a><span>|</span><label class="collapse" for="c-41893862">[-]</label><label class="expand" for="c-41893862">[1 more]</label></div><br/><div class="children"><div class="content">If the entire stack is in usermode and it&#x27;s directly talking to the NIC with no kernel involvement beyond setup at all. This isn&#x27;t the case with QUIC, it uses the normal sockets API to send&#x2F;recv UDP.</div><br/></div></div><div id="41893816" class="c"><input type="checkbox" id="c-41893816" checked=""/><div class="controls bullet"><span class="by">WesolyKubeczek</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41893658">parent</a><span>|</span><a href="#41893862">prev</a><span>|</span><a href="#41893802">next</a><span>|</span><label class="collapse" for="c-41893816">[-]</label><label class="expand" for="c-41893816">[1 more]</label></div><br/><div class="children"><div class="content">You have to jump contexts for every datagram, and you cannot offload checksumming to the network hardware.</div><br/></div></div></div></div><div id="41893802" class="c"><input type="checkbox" id="c-41893802" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41893658">prev</a><span>|</span><a href="#41892709">next</a><span>|</span><label class="collapse" for="c-41893802">[-]</label><label class="expand" for="c-41893802">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I look at this article and consider the result pretty much as expected. Why? Because it pushes the flow control out of the kernel (and possibly network adapters) into userspace. TCP has flow-control and sequencing. QUICK makes you manage that yourself (sort of).<p>I truly hope the QUIC in Linux Kernel project [0] succeeds. I&#x27;m not looking forward to linking big HTTP&#x2F;3 libraries to all applications.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;lxin&#x2F;quic">https:&#x2F;&#x2F;github.com&#x2F;lxin&#x2F;quic</a></div><br/></div></div><div id="41892709" class="c"><input type="checkbox" id="c-41892709" checked=""/><div class="controls bullet"><span class="by">bdd8f1df777b</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41893802">prev</a><span>|</span><a href="#41892118">next</a><span>|</span><label class="collapse" for="c-41892709">[-]</label><label class="expand" for="c-41892709">[1 more]</label></div><br/><div class="children"><div class="content">As a Chinese whose latency to servers outside China often exceeds 300ms, I&#x27;m a staunch supporter of QUIC. The difference is night and day.</div><br/></div></div><div id="41892118" class="c"><input type="checkbox" id="c-41892118" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41892709">prev</a><span>|</span><a href="#41891766">next</a><span>|</span><label class="collapse" for="c-41892118">[-]</label><label class="expand" for="c-41892118">[3 more]</label></div><br/><div class="children"><div class="content">The Network tab in the Chrome console allows you to degrade your connection. There are presets for Slow&#x2F;Fast 4G, 3G, or you can make a custom present where you can specify download and upload speeds, latency in ms, a packet loss percent, a packet queue length and can enable packet reordering.</div><br/><div id="41892287" class="c"><input type="checkbox" id="c-41892287" checked=""/><div class="controls bullet"><span class="by">lelandfe</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892118">parent</a><span>|</span><a href="#41891766">next</a><span>|</span><label class="collapse" for="c-41892287">[-]</label><label class="expand" for="c-41892287">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also an <i>old</i> macOS preference pane called Network Link Conditioner that makes the connections more realistic: <a href="https:&#x2F;&#x2F;nshipster.com&#x2F;network-link-conditioner&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nshipster.com&#x2F;network-link-conditioner&#x2F;</a><p>IIRC, Chrome&#x27;s network simulation just applies a delay after a connection is established</div><br/><div id="41893107" class="c"><input type="checkbox" id="c-41893107" checked=""/><div class="controls bullet"><span class="by">mh-</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892287">parent</a><span>|</span><a href="#41891766">next</a><span>|</span><label class="collapse" for="c-41893107">[-]</label><label class="expand" for="c-41893107">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t remember the details offhand, but yes - unless Chrome&#x27;s network simulation has been rewritten in the last few years, it doesn&#x27;t do a good job of approximating real world network conditions.<p>It&#x27;s a lot better than nothing, and doing it realistically would be a lot more work than what they&#x27;ve done, so I say this with all due respect to those who worked on it.</div><br/></div></div></div></div></div></div><div id="41891766" class="c"><input type="checkbox" id="c-41891766" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41892118">prev</a><span>|</span><a href="#41892276">next</a><span>|</span><label class="collapse" for="c-41891766">[-]</label><label class="expand" for="c-41891766">[5 more]</label></div><br/><div class="children"><div class="content">For reasonably long downloads (so it has a chance to calibrate), why don&#x27;t congestion algorithms increase the number of inflight packets to a high enough number that bandwidth is fully utilized even over high latency connections?<p>It seems like it should never be the case that two parallel downloads will preform better than a single one to the same host.</div><br/><div id="41891957" class="c"><input type="checkbox" id="c-41891957" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891766">parent</a><span>|</span><a href="#41892726">next</a><span>|</span><label class="collapse" for="c-41891957">[-]</label><label class="expand" for="c-41891957">[1 more]</label></div><br/><div class="children"><div class="content">There are two places a packet can be ‘in-flight’. One is light travelling down cables (or the electrical equivalent) or in memory being processed by some hardware like a switch, and the other is sat in a buffer in some networking appliance because the downstream connection is busy (eg sending packets that are further up the queue, at a slower rate than they arrive). If you just increase bandwidth it is easy to get lots of in-flight packets in the second state which increases latency (admittedly that doesn’t matter so much for long downloads) and the chance of packet loss from overly full buffers.<p>CUBIC tries to increase bandwidth until it hits packet loss, then cuts bandwidth (to drain buffers a bit) and ramps up and hangs around close to the rate that led to loss, before it tries sending at a higher rate and filling up buffers again. Cubic is very sensitive to packet loss, which makes things particularly difficult on very high bandwidth links with moderate latency as you need very low rates of (non-congestion-related) loss to get that bandwidth.<p>BBR tries to do the thing you describe while also modelling buffers and trying to keep them empty. It goes through a cycle of sending at the estimated bandwidth, sending at a lower rate to see if buffers got full, and sending at a higher rate to see if that’s possible, and the second step can be somewhat harmful if you don’t need the advantages of BBR.<p>I think the main thing that tends to prevent the thing you talk about is flow control rather than congestion control. In particular, the sender needs a sufficiently large send buffer to store all unacked data (which can be a lot due to various kinds of ack-delaying) in case it needs to resend packets, and if you need to resend some then your send buffer would need to be twice as large to keep going. On the receive size, you need big enough buffers to be able to fill up those buffers from the network while waiting for an earlier packet to be retransmitted.<p>On a high-latency fast connection, those buffers need to be big to get full bandwidth, and that requires (a) growing a lot, which can take a lot of round-trips, and (b) being allowed by the operating system to grow big enough.</div><br/></div></div><div id="41892726" class="c"><input type="checkbox" id="c-41892726" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891766">parent</a><span>|</span><a href="#41891957">prev</a><span>|</span><a href="#41891874">next</a><span>|</span><label class="collapse" for="c-41892726">[-]</label><label class="expand" for="c-41892726">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve run a big webserver that served a decent size apk&#x2F;other app downloads (and a  bunch of small files and what nots). I had to set the maximum outgoing window to keep the overall memory within limits.<p>IIRC, servers were 64GB of ram and sendbufs were capped at 2MB. I was also dealing with a kernel deficiency that would leave the sendbuf allocated if the client disappeared in LAST_ACK. (This stems from a deficiency in the state description from the 1981 rfc written before my birth)</div><br/></div></div><div id="41891874" class="c"><input type="checkbox" id="c-41891874" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891766">parent</a><span>|</span><a href="#41892726">prev</a><span>|</span><a href="#41891861">next</a><span>|</span><label class="collapse" for="c-41891874">[-]</label><label class="expand" for="c-41891874">[1 more]</label></div><br/><div class="children"><div class="content">Larger windows can reduce the maximum number of simultaneous connections on the sender side.</div><br/></div></div><div id="41891861" class="c"><input type="checkbox" id="c-41891861" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891766">parent</a><span>|</span><a href="#41891874">prev</a><span>|</span><a href="#41892276">next</a><span>|</span><label class="collapse" for="c-41891861">[-]</label><label class="expand" for="c-41891861">[1 more]</label></div><br/><div class="children"><div class="content">You can in theory. You just need a accurate model of your available bandwidth and enough buffering&#x2F;storage to avoid stalls while you wait for acknowledgement. It is, frankly, not even that hard to do it right. But in practice many implementations are terrible, so good luck.</div><br/></div></div></div></div><div id="41892276" class="c"><input type="checkbox" id="c-41892276" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41891766">prev</a><span>|</span><a href="#41891919">next</a><span>|</span><label class="collapse" for="c-41892276">[-]</label><label class="expand" for="c-41892276">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Anyone who lives in Asia or Australia should relate to this. 100ms RTT latency can be devastating.<p>When I used to (try to) play online games in NZ a few years ago, RTT to US West servers sometimes exceeded 200ms.</div><br/><div id="41893624" class="c"><input type="checkbox" id="c-41893624" checked=""/><div class="controls bullet"><span class="by">albertopv</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892276">parent</a><span>|</span><a href="#41892498">next</a><span>|</span><label class="collapse" for="c-41893624">[-]</label><label class="expand" for="c-41893624">[1 more]</label></div><br/><div class="children"><div class="content">I would be surprised if online games use TCP.
Anyway, physics is still there and light speed is fast, but that much. In 10ms it travels about 3000km, NZ to US west coast is about 11000km, so less than 60ms is impossible. Cables are probably much longer, c speed is lower in a medium, add network devices latency and 200ms from NZ to USA is not that bad.</div><br/></div></div><div id="41892498" class="c"><input type="checkbox" id="c-41892498" checked=""/><div class="controls bullet"><span class="by">indrora</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892276">parent</a><span>|</span><a href="#41893624">prev</a><span>|</span><a href="#41891919">next</a><span>|</span><label class="collapse" for="c-41892498">[-]</label><label class="expand" for="c-41892498">[2 more]</label></div><br/><div class="children"><div class="content">When I was younger, I played a lot of cs1.6 and hldm. Living in rural New Mexico, my ping times were often 150-250ms.<p>DSL kills.</div><br/><div id="41893340" class="c"><input type="checkbox" id="c-41893340" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41892498">parent</a><span>|</span><a href="#41891919">next</a><span>|</span><label class="collapse" for="c-41893340">[-]</label><label class="expand" for="c-41893340">[1 more]</label></div><br/><div class="children"><div class="content">I used to play netquake(not quakeworld) at up to 800 ms lag, past that was too much for even young stupid me.<p>For them that don&#x27;t know the difference. netquake was the original strict client server version of quake, you hit the forward key it sends that to the server and the server then sends back where you moved. quakeworld was the client side prediction enhancement that came later, you hit forward, the client moves you forwards and sends it to the server at the same time. and if there are differences it gets reconciled later.<p>For the most part client side prediction feels better to play. however when there are network problems, large amounts of lag, a lot of artifacts start to show up, rubberbanding, jumping around, hits that don&#x27;t. Pure client server feels worse, every thing gets sluggish, and mushy but movement is a little more predictable and logical and can sort of be anticipated.<p>I have not played quake in 20 years but one thing I remember is at past 800ms of lag the lava felt magnetic, it would just suck you in, every time.</div><br/></div></div></div></div></div></div><div id="41891919" class="c"><input type="checkbox" id="c-41891919" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#41891721">parent</a><span>|</span><a href="#41892276">prev</a><span>|</span><a href="#41891238">next</a><span>|</span><label class="collapse" for="c-41891919">[-]</label><label class="expand" for="c-41891919">[2 more]</label></div><br/><div class="children"><div class="content">A major problem with TCP is that the limitations of the kernel network stack and sometimes port allocation place absurd artificial limits on the number of active connections. A modern big server should be able to have tens of millions of open TCP connections at least, but to do that well you have to do hacks like running a bunch of pointless VMs.</div><br/><div id="41892527" class="c"><input type="checkbox" id="c-41892527" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41891721">root</a><span>|</span><a href="#41891919">parent</a><span>|</span><a href="#41891238">next</a><span>|</span><label class="collapse" for="c-41892527">[-]</label><label class="expand" for="c-41892527">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A modern big server should be able to have tens of millions of open TCP connections at least, but to do that well you have to do hacks like running a bunch of pointless VMs.<p>Inbound connections? You don&#x27;t need to do anything other than make sure your fd limit is high and maybe not be ipv4 only and have too many users behind the same cgnat.<p>Outbound connections is harder, but hopefully you don&#x27;t need millions of connections to the same destination, or if you do, hopefully they support ipv6.<p>When I ran millions of connections through HAproxy (bare tcp proxy, just some peaking to determine the upstream), I had to do a bunch of work to make it scale, but not because of port limits.</div><br/></div></div></div></div></div></div><div id="41891238" class="c"><input type="checkbox" id="c-41891238" checked=""/><div class="controls bullet"><span class="by">jrpelkonen</span><span>|</span><a href="#41891721">prev</a><span>|</span><a href="#41890996">next</a><span>|</span><label class="collapse" for="c-41891238">[-]</label><label class="expand" for="c-41891238">[16 more]</label></div><br/><div class="children"><div class="content">Curl creator&#x2F;maintainer Daniel Stenberg blogged about HTTP&#x2F;3 in curl a few months ago: <a href="https:&#x2F;&#x2F;daniel.haxx.se&#x2F;blog&#x2F;2024&#x2F;06&#x2F;10&#x2F;http-3-in-curl-mid-2024&#x2F;" rel="nofollow">https:&#x2F;&#x2F;daniel.haxx.se&#x2F;blog&#x2F;2024&#x2F;06&#x2F;10&#x2F;http-3-in-curl-mid-20...</a><p>One of the things he highlighted was the higher CPU utilization of HTTP&#x2F;3, to the point where CPU can limit throughput.<p>I wonder how much of this is due to the immaturity of the implementations, and how much this is inherit due to way QUIC was designed?</div><br/><div id="41891813" class="c"><input type="checkbox" id="c-41891813" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41891238">parent</a><span>|</span><a href="#41891693">next</a><span>|</span><label class="collapse" for="c-41891813">[-]</label><label class="expand" for="c-41891813">[1 more]</label></div><br/><div class="children"><div class="content">Two recommendations are for improving receiver-side implementations – optimising them and making them multithreaded. Those suggest some immaturity of the implementations. A third recommendation is UDP GRO, which means modifying kernels and ideally NIC hardware to group received UDP packets together in a way that reduces per-packet work (you do lots of per-group work instead of per-packet work). This already exists in TCP and there are similar things on the send side (eg TSO, GSO in Linux), and feels a bit like immaturity but maybe harder to remedy considering the potential lack of hardware capabilities. The abstract talks about the cost of how acks work in QUIC but I didn’t look into that claim.<p>Another feature you see for modern tcp-based servers is offloading tls to the hardware. I think this matters more for servers that may have many concurrent tcp streams to send. On Linux you can get this either with userspace networking or by doing ‘kernel tls’ which will offload to hardware if possible. That feature also exists for some funny stuff in Linux about breaking down a tcp stream into ‘messages’ which can be sent to different threads, though I don’t know if it allows eagerly passing some later messages when earlier packets were lost.</div><br/></div></div><div id="41891693" class="c"><input type="checkbox" id="c-41891693" checked=""/><div class="controls bullet"><span class="by">cj</span><span>|</span><a href="#41891238">parent</a><span>|</span><a href="#41891813">prev</a><span>|</span><a href="#41891887">next</a><span>|</span><label class="collapse" for="c-41891693">[-]</label><label class="expand" for="c-41891693">[4 more]</label></div><br/><div class="children"><div class="content">I’ve always been under the impression that QUIC was designed for connections that aren’t guaranteed to be stable or fast. Like mobile networks.<p>I never got the impression that it was intended to make all connections faster.<p>If viewed from that perspective, the tradeoffs make sense. Although I’m no expert and encourage someone with more knowledge to correct me.</div><br/><div id="41891848" class="c"><input type="checkbox" id="c-41891848" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41891693">parent</a><span>|</span><a href="#41893147">next</a><span>|</span><label class="collapse" for="c-41891848">[-]</label><label class="expand" for="c-41891848">[1 more]</label></div><br/><div class="children"><div class="content">I think that’s a pretty good impression. Lots of features for those cases:<p>- better behaviour under packet loss (you don’t need to read byte n before you can see byte n+1 like in tcp)<p>- better behaviour under client ip changes (which happen when switching between cellular data and wifi)<p>- moving various tricks for getting good latency and throughput in the real world into user space (things like pacing, bbr) and not leaving enough unencrypted information in packets for middleware boxes to get too funky</div><br/></div></div><div id="41893147" class="c"><input type="checkbox" id="c-41893147" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41891693">parent</a><span>|</span><a href="#41891848">prev</a><span>|</span><a href="#41891912">next</a><span>|</span><label class="collapse" for="c-41893147">[-]</label><label class="expand" for="c-41893147">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how the internet works, there&#x27;s no guaranteed delivery and TCP bandwidth estimation is based on when packets start to be dropped when you send too many.</div><br/></div></div><div id="41891912" class="c"><input type="checkbox" id="c-41891912" checked=""/><div class="controls bullet"><span class="by">therealmarv</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41891693">parent</a><span>|</span><a href="#41893147">prev</a><span>|</span><a href="#41891887">next</a><span>|</span><label class="collapse" for="c-41891912">[-]</label><label class="expand" for="c-41891912">[1 more]</label></div><br/><div class="children"><div class="content">It makes everything faster, it&#x27;s an evolvement of HTTP&#x2F;2 in many ways. I recommend watching<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=cdb7M37o9sU" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=cdb7M37o9sU</a></div><br/></div></div></div></div><div id="41891887" class="c"><input type="checkbox" id="c-41891887" checked=""/><div class="controls bullet"><span class="by">therealmarv</span><span>|</span><a href="#41891238">parent</a><span>|</span><a href="#41891693">prev</a><span>|</span><a href="#41891790">next</a><span>|</span><label class="collapse" for="c-41891887">[-]</label><label class="expand" for="c-41891887">[9 more]</label></div><br/><div class="children"><div class="content">&quot;immaturity of the implementations&quot; is a funny wording here. QUIC was created because there is absolutely NO WAY that all internet hardware (including all middleware etc) out there will support a new TCP or TLS standard. So QUIC is an elegant solution to get a new transport standard on top of legacy internet hardware (on top of UDP).<p>In an ideal World we would create a new TCP and TLS standard and replace and&#x2F;or update all internet routers and hardware everywhere World Wide so that it is implemented with less CPU utilization ;)</div><br/><div id="41891927" class="c"><input type="checkbox" id="c-41891927" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41891887">parent</a><span>|</span><a href="#41891790">next</a><span>|</span><label class="collapse" for="c-41891927">[-]</label><label class="expand" for="c-41891927">[8 more]</label></div><br/><div class="children"><div class="content">A major mistake in IP’s design was to allow middle boxes. The protocol should have had some kind of minimal header auth feature to intentionally break them. It wouldn’t have to be strong crypto, just enough to make middle boxes impractical.<p>It would have forced IPv6 migration immediately (no NAT) and forced endpoints to be secured with local firewalls and better software instead of middle boxes.<p>The Internet would be so much simpler, faster, and more capable. Peer to peer would be trivial. Everything would just work. Protocol innovation would be possible.<p>Of course tech is full of better roads not taken. We are prisoners of network effects and accidents of history freezing ugly hacks into place.</div><br/><div id="41893968" class="c"><input type="checkbox" id="c-41893968" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41891927">parent</a><span>|</span><a href="#41892225">next</a><span>|</span><label class="collapse" for="c-41893968">[-]</label><label class="expand" for="c-41893968">[1 more]</label></div><br/><div class="children"><div class="content">I completely disagree with this take.<p>First of all, NAT is what saved the Internet from being forked. IPv6 transition was a pipe dream at the time it was first proposed, and the vast growth in consumers for ISPs that had just paid for expensive IPv4 boxes would never have resulted in them paying for far more expensive (at the time) IPv6 boxes, it would have resulted in much less growth, or other custom solutions, or even separate IPv4 networks in certain parts of the world. Or, if not, it would have resulted in tunneling all traffic over a protocol more amenable to middle boxes, such as HTTP, which would have been even worse than the NAT happening today.<p>Then, even though it was unintentional, NAT and CGNAT are what ended up protecting consumers from IP-level tracking. If we had transitioned from IPv4 directly to IPv6, without the decades of NAT, all tracking technology wouldn&#x27;t have bothered with cookies and so on, we would have had the trivial IP tracking allowed by the one-IP-per-device vision. And with the entrenched tracking adware industry controlling a big part of the Internet and relying on tracking IPs, the privacy extensions to IPv6 (which, remember, came MUCH later in IPv6&#x27;s life than the original vision for the transition) would never have happened.<p>I won&#x27;t bother going into the other kinds of important use cases that other middle boxes support, that a hostile IPv4 would have prevented, causing even bigger problems. NAT is actually an excellent example of why IPs design decisions that allow middle boxes are a godsend, not a tragic mistake. Now hopefully we can phase out NAT in the coming years, as it&#x27;s served its purpose and can honorably retire.</div><br/></div></div><div id="41892225" class="c"><input type="checkbox" id="c-41892225" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41891927">parent</a><span>|</span><a href="#41893968">prev</a><span>|</span><a href="#41892686">next</a><span>|</span><label class="collapse" for="c-41892225">[-]</label><label class="expand" for="c-41892225">[3 more]</label></div><br/><div class="children"><div class="content">Making IPv4 headers resistant to tampering wouldn&#x27;t have helped with IPv6 rollout,  as routers (both customer and ISP) would still need to be updated to be able to understand how to route packets with the new headers.</div><br/><div id="41892516" class="c"><input type="checkbox" id="c-41892516" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41892225">parent</a><span>|</span><a href="#41892686">next</a><span>|</span><label class="collapse" for="c-41892516">[-]</label><label class="expand" for="c-41892516">[2 more]</label></div><br/><div class="children"><div class="content">The GP&#x27;s point is that if middle boxes couldn&#x27;t rewrite the header, NAt would be impossible. And if NAT were impossible, ipV4 would have died several years ago because NAT allowed more computers than addresses.</div><br/><div id="41893989" class="c"><input type="checkbox" id="c-41893989" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41892516">parent</a><span>|</span><a href="#41892686">next</a><span>|</span><label class="collapse" for="c-41893989">[-]</label><label class="expand" for="c-41893989">[1 more]</label></div><br/><div class="children"><div class="content">Very unlikely. Most likely NAT would have happened to other layers of the stack (HTTP, for example), causing even more problems. Or, the growth of the Internet would have stalled dramatically, as ISPs would have either increased prices dramatically to account for investments in new and expensive IPv6 hardware, or simply stopped acceptong new subscribers.</div><br/></div></div></div></div></div></div><div id="41892686" class="c"><input type="checkbox" id="c-41892686" checked=""/><div class="controls bullet"><span class="by">ocdtrekkie</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41891927">parent</a><span>|</span><a href="#41892225">prev</a><span>|</span><a href="#41892920">next</a><span>|</span><label class="collapse" for="c-41892686">[-]</label><label class="expand" for="c-41892686">[2 more]</label></div><br/><div class="children"><div class="content">This ignores... a lot of reality. Like the fact that when IP was designed, the idea of every individual network device having to run its own firewall was impractical performance-wise, and decades later... still not really ideal.<p>There&#x27;s definitely some benefits to glean from a zero trust model, but putting a moat around your network still <i>helps a lot</i> and NAT is probably the best accidental security feature to ever exist. Half the cybersecurity problems we have are because the cloud model has normalized routing sensitive behavior out to the open Internet instead of private networks.<p>My middleboxes will happily be configured to continue to block any traffic that refuses to obey them. (QUIC and ECH inclusive.)</div><br/><div id="41893112" class="c"><input type="checkbox" id="c-41893112" checked=""/><div class="controls bullet"><span class="by">codexon</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41892686">parent</a><span>|</span><a href="#41892920">next</a><span>|</span><label class="collapse" for="c-41893112">[-]</label><label class="expand" for="c-41893112">[1 more]</label></div><br/><div class="children"><div class="content">Even now, you can saturate a modern cpu core with only 1 million packets per second.</div><br/></div></div></div></div><div id="41892920" class="c"><input type="checkbox" id="c-41892920" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#41891238">root</a><span>|</span><a href="#41891927">parent</a><span>|</span><a href="#41892686">prev</a><span>|</span><a href="#41891790">next</a><span>|</span><label class="collapse" for="c-41892920">[-]</label><label class="expand" for="c-41892920">[1 more]</label></div><br/><div class="children"><div class="content">Now that’s a horse of a different color! I’m already opining this alt reality. Middle-boxes and everyone touching them ruined the internet.</div><br/></div></div></div></div></div></div><div id="41891790" class="c"><input type="checkbox" id="c-41891790" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41891238">parent</a><span>|</span><a href="#41891887">prev</a><span>|</span><a href="#41890996">next</a><span>|</span><label class="collapse" for="c-41891790">[-]</label><label class="expand" for="c-41891790">[1 more]</label></div><br/><div class="children"><div class="content">Those performance results surprised me too.<p>His testing has CPU-bound quiche at &lt;200MB&#x2F;s and nghttp2 was &gt;900MB&#x2F;s.<p>I wonder if the CPU was throttled.<p>Because if HTTP 3 impl took 4x CPU that could be interesting but not necessarily a big problem if the absolute value was very low to begin with.</div><br/></div></div></div></div><div id="41890996" class="c"><input type="checkbox" id="c-41890996" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891238">prev</a><span>|</span><a href="#41891085">next</a><span>|</span><label class="collapse" for="c-41890996">[-]</label><label class="expand" for="c-41890996">[69 more]</label></div><br/><div class="children"><div class="content">&gt;  We find that over fast Internet, the UDP+QUIC+HTTP&#x2F;3 stack suffers a data rate reduction of up to 45.2% compared to the TCP+TLS+HTTP&#x2F;2 counterpart.<p>Haven&#x27;t read the whole paper yet, but below 600 Mbit&#x2F;s is implied as being &quot;Slow Internet&quot; in the intro.</div><br/><div id="41891362" class="c"><input type="checkbox" id="c-41891362" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891574">next</a><span>|</span><label class="collapse" for="c-41891362">[-]</label><label class="expand" for="c-41891362">[3 more]</label></div><br/><div class="children"><div class="content">They also mainly identified a throughput reduction due to latency issues caused by ineffective&#x2F;too many syscalls in how browsers implement it.<p>But such a latency issue isn&#x27;t majorly increasing battery usage (compared to a CPU usage issue which would make CPUs boost). Nor is it an issue for server-to-server communication.<p>It basically &quot;only&quot; slows down high bandwidth transmissions on end user devices with (for 2024 standards) very high speed connection (if you take effective speeds from device to server, not speeds you where advertised to have bough and at best can get when the server owner has a direct pairing agreement with you network provider and a server in your region.....).<p>Doesn&#x27;t mean the paper is worthless, browser should improve their impl. and it highlights it.<p>But the title of the paper is basically 100% click bait.</div><br/><div id="41891784" class="c"><input type="checkbox" id="c-41891784" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891362">parent</a><span>|</span><a href="#41891574">next</a><span>|</span><label class="collapse" for="c-41891784">[-]</label><label class="expand" for="c-41891784">[2 more]</label></div><br/><div class="children"><div class="content">How is it clickbait? The title implies that QUIC isn&#x27;t as fast as other protocols over fast internet connections.</div><br/><div id="41891850" class="c"><input type="checkbox" id="c-41891850" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891784">parent</a><span>|</span><a href="#41891574">next</a><span>|</span><label class="collapse" for="c-41891850">[-]</label><label class="expand" for="c-41891850">[1 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s QUIC _implementations of browser_ not being as fast as the non quick impl of browsers on connections most people would not just call fast but very fast (in context of browser usage) while still being definitely 100% fast enough for all browser use case done today (sure it theoretically might reduce video bit rate, that is, if it isn&#x27;t already capped to a anyway smaller rate, which AFIK it basically always is).<p>So &quot;Not Quick Enough&quot; is plain out wrong, it is fast enough.<p>The definition of &quot;Fast Internet&quot; misleading.<p>And even &quot;QUIC&quot; is misleading as it normally refers to the protocol while the benchmarked protocol is HTTP&#x2F;3 over QUIC and the issue seem to be mainly in the implementations.</div><br/></div></div></div></div></div></div><div id="41891574" class="c"><input type="checkbox" id="c-41891574" checked=""/><div class="controls bullet"><span class="by">cj</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891362">prev</a><span>|</span><a href="#41891077">next</a><span>|</span><label class="collapse" for="c-41891574">[-]</label><label class="expand" for="c-41891574">[2 more]</label></div><br/><div class="children"><div class="content">In other words:<p>Enable http&#x2F;3 + quic between client browser &lt;&gt; edge and restrict edge &lt;&gt; origin connections to http&#x2F;2 or http&#x2F;1<p>Cloudflare (as an example) only supports QUIC between client &lt;&gt; edge and doesn’t support it for connections to origin. Makes sense if the edge &lt;&gt; origin connection is reusable, stable, and “fast”.<p><a href="https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;speed&#x2F;optimization&#x2F;protocol&#x2F;http3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;speed&#x2F;optimization&#x2F;protoco...</a></div><br/><div id="41892865" class="c"><input type="checkbox" id="c-41892865" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891574">parent</a><span>|</span><a href="#41891077">next</a><span>|</span><label class="collapse" for="c-41892865">[-]</label><label class="expand" for="c-41892865">[1 more]</label></div><br/><div class="children"><div class="content">Cloudflare tunnels work over quic so this is not entirely correct</div><br/></div></div></div></div><div id="41891077" class="c"><input type="checkbox" id="c-41891077" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891574">prev</a><span>|</span><a href="#41891146">next</a><span>|</span><label class="collapse" for="c-41891077">[-]</label><label class="expand" for="c-41891077">[1 more]</label></div><br/><div class="children"><div class="content">Just as important is &gt; <i>we identify the root cause to be high receiver-side processing overhead, in particular, excessive data packets and QUIC&#x27;s user-space ACKs</i><p>It doesn&#x27;t sound like there&#x27;s a fundamental issue with the protocol.</div><br/></div></div><div id="41891146" class="c"><input type="checkbox" id="c-41891146" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891077">prev</a><span>|</span><a href="#41891071">next</a><span>|</span><label class="collapse" for="c-41891146">[-]</label><label class="expand" for="c-41891146">[20 more]</label></div><br/><div class="children"><div class="content">Internet access is only going to become faster. Switching to a slower transport just as Gigabit internet is proliferating would be a mistake, obviously.</div><br/><div id="41891292" class="c"><input type="checkbox" id="c-41891292" checked=""/><div class="controls bullet"><span class="by">ratorx</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891146">parent</a><span>|</span><a href="#41891187">next</a><span>|</span><label class="collapse" for="c-41891292">[-]</label><label class="expand" for="c-41891292">[4 more]</label></div><br/><div class="children"><div class="content">It depends on whether it’s meaningfully slower. QUIC is pretty optimized for standard web traffic, and more specifically for high-latency networks. Most websites also don’t send enough data for throughput to be a significant issue.<p>I’m not sure whether it’s possible, but could you theoretically offload large file downloads to HTTP&#x2F;2 to get best of both worlds?</div><br/><div id="41891490" class="c"><input type="checkbox" id="c-41891490" checked=""/><div class="controls bullet"><span class="by">pocketarc</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891292">parent</a><span>|</span><a href="#41891616">next</a><span>|</span><label class="collapse" for="c-41891490">[-]</label><label class="expand" for="c-41891490">[1 more]</label></div><br/><div class="children"><div class="content">&gt; could you theoretically offload large file downloads to HTTP&#x2F;2<p>Yes, you can! You’d have your websites on servers that support HTTP&#x2F;3 and your large files on HTTP&#x2F;2 servers, similar to how people put certain files on CDNs. It might well be a great solution!</div><br/></div></div><div id="41892614" class="c"><input type="checkbox" id="c-41892614" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891292">parent</a><span>|</span><a href="#41891616">prev</a><span>|</span><a href="#41891187">next</a><span>|</span><label class="collapse" for="c-41892614">[-]</label><label class="expand" for="c-41892614">[1 more]</label></div><br/><div class="children"><div class="content">High-latency networks are going away, too, with Cloudflare eating the web alive and all the other major clouds adding PoPs like crazy.</div><br/></div></div></div></div><div id="41891187" class="c"><input type="checkbox" id="c-41891187" checked=""/><div class="controls bullet"><span class="by">tomxor</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891146">parent</a><span>|</span><a href="#41891292">prev</a><span>|</span><a href="#41891205">next</a><span>|</span><label class="collapse" for="c-41891187">[-]</label><label class="expand" for="c-41891187">[5 more]</label></div><br/><div class="children"><div class="content">In terms of maximum available throughput it will obviously become greater. What&#x27;s less clear is if the median and worst throughput available throughout a nation or the world will continue to become substantially greater.<p>It&#x27;s simply not economical enough to lay fibre and put 5G masts everywhere (5G LTE bands covers less area due to being higher frequency, and so are also limited to being deployed in areas with a higher enough density to be economically justifiable).</div><br/><div id="41891795" class="c"><input type="checkbox" id="c-41891795" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891187">parent</a><span>|</span><a href="#41891425">next</a><span>|</span><label class="collapse" for="c-41891795">[-]</label><label class="expand" for="c-41891795">[3 more]</label></div><br/><div class="children"><div class="content">Fiber is <i>the</i> most economical solution, it&#x27;s compact, cheap, not susceptible to electromagnetic  interference from thunderstorms,  not interesting for metal thieves, etc.<p>Most importantly, it can be heavily over-provisioned for peanuts, so your cable is future-proof, and  you will never have dig the same trenches again.<p>Copper only makes sense if you already have it.</div><br/><div id="41892952" class="c"><input type="checkbox" id="c-41892952" checked=""/><div class="controls bullet"><span class="by">tomxor</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891795">parent</a><span>|</span><a href="#41891425">next</a><span>|</span><label class="collapse" for="c-41892952">[-]</label><label class="expand" for="c-41892952">[2 more]</label></div><br/><div class="children"><div class="content">Then why isn&#x27;t it everywhere, it&#x27;s been practical for over 40 years now.</div><br/><div id="41893719" class="c"><input type="checkbox" id="c-41893719" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892952">parent</a><span>|</span><a href="#41891425">next</a><span>|</span><label class="collapse" for="c-41893719">[-]</label><label class="expand" for="c-41893719">[1 more]</label></div><br/><div class="children"><div class="content">It is everywhere in new development. I remember Google buying tons of &quot;dark fiber&quot; capacity from telcos like 15 years ago; that fiber was likely laid for future needs 20-25 years ago. New apartment buildings in NYC just get fiber, with everything, including traditional &quot;cable TV&quot; with BNC connectors, powered by it.<p>But telcos have colossal copper networks, and they want to milk the last dollars from it before it has to be replaced, with digging and all. Hence price segmenting, with slower &quot;copper&quot; plans and premium &quot;fiber&quot; plans, obviously no matter if the building has fiber already.<p>Also, passive fiber interconnects have much higher losses than copper with RJ45s. This means you want to have no more than 2-3 connectors between pieces of active equipment, including from ISP to a building. This requires more careful planning, and this is why wiring past the apartment  (or even office  floor or a single-family house) level is usually copper Ethernet.</div><br/></div></div></div></div></div></div></div></div><div id="41891205" class="c"><input type="checkbox" id="c-41891205" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891146">parent</a><span>|</span><a href="#41891187">prev</a><span>|</span><a href="#41891071">next</a><span>|</span><label class="collapse" for="c-41891205">[-]</label><label class="expand" for="c-41891205">[10 more]</label></div><br/><div class="children"><div class="content">Here in Australia there’s talk of upgrading the National Broadband Network to 2.5 Gbps to match modern consumer Ethernet and WiFi speeds.<p>I grew up with 2400 baud modems as <i>the super fast upgrade</i>, so talk of multiple gigabits for consumers is blowing my mind a bit.</div><br/><div id="41891437" class="c"><input type="checkbox" id="c-41891437" checked=""/><div class="controls bullet"><span class="by">Kodiack</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891205">parent</a><span>|</span><a href="#41891278">next</a><span>|</span><label class="collapse" for="c-41891437">[-]</label><label class="expand" for="c-41891437">[4 more]</label></div><br/><div class="children"><div class="content">Meanwhile here in New Zealand we can get 10 Gbps FTTH already.<p>Sorry about your NBN!</div><br/><div id="41891508" class="c"><input type="checkbox" id="c-41891508" checked=""/><div class="controls bullet"><span class="by">wkat4242</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891437">parent</a><span>|</span><a href="#41891278">next</a><span>|</span><label class="collapse" for="c-41891508">[-]</label><label class="expand" for="c-41891508">[3 more]</label></div><br/><div class="children"><div class="content">Here in Spain too.<p>I don&#x27;t see a need for it yet though. I&#x27;m a really heavy user (it specialist with more than a hundred devices in my networks) and I really don&#x27;t need it.</div><br/><div id="41892619" class="c"><input type="checkbox" id="c-41892619" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891508">parent</a><span>|</span><a href="#41891278">next</a><span>|</span><label class="collapse" for="c-41892619">[-]</label><label class="expand" for="c-41892619">[2 more]</label></div><br/><div class="children"><div class="content">These things are nice-to-have until they become sufficiently widespread that typical consumer applications start to <i>require</i> the bandwidth. That comes much later.<p>E.g.: 8K 60 fps video streaming benefits from data rates up to about 1 Gbps in a noticeable way, but that&#x27;s at least a decade away form mainstream availability.</div><br/><div id="41893367" class="c"><input type="checkbox" id="c-41893367" checked=""/><div class="controls bullet"><span class="by">notpushkin</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892619">parent</a><span>|</span><a href="#41891278">next</a><span>|</span><label class="collapse" for="c-41893367">[-]</label><label class="expand" for="c-41893367">[1 more]</label></div><br/><div class="children"><div class="content">The other side of this particular coin is, when such bandwidth is widely available, suddenly a lot of apps that have worked just fine are now eating it up. I&#x27;m not looking forward to 9 gigabyte Webpack 2036 bundles everywhere :V</div><br/></div></div></div></div></div></div></div></div><div id="41891278" class="c"><input type="checkbox" id="c-41891278" checked=""/><div class="controls bullet"><span class="by">TechDebtDevin</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891205">parent</a><span>|</span><a href="#41891437">prev</a><span>|</span><a href="#41891071">next</a><span>|</span><label class="collapse" for="c-41891278">[-]</label><label class="expand" for="c-41891278">[5 more]</label></div><br/><div class="children"><div class="content">Is Australia&#x27;s ISP infrastructure nationalized?</div><br/><div id="41891529" class="c"><input type="checkbox" id="c-41891529" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891278">parent</a><span>|</span><a href="#41891071">next</a><span>|</span><label class="collapse" for="c-41891529">[-]</label><label class="expand" for="c-41891529">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a long story featuring nasty partisan politics, corrupt incumbents, Rupert Murdoch, and agile upstarts doing stealth rollouts at the crack of dawn.<p>Basically, the old copper lines were replaced by the NBN, which is a government-owned corporation that sells wholesale  networking to telcos. Essentially, the government has a monopoly, providing the last-mile fibre links. They use nested VLANs to provide layer-2 access to the consumer telcos.<p>Where it got complicated was that the right-wing government was in the pocket of Rupert Murdoch, who threatened them with negative press before an upcoming election. They bent over and grabbed their ankles like the good little Christian school boys they are, and torpedoed the NBN network technology to protect the incumbent Fox cable network. Instead of fibre going to all premises, the NBN ended up with a mix of technologies, most of which don&#x27;t scale to gigabit. It also took longer and cost more, despite the government responsible saying they were making these cuts to &quot;save taxpayer money&quot;.<p>Also for political reasons, they were rolling it out starting at the sparse rural areas and leaving the high-density CBD regions till last. This made it look bad, because if they spent $40K digging up the long rural dirt roads to every individual farmhouse, it obviously won&#x27;t have much of a return on the taxpayer&#x27;s investment... like it would have if deployed to areas with technology companies and their staff.<p>Some existing smaller telcos noticed that there was a loophole in the regulation that allowed them to connect the more lucrative tech-savvy customers to their own private fibre if it&#x27;s within 2km of an existing line. Companies like TPG had the entire CBD and inner suburban regions of every major city already 100% covered by this radius, so they proceeded to leapfrog the NBN and roll out their own 100 Mbps fibre-to-the-building service half a decade ahead. I saw their <i>unmarked white vans</i> stealthily rolling out extra fibre at like 3am to extend their coverage area before anyone in the government noticed.<p>The funny part was that FttB uses VDSL2 boxes in the basement for the last 100m going up to apartments, but <i>you can only have one</i> per building because they use active cross-talk cancellation. So by the time the NBN eventually got around to wiring the CBD regions, they got to the apartments to discover that &quot;oops, too late&quot;, private telcos had gotten there first!<p>There were lawsuits... which the government lost. After all, <i>they wrote the legislation</i>, they were just mad that they hadn&#x27;t actually understood it.<p>Meanwhile, some other incumbent fibre providers that should have disappeared persisted like a stubborn cockroach infestation. I&#x27;ve just moved to an apartment serviced by OptiComm, which has 1.1 out of 5 stars on Google... which should tell you something. They even have a grey fibre box that looks identical to the NBNCo box except it&#x27;s labelled LBNCo <i>with the same font</i> so that during a whirlwind apartment inspection you might not notice that you&#x27;re not going to be on the same high-speed Internet as the rest of the country.</div><br/><div id="41891961" class="c"><input type="checkbox" id="c-41891961" checked=""/><div class="controls bullet"><span class="by">dbaggerman</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891529">parent</a><span>|</span><a href="#41891071">next</a><span>|</span><label class="collapse" for="c-41891961">[-]</label><label class="expand" for="c-41891961">[3 more]</label></div><br/><div class="children"><div class="content">To clarify, NBN is a monopoly on the last mile infrastructure which is resold to private ISPs that sell internet services.<p>The history there is that Australia used to have a government run monopoly on telephone infrastructure and services (Telecom Australia), which was later privatised (and rebranded to Telstra). The privatisation left Telstra with a monopoly on the infrastructure, but also a requirement that they resell the last mile at a reasonable rate to allow for some competition.<p>So Australia already had an existing industry of ISPs that were already buying last mile access from someone else. The NBN was just a continuation of the existing status quo in that regard.<p>&gt; They even have a grey fibre box that looks identical to the NBNCo box except it&#x27;s labelled LBNCo with the same font<p>Early in my career I worked for one of those smaller telcos trying to race to get services into buildings before the NBN. I left around the time they were talking about introducing an LBNCo brand (only one of the reasons I left). At the time, they weren&#x27;t part of Opticomm, but did partner with them in a few locations. If the brand is still around, I guess they must have been acquired at some point.</div><br/><div id="41892626" class="c"><input type="checkbox" id="c-41892626" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891961">parent</a><span>|</span><a href="#41891071">next</a><span>|</span><label class="collapse" for="c-41892626">[-]</label><label class="expand" for="c-41892626">[2 more]</label></div><br/><div class="children"><div class="content">I heard from several sources that what they do is give the apartment builder a paper bag of cash in exchange for the right to use their wires instead of the NBN. Then they gouge the users with higher monthly fees.</div><br/><div id="41892945" class="c"><input type="checkbox" id="c-41892945" checked=""/><div class="controls bullet"><span class="by">dbaggerman</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892626">parent</a><span>|</span><a href="#41891071">next</a><span>|</span><label class="collapse" for="c-41892945">[-]</label><label class="expand" for="c-41892945">[1 more]</label></div><br/><div class="children"><div class="content">When I was there NBNCo hadn&#x27;t really moved into the inner city yet. We did have some kind of financial agreement with the building developer&#x2F;management to install our VDSL DSLAMs in their comms room. It wouldn&#x27;t surprise me if those payments got shadier and more aggressive as the NBN coverage increased.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41891071" class="c"><input type="checkbox" id="c-41891071" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891146">prev</a><span>|</span><a href="#41891497">next</a><span>|</span><label class="collapse" for="c-41891071">[-]</label><label class="expand" for="c-41891071">[35 more]</label></div><br/><div class="children"><div class="content">That is interesting though. 1gbit is becoming more common</div><br/><div id="41891194" class="c"><input type="checkbox" id="c-41891194" checked=""/><div class="controls bullet"><span class="by">schmidtleonard</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891071">parent</a><span>|</span><a href="#41891645">next</a><span>|</span><label class="collapse" for="c-41891194">[-]</label><label class="expand" for="c-41891194">[33 more]</label></div><br/><div class="children"><div class="content">It&#x27;s wild that 1gbit LAN has been &quot;standard&quot; for so long that the internet caught up.<p>Meanwhile, low-end computers ship with a dozen 10+Gbit class transceivers on USB, HDMI, Displayport, pretty much any external port except for ethernet, and twice that many on the PCIe backbone. But 10Gbit ethernet is still priced like it&#x27;s made from unicorn blood.</div><br/><div id="41891460" class="c"><input type="checkbox" id="c-41891460" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891194">parent</a><span>|</span><a href="#41891304">next</a><span>|</span><label class="collapse" for="c-41891460">[-]</label><label class="expand" for="c-41891460">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Meanwhile, low-end computers ship with a dozen 10+Gbit class transceivers on USB, HDMI, Displayport, pretty much any external port except for ethernet, and twice that many on the PCIe backbone. But 10Gbit ethernet is still priced like it&#x27;s made from unicorn blood.<p>You really can’t think of any major difference between 10G Ethernet and all of those other standards that might be responsible for the price difference?<p>Look at the supported lengths and cables. 10G Ethernet over copper can go an order of magnitude farther over relatively generic cables. Your USB-C or HDMI connections cannot go nearly as far and require significantly more tightly controlled cables and shielding.<p>That’s the difference. It’s not easy to accomplish what they did with 10G Ethernet over copper. They used a long list of tricks to squeeze every possible dB of SNR out of those cables. You pay for it with extremely complex transceivers that require significant die area and a laundry list of complex algorithms.</div><br/><div id="41891597" class="c"><input type="checkbox" id="c-41891597" checked=""/><div class="controls bullet"><span class="by">schmidtleonard</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891460">parent</a><span>|</span><a href="#41892302">next</a><span>|</span><label class="collapse" for="c-41891597">[-]</label><label class="expand" for="c-41891597">[1 more]</label></div><br/><div class="children"><div class="content">There was a time when FFE, DFE, CTLE, and FEC could reasonably be considered an extremely complex bag of tricks by the standards of the competition. That time passed many years ago. They&#x27;ve been table stakes for a while in every other serial standard. <i>Wifi</i> is beating ethernet at the low end, ffs, and you can&#x27;t tell me that air is a kinder channel. A low-end PC will ship with a dozen transceivers implementing all of these tricks sitting idle, while it&#x27;ll be lucky to have a single 2.5Gbe port and you&#x27;ll have to pay extra for the privilege.<p>No matter, eventually USB4NET will work out of the box. The USB-IF is a clown show and they have tripped over their shoelaces every step of the way, but consumer Ethernet hasn&#x27;t moved in 20 years so this horse race still has a clear favorite, lol.</div><br/></div></div><div id="41892302" class="c"><input type="checkbox" id="c-41892302" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891460">parent</a><span>|</span><a href="#41891597">prev</a><span>|</span><a href="#41891304">next</a><span>|</span><label class="collapse" for="c-41892302">[-]</label><label class="expand" for="c-41892302">[4 more]</label></div><br/><div class="children"><div class="content">You explained why 10G Ethernet <i>cables</i> are expensive, but why should it be so expensive to put a 10G-capable <i>port</i> on the computer compared to the other ports?</div><br/><div id="41892394" class="c"><input type="checkbox" id="c-41892394" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892302">parent</a><span>|</span><a href="#41891304">next</a><span>|</span><label class="collapse" for="c-41892394">[-]</label><label class="expand" for="c-41892394">[3 more]</label></div><br/><div class="children"><div class="content">Did you completely misunderstand OP? The 10G Ethernet cables are not expensive. In a pinch, even your Cat 5e cable is capable of 10G Ethernet albeit at a shorter distance than Cat 6 cable. Even then, it can be at least a dozen times longer than a similar USB or HDMI or DisplayPort cable.</div><br/><div id="41893195" class="c"><input type="checkbox" id="c-41893195" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892394">parent</a><span>|</span><a href="#41891304">next</a><span>|</span><label class="collapse" for="c-41893195">[-]</label><label class="expand" for="c-41893195">[2 more]</label></div><br/><div class="children"><div class="content">I did misunderstand it, because looking at it again now, they spent the entire post talking about how difficult it is to make the cables, except for the very last sentence where they mention die area one time, and it’s still not clear that they’re talking about die area for something that’s inside the computer rather than a chip that goes in the cable.<p>&gt; Look at the supported lengths and <i>cables</i>. … relatively generic <i>cables</i>. Your USB-C or HDMI connections cannot go nearly as far and require significantly more tightly controlled <i>cables</i> and shielding. … They used a long list of tricks to squeeze every possible dB of SNR out of those <i>cables</i>.</div><br/><div id="41893805" class="c"><input type="checkbox" id="c-41893805" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41893195">parent</a><span>|</span><a href="#41891304">next</a><span>|</span><label class="collapse" for="c-41893805">[-]</label><label class="expand" for="c-41893805">[1 more]</label></div><br/><div class="children"><div class="content">Their point was those systems like hdmi, bits of usb-c etc put the complexity is very expensive very short cables.<p>Meanwhile a 10g port on my home router will run over copper for far longer. Not that I’m a fan given the power use, fibre is much easier to deal with and will run for miles.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41891304" class="c"><input type="checkbox" id="c-41891304" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891194">parent</a><span>|</span><a href="#41891460">prev</a><span>|</span><a href="#41891326">next</a><span>|</span><label class="collapse" for="c-41891304">[-]</label><label class="expand" for="c-41891304">[5 more]</label></div><br/><div class="children"><div class="content">Those very fast consumer interconnects are distinguished from ethernet by very limited cable lengths though, none of them are going to push 10gbps over tens of meters nevermind a hundred. DisplayPort is up to 80gbps now but in that mode it can barely even cross 1.5m of heavily shielded copper before the signal dies.<p>In a perfect world we would start using fiber in consumer products that need to move that much bandwidth, but I think the standards bodies don&#x27;t trust consumers with bend radiuses and dust management so instead we keep inventing new ways to torture copper wires.</div><br/><div id="41891614" class="c"><input type="checkbox" id="c-41891614" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891304">parent</a><span>|</span><a href="#41891533">next</a><span>|</span><label class="collapse" for="c-41891614">[-]</label><label class="expand" for="c-41891614">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In a perfect world we would start using fiber in consumer products that need to move that much bandwidth<p>We are already doing this. USB-C is explicitly designed to allow for cables with active electronics, including conversion to &amp; from fiber. You could just buy an optical USB-C cable off Amazon, if you wanted to.</div><br/><div id="41892073" class="c"><input type="checkbox" id="c-41892073" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891614">parent</a><span>|</span><a href="#41891533">next</a><span>|</span><label class="collapse" for="c-41892073">[-]</label><label class="expand" for="c-41892073">[1 more]</label></div><br/><div class="children"><div class="content">When you make the cable do the conversion, you go from two expensive transceivers to six expensive transceivers.  And if the cable breaks you need to throw out four of them.  It&#x27;s a poor replacement for direct fiber use.</div><br/></div></div></div></div><div id="41891533" class="c"><input type="checkbox" id="c-41891533" checked=""/><div class="controls bullet"><span class="by">schmidtleonard</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891304">parent</a><span>|</span><a href="#41891614">prev</a><span>|</span><a href="#41891326">next</a><span>|</span><label class="collapse" for="c-41891533">[-]</label><label class="expand" for="c-41891533">[2 more]</label></div><br/><div class="children"><div class="content">Sure you need fiber for long runs at ultra bandwidth, but short runs are common and fiber is not a good reason for DAC to be expensive. Not within an order of magnitude of where it is.</div><br/><div id="41892108" class="c"><input type="checkbox" id="c-41892108" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891533">parent</a><span>|</span><a href="#41891326">next</a><span>|</span><label class="collapse" for="c-41892108">[-]</label><label class="expand" for="c-41892108">[1 more]</label></div><br/><div class="children"><div class="content">These days, passive cables that support ultra bandwidth are down to like .5 meters.<p>For anything that wants 10Gbps lanes or less, copper is fine.<p>For ultra bandwidth, going fiber-only is a tempting idea.</div><br/></div></div></div></div></div></div><div id="41891326" class="c"><input type="checkbox" id="c-41891326" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891194">parent</a><span>|</span><a href="#41891304">prev</a><span>|</span><a href="#41891250">next</a><span>|</span><label class="collapse" for="c-41891326">[-]</label><label class="expand" for="c-41891326">[3 more]</label></div><br/><div class="children"><div class="content">Agree that a widespread faster ethernet is long overdue.<p>But bear in mind, standards like USB4 only support very short cables. It&#x27;s impressive that USB4 can offer 40 Gbps - but it can only do so on 1m cables. On the other hand, 10 gigabit ethernet claims to go 100m on CAT6A.</div><br/><div id="41891634" class="c"><input type="checkbox" id="c-41891634" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891326">parent</a><span>|</span><a href="#41891250">next</a><span>|</span><label class="collapse" for="c-41891634">[-]</label><label class="expand" for="c-41891634">[2 more]</label></div><br/><div class="children"><div class="content">USB4 <i>does</i> support longer distances, but those cables need active electronics to guarantee signal integrity. That&#x27;s how you end up with Apple&#x27;s $160 3-meter cable.</div><br/><div id="41893835" class="c"><input type="checkbox" id="c-41893835" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891634">parent</a><span>|</span><a href="#41891250">next</a><span>|</span><label class="collapse" for="c-41893835">[-]</label><label class="expand" for="c-41893835">[1 more]</label></div><br/><div class="children"><div class="content">A 3m 100g dac is 1&#x2F;3 the price</div><br/></div></div></div></div></div></div><div id="41891250" class="c"><input type="checkbox" id="c-41891250" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891194">parent</a><span>|</span><a href="#41891326">prev</a><span>|</span><a href="#41891692">next</a><span>|</span><label class="collapse" for="c-41891250">[-]</label><label class="expand" for="c-41891250">[16 more]</label></div><br/><div class="children"><div class="content">2.5Gbps is becoming pretty common and fairly affordable, though<p>My understanding is right around 10Gbps you start to hit limitations with the shielding&#x2F;type of cable and power needed to transmit&#x2F;send over Ethernet.<p>When I was looking to upgrade at home, I had to get expensive PoE+ injectors and splitters to power the switch in the closet (where there&#x27;s no outlet) and 10Gbps SFP+ transceivers are like $10 for fiber or $40 for Ethernet. The Ethernet transceivers hit like 40-50C</div><br/><div id="41891559" class="c"><input type="checkbox" id="c-41891559" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891250">parent</a><span>|</span><a href="#41891404">next</a><span>|</span><label class="collapse" for="c-41891559">[-]</label><label class="expand" for="c-41891559">[9 more]</label></div><br/><div class="children"><div class="content">The main issue is switches, really. 5Gbps USB NICs are available for $30 on Amazon, or $20 on AliExpress. 10Gbps NICS are $60, so not exactly crazy expensive either.<p>But switches haven&#x27;t really kept up. A simple unmanaged 5-port or 8-port 2.5GigE isn&#x27;t too bad, but anything beyond that gets tricky. 5GigE switches don&#x27;t seem to exist, and you&#x27;re already paying $500 for a budget-brand 10GigE switch with basic VLAN support. You want PoE? Forget it.<p>The irony is that at 10Gbps fiber suddenly becomes quite attractive. A brand-new SFP+ NIC can be found for $30, with DACs only $5 (per side) and transceivers $30 or so. You can get an actually-decent switch from Mikrotik for less than $300.<p>Heck, you can even get brand-new dualport SFP28 NICs for $100, or as little as $25 on Ebay! Switch-wise you can get 16 ports of 25Gbps out of a $800 Mikrotik switch: not exactly <i>cheap</i>, but definitely within range for a very enthusiastic homelabber.<p>The only issue is that wiring your home for fiber is stupidly expensive, and you can&#x27;t exactly use it to power access points either.</div><br/><div id="41892578" class="c"><input type="checkbox" id="c-41892578" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891559">parent</a><span>|</span><a href="#41891984">next</a><span>|</span><label class="collapse" for="c-41892578">[-]</label><label class="expand" for="c-41892578">[1 more]</label></div><br/><div class="children"><div class="content">Apparently there is the <a href="https:&#x2F;&#x2F;store.ui.com&#x2F;us&#x2F;en&#x2F;products&#x2F;us-xg-6poe" rel="nofollow">https:&#x2F;&#x2F;store.ui.com&#x2F;us&#x2F;en&#x2F;products&#x2F;us-xg-6poe</a> from Ubiquity. It only has 4 10GbE ports but they all have PoE.</div><br/></div></div><div id="41891984" class="c"><input type="checkbox" id="c-41891984" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891559">parent</a><span>|</span><a href="#41892578">prev</a><span>|</span><a href="#41891404">next</a><span>|</span><label class="collapse" for="c-41891984">[-]</label><label class="expand" for="c-41891984">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The only issue is that wiring your home for fiber is stupidly expensive<p>What do you mean by that? My home isnt wired for ethernet. I can buy 30m of CAT6 cable for £7, or 30m of fibre for £17. For a home use, that&#x27;s a decent amount of cable, and even spending £100 on cabling will likely run cables to even the biggest of houses.</div><br/><div id="41892627" class="c"><input type="checkbox" id="c-41892627" checked=""/><div class="controls bullet"><span class="by">hakfoo</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891984">parent</a><span>|</span><a href="#41891404">next</a><span>|</span><label class="collapse" for="c-41892627">[-]</label><label class="expand" for="c-41892627">[6 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the expensive part more the assembly aspect?  For Cat 6 the plugs and keystone jacks add up to a few dollars per port, and the crimper is like $20.  I understand building your own fibre cables-- if you don&#x27;t want to thread them through walls without the heads pre-attached, for example-- involves more sophisticated glass-fusion tools that are fairly expensive.<p>A rental service might help there, or a call-in service-- the 6 hours of drilling holes and pulling fibre can be done by yourself, and once it&#x27;s all cut to rough length, bring out a guy who can fuse on 10 plugs in an hour for $150.</div><br/><div id="41893860" class="c"><input type="checkbox" id="c-41893860" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892627">parent</a><span>|</span><a href="#41892963">next</a><span>|</span><label class="collapse" for="c-41893860">[-]</label><label class="expand" for="c-41893860">[1 more]</label></div><br/><div class="children"><div class="content">My single mode keystones pass through were about the same price as cat5, and pre-made cables were no harder to run than un terminated cat5.</div><br/></div></div><div id="41892963" class="c"><input type="checkbox" id="c-41892963" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892627">parent</a><span>|</span><a href="#41893860">prev</a><span>|</span><a href="#41891404">next</a><span>|</span><label class="collapse" for="c-41892963">[-]</label><label class="expand" for="c-41892963">[4 more]</label></div><br/><div class="children"><div class="content">If you particularly want to use a raw spool, then yes that&#x27;s an annoying cost.  If you buy premade cables for an extra $5 each then it&#x27;s fine.</div><br/><div id="41893210" class="c"><input type="checkbox" id="c-41893210" checked=""/><div class="controls bullet"><span class="by">hakfoo</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892963">parent</a><span>|</span><a href="#41893331">next</a><span>|</span><label class="collapse" for="c-41893210">[-]</label><label class="expand" for="c-41893210">[1 more]</label></div><br/><div class="children"><div class="content">A practical drawback to premade cables is the need for a larger hole to accommodate the pre-attached connector.  There&#x27;s also a larger gap that needs to be plugged around the cable to prevent leaks into he wall.<p>My ordinary home-centre electric drill and an affordable ~7mm masonry bit lets me drill a hole in stucco large enough to accept bare cables with a very narrow gap to worry about.</div><br/></div></div><div id="41893331" class="c"><input type="checkbox" id="c-41893331" checked=""/><div class="controls bullet"><span class="by">inferiorhuman</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41892963">parent</a><span>|</span><a href="#41893210">prev</a><span>|</span><a href="#41891404">next</a><span>|</span><label class="collapse" for="c-41893331">[-]</label><label class="expand" for="c-41893331">[2 more]</label></div><br/><div class="children"><div class="content">Where are you finding them for that cheap?  OP is talking about 20GBP for a run of fiber.  If I look at, for instance, Ubiquiti their direct attach cables start at $13 for 0.5 meter cables.</div><br/><div id="41893480" class="c"><input type="checkbox" id="c-41893480" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41893331">parent</a><span>|</span><a href="#41891404">next</a><span>|</span><label class="collapse" for="c-41893480">[-]</label><label class="expand" for="c-41893480">[1 more]</label></div><br/><div class="children"><div class="content">I was looking at patch cables.  Ubiquiti&#x27;s start at $4.80</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41891404" class="c"><input type="checkbox" id="c-41891404" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891250">parent</a><span>|</span><a href="#41891559">prev</a><span>|</span><a href="#41891378">next</a><span>|</span><label class="collapse" for="c-41891404">[-]</label><label class="expand" for="c-41891404">[1 more]</label></div><br/><div class="children"><div class="content">40-50C? What is the brand?<p>Mine were over 90C, resulting in thermal shutdowns. I had to add an improvised heat exchanger to lower it down to ~70C: <a href="https:&#x2F;&#x2F;pics.archie.alex.net&#x2F;share&#x2F;U0G1yiWzShqOGXulwe1AetDjRdfBOHilPBPNeRYQgcaWOtFOOXWrZ--Rht8WuKeLQkE" rel="nofollow">https:&#x2F;&#x2F;pics.archie.alex.net&#x2F;share&#x2F;U0G1yiWzShqOGXulwe1AetDjR...</a></div><br/></div></div><div id="41891378" class="c"><input type="checkbox" id="c-41891378" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891250">parent</a><span>|</span><a href="#41891404">prev</a><span>|</span><a href="#41892154">next</a><span>|</span><label class="collapse" for="c-41891378">[-]</label><label class="expand" for="c-41891378">[4 more]</label></div><br/><div class="children"><div class="content">Ironically..  2.5 Gbps is created by taking a 10GBASE-T module and effectively underclocking it.  I wonder if &quot;automatic speed selection&quot; is around the corner with modules that automatically connect at 100Mbps to 10Gbps based on available cable quality.</div><br/><div id="41891448" class="c"><input type="checkbox" id="c-41891448" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891378">parent</a><span>|</span><a href="#41892154">next</a><span>|</span><label class="collapse" for="c-41891448">[-]</label><label class="expand" for="c-41891448">[3 more]</label></div><br/><div class="children"><div class="content">My 10G modules automatically drop down to 2.5G or 1G if the cable is not good enough. There&#x27;s also 5G, but I have never seen it work better than 2.5G.</div><br/><div id="41893870" class="c"><input type="checkbox" id="c-41893870" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891448">parent</a><span>|</span><a href="#41891893">next</a><span>|</span><label class="collapse" for="c-41893870">[-]</label><label class="expand" for="c-41893870">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think my 10g coppers will drop to 10m. 100m sure, but 10m rings a bell.</div><br/></div></div><div id="41891893" class="c"><input type="checkbox" id="c-41891893" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891448">parent</a><span>|</span><a href="#41893870">prev</a><span>|</span><a href="#41892154">next</a><span>|</span><label class="collapse" for="c-41891893">[-]</label><label class="expand" for="c-41891893">[1 more]</label></div><br/><div class="children"><div class="content">Oh man.  I&#x27;ve been off the IT floor for too long.  Time to change my rhetoric,  ya&#x27;ll have been around the corner for a while.<p>Aging has it&#x27;s upsides and downsides I guess.</div><br/></div></div></div></div></div></div><div id="41892154" class="c"><input type="checkbox" id="c-41892154" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891250">parent</a><span>|</span><a href="#41891378">prev</a><span>|</span><a href="#41891692">next</a><span>|</span><label class="collapse" for="c-41892154">[-]</label><label class="expand" for="c-41892154">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My understanding is right around 10Gbps you start to hit limitations with the shielding&#x2F;type of cable and power needed to transmit&#x2F;send over Ethernet.<p>If you decide you only need 50 meters, that reduces both power and cable requirements by a lot.  Did we decide to ignore the easy solution in favor of stagnation?</div><br/></div></div></div></div><div id="41891692" class="c"><input type="checkbox" id="c-41891692" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891194">parent</a><span>|</span><a href="#41891250">prev</a><span>|</span><a href="#41892294">next</a><span>|</span><label class="collapse" for="c-41891692">[-]</label><label class="expand" for="c-41891692">[1 more]</label></div><br/><div class="children"><div class="content">It passed it! Here there are offers up to 3gbit residential (Vancouver). I had 1.5 bit for a while. Downgraded to 1gbit because while I love fast internet, right now nobody in the home uses it enough to affect 1gbit speed</div><br/></div></div><div id="41892294" class="c"><input type="checkbox" id="c-41892294" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891194">parent</a><span>|</span><a href="#41891692">prev</a><span>|</span><a href="#41891645">next</a><span>|</span><label class="collapse" for="c-41892294">[-]</label><label class="expand" for="c-41892294">[1 more]</label></div><br/><div class="children"><div class="content">There is an argument to be made that gigabit ethernet is &quot;good enough&quot; for Joe Average.<p>Gigabit ethernet is ~100MB&#x2F;s transfer speed over copper wire or ~30MB&#x2F;s over wireless accounting for overhead and degradation. That is more than fast enough for most people.<p>10gbit is seemingly made from unicorn blood and 2.5gbit is seeing limited adoption because there simply isn&#x27;t demand for them outside of enterprise who have lots of unicorn blood in their banks.</div><br/></div></div></div></div></div></div><div id="41891497" class="c"><input type="checkbox" id="c-41891497" checked=""/><div class="controls bullet"><span class="by">wkat4242</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891071">prev</a><span>|</span><a href="#41891685">next</a><span>|</span><label class="collapse" for="c-41891497">[-]</label><label class="expand" for="c-41891497">[1 more]</label></div><br/><div class="children"><div class="content">For local purposes that&#x27;s certainly true. It seems that quic trades a faster connection establishment for lower throughput. I personally prefer tcp anyway.</div><br/></div></div><div id="41891685" class="c"><input type="checkbox" id="c-41891685" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891497">prev</a><span>|</span><a href="#41891480">next</a><span>|</span><label class="collapse" for="c-41891685">[-]</label><label class="expand" for="c-41891685">[2 more]</label></div><br/><div class="children"><div class="content">Gigabit connections are widely available in urban areas. The problem  is not theoretical, but definitely is pretty recent &#x2F; nascent.</div><br/><div id="41891775" class="c"><input type="checkbox" id="c-41891775" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891685">parent</a><span>|</span><a href="#41891480">next</a><span>|</span><label class="collapse" for="c-41891775">[-]</label><label class="expand" for="c-41891775">[1 more]</label></div><br/><div class="children"><div class="content">A gigabit connection is just one prerequisite.  The server also has to be sending very big bursts of foreground&#x2F;immediate data or you&#x27;re very unlikely to notice anything.</div><br/></div></div></div></div><div id="41891480" class="c"><input type="checkbox" id="c-41891480" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891685">prev</a><span>|</span><a href="#41891800">next</a><span>|</span><label class="collapse" for="c-41891480">[-]</label><label class="expand" for="c-41891480">[2 more]</label></div><br/><div class="children"><div class="content">In Switzerland you get 25 Gbit&#x2F;s for $60&#x2F;month.<p>In 30 years it will be even faster. It would be silly to have to use older protocols to get line speed.</div><br/><div id="41891509" class="c"><input type="checkbox" id="c-41891509" checked=""/><div class="controls bullet"><span class="by">77pt77</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891480">parent</a><span>|</span><a href="#41891800">next</a><span>|</span><label class="collapse" for="c-41891509">[-]</label><label class="expand" for="c-41891509">[1 more]</label></div><br/><div class="children"><div class="content">Now do the same in Germany...</div><br/></div></div></div></div><div id="41891800" class="c"><input type="checkbox" id="c-41891800" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41890996">parent</a><span>|</span><a href="#41891480">prev</a><span>|</span><a href="#41891085">next</a><span>|</span><label class="collapse" for="c-41891800">[-]</label><label class="expand" for="c-41891800">[2 more]</label></div><br/><div class="children"><div class="content">&gt; below 600 Mbit&#x2F;s is implied as being &quot;Slow Internet&quot; in the intro<p>Or rather, not &quot;Fast Internet&quot;</div><br/><div id="41892077" class="c"><input type="checkbox" id="c-41892077" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41890996">root</a><span>|</span><a href="#41891800">parent</a><span>|</span><a href="#41891085">next</a><span>|</span><label class="collapse" for="c-41892077">[-]</label><label class="expand" for="c-41892077">[1 more]</label></div><br/><div class="children"><div class="content">Yeah.</div><br/></div></div></div></div></div></div><div id="41891085" class="c"><input type="checkbox" id="c-41891085" checked=""/><div class="controls bullet"><span class="by">Tempest1981</span><span>|</span><a href="#41890996">prev</a><span>|</span><a href="#41891157">next</a><span>|</span><label class="collapse" for="c-41891085">[-]</label><label class="expand" for="c-41891085">[31 more]</label></div><br/><div class="children"><div class="content">From September:<p>QUIC is not quick enough over fast internet (acm.org)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41484991">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41484991</a> (327 comments)</div><br/><div id="41891107" class="c"><input type="checkbox" id="c-41891107" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">parent</a><span>|</span><a href="#41893876">next</a><span>|</span><label class="collapse" for="c-41891107">[-]</label><label class="expand" for="c-41891107">[29 more]</label></div><br/><div class="children"><div class="content">My personal takeaway from that: Perhaps we shouldn&#x27;t let Google design and more or less unilaterally dictate and enforce internet protocol usage via Chromium.<p>Brave&#x2F;Vivaldi&#x2F;Opera&#x2F;etc: You should make a conscious choice.</div><br/><div id="41891374" class="c"><input type="checkbox" id="c-41891374" checked=""/><div class="controls bullet"><span class="by">ratorx</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891107">parent</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41891374">[-]</label><label class="expand" for="c-41891374">[23 more]</label></div><br/><div class="children"><div class="content">Having read through that thread, most of the (top) comments are somewhat related to the lacking performance of the UDP&#x2F;QUIC stack and thoughts on the meaningfulness of the speeds in the test. There is a single comment suggesting HTTP&#x2F;2 was rushed (because server push was later deprecated).<p>QUIC is also acknowledged as being quite different from the Google version, and incorporating input from many different people.<p>Could you expand more on why this seems like evidence that Google unilaterally dictating bad standards? None of the changes in protocol seem objectively wrong (except possibly Server Push).<p>Disclaimer: Work at Google on networking, but unrelated to QUIC and other protocol level stuff.</div><br/><div id="41891400" class="c"><input type="checkbox" id="c-41891400" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891374">parent</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41891400">[-]</label><label class="expand" for="c-41891400">[22 more]</label></div><br/><div class="children"><div class="content">&gt; Could you expand more on why this seems like evidence that Google unilaterally dictating bad standards?<p>I guess I&#x27;m just generally disgusted in the way Google is poisoning the web in the worst way possible: By pushing ever more complex standards. Imagine the complexity of the web stack in 2050 if we continue to let Google run things. It&#x27;s Microsoft&#x27;s old embrace-extend-and-extinguish scheme taken to the next level.<p>In short: it&#x27;s not you, it&#x27;s your manager&#x27;s manager&#x27;s manager&#x27;s manager&#x27;s strategy that is messed up.</div><br/><div id="41891552" class="c"><input type="checkbox" id="c-41891552" checked=""/><div class="controls bullet"><span class="by">ratorx</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891400">parent</a><span>|</span><a href="#41891503">next</a><span>|</span><label class="collapse" for="c-41891552">[-]</label><label class="expand" for="c-41891552">[8 more]</label></div><br/><div class="children"><div class="content">This is making a pretty big assumption that the web is perfectly fine the way it is and never needs to change.<p>In reality, there are perfectly valid reasons that motivate QUIC and HTTP&#x2F;2 and I don’t think there is a reasonable argument that they are objectively bad. Now, for your personal use case, it might not be worth it, but that’s a different argument. The standards are built for the majority.<p>All systems have tradeoffs. Increased complexity is undesirable, but whether it is bad or not depends on the benefits. Just blanket making a statement that increasing complexity is bad, and the runaway effects of that in 2050 would be worse does not seem particularly useful.</div><br/><div id="41891586" class="c"><input type="checkbox" id="c-41891586" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891552">parent</a><span>|</span><a href="#41891503">next</a><span>|</span><label class="collapse" for="c-41891586">[-]</label><label class="expand" for="c-41891586">[7 more]</label></div><br/><div class="children"><div class="content">Nothing is perfect. But gigantic big bang changes (like from HTTP 1.1 to 2.0) enforced by a browser mono culture and a dominant company with several thousands of individually well-meaning Chromium software engineers like yourself - yeah, pretty sure that&#x27;s bad.</div><br/><div id="41891762" class="c"><input type="checkbox" id="c-41891762" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891586">parent</a><span>|</span><a href="#41891503">next</a><span>|</span><label class="collapse" for="c-41891762">[-]</label><label class="expand" for="c-41891762">[6 more]</label></div><br/><div class="children"><div class="content">Except that HTTP&#x2F;1.1 to HTTP&#x2F;2 was not a big bang change on the ecosystem level. No server or browser was forced to implement HTTP&#x2F;2 to remain interoperable[0]. I bet you can&#x27;t point any of this &quot;enforcement&quot; you claim happened. If other browser implemented HTTP&#x2F;2, it was because they thought that the benefits of H2 outweighed any downsides.<p>[0] There are non-browser protocols that are based on H2 only, but since your complaint was explicitly about browsers, I know that&#x27;s not what you had in mind.</div><br/><div id="41891785" class="c"><input type="checkbox" id="c-41891785" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891762">parent</a><span>|</span><a href="#41891503">next</a><span>|</span><label class="collapse" for="c-41891785">[-]</label><label class="expand" for="c-41891785">[5 more]</label></div><br/><div class="children"><div class="content">You are missing the entire point: Complexity.<p>It&#x27;s not your fault, in case you were working on this. It was likely the result a strategy thing being decided at Google&#x2F;Alphabet exec level.<p>Several thousand very competent C++ software engineers don&#x27;t come cheap.</div><br/><div id="41891904" class="c"><input type="checkbox" id="c-41891904" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891785">parent</a><span>|</span><a href="#41891503">next</a><span>|</span><label class="collapse" for="c-41891904">[-]</label><label class="expand" for="c-41891904">[4 more]</label></div><br/><div class="children"><div class="content">I mean, the reason I was discussing those specific aspects is that you&#x27;re the one brought them up. You made the claim about how HTTP&#x2F;2 was a &quot;big bang&quot; change. You&#x27;re the one who made the claim that HTTP&#x2F;2 was enforced on the ecosystem by Google.<p>And it seems that you can&#x27;t support either of those claims in any way. In fact, you&#x27;re just pretending that you never made those comments at all, and have once again pivoted to a new grievance.<p>But the new grievance is equally nonsensical. HTTP&#x2F;2 is not particularly complex, and <i>nobody on either the server or browser side was forced to implement it</i>. Only those who thought the minimal complexity was worth it needed to do it. Everyone else remained fully interoperable.<p>I&#x27;m not entirely sure where you&#x27;re coming from here, to be honest. Like, is your belief that there are no possible tradeoffs here? Nothing can ever justify even such minor amounts of complexity, no matter how large the benefits are? Or do you accept that there are tradeoffs, and are &quot;just&quot; disagree with every developer who made a different call on this when choosing whether to support HTTP&#x2F;2 in their (non-Google) browser or server?</div><br/><div id="41891920" class="c"><input type="checkbox" id="c-41891920" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891904">parent</a><span>|</span><a href="#41891503">next</a><span>|</span><label class="collapse" for="c-41891920">[-]</label><label class="expand" for="c-41891920">[3 more]</label></div><br/><div class="children"><div class="content">Edit: this whole comment is incorrect. I was really thinking about HTTP 3.0, not 2.0.<p>HTTP&#x2F;2 is not &quot;particularly complex?&quot; Come on! Do remember where we started.<p>&gt; I&#x27;m not entirely sure where you&#x27;re coming from here, to be honest. Like, is your belief that there are no possible tradeoffs here? Nothing can ever justify even such minor amounts of complexity, no matter how large the benefits are? Or do you accept that there are tradeoffs, and are &quot;just&quot; disagree with every developer who made a different call on this when choosing whether to support HTTP&#x2F;2 in their (non-Google) browser or server?<p>&quot;Such minor amounts of complexity&quot;. Ahem.<p>I believe there are tradeoffs. I don&#x27;t believe that HTTP&#x2F;2 met that tradeoff between complexity vs benefit. I do believe it benefitted Google.</div><br/><div id="41892103" class="c"><input type="checkbox" id="c-41892103" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891920">parent</a><span>|</span><a href="#41891503">next</a><span>|</span><label class="collapse" for="c-41892103">[-]</label><label class="expand" for="c-41892103">[2 more]</label></div><br/><div class="children"><div class="content">&quot;We&quot; started from you making outlandish claims about HTTP&#x2F;2 and immediately pivoting to a new complaint when rebutted rather than admit you were wrong.<p>Yes, HTTP&#x2F;2 is not really complex as far as these things go. You just keep making that assertion as if it was self-evident, but it isn&#x27;t. Like, can you maybe just name the parts you think are unnecessary complex? And then we can discuss just how complex they really are, and what the benefits are.<p>(Like, sure, having header compression is more complicated than not having it. But it&#x27;s also an amazingly beneficial tradeoff, so it can&#x27;t be what you had in mind.)<p>&gt; I believe there are tradeoffs. I don&#x27;t believe that HTTP&#x2F;2 met that tradeoff between complexity vs benefit.<p>So why did Firefox implement it? Safari? Basically all the production level web servers? Google didn&#x27;t force them to do it. The developers of all of that software had agency, evaluated the tradeoffs, and decided it was worth implementing. What makes you a better judge of the tradoffs than all of these <i>non-Google</i> entities?</div><br/><div id="41892192" class="c"><input type="checkbox" id="c-41892192" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41892103">parent</a><span>|</span><a href="#41891503">next</a><span>|</span><label class="collapse" for="c-41892192">[-]</label><label class="expand" for="c-41892192">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, sorry, I mixed up 2.0 (the one that still uses TCP) with 3.0. Sorry for wasting your time.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41891503" class="c"><input type="checkbox" id="c-41891503" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891400">parent</a><span>|</span><a href="#41891552">prev</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41891503">[-]</label><label class="expand" for="c-41891503">[13 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s Microsoft&#x27;s old embrace-extend-and-extinguish scheme taken to the next level.<p>It literally is not.</div><br/><div id="41891506" class="c"><input type="checkbox" id="c-41891506" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891503">parent</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41891506">[-]</label><label class="expand" for="c-41891506">[12 more]</label></div><br/><div class="children"><div class="content">Because?<p>Edit: I&#x27;m not the first person to make this comparison. Witness the Chrome section in this article:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Embrace,_extend,_and_extinguish#Google_Chrome" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Embrace,_extend,_and_extinguis...</a></div><br/><div id="41891590" class="c"><input type="checkbox" id="c-41891590" checked=""/><div class="controls bullet"><span class="by">ratorx</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891506">parent</a><span>|</span><a href="#41891571">next</a><span>|</span><label class="collapse" for="c-41891590">[-]</label><label class="expand" for="c-41891590">[4 more]</label></div><br/><div class="children"><div class="content">Contributing to an open standard seems to be the opposite of the classic example.<p>Assume that change X for the web is positive overall. Currently Google’s strategy is to implement in Chrome and collect data on usefulness, then propose a standard and have other people contribute to it.<p>That approach seems pretty optimal. How else would you do it?</div><br/><div id="41891628" class="c"><input type="checkbox" id="c-41891628" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891590">parent</a><span>|</span><a href="#41891571">next</a><span>|</span><label class="collapse" for="c-41891628">[-]</label><label class="expand" for="c-41891628">[3 more]</label></div><br/><div class="children"><div class="content">When was the last time the Chromium team fit in a single hotel? How many are you now? 3k? certainly not 4k browser engineers?</div><br/><div id="41891648" class="c"><input type="checkbox" id="c-41891648" checked=""/><div class="controls bullet"><span class="by">ratorx</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891628">parent</a><span>|</span><a href="#41891571">next</a><span>|</span><label class="collapse" for="c-41891648">[-]</label><label class="expand" for="c-41891648">[2 more]</label></div><br/><div class="children"><div class="content">How does this have any relevance to my comment?</div><br/><div id="41891655" class="c"><input type="checkbox" id="c-41891655" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891648">parent</a><span>|</span><a href="#41891571">next</a><span>|</span><label class="collapse" for="c-41891655">[-]</label><label class="expand" for="c-41891655">[1 more]</label></div><br/><div class="children"><div class="content">How does your comment have any relevance to what we are discussing throughout this thread?</div><br/></div></div></div></div></div></div></div></div><div id="41891571" class="c"><input type="checkbox" id="c-41891571" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891506">parent</a><span>|</span><a href="#41891590">prev</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41891571">[-]</label><label class="expand" for="c-41891571">[7 more]</label></div><br/><div class="children"><div class="content">Well it may be possible to make the comparison in other things google does (they have done a lot of things) it makes no sense for quic&#x2F;http3.<p>What are they extending in this analogy? Http3 is not an extension of http. What are they extinguishing? There is no plan to get rid of http1&#x2F;2, since you still need it in lots of networks that dont allow udp.<p>Additionally, its an open standard, with an rfc, and multiple competing implementations (including firefox and i believe experimental in safari). The entire point of embrace, extend, extinguish is that the extension is not well specified making it dufficult for competitors to implement. That is simply not what is happening here.</div><br/><div id="41891709" class="c"><input type="checkbox" id="c-41891709" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891571">parent</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41891709">[-]</label><label class="expand" for="c-41891709">[6 more]</label></div><br/><div class="children"><div class="content">What I meant with Microsoft&#x27;s Embrace, extend, and extinguish (EEE) scheme taken to the next level is what Google has done to the web via Chromium:<p>They have several thousand C++ browser engineers (and as many web standards people as they could get their hands on, early on). Combined with a dominant browser market share, this has let them dominate browser standards, and even internet protocols. They have abused this dominant position to eliminate all competitors except Apple and (so far) Mozilla. It&#x27;s quite clever.</div><br/><div id="41893616" class="c"><input type="checkbox" id="c-41893616" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891709">parent</a><span>|</span><a href="#41892178">next</a><span>|</span><label class="collapse" for="c-41893616">[-]</label><label class="expand" for="c-41893616">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They have abused this dominant position to eliminate all competitors except Apple and (so far) Mozilla.<p>But that&#x27;s like all of them. Except edge but that was mostly dead before chrome came on the scene.<p>It seems like you are using embrace, extend, extinguish to just mean, &quot;be succesful&quot;, but that&#x27;s not what the term means. Being a market leader is not the same thing as embrace, extend, extinguish. Neither is putting competition out of business.</div><br/></div></div><div id="41892178" class="c"><input type="checkbox" id="c-41892178" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891709">parent</a><span>|</span><a href="#41893616">prev</a><span>|</span><a href="#41891918">next</a><span>|</span><label class="collapse" for="c-41892178">[-]</label><label class="expand" for="c-41892178">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What I meant with Microsoft&#x27;s Embrace, extend, and extinguish (EEE) scheme taken to the next level is what Google has done to the web via Chromium<p>I think this argument is reasonable, but QUIC isn&#x27;t part of the problem.</div><br/></div></div><div id="41891918" class="c"><input type="checkbox" id="c-41891918" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891709">parent</a><span>|</span><a href="#41892178">prev</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41891918">[-]</label><label class="expand" for="c-41891918">[3 more]</label></div><br/><div class="children"><div class="content">Microsoft just did shit, whatever they wanted. Google has worked with all the w3c committees and other browsers with tireless commitment to participation, with endless review.<p>It&#x27;s such a tired sad trope of people disaffected with the web because they can&#x27;t implement it by themselves easily. I&#x27;m so exhausted by this anti-progress terrorism; the world&#x27;s shared hypermedia should be rich and capable.<p>We also see lots of strong progress these days from newcomers like Ladybird, and Servo seems gearing up to be more browser like.</div><br/><div id="41891955" class="c"><input type="checkbox" id="c-41891955" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891918">parent</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41891955">[-]</label><label class="expand" for="c-41891955">[2 more]</label></div><br/><div class="children"><div class="content">Yes, Google found the loophole: brute-force standards complexity by hiring thousands of very competent engineers eager to leave their mark on the web and eager to get promoted. The only thing they needed was lots of money, and they had just that.<p>I think my message here is only hard to understand if your salary (or personal worth etc) depends on not understanding it. It&#x27;s really not that <i>complex</i>.</div><br/><div id="41893552" class="c"><input type="checkbox" id="c-41893552" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891955">parent</a><span>|</span><a href="#41891355">next</a><span>|</span><label class="collapse" for="c-41893552">[-]</label><label class="expand" for="c-41893552">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think my message here is only hard to understand if your salary (or personal worth etc) depends on not understanding it. It&#x27;s really not that complex.<p>Just because someone disagrees with you, doesn&#x27;t mean they don&#x27;t understand you.<p>However, if you think google is making standards unneccessarily complex, you should read some of the standards from the 2000s (e.g. SAML).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41891355" class="c"><input type="checkbox" id="c-41891355" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891107">parent</a><span>|</span><a href="#41891374">prev</a><span>|</span><a href="#41891197">next</a><span>|</span><label class="collapse" for="c-41891355">[-]</label><label class="expand" for="c-41891355">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, but QUIC is not bad as a protocol. The problem here is that OSes are not as well optimized for QUIC as they are for TCP. Just give it time, the paper even has suggestions.<p>QUIC has some debatable properties, like mandatory encryption, or the use of UDP instead of being a protocol under IP like TCP, but there are good reasons for it, related to ossification.<p>Yes, Google pushed for it, but I think it deserves its approval as a standard. It is not perfect but it is practical, they don&#x27;t want another IPv6 situation.</div><br/></div></div><div id="41891197" class="c"><input type="checkbox" id="c-41891197" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891107">parent</a><span>|</span><a href="#41891355">prev</a><span>|</span><a href="#41893876">next</a><span>|</span><label class="collapse" for="c-41891197">[-]</label><label class="expand" for="c-41891197">[4 more]</label></div><br/><div class="children"><div class="content">So because the Linux kernel isn’t as optimized for QUIC as it has been for TCP we shouldn’t design new protocols? Or it should be restricted to academics that had tried and failed for decades and would have had all the same problems even if they succeeded? And all of this only in a data center environment really and less about the general internet Quic was designed for?<p>This is an interesting hot take.</div><br/><div id="41891219" class="c"><input type="checkbox" id="c-41891219" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891197">parent</a><span>|</span><a href="#41893876">next</a><span>|</span><label class="collapse" for="c-41891219">[-]</label><label class="expand" for="c-41891219">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m struggling to parse my comment in the way you seem to think it did. In what way did or would my comment restrict your ability to design new protocols? Please explain.</div><br/><div id="41892122" class="c"><input type="checkbox" id="c-41892122" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41891219">parent</a><span>|</span><a href="#41893876">next</a><span>|</span><label class="collapse" for="c-41892122">[-]</label><label class="expand" for="c-41892122">[2 more]</label></div><br/><div class="children"><div class="content">Because you imply in that comment that it should be someone other than Google developing new protocols while in another you say that the protocols are already too complex implying stasis is the preferred state.<p>You’re also factually incorrect in a number of ways such as claiming that HTTP&#x2F;2 was a Google project (it’s not and some of the poorly thought out ideas like push didn’t come from Google).<p>The fact of the matter is that other attempts at “next gen” protocols had taken place. Google is the only one that won out. Part of it is because they were one of the few properties that controlled enough web traffic to try something. Another is that they explicitly learned from mistakes that the academics had been doing and taken market effects into account (ie not requiring SW updates of middleware boxes). I’d say all things considered Internet connectivity is better that QUIC got standardized. Papers like this simply point to current inefficiencies of today’s implementation - those can be fixed. These aren’t intractable design flaws of the protocol itself.<p>But you seem to really hate Google as a starting point so that seems to color your opinion of anything they produce rather than engaging with the technical material in good faith.</div><br/><div id="41892260" class="c"><input type="checkbox" id="c-41892260" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41891085">root</a><span>|</span><a href="#41892122">parent</a><span>|</span><a href="#41893876">next</a><span>|</span><label class="collapse" for="c-41892260">[-]</label><label class="expand" for="c-41892260">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t hate Google. I admire it what for what it is; an extremely efficient and inherently scalable corporate structure designed to exploit the Internet and the web in the most brutal and profitable way imaginable.<p>It&#x27;s just that their interests in certain aspects don&#x27;t align with ours.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41893876" class="c"><input type="checkbox" id="c-41893876" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#41891085">parent</a><span>|</span><a href="#41891107">prev</a><span>|</span><a href="#41891157">next</a><span>|</span><label class="collapse" for="c-41893876">[-]</label><label class="expand" for="c-41893876">[1 more]</label></div><br/><div class="children"><div class="content">QUIC is all about an advertising company guarenteeing delivery of adverts to the consumer.<p>As long as the adverts arrive quickly the rest is immaterial.</div><br/></div></div></div></div><div id="41891157" class="c"><input type="checkbox" id="c-41891157" checked=""/><div class="controls bullet"><span class="by">kachapopopow</span><span>|</span><a href="#41891085">prev</a><span>|</span><a href="#41891057">next</a><span>|</span><label class="collapse" for="c-41891157">[-]</label><label class="expand" for="c-41891157">[5 more]</label></div><br/><div class="children"><div class="content">This sounds really really wrong. I&#x27;ve achieved 900mbps speeds on quic+http3 and just quic... Seems like a bad TLS implementation? Early implementation that&#x27;s not efficient? The CPU usage seemed pretty avg at around 5% on gen 2 epyc cores.</div><br/><div id="41891399" class="c"><input type="checkbox" id="c-41891399" checked=""/><div class="controls bullet"><span class="by">kachapopopow</span><span>|</span><a href="#41891157">parent</a><span>|</span><a href="#41891057">next</a><span>|</span><label class="collapse" for="c-41891399">[-]</label><label class="expand" for="c-41891399">[4 more]</label></div><br/><div class="children"><div class="content">This is actually very well known: current QUIC implementation in browsers is *not stable* and is built of either rustls or in another similar hacky way.</div><br/><div id="41893375" class="c"><input type="checkbox" id="c-41893375" checked=""/><div class="controls bullet"><span class="by">vasilvv</span><span>|</span><a href="#41891157">root</a><span>|</span><a href="#41891399">parent</a><span>|</span><a href="#41892611">next</a><span>|</span><label class="collapse" for="c-41893375">[-]</label><label class="expand" for="c-41893375">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure where rustls comes from -- Chrome uses BoringSSL, and last time I checked, Mozilla implementation used NSS.</div><br/></div></div><div id="41892611" class="c"><input type="checkbox" id="c-41892611" checked=""/><div class="controls bullet"><span class="by">AlienRobot</span><span>|</span><a href="#41891157">root</a><span>|</span><a href="#41891399">parent</a><span>|</span><a href="#41893375">prev</a><span>|</span><a href="#41891057">next</a><span>|</span><label class="collapse" for="c-41892611">[-]</label><label class="expand" for="c-41892611">[2 more]</label></div><br/><div class="children"><div class="content">Why am I beta testing unstable software?</div><br/><div id="41892983" class="c"><input type="checkbox" id="c-41892983" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41891157">root</a><span>|</span><a href="#41892611">parent</a><span>|</span><a href="#41891057">next</a><span>|</span><label class="collapse" for="c-41892983">[-]</label><label class="expand" for="c-41892983">[1 more]</label></div><br/><div class="children"><div class="content">Because Google puts whatever they want in their browser for you to beta test and you’ll be pleased about it, peasant &#x2F;s.</div><br/></div></div></div></div></div></div></div></div><div id="41891057" class="c"><input type="checkbox" id="c-41891057" checked=""/><div class="controls bullet"><span class="by">spott</span><span>|</span><a href="#41891157">prev</a><span>|</span><a href="#41891200">next</a><span>|</span><label class="collapse" for="c-41891057">[-]</label><label class="expand" for="c-41891057">[1 more]</label></div><br/><div class="children"><div class="content">Here “fast internet” is 500Mbps, and the reason is  that quic seems to be cpu bound above that.<p>I didn’t look closely enough to see what their test system was to see if this is basic consumer systems or is still a problem for high performance desktops.</div><br/></div></div><div id="41891200" class="c"><input type="checkbox" id="c-41891200" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#41891057">prev</a><span>|</span><a href="#41892212">next</a><span>|</span><label class="collapse" for="c-41891200">[-]</label><label class="expand" for="c-41891200">[2 more]</label></div><br/><div class="children"><div class="content">I thought QUIC was optimized for latency - loading lots of little things at once on webpages and video games (which send lots of tiny little packets - low overall throughput but highly latency senstive) and such. I&#x27;m not surprised that it falls short when overall throughput is the only thing being measured.<p>I wonder if this can be optimized at the protocol level by detecting usage patterns that look like large file transfers or very high bandwidth video streaming and swapping over to something less cpu intensive.<p>Or is this just a case of less hardware&#x2F;OS level optimization of QUIC vs TCP because it&#x27;s new?</div><br/><div id="41891429" class="c"><input type="checkbox" id="c-41891429" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#41891200">parent</a><span>|</span><a href="#41892212">next</a><span>|</span><label class="collapse" for="c-41891429">[-]</label><label class="expand" for="c-41891429">[1 more]</label></div><br/><div class="children"><div class="content">It seems that syscalls might be the culprit (ACKs occur completely inside the kernel for TCP, where anything UDP acks from userspace). I wonder if BGP could be extended for protocol development.</div><br/></div></div></div></div><div id="41892212" class="c"><input type="checkbox" id="c-41892212" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#41891200">prev</a><span>|</span><a href="#41891042">next</a><span>|</span><label class="collapse" for="c-41892212">[-]</label><label class="expand" for="c-41892212">[1 more]</label></div><br/><div class="children"><div class="content">Previous post on HN (326 comments - 40 days ago):<p>QUIC is not quick enough over fast internet:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41484991">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41484991</a></div><br/></div></div><div id="41891042" class="c"><input type="checkbox" id="c-41891042" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#41892212">prev</a><span>|</span><a href="#41891114">next</a><span>|</span><label class="collapse" for="c-41891042">[-]</label><label class="expand" for="c-41891042">[4 more]</label></div><br/><div class="children"><div class="content">I wish QUIC had a non-TLS mode... if I&#x27;m developing locally I really just want to see whats going over the wire sometimes and this adds a lot of un-needed friction.</div><br/><div id="41891135" class="c"><input type="checkbox" id="c-41891135" checked=""/><div class="controls bullet"><span class="by">guidedlight</span><span>|</span><a href="#41891042">parent</a><span>|</span><a href="#41891081">next</a><span>|</span><label class="collapse" for="c-41891135">[-]</label><label class="expand" for="c-41891135">[1 more]</label></div><br/><div class="children"><div class="content">QUIC reuses parts of the TLS specification (e.g. handshake, transport state, etc).<p>So it can’t function without it.</div><br/></div></div><div id="41891081" class="c"><input type="checkbox" id="c-41891081" checked=""/><div class="controls bullet"><span class="by">krater23</span><span>|</span><a href="#41891042">parent</a><span>|</span><a href="#41891135">prev</a><span>|</span><a href="#41891114">next</a><span>|</span><label class="collapse" for="c-41891081">[-]</label><label class="expand" for="c-41891081">[2 more]</label></div><br/><div class="children"><div class="content">You can add the private key of your server in wireshark and it will automatically decrypt the packets.</div><br/><div id="41891463" class="c"><input type="checkbox" id="c-41891463" checked=""/><div class="controls bullet"><span class="by">jborean93</span><span>|</span><a href="#41891042">root</a><span>|</span><a href="#41891081">parent</a><span>|</span><a href="#41891114">next</a><span>|</span><label class="collapse" for="c-41891463">[-]</label><label class="expand" for="c-41891463">[1 more]</label></div><br/><div class="children"><div class="content">This only works tor RSA keys and I believe ciphers that do not have forward secrecy. Quic is TLS 1.3 and all the ciphers in that protocol do forward secrecy so cannot be decrypted in this way. You’ll have to use a tool that provides the TLS session info through the SSLKEYLOGFILE format.</div><br/></div></div></div></div></div></div><div id="41891114" class="c"><input type="checkbox" id="c-41891114" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41891042">prev</a><span>|</span><a href="#41891318">next</a><span>|</span><label class="collapse" for="c-41891114">[-]</label><label class="expand" for="c-41891114">[2 more]</label></div><br/><div class="children"><div class="content">Looking at Figure 5, Chrome tops out at ~500 Mbps due to CPU usage. I don&#x27;t think many people care about these speeds? Perhaps not using all available bandwidth for a few speedy clients is an okay compromise for most websites? This inadvertent throttling might improve others&#x27; experiences.<p>But then again, being CPU-throttled isn&#x27;t great for battery life, so perhaps there&#x27;s a better way.</div><br/><div id="41893586" class="c"><input type="checkbox" id="c-41893586" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#41891114">parent</a><span>|</span><a href="#41891318">next</a><span>|</span><label class="collapse" for="c-41893586">[-]</label><label class="expand" for="c-41893586">[1 more]</label></div><br/><div class="children"><div class="content">These caps are a massive pain when downloading large games or OS upgrades for me as the end user. 500mbps is still fast but for a new protocol looking to replace older protocols, it&#x27;s a big downside.<p>I don&#x27;t really benefit much from http&#x2F;3 or QUIC (I don&#x27;t live in a remote area or host a cloud server) so I&#x27;ve already considered disabling either. A bandwidth cap this low makes a bigger impact than the tiny latency improvements.</div><br/></div></div></div></div><div id="41891318" class="c"><input type="checkbox" id="c-41891318" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#41891114">prev</a><span>|</span><a href="#41891809">next</a><span>|</span><label class="collapse" for="c-41891318">[-]</label><label class="expand" for="c-41891318">[8 more]</label></div><br/><div class="children"><div class="content">TL;DR: Nothing that&#x27;s inherent to QUIC itself, it&#x27;s just that current QUIC implementations are CPU-bound because hardware GRO support has not yet matured in commodity NICs.<p>But throughput was never the compelling aspect of QUIC in the first place. It was always the <i>reduced latency</i>. A 1-RTT handshake <i>including key&#x2F;cert exchange</i> is nothing to scoff at, and the 2-RTT request&#x2F;response cycle that HTTP&#x2F;3-over-QUIC offers means that I can load a blog page from a rinky-dink server on the other side of the world in &lt; 500 ms. Look ma, no CDN!</div><br/><div id="41891384" class="c"><input type="checkbox" id="c-41891384" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41891318">parent</a><span>|</span><a href="#41891809">next</a><span>|</span><label class="collapse" for="c-41891384">[-]</label><label class="expand" for="c-41891384">[7 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the fact that TCP has an unfixable security flaw - any random middleware can inject data (without needing to block packets) and break the connection. TLS only  can add Confidentiality and Integrity, it can do nothing about the missing Availability.</div><br/><div id="41891651" class="c"><input type="checkbox" id="c-41891651" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#41891318">root</a><span>|</span><a href="#41891384">parent</a><span>|</span><a href="#41891453">next</a><span>|</span><label class="collapse" for="c-41891651">[-]</label><label class="expand" for="c-41891651">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s also the fact that TCP has an unfixable security flaw - any random middleware can inject data (without needing to block packets) and break the connection<p>I am unsure how this is a security flaw of TCP? Any middleman could block UDP packets too and get the same effect, or modify UDP packets in an attempt to cause the receiving application to crash.</div><br/><div id="41891976" class="c"><input type="checkbox" id="c-41891976" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41891318">root</a><span>|</span><a href="#41891651">parent</a><span>|</span><a href="#41891453">next</a><span>|</span><label class="collapse" for="c-41891976">[-]</label><label class="expand" for="c-41891976">[2 more]</label></div><br/><div class="children"><div class="content">In order to attack UDP, you have to block <i>all</i> routes through which traffic might flow. This is hard; remember, the internet tries to be resilient.<p>In order to attack TCP, all you have to do is spy on a single packet (very easy) to learn the sequence number, then you can inject a wrench into the cogs and the endpoints will reject all legitimate traffic from each other.</div><br/><div id="41893618" class="c"><input type="checkbox" id="c-41893618" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#41891318">root</a><span>|</span><a href="#41891976">parent</a><span>|</span><a href="#41891453">next</a><span>|</span><label class="collapse" for="c-41893618">[-]</label><label class="expand" for="c-41893618">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only true if you use the kernel TCP stack. You can replicate the slow QUIC stack and do everything in user mode to get control back over what packets you accept (i.e. reject any that don&#x27;t fit your TLS stream).</div><br/></div></div></div></div></div></div><div id="41891453" class="c"><input type="checkbox" id="c-41891453" checked=""/><div class="controls bullet"><span class="by">suprjami</span><span>|</span><a href="#41891318">root</a><span>|</span><a href="#41891384">parent</a><span>|</span><a href="#41891651">prev</a><span>|</span><a href="#41891809">next</a><span>|</span><label class="collapse" for="c-41891453">[-]</label><label class="expand" for="c-41891453">[3 more]</label></div><br/><div class="children"><div class="content">What does that have to do with anything here? This post is about QUIC performance, not TCP packet injection.</div><br/><div id="41891674" class="c"><input type="checkbox" id="c-41891674" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41891318">root</a><span>|</span><a href="#41891453">parent</a><span>|</span><a href="#41891809">next</a><span>|</span><label class="collapse" for="c-41891674">[-]</label><label class="expand" for="c-41891674">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Accept worse performance in order to fix security problems&quot; is a standard tradeoff.</div><br/><div id="41892201" class="c"><input type="checkbox" id="c-41892201" checked=""/><div class="controls bullet"><span class="by">suprjami</span><span>|</span><a href="#41891318">root</a><span>|</span><a href="#41891674">parent</a><span>|</span><a href="#41891809">next</a><span>|</span><label class="collapse" for="c-41892201">[-]</label><label class="expand" for="c-41892201">[1 more]</label></div><br/><div class="children"><div class="content">QUIC was invented to provide <i>better</i> performance for multiplexed HTTP&#x2F;3 streams and the bufferbloat people love that it avoids middlebox protocol interference.<p>QUIC has never been about &quot;worse performance&quot; to avoid TCP packet injection.<p>Anybody who cares about TCP packet injection is using crypto (IPSec&#x2F;Wireguard). If performant crypto is needed there are appliances which do it at wirespeed.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41891809" class="c"><input type="checkbox" id="c-41891809" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#41891318">prev</a><span>|</span><a href="#41891796">next</a><span>|</span><label class="collapse" for="c-41891809">[-]</label><label class="expand" for="c-41891809">[3 more]</label></div><br/><div class="children"><div class="content">Meanwhile fast.com (and presumably netflix cdn) is using http 1.1 still.</div><br/><div id="41891875" class="c"><input type="checkbox" id="c-41891875" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41891809">parent</a><span>|</span><a href="#41891796">next</a><span>|</span><label class="collapse" for="c-41891875">[-]</label><label class="expand" for="c-41891875">[2 more]</label></div><br/><div class="children"><div class="content">Why do you need multiplexing when you are only downloading one (video) stream? Are there any features of http&#x2F;2 that would benefit the Netflix use case?</div><br/><div id="41892018" class="c"><input type="checkbox" id="c-41892018" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#41891809">root</a><span>|</span><a href="#41891875">parent</a><span>|</span><a href="#41891796">next</a><span>|</span><label class="collapse" for="c-41892018">[-]</label><label class="expand" for="c-41892018">[1 more]</label></div><br/><div class="children"><div class="content">QUIC handles packet loss better. But I do not think there is any benefit from HTTP2.</div><br/></div></div></div></div></div></div><div id="41891796" class="c"><input type="checkbox" id="c-41891796" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#41891809">prev</a><span>|</span><a href="#41891138">next</a><span>|</span><label class="collapse" for="c-41891796">[-]</label><label class="expand" for="c-41891796">[1 more]</label></div><br/><div class="children"><div class="content">Designing for resource-constrained systems typically comes with making tradeoffs.<p>Once the resource constraint is eliminared, you&#x27;re no longer getting the benefit of that tradeoff but are paying the costs.</div><br/></div></div><div id="41891138" class="c"><input type="checkbox" id="c-41891138" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#41891796">prev</a><span>|</span><a href="#41891673">next</a><span>|</span><label class="collapse" for="c-41891138">[-]</label><label class="expand" for="c-41891138">[1 more]</label></div><br/><div class="children"><div class="content">Well latency&#x2F;bandwidth tradeoffs make sense. After bufferbloat mitigations my throughout halved on my router. But for gaming while everyone is streaming, it makes sense to settle with half a gigabit.</div><br/></div></div><div id="41891673" class="c"><input type="checkbox" id="c-41891673" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#41891138">prev</a><span>|</span><a href="#41891981">next</a><span>|</span><label class="collapse" for="c-41891673">[-]</label><label class="expand" for="c-41891673">[1 more]</label></div><br/><div class="children"><div class="content">How does it compare to HTTP&#x2F;1 on similar benchmarks?</div><br/></div></div><div id="41891981" class="c"><input type="checkbox" id="c-41891981" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#41891673">prev</a><span>|</span><a href="#41892598">next</a><span>|</span><label class="collapse" for="c-41891981">[-]</label><label class="expand" for="c-41891981">[1 more]</label></div><br/><div class="children"><div class="content">QUIC is pretty much what serious online games have been doing in the last 20 years.</div><br/></div></div><div id="41892598" class="c"><input type="checkbox" id="c-41892598" checked=""/><div class="controls bullet"><span class="by">AlienRobot</span><span>|</span><a href="#41891981">prev</a><span>|</span><a href="#41891109">next</a><span>|</span><label class="collapse" for="c-41892598">[-]</label><label class="expand" for="c-41892598">[1 more]</label></div><br/><div class="children"><div class="content">Anecdote: I was having trouble accessing wordpress.org. When I started using Wordpress, I could access the documentation just fine, but then suddenly I couldn&#x27;t access the website anymore. I dual boot Linux, so it wasn&#x27;t Windows fault. I could ping them just fine. I tried three different browsers with the same issue. It&#x27;s just that when I accessed the website, it would get stuck and not load at all, and sometimes pages would just stop loading mid-way.<p>Today I found the solution. Disable &quot;Experimental QUIC Protocol&quot; in Chrome settings.<p>This makes me kind of worried because I&#x27;ve had issues accessing wordpress.org for months. There was no indication that this was caused by QUIC. I just managed to realize it because there was QUIC-related error in devtools that appeared only sometimes.<p>I wonder what other websites are rendered inaccessible by this protocol and users have no idea what is causing it.</div><br/></div></div><div id="41891109" class="c"><input type="checkbox" id="c-41891109" checked=""/><div class="controls bullet"><span class="by">superkuh</span><span>|</span><a href="#41892598">prev</a><span>|</span><a href="#41891543">next</a><span>|</span><label class="collapse" for="c-41891109">[-]</label><label class="expand" for="c-41891109">[2 more]</label></div><br/><div class="children"><div class="content">Since QUIC was designed for <i>Fast Internet</i> as used by the megacorporations like Google and Microsoft how it performs at these scales does matter even if it doesn&#x27;t for a human person&#x27;s end.<p>Without it&#x27;s designed for use case all it does is slightly help mobile platforms that don&#x27;t want to hold open a TCP connection (for energy use reasons) and bring in fragile &quot;CA TLS&quot;-only in an environment where cert lifetimes are trending down to single months (Apple etc latest proposal).</div><br/><div id="41891301" class="c"><input type="checkbox" id="c-41891301" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41891109">parent</a><span>|</span><a href="#41891543">next</a><span>|</span><label class="collapse" for="c-41891301">[-]</label><label class="expand" for="c-41891301">[1 more]</label></div><br/><div class="children"><div class="content">not really it&#x27;s (mainly) designed by companies like Google to connect to all their end users<p>Such a internet connection becoming so low latency that the latency of receiver side processing becomes dominant is in practice not the most relevant. Sure theoretically you can hit it with e.g. 5G but in practice even with 5G many real world situations won&#x27;t. Most importantly a slow down of such isn&#x27;t necessary bad for Google and co. as it only add limited amounts on strain on their services, infrastructure, internet and is still fast enough for most users to not care for most Google and co. use cases.<p>Similar being slow due to receiver delays isn&#x27;t necessary bad enough to cause user noticeable battery issues, on of the main reasons seem to many user&lt;-&gt;kernel boundary crossings which are slow due to cache missues&#x2F;ejections etc. but also don&#x27;t boost your CPU clock (which is one of the main ways to drain your battery, besides the screen)<p>Also like the article mentions the main issue is sub optimal network stack usage in browsers (including Chrome) not necessary a fundamental issue in the protocol. Which brings us to inter service communication for Google and co. which doesn&#x27;t use any of the tested network stacks but very highly optimized stacks. I mean it really would be surprising if such network stacks where slow as there had been exhaustive perf. testing during the design of QUIC.</div><br/></div></div></div></div><div id="41891263" class="c"><input type="checkbox" id="c-41891263" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41891543">prev</a><span>|</span><label class="collapse" for="c-41891263">[-]</label><label class="expand" for="c-41891263">[15 more]</label></div><br/><div class="children"><div class="content">EDITED.<p>I preference WebSockets over anything analogous to HTTP.<p>Commented edited because I mentioned performance conditions.  Software developers tend to make unfounded assumptions&#x2F;rebuttals of performance conditions they have not tested.</div><br/><div id="41891333" class="c"><input type="checkbox" id="c-41891333" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41891263">parent</a><span>|</span><a href="#41891517">next</a><span>|</span><label class="collapse" for="c-41891333">[-]</label><label class="expand" for="c-41891333">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d use them more,  but WebSockets are just unfortunately a little too hard to implement efficiently in a serverless environment,  I wish there was a protocol that spoke to that environment&#x27;s tradeoffs more effectively.<p>The current crop aside from WebSockets all seem to be born from taking a butcher knife to HTTP and hacking out everything that gets in the way of time to first byte.  I don&#x27;t think that&#x27;s likely to produce anything worthwhile.</div><br/><div id="41891438" class="c"><input type="checkbox" id="c-41891438" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41891263">root</a><span>|</span><a href="#41891333">parent</a><span>|</span><a href="#41891517">next</a><span>|</span><label class="collapse" for="c-41891438">[-]</label><label class="expand" for="c-41891438">[1 more]</label></div><br/><div class="children"><div class="content">That is a fair point.  I wrote my own implementation of WebSockets in JavaScript and learned much in doing so, but it took tremendous trial and effort to get right.  Nonetheless, the result was well worth the effort.  I have a means to communicate to the browser and between servers that is real time with freedom to extend and modify it at my choosing.  It is unbelievably more responsive than reliance upon HTTP in any of its forms.  Imagine being able to execute hundreds of end-to-end test automation scenarios in the browser in 10 seconds.  I can do that, but I couldn&#x27;t with HTTP.</div><br/></div></div></div></div><div id="41891517" class="c"><input type="checkbox" id="c-41891517" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41891263">parent</a><span>|</span><a href="#41891333">prev</a><span>|</span><a href="#41891575">next</a><span>|</span><label class="collapse" for="c-41891517">[-]</label><label class="expand" for="c-41891517">[2 more]</label></div><br/><div class="children"><div class="content">This is an insane take.<p>Just to pick at one point of this craziness, you think that communicating over web sockets does not involve round trips????</div><br/><div id="41891544" class="c"><input type="checkbox" id="c-41891544" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41891263">root</a><span>|</span><a href="#41891517">parent</a><span>|</span><a href="#41891575">next</a><span>|</span><label class="collapse" for="c-41891544">[-]</label><label class="expand" for="c-41891544">[1 more]</label></div><br/><div class="children"><div class="content">That is correct.</div><br/></div></div></div></div><div id="41891575" class="c"><input type="checkbox" id="c-41891575" checked=""/><div class="controls bullet"><span class="by">sleepydog</span><span>|</span><a href="#41891263">parent</a><span>|</span><a href="#41891517">prev</a><span>|</span><a href="#41891426">next</a><span>|</span><label class="collapse" for="c-41891575">[-]</label><label class="expand" for="c-41891575">[1 more]</label></div><br/><div class="children"><div class="content">QUIC is a reliable transport. It&#x27;s not &quot;fire and forget&quot;, there is a mechanism for recovering lost messages similar, but slightly superior to TCP. QUIC has the significant advantage of 0- and 1-rtt connection establishments which can hide latency better than TCP&#x27;s 3-way handshake.<p>Current implementations have some disadvantages to TCP, but they are not inherent to the protocol, they just highlight the decades of work done to make TCP scale with network hardware.<p>Your points seem better directed at HTTP&#x2F;3 than QUIC.</div><br/></div></div><div id="41891426" class="c"><input type="checkbox" id="c-41891426" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41891263">parent</a><span>|</span><a href="#41891575">prev</a><span>|</span><a href="#41891324">next</a><span>|</span><label class="collapse" for="c-41891426">[-]</label><label class="expand" for="c-41891426">[3 more]</label></div><br/><div class="children"><div class="content">&gt; QUIC is faster than prior versions of HTTP, but its still HTTP. It will never be fast enough because its still HTTP:
&gt; * String headers
&gt; * round trips
&gt; * many sockets, there is additional overhead to socket creation, especially over TLS<p>QUIC is a transport. HTTP can run on top of QUIC, but the way you’re equating QUIC and HTTP doesn’t make sense.<p>String headers and socket opening have nothing to do with the performance issues being discussed.<p>String headers aren’t even a performance issue at all. The  amount of processing done for when the most excessive use of string headers is completely trivial relative to all of the other processing that goes into sending 1,000,000,000 bits per second (Gigabit) over the internet, which is the order of magnitude target being discussed.<p>I don’t think you understand what QUIC is or even the prior art in HTTP&#x2F;2 that precedes these discussions of QUIC and HTTP&#x2F;3.</div><br/><div id="41891484" class="c"><input type="checkbox" id="c-41891484" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41891263">root</a><span>|</span><a href="#41891426">parent</a><span>|</span><a href="#41891324">next</a><span>|</span><label class="collapse" for="c-41891484">[-]</label><label class="expand" for="c-41891484">[2 more]</label></div><br/><div class="children"><div class="content">&gt; String headers aren’t even a performance issue at all.<p>That is universally incorrect.  String instructions require parsing as strings are for humans and binary is for machines.  There is performance overhead to string parsing always, and it is relatively trivial to perf.  I have performance tested this in my own WebSocket and test automation applications.  That performance difference scales in logarithmic fashion provided the quantity of messages to send&#x2F;receive.  I encourage you to run your own tests.</div><br/><div id="41891710" class="c"><input type="checkbox" id="c-41891710" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41891263">root</a><span>|</span><a href="#41891484">parent</a><span>|</span><a href="#41891324">next</a><span>|</span><label class="collapse" for="c-41891710">[-]</label><label class="expand" for="c-41891710">[1 more]</label></div><br/><div class="children"><div class="content">Both HTTP&#x2F;2 and HTTP&#x2F;3 use binary protocol encoding and compressed (binary) headers. You&#x27;re arguing a straw man that has little to do with reality.</div><br/></div></div></div></div></div></div><div id="41891324" class="c"><input type="checkbox" id="c-41891324" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41891263">parent</a><span>|</span><a href="#41891426">prev</a><span>|</span><a href="#41891549">next</a><span>|</span><label class="collapse" for="c-41891324">[-]</label><label class="expand" for="c-41891324">[2 more]</label></div><br/><div class="children"><div class="content">&gt; * String headers
&gt; * round trips
&gt; * many sockets, there is additional overhead to socket creation, especially over TLS
&gt; * UDP. Yes, in theory UDP is faster than TCP but only when you completely abandon integrity.<p>Have you ever read up on the technical details of QUIC? Every single of one of your bullets reflects a misunderstanding of QUIC&#x27;s design.</div><br/><div id="41891440" class="c"><input type="checkbox" id="c-41891440" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41891263">root</a><span>|</span><a href="#41891324">parent</a><span>|</span><a href="#41891549">next</a><span>|</span><label class="collapse" for="c-41891440">[-]</label><label class="expand" for="c-41891440">[1 more]</label></div><br/><div class="children"><div class="content">Honestly the entire comment is a head scratcher, from comparing QUIC to HTTP (different layers of the stack) or suggesting that string headers are a performance bottleneck.<p>Websockets are useful in some cases where you need to upgrade an HTTP connection to something more. Some people learn about websockets and then try to apply them to everything, everywhere. This seems to be one of those cases.</div><br/></div></div></div></div><div id="41891549" class="c"><input type="checkbox" id="c-41891549" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41891263">parent</a><span>|</span><a href="#41891324">prev</a><span>|</span><label class="collapse" for="c-41891549">[-]</label><label class="expand" for="c-41891549">[4 more]</label></div><br/><div class="children"><div class="content">QUIC isn’t HTTP, QUIC is a protocol that operates at a similar level to UDP and TCP.<p>HTTP&#x2F;3 is HTTP over QUIC. HTTP protocols v2 and onwards use binary headers. QUIC, by design, does 0-RTT handshakes.<p>&gt; Yes, in theory UDP is faster than TCP but only when you completely abandon integrity<p>The point of QUIC, is that it enables application&#x2F;userspace level reconstruction with UDP levels of performance. There’s no integrity being abandoned here: packets are free to arrive out of order, across independent sub-streams, and the protocol machinery puts them back together. QUIC also supports full bidirectional streams, so HTTP&#x2F;3 also benefits from this directly. QUIC&#x2F;HTTP3 also supports multiple streams per client with backpressure per substream.<p>Web-sockets are a pretty limited special case, built on-top of HTTP and TCP. You literally form the http connection and then upgrade it to web-sockets, it’s still TCP underneath.<p>Tl;Dr: your gripes are legitimate, but they refer to HTTP&#x2F;1.1 at most, QUIC and HTTP&#x2F;3 are far more sophisticated and performant protocols.</div><br/><div id="41891587" class="c"><input type="checkbox" id="c-41891587" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41891263">root</a><span>|</span><a href="#41891549">parent</a><span>|</span><label class="collapse" for="c-41891587">[-]</label><label class="expand" for="c-41891587">[3 more]</label></div><br/><div class="children"><div class="content">WebSockets are not built on top of HTTP, though that is how they are commonly implemented.  WebSockets are faster when HTTP is not considered.  A careful reading of RFC6455 only mentions the handshake and its response must be a static string resembling a header in style of RFC2616 (HTTP), but a single static string is not HTTP.  This is easily provable if you attempt your own implementation of WebSockets.</div><br/><div id="41892523" class="c"><input type="checkbox" id="c-41892523" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41891263">root</a><span>|</span><a href="#41891587">parent</a><span>|</span><label class="collapse" for="c-41892523">[-]</label><label class="expand" for="c-41892523">[2 more]</label></div><br/><div class="children"><div class="content">… I mean, <i>in theory</i> someone could craft some protocol that just starts with speaking Websockets or starts with some other handshake¹, I suppose, but the overwhelming majority of the uses of websockets out there are going to be over HTTP, as that&#x27;s what a browser speaks, and the client is quite probably a browser.<p>&gt; <i>A careful reading of RFC6455 only mentions the handshake and its response must be a static string resembling a header in style of RFC2616 (HTTP), but a single static string is not HTTP.</i><p>You&#x27;re going to have to cite the paragraph, then, because that is most definitely <i>not</i> what RFC 6455 says. RFC 6455 says,<p>&gt; <i>The handshake consists of an HTTP Upgrade request, along with a list of required and optional header fields.</i><p>That&#x27;s not &quot;a single static string&quot;. You can&#x27;t just say &quot;are the first couple of bytes of the connection == SOME_STATIC&quot;, as that would not be a conforming implementation. (That would just be a custom protocol with its own custom upgrade-into-Websockets, as mentioned in the first paragraph, but if you&#x27;re doing that, you might as well just ditch that and just start in Websockets.)<p>¹(i.e., I grant the RFC&#x27;s &quot;However, the design does not limit WebSocket to HTTP, and future implementations could use a simpler handshake&quot;, but making use of that to me that puts us solidly in &quot;custom protocol&quot; land, as conforming libraries won&#x27;t interoperate.)</div><br/><div id="41894003" class="c"><input type="checkbox" id="c-41894003" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41891263">root</a><span>|</span><a href="#41892523">parent</a><span>|</span><label class="collapse" for="c-41894003">[-]</label><label class="expand" for="c-41894003">[1 more]</label></div><br/><div class="children"><div class="content">That is still incorrect. Once the handshake completes the browser absolutely doesn’t care about HTTP with regard to message processing over WebSockets. Therefore just achieve the handshake by any means and WebSockets will work correctly in the browser. The only browser specific behavior of any importance is that RFC6455 masking will occur on all messaging leaving the browser and will fail on all messaging entering the browser.<p>&gt; You can&#x27;t just say<p>I can say that, because I have my own working code that proves it cross browser and I have written perf tools to analyze it with numbers. One of my biggest learnings about software is to always conduct your own performance measurements because developers tend to be universally wrong about performance assumptions and when they are wrong they are frequently wrong by multiple orders of magnitude.<p>As far as custom implementation goes you gain many liberties after leaving the restrictions of the browser as there are some features you don’t need to execute the protocol and there are features of the protocol the browser does not use.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>