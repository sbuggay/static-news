<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708938059326" as="style"/><link rel="stylesheet" href="styles.css?v=1708938059326"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">Coroutines in C (2000)</a> <span class="domain">(<a href="https://www.chiark.greenend.org.uk">www.chiark.greenend.org.uk</a>)</span></div><div class="subtext"><span>ColinWright</span> | <span>87 comments</span></div><br/><div><div id="39502520" class="c"><input type="checkbox" id="c-39502520" checked=""/><div class="controls bullet"><span class="by">DriftRegion</span><span>|</span><a href="#39503465">next</a><span>|</span><label class="collapse" for="c-39502520">[-]</label><label class="expand" for="c-39502520">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found myself at this webpage multiple times while trying to minimize the complexity of APIs in my C projects. I think it does a lovely job explaining control flow and it has helped me to think more explicitly about storage of state on and off the stack as well as the readability consequences of different approaches.<p>My conclusion for now is that the choice to use C coroutines is best left to the library user. For example: Mongoose (<a href="https:&#x2F;&#x2F;github.com&#x2F;cesanta&#x2F;mongoose">https:&#x2F;&#x2F;github.com&#x2F;cesanta&#x2F;mongoose</a>) uses event callbacks to deal with asynchronousness. It is much more pleasant to wrap a library like this in whatever thread&#x2F;task primitives your system has rather than try to port the mythical cross-platform C couroutine or worse, std::thread.</div><br/><div id="39503328" class="c"><input type="checkbox" id="c-39503328" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#39502520">parent</a><span>|</span><a href="#39503465">next</a><span>|</span><label class="collapse" for="c-39503328">[-]</label><label class="expand" for="c-39503328">[3 more]</label></div><br/><div class="children"><div class="content">It’s Simon Tatham’s website. He’s well known for being the author of PuTTY [1] and his puzzle collection [2]!<p>[1] <a href="https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;putty&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;putty&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;puzzles&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;puzzles&#x2F;</a></div><br/><div id="39503546" class="c"><input type="checkbox" id="c-39503546" checked=""/><div class="controls bullet"><span class="by">hnfong</span><span>|</span><a href="#39502520">root</a><span>|</span><a href="#39503328">parent</a><span>|</span><a href="#39503610">next</a><span>|</span><label class="collapse" for="c-39503546">[-]</label><label class="expand" for="c-39503546">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve known about the two projects for literally 20+ years, but wow I never knew it was the same person behind them....</div><br/></div></div><div id="39503610" class="c"><input type="checkbox" id="c-39503610" checked=""/><div class="controls bullet"><span class="by">abhgh</span><span>|</span><a href="#39502520">root</a><span>|</span><a href="#39503328">parent</a><span>|</span><a href="#39503546">prev</a><span>|</span><a href="#39503465">next</a><span>|</span><label class="collapse" for="c-39503610">[-]</label><label class="expand" for="c-39503610">[1 more]</label></div><br/><div class="children"><div class="content">Oh wow... I have had the Android port of his puzzles (your second reference links to it) on my phone for a while. Had no idea the developer of Putty had anything to do with it!</div><br/></div></div></div></div></div></div><div id="39503465" class="c"><input type="checkbox" id="c-39503465" checked=""/><div class="controls bullet"><span class="by">utopcell</span><span>|</span><a href="#39502520">prev</a><span>|</span><a href="#39502495">next</a><span>|</span><label class="collapse" for="c-39503465">[-]</label><label class="expand" for="c-39503465">[9 more]</label></div><br/><div class="children"><div class="content">Coroutines. What a lovely concept! It&#x27;s a joy to watch all the CppCon videos about C++ coroutines, primarily by Microsoft folks. &quot;Negative-cost abstraction&quot; is such a nice hook phrase.<p>Friends at Meta mentioned to me a couple years ago that they started using c++ coroutines, which ended up being a big mistake because they had to face compiler implementation bugs, which must have been nasty to track down. At Google, we are eagerly waiting for the brilliant folks that are working on properly integrating them in google3&#x2F; to tell us when the time has come to use them.<p>This article uses Duff&#x27;s device [1] to motivate structured gotos via macros as an implementation strategy for C coroutines. Duff wanted to loop-unroll this:<p><pre><code>    do {
        *to = *from++;
    } while (--count &gt; 0);
</code></pre>
which he did in this way (shortened for brevity) :<p><pre><code>    int n = (count + 3) &#x2F; 4;
    switch (count % 4) {
    case 0: do { *to = *from++;
    case 3:      *to = *from++;
    case 2:      *to = *from++;
    case 1:      *to = *from++;
            } while (--n &gt; 0);
    } 
</code></pre>
That is to say, he realized that he could use `case` statements (almost) anywhere in a `switch` block. The connection with coroutines is simple: One can wrap the whole function body with a switch statement, use a static variable for holding the location of the latest coroutine return, and label all co-returns with a `case` statement:<p><pre><code>  #define coBegin static int state = 0; switch (state) { case 0:
  #define coReturn(x) do { state = __LINE_; return x; case __LINE:; } while (0)
  #define coFinish }

  int function(void) {
      static int i;  &#x2F;&#x2F; function state can&#x27;t be local anymore.
      coBegin;
      for (i = 0; i &lt; 10; ++i)
          coReturn(i);
      coFinish;
  }
</code></pre>
Sustrik&#x27;s take on C coroutines might also be an interesting read [2].<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Duff%27s_device" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Duff%27s_device</a><p>[2] <a href="https:&#x2F;&#x2F;250bpm.com&#x2F;blog:48&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;250bpm.com&#x2F;blog:48&#x2F;index.html</a></div><br/><div id="39505239" class="c"><input type="checkbox" id="c-39505239" checked=""/><div class="controls bullet"><span class="by">codemac</span><span>|</span><a href="#39503465">parent</a><span>|</span><a href="#39503653">next</a><span>|</span><label class="collapse" for="c-39505239">[-]</label><label class="expand" for="c-39505239">[1 more]</label></div><br/><div class="children"><div class="content">As someone who moved from google3 -&gt; fbcode in the last few years, I think there are weird upsides AND downsides to having async code littered through your C++ (aka co_yield, co_return, co_await, etc).<p>The advantage, compared to the internal stuff google3 was using, was that as you read code, the async nature of various parts was obvious. Some programmers at G would spend entire quarters+ not knowing what the threading model was, and cause serious bugs in retrospect.<p>The disadvantage is actually much dumber - a lot of code &quot;could&quot; be async, and over time becomes entirely async because that&#x27;s the mode the programmer is in when writing the program.<p>The choice to use a spinlock vs. a mutex w&#x2F;yields should be one based on the size of the critical section and the threading going on at the time. Unfortunately to make code more readable&#x2F;uniform&#x2F;etc you end up with entire projects doing one or the other.<p>I&#x27;d love to learn more about language implementations of threading that do not default either way, but instead could take a profile of the previous run, and make the next run more optimal, without having to change the code or causing bugs.</div><br/></div></div><div id="39503653" class="c"><input type="checkbox" id="c-39503653" checked=""/><div class="controls bullet"><span class="by">dividuum</span><span>|</span><a href="#39503465">parent</a><span>|</span><a href="#39505239">prev</a><span>|</span><a href="#39506883">next</a><span>|</span><label class="collapse" for="c-39503653">[-]</label><label class="expand" for="c-39503653">[3 more]</label></div><br/><div class="children"><div class="content">The alternative is to use the „labels as values“ feature of GCC. You can take the address of a label and later jump to it. I contributed the code that’s now in lc-addrlabels.h back in 2005 :-)<p>I also used the GCC local labels feature to completely avoid using __LINE__ anywhere, so you could have multiple coReturns in a single code line:<p>#define LC_SET(s) 
  do { ({ __label__ resume; resume: (s) = &amp;&amp;resume; }); }while(0)</div><br/><div id="39504317" class="c"><input type="checkbox" id="c-39504317" checked=""/><div class="controls bullet"><span class="by">bxparks</span><span>|</span><a href="#39503465">root</a><span>|</span><a href="#39503653">parent</a><span>|</span><a href="#39506883">next</a><span>|</span><label class="collapse" for="c-39504317">[-]</label><label class="expand" for="c-39504317">[2 more]</label></div><br/><div class="children"><div class="content">Definitely, &quot;labels as values&quot; (aka &quot;computed gotos&quot;, <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Labels-as-Values.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Labels-as-Values.html</a>) is so much better than Duff&#x27;s device.<p>Unfortunately, computed-gotos is not a C language standard. I don&#x27;t understand why. I think FORTRAN had it in the 60s. It is so useful in some situations, like a coroutine, or a byte-code interpreter. Is it because some obscure DSP chip with a sizeof(char)==32 using 1&#x27;s complement arithmetic can&#x27;t support it? Then maybe make it implementation-defined and allow the rest of the world get nice things.</div><br/><div id="39506918" class="c"><input type="checkbox" id="c-39506918" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#39503465">root</a><span>|</span><a href="#39504317">parent</a><span>|</span><a href="#39506883">next</a><span>|</span><label class="collapse" for="c-39506918">[-]</label><label class="expand" for="c-39506918">[1 more]</label></div><br/><div class="children"><div class="content">(For ease of reference—Fortran calls this an <i>assigned</i> GOTO: jump to label stored in a variable—as an integer number, as is Fortran’s way, not an address. A <i>computed</i> GOTO in Fortran is more like a switch statement in C: jump to the first label listed in the statement if the specified variable is one, to the second if it is two, ..., fall through to the next statement otherwise.)</div><br/></div></div></div></div></div></div><div id="39506883" class="c"><input type="checkbox" id="c-39506883" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#39503465">parent</a><span>|</span><a href="#39503653">prev</a><span>|</span><a href="#39504651">next</a><span>|</span><label class="collapse" for="c-39506883">[-]</label><label class="expand" for="c-39506883">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [Duff] realized that he could use `case` statements (almost) anywhere in a `switch` block.<p>That’s likely true, in that it probably was a moment for realization for Duff (and many others reading him, including me); yet it’s almost certainly a completely intentional feature.<p>(As mentioned at the bottom of TFA, Duff also realized you could build coroutines on top of it but thought the idea “revolting”.)<p>There’s a temptation to think of C’s `switch` as a very inexpressive pattern match, and then the “fallthrough” seems like a bug and so on. It’s not. It’s a computed GOTO, in the vein of the one in Fortran but more convenient in that the values don’t have to be sequential, and also in that you don’t have to list all the labels at the top. (In fact, now that I’m writing this out, it’s more of a computed COMEFROM, then, isn’t it? However insane that sounds.)</div><br/></div></div><div id="39504651" class="c"><input type="checkbox" id="c-39504651" checked=""/><div class="controls bullet"><span class="by">Scubabear68</span><span>|</span><a href="#39503465">parent</a><span>|</span><a href="#39506883">prev</a><span>|</span><a href="#39504571">next</a><span>|</span><label class="collapse" for="c-39504651">[-]</label><label class="expand" for="c-39504651">[2 more]</label></div><br/><div class="children"><div class="content">Ah the C pre-processor, the gift that keeps on giving after all these years :-(</div><br/><div id="39506863" class="c"><input type="checkbox" id="c-39506863" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#39503465">root</a><span>|</span><a href="#39504651">parent</a><span>|</span><a href="#39504571">next</a><span>|</span><label class="collapse" for="c-39506863">[-]</label><label class="expand" for="c-39506863">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mind macro heavy C code, but this one made me freeze</div><br/></div></div></div></div><div id="39504571" class="c"><input type="checkbox" id="c-39504571" checked=""/><div class="controls bullet"><span class="by">benlivengood</span><span>|</span><a href="#39503465">parent</a><span>|</span><a href="#39504651">prev</a><span>|</span><a href="#39502495">next</a><span>|</span><label class="collapse" for="c-39504571">[-]</label><label class="expand" for="c-39504571">[1 more]</label></div><br/><div class="children"><div class="content">Oh come on, just rewrite it all in Go!  It should only be a few billion line CR.  Your SREs will thank you (eventually).</div><br/></div></div></div></div><div id="39502495" class="c"><input type="checkbox" id="c-39502495" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#39503465">prev</a><span>|</span><a href="#39504208">next</a><span>|</span><label class="collapse" for="c-39502495">[-]</label><label class="expand" for="c-39502495">[5 more]</label></div><br/><div class="children"><div class="content">&gt; no commonly used high level language supports the coroutine<p>This might have been the case back in 2000, but these days many languages do support it, including C++20, Lua, Python, Ruby, etc.</div><br/><div id="39505955" class="c"><input type="checkbox" id="c-39505955" checked=""/><div class="controls bullet"><span class="by">esfandia</span><span>|</span><a href="#39502495">parent</a><span>|</span><a href="#39504107">next</a><span>|</span><label class="collapse" for="c-39505955">[-]</label><label class="expand" for="c-39505955">[3 more]</label></div><br/><div class="children"><div class="content">Python was created in 1991; I imagine the &quot;yield&quot; keyword appeared either right then or not much later!<p>Also, the refinement at the end of the article: &quot;We arrange an extra function parameter, which is a pointer to a context structure; we declare all our local state, and our coroutine state variable, as elements of that structure.&quot; sounds like implementing a closure to me. You make the callee a lambda which would use an outside var&#x2F;context&#x2F;state to determine what to do or with what value. Am I understanding this correctly?</div><br/><div id="39507254" class="c"><input type="checkbox" id="c-39507254" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39502495">root</a><span>|</span><a href="#39505955">parent</a><span>|</span><a href="#39506202">next</a><span>|</span><label class="collapse" for="c-39507254">[-]</label><label class="expand" for="c-39507254">[1 more]</label></div><br/><div class="children"><div class="content">your note about closures is correct, yes<p>as lmm pointed out, python didn&#x27;t have generators and yield until 2.2.  icon, which tim peters adapted the idea from, had them quite a bit earlier than that, but i think it&#x27;s reasonable to describe icon as not being a commonly used language, then or now<p>(python&#x27;s generators are closer syntactically to icon&#x27;s generators than they are semantically)</div><br/></div></div><div id="39506202" class="c"><input type="checkbox" id="c-39506202" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39502495">root</a><span>|</span><a href="#39505955">parent</a><span>|</span><a href="#39507254">prev</a><span>|</span><a href="#39504107">next</a><span>|</span><label class="collapse" for="c-39506202">[-]</label><label class="expand" for="c-39506202">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Python was created in 1991; I imagine the &quot;yield&quot; keyword appeared either right then or not much later!<p>Nope. It was introduced 10 years later, as part of PEP 255, released in Python 2.2.</div><br/></div></div></div></div><div id="39504107" class="c"><input type="checkbox" id="c-39504107" checked=""/><div class="controls bullet"><span class="by">perbu</span><span>|</span><a href="#39502495">parent</a><span>|</span><a href="#39505955">prev</a><span>|</span><a href="#39504208">next</a><span>|</span><label class="collapse" for="c-39504107">[-]</label><label class="expand" for="c-39504107">[1 more]</label></div><br/><div class="children"><div class="content">fwiw, Simula67 had coroutines. Not the first to do so, but IIRC it was the first major language to do so.</div><br/></div></div></div></div><div id="39504208" class="c"><input type="checkbox" id="c-39504208" checked=""/><div class="controls bullet"><span class="by">mid-kid</span><span>|</span><a href="#39502495">prev</a><span>|</span><a href="#39504002">next</a><span>|</span><label class="collapse" for="c-39504208">[-]</label><label class="expand" for="c-39504208">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;switch&quot; method isn&#x27;t too uncommon, but usually people have an init function and &quot;state&quot; pointer that&#x27;s passed into the coroutine function. I&#x27;ve used this method a lot in embedded projects, where one coroutine was handling motor acceleration&#x2F;deceleration while the other would simply tell it what direction to go, but I&#x27;ve also used it for networked libraries[1]. Even the standard library has a coroutine function like this in &quot;strtok()&quot;[2]<p>You don&#x27;t really need to introduce macro hell for it to be manageable, though I&#x27;ve never found reading switch&#x2F;case flow to be very enjoyable.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;REONTeam&#x2F;libmobile&#x2F;blob&#x2F;master&#x2F;relay.c#L346">https:&#x2F;&#x2F;github.com&#x2F;REONTeam&#x2F;libmobile&#x2F;blob&#x2F;master&#x2F;relay.c#L3...</a><p>[2]: <a href="https:&#x2F;&#x2F;manpages.debian.org&#x2F;bookworm&#x2F;manpages-dev&#x2F;strtok.3.en.html" rel="nofollow">https:&#x2F;&#x2F;manpages.debian.org&#x2F;bookworm&#x2F;manpages-dev&#x2F;strtok.3.e...</a></div><br/></div></div><div id="39504002" class="c"><input type="checkbox" id="c-39504002" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#39504208">prev</a><span>|</span><a href="#39502420">next</a><span>|</span><label class="collapse" for="c-39504002">[-]</label><label class="expand" for="c-39504002">[4 more]</label></div><br/><div class="children"><div class="content">If you think this is some C black magic, try reading this by the same author on creating arbitrary control structures with macros: <a href="https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;mp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;mp&#x2F;</a></div><br/><div id="39504210" class="c"><input type="checkbox" id="c-39504210" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39504002">parent</a><span>|</span><a href="#39502420">next</a><span>|</span><label class="collapse" for="c-39504210">[-]</label><label class="expand" for="c-39504210">[3 more]</label></div><br/><div class="children"><div class="content">Note that the underscore prefix thing often is still prone to shadowing. You need pretty ugly mangled names to avoid that, and for external-block macros (unlike expression-ish&#x2F;statement-ish macros) it can&#x27;t be avoided with GNU&#x27;s&#x2F;C23&#x27;s hygienic macro hack.</div><br/><div id="39508031" class="c"><input type="checkbox" id="c-39508031" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39504002">root</a><span>|</span><a href="#39504210">parent</a><span>|</span><a href="#39506467">next</a><span>|</span><label class="collapse" for="c-39508031">[-]</label><label class="expand" for="c-39508031">[1 more]</label></div><br/><div class="children"><div class="content">Wait, was there any recent change to C23 that enabled a different solution than `__COUNTER__`? I realized you have mentioned but didn&#x27;t fully define `CLEANSE_MACRO_VARS` in recent comments, is there any other pointer?</div><br/></div></div><div id="39506467" class="c"><input type="checkbox" id="c-39506467" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#39504002">root</a><span>|</span><a href="#39504210">parent</a><span>|</span><a href="#39508031">prev</a><span>|</span><a href="#39502420">next</a><span>|</span><label class="collapse" for="c-39506467">[-]</label><label class="expand" for="c-39506467">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t recommend doing any of this stuff at all, personally. It&#x27;s just always amazed me though how much you can do with with just basic string substitution and no homoiconicity&#x2F;no AST access.</div><br/></div></div></div></div></div></div><div id="39502420" class="c"><input type="checkbox" id="c-39502420" checked=""/><div class="controls bullet"><span class="by">pieterr</span><span>|</span><a href="#39504002">prev</a><span>|</span><a href="#39502658">next</a><span>|</span><label class="collapse" for="c-39502420">[-]</label><label class="expand" for="c-39502420">[1 more]</label></div><br/><div class="children"><div class="content">From the same author:
Simon Tatham&#x27;s Portable Puzzle Collection<p><a href="https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;puzzles&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;puzzles&#x2F;</a></div><br/></div></div><div id="39502658" class="c"><input type="checkbox" id="c-39502658" checked=""/><div class="controls bullet"><span class="by">c-smile</span><span>|</span><a href="#39502420">prev</a><span>|</span><a href="#39506455">next</a><span>|</span><label class="collapse" for="c-39502658">[-]</label><label class="expand" for="c-39502658">[1 more]</label></div><br/><div class="children"><div class="content">C++ version of the approach: <a href="https:&#x2F;&#x2F;www.codeproject.com&#x2F;Tips&#x2F;29524&#x2F;Generators-in-C" rel="nofollow">https:&#x2F;&#x2F;www.codeproject.com&#x2F;Tips&#x2F;29524&#x2F;Generators-in-C</a><p>I am using this in my Sciter, just in case. Works quite well and convenient.</div><br/></div></div><div id="39506455" class="c"><input type="checkbox" id="c-39506455" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39502658">prev</a><span>|</span><a href="#39506156">next</a><span>|</span><label class="collapse" for="c-39506455">[-]</label><label class="expand" for="c-39506455">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Of course, this trick violates every coding standard in the book. […] I would claim that the coding standards are at fault here.<p>Thoroughly disagree here. The coding standards for not at fault for rejecting this code, but rather the code is merely a cute trick. Software engineering in the large is all about removing surprises and making code readable even to the sleep-deprived on caller waking up at 3am to debug this. You can&#x27;t rely on programmers remembering the ground rules all the time (and there are four of them!)<p>&gt; Coding standards aim for clarity. By hiding vital things like switch, return and case statements inside &quot;obfuscating&quot; macros, the coding standards would claim you have obscured the syntactic structure of the program, and violated the requirement for clarity. But you have done so in the cause of revealing the algorithmic structure of the program, which is far more likely to be what the reader wants to know!<p>It takes skill to write programs that see clear in both their syntactic structure and their algorithmic structure. This isn&#x27;t it. (I am a fan of Rust creating implicit state machines from async functions and I think that should be the model here.)</div><br/><div id="39506503" class="c"><input type="checkbox" id="c-39506503" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39506455">parent</a><span>|</span><a href="#39506156">next</a><span>|</span><label class="collapse" for="c-39506503">[-]</label><label class="expand" for="c-39506503">[7 more]</label></div><br/><div class="children"><div class="content">Endlessly &quot;dumbing down&quot; lowest-common-denominator crap is what&#x27;s responsible for the quality, or lack thereof, of most software today. Shunning knowledge and education will come back to bite you.</div><br/><div id="39506538" class="c"><input type="checkbox" id="c-39506538" checked=""/><div class="controls bullet"><span class="by">bdjsiqoocwk</span><span>|</span><a href="#39506455">root</a><span>|</span><a href="#39506503">parent</a><span>|</span><a href="#39506679">next</a><span>|</span><label class="collapse" for="c-39506538">[-]</label><label class="expand" for="c-39506538">[1 more]</label></div><br/><div class="children"><div class="content">Seconded. Not everything is about the sleep deprived on call guy, not everything is about reducing surprises, not everything is about operations.<p>I had thought before that this &quot;what about the guy at 3am arguments&quot; push in the direction of mediocrity - happy to see I&#x27;m not the only one have these thoughts.</div><br/></div></div><div id="39506679" class="c"><input type="checkbox" id="c-39506679" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39506455">root</a><span>|</span><a href="#39506503">parent</a><span>|</span><a href="#39506538">prev</a><span>|</span><a href="#39506659">next</a><span>|</span><label class="collapse" for="c-39506679">[-]</label><label class="expand" for="c-39506679">[4 more]</label></div><br/><div class="children"><div class="content">Feel free to write your artisanal code in your personal projects. But they don&#x27;t belong in most companies&#x27; code base. You are a cog in the machine at these companies. Your role is to produce code that&#x27;s easily understood by the next programmer. That&#x27;s why coding guidelines exist.</div><br/><div id="39507262" class="c"><input type="checkbox" id="c-39507262" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39506455">root</a><span>|</span><a href="#39506679">parent</a><span>|</span><a href="#39506659">next</a><span>|</span><label class="collapse" for="c-39507262">[-]</label><label class="expand" for="c-39507262">[3 more]</label></div><br/><div class="children"><div class="content">that&#x27;s why all those companies are using putty instead of their own ssh client; they&#x27;re organizationally incapable of writing software of putty&#x27;s quality</div><br/><div id="39507693" class="c"><input type="checkbox" id="c-39507693" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#39506455">root</a><span>|</span><a href="#39507262">parent</a><span>|</span><a href="#39506659">next</a><span>|</span><label class="collapse" for="c-39507693">[-]</label><label class="expand" for="c-39507693">[2 more]</label></div><br/><div class="children"><div class="content">A lot of these companies don’t ship software at all, they write it only for internal use. It needs to be easily fixable by junior interns, not dependent on Bob the 100X programmer who decided to retire last week.</div><br/><div id="39507874" class="c"><input type="checkbox" id="c-39507874" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39506455">root</a><span>|</span><a href="#39507693">parent</a><span>|</span><a href="#39506659">next</a><span>|</span><label class="collapse" for="c-39507874">[-]</label><label class="expand" for="c-39507874">[1 more]</label></div><br/><div class="children"><div class="content">yeah, and of course you normally want as much as possible of your software to be easily fixable by junior interns in any case; that&#x27;s always better when there&#x27;s no compensating drawback<p>the implicit premise of your comment, however, seems to be that no such compensating drawback is possible, presumably because internal-use-only software isn&#x27;t a competitive advantage.  there are a lot of companies that think that way, but i think it&#x27;s shortsighted; see <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39402299">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39402299</a> for some examples of companies that discovered that it mattered a lot how good their internal-use-only software was</div><br/></div></div></div></div></div></div></div></div><div id="39506659" class="c"><input type="checkbox" id="c-39506659" checked=""/><div class="controls bullet"><span class="by">furyofantares</span><span>|</span><a href="#39506455">root</a><span>|</span><a href="#39506503">parent</a><span>|</span><a href="#39506679">prev</a><span>|</span><a href="#39506156">next</a><span>|</span><label class="collapse" for="c-39506659">[-]</label><label class="expand" for="c-39506659">[1 more]</label></div><br/><div class="children"><div class="content">&gt; quality, or lack thereof, of most software today.<p>Also the incredible quantity software today, and how dang cheap it is.</div><br/></div></div></div></div></div></div><div id="39506773" class="c"><input type="checkbox" id="c-39506773" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#39506156">prev</a><span>|</span><a href="#39502465">next</a><span>|</span><label class="collapse" for="c-39506773">[-]</label><label class="expand" for="c-39506773">[1 more]</label></div><br/><div class="children"><div class="content">I’ve used libaco in the past for coroutines in C. I found zlib a pain to use when using curl scheduled with libuv to fetch data. zlib expects a read loop to extract data, but libuv provides an evented push model. Saving all of the zlib state and building a state machine seemed tedious, but a coroutine made the zlib code look like the standard, blocking loop.<p>This was just code for my own amusement, and maybe used by a few people, for non-production work. I’d do it again, however, if I needed to.</div><br/></div></div><div id="39502465" class="c"><input type="checkbox" id="c-39502465" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39506773">prev</a><span>|</span><a href="#39507232">next</a><span>|</span><label class="collapse" for="c-39502465">[-]</label><label class="expand" for="c-39502465">[23 more]</label></div><br/><div class="children"><div class="content">Coroutines are fun, but in real code please consider using actual threads.  Modern processors have many cores, but coroutines will (often) only use a single core.<p>Edit to add: This is a real world problem too.  Until recently qemu, which extensively uses coroutines, would put a lot of its block device I&#x2F;O through a single thread.  This caused some performance issues.  Kevin Wolf and others have spent years of effort fixing this so modern qemu will use many threads for I&#x2F;O (this work will appear in RHEL 9.4).</div><br/><div id="39504850" class="c"><input type="checkbox" id="c-39504850" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39503247">next</a><span>|</span><label class="collapse" for="c-39504850">[-]</label><label class="expand" for="c-39504850">[4 more]</label></div><br/><div class="children"><div class="content">The only connection between threads and coroutines is that some single-threaded language runtimes only have coroutines, so you might occasionally use them where threads would be a better choice.<p>Coroutines are a way of structuring single-threaded execution, and a useful one. The example in the Fine Article of a producer-consumer pattern is a good one, attaching a stream to a parser isn&#x27;t a parallel algorithm so threads are useless for writing it.<p>Naturally, using a single-threaded paradigm for work which could be performed in parallel is inefficient, but coroutines aren&#x27;t a poor man&#x27;s parallelism, they&#x27;re a control structure which functions on its own terms. They can be combined productively with threads, such as using an event loop in a web server to thread (as in needle) coroutines through various blocking events with a dispatcher, and the runtime can spin up a thread per core to parallelize this, which reduces per-thread coordination to checking the depth of each thread&#x27;s work queue and farming the request to the least congested one.</div><br/><div id="39506835" class="c"><input type="checkbox" id="c-39506835" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39504850">parent</a><span>|</span><a href="#39505476">next</a><span>|</span><label class="collapse" for="c-39506835">[-]</label><label class="expand" for="c-39506835">[1 more]</label></div><br/><div class="children"><div class="content">Bob Nystrom makes this argument best, I think, in his two-parter on loops and iteration[1,2]. Looping over data structures is of course only one example of how one can apply coroutines, but a very established one. The canonical problem requiring coroutines[3] is also essentially about doing that.<p>Or for those who want something different there’s the elevator (and elevator-userbase) simulation from TAoCP volume 1, also an essentially concurrent problem with little to no parallelism or I&#x2F;O to it.<p>[1] <a href="https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2013&#x2F;01&#x2F;13&#x2F;iteration-inside-and-out&#x2F;" rel="nofollow">https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2013&#x2F;01&#x2F;13&#x2F;iteration-insi...</a><p>[2] <a href="https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2013&#x2F;02&#x2F;24&#x2F;iteration-inside-and-out-part-2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2013&#x2F;02&#x2F;24&#x2F;iteration-insi...</a><p>[3] <a href="https:&#x2F;&#x2F;wiki.c2.com&#x2F;?SameFringeProblem" rel="nofollow">https:&#x2F;&#x2F;wiki.c2.com&#x2F;?SameFringeProblem</a></div><br/></div></div><div id="39505476" class="c"><input type="checkbox" id="c-39505476" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39504850">parent</a><span>|</span><a href="#39506835">prev</a><span>|</span><a href="#39503247">next</a><span>|</span><label class="collapse" for="c-39505476">[-]</label><label class="expand" for="c-39505476">[2 more]</label></div><br/><div class="children"><div class="content">&gt; attaching a stream to a parser isn&#x27;t a parallel algorithm so threads are useless for writing it.<p>Couldn&#x27;t it be done in 2 threads? The output of the decompressor thread feeds to the input of the parser thread.</div><br/><div id="39506770" class="c"><input type="checkbox" id="c-39506770" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39505476">parent</a><span>|</span><a href="#39503247">next</a><span>|</span><label class="collapse" for="c-39506770">[-]</label><label class="expand" for="c-39506770">[1 more]</label></div><br/><div class="children"><div class="content">It could be, but given the sometimes astonishing costs of the—effectively—network protocol we know as cache coherency (thousands of cycles if you’re not careful), it’d be a giant waste in many of the cases where stackless coroutines would be perfectly appropriate.</div><br/></div></div></div></div></div></div><div id="39503247" class="c"><input type="checkbox" id="c-39503247" checked=""/><div class="controls bullet"><span class="by">c-smile</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39504850">prev</a><span>|</span><a href="#39504032">next</a><span>|</span><label class="collapse" for="c-39503247">[-]</label><label class="expand" for="c-39503247">[5 more]</label></div><br/><div class="children"><div class="content">&gt; please consider using actual threads.<p>Bad advice in general.<p>Why would you run separate thread if you only want is to iterate over nodes in a tree (as an example of non flat collection).</div><br/><div id="39503354" class="c"><input type="checkbox" id="c-39503354" checked=""/><div class="controls bullet"><span class="by">cylon13</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39503247">parent</a><span>|</span><a href="#39504287">next</a><span>|</span><label class="collapse" for="c-39503354">[-]</label><label class="expand" for="c-39503354">[3 more]</label></div><br/><div class="children"><div class="content">It’s never bad advice to consider something.</div><br/><div id="39503532" class="c"><input type="checkbox" id="c-39503532" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39503354">parent</a><span>|</span><a href="#39503891">next</a><span>|</span><label class="collapse" for="c-39503532">[-]</label><label class="expand" for="c-39503532">[1 more]</label></div><br/><div class="children"><div class="content">To the contrary, consideration takes time, and rules of thumb are valuable to mitigate overthinking.</div><br/></div></div><div id="39503891" class="c"><input type="checkbox" id="c-39503891" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39503354">parent</a><span>|</span><a href="#39503532">prev</a><span>|</span><a href="#39504287">next</a><span>|</span><label class="collapse" for="c-39503891">[-]</label><label class="expand" for="c-39503891">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s <i>frequently</i> bad advice to consider something. See eg <a href="https:&#x2F;&#x2F;www.xkcd.com&#x2F;1445&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.xkcd.com&#x2F;1445&#x2F;</a>.</div><br/></div></div></div></div><div id="39504287" class="c"><input type="checkbox" id="c-39504287" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39503247">parent</a><span>|</span><a href="#39503354">prev</a><span>|</span><a href="#39504032">next</a><span>|</span><label class="collapse" for="c-39504287">[-]</label><label class="expand" for="c-39504287">[1 more]</label></div><br/><div class="children"><div class="content">Real world and toy examples are very different.  The example isn&#x27;t like what people are using coroutines for in the real world.  I&#x27;d urge you to look at how coroutines are used for inversion of control (quite correctly) in qemu.</div><br/></div></div></div></div><div id="39504032" class="c"><input type="checkbox" id="c-39504032" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39503247">prev</a><span>|</span><a href="#39503925">next</a><span>|</span><label class="collapse" for="c-39504032">[-]</label><label class="expand" for="c-39504032">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Coroutines are fun, but in real code please consider using actual threads.<p>Coroutines are lightweight and trivial to synchronize. They are perfect for small bits of incremental computation, like iterators and tokenizers. Maybe you&#x27;re thinking of green threads?</div><br/></div></div><div id="39503925" class="c"><input type="checkbox" id="c-39503925" checked=""/><div class="controls bullet"><span class="by">DinaCoder99</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39504032">prev</a><span>|</span><a href="#39504682">next</a><span>|</span><label class="collapse" for="c-39503925">[-]</label><label class="expand" for="c-39503925">[1 more]</label></div><br/><div class="children"><div class="content">That seems like an orthogonal concern to structuring control flow, though it is much more difficult if you intend to use coroutines across multiple threads. There&#x27;s nothing stopping you from using both threading and coroutines.</div><br/></div></div><div id="39504682" class="c"><input type="checkbox" id="c-39504682" checked=""/><div class="controls bullet"><span class="by">ot1138</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39503925">prev</a><span>|</span><a href="#39506283">next</a><span>|</span><label class="collapse" for="c-39504682">[-]</label><label class="expand" for="c-39504682">[1 more]</label></div><br/><div class="children"><div class="content">This is out of the question for real time apps. Co-routines are an elegant solution to implement cooperative multitasking in such cases.</div><br/></div></div><div id="39506283" class="c"><input type="checkbox" id="c-39506283" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39504682">prev</a><span>|</span><a href="#39504758">next</a><span>|</span><label class="collapse" for="c-39506283">[-]</label><label class="expand" for="c-39506283">[1 more]</label></div><br/><div class="children"><div class="content">Threads with implicitly shared memory are more or less impossible to use safely, particularly in a language like C. Coroutines for concurrency, and multiprocessing with explicitly shared memory for parallelism, is a better approach.</div><br/></div></div><div id="39504758" class="c"><input type="checkbox" id="c-39504758" checked=""/><div class="controls bullet"><span class="by">narag</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39506283">prev</a><span>|</span><a href="#39505641">next</a><span>|</span><label class="collapse" for="c-39504758">[-]</label><label class="expand" for="c-39504758">[1 more]</label></div><br/><div class="children"><div class="content"><i>Coroutines are fun, but in real code please consider using actual threads. Modern processors have many cores, but coroutines will (often) only use a single core.</i><p>Threads and coroutines have different purposes. Coroutines are more about logical structure.</div><br/></div></div><div id="39505641" class="c"><input type="checkbox" id="c-39505641" checked=""/><div class="controls bullet"><span class="by">tiberius_p</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39504758">prev</a><span>|</span><a href="#39502697">next</a><span>|</span><label class="collapse" for="c-39505641">[-]</label><label class="expand" for="c-39505641">[1 more]</label></div><br/><div class="children"><div class="content">Coroutines are good for modelling concurrency which is different from parallelism. Concurrency is useful for abstraction and expressiveness. Parallelism is useful for making your code run faster by running parts of it in parallel on multiple cores. You could make concurrent programs run faster on multiple cores by distributing the coroutines which don&#x27;t share state on multiple working threads in a thread pool, thus mixing concurrency and parallelism...but they are still two different things with different purposes.</div><br/></div></div><div id="39502697" class="c"><input type="checkbox" id="c-39502697" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39505641">prev</a><span>|</span><a href="#39503973">next</a><span>|</span><label class="collapse" for="c-39502697">[-]</label><label class="expand" for="c-39502697">[2 more]</label></div><br/><div class="children"><div class="content">&gt; coroutines will (often) only use a single core<p>That&#x27;s generally the desired behavior.  If you have decoupled, parallel workloads they&#x27;re going to naturally be working on disjoint data.  The idea behind coroutines is that you have some kind of <i>local</i> workload with synchronous data that, for whatever reason, is easiest to express &quot;inside out&quot; with a function that gets to loop over something and &quot;push&quot; the results to its abstracted consumer whose code lives somewhere else, vs. the natural functional paradigm where the inner loop is a conceptual &quot;pull&quot; controlled by the caller.</div><br/><div id="39503298" class="c"><input type="checkbox" id="c-39503298" checked=""/><div class="controls bullet"><span class="by">repelsteeltje</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39502697">parent</a><span>|</span><a href="#39503973">next</a><span>|</span><label class="collapse" for="c-39503298">[-]</label><label class="expand" for="c-39503298">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for eloquently expressing an observation I probably should have learned years ago.</div><br/></div></div></div></div><div id="39503142" class="c"><input type="checkbox" id="c-39503142" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39503973">prev</a><span>|</span><a href="#39502510">next</a><span>|</span><label class="collapse" for="c-39503142">[-]</label><label class="expand" for="c-39503142">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s often a sweet spot to be had in mixing threads and coroutines, where you have a coroutine scheduler instance per thread, and a thread created per core.<p>Then rarely, if ever, migrate coroutines across schedulers, and rarely, if ever, share data between coroutines on different schedulers.<p>Coroutines can enable an ergonomic concurrent programming style while avoiding the need for any locking at all via cooperative scheduling.  You generally end up with higher scheduling latencies, but potentially quite high throughput by removing any need for atomics&#x2F;locking overheads, and no timer constantly interrupting execution for preemptive scheduling.</div><br/><div id="39504280" class="c"><input type="checkbox" id="c-39504280" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39503142">parent</a><span>|</span><a href="#39502510">next</a><span>|</span><label class="collapse" for="c-39504280">[-]</label><label class="expand" for="c-39504280">[1 more]</label></div><br/><div class="children"><div class="content">Right, that&#x27;s what qemu has ended up with.</div><br/></div></div></div></div><div id="39502510" class="c"><input type="checkbox" id="c-39502510" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#39502465">parent</a><span>|</span><a href="#39503142">prev</a><span>|</span><a href="#39507232">next</a><span>|</span><label class="collapse" for="c-39502510">[-]</label><label class="expand" for="c-39502510">[2 more]</label></div><br/><div class="children"><div class="content">Not just that, but the scaling problems with threads are usually massively overstated. It&#x27;s true that thread switching has quite a bit more overhead, but it&#x27;s been optimized a <i>lot</i> since the bad old days of 15+ years ago. (Plus, unless you&#x27;re using a massive number of threads it&#x27;s very unlikely that thread switching is going to be your bottleneck.)</div><br/><div id="39503032" class="c"><input type="checkbox" id="c-39503032" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#39502465">root</a><span>|</span><a href="#39502510">parent</a><span>|</span><a href="#39507232">next</a><span>|</span><label class="collapse" for="c-39503032">[-]</label><label class="expand" for="c-39503032">[1 more]</label></div><br/><div class="children"><div class="content">Unless you&#x27;re on QNX 7 of course...</div><br/></div></div></div></div></div></div><div id="39507232" class="c"><input type="checkbox" id="c-39507232" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#39502465">prev</a><span>|</span><a href="#39502591">next</a><span>|</span><label class="collapse" for="c-39507232">[-]</label><label class="expand" for="c-39507232">[1 more]</label></div><br/><div class="children"><div class="content">I was so sure this was about protothreads til I remembered its name. <a href="https:&#x2F;&#x2F;dunkels.com&#x2F;adam&#x2F;pt&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dunkels.com&#x2F;adam&#x2F;pt&#x2F;</a></div><br/></div></div><div id="39502591" class="c"><input type="checkbox" id="c-39502591" checked=""/><div class="controls bullet"><span class="by">DenisM</span><span>|</span><a href="#39507232">prev</a><span>|</span><a href="#39504502">next</a><span>|</span><label class="collapse" for="c-39502591">[-]</label><label class="expand" for="c-39502591">[9 more]</label></div><br/><div class="children"><div class="content">Setjmp&#x2F;longjump are the built-in coroutines in C, no?</div><br/><div id="39502970" class="c"><input type="checkbox" id="c-39502970" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#39502591">parent</a><span>|</span><a href="#39504415">next</a><span>|</span><label class="collapse" for="c-39502970">[-]</label><label class="expand" for="c-39502970">[4 more]</label></div><br/><div class="children"><div class="content">Some longjmp implementations unwind the stack, so they can&#x27;t be used for coroutine switching. Even if it works (it&#x27;s technically undefined), you need to get a suitable stack from somewhere.<p>The next issue is that usually, applications want to resume coroutines on a thread different from the one it on which it was suspended. That runs into trouble because on some systems, compilers cache the address of thread-local variables in the local stack frame, assuming that the thread does not switch in a function mid-execution.</div><br/><div id="39503320" class="c"><input type="checkbox" id="c-39503320" checked=""/><div class="controls bullet"><span class="by">DenisM</span><span>|</span><a href="#39502591">root</a><span>|</span><a href="#39502970">parent</a><span>|</span><a href="#39504415">next</a><span>|</span><label class="collapse" for="c-39503320">[-]</label><label class="expand" for="c-39503320">[3 more]</label></div><br/><div class="children"><div class="content">The only platform I’ve seen stack unwind was VAX&#x2F;VMS :)<p>But yes, you do need to allocate the stack which could take up a lot of ram.<p>It’s odd not to mention it in the article though.</div><br/><div id="39503776" class="c"><input type="checkbox" id="c-39503776" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#39502591">root</a><span>|</span><a href="#39503320">parent</a><span>|</span><a href="#39504415">next</a><span>|</span><label class="collapse" for="c-39503776">[-]</label><label class="expand" for="c-39503776">[2 more]</label></div><br/><div class="children"><div class="content">Current glibc unwinds the shadow stack if it is active: <a href="https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p=glibc.git;a=blob;f=sysdeps&#x2F;x86_64&#x2F;__longjmp.S;h=22fedc49970eba0ab86cb8dec8411197bec95d37;hb=HEAD#l80" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p=glibc.git;a=blob;f=sysdeps&#x2F;x86...</a><p>It makes longjmp useless for coroutine switching, although it does not result in other effects of stack unwinding (such as invoking C++ destructors).<p>On Windows, longjmp really unwinds the stack (and maybe this is something influenced by VMS): <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;c-runtime-library&#x2F;reference&#x2F;longjmp" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;c-runtime-library&#x2F;refe...</a> “In Microsoft C++ code on Windows, longjmp uses the same stack-unwinding semantics as exception-handling code. It&#x27;s safe to use in the same places that C++ exceptions can be raised.”</div><br/><div id="39504187" class="c"><input type="checkbox" id="c-39504187" checked=""/><div class="controls bullet"><span class="by">DenisM</span><span>|</span><a href="#39502591">root</a><span>|</span><a href="#39503776">parent</a><span>|</span><a href="#39504415">next</a><span>|</span><label class="collapse" for="c-39504187">[-]</label><label class="expand" for="c-39504187">[1 more]</label></div><br/><div class="children"><div class="content">Well, things have changed since I looked last. Thanks for explaining.<p>FWIW, back in the nineties we just wrote our own setjmp&#x2F;longjmp for VMS to avoid stack unwind - save registers &#x2F; restore registers. We used it to implement coroutines in Modula 2, iirc.</div><br/></div></div></div></div></div></div></div></div><div id="39504415" class="c"><input type="checkbox" id="c-39504415" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#39502591">parent</a><span>|</span><a href="#39502970">prev</a><span>|</span><a href="#39502757">next</a><span>|</span><label class="collapse" for="c-39504415">[-]</label><label class="expand" for="c-39504415">[1 more]</label></div><br/><div class="children"><div class="content">No. The C standard says this about longjmp: &quot;if the function containing the invocation of the setjmp macro has terminated execution in the interim [...] the behavior is undefined&quot;. So while you can longjmp out of functions, you can&#x27;t longjmp back into them.</div><br/></div></div><div id="39502757" class="c"><input type="checkbox" id="c-39502757" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#39502591">parent</a><span>|</span><a href="#39504415">prev</a><span>|</span><a href="#39502774">next</a><span>|</span><label class="collapse" for="c-39502757">[-]</label><label class="expand" for="c-39502757">[2 more]</label></div><br/><div class="children"><div class="content">These are stackless coroutines, if you use longjump you have to create a stack for the coroutine.<p>There are pros and cons for each style.</div><br/><div id="39506969" class="c"><input type="checkbox" id="c-39506969" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#39502591">root</a><span>|</span><a href="#39502757">parent</a><span>|</span><a href="#39502774">next</a><span>|</span><label class="collapse" for="c-39506969">[-]</label><label class="expand" for="c-39506969">[1 more]</label></div><br/><div class="children"><div class="content">In theory (but only possible in assembly right now), there could be coroutines that shared the stack of their caller. As long as the caller (who&#x27;s calling from a normal function) finishes calling the coroutine and doesn&#x27;t expect to be able to call it after they return, then you could use it to implement iterators, e.g. over a binary tree or a hash table, like generators in Python. It could work as long as the caller used the stack frame base pointer to refer to their saved local variables, since the stack pointer could be changed between yields to the coroutine. I&#x27;m genuinely surprised there hasn&#x27;t been a compiled programming language to do that other than Sather and CLU[0] (both of which are long dead by now). Graydon Hoare originally wanted them in Rust [1], but LLVM didn&#x27;t support it, so it was scrapped.<p>[0]: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;800127.804079" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;800127.804079</a> (the third PDF page, page 125)<p>[1]: <a href="https:&#x2F;&#x2F;graydon2.dreamwidth.org&#x2F;307291.html" rel="nofollow">https:&#x2F;&#x2F;graydon2.dreamwidth.org&#x2F;307291.html</a> (search &quot;non-escaping coroutine&quot;)</div><br/></div></div></div></div><div id="39502774" class="c"><input type="checkbox" id="c-39502774" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#39502591">parent</a><span>|</span><a href="#39502757">prev</a><span>|</span><a href="#39504502">next</a><span>|</span><label class="collapse" for="c-39502774">[-]</label><label class="expand" for="c-39502774">[1 more]</label></div><br/><div class="children"><div class="content">You can absolutely build coroutines out of a generalized context switch.  So yes, in some sense.  But note that the linked article doesn&#x27;t use setjmp&#x2F;longjmp, which is what makes it so clever.<p>FWIW: would I personally actually use this trick?  Almost certainly not.  C APIs aren&#x27;t well suited to that level of abstraction IMHO, if you have an app that needs it leave the C stuff to the stuff C is good at and wrap a C++ or Rust or whatever layer on top for the subtleties.</div><br/></div></div></div></div><div id="39504502" class="c"><input type="checkbox" id="c-39504502" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#39502591">prev</a><span>|</span><a href="#39503191">next</a><span>|</span><label class="collapse" for="c-39504502">[-]</label><label class="expand" for="c-39504502">[1 more]</label></div><br/><div class="children"><div class="content">Also related, the C++ lambda fuckup: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33084431">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33084431</a></div><br/></div></div><div id="39503191" class="c"><input type="checkbox" id="c-39503191" checked=""/><div class="controls bullet"><span class="by">vinay_ys</span><span>|</span><a href="#39504502">prev</a><span>|</span><a href="#39505781">next</a><span>|</span><label class="collapse" for="c-39503191">[-]</label><label class="expand" for="c-39503191">[1 more]</label></div><br/><div class="children"><div class="content">Ah, this page again! it&#x27;s been more than two decades? since I saw this page last? It was fun to learn about coroutines from the author of PuttY the ssh client of choice on Windows those days.</div><br/></div></div><div id="39503829" class="c"><input type="checkbox" id="c-39503829" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39505781">prev</a><span>|</span><a href="#39502507">next</a><span>|</span><label class="collapse" for="c-39503829">[-]</label><label class="expand" for="c-39503829">[2 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Coroutines in C (2000)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37357673">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37357673</a> - Sept 2023 (1 comment)<p><i>Coroutines in C (2000)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36639879">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36639879</a> - July 2023 (2 comments)<p><i>Coroutines in C</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23293835">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23293835</a> - May 2020 (1 comment)<p><i>Coroutines in C (2000)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19106796">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19106796</a> - Feb 2019 (59 comments)<p><i>Coroutines in C, revisited</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13199245">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13199245</a> - Dec 2016 (36 comments)<p><i>Coroutines in C</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13138673">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13138673</a> - Dec 2016 (1 comment)<p><i>Coroutines in C (2000)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11051004">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11051004</a> - Feb 2016 (11 comments)<p><i>Show HN: Libconcurrent – Coroutines in C</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10887071">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10887071</a> - Jan 2016 (24 comments)<p><i>Coroutines in C with Arbitrary Arguments</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9402314">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9402314</a> - April 2015 (22 comments)<p><i>Coroutines in C (2000)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8615501">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8615501</a> - Nov 2014 (27 comments)<p><i>Coroutines in C (2000)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6244994">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6244994</a> - Aug 2013 (1 comment)<p><i>Coroutines in one page of C</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6243946">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6243946</a> - Aug 2013 (60 comments)<p><i>Coroutines in C (Simon Tatham, 2000)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1380044">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1380044</a> - May 2010 (16 comments)<p><i>Coroutines in C</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=835849">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=835849</a> - Sept 2009 (16 comments)<p><i>Co-routines in C</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=794157">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=794157</a> - Aug 2009 (1 comment)</div><br/><div id="39505564" class="c"><input type="checkbox" id="c-39505564" checked=""/><div class="controls bullet"><span class="by">anfilt</span><span>|</span><a href="#39503829">parent</a><span>|</span><a href="#39502507">next</a><span>|</span><label class="collapse" for="c-39505564">[-]</label><label class="expand" for="c-39505564">[1 more]</label></div><br/><div class="children"><div class="content">Bunki, a C Coroutine library
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35133095">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35133095</a></div><br/></div></div></div></div><div id="39502509" class="c"><input type="checkbox" id="c-39502509" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39502507">prev</a><span>|</span><a href="#39502616">next</a><span>|</span><label class="collapse" for="c-39502509">[-]</label><label class="expand" for="c-39502509">[1 more]</label></div><br/><div class="children"><div class="content">(2000)</div><br/></div></div><div id="39502616" class="c"><input type="checkbox" id="c-39502616" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#39502509">prev</a><span>|</span><a href="#39505529">next</a><span>|</span><label class="collapse" for="c-39502616">[-]</label><label class="expand" for="c-39502616">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used this for some embedded&#x2F;IoT projects before. They work really well.</div><br/></div></div><div id="39505529" class="c"><input type="checkbox" id="c-39505529" checked=""/><div class="controls bullet"><span class="by">anfilt</span><span>|</span><a href="#39502616">prev</a><span>|</span><a href="#39507900">next</a><span>|</span><label class="collapse" for="c-39505529">[-]</label><label class="expand" for="c-39505529">[1 more]</label></div><br/><div class="children"><div class="content">I honestly like stackful coroutines if you don’t mind allocating memory for a stack.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Keith-Cancel&#x2F;Bunki">https:&#x2F;&#x2F;github.com&#x2F;Keith-Cancel&#x2F;Bunki</a></div><br/></div></div><div id="39507900" class="c"><input type="checkbox" id="c-39507900" checked=""/><div class="controls bullet"><span class="by">jijji</span><span>|</span><a href="#39505529">prev</a><span>|</span><a href="#39503485">next</a><span>|</span><label class="collapse" for="c-39507900">[-]</label><label class="expand" for="c-39507900">[1 more]</label></div><br/><div class="children"><div class="content">how does this compare to using Go goroutines?</div><br/></div></div><div id="39505081" class="c"><input type="checkbox" id="c-39505081" checked=""/><div class="controls bullet"><span class="by">whiterknight</span><span>|</span><a href="#39503485">prev</a><span>|</span><a href="#39502424">next</a><span>|</span><label class="collapse" for="c-39505081">[-]</label><label class="expand" for="c-39505081">[3 more]</label></div><br/><div class="children"><div class="content">UNIX pipes solve this problem. Both reader and writer are driving their respective process.</div><br/><div id="39505854" class="c"><input type="checkbox" id="c-39505854" checked=""/><div class="controls bullet"><span class="by">esfandia</span><span>|</span><a href="#39505081">parent</a><span>|</span><a href="#39502424">next</a><span>|</span><label class="collapse" for="c-39505854">[-]</label><label class="expand" for="c-39505854">[2 more]</label></div><br/><div class="children"><div class="content">The article says: &quot;In many modern operating systems, you could do this using pipes between two processes or two threads. emit() in the decompressor writes to a pipe, and getchar() in the parser reads from the other end of the same pipe. Simple and robust, but also heavyweight and not portable. Typically you don&#x27;t want to have to divide your program into threads for a task this simple.&quot;</div><br/><div id="39505877" class="c"><input type="checkbox" id="c-39505877" checked=""/><div class="controls bullet"><span class="by">whiterknight</span><span>|</span><a href="#39505081">root</a><span>|</span><a href="#39505854">parent</a><span>|</span><a href="#39502424">next</a><span>|</span><label class="collapse" for="c-39505877">[-]</label><label class="expand" for="c-39505877">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. I have read this article a few times and somehow missed that was acknowledged.<p>“Heavyweight” is where I disagree. It’s exactly whats needed to be able to write sequential code on each side.</div><br/></div></div></div></div></div></div><div id="39502424" class="c"><input type="checkbox" id="c-39502424" checked=""/><div class="controls bullet"><span class="by">anymouse123456</span><span>|</span><a href="#39505081">prev</a><span>|</span><label class="collapse" for="c-39502424">[-]</label><label class="expand" for="c-39502424">[4 more]</label></div><br/><div class="children"><div class="content">I assume I&#x27;m missing that this a joke, it&#x27;s honestly hard for me to tell.<p>But in the conclusion, the author talks about actually making this work by providing a context object to hold all of the intermediate state and providing this context object to the callee.<p>Once this is required, how does this approach compare to simply using an external iterator?<p>Seems to me like an iterator solves the lion&#x27;s share of the problem here. It moves the state into the caller&#x27;s stack (or above them), it&#x27;s easy to understand, simple to implement and doesn&#x27;t involve unenclosed and context-dependent macros.</div><br/><div id="39503258" class="c"><input type="checkbox" id="c-39503258" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#39502424">parent</a><span>|</span><a href="#39502506">next</a><span>|</span><label class="collapse" for="c-39503258">[-]</label><label class="expand" for="c-39503258">[1 more]</label></div><br/><div class="children"><div class="content">Why would you assume that this is a joke?<p>C (particularly back when this was written) was a low level language. You could not simply use an external iterator - they didn&#x27;t exist. And if you try to roll your own, you&#x27;ll wind up dealing with a lot of complications around resource management in a language which lacks basic memory management.<p>But the proof is in the pudding. Back then it was common to want to telnet into a Unix machine from Windows. And the only two solutions that worked well enough to consider were installing Cygwin, or installing PuTTY. Cygwin was better if you needed a Unix environment on your Windows machine. Otherwise PuTTY was your answer. As the article comments, PuTTY was written with this technique.<p>When you&#x27;ve solved a problem that a lot of people had, and your solution is widely acknowledged as the best one out there, people get interested in how you think it should be solved. Which is why this article interested me when I first saw in many years ago on Slashdot.<p>So absolutely not a joke.</div><br/></div></div><div id="39502506" class="c"><input type="checkbox" id="c-39502506" checked=""/><div class="controls bullet"><span class="by">syncurrent</span><span>|</span><a href="#39502424">parent</a><span>|</span><a href="#39503258">prev</a><span>|</span><a href="#39502744">next</a><span>|</span><label class="collapse" for="c-39502506">[-]</label><label class="expand" for="c-39502506">[1 more]</label></div><br/><div class="children"><div class="content">Proto-Activities have this context to store the state in the caller.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;frameworklabs&#x2F;proto_activities">https:&#x2F;&#x2F;github.com&#x2F;frameworklabs&#x2F;proto_activities</a></div><br/></div></div><div id="39502744" class="c"><input type="checkbox" id="c-39502744" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#39502424">parent</a><span>|</span><a href="#39502506">prev</a><span>|</span><label class="collapse" for="c-39502744">[-]</label><label class="expand" for="c-39502744">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Seems to me like an iterator solves the lion&#x27;s share of the problem here.<p>Iterator APIs are indeed aimed at the same kind of problem, but they&#x27;re not the same solution.  And often they&#x27;re harder to write.  If you have a component with a big list of stuff, it&#x27;s generally easier to write and understand the idea of &quot;iterate over my big list of stuff and emit one item at a time to my consumer&quot; than it is &quot;what state do I need to remember such that when I get called again I can emit the correct next item given the one I just emitted?&quot;.<p>Coroutines are a way of expressing the former.  Iterators are the latter.  If all you do is write the outer loop, iterators are absolutely just as good.  If you need to write the iterator itself, it&#x27;s more of a discussion.</div><br/></div></div></div></div></div></div></div></div></div></body></html>