<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688547651855" as="style"/><link rel="stylesheet" href="styles.css?v=1688547651855"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.biscuitsec.org/docs/guides/revocation/">Token revocation</a>Â <span class="domain">(<a href="https://www.biscuitsec.org">www.biscuitsec.org</a>)</span></div><div class="subtext"><span>geal</span> | <span>32 comments</span></div><br/><div><div id="36595216" class="c"><input type="checkbox" id="c-36595216" checked=""/><div class="controls bullet"><span class="by">jcrites</span><span>|</span><a href="#36593927">next</a><span>|</span><label class="collapse" for="c-36595216">[-]</label><label class="expand" for="c-36595216">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It is now recommended to have a refresh token with an expiration date, that can be long, and have that refresh token be single use. When it is sent to the authorization server to get a new access token, the authorization server will revoke the old refresh token and issue new refresh and access tokens.<p>I&#x27;ve been wondering briefly about this specific flow. It seems prone to a problem: if the refresh request gets <i>sent</i> successfully (and then invalidated), but <i>the reply is not received</i> for any reason, then the authorization chain is broken. There&#x27;s no way to get a new token. Is there a good &#x27;standard&#x27; way to handle this problem?<p>On brief reflection, while writing this comment, it seems like the only solution is to fall back to some other (long-lived) identity (from which the original OAuth token was derived). But that can be an inconvenient fallback.<p>&gt; The interesting property here is that if the authorization server sees the same refresh token twice, it means that the token was stolen: either the thief or the legitimate client already used the refresh token, and the other one is now requesting an access token too. In that case, the authorization server must revoke all current refresh and access tokens for this client.<p>That seems like an invalid conclusion to draw though. Multiple requests could simply be caused by failures (including race conditions). Should the refresh token really be single-use?<p>One alternative that I could imagine is that the refresh token can be used multiple times, but whenever it&#x27;s used, then only the most-recently created tokens remain valid -- with all prior tokens (that were created from it) being invalidated. This would enable token refresh to survive failures, while also making any tampering evident (due to the appearance of unexpectedly invalidated tokens).<p>Edit: Another strategy might be to link together all access tokens into one &quot;session&quot;: whenever a refresh token is used to create new tokens, those all count as the same &quot;session&quot; and the session is what&#x27;s invalidated. (The &#x27;session&#x27; would be established during the process issues the first tokens).</div><br/><div id="36595628" class="c"><input type="checkbox" id="c-36595628" checked=""/><div class="controls bullet"><span class="by">as1mov</span><span>|</span><a href="#36595216">parent</a><span>|</span><a href="#36595271">next</a><span>|</span><label class="collapse" for="c-36595628">[-]</label><label class="expand" for="c-36595628">[1 more]</label></div><br/><div class="children"><div class="content">&gt; On brief reflection, while writing this comment, it seems like the only solution is to fall back to some other (long-lived) identity (from which the original OAuth token was derived).<p>I have been working on an OAuth service provider for the past few months, ran into this scenario. We came up with a solution of not immediately expiring the refresh token after it&#x27;s used but set its expiry to X seconds (&lt;30s) in the future and put it in a leeway state. If another call with the same refresh token is received within the X seconds and the refresh token is in the leeway state, a new token pair is created. If the refresh token is used after X seconds, it&#x27;s no longer valid and a new authorization has to be generated.<p>Of course this isn&#x27;t a foolproof solution, it has its own caveats but it&#x27;s better than the alternative of forcing the user to go through the authorization process again or keeping the refresh token alive forever.</div><br/></div></div><div id="36595271" class="c"><input type="checkbox" id="c-36595271" checked=""/><div class="controls bullet"><span class="by">xyzzy123</span><span>|</span><a href="#36595216">parent</a><span>|</span><a href="#36595628">prev</a><span>|</span><a href="#36596084">next</a><span>|</span><label class="collapse" for="c-36595271">[-]</label><label class="expand" for="c-36595271">[1 more]</label></div><br/><div class="children"><div class="content">I do think it&#x27;s a practical control if you are responsible for both the server AND all the client(s) code, i.e, it&#x27;s feasible for you to micro-manage the fine detail of the auth dance.<p>However if you are providing an oauth &#x2F; oidc API endpoint to be consumed by arbitrary developers I wouldn&#x27;t advise this.<p>The way many clients work is that refresh token stuff happens in the background as needed, &quot;piggybacking&quot; off the thread using the access token. Depending on how everything is set up, parallel requests can be generated.<p>Providing support for oidc &#x2F; oauth token flows is already extremely difficult because customers will usually be using an ecosystem-specific library and usually don&#x27;t understand the spec, let alone whatever stricter &quot;best practices&quot; you might be enforcing.</div><br/></div></div><div id="36596084" class="c"><input type="checkbox" id="c-36596084" checked=""/><div class="controls bullet"><span class="by">buzer</span><span>|</span><a href="#36595216">parent</a><span>|</span><a href="#36595271">prev</a><span>|</span><a href="#36593927">next</a><span>|</span><label class="collapse" for="c-36596084">[-]</label><label class="expand" for="c-36596084">[1 more]</label></div><br/><div class="children"><div class="content">One option could be to require that the access token needs to used within X seconds after it has been issued. During this period:<p>* Old refresh token can be used. Using it will revoke previous &quot;new&quot; tokens (and possibly generate some warnings, especially if new tokens are used after this)<p>* Using new access token will revoke old refresh token and access tokens, possibly requiring access on dedicated path (something like lookup, essentially confirming that you received it)<p>This probably should be rate limited to avoid malicious&#x2F;buggy client filling the revoke list with junk. And it may also make sense to decrease the lifetime of the old refresh token (e.g. if it was originally going to expire in 24h make it expire in 30 minutes) or set maximum of times this swap can happen.<p>Of course this would still cause issues if e.g. database server where these were stored failed and client had to restore from backups.</div><br/></div></div></div></div><div id="36593927" class="c"><input type="checkbox" id="c-36593927" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#36595216">prev</a><span>|</span><a href="#36593796">next</a><span>|</span><label class="collapse" for="c-36593927">[-]</label><label class="expand" for="c-36593927">[1 more]</label></div><br/><div class="children"><div class="content">This is an ongoing struggle with providers like Azure AD. In our setup, we have function apps that are receiving OIDC tokens from our AAD provider - either from our tenant our others via B2B collab. In this arrangement, it is possible for a user to pass authn for up to 1 hour before revocation in the hosting tenant takes effect. You can reduce this expiration but it can make the experience really bad across the board for all apps.<p>My current strategy for dealing with this is to add application-specific safeguards that re-verify the assigned roles of whatever user principal is present during more sensitive operations. If we detect that the user principal+token is no longer authorized, we can revoke our session bound to the AAD token and <i>any</i> further access is effectively restricted.<p>I&#x27;ve seen some other approaches, but I don&#x27;t think you will get one that fits like a glove without making some alterations to the actual application which is consuming these tokens.</div><br/></div></div><div id="36593796" class="c"><input type="checkbox" id="c-36593796" checked=""/><div class="controls bullet"><span class="by">WirelessGigabit</span><span>|</span><a href="#36593927">prev</a><span>|</span><a href="#36594064">next</a><span>|</span><label class="collapse" for="c-36593796">[-]</label><label class="expand" for="c-36593796">[6 more]</label></div><br/><div class="children"><div class="content">You&#x27;re still stuck with a delay of you fetching the list of revoked tokens and someone getting to your service.<p>And that delay allows someone to come in with a compromised token.<p>However, with short expiration dates you achieve the same. You shorten the duration that a token is valid for.<p>Assume a token is revoked. It can be used against any target until they refresh their revocation list.<p>Same goes with just tokens with a short expiration date. It can be used against any target until it expires.<p>I guess the difference is users extending their token lifetime more often (more load for your signing server) vs offering an API that you can use to share revoked tokens which needs to be checked every time (in which case it&#x27;s no longer stateless) or checked every once in a while.<p>Pick your poison.</div><br/><div id="36594301" class="c"><input type="checkbox" id="c-36594301" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#36593796">parent</a><span>|</span><a href="#36593876">next</a><span>|</span><label class="collapse" for="c-36594301">[-]</label><label class="expand" for="c-36594301">[1 more]</label></div><br/><div class="children"><div class="content">You can do something like the True time trick. Services refresh the revocation list every 1s. If they can&#x27;t refresh for more than 10s they reject authorization. Then on revocation you just need to wait for 15s or so to ensure that the token will no longer be accepted.<p>This of course means that your downtime tolerance for the token distribution is quite low, but still better than checking revocation on each request.<p>You can also flip it and track the state of every app server, revocation waits until they have all updated (or been confirmed dead) but now revocation time is unbounded. (And you are tracking more mutable state)</div><br/></div></div><div id="36593876" class="c"><input type="checkbox" id="c-36593876" checked=""/><div class="controls bullet"><span class="by">meindnoch</span><span>|</span><a href="#36593796">parent</a><span>|</span><a href="#36594301">prev</a><span>|</span><a href="#36594042">next</a><span>|</span><label class="collapse" for="c-36593876">[-]</label><label class="expand" for="c-36593876">[2 more]</label></div><br/><div class="children"><div class="content">Unless you push the revocation list changes immediately to the service instances.</div><br/><div id="36594017" class="c"><input type="checkbox" id="c-36594017" checked=""/><div class="controls bullet"><span class="by">WirelessGigabit</span><span>|</span><a href="#36593796">root</a><span>|</span><a href="#36593876">parent</a><span>|</span><a href="#36594042">next</a><span>|</span><label class="collapse" for="c-36594017">[-]</label><label class="expand" for="c-36594017">[1 more]</label></div><br/><div class="children"><div class="content">Which makes it stateful, but instead of a punch of systems pulling your revocation list you&#x27;re pushing it.</div><br/></div></div></div></div><div id="36594042" class="c"><input type="checkbox" id="c-36594042" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#36593796">parent</a><span>|</span><a href="#36593876">prev</a><span>|</span><a href="#36594064">next</a><span>|</span><label class="collapse" for="c-36594042">[-]</label><label class="expand" for="c-36594042">[2 more]</label></div><br/><div class="children"><div class="content">How about short-lived access tokens and refresh tokens?</div><br/><div id="36594495" class="c"><input type="checkbox" id="c-36594495" checked=""/><div class="controls bullet"><span class="by">WirelessGigabit</span><span>|</span><a href="#36593796">root</a><span>|</span><a href="#36594042">parent</a><span>|</span><a href="#36594064">next</a><span>|</span><label class="collapse" for="c-36594495">[-]</label><label class="expand" for="c-36594495">[1 more]</label></div><br/><div class="children"><div class="content">Depends on your usecase. On a device it&#x27;s harder to steal a token, especially on iOS when you put all that stuff in the secured enclave.<p>Fortify that with certificate pinning on your application and it suddenly becomes REALLY hard to intercept traffic.</div><br/></div></div></div></div></div></div><div id="36594064" class="c"><input type="checkbox" id="c-36594064" checked=""/><div class="controls bullet"><span class="by">dmatech</span><span>|</span><a href="#36593796">prev</a><span>|</span><a href="#36593455">next</a><span>|</span><label class="collapse" for="c-36594064">[-]</label><label class="expand" for="c-36594064">[1 more]</label></div><br/><div class="children"><div class="content">It depends on the scenario.  I can think of the following, although they&#x27;re pretty similar.<p>1. Lost&#x2F;stolen access token.
2. Lost&#x2F;stolen refresh token.
3. Disabled account.<p>In the case of systems like Azure where access tokens have an &quot;audience&quot;, they could theoretically send a revocation message to the audience endpoint (which would only need to care about revocations younger than the duration of access tokens, much like a CRL).<p>Revoking a refresh token would probably need to revoke all access (and perhaps identity) tokens associated with it.<p>Disabling an account would just need to revoke all tokens associated with it.</div><br/></div></div><div id="36593455" class="c"><input type="checkbox" id="c-36593455" checked=""/><div class="controls bullet"><span class="by">FrenchyJiby</span><span>|</span><a href="#36594064">prev</a><span>|</span><a href="#36594066">next</a><span>|</span><label class="collapse" for="c-36593455">[-]</label><label class="expand" for="c-36593455">[1 more]</label></div><br/><div class="children"><div class="content">Biscuit has been one of those pieces of tech that makes me re-think the way we organize our stack, with a couple of key ideas that make us more user-centric and enable decentralized systems.<p>Granted I haven&#x27;t used it, on toy project or in anger, but it sounds really neat.</div><br/></div></div><div id="36594066" class="c"><input type="checkbox" id="c-36594066" checked=""/><div class="controls bullet"><span class="by">ShroudedNight</span><span>|</span><a href="#36593455">prev</a><span>|</span><a href="#36593943">next</a><span>|</span><label class="collapse" for="c-36594066">[-]</label><label class="expand" for="c-36594066">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand the argument that expirations are inadequate: what&#x27;s the likelihood of ending up with a token compromise without the client machine also being compromised? Further, if the client machine is compromised, isn&#x27;t token revocation not much more than a fig leaf? If the machine is working correctly, and the user wants to explicitly terminate a session, why is erasing &#x2F; forgetting the session secret not adequate?<p>I feel like I&#x27;m missing some critical, but non-obvious threat model here.</div><br/><div id="36595285" class="c"><input type="checkbox" id="c-36595285" checked=""/><div class="controls bullet"><span class="by">jcrites</span><span>|</span><a href="#36594066">parent</a><span>|</span><a href="#36595300">next</a><span>|</span><label class="collapse" for="c-36595285">[-]</label><label class="expand" for="c-36595285">[1 more]</label></div><br/><div class="children"><div class="content">One threat model that people worry about is whether credentials can be lifted from a compromised machine <i>once</i> and then used to have permanent ongoing access -- without requiring ongoing access to the compromised machine.<p>If you have ongoing access to a compromised machine, then all bets are off. However, one security goal in these kinds of situations is to be able to rapidly &quot;lock down&quot; and quarantine a suspected breach; which in this case means revoking all of the credentials that the machine had access to. You want to be able to do this, and then once you&#x27;ve done this, be confident that the attacker has no further access.<p>If an attacker can lift a &#x27;refresh token&#x27; from the machine, and use it to generate their own unlimited number of new credentials (that can be periodically refreshed indefinitely), then the challenge of revoking compromised credentials is more difficult; by the time you add a compromised token to a refresh list, it may have already been used to create another.<p>So you can&#x27;t just say: &quot;What credentials were on the machine? Revoke them all.&quot; That&#x27;s not enough if the attacker can create their own new credentials using the refresh token.<p>If access tokens can be used to create additional access credentials, then it&#x27;s more difficult to track and revoke all of them -- you&#x27;d need to revoke some kind of &#x27;session&#x27; that all of the access tokens can be attributed to.</div><br/></div></div><div id="36595300" class="c"><input type="checkbox" id="c-36595300" checked=""/><div class="controls bullet"><span class="by">brianpan</span><span>|</span><a href="#36594066">parent</a><span>|</span><a href="#36595285">prev</a><span>|</span><a href="#36593943">next</a><span>|</span><label class="collapse" for="c-36595300">[-]</label><label class="expand" for="c-36595300">[1 more]</label></div><br/><div class="children"><div class="content">They mention lifecycle at the top: logout now, log out specific devices (I forgot to logout of Netflix after I left the AirBnB), log out unknown&#x2F;old devices. I don&#x27;t know Biscuit, but this is just normal security design.<p>Besides normal lifecycle, compromises can happen any number of ways. You won&#x27;t know them all ahead of time, but having something like revocation designed into your system means you have one more mitigation option when something goes wrong.<p>Examples: all user-side compromises would be covered by &quot;lifecycle&quot; (give them a way to logout if they accidentally pasted a cookie somewhere, logged in to a public computer, etc). On the application side: discovered a security flaw (CVSS bug in a library or you designed a flaw), discovered suspicious activity in your network, suspect some browser or other exploit is allowing tokens to be stolen. After deploying fixes, you might want to revoke some set of token immediately instead of waiting for them to expire out.<p>Having revocation as an option might mean that you can make default expirations longer. Maybe we&#x27;re ok with letting users be logged in for one week instead of 24 hours if we have the option to revoke. Otherwise if a token is compromised, an attacker has a whole week to play with the token.</div><br/></div></div></div></div><div id="36593943" class="c"><input type="checkbox" id="c-36593943" checked=""/><div class="controls bullet"><span class="by">LanceH</span><span>|</span><a href="#36594066">prev</a><span>|</span><a href="#36593941">next</a><span>|</span><label class="collapse" for="c-36593943">[-]</label><label class="expand" for="c-36593943">[5 more]</label></div><br/><div class="children"><div class="content">Instead of assuming tokens are good and looking up blacklisted tokens, how about look up whitelisted tokens?</div><br/><div id="36595178" class="c"><input type="checkbox" id="c-36595178" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#36593943">parent</a><span>|</span><a href="#36595146">next</a><span>|</span><label class="collapse" for="c-36595178">[-]</label><label class="expand" for="c-36595178">[2 more]</label></div><br/><div class="children"><div class="content">Snarky peer comment, but <i>if</i> you can do this, then yeah, it sidesteps all of the complexity of a distributed authorization system. The trade off is the single point of failure: when your token verifier goes down, so does the entire system.</div><br/><div id="36595314" class="c"><input type="checkbox" id="c-36595314" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36593943">root</a><span>|</span><a href="#36595178">parent</a><span>|</span><a href="#36595146">next</a><span>|</span><label class="collapse" for="c-36595314">[-]</label><label class="expand" for="c-36595314">[1 more]</label></div><br/><div class="children"><div class="content">A blacklist checker is also a single point of failure.</div><br/></div></div></div></div><div id="36595146" class="c"><input type="checkbox" id="c-36595146" checked=""/><div class="controls bullet"><span class="by">quesera</span><span>|</span><a href="#36593943">parent</a><span>|</span><a href="#36595178">prev</a><span>|</span><a href="#36593941">next</a><span>|</span><label class="collapse" for="c-36595146">[-]</label><label class="expand" for="c-36595146">[2 more]</label></div><br/><div class="children"><div class="content">Defeats the purpose of a token. You&#x27;ve just reinvented the session cookie.</div><br/><div id="36595658" class="c"><input type="checkbox" id="c-36595658" checked=""/><div class="controls bullet"><span class="by">creamyhorror</span><span>|</span><a href="#36593943">root</a><span>|</span><a href="#36595146">parent</a><span>|</span><a href="#36593941">next</a><span>|</span><label class="collapse" for="c-36595658">[-]</label><label class="expand" for="c-36595658">[1 more]</label></div><br/><div class="children"><div class="content">What do we call a token that&#x27;s stored in a cookie, sent via the HTTP &#x27;Authorization&#x27; header to the API with each request, and Redis-cached on the server for say 5 minutes after looking it up in the users&#x2F;token service? I still call it a token, just not a JWT. Maybe I should change my terminology?</div><br/></div></div></div></div></div></div><div id="36593941" class="c"><input type="checkbox" id="c-36593941" checked=""/><div class="controls bullet"><span class="by">grandpoobah</span><span>|</span><a href="#36593943">prev</a><span>|</span><a href="#36593262">next</a><span>|</span><label class="collapse" for="c-36593941">[-]</label><label class="expand" for="c-36593941">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t reference tokens solve this problem?</div><br/></div></div><div id="36593262" class="c"><input type="checkbox" id="c-36593262" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#36593941">prev</a><span>|</span><label class="collapse" for="c-36593262">[-]</label><label class="expand" for="c-36593262">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still skeptical whether expiration times wouldn&#x27;t be adequate for many applications, assuming these times are short enough, like five minutes?</div><br/><div id="36593321" class="c"><input type="checkbox" id="c-36593321" checked=""/><div class="controls bullet"><span class="by">ravenstine</span><span>|</span><a href="#36593262">parent</a><span>|</span><a href="#36593309">next</a><span>|</span><label class="collapse" for="c-36593321">[-]</label><label class="expand" for="c-36593321">[3 more]</label></div><br/><div class="children"><div class="content">A malicious actor can do quite a lot in 5 minutes.  And now you&#x27;ve got to have your users&#x2F;services renew their authentication at least every 5 minutes, meaning there has to be some central authentication authority to be renewing through... which completely defeats the whole decentralization thing and is more complicated than just issuing randomized tokens and keeping hashes of those in Redis.<p>At best, you&#x27;ve got a system where a malicious actor doesn&#x27;t think to renew their token fast enough.</div><br/><div id="36597203" class="c"><input type="checkbox" id="c-36597203" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#36593262">root</a><span>|</span><a href="#36593321">parent</a><span>|</span><a href="#36593430">next</a><span>|</span><label class="collapse" for="c-36597203">[-]</label><label class="expand" for="c-36597203">[1 more]</label></div><br/><div class="children"><div class="content">You can make a lot of decentralized requests with an access token, before needing one centralized request with a refresh token.</div><br/></div></div></div></div><div id="36593309" class="c"><input type="checkbox" id="c-36593309" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#36593262">parent</a><span>|</span><a href="#36593321">prev</a><span>|</span><a href="#36593747">next</a><span>|</span><label class="collapse" for="c-36593309">[-]</label><label class="expand" for="c-36593309">[3 more]</label></div><br/><div class="children"><div class="content">This approach doesn&#x27;t really solve anything. If you have expiration times that short you will need a mechanism for renewing tokens and a compromised token can be renewed all the same. All you have is slightly higher server load because your regular users need to renew their tokens all the time.</div><br/><div id="36593360" class="c"><input type="checkbox" id="c-36593360" checked=""/><div class="controls bullet"><span class="by">sisve</span><span>|</span><a href="#36593262">root</a><span>|</span><a href="#36593309">parent</a><span>|</span><a href="#36593747">next</a><span>|</span><label class="collapse" for="c-36593360">[-]</label><label class="expand" for="c-36593360">[2 more]</label></div><br/><div class="children"><div class="content">If your access token is compromised, you would normally need your refresh token to get a new access token? So it would increase security, but if you lose your refresh token, you def have the same problem.<p>Or am I missing some context?</div><br/><div id="36593804" class="c"><input type="checkbox" id="c-36593804" checked=""/><div class="controls bullet"><span class="by">WirelessGigabit</span><span>|</span><a href="#36593262">root</a><span>|</span><a href="#36593360">parent</a><span>|</span><a href="#36593747">next</a><span>|</span><label class="collapse" for="c-36593804">[-]</label><label class="expand" for="c-36593804">[1 more]</label></div><br/><div class="children"><div class="content">Depends. Some systems allow for access tokens to be extended, some don&#x27;t.<p>We only use refresh tokens for mobile devices as those can be security stored.<p>Access token renewal is allowed for browsers for as long as we detect a valid session.<p>And that session cannot be extended. Every 8 hours it&#x27;s back to the authentication page with your YubiKey.</div><br/></div></div></div></div></div></div><div id="36593747" class="c"><input type="checkbox" id="c-36593747" checked=""/><div class="controls bullet"><span class="by">WirelessGigabit</span><span>|</span><a href="#36593262">parent</a><span>|</span><a href="#36593309">prev</a><span>|</span><label class="collapse" for="c-36593747">[-]</label><label class="expand" for="c-36593747">[2 more]</label></div><br/><div class="children"><div class="content">Same idea with certificates right? No-one checks certificate revocation lists, so Google is shortening maximum lifetimes reducing chance of long-time malicious use.</div><br/><div id="36594072" class="c"><input type="checkbox" id="c-36594072" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#36593262">root</a><span>|</span><a href="#36593747">parent</a><span>|</span><label class="collapse" for="c-36594072">[-]</label><label class="expand" for="c-36594072">[1 more]</label></div><br/><div class="children"><div class="content">Right. SSL certification revocation lists have been called &quot;broken in practice&quot;. In perfect practice, any time you want to use a cert you have to check the CRL, which means you have to pull the whole CRL or have it on a short enough refresh to satisfy your risk profile. If the attempt to access the CRL fails, then what? Do you trust the cert or not?
 <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Certificate_revocation_list#Problems_with_certificate_revocation_lists" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Certificate_revocation_list#Pr...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>