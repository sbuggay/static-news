<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726822877095" as="style"/><link rel="stylesheet" href="styles.css?v=1726822877095"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://neilmadden.blog/2024/09/18/digital-signatures-and-how-to-avoid-them/">Digital signatures and how to avoid them</a> <span class="domain">(<a href="https://neilmadden.blog">neilmadden.blog</a>)</span></div><div class="subtext"><span>_ikke_</span> | <span>26 comments</span></div><br/><div><div id="41597709" class="c"><input type="checkbox" id="c-41597709" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41595852">next</a><span>|</span><label class="collapse" for="c-41597709">[-]</label><label class="expand" for="c-41597709">[16 more]</label></div><br/><div class="children"><div class="content">The author mentions HMAC at the end. I think HMAC is really an underrated technique. I remember reading Colin Percival&#x27;s classic <i>Cryptographic Right Answers</i>[0] and saw a section about &quot;symmetric signatures.&quot; I pondered to myself what scheme I could use for that before I looked at the answer: of course it&#x27;s just HMAC. I feel like this is another perspective that ought to be more widely known: if you want something to be like a signature, but the two parties (or just a single party at different times) can share a key, HMAC really is the right answer. Things like, a server needs to cryptographically sign a cookie to prevent tempering: that&#x27;s HMAC. Or a server needs to know an API request is coming from an expected client: that&#x27;s also HMAC.<p>[0]: <a href="https:&#x2F;&#x2F;www.daemonology.net&#x2F;blog&#x2F;2009-06-11-cryptographic-right-answers.html" rel="nofollow">https:&#x2F;&#x2F;www.daemonology.net&#x2F;blog&#x2F;2009-06-11-cryptographic-ri...</a></div><br/><div id="41598251" class="c"><input type="checkbox" id="c-41598251" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41597709">parent</a><span>|</span><a href="#41599606">next</a><span>|</span><label class="collapse" for="c-41598251">[-]</label><label class="expand" for="c-41598251">[5 more]</label></div><br/><div class="children"><div class="content">More generally, a MAC.  You don&#x27;t necessarily need one based on a hash.<p>(Unrelated) see also the more recent <a href="https:&#x2F;&#x2F;www.latacora.com&#x2F;blog&#x2F;2018&#x2F;04&#x2F;03&#x2F;cryptographic-right-answers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.latacora.com&#x2F;blog&#x2F;2018&#x2F;04&#x2F;03&#x2F;cryptographic-right...</a></div><br/><div id="41598953" class="c"><input type="checkbox" id="c-41598953" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41598251">parent</a><span>|</span><a href="#41598483">next</a><span>|</span><label class="collapse" for="c-41598953">[-]</label><label class="expand" for="c-41598953">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d also throw in that HMAC is <i>overrated</i>. It&#x27;s a  workaround for bad hash algorithms that are vulnerable to length-extension attacks.<p>If you&#x27;re using a &quot;good&quot; hash algorithm, then MAC-ing is simple: hash over your key and message.<p>It&#x27;s pretty weird that SHA-256 has been king for so long, when SHA-512&#x2F;256 (which, as I&#x27;ve noticed people don&#x27;t understand, means SHA-512 truncated to 256 bits) was there from the beginning and is immune from this attack.<p>Anyway, in general it&#x27;s a pet peeve of mine that many people so often say &quot;HMAC&quot; when really they just mean MAC.</div><br/><div id="41599795" class="c"><input type="checkbox" id="c-41599795" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41598953">parent</a><span>|</span><a href="#41598483">next</a><span>|</span><label class="collapse" for="c-41599795">[-]</label><label class="expand" for="c-41599795">[1 more]</label></div><br/><div class="children"><div class="content">Yes and no. HMAC is very inefficient for short messages, but that inefficiency quickly vanishes into noise for anything over a kB or two. (HKDF and HMAC-DRBG are probably the worst offenders as they are always running HMAC on small inputs).<p>But, on the other hand, HMAC has repeatedly proven itself to be resilient to all kinds of attacks. I definitely didn’t mean any MAC when I recommended HMAC: eg I don’t think Poly1305 is a good general purpose MAC. PRF maybe, but sometimes you need the MAC to be committing too. Yes, some hash functions can be used with a simple prefix MAC, but then you need to list which specific hash functions to use (and most of those are not yet widely available).</div><br/></div></div></div></div><div id="41598483" class="c"><input type="checkbox" id="c-41598483" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41598251">parent</a><span>|</span><a href="#41598953">prev</a><span>|</span><a href="#41599606">next</a><span>|</span><label class="collapse" for="c-41598483">[-]</label><label class="expand" for="c-41598483">[2 more]</label></div><br/><div class="children"><div class="content">Ah yes of course in 2018 it&#x27;s still HMAC.</div><br/><div id="41598588" class="c"><input type="checkbox" id="c-41598588" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41598483">parent</a><span>|</span><a href="#41599606">next</a><span>|</span><label class="collapse" for="c-41598588">[-]</label><label class="expand" for="c-41598588">[1 more]</label></div><br/><div class="children"><div class="content">They published a followup to that article two months ago, and the correct answer in 2024 is still HMAC.<p><a href="https:&#x2F;&#x2F;www.latacora.com&#x2F;blog&#x2F;2024&#x2F;07&#x2F;29&#x2F;crypto-right-answers-pq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.latacora.com&#x2F;blog&#x2F;2024&#x2F;07&#x2F;29&#x2F;crypto-right-answer...</a></div><br/></div></div></div></div></div></div><div id="41599606" class="c"><input type="checkbox" id="c-41599606" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#41597709">parent</a><span>|</span><a href="#41598251">prev</a><span>|</span><a href="#41598230">next</a><span>|</span><label class="collapse" for="c-41599606">[-]</label><label class="expand" for="c-41599606">[2 more]</label></div><br/><div class="children"><div class="content">One question I always wondered about with cookie signing is: Why not store the user and the cookie in a database and check against that when they try to present it to you? Performance reasons?</div><br/><div id="41599862" class="c"><input type="checkbox" id="c-41599862" checked=""/><div class="controls bullet"><span class="by">argulane</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41599606">parent</a><span>|</span><a href="#41598230">next</a><span>|</span><label class="collapse" for="c-41599862">[-]</label><label class="expand" for="c-41599862">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s mostly about performance. If you can store all the required info about the user inside the cookie then you can avoid a DB query roundtrip before sending a response.<p>Now that your cookie looks like this (probably also base64 encoded):<p><pre><code>  {&quot;id&quot;: 42, &quot;display_name&quot;: &quot;John&quot;, &quot;is_admin&quot;: false, &quot;session_end_at&quot;:1726819411}
</code></pre>
You don&#x27;t have to hit the DB to display &quot;Hi John&quot; to the user and hide the jucy &quot;Admin&quot; panel. Without HMAC, an attacker could flip the &quot;is_admin&quot; boolean in the cookie.<p>You could also create a cookie that is just random bytes<p><pre><code>  F2x8V0hExbWNMhYMCUqtMrdpSNQb9dwiSiUBId6T3jg
</code></pre>
and then store it in a DB table with similar info but now you would have to query that table for each request. For small sites it doesn&#x27;t matter much and if it becomes a problem you can quite easily move that info into a faster key-value store like Redis. And when Redis also becomes too slow you are forced to move to JSON Web Tokens (JWT) witch is just a more standardized base64 encoded json wrapped with HMAC to avoid querying a database for each request.<p>But even if you are using random bytes as your session identifier, you should still wrap it in a HMAC so that you can drop invalid sessions early. Just for making it harder for someone to DDOS your DB.</div><br/></div></div></div></div><div id="41598230" class="c"><input type="checkbox" id="c-41598230" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41597709">parent</a><span>|</span><a href="#41599606">prev</a><span>|</span><a href="#41598218">next</a><span>|</span><label class="collapse" for="c-41598230">[-]</label><label class="expand" for="c-41598230">[2 more]</label></div><br/><div class="children"><div class="content">Are things like Diffie Hellman generally available such that you can always get a symmetric key? Or is that a special case?</div><br/><div id="41599902" class="c"><input type="checkbox" id="c-41599902" checked=""/><div class="controls bullet"><span class="by">vogr</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41598230">parent</a><span>|</span><a href="#41598218">next</a><span>|</span><label class="collapse" for="c-41599902">[-]</label><label class="expand" for="c-41599902">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m no cryptographer, but I would say that it is indeed the case that you can assume that two parties can derive a shared key over an untrusted channel. The post Cryptography Right Answers PQ [1], linked in another comment, addresses this in the section &quot;Key Exchange&quot;. Rather than thinking about Diffie-Hellman directly, you would turn to a Key Exchange Mechanism (KEM).<p>Before post-quantum cryptography concerns, KEM were indeed mostly built on top of Diffie-Hellman key agreement, but you could also build one on top of RSA, or on top of some lattice constructs. But you wouldn&#x27;t build one yourself, there are good constructions to choose from! The OP actually has a 3-part series on KEMs, although I don&#x27;t think it addresses post-quantum issues [2].<p>[1]: <a href="https:&#x2F;&#x2F;www.latacora.com&#x2F;blog&#x2F;2024&#x2F;07&#x2F;29&#x2F;crypto-right-answers-pq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.latacora.com&#x2F;blog&#x2F;2024&#x2F;07&#x2F;29&#x2F;crypto-right-answer...</a>
[2]: <a href="https:&#x2F;&#x2F;neilmadden.blog&#x2F;2021&#x2F;01&#x2F;22&#x2F;hybrid-encryption-and-the-kem-dem-paradigm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neilmadden.blog&#x2F;2021&#x2F;01&#x2F;22&#x2F;hybrid-encryption-and-the...</a></div><br/></div></div></div></div><div id="41598218" class="c"><input type="checkbox" id="c-41598218" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#41597709">parent</a><span>|</span><a href="#41598230">prev</a><span>|</span><a href="#41597917">next</a><span>|</span><label class="collapse" for="c-41598218">[-]</label><label class="expand" for="c-41598218">[4 more]</label></div><br/><div class="children"><div class="content">A bit of a tangent. This isn&#x27;t a dig on HMAC itself, but using HTTP request body or query string as the HMAC &quot;message&quot; is the worst. My employer provides some APIs with that sort of scheme and it&#x27;s a very common source of technical customer support tickets.<p>The problem is that many people are using web frameworks that automatically turn body and query into some kind of hash map data structure. So when you tell them &quot;use the request body as the HMAC message&quot;, they go &quot;OK, message = JSON.stringify(request.body)&quot;, and then it&#x27;s up to fate whether or not their runtime produces the same exact same JSON as yours. Adding a &quot;YOU MUST USE THE RAW REQUEST BODY&quot; to the docs doesn&#x27;t seem to work. We&#x27;ve even had customers outright refuse to do so after we ask them to do so in the &quot;why are my verifications failing&quot; ticket. And good luck if it&#x27;s a large&#x2F;enterprise customer. Get ready to have 2 different serialization routines: one for the general populous, and one for the very large customer that wrote their integration years ago and you only now found out that their runtime preserves &quot;&amp;&quot; inside JSON strings but yours escapes it.<p>Rant over...</div><br/><div id="41600016" class="c"><input type="checkbox" id="c-41600016" checked=""/><div class="controls bullet"><span class="by">growse</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41598218">parent</a><span>|</span><a href="#41599045">next</a><span>|</span><label class="collapse" for="c-41600016">[-]</label><label class="expand" for="c-41600016">[1 more]</label></div><br/><div class="children"><div class="content">I think AWS SigV4 tries (and succeeds?) in solving this issue?</div><br/></div></div><div id="41599045" class="c"><input type="checkbox" id="c-41599045" checked=""/><div class="controls bullet"><span class="by">Elucalidavah</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41598218">parent</a><span>|</span><a href="#41600016">prev</a><span>|</span><a href="#41597917">next</a><span>|</span><label class="collapse" for="c-41599045">[-]</label><label class="expand" for="c-41599045">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;&amp;&quot; inside JSON strings but yours escapes it<p>What escaping of &quot;&amp;&quot; inside JSON are you talking about? Some unholy mix of JSON and urlencode?</div><br/><div id="41599408" class="c"><input type="checkbox" id="c-41599408" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41599045">parent</a><span>|</span><a href="#41597917">next</a><span>|</span><label class="collapse" for="c-41599408">[-]</label><label class="expand" for="c-41599408">[1 more]</label></div><br/><div class="children"><div class="content">Ruby on Rails turns &quot;&amp;&quot; into &quot;\u0026&quot;.<p>See rails&#x2F;rails, activesupport&#x2F;lib&#x2F;active_support&#x2F;json&#x2F;encoding.rb.</div><br/></div></div></div></div></div></div><div id="41597917" class="c"><input type="checkbox" id="c-41597917" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41597709">parent</a><span>|</span><a href="#41598218">prev</a><span>|</span><a href="#41595852">next</a><span>|</span><label class="collapse" for="c-41597917">[-]</label><label class="expand" for="c-41597917">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, if you have a shared secret, HMAC is the way to go.<p>It&#x27;s also super simple: It&#x27;s almost literally just concatenating the secret and the message you want to authenticate together, and take an ordinary hash (like SHA256) of that, the rest of it is just to deal with padding.<p>It&#x27;s super intuitive how HMAC works: If you just mash secret and message together on your side, and get the same answer as what the other side told you, then you know that the other side had the secret key (and exactly this message), because there&#x27;s obviously no way to go from SHA256 to the input.<p>HMAC is also useful if you want to derive new secret keys from other secret keys. Take an HMAC with the secret key and an arbitrary string, you get a new secret key. The other side can do the same thing. Here&#x27;s the kicker, the arbitrary string does not have to be secret to anyone, it can be completely public!<p>Why would you do that? Well, maybe you want the derived key to have a different lifetime and scope. A &quot;less trusted&quot; component could be given this derived key to do its job without having to know the super-secret key it was derived from (which could be used to derive other keys for other components, or directly HMAC or decrypt other stuff).</div><br/><div id="41598272" class="c"><input type="checkbox" id="c-41598272" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41597709">root</a><span>|</span><a href="#41597917">parent</a><span>|</span><a href="#41595852">next</a><span>|</span><label class="collapse" for="c-41598272">[-]</label><label class="expand" for="c-41598272">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s also super simple: It&#x27;s almost literally just concatenating the secret and the message you want to authenticate together, and take an ordinary hash (like SHA256) of that, the rest of it is just to deal with padding.<p>It&#x27;s not quite as simple as that. The output of the first hash is hashed a second time (to prevent length extension attacks).</div><br/></div></div></div></div></div></div><div id="41595852" class="c"><input type="checkbox" id="c-41595852" checked=""/><div class="controls bullet"><span class="by">sandij</span><span>|</span><a href="#41597709">prev</a><span>|</span><a href="#41598003">next</a><span>|</span><label class="collapse" for="c-41595852">[-]</label><label class="expand" for="c-41595852">[8 more]</label></div><br/><div class="children"><div class="content">This article is very relevant in the context of the EU Digital Identity Wallet, and digital credentials in general, such as ISO&#x2F;IEC 18013-5 mobile driver licenses and other mdocs.<p>We may accidentially end up with non-repudiation of attribute presentation, thinking that this increases assurance for the parties involved in a transaction. The legal framework is not designed for this and insufficiently protects the credential subject for example.<p>Instead, the high assurance use cases should complement digital credentials (with plausible deniability of past presentations) with qualified e-signatures and e-seals. For these, the EU for example does provide a legal framework that protects both the relying party and the signer.</div><br/><div id="41597835" class="c"><input type="checkbox" id="c-41597835" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41595852">parent</a><span>|</span><a href="#41596359">next</a><span>|</span><label class="collapse" for="c-41597835">[-]</label><label class="expand" for="c-41597835">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t non-repudiation something we <i>want</i> for cases like this? If e.g. a car rental place checks your driving license before renting you a car, and then you get into a crash, no-one wants you to be able to claim that you never showed them your driving license and they never checked.</div><br/><div id="41599180" class="c"><input type="checkbox" id="c-41599180" checked=""/><div class="controls bullet"><span class="by">sandij</span><span>|</span><a href="#41595852">root</a><span>|</span><a href="#41597835">parent</a><span>|</span><a href="#41596359">next</a><span>|</span><label class="collapse" for="c-41599180">[-]</label><label class="expand" for="c-41599180">[1 more]</label></div><br/><div class="children"><div class="content">To prove that the car rental company has seen the driver licence, they just need to show the judge a copy of the licence which is e-sealed by its issuing authority. No need to include a non-repudiable proof-of-possession signature of the holder. Having that in addition would just introduce legal ambiguity and information asymmetry to the disadvantage of the holder.<p>The opponent may still claim that the car rental place is showing a copy that was obtained illegally, and not in holder presentation. To avoid such a claim, the car rental company should ask for a qualified e-signature before providing the car key. The signed data can include any relevant claims that both parties confirm as part of the transaction. To provide similar assurance to the customer, the company should counter-sign that document, or provide it pre-sealed if it is an automated process.<p>Note that with the EU Digital Identity, creating qualified e-signatures is just as easy as presenting digital credentials.</div><br/></div></div></div></div><div id="41596359" class="c"><input type="checkbox" id="c-41596359" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#41595852">parent</a><span>|</span><a href="#41597835">prev</a><span>|</span><a href="#41597506">next</a><span>|</span><label class="collapse" for="c-41596359">[-]</label><label class="expand" for="c-41596359">[4 more]</label></div><br/><div class="children"><div class="content">I mean it&#x27;s not a super big deal if the EU identity private key leaks in some arcane attack or if someone steals it the normal way, you can just cancel it and order a new one like a credit card. It expires every two years I think anyway.<p>This reminds me of a specific number that Americans have to give in plain text as proof of digital identity that they only get one of and can&#x27;t change it ever. Lol.</div><br/><div id="41596670" class="c"><input type="checkbox" id="c-41596670" checked=""/><div class="controls bullet"><span class="by">sunk1st</span><span>|</span><a href="#41595852">root</a><span>|</span><a href="#41596359">parent</a><span>|</span><a href="#41597888">next</a><span>|</span><label class="collapse" for="c-41596670">[-]</label><label class="expand" for="c-41596670">[1 more]</label></div><br/><div class="children"><div class="content">That doesn’t matter. The claim being made by the grandparent post is that the legal system isn’t well-equipped to deal with scenarios like, “yes the digital signature is valid but it was improperly authorized.”</div><br/></div></div><div id="41597888" class="c"><input type="checkbox" id="c-41597888" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41595852">root</a><span>|</span><a href="#41596359">parent</a><span>|</span><a href="#41596670">prev</a><span>|</span><a href="#41596429">next</a><span>|</span><label class="collapse" for="c-41597888">[-]</label><label class="expand" for="c-41597888">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This reminds me of a specific number that Americans have to give in plain text as proof of digital identity that they only get one of and can&#x27;t change it ever. Lol.<p>You can get up to ten replacements of your card in your lifetime. They do all have the same number though.<p>[1] <a href="https:&#x2F;&#x2F;secure.ssa.gov&#x2F;poms.nsf&#x2F;lnx&#x2F;0110205400" rel="nofollow">https:&#x2F;&#x2F;secure.ssa.gov&#x2F;poms.nsf&#x2F;lnx&#x2F;0110205400</a></div><br/></div></div><div id="41596429" class="c"><input type="checkbox" id="c-41596429" checked=""/><div class="controls bullet"><span class="by">the_sleaze_</span><span>|</span><a href="#41595852">root</a><span>|</span><a href="#41596359">parent</a><span>|</span><a href="#41597888">prev</a><span>|</span><a href="#41597506">next</a><span>|</span><label class="collapse" for="c-41596429">[-]</label><label class="expand" for="c-41596429">[1 more]</label></div><br/><div class="children"><div class="content">Well, at least you can laminate it</div><br/></div></div></div></div></div></div><div id="41598003" class="c"><input type="checkbox" id="c-41598003" checked=""/><div class="controls bullet"><span class="by">gyush</span><span>|</span><a href="#41595852">prev</a><span>|</span><label class="collapse" for="c-41598003">[-]</label><label class="expand" for="c-41598003">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  As well as authenticating a message, they also provide third-party verifiability and (part of) non-repudiation.<p>I think digital signatures and third party verification are an incredibly useful  feature. The ability to prove you received some data from some third party lets you prove things about yourself, and enables better data privacy long-term, especially when you have selective disclosure when combined with zero knowledge proofs. See: <a href="https:&#x2F;&#x2F;www.andrewclu.com&#x2F;sign-everything" rel="nofollow">https:&#x2F;&#x2F;www.andrewclu.com&#x2F;sign-everything</a> -- the ability to make all your data self-sovereign and selectively prove data to the outside world (i.e. prove I&#x27;m over 18 without showing my whole passport) can be extremely beneficial, especially as we move towards a world of AI generated content where provenant proofs can prove content origin to third parties. You&#x27;re right that post quantum signature research is still in progress, but I suspect that until post-quantum supremacy, it&#x27;s still useful (and by then I hope we&#x27;ll have fast and small post quantum signature schemes).<p>EU&#x27;s digital signatures let you do this for your IDs and <a href="https:&#x2F;&#x2F;www.openpassport.app&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.openpassport.app&#x2F;</a> lets you do this for any country passport, but imagine you could do this for all your social media data, personal info, and login details. we could have full selective privacy online, but only if everyone uses digital signatures instead of HMACs.</div><br/></div></div></div></div></div></div></div></body></html>