<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693299664915" as="style"/><link rel="stylesheet" href="styles.css?v=1693299664915"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://applied-langua.ge/~hayley/swcl-gc.pdf">Parallel garbage collection for SBCL [pdf]</a> <span class="domain">(<a href="https://applied-langua.ge">applied-langua.ge</a>)</span></div><div class="subtext"><span>slyrus</span> | <span>32 comments</span></div><br/><div><div id="37300684" class="c"><input type="checkbox" id="c-37300684" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37296272">next</a><span>|</span><label class="collapse" for="c-37300684">[-]</label><label class="expand" for="c-37300684">[7 more]</label></div><br/><div class="children"><div class="content">Recent and related (but we merged the comments hither):<p><i>Steel Bank Common Lisp 2.3.8 released: “a mark-region parallel GC is available”</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37295611">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37295611</a></div><br/><div id="37302483" class="c"><input type="checkbox" id="c-37302483" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#37300684">parent</a><span>|</span><a href="#37296272">next</a><span>|</span><label class="collapse" for="c-37302483">[-]</label><label class="expand" for="c-37302483">[6 more]</label></div><br/><div class="children"><div class="content">Please note that the paper was published before I implemented incremental compaction; the GC in SBCL 2.3.8 can compact.</div><br/><div id="37303647" class="c"><input type="checkbox" id="c-37303647" checked=""/><div class="controls bullet"><span class="by">dmpk2k</span><span>|</span><a href="#37300684">root</a><span>|</span><a href="#37302483">parent</a><span>|</span><a href="#37303645">next</a><span>|</span><label class="collapse" for="c-37303647">[-]</label><label class="expand" for="c-37303647">[3 more]</label></div><br/><div class="children"><div class="content">Does this have much effect on Kandria’s latency results? Shirakumo tries to put a positive spin on things, but her results show that SBCL’s existing GC isn’t up to the task for real-time games (or many networked apps, for that matter).<p>As an aside, thanks for your efforts. Adding a new GC is a major effort, which improves things for all of us! :D</div><br/><div id="37303821" class="c"><input type="checkbox" id="c-37303821" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#37300684">root</a><span>|</span><a href="#37303647">parent</a><span>|</span><a href="#37303645">next</a><span>|</span><label class="collapse" for="c-37303821">[-]</label><label class="expand" for="c-37303821">[2 more]</label></div><br/><div class="children"><div class="content">I have yet to benchmark it again; my setup was sloppy as I had to run the same part of the game over and over, because record&#x2F;replay didn&#x27;t work. (Nor do I have the time and energy now; have to survive the last semester of university now.) But I suspect it should help, by reducing the sweeping and scavenging times which were pretty bad.<p>I&#x27;m not sure I agree with the comment about &quot;up to the task for real-time games&quot;, but maybe my standards are low for video games, and I have an abnormally fast machine and am likely biased there too.</div><br/><div id="37304126" class="c"><input type="checkbox" id="c-37304126" checked=""/><div class="controls bullet"><span class="by">dmpk2k</span><span>|</span><a href="#37300684">root</a><span>|</span><a href="#37303821">parent</a><span>|</span><a href="#37303645">next</a><span>|</span><label class="collapse" for="c-37304126">[-]</label><label class="expand" for="c-37304126">[1 more]</label></div><br/><div class="children"><div class="content">Rightly or wrongly, 60fps is becoming what 30fps used to be, and gamers can tell the difference (as can normal people with VR). It is what it is.<p>This latency problem is why I’m dabbling with raylib and LFE of all things. The BEAM cannot hold a candle to SBCL for performance code, but the GC latency can be managed better.<p>Anyway, I don’t want to go on a tangent, since I really appreciate your efforts; there are plenty of domains that the new SBCL GC will be a big deal for.</div><br/></div></div></div></div></div></div><div id="37303645" class="c"><input type="checkbox" id="c-37303645" checked=""/><div class="controls bullet"><span class="by">amno</span><span>|</span><a href="#37300684">root</a><span>|</span><a href="#37302483">parent</a><span>|</span><a href="#37303647">prev</a><span>|</span><a href="#37296272">next</a><span>|</span><label class="collapse" for="c-37303645">[-]</label><label class="expand" for="c-37303645">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for the paper, and for the work!<p>Can I ask a newbish question: will this new GC be available on all OS:s and CPU architectures, or only on some? I don&#x27;t see anything in the paper about being limiting to some certain platform, so my hopes are high :).</div><br/><div id="37303842" class="c"><input type="checkbox" id="c-37303842" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#37300684">root</a><span>|</span><a href="#37303645">parent</a><span>|</span><a href="#37296272">next</a><span>|</span><label class="collapse" for="c-37303842">[-]</label><label class="expand" for="c-37303842">[1 more]</label></div><br/><div class="children"><div class="content">It should be pretty portable, porting is just a matter of time and interest. The main thing is that the compiler needs to use a (more precise, lower overhead) software write barrier rather than using the (coarser, slower) hardware write barrier which was around the longest. I also have to wonder how well the bit-scanning algorithms fare on big-endian, or is that taking &quot;all CPU architectures&quot; too far?</div><br/></div></div></div></div></div></div></div></div><div id="37296272" class="c"><input type="checkbox" id="c-37296272" checked=""/><div class="controls bullet"><span class="by">rayiner</span><span>|</span><a href="#37300684">prev</a><span>|</span><a href="#37301363">next</a><span>|</span><label class="collapse" for="c-37296272">[-]</label><label class="expand" for="c-37296272">[7 more]</label></div><br/><div class="children"><div class="content">Very cool! Here is the paper: <a href="https:&#x2F;&#x2F;zenodo.org&#x2F;record&#x2F;7816398" rel="nofollow noreferrer">https:&#x2F;&#x2F;zenodo.org&#x2F;record&#x2F;7816398</a>. It uses the well known Immix heap layout&#x2F;algorithm. <a href="https:&#x2F;&#x2F;users.cecs.anu.edu.au&#x2F;~steveb&#x2F;pubs&#x2F;papers&#x2F;immix-pldi-2008.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;users.cecs.anu.edu.au&#x2F;~steveb&#x2F;pubs&#x2F;papers&#x2F;immix-pldi...</a><p>The old gencgc was pretty cool for the single core era, and it sounds like it still holds up well. If I recall correctly, it was based on the Bartlett Mostly Copying paper, which is an elegant and practical GC design. <a href="https:&#x2F;&#x2F;www.hpl.hp.com&#x2F;techreports&#x2F;Compaq-DEC&#x2F;WRL-TN-12.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.hpl.hp.com&#x2F;techreports&#x2F;Compaq-DEC&#x2F;WRL-TN-12.pdf</a>. I miss these old papers that described this stuff in a way you didn’t have to be a math major to understand. I think the first version of that paper had the C++ code as an appendix: <a href="https:&#x2F;&#x2F;www.hpl.hp.com&#x2F;techreports&#x2F;Compaq-DEC&#x2F;WRL-88-2.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.hpl.hp.com&#x2F;techreports&#x2F;Compaq-DEC&#x2F;WRL-88-2.pdf</a>.<p>Clarity in your technical communications matters. The Immix papers are similarly well written and clear. I don’t think it’s a surprise that both GC designs have also been independently implemented over and over. The Chaitin-Briggs register allocator is another example where I’d attribute at least some of the success in widespread industrial implementation to Briggs’ excellent and approachable PhD thesis describing the algorithm: <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;mckinley&#x2F;380C&#x2F;lecs&#x2F;briggs-thesis-1992.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;mckinley&#x2F;380C&#x2F;lecs&#x2F;briggs-th...</a></div><br/><div id="37296724" class="c"><input type="checkbox" id="c-37296724" checked=""/><div class="controls bullet"><span class="by">sctb</span><span>|</span><a href="#37296272">parent</a><span>|</span><a href="#37303665">next</a><span>|</span><label class="collapse" for="c-37296724">[-]</label><label class="expand" for="c-37296724">[3 more]</label></div><br/><div class="children"><div class="content">For more Lisp+Immix action there&#x27;s also Andy Wingo&#x27;s article and talk about a new GC for Guile from earlier this year:<p>Article: <a href="https:&#x2F;&#x2F;wingolog.org&#x2F;archives&#x2F;2023&#x2F;02&#x2F;07&#x2F;whippet-towards-a-new-local-maximum" rel="nofollow noreferrer">https:&#x2F;&#x2F;wingolog.org&#x2F;archives&#x2F;2023&#x2F;02&#x2F;07&#x2F;whippet-towards-a-n...</a><p>Talk: <a href="https:&#x2F;&#x2F;fosdem.org&#x2F;2023&#x2F;schedule&#x2F;event&#x2F;whippet" rel="nofollow noreferrer">https:&#x2F;&#x2F;fosdem.org&#x2F;2023&#x2F;schedule&#x2F;event&#x2F;whippet</a></div><br/><div id="37297589" class="c"><input type="checkbox" id="c-37297589" checked=""/><div class="controls bullet"><span class="by">latenightcoding</span><span>|</span><a href="#37296272">root</a><span>|</span><a href="#37296724">parent</a><span>|</span><a href="#37303665">next</a><span>|</span><label class="collapse" for="c-37297589">[-]</label><label class="expand" for="c-37297589">[2 more]</label></div><br/><div class="children"><div class="content">Good to know, it never sat right with me that Guile depended on BDW-GC for so long. That&#x27;s what you use when you are implementing a toy language and don&#x27;t have time to write your own GC.</div><br/><div id="37299590" class="c"><input type="checkbox" id="c-37299590" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#37296272">root</a><span>|</span><a href="#37297589">parent</a><span>|</span><a href="#37303665">next</a><span>|</span><label class="collapse" for="c-37299590">[-]</label><label class="expand" for="c-37299590">[1 more]</label></div><br/><div class="children"><div class="content">It was never the biggest hurdle for guile performance. I do believe guix has the potential to hit the GC wall, but for most programs I think it has served guile well.<p>With that said, the upcoming immix collector is really friggin exciting.</div><br/></div></div></div></div></div></div><div id="37303665" class="c"><input type="checkbox" id="c-37303665" checked=""/><div class="controls bullet"><span class="by">amno</span><span>|</span><a href="#37296272">parent</a><span>|</span><a href="#37296724">prev</a><span>|</span><a href="#37299225">next</a><span>|</span><label class="collapse" for="c-37303665">[-]</label><label class="expand" for="c-37303665">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Clarity in your technical communications matters.<p>Indeed; it does.<p>I wish more people watched that Steels talk, where he speaks about importance to use accessible language. One-syllabus words all the way would be perhaps a bit tedious read, but he makes a very good point about clarity in connection to simplicity.<p>Thanks for all the links Raiyner.</div><br/></div></div><div id="37299225" class="c"><input type="checkbox" id="c-37299225" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#37296272">parent</a><span>|</span><a href="#37303665">prev</a><span>|</span><a href="#37300696">next</a><span>|</span><label class="collapse" for="c-37299225">[-]</label><label class="expand" for="c-37299225">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m getting &quot;connection reset by peer&quot; for the Immix link. Wayback link instead: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230313182036&#x2F;https:&#x2F;&#x2F;users.cecs.anu.edu.au&#x2F;~steveb&#x2F;pubs&#x2F;papers&#x2F;immix-pldi-2008.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230313182036&#x2F;https:&#x2F;&#x2F;users.cec...</a></div><br/></div></div><div id="37300696" class="c"><input type="checkbox" id="c-37300696" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37296272">parent</a><span>|</span><a href="#37299225">prev</a><span>|</span><a href="#37301363">next</a><span>|</span><label class="collapse" for="c-37300696">[-]</label><label class="expand" for="c-37300696">[1 more]</label></div><br/><div class="children"><div class="content">(As the paper was posted in a more accessible form a few hours ago (thanks slyrus!), I reupped that submission and merged the comments from <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37295611">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37295611</a> hither.)</div><br/></div></div></div></div><div id="37301363" class="c"><input type="checkbox" id="c-37301363" checked=""/><div class="controls bullet"><span class="by">vindarel</span><span>|</span><a href="#37296272">prev</a><span>|</span><a href="#37296498">next</a><span>|</span><label class="collapse" for="c-37301363">[-]</label><label class="expand" for="c-37301363">[6 more]</label></div><br/><div class="children"><div class="content">Other great achievements from last year [0]:<p>- SBCL is  callable as a shared library (see sbcl-librarian)<p>- sb-simd<p>- prebuilt binaries for Android (termux, unofficial)<p>- better image compression using zstd<p>- I&#x27;ll add <a href="https:&#x2F;&#x2F;github.com&#x2F;sionescu&#x2F;sbcl-goodies">https:&#x2F;&#x2F;github.com&#x2F;sionescu&#x2F;sbcl-goodies</a>, binaries with &quot;goodies&quot; inside (OpenSSL, libfixposix)<p>yay!<p>[0]: <a href="https:&#x2F;&#x2F;lisp-journey.gitlab.io&#x2F;blog&#x2F;these-years-in-common-lisp-2022-in-review&#x2F;#implementations" rel="nofollow noreferrer">https:&#x2F;&#x2F;lisp-journey.gitlab.io&#x2F;blog&#x2F;these-years-in-common-li...</a><p>bonus from 2021: true static binaries are coming <a href="https:&#x2F;&#x2F;www.timmons.dev&#x2F;posts&#x2F;static-executables-with-sbcl-v2.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.timmons.dev&#x2F;posts&#x2F;static-executables-with-sbcl-v...</a></div><br/><div id="37302819" class="c"><input type="checkbox" id="c-37302819" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#37301363">parent</a><span>|</span><a href="#37302236">next</a><span>|</span><label class="collapse" for="c-37302819">[-]</label><label class="expand" for="c-37302819">[2 more]</label></div><br/><div class="children"><div class="content">I cannot emphasize how much of a game changer SB-SIMD has been for writing performant numeric code in SBCL. Being able to experiment with AVX intrinsics in a REPL has been quite the experience for me.</div><br/><div id="37303273" class="c"><input type="checkbox" id="c-37303273" checked=""/><div class="controls bullet"><span class="by">fud101</span><span>|</span><a href="#37301363">root</a><span>|</span><a href="#37302819">parent</a><span>|</span><a href="#37302236">next</a><span>|</span><label class="collapse" for="c-37303273">[-]</label><label class="expand" for="c-37303273">[1 more]</label></div><br/><div class="children"><div class="content">needs a tutorial</div><br/></div></div></div></div><div id="37302236" class="c"><input type="checkbox" id="c-37302236" checked=""/><div class="controls bullet"><span class="by">corinroyal</span><span>|</span><a href="#37301363">parent</a><span>|</span><a href="#37302819">prev</a><span>|</span><a href="#37302003">next</a><span>|</span><label class="collapse" for="c-37302236">[-]</label><label class="expand" for="c-37302236">[2 more]</label></div><br/><div class="children"><div class="content">OMG! I read the SBCL release notes every month, but when you put together recent highlights like this, I&#x27;m blown away. Android binaries? True static executables? Yes, please!<p>This is impressive progress, especially for a language so many have written off as moribund. And that&#x27;s just one implementation of the spec. ECL, ABCL, and Clasp are all progressing at a brisk pace too. Maybe the only good language is a dead language.</div><br/><div id="37304203" class="c"><input type="checkbox" id="c-37304203" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#37301363">root</a><span>|</span><a href="#37302236">parent</a><span>|</span><a href="#37302003">next</a><span>|</span><label class="collapse" for="c-37304203">[-]</label><label class="expand" for="c-37304203">[1 more]</label></div><br/><div class="children"><div class="content">&gt;True static executables<p>Correct me if I&#x27;m wrong but this has not happened yet.</div><br/></div></div></div></div></div></div><div id="37296498" class="c"><input type="checkbox" id="c-37296498" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#37301363">prev</a><span>|</span><a href="#37303933">next</a><span>|</span><label class="collapse" for="c-37296498">[-]</label><label class="expand" for="c-37296498">[8 more]</label></div><br/><div class="children"><div class="content">Nice, good to see activity in SBCL dev.<p>Does anyone know how difficult implementing a Real-Time GC would be for SBCL or ECL. I know of that paper by Rodney Brooks (L -- A Common Lisp for Embedded Systems)</div><br/><div id="37296968" class="c"><input type="checkbox" id="c-37296968" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#37296498">parent</a><span>|</span><a href="#37299050">next</a><span>|</span><label class="collapse" for="c-37296968">[-]</label><label class="expand" for="c-37296968">[5 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll need to be more specific.<p>From a technical (i.e. useless) point of view SBCL very nearly already has a real-time GC, with a few modifications it would qualify since already:<p>1. The amount of work in a GC operation is bounded by the heap size<p>2. SBCL has a fixed maximum heap size<p>Two things would need to be done:<p>1. Ensure the areas where GC is inhibited are bounded<p>2. Call GC operations on a timer, and when they are done, ensure there is sufficient free space; RTGC cannot exist without specific bounds on the mutator, so you could almost certainly invent bounds on the mutator that would make the gencgc qualify as real-time for.<p>#1 would need to be done for any actually useful RTGC anyways.<p>A slightly less snarky answer is that a non-toy GC is a lot of work.  Different choices in GC will affect code-generation (e.g. read and&#x2F;or write barriers GC, and forwarding-pointers for incremental GC[1]).<p>There&#x27;s a reason the gencgc has been around as long as it has, and it&#x27;s because it&#x27;s &quot;good enough&quot; for a lot of people and the work needed to replace it (with any non stop-the-world GC anyways) is rather large.  Even TFA is neither incremental nor concurrent, just parallel.<p>1: Stop the World GCs may also use forwarding pointers, but codegen doesn&#x27;t need to know about them because they are fully resolved before the mutator continues.</div><br/><div id="37301308" class="c"><input type="checkbox" id="c-37301308" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#37296498">root</a><span>|</span><a href="#37296968">parent</a><span>|</span><a href="#37297334">next</a><span>|</span><label class="collapse" for="c-37301308">[-]</label><label class="expand" for="c-37301308">[3 more]</label></div><br/><div class="children"><div class="content">&gt; From a technical (i.e. useless) point of view SBCL very nearly already has a real-time GC<p>If your technical (theoretical) definitions are useless, you need to use different definitions. A practical definition of “real-time” GC is a minimum mutator utilization bound for any program given sufficent RAM, but the only GC I’m aware of that does this (despite the abundance of papers on GC wirh “real-time” in the title) is Klock’s regional collector[1]. Unfortunately, it seems to be impractically complex. [To be fair, I don’t think any implementation of malloc() in common use would satisfy this constraint either.]<p>[1] <a href="https:&#x2F;&#x2F;eschew.wordpress.com&#x2F;2016&#x2F;09&#x2F;02&#x2F;summarizing-gc&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;eschew.wordpress.com&#x2F;2016&#x2F;09&#x2F;02&#x2F;summarizing-gc&#x2F;</a></div><br/><div id="37303143" class="c"><input type="checkbox" id="c-37303143" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#37296498">root</a><span>|</span><a href="#37301308">parent</a><span>|</span><a href="#37302565">next</a><span>|</span><label class="collapse" for="c-37303143">[-]</label><label class="expand" for="c-37303143">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If your technical (theoretical) definitions are useless, you need to use different definitions...<p>The question of &quot;what is a real-time GC&quot; is academic because nobody actually wants a real-time GC.  They want a real-time system.  And some GC algorithms can be used to construct a real-time system.  Indeed, as others have noted, SBCL can be used to construct a real-time system if you don&#x27;t do any allocations.</div><br/></div></div><div id="37302565" class="c"><input type="checkbox" id="c-37302565" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#37296498">root</a><span>|</span><a href="#37301308">parent</a><span>|</span><a href="#37303143">prev</a><span>|</span><a href="#37297334">next</a><span>|</span><label class="collapse" for="c-37302565">[-]</label><label class="expand" for="c-37302565">[1 more]</label></div><br/><div class="children"><div class="content">The customary way to improve GC performance in Common Lisp is to avoid consing. Which, incidentally, is the customary way to write high performance C code too. Allocate your memory in a piece up front and arrange the data in a way that&#x27;s friendly to your architecture and then do stuff. Nice thing about Common Lisp is that DISASSEMBLE makes it a fairly smooth process to check that the optimizer is actually doing what you want.<p>And the new SBCL release aids this approach by expanding the cases where the compiler will stack allocate.</div><br/></div></div></div></div><div id="37297334" class="c"><input type="checkbox" id="c-37297334" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#37296498">root</a><span>|</span><a href="#37296968">parent</a><span>|</span><a href="#37301308">prev</a><span>|</span><a href="#37299050">next</a><span>|</span><label class="collapse" for="c-37297334">[-]</label><label class="expand" for="c-37297334">[1 more]</label></div><br/><div class="children"><div class="content">thanks</div><br/></div></div></div></div><div id="37299050" class="c"><input type="checkbox" id="c-37299050" checked=""/><div class="controls bullet"><span class="by">mannycalavera42</span><span>|</span><a href="#37296498">parent</a><span>|</span><a href="#37296968">prev</a><span>|</span><a href="#37303933">next</a><span>|</span><label class="collapse" for="c-37299050">[-]</label><label class="expand" for="c-37299050">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Nice, good to see activity in SBCL dev.<p>I mean, they release on a monthly basis... pretty much active I would argue?
<a href="https:&#x2F;&#x2F;www.sbcl.org&#x2F;all-news.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sbcl.org&#x2F;all-news.html</a></div><br/><div id="37300089" class="c"><input type="checkbox" id="c-37300089" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#37296498">root</a><span>|</span><a href="#37299050">parent</a><span>|</span><a href="#37303933">next</a><span>|</span><label class="collapse" for="c-37300089">[-]</label><label class="expand" for="c-37300089">[1 more]</label></div><br/><div class="children"><div class="content">Maybe he meant he&#x27;s happy to see regular activity.</div><br/></div></div></div></div></div></div><div id="37303933" class="c"><input type="checkbox" id="c-37303933" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#37296498">prev</a><span>|</span><a href="#37303669">next</a><span>|</span><label class="collapse" for="c-37303933">[-]</label><label class="expand" for="c-37303933">[2 more]</label></div><br/><div class="children"><div class="content">What would having a parallel GC mean in the practical sense?<p>That there is no pauses happening during the runtime?</div><br/><div id="37304213" class="c"><input type="checkbox" id="c-37304213" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#37303933">parent</a><span>|</span><a href="#37303669">next</a><span>|</span><label class="collapse" for="c-37304213">[-]</label><label class="expand" for="c-37304213">[1 more]</label></div><br/><div class="children"><div class="content">There are still pauses, but the pauses are faster by using multiple cores to collect, which is nice for both throughput- and latency-sensitive apps. No-pause (&quot;on-the-fly&quot;) collectors exist, but sufficiently-short pause (&quot;concurrent&quot;) collectors still do wonders with sub-millisecond latency.</div><br/></div></div></div></div></div></div></div></div></div></body></html>