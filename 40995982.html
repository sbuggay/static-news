<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721379649402" as="style"/><link rel="stylesheet" href="styles.css?v=1721379649402"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://research.swtch.com/bisect">Hash-based bisect debugging in compilers and runtimes</a>Â <span class="domain">(<a href="https://research.swtch.com">research.swtch.com</a>)</span></div><div class="subtext"><span>rsc</span> | <span>24 comments</span></div><br/><div><div id="41000188" class="c"><input type="checkbox" id="c-41000188" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#40998682">next</a><span>|</span><label class="collapse" for="c-41000188">[-]</label><label class="expand" for="c-41000188">[6 more]</label></div><br/><div class="children"><div class="content">Aside: bisecting flakes doesn&#x27;t <i>have</i> to involve repeated runs. You can reformulate bisection as an information probing operation, expanding the scope to support noisy benchmarks or low-probability flakes. Bayesian inference narrows down the probable range of the failure for each new observation, and you can choose new probes to maximize information gain-- or even run them in parallel to minimize the total time.<p>You <i>do</i> have to provide flake rate probability to do the probability estimates, but even roughly correct rates work fine. Running bisects assuming a 5% chance of getting a false positive or negative barely adds more steps and greatly improves robustness.<p>The math is pretty simple too-- my old prototype might still be in Google&#x27;s monorepo; I should reimplement it for the open source world.</div><br/><div id="41000360" class="c"><input type="checkbox" id="c-41000360" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#41000188">parent</a><span>|</span><a href="#41001498">next</a><span>|</span><label class="collapse" for="c-41000360">[-]</label><label class="expand" for="c-41000360">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Something like this is what I intend to do when I get some time.</div><br/></div></div><div id="41001498" class="c"><input type="checkbox" id="c-41001498" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41000188">parent</a><span>|</span><a href="#41000360">prev</a><span>|</span><a href="#40998682">next</a><span>|</span><label class="collapse" for="c-41001498">[-]</label><label class="expand" for="c-41001498">[4 more]</label></div><br/><div class="children"><div class="content">Could you briefly sketch out the math (or point to a sketch) so that other people can pick it up?  I&#x27;m quite interested!<p>(I suspect you could get pretty far with a Monte Carlo simulation, and that would let you bypass most of the math anyway.)</div><br/><div id="41001534" class="c"><input type="checkbox" id="c-41001534" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#41000188">root</a><span>|</span><a href="#41001498">parent</a><span>|</span><a href="#41002093">next</a><span>|</span><label class="collapse" for="c-41001534">[-]</label><label class="expand" for="c-41001534">[1 more]</label></div><br/><div class="children"><div class="content">Here is a doc explaining a Bayesian search algorithm; not sure if it&#x27;s precisely what GP has in mind.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Ealdwulf&#x2F;BBChop&#x2F;blob&#x2F;master&#x2F;BBChop&#x2F;doc&#x2F;BayesianSearch_Debugging.pdf">https:&#x2F;&#x2F;github.com&#x2F;Ealdwulf&#x2F;BBChop&#x2F;blob&#x2F;master&#x2F;BBChop&#x2F;doc&#x2F;Ba...</a><p>(Edit- had wrong link originally)</div><br/></div></div><div id="41002093" class="c"><input type="checkbox" id="c-41002093" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41000188">root</a><span>|</span><a href="#41001498">parent</a><span>|</span><a href="#41001534">prev</a><span>|</span><a href="#40998682">next</a><span>|</span><label class="collapse" for="c-41002093">[-]</label><label class="expand" for="c-41002093">[2 more]</label></div><br/><div class="children"><div class="content">For Bayesian Inference, the example in the Wikipedia article is good (who doesn&#x27;t like cookies?): <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Bayesian_inference#Examples" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Bayesian_inference#Examples</a><p>When gathering more evidence, you&#x27;d use your new belief about which cookie bowl Fred has as P(H1)=0.6 and P(H2)=0.4</div><br/><div id="41002737" class="c"><input type="checkbox" id="c-41002737" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41000188">root</a><span>|</span><a href="#41002093">parent</a><span>|</span><a href="#40998682">next</a><span>|</span><label class="collapse" for="c-41002737">[-]</label><label class="expand" for="c-41002737">[1 more]</label></div><br/><div class="children"><div class="content">That just explains Bayesian inference in general, which is useful, but not what I&#x27;m after.<p>I was specifically interested in the application to binary search &#x2F; bisection in the presence of flaky tests.</div><br/></div></div></div></div></div></div></div></div><div id="40998682" class="c"><input type="checkbox" id="c-40998682" checked=""/><div class="controls bullet"><span class="by">tabbott</span><span>|</span><a href="#41000188">prev</a><span>|</span><a href="#40999220">next</a><span>|</span><label class="collapse" for="c-40998682">[-]</label><label class="expand" for="c-40998682">[1 more]</label></div><br/><div class="children"><div class="content">This is so cool!<p>It reminds me a bit of one my favorite debugging techniques: Running an individual test with coverage reporting enabled, and then clicking around the HTML coverage report to see exactly what code path the test followed, without needing to use either print statements or a specialized debugger.<p>Very helpful for answering questions of the form &quot;Why does this test not exercise the code I thought it did?&quot;.</div><br/></div></div><div id="40999220" class="c"><input type="checkbox" id="c-40999220" checked=""/><div class="controls bullet"><span class="by">carry_bit</span><span>|</span><a href="#40998682">prev</a><span>|</span><a href="#40996682">next</a><span>|</span><label class="collapse" for="c-40999220">[-]</label><label class="expand" for="c-40999220">[2 more]</label></div><br/><div class="children"><div class="content">A closely related technique for debugging optimization passes is that of &quot;optimization fuel&quot;. Each rewrite decreases the fuel by one, and when the fuel is gone no more rewrites happen. You can then perform binary search on the optimization fuel to find a specific rewrite instance that breaks things.</div><br/><div id="41000374" class="c"><input type="checkbox" id="c-41000374" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#40999220">parent</a><span>|</span><a href="#40996682">next</a><span>|</span><label class="collapse" for="c-41000374">[-]</label><label class="expand" for="c-41000374">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I believe LLVM has a flag for &quot;run only the first N optimization passes&quot; that gets used with binary search this way.<p>A global optimization fuel that worked at finer granularity would be even more precise but you&#x27;d have to have the compiler run single-threaded to make sure the numbering always matches. At least in the Go compiler, we compile different functions in different threads, so that fouls up any global numbering.</div><br/></div></div></div></div><div id="40996682" class="c"><input type="checkbox" id="c-40996682" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#40999220">prev</a><span>|</span><a href="#41001280">next</a><span>|</span><label class="collapse" for="c-40996682">[-]</label><label class="expand" for="c-40996682">[2 more]</label></div><br/><div class="children"><div class="content">This is very cool and seems similar to what we do&#x2F;did in Cinder: <a href="https:&#x2F;&#x2F;bernsteinbear.com&#x2F;blog&#x2F;cinder-jit-bisect&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bernsteinbear.com&#x2F;blog&#x2F;cinder-jit-bisect&#x2F;</a><p>EDIT: Oops, this tool is mentioned in the post already (but the post is not, so here it is if you want to read about it). Neat!</div><br/><div id="40998310" class="c"><input type="checkbox" id="c-40998310" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#40996682">parent</a><span>|</span><a href="#41001280">next</a><span>|</span><label class="collapse" for="c-40998310">[-]</label><label class="expand" for="c-40998310">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for that link. I&#x27;ve changed the link beneath the Cinder mention to that page instead of the GitHub page.</div><br/></div></div></div></div><div id="41001280" class="c"><input type="checkbox" id="c-41001280" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40996682">prev</a><span>|</span><a href="#41000764">next</a><span>|</span><label class="collapse" for="c-41001280">[-]</label><label class="expand" for="c-41001280">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m running one of these now, interestingly enough. Apparently something&#x27;s broken in OpenJDK if you build with the new Xcode. So I&#x27;m bisecting on all the files (choosing either the old or new compiler) trying to see which one is breaking things.</div><br/></div></div><div id="41000764" class="c"><input type="checkbox" id="c-41000764" checked=""/><div class="controls bullet"><span class="by">drivebycomment</span><span>|</span><a href="#41001280">prev</a><span>|</span><a href="#40998811">next</a><span>|</span><label class="collapse" for="c-41000764">[-]</label><label class="expand" for="c-41000764">[1 more]</label></div><br/><div class="children"><div class="content">In my former life, I used to maintain a script that can be given two sets of objects files, one compiled with optimization, and one without, and the script will effectively do a binary search by choosing which object files you link and run the executable to determine success&#x2F;fail. Each iteration is quick, since linking step is usually fast. This was useful when troubleshooting a big binary, since optimized build back then was often quite slow for a large executable.</div><br/></div></div><div id="40998811" class="c"><input type="checkbox" id="c-40998811" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#41000764">prev</a><span>|</span><a href="#40999717">next</a><span>|</span><label class="collapse" for="c-40998811">[-]</label><label class="expand" for="c-40998811">[1 more]</label></div><br/><div class="children"><div class="content">When I read <a href="https:&#x2F;&#x2F;marcan.st&#x2F;2017&#x2F;12&#x2F;debugging-an-evil-go-runtime-bug&#x2F;" rel="nofollow">https:&#x2F;&#x2F;marcan.st&#x2F;2017&#x2F;12&#x2F;debugging-an-evil-go-runtime-bug&#x2F;</a> and saw the hash bisection trick for the first time I was super impressed, it really does sound incredibly slick :) I imagine that&#x27;s how first coming across normal git bisect must feel to new engineers.</div><br/></div></div><div id="40999717" class="c"><input type="checkbox" id="c-40999717" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#40998811">prev</a><span>|</span><a href="#41002419">next</a><span>|</span><label class="collapse" for="c-40999717">[-]</label><label class="expand" for="c-40999717">[3 more]</label></div><br/><div class="children"><div class="content">This is pretty close to what I built for maintaining demo compatibility in Doom engines. Basically it runs a demo and dumps a save game to a file every frame. As soon as there&#x27;s a divergence it says what the difference is (monster 17 is at (4, 22); should be (4, 21)) and bails. Not a ton of difference between that and diffing the stack.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;camgunz&#x2F;democomp">https:&#x2F;&#x2F;github.com&#x2F;camgunz&#x2F;democomp</a></div><br/><div id="41000110" class="c"><input type="checkbox" id="c-41000110" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#40999717">parent</a><span>|</span><a href="#41002759">next</a><span>|</span><label class="collapse" for="c-41000110">[-]</label><label class="expand" for="c-41000110">[1 more]</label></div><br/><div class="children"><div class="content">What you are describing sounds like comparing traces of two supposed-to-be-identical programs to see where they first diverge. That&#x27;s not what this is describing. There is no trace at all, nor any decision about what to trace or what not to trace.<p>There is only a decision about whether to use the old or new implementation based on the hash of the call stack at that moment. Then you binary search on hash values to identify the exact call stack hash for which the new implementation causes a problem. Then you run the program once more with the instructions &quot;print the stack with this hash&quot;.</div><br/></div></div><div id="41002759" class="c"><input type="checkbox" id="c-41002759" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40999717">parent</a><span>|</span><a href="#41000110">prev</a><span>|</span><a href="#41002419">next</a><span>|</span><label class="collapse" for="c-41002759">[-]</label><label class="expand" for="c-41002759">[1 more]</label></div><br/><div class="children"><div class="content">What you implemented is just checking output against a reference. That&#x27;s an extremely common testing method.<p>This is significantly different because it actually changes the program that is being run. It&#x27;s not common at all - probably because there aren&#x27;t too many situations where it applies. You need to be processing some large input that you don&#x27;t understand, and commonly change bits of your code in ways that you can turn on and off dynamically during a single run.</div><br/></div></div></div></div><div id="41002419" class="c"><input type="checkbox" id="c-41002419" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40999717">prev</a><span>|</span><a href="#41001161">next</a><span>|</span><label class="collapse" for="c-41002419">[-]</label><label class="expand" for="c-41002419">[1 more]</label></div><br/><div class="children"><div class="content">this is a wonderful post!<p>the algorithms for using binary search to efficiently reduce a set satisfying some predicate to a locally minimal satisfying subset* are new to me (though cox says zeller published a slightly buggy version in 01999! and meta&#x27;s  cinder a correct one in 02021), and seem brilliant; their applications are not limited to debugging.  i wonder how it relates to hypothesis&#x27;s test-case reduction algorithm; can one of them be considered an application of the other?<p>also, this idea of binary-search debugging of the program&#x27;s call tree rather than your revision history (or program input, or a set of data instances) is also a brilliant one.  and although they published it a decade ago, i hadn&#x27;t heard about it until now<p>the examples of asynctimerchan=1, changing optimization settings, and changing sort algorithms have in common that in some sense they are behavior-preserving, so you can toggle them on and off at will during execution without breaking anything.  i wonder how to apply this call-tree debugging if the change you&#x27;re trying to narrow down is a change that has to be consistent throughout the program&#x27;s execution.  for example, suppose some code using your hash tables breaks when you switch to a new hash function, maybe because it inadvertently depended on enumeration order.  if you change the hash function partway through the program, you won&#x27;t be able to find things in your hash tables after that.  you could change the algorithm per table, of course, and narrow it down to a particular table, but that won&#x27;t give you the particular line of code<p>i need to think a bit more about this issue of &#x27;hashing a list of program counters&#x27;.  you could of course number the sequence of all subroutine invocations during a (deterministic! single-threaded!) execution, as gas does for macro invocations, and binary-search that dense numbering.  (this is a variant of the technique carry_bit is calling &#x27;optimization fuel&#x27;, but one that requires support from a compiler or debugger.)  but, since you&#x27;re toggling options on and off that will change the number of subroutine calls, the numbering won&#x27;t be stable; so this will tend to only reliably find single-culprit failures<p>you could possibly get a stable-enough numbering using pathnames like &#x2F;3&#x2F;5&#x2F;1, meaning the the 1st subroutine called  from the 5th subroutine called from the 3rd subroutine called from main().  that seems like it might in some sense be <i>stabler</i> than hashing the <i>entire</i> list of return addresses, and it would certainly permit a lower-overhead implementation using a debugger and breakpoints rather than a check in every leaf call.  plausibly i&#x27;m overlooking a flaw in this form of &#x27;sequential numbering&#x27;?  does the hashed list get truncated at some point for stability?<p>often when you have a change that is in some sense behavior-preserving, which is to say, you have two ways to do the same thing, you can use generative testing systems like hypothesis to detect bugs in either of them: process the same input through both paths and verify that the results are equivalent in the appropriate sense.  this doesn&#x27;t require the instrumentation infrastructure russ is using here, but it does depend on you being able to identify the relevant &#x27;input&#x27;, which can be very hard<p>in itself that doesn&#x27;t help with the kinds of bugs he&#x27;s talking about here, though: bugs where both the old and new code is &#x27;equivalent&#x27; by your lights, but some other client code that calls it doesn&#x27;t find it equivalent.  this suggests a different generative-testing approach: generatively inject behavioral perturbations which don&#x27;t violate equivalence, attempting to provoke failures in client code.  aslr and hash-table seed randomization are doing this for us for some purposes, but unlike generative-testing frameworks, they provoke outages in production, don&#x27;t do test-case minimization, and don&#x27;t record failing cases to make bisection easy and prevent later regressions.  and they don&#x27;t do things like shuffling the input to a non-stable sort subroutine<p>binary-search debugging does indeed feel magical.  scaevolus seems to be saying there&#x27;s a bayesian generalization of it for nondeterministic bugs that are effectively random?  you can of course run the test 5 (or 1000) times on each revision you&#x27;re binary-searching over, but it feels like, if the number of revisions you&#x27;re searching over is several thousand, you ought to be able to get some additional advantage out of running the test once on each of 5 (or 1000) revisions.  can you solve this just by maximizing the expected shannon information of each test?<p>on a side note, it&#x27;s pretty appalling that 30 years ago the plan9 group had `yesterday -d -n 7 anyfilename` to see what changed in the last week, thanks to their optical jukebox, while in the mainstream we still struggle with accidental file deletion and overwrites despite routinely carrying around terabytes in our pockets<p>on an even more marginally relevant note, earlier this week i was perusing the 7th edition unix kernel, in which the subroutine that switches stacks (the one with the well-known comment in 6th edition) is called swtch().  and tonight i just realized why russ cox uses that domain name<p>______<p>* conventionally this is just called a &#x27;minimal satisfying subset&#x27;, because it&#x27;s &#x27;minimal&#x27; in the partial-order sense, but i think cox&#x27;s term &#x27;locally minimal&#x27; is clearer</div><br/></div></div><div id="41001161" class="c"><input type="checkbox" id="c-41001161" checked=""/><div class="controls bullet"><span class="by">millipede</span><span>|</span><a href="#41002419">prev</a><span>|</span><label class="collapse" for="c-41001161">[-]</label><label class="expand" for="c-41001161">[5 more]</label></div><br/><div class="children"><div class="content">Are there any non-compiler use cases for this technique?</div><br/><div id="41001664" class="c"><input type="checkbox" id="c-41001664" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#41001161">parent</a><span>|</span><a href="#41001822">next</a><span>|</span><label class="collapse" for="c-41001664">[-]</label><label class="expand" for="c-41001664">[1 more]</label></div><br/><div class="children"><div class="content">Anyone working on libraries that are used by large programs can use them, like in the sort and timer cases described toward the end of the paper. When you work on libraries used by other larger programs you inevitably break them accidentally. This technique pinpoints the exact context of the breakage.</div><br/></div></div><div id="41001822" class="c"><input type="checkbox" id="c-41001822" checked=""/><div class="controls bullet"><span class="by">Twirrim</span><span>|</span><a href="#41001161">parent</a><span>|</span><a href="#41001664">prev</a><span>|</span><a href="#41001284">next</a><span>|</span><label class="collapse" for="c-41001822">[-]</label><label class="expand" for="c-41001822">[2 more]</label></div><br/><div class="children"><div class="content">All sorts of stuff, I git bisect reasonably regularly.<p>You can even do things like automatically git bisect the linux kernel, with a little care.  I wrote this up a few years ago <a href="https:&#x2F;&#x2F;paulgraydon.co.uk&#x2F;posts&#x2F;2020-12-27-automated-kernel-bisection&#x2F;" rel="nofollow">https:&#x2F;&#x2F;paulgraydon.co.uk&#x2F;posts&#x2F;2020-12-27-automated-kernel-...</a>.<p>I can&#x27;t talk about the actual case that lead me to ever need to git bisect a kernel in the first place, but at the same time I also learned how to make a minimalist one-C-file initrd, because what I needed to catch was visible under a &#x2F;sys or &#x2F;dev mount, or something like that.  I later realised it&#x27;s possible to do the same thing with Go in slightly easier syntax, if you cajole it in to producing a statically compiled binary!</div><br/><div id="41002937" class="c"><input type="checkbox" id="c-41002937" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41001161">root</a><span>|</span><a href="#41001822">parent</a><span>|</span><a href="#41001284">next</a><span>|</span><label class="collapse" for="c-41002937">[-]</label><label class="expand" for="c-41002937">[1 more]</label></div><br/><div class="children"><div class="content">He means the runtime bisection that this article is about, not `git bisect`.</div><br/></div></div></div></div><div id="41001284" class="c"><input type="checkbox" id="c-41001284" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41001161">parent</a><span>|</span><a href="#41001822">prev</a><span>|</span><label class="collapse" for="c-41001284">[-]</label><label class="expand" for="c-41001284">[1 more]</label></div><br/><div class="children"><div class="content">You can use this for any codebase of sufficient complexity where you want to identify which change is causing the effect you&#x27;re observing.</div><br/></div></div></div></div></div></div></div></div></div></body></html>