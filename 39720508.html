<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710579650748" as="style"/><link rel="stylesheet" href="styles.css?v=1710579650748"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.vusec.net/projects/ghostrace/">GhostRace: Exploiting and mitigating speculative race conditions</a> <span class="domain">(<a href="https://www.vusec.net">www.vusec.net</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>17 comments</span></div><br/><div><div id="39721749" class="c"><input type="checkbox" id="c-39721749" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#39721516">next</a><span>|</span><label class="collapse" for="c-39721749">[-]</label><label class="expand" for="c-39721749">[6 more]</label></div><br/><div class="children"><div class="content">The paper seems to make no mention of the memory barriers in play, merely talking about the atomic operation and the conditional branch. Despite that, they indicate they produced a proof-of-concept exploit leaking data.<p>Traditionally, you would use a acquire, L-LS, barrier on entry to a critical section to order any memory accesses in the critical section after the load of the atomic operation completes. Without that, the critical section may speculatively execute on your core while somebody else holds the lock and those changes would be confirmed if the owner releases before your delayed acquiring load completes.<p>For this paper to be true, either their synchronization primitives do not have acquire barriers, which is wrong to start with, or the acquire barrier must not be stalling later memory accesses which is how I have seen it portrayed. How would that even work correctly on normal code?<p>To preserve the L-L ordering implicit in the L-LS ordering, you need to guarantee that any loads after the acquiring load will see all stores explicitly ordered before the releasing store. You would need to guarantee that any speculative load must at least see the value the memory would have immediately preceding the release barrier on the other core even if you happened to load that value arbitrarily long before the release barrier on the other core. I guess you could track every single speculative access after a L-* barrier and their dependency chain and then invalidate and re-compute as you see stores until you resolve all pertinent operations prior to your L-* barrier (such as the acquiring load in this case)? If the chip people are actually doing that, that seems... wild.</div><br/><div id="39723699" class="c"><input type="checkbox" id="c-39723699" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#39721749">parent</a><span>|</span><a href="#39722620">next</a><span>|</span><label class="collapse" for="c-39723699">[-]</label><label class="expand" for="c-39723699">[1 more]</label></div><br/><div class="children"><div class="content">See &quot;Speculative Lock Elision&quot; from MICRO34 (in 2001!):<p><a href="https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~rajwar&#x2F;papers&#x2F;micro01.pdf" rel="nofollow">https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~rajwar&#x2F;papers&#x2F;micro01.pdf</a></div><br/></div></div><div id="39722620" class="c"><input type="checkbox" id="c-39722620" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39721749">parent</a><span>|</span><a href="#39723699">prev</a><span>|</span><a href="#39722371">next</a><span>|</span><label class="collapse" for="c-39722620">[-]</label><label class="expand" for="c-39722620">[1 more]</label></div><br/><div class="children"><div class="content">It seems like the chips are speculating past a &#x27;lock cmpxchgq&#x27;, which corresponds to a seq-cst access (IIRC).<p>&gt; or the acquire barrier must not be stalling later memory accesses<p>That is my impression.  But I am really confused about this stuff in general.</div><br/></div></div><div id="39722371" class="c"><input type="checkbox" id="c-39722371" checked=""/><div class="controls bullet"><span class="by">trebligdivad</span><span>|</span><a href="#39721749">parent</a><span>|</span><a href="#39722620">prev</a><span>|</span><a href="#39721516">next</a><span>|</span><label class="collapse" for="c-39722371">[-]</label><label class="expand" for="c-39722371">[3 more]</label></div><br/><div class="children"><div class="content">Is that lot true on x86?  I thought it&#x27;s (fairly) strict memory ordering meant you didn&#x27;t have acquire type thing?</div><br/><div id="39722539" class="c"><input type="checkbox" id="c-39722539" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#39721749">root</a><span>|</span><a href="#39722371">parent</a><span>|</span><a href="#39721516">next</a><span>|</span><label class="collapse" for="c-39722539">[-]</label><label class="expand" for="c-39722539">[2 more]</label></div><br/><div class="children"><div class="content">The concept of ordering is independent of architecture. What operations need to be ordered relative to other operations to be correct does not change. But, your architecture may implicitly guarantee certain orderings so you do not need to explicitly guarantee those orderings.<p>If I remember correctly, x86 basically gives you everything except S-L automatically. That means a traditional acquire, L-LS, and traditional release, LS-S, barrier should be &quot;free&quot; and require no explicit instructions. I forgot about that, so it makes sense why they would not mention the presence of explicit barriers. But, that does not change the fact that you need that ordering to guarantee correctness, it is just built-in and automatic.<p>The oddity here is that speculative loads across a L-LS ordering requires some pretty deep black magic to be going on at the hardware level. I have no idea how they could safely reorder stores across a L-S ordering and still maintain &quot;as-if&quot; the store happens after the load, and even safely reordering loads across a L-L ordering and maintaining the &quot;as-if&quot; seems pretty arcane. The fact that the paper is claiming their PoC works and thus the reordering must be happening is wild. Either the processor is not correctly implementing the declared memory ordering semantics, or they are doing some real reordering magic.</div><br/><div id="39723785" class="c"><input type="checkbox" id="c-39723785" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#39721749">root</a><span>|</span><a href="#39722539">parent</a><span>|</span><a href="#39721516">next</a><span>|</span><label class="collapse" for="c-39723785">[-]</label><label class="expand" for="c-39723785">[1 more]</label></div><br/><div class="children"><div class="content">This kind of memory order speculatiom is basically required on x86 since the strong semantics would otherwise prevent many useful reorderings (especially L-L which is absolutely critical).<p>The basic way it works is that pretty much any reordered is allowed, speculatively, even if it violates the explicit or implicit barriers, but then the operations are tracked in a memory order buffer (MOB) until retirement which can detect whether the reordering was detectable and if so flush the pipeline (so-called &quot;memory order nuke&quot;, visible in performance counters).</div><br/></div></div></div></div></div></div></div></div><div id="39721516" class="c"><input type="checkbox" id="c-39721516" checked=""/><div class="controls bullet"><span class="by">Voultapher</span><span>|</span><a href="#39721749">prev</a><span>|</span><a href="#39721544">next</a><span>|</span><label class="collapse" for="c-39721516">[-]</label><label class="expand" for="c-39721516">[1 more]</label></div><br/><div class="children"><div class="content">Spectre-v1 really is the ghost that keeps haunting us. All the mitigations I&#x27;m aware of work by containing the domain, for example inter-process boundaries together with the MMU to limit the leaked surface. How are we developers supposed to reason about code where most conditions break the invariants we encoded?<p>The demonstrated exploit strategy is pretty cool.</div><br/></div></div><div id="39721544" class="c"><input type="checkbox" id="c-39721544" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#39721516">prev</a><span>|</span><a href="#39721659">next</a><span>|</span><label class="collapse" for="c-39721544">[-]</label><label class="expand" for="c-39721544">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Our mitigation requires minimal kernel changes (i.e., 2 LoC) and incurs only ≈5% geomean performance overhead on LMBench.<p>5 percent is not nothing but seems like a worthwhile investment here. Really cool exploit strategy btw.</div><br/><div id="39722592" class="c"><input type="checkbox" id="c-39722592" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39721544">parent</a><span>|</span><a href="#39721659">next</a><span>|</span><label class="collapse" for="c-39722592">[-]</label><label class="expand" for="c-39722592">[1 more]</label></div><br/><div class="children"><div class="content">5% is a pretty big regression.</div><br/></div></div></div></div><div id="39721659" class="c"><input type="checkbox" id="c-39721659" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39721544">prev</a><span>|</span><label class="collapse" for="c-39721659">[-]</label><label class="expand" for="c-39721659">[7 more]</label></div><br/><div class="children"><div class="content">What does &quot;speculative race condition&quot; mean?</div><br/><div id="39722564" class="c"><input type="checkbox" id="c-39722564" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#39721659">parent</a><span>|</span><a href="#39721802">next</a><span>|</span><label class="collapse" for="c-39722564">[-]</label><label class="expand" for="c-39722564">[2 more]</label></div><br/><div class="children"><div class="content">This is described pretty well in the paper, but briefly: the &quot;race condition&quot; which they exploit happens because the CPU speculatively (and incorrectly) thinks it acquired a lock. Multiple threads being in a critical section can be exploitable and lead to arbitrary read&#x2F;write and malicious code execution (one case demonstrated in the paper is some random NFC function). The researchers abuse the fact that the critical section can be entered speculatively to gain speculative malicious code execution, which they then use to construct a gadget which leaks arbitrary kernel memory into side channels.</div><br/><div id="39722920" class="c"><input type="checkbox" id="c-39722920" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39721659">root</a><span>|</span><a href="#39722564">parent</a><span>|</span><a href="#39721802">next</a><span>|</span><label class="collapse" for="c-39722920">[-]</label><label class="expand" for="c-39722920">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!</div><br/></div></div></div></div><div id="39721802" class="c"><input type="checkbox" id="c-39721802" checked=""/><div class="controls bullet"><span class="by">sweatypalmer</span><span>|</span><a href="#39721659">parent</a><span>|</span><a href="#39722564">prev</a><span>|</span><label class="collapse" for="c-39721802">[-]</label><label class="expand" for="c-39721802">[4 more]</label></div><br/><div class="children"><div class="content">I encourage you to research the rabbit hole that is speculative executive and &#x27;spectre&#x27; attacks.</div><br/><div id="39722582" class="c"><input type="checkbox" id="c-39722582" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39721659">root</a><span>|</span><a href="#39721802">parent</a><span>|</span><a href="#39722509">next</a><span>|</span><label class="collapse" for="c-39722582">[-]</label><label class="expand" for="c-39722582">[2 more]</label></div><br/><div class="children"><div class="content">I know what speculative execution is and have some understanding of spectre already. What I don&#x27;t get is what it means to exploit a speculative race condition.</div><br/><div id="39724137" class="c"><input type="checkbox" id="c-39724137" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39721659">root</a><span>|</span><a href="#39722582">parent</a><span>|</span><a href="#39722509">next</a><span>|</span><label class="collapse" for="c-39724137">[-]</label><label class="expand" for="c-39724137">[1 more]</label></div><br/><div class="children"><div class="content">So the thing with speculative attacks is that you can use an invariant that is broken speculatively to leak things. In this case they use a speculative race condition to gain speculative code execution, much like you can use a normal race condition to gain real code execution. Arbitrary speculative code execution can be used to leak data which can be picked up via side channels.</div><br/></div></div></div></div><div id="39722509" class="c"><input type="checkbox" id="c-39722509" checked=""/><div class="controls bullet"><span class="by">Jerrrry</span><span>|</span><a href="#39721659">root</a><span>|</span><a href="#39721802">parent</a><span>|</span><a href="#39722582">prev</a><span>|</span><label class="collapse" for="c-39722509">[-]</label><label class="expand" for="c-39722509">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Speculative Execution&quot; is gonna be my boat name.<p>I&#x27;ll tell people it&#x27;s a punny triple entendre, leading people to believe I am a wall street hacking guru hit-man.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>