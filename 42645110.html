<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736499664085" as="style"/><link rel="stylesheet" href="styles.css?v=1736499664085"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jirevwe.github.io/sql-nulls-are-weird.html">SQL nulls are weird</a> <span class="domain">(<a href="https://jirevwe.github.io">jirevwe.github.io</a>)</span></div><div class="subtext"><span>subomi</span> | <span>126 comments</span></div><br/><div><div id="42647926" class="c"><input type="checkbox" id="c-42647926" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#42647290">next</a><span>|</span><label class="collapse" for="c-42647926">[-]</label><label class="expand" for="c-42647926">[26 more]</label></div><br/><div class="children"><div class="content">SQL NULLs aren&#x27;t <i>weird</i>, they&#x27;re just based off of Kleene&#x27;s TRUE-FALSE-UNKNOWN logic!<p>If you want you can read NULL as UNKNOWN and suddenly a whole bunch of operations involving them become a lot more intuitive:<p>1. TRUE <i>OR</i> UNKNOWN = TRUE, because you know you have at least one TRUE already.<p>2. TRUE <i>AND</i> UNKNOWN = UNKNOWN, because you don&#x27;t know whether you have two TRUEs or not. It&#x27;s just out there.<p>3. UNKNOWN <i>XOR</i> UNKNOWN = UNKNOWN, because it could darn near be anything: TRUE XOR TRUE, TRUE XOR FALSE, FALSE XOR FALSE, FALSE XOR TRUE... Internalizing this is where SQL&#x27;s use of NULL &#x2F; UNKNOWN really becomes intuitive.<p>4. (TRUE AND FALSE) XOR (TRUE OR UNKNOWN) = (FALSE) XOR (TRUE) per #1 = TRUE. See, it&#x27;s consistent, you just need to keep in mind that if you have a lot of known UNKNOWNs they&#x27;re quite parasitic and your final outcome is likely to be, itself, an UNKNOWN. Just like in real life!</div><br/><div id="42651862" class="c"><input type="checkbox" id="c-42651862" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#42647926">parent</a><span>|</span><a href="#42653803">next</a><span>|</span><label class="collapse" for="c-42651862">[-]</label><label class="expand" for="c-42651862">[4 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t address anything in the second half of the post though, starting with this pull quote:<p>&gt; <i>The fact that NULLs are distinct for UNIQUE columns but are indistinct for SELECT DISTINCT and UNION continues to be puzzling. It seems that NULLs should be either distinct everywhere or nowhere. And the SQL standards documents suggest that NULLs should be distinct everywhere. Yet as of this writing, no SQL engine tested treats NULLs as distinct in a SELECT DISTINCT statement or in a UNION.</i></div><br/><div id="42652013" class="c"><input type="checkbox" id="c-42652013" checked=""/><div class="controls bullet"><span class="by">sitharus</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42651862">parent</a><span>|</span><a href="#42651953">next</a><span>|</span><label class="collapse" for="c-42652013">[-]</label><label class="expand" for="c-42652013">[1 more]</label></div><br/><div class="children"><div class="content">This is confusing when you know that NULLs are not comparable, but it makes some sense if you consider the result of distinct&#x2F;union as the output of a GROUP BY. You can consider everything that&#x27;s NULL to be part of the same group, all the values are unknown.<p>So NULLs are not comparable but they are part of the same set.</div><br/></div></div><div id="42651953" class="c"><input type="checkbox" id="c-42651953" checked=""/><div class="controls bullet"><span class="by">Aloisius</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42651862">parent</a><span>|</span><a href="#42652013">prev</a><span>|</span><a href="#42653803">next</a><span>|</span><label class="collapse" for="c-42651953">[-]</label><label class="expand" for="c-42651953">[2 more]</label></div><br/><div class="children"><div class="content">MS SQL Server treats NULLs as indistinct for UNIQUE constraints, SELECT DISTINCT and for UNION.<p>Indeed, the sqlite page the pull quote is from says as much.</div><br/><div id="42653900" class="c"><input type="checkbox" id="c-42653900" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42651953">parent</a><span>|</span><a href="#42653803">next</a><span>|</span><label class="collapse" for="c-42653900">[-]</label><label class="expand" for="c-42653900">[1 more]</label></div><br/><div class="children"><div class="content">&gt; MS SQL Server treats NULLs as indistinct for UNIQUE constraints<p>Postgres lets you control that behaviour when creating the constraint (or index)</div><br/></div></div></div></div></div></div><div id="42653803" class="c"><input type="checkbox" id="c-42653803" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#42647926">parent</a><span>|</span><a href="#42651862">prev</a><span>|</span><a href="#42652344">next</a><span>|</span><label class="collapse" for="c-42653803">[-]</label><label class="expand" for="c-42653803">[1 more]</label></div><br/><div class="children"><div class="content">This is the correct way of thinking about things. Null is one of the hardest things for traditional software engineers in my experience as a guy who came up as a data admin.</div><br/></div></div><div id="42652344" class="c"><input type="checkbox" id="c-42652344" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42647926">parent</a><span>|</span><a href="#42653803">prev</a><span>|</span><a href="#42648007">next</a><span>|</span><label class="collapse" for="c-42652344">[-]</label><label class="expand" for="c-42652344">[1 more]</label></div><br/><div class="children"><div class="content">If only it had a name that was more indicative of that, like UNKNOWN, or UNDEFINED or INDERTIMINATE or something.</div><br/></div></div><div id="42648007" class="c"><input type="checkbox" id="c-42648007" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42647926">parent</a><span>|</span><a href="#42652344">prev</a><span>|</span><a href="#42651791">next</a><span>|</span><label class="collapse" for="c-42648007">[-]</label><label class="expand" for="c-42648007">[15 more]</label></div><br/><div class="children"><div class="content">It&#x27;s unfortunate to namesquat on &#x27;boolean&#x27; if your elements have three possible values.  Just call it &#x27;ternary logic&#x27; and let individuals decide which system to use.</div><br/><div id="42648171" class="c"><input type="checkbox" id="c-42648171" checked=""/><div class="controls bullet"><span class="by">foobarchu</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42648007">parent</a><span>|</span><a href="#42648037">next</a><span>|</span><label class="collapse" for="c-42648171">[-]</label><label class="expand" for="c-42648171">[10 more]</label></div><br/><div class="children"><div class="content">Who&#x27;s name squatting boolean? The bool column is exactly what it claims to be, you just have the option of introducing unknowability if you define it allow nulls.</div><br/><div id="42648699" class="c"><input type="checkbox" id="c-42648699" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42648171">parent</a><span>|</span><a href="#42648037">next</a><span>|</span><label class="collapse" for="c-42648699">[-]</label><label class="expand" for="c-42648699">[9 more]</label></div><br/><div class="children"><div class="content">The distinction is that not all formal logic systems are Boolean. Meaning that it is nonsensical and confusing to use &quot;Boolean&quot; as a generic synonym for &quot;truth value&quot; in the same way that it&#x27;s nonsensical to use &quot;Pantone&quot; as a generic synonym for &quot;color value&quot;, including when the specific kind of color value you&#x27;re talking about is CMYK or HSV and definitely <i>not</i> Pantone.</div><br/><div id="42653920" class="c"><input type="checkbox" id="c-42653920" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42648699">parent</a><span>|</span><a href="#42651853">next</a><span>|</span><label class="collapse" for="c-42653920">[-]</label><label class="expand" for="c-42653920">[1 more]</label></div><br/><div class="children"><div class="content">There are two values, TRUE and FALSE. Null is not a value, it the the lack of a value.<p>You have a list of people and you ask if they own a car. You didn&#x27;t get around to asking George, so that, somehow means he owns a car because you are using boolean logic? Or does it mean he doesn&#x27;t own a car, because you are using boolean logic?<p>No, it means you haven&#x27;t gathered this data point and don&#x27;t know.</div><br/></div></div><div id="42651853" class="c"><input type="checkbox" id="c-42651853" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42648699">parent</a><span>|</span><a href="#42653920">prev</a><span>|</span><a href="#42648037">next</a><span>|</span><label class="collapse" for="c-42651853">[-]</label><label class="expand" for="c-42651853">[7 more]</label></div><br/><div class="children"><div class="content">But it is a boolean value, there&#x27;s only two possible values TRUE and FALSE. But because it&#x27;s SQL you can define any column as TYPE | NULL.<p>You could say that a boolean column with a NULL value is FALSE like how a lot of programming languages coerce it but if you wanted that you would just make a default of FALSE. The meaning of NULL in general being &quot;value not specified&quot; lends itself pretty nicely to &quot;either true or false.&quot;</div><br/><div id="42653120" class="c"><input type="checkbox" id="c-42653120" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42651853">parent</a><span>|</span><a href="#42651941">next</a><span>|</span><label class="collapse" for="c-42653120">[-]</label><label class="expand" for="c-42653120">[1 more]</label></div><br/><div class="children"><div class="content">What I want is for e.g. &quot;x OR y&quot; where y is NULL (and&#x2F;or of nullable type) to be an error rather than silently giving surprising results. Just like in a decent programming language I can&#x27;t do x || y where x and y are of type boolean?, I have to explicitly handle the case where one or other of them is null (or e.g. write x!! || y!! - and that will at still error if either is null rather than silently evaluating to a funny result).</div><br/></div></div><div id="42651941" class="c"><input type="checkbox" id="c-42651941" checked=""/><div class="controls bullet"><span class="by">bdangubic</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42651853">parent</a><span>|</span><a href="#42653120">prev</a><span>|</span><a href="#42648037">next</a><span>|</span><label class="collapse" for="c-42651941">[-]</label><label class="expand" for="c-42651941">[5 more]</label></div><br/><div class="children"><div class="content"><i>The meaning of NULL in general being &quot;value not specified&quot; lends itself pretty nicely to &quot;either true or false.&quot;</i><p>You mean <i>neither</i> true or false?</div><br/><div id="42652271" class="c"><input type="checkbox" id="c-42652271" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42651941">parent</a><span>|</span><a href="#42652492">next</a><span>|</span><label class="collapse" for="c-42652271">[-]</label><label class="expand" for="c-42652271">[3 more]</label></div><br/><div class="children"><div class="content">I think I mean either. So yes  NULL is a distinct value from true and false so I think it&#x27;s also right to say it&#x27;s neither true nor false. But the value NULL does represent is roughly &quot;could be true or false, we don&#x27;t know yet.&quot;</div><br/><div id="42653126" class="c"><input type="checkbox" id="c-42653126" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42652271">parent</a><span>|</span><a href="#42652502">next</a><span>|</span><label class="collapse" for="c-42653126">[-]</label><label class="expand" for="c-42653126">[1 more]</label></div><br/><div class="children"><div class="content">It could mean anything or nothing depending on context, which is part of the problem. (Plenty of people think the meaning of NULL is clear and obvious and consistent, unfortunately they give different answers about what that meaning is)</div><br/></div></div><div id="42652502" class="c"><input type="checkbox" id="c-42652502" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42652271">parent</a><span>|</span><a href="#42653126">prev</a><span>|</span><a href="#42652492">next</a><span>|</span><label class="collapse" for="c-42652502">[-]</label><label class="expand" for="c-42652502">[1 more]</label></div><br/><div class="children"><div class="content">It could also be neither. It&#x27;s whatever you define it to be. Null could mean you don&#x27;t know if it&#x27;s true or if it&#x27;s false, or it could mean you know it&#x27;s neither true nor false.</div><br/></div></div></div></div><div id="42652492" class="c"><input type="checkbox" id="c-42652492" checked=""/><div class="controls bullet"><span class="by">solumunus</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42651941">parent</a><span>|</span><a href="#42652271">prev</a><span>|</span><a href="#42648037">next</a><span>|</span><label class="collapse" for="c-42652492">[-]</label><label class="expand" for="c-42652492">[1 more]</label></div><br/><div class="children"><div class="content">It could be true or false, but it’s unknown. For example. a user doing a survey is yet to fill in the answer. That doesn’t mean there is no answer, it’s just unrecorded.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42648037" class="c"><input type="checkbox" id="c-42648037" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42648007">parent</a><span>|</span><a href="#42648171">prev</a><span>|</span><a href="#42651899">next</a><span>|</span><label class="collapse" for="c-42648037">[-]</label><label class="expand" for="c-42648037">[3 more]</label></div><br/><div class="children"><div class="content">Maybe GP was edited, but it doesn&#x27;t use the word &quot;boolean&quot; anywhere.</div><br/><div id="42648083" class="c"><input type="checkbox" id="c-42648083" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42648037">parent</a><span>|</span><a href="#42648074">next</a><span>|</span><label class="collapse" for="c-42648083">[-]</label><label class="expand" for="c-42648083">[1 more]</label></div><br/><div class="children"><div class="content">Correct, I edited &quot;boolean&quot; out prior to ^^P&#x27;s comment. My apologies.</div><br/></div></div></div></div></div></div><div id="42651791" class="c"><input type="checkbox" id="c-42651791" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#42647926">parent</a><span>|</span><a href="#42648007">prev</a><span>|</span><a href="#42652444">next</a><span>|</span><label class="collapse" for="c-42651791">[-]</label><label class="expand" for="c-42651791">[1 more]</label></div><br/><div class="children"><div class="content">&gt; quite parasitic<p>This is the mental model that I use and teach: a NULL is a virus that will likely make everything it touches NULL... unless cordoned off by a COALESCE or IFNULL or something else that explicitly speaks about its NULL-sensitive behavior in its documentation.<p>So if you see a bug where a WHERE or FILTER clause is unexpectedly failing, and you&#x27;re in a time crunch, rather than pounding your head against the wall, start sprinkling COALESCE statements around (while being thoughtful about the domain meaning of what you&#x27;re doing) and it&#x27;s more likely than not to solve your problem!</div><br/></div></div><div id="42652444" class="c"><input type="checkbox" id="c-42652444" checked=""/><div class="controls bullet"><span class="by">remywang</span><span>|</span><a href="#42647926">parent</a><span>|</span><a href="#42651791">prev</a><span>|</span><a href="#42647290">next</a><span>|</span><label class="collapse" for="c-42652444">[-]</label><label class="expand" for="c-42652444">[3 more]</label></div><br/><div class="children"><div class="content">Except that NULL is <i>not</i> the same as UNKNOWN! NULL is a data value (like integers) that can appear in data expressions (like NULL + 1) and comparisons (like NULL = 1) whereas UNKNOWN is a truth value that can appear in boolean&#x2F;logical expressions constructed from logical connectives like AND, OR, NOT.<p>A data expression always evaluates to a data value, and usually whenever any part of the expression is NULL, the entire expression evaluates to NULL.<p>A comparison evaluates to a truth value, and usually when a comparison invovles a NULL it returns UNKNOWN. This leads to weird behaviors where both `SELECT 3 WHERE NULL = NULL;` and `SELECT 3 WHERE NULL &lt;&gt; NULL;` returns nothing (because the query engine does not output a row if the predicate returns UNKNOWN on it).<p>What you listed above only comes into play for boolean&#x2F;logical connectives like AND, OR, NOT, and in that case we follow 3-valued logic.<p>And there&#x27;s more annoying corner cases when you deal with DISTINCT. The situation is so hopeless that SQLite has a whole table documenting divergent behaviors of NULL in different systems: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;nulls.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;nulls.html</a></div><br/><div id="42653167" class="c"><input type="checkbox" id="c-42653167" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42652444">parent</a><span>|</span><a href="#42647290">next</a><span>|</span><label class="collapse" for="c-42653167">[-]</label><label class="expand" for="c-42653167">[2 more]</label></div><br/><div class="children"><div class="content">Indeed, they&#x27;re not identical - that&#x27;s why I just said &quot;based on&quot;, and that&#x27;s likely why the word UNKNOWN itself isn&#x27;t used in SQL.<p>Nevertheless I find it a useful intuition pump. I wager that most people reading `UNKNOWN = UNKNOWN` or `UNKNOWN &lt;&gt; UNKNOWN` and thinking about the examples above would stop and say, &quot;Wait, I actually don&#x27;t know the value of that statement for sure either, since the LHS and the RHS could be completely different things,&quot; and would then double check what their SQL dialect would actually do in this situation.</div><br/><div id="42653344" class="c"><input type="checkbox" id="c-42653344" checked=""/><div class="controls bullet"><span class="by">remywang</span><span>|</span><a href="#42647926">root</a><span>|</span><a href="#42653167">parent</a><span>|</span><a href="#42647290">next</a><span>|</span><label class="collapse" for="c-42653344">[-]</label><label class="expand" for="c-42653344">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the word UNKNOWN itself isn&#x27;t used in SQL<p>That leads to an even more confusing point, that some systems (at least SQLite) overloads NULL to mean UNKNOWN, for example `SELECT 1 WHERE NULL = (NULL = NULL)`.<p>And the dangerous thing about NULLs is not when they are explicitly used in the query as a literal (as I did for brevity), but when they appear in tables. It&#x27;s perfectly reasonable to assume `SELECT COUNT( * ) FROM t;` should be the same as `SELECT COUNT( * ) from t WHERE t.x = t.x OR t.x &lt;&gt; t.x`, but they are not the same because the latter does not return NULL rows. This has lead to real query optimizer bugs. For more examples see this paper <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.14778&#x2F;3551793.3551818" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.14778&#x2F;3551793.3551818</a></div><br/></div></div></div></div></div></div></div></div><div id="42647290" class="c"><input type="checkbox" id="c-42647290" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#42647926">prev</a><span>|</span><a href="#42652706">next</a><span>|</span><label class="collapse" for="c-42647290">[-]</label><label class="expand" for="c-42647290">[39 more]</label></div><br/><div class="children"><div class="content">&gt; select null = null; returns NULL, because each NULL is basically a placeholder representing any “unknown value”. Two unknown values are not necessarily the same value; we can’t say that they are equal, because we don’t know the value of either of them.<p>Agreed with all of this, it would probably have been better if they were named `unknown` instead of reusing the `null` keyword.<p>Note also that since Postgresql 15, you can use `NULLS NOT DISTINCT` when creating a unique index [0]. I&#x27;m less familiar with other databases.<p>0: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;15&#x2F;sql-createtable.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;15&#x2F;sql-createtable.html</a></div><br/><div id="42653602" class="c"><input type="checkbox" id="c-42653602" checked=""/><div class="controls bullet"><span class="by">cm2187</span><span>|</span><a href="#42647290">parent</a><span>|</span><a href="#42647944">next</a><span>|</span><label class="collapse" for="c-42653602">[-]</label><label class="expand" for="c-42653602">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that in practice in a database NULL is a placeholder for a <i>missing</i> value, not an <i>unknown</i> value.</div><br/></div></div><div id="42647944" class="c"><input type="checkbox" id="c-42647944" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42647290">parent</a><span>|</span><a href="#42653602">prev</a><span>|</span><a href="#42647845">next</a><span>|</span><label class="collapse" for="c-42647944">[-]</label><label class="expand" for="c-42647944">[6 more]</label></div><br/><div class="children"><div class="content">SQL NULL doesn’t behave like “unknown” in all contexts. That’s one issue of NULL, that it doesn’t really have consistent semantics.</div><br/><div id="42648163" class="c"><input type="checkbox" id="c-42648163" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647944">parent</a><span>|</span><a href="#42647845">next</a><span>|</span><label class="collapse" for="c-42648163">[-]</label><label class="expand" for="c-42648163">[5 more]</label></div><br/><div class="children"><div class="content">Furthermore if null only means unknown then we need a value for “known absent”, there’s a reason why null is so often used as that.</div><br/><div id="42652133" class="c"><input type="checkbox" id="c-42652133" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42648163">parent</a><span>|</span><a href="#42651699">next</a><span>|</span><label class="collapse" for="c-42652133">[-]</label><label class="expand" for="c-42652133">[2 more]</label></div><br/><div class="children"><div class="content">From a purely relational perspective, if some piece of data can be absent, it&#x27;s a 1:N relation where N&lt;=1, and ought to be encoded as such.<p>(Of course, this is rather awkward in practice, and when NULL is there, it&#x27;s inevitably going to be used for that instead.)</div><br/><div id="42653640" class="c"><input type="checkbox" id="c-42653640" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42652133">parent</a><span>|</span><a href="#42651699">next</a><span>|</span><label class="collapse" for="c-42653640">[-]</label><label class="expand" for="c-42653640">[1 more]</label></div><br/><div class="children"><div class="content">It <i>is</i> encoded as such. That&#x27;s why most columns are made nullable. It&#x27;s crazy to say you need to use the full power of a 1:N relation with some child table when you know N cannot be greater than 1, when a nullable column already exactly encodes a 1:(0..1) relation. I&#x27;m not trying to shill for null here: one of null&#x27;s great problems is exactly the fact that null can represent &quot;unknown&quot;, &quot;known absent&quot;, &quot;not applicable&quot;, or even some sentinel-ish &quot;other&quot; escape condition, each with their own subtle differences in how they should be handled.<p>Null has tons of problems, of course. But it&#x27;s patently absurd to claim that you &quot;ought to be&quot; making a different 1-column table with a unique foreign key or shared primary key for every column that might be absent, because of some vague appeal to the fact that you <i>can</i> write it as a 1:N relation with N&lt;=1. You can just as easily claim that every <i>non</i>-nullable column is a 1:N relation where N==1 and &quot;should be encoded as such&quot;. It <i>is</i> encoded as such! That&#x27;s what a column <i>is</i>!</div><br/></div></div></div></div><div id="42651699" class="c"><input type="checkbox" id="c-42651699" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42648163">parent</a><span>|</span><a href="#42652133">prev</a><span>|</span><a href="#42647845">next</a><span>|</span><label class="collapse" for="c-42651699">[-]</label><label class="expand" for="c-42651699">[2 more]</label></div><br/><div class="children"><div class="content">Do you actually need that in a Boolean context? It would only be useful for evaluating self-referent claims like &quot;this sentence is false&quot;.</div><br/><div id="42652762" class="c"><input type="checkbox" id="c-42652762" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42651699">parent</a><span>|</span><a href="#42647845">next</a><span>|</span><label class="collapse" for="c-42652762">[-]</label><label class="expand" for="c-42652762">[1 more]</label></div><br/><div class="children"><div class="content">Your questions might be relevant if null were limited to boolean contexts.<p>It’s not.</div><br/></div></div></div></div></div></div></div></div><div id="42647845" class="c"><input type="checkbox" id="c-42647845" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42647290">parent</a><span>|</span><a href="#42647944">prev</a><span>|</span><a href="#42647573">next</a><span>|</span><label class="collapse" for="c-42647845">[-]</label><label class="expand" for="c-42647845">[6 more]</label></div><br/><div class="children"><div class="content">The result of comparisons involving NULL values can result[1][2] in UNKNOWN, and in PostgreSQL for example you can test[3] for this using IS UNKNOWN.<p>That said, as someone self-taught in SQL, I agree NULL was not a good choice.<p>Replacing NULL with UNKNOWN and the third boolean value as INDETERMINATE for example would have been better.<p>[1]: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;79270181" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;79270181</a><p>[2]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;t-sql&#x2F;language-elements&#x2F;null-and-unknown-transact-sql" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;t-sql&#x2F;language-element...</a><p>[3]: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;functions-comparison.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;functions-comparison...</a></div><br/><div id="42652091" class="c"><input type="checkbox" id="c-42652091" checked=""/><div class="controls bullet"><span class="by">labster</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647845">parent</a><span>|</span><a href="#42651602">next</a><span>|</span><label class="collapse" for="c-42652091">[-]</label><label class="expand" for="c-42652091">[2 more]</label></div><br/><div class="children"><div class="content">SQL was developed in the 1970s, there’s no way they’d waste all those bytes to spell out UNKNOWN and INDETERMINATE.</div><br/></div></div><div id="42651602" class="c"><input type="checkbox" id="c-42651602" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647845">parent</a><span>|</span><a href="#42652091">prev</a><span>|</span><a href="#42647573">next</a><span>|</span><label class="collapse" for="c-42651602">[-]</label><label class="expand" for="c-42651602">[3 more]</label></div><br/><div class="children"><div class="content">Also self-taught SQLer and I don&#x27;t have an issue with NULL.<p>I also don&#x27;t use UNIQUE constraints, so maybe that has something to do with it.</div><br/><div id="42653802" class="c"><input type="checkbox" id="c-42653802" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42651602">parent</a><span>|</span><a href="#42653739">next</a><span>|</span><label class="collapse" for="c-42653802">[-]</label><label class="expand" for="c-42653802">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have an issue as such, I was a fairly experienced developer first time I had to dabble with SQL, but sometimes it can still surprise.<p>For example I learned the hard way that the DB we use at work does not index NULL values.<p>And once in a while if I&#x27;m tired or stressed I might forget about UNKNOWN and thus that &quot;Col &lt;&gt; 42&quot; does not return rows where Col is NULL.<p>Not that better naming would prevent such surprises, but I still think the current naming is less than optimal from a pedagogical perspective. At least I see this at times when teaching our support folks SQL (many have domain background and not a technical background).</div><br/></div></div></div></div></div></div><div id="42647573" class="c"><input type="checkbox" id="c-42647573" checked=""/><div class="controls bullet"><span class="by">duncan-donuts</span><span>|</span><a href="#42647290">parent</a><span>|</span><a href="#42647845">prev</a><span>|</span><a href="#42647483">next</a><span>|</span><label class="collapse" for="c-42647573">[-]</label><label class="expand" for="c-42647573">[8 more]</label></div><br/><div class="children"><div class="content">Introducing “unknown” feels like another kind of hell like undefined in JavaScript.</div><br/><div id="42647670" class="c"><input type="checkbox" id="c-42647670" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647573">parent</a><span>|</span><a href="#42647483">next</a><span>|</span><label class="collapse" for="c-42647670">[-]</label><label class="expand" for="c-42647670">[7 more]</label></div><br/><div class="children"><div class="content">Just to clarify, I&#x27;m not advocating to introduce a new `unknown` keyword. I&#x27;m saying that the existing `null` in SQL was not named properly and that the name `unknown` would have been more fitting. SQL&#x27;s `null` already has the semantics of `unknown` as explained in the part of the article that I quoted.</div><br/><div id="42647903" class="c"><input type="checkbox" id="c-42647903" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647670">parent</a><span>|</span><a href="#42647483">next</a><span>|</span><label class="collapse" for="c-42647903">[-]</label><label class="expand" for="c-42647903">[6 more]</label></div><br/><div class="children"><div class="content">SQL&#x27;s use of &quot;null&quot; is probably one of the oldest instances of that concept in computing.  It&#x27;s exactly equivalent to unknown.  That is its definition.</div><br/><div id="42652147" class="c"><input type="checkbox" id="c-42652147" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647903">parent</a><span>|</span><a href="#42648942">next</a><span>|</span><label class="collapse" for="c-42652147">[-]</label><label class="expand" for="c-42652147">[1 more]</label></div><br/><div class="children"><div class="content">SQL NULL is not &quot;exactly equivalent&quot; to unknown. E.g. in an outer join, there&#x27;s nothing unknown about the result that is missing a row from one side, yet SQL semantics is to fill it with nulls.<p>In practice, it behaves as &quot;unknown&quot; in some contexts, as &quot;missing value&quot; in other contexts, and sometimes it&#x27;s just plain WTF like SUM() returning NULL rather than 0 if there are no rows.</div><br/></div></div><div id="42648942" class="c"><input type="checkbox" id="c-42648942" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647903">parent</a><span>|</span><a href="#42652147">prev</a><span>|</span><a href="#42647483">next</a><span>|</span><label class="collapse" for="c-42648942">[-]</label><label class="expand" for="c-42648942">[4 more]</label></div><br/><div class="children"><div class="content">Really? I know that SQL is old but I would have expected `null` to refer to pointers at first.<p>Going by Wikipedia, I see that SQL is from 1974 and C from 1972. Were there earlier uses&#x2F;drafts where `null` is &quot;unknown&quot; instead of &quot;unset&quot;?</div><br/><div id="42653294" class="c"><input type="checkbox" id="c-42653294" checked=""/><div class="controls bullet"><span class="by">floating-io</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42648942">parent</a><span>|</span><a href="#42649225">next</a><span>|</span><label class="collapse" for="c-42653294">[-]</label><label class="expand" for="c-42653294">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d also have to ask when NULL came into common use in C (to which I do not know the answer).  AFAIK NULL was not considered to be standard until C89.  As far as I&#x27;m aware, all C compilers implement it as a #define in a standard header somewhere; it&#x27;s not actually part of the core language itself.<p>I wonder who first added that macro?  Was it there from the beginning?<p>Just random thoughts...</div><br/></div></div><div id="42649225" class="c"><input type="checkbox" id="c-42649225" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42648942">parent</a><span>|</span><a href="#42653294">prev</a><span>|</span><a href="#42647483">next</a><span>|</span><label class="collapse" for="c-42649225">[-]</label><label class="expand" for="c-42649225">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t necessarily define `null` as &quot;unknown&quot; -- it&#x27;s just &quot;no value&quot; -- which is really the same thing and also somewhat equivalent to &quot;unset&quot;. But null pointers aren&#x27;t <i>unset</i> as pointers aren&#x27;t initialized to null in C and you can explicitly <i>set</i> a pointer to null.<p>E.F. Codd added nulls to relational model in 1970 so that does pre-date C.  The concept is even older than that I imagine.</div><br/><div id="42651926" class="c"><input type="checkbox" id="c-42651926" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42649225">parent</a><span>|</span><a href="#42647483">next</a><span>|</span><label class="collapse" for="c-42651926">[-]</label><label class="expand" for="c-42651926">[1 more]</label></div><br/><div class="children"><div class="content">In nth normal form, you can&#x27;t have &#x27;no value&#x27;.  That would mean your model is wrong.  In academic relational data books, null does mean &quot;unknown&quot;.  There is a value, we just don&#x27;t know what it is (yet).<p>If there might actually not be such a value, you&#x27;re supposed to change your schema to reflect that.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42647483" class="c"><input type="checkbox" id="c-42647483" checked=""/><div class="controls bullet"><span class="by">NoMoreNicksLeft</span><span>|</span><a href="#42647290">parent</a><span>|</span><a href="#42647573">prev</a><span>|</span><a href="#42652706">next</a><span>|</span><label class="collapse" for="c-42647483">[-]</label><label class="expand" for="c-42647483">[17 more]</label></div><br/><div class="children"><div class="content">&gt;also that since Postgresql 15, you can use `NULLS NOT DISTINCT` when creating a unique index [0]. I&#x27;m less familiar with other databases.<p>Why would anyone want to use another database?</div><br/><div id="42653315" class="c"><input type="checkbox" id="c-42653315" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647483">parent</a><span>|</span><a href="#42647525">next</a><span>|</span><label class="collapse" for="c-42653315">[-]</label><label class="expand" for="c-42653315">[1 more]</label></div><br/><div class="children"><div class="content">SQLite has its own use cases. And MySQL was all-around better than Postgres in the past, so it still has more usage in some areas. Nowadays I&#x27;ll take Postgres over MySQL by default, but it&#x27;s not a huge difference.</div><br/></div></div><div id="42647525" class="c"><input type="checkbox" id="c-42647525" checked=""/><div class="controls bullet"><span class="by">stronglikedan</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647483">parent</a><span>|</span><a href="#42653315">prev</a><span>|</span><a href="#42647964">next</a><span>|</span><label class="collapse" for="c-42647525">[-]</label><label class="expand" for="c-42647525">[13 more]</label></div><br/><div class="children"><div class="content">Simplicity. PG is often overkill for simple apps, where MySQL&#x2F;Maria&#x2F;et al is easier to maintain, or even SQLite for very simple apps where zero DB maintenance is preferable.</div><br/><div id="42648154" class="c"><input type="checkbox" id="c-42648154" checked=""/><div class="controls bullet"><span class="by">homebrewer</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647525">parent</a><span>|</span><a href="#42647615">next</a><span>|</span><label class="collapse" for="c-42648154">[-]</label><label class="expand" for="c-42648154">[1 more]</label></div><br/><div class="children"><div class="content">Also the reverse — MySQL et al support much more complex replication topologies out of the box, including multi master for the very rare use case when you need it.<p>It&#x27;s also much easier to tune, most database instances require setting innodb_buffer_pool_size, and that&#x27;s basically it. Newer versions can even set it automatically if you&#x27;re fine with consuming all memory on that machine, thus requiring no tuning at all.</div><br/></div></div><div id="42647615" class="c"><input type="checkbox" id="c-42647615" checked=""/><div class="controls bullet"><span class="by">lcnPylGDnU4H9OF</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647525">parent</a><span>|</span><a href="#42648154">prev</a><span>|</span><a href="#42647964">next</a><span>|</span><label class="collapse" for="c-42647615">[-]</label><label class="expand" for="c-42647615">[11 more]</label></div><br/><div class="children"><div class="content">Why would you say MySQL&#x2F;Maria&#x2F;et al are easier to maintain for simple apps than PG?</div><br/><div id="42647650" class="c"><input type="checkbox" id="c-42647650" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647615">parent</a><span>|</span><a href="#42647658">next</a><span>|</span><label class="collapse" for="c-42647650">[-]</label><label class="expand" for="c-42647650">[5 more]</label></div><br/><div class="children"><div class="content">The main pain point for smaller apps is that every major Postgres version requires an explicit migration of the underlying data representation. I get why it&#x27;s there, but for simpler apps I would appreciate a flag to do it transparently.</div><br/><div id="42647807" class="c"><input type="checkbox" id="c-42647807" checked=""/><div class="controls bullet"><span class="by">throwaway10235</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647650">parent</a><span>|</span><a href="#42647658">next</a><span>|</span><label class="collapse" for="c-42647807">[-]</label><label class="expand" for="c-42647807">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you mean. I have migrated versions without having to update any applications that connects to it?<p>Maybe it is a driver specific issue? I have used Python&#x2F;Java, and haven&#x27;t updated any of my code or dependencies because of a major Postgre update</div><br/><div id="42648762" class="c"><input type="checkbox" id="c-42648762" checked=""/><div class="controls bullet"><span class="by">Volundr</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647807">parent</a><span>|</span><a href="#42648126">next</a><span>|</span><label class="collapse" for="c-42648762">[-]</label><label class="expand" for="c-42648762">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not client side, it&#x27;s server side. The binary format between Postgres major versions is generally not compatible so you need to do a pg_dump from the old database and do a pg_restore into the new one. pg_upgrade [1] can let you bypass this by migrating the binary data directly, but still requires having both the new and old postgres versions installed. There&#x27;s also things you can do with replication, but since we&#x27;re talking simplicity I don&#x27;t think that really applies.<p>Personally I think upgrades are the one thing MySQL has on Postgres at this point.<p>[1] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;pgupgrade.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;pgupgrade.html</a></div><br/></div></div><div id="42648126" class="c"><input type="checkbox" id="c-42648126" checked=""/><div class="controls bullet"><span class="by">homebrewer</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647807">parent</a><span>|</span><a href="#42648762">prev</a><span>|</span><a href="#42648386">next</a><span>|</span><label class="collapse" for="c-42648126">[-]</label><label class="expand" for="c-42648126">[1 more]</label></div><br/><div class="children"><div class="content">It requires manual interventions because the upgrade process is basically dump + restore. MySQL and MariaDB upgrade between major versions automatically — you simply install the next version (or change the version tag in your container definition) and restart the server.<p>Usually it takes almost no time, altought might be just as slow as PG when major changes to the data format are introduced. The only example I can remember is 8.0 when oracle completely rewrote the data format (making things like atomic ddl possible).</div><br/></div></div><div id="42648386" class="c"><input type="checkbox" id="c-42648386" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647807">parent</a><span>|</span><a href="#42648126">prev</a><span>|</span><a href="#42647658">next</a><span>|</span><label class="collapse" for="c-42648386">[-]</label><label class="expand" for="c-42648386">[1 more]</label></div><br/><div class="children"><div class="content">You need to dump the database on the old PostgreSQL version and then load the dump on the new PostgreSQL version. Some other database servers can just use the old table data or migrate the data files on the fly transparently.</div><br/></div></div></div></div></div></div><div id="42647658" class="c"><input type="checkbox" id="c-42647658" checked=""/><div class="controls bullet"><span class="by">phplovesong</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647615">parent</a><span>|</span><a href="#42647650">prev</a><span>|</span><a href="#42652058">next</a><span>|</span><label class="collapse" for="c-42647658">[-]</label><label class="expand" for="c-42647658">[1 more]</label></div><br/><div class="children"><div class="content">Usually its a skill issue</div><br/></div></div><div id="42647814" class="c"><input type="checkbox" id="c-42647814" checked=""/><div class="controls bullet"><span class="by">badlibrarian</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647615">parent</a><span>|</span><a href="#42652058">prev</a><span>|</span><a href="#42647964">next</a><span>|</span><label class="collapse" for="c-42647814">[-]</label><label class="expand" for="c-42647814">[3 more]</label></div><br/><div class="children"><div class="content">VACUUM</div><br/><div id="42648210" class="c"><input type="checkbox" id="c-42648210" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647814">parent</a><span>|</span><a href="#42647964">next</a><span>|</span><label class="collapse" for="c-42648210">[-]</label><label class="expand" for="c-42648210">[2 more]</label></div><br/><div class="children"><div class="content">If your data&#x27;s large and changing enough that you have to care about vacuuming, <i>any</i> reasonable database is going to require some tuning, tending and management.<p>I&#x27;d posit that only a tiny fraction of PostgreSQL uses have to know or care that vacuuming is a thing because the autovacuum default handle it for them.</div><br/><div id="42649472" class="c"><input type="checkbox" id="c-42649472" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42648210">parent</a><span>|</span><a href="#42647964">next</a><span>|</span><label class="collapse" for="c-42649472">[-]</label><label class="expand" for="c-42649472">[1 more]</label></div><br/><div class="children"><div class="content">Sure, it&#x27;s never going to be plug and play, but it doesn&#x27;t mean that all the issues will be equivalent. Vacuuming doesn&#x27;t really have an equivalent in say, MySQL. It&#x27;s something you don&#x27;t have to worry about if you use the latter.<p>For example, HA and clustering will always be challenging to deploy&#x2F;maintain, but you will still have a harder time doing that with postgres than with MySQL. Postgres also has a lot of benefits obviously, though.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42647964" class="c"><input type="checkbox" id="c-42647964" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647483">parent</a><span>|</span><a href="#42647525">prev</a><span>|</span><a href="#42647659">next</a><span>|</span><label class="collapse" for="c-42647964">[-]</label><label class="expand" for="c-42647964">[1 more]</label></div><br/><div class="children"><div class="content">* legacy applications or vendor lock-in<p>* use of a cloud provider that favours another database (like SQL server)<p>* some people claim mysql&#x2F;maria is faster for them, simpler, or has a better support for replication<p>* use of sqlite for lightweight or portable apps<p>* domain specific databases that still use sql as their query language<p>* someone may want to use another database for fun or to learn something new</div><br/></div></div><div id="42647659" class="c"><input type="checkbox" id="c-42647659" checked=""/><div class="controls bullet"><span class="by">password4321</span><span>|</span><a href="#42647290">root</a><span>|</span><a href="#42647483">parent</a><span>|</span><a href="#42647964">prev</a><span>|</span><a href="#42652706">next</a><span>|</span><label class="collapse" for="c-42647659">[-]</label><label class="expand" for="c-42647659">[1 more]</label></div><br/><div class="children"><div class="content">Replication</div><br/></div></div></div></div></div></div><div id="42652706" class="c"><input type="checkbox" id="c-42652706" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#42647290">prev</a><span>|</span><a href="#42647986">next</a><span>|</span><label class="collapse" for="c-42652706">[-]</label><label class="expand" for="c-42652706">[7 more]</label></div><br/><div class="children"><div class="content">In Object Oriented Context &quot;null&quot;  is useful to indicate that some object doesn&#x27;t have value for that property.<p>What&#x27;s interesting is, do we mean that in our data that attribute has no value? Or do we mean the real-world object represented by the data does not have that attribute?<p>Does null mean<p>a) We don&#x27;t know the value of this attribute 
   for this object, or<p>b) We do know that there is no value for this
   attribute in the real-world object 
   represented by our data.<p>In JavaScript because there is both null and undefined it is easy to assume that undefined means we don&#x27;t know the value and null means we do know it has no value.<p>EXAMPLE:
The attribute &#x27;spouse&#x27;. Some people have a spouse some don&#x27;t. So what does it mean if the value of the field &#x27;spouse&#x27; is null? That we know there is no spouse, or that we don&#x27;t know who the spouse is if any.<p>In practical terms we can say null means &quot;We don&#x27;t know&quot; which includes the case that there is no spouse.</div><br/><div id="42653125" class="c"><input type="checkbox" id="c-42653125" checked=""/><div class="controls bullet"><span class="by">mnsc</span><span>|</span><a href="#42652706">parent</a><span>|</span><a href="#42652759">next</a><span>|</span><label class="collapse" for="c-42653125">[-]</label><label class="expand" for="c-42653125">[1 more]</label></div><br/><div class="children"><div class="content">But in a _relational_ database lack of spouse would not be modeled with a nullable column &quot;spouse&quot; but rather an absence of a spouse row&#x2F;relation. Which is very real-world-like.</div><br/></div></div><div id="42652759" class="c"><input type="checkbox" id="c-42652759" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#42652706">parent</a><span>|</span><a href="#42653125">prev</a><span>|</span><a href="#42653563">next</a><span>|</span><label class="collapse" for="c-42652759">[-]</label><label class="expand" for="c-42652759">[3 more]</label></div><br/><div class="children"><div class="content">I remember from my databases course at university that NULL means that the database doesn&#x27;t contain that data, and empty string means that it is <i>known</i> to be empty.</div><br/><div id="42653695" class="c"><input type="checkbox" id="c-42653695" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#42652706">root</a><span>|</span><a href="#42652759">parent</a><span>|</span><a href="#42653036">next</a><span>|</span><label class="collapse" for="c-42653695">[-]</label><label class="expand" for="c-42653695">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s your professor&#x27;s opinion, and probably one that does not come from industry experience. Look in 4 different databases and you&#x27;ll see 9 different conventions. A common one is to have all strings non-null with a default value of empty string. And not all columns are strings; there is no &quot;obviously empty&quot; integer or boolean.</div><br/></div></div><div id="42653036" class="c"><input type="checkbox" id="c-42653036" checked=""/><div class="controls bullet"><span class="by">niij</span><span>|</span><a href="#42652706">root</a><span>|</span><a href="#42652759">parent</a><span>|</span><a href="#42653695">prev</a><span>|</span><a href="#42653563">next</a><span>|</span><label class="collapse" for="c-42653036">[-]</label><label class="expand" for="c-42653036">[1 more]</label></div><br/><div class="children"><div class="content">What is the type is something other than a string?<p>age: null?
married: null?</div><br/></div></div></div></div><div id="42653563" class="c"><input type="checkbox" id="c-42653563" checked=""/><div class="controls bullet"><span class="by">bogeholm</span><span>|</span><a href="#42652706">parent</a><span>|</span><a href="#42652759">prev</a><span>|</span><a href="#42652815">next</a><span>|</span><label class="collapse" for="c-42653563">[-]</label><label class="expand" for="c-42653563">[1 more]</label></div><br/><div class="children"><div class="content">How about Option&lt;bool&gt; for that? In SQL you could have a nullable Boolean column</div><br/></div></div></div></div><div id="42647986" class="c"><input type="checkbox" id="c-42647986" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#42652706">prev</a><span>|</span><a href="#42652769">next</a><span>|</span><label class="collapse" for="c-42647986">[-]</label><label class="expand" for="c-42647986">[6 more]</label></div><br/><div class="children"><div class="content">&gt; ... and this is even less obvious if you’re used to using ORMs.<p>Which is why I continue to be such an ORM skeptic. I agree that they&#x27;re convenient. But I do worry that we&#x27;ve now got an entire generation of engineers who regularly interact with relational databases, but have largely been spared the effort of learning how they actually work.<p>As another commenter pointed out, if you&#x27;ve learned basic relational algebra then the way SQL nulls behave seems obvious and logically consistent. The logic is the same as the logic behind the comparison rules for NaN in IEEE floats. It&#x27;s the behavior of C-style nulls that is, always and forever, a billion-dollar mistake.</div><br/><div id="42653770" class="c"><input type="checkbox" id="c-42653770" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#42647986">parent</a><span>|</span><a href="#42653318">next</a><span>|</span><label class="collapse" for="c-42653770">[-]</label><label class="expand" for="c-42653770">[1 more]</label></div><br/><div class="children"><div class="content">Stop thinking of ORMs as trying to hide the details of SQL and you&#x27;ll stop hating them. Instead think of them as a way to compose relational queries dynamically, with the full power of your primary language, instead of inside of database stored procedures in a language totally devoid of any support for basic software engineering best practices. They shouldn&#x27;t be <i>hiding</i> SQL from your primary language, they should be <i>exposing</i> the relational model to it! SQL is not the only possible implementation of the relational model, and it&#x27;s not even a particularly <i>good</i> one. Even SQL&#x27;s founders don&#x27;t think it implements EF Codd&#x27;s relational model very faithfully. Good ORMs act as a domain-specific language for the relational model embedded inside the parent language.</div><br/></div></div><div id="42653318" class="c"><input type="checkbox" id="c-42653318" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#42647986">parent</a><span>|</span><a href="#42653770">prev</a><span>|</span><a href="#42648345">next</a><span>|</span><label class="collapse" for="c-42653318">[-]</label><label class="expand" for="c-42653318">[1 more]</label></div><br/><div class="children"><div class="content">If you can avoid learning SQL or the underlying DBMS then great, I have no problem with people ignoring things that are ignore-able. Problem is you can&#x27;t. You will need to learn the DBMS, and the ORM will end up just getting in the way of what you really want to do.</div><br/></div></div><div id="42648345" class="c"><input type="checkbox" id="c-42648345" checked=""/><div class="controls bullet"><span class="by">thrance</span><span>|</span><a href="#42647986">parent</a><span>|</span><a href="#42653318">prev</a><span>|</span><a href="#42652769">next</a><span>|</span><label class="collapse" for="c-42648345">[-]</label><label class="expand" for="c-42648345">[3 more]</label></div><br/><div class="children"><div class="content">My experience with ORMs is that most of the time you end up needing to write <i>some</i> queries by hand, in raw SQL. Usually these are the most complex, that you can&#x27;t express in your ORM&#x27;s DSL. My point being, I don&#x27;t think using an ORM really shields you from having to learn how it works behind the scenes.</div><br/><div id="42653536" class="c"><input type="checkbox" id="c-42653536" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42647986">root</a><span>|</span><a href="#42648345">parent</a><span>|</span><a href="#42652769">next</a><span>|</span><label class="collapse" for="c-42653536">[-]</label><label class="expand" for="c-42653536">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not even about having to write SQL by hand. In an ORM like Django that&#x27;s exceedingly rare. But you <i>still</i> need to understand what&#x27;s going on underneath. In other words, it&#x27;s the most leaky abstraction there is. I think the popularity is mostly aesthetic and convenience. Most people into ORMs like Django don&#x27;t really know about layered architecture and that you can keep all your SQL in one place in the data access layer. They just scatter that stuff everywhere in the codebase.</div><br/><div id="42653756" class="c"><input type="checkbox" id="c-42653756" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#42647986">root</a><span>|</span><a href="#42653536">parent</a><span>|</span><a href="#42652769">next</a><span>|</span><label class="collapse" for="c-42653756">[-]</label><label class="expand" for="c-42653756">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know Django specifically but I&#x27;m always floored by how people talk about ORMs. They&#x27;re only a leaky abstraction if you believe their point is to shield terrified junior devs of the inner workings of the scary relational database. That&#x27;s an awful way to use ORMs, and the source of most of the flak they get. To be fair, some are designed that way, or at least strongly push you toward it.<p>Stop thinking of ORMs as trying to hide the details of SQL and you&#x27;ll stop hating them. Instead think of them as a way to <i>compose</i> SQL dynamically, with the full power of your language. SQL is an <i>awful</i> language to write application logic in, because it has horrible support for abstraction, composition, encapsulation, dependency injection, etc. The ORM gives you a way to produce SQL in an environment that actually supports basic software engineering principles. Scattering ORM logic everywhere in the codebase is <i>the point</i>: putting all your SQL in one data access layer is like putting all your arithmetic in one calculation layer. Why would you ever do that? What&#x27;s wrong with seeing a plus sign in more than one file? What&#x27;s wrong with seeing language-encoded relational logic in more than one file?<p>I can guarantee you the popularity is not &quot;aesthetic&quot;. And convenience is a real thing that actually does reduce costs. People complain about ORMs, but have you seen the absolute horse-shit-level code that people jam into SQL functions and procedures to do the utterly most basic things? The standard for what ends up in SQL Stored procedures is the most unmaintainable garbage in the entire software engineering ecosystem.</div><br/></div></div></div></div></div></div></div></div><div id="42652769" class="c"><input type="checkbox" id="c-42652769" checked=""/><div class="controls bullet"><span class="by">branko_d</span><span>|</span><a href="#42647986">prev</a><span>|</span><a href="#42652083">next</a><span>|</span><label class="collapse" for="c-42652769">[-]</label><label class="expand" for="c-42652769">[1 more]</label></div><br/><div class="children"><div class="content">NULLs are weird because they are basically two different types under the same name. The 3-value logic type is useful for representing &quot;missing&quot; foreign keys, but 2-value logic type is arguably more useful when searching&#x2F;sorting&#x2F;aggregating.<p>I think we would have been better-off by treating FKs (and maybe outer JOINs) as a special case, and using 2-value logic everywhere else.</div><br/></div></div><div id="42652083" class="c"><input type="checkbox" id="c-42652083" checked=""/><div class="controls bullet"><span class="by">lolpanda</span><span>|</span><a href="#42652769">prev</a><span>|</span><a href="#42647456">next</a><span>|</span><label class="collapse" for="c-42652083">[-]</label><label class="expand" for="c-42652083">[4 more]</label></div><br/><div class="children"><div class="content">I actually like how NULLs behave in SQL. They mean &quot;I don&#x27;t know&quot; In the modern programming language we all care about Null safety. But no matter how you model your data, you will always run into the situations when you don&#x27;t know everything. So I believe NOT NULL is not very practical. NULLs in SQL handle these case very well - when the input is unknown your output is unknown</div><br/><div id="42652118" class="c"><input type="checkbox" id="c-42652118" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42652083">parent</a><span>|</span><a href="#42652098">next</a><span>|</span><label class="collapse" for="c-42652118">[-]</label><label class="expand" for="c-42652118">[1 more]</label></div><br/><div class="children"><div class="content">Except they don&#x27;t consistently behave that way. If NULL means &quot;unknown&quot;, why do they show up in outer joins, or when you SUM an empty table?</div><br/></div></div><div id="42652098" class="c"><input type="checkbox" id="c-42652098" checked=""/><div class="controls bullet"><span class="by">dalton_zk</span><span>|</span><a href="#42652083">parent</a><span>|</span><a href="#42652118">prev</a><span>|</span><a href="#42652241">next</a><span>|</span><label class="collapse" for="c-42652098">[-]</label><label class="expand" for="c-42652098">[1 more]</label></div><br/><div class="children"><div class="content">I feel like the same, Null equal null is null is totally right</div><br/></div></div><div id="42652241" class="c"><input type="checkbox" id="c-42652241" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#42652083">parent</a><span>|</span><a href="#42652098">prev</a><span>|</span><a href="#42647456">next</a><span>|</span><label class="collapse" for="c-42652241">[-]</label><label class="expand" for="c-42652241">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. If SQL didn&#x27;t have NULL, we&#x27;d have other special values meaning &quot;I don&#x27;t know&quot; or &quot;no data&quot; all over the place.<p>Too many newbies hear that NULL is bad, so they declare all columns as NOT NULL and end up inserting ad hoc values like 0, -1, &#x27;&#x27;, or {} when they inevitably come across cases where they don&#x27;t have data. Which is even worse than NULL.</div><br/></div></div></div></div><div id="42647456" class="c"><input type="checkbox" id="c-42647456" checked=""/><div class="controls bullet"><span class="by">irrational</span><span>|</span><a href="#42652083">prev</a><span>|</span><a href="#42647504">next</a><span>|</span><label class="collapse" for="c-42647456">[-]</label><label class="expand" for="c-42647456">[4 more]</label></div><br/><div class="children"><div class="content">I expected the article to mention how in Oracle NULLs are equal to empty strings. Now that is weird.</div><br/><div id="42648978" class="c"><input type="checkbox" id="c-42648978" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#42647456">parent</a><span>|</span><a href="#42647517">next</a><span>|</span><label class="collapse" for="c-42648978">[-]</label><label class="expand" for="c-42648978">[2 more]</label></div><br/><div class="children"><div class="content">Oh man.  I had a talk with a DBA about how oracle could not deal with an adress with no street name - literally a tiny village with 10 houses on 1 nameless town square.  It was unsearchable in parts of the app because street=&#x27;&#x27; was interpreted as street is null.  DBA kept claiming oracle was right and the town should adapt their naming to our software.<p>This attitude was so prevalent at the time, I sometimes wonder if the rise of noSQL was simply people sick of dealing with Oracle DBAs</div><br/><div id="42653430" class="c"><input type="checkbox" id="c-42653430" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42647456">root</a><span>|</span><a href="#42648978">parent</a><span>|</span><a href="#42647517">next</a><span>|</span><label class="collapse" for="c-42653430">[-]</label><label class="expand" for="c-42653430">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This attitude was so prevalent at the time, I sometimes wonder if the rise of noSQL was simply people sick of dealing with Oracle DBAs<p>That was definitely one part; another part was sharp corners in MySQL (at least as of 20 years ago; I would be surprised if many of them haven&#x27;t been rounded off in the meantime).  The last part was places with <i>no</i> DBA with developers unaware of how to handle schema migrations.</div><br/></div></div></div></div><div id="42647517" class="c"><input type="checkbox" id="c-42647517" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#42647456">parent</a><span>|</span><a href="#42648978">prev</a><span>|</span><a href="#42647504">next</a><span>|</span><label class="collapse" for="c-42647517">[-]</label><label class="expand" for="c-42647517">[1 more]</label></div><br/><div class="children"><div class="content">Domain-embedded nulls are the bane of my existence.</div><br/></div></div></div></div><div id="42647504" class="c"><input type="checkbox" id="c-42647504" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#42647456">prev</a><span>|</span><a href="#42653561">next</a><span>|</span><label class="collapse" for="c-42647504">[-]</label><label class="expand" for="c-42647504">[8 more]</label></div><br/><div class="children"><div class="content">SQL NULLs are not weird once you consider how you want relational logic to work when they is a record with non-existent values.</div><br/><div id="42647548" class="c"><input type="checkbox" id="c-42647548" checked=""/><div class="controls bullet"><span class="by">grahamlee</span><span>|</span><a href="#42647504">parent</a><span>|</span><a href="#42647843">next</a><span>|</span><label class="collapse" for="c-42647548">[-]</label><label class="expand" for="c-42647548">[3 more]</label></div><br/><div class="children"><div class="content">Exactly this. SQL is based on the relational algebra and that&#x27;s well-defined, NULL along with other features of SQL work in an entirely regular and predictable way. The only time it&#x27;s weird is when a developer decides that it should work the way Javascript (or whatever) NULLs work because that&#x27;s the last time they saw the same word used in a programming language, in which case it&#x27;s the assumption that&#x27;s weird.</div><br/><div id="42648655" class="c"><input type="checkbox" id="c-42648655" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#42647504">root</a><span>|</span><a href="#42647548">parent</a><span>|</span><a href="#42647971">next</a><span>|</span><label class="collapse" for="c-42648655">[-]</label><label class="expand" for="c-42648655">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the only time it is weird. There&#x27;s even a whole book by one of the pioneers of the relational DB model, Date&#x27;s &quot;Database Technology: Nulls Considered Harmful&quot; [1], covering many of the ways it is weird.<p>[1] <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Database-Technology-Nulls-Considered-Harmful&#x2F;dp&#x2F;1634624769" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Database-Technology-Nulls-Considered-...</a></div><br/></div></div><div id="42647971" class="c"><input type="checkbox" id="c-42647971" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#42647504">root</a><span>|</span><a href="#42647548">parent</a><span>|</span><a href="#42648655">prev</a><span>|</span><a href="#42647843">next</a><span>|</span><label class="collapse" for="c-42647971">[-]</label><label class="expand" for="c-42647971">[1 more]</label></div><br/><div class="children"><div class="content">The part that’s weird with nulls is that it’s a trinary logic stuffed into a boolean algebra. The use of x = NULL instead of x IS NULL is pretty much always a mistake.<p>More importantly, x = value instead of (x = value and x IS NOT NULL) is almost always a mistake, and a stupidly subtle one at that. And for this curse, we get… nothing particularly useful from these semantics.<p>Also the x != NULL case is completely cursed</div><br/></div></div></div></div><div id="42647843" class="c"><input type="checkbox" id="c-42647843" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#42647504">parent</a><span>|</span><a href="#42647548">prev</a><span>|</span><a href="#42653561">next</a><span>|</span><label class="collapse" for="c-42647843">[-]</label><label class="expand" for="c-42647843">[4 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>I will die on the hill that regular C-like nulls are the actual thing that&#x27;s weird.<p>The real billion dollar mistake [1] was the damage it made on the minds of developers.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tony_Hoare" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tony_Hoare</a></div><br/><div id="42648096" class="c"><input type="checkbox" id="c-42648096" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#42647504">root</a><span>|</span><a href="#42647843">parent</a><span>|</span><a href="#42647987">next</a><span>|</span><label class="collapse" for="c-42648096">[-]</label><label class="expand" for="c-42648096">[2 more]</label></div><br/><div class="children"><div class="content">Even null in programming languages isn&#x27;t so bad if it&#x27;s a distinct type.  The problem with null in languages like Java is that null is part of <i>every</i> reference type (C&#x27;s pointers are another world of broken, null being basically just another unsafe invalid address).<p>Most languages nowadays do get nulls right, even PHP of all things.</div><br/><div id="42653195" class="c"><input type="checkbox" id="c-42653195" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#42647504">root</a><span>|</span><a href="#42648096">parent</a><span>|</span><a href="#42647987">next</a><span>|</span><label class="collapse" for="c-42653195">[-]</label><label class="expand" for="c-42653195">[1 more]</label></div><br/><div class="children"><div class="content">&gt;unsafe invalid address<p>Ironically NULL is probably the safest pointer value in C, as any dereferences from it (and thousands of pages that follow it) are guaranteed to crash.</div><br/></div></div></div></div><div id="42647987" class="c"><input type="checkbox" id="c-42647987" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#42647504">root</a><span>|</span><a href="#42647843">parent</a><span>|</span><a href="#42648096">prev</a><span>|</span><a href="#42653561">next</a><span>|</span><label class="collapse" for="c-42647987">[-]</label><label class="expand" for="c-42647987">[1 more]</label></div><br/><div class="children"><div class="content">We should start adjusting that billion for inflation.</div><br/></div></div></div></div></div></div><div id="42653561" class="c"><input type="checkbox" id="c-42653561" checked=""/><div class="controls bullet"><span class="by">qwertydog</span><span>|</span><a href="#42647504">prev</a><span>|</span><a href="#42647435">next</a><span>|</span><label class="collapse" for="c-42653561">[-]</label><label class="expand" for="c-42653561">[1 more]</label></div><br/><div class="children"><div class="content">SQL NULL is also coerced to different boolean values depending on context e.g. in a WHERE clause NULL is coerced to false, whereas in a CHECK constraint NULL is coerced to true<p><a href="https:&#x2F;&#x2F;dbfiddle.uk&#x2F;C5JqMP8O" rel="nofollow">https:&#x2F;&#x2F;dbfiddle.uk&#x2F;C5JqMP8O</a></div><br/></div></div><div id="42647435" class="c"><input type="checkbox" id="c-42647435" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#42653561">prev</a><span>|</span><a href="#42651648">next</a><span>|</span><label class="collapse" for="c-42647435">[-]</label><label class="expand" for="c-42647435">[9 more]</label></div><br/><div class="children"><div class="content">SQL nulls in some ways behave in similar to floating point nans. Of course nans are also weird in their own way, but it is a bit comforting that its not so completely singularly weird.</div><br/><div id="42647728" class="c"><input type="checkbox" id="c-42647728" checked=""/><div class="controls bullet"><span class="by">dunham</span><span>|</span><a href="#42647435">parent</a><span>|</span><a href="#42647833">next</a><span>|</span><label class="collapse" for="c-42647728">[-]</label><label class="expand" for="c-42647728">[1 more]</label></div><br/><div class="children"><div class="content">Also similar to the bottom value in haskell and exceptions in other languages.</div><br/></div></div><div id="42647833" class="c"><input type="checkbox" id="c-42647833" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#42647435">parent</a><span>|</span><a href="#42647728">prev</a><span>|</span><a href="#42651648">next</a><span>|</span><label class="collapse" for="c-42647833">[-]</label><label class="expand" for="c-42647833">[7 more]</label></div><br/><div class="children"><div class="content">NaN is cool because it&#x27;s almost like a type that constrains uncertainty. What do we know about this entity? not much! but it&#x27;s definitely not a number. Calling it anything else would have been a mistake.<p>Null is more confusing because it means different things in different languages. Sometimes it&#x27;s a more constrained uncertainty, eg this definitely doesn&#x27;t exist. But in sql it&#x27;s a less constrained uncertainty, like &quot;undefined&quot; in math. The value of this thing couldn&#x27;t make sense in this context, but we can&#x27;t make assertions about its existence.</div><br/><div id="42648261" class="c"><input type="checkbox" id="c-42648261" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#42647435">root</a><span>|</span><a href="#42647833">parent</a><span>|</span><a href="#42648285">next</a><span>|</span><label class="collapse" for="c-42648261">[-]</label><label class="expand" for="c-42648261">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another comment in here that talks about thinking of NULL as UNKNOWN, and I quite like that. It makes a lot more sense, and I think it would&#x27;ve been a better choice to standardize on. UNDEFINED would also be an improvement.</div><br/><div id="42651977" class="c"><input type="checkbox" id="c-42651977" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#42647435">root</a><span>|</span><a href="#42648261">parent</a><span>|</span><a href="#42648285">next</a><span>|</span><label class="collapse" for="c-42651977">[-]</label><label class="expand" for="c-42651977">[4 more]</label></div><br/><div class="children"><div class="content">UNDEFINED would not be accurate. If your signup form has an optional field for a full name which I don’t fill in, I still have a name. Just because a value is not known by your database doesn’t mean it isn’t defined.<p>E. F. Codd thought about this issue.[0]<p>&gt; Codd indicated in his 1990 book The Relational Model for Database Management, Version 2 that the single Null mandated by the SQL standard was inadequate, and should be replaced by two separate Null-type markers to indicate why data is missing. In Codd&#x27;s book, these two Null-type markers are referred to as &#x27;A-Values&#x27; and &#x27;I-Values&#x27;, representing &#x27;Missing But Applicable&#x27; and &#x27;Missing But Inapplicable&#x27;, respectively. Codd&#x27;s recommendation would have required SQL&#x27;s logic system be expanded to accommodate a four-valued logic system. Because of this additional complexity, the idea of multiple Nulls with different definitions has not gained widespread acceptance in the database practitioners&#x27; domain. It remains an active field of research though, with numerous papers still being published.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Null_(SQL)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Null_(SQL)</a></div><br/><div id="42653503" class="c"><input type="checkbox" id="c-42653503" checked=""/><div class="controls bullet"><span class="by">benzayb</span><span>|</span><a href="#42647435">root</a><span>|</span><a href="#42651977">parent</a><span>|</span><a href="#42652805">next</a><span>|</span><label class="collapse" for="c-42653503">[-]</label><label class="expand" for="c-42653503">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If your signup form has an optional field for a full name which I don’t fill in, I still have a name. Just because a value is not known by your database doesn’t mean it isn’t defined.<p>There&#x27;s the Closed World Assumption in a database.</div><br/></div></div><div id="42652805" class="c"><input type="checkbox" id="c-42652805" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42647435">root</a><span>|</span><a href="#42651977">parent</a><span>|</span><a href="#42653503">prev</a><span>|</span><a href="#42648285">next</a><span>|</span><label class="collapse" for="c-42652805">[-]</label><label class="expand" for="c-42652805">[2 more]</label></div><br/><div class="children"><div class="content">&gt; UNDEFINED would not be accurate. If your signup form has an optional field for a full name which I don’t fill in, I still have a name.<p>If your signup form has an optional field for middle name which I don’t fill, it can absolutely be because I don’t have a middle name. It’s undefined and known to be so.<p>&gt; E. F. Codd thought about this issue.[0]<p>And <i>because</i> four value logic was left out, nulls have to fulfil multiple incompatible roles, and ends up being weird.</div><br/><div id="42653130" class="c"><input type="checkbox" id="c-42653130" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#42647435">root</a><span>|</span><a href="#42652805">parent</a><span>|</span><a href="#42648285">next</a><span>|</span><label class="collapse" for="c-42653130">[-]</label><label class="expand" for="c-42653130">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If your signup form has an optional field for middle name which I don’t fill, it can absolutely be because I don’t have a middle name.<p>The fact that <i>some</i> NULLs are indeed undefined doesn’t contradict my point that it would be inaccurate to refer to <i>all</i> NULLs as UNDEFINED.<p>&gt; It’s undefined and known to be so… And <i>because</i> four value logic was left out, nulls have to fulfil multiple incompatible roles, and ends up being weird.<p><i>You</i> know it to be undefined, but if you just leave that field blank on the form, the <i>database</i> still can’t know whether that’s because you don’t have one or because you didn’t provide the one you have, unless there was a field on the form that allowed you to explicitly indicate that you don’t have one.</div><br/></div></div></div></div></div></div></div></div><div id="42648285" class="c"><input type="checkbox" id="c-42648285" checked=""/><div class="controls bullet"><span class="by">adhamsalama</span><span>|</span><a href="#42647435">root</a><span>|</span><a href="#42647833">parent</a><span>|</span><a href="#42648261">prev</a><span>|</span><a href="#42651648">next</a><span>|</span><label class="collapse" for="c-42648285">[-]</label><label class="expand" for="c-42648285">[1 more]</label></div><br/><div class="children"><div class="content">Except it is of type number, at least in JavaScript.</div><br/></div></div></div></div></div></div><div id="42651648" class="c"><input type="checkbox" id="c-42651648" checked=""/><div class="controls bullet"><span class="by">Recursing</span><span>|</span><a href="#42647435">prev</a><span>|</span><a href="#42653306">next</a><span>|</span><label class="collapse" for="c-42651648">[-]</label><label class="expand" for="c-42651648">[2 more]</label></div><br/><div class="children"><div class="content">Surprised that this doesn&#x27;t mention &quot;IS DISTINCT FROM&quot; ( <a href="https:&#x2F;&#x2F;modern-sql.com&#x2F;caniuse&#x2F;is-distinct-from" rel="nofollow">https:&#x2F;&#x2F;modern-sql.com&#x2F;caniuse&#x2F;is-distinct-from</a> )<p>(Although in rare cases that is even weirder: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;58998043" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;58998043</a> )</div><br/><div id="42651757" class="c"><input type="checkbox" id="c-42651757" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#42651648">parent</a><span>|</span><a href="#42653306">next</a><span>|</span><label class="collapse" for="c-42651757">[-]</label><label class="expand" for="c-42651757">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad SQL Server finally got this, but I wish the syntax was nicer. It&#x27;s a multi-word infix operator that gets tough to read. I&#x27;ve been using Snowflake SQL recently and I like that they just made it a function called EQUAL_NULL</div><br/></div></div></div></div><div id="42653306" class="c"><input type="checkbox" id="c-42653306" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#42651648">prev</a><span>|</span><a href="#42648155">next</a><span>|</span><label class="collapse" for="c-42653306">[-]</label><label class="expand" for="c-42653306">[1 more]</label></div><br/><div class="children"><div class="content">Weird as they seem at first, SQL null handling ends up being convenient the way it is. Part of this is because left&#x2F;right join give you nulls.</div><br/></div></div><div id="42648155" class="c"><input type="checkbox" id="c-42648155" checked=""/><div class="controls bullet"><span class="by">kurtbuilds</span><span>|</span><a href="#42653306">prev</a><span>|</span><a href="#42651726">next</a><span>|</span><label class="collapse" for="c-42648155">[-]</label><label class="expand" for="c-42648155">[2 more]</label></div><br/><div class="children"><div class="content">If you want equality testing with nulls, you want to use `is (not) distinct from` instead of `=` and `&lt;&gt;` &#x2F; `!=`.<p>`1 is not distinct from NULL` =&gt; false<p>`NULL is not distinct from NULL` =&gt; true<p>`0 is not distinct from 1` =&gt; false</div><br/><div id="42651574" class="c"><input type="checkbox" id="c-42651574" checked=""/><div class="controls bullet"><span class="by">blast</span><span>|</span><a href="#42648155">parent</a><span>|</span><a href="#42651726">next</a><span>|</span><label class="collapse" for="c-42651574">[-]</label><label class="expand" for="c-42651574">[1 more]</label></div><br/><div class="children"><div class="content">Having that is much better than not having it, but man is it verbose and confusing.</div><br/></div></div></div></div><div id="42651726" class="c"><input type="checkbox" id="c-42651726" checked=""/><div class="controls bullet"><span class="by">tzury</span><span>|</span><a href="#42648155">prev</a><span>|</span><a href="#42652268">next</a><span>|</span><label class="collapse" for="c-42651726">[-]</label><label class="expand" for="c-42651726">[1 more]</label></div><br/><div class="children"><div class="content">For Postgres specific approach, you may refer to<p><a href="https:&#x2F;&#x2F;blog.rustprooflabs.com&#x2F;2022&#x2F;07&#x2F;postgres-15-unique-improvement-with-null" rel="nofollow">https:&#x2F;&#x2F;blog.rustprooflabs.com&#x2F;2022&#x2F;07&#x2F;postgres-15-unique-im...</a><p>Practically speaking, I go with not null, and always set default value.</div><br/></div></div><div id="42652268" class="c"><input type="checkbox" id="c-42652268" checked=""/><div class="controls bullet"><span class="by">gxt</span><span>|</span><a href="#42651726">prev</a><span>|</span><a href="#42651822">next</a><span>|</span><label class="collapse" for="c-42652268">[-]</label><label class="expand" for="c-42652268">[4 more]</label></div><br/><div class="children"><div class="content">This has always made queries unpredictable in many scenarios and it should be a feature to turn nulls off entirely and swap them out with Option&lt;T&gt; instead.</div><br/><div id="42652540" class="c"><input type="checkbox" id="c-42652540" checked=""/><div class="controls bullet"><span class="by">solumunus</span><span>|</span><a href="#42652268">parent</a><span>|</span><a href="#42651822">next</a><span>|</span><label class="collapse" for="c-42652540">[-]</label><label class="expand" for="c-42652540">[3 more]</label></div><br/><div class="children"><div class="content">How would you handle unmatched outer joins?</div><br/><div id="42653510" class="c"><input type="checkbox" id="c-42653510" checked=""/><div class="controls bullet"><span class="by">benzayb</span><span>|</span><a href="#42652268">root</a><span>|</span><a href="#42652540">parent</a><span>|</span><a href="#42652835">next</a><span>|</span><label class="collapse" for="c-42653510">[-]</label><label class="expand" for="c-42653510">[1 more]</label></div><br/><div class="children"><div class="content">By having a default value (non-null) for each declared type of those columns.<p>Or, the user must define a default value in the query itself.<p>Yes, tedious; but, precise and forces the programmer to really prepare for the &quot;unknown&quot; scenario.</div><br/></div></div><div id="42652835" class="c"><input type="checkbox" id="c-42652835" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42652268">root</a><span>|</span><a href="#42652540">parent</a><span>|</span><a href="#42653510">prev</a><span>|</span><a href="#42651822">next</a><span>|</span><label class="collapse" for="c-42652835">[-]</label><label class="expand" for="c-42652835">[1 more]</label></div><br/><div class="children"><div class="content">a left outer join b yields tuples of (A, Option&lt;B&gt;), a full outer join b yields tuples of (Option&lt;A&gt;, Option&lt;B&gt;)</div><br/></div></div></div></div></div></div><div id="42651822" class="c"><input type="checkbox" id="c-42651822" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#42652268">prev</a><span>|</span><a href="#42647669">next</a><span>|</span><label class="collapse" for="c-42651822">[-]</label><label class="expand" for="c-42651822">[1 more]</label></div><br/><div class="children"><div class="content">null != null is pretty bizarre at first, until you understand the reason the did it was to try to make sense of null-able indexed columns. Not sure why we couldnt have our cake and eat it, but instead we got IS NOT NULL is not the same as != NULL</div><br/></div></div><div id="42647669" class="c"><input type="checkbox" id="c-42647669" checked=""/><div class="controls bullet"><span class="by">al2o3cr</span><span>|</span><a href="#42651822">prev</a><span>|</span><a href="#42651691">next</a><span>|</span><label class="collapse" for="c-42647669">[-]</label><label class="expand" for="c-42647669">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, you can explicitly change this behavior in Postgres as of version 15 - include &quot;NULLS NOT DISTINCT&quot; when creating the unique index.</div><br/></div></div><div id="42651691" class="c"><input type="checkbox" id="c-42651691" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#42647669">prev</a><span>|</span><a href="#42651991">next</a><span>|</span><label class="collapse" for="c-42651691">[-]</label><label class="expand" for="c-42651691">[1 more]</label></div><br/><div class="children"><div class="content">Weirder still are floating point numbers in SQL.</div><br/></div></div><div id="42651991" class="c"><input type="checkbox" id="c-42651991" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#42651691">prev</a><span>|</span><a href="#42652724">next</a><span>|</span><label class="collapse" for="c-42651991">[-]</label><label class="expand" for="c-42651991">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another good, technical write-up on NULL behavior in SQL at modern-sql.com<p><a href="https:&#x2F;&#x2F;modern-sql.com&#x2F;concept&#x2F;null" rel="nofollow">https:&#x2F;&#x2F;modern-sql.com&#x2F;concept&#x2F;null</a><p>(Note: I am not affiliated with that bloh&#x2F;website in any way, shape, or form.)</div><br/></div></div><div id="42647541" class="c"><input type="checkbox" id="c-42647541" checked=""/><div class="controls bullet"><span class="by">ungut</span><span>|</span><a href="#42652724">prev</a><span>|</span><a href="#42647421">next</a><span>|</span><label class="collapse" for="c-42647541">[-]</label><label class="expand" for="c-42647541">[1 more]</label></div><br/><div class="children"><div class="content">The NULLs in unique constraints quirk actually works differently in ORACLE databases, which is infuriating to say the least. Apparently this comes from some ambiguity in some sql standard, anyone know more about this?</div><br/></div></div><div id="42647421" class="c"><input type="checkbox" id="c-42647421" checked=""/><div class="controls bullet"><span class="by">jmyeet</span><span>|</span><a href="#42647541">prev</a><span>|</span><label class="collapse" for="c-42647421">[-]</label><label class="expand" for="c-42647421">[4 more]</label></div><br/><div class="children"><div class="content">NULL is the absence of a value. If you try and treat it as a value, you&#x27;re going to have a bad time. So an attempted UNIQUE(email_address, deleted_at) constraint is fundamentally flawed. If you treated NULL as a value that could be unique, you&#x27;re going to break foreign keys.<p>But let&#x27;s continue the logic of deleted_at being NULL indicating an active account, which seems to the intent here. You end up doing things like:<p><pre><code>    SELECT &#x2F;* ... *&#x2F;
    FROM accounts
    WHERE email_address = &#x27;...&#x27;
    AND deleted_at IS NOT NULL
</code></pre>
Depending on your database, that may or may not index well. More problematic, you may end up with privacy leaks if someone forgets the last conditional.<p>If anything, you want to reverse this so someone has to go out of their way to explicitly select deleted accounts. There are multiple strategies for this eg using an active_accounts view or table.<p>Lastly, there are lots of potential reasons for an account to be disabled or otherwise not visible&#x2F;accessible. Takedowns, court orders, site safety, hacked accounts and so on.<p>Overloading deleted_at to have a semantic meaning for an active account is just fundamentally bad design.</div><br/><div id="42648207" class="c"><input type="checkbox" id="c-42648207" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#42647421">parent</a><span>|</span><a href="#42647568">next</a><span>|</span><label class="collapse" for="c-42648207">[-]</label><label class="expand" for="c-42648207">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Overloading deleted_at to have a semantic meaning for an active account is just fundamentally bad design.<p>Then don&#x27;t do that.  It&#x27;s kind of a leap to say soft deletes are categorically bad because someone might confuse &quot;deleted&quot; with &quot;inactive&quot;.  My users table does the super-advanced thing of having both columns.  The ORM also doesn&#x27;t forget to add the not-null criterion.  There&#x27;s also zero databases in active use where it poses a problem to indexing.<p>Soft deletes suck in their own way, but none of the alternatives are perfect either.</div><br/></div></div><div id="42647568" class="c"><input type="checkbox" id="c-42647568" checked=""/><div class="controls bullet"><span class="by">indeed30</span><span>|</span><a href="#42647421">parent</a><span>|</span><a href="#42648207">prev</a><span>|</span><a href="#42647928">next</a><span>|</span><label class="collapse" for="c-42647568">[-]</label><label class="expand" for="c-42647568">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting - I believe this is exactly how Sequelize implements soft-deletion.</div><br/></div></div><div id="42647928" class="c"><input type="checkbox" id="c-42647928" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#42647421">parent</a><span>|</span><a href="#42647568">prev</a><span>|</span><label class="collapse" for="c-42647928">[-]</label><label class="expand" for="c-42647928">[1 more]</label></div><br/><div class="children"><div class="content">You put the &quot;is not null&quot; on the index itself and then simply don&#x27;t use it for the much rarer queries that <i>are</i> on deleted accounts. Or just use a view for active accounts.<p>Overloading timestamps to carry a boolean on null is awesome as long as you decide that&#x27;s what you&#x27;re doing and use one of the several standard techniques to dodge the easily avoided potential downside.<p>This isn&#x27;t a valid security concern, more than any other incorrect sql query would be anyway. A dev can always write a bad Q, you need another way to address that it&#x27;s not more likely here because of the null.</div><br/></div></div></div></div></div></div></div></div></div></body></html>