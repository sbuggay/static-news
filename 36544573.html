<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688202055898" as="style"/><link rel="stylesheet" href="styles.css?v=1688202055898"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.sbcl.org">Steel Bank Common Lisp</a> <span class="domain">(<a href="https://www.sbcl.org">www.sbcl.org</a>)</span></div><div class="subtext"><span>swatson741</span> | <span>59 comments</span></div><br/><div><div id="36545026" class="c"><input type="checkbox" id="c-36545026" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#36545302">next</a><span>|</span><label class="collapse" for="c-36545026">[-]</label><label class="expand" for="c-36545026">[6 more]</label></div><br/><div class="children"><div class="content">SBCL is an implementation I love working with because updates are steady and the software is stable.<p>But the real superpower, in my opinion, is that, because the compiler and standard library are written in Common Lisp, you can reach in into the internals of SBCL for your own projects—as if SBCL were just another Lisp library. Is it advised to use unsupported APIs? Definitely not. But it&#x27;s nice to be able to have seamless access to the same facilities and optimization tools (e.g., DEFTRANSFORM, DEFINE-VOP) that the SBCL uses for its own implementation. You can build impressively clear and highly efficient code this way, essentially by extending the compiler &quot;in userspace&quot;.</div><br/><div id="36548070" class="c"><input type="checkbox" id="c-36548070" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#36545026">parent</a><span>|</span><a href="#36545170">next</a><span>|</span><label class="collapse" for="c-36548070">[-]</label><label class="expand" for="c-36548070">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s a good introduction for learning SBCL compiler internals like VOP&#x27;s?</div><br/></div></div><div id="36545170" class="c"><input type="checkbox" id="c-36545170" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#36545026">parent</a><span>|</span><a href="#36548070">prev</a><span>|</span><a href="#36545305">next</a><span>|</span><label class="collapse" for="c-36545170">[-]</label><label class="expand" for="c-36545170">[1 more]</label></div><br/><div class="children"><div class="content">I wanted to get last modified dates from some files, and I tried to use OSICAT-POSIX, but it didn&#x27;t work because it was missing a non-CL dependency, so I used SB-POSIX instead, and it worked as expected, no issues. I was glad to have that option, and for that particular code, cross-compatibility with other implementations wasn&#x27;t a concern.</div><br/></div></div><div id="36545305" class="c"><input type="checkbox" id="c-36545305" checked=""/><div class="controls bullet"><span class="by">kaeland</span><span>|</span><a href="#36545026">parent</a><span>|</span><a href="#36545170">prev</a><span>|</span><a href="#36545969">next</a><span>|</span><label class="collapse" for="c-36545305">[-]</label><label class="expand" for="c-36545305">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been learning CL in my spare time and had no idea this was possible or even a distinction between CL implementations. Thanks for sharing.</div><br/></div></div><div id="36545969" class="c"><input type="checkbox" id="c-36545969" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36545026">parent</a><span>|</span><a href="#36545305">prev</a><span>|</span><a href="#36545302">next</a><span>|</span><label class="collapse" for="c-36545969">[-]</label><label class="expand" for="c-36545969">[2 more]</label></div><br/><div class="children"><div class="content">I have a real soft spot for DISASSEMBLE too. It’s magical to be able to instantly see how the optimizer handles your hot spots.</div><br/><div id="36546261" class="c"><input type="checkbox" id="c-36546261" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36545026">root</a><span>|</span><a href="#36545969">parent</a><span>|</span><a href="#36545302">next</a><span>|</span><label class="collapse" for="c-36546261">[-]</label><label class="expand" for="c-36546261">[1 more]</label></div><br/><div class="children"><div class="content">And if you profile code, then you see assembly level profiling information too!</div><br/></div></div></div></div></div></div><div id="36545302" class="c"><input type="checkbox" id="c-36545302" checked=""/><div class="controls bullet"><span class="by">jonas21</span><span>|</span><a href="#36545026">prev</a><span>|</span><a href="#36546990">next</a><span>|</span><label class="collapse" for="c-36545302">[-]</label><label class="expand" for="c-36545302">[3 more]</label></div><br/><div class="children"><div class="content">In case anyone else is curious about the name:<p>&gt; <i>SBCL derives most of its code from CMU CL, created at Carnegie Mellon University. ... it&#x27;s appropriate to acknowledge the descent from the CMU hackers (and post-CMU CMU CL hackers) who did most of the heavy lifting to make the system work. So the system is named Steel Bank after the industries where Andrew Carnegie and Andrew Mellon, respectively, made the big bucks.</i><p><a href="https:&#x2F;&#x2F;www.sbcl.org&#x2F;history.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sbcl.org&#x2F;history.html</a></div><br/><div id="36545441" class="c"><input type="checkbox" id="c-36545441" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#36545302">parent</a><span>|</span><a href="#36546990">next</a><span>|</span><label class="collapse" for="c-36545441">[-]</label><label class="expand" for="c-36545441">[2 more]</label></div><br/><div class="children"><div class="content">Note that SBCL forked from CMUCL 23 years ago.  There&#x27;s been a great deal of turnover in the code since then.  I&#x27;m sure you could find some remnants of the original code, but overall it&#x27;s very much its own thing now.</div><br/><div id="36545893" class="c"><input type="checkbox" id="c-36545893" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#36545302">root</a><span>|</span><a href="#36545441">parent</a><span>|</span><a href="#36546990">next</a><span>|</span><label class="collapse" for="c-36545893">[-]</label><label class="expand" for="c-36545893">[1 more]</label></div><br/><div class="children"><div class="content">In the same way that a version of SBCL 23 years in the future is a clear descendent of the current version, so is the current version a direct descendent of CMU CL, 23 years ago.</div><br/></div></div></div></div></div></div><div id="36546990" class="c"><input type="checkbox" id="c-36546990" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36545302">prev</a><span>|</span><a href="#36547898">next</a><span>|</span><label class="collapse" for="c-36546990">[-]</label><label class="expand" for="c-36546990">[1 more]</label></div><br/><div class="children"><div class="content">The biggest advantage of using SBCL over other Common Lisp implemnetations is that it has very good support for Common Lisp types:<p><a href="https:&#x2F;&#x2F;www.sbcl.org&#x2F;manual&#x2F;index.html#Handling-of-Types" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sbcl.org&#x2F;manual&#x2F;index.html#Handling-of-Types</a><p>I &quot;(declaim)&quot; the types of my exported functions (at least) which makes life much easier when consuming the library&#x27;s API, and when you make a mistake (either in the caller or the implementation) you&#x27;ll get either an error or a warning when you compile the function. The types also show up in the documentation in SLIME and can (but is not guaranteed to, you can check with (time) and (disassemble) and (sb-profile))  make code much faster... specially if you need a lot of numeric computation, declaring the types of the numbers as `fixnum` or `single-float` (you may need to explicitly restrict the range of the numbers too to get the best Assembly) your code can run much faster as that will let it compile to basically what C would do, as it avoids the Lisp numerical tower slowing things down.</div><br/></div></div><div id="36547898" class="c"><input type="checkbox" id="c-36547898" checked=""/><div class="controls bullet"><span class="by">anyfactor</span><span>|</span><a href="#36546990">prev</a><span>|</span><a href="#36547967">next</a><span>|</span><label class="collapse" for="c-36547898">[-]</label><label class="expand" for="c-36547898">[2 more]</label></div><br/><div class="children"><div class="content">Kinda was hoping that it was developed by a Bank of some sort, but no. Imagine a bank investing time and effort into creating a Lisp implementation.<p>&gt; The name &quot;Steel Bank Common Lisp&quot; is a reference to Carnegie Mellon University Common Lisp from which SBCL forked: Andrew Carnegie made his fortune in the steel industry and Andrew Mellon was a successful banker.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Steel_Bank_Common_Lisp" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Steel_Bank_Common_Lisp</a></div><br/><div id="36547973" class="c"><input type="checkbox" id="c-36547973" checked=""/><div class="controls bullet"><span class="by">pluijzer</span><span>|</span><a href="#36547898">parent</a><span>|</span><a href="#36547967">next</a><span>|</span><label class="collapse" for="c-36547973">[-]</label><label class="expand" for="c-36547973">[1 more]</label></div><br/><div class="children"><div class="content">Well there is Nubank investing heavily in Clojure.</div><br/></div></div></div></div><div id="36547967" class="c"><input type="checkbox" id="c-36547967" checked=""/><div class="controls bullet"><span class="by">jwr</span><span>|</span><a href="#36547898">prev</a><span>|</span><a href="#36548071">next</a><span>|</span><label class="collapse" for="c-36547967">[-]</label><label class="expand" for="c-36547967">[1 more]</label></div><br/><div class="children"><div class="content">Before I moved on to Clojure, SBCL was what I used. Rock solid, open-source and debuggable (I also used commercial lisps: AllegroCL and Lispworks, and was not happy with them), actively developed.<p>If you use Common Lisp, this is a really good implementation.</div><br/></div></div><div id="36548071" class="c"><input type="checkbox" id="c-36548071" checked=""/><div class="controls bullet"><span class="by">submeta</span><span>|</span><a href="#36547967">prev</a><span>|</span><a href="#36545990">next</a><span>|</span><label class="collapse" for="c-36548071">[-]</label><label class="expand" for="c-36548071">[1 more]</label></div><br/><div class="children"><div class="content">Whenever a post about Lisp graces the front page of Hacker News, I typically observe two main categories of commenters. The first group is composed of devout Lisp enthusiasts who have either applied it to solve problems in the past or continue to utilize it in their personal and professional projects. They are well-versed in the numerous advantages of Lisp over many contemporary programming languages. Their familiarity with the language extends to its versatility in writing DSLs using its macro system, its adaptability in altering running programs, and its debugging prowess. They value the ability to scrutinize the internals, apply multiple programming paradigms, and appreciate various other benefits.<p>The second group, conversely, is characterized by its perennial question whenever a Lisp-related article surfaces: &quot;Does anybody use Lisp these days?&quot; In response, the first group can usually cite a small collection of projects that still use Lisp, including Clojure shops, a Brazilian startup, and the Hacker News website, which is written in Arc, among others.<p>This dichotomy serves as an apt illustration of how one&#x27;s perspective can be distorted, causing them to overlook the broader reality. As much as I admire and appreciate Lisp (and I genuinely do!), it&#x27;s hard to ignore that the technological world primarily operates on languages such as C, Java, JavaScript, Python, C#, and a handful of others. The communities surrounding these languages seldom feel the need to prove their viability by listing projects that use them.<p>The undeniable truth is that the world has largely embraced C-type languages, and in doing so, has achieved remarkable feats. The &quot;absolute best&quot; programming language was not a requirement for this progress.<p>Management professor and esteemed writer Peter Drucker offered valuable insight in his book &quot;The Effective Executive.&quot; He stated that effective executives don&#x27;t become preoccupied with the tools they use; instead, they employ whatever tools are necessary to accomplish their tasks. This notion, I believe, is applicable not only to management but also to the realm of programming languages.</div><br/></div></div><div id="36545990" class="c"><input type="checkbox" id="c-36545990" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#36548071">prev</a><span>|</span><a href="#36545857">next</a><span>|</span><label class="collapse" for="c-36545990">[-]</label><label class="expand" for="c-36545990">[1 more]</label></div><br/><div class="children"><div class="content">I used SBCL for a decent chunk of my college coursework. It was a joy to use and made programming fun and exciting in a way I hadn&#x27;t experienced before.</div><br/></div></div><div id="36545857" class="c"><input type="checkbox" id="c-36545857" checked=""/><div class="controls bullet"><span class="by">beefman</span><span>|</span><a href="#36545990">prev</a><span>|</span><a href="#36545308">next</a><span>|</span><label class="collapse" for="c-36545857">[-]</label><label class="expand" for="c-36545857">[2 more]</label></div><br/><div class="children"><div class="content">Was this ever called SuperBallistic Common Lisp? I remember it being called that but google only returns<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1348383">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1348383</a></div><br/><div id="36546488" class="c"><input type="checkbox" id="c-36546488" checked=""/><div class="controls bullet"><span class="by">throwaway1777</span><span>|</span><a href="#36545857">parent</a><span>|</span><a href="#36545308">next</a><span>|</span><label class="collapse" for="c-36546488">[-]</label><label class="expand" for="c-36546488">[1 more]</label></div><br/><div class="children"><div class="content">No</div><br/></div></div></div></div><div id="36545308" class="c"><input type="checkbox" id="c-36545308" checked=""/><div class="controls bullet"><span class="by">jgerrish</span><span>|</span><a href="#36545857">prev</a><span>|</span><a href="#36546499">next</a><span>|</span><label class="collapse" for="c-36545308">[-]</label><label class="expand" for="c-36545308">[4 more]</label></div><br/><div class="children"><div class="content">I posted previously about SBCL and quicklisp.  Great ecosystem.  I&#x27;m still learning but it&#x27;s usually fun to work in.<p>I made some recommendations about quicklisp using http by default and how to lock it down.<p>I don&#x27;t know if those are good recommendations anymore.  I couldn&#x27;t manage to follow them myself.  I couldn&#x27;t keep up and my patch approach didnt work.<p>So, I don&#x27;t know the best approach with that problem, but I was too confident in my post about security suggestions.</div><br/><div id="36546682" class="c"><input type="checkbox" id="c-36546682" checked=""/><div class="controls bullet"><span class="by">atgreen</span><span>|</span><a href="#36545308">parent</a><span>|</span><a href="#36547324">next</a><span>|</span><label class="collapse" for="c-36546682">[-]</label><label class="expand" for="c-36546682">[1 more]</label></div><br/><div class="children"><div class="content">Check out ocicl as an alternative to quicklisp if you are concerned about security. Code is distributed using the OCI ecosystem (https by default, proxies work, sigstore integration, etc).  <a href="https:&#x2F;&#x2F;github.com&#x2F;ocicl&#x2F;ocicl">https:&#x2F;&#x2F;github.com&#x2F;ocicl&#x2F;ocicl</a></div><br/></div></div><div id="36547324" class="c"><input type="checkbox" id="c-36547324" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36545308">parent</a><span>|</span><a href="#36546682">prev</a><span>|</span><a href="#36546499">next</a><span>|</span><label class="collapse" for="c-36547324">[-]</label><label class="expand" for="c-36547324">[2 more]</label></div><br/><div class="children"><div class="content">Quicklisp, ironically, only updates once a month. It&#x27;s managed like a Linux distro. That means the client has a full index of every library in the registry, and knows the hash of every file it may download.<p>I am pretty sure quicklisp checks the hashes it downloads. Hence, the only security issue with using HTTP seems to be that middleman can see what you&#x27;ve downloaded... if they try to change it in any way, the quicklisp client will reject the download as far as I know (though I haven&#x27;t checked the code).<p>Do you believe this is not sufficient, and why?</div><br/><div id="36548011" class="c"><input type="checkbox" id="c-36548011" checked=""/><div class="controls bullet"><span class="by">atgreen</span><span>|</span><a href="#36545308">root</a><span>|</span><a href="#36547324">parent</a><span>|</span><a href="#36546499">next</a><span>|</span><label class="collapse" for="c-36548011">[-]</label><label class="expand" for="c-36548011">[1 more]</label></div><br/><div class="children"><div class="content">Man-in-the-middle attacks.  But equally important, many secure environments won&#x27;t allow outbound http connections.</div><br/></div></div></div></div></div></div><div id="36545207" class="c"><input type="checkbox" id="c-36545207" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#36546499">prev</a><span>|</span><a href="#36545885">next</a><span>|</span><label class="collapse" for="c-36545207">[-]</label><label class="expand" for="c-36545207">[25 more]</label></div><br/><div class="children"><div class="content">What is the dominant flavor of Lisp these days?</div><br/><div id="36545468" class="c"><input type="checkbox" id="c-36545468" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#36545207">parent</a><span>|</span><a href="#36545233">next</a><span>|</span><label class="collapse" for="c-36545468">[-]</label><label class="expand" for="c-36545468">[7 more]</label></div><br/><div class="children"><div class="content">My guess is Common Lisp has the most usage in industry, its just quiet compared to the latest dog food sharing app built in Clojure. Racket seems the most enthusiastic and fun community, and has some great learning tools. And Emacs Lisp secretly runs all of it.</div><br/><div id="36545941" class="c"><input type="checkbox" id="c-36545941" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545468">parent</a><span>|</span><a href="#36545233">next</a><span>|</span><label class="collapse" for="c-36545941">[-]</label><label class="expand" for="c-36545941">[6 more]</label></div><br/><div class="children"><div class="content">I vaguely recall a story about some enterprise critical app that some madman hacked out in elisp because time was tight.</div><br/><div id="36546399" class="c"><input type="checkbox" id="c-36546399" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545941">parent</a><span>|</span><a href="#36547085">next</a><span>|</span><label class="collapse" for="c-36546399">[-]</label><label class="expand" for="c-36546399">[1 more]</label></div><br/><div class="children"><div class="content">Steve Yegge’s customer support app for Amazon possibly</div><br/></div></div><div id="36547085" class="c"><input type="checkbox" id="c-36547085" checked=""/><div class="controls bullet"><span class="by">viksit</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545941">parent</a><span>|</span><a href="#36546399">prev</a><span>|</span><a href="#36546411">next</a><span>|</span><label class="collapse" for="c-36547085">[-]</label><label class="expand" for="c-36547085">[3 more]</label></div><br/><div class="children"><div class="content">This one about german ATC running in elisp<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26202517">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26202517</a></div><br/><div id="36547131" class="c"><input type="checkbox" id="c-36547131" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36547085">parent</a><span>|</span><a href="#36547365">next</a><span>|</span><label class="collapse" for="c-36547131">[-]</label><label class="expand" for="c-36547131">[1 more]</label></div><br/><div class="children"><div class="content">More than disturbing that ATC software was written quickly because of tight constraints.</div><br/></div></div><div id="36547365" class="c"><input type="checkbox" id="c-36547365" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36547085">parent</a><span>|</span><a href="#36547131">prev</a><span>|</span><a href="#36546411">next</a><span>|</span><label class="collapse" for="c-36547365">[-]</label><label class="expand" for="c-36547365">[1 more]</label></div><br/><div class="children"><div class="content">Yes that&#x27;s the one. Thanks!</div><br/></div></div></div></div><div id="36546411" class="c"><input type="checkbox" id="c-36546411" checked=""/><div class="controls bullet"><span class="by">jes</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545941">parent</a><span>|</span><a href="#36547085">prev</a><span>|</span><a href="#36545233">next</a><span>|</span><label class="collapse" for="c-36546411">[-]</label><label class="expand" for="c-36546411">[1 more]</label></div><br/><div class="children"><div class="content">Might it be this article?<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26531660">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26531660</a></div><br/></div></div></div></div></div></div><div id="36545233" class="c"><input type="checkbox" id="c-36545233" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#36545207">parent</a><span>|</span><a href="#36545468">prev</a><span>|</span><a href="#36547133">next</a><span>|</span><label class="collapse" for="c-36545233">[-]</label><label class="expand" for="c-36545233">[12 more]</label></div><br/><div class="children"><div class="content">As measured by what? Clojure is pretty popular, as is Racket in other circles. Common Lisp is robust, standardized, and &quot;decentralized&quot; with both free and commercial implementations. It and Python power a few quantum computing technologies.</div><br/><div id="36545461" class="c"><input type="checkbox" id="c-36545461" checked=""/><div class="controls bullet"><span class="by">opan</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545233">parent</a><span>|</span><a href="#36546606">next</a><span>|</span><label class="collapse" for="c-36545461">[-]</label><label class="expand" for="c-36545461">[7 more]</label></div><br/><div class="children"><div class="content">In addition to this, Guile is big in the GNU space, used for Guix and other things.</div><br/><div id="36545707" class="c"><input type="checkbox" id="c-36545707" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545461">parent</a><span>|</span><a href="#36546606">next</a><span>|</span><label class="collapse" for="c-36545707">[-]</label><label class="expand" for="c-36545707">[6 more]</label></div><br/><div class="children"><div class="content">There was also sustained effort over the past two decades to move Emacs from Elisp to Guile but that has stalled:<p><a href="https:&#x2F;&#x2F;emacsninja.com&#x2F;posts&#x2F;state-of-emacs-lisp-on-guile.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;emacsninja.com&#x2F;posts&#x2F;state-of-emacs-lisp-on-guile.ht...</a></div><br/><div id="36547266" class="c"><input type="checkbox" id="c-36547266" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545707">parent</a><span>|</span><a href="#36545958">next</a><span>|</span><label class="collapse" for="c-36547266">[-]</label><label class="expand" for="c-36547266">[2 more]</label></div><br/><div class="children"><div class="content">My impression is that part of the problem is that Emacs Lisp is a large language (lots of data types and functions implemented in C) and one without any formal specification, which makes duplicating it correctly in another system very difficult. By contrast, Scheme is a smaller language and has a reasonably clear spec.<p>Which makes me wonder – instead of trying to port GNU Emacs to run on top of Scheme, might it be easier to produce a Scheme implementation that ran on top of Emacs Lisp? Possibly Emacs Lisp is missing some of the primitives required to implement Scheme efficiently, but the amount of code required to add those primitives will likely turn out to be less than that required to reimplement the whole of GNU Emacs in Scheme – and adding those new primitives may make Emacs Lisp a better language, thus benefitting even those users who aren&#x27;t interested in Scheme in itself.</div><br/><div id="36548182" class="c"><input type="checkbox" id="c-36548182" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36547266">parent</a><span>|</span><a href="#36545958">next</a><span>|</span><label class="collapse" for="c-36548182">[-]</label><label class="expand" for="c-36548182">[1 more]</label></div><br/><div class="children"><div class="content">Guile has a generic VM and extensible compiler tower, so a bug for bug port of elisp was proving to be an effective method. Unfortunately, the project did not interest the Emacs devs so there just wasn&#x27;t the buy-in necessary to work through the finer details and make it happen for real. You can open a Guile REPL today and switch the language from Scheme to Elisp and hack away. What makes the whole thing so appealing is that the Elisp compiler simply lowers the code to Guile&#x27;s &quot;tree intermediate language&quot; (Tree-IL) and gets a free ride the rest of the way through optimization and bytecode emission. The biggest impact Elisp support had on core Guile was that a new immediate type had to be added to represent &#x27;nil&#x27;. Soon it won&#x27;t even be much of a stretch to compile Elisp to WebAssembly (would be funny!) once that backend is ready for Scheme. Guile is undervalued as a platform for language implementation and Emacs missed out on a cool opportunity.</div><br/></div></div></div></div><div id="36545958" class="c"><input type="checkbox" id="c-36545958" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545707">parent</a><span>|</span><a href="#36547266">prev</a><span>|</span><a href="#36546606">next</a><span>|</span><label class="collapse" for="c-36545958">[-]</label><label class="expand" for="c-36545958">[3 more]</label></div><br/><div class="children"><div class="content">And now thanks to the JIT patch elisp outperforms Guile considerably. Emacs dev is very much motivated by pragmatism, jokes about Emacs being a tool created to write Emacs config notwithstanding.</div><br/><div id="36546029" class="c"><input type="checkbox" id="c-36546029" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545958">parent</a><span>|</span><a href="#36546019">next</a><span>|</span><label class="collapse" for="c-36546029">[-]</label><label class="expand" for="c-36546029">[1 more]</label></div><br/><div class="children"><div class="content">You sure about that? Guile also has a JIT compiler these days and I don&#x27;t know of any benchmarks comparing the two in a meaningful way.</div><br/></div></div><div id="36546019" class="c"><input type="checkbox" id="c-36546019" checked=""/><div class="controls bullet"><span class="by">gjvc</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545958">parent</a><span>|</span><a href="#36546029">prev</a><span>|</span><a href="#36546606">next</a><span>|</span><label class="collapse" for="c-36546019">[-]</label><label class="expand" for="c-36546019">[1 more]</label></div><br/><div class="children"><div class="content">I think of emacs as a lisp machine with an editor attached.</div><br/></div></div></div></div></div></div></div></div><div id="36546606" class="c"><input type="checkbox" id="c-36546606" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36545233">parent</a><span>|</span><a href="#36545461">prev</a><span>|</span><a href="#36547133">next</a><span>|</span><label class="collapse" for="c-36546606">[-]</label><label class="expand" for="c-36546606">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a user of one of those QC technologies (ARTIQ), but what&#x27;s the CL one?</div><br/><div id="36546638" class="c"><input type="checkbox" id="c-36546638" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36546606">parent</a><span>|</span><a href="#36547111">next</a><span>|</span><label class="collapse" for="c-36546638">[-]</label><label class="expand" for="c-36546638">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;quilc">https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;quilc</a></div><br/><div id="36546674" class="c"><input type="checkbox" id="c-36546674" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36546638">parent</a><span>|</span><a href="#36547111">next</a><span>|</span><label class="collapse" for="c-36546674">[-]</label><label class="expand" for="c-36546674">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t realize Rigetti was a CL shop. That&#x27;s cool!</div><br/></div></div></div></div><div id="36547111" class="c"><input type="checkbox" id="c-36547111" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36546606">parent</a><span>|</span><a href="#36546638">prev</a><span>|</span><a href="#36547133">next</a><span>|</span><label class="collapse" for="c-36547111">[-]</label><label class="expand" for="c-36547111">[1 more]</label></div><br/><div class="children"><div class="content">At least HRL Laboratories, Rigetti Computing, and D-Wave all use&#x2F;deploy Common Lisp.</div><br/></div></div></div></div></div></div><div id="36547133" class="c"><input type="checkbox" id="c-36547133" checked=""/><div class="controls bullet"><span class="by">espadrine</span><span>|</span><a href="#36545207">parent</a><span>|</span><a href="#36545233">prev</a><span>|</span><a href="#36546155">next</a><span>|</span><label class="collapse" for="c-36547133">[-]</label><label class="expand" for="c-36547133">[1 more]</label></div><br/><div class="children"><div class="content">One measure is git pushes on GitHub. By that measure[0], in Q1 2023, we have Emacs Lisp (2995 pushes) &gt; Clojure (2135) &gt; Scheme (1350) &gt; Common Lisp (236) &gt; Racket (below detection; latest in Q1 2022: 102).<p>[0]: <a href="https:&#x2F;&#x2F;madnight.github.io&#x2F;githut&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;madnight.github.io&#x2F;githut&#x2F;</a></div><br/></div></div><div id="36546155" class="c"><input type="checkbox" id="c-36546155" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#36545207">parent</a><span>|</span><a href="#36547133">prev</a><span>|</span><a href="#36547790">next</a><span>|</span><label class="collapse" for="c-36546155">[-]</label><label class="expand" for="c-36546155">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not clear what &quot;dominant&quot; means in an already-niche language, but while Guile isn&#x27;t very <i>popular</i> you still find little snippets of it everywhere from back when it was GNU&#x27;s official extension language. Even GNU make embeds a guile interpreter, though I think most packagers turn that off at this point, sadly.</div><br/><div id="36547286" class="c"><input type="checkbox" id="c-36547286" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36546155">parent</a><span>|</span><a href="#36547790">next</a><span>|</span><label class="collapse" for="c-36547286">[-]</label><label class="expand" for="c-36547286">[2 more]</label></div><br/><div class="children"><div class="content">&gt; while Guile isn&#x27;t very popular you still find little snippets of it everywhere from back when it was GNU&#x27;s official extension language<p>Your use of past tense here seems to imply it is <i>no longer</i> GNU&#x27;s official extension language. GNU&#x27;s own website still says [0] &quot;Guile is the GNU Ubiquitous Intelligent Language for Extensions, and the official extension language of the GNU project.&quot;<p>[0] <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;</a></div><br/><div id="36547757" class="c"><input type="checkbox" id="c-36547757" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#36545207">root</a><span>|</span><a href="#36547286">parent</a><span>|</span><a href="#36547790">next</a><span>|</span><label class="collapse" for="c-36547757">[-]</label><label class="expand" for="c-36547757">[1 more]</label></div><br/><div class="children"><div class="content">And it&#x27;s all of the infrastructure in the official GNU Linux distribution, so I guess you&#x27;re right, but it was supposed to be the scripting language for the GNU desktop, and to the extent that&#x27;s still Gnome, that didn&#x27;t happen. Also the Guile team itself keeps toying with writing a (<i>shudder</i>) Javascript front-end.</div><br/></div></div></div></div></div></div><div id="36547790" class="c"><input type="checkbox" id="c-36547790" checked=""/><div class="controls bullet"><span class="by">darthrupert</span><span>|</span><a href="#36545207">parent</a><span>|</span><a href="#36546155">prev</a><span>|</span><a href="#36545885">next</a><span>|</span><label class="collapse" for="c-36547790">[-]</label><label class="expand" for="c-36547790">[1 more]</label></div><br/><div class="children"><div class="content">Typescript?</div><br/></div></div></div></div><div id="36545885" class="c"><input type="checkbox" id="c-36545885" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#36545207">prev</a><span>|</span><a href="#36546091">next</a><span>|</span><label class="collapse" for="c-36545885">[-]</label><label class="expand" for="c-36545885">[6 more]</label></div><br/><div class="children"><div class="content">They missed a trick when they didn&#x27;t call it Rich Friend Common Lisp<p>(Originally based on Carnegie Mellon University Common Lisp. Carnegie got rich in steel, Mellon in banks, but both were rich, and Mellon is Elvish for Friend. Rich Friend Common Lisp. There. A bilingual pun about a Common Lisp implementation, where one of those languages is a conlang from a fantasy novel. Geekiest joke you&#x27;ll hear all day.)</div><br/><div id="36546615" class="c"><input type="checkbox" id="c-36546615" checked=""/><div class="controls bullet"><span class="by">jrflowers</span><span>|</span><a href="#36545885">parent</a><span>|</span><a href="#36546091">next</a><span>|</span><label class="collapse" for="c-36546615">[-]</label><label class="expand" for="c-36546615">[5 more]</label></div><br/><div class="children"><div class="content">That would be a very belabored joke. I read the entire explanation of the joke twice and do not see how it could qualify as a “missed trick”</div><br/><div id="36547593" class="c"><input type="checkbox" id="c-36547593" checked=""/><div class="controls bullet"><span class="by">gautamcgoel</span><span>|</span><a href="#36545885">root</a><span>|</span><a href="#36546615">parent</a><span>|</span><a href="#36547983">next</a><span>|</span><label class="collapse" for="c-36547593">[-]</label><label class="expand" for="c-36547593">[3 more]</label></div><br/><div class="children"><div class="content">I agree, &quot;Steel Bank&quot; is way more natural.</div><br/><div id="36548123" class="c"><input type="checkbox" id="c-36548123" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#36545885">root</a><span>|</span><a href="#36547593">parent</a><span>|</span><a href="#36547913">next</a><span>|</span><label class="collapse" for="c-36548123">[-]</label><label class="expand" for="c-36548123">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the joke that SB stands for &quot;Sanely Bootstrappable&quot;, which refers to how SBCL is easy to build from source without having a copy of SBCL.</div><br/></div></div><div id="36547913" class="c"><input type="checkbox" id="c-36547913" checked=""/><div class="controls bullet"><span class="by">jrflowers</span><span>|</span><a href="#36545885">root</a><span>|</span><a href="#36547593">parent</a><span>|</span><a href="#36548123">prev</a><span>|</span><a href="#36547983">next</a><span>|</span><label class="collapse" for="c-36547913">[-]</label><label class="expand" for="c-36547913">[1 more]</label></div><br/><div class="children"><div class="content">I mean yeah, if we’re in Belabored Jokes Town (where Steel Bank was invented) it is relatively more natural than Rich Friend.</div><br/></div></div></div></div><div id="36547983" class="c"><input type="checkbox" id="c-36547983" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#36545885">root</a><span>|</span><a href="#36546615">parent</a><span>|</span><a href="#36547593">prev</a><span>|</span><a href="#36546091">next</a><span>|</span><label class="collapse" for="c-36547983">[-]</label><label class="expand" for="c-36547983">[1 more]</label></div><br/><div class="children"><div class="content">Eh, just a bit more work than Leiningen as a build automation tool:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Leiningen_(software)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Leiningen_(software)</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Apache_Ant" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Apache_Ant</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Leiningen_Versus_the_Ants" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Leiningen_Versus_the_Ants</a></div><br/></div></div></div></div></div></div><div id="36546091" class="c"><input type="checkbox" id="c-36546091" checked=""/><div class="controls bullet"><span class="by">jderiksen</span><span>|</span><a href="#36545885">prev</a><span>|</span><a href="#36547890">next</a><span>|</span><label class="collapse" for="c-36546091">[-]</label><label class="expand" for="c-36546091">[1 more]</label></div><br/><div class="children"><div class="content">Fond memories of using SBCL in grad school</div><br/></div></div><div id="36547890" class="c"><input type="checkbox" id="c-36547890" checked=""/><div class="controls bullet"><span class="by">dumdumchan</span><span>|</span><a href="#36546091">prev</a><span>|</span><label class="collapse" for="c-36547890">[-]</label><label class="expand" for="c-36547890">[4 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t remember the last time I came across something new built using common lisp. Is it a dead language? Have the modern languages implemented 20% of its features that provide 80% of functionality?</div><br/><div id="36548039" class="c"><input type="checkbox" id="c-36548039" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#36547890">parent</a><span>|</span><label class="collapse" for="c-36548039">[-]</label><label class="expand" for="c-36548039">[3 more]</label></div><br/><div class="children"><div class="content">imagine python, but you can add more types in order to compile python code into machine code. So you have some slow tight loop, add types, add a decorator and it runs thousands of times faster. Now imagine being able to do this since early 2000s.</div><br/><div id="36548097" class="c"><input type="checkbox" id="c-36548097" checked=""/><div class="controls bullet"><span class="by">dumdumchan</span><span>|</span><a href="#36547890">root</a><span>|</span><a href="#36548039">parent</a><span>|</span><label class="collapse" for="c-36548097">[-]</label><label class="expand" for="c-36548097">[2 more]</label></div><br/><div class="children"><div class="content">You dodged the question. If it&#x27;s so good then why did people stop using it?</div><br/><div id="36548162" class="c"><input type="checkbox" id="c-36548162" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#36547890">root</a><span>|</span><a href="#36548097">parent</a><span>|</span><label class="collapse" for="c-36548162">[-]</label><label class="expand" for="c-36548162">[1 more]</label></div><br/><div class="children"><div class="content">Touché, I wasn&#x27;t really answering the question. But I don&#x27;t think people really started using it.<p>If my task was to gather a team of developers for a general purpose firm, I&#x27;d probably choose Java. I guess that answers a lot.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>