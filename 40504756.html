<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716973278411" as="style"/><link rel="stylesheet" href="styles.css?v=1716973278411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jviide.iki.fi/http-redirects">API Shouldn&#x27;t Redirect HTTP to HTTPS</a>Â <span class="domain">(<a href="https://jviide.iki.fi">jviide.iki.fi</a>)</span></div><div class="subtext"><span>oherrala</span> | <span>161 comments</span></div><br/><div><div id="40509898" class="c"><input type="checkbox" id="c-40509898" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#40505525">next</a><span>|</span><label class="collapse" for="c-40509898">[-]</label><label class="expand" for="c-40509898">[1 more]</label></div><br/><div class="children"><div class="content">&gt; revoke API keys sent over the unencrypted connection. Unfortunately, many well-known API providers don&#x27;t currently do so.<p>If I am not offering a TLS endpoint to begin with, and the client decides to shout his secret out into the open internet, then I don&#x27;t see how that is my problem, or why I should make my software more complex to deal with it.<p>What&#x27;s next? Should I be required to regularly scan repos on all public git providers for revealed secrets to my api, so I can revoke them as well?<p>The things are called &quot;SECRETS&quot; for a reason. I am my clients provider, not his nanny.</div><br/></div></div><div id="40505525" class="c"><input type="checkbox" id="c-40505525" checked=""/><div class="controls bullet"><span class="by">zepton</span><span>|</span><a href="#40509898">prev</a><span>|</span><a href="#40506141">next</a><span>|</span><label class="collapse" for="c-40505525">[-]</label><label class="expand" for="c-40505525">[36 more]</label></div><br/><div class="children"><div class="content">The Stack Exchange API used to revoke API keys sent over HTTP (and return an error message), which is my favorite way to handle this.</div><br/><div id="40506823" class="c"><input type="checkbox" id="c-40506823" checked=""/><div class="controls bullet"><span class="by">Eduard</span><span>|</span><a href="#40505525">parent</a><span>|</span><a href="#40509625">next</a><span>|</span><label class="collapse" for="c-40506823">[-]</label><label class="expand" for="c-40506823">[13 more]</label></div><br/><div class="children"><div class="content">that&#x27;s more secure, but still not bulletproof:<p>A MITM (e.g. a router along a multi-hop route between the victim client and StackExchange) could silently drop the unsafe HTTP requests and maliciously repackage it as an HTTPS request, thereby circumventing the revocation.<p>Also: even if an insecure HTTP request isn&#x27;t dropped &#x2F; makes it through to StackExchange&#x27;s endpoint eventually (and thereby triggering the API key revocation), a MITM with a shorter trip time to SE&#x27;s servers could race for wrecking havoc until the revocation happens.<p>Nevertheless, SE&#x27;s revocation tactic contributes positively to a defense in depth strategy.</div><br/><div id="40506943" class="c"><input type="checkbox" id="c-40506943" checked=""/><div class="controls bullet"><span class="by">Titan2189</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506823">parent</a><span>|</span><a href="#40506979">next</a><span>|</span><label class="collapse" for="c-40506943">[-]</label><label class="expand" for="c-40506943">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue your reasoning is incorrect. By the time your service is developed you would have already changed it to https, as during development every time you tried your API keys sent via http got disabled.
So an in-the-wild MITM would never get to see your http request</div><br/><div id="40508408" class="c"><input type="checkbox" id="c-40508408" checked=""/><div class="controls bullet"><span class="by">throw__away7391</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506943">parent</a><span>|</span><a href="#40506979">next</a><span>|</span><label class="collapse" for="c-40508408">[-]</label><label class="expand" for="c-40508408">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very good point, I agree. You&#x27;re always going to run a service at least once.</div><br/></div></div></div></div><div id="40506979" class="c"><input type="checkbox" id="c-40506979" checked=""/><div class="controls bullet"><span class="by">lofenfew</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506823">parent</a><span>|</span><a href="#40506943">prev</a><span>|</span><a href="#40509713">next</a><span>|</span><label class="collapse" for="c-40506979">[-]</label><label class="expand" for="c-40506979">[8 more]</label></div><br/><div class="children"><div class="content">There&#x27;s absolutely nothing you can do to prevent an active MITM attack over HTTP</div><br/><div id="40509690" class="c"><input type="checkbox" id="c-40509690" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506979">parent</a><span>|</span><a href="#40507236">next</a><span>|</span><label class="collapse" for="c-40509690">[-]</label><label class="expand" for="c-40509690">[1 more]</label></div><br/><div class="children"><div class="content">I think the CONNECT proxy protocol carrying TLS over HTTP&#x2F;1 is a counterexample.<p>ref: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Methods&#x2F;CONNECT" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Methods&#x2F;CO...</a></div><br/></div></div><div id="40507236" class="c"><input type="checkbox" id="c-40507236" checked=""/><div class="controls bullet"><span class="by">amscanne</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506979">parent</a><span>|</span><a href="#40509690">prev</a><span>|</span><a href="#40509713">next</a><span>|</span><label class="collapse" for="c-40507236">[-]</label><label class="expand" for="c-40507236">[6 more]</label></div><br/><div class="children"><div class="content">Have the authentication header effectively be a signed hash of relevant headers and the full URL, rather than a simple bearer token?</div><br/><div id="40507980" class="c"><input type="checkbox" id="c-40507980" checked=""/><div class="controls bullet"><span class="by">grantism</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40507236">parent</a><span>|</span><a href="#40509713">next</a><span>|</span><label class="collapse" for="c-40507980">[-]</label><label class="expand" for="c-40507980">[5 more]</label></div><br/><div class="children"><div class="content">What&#x27;s stopping the MITM just copying that header?</div><br/><div id="40508148" class="c"><input type="checkbox" id="c-40508148" checked=""/><div class="controls bullet"><span class="by">gruez</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40507980">parent</a><span>|</span><a href="#40508623">next</a><span>|</span><label class="collapse" for="c-40508148">[-]</label><label class="expand" for="c-40508148">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s complicated authentication schemes around hmac that tries to do this, but if you&#x27;re putting that much effort into it you might as well give up and use https.</div><br/><div id="40508984" class="c"><input type="checkbox" id="c-40508984" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508148">parent</a><span>|</span><a href="#40508623">next</a><span>|</span><label class="collapse" for="c-40508984">[-]</label><label class="expand" for="c-40508984">[1 more]</label></div><br/><div class="children"><div class="content">Some of these include a nonce and&#x2F;or are deployed over TLS to prevent replay attacks and avoid sending bearer tokens over the wire. AWS sig v4 and RFC7616 come to mind.</div><br/></div></div></div></div><div id="40508623" class="c"><input type="checkbox" id="c-40508623" checked=""/><div class="controls bullet"><span class="by">4death4</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40507980">parent</a><span>|</span><a href="#40508148">prev</a><span>|</span><a href="#40509713">next</a><span>|</span><label class="collapse" for="c-40508623">[-]</label><label class="expand" for="c-40508623">[2 more]</label></div><br/><div class="children"><div class="content">Even if the copy the header, they can only perform a replay attack, which is an improvement over leaking an API key. Also, you could include a timestamp in the signature to limit the amount of time it could be replayed.</div><br/><div id="40508895" class="c"><input type="checkbox" id="c-40508895" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508623">parent</a><span>|</span><a href="#40509713">next</a><span>|</span><label class="collapse" for="c-40508895">[-]</label><label class="expand" for="c-40508895">[1 more]</label></div><br/><div class="children"><div class="content">Sign a nonce.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40509713" class="c"><input type="checkbox" id="c-40509713" checked=""/><div class="controls bullet"><span class="by">dotancohen</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506823">parent</a><span>|</span><a href="#40506979">prev</a><span>|</span><a href="#40509625">next</a><span>|</span><label class="collapse" for="c-40509713">[-]</label><label class="expand" for="c-40509713">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; that&#x27;s more secure, but still not bulletproof
</code></pre>
I&#x27;ve never heard of bulletproof ever actually being achieved in IT security. Not even air gaps.</div><br/><div id="40509792" class="c"><input type="checkbox" id="c-40509792" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40509713">parent</a><span>|</span><a href="#40509625">next</a><span>|</span><label class="collapse" for="c-40509792">[-]</label><label class="expand" for="c-40509792">[1 more]</label></div><br/><div class="children"><div class="content">You tend to only hear about the systems where security was successfully broken, not the systems nobody managed to penetrate.</div><br/></div></div></div></div></div></div><div id="40509625" class="c"><input type="checkbox" id="c-40509625" checked=""/><div class="controls bullet"><span class="by">ChrisTorng</span><span>|</span><a href="#40505525">parent</a><span>|</span><a href="#40506823">prev</a><span>|</span><a href="#40505672">next</a><span>|</span><label class="collapse" for="c-40509625">[-]</label><label class="expand" for="c-40509625">[1 more]</label></div><br/><div class="children"><div class="content">The client-side library should disable HTTP by default to ensure that raw data never leaves the local environment, thereby avoiding any leakage.</div><br/></div></div><div id="40505672" class="c"><input type="checkbox" id="c-40505672" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#40505525">parent</a><span>|</span><a href="#40509625">prev</a><span>|</span><a href="#40505788">next</a><span>|</span><label class="collapse" for="c-40505672">[-]</label><label class="expand" for="c-40505672">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been thinking for about 5 minutes about this comment and what to write but i&#x27;ve come to the conclusion that this is really not the best thing to do, but the correct thing to do.<p>It&#x27;s not different levels of good or bad... everything else is wrong.</div><br/><div id="40505914" class="c"><input type="checkbox" id="c-40505914" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40505672">parent</a><span>|</span><a href="#40506673">next</a><span>|</span><label class="collapse" for="c-40505914">[-]</label><label class="expand" for="c-40505914">[8 more]</label></div><br/><div class="children"><div class="content">One of the approaches mentioned in the article is to just not listen on port 80.  Supposedly thatâs equally good because the connection should get aborted before the client has the chance to actually send any API keys.<p>But is that actually true?  With TCP Fast Open, a client can send initial TCP data before actually learning whether the port is open.  It needs a cookie previously received from the server to do so, but the cookie is not port-specific, so â assuming the server supports Fast Open â the client could have obtained the cookie from a prior connection over HTTPS or any other valid port. Thatâs the impression I get from reading the RFC, anyway.  The RFC does mention that clients should distinguish between different server ports when caching refusals by the server to support Fast Open, but by that point itâs too late; the data may have already been leaked.</div><br/><div id="40506222" class="c"><input type="checkbox" id="c-40506222" checked=""/><div class="controls bullet"><span class="by">andrewaylett</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40505914">parent</a><span>|</span><a href="#40506188">next</a><span>|</span><label class="collapse" for="c-40506222">[-]</label><label class="expand" for="c-40506222">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re serving web traffic and API traffic on the same domain, which many services are, then not listening on port 80 may not be possible.  Even if you do use a different domain, if you&#x27;re behind a CDN then you probably can&#x27;t avoid an open port 80.  I <i>do</i> keep port 80 closed for those of my services I can do so for, but I don&#x27;t have anything else that needs port 80 to be open on those IPs.<p>I think Stack Exchange&#x27;s solution is probably the right one in that case -- and hopefully anyone who hits it will do so with dev keys rather than in production.</div><br/><div id="40508991" class="c"><input type="checkbox" id="c-40508991" checked=""/><div class="controls bullet"><span class="by">xnorswap</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506222">parent</a><span>|</span><a href="#40506188">next</a><span>|</span><label class="collapse" for="c-40508991">[-]</label><label class="expand" for="c-40508991">[2 more]</label></div><br/><div class="children"><div class="content">I always thought it was bad practice to use the same domain for API and non-API traffic. In the browser there&#x27;ll be a ton of wasted context (cookies) attached to the API request that isn&#x27;t needed.<p>So it&#x27;s better to have &quot;api.example.com&quot; and &quot;www.example.com&quot; kept separate, rather than using &quot;www.example.com&#x2F;api&#x2F;&quot;, where API requests will have inflated headers.</div><br/><div id="40509573" class="c"><input type="checkbox" id="c-40509573" checked=""/><div class="controls bullet"><span class="by">wichert</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508991">parent</a><span>|</span><a href="#40506188">next</a><span>|</span><label class="collapse" for="c-40509573">[-]</label><label class="expand" for="c-40509573">[1 more]</label></div><br/><div class="children"><div class="content">What matters is that there is nothing listening on port 80 on the same IP address. That may be hard to control if you are using an environment with shared ingress.</div><br/></div></div></div></div></div></div><div id="40506188" class="c"><input type="checkbox" id="c-40506188" checked=""/><div class="controls bullet"><span class="by">pixl97</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40505914">parent</a><span>|</span><a href="#40506222">prev</a><span>|</span><a href="#40506673">next</a><span>|</span><label class="collapse" for="c-40506188">[-]</label><label class="expand" for="c-40506188">[4 more]</label></div><br/><div class="children"><div class="content">If someone is in your path they can just fake listen to 80 and intercept, then forward your call to 443.<p>Probably best to listen on 80 and trash the token right then as the majority of the time there won&#x27;t be a MITM and breaking the application will force the developer to change to https</div><br/><div id="40506646" class="c"><input type="checkbox" id="c-40506646" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506188">parent</a><span>|</span><a href="#40506456">next</a><span>|</span><label class="collapse" for="c-40506646">[-]</label><label class="expand" for="c-40506646">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If someone is in your path they can just fake listen to 80 and intercept, then forward your call to 443.<p>They can do that whether or not you are listening on port 80 though.</div><br/><div id="40508502" class="c"><input type="checkbox" id="c-40508502" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506646">parent</a><span>|</span><a href="#40506456">next</a><span>|</span><label class="collapse" for="c-40508502">[-]</label><label class="expand" for="c-40508502">[1 more]</label></div><br/><div class="children"><div class="content">That was OPs point. Not listening on port 80 won&#x27;t help against an active MitM.</div><br/></div></div></div></div><div id="40506456" class="c"><input type="checkbox" id="c-40506456" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40506188">parent</a><span>|</span><a href="#40506646">prev</a><span>|</span><a href="#40506673">next</a><span>|</span><label class="collapse" for="c-40506456">[-]</label><label class="expand" for="c-40506456">[1 more]</label></div><br/><div class="children"><div class="content">But not listening on port 80 will also usually break the application.  Though I suppose the same API key may be used by multiple applications, or multiple copies of an application configured differently.<p>edit: and even if there&#x27;s only one application, yet for whatever reason it doesn&#x27;t get taken down despite being broken, revoking the key now still prevents against a MITM later.</div><br/></div></div></div></div></div></div><div id="40506673" class="c"><input type="checkbox" id="c-40506673" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40505672">parent</a><span>|</span><a href="#40505914">prev</a><span>|</span><a href="#40505788">next</a><span>|</span><label class="collapse" for="c-40506673">[-]</label><label class="expand" for="c-40506673">[1 more]</label></div><br/><div class="children"><div class="content">Well, nothing you do on the server side will protect a client willing to use http: when an MITM is present: the client can still connect to the MITIM, give away its credentials, and your server won&#x27;t know.<p>Still, I agree that this is a very good way to teach your users to not start with http:!  And that this is what one should do.</div><br/></div></div></div></div><div id="40505788" class="c"><input type="checkbox" id="c-40505788" checked=""/><div class="controls bullet"><span class="by">op00to</span><span>|</span><a href="#40505525">parent</a><span>|</span><a href="#40505672">prev</a><span>|</span><a href="#40508363">next</a><span>|</span><label class="collapse" for="c-40505788">[-]</label><label class="expand" for="c-40505788">[1 more]</label></div><br/><div class="children"><div class="content">I love this.</div><br/></div></div><div id="40505858" class="c"><input type="checkbox" id="c-40505858" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40505525">parent</a><span>|</span><a href="#40508363">prev</a><span>|</span><a href="#40508258">next</a><span>|</span><label class="collapse" for="c-40505858">[-]</label><label class="expand" for="c-40505858">[2 more]</label></div><br/><div class="children"><div class="content">Technically correct.</div><br/><div id="40507066" class="c"><input type="checkbox" id="c-40507066" checked=""/><div class="controls bullet"><span class="by">freehorse</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40505858">parent</a><span>|</span><a href="#40508258">next</a><span>|</span><label class="collapse" for="c-40507066">[-]</label><label class="expand" for="c-40507066">[1 more]</label></div><br/><div class="children"><div class="content">Best kind of correct.</div><br/></div></div></div></div><div id="40508258" class="c"><input type="checkbox" id="c-40508258" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#40505525">parent</a><span>|</span><a href="#40505858">prev</a><span>|</span><a href="#40506141">next</a><span>|</span><label class="collapse" for="c-40508258">[-]</label><label class="expand" for="c-40508258">[7 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t this open the door to revoking random API keys sent maliciously ?</div><br/><div id="40508275" class="c"><input type="checkbox" id="c-40508275" checked=""/><div class="controls bullet"><span class="by">Townley</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508258">parent</a><span>|</span><a href="#40508452">next</a><span>|</span><label class="collapse" for="c-40508275">[-]</label><label class="expand" for="c-40508275">[5 more]</label></div><br/><div class="children"><div class="content">If a malicious party has access to the API key, it should be revoked regardless</div><br/><div id="40508460" class="c"><input type="checkbox" id="c-40508460" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508275">parent</a><span>|</span><a href="#40508452">next</a><span>|</span><label class="collapse" for="c-40508460">[-]</label><label class="expand" for="c-40508460">[4 more]</label></div><br/><div class="children"><div class="content">Of course. But I think the poster above was referring to just posting random keys to the server.<p>In other words I don&#x27;t have <i>your</i> key, or any key, but I have &quot;all of them&quot;.<p>The correct response to this though is that &quot;there are lots of keys, and valid keys are sparse.&quot;<p>In other words the jumper of valid keys that could be invalidated in this way is massively smaller than the list of invalid keys. Think trillions of trillions to 1.</div><br/><div id="40508778" class="c"><input type="checkbox" id="c-40508778" checked=""/><div class="controls bullet"><span class="by">ncallaway</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508460">parent</a><span>|</span><a href="#40508745">next</a><span>|</span><label class="collapse" for="c-40508778">[-]</label><label class="expand" for="c-40508778">[2 more]</label></div><br/><div class="children"><div class="content">Which, like, if posting random keys has any realistic plausibility of collision, malicious revoking of keys is the least of your concerns.<p>People could just hit important data fetch endpoints with random keys, until they find one thatâs good, and then have a compromised account.</div><br/><div id="40509398" class="c"><input type="checkbox" id="c-40509398" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508778">parent</a><span>|</span><a href="#40508745">next</a><span>|</span><label class="collapse" for="c-40509398">[-]</label><label class="expand" for="c-40509398">[1 more]</label></div><br/><div class="children"><div class="content">Good point. Presented that way I am seeing more positives to their policies, in particular if a vulnerability was unearthed by the invalidation  quirk it&#x27;s a way better way to find out than any other way.</div><br/></div></div></div></div><div id="40508745" class="c"><input type="checkbox" id="c-40508745" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508460">parent</a><span>|</span><a href="#40508778">prev</a><span>|</span><a href="#40508452">next</a><span>|</span><label class="collapse" for="c-40508745">[-]</label><label class="expand" for="c-40508745">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s wrong that clients are authenticated with just the random generated username. But it&#x27;s also what everyone do.</div><br/></div></div></div></div></div></div><div id="40508452" class="c"><input type="checkbox" id="c-40508452" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#40505525">root</a><span>|</span><a href="#40508258">parent</a><span>|</span><a href="#40508275">prev</a><span>|</span><a href="#40506141">next</a><span>|</span><label class="collapse" for="c-40508452">[-]</label><label class="expand" for="c-40508452">[1 more]</label></div><br/><div class="children"><div class="content">This is just a run-of-the-mill DoS attack, with the astronomically unlikely jackpot of additionally invaliding a random unknown user&#x27;s API key when you get a hit.</div><br/></div></div></div></div></div></div><div id="40506141" class="c"><input type="checkbox" id="c-40506141" checked=""/><div class="controls bullet"><span class="by">athyuttamre</span><span>|</span><a href="#40505525">prev</a><span>|</span><a href="#40505118">next</a><span>|</span><label class="collapse" for="c-40506141">[-]</label><label class="expand" for="c-40506141">[23 more]</label></div><br/><div class="children"><div class="content">Great article! We&#x27;ve updated the OpenAI API to 403 on HTTP requests instead of redirecting.<p><pre><code>  $ curl http:&#x2F;&#x2F;api.openai.com&#x2F;v1&#x2F;chat&#x2F;completions \
  -H &quot;Content-Type: application&#x2F;json&quot; \
  -H &quot;Authorization: Bearer 123&quot; \
  -d &#x27;{}&#x27;

  {
    &quot;error&quot;: {
      &quot;type&quot;: &quot;invalid_request_error&quot;,
      &quot;code&quot;: &quot;http_unsupported&quot;,
      &quot;message&quot;: &quot;The OpenAI API is only accessible over HTTPS. Ensure the URL starts with &#x27;https:&#x2F;&#x2F;&#x27; and not &#x27;http:&#x2F;&#x2F;&#x27;.&quot;,
      &quot;param&quot;: null
    }
  }</code></pre></div><br/><div id="40506944" class="c"><input type="checkbox" id="c-40506944" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#40506141">parent</a><span>|</span><a href="#40508253">next</a><span>|</span><label class="collapse" for="c-40506944">[-]</label><label class="expand" for="c-40506944">[5 more]</label></div><br/><div class="children"><div class="content">Doesnât returning a 403 on HTTP break HSTS?<p><a href="https:&#x2F;&#x2F;security.stackexchange.com&#x2F;questions&#x2F;122441&#x2F;should-hsts-header-be-sent-on-an-error-response" rel="nofollow">https:&#x2F;&#x2F;security.stackexchange.com&#x2F;questions&#x2F;122441&#x2F;should-h...</a><p>Doesnât HSTS require only responding to a user via HTTP<i>S</i> (even for error codes).</div><br/><div id="40507022" class="c"><input type="checkbox" id="c-40507022" checked=""/><div class="controls bullet"><span class="by">mc10</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40506944">parent</a><span>|</span><a href="#40509242">next</a><span>|</span><label class="collapse" for="c-40507022">[-]</label><label class="expand" for="c-40507022">[1 more]</label></div><br/><div class="children"><div class="content">HSTS is intended for browsers. For API clients the correct behavior (following curl&#x27;s lead) is probably to never follow&#x2F;make any redirects by default.</div><br/></div></div><div id="40509242" class="c"><input type="checkbox" id="c-40509242" checked=""/><div class="controls bullet"><span class="by">LinAGKar</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40506944">parent</a><span>|</span><a href="#40507022">prev</a><span>|</span><a href="#40508669">next</a><span>|</span><label class="collapse" for="c-40509242">[-]</label><label class="expand" for="c-40509242">[1 more]</label></div><br/><div class="children"><div class="content">The HSTS header is only effective when it&#x27;s received over HTTPS. And if it has taken effect, the client won&#x27;t try to access HTTP anymore, so it won&#x27;t even know what response it would have gotten from HTTP.</div><br/></div></div><div id="40508669" class="c"><input type="checkbox" id="c-40508669" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40506944">parent</a><span>|</span><a href="#40509242">prev</a><span>|</span><a href="#40507012">next</a><span>|</span><label class="collapse" for="c-40508669">[-]</label><label class="expand" for="c-40508669">[1 more]</label></div><br/><div class="children"><div class="content">What about this then? When the request is made over insecure HTTP, revoke the API key used, but then send the usual redirect response for HSTS. Then, when&#x2F;if the request gets repeated over HTTPS, notice the key is revoked and so respond to that one with 403.</div><br/></div></div><div id="40507012" class="c"><input type="checkbox" id="c-40507012" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40506944">parent</a><span>|</span><a href="#40508669">prev</a><span>|</span><a href="#40508253">next</a><span>|</span><label class="collapse" for="c-40507012">[-]</label><label class="expand" for="c-40507012">[1 more]</label></div><br/><div class="children"><div class="content">HSTS is a note to the browser to insist on TLS when hitting a website.  It is sent as a header, with a timescale, regardless of http&#x2F;https.</div><br/></div></div></div></div><div id="40508253" class="c"><input type="checkbox" id="c-40508253" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#40506141">parent</a><span>|</span><a href="#40506944">prev</a><span>|</span><a href="#40507264">next</a><span>|</span><label class="collapse" for="c-40508253">[-]</label><label class="expand" for="c-40508253">[1 more]</label></div><br/><div class="children"><div class="content">You may want to disable path resolution as well.<p><a href="http:&#x2F;&#x2F;api.openai.com&#x2F;v1&#x2F;chat&#x2F;completions&#x2F;..&#x2F;bar" rel="nofollow">http:&#x2F;&#x2F;api.openai.com&#x2F;v1&#x2F;chat&#x2F;completions&#x2F;..&#x2F;bar</a> responds with error messages about <a href="http:&#x2F;&#x2F;api.openai.com&#x2F;v1&#x2F;chat&#x2F;bar" rel="nofollow">http:&#x2F;&#x2F;api.openai.com&#x2F;v1&#x2F;chat&#x2F;bar</a> which might suggest some path traversal vulnerability that could be exploited.<p>Generally an API client is not going to need .. to be resolved in a path. It should return 400 - Bad Request (deceptive routing).</div><br/></div></div><div id="40507264" class="c"><input type="checkbox" id="c-40507264" checked=""/><div class="controls bullet"><span class="by">Hizonner</span><span>|</span><a href="#40506141">parent</a><span>|</span><a href="#40508253">prev</a><span>|</span><a href="#40506955">next</a><span>|</span><label class="collapse" for="c-40507264">[-]</label><label class="expand" for="c-40507264">[5 more]</label></div><br/><div class="children"><div class="content">Why not just stop listening on port 80, period?</div><br/><div id="40507628" class="c"><input type="checkbox" id="c-40507628" checked=""/><div class="controls bullet"><span class="by">Pesthuf</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507264">parent</a><span>|</span><a href="#40509615">next</a><span>|</span><label class="collapse" for="c-40507628">[-]</label><label class="expand" for="c-40507628">[3 more]</label></div><br/><div class="children"><div class="content">Itâs a good option, but you canât give users a reason for the failure. They might even assume your service is broken.</div><br/><div id="40508036" class="c"><input type="checkbox" id="c-40508036" checked=""/><div class="controls bullet"><span class="by">booi</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507628">parent</a><span>|</span><a href="#40508330">next</a><span>|</span><label class="collapse" for="c-40508036">[-]</label><label class="expand" for="c-40508036">[1 more]</label></div><br/><div class="children"><div class="content">I stopped listening on port 80 for everythingâ¦ nobodyâs complained yet! Maybe because they canât find the service though.</div><br/></div></div><div id="40508330" class="c"><input type="checkbox" id="c-40508330" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507628">parent</a><span>|</span><a href="#40508036">prev</a><span>|</span><a href="#40509615">next</a><span>|</span><label class="collapse" for="c-40508330">[-]</label><label class="expand" for="c-40508330">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s fair to assume j. random user isn&#x27;t typing &quot;<a href="http:&#x2F;&#x2F;api.example.net" rel="nofollow">http:&#x2F;&#x2F;api.example.net</a>&quot; into their web browser.<p>leading www perhaps, leading api no.</div><br/></div></div></div></div><div id="40509615" class="c"><input type="checkbox" id="c-40509615" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507264">parent</a><span>|</span><a href="#40507628">prev</a><span>|</span><a href="#40506955">next</a><span>|</span><label class="collapse" for="c-40509615">[-]</label><label class="expand" for="c-40509615">[1 more]</label></div><br/><div class="children"><div class="content">Because the whole point is a mitm can compromise it, and the mitm can listen on 80 regardless if you turn yours off.</div><br/></div></div></div></div><div id="40506955" class="c"><input type="checkbox" id="c-40506955" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#40506141">parent</a><span>|</span><a href="#40507264">prev</a><span>|</span><a href="#40507077">next</a><span>|</span><label class="collapse" for="c-40506955">[-]</label><label class="expand" for="c-40506955">[3 more]</label></div><br/><div class="children"><div class="content">This is better as it allow you to immediately notice that there&#x27;s an issue. However it still facilitates api key exposing on the initial request.</div><br/><div id="40507219" class="c"><input type="checkbox" id="c-40507219" checked=""/><div class="controls bullet"><span class="by">NotYourLawyer</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40506955">parent</a><span>|</span><a href="#40507077">next</a><span>|</span><label class="collapse" for="c-40507219">[-]</label><label class="expand" for="c-40507219">[2 more]</label></div><br/><div class="children"><div class="content">How would the endpoint prevent that?</div><br/><div id="40507808" class="c"><input type="checkbox" id="c-40507808" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507219">parent</a><span>|</span><a href="#40507077">next</a><span>|</span><label class="collapse" for="c-40507808">[-]</label><label class="expand" for="c-40507808">[1 more]</label></div><br/><div class="children"><div class="content">Not listening on port 80, such that the user gets a connection refused, would result in the client not sending the api key over the wire at all.<p>I personally think listening, accepting that user mistakes can expose API keys to MITMs, and returning the user-facing error is better than a &quot;connection refused&quot; error, but it is a tradeoff.</div><br/></div></div></div></div></div></div><div id="40507077" class="c"><input type="checkbox" id="c-40507077" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40506141">parent</a><span>|</span><a href="#40506955">prev</a><span>|</span><a href="#40505118">next</a><span>|</span><label class="collapse" for="c-40507077">[-]</label><label class="expand" for="c-40507077">[8 more]</label></div><br/><div class="children"><div class="content">If anybody is looking to copy in a public API, please return 400 and don&#x27;t misuse a standard code.</div><br/><div id="40508423" class="c"><input type="checkbox" id="c-40508423" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507077">parent</a><span>|</span><a href="#40507209">next</a><span>|</span><label class="collapse" for="c-40508423">[-]</label><label class="expand" for="c-40508423">[1 more]</label></div><br/><div class="children"><div class="content">Why do you think 403 is the wrong error code? Based on the spec it seems entirely appropriate to me:<p>&gt; HTTP 403 provides a distinct error case from HTTP 401; while HTTP 401 is returned when the client has not authenticated, and implies that a successful response may be returned following valid authentication, HTTP 403 is returned when the client is not permitted access to the resource despite providing authentication such as insufficient permissions of the authenticated account.[a]<p>&gt; Error 403: &quot;The server understood the request, but is refusing to authorize it.&quot; (RFC 7231)</div><br/></div></div><div id="40507209" class="c"><input type="checkbox" id="c-40507209" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507077">parent</a><span>|</span><a href="#40508423">prev</a><span>|</span><a href="#40508480">next</a><span>|</span><label class="collapse" for="c-40507209">[-]</label><label class="expand" for="c-40507209">[5 more]</label></div><br/><div class="children"><div class="content">400 is usually for a malformed request. It seems like in this case the request is well formed, it&#x27;s just not allowed. 403 seems reasonable if the user isn&#x27;t authorized to make a request to the URL, which they aren&#x27;t. Some APIs return redirects which also seems pretty reasonable.</div><br/><div id="40508032" class="c"><input type="checkbox" id="c-40508032" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507209">parent</a><span>|</span><a href="#40507437">next</a><span>|</span><label class="collapse" for="c-40508032">[-]</label><label class="expand" for="c-40508032">[1 more]</label></div><br/><div class="children"><div class="content">But that also implies that <i>some</i> user would be authorized to make a request to the HTTP port (or that the resource does exist, which in this case it doesnât).<p>IMO, 400 is more accurate, but really either could be acceptable, so long as the client is notified of the error. But, I wouldnât automatically redirect the client. Thatâs what we are trying to avoid.</div><br/></div></div><div id="40507437" class="c"><input type="checkbox" id="c-40507437" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507209">parent</a><span>|</span><a href="#40508032">prev</a><span>|</span><a href="#40507383">next</a><span>|</span><label class="collapse" for="c-40507437">[-]</label><label class="expand" for="c-40507437">[2 more]</label></div><br/><div class="children"><div class="content">404 would also work, since the resource does not exist at the http: address.</div><br/><div id="40508485" class="c"><input type="checkbox" id="c-40508485" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507437">parent</a><span>|</span><a href="#40507383">next</a><span>|</span><label class="collapse" for="c-40508485">[-]</label><label class="expand" for="c-40508485">[1 more]</label></div><br/><div class="children"><div class="content">True, but 404 has trained us to look hard at the URL part, not the protocol part.<p>Whereas 403 or 400 are less likely to have so automated built-in handling on the client side.</div><br/></div></div></div></div><div id="40507383" class="c"><input type="checkbox" id="c-40507383" checked=""/><div class="controls bullet"><span class="by">endofreach</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507209">parent</a><span>|</span><a href="#40507437">prev</a><span>|</span><a href="#40508480">next</a><span>|</span><label class="collapse" for="c-40507383">[-]</label><label class="expand" for="c-40507383">[1 more]</label></div><br/><div class="children"><div class="content">Well in that case really anything is a 403.</div><br/></div></div></div></div><div id="40508480" class="c"><input type="checkbox" id="c-40508480" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#40506141">root</a><span>|</span><a href="#40507077">parent</a><span>|</span><a href="#40507209">prev</a><span>|</span><a href="#40505118">next</a><span>|</span><label class="collapse" for="c-40508480">[-]</label><label class="expand" for="c-40508480">[1 more]</label></div><br/><div class="children"><div class="content">Not sure how I feel about this (extremely arbitrary) distinction. 400 Bad Request maybe implies that no matter how many times you retry the request, it will never succeed. 403 Forbidden maybe implies that some external change in the authentication system could perhaps allow the same request to succeed in the future? So I guess in that lens I can see the logic, but again, seems extremely arbitrary.</div><br/></div></div></div></div></div></div><div id="40505118" class="c"><input type="checkbox" id="c-40505118" checked=""/><div class="controls bullet"><span class="by">justin_oaks</span><span>|</span><a href="#40506141">prev</a><span>|</span><a href="#40508183">next</a><span>|</span><label class="collapse" for="c-40505118">[-]</label><label class="expand" for="c-40505118">[3 more]</label></div><br/><div class="children"><div class="content">I appreciate the author calling this out because creating an HTTP-redirect-to-HTTPS is something I&#x27;ll do almost without thinking about it. &quot;If it has HTTPS, I&#x27;ll set up an HTTP redirect.&quot; Now I know that I need to think about it before setting that up.<p>It also made me realize that cURL&#x27;s default to not redirect automatically is probably intentional and is a good default. Praise be to Daniel Stenberg for this choice when implementing cURL.</div><br/><div id="40505523" class="c"><input type="checkbox" id="c-40505523" checked=""/><div class="controls bullet"><span class="by">tootie</span><span>|</span><a href="#40505118">parent</a><span>|</span><a href="#40505385">next</a><span>|</span><label class="collapse" for="c-40505523">[-]</label><label class="expand" for="c-40505523">[1 more]</label></div><br/><div class="children"><div class="content">Using Cloudfront, the redirect was the only built-in option for a long time. They only added pushbutton HSTS recently. But I&#x27;d say author is correct that if you&#x27;re hosting an API there&#x27;s no reason to support http at all. Just send a 400 on all requests and let the client developers use common sense.</div><br/></div></div></div></div><div id="40508183" class="c"><input type="checkbox" id="c-40508183" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#40505118">prev</a><span>|</span><a href="#40505392">next</a><span>|</span><label class="collapse" for="c-40508183">[-]</label><label class="expand" for="c-40508183">[1 more]</label></div><br/><div class="children"><div class="content">As a non-developer, ordinary computer user &quot;providing service&quot; for one user (yours truly) it&#x27;s easy for me to configure the TLS forward proxy listening on the loopback to send _all_ HTTP requests, from _any_ application, including ones sent to port 80, via HTTPS.  This I find preferable to letting a browser try to convert HTTP to HTTPS, e.g., &quot;HTTPS Everywhere&quot;, or letting a developer do it with a redirect.  Personally, I compile clients without linking to a TLS library.  They are smaller without it and I do not have to worry about every author having correctly added TLS support.  When SSL&#x2F;TLS changes, applications using it often need to be updated, and some authors have made mistakes, socat being one example that comes to mind.  I do 100% of TLS negotiation using a single program: the proxy.  Every HTTP request on the home network goes to the proxy.</div><br/></div></div><div id="40505392" class="c"><input type="checkbox" id="c-40505392" checked=""/><div class="controls bullet"><span class="by">dfabulich</span><span>|</span><a href="#40508183">prev</a><span>|</span><a href="#40509807">next</a><span>|</span><label class="collapse" for="c-40505392">[-]</label><label class="expand" for="c-40505392">[16 more]</label></div><br/><div class="children"><div class="content">The author includes a surprising response from &quot;Provider B&quot; to the HackerOne report.<p>&gt; <i>Provider B: Reported on 2024-05-21 through their HackerOne program. Got a prompt triage response, stating that attacks requiring MITM (or physical access to a user&#x27;s device) are outside the scope of the program. Sent back a response explaining that MITM or physical access was not required for sniffing. Awaiting response.</i><p>I think Provider B morally should require HTTPS, but it really surprises me that the author would say &quot;MITM or physical access is not required for sniffing.&quot;<p>Is that true? Isn&#x27;t HTTP sniffing an example of a MITM attack, by definition? Am I using the words &quot;MITM&quot; or &quot;sniffing&quot; differently from the author?<p>I&#x27;m familiar with the following attacks, all of which I&#x27;d call &quot;MITM&quot;:<p>1. Public unencrypted (or weakly WEP encrypted) wifi, with clients connecting to HTTP websites. Other clients on the same wifi network can read the unencrypted HTTP packets over the air.<p>2. Public encrypted wifi, where the attacker controls the wifi network (or runs a proxy wifi with the same&#x2F;similar SSID,) tricking the client into connecting to the attacker over non-TLS HTTP.<p>3. ISP-level attacks where the ISP reads the packets between you and the HTTP website.<p>Aren&#x27;t all of these MITM attacks, or at the very least &quot;physical access&quot; attacks? How could anyone possibly perform HTTP sniffing without MITM or physical access??</div><br/><div id="40509356" class="c"><input type="checkbox" id="c-40509356" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#40505392">parent</a><span>|</span><a href="#40506005">next</a><span>|</span><label class="collapse" for="c-40509356">[-]</label><label class="expand" for="c-40509356">[1 more]</label></div><br/><div class="children"><div class="content">At the end of the day it doesn&#x27;t matter how you define &quot;MITM&quot;. HTTPS means that <i>even if</i> I control a network hop in between the two endpoints, I can&#x27;t get the key. Provider B says &quot;we are OK with any hop on your route gaining access to your keys&quot; (e.g. via owning a wifi router and giving customers access, or via being a customer and sniffing other customer&#x27;s traffic, or the industrial-level equivalents of this).</div><br/></div></div><div id="40506005" class="c"><input type="checkbox" id="c-40506005" checked=""/><div class="controls bullet"><span class="by">HL33tibCe7</span><span>|</span><a href="#40505392">parent</a><span>|</span><a href="#40509356">prev</a><span>|</span><a href="#40506465">next</a><span>|</span><label class="collapse" for="c-40506005">[-]</label><label class="expand" for="c-40506005">[7 more]</label></div><br/><div class="children"><div class="content">MITM generally refers to someone who can intercept and modify traffic, i.e. they sit âin the middleâ, between you and your recipient, reading&#x2F;modifying&#x2F;relaying traffic.<p>âPassive eavesdropperâ is often used to describe what you talk about. Someone on an unencrypted WiFi network sniffing your traffic isnât really âin the middleâ at all, after all.</div><br/><div id="40507163" class="c"><input type="checkbox" id="c-40507163" checked=""/><div class="controls bullet"><span class="by">syncsynchalt</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506005">parent</a><span>|</span><a href="#40506445">next</a><span>|</span><label class="collapse" for="c-40507163">[-]</label><label class="expand" for="c-40507163">[1 more]</label></div><br/><div class="children"><div class="content">Eve and Mallory are both MITM, in my opinion.</div><br/></div></div><div id="40506445" class="c"><input type="checkbox" id="c-40506445" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506005">parent</a><span>|</span><a href="#40507163">prev</a><span>|</span><a href="#40506150">next</a><span>|</span><label class="collapse" for="c-40506445">[-]</label><label class="expand" for="c-40506445">[1 more]</label></div><br/><div class="children"><div class="content">I agree that&#x27;s not a case of MITM, but I do think it&#x27;s fair to call sitting in range of the same Wi-Fi access point &quot;physical access&quot;.</div><br/></div></div><div id="40506150" class="c"><input type="checkbox" id="c-40506150" checked=""/><div class="controls bullet"><span class="by">Control8894</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506005">parent</a><span>|</span><a href="#40506445">prev</a><span>|</span><a href="#40506465">next</a><span>|</span><label class="collapse" for="c-40506150">[-]</label><label class="expand" for="c-40506150">[4 more]</label></div><br/><div class="children"><div class="content">I disagree. So does Wikipedia (&quot;where the attacker secretly relays and possibly alters the communications between two parties who believe that they are directly communicating with each other, as the attacker has inserted themselves between the two parties ... for example, an attacker within range of an Wi-Fi access point hosting a network without encryption could insert themselves as a man in the middle&quot;) and so I believe do most people.<p>&quot;Active MITM&quot; would be how you describe someone who does modify traffic.<p>And an attacker in each of the scenarios GP mentioned <i>can</i> modify traffic. (For ISP&#x2F;attacker-controlled networks it&#x27;s trivial; for other networks you just need to ARP spoof)</div><br/><div id="40506244" class="c"><input type="checkbox" id="c-40506244" checked=""/><div class="controls bullet"><span class="by">dTP90pN</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506150">parent</a><span>|</span><a href="#40506465">next</a><span>|</span><label class="collapse" for="c-40506244">[-]</label><label class="expand" for="c-40506244">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no &quot;relaying&quot; when the the attacker just captures unencrypted WiFi packets from the air, or more traditionally, splits some light out of the fiber line.</div><br/><div id="40506592" class="c"><input type="checkbox" id="c-40506592" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506244">parent</a><span>|</span><a href="#40506249">next</a><span>|</span><label class="collapse" for="c-40506592">[-]</label><label class="expand" for="c-40506592">[1 more]</label></div><br/><div class="children"><div class="content">I hate to agree but they are right. Endpoint-spoofing and relaying between two spoofed endpoinbts is just one of the possible forms of mitm attack that just happens to be required if you happen need to open and re-pack encryption in order to evesdrop, or if you need to modify the data.<p>Spoofing the two endpoints to decrypt and re-encrypt, just so that you can evesdrop without modifying the data (other than the encryption) is certainly still &quot;mitm&quot;. Yet all the man in the middle did was evesdrop. Becoming two endpoints in the middle was only an implimentetion detail required because of the encryption.<p>If you are admin of one of the mail servers along the way between sender and recipient and and can read all the plain smtp messages that pass through your hands like postcards without having to decrypt or spoof endpoints, that is still mitm.<p>So listening to wifi is no less. There is nothing substantive that makes it any different.<p>For endpoint-spoofing to be required for mitm, you would have to say that mitm only applies to modifying the data, which I don&#x27;t think is so. Several purely evesdropping applications are still called mitm.</div><br/></div></div><div id="40506249" class="c"><input type="checkbox" id="c-40506249" checked=""/><div class="controls bullet"><span class="by">Control8894</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506244">parent</a><span>|</span><a href="#40506592">prev</a><span>|</span><a href="#40506465">next</a><span>|</span><label class="collapse" for="c-40506249">[-]</label><label class="expand" for="c-40506249">[1 more]</label></div><br/><div class="children"><div class="content">&gt; for example, an attacker within range of an Wi-Fi access point hosting a network without encryption<p>The monkey in the middle doesn&#x27;t get to &quot;relay&quot; anything either, but he can sure see it going over his head.</div><br/></div></div></div></div></div></div></div></div><div id="40506465" class="c"><input type="checkbox" id="c-40506465" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#40505392">parent</a><span>|</span><a href="#40506005">prev</a><span>|</span><a href="#40505430">next</a><span>|</span><label class="collapse" for="c-40506465">[-]</label><label class="expand" for="c-40506465">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think people would consider 1 or 3 to be MITM. MITM requires someone who is, well, in the middle: you connect to the MITM, and they connect to your destination. 2 is clearly a MITM.<p>Also, while 1 is arguably a case of &quot;physical access&quot;, I don&#x27;t think 3 is. If you have a tap in an ISP, you don&#x27;t have &quot;physical access&quot; to any of the endpoints of the HTTP connection. Otherwise, you could say you have &quot;physical access&quot; to literally every machine on the internet, since there is some physical path between you and that machine.<p>For another example, Kubernetes started as IPv4-only, and there are still plenty of plugins that have IPv4-only features.</div><br/></div></div><div id="40505430" class="c"><input type="checkbox" id="c-40505430" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#40505392">parent</a><span>|</span><a href="#40506465">prev</a><span>|</span><a href="#40505800">next</a><span>|</span><label class="collapse" for="c-40505430">[-]</label><label class="expand" for="c-40505430">[1 more]</label></div><br/><div class="children"><div class="content">Definition question. I can see your reasoning and I can see the author&#x27;s, where they define MITM as requiring an active component being in the middle to actually tamper with it and not just some far-off device receiving backscatter with a high-gain antenna, or a read-only mirror port on a switch or whatever is technically not &quot;in the middle&quot; but in a cul-de-sac. I&#x27;m not sure I&#x27;ve got a strong opinion, claiming one or the other is the only correct definition might just be nitpicking<p>They may have chosen this wording (&quot;it&#x27;s not MITM&quot;) to get the team into action rather than dismissing the risk<p>Edit: another legitimate-sounding question downvoted in this thread without further comment (since I&#x27;m the only comment still after it got downvoted). Can people maybe just explain what&#x27;s wrong with a post when it&#x27;s not a personal attack, not off topic, not answered in the article, or any other obvious downvote reason? Everyone would appreciate the author learning from the problem if there is one</div><br/></div></div><div id="40505800" class="c"><input type="checkbox" id="c-40505800" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#40505392">parent</a><span>|</span><a href="#40505430">prev</a><span>|</span><a href="#40509807">next</a><span>|</span><label class="collapse" for="c-40505800">[-]</label><label class="expand" for="c-40505800">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Public unencrypted (or weakly WEP encrypted) wifi, with clients connecting to HTTP websites. Other clients on the same wifi network can read the unencrypted HTTP packets over the air.<p>That&#x27;s sniffing. The other two are MITM. The sniffer isn&#x27;t in the middle of anything; you never speak to him.</div><br/><div id="40506702" class="c"><input type="checkbox" id="c-40506702" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40505800">parent</a><span>|</span><a href="#40509807">next</a><span>|</span><label class="collapse" for="c-40506702">[-]</label><label class="expand" for="c-40506702">[4 more]</label></div><br/><div class="children"><div class="content">You have to mitm in order to evesdrop on an encrypted channel. If you do nothing but evesdrop, isn&#x27;t it still mitm? You had to actively replace &amp; spoof the two endpoints, but that is just a technicality required by the encryption, in the end you still only evesdropped, yet it was still called mitm.<p>So, mere evesdropping is mitm. So, how is evesdropping on unencrypted traffic or wifi traffic meaningfully different than evesdropping by decrypt &amp; reencrypt?<p>I don&#x27;t think the term mitm includes a requirement that you aren&#x27;t talking to who you thought you were talking to, because generally you <i>do</i> still talk to who you thought you were, just not directly.<p>The traffic <i>may</i> be modified along the way rather than merely copied, or one or the other endpoint <i>may</i> be wholly faked rather than merely relayed, but they also may not be, the attacker may simply relay everything verbatim in both directions, IE pure evesdropping, and the attack would still be called mitm.<p>Then again, I guess a keylogger is evesdropping and not called mitm.</div><br/><div id="40506751" class="c"><input type="checkbox" id="c-40506751" checked=""/><div class="controls bullet"><span class="by">danparsonson</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506702">parent</a><span>|</span><a href="#40508589">next</a><span>|</span><label class="collapse" for="c-40506751">[-]</label><label class="expand" for="c-40506751">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You have to mitm in order to evesdrop on an encrypted channel.<p>OK but we&#x27;re talking about evesdropping HTTP, which is unencrypted.</div><br/><div id="40508562" class="c"><input type="checkbox" id="c-40508562" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506751">parent</a><span>|</span><a href="#40508589">next</a><span>|</span><label class="collapse" for="c-40508562">[-]</label><label class="expand" for="c-40508562">[1 more]</label></div><br/><div class="children"><div class="content">So what? My point was the encryption doesn&#x27;t matter, it&#x27;s just the reason you have to impersonate in order to merely evesdrop sometimes.</div><br/></div></div></div></div><div id="40508589" class="c"><input type="checkbox" id="c-40508589" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#40505392">root</a><span>|</span><a href="#40506702">parent</a><span>|</span><a href="#40506751">prev</a><span>|</span><a href="#40509807">next</a><span>|</span><label class="collapse" for="c-40508589">[-]</label><label class="expand" for="c-40508589">[1 more]</label></div><br/><div class="children"><div class="content">&gt; because generally you do still talk to who you thought you were, just not directly.<p>...that&#x27;s the requirement. The indirection of someone interposing themselves between you and the party you&#x27;re trying to speak to is what is referred to by the phrase &quot;man in the middle&quot;.<p>There is no phrase &quot;man to the side&quot;. If you don&#x27;t represent yourself as being the party they want to talk to, you aren&#x27;t performing a man-in-the-middle attack.</div><br/></div></div></div></div></div></div></div></div><div id="40509807" class="c"><input type="checkbox" id="c-40509807" checked=""/><div class="controls bullet"><span class="by">alt227</span><span>|</span><a href="#40505392">prev</a><span>|</span><a href="#40509553">next</a><span>|</span><label class="collapse" for="c-40509807">[-]</label><label class="expand" for="c-40509807">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The initial code commit contained a mistyped API base URL &quot;<a href="http:&#x2F;&#x2F;" rel="nofollow">http:&#x2F;&#x2F;</a>...&quot; instead of &quot;<a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a>...&quot;. A pretty easy mistake to make.<p>A pretty easy mistake to make if you dont really care about security. This should have been picked up at multiple points in development. Its like the author made a mistake and is now blaming every API on the internet for not picking him up on it.</div><br/></div></div><div id="40509553" class="c"><input type="checkbox" id="c-40509553" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#40509807">prev</a><span>|</span><a href="#40505189">next</a><span>|</span><label class="collapse" for="c-40509553">[-]</label><label class="expand" for="c-40509553">[1 more]</label></div><br/><div class="children"><div class="content">If you are paying the cost of a TLS handshake, which you will have to anyway, why not just use client certificates to authenticate (mTLS) instead of hand rolled and rudimentary auth tokens on top. gRPC has built-in support for mTLS and it could be a good time to modernize your endpoints if you are looking to invest time to improve your API security.</div><br/></div></div><div id="40505189" class="c"><input type="checkbox" id="c-40505189" checked=""/><div class="controls bullet"><span class="by">snowwrestler</span><span>|</span><a href="#40509553">prev</a><span>|</span><a href="#40505681">next</a><span>|</span><label class="collapse" for="c-40505189">[-]</label><label class="expand" for="c-40505189">[1 more]</label></div><br/><div class="children"><div class="content">HTTPS and SVCB DNS records will hopefully make it more feasible over time to drop the traditional HTTP server-side redirect. The client agent will be able to read the DNS record and upgrade to the highest available protocol prior to sending the first request.</div><br/></div></div><div id="40505681" class="c"><input type="checkbox" id="c-40505681" checked=""/><div class="controls bullet"><span class="by">ikisusi</span><span>|</span><a href="#40505189">prev</a><span>|</span><a href="#40507089">next</a><span>|</span><label class="collapse" for="c-40505681">[-]</label><label class="expand" for="c-40505681">[1 more]</label></div><br/><div class="children"><div class="content">I hope that providers whose APIs responded and interacted fully over unencrypted HTTP would go back to their historical access logs and check how widespread using plaintext HTTP is. If they don&#x27;t have access logs for their API then they could just sample next 24 hours for API accesses.<p>Popular providers have so many API users today that even a rare mistake could expose quite many users in absolute numbers. Would rather have providers to check this out rather than have this poor practice abused by the next DNS hijacking malware affecting home routers.</div><br/></div></div><div id="40507089" class="c"><input type="checkbox" id="c-40507089" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#40505681">prev</a><span>|</span><a href="#40505991">next</a><span>|</span><label class="collapse" for="c-40507089">[-]</label><label class="expand" for="c-40507089">[3 more]</label></div><br/><div class="children"><div class="content">Revoking an API key upon a single http request assumes you have a competent team. Have worked with people that have committed sensitive credentials into public repositories, used PRODUCTION secrets for testing, and of course sharing secrets in plain text over IM and group chats.<p>The number of times I have had to deal with password or secret key resets because of this is way too high. I remember working with a guy that thought sharing a demo of an internal application on YouTube was okay. Of course it had snippets of company secrets and development API keys clearly visible in the demo.</div><br/><div id="40508305" class="c"><input type="checkbox" id="c-40508305" checked=""/><div class="controls bullet"><span class="by">loa_in_</span><span>|</span><a href="#40507089">parent</a><span>|</span><a href="#40505991">next</a><span>|</span><label class="collapse" for="c-40508305">[-]</label><label class="expand" for="c-40508305">[2 more]</label></div><br/><div class="children"><div class="content">It assumes nothing like that. It provides you and your team with a safe opportunity to learn and grow.<p>Revoking a key like this is a problem that&#x27;s solution is at worst a dozen clicks away fix. The alternative, leaking keys can be much worse.<p>So go and reset those creds for the guy who made a mistake happily and be grateful. He had an opportunity to learn.</div><br/><div id="40508552" class="c"><input type="checkbox" id="c-40508552" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#40507089">root</a><span>|</span><a href="#40508305">parent</a><span>|</span><a href="#40505991">next</a><span>|</span><label class="collapse" for="c-40508552">[-]</label><label class="expand" for="c-40508552">[1 more]</label></div><br/><div class="children"><div class="content">It might be optimistic to say that rolling over to a new key is &#x27;at most a dozen clicks&#x27;.<p>Hardcoded keys are a big one. But even just hunting down all config where the key needs to change can be a major hassle. Is there some ci yaml that expects a runner to have the key in a .env file that only runs on major release? Good chance you won&#x27;t realize that key exists.<p>Still a great idea to revoke those keys. But it will damage some customers in the short term. And they will be angry, as people often are when you demonstrate their mistake.</div><br/></div></div></div></div></div></div><div id="40505991" class="c"><input type="checkbox" id="c-40505991" checked=""/><div class="controls bullet"><span class="by">amanzi</span><span>|</span><a href="#40507089">prev</a><span>|</span><a href="#40504956">next</a><span>|</span><label class="collapse" for="c-40505991">[-]</label><label class="expand" for="c-40505991">[1 more]</label></div><br/><div class="children"><div class="content">Interesting - I hadn&#x27;t considered this before, but makes perfect sense. Feels like it&#x27;s something that&#x27;s easy to miss, as lots of APIs are hosted behind generic web application firewalls that often have automatic HTTPS redirection as a base rule.</div><br/></div></div><div id="40504956" class="c"><input type="checkbox" id="c-40504956" checked=""/><div class="controls bullet"><span class="by">medellin</span><span>|</span><a href="#40505991">prev</a><span>|</span><a href="#40505381">next</a><span>|</span><label class="collapse" for="c-40504956">[-]</label><label class="expand" for="c-40504956">[2 more]</label></div><br/><div class="children"><div class="content">I fully support this and have always pushed for this. One because it becomes a huge mess to maintain over time but also because it long term will lower traffic through the LB.<p>Unfortunately what i see happen all the time is quick fixes are pushed to the infra. For example they deploy and typo the URL. Now we have a prod outage and infra is pulled in to fix this asap. No time to wait for that 10 minute deploy pipeline that requires all the tests to run and a deploy to dev.<p>This happens once and then infra is asked why we donât already redirect all URLs. Management doesnât care about security and they just lost money. Guess what you are doing now. This is the world we live in.</div><br/><div id="40505026" class="c"><input type="checkbox" id="c-40505026" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#40504956">parent</a><span>|</span><a href="#40505381">next</a><span>|</span><label class="collapse" for="c-40505026">[-]</label><label class="expand" for="c-40505026">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Itâs probably why so many APIs accept the api key in the URL.</div><br/></div></div></div></div><div id="40505381" class="c"><input type="checkbox" id="c-40505381" checked=""/><div class="controls bullet"><span class="by">sdsd</span><span>|</span><a href="#40504956">prev</a><span>|</span><a href="#40505755">next</a><span>|</span><label class="collapse" for="c-40505381">[-]</label><label class="expand" for="c-40505381">[18 more]</label></div><br/><div class="children"><div class="content">My personal website (darigo.su) doesn&#x27;t have HTTPS. I just deployed it a few months ago and haven&#x27;t really done much with it yet. I guess I&#x27;ll have to get around to it eventually, but I find charm in small old sites that haven&#x27;t implemented modern protocol stuff. My site also uses &lt;font&gt; and &lt;center&gt; tags all over the place.<p>Maybe I&#x27;ll do some more quirky anachronisms, like only serve the site via HTTP 1.0 or something. Who knows. Since my site has very little functionality, it doesn&#x27;t really matter, it&#x27;s just for fun.</div><br/><div id="40506107" class="c"><input type="checkbox" id="c-40506107" checked=""/><div class="controls bullet"><span class="by">HL33tibCe7</span><span>|</span><a href="#40505381">parent</a><span>|</span><a href="#40508574">next</a><span>|</span><label class="collapse" for="c-40506107">[-]</label><label class="expand" for="c-40506107">[1 more]</label></div><br/><div class="children"><div class="content">To me, HTTPS is worth it alone to eliminate the possibility of the ISPs of people reading my site from injecting shit (ads, trackers, etc.) into the responses I send to them.<p>Itâs completely trivial to set up, thereâs really no downside at this point.</div><br/></div></div><div id="40508574" class="c"><input type="checkbox" id="c-40508574" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40505381">parent</a><span>|</span><a href="#40506107">prev</a><span>|</span><a href="#40505461">next</a><span>|</span><label class="collapse" for="c-40508574">[-]</label><label class="expand" for="c-40508574">[4 more]</label></div><br/><div class="children"><div class="content">I see this a lot. You&#x27;ve just made a small non-interactive site, and there&#x27;s nothing secret. So why bother either https?<p>Well, firstly, I&#x27;d say, make ot https for fun. It&#x27;s pretty simple to do, makes itself automatic, and costs no money. Just exploring this route can be very illuminating.<p>Secondly it prevents your site from being altered by the outside. There&#x27;s a lot of equipment between your site and the client. Being HTTP allows it to be altered along the way.<p>Gor example, and thd least serious, is that your ISP can inject adverts onto your page. Most ISPs don&#x27;t do this, but quite a few do.<p>Second, a malicious user could inject additional text onto upur pages, proclaiming your love for a political party, some racial or misogynistic slur, or whatever.<p>Third, you&#x27;re sending a signal to all that you either don&#x27;t understand the security risks, or don&#x27;t care about them. This can have consequences (reputationally) if you are in, or going into, a computing career.<p>Making it HTTPS can be fun too!</div><br/><div id="40509034" class="c"><input type="checkbox" id="c-40509034" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40508574">parent</a><span>|</span><a href="#40509669">next</a><span>|</span><label class="collapse" for="c-40509034">[-]</label><label class="expand" for="c-40509034">[2 more]</label></div><br/><div class="children"><div class="content">The bigger issue is that a malicious interceptor could inject javascript. The site may not use javascript, but the users almost certainly have it turned on, and accessing a non-https site means that any man in the middle can inject malicious javascript.<p>HTTPS is about protecting the client.</div><br/><div id="40509287" class="c"><input type="checkbox" id="c-40509287" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40509034">parent</a><span>|</span><a href="#40509669">next</a><span>|</span><label class="collapse" for="c-40509287">[-]</label><label class="expand" for="c-40509287">[1 more]</label></div><br/><div class="children"><div class="content">E.g. China&#x27;s great firewall sometimes inserts malicious Javascript that causes the client to launch a DDoS attack against Github or other sites China doesn&#x27;t like.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Great_Cannon" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Great_Cannon</a></div><br/></div></div></div></div><div id="40509669" class="c"><input type="checkbox" id="c-40509669" checked=""/><div class="controls bullet"><span class="by">noirscape</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40508574">parent</a><span>|</span><a href="#40509034">prev</a><span>|</span><a href="#40505461">next</a><span>|</span><label class="collapse" for="c-40509669">[-]</label><label class="expand" for="c-40509669">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, hard disagree. I get the push for HTTPS, but setting up HTTPS nowadays isn&#x27;t fun. It&#x27;s more or less 4 steps;<p>1. Install and run certbot (+the DNS plugin for your DNS provider).<p>2. Find an nginx config file on the internet that only includes the necessary ciphers to work on modern devices. Then include that config file + lines to your cert paths that certbot spits out into your nginx config.<p>3. Set up a generic redirect server block to send everything on port 80 to port 443.<p>4. Reboot nginx.<p>It&#x27;s at least better than fiddling with openssl directly, but this isn&#x27;t fun, it&#x27;s busywork.</div><br/></div></div></div></div><div id="40505461" class="c"><input type="checkbox" id="c-40505461" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40505381">parent</a><span>|</span><a href="#40508574">prev</a><span>|</span><a href="#40506523">next</a><span>|</span><label class="collapse" for="c-40505461">[-]</label><label class="expand" for="c-40505461">[2 more]</label></div><br/><div class="children"><div class="content">Thatâs fine, but rather unrelated to the article, which is about the situation that you have an API served via HTTPS, and the question of whether you should also have a redirect from HTTP to HTTPS in that case, or rather return an HTTP error.</div><br/><div id="40505962" class="c"><input type="checkbox" id="c-40505962" checked=""/><div class="controls bullet"><span class="by">sdsd</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40505461">parent</a><span>|</span><a href="#40506523">next</a><span>|</span><label class="collapse" for="c-40505962">[-]</label><label class="expand" for="c-40505962">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I should have clarified. Nothing to do with the article really, just a random thought. Sorry if too off-topic!</div><br/></div></div></div></div><div id="40506523" class="c"><input type="checkbox" id="c-40506523" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#40505381">parent</a><span>|</span><a href="#40505461">prev</a><span>|</span><a href="#40505549">next</a><span>|</span><label class="collapse" for="c-40506523">[-]</label><label class="expand" for="c-40506523">[5 more]</label></div><br/><div class="children"><div class="content">When a user visits your site with a modern browser in default configuration they&#x27;ll get an error page along the lines of:<p><pre><code>  Secure site not available

  Most likely, the web site simply does not support HTTPS.

  However, itâs also possible that an attacker is involved. If you continue to the web site, you should not enter any sensitive info. If you continue, HTTPS-Only mode will be turned off temporarily for the site.

  [Continue to HTTP site]
</code></pre>
(Copied from Firefox on Android)<p>Personally I think that&#x27;s reason to do it alone, for the price of a free Let&#x27;s Encrypt cert you can deliver much better UX. You presumably <i>want</i> people to visit your site.</div><br/><div id="40506671" class="c"><input type="checkbox" id="c-40506671" checked=""/><div class="controls bullet"><span class="by">sdsd</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40506523">parent</a><span>|</span><a href="#40505549">next</a><span>|</span><label class="collapse" for="c-40506671">[-]</label><label class="expand" for="c-40506671">[4 more]</label></div><br/><div class="children"><div class="content">&gt;When a user visits your site with a modern browser in default configuration they&#x27;ll get an error page along the lines of:<p>Neither desktop firefox nor chrome seem to do this by default, at least on my Mac (actually I think I&#x27;m wrong about Firefox on desktop as well, thanks to a guestbook signer!). Maybe it&#x27;s a Firefox mobile thing, rather than a modernity thing?<p>&gt;for the price of a free Let&#x27;s Encrypt cert you can deliver much better UX<p>I&#x27;m going to get around to it, I promise haha.<p>Btw if anyone does visit the site, please do sign my guestbook: <a href="http:&#x2F;&#x2F;darigo.su&#x2F;33chan" rel="nofollow">http:&#x2F;&#x2F;darigo.su&#x2F;33chan</a> (but be warned, a MITM might intercept and alter your comment!!)</div><br/><div id="40506788" class="c"><input type="checkbox" id="c-40506788" checked=""/><div class="controls bullet"><span class="by">prettymuchnoone</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40506671">parent</a><span>|</span><a href="#40505549">next</a><span>|</span><label class="collapse" for="c-40506788">[-]</label><label class="expand" for="c-40506788">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Neither desktop firefox nor chrome seem to do this by default<p>they do, you probably just checked the &quot;i&#x27;m sure this is safe&quot; button<p>posted a pic on the imageboard hehe</div><br/><div id="40506829" class="c"><input type="checkbox" id="c-40506829" checked=""/><div class="controls bullet"><span class="by">sdsd</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40506788">parent</a><span>|</span><a href="#40505549">next</a><span>|</span><label class="collapse" for="c-40506829">[-]</label><label class="expand" for="c-40506829">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for visiting! Receiving guestbook comments is such a delight. Does Chrome also give you this warning on desktop?</div><br/><div id="40506872" class="c"><input type="checkbox" id="c-40506872" checked=""/><div class="controls bullet"><span class="by">prettymuchnoone</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40506829">parent</a><span>|</span><a href="#40505549">next</a><span>|</span><label class="collapse" for="c-40506872">[-]</label><label class="expand" for="c-40506872">[1 more]</label></div><br/><div class="children"><div class="content">nope</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40505549" class="c"><input type="checkbox" id="c-40505549" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#40505381">parent</a><span>|</span><a href="#40506523">prev</a><span>|</span><a href="#40507067">next</a><span>|</span><label class="collapse" for="c-40505549">[-]</label><label class="expand" for="c-40505549">[1 more]</label></div><br/><div class="children"><div class="content">I can appreciate this and also run a service that is neither meant to be commonly visited (imagine a tor exit node landing page explaining what this IP address is doing, but for a different service) nor will produce or ingest sensitive information<p>For a personal website that people might commonly want to visit, though, consider the second point made in this other comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40505294">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40505294</a> (someone else mentioned this in the thread slightly sooner than me but I don&#x27;t see it anymore)</div><br/></div></div><div id="40507067" class="c"><input type="checkbox" id="c-40507067" checked=""/><div class="controls bullet"><span class="by">npsimons</span><span>|</span><a href="#40505381">parent</a><span>|</span><a href="#40505549">prev</a><span>|</span><a href="#40505780">next</a><span>|</span><label class="collapse" for="c-40507067">[-]</label><label class="expand" for="c-40507067">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, for public facing read-only websites, it&#x27;s perfectly fine to redirect HTTP to HTTPS. There&#x27;s just too many cases where you aren&#x27;t going to get <i>everyone</i> to put &quot;<a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a>&quot; on the front of URIs when they put them in docs, flyers, etc. You&#x27;re lucky if you get &quot;<a href="http:&#x2F;&#x2F;" rel="nofollow">http:&#x2F;&#x2F;</a>&quot;!<p>The API security thing, yes, that makes sense. Personally, I run a number of servers for small groups where the sensitive stuff is SSL only - you won&#x27;t even get an error going to port 80, other than the eventual timeout. But for reasons above, I <i>cannot</i> just turn port 80 off, and it&#x27;s perfectly safe redirecting to 443.</div><br/></div></div><div id="40505780" class="c"><input type="checkbox" id="c-40505780" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#40505381">parent</a><span>|</span><a href="#40507067">prev</a><span>|</span><a href="#40505755">next</a><span>|</span><label class="collapse" for="c-40505780">[-]</label><label class="expand" for="c-40505780">[3 more]</label></div><br/><div class="children"><div class="content">A HTTP website presents an opportunity for an attacker to MITM a payload that is ultimately executed in a userâs browser. Beyond âgetting a moustache tattoo on your fingerâ quirkiness, HTTP-only websites are really inexcusable beyond some very niche cases.</div><br/><div id="40505982" class="c"><input type="checkbox" id="c-40505982" checked=""/><div class="controls bullet"><span class="by">sdsd</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40505780">parent</a><span>|</span><a href="#40506094">next</a><span>|</span><label class="collapse" for="c-40505982">[-]</label><label class="expand" for="c-40505982">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Beyond âgetting a moustache tattoo on your fingerâ quirkiness<p>In that case, seems totally worth it. I, like moustache finger tattoos, am aggressively opposed to worrying about being perceived as cool. I will just have to live with being inexcusable.</div><br/></div></div><div id="40506094" class="c"><input type="checkbox" id="c-40506094" checked=""/><div class="controls bullet"><span class="by">valec</span><span>|</span><a href="#40505381">root</a><span>|</span><a href="#40505780">parent</a><span>|</span><a href="#40505982">prev</a><span>|</span><a href="#40505755">next</a><span>|</span><label class="collapse" for="c-40506094">[-]</label><label class="expand" for="c-40506094">[1 more]</label></div><br/><div class="children"><div class="content">not my problem!</div><br/></div></div></div></div></div></div><div id="40505755" class="c"><input type="checkbox" id="c-40505755" checked=""/><div class="controls bullet"><span class="by">barryrandall</span><span>|</span><a href="#40505381">prev</a><span>|</span><a href="#40507639">next</a><span>|</span><label class="collapse" for="c-40505755">[-]</label><label class="expand" for="c-40505755">[1 more]</label></div><br/><div class="children"><div class="content">I agree that APIs shouldn&#x27;t automatically redirect HTTP to HTTPS, but I also think that client libraries shouldn&#x27;t follow redirects by default.</div><br/></div></div><div id="40507639" class="c"><input type="checkbox" id="c-40507639" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#40505755">prev</a><span>|</span><a href="#40505122">next</a><span>|</span><label class="collapse" for="c-40507639">[-]</label><label class="expand" for="c-40507639">[4 more]</label></div><br/><div class="children"><div class="content">npm is misusing 426 Upgrade Required.<p><a href="https:&#x2F;&#x2F;httpwg.org&#x2F;specs&#x2F;rfc9110.html#status.426" rel="nofollow">https:&#x2F;&#x2F;httpwg.org&#x2F;specs&#x2F;rfc9110.html#status.426</a>:<p>&gt; <i>The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 7.8).</i><p><a href="https:&#x2F;&#x2F;httpwg.org&#x2F;specs&#x2F;rfc9110.html#field.upgrade" rel="nofollow">https:&#x2F;&#x2F;httpwg.org&#x2F;specs&#x2F;rfc9110.html#field.upgrade</a>:<p>&gt; <i>The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 15.4).</i><p>If youâre going to talk cleartext HTTP and issue a client error rather than redirecting, 403 Forbidden or 410 Gone are the two most clearly correct codes to use.<p>Ignoring the mandated semantics and requirements of status codes is sadly not as rare as it should be. A few Iâve encountered more than once or twice: 401 Unauthorized without using WWW-Authenticate and Authorization; 405 Method Not Allowed without providing Allow; 412 Precondition Failed for <i>business logic</i> preconditions rather than <i>HTTP</i> preconditions; 417 Expectation Failed for something other than an Expect header. I think it only ever really happens with 4xx client errors.</div><br/><div id="40508802" class="c"><input type="checkbox" id="c-40508802" checked=""/><div class="controls bullet"><span class="by">notpushkin</span><span>|</span><a href="#40507639">parent</a><span>|</span><a href="#40508254">next</a><span>|</span><label class="collapse" for="c-40508802">[-]</label><label class="expand" for="c-40508802">[2 more]</label></div><br/><div class="children"><div class="content">TLS is in fact a valid protocol to use in an Upgrade header:<p><pre><code>    HTTP&#x2F;1.1 426 Upgrade Required
    Upgrade: TLS&#x2F;1.0, HTTP&#x2F;1.1
    Connection: Upgrade
</code></pre>
So you can use 426 Upgrade Required here, and I&#x27;d argue it&#x27;s the most correct code to use in such a case. npm doesn&#x27;t send the Upgrade header though, so that&#x27;s a mistake.<p><a href="https:&#x2F;&#x2F;www.iana.org&#x2F;assignments&#x2F;http-upgrade-tokens&#x2F;http-upgrade-tokens.xhtml" rel="nofollow">https:&#x2F;&#x2F;www.iana.org&#x2F;assignments&#x2F;http-upgrade-tokens&#x2F;http-up...</a><p><a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc2817.html#section-4.2" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc2817.html#section-4.2</a></div><br/><div id="40509697" class="c"><input type="checkbox" id="c-40509697" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#40507639">root</a><span>|</span><a href="#40508802">parent</a><span>|</span><a href="#40508254">next</a><span>|</span><label class="collapse" for="c-40509697">[-]</label><label class="expand" for="c-40509697">[1 more]</label></div><br/><div class="children"><div class="content">Thatâs something different: thatâs for upgrading to TLS <i>within the same connection</i>. As in, approximately <a href="http:&#x2F;&#x2F;example.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;example.com&#x2F;</a> â <a href="https:&#x2F;&#x2F;example.com:80&#x2F;" rel="nofollow">https:&#x2F;&#x2F;example.com:80&#x2F;</a> (but without the URLâs scheme actually being allowed to change), whereas <a href="https:&#x2F;&#x2F;example.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;example.com&#x2F;</a> is <a href="https:&#x2F;&#x2F;example.com:443&#x2F;" rel="nofollow">https:&#x2F;&#x2F;example.com:443&#x2F;</a>. I was only a child when RFC 2817 was published, but Iâve never heard of any software that supported it, other than the Internet Printing Protocol which can use it for ipp: URLs, kinda like SMTP has STARTTLS. As for the motivations of RFC 2817, theyâre <i>long</i> obsolete: encryption should no longer be optional on these sorts of things so that the parallel secure port problem is gone (not sure when this became actual IETF policy, but Iâm going to guess towards ten years ago), and the virtual hosting problem is solved by SNI (supported by everything that matters for well over a decade).</div><br/></div></div></div></div><div id="40508254" class="c"><input type="checkbox" id="c-40508254" checked=""/><div class="controls bullet"><span class="by">Titan2189</span><span>|</span><a href="#40507639">parent</a><span>|</span><a href="#40508802">prev</a><span>|</span><a href="#40505122">next</a><span>|</span><label class="collapse" for="c-40508254">[-]</label><label class="expand" for="c-40508254">[1 more]</label></div><br/><div class="children"><div class="content">How is this not more upvoted? HTTP Code 426 sounds like the best code to send?</div><br/></div></div></div></div><div id="40505122" class="c"><input type="checkbox" id="c-40505122" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40507639">prev</a><span>|</span><a href="#40506760">next</a><span>|</span><label class="collapse" for="c-40505122">[-]</label><label class="expand" for="c-40505122">[15 more]</label></div><br/><div class="children"><div class="content">Completely agree, and arguably why stop at API servers?<p>Depending on server-side HTTP -&gt; HTTPS redirects for security reinforces&#x2F;rewards bad practices (linking to HTTP, users directly entering HTTP etc.), in a way that makes users vulnerable to one of the few remaining attack vectors of &quot;scary public Wi-Fis&quot;.</div><br/><div id="40505532" class="c"><input type="checkbox" id="c-40505532" checked=""/><div class="controls bullet"><span class="by">nimih</span><span>|</span><a href="#40505122">parent</a><span>|</span><a href="#40505225">next</a><span>|</span><label class="collapse" for="c-40505532">[-]</label><label class="expand" for="c-40505532">[1 more]</label></div><br/><div class="children"><div class="content">&gt; arguably why stop at API servers?<p>I think this is pretty convincingly argued in TFA, honestly: modern browsers understand and respect HSTS headers, maintain enough local state that such headers are meaningful, and HSTS preloading is easy enough to set up that it should be achievable by most website operators.<p>Furthermore, it is actually quite hard to concoct a scenario where a user clicking an HTTP link and getting immediately redirected constitutes a danger to their security: unlike with API endpoints, people clicking links (and in particular, links which were typed out by hand, which is how you get the HTTP protocol in the first place) are generally not making requests that contain sensitive information (with the exception of cookies, but I would argue that getting someone to have a sane configuration for their cookies and HSTS headers is a far easier ask than telling them to stop responding to all port 80 traffic).</div><br/></div></div><div id="40505225" class="c"><input type="checkbox" id="c-40505225" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#40505122">parent</a><span>|</span><a href="#40505532">prev</a><span>|</span><a href="#40506038">next</a><span>|</span><label class="collapse" for="c-40505225">[-]</label><label class="expand" for="c-40505225">[7 more]</label></div><br/><div class="children"><div class="content">We are. Slowly, due to lots of legacy, but surely getting there.<p>See the small steps over the years where it was first an add-on to force https-only mode (HttpsEverywhere, 2011), then browsers started showing insecure symbols for http connections (e.g. in 2019: <a href="https:&#x2F;&#x2F;blog.mozilla.org&#x2F;security&#x2F;2019&#x2F;10&#x2F;15&#x2F;improved-security-and-privacy-indicators-in-firefox-70&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.mozilla.org&#x2F;security&#x2F;2019&#x2F;10&#x2F;15&#x2F;improved-securi...</a>), and more recently I think browsers are starting to try https before http when you don&#x27;t specify the protocol. I&#x27;ve also seen a mention of strict https mode or something, not sure if that&#x27;s a private navigation feature or something yet to come, but warning screens equivalent to insecure certificate pages are getting there</div><br/><div id="40505595" class="c"><input type="checkbox" id="c-40505595" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40505225">parent</a><span>|</span><a href="#40506038">next</a><span>|</span><label class="collapse" for="c-40505595">[-]</label><label class="expand" for="c-40505595">[6 more]</label></div><br/><div class="children"><div class="content">Chrome&#x27;s version of trying https first sure is annoying though.<p>If a site is down entirely, when chrome can&#x27;t connect to port 443 it confidently declares that &quot;the connection is not secure because this site does not support https&quot; and gives a &quot;continue&quot; button.  Then when you click &quot;continue&quot; nothing happens for a while before it finally admits there&#x27;s nothing responding at all.<p>So it gives a misleading error <i>and</i> takes longer to figure out if a site is actually down.</div><br/><div id="40508597" class="c"><input type="checkbox" id="c-40508597" checked=""/><div class="controls bullet"><span class="by">hirsin</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40505595">parent</a><span>|</span><a href="#40506867">next</a><span>|</span><label class="collapse" for="c-40508597">[-]</label><label class="expand" for="c-40508597">[1 more]</label></div><br/><div class="children"><div class="content">This is only enabled for a small percent of people at random, otherwise just folks in the advanced protection program.</div><br/></div></div><div id="40506867" class="c"><input type="checkbox" id="c-40506867" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40505595">parent</a><span>|</span><a href="#40508597">prev</a><span>|</span><a href="#40505763">next</a><span>|</span><label class="collapse" for="c-40506867">[-]</label><label class="expand" for="c-40506867">[1 more]</label></div><br/><div class="children"><div class="content">I have never seen this happen in Chrome. I just tried it to make sure I wasn&#x27;t crazy and it did indeed go straight to telling my that the connection timed out without showing a security error first.</div><br/></div></div><div id="40505763" class="c"><input type="checkbox" id="c-40505763" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40505595">parent</a><span>|</span><a href="#40506867">prev</a><span>|</span><a href="#40506280">next</a><span>|</span><label class="collapse" for="c-40505763">[-]</label><label class="expand" for="c-40505763">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m highly surprised by this. It seems very dumb and I have never seen anything like this, though I never use Chrome and very rarely fire Chromium for testing something.<p>Is there something to read about this, like a dev ticket?</div><br/><div id="40505891" class="c"><input type="checkbox" id="c-40505891" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40505763">parent</a><span>|</span><a href="#40506280">next</a><span>|</span><label class="collapse" for="c-40505891">[-]</label><label class="expand" for="c-40505891">[1 more]</label></div><br/><div class="children"><div class="content">There might be but I&#x27;m not aware of any tickets.  But if you open chrome and navigate to 192.168.20.20 you should see it.  Or any domain that resolves to a non-responsive IP, if you have one in mind.</div><br/></div></div></div></div><div id="40506280" class="c"><input type="checkbox" id="c-40506280" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40505595">parent</a><span>|</span><a href="#40505763">prev</a><span>|</span><a href="#40506038">next</a><span>|</span><label class="collapse" for="c-40506280">[-]</label><label class="expand" for="c-40506280">[1 more]</label></div><br/><div class="children"><div class="content">Firefox has a similar bug, but for DNS rather than connection.</div><br/></div></div></div></div></div></div><div id="40506038" class="c"><input type="checkbox" id="c-40506038" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40505122">parent</a><span>|</span><a href="#40505225">prev</a><span>|</span><a href="#40506760">next</a><span>|</span><label class="collapse" for="c-40506038">[-]</label><label class="expand" for="c-40506038">[6 more]</label></div><br/><div class="children"><div class="content">The push for &quot;TLS all the things&quot; was already a massive overreach that actively made security worse overall, because it further ingrained the user tendency to click through scary browser warnings (all for the sake of encrypting things that were fine in plaintext). And you want to go even <i>further</i>? No thank you.</div><br/><div id="40506515" class="c"><input type="checkbox" id="c-40506515" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40506038">parent</a><span>|</span><a href="#40506113">next</a><span>|</span><label class="collapse" for="c-40506515">[-]</label><label class="expand" for="c-40506515">[2 more]</label></div><br/><div class="children"><div class="content">What scary browser warnings do you regularly get when visiting HTTPS sites?<p>Itâs also not just about avoiding transmitting HTML etc. in plaintext; somebody being able to inject arbitrary scripts into sites you otherwise trust is bad as well.<p>But as I&#x27;ve said above, I think the HTTP -&gt; HTTPS redirect should have never happened at the HTTP level. If we&#x27;d done it in DNS or at least as a new HTTP header (&quot;optional TLS available&quot; or whatnot), we could have avoided locking out legacy clients.</div><br/><div id="40509041" class="c"><input type="checkbox" id="c-40509041" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40506515">parent</a><span>|</span><a href="#40506113">next</a><span>|</span><label class="collapse" for="c-40509041">[-]</label><label class="expand" for="c-40509041">[1 more]</label></div><br/><div class="children"><div class="content">Scripts other than those that the user had specifically allowed, can also be a problem, whether or not it is with TLS. With TLS, only the server operator can add malicious scripts; without TLS, spies can also do so; either way, it can do so.<p>Specifying availability of TLS (and, perhaps, which ciphers are usable, in order to avoid the use of insecure ciphers) by DNS would do, if you can (at the client&#x27;s option) acquire DNS records securely and can know that they have not been tampered with (including by removing parts of them). (This is independent of whether it is HTTP or other protocols that can optionally use TLS.)<p>(Actually, I think that using DNS in this way, would also solve &quot;Gopher with TLS&quot;; the format of gopher menus makes it difficult to use TLS, but knowing if TLS is available by looking at DNS records would make it work. Gopher servers can still accept non-TLS requests without a problem, if none of the valid selector strings on that server begin with character code 0x16 (which is always the first byte of any TLS connection, and is very unlikely to be a part of any Gopher selector string).)<p>It would also help to make cookies unable to cross between secure and insecure connections in either direction (always, rather than needing a &quot;secure cookies&quot; flag).</div><br/></div></div></div></div><div id="40506113" class="c"><input type="checkbox" id="c-40506113" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40506038">parent</a><span>|</span><a href="#40506515">prev</a><span>|</span><a href="#40508972">next</a><span>|</span><label class="collapse" for="c-40506113">[-]</label><label class="expand" for="c-40506113">[2 more]</label></div><br/><div class="children"><div class="content">&gt; because it further ingrained the user tendency to click through scary browser warnings (all for the sake of encrypting things that were fine in plaintext).<p>Why should there be more scary warnings when more websites use TLS? Sure, you get more scary warnings if you set your browser to &quot;warn if it&#x27;s http&quot;, but then you&#x27;re asking for it.</div><br/><div id="40506281" class="c"><input type="checkbox" id="c-40506281" checked=""/><div class="controls bullet"><span class="by">xboxnolifes</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40506113">parent</a><span>|</span><a href="#40508972">next</a><span>|</span><label class="collapse" for="c-40506281">[-]</label><label class="expand" for="c-40506281">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sure, you get more scary warnings if you set your browser to &quot;warn if it&#x27;s http&quot;, but then you&#x27;re asking for it.<p>Defaults. They matter.</div><br/></div></div></div></div><div id="40508972" class="c"><input type="checkbox" id="c-40508972" checked=""/><div class="controls bullet"><span class="by">xvector</span><span>|</span><a href="#40505122">root</a><span>|</span><a href="#40506038">parent</a><span>|</span><a href="#40506113">prev</a><span>|</span><a href="#40506760">next</a><span>|</span><label class="collapse" for="c-40508972">[-]</label><label class="expand" for="c-40508972">[1 more]</label></div><br/><div class="children"><div class="content">&gt; all for the sake of encrypting things that were fine in plaintext<p>What was fine in plaintext?</div><br/></div></div></div></div></div></div><div id="40506760" class="c"><input type="checkbox" id="c-40506760" checked=""/><div class="controls bullet"><span class="by">dramm</span><span>|</span><a href="#40505122">prev</a><span>|</span><a href="#40508872">next</a><span>|</span><label class="collapse" for="c-40506760">[-]</label><label class="expand" for="c-40506760">[1 more]</label></div><br/><div class="children"><div class="content">Yes, great article. And now can we convince folks with http+https websites to shut down http access and only offer https. I&#x27;ve seen simple mistakes like only partial redirects happening. Large numbers of internal links that still go to the http site, and some of those not redirect, etc. (you would think they are simple to find and just clean up), etc. And it is frustrating when sites like some online forums may be interesting targets for password theft.</div><br/></div></div><div id="40508872" class="c"><input type="checkbox" id="c-40508872" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#40506760">prev</a><span>|</span><a href="#40506189">next</a><span>|</span><label class="collapse" for="c-40508872">[-]</label><label class="expand" for="c-40508872">[1 more]</label></div><br/><div class="children"><div class="content">I think a good approach would be for developers to always use a custom HTTPClient class which throws an error if HTTP is used. I.e. you MUST opt in to use HTTP.</div><br/></div></div><div id="40506189" class="c"><input type="checkbox" id="c-40506189" checked=""/><div class="controls bullet"><span class="by">andrewaylett</span><span>|</span><a href="#40508872">prev</a><span>|</span><a href="#40508470">next</a><span>|</span><label class="collapse" for="c-40506189">[-]</label><label class="expand" for="c-40506189">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve stopped opening port 80 at all for some of my web services.  The parent domain is in the HSTS preload list, so no modern browser should ever be trying to connect to port 80.  And (as the fine article intimates) API calls shouldn&#x27;t be available on port 80 <i>anyway</i>.</div><br/></div></div><div id="40508470" class="c"><input type="checkbox" id="c-40508470" checked=""/><div class="controls bullet"><span class="by">ac130kz</span><span>|</span><a href="#40506189">prev</a><span>|</span><a href="#40508628">next</a><span>|</span><label class="collapse" for="c-40508470">[-]</label><label class="expand" for="c-40508470">[1 more]</label></div><br/><div class="children"><div class="content">There is a limited number of cases, where unencrypted http is still applicable, e.g. verifiable packages. In general though, it feels wrong even to think about putting such a glaring useless hole.</div><br/></div></div><div id="40508628" class="c"><input type="checkbox" id="c-40508628" checked=""/><div class="controls bullet"><span class="by">tonymet</span><span>|</span><a href="#40508470">prev</a><span>|</span><a href="#40504941">next</a><span>|</span><label class="collapse" for="c-40508628">[-]</label><label class="expand" for="c-40508628">[2 more]</label></div><br/><div class="children"><div class="content">You canât make this decision until you know how many customers are on http and how lucrative they are .<p>Breaking an API because you read a blog post is a bad idea</div><br/><div id="40508763" class="c"><input type="checkbox" id="c-40508763" checked=""/><div class="controls bullet"><span class="by">notpushkin</span><span>|</span><a href="#40508628">parent</a><span>|</span><a href="#40504941">next</a><span>|</span><label class="collapse" for="c-40508763">[-]</label><label class="expand" for="c-40508763">[1 more]</label></div><br/><div class="children"><div class="content">You can only do it for new customers, though. Just save the list of API keys used over HTTP, then whitelist those who earn more than $xxx&#x2F;year.<p>Then you can work with those customers to help them upgrade their clients to HTTPS.</div><br/></div></div></div></div><div id="40504941" class="c"><input type="checkbox" id="c-40504941" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40508628">prev</a><span>|</span><a href="#40505603">next</a><span>|</span><label class="collapse" for="c-40504941">[-]</label><label class="expand" for="c-40504941">[16 more]</label></div><br/><div class="children"><div class="content">&gt; Servers can now send HSTS along with the initial HTTP-to-HTTPS redirection response<p>&gt; Node.js&#x27;s built-in fetch happily and quietly followed those redirects to the HTTPS endpoint.<p>Okay..  does nodejs fetch respect HSTS?</div><br/><div id="40505142" class="c"><input type="checkbox" id="c-40505142" checked=""/><div class="controls bullet"><span class="by">NewJazz</span><span>|</span><a href="#40504941">parent</a><span>|</span><a href="#40505102">next</a><span>|</span><label class="collapse" for="c-40505142">[-]</label><label class="expand" for="c-40505142">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not aware of any general programming language http clients that honor HSTS.</div><br/><div id="40506000" class="c"><input type="checkbox" id="c-40506000" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505142">parent</a><span>|</span><a href="#40505102">next</a><span>|</span><label class="collapse" for="c-40506000">[-]</label><label class="expand" for="c-40506000">[1 more]</label></div><br/><div class="children"><div class="content">libcurl supports HSTS, but the client has to specify a file where the state should be stored <a href="https:&#x2F;&#x2F;curl.se&#x2F;docs&#x2F;hsts.html" rel="nofollow">https:&#x2F;&#x2F;curl.se&#x2F;docs&#x2F;hsts.html</a><p>Many languages&#x2F;libraries use libcurl in some shape or form, but whether they set up an on-disk HSTS store or not - I don&#x27;t know either.</div><br/></div></div></div></div><div id="40505102" class="c"><input type="checkbox" id="c-40505102" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#40504941">parent</a><span>|</span><a href="#40505142">prev</a><span>|</span><a href="#40505307">next</a><span>|</span><label class="collapse" for="c-40505102">[-]</label><label class="expand" for="c-40505102">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not even sure I&#x27;d find it desirable for nodejs fetch() to quietly store state somewhere on my server without asking me: I wouldn&#x27;t know to back that file up, it may be trashed regularly depending on the infrastructure, it could mess with version control by creating a local working directory change, or it might run into an error condition if it is on a read-only filesystem (either crashing or being unable to use this security feature, neither is great).<p>Config file writes are to be expected for user-facing software, but for developers it should error out so they can just choose what it needs to do<p>E.g., &quot;Error: HSTS response received after a redirect from HTTP, but no storage location specified for security states. Use the <a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a> protocol, specify a file location, or set insecure_ignore_hsts=true.&quot;<p>Edit: but it&#x27;s a very legitimate question?! Just saw you got downvoted, I have no idea why</div><br/><div id="40505282" class="c"><input type="checkbox" id="c-40505282" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505102">parent</a><span>|</span><a href="#40505237">next</a><span>|</span><label class="collapse" for="c-40505282">[-]</label><label class="expand" for="c-40505282">[5 more]</label></div><br/><div class="children"><div class="content">I think the original question &quot;Okay.. does nodejs fetch respect HSTS?&quot; goes into the &quot;not even wrong&quot; bucket, for the reasons you point out.<p>HSTS really only makes sense from a browser perspective (or, rather, a &quot;permanently installed, stateful client&quot; perspective). For an API like fetch it doesn&#x27;t even make sense as a question IMO.</div><br/><div id="40505335" class="c"><input type="checkbox" id="c-40505335" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505282">parent</a><span>|</span><a href="#40505304">next</a><span>|</span><label class="collapse" for="c-40505335">[-]</label><label class="expand" for="c-40505335">[1 more]</label></div><br/><div class="children"><div class="content">I would say it does make sense as a nice upgrade path for services that don&#x27;t yet support https but you&#x27;d like to switch as soon as they enable it, or if you&#x27;re forgetful or lazy and didn&#x27;t type <a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a> in front of the link you were given or so<p>Whether that&#x27;s still common enough to warrant the extra complexity in the fetch function is not something I&#x27;m qualified to judge</div><br/></div></div><div id="40505304" class="c"><input type="checkbox" id="c-40505304" checked=""/><div class="controls bullet"><span class="by">moralestapia</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505282">parent</a><span>|</span><a href="#40505335">prev</a><span>|</span><a href="#40505237">next</a><span>|</span><label class="collapse" for="c-40505304">[-]</label><label class="expand" for="c-40505304">[3 more]</label></div><br/><div class="children"><div class="content">&gt;For an API like fetch it doesn&#x27;t even make sense as a question IMO.<p>Why not?</div><br/><div id="40505390" class="c"><input type="checkbox" id="c-40505390" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505304">parent</a><span>|</span><a href="#40505237">next</a><span>|</span><label class="collapse" for="c-40505390">[-]</label><label class="expand" for="c-40505390">[2 more]</label></div><br/><div class="children"><div class="content">Because the way HSTS works fundamentally implies a stateful client, and because it was fundamentally created to solve a <i>human</i> problem (i.e. humans entering in URLs directly in the address bar). It really doesn&#x27;t make sense with a non-stateful client, and it isn&#x27;t intended for cases where someone isn&#x27;t manually entering in the URL to hit.<p>E.g. fetch is often loaded in transient situations - it really shouldn&#x27;t be updating its <i>own</i> config because of responses it gets. Also, based on the other comment I was originally thinking it would be good if fetch would just error out if it gets a redirect from http -&gt; https AND also a Strict-Transport-Security header, but in that case it would still mean it was dependent on the server setting up the STS header, and if they could do that they should just go ahead and get rid of the http -&gt; https redirect in the first place.</div><br/><div id="40505851" class="c"><input type="checkbox" id="c-40505851" checked=""/><div class="controls bullet"><span class="by">moralestapia</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505390">parent</a><span>|</span><a href="#40505237">next</a><span>|</span><label class="collapse" for="c-40505851">[-]</label><label class="expand" for="c-40505851">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you on things like CORS, but HSTS would actually solve the problem stated in this thread quite gracefully.<p>Client fetches http, notices the header, retries https then ... ok no, lol. But I guess it&#x27;s still of some use to let clients know &quot;this should always happen through https&quot; and make them fail if that&#x27;s not the case.<p>Edit: yeah I got it, client fetches http, notices the header and then explicitly fails because HSTS is there.</div><br/></div></div></div></div></div></div></div></div><div id="40505237" class="c"><input type="checkbox" id="c-40505237" checked=""/><div class="controls bullet"><span class="by">moralestapia</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505102">parent</a><span>|</span><a href="#40505282">prev</a><span>|</span><a href="#40505307">next</a><span>|</span><label class="collapse" for="c-40505237">[-]</label><label class="expand" for="c-40505237">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Just saw you got downvoted, I have no idea why<p>I&#x27;ve noticed a gradual increase in this behavior during the past ... year maybe? I think for a lot of new people, downvoting equates disagreeing, which is not ideal.<p>Although, I also have no idea why someone would disagree with a neutral question like GPs, lol.<p>Hopefully, it&#x27;s not the beginning of the end for HN as it is a great website.</div><br/><div id="40505285" class="c"><input type="checkbox" id="c-40505285" checked=""/><div class="controls bullet"><span class="by">iJohnDoe</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505237">parent</a><span>|</span><a href="#40505307">next</a><span>|</span><label class="collapse" for="c-40505285">[-]</label><label class="expand" for="c-40505285">[1 more]</label></div><br/><div class="children"><div class="content">These types of downvotes also discourage discussions. Iâll upvote a comment when it has been downvoted if it has a constructive discussion thread.</div><br/></div></div></div></div></div></div><div id="40505307" class="c"><input type="checkbox" id="c-40505307" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40504941">parent</a><span>|</span><a href="#40505102">prev</a><span>|</span><a href="#40505603">next</a><span>|</span><label class="collapse" for="c-40505307">[-]</label><label class="expand" for="c-40505307">[5 more]</label></div><br/><div class="children"><div class="content">How would that even work? It&#x27;s up to the developer to consider the response and act correctly on it.</div><br/><div id="40506392" class="c"><input type="checkbox" id="c-40506392" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505307">parent</a><span>|</span><a href="#40505458">next</a><span>|</span><label class="collapse" for="c-40506392">[-]</label><label class="expand" for="c-40506392">[2 more]</label></div><br/><div class="children"><div class="content">So if you occasionally forget and use http when you meant https and are worried about the consequences of that,  you should just implement your own HSTS checking layer?<p>Why not just implement your own fetch wrapper that throws if it&#x27;s not an https connection?</div><br/><div id="40509028" class="c"><input type="checkbox" id="c-40509028" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40506392">parent</a><span>|</span><a href="#40505458">next</a><span>|</span><label class="collapse" for="c-40509028">[-]</label><label class="expand" for="c-40509028">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So if you occasionally forget and use http when you meant https and are worried about the consequences of that, you should just implement your own HSTS checking layer?<p>Or use a library to do it. The core fetch functionality shouldn&#x27;t have to deal with HSTS. There may be legitimate reasons to fetch over HTTP even after you received an HSTS header - for testing purposes, for example.<p>&gt; Why not just implement your own fetch wrapper that throws if it&#x27;s not an https connection?<p>That&#x27;s the developer dealing with HSTS.</div><br/></div></div></div></div><div id="40505458" class="c"><input type="checkbox" id="c-40505458" checked=""/><div class="controls bullet"><span class="by">Aachen</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505307">parent</a><span>|</span><a href="#40506392">prev</a><span>|</span><a href="#40505498">next</a><span>|</span><label class="collapse" for="c-40505458">[-]</label><label class="expand" for="c-40505458">[1 more]</label></div><br/><div class="children"><div class="content">Same way as TLS session resumption can be handled by libraries without you having to touch it, or perhaps requiring you to specify a storage file and taking it from there</div><br/></div></div><div id="40505498" class="c"><input type="checkbox" id="c-40505498" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#40504941">root</a><span>|</span><a href="#40505307">parent</a><span>|</span><a href="#40505458">prev</a><span>|</span><a href="#40505603">next</a><span>|</span><label class="collapse" for="c-40505498">[-]</label><label class="expand" for="c-40505498">[1 more]</label></div><br/><div class="children"><div class="content">Just do it like a web browser - when you install Chrome it comes with a list of many tens of thousands of domains that had HSTS set when GoogleBot visited it.</div><br/></div></div></div></div></div></div><div id="40505603" class="c"><input type="checkbox" id="c-40505603" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#40504941">prev</a><span>|</span><a href="#40506679">next</a><span>|</span><label class="collapse" for="c-40505603">[-]</label><label class="expand" for="c-40505603">[3 more]</label></div><br/><div class="children"><div class="content">Maybe shttp would have been better than https to reduce typo errors or maybe even something completely different from http.</div><br/><div id="40508876" class="c"><input type="checkbox" id="c-40508876" checked=""/><div class="controls bullet"><span class="by">jimbobthrowawy</span><span>|</span><a href="#40505603">parent</a><span>|</span><a href="#40505634">next</a><span>|</span><label class="collapse" for="c-40508876">[-]</label><label class="expand" for="c-40508876">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure it was added to the end following a pattern of other protocols doing the same for their ssl-wrapped version. Right now, shttp reads like http over ssh to me.</div><br/></div></div><div id="40505634" class="c"><input type="checkbox" id="c-40505634" checked=""/><div class="controls bullet"><span class="by">toomim</span><span>|</span><a href="#40505603">parent</a><span>|</span><a href="#40508876">prev</a><span>|</span><a href="#40506679">next</a><span>|</span><label class="collapse" for="c-40505634">[-]</label><label class="expand" for="c-40505634">[1 more]</label></div><br/><div class="children"><div class="content">Ah... you know, that idea sounds not too shtty to me.</div><br/></div></div></div></div><div id="40505336" class="c"><input type="checkbox" id="c-40505336" checked=""/><div class="controls bullet"><span class="by">winddude</span><span>|</span><a href="#40506679">prev</a><span>|</span><a href="#40506629">next</a><span>|</span><label class="collapse" for="c-40505336">[-]</label><label class="expand" for="c-40505336">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an excellent point, and definitely something I&#x27;ve done without thinking about it. I&#x27;m going to stop, and disable those. Thanks!</div><br/></div></div><div id="40506629" class="c"><input type="checkbox" id="c-40506629" checked=""/><div class="controls bullet"><span class="by">victorbjorklund</span><span>|</span><a href="#40505336">prev</a><span>|</span><a href="#40505463">next</a><span>|</span><label class="collapse" for="c-40506629">[-]</label><label class="expand" for="c-40506629">[1 more]</label></div><br/><div class="children"><div class="content">Makes sense.</div><br/></div></div><div id="40505463" class="c"><input type="checkbox" id="c-40505463" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#40506629">prev</a><span>|</span><a href="#40505493">next</a><span>|</span><label class="collapse" for="c-40505463">[-]</label><label class="expand" for="c-40505463">[2 more]</label></div><br/><div class="children"><div class="content">Now that I think about it, interfaces such as Js fetch should make it an error to use http without explicitly allowing in an option.<p>It seems to easy to make an error and end up in a situation like the post explains.</div><br/><div id="40505926" class="c"><input type="checkbox" id="c-40505926" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#40505463">parent</a><span>|</span><a href="#40505493">next</a><span>|</span><label class="collapse" for="c-40505926">[-]</label><label class="expand" for="c-40505926">[1 more]</label></div><br/><div class="children"><div class="content">Hmm. I think, perhaps, release versions should need this, without a flag.<p>For testing&#x2F;prototyping, it is invaluable to turn off all the security to rule out security misconfiguration instead of application error.<p>If your API is non-sensitive&#x2F;relies on out of band security (like large files with checksums), you may still not want https, so there should be some configuration to turn it off. And for &quot;integrations&quot; like jsdelivr, perhaps https libraries should follow this rule, while http ones can have the flag off...<p>Then, if you mix the two (http and https) perhaps they can provide an noticeable alert to the user rather than failing silently...</div><br/></div></div></div></div><div id="40505493" class="c"><input type="checkbox" id="c-40505493" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#40505463">prev</a><span>|</span><a href="#40507958">next</a><span>|</span><label class="collapse" for="c-40505493">[-]</label><label class="expand" for="c-40505493">[1 more]</label></div><br/><div class="children"><div class="content">I do redirect APIs to HTTPS, but I&#x27;d prefer not to. There&#x27;s a simple reason - My APIs are hosted on the same IP as the public website, behind the same load balancer, so something has to be on the HTTP port. I would prefer to separate them, and my larger customers do - But for smaller customers, it&#x27;s an unnecessary added expense and complication that doesn&#x27;t make sense.</div><br/></div></div><div id="40507958" class="c"><input type="checkbox" id="c-40507958" checked=""/><div class="controls bullet"><span class="by">zeeb0t</span><span>|</span><a href="#40505493">prev</a><span>|</span><label class="collapse" for="c-40507958">[-]</label><label class="expand" for="c-40507958">[1 more]</label></div><br/><div class="children"><div class="content">Hard to argue against this.</div><br/></div></div></div></div></div></div></div></body></html>