<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732006876076" as="style"/><link rel="stylesheet" href="styles.css?v=1732006876076"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/ssoready/hyrumtoken">Hyrumtoken: A Go package to encrypt pagination tokens</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>noleary</span> | <span>19 comments</span></div><br/><div><div id="42180865" class="c"><input type="checkbox" id="c-42180865" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#42180558">next</a><span>|</span><label class="collapse" for="c-42180865">[-]</label><label class="expand" for="c-42180865">[4 more]</label></div><br/><div class="children"><div class="content">Maybe the deeper message of this is: Pagination tokens are a shitty API and you should really offer something that gives the client more options.<p>Pagination tokens feel great if you&#x27;re <i>providing</i> the API, because they let you retain maximum control over API usage and let you do all kinds of optimizations in the back-end. But they are really limiting for the clients and - as we&#x27;ve seen here - often fail to address even basic use cases, such as going back a page or even reliably reloading the same page you&#x27;re on. (Not even starting about arbitrary seeking.)<p>This leads to dreaded infinite-scrolling or &quot;click to load more&quot; UIs, which overload my browser and will have me start again from the very beginning should I have to reload the page.<p>I think it&#x27;s also very easy to miss for non-technical stakeholders just how constraining this API is. E.g. in the OP&#x27;s story, I could easily imagine some nontechnical PM assigning tasks like this:<p>- back-end team: Implement data access API using pagination tokens (because the devs said this is the best way to do it)<p>- front-end team: Implement the data view UI, including &quot;next&quot;, &quot; previous&quot; and &quot;go to page&quot; buttons, linkability and page numbers in the URL. (Because that&#x27;s what the product owners ordered)<p>Without having some specific knowledge about how pagination tokens work, it&#x27;s easy to miss that those requirements are contradictory - unless someone cheats, like in this case the front-end.</div><br/><div id="42181122" class="c"><input type="checkbox" id="c-42181122" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42180865">parent</a><span>|</span><a href="#42180985">next</a><span>|</span><label class="collapse" for="c-42181122">[-]</label><label class="expand" for="c-42181122">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t really contradictory to have pages and pagination tokens?  Just, at the low level, you want dumb API calls.<p>Now, I will assert you are probably better off with index like pages, anyway.  Instead of numbered, jump to the &quot;g&quot; records.  If you insist on page numbers, not too hard to somewhat precalculate what offset each page could be.  Just more work, after all.<p>The advantage of tokenized apis is that you can prevent unbounded work on an API call.  In particular, if you allow filters, it is easy to build what has to be a full table scan in one call.  This keeps you from later having to build a way to cancel a call.</div><br/></div></div><div id="42180985" class="c"><input type="checkbox" id="c-42180985" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#42180865">parent</a><span>|</span><a href="#42181122">prev</a><span>|</span><a href="#42180897">next</a><span>|</span><label class="collapse" for="c-42180985">[-]</label><label class="expand" for="c-42180985">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But they are really limiting for the clients and - as we&#x27;ve seen here - often fail to address even basic use cases, such as going back a page or even reliably reloading the same page you&#x27;re on.<p>That&#x27;s not really true. If this level of consistency is required, which it hardly is, then there&#x27;s solutions with pagination tokens for both of these requirements.</div><br/></div></div><div id="42180897" class="c"><input type="checkbox" id="c-42180897" checked=""/><div class="controls bullet"><span class="by">alserio</span><span>|</span><a href="#42180865">parent</a><span>|</span><a href="#42180985">prev</a><span>|</span><a href="#42180558">next</a><span>|</span><label class="collapse" for="c-42180897">[-]</label><label class="expand" for="c-42180897">[1 more]</label></div><br/><div class="children"><div class="content">what&#x27;s the solution space for these problems?</div><br/></div></div></div></div><div id="42180558" class="c"><input type="checkbox" id="c-42180558" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42180865">prev</a><span>|</span><a href="#42180067">next</a><span>|</span><label class="collapse" for="c-42180558">[-]</label><label class="expand" for="c-42180558">[1 more]</label></div><br/><div class="children"><div class="content">Pagination tokens have been a bane to my existence.  I&#x27;m basically this backend engineer.  Have done these exact steps.  Between worry the frontend will decode and annoyance at explaining how tokens work, I am growing to hate working with frontend teams.<p>Even worse, when I have to explain that they may get an empty result with a token meaning they need to call again.  Unbounded service call means nothing, it seems.<p>Kudos on this project!</div><br/></div></div><div id="42180067" class="c"><input type="checkbox" id="c-42180067" checked=""/><div class="controls bullet"><span class="by">unsnap_biceps</span><span>|</span><a href="#42180558">prev</a><span>|</span><a href="#42180760">next</a><span>|</span><label class="collapse" for="c-42180067">[-]</label><label class="expand" for="c-42180067">[3 more]</label></div><br/><div class="children"><div class="content">Looks pretty cool, however, I&#x27;m curious about the usage of a pointer to the key slice. A slice is just two ints and a pointer, so the copy semantics is pretty cheap, and one less pointer for the GC to clean up later.<p>Is there some reason why you choose to pass a pointer to the slice?</div><br/><div id="42180184" class="c"><input type="checkbox" id="c-42180184" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#42180067">parent</a><span>|</span><a href="#42180760">next</a><span>|</span><label class="collapse" for="c-42180184">[-]</label><label class="expand" for="c-42180184">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re correct about slice semantics but key here is actually a Go array, not a slice.  So it&#x27;s passing a pointer instead of an entire array.</div><br/><div id="42180491" class="c"><input type="checkbox" id="c-42180491" checked=""/><div class="controls bullet"><span class="by">unsnap_biceps</span><span>|</span><a href="#42180067">root</a><span>|</span><a href="#42180184">parent</a><span>|</span><a href="#42180760">next</a><span>|</span><label class="collapse" for="c-42180491">[-]</label><label class="expand" for="c-42180491">[1 more]</label></div><br/><div class="children"><div class="content">Ahh, thank you. Still very new to go :)</div><br/></div></div></div></div></div></div><div id="42180760" class="c"><input type="checkbox" id="c-42180760" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#42180067">prev</a><span>|</span><a href="#42181007">next</a><span>|</span><label class="collapse" for="c-42180760">[-]</label><label class="expand" for="c-42180760">[2 more]</label></div><br/><div class="children"><div class="content">I have been in this situation also. The biggest issue, that took several meetings, was getting the ux team to understand that they can not index the pages as we do not know their tokens.</div><br/><div id="42180798" class="c"><input type="checkbox" id="c-42180798" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42180760">parent</a><span>|</span><a href="#42181007">next</a><span>|</span><label class="collapse" for="c-42180798">[-]</label><label class="expand" for="c-42180798">[1 more]</label></div><br/><div class="children"><div class="content">If you have found good links to explain this to other teams, I&#x27;d love to see them.</div><br/></div></div></div></div><div id="42181007" class="c"><input type="checkbox" id="c-42181007" checked=""/><div class="controls bullet"><span class="by">rendall</span><span>|</span><a href="#42180760">prev</a><span>|</span><a href="#42180120">next</a><span>|</span><label class="collapse" for="c-42181007">[-]</label><label class="expand" for="c-42181007">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really agree with the entire premise. At first I read about this trying to understand what the security implications are of obscured pagination tokens. Why would one want to obfuscate pagination tokens from hackers?<p>Turns out, it&#x27;s to make things more opaque <i>for one&#x27;s own team</i> ::scream emoji::<p>This is simply not a good way to work, sorry.<p>Either implement paging the way the frontend team wants and expects it to work, or take the time to explain in a clear and friendly why you cannot (i.e. the data is not structured as pages, specs were clear and rigid, whatever). With healthy interteam communication, there won&#x27;t be a need to obfuscate pagination tokens in this manner.<p>It reads like OP built something as a backend engineer without reference to client or user needs and then threw it over the wall to the frontend team. Not good.</div><br/></div></div><div id="42180120" class="c"><input type="checkbox" id="c-42180120" checked=""/><div class="controls bullet"><span class="by">njtransit</span><span>|</span><a href="#42181007">prev</a><span>|</span><a href="#42180250">next</a><span>|</span><label class="collapse" for="c-42180120">[-]</label><label class="expand" for="c-42180120">[3 more]</label></div><br/><div class="children"><div class="content">This looks like a <i>very</i> simple wrapper around golang.org&#x2F;x&#x2F;crypto&#x2F;nacl&#x2F;secretbox<p>Whatâs the point of this?</div><br/><div id="42180243" class="c"><input type="checkbox" id="c-42180243" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#42180120">parent</a><span>|</span><a href="#42180838">next</a><span>|</span><label class="collapse" for="c-42180243">[-]</label><label class="expand" for="c-42180243">[1 more]</label></div><br/><div class="children"><div class="content">To remove&#x2F;obscure structure from a token so that the structure is not relied upon &amp; can be changed in backwards incompatible ways without disrupting API consumers.<p>If you think it&#x27;s internal details are too simple to justify a dependency, you can vendor or  reimplement it, but that&#x27;s orthogonal to whether it&#x27;s pointless. The README is pretty detailed &amp; explicit about what the point is.</div><br/></div></div><div id="42180838" class="c"><input type="checkbox" id="c-42180838" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#42180120">parent</a><span>|</span><a href="#42180243">prev</a><span>|</span><a href="#42180250">next</a><span>|</span><label class="collapse" for="c-42180838">[-]</label><label class="expand" for="c-42180838">[1 more]</label></div><br/><div class="children"><div class="content">Huh. Anyone know why the nonce isn&#x27;t baked into the box upon sealing?<p>It&#x27;s the same in the original: <a href="https:&#x2F;&#x2F;nacl.cr.yp.to&#x2F;secretbox.html" rel="nofollow">https:&#x2F;&#x2F;nacl.cr.yp.to&#x2F;secretbox.html</a></div><br/></div></div></div></div><div id="42180250" class="c"><input type="checkbox" id="c-42180250" checked=""/><div class="controls bullet"><span class="by">Xxfireman</span><span>|</span><a href="#42180120">prev</a><span>|</span><label class="collapse" for="c-42180250">[-]</label><label class="expand" for="c-42180250">[4 more]</label></div><br/><div class="children"><div class="content">âintellectual curiosity of your coworkers demands they base64-parse it.â This is crazy behavior. Creating your own pagination key, assuming it exists, and then putting that in production certainly proves âHyrumâs lawâ.</div><br/><div id="42180606" class="c"><input type="checkbox" id="c-42180606" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#42180250">parent</a><span>|</span><label class="collapse" for="c-42180606">[-]</label><label class="expand" for="c-42180606">[3 more]</label></div><br/><div class="children"><div class="content">I have a similar story to OP&#x27;s. I had made a service that provided access to cryptographic keys but did not reveal the key material directly. Instead it had an RPC API for requesting a key &quot;handle&quot; for the key you wanted to use, and API for performing operations like encrypt or sign that took that key handle, performed the operation inside the service and returned the result. The key handle was to be treated as opaque and implemented as a base64-encoded blob containing the key ID and a signature (for tamper-proofing).<p>One day a coworker working on another project that would use my service contacted me to complain that the keys from my service were malformed. Turned out they had noticed that the return value was base64-encoded so they assumed it was a base64-encoded key, so they wrote code to base64-decode it and load the result into their language&#x27;s crypto library to perform those operations directly. They figured that the service&#x27;s API for doing those operations was just there to be convenient for callers that didn&#x27;t have access to a crypto library.</div><br/><div id="42180796" class="c"><input type="checkbox" id="c-42180796" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42180250">root</a><span>|</span><a href="#42180606">parent</a><span>|</span><label class="collapse" for="c-42180796">[-]</label><label class="expand" for="c-42180796">[2 more]</label></div><br/><div class="children"><div class="content">We could probably make a drinking club for teams that have been bitten by stuff like this.  :)</div><br/><div id="42181010" class="c"><input type="checkbox" id="c-42181010" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#42180250">root</a><span>|</span><a href="#42180796">parent</a><span>|</span><label class="collapse" for="c-42181010">[-]</label><label class="expand" for="c-42181010">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll join :) For past war stories, because these days, I sign parameters that should not be tapered with ;)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>