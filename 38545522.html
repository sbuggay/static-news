<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702112456277" as="style"/><link rel="stylesheet" href="styles.css?v=1702112456277"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantamagazine.org/a-team-of-math-proves-a-critical-link-between-addition-and-sets-20231206/">&#x27;A-team&#x27; of math proves a critical link between addition and sets</a> <span class="domain">(<a href="https://www.quantamagazine.org">www.quantamagazine.org</a>)</span></div><div class="subtext"><span>digital55</span> | <span>99 comments</span></div><br/><div><div id="38573029" class="c"><input type="checkbox" id="c-38573029" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#38575359">next</a><span>|</span><label class="collapse" for="c-38573029">[-]</label><label class="expand" for="c-38573029">[32 more]</label></div><br/><div class="children"><div class="content">The maths goes over my head, but this paragraph was very interesting:<p>&gt; Tao then kicked off an effort to formalize the proof in Lean, a programming language that helps mathematicians verify theorems. In just a few weeks, that effort succeeded. Early Tuesday morning of December 5, Tao announced that Lean had proved the conjecture without any “sorrys” — the standard statement that appears when the computer can’t verify a certain step. This is the highest-profile use of such verification tools since 2021, and marks an inflection point in the ways mathematicians write proofs in terms a computer can understand. If these tools become easy enough for mathematicians to use, they might be able to substitute for the often prolonged and onerous peer review process, said Gowers.</div><br/><div id="38573370" class="c"><input type="checkbox" id="c-38573370" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#38573029">parent</a><span>|</span><a href="#38573722">next</a><span>|</span><label class="collapse" for="c-38573370">[-]</label><label class="expand" for="c-38573370">[21 more]</label></div><br/><div class="children"><div class="content">I helped a very little with the formalization (I filled in some trivial algebraic manipulations, and I was there for some Lean technical support).<p>It&#x27;s exciting to see how quickly the work was done, but it&#x27;s worth keeping in mind that a top mathematician leading a formalization effort is very exciting, so he could very easily scramble a team of around 20 experienced Lean users.<p>There aren&#x27;t enough experienced Lean users to go around yet for any old project, so Gowers&#x27;s point about ease of use is an important one.<p>Something that was necessary for the success of this was years of development that had already been done for both Lean and mathlib. It&#x27;s reassuring that mathlib is being developed in such a way that new mathematics can be formalized using it. Like usual though, there was plenty missing. I think this drove a few thousand more lines of general probability theory development.</div><br/><div id="38573841" class="c"><input type="checkbox" id="c-38573841" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573370">parent</a><span>|</span><a href="#38573499">next</a><span>|</span><label class="collapse" for="c-38573841">[-]</label><label class="expand" for="c-38573841">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Something that was necessary for the success of this was years of development that had already been done for both Lean and mathlib<p>Yes but the bulk of the work on this project was background as well.  So the ease of use problem should be solving itself over time as more and more prereqs get filled in.<p>BTW, I find it interesting that mathlib is apparently also getting refactored to accommodate constructive proofs better, as part of the porting effort to Lean 4.  This might encourage more CS- and program-verification minded folks to join the effort, and maybe some folks in math-foundations too (though Lean suffers there by not being able to work with the homotopy-types axioms).</div><br/><div id="38574382" class="c"><input type="checkbox" id="c-38574382" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573841">parent</a><span>|</span><a href="#38573499">next</a><span>|</span><label class="collapse" for="c-38574382">[-]</label><label class="expand" for="c-38574382">[8 more]</label></div><br/><div class="children"><div class="content">Yes, sure, and that&#x27;s how mathlib usually gets developed, project by project and PRing missing background material. I&#x27;m one of the mathlib maintainers, and I wanted to be sure there&#x27;s acknowledgment here for the years of Boubaki-style work among hundreds of volunteers to build up the mathematics. In a way, now that the paper&#x27;s been formalized it&#x27;s time for the really hard work, which is figuring out how to restructure it (and mathlib) so that it can easily support future work. That&#x27;s writing libraries for you.<p>Where are you getting the idea mathlib is being refactored for constructive proofs? I wouldn&#x27;t say that&#x27;s on the road map. In fact, the core Lean developers are uninterested in pursuing supporting this.<p>Since you&#x27;re here, are you able to say why constructive proofs are interesting to program verification or (T)CS people? I&#x27;ve never heard anyone in TCS even know what constructivity is -- Lean supports their case where you write a program&#x2F;algorithm and then (with classical logic) prove correctness and other properties. What would constructive logic give them?</div><br/><div id="38574491" class="c"><input type="checkbox" id="c-38574491" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38574382">parent</a><span>|</span><a href="#38574766">next</a><span>|</span><label class="collapse" for="c-38574491">[-]</label><label class="expand" for="c-38574491">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll mention that the &quot;Lean way&quot; for constructivity is that you write `def`s for constructions. These can depend on classical reasoning for well-typedness if you want (like for being sure a number is in range when indexing an array), but there is a computability checker. In particular, the compiler sees if there is a way to lower the `def` into some simply typed IR, and this IR can be further compiled to C. If you trust the compiler, then you can trust whether it&#x27;s real construction.<p>(Of course, you can also go and prove a definition evaluates to some value if you don&#x27;t want to trust the evaluator.)</div><br/></div></div><div id="38574766" class="c"><input type="checkbox" id="c-38574766" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38574382">parent</a><span>|</span><a href="#38574491">prev</a><span>|</span><a href="#38573499">next</a><span>|</span><label class="collapse" for="c-38574766">[-]</label><label class="expand" for="c-38574766">[6 more]</label></div><br/><div class="children"><div class="content">&gt; [W]rite a program&#x2F;algorithm and then (with classical logic) prove correctness.  What would constructive logic give them?<p>Compared to the usual case of writing the &quot;algorithm&quot; (i.e. the construction&#x2F;decision part) and &quot;proof&quot; separately, it basically offers better structuring and composability.  Imagine writing an &quot;algorithm&quot; that itself relies for correctness on non-trivial preconditions, or must maintain some invariants etc. Proving correctness of a complete development that might involve wiring up several of these together is quite possible if you can use constructive proofs, but becomes quite tedious if you have to work with the two facets separately.<p>&gt; Where are you getting the idea mathlib is being refactored for constructive proofs?<p>It&#x27;s not being refactored <i>for</i> constructive proofs, but proofs that do use classical reasoning are being marked as such in a more fine-grained fashion rather than leaving it as the default for the entire development.  Which makes it at least possible to add more constructive content.</div><br/><div id="38575036" class="c"><input type="checkbox" id="c-38575036" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38574766">parent</a><span>|</span><a href="#38573499">next</a><span>|</span><label class="collapse" for="c-38575036">[-]</label><label class="expand" for="c-38575036">[5 more]</label></div><br/><div class="children"><div class="content">Yeah, I can imagine that, and I&#x27;ve used sigma types to carry it out (`Subtype`s in particular, or perhaps custom structures). Why does the proof in the sigma type have to be constructive?<p>Certainly this is the road to &quot;dependently typed hell&quot; and it&#x27;s good to avoid mingling proofs with data if you can, but avoiding the law of the excluded middle doesn&#x27;t make any of that any easier.<p>This is also a bit of a distraction since what I really mean regarding TCS is that in my experience is that they do not see the proofs themselves as being objects-with-properties. They&#x27;re perfectly happy with non-constructive reasoning to support constructions. I am looking to be convinced that constructive logic is worth it, but this mathematician hasn&#x27;t seen anything compelling beyond work on foundations themselves.<p>Regarding mathlib, could you say what in particular you&#x27;re talking about, since it&#x27;s not ringing a bell, and I follow the changelogs.</div><br/><div id="38575514" class="c"><input type="checkbox" id="c-38575514" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38575036">parent</a><span>|</span><a href="#38573499">next</a><span>|</span><label class="collapse" for="c-38575514">[-]</label><label class="expand" for="c-38575514">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Regarding mathlib, could you say what in particular you&#x27;re talking about, since it&#x27;s not ringing a bell, and I follow the changelogs.<p>There&#x27;s been several commits where general appeals to classical reasoning in some development have been replaced by more fine-grained assumptions of decidability for some objects, or marking uses of classical reasoning in some specific proofs.  This has not happened throughout mathlib of course, just in some specific places.  But it might still show one way of making the development a bit friendlier to alternate foundations.<p>&gt; ...but avoiding the law of the excluded middle doesn&#x27;t make any of that any easier.<p>Constructivist developments are not about &quot;avoiding the law of excluded middle&quot;.  They&#x27;re more about leveraging the way we <i>already</i> structure mathematical proofs (and mathematical reasoning more generally) to make it easier to understand where simple direct reasoning <i>has</i> in fact been used, and a theorem can thus be said to be useful for such purposes.  If all we did was proofs by contradiction and excluded middle, there would be no point to it - but direct proof is actually rather common.<p>&gt; Why does the proof in the sigma type have to be constructive?<p>It doesn&#x27;t, <i>if</i> the constructibility part has been stated separately (e.g. stating that some property is decidable, or that some object is constructible).  That&#x27;s in fact how one can &quot;write the program&#x2F;algorithm and the logic separately&quot; in a principled way.<p>&gt; I am looking to be convinced that constructive logic is worth it, but this mathematician hasn&#x27;t seen anything compelling beyond work on foundations themselves.<p>This paper <a href="https:&#x2F;&#x2F;www.ams.org&#x2F;journals&#x2F;bull&#x2F;2017-54-03&#x2F;S0273-0979-2016-01556-4&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ams.org&#x2F;journals&#x2F;bull&#x2F;2017-54-03&#x2F;S0273-0979-2016...</a> provides a reasonable summary of the relevant arguments.  It&#x27;s notable that a number of mathematicians are doing work that involves, e.g. the internal language of topoi, which pretty much amounts to invoking constructive foundations despite starting from what&#x27;s otherwise a &quot;classical&quot; setting.  That they go to all this trouble to do this certainly suggests that they find that work compelling enough.  And indeed, it has practical implications wrt. e.g. alternate foundations for analysis, differential geometry etc.</div><br/><div id="38575768" class="c"><input type="checkbox" id="c-38575768" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38575514">parent</a><span>|</span><a href="#38573499">next</a><span>|</span><label class="collapse" for="c-38575768">[-]</label><label class="expand" for="c-38575768">[3 more]</label></div><br/><div class="children"><div class="content">Many times, Decidable assumptions are added simply because they appear in the terms in a theorem statement, and doing so makes applying such a theorem easier. There&#x27;s the technical annoyance that Decidable instances are equal but not necessarily defeq, so if the wrong instances are present (such as the classical ones) then you need simp-like automation to rewrite instances before unifying. Maybe this is what you&#x27;re seeing?<p>There have also been attempts to make polynomials computable, which peppers everything with decidability, but it&#x27;s not a good data type for real large-scale computations, so it&#x27;s not clear what the future is there. Maybe the defeqs are worth it, I don&#x27;t know.<p>Re constructibility, this is all at too high of a level to really know what you&#x27;re talking about, or why it&#x27;s beneficial to write proofs themselves in a certain way. I&#x27;m not really even sure what you mean by &quot;constructive&quot;. To me, I see no problem with writing a recursive definition that requires a non-constructive proof of termination by well-founded recursion -- is that constructive to you?</div><br/><div id="38576189" class="c"><input type="checkbox" id="c-38576189" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38575768">parent</a><span>|</span><a href="#38573499">next</a><span>|</span><label class="collapse" for="c-38576189">[-]</label><label class="expand" for="c-38576189">[2 more]</label></div><br/><div class="children"><div class="content">AIUI, the fact that well-founded recursion is encoded as &quot;noncomputable&quot; in Lean is just a wart&#x2F;quirk of that particular system; it can be justified in dependent type theory which is quite constructive and used by other systems such as Coq.</div><br/><div id="38576543" class="c"><input type="checkbox" id="c-38576543" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38576189">parent</a><span>|</span><a href="#38573499">next</a><span>|</span><label class="collapse" for="c-38576543">[-]</label><label class="expand" for="c-38576543">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not `noncomputable` in Lean though. Lots of computable functions use it.<p>I&#x27;ve read Bauer&#x27;s paper before btw. I think topoi are cool, but I don&#x27;t think it&#x27;s a complexity worth thinking about for everyone else who isn&#x27;t concerned about these things.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38573499" class="c"><input type="checkbox" id="c-38573499" checked=""/><div class="controls bullet"><span class="by">cs702</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573370">parent</a><span>|</span><a href="#38573841">prev</a><span>|</span><a href="#38573613">next</a><span>|</span><label class="collapse" for="c-38573499">[-]</label><label class="expand" for="c-38573499">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I helped a very little...</i><p>Thank You for helping with the effort, even if it was only &quot;a very little.&quot;<p>I love coming across comments like yours on HN.</div><br/></div></div><div id="38573613" class="c"><input type="checkbox" id="c-38573613" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573370">parent</a><span>|</span><a href="#38573499">prev</a><span>|</span><a href="#38579029">next</a><span>|</span><label class="collapse" for="c-38573613">[-]</label><label class="expand" for="c-38573613">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Something that was necessary for the success of this was years of development that had already been<p>For projects like this it is often very thankless work in the beginning, and can be a real grind.<p>You need at least one person with a vision of how cool it will be in the (poorly defined) future, and a lot of determination.</div><br/></div></div><div id="38579029" class="c"><input type="checkbox" id="c-38579029" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573370">parent</a><span>|</span><a href="#38573613">prev</a><span>|</span><a href="#38577043">next</a><span>|</span><label class="collapse" for="c-38579029">[-]</label><label class="expand" for="c-38579029">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>so he could very easily scramble a team of around 20 experienced Lean users</i><p>What have you to say about methods such as these:<p>&quot;LeanDojo: Theorem Proving with Retrieval-Augmented Language Models&quot; (2023) <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2306.15626" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2306.15626</a> 
<a href="https:&#x2F;&#x2F;leandojo.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;leandojo.org&#x2F;</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=leandojo.org">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=leandojo.org</a><p>( <a href="https:&#x2F;&#x2F;westurner.github.io&#x2F;hnlog&#x2F;#story-38435908" rel="nofollow noreferrer">https:&#x2F;&#x2F;westurner.github.io&#x2F;hnlog&#x2F;#story-38435908</a> Ctrl-F &quot;TheoremQA&quot; (to find the citation and its references in my local <i>personal knowledgebase</i> HTML document with my comments archived in it), manually )<p>&quot;TheoremQA: A Theorem-driven [STEM] Question Answering dataset&quot; (2023) <a href="https:&#x2F;&#x2F;github.com&#x2F;wenhuchen&#x2F;TheoremQA#leaderboard">https:&#x2F;&#x2F;github.com&#x2F;wenhuchen&#x2F;TheoremQA#leaderboard</a> (they check LLM accuracy with Wolfram Mathematica)<p>&quot;Large language models as simulated economic agents (2022) [pdf]&quot; 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34385880">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34385880</a> :<p>&gt; <i>Can any LLM do n-body gravity? What does it say when it doesn&#x27;t know; doesn&#x27;t have confidence in estimates?</i><p>From <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38354679">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38354679</a> :<p>&gt; <i>&quot;LLMs cannot find reasoning errors, but can correct them&quot; (2023) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38353285">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38353285</a> </i><p>&gt; <i>&quot;Misalignment and Deception by an autonomous stock trading LLM agent&quot; <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38353880#38354486">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38353880#38354486</a> </i><p>That being said, guess and check and then develop a fitting casual explanation is or is not the standard practice of science, so<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38124505">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38124505</a> <a href="https:&#x2F;&#x2F;westurner.github.io&#x2F;hnlog&#x2F;#comment-38124505" rel="nofollow noreferrer">https:&#x2F;&#x2F;westurner.github.io&#x2F;hnlog&#x2F;#comment-38124505</a> :<p>&gt; <i>What does Mathlib have for SetTheory, ZFC, NFU, and HoTT?</i><p>&gt; <i>Do any existing CAS systems have configurable axioms?</i><p>Does LeanDojo have configurable axioms?<p>From <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38527844">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38527844</a> :<p>&gt; <i>TIL i^4x == e^2iπx</i> ... But SymPy says it isn&#x27;t so (as the equality relation automated test assertion fails); and GeoGebra plots it as a unit circle and a line, but SymPy doesn&#x27;t have a plot_complex() function to compare just one tool&#x27;s output with another.</div><br/><div id="38579654" class="c"><input type="checkbox" id="c-38579654" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38579029">parent</a><span>|</span><a href="#38577043">next</a><span>|</span><label class="collapse" for="c-38579654">[-]</label><label class="expand" for="c-38579654">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a lot of links to take in, and I don&#x27;t do really anything with ML, but feel free to head over to <a href="https:&#x2F;&#x2F;leanprover.zulipchat.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;leanprover.zulipchat.com&#x2F;</a> and start a discussion in the Machine Learning for Theorem Proving stream!<p>My observation at the moment is that we haven&#x27;t seen ML formalize a cutting-edge math paper and that it did in fact take a lot of experience to pull it off so quickly, experience that&#x27;s not yet encoded in ML models. Maybe one day.<p>Something that I didn&#x27;t mention is that Terry Tao is perhaps the most intelligent, articulate, and conscientious person I have ever interacted with. I found it very impressive how quickly he absorbed the Lean language, what goes into formalization, and how to direct a formalization project. He could have done this whole thing on his own I am sure. No amount of modern ML can replace him at the helm. However, he is such an excellent communicator that he could have probably gotten well-above-average results from an LLM. My understanding is that he used tools like ChatGPT to learn Lean and formalization, and my experience is that what you get from these tools is proportional to the quality of what you put into them.</div><br/></div></div></div></div><div id="38577043" class="c"><input type="checkbox" id="c-38577043" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573370">parent</a><span>|</span><a href="#38579029">prev</a><span>|</span><a href="#38573722">next</a><span>|</span><label class="collapse" for="c-38577043">[-]</label><label class="expand" for="c-38577043">[7 more]</label></div><br/><div class="children"><div class="content">Since you seem to be an expert on this matter I have always wondered whether at some point it becomes faster to prove novel theorems using a theorem prover then doing it on paper. I imagine that quite a bit of time is wasted in proving things that are already proven. In a similar manner that if there would be no libraries, just snippets of code in papers, in computer programming a lot of time would be wasted writing the same things again. I imagine a &quot;proof finding&quot; tool like hoogle is a &quot;function finding&quot; tool could provide a lot of value here. What is your perspective on this?</div><br/><div id="38577137" class="c"><input type="checkbox" id="c-38577137" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38577043">parent</a><span>|</span><a href="#38579542">next</a><span>|</span><label class="collapse" for="c-38577137">[-]</label><label class="expand" for="c-38577137">[3 more]</label></div><br/><div class="children"><div class="content">The biggest benefit of a formalized theorem library is not so much proving entirely new theorems (though it helps a little bit I suppose) but refactoring the existing developments to make them more elegant, easier to understand, and enhance their generality.  In fact, it&#x27;s already the case that the average formal proof is written to be somewhat higher in abstraction and more straightforward in reasoning than the informal counterpart.<p>This kind of refactoring work is quite hard to do with paper proofs alone, since one cannot essily be sure whether they&#x27;ve preserved correctness wrt. the original development. Having a proof assistant really is a big help there.</div><br/><div id="38579074" class="c"><input type="checkbox" id="c-38579074" checked=""/><div class="controls bullet"><span class="by">jenesaispas</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38577137">parent</a><span>|</span><a href="#38579542">next</a><span>|</span><label class="collapse" for="c-38579074">[-]</label><label class="expand" for="c-38579074">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The biggest benefit of a formalized theorem library is not [...] but [...]<p>[citation needed]<p>I think there are many benefits. Hard to claim that your favourite one is the biggest benefit.<p>In general, I think it&#x27;s a bit weird that you are repeatedly (also other HN threads, and sibling comments in this one) making unfounded claims about Lean&#x2F;mathlib, to the point where you are telling maintainers how their system works. And if they explain that you are misunderstanding the system, you ignore their correction and bring up the next (or the same) unfounded claim.<p>Disclaimer: I am a Lean&#x2F;mathlib user.</div><br/><div id="38579728" class="c"><input type="checkbox" id="c-38579728" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38579074">parent</a><span>|</span><a href="#38579542">next</a><span>|</span><label class="collapse" for="c-38579728">[-]</label><label class="expand" for="c-38579728">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [citation needed]<p>Whoops, you&#x27;re right.  Here&#x27;s what Fields medalist Terence Tao has to say about it: <a href="https:&#x2F;&#x2F;terrytao.wordpress.com&#x2F;2023&#x2F;12&#x2F;05&#x2F;a-slightly-longer-lean-4-proof-tour&#x2F;#comment-682450" rel="nofollow noreferrer">https:&#x2F;&#x2F;terrytao.wordpress.com&#x2F;2023&#x2F;12&#x2F;05&#x2F;a-slightly-longer-...</a> &quot;...sometimes, after a proposition has been proven, someone in the project realizes that in order to apply the proposition neatly in some other part of the project, one has to slightly modify a hypothesis ...  Often one can just modify that hypothesis and watch what the compiler does. ... [W]ith well-designed proofs, the process of modifying a proposition is often substantially easier than writing a proof from scratch. (Indeed it is this aspect of formalization where I think we really have a chance in the future of being in a situation where the task is <i>faster</i> to perform in a formal framework than in traditional pen-and-paper (and LaTeX) framework.)&quot;<p>&gt; And if they explain that you are misunderstanding the system<p>I don&#x27;t think that&#x27;s a fair description of the sibling threads. If a mathlib maintainer says &quot;no, we&#x27;re not going to avoid LEM&#x2F;by-contradiction  everywhere in our proof library, that would be silly&quot; because that&#x27;s what most mathematicians today think constructivism means, as in rejecting the bulk of existing math entirely as meaningless - and then they add &quot;but yes, there are places where we want to work with our own assertions about decidability, and not let classical reasoning mess that up&quot; I think it&#x27;s entirely fair to call the latter pretty close to a constructivism-friendly approach.<p>(Keep in mind that most practicing mathematicians don&#x27;t work with foundations, so the fact that misconceptions like the above would be widespread is not surprising.  The remaining argument is about the increased complexity of constructive reasoning, and it&#x27;s entirely fair for a practical development to want to avoid that, and just work with classical statements.  After all, most of the mathematical literature is indeed classical; it does not bother with the computational aspect or with the perceived messiness of numerical analysis.)</div><br/></div></div></div></div></div></div><div id="38579542" class="c"><input type="checkbox" id="c-38579542" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38577043">parent</a><span>|</span><a href="#38577137">prev</a><span>|</span><a href="#38579087">next</a><span>|</span><label class="collapse" for="c-38579542">[-]</label><label class="expand" for="c-38579542">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m by no means an expert on interactive theorem proving -- I&#x27;m just a Lean user who knows a lot about how Lean works, and I got into it while procrastinating finishing my math PhD.<p>I think writing novel theorems directly in Lean is similar to the idea of architecting a large software system by jumping right into writing code. Certainly for small things you can just code it, but past a certain level of complexity you need a plan. Paper is still a useful tool in programming, and theorem proving is just a kind of programming.<p>During my PhD I occasionally used Lean to check whether some ideas I had made sense. They were more of a technical flavor of idea than what I&#x27;d usually think of a novel theorem being, and where Lean was helpful was in keeping track of all these technical details that I didn&#x27;t trust myself to get completely right.<p>Speaking of roadmaps, one tool large formalization efforts use are blueprints, an idea developed by Patrick Massot. Here&#x27;s the one for Tao&#x27;s project: <a href="https:&#x2F;&#x2F;teorth.github.io&#x2F;pfr&#x2F;blueprint&#x2F;dep_graph_document.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;teorth.github.io&#x2F;pfr&#x2F;blueprint&#x2F;dep_graph_document.ht...</a>  On this webpage there are also LaTeX versions of every main theorem and links to their Lean equivalents. The original paper was not formal enough to directly formalize in a theorem prover, and this blueprint represents the non-trivial additional creative effort that went into just planning out how to code it.<p>Speaking of Hoogle, there&#x27;s Loogle by Joachim Breitner: <a href="https:&#x2F;&#x2F;loogle.lean-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;loogle.lean-lang.org&#x2F;</a><p>There&#x27;s also an AI-driven free-form text tool that recently appeared: <a href="https:&#x2F;&#x2F;www.moogle.ai&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.moogle.ai&#x2F;</a><p>A funny thing about libraries saving people from wasting effort redoing things is that, while on one hand this is true that having centralized repositories of knowledge invites people to contribute to them and reuse their work, on the other what can happen is that philosophical differences can cause schisms and result in n-fold duplicated work. (Consider the endless web frameworks out there!) Even Lean could be such a duplication since there&#x27;s already Coq, Agda, HOL, etc. So far, Lean&#x27;s mathlib has managed to remain a single project, which I think is an important experiment in seeing if all of mathematics can be unified in a common language. Mathlib is a strange compared to normal software libraries, since its goal is to eventually consume every downstream project that&#x27;s ever created. If this model can continue to scale, then that makes the question of whether something&#x27;s been formalized yet or not simpler. Though, even now, there&#x27;s so much code in mathlib that sometimes you need to go to leanprover.zulipchat.com and ask, and someone familiar with the right corner of the library will usually answer reasonably quickly.<p>One silver lining for n-fold duplication is that it&#x27;s usually not a complete reinvention, and this gives variants of ideas an opportunity to explored that otherwise would succumb to the status quo. I feel that even when someone re-formalizes a theorem, it&#x27;s an additional opportunity to evaluate how this knowledge fits into the larger theory.</div><br/><div id="38579882" class="c"><input type="checkbox" id="c-38579882" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38579542">parent</a><span>|</span><a href="#38579087">next</a><span>|</span><label class="collapse" for="c-38579882">[-]</label><label class="expand" for="c-38579882">[1 more]</label></div><br/><div class="children"><div class="content">&gt; on the other what can happen is that philosophical differences can cause schisms and result in n-fold duplicated work<p>It would indeed be nice to have a principled answer to the issue of differing foundations, including e.g. working in ZF(C) vs. type theory. (The dirty little secret there - and what makes mathlib more popular than it might be otherwise - is that while most practicing mathematicians appeal to ZF(C) as their default foundation they don&#x27;t actually work <i>with</i> it in a formal sense, and the way they do reason about math is a lot easier to account for in type theory. See also <a href="https:&#x2F;&#x2F;math.andrej.com&#x2F;2023&#x2F;02&#x2F;13&#x2F;formalizing-invisible-mathematics&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;math.andrej.com&#x2F;2023&#x2F;02&#x2F;13&#x2F;formalizing-invisible-mat...</a> ) I guess the closest thing we have to that is logical frameworks, which are designed to accommodate even very weak&#x2F;general foundations at the outset and &quot;bridge&quot; theorem statements and proofs across when needed.</div><br/></div></div></div></div><div id="38579087" class="c"><input type="checkbox" id="c-38579087" checked=""/><div class="controls bullet"><span class="by">jenesaispas</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38577043">parent</a><span>|</span><a href="#38579542">prev</a><span>|</span><a href="#38573722">next</a><span>|</span><label class="collapse" for="c-38579087">[-]</label><label class="expand" for="c-38579087">[1 more]</label></div><br/><div class="children"><div class="content">Such a hoogle analogue exists! See moogle.ai.</div><br/></div></div></div></div></div></div><div id="38573722" class="c"><input type="checkbox" id="c-38573722" checked=""/><div class="controls bullet"><span class="by">spadufed</span><span>|</span><a href="#38573029">parent</a><span>|</span><a href="#38573370">prev</a><span>|</span><a href="#38578501">next</a><span>|</span><label class="collapse" for="c-38573722">[-]</label><label class="expand" for="c-38573722">[1 more]</label></div><br/><div class="children"><div class="content">If anybody&#x27;s interested in learning more about Lean, he&#x27;s been posting his experiences with the project over at @tao@mathstodon.xyz</div><br/></div></div><div id="38578501" class="c"><input type="checkbox" id="c-38578501" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38573029">parent</a><span>|</span><a href="#38573722">prev</a><span>|</span><a href="#38573166">next</a><span>|</span><label class="collapse" for="c-38578501">[-]</label><label class="expand" for="c-38578501">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>If these tools become easy enough for mathematicians to use, they might be able to substitute for the often prolonged and onerous peer review process,</i><p>List of long mathematical proofs: 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_long_mathematical_proofs" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_long_mathematical_proo...</a> :<p>&gt; <i>This is a list of unusually long mathematical proofs. Such proofs often use computational proof methods and may be considered non-surveyable.</i><p>&gt; <i>As of 2011, the longest mathematical proof, measured by number of published journal pages, is the classification of finite simple groups with well over 10000 pages. There are several proofs that would be far longer than this if the details of the computer calculations they depend on were published in full.</i><p>Non-surveyable proof: 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Non-surveyable_proof" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Non-surveyable_proof</a> :<p>&gt; <i>In the philosophy of mathematics, a non-surveyable proof is a mathematical proof that is considered infeasible for a human mathematician to verify and so of controversial validity. </i></div><br/><div id="38578591" class="c"><input type="checkbox" id="c-38578591" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38578501">parent</a><span>|</span><a href="#38573166">next</a><span>|</span><label class="collapse" for="c-38578591">[-]</label><label class="expand" for="c-38578591">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how much of mathematics is locked away from us as it requires a level of intelligence we may never have. Why do we assume proofs should be simple little equations or even just a few pages? Elegance? Why should the universe be so elegant? Is it because elegant structures are more efficient and use less energy?<p>Edit: I know some proofs like Fermat&#x27;s last theorem were like dozens of pages or more, but I realize that is still within the comprehension of a well trained and gifted human being.</div><br/><div id="38578835" class="c"><input type="checkbox" id="c-38578835" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38578591">parent</a><span>|</span><a href="#38573166">next</a><span>|</span><label class="collapse" for="c-38578835">[-]</label><label class="expand" for="c-38578835">[1 more]</label></div><br/><div class="children"><div class="content">Take for example the Standard Model Lagrangian (which is a sum of nonlinear fields and used to predict some but not all of particle physics (i.e. n-body gravity, superfluids, antimatter or not, Copenhagen interpretation or not, etc.)),<p>[ LaTeX rendering of the Standard Model Lagrangian, and other as-yet unintegrated equations ]<p>How elegant are these? Is it ever proven that they are of minimal complexity in their respective domains piece-wisely?<p>Learning of Entropy, I had hoped you know. But then that&#x27;s just classical Shannon entropy, and not quite the <i>types of</i> quantum entropy described in for example the Quantum discord Wikipedia article, and then that&#x27;s still not quite quantum fluidic complexity (with other field effects discounted, of course); so is there an elegant <i>quantum fluidic </i> thermodynamic basis for it all and emergence?<p>Quasiparticles display emergent behavior.<p>Virtual particles have or haven&#x27;t mass independent of 2-body gravity.<p>Gravity alone sometimes produces mass, or photons at least.<p>Regardless, things have curl and Divergence.<p>And so Quantum Chaos: what can <i>it</i> predict? Can it can do quantum gravity effects in Superfluids at scale?<p>Progress in quantum CFD would require a different architecture to prove low error of a model for predictions in superfluids.<p>And so how many error-corrected qubits exist to simulate a gas fluid in space (in microgravity) is the limiting factor in checking the sufficiency of a grander unified model from here, too.<p>And also for how long qubits can be stored; we can save save a integer and a float for longer than human timescale with error corrected distributed storage networks, but we can&#x27;t store the output wave function(s*) from quantum computer simulations for more than a second.<p>So <i>prove it</i> means QC, and that&#x27;s not what I see here.</div><br/></div></div></div></div></div></div><div id="38573166" class="c"><input type="checkbox" id="c-38573166" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#38573029">parent</a><span>|</span><a href="#38578501">prev</a><span>|</span><a href="#38574441">next</a><span>|</span><label class="collapse" for="c-38573166">[-]</label><label class="expand" for="c-38573166">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If these tools become easy enough for mathematicians to use<p>Sick burn, Gowers.</div><br/><div id="38573310" class="c"><input type="checkbox" id="c-38573310" checked=""/><div class="controls bullet"><span class="by">gowld</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573166">parent</a><span>|</span><a href="#38574441">next</a><span>|</span><label class="collapse" for="c-38573310">[-]</label><label class="expand" for="c-38573310">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s honest constructive criticism. Lean is very hard to use. It&#x27;s even hard to install and run.</div><br/><div id="38573931" class="c"><input type="checkbox" id="c-38573931" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573310">parent</a><span>|</span><a href="#38574441">next</a><span>|</span><label class="collapse" for="c-38573931">[-]</label><label class="expand" for="c-38573931">[1 more]</label></div><br/><div class="children"><div class="content">Elan makes it actually quite easy. It&#x27;s among the better package managers out there, comparable to cargo.<p>There&#x27;s a single bash script to install both the runtime and the package manager on a variety of platforms, and the integrated build system and native module bundler is both powerful and isomorphic, so all you need to learn is Lean. Without any prior knowledge of Lean I was able to patch existing build scripts to support platform specific C extensions in less than half an hour.</div><br/></div></div></div></div></div></div><div id="38574441" class="c"><input type="checkbox" id="c-38574441" checked=""/><div class="controls bullet"><span class="by">Affric</span><span>|</span><a href="#38573029">parent</a><span>|</span><a href="#38573166">prev</a><span>|</span><a href="#38573486">next</a><span>|</span><label class="collapse" for="c-38574441">[-]</label><label class="expand" for="c-38574441">[1 more]</label></div><br/><div class="children"><div class="content">On your opening sentence against this one from the article:<p>&gt; feels like really one of the most basic things that we didn’t understand<p>Nothing can prepare us for the depth of mathematics.</div><br/></div></div><div id="38573486" class="c"><input type="checkbox" id="c-38573486" checked=""/><div class="controls bullet"><span class="by">brap</span><span>|</span><a href="#38573029">parent</a><span>|</span><a href="#38574441">prev</a><span>|</span><a href="#38575359">next</a><span>|</span><label class="collapse" for="c-38573486">[-]</label><label class="expand" for="c-38573486">[2 more]</label></div><br/><div class="children"><div class="content">Why did the verification step take so long? I imagine just verifying proofs is very efficient, no?<p>Or do they mean formalizing the proof in Lean is what took weeks?</div><br/><div id="38574014" class="c"><input type="checkbox" id="c-38574014" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38573029">root</a><span>|</span><a href="#38573486">parent</a><span>|</span><a href="#38575359">next</a><span>|</span><label class="collapse" for="c-38574014">[-]</label><label class="expand" for="c-38574014">[1 more]</label></div><br/><div class="children"><div class="content">They’re talking about formalizing the proof (aka writing Lean “code”).</div><br/></div></div></div></div></div></div><div id="38575359" class="c"><input type="checkbox" id="c-38575359" checked=""/><div class="controls bullet"><span class="by">logtempo</span><span>|</span><a href="#38573029">prev</a><span>|</span><a href="#38576238">next</a><span>|</span><label class="collapse" for="c-38575359">[-]</label><label class="expand" for="c-38575359">[3 more]</label></div><br/><div class="children"><div class="content">Yesterday I was wondering if it&#x27;s possible to have an AI that can &quot;recreate&quot; the mathematics as we know it, and even go further and explore unexplored paths.<p>Though prduced by a video explaining how AI helped to find optimization in the computation of matrix multiplication.</div><br/><div id="38575682" class="c"><input type="checkbox" id="c-38575682" checked=""/><div class="controls bullet"><span class="by">jmj</span><span>|</span><a href="#38575359">parent</a><span>|</span><a href="#38576728">next</a><span>|</span><label class="collapse" for="c-38575682">[-]</label><label class="expand" for="c-38575682">[1 more]</label></div><br/><div class="children"><div class="content">I am working on that for my PhD!</div><br/></div></div><div id="38576728" class="c"><input type="checkbox" id="c-38576728" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38575359">parent</a><span>|</span><a href="#38575682">prev</a><span>|</span><a href="#38576238">next</a><span>|</span><label class="collapse" for="c-38576728">[-]</label><label class="expand" for="c-38576728">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately it&#x27;s too late to give Theory Mine theorems named after your loved ones as gifts this year: <a href="https:&#x2F;&#x2F;www.theorymine.com&#x2F;home" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.theorymine.com&#x2F;home</a></div><br/></div></div></div></div><div id="38576238" class="c"><input type="checkbox" id="c-38576238" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#38575359">prev</a><span>|</span><a href="#38573404">next</a><span>|</span><label class="collapse" for="c-38576238">[-]</label><label class="expand" for="c-38576238">[1 more]</label></div><br/><div class="children"><div class="content">BTW &quot;Katalin Marton’s Lasting Legacy&quot; [1]<p>[1] <a href="https:&#x2F;&#x2F;ee.stanford.edu&#x2F;~gray&#x2F;Kati_Marton.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;ee.stanford.edu&#x2F;~gray&#x2F;Kati_Marton.pdf</a></div><br/></div></div><div id="38573404" class="c"><input type="checkbox" id="c-38573404" checked=""/><div class="controls bullet"><span class="by">kleiba</span><span>|</span><a href="#38576238">prev</a><span>|</span><a href="#38578893">next</a><span>|</span><label class="collapse" for="c-38573404">[-]</label><label class="expand" for="c-38573404">[50 more]</label></div><br/><div class="children"><div class="content">What do you think, how long until we can give conjectures to a specially trained LLM to come up with a proof?</div><br/><div id="38573691" class="c"><input type="checkbox" id="c-38573691" checked=""/><div class="controls bullet"><span class="by">vakkermans</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38574962">next</a><span>|</span><label class="collapse" for="c-38573691">[-]</label><label class="expand" for="c-38573691">[14 more]</label></div><br/><div class="children"><div class="content">Finding a proof is a search in a large space, akin to searching from abstractions to concretions. LLMs don’t do anything like this, and so you’re looking at the planning problem again. It’s not clear to me how framing this particular problem as a language problem is helpful in any case.</div><br/><div id="38574894" class="c"><input type="checkbox" id="c-38574894" checked=""/><div class="controls bullet"><span class="by">sfink</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38573691">parent</a><span>|</span><a href="#38574068">next</a><span>|</span><label class="collapse" for="c-38574894">[-]</label><label class="expand" for="c-38574894">[5 more]</label></div><br/><div class="children"><div class="content">Perhaps an LLM could produce a plausible-looking proof that is completely and utterly incorrect.<p>As a party trick.</div><br/><div id="38575358" class="c"><input type="checkbox" id="c-38575358" checked=""/><div class="controls bullet"><span class="by">generalizations</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574894">parent</a><span>|</span><a href="#38574068">next</a><span>|</span><label class="collapse" for="c-38575358">[-]</label><label class="expand" for="c-38575358">[4 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t that be the point of pairing it with Lean? You wouldn&#x27;t get false positives.</div><br/><div id="38575752" class="c"><input type="checkbox" id="c-38575752" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38575358">parent</a><span>|</span><a href="#38574068">next</a><span>|</span><label class="collapse" for="c-38575752">[-]</label><label class="expand" for="c-38575752">[3 more]</label></div><br/><div class="children"><div class="content">Doesn’t mean you’d get true positives either. Garbage in, garbage out.</div><br/><div id="38577800" class="c"><input type="checkbox" id="c-38577800" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38575752">parent</a><span>|</span><a href="#38577959">next</a><span>|</span><label class="collapse" for="c-38577800">[-]</label><label class="expand" for="c-38577800">[1 more]</label></div><br/><div class="children"><div class="content">IIUC, any sensible way of &quot;pairing up&quot; these things will mean that anything you get out will be true. But the search might take millennia, and the outcome might be nothing (equivalently, &quot;the LLM&#x27;s conjecture is false&quot;).</div><br/></div></div><div id="38577959" class="c"><input type="checkbox" id="c-38577959" checked=""/><div class="controls bullet"><span class="by">hackerlight</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38575752">parent</a><span>|</span><a href="#38577800">prev</a><span>|</span><a href="#38574068">next</a><span>|</span><label class="collapse" for="c-38577959">[-]</label><label class="expand" for="c-38577959">[1 more]</label></div><br/><div class="children"><div class="content">This is equivalent to saying it&#x27;s not going to work.</div><br/></div></div></div></div></div></div></div></div><div id="38574068" class="c"><input type="checkbox" id="c-38574068" checked=""/><div class="controls bullet"><span class="by">thisismyswamp</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38573691">parent</a><span>|</span><a href="#38574894">prev</a><span>|</span><a href="#38574962">next</a><span>|</span><label class="collapse" for="c-38574068">[-]</label><label class="expand" for="c-38574068">[8 more]</label></div><br/><div class="children"><div class="content">Playing chess &amp; go is also search in a large tree of moves leading to particular game states</div><br/><div id="38574105" class="c"><input type="checkbox" id="c-38574105" checked=""/><div class="controls bullet"><span class="by">pxeger1</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574068">parent</a><span>|</span><a href="#38575410">next</a><span>|</span><label class="collapse" for="c-38574105">[-]</label><label class="expand" for="c-38574105">[4 more]</label></div><br/><div class="children"><div class="content">But AlphaGo etc don’t use any kind of language-based AI, so LLMs (which this thread was about) are no good.</div><br/><div id="38574333" class="c"><input type="checkbox" id="c-38574333" checked=""/><div class="controls bullet"><span class="by">thisismyswamp</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574105">parent</a><span>|</span><a href="#38575410">next</a><span>|</span><label class="collapse" for="c-38574333">[-]</label><label class="expand" for="c-38574333">[3 more]</label></div><br/><div class="children"><div class="content">The next step seems to be applying past advances in reinforcement learning with modern transformer based models</div><br/><div id="38575273" class="c"><input type="checkbox" id="c-38575273" checked=""/><div class="controls bullet"><span class="by">mattsan</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574333">parent</a><span>|</span><a href="#38575410">next</a><span>|</span><label class="collapse" for="c-38575273">[-]</label><label class="expand" for="c-38575273">[2 more]</label></div><br/><div class="children"><div class="content">Which multiple teams are working on - OpenAI (Q*), and Meta just released a reinforcement learning framework</div><br/><div id="38578117" class="c"><input type="checkbox" id="c-38578117" checked=""/><div class="controls bullet"><span class="by">npsomaratna</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38575273">parent</a><span>|</span><a href="#38575410">next</a><span>|</span><label class="collapse" for="c-38578117">[-]</label><label class="expand" for="c-38578117">[1 more]</label></div><br/><div class="children"><div class="content">Could you point me towards Meta&#x27;s reinforcement learning framework?  I&#x27;d like to see how it stacks up against the OpenAI gym.</div><br/></div></div></div></div></div></div></div></div><div id="38575410" class="c"><input type="checkbox" id="c-38575410" checked=""/><div class="controls bullet"><span class="by">greysphere</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574068">parent</a><span>|</span><a href="#38574105">prev</a><span>|</span><a href="#38574962">next</a><span>|</span><label class="collapse" for="c-38575410">[-]</label><label class="expand" for="c-38575410">[3 more]</label></div><br/><div class="children"><div class="content">The final state in chess is a single* state which yes, then branches out to N checkmate configurations and then N*M one-move-from-checkmates, and so on.  (*Technically it&#x27;s won&#x2F;lost&#x2F;draw.)<p>The equivalent final state in theorem proving is unique to each theorem so such a system would need to handle an additional layer-of-generalization.</div><br/><div id="38578864" class="c"><input type="checkbox" id="c-38578864" checked=""/><div class="controls bullet"><span class="by">ChainOfFools</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38575410">parent</a><span>|</span><a href="#38574962">next</a><span>|</span><label class="collapse" for="c-38578864">[-]</label><label class="expand" for="c-38578864">[2 more]</label></div><br/><div class="children"><div class="content">Is this how some of the more advanced chess engines work, or even the not so advanced ones, where there&#x27;s a point at which it stops searching the forward move tree in greatest depth, and instead starts searching backwards from a handful of plausible (gross move limit-bound) checkmate states looking for an intersection with a shallow forward search state?</div><br/><div id="38579545" class="c"><input type="checkbox" id="c-38579545" checked=""/><div class="controls bullet"><span class="by">zone411</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38578864">parent</a><span>|</span><a href="#38574962">next</a><span>|</span><label class="collapse" for="c-38579545">[-]</label><label class="expand" for="c-38579545">[1 more]</label></div><br/><div class="children"><div class="content">Kind of, but it&#x27;s calculated offline and then just accessed during the game: <a href="https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Endgame_Tablebases" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Endgame_Tablebases</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="38574962" class="c"><input type="checkbox" id="c-38574962" checked=""/><div class="controls bullet"><span class="by">llwu</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38573691">prev</a><span>|</span><a href="#38574904">next</a><span>|</span><label class="collapse" for="c-38574962">[-]</label><label class="expand" for="c-38574962">[1 more]</label></div><br/><div class="children"><div class="content">I contributed a few trivial proofs to this project, and I tried enlisting GPT-4, Copilot, Moogle, and Morph Prover to help out (I did not try LLMStep or ReProver).<p>Out of these:<p>- GPT-4 answered maybe one or two questions about syntax<p>- Copilot  autocompleted maybe 0.5%<p>- Moogle was helpful much more often but still often pointed to the wrong theorem in the right file; in most of those cases I could have just done go-to-def to get to the right file and scroll through it<p>Note that these results are actually very good! And Terence Tao seems to have a positive opinion as well. But we&#x27;re very far away from automatically proving conjectures IMO.<p>I will say that Lean has great metaprogramming facilities to accept any type of AI innovation that might emerge. Currently I find the most helpful tactics to be `aesop?`, which is a classical search tactic that tries a bunch of substitutions and simplifications; and `exact?`, when you know there&#x27;s a trivial proof but not sure of the name. But the UX for AI can be as simple as, for example, typing the `gptf` or `llmstep` tactic, and that is fully hooked into the Lean state (goals, hypotheses, etc). So there&#x27;s a lot of opportunity for incremental progress in improving existing workflows (which consist of dispatching trivial manipulations with search&#x2F;simplification tactics)</div><br/></div></div><div id="38574904" class="c"><input type="checkbox" id="c-38574904" checked=""/><div class="controls bullet"><span class="by">auntienomen</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38574962">prev</a><span>|</span><a href="#38576695">next</a><span>|</span><label class="collapse" for="c-38574904">[-]</label><label class="expand" for="c-38574904">[2 more]</label></div><br/><div class="children"><div class="content">Open conjectures are usually solved by inventing new mathematical frameworks that embed the context of the existing question.  Inventing new definitions is trivial, but there&#x27;s no rules that constrain the space of moves.  And inventing _interesting_ new definitions is extremely hard.  I wouldn&#x27;t bet on LLMs doing this ever.</div><br/><div id="38575108" class="c"><input type="checkbox" id="c-38575108" checked=""/><div class="controls bullet"><span class="by">auntienomen</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574904">parent</a><span>|</span><a href="#38576695">next</a><span>|</span><label class="collapse" for="c-38575108">[-]</label><label class="expand" for="c-38575108">[1 more]</label></div><br/><div class="children"><div class="content">What would be nice is an LLM to aid in translation between mathematics and a theorem proving language like Lean.  That might fuel a revolution in how mathematics is done.</div><br/></div></div></div></div><div id="38576695" class="c"><input type="checkbox" id="c-38576695" checked=""/><div class="controls bullet"><span class="by">golly_ned</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38574904">prev</a><span>|</span><a href="#38575066">next</a><span>|</span><label class="collapse" for="c-38576695">[-]</label><label class="expand" for="c-38576695">[1 more]</label></div><br/><div class="children"><div class="content">Recent work on combining LLMs with theorem provers with promising initial results:<p><a href="https:&#x2F;&#x2F;paperswithcode.com&#x2F;paper&#x2F;linc-a-neurosymbolic-approach-for-logical" rel="nofollow noreferrer">https:&#x2F;&#x2F;paperswithcode.com&#x2F;paper&#x2F;linc-a-neurosymbolic-approa...</a><p>&gt; Logical reasoning, i.e., deductively inferring the truth value of a conclusion from a set of premises, is an important task for artificial intelligence with wide potential impacts on science, mathematics, and society. While many prompting-based strategies have been proposed to enable Large Language Models (LLMs) to do such reasoning more effectively, they still appear unsatisfactory, often failing in subtle and unpredictable ways. In this work, we investigate the validity of instead reformulating such tasks as modular neurosymbolic programming, which we call LINC: Logical Inference via Neurosymbolic Computation. In LINC, the LLM acts as a semantic parser, translating premises and conclusions from natural language to expressions in first-order logic. These expressions are then offloaded to an external theorem prover, which symbolically performs deductive inference. Leveraging this approach, we observe significant performance gains on FOLIO and a balanced subset of ProofWriter for three different models in nearly all experimental conditions we evaluate. On ProofWriter, augmenting the comparatively small open-source StarCoder+ (15.5B parameters) with LINC even outperforms GPT-3.5 and GPT-4 with Chain-of-Thought (CoT) prompting by an absolute 38% and 10%, respectively. When used with GPT-4, LINC scores 26% higher than CoT on ProofWriter while performing comparatively on FOLIO. Further analysis reveals that although both methods on average succeed roughly equally often on this dataset, they exhibit distinct and complementary failure modes. We thus provide promising evidence for how logical reasoning over natural language can be tackled through jointly leveraging LLMs alongside symbolic provers. All corresponding code is publicly available at <a href="https:&#x2F;&#x2F;github.com&#x2F;benlipkin&#x2F;linc">https:&#x2F;&#x2F;github.com&#x2F;benlipkin&#x2F;linc</a></div><br/></div></div><div id="38575066" class="c"><input type="checkbox" id="c-38575066" checked=""/><div class="controls bullet"><span class="by">steego</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38576695">prev</a><span>|</span><a href="#38573964">next</a><span>|</span><label class="collapse" for="c-38575066">[-]</label><label class="expand" for="c-38575066">[3 more]</label></div><br/><div class="children"><div class="content">Check out this paper:<p><a href="https:&#x2F;&#x2F;leandojo.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;leandojo.org&#x2F;</a><p>People have already trained models to assist suggestion tactics. They then linked it up to ChatGPT to interactively solve proofs.<p>In this scenario, ChatGPT asks the model for tactic suggestions, applies it to the proof and uses the feedback from Lean to then proceed with the next step.<p>FYI, The programmatic interface to Lean was written by an OpenAI employee who was on the Lean team a few years ago.<p>Also, check out Lean’s roadmap. They aspire to position Lean to becoming a target for LLMs because it has been designed for verification from the ground up.<p>As math and compsci nerds contribute to mathlib, all of those proofs are also building up a huge corpus that will likely be leveraged for both verification and optimization.<p>If AI can make verification a lot easier, then we’re likely going to see verification change programming similarly to the way it changed electronics.</div><br/><div id="38576507" class="c"><input type="checkbox" id="c-38576507" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38575066">parent</a><span>|</span><a href="#38573964">next</a><span>|</span><label class="collapse" for="c-38576507">[-]</label><label class="expand" for="c-38576507">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it has been designed for verification from the ground up.<p>It has a <i>lot</i> of places where you assume things work in a certain way and a lot of ways to assume it (and you can prove `false` if any of those assumptions aren&#x27;t correct). I&#x27;d say it&#x27;s a lot more geared towards formalizing math than verification.<p>There&#x27;s some more things, e.g., the `Expression -&gt; C-code` &quot;compiler&quot; isn&#x27;t verified and neither is the C-compiler. Those could be fixed with some work (that nobody is working on currently, as far as I can tell). But the first issue seems pervasive. I don&#x27;t think Lean will become a standard tool for software verification or significantly advance the discipline. Of course, I&#x27;d love to be wrong.</div><br/><div id="38576720" class="c"><input type="checkbox" id="c-38576720" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38576507">parent</a><span>|</span><a href="#38573964">next</a><span>|</span><label class="collapse" for="c-38576720">[-]</label><label class="expand" for="c-38576720">[1 more]</label></div><br/><div class="children"><div class="content">If the foundations are workable (and they seems to be, though IIRC there is a quotienting construct that&#x27;s quite ad hoc and that people have complained about), the fact that you can additionally &quot;assume&quot; other things is fairly irrelevant, these are no different than extra axioms.</div><br/></div></div></div></div></div></div><div id="38574939" class="c"><input type="checkbox" id="c-38574939" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38573964">prev</a><span>|</span><a href="#38574974">next</a><span>|</span><label class="collapse" for="c-38574939">[-]</label><label class="expand" for="c-38574939">[1 more]</label></div><br/><div class="children"><div class="content">For trivial stuff, it might be able to even now (but those can probably be solved algorithmically as well). For more complex stuff, they are not even scratching the surface, I would believe — LLMs can’t really do long, complex thoughts&#x2F;inferences, which are essential for coming up with proofs, or even just to solve a sudoku (which they can’t do — no, writing a program (which was likely part of its training set) and executing that doesn’t count).</div><br/></div></div><div id="38574974" class="c"><input type="checkbox" id="c-38574974" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38574939">prev</a><span>|</span><a href="#38574514">next</a><span>|</span><label class="collapse" for="c-38574974">[-]</label><label class="expand" for="c-38574974">[2 more]</label></div><br/><div class="children"><div class="content">It will never happen. Some open math problems are equivalent to the halting problem; and we know that finite computers can’t solve the halting problem.</div><br/><div id="38576031" class="c"><input type="checkbox" id="c-38576031" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574974">parent</a><span>|</span><a href="#38574514">next</a><span>|</span><label class="collapse" for="c-38576031">[-]</label><label class="expand" for="c-38576031">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t sound right, we already have automated theorem provers, as imperfect as they may be.</div><br/></div></div></div></div><div id="38574514" class="c"><input type="checkbox" id="c-38574514" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38574974">prev</a><span>|</span><a href="#38573463">next</a><span>|</span><label class="collapse" for="c-38574514">[-]</label><label class="expand" for="c-38574514">[4 more]</label></div><br/><div class="children"><div class="content">At the same level of success as a mathematician? Never.<p>At the same level of success as your average high school graduate? Probably already can.</div><br/><div id="38574969" class="c"><input type="checkbox" id="c-38574969" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574514">parent</a><span>|</span><a href="#38573463">next</a><span>|</span><label class="collapse" for="c-38574969">[-]</label><label class="expand" for="c-38574969">[3 more]</label></div><br/><div class="children"><div class="content">I assume an average high school graduate can solve a sudoku. LLMs are very interesting but anything “thinking”-related is not their strong suit.</div><br/><div id="38576438" class="c"><input type="checkbox" id="c-38576438" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574969">parent</a><span>|</span><a href="#38573463">next</a><span>|</span><label class="collapse" for="c-38576438">[-]</label><label class="expand" for="c-38576438">[2 more]</label></div><br/><div class="children"><div class="content">Solving sudoku is not really a proof.<p>Like its a witness that a solution exists but i dont think that&#x27;s really the thing most people mean by write a proof.<p>LLMs are really good at cutting and pasting from the internet. That&#x27;s the level i would expect from average high school student.</div><br/><div id="38578001" class="c"><input type="checkbox" id="c-38578001" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38576438">parent</a><span>|</span><a href="#38573463">next</a><span>|</span><label class="collapse" for="c-38578001">[-]</label><label class="expand" for="c-38578001">[1 more]</label></div><br/><div class="children"><div class="content">Solving sudoku is a pure exercise in proving what the solution is.<p>But most sudoku tend to be unsatisfying in that you&#x27;re forced to use trial and error. The more formal term would be &quot;proof by cases&quot;: once your fun proving has reached its limits, you&#x27;ve shown that a particular cell must contain either 5 or 7. If you show that that cell containing a 5 will lead to a contradiction, you&#x27;ve created an impeccable proof that the cell contains a 7.<p>The distinction you&#x27;ve stated would only come into play if the number of possible solutions to a puzzle differs from one; if there are no solutions, you have inconsistent premises and your proofs will be valid but not sound. If there are several solutions, then guessing and being right will, as you describe, create a proof that a solution exists, but it won&#x27;t prove that that solution is unique or characterize what valid solutions are like, both of which are common mathematical goals.</div><br/></div></div></div></div></div></div></div></div><div id="38573463" class="c"><input type="checkbox" id="c-38573463" checked=""/><div class="controls bullet"><span class="by">brap</span><span>|</span><a href="#38573404">parent</a><span>|</span><a href="#38574514">prev</a><span>|</span><a href="#38578893">next</a><span>|</span><label class="collapse" for="c-38573463">[-]</label><label class="expand" for="c-38573463">[20 more]</label></div><br/><div class="children"><div class="content">My uneducated hunch is that we’re just a few years away from “proof search” being a solved problem. But that’s only a part of mathematical research.</div><br/><div id="38573763" class="c"><input type="checkbox" id="c-38573763" checked=""/><div class="controls bullet"><span class="by">prmph</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38573463">parent</a><span>|</span><a href="#38574203">next</a><span>|</span><label class="collapse" for="c-38573763">[-]</label><label class="expand" for="c-38573763">[18 more]</label></div><br/><div class="children"><div class="content">I think you are much too optimistic.<p>Proof verification, though still hard to automate, seems at least tractable. I&#x27;m not a mathematician by any means, but something tells me automated proof search, in the general case, would require solving the halting problem, which means it is impossible even in principle.</div><br/><div id="38574017" class="c"><input type="checkbox" id="c-38574017" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38573763">parent</a><span>|</span><a href="#38575259">next</a><span>|</span><label class="collapse" for="c-38574017">[-]</label><label class="expand" for="c-38574017">[7 more]</label></div><br/><div class="children"><div class="content">In the general case, proof search is obviously impossible, for the reason you state. But the case need not be general. A proof search machine that takes in a theorem and outputs `&quot;proof: ...&quot; | &quot;antiProof: ...&quot; | &quot;idk&quot;` would be quite powerful indeed.</div><br/><div id="38574902" class="c"><input type="checkbox" id="c-38574902" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574017">parent</a><span>|</span><a href="#38578012">next</a><span>|</span><label class="collapse" for="c-38574902">[-]</label><label class="expand" for="c-38574902">[5 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    def decider(_): print(&quot;idk&quot;)
</code></pre>
Done ;)<p>---<p>More seriously, the benchmark would be something along the lines of &quot;and it is better at finding proofs than humans are&quot;, like how chess engines haven&#x27;t solved chess, but they are so much better than humans that they always win in a competition between the two.<p>There&#x27;s no good reason to think that humans are capable of finding proofs that are hard to find algorithmically.</div><br/><div id="38576659" class="c"><input type="checkbox" id="c-38576659" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574902">parent</a><span>|</span><a href="#38575073">next</a><span>|</span><label class="collapse" for="c-38576659">[-]</label><label class="expand" for="c-38576659">[3 more]</label></div><br/><div class="children"><div class="content">Clearly the prevalence of idk&#x27;s in the output is the metric for determining power.<p>As for the human-vs-computer, I think the most powerful solutions will be those that combine human and computer prowess, similar to how a Human+Stockfish beats Stockfish^. To that end I&#x27;ve been working on Lean search tools that keep a human firmly in the loop. Terence has actually called out a tool I helped make as being quite helpful in his work, which is rather neat.<p>^ I heard this to be true at some point, but cannot find any reference on it at the moment.</div><br/><div id="38576950" class="c"><input type="checkbox" id="c-38576950" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38576659">parent</a><span>|</span><a href="#38575073">next</a><span>|</span><label class="collapse" for="c-38576950">[-]</label><label class="expand" for="c-38576950">[2 more]</label></div><br/><div class="children"><div class="content">&gt; similar to how a Human+Stockfish beats Stockfish^<p>&gt; ^ I heard this to be true at some point, but cannot find any reference on it at the moment.<p>Known as centaur chess (amongst other things). It was certainly the case at one point. I strongly suspect that it isn&#x27;t still the case, but it&#x27;s hard to say for absolute certainty because it never developed a serious competitive community like engine and non-engine chess has. I can&#x27;t find anyone listing any results post 2017 [1]. It was barely the case in 2017, and Stockfish has improved a <i>lot</i> since then [2].<p>[1] <a href="https:&#x2F;&#x2F;gwern.net&#x2F;note&#x2F;note#advanced-chess-obituary" rel="nofollow noreferrer">https:&#x2F;&#x2F;gwern.net&#x2F;note&#x2F;note#advanced-chess-obituary</a><p>[2] E.g. here&#x27;s someone running stockfish 14 (current from July 2 2021 - April 18 2022) against stockfish 8 (current from November 1 2016 to February 1 2018). Stockfish 14 won 61 games and drew 3: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;chess&#x2F;comments&#x2F;oov714&#x2F;64_game_match_between_the_new_stockfish_14_and&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;chess&#x2F;comments&#x2F;oov714&#x2F;64_game_match...</a> (PS: They don&#x27;t document time controls and I&#x27;m not sure how scientific this test was, but it matches with what I would expect, so eh)<p>Not to discourage you from your project with lean. At the very least I would expect there to be a transitional period, likely of decades, where computer+human is better than computer.</div><br/><div id="38577035" class="c"><input type="checkbox" id="c-38577035" checked=""/><div class="controls bullet"><span class="by">zone411</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38576950">parent</a><span>|</span><a href="#38575073">next</a><span>|</span><label class="collapse" for="c-38577035">[-]</label><label class="expand" for="c-38577035">[1 more]</label></div><br/><div class="children"><div class="content">In the 2022 Correspondence Chess Championship, humans hurt the performance of computers by themselves. I posted about this here: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;LechMazur&#x2F;status&#x2F;1721008768899555677" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;LechMazur&#x2F;status&#x2F;1721008768899555677</a></div><br/></div></div></div></div></div></div><div id="38575073" class="c"><input type="checkbox" id="c-38575073" checked=""/><div class="controls bullet"><span class="by">brap</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574902">parent</a><span>|</span><a href="#38576659">prev</a><span>|</span><a href="#38578012">next</a><span>|</span><label class="collapse" for="c-38575073">[-]</label><label class="expand" for="c-38575073">[1 more]</label></div><br/><div class="children"><div class="content">&gt;There&#x27;s no good reason to think that humans are capable of finding proofs that are hard to find algorithmically<p>That’s really all I was trying to say, not sure why I’m getting downvoted</div><br/></div></div></div></div><div id="38578012" class="c"><input type="checkbox" id="c-38578012" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574017">parent</a><span>|</span><a href="#38574902">prev</a><span>|</span><a href="#38575259">next</a><span>|</span><label class="collapse" for="c-38578012">[-]</label><label class="expand" for="c-38578012">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;antiProof: ...&quot;<p>The standard terminology would be &quot;counterexample&quot;.</div><br/></div></div></div></div><div id="38574102" class="c"><input type="checkbox" id="c-38574102" checked=""/><div class="controls bullet"><span class="by">dellamonica</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38573763">parent</a><span>|</span><a href="#38575259">prev</a><span>|</span><a href="#38574203">next</a><span>|</span><label class="collapse" for="c-38574102">[-]</label><label class="expand" for="c-38574102">[8 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t require anything like that.<p>Math proofs are of NP complexity. If you had access to a non deterministic Turing machine you could enumerate all possible proofs of a given length and check them all in poly time.<p>That does not say anything about LLMs though. Personally, I believe they could be quite helpful to mathematicians in a way similar to copilot for software programming.</div><br/><div id="38574765" class="c"><input type="checkbox" id="c-38574765" checked=""/><div class="controls bullet"><span class="by">Jweb_Guru</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574102">parent</a><span>|</span><a href="#38574206">next</a><span>|</span><label class="collapse" for="c-38574765">[-]</label><label class="expand" for="c-38574765">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Math proofs are of NP complexity.<p>This is only true for very specific kinds of proofs, and doesn&#x27;t apply to stuff that uses CiC like Lean 4.  This is because many proof steps proceed by conversion, which can require running programs of <i>extremely</i> high complexity (much higher than exponential) in order to determine whether two terms are equal.  If this weren&#x27;t the case, it would be much much easier to prove things like termination of proof verification in CiC (which is considered a very difficult problem that requires appeal to large cardinal axioms!).  There <i>are</i> formalisms where verifying each proof steps is much lower complexity, but these can be proven to have exponentially (or greater) longer proofs on some problems (whether these cases are relevant in practice is often debated, but I do think the amount of real mathematics that&#x27;s been formalized in CiC-based provers suggests that the extra power can be useful).</div><br/><div id="38575488" class="c"><input type="checkbox" id="c-38575488" checked=""/><div class="controls bullet"><span class="by">dellamonica</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574765">parent</a><span>|</span><a href="#38575000">next</a><span>|</span><label class="collapse" for="c-38575488">[-]</label><label class="expand" for="c-38575488">[1 more]</label></div><br/><div class="children"><div class="content">This is all very interesting but it  seems that we&#x27;re just taking different views on what is the instance size. If it is the length of the theorem statement in some suitable encoding and the goal is to find a proof, of any possible length, then yeah, this is way too hard.<p>I&#x27;m taking the view that the (max) length of the proof can be taken as a parameter for the complexity because anything too long would not have any chance of being found by a human. It may also not be trusted by mathematicians anyway... do you know if the hardware is bug free, the compiler is 100% correct and no cosmic particle corrupted some part of your exponential length proof? It&#x27;s a tough sell.</div><br/></div></div><div id="38575000" class="c"><input type="checkbox" id="c-38575000" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574765">parent</a><span>|</span><a href="#38575488">prev</a><span>|</span><a href="#38574206">next</a><span>|</span><label class="collapse" for="c-38575000">[-]</label><label class="expand" for="c-38575000">[1 more]</label></div><br/><div class="children"><div class="content">Yes, executing a calculation as part of a proof after separately proving that it is the &quot;right&quot; calculation to solve the problem is quite a common way of proceeding.  Even common things like algebraic simplifications of all kinds (including solving equations, etc.) can be seen as instances of this, but this kind of thing has notably come up in the solution of famous problems like the 4-color problem, or the Kepler conjecture - both of which have been computer-verified.</div><br/></div></div></div></div><div id="38574206" class="c"><input type="checkbox" id="c-38574206" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574102">parent</a><span>|</span><a href="#38574765">prev</a><span>|</span><a href="#38574203">next</a><span>|</span><label class="collapse" for="c-38574206">[-]</label><label class="expand" for="c-38574206">[4 more]</label></div><br/><div class="children"><div class="content">&gt; you could enumerate all possible proofs of a given length<p>That does not help us with proof search as we do not know the target length.</div><br/><div id="38574540" class="c"><input type="checkbox" id="c-38574540" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574206">parent</a><span>|</span><a href="#38574623">next</a><span>|</span><label class="collapse" for="c-38574540">[-]</label><label class="expand" for="c-38574540">[1 more]</label></div><br/><div class="children"><div class="content">A proof longer than the size of the universe is also pretty useless and probably not something we need to worry about.<p>Like i guess you are saying we couldn&#x27;t really use such a machine to determine whether a certain conjecture just has a very long proof&#x2F;disproof  or is actually undecidable. Which sure, but umm i think that is the sort of problem most mathematicians would love to have.<p>The real reason non-deterministic turing machines can&#x27;t help us is that they dont actually exist.</div><br/></div></div><div id="38574623" class="c"><input type="checkbox" id="c-38574623" checked=""/><div class="controls bullet"><span class="by">dellamonica</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574206">parent</a><span>|</span><a href="#38574540">prev</a><span>|</span><a href="#38574203">next</a><span>|</span><label class="collapse" for="c-38574623">[-]</label><label class="expand" for="c-38574623">[2 more]</label></div><br/><div class="children"><div class="content">Of course it would, you would enumerate lengths too. If the lengths need to be larger than polynomially bounded then we can be sure it would never be found by a human anyway.</div><br/><div id="38576783" class="c"><input type="checkbox" id="c-38576783" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38574623">parent</a><span>|</span><a href="#38574203">next</a><span>|</span><label class="collapse" for="c-38576783">[-]</label><label class="expand" for="c-38576783">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If the lengths need to be larger than polynomially bounded then we can be sure it would never be found by a human anyway.<p>We cannot, as a human might be able to intuitively devise proof that might be quite large in the target language but easily constructible in a separate one.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38574203" class="c"><input type="checkbox" id="c-38574203" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#38573404">root</a><span>|</span><a href="#38573463">parent</a><span>|</span><a href="#38573763">prev</a><span>|</span><a href="#38578893">next</a><span>|</span><label class="collapse" for="c-38574203">[-]</label><label class="expand" for="c-38574203">[1 more]</label></div><br/><div class="children"><div class="content">Neither RH nor P vs NP will succumb.</div><br/></div></div></div></div></div></div><div id="38578893" class="c"><input type="checkbox" id="c-38578893" checked=""/><div class="controls bullet"><span class="by">oldandtired</span><span>|</span><a href="#38573404">prev</a><span>|</span><a href="#38576552">next</a><span>|</span><label class="collapse" for="c-38578893">[-]</label><label class="expand" for="c-38578893">[1 more]</label></div><br/><div class="children"><div class="content">Now that it has been done in Lean, how about the version that can be put into Metamath?</div><br/></div></div><div id="38576552" class="c"><input type="checkbox" id="c-38576552" checked=""/><div class="controls bullet"><span class="by">swayvil</span><span>|</span><a href="#38578893">prev</a><span>|</span><a href="#38573049">next</a><span>|</span><label class="collapse" for="c-38576552">[-]</label><label class="expand" for="c-38576552">[2 more]</label></div><br/><div class="children"><div class="content">You always hear &quot;the map is not the territory&quot;. Which is to say, names are applied, models are asserted and all our fine ideas about the world are our own contrivance, not the world&#x27;s.<p>But how close could we get?</div><br/><div id="38578873" class="c"><input type="checkbox" id="c-38578873" checked=""/><div class="controls bullet"><span class="by">oldandtired</span><span>|</span><a href="#38576552">parent</a><span>|</span><a href="#38573049">next</a><span>|</span><label class="collapse" for="c-38578873">[-]</label><label class="expand" for="c-38578873">[1 more]</label></div><br/><div class="children"><div class="content">Not very close at all.<p>Every map that is made leaves out an enormous amount of the territory because that detail is irrelevant to the map being used or created. The more detailed the map is, the more one should recognise just how much more detail is being ignored.<p>If you want to get close, just go to the territory itself and be there directly.<p>All too often, we use mathematics as a map for the actual world around and to keep that map manageable, we have to ignore much of the actual world.</div><br/></div></div></div></div><div id="38573049" class="c"><input type="checkbox" id="c-38573049" checked=""/><div class="controls bullet"><span class="by">owlbite</span><span>|</span><a href="#38576552">prev</a><span>|</span><label class="collapse" for="c-38573049">[-]</label><label class="expand" for="c-38573049">[9 more]</label></div><br/><div class="children"><div class="content">10 years ago a crack professor unit was defunded by an academic tribunal for misconduct they didn&#x27;t commit. These men promptly escaped from a maximum teaching schedule to the research underground. Today, still wanted by the activist community, they survive as proovers of fortune. If you have a problem that no one else can solve, and if you can find them, maybe you can hire The A-Team.</div><br/><div id="38573341" class="c"><input type="checkbox" id="c-38573341" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38573049">parent</a><span>|</span><a href="#38579561">next</a><span>|</span><label class="collapse" for="c-38573341">[-]</label><label class="expand" for="c-38573341">[5 more]</label></div><br/><div class="children"><div class="content">My favourite bit of every episode was the iconic ὅπλισις when Prof. Dr. P.H.D. Baracus first adds structure preserving maps to every object in sight then uses the snake lemma to weld them together with connecting homomorphisms. &quot;I pity the fool who doesn&#x27;t chase diagrams&quot;</div><br/><div id="38573409" class="c"><input type="checkbox" id="c-38573409" checked=""/><div class="controls bullet"><span class="by">CobrastanJorji</span><span>|</span><a href="#38573049">root</a><span>|</span><a href="#38573341">parent</a><span>|</span><a href="#38579561">next</a><span>|</span><label class="collapse" for="c-38573409">[-]</label><label class="expand" for="c-38573409">[4 more]</label></div><br/><div class="children"><div class="content">I got a little sick of the recurring joke where Prof. Dr. Baracus would complain about flat, two-dimensional, infinite surfaces, and then the team would trick him into using one anyway.</div><br/><div id="38574020" class="c"><input type="checkbox" id="c-38574020" checked=""/><div class="controls bullet"><span class="by">jfengel</span><span>|</span><a href="#38573049">root</a><span>|</span><a href="#38573409">parent</a><span>|</span><a href="#38579561">next</a><span>|</span><label class="collapse" for="c-38574020">[-]</label><label class="expand" for="c-38574020">[3 more]</label></div><br/><div class="children"><div class="content">Goddamn that&#x27;s a long way to go to make that joke.<p>Worth the journey, but those are brain cells I haven&#x27;t used in decades. I really wish I could garbage-collect some of the 1980s pop culture neurons and put them to better use.</div><br/><div id="38574294" class="c"><input type="checkbox" id="c-38574294" checked=""/><div class="controls bullet"><span class="by">sumtechguy</span><span>|</span><a href="#38573049">root</a><span>|</span><a href="#38574020">parent</a><span>|</span><a href="#38574036">next</a><span>|</span><label class="collapse" for="c-38574294">[-]</label><label class="expand" for="c-38574294">[1 more]</label></div><br/><div class="children"><div class="content">A lone mathematician battles the forces of evil with the help of a virtually indestructible and artificially intelligent assistant CGPT.</div><br/></div></div><div id="38574036" class="c"><input type="checkbox" id="c-38574036" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#38573049">root</a><span>|</span><a href="#38574020">parent</a><span>|</span><a href="#38574294">prev</a><span>|</span><a href="#38579561">next</a><span>|</span><label class="collapse" for="c-38574036">[-]</label><label class="expand" for="c-38574036">[1 more]</label></div><br/><div class="children"><div class="content">I feel like this about Call of Duty maps.</div><br/></div></div></div></div></div></div></div></div><div id="38573521" class="c"><input type="checkbox" id="c-38573521" checked=""/><div class="controls bullet"><span class="by">gosub100</span><span>|</span><a href="#38573049">parent</a><span>|</span><a href="#38579561">prev</a><span>|</span><a href="#38573320">next</a><span>|</span><label class="collapse" for="c-38573521">[-]</label><label class="expand" for="c-38573521">[1 more]</label></div><br/><div class="children"><div class="content">I love it when a discrete manifold comes together!</div><br/></div></div><div id="38573320" class="c"><input type="checkbox" id="c-38573320" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#38573049">parent</a><span>|</span><a href="#38573521">prev</a><span>|</span><label class="collapse" for="c-38573320">[-]</label><label class="expand" for="c-38573320">[1 more]</label></div><br/><div class="children"><div class="content">That’s funny  thanks :-)</div><br/></div></div></div></div></div></div></div></div></div></body></html>