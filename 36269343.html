<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686560474982" as="style"/><link rel="stylesheet" href="styles.css?v=1686560474982"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://evanhahn.com/utf-21/">UTF-21, a toy character encoding</a> <span class="domain">(<a href="https://evanhahn.com">evanhahn.com</a>)</span></div><div class="subtext"><span>samwillis</span> | <span>56 comments</span></div><br/><div><div id="36288405" class="c"><input type="checkbox" id="c-36288405" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#36290268">next</a><span>|</span><label class="collapse" for="c-36288405">[-]</label><label class="expand" for="c-36288405">[25 more]</label></div><br/><div class="children"><div class="content">For older programmers like me, who pretty much only deal in English, the very simplicity of ASCII can make unicode difficult to grasp.<p>In ASCII 1 byte (always 1 byte) of ram = 1 character. And the encoding called ASCII matches the mapping called ASCII.<p>Along comes Unicode (a mapping), which has multiple different encodings. A difficult distinction leading to statements like &quot;that&#x27;s a unicode string&#x2F;file&#x2F;field&quot;.<p>Along comes unicode which has variable bytes per character. (Yes, even for utf-32, which is why no-one uses utf-32). I still regularly come across folk who think unicode means 2 bytes per character.<p>Along comes unicode which asks you to consider if the functions LEN, SUB, SLICE etc are counting Bytes or Characters.<p>Along comes unicode that breaks the idea of setting field length in databases as &quot;number of characters&quot;, made worse by a cohort brought up on limited storage, who want to be &quot;effecient&quot; in their declarations.<p>Along comes unicode with code units, code points, characters -all of which come into play, all with different, or variable, lengths.<p>So while utf-21 might be a &quot;toy&quot;, even making something like that yourself is a learning exercise well worth the endeavour. It should be a mandatory teaching exercise. Two thumbs up.</div><br/><div id="36290022" class="c"><input type="checkbox" id="c-36290022" checked=""/><div class="controls bullet"><span class="by">aardvark179</span><span>|</span><a href="#36288405">parent</a><span>|</span><a href="#36288456">next</a><span>|</span><label class="collapse" for="c-36290022">[-]</label><label class="expand" for="c-36290022">[1 more]</label></div><br/><div class="children"><div class="content">That ship sailed long before Unicode. ISO&#x2F;IEC 8859-1 Included several accents which combine with a preceding character, and that was standardised in 1987. If you only deal in English then remove all accents and map everything down to 7 bit ASCII, if you don’t just deal with English then accept that and deal with it. :-)<p>Having had to do some internationalisation of code written by Americans that couldn’t even handle 8 bit characters I am fine with spreading this bit of pain a little more evenly round the world.</div><br/></div></div><div id="36288456" class="c"><input type="checkbox" id="c-36288456" checked=""/><div class="controls bullet"><span class="by">franciscop</span><span>|</span><a href="#36288405">parent</a><span>|</span><a href="#36290022">prev</a><span>|</span><a href="#36289300">next</a><span>|</span><label class="collapse" for="c-36288456">[-]</label><label class="expand" for="c-36288456">[9 more]</label></div><br/><div class="children"><div class="content">As a beginner programmer back in the day I&#x27;d have agreed that unicode is weird and &quot;length in characters&quot; is the right metric for the database entry.<p>However as a senior dev, who have read and messed around enough with binary, UTF-X, compression&#x2F;GZIP, etc, I&#x27;d say that &quot;character length&quot; for database field size is a weird concept and that &quot;size in bytes&quot; would make more sense since that maps better to what you have in the HDD&#x2F;SSD&#x2F;network.</div><br/><div id="36290294" class="c"><input type="checkbox" id="c-36290294" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36288456">parent</a><span>|</span><a href="#36290015">next</a><span>|</span><label class="collapse" for="c-36290294">[-]</label><label class="expand" for="c-36290294">[1 more]</label></div><br/><div class="children"><div class="content">It makes it less intuitive for the user if you have input fields limited to <i>n</i> bytes instead of to <i>n</i> characters (complications caused by combining characters notwithstanding).</div><br/></div></div><div id="36290015" class="c"><input type="checkbox" id="c-36290015" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36288456">parent</a><span>|</span><a href="#36290294">prev</a><span>|</span><a href="#36289019">next</a><span>|</span><label class="collapse" for="c-36290015">[-]</label><label class="expand" for="c-36290015">[1 more]</label></div><br/><div class="children"><div class="content">Typically there should be a <i>maximum</i> size in bytes for performance reasons (e.g. how many rows fit in a page) and&#x2F;or a <i>minimum</i> size in &quot;characters&quot; (very ill defined but usually approximated as code points, with some slack to allow a reasonable amount of combining marks in addition to the desired number of letters), with no guarantee that the two sizes are compatible.<p>I&#x27;ve often found in practice short UTF-8 columns with a bytes length, that &quot;accidentally&quot; truncated text with ctastrophic effects after the application checked value lengths in characters.</div><br/></div></div><div id="36289019" class="c"><input type="checkbox" id="c-36289019" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36288456">parent</a><span>|</span><a href="#36290015">prev</a><span>|</span><a href="#36289300">next</a><span>|</span><label class="collapse" for="c-36289019">[-]</label><label class="expand" for="c-36289019">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say that &quot;character length&quot; for database field size is a weird concept<p>Until you want a constraint for such a column. From a business perspective, you would limit the column to a specific number of characters, not bytes</div><br/><div id="36290357" class="c"><input type="checkbox" id="c-36290357" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289019">parent</a><span>|</span><a href="#36289699">next</a><span>|</span><label class="collapse" for="c-36290357">[-]</label><label class="expand" for="c-36290357">[1 more]</label></div><br/><div class="children"><div class="content">Is there ever a genuine, non-arbitrary business requirement to limit any string to a certain number of unicode characters? And by characters here we probably mean extended grapheme clusters.<p>If the data is going to get printed in a monospace font, on a passport or credit card or something, then i can understand a limit on the number of characters. But then it&#x27;s not full unicode either - you want to constrain the length in some specific character set.<p>Otherwise, i think limits are always arbitrary. I suspect there is a strong cultural holdover from the days of punched cards here.</div><br/></div></div><div id="36289699" class="c"><input type="checkbox" id="c-36289699" checked=""/><div class="controls bullet"><span class="by">PeterisP</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289019">parent</a><span>|</span><a href="#36290357">prev</a><span>|</span><a href="#36289158">next</a><span>|</span><label class="collapse" for="c-36289699">[-]</label><label class="expand" for="c-36289699">[1 more]</label></div><br/><div class="children"><div class="content">If you want a constraint for such a column, then due to nature of our complex writing, it has to be separate from the actual field type and physical storage allocation - it&#x27;s the equivalent of an integer field having a constraint that it must be between 1 and 100.</div><br/></div></div><div id="36289158" class="c"><input type="checkbox" id="c-36289158" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289019">parent</a><span>|</span><a href="#36289699">prev</a><span>|</span><a href="#36289305">next</a><span>|</span><label class="collapse" for="c-36289158">[-]</label><label class="expand" for="c-36289158">[1 more]</label></div><br/><div class="children"><div class="content">Let me be clear. You currently cannot constrain for number of characters in a unicode string.<p>From a business perspective it&#x27;s unhelpful to think of constraining in that way.<p>By all means constrain on bytes, and if that&#x27;s close enough for you, use that as a proxy. Or provision lots of space, and count characters in the UI.</div><br/></div></div><div id="36289305" class="c"><input type="checkbox" id="c-36289305" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289019">parent</a><span>|</span><a href="#36289158">prev</a><span>|</span><a href="#36289300">next</a><span>|</span><label class="collapse" for="c-36289305">[-]</label><label class="expand" for="c-36289305">[2 more]</label></div><br/><div class="children"><div class="content">This is ALWAYS broken on unicode. It only makes sense in ASCII and with alphabets similar to the Latin alphabet.</div><br/><div id="36289377" class="c"><input type="checkbox" id="c-36289377" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289305">parent</a><span>|</span><a href="#36289300">next</a><span>|</span><label class="collapse" for="c-36289377">[-]</label><label class="expand" for="c-36289377">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not broken if &quot;character&quot; means &quot;extended grapheme cluster&quot;.<p>Though in that case it makes it very hard to index the column.</div><br/></div></div></div></div></div></div></div></div><div id="36289300" class="c"><input type="checkbox" id="c-36289300" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#36288405">parent</a><span>|</span><a href="#36288456">prev</a><span>|</span><a href="#36289239">next</a><span>|</span><label class="collapse" for="c-36289300">[-]</label><label class="expand" for="c-36289300">[5 more]</label></div><br/><div class="children"><div class="content">The gist of unicode is that code like<p><pre><code>   const char *const end = str + strlen(str);
   for (const char *it = str; it &lt; end; ++i) { .. }
</code></pre>
is almost always wrong unless your locale is C and you explicitly say you only work with ASCII. It&#x27;s wrong with UTF-32 and char32_t too, because as the post suggests Unicode codepoints are not glyphs - you can have glyphs spanning over multiple codepoints, with multiple normalization forms. This is particularly tricky, because characters printed the same can be represented in multiple ways and it&#x27;s hard to discern them, i.e. è can be a single codepoint or a combination of a &#x27;◌́ &#x27; modifier and &#x27;e&#x27;.<p>In general the trivial C assumption &quot;strings are just char arrays&quot; most people are accustomed to is dangerous and broken in Unicode. str[x] in Unicode is wrong 99% of the time, thus UTF16 and 32 are nonsense¹ and either you treat strings as bytes you just pass around, or you need a full Unicode library such as ICU to operate on Unicode text safely.<p>¹: in my experience they are NEVER used mostly, UTF-16 is actually two incompatible encodings and use it as a way to &quot;UTF-wash&quot; the broken UCS-2 they so eagerly adopted in the &#x27;90s (including Java, Windows NT, Cocoa, Qt, Unreal, JavaScript, [partially] Python, ...) .</div><br/><div id="36289962" class="c"><input type="checkbox" id="c-36289962" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289300">parent</a><span>|</span><a href="#36289328">next</a><span>|</span><label class="collapse" for="c-36289962">[-]</label><label class="expand" for="c-36289962">[3 more]</label></div><br/><div class="children"><div class="content">So, as someone who has had to briefly dabble in Unicode muck some years ago: how would I properly iterate through Unicode? How do I know how many bytes to iterate before I get a proper glyph instead of part of a glyph, or worse: a glyph and some extra codepoints?<p>Is the concept so esoteric that it&#x27;s best to just find a blackbox library and not worry about the finer details?</div><br/><div id="36290143" class="c"><input type="checkbox" id="c-36290143" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289962">parent</a><span>|</span><a href="#36290177">next</a><span>|</span><label class="collapse" for="c-36290143">[-]</label><label class="expand" for="c-36290143">[1 more]</label></div><br/><div class="children"><div class="content">If you want a &quot;glyph&quot; you are trolling yourself because selecting and assembling glyphs in fonts is an additional layer of punishing complication on top of Unicode itself. Correct text rendering requires passing as much text as possible (even multiple lines) to a &quot;black box&quot; library that figures out layout, ligatures, glyph replacement etc.<p>If instead you want to find, as is more likely, whole grapheme clusters that can be treated as editing units (e.g. select&#x2F;copy&#x2F;delete &quot;the character after the cursor&quot;, move the cursor N &quot;characters&quot;, count &quot;letters&quot; in a string) you can go forward through your string, codepoint by codepoint, and decide depending on how those codepoints are classified where a &quot;character&quot; ends. Your ideas and requirements about the criteria might or might not match those of your libraries and of the Unicode standard itself.</div><br/></div></div><div id="36290177" class="c"><input type="checkbox" id="c-36290177" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289962">parent</a><span>|</span><a href="#36290143">prev</a><span>|</span><a href="#36289328">next</a><span>|</span><label class="collapse" for="c-36290177">[-]</label><label class="expand" for="c-36290177">[1 more]</label></div><br/><div class="children"><div class="content">To do it correctly, you decode the unicode. Then you apply whatever algorithms you need. Decide things like &quot;are the diacritics on combined characters extra glyphs or not&quot; and &quot;how many characters is &#x27;﷽&#x27;&quot; and &quot;ௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌௌ is technically a single glyph built around several character combinations but it&#x27;s as long as a sentence&quot;. Actually, you don&#x27;t want glyphs, you&#x27;re probably interested in grapheme clusters.<p>You can try to be smart and measure the width of the rendered string, but then you find out that Mongolian is written top-to-bottom and that Zalgo allows for freaky combinations that break the line boundaries.<p>The real answer is the answer to the question &quot;how do I deal with timezones in my code&quot;: you use a library by people who already put the effort in. Take something like ICU and let that deal with the text. If you need to ask the question, you&#x27;re probably not a programmer with a minor in linguistics so letting the people who do know do the work makes everyone&#x27;s lives a lot easier. Just make sure to read the documentation right.</div><br/></div></div></div></div><div id="36289328" class="c"><input type="checkbox" id="c-36289328" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36289300">parent</a><span>|</span><a href="#36289962">prev</a><span>|</span><a href="#36289239">next</a><span>|</span><label class="collapse" for="c-36289328">[-]</label><label class="expand" for="c-36289328">[1 more]</label></div><br/><div class="children"><div class="content">UTF-16 is the internal encoding of ICU to this day. If you&#x27;re using ICU, you&#x27;re using UTF-16. The library treats UTF-8 as a conversion target rather than a native representation. If you ever see a new project pick UTF-16 and you don&#x27;t know why, it&#x27;s because of ICU; any other choice forces a round trip conversion on every ICU call. If you pick UTF-16 you can just use icu::UnicodeString as your string representation and life is easy.</div><br/></div></div></div></div><div id="36289239" class="c"><input type="checkbox" id="c-36289239" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#36288405">parent</a><span>|</span><a href="#36289300">prev</a><span>|</span><a href="#36288504">next</a><span>|</span><label class="collapse" for="c-36289239">[-]</label><label class="expand" for="c-36289239">[1 more]</label></div><br/><div class="children"><div class="content">In ASCII, the concept of a character is overloaded with many properties. Unicode breaks &quot;character&quot; out to separate concepts like code unit, code point, grapheme cluster, etc.<p>Because of this, some of your statements are invalid. For example, &quot;Along comes unicode which has variable bytes per character. (Yes, even for utf-32, which is why no-one uses utf-32).&quot;.<p>UTF-32 has a fixed number of bytes per code point. It doesn&#x27;t have a fixed number of bytes per grapheme cluster.</div><br/></div></div><div id="36288504" class="c"><input type="checkbox" id="c-36288504" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36288405">parent</a><span>|</span><a href="#36289239">prev</a><span>|</span><a href="#36288712">next</a><span>|</span><label class="collapse" for="c-36288504">[-]</label><label class="expand" for="c-36288504">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I still regularly come across folk who think unicode means 2 bytes per character.<p>To be fair, a lot of programming interfaces with &quot;unicode&quot; in the name were invented when UCS-2 was the only option.</div><br/><div id="36288837" class="c"><input type="checkbox" id="c-36288837" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36288504">parent</a><span>|</span><a href="#36288712">next</a><span>|</span><label class="collapse" for="c-36288837">[-]</label><label class="expand" for="c-36288837">[2 more]</label></div><br/><div class="children"><div class="content">True. And for those of us around who &quot;learned&quot; unicode in the 90s, when unicode was UCS2, it can be hard to let go of those &quot;truths that are no longer true.&quot; This complicates the learning process now.</div><br/><div id="36289077" class="c"><input type="checkbox" id="c-36289077" checked=""/><div class="controls bullet"><span class="by">pastage</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36288837">parent</a><span>|</span><a href="#36288712">next</a><span>|</span><label class="collapse" for="c-36289077">[-]</label><label class="expand" for="c-36289077">[1 more]</label></div><br/><div class="children"><div class="content">From Wikipedia.<p>&gt; In 1996, a surrogate character mechanism was implemented in Unicode 2.0, so that Unicode was no longer restricted to 16 bits. This increased the Unicode codespace to over a million code points,<p>So that seems like a fair analysis. I know we still did latin-1 DBs here into 2005, but I think you had to choose charsets at that point. Everyone knew you should do Unicode but there were so many excusese not to. Unicode still is harder than ascii because of that mindset.</div><br/></div></div></div></div></div></div><div id="36288712" class="c"><input type="checkbox" id="c-36288712" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36288405">parent</a><span>|</span><a href="#36288504">prev</a><span>|</span><a href="#36288996">next</a><span>|</span><label class="collapse" for="c-36288712">[-]</label><label class="expand" for="c-36288712">[2 more]</label></div><br/><div class="children"><div class="content">None of your complaints make any sense. If you limit your usage to ASCII characters, then all of your complaints of Unicode no longer apply. E.g. character length matches your intuition of “number of characters”.</div><br/><div id="36288827" class="c"><input type="checkbox" id="c-36288827" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36288712">parent</a><span>|</span><a href="#36288996">next</a><span>|</span><label class="collapse" for="c-36288827">[-]</label><label class="expand" for="c-36288827">[1 more]</label></div><br/><div class="children"><div class="content">Firstly we live in a world where limiting yourself to ASCII characters is increasingly untenable. There are plenty of non-ascii characters in Spanish or European names.<p>So your argument about limiting to ASCII is like saying its also not a problem if we don&#x27;t use computers. Sure, you&#x27;re right, but it&#x27;s not terribly practical.<p>Plus your argument uses the word Unicode (a mapping) where it only applies to utf-8, (a specific encoding ). This inaccurate use of the terms is the very issue I&#x27;m alluding to.<p>Incidentally I&#x27;m not complaining about Unicode. Unicode is necessary and good. My comment is that (mostly older, but not exclusively) programmers find it hard to grasp the nuances of unicode and think of it as a  encoding, not a mapping.</div><br/></div></div></div></div><div id="36288996" class="c"><input type="checkbox" id="c-36288996" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#36288405">parent</a><span>|</span><a href="#36288712">prev</a><span>|</span><a href="#36288979">next</a><span>|</span><label class="collapse" for="c-36288996">[-]</label><label class="expand" for="c-36288996">[1 more]</label></div><br/><div class="children"><div class="content">Maybe but for people who worked a lot with code pages &#x2F; different ISO encodings unicode brings simplicity that wasn’t there before.</div><br/></div></div><div id="36288979" class="c"><input type="checkbox" id="c-36288979" checked=""/><div class="controls bullet"><span class="by">jesprenj</span><span>|</span><a href="#36288405">parent</a><span>|</span><a href="#36288996">prev</a><span>|</span><a href="#36290268">next</a><span>|</span><label class="collapse" for="c-36288979">[-]</label><label class="expand" for="c-36288979">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why in C you have wchar_t.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wide_character" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wide_character</a></div><br/><div id="36289541" class="c"><input type="checkbox" id="c-36289541" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#36288405">root</a><span>|</span><a href="#36288979">parent</a><span>|</span><a href="#36290268">next</a><span>|</span><label class="collapse" for="c-36289541">[-]</label><label class="expand" for="c-36289541">[1 more]</label></div><br/><div class="children"><div class="content">wchar_t is a massive mistake that came from an era (the &#x27;90s) where people wanted to delude themselves they could keep ASCII-like code ergonomics (iterating, random access, ...) by just changing character types.
It was a stupid mistake we are still paying to this day, when OSes and libraries made in the &#x27;90s are forced to convert from the UCS2 they use internally to UTF-8 constantly (just look at Qt).<p>The cherry on top is also that `wchar_t` is spectacularly broken in C, alongside multichar encoding and everything that&#x27;s not ASCII (<a href="https:&#x2F;&#x2F;thephd.dev&#x2F;cuneicode-and-the-future-of-text-in-c" rel="nofollow noreferrer">https:&#x2F;&#x2F;thephd.dev&#x2F;cuneicode-and-the-future-of-text-in-c</a>).</div><br/></div></div></div></div></div></div><div id="36290268" class="c"><input type="checkbox" id="c-36290268" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#36288405">prev</a><span>|</span><a href="#36288430">next</a><span>|</span><label class="collapse" for="c-36290268">[-]</label><label class="expand" for="c-36290268">[1 more]</label></div><br/><div class="children"><div class="content">One aspect the article is omitting is that UTF-16 and UTF-32 aren’t strictly speaking  encodings, but UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE are. Furthermore, with a 21-bit packed encoding like UTF-21, not only byte-level endianness is relevant, but inner-byte bit-level endianness becomes relevant as well. While the encoding examples given imply a particular endianness, this is something that would have to be specified more explicitly.</div><br/></div></div><div id="36288430" class="c"><input type="checkbox" id="c-36288430" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#36290268">prev</a><span>|</span><a href="#36288439">next</a><span>|</span><label class="collapse" for="c-36288430">[-]</label><label class="expand" for="c-36288430">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Unicode has three official ways of storing these numbers: UTF-8, UTF-16, and UTF-32<p>They are less official, but Unicode defines several other encodings in their technical reports and notes:<p>SCSU: <a href="https:&#x2F;&#x2F;www.unicode.org&#x2F;reports&#x2F;tr6&#x2F;tr6-4.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.unicode.org&#x2F;reports&#x2F;tr6&#x2F;tr6-4.html</a><p>UTF-EBCDIC: <a href="http:&#x2F;&#x2F;www.unicode.org&#x2F;reports&#x2F;tr16&#x2F;tr16-8.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.unicode.org&#x2F;reports&#x2F;tr16&#x2F;tr16-8.html</a><p>CESU-8: <a href="https:&#x2F;&#x2F;www.unicode.org&#x2F;reports&#x2F;tr26&#x2F;tr26-4.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.unicode.org&#x2F;reports&#x2F;tr26&#x2F;tr26-4.html</a><p>BOCU-1: <a href="https:&#x2F;&#x2F;www.unicode.org&#x2F;notes&#x2F;tn6&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.unicode.org&#x2F;notes&#x2F;tn6&#x2F;</a><p>These are all somewhat legacy, having never seen very wide adoption:<p>Compression schemes such as SCSU and BOCU-1 turned out in practice to add a lot of complexity for minimal real-world benefit. If you really need to save storage, then a standard compression algorithm (e.g. deflate or zstd) is usually a better option.<p>CESU-8 is a backward compatibility hack for old UTF-8 implementations which used encoded UTF-16 surrogates for codepoints outside the BMP.<p>UTF-EBCDIC is basically UTF-8 but for EBCDIC. It was invented by someone at IBM, but IBM themselves ended up standardising on UTF-16 instead. And if IBM ended up not using UTF-EBCDIC, who else was going to? Well, there&#x27;s a few surviving non-IBM mainframe vendors who also use EBCDIC (such as Unisys and Fujitsu BS2000), but I&#x27;m not aware any of them ever expressed any interest in it either.</div><br/><div id="36288779" class="c"><input type="checkbox" id="c-36288779" checked=""/><div class="controls bullet"><span class="by">wpietri</span><span>|</span><a href="#36288430">parent</a><span>|</span><a href="#36288439">next</a><span>|</span><label class="collapse" for="c-36288779">[-]</label><label class="expand" for="c-36288779">[1 more]</label></div><br/><div class="children"><div class="content">&gt; UTF-EBCDIC<p>Just reading that made my eyelid twitch.</div><br/></div></div></div></div><div id="36288439" class="c"><input type="checkbox" id="c-36288439" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36288430">prev</a><span>|</span><a href="#36288659">next</a><span>|</span><label class="collapse" for="c-36288439">[-]</label><label class="expand" for="c-36288439">[6 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t see any advantage to UTF-32 when not-officially-standardised UTF-24 has the same constant 3-byte-sized codepoints (and multiplying by 3 is not hard - it&#x27;s n + 2n); in UTF-32, the highest byte will <i>never</i> be anything other than 0, so it&#x27;s essentially permanent waste.<p>Also, according to <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_Unicode_characters" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_Unicode_characters</a> there&#x27;s currently less than 150k codepoints defined, so even 21 bits is several times larger than necessary --- 18 bits will contain all the currently assigned codepoints, and be sufficient until 256k codepoints is reached.<p>Incidentally, 18-bit architectures were once common: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;18-bit_computing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;18-bit_computing</a></div><br/><div id="36290301" class="c"><input type="checkbox" id="c-36290301" checked=""/><div class="controls bullet"><span class="by">dukoid</span><span>|</span><a href="#36288439">parent</a><span>|</span><a href="#36288714">next</a><span>|</span><label class="collapse" for="c-36290301">[-]</label><label class="expand" for="c-36290301">[1 more]</label></div><br/><div class="children"><div class="content">&quot;640K ought to be enough for anybody.&quot; -- Bill Gates</div><br/></div></div><div id="36288714" class="c"><input type="checkbox" id="c-36288714" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#36288439">parent</a><span>|</span><a href="#36290301">prev</a><span>|</span><a href="#36289114">next</a><span>|</span><label class="collapse" for="c-36288714">[-]</label><label class="expand" for="c-36288714">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I really don&#x27;t see any advantage to UTF-32 when not-officially-standardised UTF-24 has the same constant 3-byte-sized codepoints (and multiplying by 3 is not hard - it&#x27;s n + 2n); in UTF-32, the highest byte will never be anything other than 0, so it&#x27;s essentially permanent waste.<p>Wouldn’t the difference in alignment (4 byte versus 3 bytes) make UTF-32 faster than UTF-24 in certain cases, on certain CPU architectures? So the always zero byte would be wasting space to gain greater performance.</div><br/></div></div><div id="36289114" class="c"><input type="checkbox" id="c-36289114" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#36288439">parent</a><span>|</span><a href="#36288714">prev</a><span>|</span><a href="#36288702">next</a><span>|</span><label class="collapse" for="c-36289114">[-]</label><label class="expand" for="c-36289114">[1 more]</label></div><br/><div class="children"><div class="content">UTF-32 is easy to understand for educational purposes but it&#x27;s probably a mistake to use it as a real string representation, and almost nobody does. Code units and code points are the same thing in UTF-32 but they&#x27;re different in UTF-16 and UTF-8; you can teach someone UTF-32 before they understand the distinction. Obviously, UTF-24 isn&#x27;t used because it isn&#x27;t a standard encoding, and if you really wanted to save memory, you&#x27;d use UTF-8 instead which is even more compact yet.<p>As for UTF-16, today the only reason people choose UTF-16 for new projects is because it&#x27;s the native internal encoding of the ICU library. If you&#x27;re not using ICU, it&#x27;s pretty hard to defend anything but UTF-8.</div><br/></div></div><div id="36288702" class="c"><input type="checkbox" id="c-36288702" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#36288439">parent</a><span>|</span><a href="#36289114">prev</a><span>|</span><a href="#36289171">next</a><span>|</span><label class="collapse" for="c-36288702">[-]</label><label class="expand" for="c-36288702">[1 more]</label></div><br/><div class="children"><div class="content">To fit all currently assigned code points within 18 bits is  easy: you would only have to move one range.
Above 32FFF, all assigned code points are within E0000 to E01EF, which fits in-between 32FFF to 3FFFF with room to spare.<p>Those code points are used for flag emojis and for selecting uncommon CJK variants. If you don&#x27;t support those, you could just strip out anything that doesn&#x27;t fit in 18 bits to begin with.</div><br/></div></div><div id="36289171" class="c"><input type="checkbox" id="c-36289171" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36288439">parent</a><span>|</span><a href="#36288702">prev</a><span>|</span><a href="#36288659">next</a><span>|</span><label class="collapse" for="c-36289171">[-]</label><label class="expand" for="c-36289171">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d have to abandon the two private use planes to use 18 bits, which would be a notable limitation.</div><br/></div></div></div></div><div id="36288659" class="c"><input type="checkbox" id="c-36288659" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#36288439">prev</a><span>|</span><a href="#36289301">next</a><span>|</span><label class="collapse" for="c-36288659">[-]</label><label class="expand" for="c-36288659">[2 more]</label></div><br/><div class="children"><div class="content">Shameless plug: I came up with UTF-21 for my esoteric programming language, Funciton (<a href="https:&#x2F;&#x2F;esolangs.org&#x2F;wiki&#x2F;Funciton" rel="nofollow noreferrer">https:&#x2F;&#x2F;esolangs.org&#x2F;wiki&#x2F;Funciton</a>), back in 2011.</div><br/><div id="36289018" class="c"><input type="checkbox" id="c-36289018" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#36288659">parent</a><span>|</span><a href="#36289301">next</a><span>|</span><label class="collapse" for="c-36289018">[-]</label><label class="expand" for="c-36289018">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny: for all I knew when reading the post, UTF-21 was something I&#x27;d never seen before. But when I saw your comment, I remembered that I must have been quite aware of it back in 2015, when I golfed a Funciton Hello World program [0]. Seven years is a long time for such a silly thing to circle around again.<p>[0] <a href="https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;a&#x2F;55777" rel="nofollow noreferrer">https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;a&#x2F;55777</a></div><br/></div></div></div></div><div id="36289301" class="c"><input type="checkbox" id="c-36289301" checked=""/><div class="controls bullet"><span class="by">hlandau</span><span>|</span><a href="#36288659">prev</a><span>|</span><a href="#36289119">next</a><span>|</span><label class="collapse" for="c-36289301">[-]</label><label class="expand" for="c-36289301">[4 more]</label></div><br/><div class="children"><div class="content">The Unicode space used to be 31-bit. UTF-8 defined 5 and 6-byte encoding sequences for this reason. When UCS-2 had to be extended to create UTF-16, the solution chosen effectively limited things to a 21-bit space. Unicode was then redefined to be 21-bit, and the 5 and 6-byte encodings of UTF-8 were removed from the standard, though old systems might still accept them.<p>It is worth noting that if we ever run out of space in 21-bit Unicode, one could conceivably re-extend it back to the original 31 bits by throwing UTF-16 under the bus. The only reason Unicode is limited to 21 bits is because of UTF-16.</div><br/><div id="36290332" class="c"><input type="checkbox" id="c-36290332" checked=""/><div class="controls bullet"><span class="by">unflxw</span><span>|</span><a href="#36289301">parent</a><span>|</span><a href="#36289342">next</a><span>|</span><label class="collapse" for="c-36290332">[-]</label><label class="expand" for="c-36290332">[1 more]</label></div><br/><div class="children"><div class="content">By throwing UTF-16 under the bus, or by extending it, in the same way that UCS-2 was created by extending UTF-16.<p>Just like a number of UCS-2-representable codepoints in the basic plane were given up, in order to allow that number squared of non-UCS-2-representable codepoints to be representable in UTF-16, a number of UTF-16-representable codepoints in a supplemental plane could be given up, in order to allow N^2 non-UTF-16-representable codepoints in not-yet-existing supplemental planes to be representable in UTF-16-but-worse.<p>Yes, I&#x27;m talking about putting surrogates in the surrogates.</div><br/></div></div><div id="36289342" class="c"><input type="checkbox" id="c-36289342" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#36289301">parent</a><span>|</span><a href="#36290332">prev</a><span>|</span><a href="#36289119">next</a><span>|</span><label class="collapse" for="c-36289342">[-]</label><label class="expand" for="c-36289342">[2 more]</label></div><br/><div class="children"><div class="content">But JS is UTF-16 native. Would it even be feasible to migrate?</div><br/><div id="36290281" class="c"><input type="checkbox" id="c-36290281" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#36289301">root</a><span>|</span><a href="#36289342">parent</a><span>|</span><a href="#36289119">next</a><span>|</span><label class="collapse" for="c-36290281">[-]</label><label class="expand" for="c-36290281">[1 more]</label></div><br/><div class="children"><div class="content">&quot;UTF-16 native&quot; doesn&#x27;t mean your &quot;UTF-16 unit&quot; (i.e. what would `charCodeAt` return) should not exceed 16 bits. JS implementations already do not use UTF-16 as a sole native representation anyway, so the migration should be relatively easy.</div><br/></div></div></div></div></div></div><div id="36289119" class="c"><input type="checkbox" id="c-36289119" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36289301">prev</a><span>|</span><a href="#36288773">next</a><span>|</span><label class="collapse" for="c-36289119">[-]</label><label class="expand" for="c-36289119">[1 more]</label></div><br/><div class="children"><div class="content">I feel like the obvious 21 bit encoding is to pack 3 codepoints into 8 bytes.<p>But uh I guess this works.<p>If you want to do something more in depth and make real decisions about encoding, a good space to explore is 1-3 byte variable width encodings.  You have lots of different tradeoffs to consider and you can make something surprisingly good.</div><br/></div></div><div id="36288773" class="c"><input type="checkbox" id="c-36288773" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36289119">prev</a><span>|</span><a href="#36289215">next</a><span>|</span><label class="collapse" for="c-36288773">[-]</label><label class="expand" for="c-36288773">[3 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, is there a more compact alternative to Unicode that excludes all precomposed chars like ñ, but also for all the Asian languages, so you&#x27;d basically have some set of &quot;strokes&quot; that can compose anything else? And if you need to add semantic meaning to identically looking results, that would be another non-visual composable indicator</div><br/><div id="36290293" class="c"><input type="checkbox" id="c-36290293" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#36288773">parent</a><span>|</span><a href="#36289418">next</a><span>|</span><label class="collapse" for="c-36290293">[-]</label><label class="expand" for="c-36290293">[1 more]</label></div><br/><div class="children"><div class="content">If you know exactly what text you&#x27;re going to render, you can create your own font, relocate all the characters, and fit everything very compactly into UTF-8. You&#x27;ll need to convert external input to your encoding scheme, but it can save a lot of bytes for some corpuses.<p>If you try to standardise against &quot;what things look like&quot;, you&#x27;ll inevitable run into trouble like the famous Turkic I (I (Iı) vs İ (İi) vs I (Ii) where &quot;İ&quot;.toLower().toUpper() != &quot;İ&quot;).<p>Sure, this means characters like é can theoretically be stored as either 0xE9 or 0xC3A9, but if you can pick what encoding you use, you can also optimise for the smallest length.</div><br/></div></div><div id="36289418" class="c"><input type="checkbox" id="c-36289418" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36288773">parent</a><span>|</span><a href="#36290293">prev</a><span>|</span><a href="#36289215">next</a><span>|</span><label class="collapse" for="c-36289418">[-]</label><label class="expand" for="c-36289418">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s your definition of &quot;compact&quot; here?<p>And there&#x27;s a lot of ways to put together a character, so I worry you&#x27;d end up with something closer to a vector format than a normal character encoding.</div><br/></div></div></div></div><div id="36289215" class="c"><input type="checkbox" id="c-36289215" checked=""/><div class="controls bullet"><span class="by">ttflee</span><span>|</span><a href="#36288773">prev</a><span>|</span><a href="#36288321">next</a><span>|</span><label class="collapse" for="c-36289215">[-]</label><label class="expand" for="c-36289215">[2 more]</label></div><br/><div class="children"><div class="content">Now for an encoding in real life:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;UTF-7" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;UTF-7</a></div><br/><div id="36290368" class="c"><input type="checkbox" id="c-36290368" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#36289215">parent</a><span>|</span><a href="#36288321">next</a><span>|</span><label class="collapse" for="c-36290368">[-]</label><label class="expand" for="c-36290368">[1 more]</label></div><br/><div class="children"><div class="content">With UTF-7 being a requirement for certain (outdated) email protocols and programs intentionally sabotaging their UTF-7 code paths (most importantly .NET 5), UTF-7 will remain relevant for anyone dealing with email software for a while. UTF-7 is just one of the many ways in which email can screw you over.<p>SMTP can&#x27;t reliably handle UTF-8 so your options quickly devolve into base64 encoding messages or falling back to UTF-7 encoding. Base64 is a lot more wasteful than the alternative, as cursed as UTF-7 may be. For full interoperability, some mail servers even require you to be able to deal with UTF-7 wrapped inside another transcoding format!</div><br/></div></div></div></div><div id="36288321" class="c"><input type="checkbox" id="c-36288321" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#36289215">prev</a><span>|</span><a href="#36288237">next</a><span>|</span><label class="collapse" for="c-36288321">[-]</label><label class="expand" for="c-36288321">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d appreciate an analysis of how it compresses! The encoding looks highly compressible, so I&#x27;d expect it to be competitive with UTF-8 for English text, and seems like it would beat it for East Asian languages.</div><br/><div id="36288423" class="c"><input type="checkbox" id="c-36288423" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#36288321">parent</a><span>|</span><a href="#36288237">next</a><span>|</span><label class="collapse" for="c-36288423">[-]</label><label class="expand" for="c-36288423">[5 more]</label></div><br/><div class="children"><div class="content">At first glance I&#x27;d suggest it doesn&#x27;t compress at all. Especially if the compression uses bytes.<p>Bit-streams of characters of non-bytes length become randomish when viewed as bytes, and random bytes contain no redundancy and can&#x27;t be compressed.</div><br/><div id="36288560" class="c"><input type="checkbox" id="c-36288560" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#36288321">root</a><span>|</span><a href="#36288423">parent</a><span>|</span><a href="#36288237">next</a><span>|</span><label class="collapse" for="c-36288560">[-]</label><label class="expand" for="c-36288560">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Especially if the compression uses bytes<p>Arithmetic compression can use whatever, even fractional bits, and it&#x27;s been around since the seventies.</div><br/><div id="36289205" class="c"><input type="checkbox" id="c-36289205" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36288321">root</a><span>|</span><a href="#36288560">parent</a><span>|</span><a href="#36289046">next</a><span>|</span><label class="collapse" for="c-36289205">[-]</label><label class="expand" for="c-36289205">[1 more]</label></div><br/><div class="children"><div class="content">Arithmetic coding goes one token&#x2F;symbol at a time, just like most kinds of compression.  The fractional bits come after token selection, and aren&#x27;t really relevant here.<p>You can split the input into tokens that aren&#x27;t a multiple of 8 bits, sure.  But that&#x27;s its own decision.  7 or 21 or whatever bit tokens could be fed into a huffman tree just as easily.</div><br/></div></div><div id="36289046" class="c"><input type="checkbox" id="c-36289046" checked=""/><div class="controls bullet"><span class="by">temac</span><span>|</span><a href="#36288321">root</a><span>|</span><a href="#36288560">parent</a><span>|</span><a href="#36289205">prev</a><span>|</span><a href="#36288684">next</a><span>|</span><label class="collapse" for="c-36289046">[-]</label><label class="expand" for="c-36289046">[1 more]</label></div><br/><div class="children"><div class="content">Arithmetic compression uses whatever on the output. Of course you can retokenize weird input but you can usually do so for any algo if you can modify it. But UTF21 can not have a substantial advantage if you compress. It will usually be worse.</div><br/></div></div><div id="36288684" class="c"><input type="checkbox" id="c-36288684" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#36288321">root</a><span>|</span><a href="#36288560">parent</a><span>|</span><a href="#36289046">prev</a><span>|</span><a href="#36288237">next</a><span>|</span><label class="collapse" for="c-36288684">[-]</label><label class="expand" for="c-36288684">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but if you run a normal compression algorithm like gz, rar or 7z on it, it&#x27;s still going to use bytes.</div><br/></div></div></div></div></div></div></div></div><div id="36288237" class="c"><input type="checkbox" id="c-36288237" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#36288321">prev</a><span>|</span><label class="collapse" for="c-36288237">[-]</label><label class="expand" for="c-36288237">[3 more]</label></div><br/><div class="children"><div class="content">If you exclude surrogates, I think you can fit the rest of the codepoints in 20 bits.  There would be no need for surrogates all Unicode scalars are representable elseways.  Looks like an easy size win.</div><br/><div id="36288873" class="c"><input type="checkbox" id="c-36288873" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#36288237">parent</a><span>|</span><label class="collapse" for="c-36288873">[-]</label><label class="expand" for="c-36288873">[2 more]</label></div><br/><div class="children"><div class="content">This is not true; the number of Unicode scalar values excluding surrogates is 17*2^16 - 2^11 = 1,112,064, which is larger than 2^20 = 1,048,576.</div><br/><div id="36289287" class="c"><input type="checkbox" id="c-36289287" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#36288237">root</a><span>|</span><a href="#36288873">parent</a><span>|</span><label class="collapse" for="c-36289287">[-]</label><label class="expand" for="c-36289287">[1 more]</label></div><br/><div class="children"><div class="content">In particular, UTF-16 surrogates use 2048 code points in the basic multilingual plane (BMP), but surrogates allow another 2^20 code points to be encodable in addition to the non-surrogate 65536−2048 code points of the BMP.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>