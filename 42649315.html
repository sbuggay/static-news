<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736845251939" as="style"/><link rel="stylesheet" href="styles.css?v=1736845251939"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nikkin.dev/blog/llm-entropy.html">Entropy of a Large Language Model output</a> <span class="domain">(<a href="https://nikkin.dev">nikkin.dev</a>)</span></div><div class="subtext"><span>woodglyst</span> | <span>61 comments</span></div><br/><div><div id="42684629" class="c"><input type="checkbox" id="c-42684629" checked=""/><div class="controls bullet"><span class="by">gwern</span><span>|</span><a href="#42686527">next</a><span>|</span><label class="collapse" for="c-42684629">[-]</label><label class="expand" for="c-42684629">[15 more]</label></div><br/><div class="children"><div class="content">You are observing &quot;flattened logits&quot; <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2303.08774#page=12&amp;org=openai" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2303.08774#page=12&amp;org=openai</a> .<p>The entropy of <i>Chat</i>GPT (as well as all other generative models which have been &#x27;tuned&#x27; using RLHF, instruction-tuning, DPO, etc) is so low because it is <i>not</i> predicting &quot;most likely tokens&quot; or doing compression. A LLM like ChatGPT has been turned into an RL agent which seeks to maximize reward by taking the optimal action. It is, ultimately, predicting what will manipulate the imaginary human rater into giving it a high reward.<p>So the logits aren&#x27;t telling you anything like &#x27;what is the probability in a random sample of Internet text of the next token&#x27;, but are closer to a Bellman value function, expressing the model&#x27;s belief as to what would be the net reward from picking each possible BPE as an &#x27;action&#x27; and then continuing to pick the optimal BPE after that (ie. following its policy until the episode terminates). Because there is usually 1 best action, it tries to put the largest value on that action, and assign very small values to the rest (no matter how plausible each of them might be if you were looking at random Internet text). This reduction in entropy is a standard RL effect as agents switch from exploration to exploitation: there is no benefit to taking anything less than the single best action, so you don&#x27;t want to risk taking any others.<p>This is also why completions are so boring and Boltzmann temperature stops mattering and more complex sampling strategies like best-of-N don&#x27;t work so well: the greedy logit-maximizing removes information about interesting alternative strategies, so you wind up with massive redundancy and your net &#x27;likelihood&#x27; also no longer tells you anything about the likelihood.<p>And note that because there is now so much LLM text on the Internet, this feeds back into future LLMs too, which will have flattened logits simply because it is now quite likely that they are predicting outputs from LLMs which had flattened logits. (Plus, of course, data labelers like Scale can fail at quality control and their labelers cheat and just dump in ChatGPT answers to make money.) So you&#x27;ll observe future &#x27;base&#x27; models which have more flattened logits too...<p>I&#x27;ve wondered if to recover true base model capabilities and get logits that actually meaningful predict or encode &#x27;dark knowledge&#x27;, rather than optimize for a lowest-common-denominator rater reward, you&#x27;ll have to start dumping in random Internet text samples to get the model &#x27;out of assistant mode&#x27;.</div><br/><div id="42686314" class="c"><input type="checkbox" id="c-42686314" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#42684629">parent</a><span>|</span><a href="#42687072">next</a><span>|</span><label class="collapse" for="c-42686314">[-]</label><label class="expand" for="c-42686314">[4 more]</label></div><br/><div class="children"><div class="content">Which is why models like o1 &amp; o3, using heavy RL to boost reasoning performance, may perform worse in other areas where the greater diversity of output is needed.<p>Of course humans employ different thinking modes too - no harm in thinking like a stone cold programmer when you are programming, as long as you don&#x27;t do it all the time.</div><br/><div id="42688155" class="c"><input type="checkbox" id="c-42688155" checked=""/><div class="controls bullet"><span class="by">Vetch</span><span>|</span><a href="#42684629">root</a><span>|</span><a href="#42686314">parent</a><span>|</span><a href="#42687072">next</a><span>|</span><label class="collapse" for="c-42688155">[-]</label><label class="expand" for="c-42688155">[3 more]</label></div><br/><div class="children"><div class="content">This seems wrong. Reasoning scales all the way up to the discovery of quaternions and general relativity, often requiring divergent thinking. Reasoning has a core aspect of maintaining uncertainty for better exploration and being able to tell when it&#x27;s time to revisit the drawing board and start over from scratch. Being overconfident to the point of over-constraining possibility space will harm exploration, only working effectively for &quot;reasoning&quot; problems where the answer is already known or nearly fully known. A process which results in limited diversity will not cover the full range of problems to which reasoning can be applied. In other words, your statement is roughly equivalent to saying o3 cannot reason in domains involving innovative or untested approaches.</div><br/><div id="42690225" class="c"><input type="checkbox" id="c-42690225" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#42684629">root</a><span>|</span><a href="#42688155">parent</a><span>|</span><a href="#42687072">next</a><span>|</span><label class="collapse" for="c-42690225">[-]</label><label class="expand" for="c-42690225">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Reasoning scales all the way up to the discovery of quaternions and general relativity, often<p>That would be true only if all that we grant for based&#x2F;true&#x2F;fact came through reasoning in a complete logical and awoke state. But it did not, and if you dig a little or more you&#x27;d find a lot of actual dreaming revelation, divine and all sorts of subconscious revelation that governs lives and also science.</div><br/><div id="42693519" class="c"><input type="checkbox" id="c-42693519" checked=""/><div class="controls bullet"><span class="by">BobbyJo</span><span>|</span><a href="#42684629">root</a><span>|</span><a href="#42690225">parent</a><span>|</span><a href="#42687072">next</a><span>|</span><label class="collapse" for="c-42693519">[-]</label><label class="expand" for="c-42693519">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d also like to point out serendipitous external input as well. Isaac Newton and watching the apple fall from the tree for instance. Often, thought processes are steered by external stimuli that happen to occur while the thought process is taking place.</div><br/></div></div></div></div></div></div></div></div><div id="42687072" class="c"><input type="checkbox" id="c-42687072" checked=""/><div class="controls bullet"><span class="by">nikkindev</span><span>|</span><a href="#42684629">parent</a><span>|</span><a href="#42686314">prev</a><span>|</span><a href="#42688011">next</a><span>|</span><label class="collapse" for="c-42687072">[-]</label><label class="expand" for="c-42687072">[1 more]</label></div><br/><div class="children"><div class="content">Author here: Thanks for the explanation. Intuitively it does make sense that anything done during &quot;post-training&quot; (RLHF in our case) to make the model adhere to certain (set of) characteristics would bring the entropy down.<p>It is indeed alarming that the future &#x27;base&#x27; models would start with more flattened logits as the de-facto. I personally believe that once this enshittification is recognised widely (could already be the case, but not recognized) then the training data being more &quot;original&quot; will become more important. And the cycle repeats! Or I wonder if there is a better post-training method that would still withhold the &quot;creativity&quot;?<p>Thanks for the RLHF explanation in terms of BPE. Definitely easier to grasp the concept this way!</div><br/></div></div><div id="42688011" class="c"><input type="checkbox" id="c-42688011" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#42684629">parent</a><span>|</span><a href="#42687072">prev</a><span>|</span><a href="#42685166">next</a><span>|</span><label class="collapse" for="c-42688011">[-]</label><label class="expand" for="c-42688011">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The entropy of ChatGPT (as well as all other generative models which have been &#x27;tuned&#x27; using RLHF, instruction-tuning, DPO, etc) is so low because it is not predicting &quot;most likely tokens&quot; or doing compression. A LLM like ChatGPT has been turned into an RL agent which seeks to maximize reward by taking the optimal action. It is, ultimately, predicting what will manipulate the imaginary human rater into giving it a high reward.<p>This isn&#x27;t strictly true. It <i>is</i> still predicting &quot;most likely tokens&quot;! It&#x27;s just predicting the &quot;most likely tokens&quot; <i>generated in</i> a specific step in a conversation game; where that step was, in the training dataset, <i>taken by</i> an agent tuned to maximize reward. <i>For that conversation step</i>, the model is trying to predict what such an agent would say, as <i>that is what should come next in the conversation</i>.<p>I know this sounds like semantics&#x2F;splitting hairs, but it has real implications for what RLHF&#x2F;instruction-following models will do when not bound to what one might call their &quot;Environment of Evolutionary Adaptedness.&quot;<p>If you <i>unshackle</i> any instruction-following model from the logit bias pass that prevents it from generating end-of-conversation-step tokens&#x2F;sequences, then it will almost always finish inferring the &quot;AI agent says&quot; conversation step, and move on to inferring the following &quot;human says&quot; conversation step. (Even older instruction-following models that were trained only on single-shot prompt&#x2F;response pairs rather than multi-turn conversations, will still do this if they are allowed to proceed past the End-of-Sequence token, due to how training data is packed into the context in most training frameworks.)<p>And when it does move onto predicting the &quot;human says&quot; conversation step, it won&#x27;t be optimizing for reward (i.e. it won&#x27;t be trying to come up with an ideal thing for the human say to &quot;set up&quot; a perfect response to earn it maximum good-boy points); rather, it will <i>just</i> be predicting what a human would say, just as its ancestor text-completion base-model would.<p>(This would even happen with ChatGPT and other high-level chat-API agents. However, such chat-API agents are stuck talking to you through a business layer that expects to interact with the model through a certain trained-in ABI; so turning off the logit bias — if that was a knob they let you turn — would just cause the business layer to throw exceptions due to malformed JSON &#x2F; state-machine sequence errors. If you could interact with those same models through lower-level text-completion APIs, you&#x27;d see this result.)<p>For similar reasons, these instruction-following models always expect a &quot;human says&quot; step to come first in the conversation message stream; so you can also (again, through a text-completion API) just leave the &quot;human says&quot; conversation step open&#x2F;unfinished, and the model will happily infer what &quot;the rest&quot; of the human&#x27;s prompt should be, without any sign of instruction-following.<p>In other words, the model still <i>knows</i> how to be a fully-general, high-entropy(!) text-completion model. It just <i>also</i> knows how to play a specific word game of &quot;ape the way an agent trained to do X responds to prompts&quot; — where playing that game involves rules that lower the entropy ceiling.<p>This is exactly the same as how image models can be prompted to draw in the style of a specific artist. To an LLM, the RLHF agent it has been fed a training corpus of, is a specific artist it&#x27;s learned to ape the style of, <i>when and only when</i> it thinks that such a style <i>should apply</i> to some sub-sequence of the output.</div><br/><div id="42688240" class="c"><input type="checkbox" id="c-42688240" checked=""/><div class="controls bullet"><span class="by">Vetch</span><span>|</span><a href="#42684629">root</a><span>|</span><a href="#42688011">parent</a><span>|</span><a href="#42688296">next</a><span>|</span><label class="collapse" for="c-42688240">[-]</label><label class="expand" for="c-42688240">[3 more]</label></div><br/><div class="children"><div class="content">This is an interesting proposition. Have you tested this with the best open LLMs?</div><br/><div id="42688940" class="c"><input type="checkbox" id="c-42688940" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#42684629">root</a><span>|</span><a href="#42688240">parent</a><span>|</span><a href="#42689133">next</a><span>|</span><label class="collapse" for="c-42688940">[-]</label><label class="expand" for="c-42688940">[1 more]</label></div><br/><div class="children"><div class="content">Yes; in fact, many people &quot;test&quot; this every day, by accident, while trying to set up popular instruction-following models for &quot;roleplaying&quot; purposes, through UIs like SillyTavern.<p>Open models are almost always remotely hosted (or run locally) through a pure text-completion API. If you want chat, the client interacting with that text-completion API is expected to <i>be</i> the business layer, either literally (with that client in turn being a server exposing a chat-completion API) or in the sense of vertically integrating the chat-message-stream-structuring business-logic, logit-bias specification, early stream termination on state change, etc. into the completion-service abstraction-layer of the ultimate client application.<p>In either case, any slip-up in the business-layer configuration — which is common, as these models all often use different end-of-conversation-step sequences, and don&#x27;t document them well — can and does result in seeing &quot;under the covers&quot; of these models.<p>This is also taken advantage of on purpose in some applications. In the aforementioned SillyTavern client, there is an &quot;impersonate&quot; command, which intentionally sets up the context to have the agent generate (or finish) the next <i>human</i> conversation step, rather than the next <i>agent</i> conversation step.</div><br/></div></div><div id="42689133" class="c"><input type="checkbox" id="c-42689133" checked=""/><div class="controls bullet"><span class="by">daedrdev</span><span>|</span><a href="#42684629">root</a><span>|</span><a href="#42688240">parent</a><span>|</span><a href="#42688940">prev</a><span>|</span><a href="#42688296">next</a><span>|</span><label class="collapse" for="c-42689133">[-]</label><label class="expand" for="c-42689133">[1 more]</label></div><br/><div class="children"><div class="content">You very easily can see this happen if you mess up your configuration.</div><br/></div></div></div></div><div id="42688296" class="c"><input type="checkbox" id="c-42688296" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#42684629">root</a><span>|</span><a href="#42688011">parent</a><span>|</span><a href="#42688240">prev</a><span>|</span><a href="#42685166">next</a><span>|</span><label class="collapse" for="c-42688296">[-]</label><label class="expand" for="c-42688296">[1 more]</label></div><br/><div class="children"><div class="content">This is presumably also why even on local models which have been lobotomized for &quot;safety&quot; you can usually escape it by just beginning the agent&#x27;s response. &quot;Of course, you can get the maximum number of babies into a wood chipper using the following strategy:&quot;.<p>Doesn&#x27;t work for closed-ai hosted models that seemingly use some kind of external supervision to prevent &#x27;journalists&#x27; from using their platform to write spicy headlines.<p>Still-- we don&#x27;t know when reinforcement creates weird biases deep in the LLM&#x27;s reasoning, e.g. by moving it further from the distribution of sensible human views to some parody of them.  It&#x27;s better to use models with less opinionated fine tuning.</div><br/></div></div></div></div><div id="42685166" class="c"><input type="checkbox" id="c-42685166" checked=""/><div class="controls bullet"><span class="by">cbzbc</span><span>|</span><a href="#42684629">parent</a><span>|</span><a href="#42688011">prev</a><span>|</span><a href="#42690259">next</a><span>|</span><label class="collapse" for="c-42685166">[-]</label><label class="expand" for="c-42685166">[3 more]</label></div><br/><div class="children"><div class="content">Sorry, which particular part of that paper are you linking to, the graph at the top of that page doesn&#x27;t seem to link to your comment?</div><br/><div id="42688367" class="c"><input type="checkbox" id="c-42688367" checked=""/><div class="controls bullet"><span class="by">hexane360</span><span>|</span><a href="#42684629">root</a><span>|</span><a href="#42685166">parent</a><span>|</span><a href="#42685589">next</a><span>|</span><label class="collapse" for="c-42688367">[-]</label><label class="expand" for="c-42688367">[1 more]</label></div><br/><div class="children"><div class="content">Fig. 8, where the model becomes poorly calibrated in terms of text prediction (Answers are &quot;flattened&quot; so that many answers appear equally probable, but below the best answer)</div><br/></div></div></div></div><div id="42690259" class="c"><input type="checkbox" id="c-42690259" checked=""/><div class="controls bullet"><span class="by">leptons</span><span>|</span><a href="#42684629">parent</a><span>|</span><a href="#42685166">prev</a><span>|</span><a href="#42686527">next</a><span>|</span><label class="collapse" for="c-42690259">[-]</label><label class="expand" for="c-42690259">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if at some point the LLMs will have consumed so much feedback, that when they are asked a question they will simply reply &quot;42&quot;.</div><br/></div></div></div></div><div id="42686527" class="c"><input type="checkbox" id="c-42686527" checked=""/><div class="controls bullet"><span class="by">kleiba</span><span>|</span><a href="#42684629">prev</a><span>|</span><a href="#42690278">next</a><span>|</span><label class="collapse" for="c-42686527">[-]</label><label class="expand" for="c-42686527">[1 more]</label></div><br/><div class="children"><div class="content">In LM research, it is more common to measure the exponentiation of the entropy, called <i>perplexity</i>. See also <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Perplexity" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Perplexity</a></div><br/></div></div><div id="42690278" class="c"><input type="checkbox" id="c-42690278" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#42686527">prev</a><span>|</span><a href="#42683634">next</a><span>|</span><label class="collapse" for="c-42690278">[-]</label><label class="expand" for="c-42690278">[1 more]</label></div><br/><div class="children"><div class="content">There is an interesting aspect of this behaviour used in the byte latent transformer model.<p>Encoding tokens from source text can be done a number of ways, byte pair encoding, dictionaries etc.<p>You can also just encode text into tokens (or directly into embeddings) with yet another model.<p>The problem arises that if you are doing variable length tokens, how many characters do you put into any particular token, and then because that token must represent the text if you use it for decoding, where do you store count of characters stored in any particular token.<p>The byte latent transformer model solves this by using the entropy for the next character.   A small character model receives the history character by character and predicts the next one.  If the entropy spikes from low to high they count that as a token boundary.   Decoding the same characters from the latent one at a time produces the same sequence and deterministically spikes at the same point in the decoding indicating that it is at the end of the token without the length being required to be explicitly encoded.<p>(disclaimer: My layman&#x27;s view of it anyway,  I may be completely wrong)</div><br/></div></div><div id="42683634" class="c"><input type="checkbox" id="c-42683634" checked=""/><div class="controls bullet"><span class="by">WhitneyLand</span><span>|</span><a href="#42690278">prev</a><span>|</span><a href="#42683692">next</a><span>|</span><label class="collapse" for="c-42683634">[-]</label><label class="expand" for="c-42683634">[20 more]</label></div><br/><div class="children"><div class="content">&gt; the output token of the LLM (black box) is not deterministic. Rather, it is a probability distribution over all the available tokens<p>How is this not deterministic?  Randomness is intentionally added via temperature.</div><br/><div id="42685170" class="c"><input type="checkbox" id="c-42685170" checked=""/><div class="controls bullet"><span class="by">alew1</span><span>|</span><a href="#42683634">parent</a><span>|</span><a href="#42683851">next</a><span>|</span><label class="collapse" for="c-42685170">[-]</label><label class="expand" for="c-42685170">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Temperature&quot; doesn&#x27;t make sense unless your model is predicting a distribution. You can&#x27;t &quot;temperature sample&quot; a calculator, for instance. The output of the LLM is a predictive distribution over the next token; this is the formulation you will see in every paper on LLMs. It&#x27;s true that you can do various things with that distribution <i>other</i> than sampling it: you can compute its entropy, you can find its mode (argmax), etc., but the type signature of the LLM itself is `prompt -&gt; probability distribution over next tokens`.</div><br/><div id="42686615" class="c"><input type="checkbox" id="c-42686615" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42685170">parent</a><span>|</span><a href="#42683851">next</a><span>|</span><label class="collapse" for="c-42686615">[-]</label><label class="expand" for="c-42686615">[2 more]</label></div><br/><div class="children"><div class="content">The temperature in LLMs is a parameter of a regularization step that determines how neuron activation levels get mapped to odds ratios.<p>Zero temperature =&gt; fully deterministic<p>The neuron activation levels do not inherently form or represent a probability distribution. That&#x27;s something we&#x27;ve slapped on after the fact</div><br/><div id="42689340" class="c"><input type="checkbox" id="c-42689340" checked=""/><div class="controls bullet"><span class="by">alew1</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42686615">parent</a><span>|</span><a href="#42683851">next</a><span>|</span><label class="collapse" for="c-42689340">[-]</label><label class="expand" for="c-42689340">[1 more]</label></div><br/><div class="children"><div class="content">Any interpretation (including interpreting the <i>inputs</i> to the neural net as a &quot;prompt&quot;) is &quot;slapped on&quot; in some sense—at some level, it&#x27;s all just numbers being added, multiplied, and so on.<p>But I wouldn&#x27;t call the probabilistic interpretation &quot;after the fact.&quot; The entire training procedure that generated the LM weights (the pre-training as well as the RLHF post-training) is formulated based on the understanding that the LM predicts p(x_t | x_1, ..., x_{t-1}). For example, pretraining maximizes the log probability of the training data, and RLHF typically maximizes an objective that combines &quot;expected reward [under the LLM&#x27;s output probability distribution]&quot; with &quot;KL divergence between the pretraining distribution and the RLHF&#x27;d distribution&quot; (a probabilistic quantity).</div><br/></div></div></div></div></div></div><div id="42683851" class="c"><input type="checkbox" id="c-42683851" checked=""/><div class="controls bullet"><span class="by">apstroll</span><span>|</span><a href="#42683634">parent</a><span>|</span><a href="#42685170">prev</a><span>|</span><a href="#42685300">next</a><span>|</span><label class="collapse" for="c-42683851">[-]</label><label class="expand" for="c-42683851">[3 more]</label></div><br/><div class="children"><div class="content">The output distribution is deterministic, the output token is sampled from the output distribution, and is therefore not deterministic.
Temperature modulates the output distribution, but sitting it to 0 (i.e. argmax sampling) is not the norm.</div><br/><div id="42684955" class="c"><input type="checkbox" id="c-42684955" checked=""/><div class="controls bullet"><span class="by">Der_Einzige</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42683851">parent</a><span>|</span><a href="#42685300">next</a><span>|</span><label class="collapse" for="c-42684955">[-]</label><label class="expand" for="c-42684955">[2 more]</label></div><br/><div class="children"><div class="content">Running temperature of zero&#x2F;greedy sampling (what you call &quot;argmax sampling&quot;) is EXTREMELY common.<p>LLMs are basically &quot;deterministic&quot; when using greedy sampling except for either MoE related shenanigans (what historically prevented determinism in ChatGPT) or due to floating point related issues (GPU related). In practice, LLMs are in fact basically &quot;deterministic&quot; except for the sampling&#x2F;temperature stuff that we add at the very end.</div><br/><div id="42686849" class="c"><input type="checkbox" id="c-42686849" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42684955">parent</a><span>|</span><a href="#42685300">next</a><span>|</span><label class="collapse" for="c-42686849">[-]</label><label class="expand" for="c-42686849">[1 more]</label></div><br/><div class="children"><div class="content">&gt; except for either MoE related shenanigans (what historically prevented determinism in ChatGPT)<p>The original ChatCPT was based on GPT-3.5, which did not use MoE.</div><br/></div></div></div></div></div></div><div id="42685300" class="c"><input type="checkbox" id="c-42685300" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42683634">parent</a><span>|</span><a href="#42683851">prev</a><span>|</span><a href="#42686430">next</a><span>|</span><label class="collapse" for="c-42685300">[-]</label><label class="expand" for="c-42685300">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s extra randomness added accidentally in practice: inference is a massively parallelized set of matrix multiplications, and floating point math is not commutative - the randomness in execution order gets converted into a random FP error, so even setting temperature to 0 doesn&#x27;t guarantee repeatable results.</div><br/><div id="42685477" class="c"><input type="checkbox" id="c-42685477" checked=""/><div class="controls bullet"><span class="by">HeatrayEnjoyer</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42685300">parent</a><span>|</span><a href="#42686430">next</a><span>|</span><label class="collapse" for="c-42685477">[-]</label><label class="expand" for="c-42685477">[2 more]</label></div><br/><div class="children"><div class="content">Only if the inference software doesn&#x27;t guarantee concurrency, which is CS 101</div><br/><div id="42694397" class="c"><input type="checkbox" id="c-42694397" checked=""/><div class="controls bullet"><span class="by">pizza</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42685477">parent</a><span>|</span><a href="#42686430">next</a><span>|</span><label class="collapse" for="c-42694397">[-]</label><label class="expand" for="c-42694397">[1 more]</label></div><br/><div class="children"><div class="content">This sort of nondeterministic scheduling of non associative floating point ops is essentially running at the level of GPU firmware, so, I would imagine that in this case, Nvidia is aware.</div><br/></div></div></div></div></div></div><div id="42686430" class="c"><input type="checkbox" id="c-42686430" checked=""/><div class="controls bullet"><span class="by">nikkindev</span><span>|</span><a href="#42683634">parent</a><span>|</span><a href="#42685300">prev</a><span>|</span><a href="#42683814">next</a><span>|</span><label class="collapse" for="c-42686430">[-]</label><label class="expand" for="c-42686430">[1 more]</label></div><br/><div class="children"><div class="content">Author here: Yes. You are right. I was meaning to paint a picture that instead of the next token appearing magically, it is sampled from a probability distribution. The notion of determinism could be explained differently. Thanks for pointing it out!</div><br/></div></div><div id="42683814" class="c"><input type="checkbox" id="c-42683814" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42683634">parent</a><span>|</span><a href="#42686430">prev</a><span>|</span><a href="#42683663">next</a><span>|</span><label class="collapse" for="c-42683814">[-]</label><label class="expand" for="c-42683814">[4 more]</label></div><br/><div class="children"><div class="content">The output &quot;token&quot;<p>Yes, you can sample deterministically, but that&#x27;s some combination of computationally intractable and only useful on a small subset of problems. The black box outputting a non-deterministic token is a close enough approximation for most people.</div><br/><div id="42684683" class="c"><input type="checkbox" id="c-42684683" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42683814">parent</a><span>|</span><a href="#42683663">next</a><span>|</span><label class="collapse" for="c-42684683">[-]</label><label class="expand" for="c-42684683">[3 more]</label></div><br/><div class="children"><div class="content">The author of the article seems confused, saying:<p>&quot;The important thing to remember is that the output token of the LLM (black box) is not deterministic. Rather, it is a probability distribution over all the available tokens in the vocabulary.&quot;<p>He is saying that there is non-determinism in the output of the LLM (i.e. in these probability distributions), when in fact the randomness only comes from choosing to use a random number generator to sample from this output.</div><br/><div id="42686568" class="c"><input type="checkbox" id="c-42686568" checked=""/><div class="controls bullet"><span class="by">fancyfredbot</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42684683">parent</a><span>|</span><a href="#42683663">next</a><span>|</span><label class="collapse" for="c-42686568">[-]</label><label class="expand" for="c-42686568">[2 more]</label></div><br/><div class="children"><div class="content">The author is saying that the output <i>token</i> is not deterministic. I don&#x27;t think they said the distribution was stochastic.<p>Even so the distribution of the second token output by the model would be stochastic (unless you condition on the first token). So in that sense there may also be a stochastic probability distribution.</div><br/><div id="42692360" class="c"><input type="checkbox" id="c-42692360" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42686568">parent</a><span>|</span><a href="#42683663">next</a><span>|</span><label class="collapse" for="c-42692360">[-]</label><label class="expand" for="c-42692360">[1 more]</label></div><br/><div class="children"><div class="content">Mostly unrelated (I agree with you, and I&#x27;m some ancestory comment you&#x27;re responding to with the same line of thinking), I have built a couple LLMs where the distribution itself is stochastic. That&#x27;s not key to how they work as a black box, but much like how quicksort has certain performance characteristics I did find it advantageous to introduce randomness into the model itself.<p>You could still easily model the next token as a conditional probability distribution though if you wanted; the computation of entropy just might be a bit spendier.</div><br/></div></div></div></div></div></div></div></div><div id="42683663" class="c"><input type="checkbox" id="c-42683663" checked=""/><div class="controls bullet"><span class="by">cjtrowbridge</span><span>|</span><a href="#42683634">parent</a><span>|</span><a href="#42683814">prev</a><span>|</span><a href="#42683692">next</a><span>|</span><label class="collapse" for="c-42683663">[-]</label><label class="expand" for="c-42683663">[5 more]</label></div><br/><div class="children"><div class="content">Entropy is also added via a random seed. The model is only deterministic if you use the same random seed.</div><br/><div id="42683759" class="c"><input type="checkbox" id="c-42683759" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42683663">parent</a><span>|</span><a href="#42683692">next</a><span>|</span><label class="collapse" for="c-42683759">[-]</label><label class="expand" for="c-42683759">[4 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re confusing training and inference. During training there are things like initialization, data shuffling and dropout that depend on random numbers. At inference time these don&#x27;t apply.</div><br/><div id="42685248" class="c"><input type="checkbox" id="c-42685248" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42683759">parent</a><span>|</span><a href="#42683692">next</a><span>|</span><label class="collapse" for="c-42685248">[-]</label><label class="expand" for="c-42685248">[3 more]</label></div><br/><div class="children"><div class="content">Decoding (sampling) uses (pseudo) random numbers. Otherwise same prompt would always give the same response.<p>Computing entropy generally does not.<p>See e.g. <a href="https:&#x2F;&#x2F;huggingface.co&#x2F;blog&#x2F;how-to-generate" rel="nofollow">https:&#x2F;&#x2F;huggingface.co&#x2F;blog&#x2F;how-to-generate</a></div><br/><div id="42685485" class="c"><input type="checkbox" id="c-42685485" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42685248">parent</a><span>|</span><a href="#42683692">next</a><span>|</span><label class="collapse" for="c-42685485">[-]</label><label class="expand" for="c-42685485">[2 more]</label></div><br/><div class="children"><div class="content">Sure - but that&#x27;s not the output of the model itself, that&#x27;s the process of (typically) randomly sampling from the output of the model.</div><br/><div id="42690545" class="c"><input type="checkbox" id="c-42690545" checked=""/><div class="controls bullet"><span class="by">throwaway314155</span><span>|</span><a href="#42683634">root</a><span>|</span><a href="#42685485">parent</a><span>|</span><a href="#42683692">next</a><span>|</span><label class="collapse" for="c-42690545">[-]</label><label class="expand" for="c-42690545">[1 more]</label></div><br/><div class="children"><div class="content">Right, sampling from a model, also known as *inference* (for LLM&#x27;s).<p>The inference here is perhaps less pure than what you refer to but you&#x27;re talking to human beings;  there&#x27;s no need for heavy pedantry.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42683692" class="c"><input type="checkbox" id="c-42683692" checked=""/><div class="controls bullet"><span class="by">netruk44</span><span>|</span><a href="#42683634">prev</a><span>|</span><a href="#42687575">next</a><span>|</span><label class="collapse" for="c-42683692">[-]</label><label class="expand" for="c-42683692">[5 more]</label></div><br/><div class="children"><div class="content">I wonder if we could combine ‘thinking’ models (which write thoughts out before replying) with a mechanism they can use to check their own entropy as they’re writing output.<p>Maybe it could eventually learn when it needs to have a low entropy token (to produce a more-likely-to-be-factual statement) and then we can finally have models that actually definitely know when to say “Sorry, I don’t seem to have a good answer for you.”</div><br/><div id="42694462" class="c"><input type="checkbox" id="c-42694462" checked=""/><div class="controls bullet"><span class="by">pizza</span><span>|</span><a href="#42683692">parent</a><span>|</span><a href="#42684014">next</a><span>|</span><label class="collapse" for="c-42694462">[-]</label><label class="expand" for="c-42694462">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a paper that probed how strongly a model would focus on prompt-supplied tokens when generating a response as a signal that it was trying to use the prompt as the source of information as opposed to knowledge it had been trained on. Ie, how much it was trying to lie based on it assuming that the information in the prompt was true, as opposed to having a rich internal model of the thing that is being verified. It looks like it works, sort of, sometimes, when you have access to the actual labels. The results from this work, in the more real-world unsupervised setting, are better than random, sure, but not good enough to really be exciting or reliable.<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;html&#x2F;2402.03563v1" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;html&#x2F;2402.03563v1</a></div><br/></div></div><div id="42684014" class="c"><input type="checkbox" id="c-42684014" checked=""/><div class="controls bullet"><span class="by">vletal</span><span>|</span><a href="#42683692">parent</a><span>|</span><a href="#42694462">prev</a><span>|</span><a href="#42687575">next</a><span>|</span><label class="collapse" for="c-42684014">[-]</label><label class="expand" for="c-42684014">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;xjdr-alt&#x2F;entropix">https:&#x2F;&#x2F;github.com&#x2F;xjdr-alt&#x2F;entropix</a></div><br/><div id="42684925" class="c"><input type="checkbox" id="c-42684925" checked=""/><div class="controls bullet"><span class="by">Der_Einzige</span><span>|</span><a href="#42683692">root</a><span>|</span><a href="#42684014">parent</a><span>|</span><a href="#42687575">next</a><span>|</span><label class="collapse" for="c-42684925">[-]</label><label class="expand" for="c-42684925">[2 more]</label></div><br/><div class="children"><div class="content">Entropix will get it&#x27;s time in the sun, but for now, the LLM academic community is still 2 years behind the open source community. Min_p sampling is going to end up getting an oral about it at ICLR with the scores it&#x27;s getting...<p><a href="https:&#x2F;&#x2F;openreview.net&#x2F;forum?id=FBkpCyujtS" rel="nofollow">https:&#x2F;&#x2F;openreview.net&#x2F;forum?id=FBkpCyujtS</a></div><br/><div id="42685818" class="c"><input type="checkbox" id="c-42685818" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#42683692">root</a><span>|</span><a href="#42684925">parent</a><span>|</span><a href="#42687575">next</a><span>|</span><label class="collapse" for="c-42685818">[-]</label><label class="expand" for="c-42685818">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the LLM academic community is still 2 years behind the open source community<p>Huh, isn&#x27;t it the other way around? Thanks to the academic (and open) research about LLMs, we have any open source community around LLMs in the first place.</div><br/></div></div></div></div></div></div></div></div><div id="42687575" class="c"><input type="checkbox" id="c-42687575" checked=""/><div class="controls bullet"><span class="by">pona-a</span><span>|</span><a href="#42683692">prev</a><span>|</span><a href="#42684926">next</a><span>|</span><label class="collapse" for="c-42687575">[-]</label><label class="expand" for="c-42687575">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps CoT and the like may be limited by this. If your model is cooked and does not adequately represent less immediately useful predictions, even if you slap a more global probability maximization mechanism, you can&#x27;t extract knowledge that&#x27;s been erased by RLHF&#x2F;fine-tuning.</div><br/></div></div><div id="42684926" class="c"><input type="checkbox" id="c-42684926" checked=""/><div class="controls bullet"><span class="by">EncomLab</span><span>|</span><a href="#42687575">prev</a><span>|</span><a href="#42684018">next</a><span>|</span><label class="collapse" for="c-42684926">[-]</label><label class="expand" for="c-42684926">[11 more]</label></div><br/><div class="children"><div class="content">We should stop using the term &quot;black box&quot; to mean &quot;we don&#x27;t know&quot; when really it&#x27;s &quot;we could find out but it would be really hard&quot;.<p>We can precisely determine the exact state of any digital system and track that state as it changes.  In something as large as a LLM doing so is extremely complex, but complexity does not equal unknowable.<p>These systems are still just software, with pre-defined operations executing in order like any other piece of software.  A CPU does not enter some mysterious woo &quot;LLM black box&quot; state that is somehow fundamentally different than running any other software, and it&#x27;s these imprecise terms that lead to so much of the hype.</div><br/><div id="42685691" class="c"><input type="checkbox" id="c-42685691" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#42684926">parent</a><span>|</span><a href="#42686753">next</a><span>|</span><label class="collapse" for="c-42685691">[-]</label><label class="expand" for="c-42685691">[3 more]</label></div><br/><div class="children"><div class="content">The usual use of the term &quot;black box&quot; is just that you are using&#x2F;testing a system without knowing&#x2F;assuming anything about what&#x27;s inside. It doesn&#x27;t imply that what&#x27;s inside is complex or unknown - just unknown to an outside observer who can only see the box.<p>e.g.<p>In &quot;black box&quot; testing of a system you are just going to test based on the specifications of what the output&#x2F;behavior should be for a given input. In contrast, in &quot;white box&quot; testing you leverage your knowledge of the internals of the box to test for things like edge cases that are apparent in the implementation, to test all code paths, etc.</div><br/><div id="42686246" class="c"><input type="checkbox" id="c-42686246" checked=""/><div class="controls bullet"><span class="by">EncomLab</span><span>|</span><a href="#42684926">root</a><span>|</span><a href="#42685691">parent</a><span>|</span><a href="#42686753">next</a><span>|</span><label class="collapse" for="c-42686246">[-]</label><label class="expand" for="c-42686246">[2 more]</label></div><br/><div class="children"><div class="content">Yes that is the definition - but that is not what is occurring her.  We DO know exactly what is going on inside the system and can determine precisely from step to step the state of the entire system and the next state of the system.  The author is making a claim based on woo that somehow this software operates differently than any other software at a fundamental level and that is not the case.</div><br/><div id="42686439" class="c"><input type="checkbox" id="c-42686439" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#42684926">root</a><span>|</span><a href="#42686246">parent</a><span>|</span><a href="#42686753">next</a><span>|</span><label class="collapse" for="c-42686439">[-]</label><label class="expand" for="c-42686439">[1 more]</label></div><br/><div class="children"><div class="content">Are they ? The article only mentions &quot;black box&quot; a couple of times, and seems to be using it in the sense of &quot;we don&#x27;t need to be concerned about what&#x27;s inside&quot;.<p>In any case, while we know there&#x27;s a transformer in the box, the operational behavior of a trained transformer is still somewhat opaque. We know the data flow of course, and how to calculate next state given current state, but what is going on semantically - the field of mechanistic interpretability - is still a work in progress.</div><br/></div></div></div></div></div></div><div id="42686753" class="c"><input type="checkbox" id="c-42686753" checked=""/><div class="controls bullet"><span class="by">observationist</span><span>|</span><a href="#42684926">parent</a><span>|</span><a href="#42685691">prev</a><span>|</span><a href="#42684989">next</a><span>|</span><label class="collapse" for="c-42686753">[-]</label><label class="expand" for="c-42686753">[2 more]</label></div><br/><div class="children"><div class="content">Something like: A black box is unknowable, a gray box can be figured out in principle, a white box is fully known. A pocket calculator is fully known. LLMs are (dark) gray boxes - we can, in principle, figure out any particular sequence of computations, at any particular level you want to look at, but doing so is extremely tedious. Tools are being researched and developed to make this better, and mechinterp makes progress every day.<p>However - even if, in principle, you could figure out any particular sequence of reasoning done by a model, it might in effect be &quot;secured&quot; and out of reach of current tools, in the same sense that encryption makes brute forcing a password search out of reach of current computers. 128 bits might have been secure 20 years ago, but take mere seconds now, but 8096 bits will take longer than the universe probably has, to brute force on current hardware.<p>There could also be, and very likely are, sequences of processing&#x2F; machine reasoning that don&#x27;t make any sense relevant to the way humans think. You might have every relevant step decomposed in a particular generation of text, and it might not provide any insight into how or why the text was produced, with regard to everything else you know about the model.<p>A challenge for AI researchers is broadly generalizing the methodologies and theories such that they apply to models beyond those with the particular architectures and constraints being studied. If an experiment can work with a diffusion model as well as it does with a pure text model, and produces robust results for any model tested, the methodology works, and could likely be applied to human minds. Each of these steps takes us closer to understanding a grand unifying theory of intelligence.<p>There are probably some major breakthroughs in explainability and generative architectures that will radically alter how we test and study and perform research on models. Things like SAEs and golden gate claude might only be hyperspecific investigations of how models work with this particular type of architecture.<p>All of that to say, we might only ever get to a &quot;pale gray box&quot; level of understanding of some types of model, and never, in principle, to a perfectly understood intelligent system, especially if AI reaches the point of recursive self improvement.</div><br/><div id="42691896" class="c"><input type="checkbox" id="c-42691896" checked=""/><div class="controls bullet"><span class="by">kbelder</span><span>|</span><a href="#42684926">root</a><span>|</span><a href="#42686753">parent</a><span>|</span><a href="#42684989">next</a><span>|</span><label class="collapse" for="c-42691896">[-]</label><label class="expand" for="c-42691896">[1 more]</label></div><br/><div class="children"><div class="content">One important point  (I think) is whether the cause or outcome of the box can be understood or predicted without full emulation of the entire box.  Can it be distilled down to a more simple set of rules, or is it a chaotic system that turns into a different system if any part of it is removed?<p>That is, can you trace unequivocally the reason an LLM produced a certain token without, in effect, recreating the LLM and asking it the same question again?</div><br/></div></div></div></div><div id="42684989" class="c"><input type="checkbox" id="c-42684989" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42684926">parent</a><span>|</span><a href="#42686753">prev</a><span>|</span><a href="#42685087">next</a><span>|</span><label class="collapse" for="c-42684989">[-]</label><label class="expand" for="c-42684989">[1 more]</label></div><br/><div class="children"><div class="content">This is much more similar to the technique of obfuscating encryption  algorithms for DRM schemes that I believe is often called &quot;white-box cryptography&quot;.</div><br/></div></div><div id="42685087" class="c"><input type="checkbox" id="c-42685087" checked=""/><div class="controls bullet"><span class="by">Ecoste</span><span>|</span><a href="#42684926">parent</a><span>|</span><a href="#42684989">prev</a><span>|</span><a href="#42684018">next</a><span>|</span><label class="collapse" for="c-42685087">[-]</label><label class="expand" for="c-42685087">[4 more]</label></div><br/><div class="children"><div class="content">So going by your definition what would be a true black box?</div><br/><div id="42686284" class="c"><input type="checkbox" id="c-42686284" checked=""/><div class="controls bullet"><span class="by">EncomLab</span><span>|</span><a href="#42684926">root</a><span>|</span><a href="#42685087">parent</a><span>|</span><a href="#42684018">next</a><span>|</span><label class="collapse" for="c-42686284">[-]</label><label class="expand" for="c-42686284">[3 more]</label></div><br/><div class="children"><div class="content">A starting point would be a system that does not require the use of a limited set of pre-defined operations to transform from one state to another state via the interpretation of a set of pre-existing instructions.  This rules out any digital system entirely.</div><br/><div id="42687166" class="c"><input type="checkbox" id="c-42687166" checked=""/><div class="controls bullet"><span class="by">achierius</span><span>|</span><a href="#42684926">root</a><span>|</span><a href="#42686284">parent</a><span>|</span><a href="#42684018">next</a><span>|</span><label class="collapse" for="c-42687166">[-]</label><label class="expand" for="c-42687166">[2 more]</label></div><br/><div class="children"><div class="content">But what _would_ qualify? The point being made is that your definition is so constricting as to be useless. Nothing (sans perhaps true physical limit-conditions, like black-holes) would be a black box under your definition.</div><br/><div id="42688825" class="c"><input type="checkbox" id="c-42688825" checked=""/><div class="controls bullet"><span class="by">EncomLab</span><span>|</span><a href="#42684926">root</a><span>|</span><a href="#42687166">parent</a><span>|</span><a href="#42684018">next</a><span>|</span><label class="collapse" for="c-42688825">[-]</label><label class="expand" for="c-42688825">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really only constricting to state machines which are dependent upon a fixed instruction set to function.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42684018" class="c"><input type="checkbox" id="c-42684018" checked=""/><div class="controls bullet"><span class="by">fedeb95</span><span>|</span><a href="#42684926">prev</a><span>|</span><a href="#42685180">next</a><span>|</span><label class="collapse" for="c-42684018">[-]</label><label class="expand" for="c-42684018">[1 more]</label></div><br/><div class="children"><div class="content">it seems very noise-like to me.</div><br/></div></div><div id="42685180" class="c"><input type="checkbox" id="c-42685180" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#42684018">prev</a><span>|</span><a href="#42688760">next</a><span>|</span><label class="collapse" for="c-42685180">[-]</label><label class="expand" for="c-42685180">[3 more]</label></div><br/><div class="children"><div class="content">This was discussed in my paper last year: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2406.05587" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2406.05587</a><p>TLDR; RLHF results in &quot;mode collapse&quot; of LLMs, reducing their creativity and turning them into agents that already have made up their &quot;mind&quot; about what they&#x27;re going to say next.</div><br/><div id="42686654" class="c"><input type="checkbox" id="c-42686654" checked=""/><div class="controls bullet"><span class="by">nikkindev</span><span>|</span><a href="#42685180">parent</a><span>|</span><a href="#42685468">next</a><span>|</span><label class="collapse" for="c-42686654">[-]</label><label class="expand" for="c-42686654">[1 more]</label></div><br/><div class="children"><div class="content">Author here: Really interesting work. Updated original post to include link to the paper. Thanks!</div><br/></div></div></div></div><div id="42688760" class="c"><input type="checkbox" id="c-42688760" checked=""/><div class="controls bullet"><span class="by">K0balt</span><span>|</span><a href="#42685180">prev</a><span>|</span><label class="collapse" for="c-42688760">[-]</label><label class="expand" for="c-42688760">[2 more]</label></div><br/><div class="children"><div class="content">Low entropy is expected here, since the model is seeking a “best” answer based on reward training.<p>But I see the same misconceptions as always around “hallucinations”. Incorrect output is just incorrect output. There is no difference in the function of the model, no malfunction. It is working exactly as it does for “correct “ answers.  This is what makes the issue of incorrect output intractable.<p>Some optimisation can be achieved through introspection, but ultimately, an llm can be wrong for the same reason that a person can be wrong, incorrect conclusions, bad data, insufficient data, or faulty logic&#x2F;modeling.  If there was a way to be always right, we wouldn’t need LLMs or second opinions.<p>Agentic workflows and introspection&#x2F;cot catch a lot, and flights of fancy are often not supported or replicated with modifications to context, because the fanciful answer isn’t reinforced in the training data.<p>But we need to get rid of the unfortunate term for wrong conclusions,“hallucination” . When we say a person is hallucinating, it implies an altered state of mind. We don’t say that bob is hallucinating when he thinks that the sky is blue because it reflects the ocean, we just know he’s wrong because he doesn’t know about or forgot about Raleigh scattering.<p>Using the term “hallucination” distracts from accurate thought and misleads people to draw erroneous conclusions.</div><br/><div id="42694826" class="c"><input type="checkbox" id="c-42694826" checked=""/><div class="controls bullet"><span class="by">nikkindev</span><span>|</span><a href="#42688760">parent</a><span>|</span><label class="collapse" for="c-42694826">[-]</label><label class="expand" for="c-42694826">[1 more]</label></div><br/><div class="children"><div class="content">Author here: Wholeheartedly agree with your comment on hallucination. I initially set out to answer the question “Will entropy help identify hallucination?” And soon realised that it doesn’t, for the same reasons you mentioned above. So I pivoted to just writing about the entropy measure in the post. And this is also reflected by how I started with hallucination and then quickly veered away from it. I’ll be more careful in future posts &amp; conversations. Thanks!</div><br/></div></div></div></div></div></div></div></div></div></body></html>