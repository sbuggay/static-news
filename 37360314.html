<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693818074588" as="style"/><link rel="stylesheet" href="styles.css?v=1693818074588"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://research.swtch.com/sparse">Using uninitialized memory for fun and profit (2008)</a> <span class="domain">(<a href="https://research.swtch.com">research.swtch.com</a>)</span></div><div class="subtext"><span>Smaug123</span> | <span>31 comments</span></div><br/><div><div id="37376577" class="c"><input type="checkbox" id="c-37376577" checked=""/><div class="controls bullet"><span class="by">devbug</span><span>|</span><a href="#37376884">next</a><span>|</span><label class="collapse" for="c-37376577">[-]</label><label class="expand" for="c-37376577">[2 more]</label></div><br/><div class="children"><div class="content">A similar data-structure that is also very useful uses sparse-dense arrays but encodes a free-list in the unused memory. It&#x27;s an ideal data structure if your access patterns are sporadic reads&#x2F;writes bookmarked by frequent complete iterations of the dense array. You can insert and remove (swap &#x27;n&#x27; pop) in O(1) and iterate in O(n) without polluting your cache and skipping over empty slots.<p>It&#x27;s frequently used in Entity-Component Systems (ECS) which introduce safety by associating a counter with each entry in the sparse array (usually called a &quot;generation&quot;) and incrementing them on deletion. You can also verify cross-linkage between the sparse and dense arrays like the data structure described in the article, but that comes at the cost of another indirection and fetch from memory.</div><br/><div id="37378554" class="c"><input type="checkbox" id="c-37378554" checked=""/><div class="controls bullet"><span class="by">mandarax8</span><span>|</span><a href="#37376577">parent</a><span>|</span><a href="#37376884">next</a><span>|</span><label class="collapse" for="c-37378554">[-]</label><label class="expand" for="c-37378554">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like just what I need for a project, any idea where I could find more info on this or how its called?</div><br/></div></div></div></div><div id="37376884" class="c"><input type="checkbox" id="c-37376884" checked=""/><div class="controls bullet"><span class="by">turndown</span><span>|</span><a href="#37376577">prev</a><span>|</span><a href="#37376818">next</a><span>|</span><label class="collapse" for="c-37376884">[-]</label><label class="expand" for="c-37376884">[23 more]</label></div><br/><div class="children"><div class="content">&gt;     return sparse[i] &lt; n &amp;&amp; dense[sparse[i]] == i<p>This line lives in fear of the optimizer. sparse[i] references uninitialized memory and is thus UB and could be optimized out at a certain level. Also I think I read once that even if we’ll allow that sparse[i] stays in the program, there’s still no guarantee that each access of sparse[i] <i>will read the same value</i> since it’s still UB.</div><br/><div id="37378290" class="c"><input type="checkbox" id="c-37378290" checked=""/><div class="controls bullet"><span class="by">laanaah</span><span>|</span><a href="#37376884">parent</a><span>|</span><a href="#37377028">next</a><span>|</span><label class="collapse" for="c-37378290">[-]</label><label class="expand" for="c-37378290">[1 more]</label></div><br/><div class="children"><div class="content">The way I usually deal with this nonsense is to write a function in assembly that returns its pointer argument:<p><pre><code>  stop_messing_with_my_code:
    mov rax, rdi
    ret

  extern &quot;C&quot; void *stop_messing_with_my_code(void *);

  void *p = stop_messing_with_my_code(malloc(100));
  &#x2F;&#x2F; compiler cant know what my function does, it might have initialized it,
  &#x2F;&#x2F; aligned it properly, returned the correct, type, etc.
</code></pre>
Also useful for getting around the idiotic type-based aliasing so you can write custom allocators (i.e a byte pool allocated statically&#x2F;globally, then allocate data from that which is common in embedded, which is technically not possible in standard C or C++...)</div><br/></div></div><div id="37377028" class="c"><input type="checkbox" id="c-37377028" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#37376884">parent</a><span>|</span><a href="#37378290">prev</a><span>|</span><a href="#37377118">next</a><span>|</span><label class="collapse" for="c-37377028">[-]</label><label class="expand" for="c-37377028">[19 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re running in some theoretical fairy dust C++ spec environment sure, but in reality sparse is just a pointer and the compiler can&#x27;t know its value, or whether or not it&#x27;s &quot;initialized&quot;.<p>Even if you construct a degenerate case:<p><pre><code>    int* sparse = (int*)malloc(100 * sizeof(int));
    int x = sparse[40]; &#x2F;&#x2F; provably unitialized
</code></pre>
it still won&#x27;t &quot;optimize out&quot; the access, since<p>1. it&#x27;s insane. nobody would write such an optimization because there&#x27;s no possible performance gain, and it changes program behavior<p>2. malloc is just a function, it&#x27;s not treated in any special way<p>3. there&#x27;s no guarentee this malloc is a per-spec malloc, it can be
       a user-defined function for which this is perfectly valid</div><br/><div id="37377166" class="c"><input type="checkbox" id="c-37377166" checked=""/><div class="controls bullet"><span class="by">nlewycky</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377028">parent</a><span>|</span><a href="#37377419">next</a><span>|</span><label class="collapse" for="c-37377166">[-]</label><label class="expand" for="c-37377166">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 1. it&#x27;s insane. nobody would write such an optimization because there&#x27;s no possible performance gain, and it changes program behavior<p>LLVM explicitly has an &#x27;undef&#x27; constant value which facilitates this optimization. <a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#undefined-values" rel="nofollow noreferrer">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#undefined-values</a><p>FWIW, the most important reason compilers do this is to decrease compile time. The compiler notices that some code has undefined behaviour and deletes the code now instead of waiting to prove that the path to this code is unreachable. The later optimizations tend to be slower and scale badly with more code in the function, so deleting it earlier will speed up the compilation.<p>&gt; 2. malloc is just a function, it&#x27;s not treated in any special way<p>The compiler is full of optimizations that treat malloc and other functions specially. This file implements an analysis, but the results of the analysis is used by transformations. <a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;blob&#x2F;main&#x2F;llvm&#x2F;lib&#x2F;Analysis&#x2F;MemoryBuiltins.cpp#L55">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;blob&#x2F;main&#x2F;llvm&#x2F;lib&#x2F;Anal...</a><p>&gt; 3. there&#x27;s no guarentee this malloc is a per-spec malloc, it can be a user-defined function for which this is perfectly valid<p>Yep, there&#x27;s a flag for that mode, `-ffreestanding` which corresponds to freestanding mode in the C89 standard, section 2.1.2.1. Without that flag, we assume malloc, strlen, etc., are the standard library functions that do as described in the standard.</div><br/></div></div><div id="37377419" class="c"><input type="checkbox" id="c-37377419" checked=""/><div class="controls bullet"><span class="by">turndown</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377028">parent</a><span>|</span><a href="#37377166">prev</a><span>|</span><a href="#37377099">next</a><span>|</span><label class="collapse" for="c-37377419">[-]</label><label class="expand" for="c-37377419">[6 more]</label></div><br/><div class="children"><div class="content">Others have shown that your degenerate example really does optimize it all away, but I&#x27;ll just say that we really do exist in a theoretical fairy dust C++ spec environment, because when we compile a piece of code we compile it <i>against the abstract machine</i>. This is one of those insane gotchas of programming languages - unless you&#x27;re writing assembly yourself you must pass the bar set by the abstract machine and nothing else. I recommend [0], along with every link in the article, and every article on the blog.<p>0: <a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;ub" rel="nofollow noreferrer">https:&#x2F;&#x2F;research.swtch.com&#x2F;ub</a></div><br/><div id="37377696" class="c"><input type="checkbox" id="c-37377696" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377419">parent</a><span>|</span><a href="#37377099">next</a><span>|</span><label class="collapse" for="c-37377696">[-]</label><label class="expand" for="c-37377696">[5 more]</label></div><br/><div class="children"><div class="content"><i>This is one of those insane gotchas of programming languages</i><p>...created only by adversarial compiler writers who seem to be as user-hostile as a lot of other &quot;developers&quot; these days. They can get away with being pedantic assholes, because they know that realistically no one is going to switch compilers that easily.<p>That said, C and even C++ used to not be like this.</div><br/><div id="37378232" class="c"><input type="checkbox" id="c-37378232" checked=""/><div class="controls bullet"><span class="by">tyg13</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377696">parent</a><span>|</span><a href="#37378159">next</a><span>|</span><label class="collapse" for="c-37378232">[-]</label><label class="expand" for="c-37378232">[1 more]</label></div><br/><div class="children"><div class="content">This seems like the sort of a comment that can only be written by completely refusing to understand why compiler writers take advantage of UB. Compiler writers are not engaging in &quot;adversarial&quot; behavior with their users -- they are their own users!<p>The simple truth is a lot of UB exists to allow for optimizations that programmers entirely take for granted. In order to optimize something, you have to make assumptions, particularly when dealing with languages as permissive as C and C++. By programming to an abstract machine and explicitly specifying which behavior is defined and which is not, we allow a compiler to make these assumptions. Despite what you may wish, a compiler is not able to read your mind to know when a given piece of UB is actually code that you intended to execute with particular semantics, or whether it&#x27;s the result of some other optimizations on a code path that will never execute.</div><br/></div></div><div id="37378159" class="c"><input type="checkbox" id="c-37378159" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377696">parent</a><span>|</span><a href="#37378232">prev</a><span>|</span><a href="#37378226">next</a><span>|</span><label class="collapse" for="c-37378159">[-]</label><label class="expand" for="c-37378159">[1 more]</label></div><br/><div class="children"><div class="content">Compiler authors aren&#x27;t doing this because they <i>hate you</i>, they&#x27;re doing this because we want ever high performance. C and C++ didn&#x27;t use to be like this because compilers were not capable of making the optimizations they can today.</div><br/></div></div><div id="37378226" class="c"><input type="checkbox" id="c-37378226" checked=""/><div class="controls bullet"><span class="by">hoseja</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377696">parent</a><span>|</span><a href="#37378159">prev</a><span>|</span><a href="#37377099">next</a><span>|</span><label class="collapse" for="c-37378226">[-]</label><label class="expand" for="c-37378226">[2 more]</label></div><br/><div class="children"><div class="content">Somebody removed all the insane UB-&quot;optimizations&quot; and the result wasn&#x27;t even any slower. Can&#x27;t find the blog now.</div><br/><div id="37378267" class="c"><input type="checkbox" id="c-37378267" checked=""/><div class="controls bullet"><span class="by">tyg13</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37378226">parent</a><span>|</span><a href="#37377099">next</a><span>|</span><label class="collapse" for="c-37378267">[-]</label><label class="expand" for="c-37378267">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be quite interested to read that post, given that one of the big UB hammers is strict aliasing which gets used a _lot_</div><br/></div></div></div></div></div></div></div></div><div id="37377099" class="c"><input type="checkbox" id="c-37377099" checked=""/><div class="controls bullet"><span class="by">nwallin</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377028">parent</a><span>|</span><a href="#37377419">prev</a><span>|</span><a href="#37377055">next</a><span>|</span><label class="collapse" for="c-37377099">[-]</label><label class="expand" for="c-37377099">[2 more]</label></div><br/><div class="children"><div class="content">c code:<p><pre><code>    #include &lt;stdlib.h&gt;

    int foo(int x) {
        int* p = malloc(1024);
        x = p[x];
        free (p);
        return x;
    }
</code></pre>
assembly:<p><pre><code>    foo:                                    # @foo
            ret
</code></pre>
<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;jfvKon5v7" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;jfvKon5v7</a></div><br/><div id="37378192" class="c"><input type="checkbox" id="c-37378192" checked=""/><div class="controls bullet"><span class="by">4gotunameagain</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377099">parent</a><span>|</span><a href="#37377055">next</a><span>|</span><label class="collapse" for="c-37378192">[-]</label><label class="expand" for="c-37378192">[1 more]</label></div><br/><div class="children"><div class="content">change `int* p = malloc(1024);` to `volatile int* p = malloc(1024);`<p>asm:<p><pre><code>  foo:                                    # @foo
        push    rbx
        mov     ebx, edi
        mov     edi, 1024
        call    malloc@PLT
        movsxd  rcx, ebx
        mov     ebx, dword ptr [rax + 4\*rcx]
        mov     rdi, rax
        call    free@PLT
        mov     eax, ebx
        pop     rbx
        ret
</code></pre>
<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;E6Teqns8b" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;E6Teqns8b</a></div><br/></div></div></div></div><div id="37377055" class="c"><input type="checkbox" id="c-37377055" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377028">parent</a><span>|</span><a href="#37377099">prev</a><span>|</span><a href="#37377203">next</a><span>|</span><label class="collapse" for="c-37377055">[-]</label><label class="expand" for="c-37377055">[1 more]</label></div><br/><div class="children"><div class="content">to address the points in order:<p>1. a specific optimisation pass won&#x27;t do this, but the combination of several passes written with other intentions can<p>2 &amp; 3. the C runtime a compiler links with is known to the compiler&#x2F;linker, and it _does_ usually treat intrinsics like malloc specially<p>A quick google reveals <a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;52930">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;52930</a>, LLVM recognising uninitialised memory as &#x27;undef&#x27;, and needing to treat it as poisoned (IIRC propogation of undef can cause things like separate uses of the variable to not even unify to a single value)<p>EDIT: duplicated link</div><br/></div></div><div id="37377203" class="c"><input type="checkbox" id="c-37377203" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377028">parent</a><span>|</span><a href="#37377055">prev</a><span>|</span><a href="#37377093">next</a><span>|</span><label class="collapse" for="c-37377203">[-]</label><label class="expand" for="c-37377203">[1 more]</label></div><br/><div class="children"><div class="content">Others have explained pretty well about UBs, but I would give an explicit evidence against 2 by quoting the actual glibc code [1]:<p><pre><code>    &#x2F;* Allocate SIZE bytes of memory.  *&#x2F;
    extern void *malloc (size_t __size) __THROW __attribute_malloc__
         __attribute_alloc_size__ ((1)) __wur;
</code></pre>
Expanding macro gives three GCC function attributes [2]: `__attribute__ ((malloc))`, `__attribute__ ((alloc_size(1)))` and `__attribute__ ((warn_unused_result))`. They are used for GCC (and others recognizing them) to actually ensure that they behave as the standard dictates and give better error messages. Your own malloc-like functions won&#x27;t be treated same unless you give similar attributes.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;807690610916df8aef17cd14bfadd5d4b6e699a9&#x2F;stdlib&#x2F;stdlib.h#L671-L676">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;807690610916df8aef17cd1...</a><p>[2] <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Common-Function-Attributes.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Common-Function-Attribute...</a></div><br/></div></div><div id="37377093" class="c"><input type="checkbox" id="c-37377093" checked=""/><div class="controls bullet"><span class="by">adwn</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377028">parent</a><span>|</span><a href="#37377203">prev</a><span>|</span><a href="#37377118">next</a><span>|</span><label class="collapse" for="c-37377093">[-]</label><label class="expand" for="c-37377093">[7 more]</label></div><br/><div class="children"><div class="content">Well, you&#x27;re 100% wrong: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;en31xx9Yx" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;en31xx9Yx</a><p>clang optimizes this function to a single <i>ret</i>, optimizing away not just the memory access, but the call to <i>malloc()</i> as well. I does this (and is allowed to do this) because it recognizes that <i>sparse[40]</i> accesses uninitialized memory, which is UB, and therefore <i>anything</i> goes – including replacing the entire function with a no-op.</div><br/><div id="37377123" class="c"><input type="checkbox" id="c-37377123" checked=""/><div class="controls bullet"><span class="by">pca006132</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377093">parent</a><span>|</span><a href="#37377792">next</a><span>|</span><label class="collapse" for="c-37377123">[-]</label><label class="expand" for="c-37377123">[4 more]</label></div><br/><div class="children"><div class="content">&gt; and therefore anything goes – including replacing the entire function with a no-op.<p>Well, I think the compiler is just thinking that the control flow of a correct program cannot cause UB, so the path causing UB is infeasible path and is optimized away. E.g. <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;h69GnfYbd" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;h69GnfYbd</a> where the path causing UB is optimized away and it just returns 42 (and a call to rand).</div><br/><div id="37377172" class="c"><input type="checkbox" id="c-37377172" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377123">parent</a><span>|</span><a href="#37377792">next</a><span>|</span><label class="collapse" for="c-37377172">[-]</label><label class="expand" for="c-37377172">[3 more]</label></div><br/><div class="children"><div class="content">I wonder why the original example emits `ret` instead of `ud2`. Clang is known to emit it for paths with the provable UB.</div><br/><div id="37377221" class="c"><input type="checkbox" id="c-37377221" checked=""/><div class="controls bullet"><span class="by">nwallin</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377172">parent</a><span>|</span><a href="#37377792">next</a><span>|</span><label class="collapse" for="c-37377221">[-]</label><label class="expand" for="c-37377221">[2 more]</label></div><br/><div class="children"><div class="content">Theirs not to reason why. Theirs but to do and die.<p>Likely there&#x27;s some SSA going on that recons the value from the pointer is undefined. So any value will do. And whatever value happens to be in eax is a perfectly cromulent value; might as well just return that.</div><br/><div id="37377303" class="c"><input type="checkbox" id="c-37377303" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377221">parent</a><span>|</span><a href="#37377792">next</a><span>|</span><label class="collapse" for="c-37377303">[-]</label><label class="expand" for="c-37377303">[1 more]</label></div><br/><div class="children"><div class="content">I mean, there is even no reason to emit a single instruction. However it would be helpful for the unconditional UB to turn to a trap (in fact, UB is particularly bad because some of them won&#x27;t have a visible effect for a long time). Given clang and LLVM does emit ud2 for traps from UB, I think this could also have become ud2 but it somehow didn&#x27;t.</div><br/></div></div></div></div></div></div></div></div><div id="37377792" class="c"><input type="checkbox" id="c-37377792" checked=""/><div class="controls bullet"><span class="by">mjan22640</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377093">parent</a><span>|</span><a href="#37377123">prev</a><span>|</span><a href="#37377118">next</a><span>|</span><label class="collapse" for="c-37377792">[-]</label><label class="expand" for="c-37377792">[2 more]</label></div><br/><div class="children"><div class="content">is there an option to emit a warning on encountering ub?</div><br/><div id="37378258" class="c"><input type="checkbox" id="c-37378258" checked=""/><div class="controls bullet"><span class="by">nlewycky</span><span>|</span><a href="#37376884">root</a><span>|</span><a href="#37377792">parent</a><span>|</span><a href="#37377118">next</a><span>|</span><label class="collapse" for="c-37378258">[-]</label><label class="expand" for="c-37378258">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s impossible in the general case, but there are compiler warnings that try to help you catch as much as they can, use `-Wall` when building code, and there is runtime instrumentation `-fsanitize=undefined` to catch as much UB as possible without breaking the ABI. Also consider using `-fsanitize=address,undefined` while developing and `-fsanitize=thread` for threaded code. `-fsanitize=memory` is a bit difficult to deploy because you need all your libraries (except libc) to be built with it too, including your C++ standard library if you&#x27;re building C++.</div><br/></div></div></div></div></div></div></div></div><div id="37377118" class="c"><input type="checkbox" id="c-37377118" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37376884">parent</a><span>|</span><a href="#37377028">prev</a><span>|</span><a href="#37377909">next</a><span>|</span><label class="collapse" for="c-37377118">[-]</label><label class="expand" for="c-37377118">[1 more]</label></div><br/><div class="children"><div class="content">See also <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;43825157" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;43825157</a> for possible workarounds. If you care about the standard comformance `calloc` seems the best approach.</div><br/></div></div><div id="37377909" class="c"><input type="checkbox" id="c-37377909" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37376884">parent</a><span>|</span><a href="#37377118">prev</a><span>|</span><a href="#37376818">next</a><span>|</span><label class="collapse" for="c-37377909">[-]</label><label class="expand" for="c-37377909">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not required that the memory be uninitialized. The trick also permits reusing the same memory without clearing every time.</div><br/></div></div></div></div><div id="37376818" class="c"><input type="checkbox" id="c-37376818" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37376884">prev</a><span>|</span><a href="#37376925">next</a><span>|</span><label class="collapse" for="c-37376818">[-]</label><label class="expand" for="c-37376818">[3 more]</label></div><br/><div class="children"><div class="content">For those wondering: in C, this is probably OK on your system, but if you don’t fully understand the explanation I give below, then you should get sign-off from an expert before using this code. Here’s how it works:<p>Accessing an uninitialized variable is always undefined, in the following case:<p>* the storage can be declared with the register keyword<p>Because this is an array of uninitialized data, this is not relevant. In that case, the standard specifies that the value produced is <i>indeterminate</i>. An indeterminate value can either be:<p>* a trap representation<p>* an <i>unspecified</i> value<p>unsigned char never has any trap representations. Its value when uninitialized is always unspecified. Other types may have a trap representation, in theory: this is <i>implementation defined</i>. On your system this is almost certainly not true for integer types, but you may have signaling floats. Accessing a value that is a trap representation is undefined behavior.<p>If you don’t have any trap representations, then the value produced is unspecified. An unspecified value is, morally, “some random value from the range of values this thing can take”. Of note, the value produced is not required to be consistent: two “reads” can produce different results. However the act of performing the read and the results it produces (bounded by what I just mentioned) are well defined.<p>Putting it all together, in the case of this algorithm, on a system where integers do not have trap representations, the uninitialized read will produce an unspecified value, which the algorithm does not rely on a consistent result from. So, overall, it’s probably ok.<p>If you are using this code and don’t have a comment that describes exactly what I just said then you need to add one immediately. There are not many cases where it is crucial to juggle the precise definition of well-defined, undefined, implementation-defined, indeterminate, and unspecified. This is one of them.</div><br/><div id="37376917" class="c"><input type="checkbox" id="c-37376917" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37376818">parent</a><span>|</span><a href="#37376925">next</a><span>|</span><label class="collapse" for="c-37376917">[-]</label><label class="expand" for="c-37376917">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe it&#x27;s guaranteed to work correctly on any system, because in this code:<p><pre><code>    is-member(i):
    return sparse[i] &lt; n &amp;&amp; dense[sparse[i]] == i
</code></pre>
there&#x27;s no requirement for the two sparse[i] to take the same value (since that expression evaluates to an indeterminate vaule). So the second occurrence of sparse[i] can take a value &gt;=n, or indeed greater than the length of the whole array, at which point reading it is definitely UB.</div><br/><div id="37377438" class="c"><input type="checkbox" id="c-37377438" checked=""/><div class="controls bullet"><span class="by">au8er</span><span>|</span><a href="#37376818">root</a><span>|</span><a href="#37376917">parent</a><span>|</span><a href="#37376925">next</a><span>|</span><label class="collapse" for="c-37377438">[-]</label><label class="expand" for="c-37377438">[1 more]</label></div><br/><div class="children"><div class="content">Would it be better to do<p><pre><code>  sparse_val = sparse[i]
  return sparse_val &lt; n &amp;&amp; dense[sparse_val] == i
</code></pre>
Regardless, we are treading in undefined territory, and the behaviour is not something that can be reliably be dependent upon</div><br/></div></div></div></div></div></div><div id="37376925" class="c"><input type="checkbox" id="c-37376925" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37376818">prev</a><span>|</span><a href="#37360396">next</a><span>|</span><label class="collapse" for="c-37376925">[-]</label><label class="expand" for="c-37376925">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Using Uninitialized Memory for Fun and Profit (2008)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8710557">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8710557</a> - Dec 2014 (17 comments)<p><i>Using Uninitialized Memory for Fun and Profit</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3565212">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3565212</a> - Feb 2012 (14 comments)<p><i>Using Uninitialized Memory for Fun and Profit</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1156628">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1156628</a> - Feb 2010 (16 comments)</div><br/></div></div></div></div></div></div></div></body></html>