<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732698075277" as="style"/><link rel="stylesheet" href="styles.css?v=1732698075277"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://volfpeter.github.io/htmy/">Htmy – Async, pure-Python rendering engine</a> <span class="domain">(<a href="https://volfpeter.github.io">volfpeter.github.io</a>)</span></div><div class="subtext"><span>friendly_deer</span> | <span>27 comments</span></div><br/><div><div id="42253142" class="c"><input type="checkbox" id="c-42253142" checked=""/><div class="controls bullet"><span class="by">keithasaurus</span><span>|</span><a href="#42253229">next</a><span>|</span><label class="collapse" for="c-42253142">[-]</label><label class="expand" for="c-42253142">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a bunch of these kinds of html renderers. Here&#x27;s mine:
<a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;simple-html&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;simple-html&#x2F;</a><p>But there are many others. Not sure I understand the point of async rendering, unless you want to mix IO with rendering? Which feels a bit too close to old PHP+html for my blood.</div><br/><div id="42253917" class="c"><input type="checkbox" id="c-42253917" checked=""/><div class="controls bullet"><span class="by">guidopallemans</span><span>|</span><a href="#42253142">parent</a><span>|</span><a href="#42253229">next</a><span>|</span><label class="collapse" for="c-42253917">[-]</label><label class="expand" for="c-42253917">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with the old PHP+html ways? It&#x27;s one of the best toolchains to knock out a small to medium sized project. I guess that fundamentally, it&#x27;s not scalable at all, or can get messy wrt closing tags and indenting. But with this approach I think you&#x27;re good on both these aspects?</div><br/></div></div></div></div><div id="42253229" class="c"><input type="checkbox" id="c-42253229" checked=""/><div class="controls bullet"><span class="by">rafram</span><span>|</span><a href="#42253142">prev</a><span>|</span><a href="#42253940">next</a><span>|</span><label class="collapse" for="c-42253229">[-]</label><label class="expand" for="c-42253229">[5 more]</label></div><br/><div class="children"><div class="content">Not clear why HTML rendering needed to be infected with async. None of the example code has a clear need for async - even the `is_admin()` method would be a prefetched property in any reasonable database model.</div><br/><div id="42253909" class="c"><input type="checkbox" id="c-42253909" checked=""/><div class="controls bullet"><span class="by">mattigames</span><span>|</span><a href="#42253229">parent</a><span>|</span><a href="#42253903">prev</a><span>|</span><a href="#42253722">next</a><span>|</span><label class="collapse" for="c-42253909">[-]</label><label class="expand" for="c-42253909">[2 more]</label></div><br/><div class="children"><div class="content">Imagine you have 2 big components, one fetches from an third-party API and the other from your backend, this way they can load at the same time instead of sequentially.</div><br/><div id="42253938" class="c"><input type="checkbox" id="c-42253938" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#42253229">root</a><span>|</span><a href="#42253909">parent</a><span>|</span><a href="#42253722">next</a><span>|</span><label class="collapse" for="c-42253938">[-]</label><label class="expand" for="c-42253938">[1 more]</label></div><br/><div class="children"><div class="content">Because checking for two conditions is impossible? This seems like a solution for a non-existent problem. I could be missing something</div><br/></div></div></div></div><div id="42253722" class="c"><input type="checkbox" id="c-42253722" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42253229">parent</a><span>|</span><a href="#42253909">prev</a><span>|</span><a href="#42253940">next</a><span>|</span><label class="collapse" for="c-42253722">[-]</label><label class="expand" for="c-42253722">[1 more]</label></div><br/><div class="children"><div class="content">Your counterpoint still naturally involves something like async _somewhere_ (your proposal is just to move it out of the HTML rendering and into an initial data-gathering stage). If you accept that premise then the question is just where the async code goes.<p>While on some level it makes sense for HTML rendering to be a pure function where the inputs are gathered from elsewhere (potentially asynchronously), it looks like htmy wants to make it easy to define hierarchies of components. Instead of `is_admin()`, imagine a dashboard whose layout is stored in a database, supporting configurable charts of various flavors. The heterogeneity of the data supporting different types of charts makes it hard to efficiently pull data in a single SQL query (equivalently, any reasonable database model), so somewhere in your code you&#x27;re pulling a bunch of data asynchronously, and somewhere else you&#x27;re rendering it. The question, still, is &quot;where?&quot;<p>Going back to the idea of htmy defining hierarchies of components, imagine how annoying it would be to have to manually grab all the data for a &quot;reporting page&quot; component only to feed it straight back into the renderer -- either having to duplicate the hierarchial structure when feeding data into the renderer (a technique some UI libraries employ, though I don&#x27;t like it) -- or having to come up with a method for flattening that hierarchy when instantiating the component (another technique some UI libraries employ, one I like more for small projects and less for large ones).<p>They solve that (to the extent that you think it needs solving) by bundling all that background logic into the components themselves. Did they really need to implement that recursively instead of just walking the hierarchy, gathering the data up-front, and populating it? Eh. The code winds up being similar either way, and either way it definitely forces async back into the middle of HTML rendering.<p>Mind you, that tends to either make some applications hard to build or to cause the framework to explode in complexity over time as people need new and new ways to say &quot;yes, re-render this thing; no, re-render that other thing, but don&#x27;t grab its data, ....&quot; There&#x27;s enough less particularly annoying code involved though that fat, smart components are a natural place for people to gravitate.<p>Unrelated to htmy completely, a technique I like from time to time even for problems which don&#x27;t need async per se (and I&#x27;m usually using lower-level languages, so the implementation is some sort of more manual continuation pattern, but all those things are basically async, so I won&#x27;t dwell on the details) is explicitly designing pausable&#x2F;restartable structures for long-running computations. It&#x27;s about as easy to write as purely iterative code, and you can run the result as purely iterative with no runtime overhead, so the downsides are low. It opens the door though to easily tuning how long you defer invariant maintenance (too infrequent and your algorithm devolves to the slow thing it&#x27;s replacing, too frequent and the overhead isn&#x27;t worth it), easily checkpointing a computation, adding other custom runners for an algorithm (like animating its progress), .... I can absolutely see a use-case for wanting to visualize each step of an HTML rendering, or log OS network counters after each step, and so on. Python&#x27;s async isn&#x27;t really the right tool for the job for that (it&#x27;s hard to modify the runtime to support them without building quite a lot of nonsense from scratch), but async in the abstract isn&#x27;t bad at all per se.</div><br/></div></div></div></div><div id="42253940" class="c"><input type="checkbox" id="c-42253940" checked=""/><div class="controls bullet"><span class="by">azinman2</span><span>|</span><a href="#42253229">prev</a><span>|</span><a href="#42253521">next</a><span>|</span><label class="collapse" for="c-42253940">[-]</label><label class="expand" for="c-42253940">[2 more]</label></div><br/><div class="children"><div class="content">But what do you do use to create dynamic updates on the client side? I’m guessing it still has JS and makes API calls, no? And if so, it seems easier (to me) to just do all of the rendering client side and let the backend just be REST queries.</div><br/><div id="42254247" class="c"><input type="checkbox" id="c-42254247" checked=""/><div class="controls bullet"><span class="by">mattigames</span><span>|</span><a href="#42253940">parent</a><span>|</span><a href="#42253521">next</a><span>|</span><label class="collapse" for="c-42254247">[-]</label><label class="expand" for="c-42254247">[1 more]</label></div><br/><div class="children"><div class="content">This is just the static html renderer, it has no JavaScript to update client side, but the author has another project for fastapi + this + htmx: <a href="https:&#x2F;&#x2F;github.com&#x2F;volfpeter&#x2F;fasthx">https:&#x2F;&#x2F;github.com&#x2F;volfpeter&#x2F;fasthx</a></div><br/></div></div></div></div><div id="42253521" class="c"><input type="checkbox" id="c-42253521" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#42253940">prev</a><span>|</span><a href="#42252961">next</a><span>|</span><label class="collapse" for="c-42253521">[-]</label><label class="expand" for="c-42253521">[1 more]</label></div><br/><div class="children"><div class="content">Oh it&#x27;s server side &quot;rendering&quot;?</div><br/></div></div><div id="42252961" class="c"><input type="checkbox" id="c-42252961" checked=""/><div class="controls bullet"><span class="by">pplante</span><span>|</span><a href="#42253521">prev</a><span>|</span><a href="#42252889">next</a><span>|</span><label class="collapse" for="c-42252961">[-]</label><label class="expand" for="c-42252961">[3 more]</label></div><br/><div class="children"><div class="content">I was looking for something like this a few weeks ago.  I typically use Django and hate the template engines limitations. I needed to make some reusable components and the best option available was switching to jinja to get their macro support, bleh.<p>This reminds me of the best part of Flutter UI composition, but in a language I always return to.<p>Have you done any benchmarking?  I don&#x27;t even know what the comparison would be.</div><br/><div id="42253893" class="c"><input type="checkbox" id="c-42253893" checked=""/><div class="controls bullet"><span class="by">kissgyorgy</span><span>|</span><a href="#42252961">parent</a><span>|</span><a href="#42253426">next</a><span>|</span><label class="collapse" for="c-42253893">[-]</label><label class="expand" for="c-42253893">[1 more]</label></div><br/><div class="children"><div class="content">Check this out: <a href="https:&#x2F;&#x2F;compone.kissgyorgy.me&#x2F;" rel="nofollow">https:&#x2F;&#x2F;compone.kissgyorgy.me&#x2F;</a><p>Much simpler than this library, components are simply functions, rendered to strings.<p>I made one microbenchmark, it&#x27;s &quot;only&quot; 2x slower than Jinja2 right now, but I know how to make it faster.</div><br/></div></div><div id="42253426" class="c"><input type="checkbox" id="c-42253426" checked=""/><div class="controls bullet"><span class="by">neeleshs</span><span>|</span><a href="#42252961">parent</a><span>|</span><a href="#42253893">prev</a><span>|</span><a href="#42252889">next</a><span>|</span><label class="collapse" for="c-42253426">[-]</label><label class="expand" for="c-42253426">[1 more]</label></div><br/><div class="children"><div class="content">You might want to look at django-cotton for components</div><br/></div></div></div></div><div id="42252889" class="c"><input type="checkbox" id="c-42252889" checked=""/><div class="controls bullet"><span class="by">throwaway314155</span><span>|</span><a href="#42252961">prev</a><span>|</span><a href="#42252935">next</a><span>|</span><label class="collapse" for="c-42252889">[-]</label><label class="expand" for="c-42252889">[1 more]</label></div><br/><div class="children"><div class="content">Looks great. Anyone using this in production?</div><br/></div></div><div id="42252935" class="c"><input type="checkbox" id="c-42252935" checked=""/><div class="controls bullet"><span class="by">ddanieltan</span><span>|</span><a href="#42252889">prev</a><span>|</span><a href="#42252954">next</a><span>|</span><label class="collapse" for="c-42252935">[-]</label><label class="expand" for="c-42252935">[1 more]</label></div><br/><div class="children"><div class="content">How does this compare with FastHTML?</div><br/></div></div><div id="42252954" class="c"><input type="checkbox" id="c-42252954" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#42252935">prev</a><span>|</span><a href="#42253273">next</a><span>|</span><label class="collapse" for="c-42252954">[-]</label><label class="expand" for="c-42252954">[1 more]</label></div><br/><div class="children"><div class="content">Would love to see some benchmarks for all these libraries that compare them to Jinja2.</div><br/></div></div><div id="42253273" class="c"><input type="checkbox" id="c-42253273" checked=""/><div class="controls bullet"><span class="by">jackson928</span><span>|</span><a href="#42252954">prev</a><span>|</span><a href="#42252986">next</a><span>|</span><label class="collapse" for="c-42253273">[-]</label><label class="expand" for="c-42253273">[1 more]</label></div><br/><div class="children"><div class="content">Looks similar to a framework I&#x27;ve been using for some personal sites reflex.dev, pretty cool when would you recommend using this over that?</div><br/></div></div><div id="42252986" class="c"><input type="checkbox" id="c-42252986" checked=""/><div class="controls bullet"><span class="by">dcreater</span><span>|</span><a href="#42253273">prev</a><span>|</span><a href="#42254143">next</a><span>|</span><label class="collapse" for="c-42252986">[-]</label><label class="expand" for="c-42252986">[4 more]</label></div><br/><div class="children"><div class="content">Is there a comparison or guide to choosing python frameworks? Every few weeks there&#x27;s a new one posted here</div><br/><div id="42253345" class="c"><input type="checkbox" id="c-42253345" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#42252986">parent</a><span>|</span><a href="#42253529">next</a><span>|</span><label class="collapse" for="c-42253345">[-]</label><label class="expand" for="c-42253345">[1 more]</label></div><br/><div class="children"><div class="content">In the real world, for web things, people use django or fastapi. I&#x27;d suggest picking a project with lots of stackoverflow questions and poking around their docs to see which makes you the most comfortable. Personally I tend to favor litestar these days since it has good docs and issues don&#x27;t sit around for years waiting on one dude to merge prs (fastapi) and it&#x27;s a lot nicer than django (and I hate django docs).<p>Flask&#x2F;quart are painful to work with due to horrible documentation in my experience, but they&#x27;re popular too. Quart is just an async rewrite of flask by the same owners.<p>Litestar has a half baked comparison chart here: <a href="https:&#x2F;&#x2F;docs.litestar.dev&#x2F;latest&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.litestar.dev&#x2F;latest&#x2F;</a></div><br/></div></div><div id="42253529" class="c"><input type="checkbox" id="c-42253529" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42252986">parent</a><span>|</span><a href="#42253345">prev</a><span>|</span><a href="#42254143">next</a><span>|</span><label class="collapse" for="c-42253529">[-]</label><label class="expand" for="c-42253529">[2 more]</label></div><br/><div class="children"><div class="content">I think the “rule of thumb” is that none of them are better than using HTMX with templates. HTMX obviously having some limits in terms of security and complex REBAC.</div><br/><div id="42253660" class="c"><input type="checkbox" id="c-42253660" checked=""/><div class="controls bullet"><span class="by">LaundroMat</span><span>|</span><a href="#42252986">root</a><span>|</span><a href="#42253529">parent</a><span>|</span><a href="#42254143">next</a><span>|</span><label class="collapse" for="c-42253660">[-]</label><label class="expand" for="c-42253660">[1 more]</label></div><br/><div class="children"><div class="content">Or Unpoly. I&#x27;ve been working with it for a month now and it&#x27;s a real pity such a robust library it gets so little attention.</div><br/></div></div></div></div></div></div><div id="42254143" class="c"><input type="checkbox" id="c-42254143" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#42252986">prev</a><span>|</span><a href="#42253828">next</a><span>|</span><label class="collapse" for="c-42254143">[-]</label><label class="expand" for="c-42254143">[1 more]</label></div><br/><div class="children"><div class="content">Yet another lib you can replace with any backend framework and htmx.</div><br/></div></div><div id="42253828" class="c"><input type="checkbox" id="c-42253828" checked=""/><div class="controls bullet"><span class="by">eddautomates</span><span>|</span><a href="#42254143">prev</a><span>|</span><label class="collapse" for="c-42253828">[-]</label><label class="expand" for="c-42253828">[4 more]</label></div><br/><div class="children"><div class="content">I think in almost-2025 any dataclass heavy library should probably use pydantic (or support it)</div><br/><div id="42253986" class="c"><input type="checkbox" id="c-42253986" checked=""/><div class="controls bullet"><span class="by">franga2000</span><span>|</span><a href="#42253828">parent</a><span>|</span><a href="#42253911">next</a><span>|</span><label class="collapse" for="c-42253986">[-]</label><label class="expand" for="c-42253986">[2 more]</label></div><br/><div class="children"><div class="content">Please don&#x27;t! Pydantic demands 100% type correctness at runtime in a language that can&#x27;t guarantee basically anything at &quot;compile&quot; (lint) time. Screw up one type annotation for one edge case and your entire system turns into one big ValidationError.<p>Dataclasses let you return &quot;incorrect&quot; data and that&#x27;s a good thing. I&#x27;d rather get an unexpected None here and there (which can be handled) than have library code crash because the wrong type snuck into a field I don&#x27;t even care about.<p>As for support, is any explicit support needed? You can Pydantic models into things expecting dataclasses and often the other way around too.</div><br/><div id="42254035" class="c"><input type="checkbox" id="c-42254035" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#42253828">root</a><span>|</span><a href="#42253986">parent</a><span>|</span><a href="#42253911">next</a><span>|</span><label class="collapse" for="c-42254035">[-]</label><label class="expand" for="c-42254035">[1 more]</label></div><br/><div class="children"><div class="content">Spoken  like a true dynamic  types programmer.  Some programmers prefer having errors over these surprises.</div><br/></div></div></div></div><div id="42253911" class="c"><input type="checkbox" id="c-42253911" checked=""/><div class="controls bullet"><span class="by">tirpen</span><span>|</span><a href="#42253828">parent</a><span>|</span><a href="#42253986">prev</a><span>|</span><label class="collapse" for="c-42253911">[-]</label><label class="expand" for="c-42253911">[1 more]</label></div><br/><div class="children"><div class="content">Probably, but I fail to see how that&#x27;s relevant here.  
This is not a &quot;dataclass heavy&quot; library in any sense, they just used dataclass in the examples to make them shorter.<p>Based on everything I see in the documentation, you should be able to use Pydantic models as well, or standard python objects, or anything else, as long as it has a method `def htmy(self, context: Context) -&gt; Component`.</div><br/></div></div></div></div></div></div></div></div></div></body></html>