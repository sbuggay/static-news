<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691139660200" as="style"/><link rel="stylesheet" href="styles.css?v=1691139660200"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ziglang.org/download/0.11.0/release-notes.html">Zig 0.11</a> <span class="domain">(<a href="https://ziglang.org">ziglang.org</a>)</span></div><div class="subtext"><span>tauoverpi</span> | <span>108 comments</span></div><br/><div><div id="36996069" class="c"><input type="checkbox" id="c-36996069" checked=""/><div class="controls bullet"><span class="by">pid-1</span><span>|</span><a href="#36996349">next</a><span>|</span><label class="collapse" for="c-36996069">[-]</label><label class="expand" for="c-36996069">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Backed by the Zig Software Foundation, the project is financially sustainable. These core team members are paid for their time: (lists five people)<p>That&#x27;s quite impressive. For comparison, Python had 2 full time paid devs in 2019 (not sure about now).</div><br/><div id="36996957" class="c"><input type="checkbox" id="c-36996957" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#36996069">parent</a><span>|</span><a href="#36996751">next</a><span>|</span><label class="collapse" for="c-36996957">[-]</label><label class="expand" for="c-36996957">[1 more]</label></div><br/><div class="children"><div class="content">I suspect some of this comes down to how larger donations are made. For Python they have often had people working at companies donating time on their employers books to the development of it.<p>GVR for example works for Microsoft and has worked at Dropbox and other places, but spends much of his time on Python. So he isn&#x27;t listed as an employee of the foundation, but at times is full time.<p>If a company donates employee time they have more influence on the project than donating cash to pay for development.<p>The fact that Zig had the cash donation to do it this way is brilliant, and probably a better model.</div><br/></div></div><div id="36996751" class="c"><input type="checkbox" id="c-36996751" checked=""/><div class="controls bullet"><span class="by">kristoff_it</span><span>|</span><a href="#36996069">parent</a><span>|</span><a href="#36996957">prev</a><span>|</span><a href="#36996819">next</a><span>|</span><label class="collapse" for="c-36996751">[-]</label><label class="expand" for="c-36996751">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re also pretty efficient, more than 90% of the donated money is used to pay developers (the rest goes to administrative costs, CI infrastructure, etc).</div><br/></div></div><div id="36996819" class="c"><input type="checkbox" id="c-36996819" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#36996069">parent</a><span>|</span><a href="#36996751">prev</a><span>|</span><a href="#36996309">next</a><span>|</span><label class="collapse" for="c-36996819">[-]</label><label class="expand" for="c-36996819">[1 more]</label></div><br/><div class="children"><div class="content">More important than the number is that the foundation actually pays the core developers.  Python suffers from having almost exclusively volunteer work and those volunteers often are not interested in solving the problems of the foundation or community (eg: packaging etc.).<p>The most the PSF could do is “bolt on” a developer to solve packaging in yet another non embraced and supported way.</div><br/></div></div></div></div><div id="36996349" class="c"><input type="checkbox" id="c-36996349" checked=""/><div class="controls bullet"><span class="by">yla92</span><span>|</span><a href="#36996069">prev</a><span>|</span><a href="#36996968">next</a><span>|</span><label class="collapse" for="c-36996349">[-]</label><label class="expand" for="c-36996349">[1 more]</label></div><br/><div class="children"><div class="content">The Async&#x2F;Await didn&#x27;t make it into this release[0] but hopefully by the next one!<p>[0]: <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;news&#x2F;0.11.0-postponed-again&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ziglang.org&#x2F;news&#x2F;0.11.0-postponed-again&#x2F;</a></div><br/></div></div><div id="36996968" class="c"><input type="checkbox" id="c-36996968" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#36996349">prev</a><span>|</span><a href="#36996355">next</a><span>|</span><label class="collapse" for="c-36996968">[-]</label><label class="expand" for="c-36996968">[2 more]</label></div><br/><div class="children"><div class="content">I enjoy seeing an update or discussion of things like D, Zig, Nim (and a few others I probably forgot) but I honestly can&#x27;t keep track of where they are in relation to C&#x2F;C++, C#&#x2F;Objective-C, and Rust.<p>Is there are chart or a &quot;are we xxxx yet&quot; page one can reference?</div><br/><div id="36997016" class="c"><input type="checkbox" id="c-36997016" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#36996968">parent</a><span>|</span><a href="#36996355">next</a><span>|</span><label class="collapse" for="c-36997016">[-]</label><label class="expand" for="c-36997016">[1 more]</label></div><br/><div class="children"><div class="content">IMHO this is still the most important page to get an idea what the current state of Zig is and how it changed over time:<p><a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;0.11.0&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;0.11.0&#x2F;</a></div><br/></div></div></div></div><div id="36996355" class="c"><input type="checkbox" id="c-36996355" checked=""/><div class="controls bullet"><span class="by">captainhorst</span><span>|</span><a href="#36996968">prev</a><span>|</span><a href="#36996163">next</a><span>|</span><label class="collapse" for="c-36996355">[-]</label><label class="expand" for="c-36996355">[1 more]</label></div><br/><div class="children"><div class="content">Their biggest release in terms of issues closed: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;milestones?state=closed">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;milestones?state=closed</a>
1012 in less than 8 months. What an amazing feat.</div><br/></div></div><div id="36996163" class="c"><input type="checkbox" id="c-36996163" checked=""/><div class="controls bullet"><span class="by">tarcio</span><span>|</span><a href="#36996355">prev</a><span>|</span><a href="#36996546">next</a><span>|</span><label class="collapse" for="c-36996163">[-]</label><label class="expand" for="c-36996163">[32 more]</label></div><br/><div class="children"><div class="content">What are the use cases for zig? The website says general purpose and tool chain but people who have used it, what it excels at?</div><br/><div id="36996330" class="c"><input type="checkbox" id="c-36996330" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36996378">next</a><span>|</span><label class="collapse" for="c-36996330">[-]</label><label class="expand" for="c-36996330">[12 more]</label></div><br/><div class="children"><div class="content">My understanding is that Zig has all of the power and modernity of Rust, without the strictness and borrow checker. Unlike Rust, it also has powerful compile-time evaluation and custom allocators, and probably more improvements I&#x27;m not familiar with (in Rust you can effectively emulate custom allocators, but you have to rewrite every allocating structure to use them; or you can use nightly, but most third-party library and even some standard-library types don&#x27;t support them).<p>I also heard someone say &quot;Zig is to C what Rust is to C++&quot;. Which I interpret as, it&#x27;s another maximum-performance modern language, but smaller than Rust; &quot;smaller&quot; meaning that it has less safety and <i>also</i> abstraction (no encapsulation [1]), but less requirements and complexity.<p>Particularly with games, many devs want to build a working prototype really fast and then iterate fast. They don&#x27;t want to deal with the borrow checker especially if their code has a lot of complex lifetime rules (and the borrow checker is a real issue; it caused evanw to switch esbuild to Go [1]).  In small scripts with niche uses, safety and architecture are a waste of effort, the script just has to be <i>done</i> and <i>work</i> (and the latter is only partly necessary, because the script may not even be fed enough inputs to cover edge cases). Plus, there are plenty of projects where custom allocation is especially important, and having every type support custom allocation is a big help vs. having to rewrite every type yourself or use `no_std` variants.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;2974">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;2974</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;evanw&#x2F;esbuild&#x2F;issues&#x2F;189#issuecomment-647024185">https:&#x2F;&#x2F;github.com&#x2F;evanw&#x2F;esbuild&#x2F;issues&#x2F;189#issuecomment-647...</a></div><br/><div id="36996524" class="c"><input type="checkbox" id="c-36996524" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996330">parent</a><span>|</span><a href="#36996462">next</a><span>|</span><label class="collapse" for="c-36996524">[-]</label><label class="expand" for="c-36996524">[6 more]</label></div><br/><div class="children"><div class="content">&gt;My understanding is that Zig has all of the power and modernity of Rust, without the strictness and borrow checker.<p>This is an oxymoron :) The strictness and borrow checker are part of the power and modernity of Rust.<p>But even apart from that, Rust has automatic value-based destructors (destructor follows the value as it&#x27;s moved across scopes and is only called in the final scope), whereas Zig only has scope-based destructors (defer) and you need to remember to write them and ensure they&#x27;re called exactly once per value. Rust has properly composable Option&#x2F;Result monads, whereas Zig has special-cased ! and ? which don&#x27;t compose (no Option of Option or Result of Result) but do benefit from nice built-in syntax due to their special-cased-ness. Rust has typed errors whereas Zig only has integers, though again that allows Zig to have much simpler syntax for defining arbitary error sets which would require defining a combinatorial explosion of enums in Rust.<p>Of course from Zig&#x27;s point-of-view these are features, not deficiences, which is completely understandable given what kind of language it wants to be. And the other advantages you listed like comptime (Rust&#x27;s const-eval is very constrained and has been WIP for ages) and custom allocator support from day 1 (the way Rust is bolting it on will make most existing code unusable with custom allocators, including parts of Rust&#x27;s own standard library) are indeed good advantages. Zig also has very nice syntax unification - generic types are type constructor functions fn(type) -&gt; type, modules are structs, etc.<p>I hope that one day we&#x27;ll have a language that combines the best of Rust&#x27;s strictness and Zig&#x27;s comptime and syntax.</div><br/><div id="36996986" class="c"><input type="checkbox" id="c-36996986" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996524">parent</a><span>|</span><a href="#36996752">next</a><span>|</span><label class="collapse" for="c-36996986">[-]</label><label class="expand" for="c-36996986">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rust has properly composable Option&#x2F;Result monads, whereas Zig has special-cased ! and ? which don&#x27;t compose (no Option of Option or Result of Result)<p>?!!??u32 is a perfectly cromulent type in Zig.</div><br/><div id="36997313" class="c"><input type="checkbox" id="c-36997313" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996986">parent</a><span>|</span><a href="#36996752">next</a><span>|</span><label class="collapse" for="c-36997313">[-]</label><label class="expand" for="c-36997313">[1 more]</label></div><br/><div class="children"><div class="content">How do you express the difference between None and Some(None) in Zig?</div><br/></div></div></div></div><div id="36996752" class="c"><input type="checkbox" id="c-36996752" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996524">parent</a><span>|</span><a href="#36996986">prev</a><span>|</span><a href="#36996462">next</a><span>|</span><label class="collapse" for="c-36996752">[-]</label><label class="expand" for="c-36996752">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Rust&#x27;s const-eval is very constrained and has been WIP for ages<p>Having strong backwards compatibility does that to the language, alternative is arguably worse (see Python 2 vs 3).</div><br/><div id="36996900" class="c"><input type="checkbox" id="c-36996900" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996752">parent</a><span>|</span><a href="#36996462">next</a><span>|</span><label class="collapse" for="c-36996900">[-]</label><label class="expand" for="c-36996900">[2 more]</label></div><br/><div class="children"><div class="content">Yes, and I don&#x27;t want a backward-incompatible Rust 2.0 either, but the slowness of stabilizing ! (named for when it&#x27;s going to be stabilized), specialization, TAIT, const-eval, Vec::drain_filter, *Map::raw_entry, ... is annoying. Also the lack of TAIT currently causes actual inefficiency when it comes to async traits, because currently async trait methods have to return allocated virtualized futures instead of concrete types. Same for Map::raw_entry, without which you have to either do two lookups (`.get()` + `.entry()`) or always create an owned key even if the entry already exists (`.entry(key.to_owned())`).</div><br/><div id="36997256" class="c"><input type="checkbox" id="c-36997256" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996900">parent</a><span>|</span><a href="#36996462">next</a><span>|</span><label class="collapse" for="c-36997256">[-]</label><label class="expand" for="c-36997256">[1 more]</label></div><br/><div class="children"><div class="content">If you think, that&#x27;s bad, look at C&#x2F;C++ standardization bodies, where stuff is eternally blocked because ABI compatibility.<p>---<p>Problem is lots of implementation things are vying for inclusion. And many thing people want aren&#x27;t safe or block&#x2F;are blocked by possible future changes.<p>For example default&#x2F;named arguments were blocked by ambiguity in parsing when it comes to type ascription iirc. And not having default arguments makes adding allocator quite more cumbersome.<p>Plus Rust maintainers are seeing some common patterns and are trying to abstract over them - like keyword generics&#x2F; effect system. If they don&#x27;t hit right abstraction now, things will be much more harder later. If they over abstract, its extremly hard to remove it.</div><br/></div></div></div></div></div></div></div></div><div id="36996462" class="c"><input type="checkbox" id="c-36996462" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996330">parent</a><span>|</span><a href="#36996524">prev</a><span>|</span><a href="#36996378">next</a><span>|</span><label class="collapse" for="c-36996462">[-]</label><label class="expand" for="c-36996462">[5 more]</label></div><br/><div class="children"><div class="content">Also none of the common knowledge around traditional data-structures and algorithms work with Rust anyways. One needs to dance like a ballerina with their hands and feet tied.</div><br/><div id="36996552" class="c"><input type="checkbox" id="c-36996552" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996462">parent</a><span>|</span><a href="#36996378">next</a><span>|</span><label class="collapse" for="c-36996552">[-]</label><label class="expand" for="c-36996552">[4 more]</label></div><br/><div class="children"><div class="content">“Linked lists are hard” is not “none of the common knowledge around traditional data-structures and algorithms work”.</div><br/><div id="36996710" class="c"><input type="checkbox" id="c-36996710" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996552">parent</a><span>|</span><a href="#36996998">next</a><span>|</span><label class="collapse" for="c-36996710">[-]</label><label class="expand" for="c-36996710">[1 more]</label></div><br/><div class="children"><div class="content">Ever tried to implement generic trees in Rust?</div><br/></div></div><div id="36996998" class="c"><input type="checkbox" id="c-36996998" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996552">parent</a><span>|</span><a href="#36996710">prev</a><span>|</span><a href="#36996378">next</a><span>|</span><label class="collapse" for="c-36996998">[-]</label><label class="expand" for="c-36996998">[2 more]</label></div><br/><div class="children"><div class="content">I retort that almost all of the concurrent data structures are obnoxious to represent in Rust.<p>A lock-free ConcurrentHashMap, for example, is by no means a straightforward data structure in a non-GC language.  Even if you somehow dodge Rust&#x27;s pedantry, you <i>still</i> have to figure out who owns what, who pays for what and when they pay for it--and there are multiple valid choices!<p>Non-GC allocation&#x2F;deallocation in concurrent data structures probably still qualifies as a solid CS problem.<p>(And, before you point me to your favorite crate for ConcurrentHashMap, please check it&#x27;s guarantees when one process needs to iterate across keys while another process simultaneously is inserting&#x2F;deleting elements.  You will be shocked at how many of them need to pull a lock--so much for lock-free.)</div><br/><div id="36997208" class="c"><input type="checkbox" id="c-36997208" checked=""/><div class="controls bullet"><span class="by">richardwhiuk</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996998">parent</a><span>|</span><a href="#36996378">next</a><span>|</span><label class="collapse" for="c-36997208">[-]</label><label class="expand" for="c-36997208">[1 more]</label></div><br/><div class="children"><div class="content">You should always know who owns some data, even if you aren&#x27;t using Rust!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36996378" class="c"><input type="checkbox" id="c-36996378" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36996330">prev</a><span>|</span><a href="#36996279">next</a><span>|</span><label class="collapse" for="c-36996378">[-]</label><label class="expand" for="c-36996378">[8 more]</label></div><br/><div class="children"><div class="content">As someone who used C as main language, I&#x27;ve switched to zig. It&#x27;s the only language that tries to be &quot;better C&quot;, and not another C++. Comptime being like Nim where it&#x27;s not entirely own language is also plus. I&#x27;d say it excels at general purpose system programming, and especially if you need to work with memory in detailed way (rust makes this very annoying and hard).</div><br/><div id="36996619" class="c"><input type="checkbox" id="c-36996619" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996378">parent</a><span>|</span><a href="#36996843">next</a><span>|</span><label class="collapse" for="c-36996619">[-]</label><label class="expand" for="c-36996619">[4 more]</label></div><br/><div class="children"><div class="content">What advantages does Zig have over C?</div><br/><div id="36996756" class="c"><input type="checkbox" id="c-36996756" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996619">parent</a><span>|</span><a href="#36996854">next</a><span>|</span><label class="collapse" for="c-36996756">[-]</label><label class="expand" for="c-36996756">[1 more]</label></div><br/><div class="children"><div class="content">- comptime, so writing compile time evaluating code, without introducing its own meta language like macros or templates.<p>- very solid build system (the build config file(s) are written in zig so you dont have to learn another language for the build system (looking at you, makefile)) that has crosscompilation builtin (with one compiler flag)<p>- language level errors, like, errors as first class citizens. forces you to handle errors, but without much mental or syntactic overhead (you can re-throw them with `try myfunction()`), also results in a unified interface<p>- no implicit conversions<p>- looks high-level (modern sytnax that is easy(ish) to parse) but as low level (or lower) than C, no abstractions that hide details you need to know about when programming (similar to C)<p>- C interop, so you can just add zig source files to a C project and compile it all with the zig toolchain. Zig can also parse c headers and source files and convert them, so you can include c headers and just start calling functions from there. For example, using SDL is as simple as pointing the toolchain to the SDL headers and .so file, and the sdl headers will be translated to zig on the fly so you can start with SDL.SDL_CreateWindow right away.</div><br/></div></div><div id="36996854" class="c"><input type="checkbox" id="c-36996854" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996619">parent</a><span>|</span><a href="#36996756">prev</a><span>|</span><a href="#36996768">next</a><span>|</span><label class="collapse" for="c-36996854">[-]</label><label class="expand" for="c-36996854">[1 more]</label></div><br/><div class="children"><div class="content">Just to name one: compile time code execution. It eliminates the need for a separate macro language and provides Zig zero cost generic types.<p>Not to mention memory leak detection, crazy fast compilation times, slices and a built in C compiler so your code can seamlessly integrate with an existing C code base (seriously no wrapper needed).<p>Zig is really really awesome. The only thing holding it back from mass adoption right now is that it&#x27;s not finished yet, and that shows in the minimal documentation. That said, if you&#x27;re comfortable tinkering, it&#x27;s completely capable of production uses (and is already used in production in various companies).</div><br/></div></div><div id="36996768" class="c"><input type="checkbox" id="c-36996768" checked=""/><div class="controls bullet"><span class="by">kristoff_it</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996619">parent</a><span>|</span><a href="#36996854">prev</a><span>|</span><a href="#36996843">next</a><span>|</span><label class="collapse" for="c-36996768">[-]</label><label class="expand" for="c-36996768">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;ziglang.org&#x2F;learn&#x2F;overview&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ziglang.org&#x2F;learn&#x2F;overview&#x2F;</a></div><br/></div></div></div></div><div id="36996843" class="c"><input type="checkbox" id="c-36996843" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996378">parent</a><span>|</span><a href="#36996619">prev</a><span>|</span><a href="#36996279">next</a><span>|</span><label class="collapse" for="c-36996843">[-]</label><label class="expand" for="c-36996843">[3 more]</label></div><br/><div class="children"><div class="content">I thought Go tried to be better C</div><br/><div id="36997122" class="c"><input type="checkbox" id="c-36997122" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996843">parent</a><span>|</span><a href="#36997066">next</a><span>|</span><label class="collapse" for="c-36997122">[-]</label><label class="expand" for="c-36997122">[1 more]</label></div><br/><div class="children"><div class="content">It kind of is, for anyone without bias against languages that have a GC.<p>However they could at least support some kind of enumerations, one of the things they definitly aren&#x27;t a better C.</div><br/></div></div><div id="36997066" class="c"><input type="checkbox" id="c-36997066" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996843">parent</a><span>|</span><a href="#36997122">prev</a><span>|</span><a href="#36996279">next</a><span>|</span><label class="collapse" for="c-36997066">[-]</label><label class="expand" for="c-36997066">[1 more]</label></div><br/><div class="children"><div class="content">Why should there only be one &quot;better C&quot;? Go has a very different philosophy than Zig, but both can be considered a &quot;better C&quot;.</div><br/></div></div></div></div></div></div><div id="36996279" class="c"><input type="checkbox" id="c-36996279" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36996378">prev</a><span>|</span><a href="#36996303">next</a><span>|</span><label class="collapse" for="c-36996279">[-]</label><label class="expand" for="c-36996279">[2 more]</label></div><br/><div class="children"><div class="content">Being Modula-2 like (in safety), with a syntax that is more appealing to C minded folks, with nice compile time execution support.</div><br/><div id="36996478" class="c"><input type="checkbox" id="c-36996478" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996279">parent</a><span>|</span><a href="#36996303">next</a><span>|</span><label class="collapse" for="c-36996478">[-]</label><label class="expand" for="c-36996478">[1 more]</label></div><br/><div class="children"><div class="content">I think this is one of the best short description of Zig.</div><br/></div></div></div></div><div id="36996303" class="c"><input type="checkbox" id="c-36996303" checked=""/><div class="controls bullet"><span class="by">tauoverpi</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36996279">prev</a><span>|</span><a href="#36996200">next</a><span>|</span><label class="collapse" for="c-36996303">[-]</label><label class="expand" for="c-36996303">[1 more]</label></div><br/><div class="children"><div class="content">A game engine <a href="https:&#x2F;&#x2F;machengine.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;machengine.org</a> is being written in zig, there&#x27;s also <a href="https:&#x2F;&#x2F;microzig.tech" rel="nofollow noreferrer">https:&#x2F;&#x2F;microzig.tech</a> as zig is well suited to embedded development.</div><br/></div></div><div id="36996200" class="c"><input type="checkbox" id="c-36996200" checked=""/><div class="controls bullet"><span class="by">johnnypangs</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36996303">prev</a><span>|</span><a href="#36996989">next</a><span>|</span><label class="collapse" for="c-36996200">[-]</label><label class="expand" for="c-36996200">[2 more]</label></div><br/><div class="children"><div class="content">Bun, a JavaScript runtime (uses WebKit as an engine I believe) is written in Zig. They seem to be doing alright:<p><a href="https:&#x2F;&#x2F;bun.sh&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bun.sh&#x2F;</a></div><br/><div id="36996583" class="c"><input type="checkbox" id="c-36996583" checked=""/><div class="controls bullet"><span class="by">BigJ1211</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996200">parent</a><span>|</span><a href="#36996989">next</a><span>|</span><label class="collapse" for="c-36996583">[-]</label><label class="expand" for="c-36996583">[1 more]</label></div><br/><div class="children"><div class="content">It uses JavaScriptCore, which was written for Safari. It&#x27;s supposedly faster than V8, but harder to work with.</div><br/></div></div></div></div><div id="36996989" class="c"><input type="checkbox" id="c-36996989" checked=""/><div class="controls bullet"><span class="by">cztomsik</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36996200">prev</a><span>|</span><a href="#36996238">next</a><span>|</span><label class="collapse" for="c-36996989">[-]</label><label class="expand" for="c-36996989">[3 more]</label></div><br/><div class="children"><div class="content">1. It&#x27;s typically at least as fast as C, unlike C++&#x2F;Rust<p>2. You can do type introspection (and switching) during compile-time, and it&#x27;s not just some stupid TokenStream transformer, you really have type information available, you can do if&#x2F;else on the presence of methods, etc.<p>3. There are no generics, but your functions can accept anytype, which is still type-safe. See <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;9c05810be60756e07bd7fee09633671bbaa8cda6&#x2F;lib&#x2F;std&#x2F;math.zig#L263">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;9c05810be60756e07bd7fee0...</a> and note the return type is &quot;computed&quot; from the type of the input.<p>4. Types are first-class values (during comptime), so any function can take or return a new type, this is how you get generic types, without (syntax&#x2F;checking) support for generics.<p>5. You can easily call anything which does not allocate in these comptime blocks.<p>6. There&#x27;s @compileError which you can use for custom type assertions -&gt; therefore, you have programmable type-system.<p>7. It&#x27;s super-easy to call C from Zig.<p>8. This is subjective: You don&#x27;t feel bad about using pointers. Linked data structures are fine.</div><br/><div id="36997128" class="c"><input type="checkbox" id="c-36997128" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36996989">parent</a><span>|</span><a href="#36996238">next</a><span>|</span><label class="collapse" for="c-36997128">[-]</label><label class="expand" for="c-36997128">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 1. It&#x27;s typically at least as fast as C, unlike C++&#x2F;Rust<p>The typical urban myth that never comes with profiler proofs.</div><br/><div id="36997303" class="c"><input type="checkbox" id="c-36997303" checked=""/><div class="controls bullet"><span class="by">cztomsik</span><span>|</span><a href="#36996163">root</a><span>|</span><a href="#36997128">parent</a><span>|</span><a href="#36996238">next</a><span>|</span><label class="collapse" for="c-36997303">[-]</label><label class="expand" for="c-36997303">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t need to prove you anything. Go and give it a try yourself.</div><br/></div></div></div></div></div></div><div id="36996238" class="c"><input type="checkbox" id="c-36996238" checked=""/><div class="controls bullet"><span class="by">skavi</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36996989">prev</a><span>|</span><a href="#36997068">next</a><span>|</span><label class="collapse" for="c-36996238">[-]</label><label class="expand" for="c-36996238">[1 more]</label></div><br/><div class="children"><div class="content">A fancy new database is written in Zig: <a href="https:&#x2F;&#x2F;tigerbeetle.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tigerbeetle.com&#x2F;</a></div><br/></div></div><div id="36997068" class="c"><input type="checkbox" id="c-36997068" checked=""/><div class="controls bullet"><span class="by">mattdesl</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36996238">prev</a><span>|</span><a href="#36996956">next</a><span>|</span><label class="collapse" for="c-36997068">[-]</label><label class="expand" for="c-36997068">[1 more]</label></div><br/><div class="children"><div class="content">Fast and compact WASM builds are builtin to Zig&#x27;s toolchain:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mattdesl&#x2F;wasm-bench">https:&#x2F;&#x2F;github.com&#x2F;mattdesl&#x2F;wasm-bench</a></div><br/></div></div><div id="36996956" class="c"><input type="checkbox" id="c-36996956" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#36996163">parent</a><span>|</span><a href="#36997068">prev</a><span>|</span><a href="#36996546">next</a><span>|</span><label class="collapse" for="c-36996956">[-]</label><label class="expand" for="c-36996956">[1 more]</label></div><br/><div class="children"><div class="content">Zig has a decent chance of being an actual embedded device (ie. no operating system) programming language.<p>In my opinion, Zig seems likely to grow the necessary bits to be good at embedded while Rust is unlikely to figure out how to shrug off the clanky bits that make it a poor fit for embedded devices.<p>However, I&#x27;m a personal believer that the future is polyglot.  We&#x27;re just at the beginning of shrugging off the C ABI that has been preventing useful interoperability for decades.<p>Once that happens, I can use Rust for the parts that Rust is good for and Zig for the parts that Zig is good for.</div><br/></div></div></div></div><div id="36996546" class="c"><input type="checkbox" id="c-36996546" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996163">prev</a><span>|</span><a href="#36996671">next</a><span>|</span><label class="collapse" for="c-36996546">[-]</label><label class="expand" for="c-36996546">[41 more]</label></div><br/><div class="children"><div class="content">Zig is not memory safe and therefore at risk, just like C&#x2F;C++, of future government legislation that outlaws the use of memory unsafe languages for some or all projects. The risk of such legislation is not insignificant: <a href="https:&#x2F;&#x2F;www.itpro.com&#x2F;development&#x2F;programming-languages&#x2F;369499&#x2F;move-away-from-memory-unsafe-languages-c" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.itpro.com&#x2F;development&#x2F;programming-languages&#x2F;3694...</a><p>Personally I do not see the point of building an entirely new language and ecosystem that does not fully address this issue.</div><br/><div id="36996689" class="c"><input type="checkbox" id="c-36996689" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36996931">next</a><span>|</span><label class="collapse" for="c-36996689">[-]</label><label class="expand" for="c-36996689">[7 more]</label></div><br/><div class="children"><div class="content">the united states government is not going to outlaw the use of memory unsafe languages. that is an absurd idea. nothing in your links suggests they would even consider it. &quot;moving the culture of software development&quot; to memory safe language does not mean &quot;we want to put you in jail for writing C&quot;.</div><br/><div id="36997009" class="c"><input type="checkbox" id="c-36997009" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996689">parent</a><span>|</span><a href="#36996742">next</a><span>|</span><label class="collapse" for="c-36997009">[-]</label><label class="expand" for="c-36997009">[1 more]</label></div><br/><div class="children"><div class="content">No, however it may require that like with other kinds of dangerous chemicals, or hazourds goods, their use must follow strict requirements, like they already have to for high integrity computing.</div><br/></div></div><div id="36996742" class="c"><input type="checkbox" id="c-36996742" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996689">parent</a><span>|</span><a href="#36997009">prev</a><span>|</span><a href="#36996952">next</a><span>|</span><label class="collapse" for="c-36996742">[-]</label><label class="expand" for="c-36996742">[3 more]</label></div><br/><div class="children"><div class="content">Where did you get the idea that jails are involved? Governments are clearly forming a position, if they fund new projects, they are quite likely to enforce that position. That&#x27;s a significant market already.</div><br/><div id="36996876" class="c"><input type="checkbox" id="c-36996876" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996742">parent</a><span>|</span><a href="#36996952">next</a><span>|</span><label class="collapse" for="c-36996876">[-]</label><label class="expand" for="c-36996876">[2 more]</label></div><br/><div class="children"><div class="content">they can enforce that position by funding projects that are written in languages that they believe are memory safe. they do not need, or want, to legislate that.</div><br/><div id="36997081" class="c"><input type="checkbox" id="c-36997081" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996876">parent</a><span>|</span><a href="#36996952">next</a><span>|</span><label class="collapse" for="c-36997081">[-]</label><label class="expand" for="c-36997081">[1 more]</label></div><br/><div class="children"><div class="content">Funny that you mention that, EU does sponsor Rust development.<p>&quot;Logical Foundations for the Future of Safe Systems Programming&quot;<p><a href="https:&#x2F;&#x2F;cordis.europa.eu&#x2F;project&#x2F;id&#x2F;683289" rel="nofollow noreferrer">https:&#x2F;&#x2F;cordis.europa.eu&#x2F;project&#x2F;id&#x2F;683289</a><p>As for US,<p><a href="https:&#x2F;&#x2F;media.defense.gov&#x2F;2022&#x2F;Nov&#x2F;10&#x2F;2003112742&#x2F;-1&#x2F;-1&#x2F;0&#x2F;CSI_SOFTWARE_MEMORY_SAFETY.PDF" rel="nofollow noreferrer">https:&#x2F;&#x2F;media.defense.gov&#x2F;2022&#x2F;Nov&#x2F;10&#x2F;2003112742&#x2F;-1&#x2F;-1&#x2F;0&#x2F;CSI...</a><p>&quot;NSA advises organizations to consider making a strategic shift from
programming languages that provide little or no inherent memory protection, such as C&#x2F;C++, to a memory safe language when possible. Some examples of memory safe
languages are C#, Go, Java, Ruby™, and Swift®. Memory safe languages provide
differing degrees of memory usage protections, so available code hardening defenses, such as compiler options, tool analysis, and operating system configurations, should be used for their protections as well. By using memory safe languages and available code hardening defenses, many memory vulnerabilities can be prevented, mitigated, or made very difficult for cyber actors to exploit.&quot;</div><br/></div></div></div></div></div></div><div id="36996952" class="c"><input type="checkbox" id="c-36996952" checked=""/><div class="controls bullet"><span class="by">dakom</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996689">parent</a><span>|</span><a href="#36996742">prev</a><span>|</span><a href="#36996931">next</a><span>|</span><label class="collapse" for="c-36996952">[-]</label><label class="expand" for="c-36996952">[2 more]</label></div><br/><div class="children"><div class="content">Agreed, it&#x27;s absurd. Jail time for writing javascript otoh...</div><br/><div id="36997026" class="c"><input type="checkbox" id="c-36997026" checked=""/><div class="controls bullet"><span class="by">Borborygymus</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996952">parent</a><span>|</span><a href="#36996931">next</a><span>|</span><label class="collapse" for="c-36997026">[-]</label><label class="expand" for="c-36997026">[1 more]</label></div><br/><div class="children"><div class="content">I guffawed, and I&#x27;m not afraid to admit it.</div><br/></div></div></div></div></div></div><div id="36996931" class="c"><input type="checkbox" id="c-36996931" checked=""/><div class="controls bullet"><span class="by">justin66</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36996689">prev</a><span>|</span><a href="#36996595">next</a><span>|</span><label class="collapse" for="c-36996931">[-]</label><label class="expand" for="c-36996931">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure the federal government&#x27;s advocacy will aid Rust adoption massively. I mean, look at how Ada&#x27;s adoption skyrocketed when it received DoD&#x27;s stamp of approval.</div><br/></div></div><div id="36996595" class="c"><input type="checkbox" id="c-36996595" checked=""/><div class="controls bullet"><span class="by">quic5</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36996931">prev</a><span>|</span><a href="#36996755">next</a><span>|</span><label class="collapse" for="c-36996595">[-]</label><label class="expand" for="c-36996595">[13 more]</label></div><br/><div class="children"><div class="content">That totally misses the point of quality software. What good is memory safety if you medical device crashes because of an out of memory error?<p>What I&#x27;m trying to say: There are use cases where areas of safety are required other than memory safety.</div><br/><div id="36996661" class="c"><input type="checkbox" id="c-36996661" checked=""/><div class="controls bullet"><span class="by">nevi-me</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996595">parent</a><span>|</span><a href="#36996639">next</a><span>|</span><label class="collapse" for="c-36996661">[-]</label><label class="expand" for="c-36996661">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like you&#x27;d be worrying about n-1 types of safety errors instead of n, which is arguably better.</div><br/></div></div><div id="36996639" class="c"><input type="checkbox" id="c-36996639" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996595">parent</a><span>|</span><a href="#36996661">prev</a><span>|</span><a href="#36996660">next</a><span>|</span><label class="collapse" for="c-36996639">[-]</label><label class="expand" for="c-36996639">[3 more]</label></div><br/><div class="children"><div class="content">Memory safety is one aspect of quality yes, but is there any evidence Zig is a good fit for other quality aspects, e.g. static analysis tooling and correctness proofs? ATS is a low-level language that allows embedded proofs of correctness in the type system.</div><br/><div id="36997194" class="c"><input type="checkbox" id="c-36997194" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996639">parent</a><span>|</span><a href="#36996660">next</a><span>|</span><label class="collapse" for="c-36997194">[-]</label><label class="expand" for="c-36997194">[2 more]</label></div><br/><div class="children"><div class="content">That article does not even mention Ada&#x2F;SPARK... So much for safety. :P Yup, there is static analysis with Ada&#x2F;SPARK and it is great. It is much more general-purpose than ATS, and there are other things in Ada&#x2F;SPARK that increases safety in general, not only memory safety.<p>For what it is worth, Ada&#x2F;SPARK has a strong presence in safety-critical domains like aerospace and medical devices, while Rust is gaining popularity in system programming and web development. ^^ I&#x27;m surprised that it is not as widespread. That, or lots of misconceptions.</div><br/><div id="36997298" class="c"><input type="checkbox" id="c-36997298" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36997194">parent</a><span>|</span><a href="#36996660">next</a><span>|</span><label class="collapse" for="c-36997298">[-]</label><label class="expand" for="c-36997298">[1 more]</label></div><br/><div class="children"><div class="content">Yes Ada&#x2F;SPARK is a great example.</div><br/></div></div></div></div></div></div><div id="36996660" class="c"><input type="checkbox" id="c-36996660" checked=""/><div class="controls bullet"><span class="by">TheFragenTaken</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996595">parent</a><span>|</span><a href="#36996639">prev</a><span>|</span><a href="#36996634">next</a><span>|</span><label class="collapse" for="c-36996660">[-]</label><label class="expand" for="c-36996660">[1 more]</label></div><br/><div class="children"><div class="content">Not to be snarky, but you argument works both ways :). What good is a medical device if it leaks sensitive data, because it had been exploited by a use-after-free?</div><br/></div></div><div id="36996634" class="c"><input type="checkbox" id="c-36996634" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996595">parent</a><span>|</span><a href="#36996660">prev</a><span>|</span><a href="#36996675">next</a><span>|</span><label class="collapse" for="c-36996634">[-]</label><label class="expand" for="c-36996634">[6 more]</label></div><br/><div class="children"><div class="content">There are use cases where safety beyond memory safety is required. But there are no use cases where memory <i>unsafety</i> is desirable, yet alone required.</div><br/><div id="36996790" class="c"><input type="checkbox" id="c-36996790" checked=""/><div class="controls bullet"><span class="by">jdrek1</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996634">parent</a><span>|</span><a href="#36996663">next</a><span>|</span><label class="collapse" for="c-36996790">[-]</label><label class="expand" for="c-36996790">[1 more]</label></div><br/><div class="children"><div class="content">While that is true, there might be other requirements that prevent memory safe languages from being used. For example not having a heap available instantly disqualifies most of them. Or when you have simulations running where having constant OOB and other checks would be a massive slowdown. Now obviously your code should still be memory safe (because otherwise it&#x27;s not correct anyway and you should fix the code), but not at the cost of runtime checks.</div><br/></div></div><div id="36996663" class="c"><input type="checkbox" id="c-36996663" checked=""/><div class="controls bullet"><span class="by">quic5</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996634">parent</a><span>|</span><a href="#36996790">prev</a><span>|</span><a href="#36996675">next</a><span>|</span><label class="collapse" for="c-36996663">[-]</label><label class="expand" for="c-36996663">[4 more]</label></div><br/><div class="children"><div class="content">That is absolutely true. But but you can write memory-bug-free code in Zig but you cannot prevent heap allocations in most of the languages listed in the article, making it outright impossible to write certain software in them.</div><br/><div id="36996701" class="c"><input type="checkbox" id="c-36996701" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996663">parent</a><span>|</span><a href="#36996675">next</a><span>|</span><label class="collapse" for="c-36996701">[-]</label><label class="expand" for="c-36996701">[3 more]</label></div><br/><div class="children"><div class="content">Sure one can write memory-bug-free code in x86 assembly too. But how can you prove it? ATS is an example of a low-level systems language where you can prove it.</div><br/><div id="36996970" class="c"><input type="checkbox" id="c-36996970" checked=""/><div class="controls bullet"><span class="by">ObscureScience</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996701">parent</a><span>|</span><a href="#36997182">next</a><span>|</span><label class="collapse" for="c-36996970">[-]</label><label class="expand" for="c-36996970">[1 more]</label></div><br/><div class="children"><div class="content">As Zig promises &quot;not hidden allocation&quot;, I assume you can build your allocator in Rust and then use it for all memory allocation in Zig.</div><br/></div></div><div id="36997182" class="c"><input type="checkbox" id="c-36997182" checked=""/><div class="controls bullet"><span class="by">ArtixFox</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996701">parent</a><span>|</span><a href="#36996970">prev</a><span>|</span><a href="#36996675">next</a><span>|</span><label class="collapse" for="c-36997182">[-]</label><label class="expand" for="c-36997182">[1 more]</label></div><br/><div class="children"><div class="content">formalized subsets of x86 assembly exist. Coq can be used as a macro assembler. tools to work with llvm ir exist, x86 can be raised up to llvm ir and proved, kinda bad way tho.</div><br/></div></div></div></div></div></div></div></div><div id="36996675" class="c"><input type="checkbox" id="c-36996675" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996595">parent</a><span>|</span><a href="#36996634">prev</a><span>|</span><a href="#36996755">next</a><span>|</span><label class="collapse" for="c-36996675">[-]</label><label class="expand" for="c-36996675">[1 more]</label></div><br/><div class="children"><div class="content">Memory errors are much, much less likely to occur with more memory than use after free.</div><br/></div></div></div></div><div id="36996755" class="c"><input type="checkbox" id="c-36996755" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36996595">prev</a><span>|</span><a href="#36997033">next</a><span>|</span><label class="collapse" for="c-36996755">[-]</label><label class="expand" for="c-36996755">[4 more]</label></div><br/><div class="children"><div class="content">At some level you need languages that are not “memory safe”.<p>Memory safety comes with a cost. Either you pay for a GC runtime (Java) or for reference counting (Swift) or by not being able to express a correct program (Rust).<p>There are plenty of use cases where none of these tradeoffs are feasible.<p>To add, Zig comes with its own story around memory safety. Not at the static type system level and it’s not as comprehensive as other languages.</div><br/><div id="36996992" class="c"><input type="checkbox" id="c-36996992" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996755">parent</a><span>|</span><a href="#36996860">next</a><span>|</span><label class="collapse" for="c-36996992">[-]</label><label class="expand" for="c-36996992">[1 more]</label></div><br/><div class="children"><div class="content">...that&#x27;s like, completely ignoring the escape hatch in Rust of <i>unsafe {}</i>.<p>You&#x27;re not <i>limited</i> by anything there, period.</div><br/></div></div><div id="36996860" class="c"><input type="checkbox" id="c-36996860" checked=""/><div class="controls bullet"><span class="by">aldanor</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996755">parent</a><span>|</span><a href="#36996992">prev</a><span>|</span><a href="#36996811">next</a><span>|</span><label class="collapse" for="c-36996860">[-]</label><label class="expand" for="c-36996860">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Express a correct program&quot; that might end up being incorrect due to programmer&#x27;s fault.<p>The difference is, you can use unsafe blocks&#x2F;fns in Rust, in which case it becomes equivalent to C expressiveness-wise; but you can also do the opposite and forbid(unsafe_code) altogether.</div><br/></div></div><div id="36996811" class="c"><input type="checkbox" id="c-36996811" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996755">parent</a><span>|</span><a href="#36996860">prev</a><span>|</span><a href="#36997033">next</a><span>|</span><label class="collapse" for="c-36996811">[-]</label><label class="expand" for="c-36996811">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At some level you need languages that are not “memory safe”.<p>Perhaps as an escape hatch (unsafe Rust) or a compiler target, but ideally not as a &quot;general purpose language&quot; as Zig is marketed as.</div><br/></div></div></div></div><div id="36997033" class="c"><input type="checkbox" id="c-36997033" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36996755">prev</a><span>|</span><a href="#36996702">next</a><span>|</span><label class="collapse" for="c-36997033">[-]</label><label class="expand" for="c-36997033">[1 more]</label></div><br/><div class="children"><div class="content">Zig enforces much more correctness than C or C++, which also results in much more memory safety, it&#x27;s just not as extremist as Rust.</div><br/></div></div><div id="36996702" class="c"><input type="checkbox" id="c-36996702" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36997033">prev</a><span>|</span><a href="#36997180">next</a><span>|</span><label class="collapse" for="c-36996702">[-]</label><label class="expand" for="c-36996702">[4 more]</label></div><br/><div class="children"><div class="content">What would happen with existing codebases, sometimes built upon 2 decades of C or C++? Will the we &quot;rewrite everything in Rust&quot; ? lol</div><br/><div id="36997097" class="c"><input type="checkbox" id="c-36997097" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996702">parent</a><span>|</span><a href="#36996749">next</a><span>|</span><label class="collapse" for="c-36997097">[-]</label><label class="expand" for="c-36997097">[1 more]</label></div><br/><div class="children"><div class="content">No, we will Rewrite in ChatGPT (or similar), and only architect jobs and the few AI druids that write the tooling will be safe.</div><br/></div></div><div id="36996749" class="c"><input type="checkbox" id="c-36996749" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996702">parent</a><span>|</span><a href="#36997097">prev</a><span>|</span><a href="#36996885">next</a><span>|</span><label class="collapse" for="c-36996749">[-]</label><label class="expand" for="c-36996749">[1 more]</label></div><br/><div class="children"><div class="content">Maybe doing it for new projects is better than doing nothing?</div><br/></div></div><div id="36996885" class="c"><input type="checkbox" id="c-36996885" checked=""/><div class="controls bullet"><span class="by">31tor</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996702">parent</a><span>|</span><a href="#36996749">prev</a><span>|</span><a href="#36997180">next</a><span>|</span><label class="collapse" for="c-36996885">[-]</label><label class="expand" for="c-36996885">[1 more]</label></div><br/><div class="children"><div class="content">AI will probably find all bugs or re-write all the software in minutes soon enough.</div><br/></div></div></div></div><div id="36997180" class="c"><input type="checkbox" id="c-36997180" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36996702">prev</a><span>|</span><a href="#36996601">next</a><span>|</span><label class="collapse" for="c-36997180">[-]</label><label class="expand" for="c-36997180">[1 more]</label></div><br/><div class="children"><div class="content">And they have not even mentioned Ada&#x2F;SPARK... right.</div><br/></div></div><div id="36996601" class="c"><input type="checkbox" id="c-36996601" checked=""/><div class="controls bullet"><span class="by">bachback</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36997180">prev</a><span>|</span><a href="#36996835">next</a><span>|</span><label class="collapse" for="c-36996601">[-]</label><label class="expand" for="c-36996601">[4 more]</label></div><br/><div class="children"><div class="content">seriously?<p>&quot;The National Security Agency (NSA) has recommended only using &#x27;memory safe&#x27; languages, like C#, Go, Java, Ruby, Rust, and Swift, in order to avoid exploitable memory-based vulnerabilities.&quot;</div><br/><div id="36996647" class="c"><input type="checkbox" id="c-36996647" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996601">parent</a><span>|</span><a href="#36997231">next</a><span>|</span><label class="collapse" for="c-36996647">[-]</label><label class="expand" for="c-36996647">[2 more]</label></div><br/><div class="children"><div class="content">Yes seriously. The west is getting hacked and owned on a daily basis. The NSA recommendation shows that governments are starting to identify where the problem is.</div><br/><div id="36997191" class="c"><input type="checkbox" id="c-36997191" checked=""/><div class="controls bullet"><span class="by">ArtixFox</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996647">parent</a><span>|</span><a href="#36997231">next</a><span>|</span><label class="collapse" for="c-36997191">[-]</label><label class="expand" for="c-36997191">[1 more]</label></div><br/><div class="children"><div class="content">ah yes the east! The lovers of memory safety. 
West is getting hacked daily because every country is getting hacked daily.</div><br/></div></div></div></div><div id="36997231" class="c"><input type="checkbox" id="c-36997231" checked=""/><div class="controls bullet"><span class="by">DrBazza</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996601">parent</a><span>|</span><a href="#36996647">prev</a><span>|</span><a href="#36996835">next</a><span>|</span><label class="collapse" for="c-36997231">[-]</label><label class="expand" for="c-36997231">[1 more]</label></div><br/><div class="children"><div class="content">log4shell enters the chat.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Log4Shell" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Log4Shell</a></div><br/></div></div></div></div><div id="36996835" class="c"><input type="checkbox" id="c-36996835" checked=""/><div class="controls bullet"><span class="by">0xfedbee</span><span>|</span><a href="#36996546">parent</a><span>|</span><a href="#36996601">prev</a><span>|</span><a href="#36996671">next</a><span>|</span><label class="collapse" for="c-36996835">[-]</label><label class="expand" for="c-36996835">[5 more]</label></div><br/><div class="children"><div class="content">Spoken like a true brainwashed Rust fanatic</div><br/><div id="36997003" class="c"><input type="checkbox" id="c-36997003" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996835">parent</a><span>|</span><a href="#36997116">next</a><span>|</span><label class="collapse" for="c-36997003">[-]</label><label class="expand" for="c-36997003">[2 more]</label></div><br/><div class="children"><div class="content">You might think that, if you live in a small world.
I want memory safety, but I am otherwise not a big fan of Rust. Rust tries to be too high-level like C++, making it opaque where allocations are happening. For a low-level systems language, with embedded proofs, I quite like ATS, but Vale is also promising and more like Zig.</div><br/><div id="36997199" class="c"><input type="checkbox" id="c-36997199" checked=""/><div class="controls bullet"><span class="by">ArtixFox</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36997003">parent</a><span>|</span><a href="#36997116">next</a><span>|</span><label class="collapse" for="c-36997199">[-]</label><label class="expand" for="c-36997199">[1 more]</label></div><br/><div class="children"><div class="content">The way zig is designed, I think it will be fairly easy to embed Ada&#x27;s Spark like proof system in it.</div><br/></div></div></div></div><div id="36997116" class="c"><input type="checkbox" id="c-36997116" checked=""/><div class="controls bullet"><span class="by">graboid</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36996835">parent</a><span>|</span><a href="#36997003">prev</a><span>|</span><a href="#36996671">next</a><span>|</span><label class="collapse" for="c-36997116">[-]</label><label class="expand" for="c-36997116">[2 more]</label></div><br/><div class="children"><div class="content">Where did he&#x2F;she even mention Rust?</div><br/><div id="36997227" class="c"><input type="checkbox" id="c-36997227" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#36996546">root</a><span>|</span><a href="#36997116">parent</a><span>|</span><a href="#36996671">next</a><span>|</span><label class="collapse" for="c-36997227">[-]</label><label class="expand" for="c-36997227">[1 more]</label></div><br/><div class="children"><div class="content">Well, you do not see people mentioning Ada&#x2F;SPARK whenever memory safety is the topic of discussion, do you? They mention Rust! Well, I do mention Ada&#x2F;SPARK as much as I can because it is still a much safer language in general than Rust.</div><br/></div></div></div></div></div></div></div></div><div id="36996671" class="c"><input type="checkbox" id="c-36996671" checked=""/><div class="controls bullet"><span class="by">konsuko</span><span>|</span><a href="#36996546">prev</a><span>|</span><a href="#36996214">next</a><span>|</span><label class="collapse" for="c-36996671">[-]</label><label class="expand" for="c-36996671">[1 more]</label></div><br/><div class="children"><div class="content">The new multi-object for loop syntax is such an improvement.
Hoping for many more small QoL features like this until Zig hits 1.0.</div><br/></div></div><div id="36996214" class="c"><input type="checkbox" id="c-36996214" checked=""/><div class="controls bullet"><span class="by">msavara</span><span>|</span><a href="#36996671">prev</a><span>|</span><a href="#36996537">next</a><span>|</span><label class="collapse" for="c-36996214">[-]</label><label class="expand" for="c-36996214">[9 more]</label></div><br/><div class="children"><div class="content">Anybody here who is using zig on daily basis?</div><br/><div id="36996784" class="c"><input type="checkbox" id="c-36996784" checked=""/><div class="controls bullet"><span class="by">captainhorst</span><span>|</span><a href="#36996214">parent</a><span>|</span><a href="#36996380">next</a><span>|</span><label class="collapse" for="c-36996784">[-]</label><label class="expand" for="c-36996784">[1 more]</label></div><br/><div class="children"><div class="content">I use Zig for all my hobby projects:<p>- A pixel art editor <a href="https:&#x2F;&#x2F;github.com&#x2F;fabioarnold&#x2F;MiniPixel">https:&#x2F;&#x2F;github.com&#x2F;fabioarnold&#x2F;MiniPixel</a><p>- A Mega Man clone <a href="https:&#x2F;&#x2F;github.com&#x2F;fabioarnold&#x2F;zeroman">https:&#x2F;&#x2F;github.com&#x2F;fabioarnold&#x2F;zeroman</a><p>- Zig Gorillas <a href="https:&#x2F;&#x2F;github.com&#x2F;fabioarnold&#x2F;zig-gorillas">https:&#x2F;&#x2F;github.com&#x2F;fabioarnold&#x2F;zig-gorillas</a><p>And most recently I had the opportunity to build a visualization for TigerBeetle&#x27;s database simulator: <a href="https:&#x2F;&#x2F;sim.tigerbeetle.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;sim.tigerbeetle.com</a><p>Before I was using C++ and Zig has been an improvement in every way.</div><br/></div></div><div id="36996380" class="c"><input type="checkbox" id="c-36996380" checked=""/><div class="controls bullet"><span class="by">trashburger</span><span>|</span><a href="#36996214">parent</a><span>|</span><a href="#36996784">prev</a><span>|</span><a href="#36996872">next</a><span>|</span><label class="collapse" for="c-36996380">[-]</label><label class="expand" for="c-36996380">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about &quot;daily&quot; right now (I&#x27;ve had to take a break due to obligations), but I&#x27;m working on a modern implementation of the Self programming language with actor capabilities: <a href="https:&#x2F;&#x2F;github.com&#x2F;sin-ack&#x2F;zigself">https:&#x2F;&#x2F;github.com&#x2F;sin-ack&#x2F;zigself</a><p>It&#x27;s nowhere near usable yet, but Zig has been a joy to work with for over a year, and I can definitely see myself using it for a big piece of software.</div><br/></div></div><div id="36996872" class="c"><input type="checkbox" id="c-36996872" checked=""/><div class="controls bullet"><span class="by">latch</span><span>|</span><a href="#36996214">parent</a><span>|</span><a href="#36996380">prev</a><span>|</span><a href="#36996333">next</a><span>|</span><label class="collapse" for="c-36996872">[-]</label><label class="expand" for="c-36996872">[1 more]</label></div><br/><div class="children"><div class="content">I took a year off, and one of the things I did was learn Zig. I&#x27;ve built a number of libraries, including one of the currently more popular HTTP server libraries (<a href="https:&#x2F;&#x2F;github.com&#x2F;karlseguin&#x2F;http.zig">https:&#x2F;&#x2F;github.com&#x2F;karlseguin&#x2F;http.zig</a>).<p>A number of my libraries are used for <a href="https:&#x2F;&#x2F;www.aolium.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.aolium.com&#x2F;</a> which I decided to write for myself.<p>I try to write a bit every day with the benefit that I can &quot;waste&quot; time digging into things or exploring likely-to-fail paths.</div><br/></div></div><div id="36996333" class="c"><input type="checkbox" id="c-36996333" checked=""/><div class="controls bullet"><span class="by">rene_d</span><span>|</span><a href="#36996214">parent</a><span>|</span><a href="#36996872">prev</a><span>|</span><a href="#36997111">next</a><span>|</span><label class="collapse" for="c-36996333">[-]</label><label class="expand" for="c-36996333">[1 more]</label></div><br/><div class="children"><div class="content">I am building an on-premise annotation platform for medical image data (MVA.ai) where it is used for both backend and frontend (WASM). Really enjoy the language, with the key aspects being the low level control and performance, the build system and cross-compilation, comptime for generics, the easy integration of existing C libraries and the support for WASM. Manual memory management is sometimes a bit tedious, but you get used to it quite quickly. On the other hand, being able to use different allocators can even give you something like &#x27;lifetimes&#x27;.</div><br/></div></div><div id="36997111" class="c"><input type="checkbox" id="c-36997111" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36996214">parent</a><span>|</span><a href="#36996333">prev</a><span>|</span><a href="#36996562">next</a><span>|</span><label class="collapse" for="c-36997111">[-]</label><label class="expand" for="c-36997111">[1 more]</label></div><br/><div class="children"><div class="content">We trade ten million dollars a day of shitcoin derivatives using zig. Should be more soon :). We&#x27;re probably stuck on 0.10.1 until async makes it back in though.</div><br/></div></div><div id="36996562" class="c"><input type="checkbox" id="c-36996562" checked=""/><div class="controls bullet"><span class="by">whitehexagon</span><span>|</span><a href="#36996214">parent</a><span>|</span><a href="#36997111">prev</a><span>|</span><a href="#36996959">next</a><span>|</span><label class="collapse" for="c-36996562">[-]</label><label class="expand" for="c-36996562">[1 more]</label></div><br/><div class="children"><div class="content">Most days.  Just switched to linux to access latest version and features, especially loving the new &#x27;packed struct(u32)&#x27; for some low level SoC work (Register representation).  I get compile errors if I miscount the bits, and I managed to get some type safety, and not a single &#x27;shift&#x27;, &#x27;and&#x27; or &#x27;or&#x27; sign in sight!<p>Looks like I&#x27;ll be porting to 0.11.1 as soon as the documentation is in place...  I hope they slow down soon, already feels complete.  The WASM support is amazing, much smaller outputs than the other options I tried (Java &amp; Go).  Great work team!</div><br/></div></div><div id="36996959" class="c"><input type="checkbox" id="c-36996959" checked=""/><div class="controls bullet"><span class="by">tauoverpi</span><span>|</span><a href="#36996214">parent</a><span>|</span><a href="#36996562">prev</a><span>|</span><a href="#36996765">next</a><span>|</span><label class="collapse" for="c-36996959">[-]</label><label class="expand" for="c-36996959">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m slowly writing a game with it in my own time and previously worked on an in-memory cache for smart metering full-time. It&#x27;s been nice to play with and my goto language for prototyping since arond 0.5.0.</div><br/></div></div><div id="36996765" class="c"><input type="checkbox" id="c-36996765" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#36996214">parent</a><span>|</span><a href="#36996959">prev</a><span>|</span><a href="#36996537">next</a><span>|</span><label class="collapse" for="c-36996765">[-]</label><label class="expand" for="c-36996765">[1 more]</label></div><br/><div class="children"><div class="content">Everyone where I work does. :)</div><br/></div></div></div></div><div id="36996537" class="c"><input type="checkbox" id="c-36996537" checked=""/><div class="controls bullet"><span class="by">ephaeton</span><span>|</span><a href="#36996214">prev</a><span>|</span><a href="#36997247">next</a><span>|</span><label class="collapse" for="c-36996537">[-]</label><label class="expand" for="c-36996537">[1 more]</label></div><br/><div class="children"><div class="content">Wow, those are really nice release notes.</div><br/></div></div><div id="36997247" class="c"><input type="checkbox" id="c-36997247" checked=""/><div class="controls bullet"><span class="by">xchkr1337</span><span>|</span><a href="#36996537">prev</a><span>|</span><a href="#36996579">next</a><span>|</span><label class="collapse" for="c-36997247">[-]</label><label class="expand" for="c-36997247">[1 more]</label></div><br/><div class="children"><div class="content">does it support tabs yet?</div><br/></div></div><div id="36996579" class="c"><input type="checkbox" id="c-36996579" checked=""/><div class="controls bullet"><span class="by">whiterock</span><span>|</span><a href="#36997247">prev</a><span>|</span><a href="#36995856">next</a><span>|</span><label class="collapse" for="c-36996579">[-]</label><label class="expand" for="c-36996579">[10 more]</label></div><br/><div class="children"><div class="content">It‘s a shame macOS Arm is deprecated :(</div><br/><div id="36996729" class="c"><input type="checkbox" id="c-36996729" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#36996579">parent</a><span>|</span><a href="#36996611">next</a><span>|</span><label class="collapse" for="c-36996729">[-]</label><label class="expand" for="c-36996729">[1 more]</label></div><br/><div class="children"><div class="content">this comment is misleading. aarch64, the architecture for apple silicon, is still fully supported. did you see &quot;arm&quot; with a skull next to it and assume that meant all ARM architectures became recently deprecated?</div><br/></div></div><div id="36996611" class="c"><input type="checkbox" id="c-36996611" checked=""/><div class="controls bullet"><span class="by">quic5</span><span>|</span><a href="#36996579">parent</a><span>|</span><a href="#36996729">prev</a><span>|</span><a href="#36997078">next</a><span>|</span><label class="collapse" for="c-36996611">[-]</label><label class="expand" for="c-36996611">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe there ever was support for macOS on 32-bit ARM.</div><br/><div id="36997052" class="c"><input type="checkbox" id="c-36997052" checked=""/><div class="controls bullet"><span class="by">AndyKelley</span><span>|</span><a href="#36996579">root</a><span>|</span><a href="#36996611">parent</a><span>|</span><a href="#36997078">next</a><span>|</span><label class="collapse" for="c-36997052">[-]</label><label class="expand" for="c-36997052">[1 more]</label></div><br/><div class="children"><div class="content">I believe iPhone 5c was the last of the 32-bit ARM Apple devices. I guess technically that&#x27;s iOS rather than macOS but as far as Zig is concerned, it&#x27;s all Darwin.</div><br/></div></div></div></div><div id="36997078" class="c"><input type="checkbox" id="c-36997078" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#36996579">parent</a><span>|</span><a href="#36996611">prev</a><span>|</span><a href="#36996631">next</a><span>|</span><label class="collapse" for="c-36997078">[-]</label><label class="expand" for="c-36997078">[1 more]</label></div><br/><div class="children"><div class="content">Wait what? I use Zig just fine on my M1 Mac. Did macOS ever run on non-Apple-ARM chips?</div><br/></div></div><div id="36996631" class="c"><input type="checkbox" id="c-36996631" checked=""/><div class="controls bullet"><span class="by">sai_c</span><span>|</span><a href="#36996579">parent</a><span>|</span><a href="#36997078">prev</a><span>|</span><a href="#36995856">next</a><span>|</span><label class="collapse" for="c-36996631">[-]</label><label class="expand" for="c-36996631">[5 more]</label></div><br/><div class="children"><div class="content">Whoa, thanks for the heads-up. I&#x27;ve been reading news about Zig from time to time, and planned giving it an honest try at 1.0 (whenever that may be) but it seems I&#x27;m out of luck.<p>Do you, by chance, know the reasoning behind this step?</div><br/><div id="36996708" class="c"><input type="checkbox" id="c-36996708" checked=""/><div class="controls bullet"><span class="by">candrewlee14</span><span>|</span><a href="#36996579">root</a><span>|</span><a href="#36996631">parent</a><span>|</span><a href="#36995856">next</a><span>|</span><label class="collapse" for="c-36996708">[-]</label><label class="expand" for="c-36996708">[4 more]</label></div><br/><div class="children"><div class="content">Aarch64 is supported (M series chips) if that’s what you’re worried about.</div><br/><div id="36996732" class="c"><input type="checkbox" id="c-36996732" checked=""/><div class="controls bullet"><span class="by">sai_c</span><span>|</span><a href="#36996579">root</a><span>|</span><a href="#36996708">parent</a><span>|</span><a href="#36995856">next</a><span>|</span><label class="collapse" for="c-36996732">[-]</label><label class="expand" for="c-36996732">[3 more]</label></div><br/><div class="children"><div class="content">No, I actually have a bunch of older Macs I keep running for certain experiments.</div><br/><div id="36996907" class="c"><input type="checkbox" id="c-36996907" checked=""/><div class="controls bullet"><span class="by">pzo</span><span>|</span><a href="#36996579">root</a><span>|</span><a href="#36996732">parent</a><span>|</span><a href="#36996859">next</a><span>|</span><label class="collapse" for="c-36996907">[-]</label><label class="expand" for="c-36996907">[1 more]</label></div><br/><div class="children"><div class="content">Older mac are intel based not arm. M1 is the first arm based chip</div><br/></div></div><div id="36996859" class="c"><input type="checkbox" id="c-36996859" checked=""/><div class="controls bullet"><span class="by">catach</span><span>|</span><a href="#36996579">root</a><span>|</span><a href="#36996732">parent</a><span>|</span><a href="#36996907">prev</a><span>|</span><a href="#36995856">next</a><span>|</span><label class="collapse" for="c-36996859">[-]</label><label class="expand" for="c-36996859">[1 more]</label></div><br/><div class="children"><div class="content">Those would be Intel not Arm, no?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36995856" class="c"><input type="checkbox" id="c-36995856" checked=""/><div class="controls bullet"><span class="by">andy_herbert</span><span>|</span><a href="#36996579">prev</a><span>|</span><a href="#36996046">next</a><span>|</span><label class="collapse" for="c-36995856">[-]</label><label class="expand" for="c-36995856">[2 more]</label></div><br/><div class="children"><div class="content">Are people supposed to realise this version number is related to Zig?</div><br/><div id="36996267" class="c"><input type="checkbox" id="c-36996267" checked=""/><div class="controls bullet"><span class="by">Tor3</span><span>|</span><a href="#36995856">parent</a><span>|</span><a href="#36996046">next</a><span>|</span><label class="collapse" for="c-36996267">[-]</label><label class="expand" for="c-36996267">[1 more]</label></div><br/><div class="children"><div class="content">Somebody fixed the title from 0.11.0 to Zig 0.11, so it&#x27;s ok now.</div><br/></div></div></div></div></div></div></div></div></div></body></html>