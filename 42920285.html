<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738659674228" as="style"/><link rel="stylesheet" href="styles.css?v=1738659674228"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://qntm.org/devphilo">Developer Philosophy</a> <span class="domain">(<a href="https://qntm.org">qntm.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>56 comments</span></div><br/><div><div id="42929929" class="c"><input type="checkbox" id="c-42929929" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#42923696">next</a><span>|</span><label class="collapse" for="c-42929929">[-]</label><label class="expand" for="c-42929929">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d add this: if you do end up with a ground-up rewrite, make sure the original authors of the current code are involved in the rewrite. If they are not, it&#x27;s not a rewrite, just another version.</div><br/></div></div><div id="42923696" class="c"><input type="checkbox" id="c-42923696" checked=""/><div class="controls bullet"><span class="by">csours</span><span>|</span><a href="#42929929">prev</a><span>|</span><a href="#42921664">next</a><span>|</span><label class="collapse" for="c-42923696">[-]</label><label class="expand" for="c-42923696">[3 more]</label></div><br/><div class="children"><div class="content">To me, software development is many things, but the inner loop is mainly characterized by two alternating modes: Trying things and Learning things.<p>The biggest hidden assumption I see is that we expect other people to be trying and learning things in the same way we do.<p>Experienced devs will write code to improve their own understanding, they will create tests to improve their own understanding, they will do research, they will do a lot of learning and all of that rarely gets talked about at standup or in a pull request. This work never shows up in a planning or budget meeting.<p>I see junior devs getting stuck hard on delivering production ready code - which is the WORK PRODUCT that we want; but that is not what the actual work of software development looks like. A lot of junior devs are hesitant to do throw-away work that does not get committed to source control - they feel like someone out there knows the answer and they just have to find them. And for a long time, that works - they can find someone to provide the answer they need, they can find a senior dev who glances at the code and fixes it effortlessly.<p>This whole thing is exacerbated by managers with no or minimal dev experience, who also confuse work product and tracked work items with the actual work of producing software.<p>(And if you&#x27;re wondering who &#x27;junior devs&#x27; is, it&#x27;s me. I&#x27;m junior devs.)</div><br/><div id="42923860" class="c"><input type="checkbox" id="c-42923860" checked=""/><div class="controls bullet"><span class="by">armanboyaci</span><span>|</span><a href="#42923696">parent</a><span>|</span><a href="#42921664">next</a><span>|</span><label class="collapse" for="c-42923860">[-]</label><label class="expand" for="c-42923860">[2 more]</label></div><br/><div class="children"><div class="content">I believe your description of software development is highly aligned with the ideas of peter naur, programming as theory building.<p><a href="https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;Naur.pdf" rel="nofollow">https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;Naur.pdf</a></div><br/><div id="42924487" class="c"><input type="checkbox" id="c-42924487" checked=""/><div class="controls bullet"><span class="by">digdugdirk</span><span>|</span><a href="#42923696">root</a><span>|</span><a href="#42923860">parent</a><span>|</span><a href="#42921664">next</a><span>|</span><label class="collapse" for="c-42924487">[-]</label><label class="expand" for="c-42924487">[1 more]</label></div><br/><div class="children"><div class="content">I love when this paper pops up, because now I get to recommend a relevant episode of a really great, really nerdy podcast:<p><a href="https:&#x2F;&#x2F;futureofcoding.org&#x2F;episodes&#x2F;061.html" rel="nofollow">https:&#x2F;&#x2F;futureofcoding.org&#x2F;episodes&#x2F;061.html</a></div><br/></div></div></div></div></div></div><div id="42921664" class="c"><input type="checkbox" id="c-42921664" checked=""/><div class="controls bullet"><span class="by">zurfer</span><span>|</span><a href="#42923696">prev</a><span>|</span><a href="#42922898">next</a><span>|</span><label class="collapse" for="c-42921664">[-]</label><label class="expand" for="c-42921664">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I apologise for writing such a long letter, but I didn&#x27;t have time to write a short one.&quot;The quote, &quot; is generally credited to Blaise Pascal, a French mathematician and philosopher. 
In his work &quot;Lettres Provinciales&quot; (Provincial Letters), published in 1657, Pascal wrote in French: &quot;Je n’ai fait celle-ci plus longue que parce que je n’ai pas eu le loisir de la faire plus courte,&quot; which translates to, &quot;I have made this letter longer than usual because I lack the time to make it shorter.&quot;</div><br/></div></div><div id="42922898" class="c"><input type="checkbox" id="c-42922898" checked=""/><div class="controls bullet"><span class="by">mtrovo</span><span>|</span><a href="#42921664">prev</a><span>|</span><a href="#42921426">next</a><span>|</span><label class="collapse" for="c-42922898">[-]</label><label class="expand" for="c-42922898">[3 more]</label></div><br/><div class="children"><div class="content">First time hearing about the 90&#x2F;50 rule and it&#x27;s something I&#x27;ve seen play out so many times. It&#x27;s easy to get caught up in just getting the code work on a limited case, but true quality comes from spending extra time on testing and handling edge cases. It&#x27;s often those overlooked details that can take up more time than we expect. This is particularly crucial for junior developers to grasp as you need to understand that your task is not done when you send your first push to git.<p>I also agree wholeheartedly with automating best practices. Relying on manual reviews for everything is just not scalable. Setting up automated tests to enforce format, lints and testable code have the side-effect of creating a code base with clear expectations and minimal side effects.</div><br/><div id="42926573" class="c"><input type="checkbox" id="c-42926573" checked=""/><div class="controls bullet"><span class="by">xmprt</span><span>|</span><a href="#42922898">parent</a><span>|</span><a href="#42923395">next</a><span>|</span><label class="collapse" for="c-42926573">[-]</label><label class="expand" for="c-42926573">[1 more]</label></div><br/><div class="children"><div class="content">I think the solution depends on the type of problem you have. If your problem is reliability then increased testing and handling edge cases (or avoiding code that even hits those edge cases) will help. But if the problem is uncertain requirements, then more testing will just add to the amount of code you&#x27;re going to throw away and refactoring will only become harder.<p>The problem is that often times in software engineering both problems happen in tandem - you&#x27;re improving reliability while also trying to change how your system works as new feature requests come in. The solutions are almost diametrically opposed.</div><br/></div></div><div id="42923395" class="c"><input type="checkbox" id="c-42923395" checked=""/><div class="controls bullet"><span class="by">pydry</span><span>|</span><a href="#42922898">parent</a><span>|</span><a href="#42926573">prev</a><span>|</span><a href="#42921426">next</a><span>|</span><label class="collapse" for="c-42923395">[-]</label><label class="expand" for="c-42923395">[1 more]</label></div><br/><div class="children"><div class="content">True quality comes from avoiding edge case traps.<p>Some approaches&#x2F;feature types create edge case explosions.<p>For example, I&#x27;m often hell bent on the need for avoiding bidirectional syncing or writing mini parsers. If there is another, simpler way its always better.</div><br/></div></div></div></div><div id="42921426" class="c"><input type="checkbox" id="c-42921426" checked=""/><div class="controls bullet"><span class="by">gchamonlive</span><span>|</span><a href="#42922898">prev</a><span>|</span><a href="#42921194">next</a><span>|</span><label class="collapse" for="c-42921426">[-]</label><label class="expand" for="c-42921426">[4 more]</label></div><br/><div class="children"><div class="content">I think any attempt to distil hard earned experience and domain awareness will eventually devolve into misplaced generalisms.<p>This isn&#x27;t to say that the article isn&#x27;t good. It&#x27;s well written and the teachings are valuable.<p>This comment is for the inexperienced dev that arrives at theses posts looking for ideological prescriptions: don&#x27;t.<p>Give yourself time. Let yourself fail and learn from your mistakes. Keep reading the masters work like Clean Code, SICP, Working effectively with legacy code, software architecture the hard parts, mythical man month etc... but don&#x27;t let anyone prescribe to you how to do your job.<p>Developing is ultimately managing an unmanageable and ever evolving complexity and making it work. Developing is art and experience. Developing requires great peace of mind.</div><br/><div id="42921757" class="c"><input type="checkbox" id="c-42921757" checked=""/><div class="controls bullet"><span class="by">spit2wind</span><span>|</span><a href="#42921426">parent</a><span>|</span><a href="#42924078">next</a><span>|</span><label class="collapse" for="c-42921757">[-]</label><label class="expand" for="c-42921757">[1 more]</label></div><br/><div class="children"><div class="content">The author has a few words about Clean Code <a href="https:&#x2F;&#x2F;qntm.org&#x2F;clean" rel="nofollow">https:&#x2F;&#x2F;qntm.org&#x2F;clean</a><p>A better recommendation is &quot;A Philosophy of Software Design&quot; by Osterhaut.</div><br/></div></div><div id="42924078" class="c"><input type="checkbox" id="c-42924078" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#42921426">parent</a><span>|</span><a href="#42921757">prev</a><span>|</span><a href="#42921935">next</a><span>|</span><label class="collapse" for="c-42924078">[-]</label><label class="expand" for="c-42924078">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Let yourself fail and learn from your mistakes.<p>In my experience, trying and failing is the very best teaching&#x2F;learning method.<p>If you&#x27;re observant and lucky during your career, you&#x27;ll gain the skill of learning from other people&#x27;s failures as well as your own.<p>(And from a management and mentoring perspective, it&#x27;s important to assign tasks&#x2F;projects to junior and mid level devs that have real risks of failure while shielding those devs from blame or blowback if&#x2F;when they fail. All the very best devs I&#x27;ve worked with in my 30+ years in this game have a deep oral history of war stories they can dig into when explaining why a particular approach might not be as good as it seems on the surface.)</div><br/></div></div><div id="42921935" class="c"><input type="checkbox" id="c-42921935" checked=""/><div class="controls bullet"><span class="by">parpfish</span><span>|</span><a href="#42921426">parent</a><span>|</span><a href="#42924078">prev</a><span>|</span><a href="#42921194">next</a><span>|</span><label class="collapse" for="c-42921935">[-]</label><label class="expand" for="c-42921935">[1 more]</label></div><br/><div class="children"><div class="content">generalisms are fine as long as you don&#x27;t try to turn it into a hard and fast rule.<p>generalisms contain knowledge that <i>generally applies</i>, but i think it&#x27;s well understood that there will always be times where it doesn&#x27;t apply.</div><br/></div></div></div></div><div id="42921194" class="c"><input type="checkbox" id="c-42921194" checked=""/><div class="controls bullet"><span class="by">parpfish</span><span>|</span><a href="#42921426">prev</a><span>|</span><a href="#42924283">next</a><span>|</span><label class="collapse" for="c-42921194">[-]</label><label class="expand" for="c-42921194">[13 more]</label></div><br/><div class="children"><div class="content">the last three entries are great and need to be drilled into folks head. too much of CS training (and leet-code driven interviewing) encourages people to get clever. but reading somebody elses clever code sucks.<p>write code that&#x27;s meant to be easily read and understood. that&#x27;s not <i>just</i> about algorithms and code comments -- variables&#x2F;functions named descriptively, formatting is consistent, things don&#x27;t get too nested, design things to be modular in a way that lets you ignore irrelevant sources of complexity, etc</div><br/><div id="42921443" class="c"><input type="checkbox" id="c-42921443" checked=""/><div class="controls bullet"><span class="by">zikzak</span><span>|</span><a href="#42921194">parent</a><span>|</span><a href="#42921541">next</a><span>|</span><label class="collapse" for="c-42921443">[-]</label><label class="expand" for="c-42921443">[5 more]</label></div><br/><div class="children"><div class="content">Kernighan&#x27;s Law - Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.</div><br/><div id="42922507" class="c"><input type="checkbox" id="c-42922507" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42921194">root</a><span>|</span><a href="#42921443">parent</a><span>|</span><a href="#42921924">next</a><span>|</span><label class="collapse" for="c-42922507">[-]</label><label class="expand" for="c-42922507">[1 more]</label></div><br/><div class="children"><div class="content">That, of course, is only valid if you are using your cleverness to optimize for something that isn&#x27;t readability.</div><br/></div></div><div id="42921924" class="c"><input type="checkbox" id="c-42921924" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#42921194">root</a><span>|</span><a href="#42921443">parent</a><span>|</span><a href="#42922507">prev</a><span>|</span><a href="#42923934">next</a><span>|</span><label class="collapse" for="c-42921924">[-]</label><label class="expand" for="c-42921924">[2 more]</label></div><br/><div class="children"><div class="content">I feel as an outlier to this I need to make a comment.. Debugging (with source) to me at least, it’s so much more easier as you have all of the stack with you along the chain.. It’s very rare, not impossible though, to find crazy behavior during correct debugging.. This law is new to me though.</div><br/><div id="42928701" class="c"><input type="checkbox" id="c-42928701" checked=""/><div class="controls bullet"><span class="by">geewee</span><span>|</span><a href="#42921194">root</a><span>|</span><a href="#42921924">parent</a><span>|</span><a href="#42923934">next</a><span>|</span><label class="collapse" for="c-42928701">[-]</label><label class="expand" for="c-42928701">[1 more]</label></div><br/><div class="children"><div class="content">I think it depends on how thorny the thing you need to debug is. Race conditions, intermittent bugs that crash the process leaving no trace, etc. Debugging is much more than using a debugger</div><br/></div></div></div></div><div id="42923934" class="c"><input type="checkbox" id="c-42923934" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#42921194">root</a><span>|</span><a href="#42921443">parent</a><span>|</span><a href="#42921924">prev</a><span>|</span><a href="#42921541">next</a><span>|</span><label class="collapse" for="c-42923934">[-]</label><label class="expand" for="c-42923934">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Do not write today, that what you cannot debug tomorrow.&quot;</div><br/></div></div></div></div><div id="42921541" class="c"><input type="checkbox" id="c-42921541" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42921194">parent</a><span>|</span><a href="#42921443">prev</a><span>|</span><a href="#42921879">next</a><span>|</span><label class="collapse" for="c-42921541">[-]</label><label class="expand" for="c-42921541">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be a bit wary of taking &#x27;simplicity&#x27; as a goal. Some people read that and think to write shorter, cleverer code instead of longer, more straightforward code which might have a few redundancies. (E.g., people often praise FP languages and Lisp-like languages for their very flexible control flow, but adding custom abstractions can result in shorter code that is difficult for newcomers to understand.)<p>On the other hand, too much modularity and factored-out code can also obscure the behavior of a program, even if each module has a well-defined role and satisfies its interface. (E.g., big Java programs can have hundreds of classes with small method bodies and lots of calls to other classes and interfaces. If you see an interface call, but the object came from somewhere several classes away, then good luck figuring out which implementation gets called.)<p>I&#x27;d say that the ultimate moral is &quot;Keep the flow of logic and data relatively linear (or at least, no more complex than it needs to be to solve the problem). Avoid dicing it up between a dozen different spots, or performing crazy stunts with it, so that only an expert can understand what&#x27;s going on. And just because some logical constructs (like dynamic dispatch) are unwritten doesn&#x27;t mean they don&#x27;t create mental load.&quot;</div><br/><div id="42922855" class="c"><input type="checkbox" id="c-42922855" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#42921194">root</a><span>|</span><a href="#42921541">parent</a><span>|</span><a href="#42921977">next</a><span>|</span><label class="collapse" for="c-42922855">[-]</label><label class="expand" for="c-42922855">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s fine if code is difficult for newcomers to understand (of course, to a point). Most programmers are taught in C-like languages and paradigms. Using FP (ML-like) languages is already &quot;difficult to understand&quot;.<p>The question then becomes: how large is the disconnect between the &quot;theory&quot; in the mind of the newcomer(s) vs. the &quot;theory&quot; they need to be useful in the codebase -- and is this gap worth it?<p>For example, programming with explicit effects (i.e. `IO`) or even just type-safe Futures. There&#x27;s not too much difficulty with simply getting started, and it builds up a general theory of effects in the newcomer, which would presumably be useful in many contexts of the codebase even outside of async effects, e.g. error-handling with `Either`.</div><br/><div id="42926486" class="c"><input type="checkbox" id="c-42926486" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42921194">root</a><span>|</span><a href="#42922855">parent</a><span>|</span><a href="#42922954">next</a><span>|</span><label class="collapse" for="c-42926486">[-]</label><label class="expand" for="c-42926486">[1 more]</label></div><br/><div class="children"><div class="content">One dev&#x27;s &quot;you&#x27;ve just gotta learn how we do things&quot; is another dev&#x27;s &quot;holy hell why does this codebase have its own mind-bending do-everything hyper-abstractions that don&#x27;t exist outside this organization&quot;. (I&#x27;m thinking not of the basic concepts of popular FP languages so much as the powerful abstractions they can be used to create. Though if a company invents its own language, that can very quickly enter the &#x27;overly large gap&#x27; range.)<p>I agree that there&#x27;s a spectrum here, but IME it&#x27;s very easy for existing devs familiar with everything to underestimate the gap between newcomers&#x27; knowledge and their own, or to overestimate how much it&#x27;s needed. In the worst case, you end up with brittle spaghetti &#x27;abstractions&#x27; where the old-timers swear up and down that everything is perfectly sensible and necessary.<p>(I&#x27;ve personally seen this kind of overestimated necessity twice, in the context of API design. In both cases, the author of a public library published a new version incompatible with the old version, under the justification that users really ought to learn and pay attention to the fine details of the problem space that the library is solving, and that changing the API is a good way to force their hand. But from an outside perspective, the fine details weren&#x27;t really important for 99.9% of use cases, and it isn&#x27;t practical for every dev to be conscious of every tradeoff and design decision in the whole stack.)</div><br/></div></div><div id="42922954" class="c"><input type="checkbox" id="c-42922954" checked=""/><div class="controls bullet"><span class="by">wry_discontent</span><span>|</span><a href="#42921194">root</a><span>|</span><a href="#42922855">parent</a><span>|</span><a href="#42926486">prev</a><span>|</span><a href="#42921977">next</a><span>|</span><label class="collapse" for="c-42922954">[-]</label><label class="expand" for="c-42922954">[1 more]</label></div><br/><div class="children"><div class="content">Everything is difficult for newcomers to understand.  Newcomers should be helped to learn new things.  Every programming language will be incomprehensible to non-programmers.  That&#x27;s not the target audience.</div><br/></div></div></div></div><div id="42921977" class="c"><input type="checkbox" id="c-42921977" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#42921194">root</a><span>|</span><a href="#42921541">parent</a><span>|</span><a href="#42922855">prev</a><span>|</span><a href="#42921879">next</a><span>|</span><label class="collapse" for="c-42921977">[-]</label><label class="expand" for="c-42921977">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but adding custom abstractions can result in shorter code that is difficult for newcomers to understand<p>I’ve worked at places where the lead would abstract everythiNg possible, it made tracing the flow not just difficult but almost intentionally obfuscated. When calling him up on it he would sing the principles and say it’s the source of robust code. I’m sure out 100 customers appreciated that.<p>I do appreciate your comment on keeping the flow right, I would add to that I guess by making sure your domains and boundaries are well established and respected.. mistakes will always happen, but if they’re “gated” by domains, the person who fixes it will definitely buy you a beer&#x2F;coffee.</div><br/></div></div></div></div><div id="42921879" class="c"><input type="checkbox" id="c-42921879" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#42921194">parent</a><span>|</span><a href="#42921541">prev</a><span>|</span><a href="#42923879">next</a><span>|</span><label class="collapse" for="c-42921879">[-]</label><label class="expand" for="c-42921879">[1 more]</label></div><br/><div class="children"><div class="content">A great rule of thumb I found useful while learning under great tutorship (way back when) was, look at your check-in, (svn at the time) if you think you will remember it in 5 months in less than 15 mins then it’s okay.. But still have someone put eyes on it before clicking. SVN made us careful maybe..</div><br/></div></div><div id="42923879" class="c"><input type="checkbox" id="c-42923879" checked=""/><div class="controls bullet"><span class="by">boogieknite</span><span>|</span><a href="#42921194">parent</a><span>|</span><a href="#42921879">prev</a><span>|</span><a href="#42924283">next</a><span>|</span><label class="collapse" for="c-42923879">[-]</label><label class="expand" for="c-42923879">[1 more]</label></div><br/><div class="children"><div class="content">i inherited spaghetti code written by a geography phd and some fresh out of coding boot camp flunkies. i really enjoy finding &quot;clever&quot; code, even code they only think is clever. its entertaining! might as well be entertained at work.<p>if its legit clever code, just add a link to the source for the theory behind it and that&#x27;s enough for me</div><br/></div></div></div></div><div id="42924283" class="c"><input type="checkbox" id="c-42924283" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#42921194">prev</a><span>|</span><a href="#42921825">next</a><span>|</span><label class="collapse" for="c-42924283">[-]</label><label class="expand" for="c-42924283">[2 more]</label></div><br/><div class="children"><div class="content">The (linked) Ratchet is genius!  A near perfect mechanism to enforce the future you want without undue work in the meantime.<p><a href="https:&#x2F;&#x2F;qntm.org&#x2F;ratchet" rel="nofollow">https:&#x2F;&#x2F;qntm.org&#x2F;ratchet</a></div><br/></div></div><div id="42921825" class="c"><input type="checkbox" id="c-42921825" checked=""/><div class="controls bullet"><span class="by">hintymad</span><span>|</span><a href="#42924283">prev</a><span>|</span><a href="#42922575">next</a><span>|</span><label class="collapse" for="c-42921825">[-]</label><label class="expand" for="c-42921825">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of Joel Spolsky&#x27;s test and true article on rewrite: <a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-never-do-part-i&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-...</a></div><br/></div></div><div id="42922575" class="c"><input type="checkbox" id="c-42922575" checked=""/><div class="controls bullet"><span class="by">neves</span><span>|</span><a href="#42921825">prev</a><span>|</span><a href="#42921641">next</a><span>|</span><label class="collapse" for="c-42922575">[-]</label><label class="expand" for="c-42922575">[1 more]</label></div><br/><div class="children"><div class="content">The author cited this quote:<p>&gt; he first 90% of the job takes 90% of the time. The last 10% of the job takes the other 90% of the time.<p>When I report my work done I always prefer the ironic version:<p>&gt; I&#x27;ve already did 90%, now there&#x27;s just the other 90%.<p>It is fun, but most importantly, for non developers, it reports a reality of our work. To do the simplest case, is almost easy, but when you have to factor in taking care of exceptions, errors, usability, log, robustness, security etc. there&#x27;s a lot of &quot;unexpected&quot; work.</div><br/></div></div><div id="42921641" class="c"><input type="checkbox" id="c-42921641" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#42922575">prev</a><span>|</span><a href="#42925910">next</a><span>|</span><label class="collapse" for="c-42921641">[-]</label><label class="expand" for="c-42921641">[5 more]</label></div><br/><div class="children"><div class="content">&quot;By the time the ground-up rewrite starts to seem like a good idea, avoidable mistakes have already been made. &quot;<p>This is the wisdom of devops. Do it well, and things will go smoothly.</div><br/><div id="42921729" class="c"><input type="checkbox" id="c-42921729" checked=""/><div class="controls bullet"><span class="by">tra3</span><span>|</span><a href="#42921641">parent</a><span>|</span><a href="#42925910">next</a><span>|</span><label class="collapse" for="c-42921729">[-]</label><label class="expand" for="c-42921729">[4 more]</label></div><br/><div class="children"><div class="content">Someone below already commented [0]<p>&gt; I think any attempt to distil hard earned experience and domain awareness will eventually devolve into misplaced generalisms.<p>Ground up rewrites are a gamble. Classic Spolksy essay [1] about Netscape losing their lead to Internet Explorer is a must read.<p>Briefly:<p>1. You think you know how to build the new version, but you really don&#x27;t. Years of improvements of the old version, years of bug fixes, years of business knowledge are below the surface.<p>2. The new version is going to have new bugs.<p>3. While you&#x27;re rebuilding everything from scratch your competition is improving their product.<p>0: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42921426">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42921426</a><p>1: <a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-never-do-part-i&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-...</a></div><br/><div id="42929962" class="c"><input type="checkbox" id="c-42929962" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#42921641">root</a><span>|</span><a href="#42921729">parent</a><span>|</span><a href="#42921856">next</a><span>|</span><label class="collapse" for="c-42929962">[-]</label><label class="expand" for="c-42929962">[1 more]</label></div><br/><div class="children"><div class="content">I had someone once say “All that ‘cruft’ you complain about, I call ‘bug fixes.’”<p>A mature codebase represents a lot of “tribal investment,” which is sort of like “tribal knowledge.”<p>It’s something that can’t really be quantified, but, nonetheless, is a really significant thing.</div><br/></div></div><div id="42921856" class="c"><input type="checkbox" id="c-42921856" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#42921641">root</a><span>|</span><a href="#42921729">parent</a><span>|</span><a href="#42929962">prev</a><span>|</span><a href="#42923155">next</a><span>|</span><label class="collapse" for="c-42921856">[-]</label><label class="expand" for="c-42921856">[1 more]</label></div><br/><div class="children"><div class="content">All abstractions are leaky, and all pithy sayings have a contradictory and equally pithy counter-saying.<p>True wisdom is knowing which wisdoms to look at and when.</div><br/></div></div><div id="42923155" class="c"><input type="checkbox" id="c-42923155" checked=""/><div class="controls bullet"><span class="by">burningChrome</span><span>|</span><a href="#42921641">root</a><span>|</span><a href="#42921729">parent</a><span>|</span><a href="#42921856">prev</a><span>|</span><a href="#42925910">next</a><span>|</span><label class="collapse" for="c-42923155">[-]</label><label class="expand" for="c-42923155">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; You think you know how to build the new version, but you really don&#x27;t. Years of improvements of the old version, years of bug fixes, years of business knowledge are below the surface.<p>This point has always baffled me. The old adage of &quot;if it ain&#x27;t broke, don&#x27;t fix it.&quot; but then in the past decades of everybody jumping on the JS frameworks and whole heartedly believing by moving to &quot;X&quot; framework, they can eliminate all the issues you have or had with the older version.<p>In my own experience, it never goes this way. Oh sure, do you want to be working in legacy code that&#x27;s 10 plus years old? Probably not, but the idea that every new shiny thing has all the answers to all the issues you had before is a sure fire way to get a lot of people fired for overpromising and underdelivering.</div><br/></div></div></div></div></div></div><div id="42925910" class="c"><input type="checkbox" id="c-42925910" checked=""/><div class="controls bullet"><span class="by">dcastonguay</span><span>|</span><a href="#42921641">prev</a><span>|</span><a href="#42924886">next</a><span>|</span><label class="collapse" for="c-42925910">[-]</label><label class="expand" for="c-42925910">[1 more]</label></div><br/><div class="children"><div class="content">Some of these items were such elegant distillations of my thoughts and feelings that it made me laugh when I read them. To the author: thank you so much for sharing this wisdom.<p>The only thing that I&#x27;ve found difficult to reconcile is the push and pull between those that think they&#x27;re fighting the &quot;you are 90% done&quot; fight and those who think they&#x27;re fighting the &quot;think about pathological data&quot; fight. Essentially, I&#x27;ve personally found the clash between speed and preparedness&#x2F;safety to be a difficult one to solve.</div><br/></div></div><div id="42924886" class="c"><input type="checkbox" id="c-42924886" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42925910">prev</a><span>|</span><a href="#42921571">next</a><span>|</span><label class="collapse" for="c-42924886">[-]</label><label class="expand" for="c-42924886">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not being snarky, really. I was a little struck by:<p>&gt;<i>After the session, I felt that it might be valuable to write my own thoughts up, and add a little more detail. So here we are.</i><p>did the senior developers at the session stay to listen to each other? do you all think alike, did you learn anything from them, or feel that anything they said should be written up?<p>I guess I&#x27;m thinking, what would a junior developer take away after listening to all the presentations, or what should they, from the pov of the senior developers?</div><br/></div></div><div id="42921571" class="c"><input type="checkbox" id="c-42921571" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#42924886">prev</a><span>|</span><a href="#42921678">next</a><span>|</span><label class="collapse" for="c-42921571">[-]</label><label class="expand" for="c-42921571">[2 more]</label></div><br/><div class="children"><div class="content">Same qntm that wrote There Is No Antimemetics Division</div><br/><div id="42928719" class="c"><input type="checkbox" id="c-42928719" checked=""/><div class="controls bullet"><span class="by">geewee</span><span>|</span><a href="#42921571">parent</a><span>|</span><a href="#42921678">next</a><span>|</span><label class="collapse" for="c-42928719">[-]</label><label class="expand" for="c-42928719">[1 more]</label></div><br/><div class="children"><div class="content">Whoa! Small world. That was a fun story.</div><br/></div></div></div></div><div id="42921678" class="c"><input type="checkbox" id="c-42921678" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42921571">prev</a><span>|</span><a href="#42926409">next</a><span>|</span><label class="collapse" for="c-42921678">[-]</label><label class="expand" for="c-42921678">[1 more]</label></div><br/><div class="children"><div class="content">These are all good ideas, particularly the last 5 which are mostly technical.  The first 2 are often influenced by things beyond developers&#x27; control.  For example, developers might be pushed on a schedule that encourages accumulation of technical debt, leading to the inevitable bug bankruptcy and ground-up rewrite.<p>I think every developer should strive to do the right thing, and also be flexible when the right outcome didn&#x27;t happen.</div><br/></div></div><div id="42926409" class="c"><input type="checkbox" id="c-42926409" checked=""/><div class="controls bullet"><span class="by">sevensor</span><span>|</span><a href="#42921678">prev</a><span>|</span><a href="#42924834">next</a><span>|</span><label class="collapse" for="c-42926409">[-]</label><label class="expand" for="c-42926409">[1 more]</label></div><br/><div class="children"><div class="content">The point about edge cases intersects with the one about automating good practice: automate finding edge cases! Property based testing is way more fun than trying to dream up all the gnarly ways things could go wrong, and it’s better at finding them than you are.</div><br/></div></div><div id="42924834" class="c"><input type="checkbox" id="c-42924834" checked=""/><div class="controls bullet"><span class="by">ultra-boss</span><span>|</span><a href="#42926409">prev</a><span>|</span><a href="#42920910">next</a><span>|</span><label class="collapse" for="c-42924834">[-]</label><label class="expand" for="c-42924834">[1 more]</label></div><br/><div class="children"><div class="content">Love this. Would love to see some type of grounded-theory qualitative analysis of Developer Philosophies of many senior software practitioners - can imagine what common themes would emerge, but I&#x27;m more curious to see which pieces <i>feel</i> intuitive and right but aren&#x27;t supported by the majority of senior practitioners.</div><br/></div></div><div id="42920910" class="c"><input type="checkbox" id="c-42920910" checked=""/><div class="controls bullet"><span class="by">robwwilliams</span><span>|</span><a href="#42924834">prev</a><span>|</span><a href="#42923944">next</a><span>|</span><label class="collapse" for="c-42920910">[-]</label><label class="expand" for="c-42920910">[2 more]</label></div><br/><div class="children"><div class="content">Great hard-won insight!
Looking forward to many HN comments on this thread.</div><br/><div id="42922065" class="c"><input type="checkbox" id="c-42922065" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42920910">parent</a><span>|</span><a href="#42923944">next</a><span>|</span><label class="collapse" for="c-42922065">[-]</label><label class="expand" for="c-42922065">[1 more]</label></div><br/><div class="children"><div class="content">Well, <i>there&#x27;s</i> a gauntlet being thrown down if I ever saw one.<p>For me?  Maybe something like:<p>1.  All rules have exceptions - have places that <i>should</i> be exceptions.  Rigidly enforcing a rule may be better than having no rule, but <i>thoughtfully</i> following the rule (almost all the time) is even better.  Know your rules, know <i>why</i> they&#x27;re the rules, and know when it might be reasonable to make an exception.  (Maybe this says that &quot;rules&quot; are really more like &quot;guidelines&quot;.)<p>Rules often come in opposite pairs.  I think of it like this:  In Zion National Park, there&#x27;s a hike called &quot;Angel&#x27;s Landing&quot;.  You wind up going up this ridge.  On one side is a 1000-foot drop-off.  On the other side is a 500 foot drop-off.  The ridge isn&#x27;t all that wide, either.  If you look at one cliff, and you think &quot;I need to be careful not to fall off of that cliff&quot;, and you back too far away from it, then you fall off of the <i>other</i> cliff.<p>I think software engineering can be like that.  There is more than one mistake that you could make.  Don&#x27;t be so busy avoiding one mistake that you make the opposite mistake.  This takes thoughtful understanding, not just blindly following rules.<p>2.  In general, don&#x27;t repeat yourself.  Early in my career, a coworker and I learned to ask ourselves, &quot;Did you fix it <i>everyplace</i>?&quot;  It&#x27;s even better if there&#x27;s only one place.<p>But...  It is common that things start out the same, and then become slightly different (and it gets covered with an &quot;if&quot;), and then become more different (and now we have several &quot;if&quot;s), and then become even more different.  Eventually it can become better to decide that these are actually different things, and split them.  Knowing when to do so is an art rather than a science, but it&#x27;s important.<p>3.  The most general problem cannot be solved.  The trick is to do something simple enough that you can actually finish it, but hard enough that it&#x27;s actually worth doing.  You cannot address this just by changing the lines of code you write; the problem is at the specification level (though it can affect the specification of a module or a function, not just a project).<p>4.  Code that is &quot;close to perfect&quot;, delivered now, may well be better than code that is absolutely perfect, an uncertain amount of time in the future.  It depends on how many imperfections there are, how likely they are to be hit, and how damaging they are when they are hit.  Code that is close to perfect may be perfectly usable to many people; code that hasn&#x27;t shipped yet is currently usable to nobody.  (Note well:  This is <i>not</i> an excuse for sloppiness!  It is an excuse for not going completely hog-wild on perfectionism.)<p>5.  You&#x27;ve got a perfect design?  Great.  As part of delivering the design, deliver an explanation&#x2F;roadmap&#x2F;tour guide for it.  (If it were an electrical design, it might be called a &quot;theory of operation&quot;.)  Consider checking it in to the version control system, right beside the code - like, in the top level directory.<p>6.  All these things take maintenance.  You have to revisit your &quot;don&#x27;t repeat yourself&quot; decisions.  You have to revisit what is within scope and out of scope. 
 You have to revisit which bugs are tolerable and which are not.  You have to update your design documents.  Take the time and do the work.  If you don&#x27;t, your program will slowly become more and more brittle.</div><br/></div></div></div></div><div id="42923944" class="c"><input type="checkbox" id="c-42923944" checked=""/><div class="controls bullet"><span class="by">settsu</span><span>|</span><a href="#42920910">prev</a><span>|</span><a href="#42921085">next</a><span>|</span><label class="collapse" for="c-42923944">[-]</label><label class="expand" for="c-42923944">[1 more]</label></div><br/><div class="children"><div class="content">The #1 rule in my home is &quot;Be kind&quot; (not to be confused with &quot;be nice&quot;.)<p>The #1 rule I <i>try</i> to abide by when coding is &quot;Be empathetic&quot; (to others and my future self.)<p>In practice, this means things like valuing clarity over cleverness (unless I can manage to be both!) and documenting unless I can really justify not (i.e., is it realistically &quot;self-documenting&quot;), but of course also extends to empathy for the user—I&#x27;m a front-end dev so much of my work is UI.<p>You may read this and think &quot;duh&quot; but trust me when I say that in the 20+ years of doing this professionally, those are very clearly not obvious guidelines (even for myself.)</div><br/></div></div><div id="42921085" class="c"><input type="checkbox" id="c-42921085" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#42923944">prev</a><span>|</span><a href="#42923177">next</a><span>|</span><label class="collapse" for="c-42921085">[-]</label><label class="expand" for="c-42921085">[1 more]</label></div><br/><div class="children"><div class="content">Seeing the domain name I really hoped this was some way-out there SF story about computers philosophising about their developers or sth.</div><br/></div></div><div id="42923177" class="c"><input type="checkbox" id="c-42923177" checked=""/><div class="controls bullet"><span class="by">tommica</span><span>|</span><a href="#42921085">prev</a><span>|</span><a href="#42921794">next</a><span>|</span><label class="collapse" for="c-42923177">[-]</label><label class="expand" for="c-42923177">[1 more]</label></div><br/><div class="children"><div class="content">This post really verbalized my own similar experiences so much better than I ever could have:<p>- I always think what could go wrong, but of course, it&#x27;s all about the edge cases!<p>- what the last 10% really consists of.</div><br/></div></div><div id="42921794" class="c"><input type="checkbox" id="c-42921794" checked=""/><div class="controls bullet"><span class="by">wduquette</span><span>|</span><a href="#42923177">prev</a><span>|</span><a href="#42924013">next</a><span>|</span><label class="collapse" for="c-42921794">[-]</label><label class="expand" for="c-42921794">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Nobody cares about the golden path. Edge cases are our entire job.&quot;<p>This is an obvious exaggeration; if you ignore the golden path, the code doesn&#x27;t solve the problem it&#x27;s meant to solve.  But yes; writing reliable code is all about the edge cases.  Eliminate them if you can; code for them if you can&#x27;t.</div><br/><div id="42922139" class="c"><input type="checkbox" id="c-42922139" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42921794">parent</a><span>|</span><a href="#42924013">next</a><span>|</span><label class="collapse" for="c-42922139">[-]</label><label class="expand" for="c-42922139">[3 more]</label></div><br/><div class="children"><div class="content">Back in the 1970s, when I was just a high school kid reading computer magazines, I saw references to a study (I believe by IBM), that said in production code, that 70 or 80% of the lines of code was error handling; only 20% or 30% was the &quot;golden path&quot;.  I&#x27;m not sure I saw an actual reference, even then, and I certainly cannot give a reference now.<p>Does anybody know the study in question?  (I have never seen another study on the topic.  Does anyone else know of one?)<p>This was almost certainly either done in assembly or PL&#x2F;I or Algol or something.  Do more modern languages change it?  Exceptions?  Dual-track programming (options or Maybes)?<p>Regardless of exact numbers, yes, error cases are something you have to think about <i>all the time</i>.</div><br/><div id="42922494" class="c"><input type="checkbox" id="c-42922494" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#42921794">root</a><span>|</span><a href="#42922139">parent</a><span>|</span><a href="#42924013">next</a><span>|</span><label class="collapse" for="c-42922494">[-]</label><label class="expand" for="c-42922494">[2 more]</label></div><br/><div class="children"><div class="content">Maybe this applies to Go code?<p>Snark aside, I am somebody who is <i>very</i> concerned about edge cases, but those ratios seem completely wrong to me for the kind of code I write. And perhaps one should say &quot;corner cases&quot; instead of &quot;error cases&quot;. Corner cases aren&#x27;t necessarily errors. What I find is that a good algorithm that is properly &quot;in tune&quot; with the problem space will often implicitly handle corner cases correctly. While an algorithm that was hacked together by somebody who is &quot;coding to the test&quot; without really understanding the problem space tends to not handle corner cases, and then the developer tries to handle them by adding if-statements to patch their handling.<p>In the end, devoting 70% or 80% of <i>thinking time</i> to corner cases seems entirely plausible to me. 70% or 80% of <i>lines of code</i> dedicated to corner cases may be a smell.</div><br/><div id="42923903" class="c"><input type="checkbox" id="c-42923903" checked=""/><div class="controls bullet"><span class="by">wduquette</span><span>|</span><a href="#42921794">root</a><span>|</span><a href="#42922494">parent</a><span>|</span><a href="#42924013">next</a><span>|</span><label class="collapse" for="c-42923903">[-]</label><label class="expand" for="c-42923903">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the kind of code.  If you&#x27;re automating a process, or handling large quantities of user input, for example, problem cases are everywhere.  Or if you&#x27;re working with a complex problem space where things can compose in unexpected ways (e.g., a language interpreter).</div><br/></div></div></div></div></div></div></div></div><div id="42924013" class="c"><input type="checkbox" id="c-42924013" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#42921794">prev</a><span>|</span><a href="#42927996">next</a><span>|</span><label class="collapse" for="c-42924013">[-]</label><label class="expand" for="c-42924013">[1 more]</label></div><br/><div class="children"><div class="content">I like the list. I&#x27;d add:<p>* Optimize for readability.<p>* The cost of a bug is exponentially proportional to the time between that it was introduced and the time is was discovered (some NIST study): prevent bugs from going to the next phase (requirements -&gt; design -&gt; dev&#x27;t -&gt; staging -&gt; prod).<p>* Favor FP principles such as: separate data and logic (functions); immutability; explicit nulls; prefer pure functions; etc. Even in non-FP languages.<p>* Strong typing disciplines in languages are worth it.</div><br/></div></div><div id="42923775" class="c"><input type="checkbox" id="c-42923775" checked=""/><div class="controls bullet"><span class="by">throw310822</span><span>|</span><a href="#42924903">prev</a><span>|</span><label class="collapse" for="c-42923775">[-]</label><label class="expand" for="c-42923775">[2 more]</label></div><br/><div class="children"><div class="content">Surprisingly boring advice from such an imaginative writer.</div><br/><div id="42924889" class="c"><input type="checkbox" id="c-42924889" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#42923775">parent</a><span>|</span><label class="collapse" for="c-42924889">[-]</label><label class="expand" for="c-42924889">[1 more]</label></div><br/><div class="children"><div class="content">The creative writing and boring advice are both because he&#x27;s smart.</div><br/></div></div></div></div></div></div></div></div></div></body></html>