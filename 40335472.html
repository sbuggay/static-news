<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715590866519" as="style"/><link rel="stylesheet" href="styles.css?v=1715590866519"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://applied-langua.ge/posts/zero-feet.html">Zero Feet: a proposal for a systems-free Lisp</a> <span class="domain">(<a href="https://applied-langua.ge">applied-langua.ge</a>)</span></div><div class="subtext"><span>tosh</span> | <span>26 comments</span></div><br/><div><div id="40339000" class="c"><input type="checkbox" id="c-40339000" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40340645">next</a><span>|</span><label class="collapse" for="c-40339000">[-]</label><label class="expand" for="c-40339000">[8 more]</label></div><br/><div class="children"><div class="content">Writing your obscure language in a popular language has an overwhelming benefit: simplicity of bootstrapping.<p>The user can easily obtain an executable C compiler from their distro or whatever. With that, they build your language.<p>If your language is written in itself entirely, then the user needs an executable of the compiler for your language.<p>There is a second benefit: C is an external language. Nothing that you do in your program changes the C language. If your language is written in itself, and you make changes to it, you&#x27;re changing the language in which your language is written. Mistakes in this can cause hair-pulling bugs.<p>Bootstrapping with another language like C doesn&#x27;t have to mean that anything remains that is written in C in the boostrapped product!<p>A self-in-self thing can be turned into a C boostrapped thing by simply adding an independent, minimal implementation of that language written in C that the user can compile and run, which is capable of running the real self-in-self compiler to compile that compiler and the run-time. Once that is done, the real compiler can be used to again compiler the compiler into a faster compiler and the run-time into a faster run-time. After that, the C boostrapper is not used for anything, and there is no evidence of it in the product.</div><br/><div id="40339056" class="c"><input type="checkbox" id="c-40339056" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#40339000">parent</a><span>|</span><a href="#40339358">next</a><span>|</span><label class="collapse" for="c-40339056">[-]</label><label class="expand" for="c-40339056">[1 more]</label></div><br/><div class="children"><div class="content">While nothing you said is technically wrong, my experience has been that languages that force themselves to dogfood are generally much more pleasant to use than those that are not, both as languages and as tooling. I strongly feel this is not a coincidence. Today&#x27;s &quot;ease of bootstrapping&quot; is 3 years from now &quot;incoherent library hell&quot;.</div><br/></div></div><div id="40339358" class="c"><input type="checkbox" id="c-40339358" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#40339000">parent</a><span>|</span><a href="#40339056">prev</a><span>|</span><a href="#40340507">next</a><span>|</span><label class="collapse" for="c-40339358">[-]</label><label class="expand" for="c-40339358">[5 more]</label></div><br/><div class="children"><div class="content">That does introduce the possibility of a Trusting Trust attack where the original C program could compile the compiler or runtime with a vulnerability that persists until the final compile.  Or a similar vector to the xz attack where everything looks completely normal, except for this old script that was subtly changed and if you bootstrap from c you are vulnerable but if you bootstrapped from the language source itself you are good.</div><br/><div id="40339521" class="c"><input type="checkbox" id="c-40339521" checked=""/><div class="controls bullet"><span class="by">Isamu</span><span>|</span><a href="#40339000">root</a><span>|</span><a href="#40339358">parent</a><span>|</span><a href="#40339714">next</a><span>|</span><label class="collapse" for="c-40339521">[-]</label><label class="expand" for="c-40339521">[1 more]</label></div><br/><div class="children"><div class="content">&gt;but if you bootstrapped from the language source itself you are good<p>No, that’s exactly what Ken Thompson was describing in Trusting Trust. You always have to bootstrap the compiler, but once you do, you use the compiler to compile itself and all future versions. So you use that circularity to hide the evidence of a back door in the compiler. It applies to all bootstrapped languages.</div><br/></div></div><div id="40339714" class="c"><input type="checkbox" id="c-40339714" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40339000">root</a><span>|</span><a href="#40339358">parent</a><span>|</span><a href="#40339521">prev</a><span>|</span><a href="#40340507">next</a><span>|</span><label class="collapse" for="c-40339714">[-]</label><label class="expand" for="c-40339714">[3 more]</label></div><br/><div class="children"><div class="content">You cannot get around the Ken Thompson problem because all bootstrapping starts with some trusted binary that compiles your level 0 sources.<p>Now, sure, if your chain does not involve C, then it is immune to a compromised C compilers; how could C compilers do anything to it, that are not installed or run?<p>However, you&#x27;re vulnerable to a doctored binary of your language.<p>Bootstrapping your Language X from C helps you here also, for multiple reasons.<p>Reason 1: there is no recursive cycle when you externally boostrap from another language. Even if a C compiler is doctored in order to recognize that it&#x27;s boostrapping Language X, and do something malicious, that malicious thing will not propagate to new Language X installations. Reason being that the build output of Language X is not used for further bootstrapping new Language X instances. The other language is always used for boostrapping. All proliferation of the hack has to propagate through the ecosystem of that other language.<p>Reason 2: Language X is less popular than the boostrapping language, which makes its ecosystem vulnerable. If a vulnerable language with a tiny ecosystem is boostrapped using ready-made binaries of itself, those binaries are likely only available from one site. If those are infected, it&#x27;s game over.<p>Reason 3: Language X development does not develop the host language (such as C). C is not of interest to the Language X project, and can be conservatively used, so that Language X will build fine with a 20 year old GCC. Even if a bad actor attacks Language X by getting malicious code upstreamed into GCC, that attack won&#x27;t appear in old versions of GCC. (By the same token, Language X written in Language X could also use a conservative dialect of Language X for boostrapping, so that a many-years-old implementation of it with a widely known SHA-256 can be used.)</div><br/><div id="40340722" class="c"><input type="checkbox" id="c-40340722" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#40339000">root</a><span>|</span><a href="#40339714">parent</a><span>|</span><a href="#40340221">next</a><span>|</span><label class="collapse" for="c-40340722">[-]</label><label class="expand" for="c-40340722">[1 more]</label></div><br/><div class="children"><div class="content">Yep I slipped up there.<p>There is a defense against the trusting trust attack. It basically involves using two different compilers and checking their output matches. You can find the article about it if you search.</div><br/></div></div><div id="40340221" class="c"><input type="checkbox" id="c-40340221" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#40339000">root</a><span>|</span><a href="#40339714">parent</a><span>|</span><a href="#40340722">prev</a><span>|</span><a href="#40340507">next</a><span>|</span><label class="collapse" for="c-40340221">[-]</label><label class="expand" for="c-40340221">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However, you&#x27;re vulnerable to a doctored binary of your language.<p>I think obscure language X being written in language X is more of a security benefit because it is more likely that a much greater portion of those who use language X are better able to recognise weirdness than if there are parts of your computing environment that are essentially blackboxes.</div><br/></div></div></div></div></div></div><div id="40340507" class="c"><input type="checkbox" id="c-40340507" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#40339000">parent</a><span>|</span><a href="#40339358">prev</a><span>|</span><a href="#40340645">next</a><span>|</span><label class="collapse" for="c-40340507">[-]</label><label class="expand" for="c-40340507">[1 more]</label></div><br/><div class="children"><div class="content">Could be a good idea to maintain a very simple stable reference C implementation for bootstrapping and testing purposes while later developing a more complex one in the language itself.</div><br/></div></div></div></div><div id="40340645" class="c"><input type="checkbox" id="c-40340645" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40339000">prev</a><span>|</span><a href="#40339900">next</a><span>|</span><label class="collapse" for="c-40340645">[-]</label><label class="expand" for="c-40340645">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; A more interesting problem is that, if almost every construct in the language is a message send, and all of the implementation is written in the language, handling a message send may cause infinite recursion.</i><p>This is where I suggest reading Ian Piumarta&#x27;s <i>Open, extensible object models</i> [1] and later his <i>COLA</i> paper [2]<p>Piumarta tried to imagine an entire late-bound, meta-circular system based around message passing, starting from as little C as possible to build a Smalltalk-like language. It is a small paper that had be obsessed for a year trying to imagine how to implement an entire OS based on it. Worth a read.<p>And in the theme of meta-circular Lisp, he also worked on Maru [3]<p>1: <a href="https:&#x2F;&#x2F;www.piumarta.com&#x2F;software&#x2F;id-objmodel&#x2F;objmodel2.pdf" rel="nofollow">https:&#x2F;&#x2F;www.piumarta.com&#x2F;software&#x2F;id-objmodel&#x2F;objmodel2.pdf</a><p>2: <a href="https:&#x2F;&#x2F;www.piumarta.com&#x2F;software&#x2F;cola&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.piumarta.com&#x2F;software&#x2F;cola&#x2F;</a><p>3: <a href="https:&#x2F;&#x2F;www.piumarta.com&#x2F;software&#x2F;maru&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.piumarta.com&#x2F;software&#x2F;maru&#x2F;</a></div><br/></div></div><div id="40339900" class="c"><input type="checkbox" id="c-40339900" checked=""/><div class="controls bullet"><span class="by">mise_en_place</span><span>|</span><a href="#40340645">prev</a><span>|</span><a href="#40337941">next</a><span>|</span><label class="collapse" for="c-40339900">[-]</label><label class="expand" for="c-40339900">[7 more]</label></div><br/><div class="children"><div class="content">I really hope this won’t be taken the wrong way, but why are these people always fighting the last war? Brendan Eich was already doing this in the 90s when developing JavaScript.<p>I disagree with a lot of what Jonathon Blow says, but he’s correct when he said that even the most trivial of projects are regarded with awe, as if they’re some insane and innovative skunkworks project. There are problems that need solving, that are in dire need of solving, but nobody seems to care about them. What we end up with is more and more bloated frameworks and languages that nobody uses after a week.</div><br/><div id="40340238" class="c"><input type="checkbox" id="c-40340238" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#40339900">parent</a><span>|</span><a href="#40340556">next</a><span>|</span><label class="collapse" for="c-40340238">[-]</label><label class="expand" for="c-40340238">[3 more]</label></div><br/><div class="children"><div class="content">What was Brendan Eich doing that is covered in this article?</div><br/><div id="40340260" class="c"><input type="checkbox" id="c-40340260" checked=""/><div class="controls bullet"><span class="by">mise_en_place</span><span>|</span><a href="#40339900">root</a><span>|</span><a href="#40340238">parent</a><span>|</span><a href="#40340556">next</a><span>|</span><label class="collapse" for="c-40340260">[-]</label><label class="expand" for="c-40340260">[2 more]</label></div><br/><div class="children"><div class="content">LISP in the browser, although he used Self instead of Newspeak for objects and Scheme as the blueprint for LISP. For systems language LISP, there are already many languages available for BEAM, like LFE and Elixir.</div><br/><div id="40340295" class="c"><input type="checkbox" id="c-40340295" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#40339900">root</a><span>|</span><a href="#40340260">parent</a><span>|</span><a href="#40340556">next</a><span>|</span><label class="collapse" for="c-40340295">[-]</label><label class="expand" for="c-40340295">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t about Lisp in the browser though, it&#x27;s about high-level low-level programming (to borrow the name from Daniel Frampton &lt;<a href="https:&#x2F;&#x2F;www.steveblackburn.org&#x2F;pubs&#x2F;theses&#x2F;frampton-2010.pdf" rel="nofollow">https:&#x2F;&#x2F;www.steveblackburn.org&#x2F;pubs&#x2F;theses&#x2F;frampton-2010.pdf</a>&gt;).</div><br/></div></div></div></div></div></div><div id="40340556" class="c"><input type="checkbox" id="c-40340556" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#40339900">parent</a><span>|</span><a href="#40340238">prev</a><span>|</span><a href="#40340091">next</a><span>|</span><label class="collapse" for="c-40340556">[-]</label><label class="expand" for="c-40340556">[1 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s fun. Not everything is a war. I just want to make a language that I would enjoy using. I don&#x27;t exactly expect it to reach the TIOBE top 10.<p>There is an infinite number of problems out there that &quot;need&quot; solving. The thing is I don&#x27;t really care about those problems. They&#x27;d have to pay money to get me to even think about them. These &quot;trivial&quot; projects though? Those provide me with plenty of intrinsic motivation. I like working with the unseen infrastructure that everybody takes for granted.</div><br/></div></div><div id="40340091" class="c"><input type="checkbox" id="c-40340091" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40339900">parent</a><span>|</span><a href="#40340556">prev</a><span>|</span><a href="#40337941">next</a><span>|</span><label class="collapse" for="c-40340091">[-]</label><label class="expand" for="c-40340091">[2 more]</label></div><br/><div class="children"><div class="content">What do you consider in dire need of solving?</div><br/><div id="40340236" class="c"><input type="checkbox" id="c-40340236" checked=""/><div class="controls bullet"><span class="by">mise_en_place</span><span>|</span><a href="#40339900">root</a><span>|</span><a href="#40340091">parent</a><span>|</span><a href="#40337941">next</a><span>|</span><label class="collapse" for="c-40340236">[-]</label><label class="expand" for="c-40340236">[1 more]</label></div><br/><div class="children"><div class="content">webGL and WASM for one thing. Of course it is dependent on the implementation, but it seems to have abysmal performance.<p>In line with that, there needs to be a good FOSS replacement of Unity. I know Godot exists but more open game engines will help.<p>Those are just a few off of the top of my head.</div><br/></div></div></div></div></div></div><div id="40337941" class="c"><input type="checkbox" id="c-40337941" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#40339900">prev</a><span>|</span><a href="#40340604">next</a><span>|</span><label class="collapse" for="c-40337941">[-]</label><label class="expand" for="c-40337941">[4 more]</label></div><br/><div class="children"><div class="content">If I understand the point of this, I believe Coral Common Lisp (now Clozure CL) has always been this way, if not more so. The lowest level is a Lisp program generating native machine code. [0] There’s no lower-level implementation language or even a bytecode translator.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Clozure&#x2F;ccl&#x2F;tree&#x2F;master&#x2F;level-0&#x2F;ARM">https:&#x2F;&#x2F;github.com&#x2F;Clozure&#x2F;ccl&#x2F;tree&#x2F;master&#x2F;level-0&#x2F;ARM</a></div><br/><div id="40338265" class="c"><input type="checkbox" id="c-40338265" checked=""/><div class="controls bullet"><span class="by">hipparcos</span><span>|</span><a href="#40337941">parent</a><span>|</span><a href="#40340604">next</a><span>|</span><label class="collapse" for="c-40338265">[-]</label><label class="expand" for="c-40338265">[3 more]</label></div><br/><div class="children"><div class="content">Interesting. Although I think the author advocates for going a step further than CCL. My understanding is that the GC of CCL is implemented by its lisp kernel [0]. The lisp kernel is a platform specific C &#x2F; ASM program which seems to provide a runtime for CCL. The author states that the GC should be written in the
language itself.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Clozure&#x2F;ccl&#x2F;blob&#x2F;master&#x2F;lisp-kernel&#x2F;gc-common.c#L1547">https:&#x2F;&#x2F;github.com&#x2F;Clozure&#x2F;ccl&#x2F;blob&#x2F;master&#x2F;lisp-kernel&#x2F;gc-co...</a></div><br/><div id="40338447" class="c"><input type="checkbox" id="c-40338447" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#40337941">root</a><span>|</span><a href="#40338265">parent</a><span>|</span><a href="#40338438">next</a><span>|</span><label class="collapse" for="c-40338447">[-]</label><label class="expand" for="c-40338447">[1 more]</label></div><br/><div class="children"><div class="content">Ah, so there is some C! Thanks for the correction. I haven’t worked on it since 68K CCL days (like, 1990) and I’m almost positive there was no C in that version, just inline assembler in Lisp. It was awesome.</div><br/></div></div></div></div></div></div><div id="40340604" class="c"><input type="checkbox" id="c-40340604" checked=""/><div class="controls bullet"><span class="by">flembat</span><span>|</span><a href="#40337941">prev</a><span>|</span><a href="#40337367">next</a><span>|</span><label class="collapse" for="c-40340604">[-]</label><label class="expand" for="c-40340604">[1 more]</label></div><br/><div class="children"><div class="content">It seems fairly normal to write lisp compilers in lisp, you tend to see them wrapped in a c shell sometimes, and to use c to talk to the system for io.
It also seems easier to write the garbage collector in c than write it in the language being garbage collected.
But .. take a typical lisp compiler and generate a standalone exe, possibly reimplement the gc, at least unlike other languages you still have the compiler, and can reimpliment the c wrapper in your native ffi. Job done I think.</div><br/></div></div><div id="40337367" class="c"><input type="checkbox" id="c-40337367" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#40340604">prev</a><span>|</span><a href="#40337354">next</a><span>|</span><label class="collapse" for="c-40337367">[-]</label><label class="expand" for="c-40337367">[3 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t Symbolics&#x27; Genera OS fully Lisp all the way down?</div><br/><div id="40339060" class="c"><input type="checkbox" id="c-40339060" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#40337367">parent</a><span>|</span><a href="#40337407">next</a><span>|</span><label class="collapse" for="c-40339060">[-]</label><label class="expand" for="c-40339060">[1 more]</label></div><br/><div class="children"><div class="content">Sort of. Some ops that a typical lisp would have in the std lib it has in hardware, though.</div><br/></div></div><div id="40337407" class="c"><input type="checkbox" id="c-40337407" checked=""/><div class="controls bullet"><span class="by">e40</span><span>|</span><a href="#40337367">parent</a><span>|</span><a href="#40339060">prev</a><span>|</span><a href="#40337354">next</a><span>|</span><label class="collapse" for="c-40337407">[-]</label><label class="expand" for="c-40337407">[1 more]</label></div><br/><div class="children"><div class="content">Yes, definitely.</div><br/></div></div></div></div><div id="40337354" class="c"><input type="checkbox" id="c-40337354" checked=""/><div class="controls bullet"><span class="by">NeutralForest</span><span>|</span><a href="#40337367">prev</a><span>|</span><label class="collapse" for="c-40337354">[-]</label><label class="expand" for="c-40337354">[1 more]</label></div><br/><div class="children"><div class="content">Not sure I understand all the ideas presented but it was an interesting read, thanks!</div><br/></div></div></div></div></div></div></div></body></html>