<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714813258525" as="style"/><link rel="stylesheet" href="styles.css?v=1714813258525"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://glitchcomet.com/articles/1024-bit-primes/">How hard can generating 1024-bit primes be?</a>Â <span class="domain">(<a href="https://glitchcomet.com">glitchcomet.com</a>)</span></div><div class="subtext"><span>techedlaksh</span> | <span>62 comments</span></div><br/><div><div id="40252687" class="c"><input type="checkbox" id="c-40252687" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#40255964">next</a><span>|</span><label class="collapse" for="c-40252687">[-]</label><label class="expand" for="c-40252687">[4 more]</label></div><br/><div class="children"><div class="content">Related, there are a few cryptocurrencies that used things related to finding large primes as part of their proof of work functions. It turns out that ~8 years ago, a really fast primality test implementation could make you a lot of money. (For some period of time I was the author and maintainer of mining software for riecoin. Why, I have no idea, except that I like prime numbers.)<p>This article omits the number one optimization for fast primality testing: Montgomery multiplication<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Montgomery_modular_multiplication" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Montgomery_modular_multiplic...</a><p>It forms the basis of fast practical modular exponentiation implementations.<p>Niall Emmart, then in academia and now I believe at Nvidia, released a really, spectacularly fast GPU bigint library, CGBN: <a href="https:&#x2F;&#x2F;github.com&#x2F;NVlabs&#x2F;CGBN">https:&#x2F;&#x2F;github.com&#x2F;NVlabs&#x2F;CGBN</a><p>It&#x27;s still the fastest batch modexp implentation that I&#x27;m aware of. It&#x27;s breathtaking, if I can gush in geek for a moment.<p>(Someday I should write up the story of how that helped me dominate production of a small cryptocurrency for about 5 years. Thanks, Niall - owe you a beer if we ever cross paths!)<p>Also worth noting that python includes an entirely fine modexp in the three-argument form of pow(x, y, m) --&gt; compute x^y % m<p>With that, you can very easily implement a fermat or miller-rabin primality test if you want to roll your own, which is quite fun. If you don&#x27;t, the gmp library provides a very nice mpz_probab_prime() function. Gmp is obviously faster, but it&#x27;s hard to beat the fun of a two liner fermat test for playing with big primes.</div><br/><div id="40253927" class="c"><input type="checkbox" id="c-40253927" checked=""/><div class="controls bullet"><span class="by">kwantam</span><span>|</span><a href="#40252687">parent</a><span>|</span><a href="#40253127">next</a><span>|</span><label class="collapse" for="c-40253927">[-]</label><label class="expand" for="c-40253927">[2 more]</label></div><br/><div class="children"><div class="content">Great stuff dga :)<p>Turns out, Niall was also involved in one of the winning ZPrize submissions for fast multi-scalar multiplication (closely related to batch modexp, although over an elliptic curve rather than mod a prime); I assume it inherits from his work on CGBN.<p>He give a very nice talk about it last year at a Stanford crypto lunch, and it turns out the slides and recording are online!<p><a href="https:&#x2F;&#x2F;cbr.stanford.edu&#x2F;seminarTalks&#x2F;slides_20230526_niall_emmart.pptx" rel="nofollow">https:&#x2F;&#x2F;cbr.stanford.edu&#x2F;seminarTalks&#x2F;slides_20230526_niall_...</a><p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KAWlySN7Hm8" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KAWlySN7Hm8</a></div><br/><div id="40254081" class="c"><input type="checkbox" id="c-40254081" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#40252687">root</a><span>|</span><a href="#40253927">parent</a><span>|</span><a href="#40253127">next</a><span>|</span><label class="collapse" for="c-40254081">[-]</label><label class="expand" for="c-40254081">[1 more]</label></div><br/><div class="children"><div class="content">Howdy, neighbor! Thanks for this - I&#x27;m glad to hear he&#x27;s still doing cool stuff. I&#x27;m off to watch that now, in fact... :-)</div><br/></div></div></div></div><div id="40253127" class="c"><input type="checkbox" id="c-40253127" checked=""/><div class="controls bullet"><span class="by">mxwsn</span><span>|</span><a href="#40252687">parent</a><span>|</span><a href="#40253927">prev</a><span>|</span><a href="#40255964">next</a><span>|</span><label class="collapse" for="c-40253127">[-]</label><label class="expand" for="c-40253127">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to read that story. Please do write it up!</div><br/></div></div></div></div><div id="40255964" class="c"><input type="checkbox" id="c-40255964" checked=""/><div class="controls bullet"><span class="by">tails4e</span><span>|</span><a href="#40252687">prev</a><span>|</span><a href="#40254238">next</a><span>|</span><label class="collapse" for="c-40255964">[-]</label><label class="expand" for="c-40255964">[1 more]</label></div><br/><div class="children"><div class="content">Really nice writeup. For the test, could Fermat&#x27;s method be used to find candidates and then trial division to weed out the false positives? Given they are rare this should not cost much extra time as the trial division (with some precomputed divisiors) is rarely used.</div><br/></div></div><div id="40254238" class="c"><input type="checkbox" id="c-40254238" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40255964">prev</a><span>|</span><a href="#40252010">next</a><span>|</span><label class="collapse" for="c-40254238">[-]</label><label class="expand" for="c-40254238">[11 more]</label></div><br/><div class="children"><div class="content">One line of inline assembler makes the bignum school multiplication trivial: <a href="https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;toy-rsa&#x2F;blob&#x2F;master&#x2F;bfi.c#L437">https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;toy-rsa&#x2F;blob&#x2F;master&#x2F;bfi.c#L4...</a><p>If I could go back in time and change one thing about the C language, I would add some notion of expanding multiplication. It&#x27;s a shame Rust doesn&#x27;t have it either. Hardware support is everywhere: hell, the Cortex M0 doesn&#x27;t do division, but it has an expanding multiply!<p>This is from a very ugly little toy implementation of RSA I wrote a long time ago: <a href="https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;toy-rsa">https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;toy-rsa</a><p>I found I could get away with the Fermat test, because the algorithm doesn&#x27;t work if the primes aren&#x27;t actually prime: the Fermat test is fast, and an encrypt&#x2F;decrypt eliminates the extremely minuscule chance either prime is a fermat liar.<p>But I don&#x27;t know if it can be proven there do not exist non-prime P&#x2F;Q values which produce an RSA keypair which can successfully encrypt&#x2F;decrypt messages. I&#x27;m sure this isn&#x27;t kosher for a real implementation, but I&#x27;ve never found an answer.</div><br/><div id="40255980" class="c"><input type="checkbox" id="c-40255980" checked=""/><div class="controls bullet"><span class="by">AndriyKunitsyn</span><span>|</span><a href="#40254238">parent</a><span>|</span><a href="#40255878">next</a><span>|</span><label class="collapse" for="c-40255980">[-]</label><label class="expand" for="c-40255980">[1 more]</label></div><br/><div class="children"><div class="content">Curiously, C actually has bignums. Now. In C23, they added a _BitInt(N) type (e.g., &quot;_BitInt(1024)&quot; for a 128-byte type).<p>The compiler support for that is limited, though. To let N be &gt;128 in Clang, -fexperimental-max-bitint-width=N flag can be provided. If N&gt;128 and _BitInt(N) is divided by something, the compiler will just crash, but +, -, * all work as expected.</div><br/></div></div><div id="40255878" class="c"><input type="checkbox" id="c-40255878" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#40254238">parent</a><span>|</span><a href="#40255980">prev</a><span>|</span><a href="#40254948">next</a><span>|</span><label class="collapse" for="c-40255878">[-]</label><label class="expand" for="c-40255878">[1 more]</label></div><br/><div class="children"><div class="content">The original Pretty Good Privacy (PGP) by Philip Zimmermann in 1994 used only a sieve that divided by all known 16-bit primes (this table was produced using the Sieve of Eratosthenes), followed by the Fermat test.</div><br/></div></div><div id="40254948" class="c"><input type="checkbox" id="c-40254948" checked=""/><div class="controls bullet"><span class="by">cbright</span><span>|</span><a href="#40254238">parent</a><span>|</span><a href="#40255878">prev</a><span>|</span><a href="#40254394">next</a><span>|</span><label class="collapse" for="c-40254948">[-]</label><label class="expand" for="c-40254948">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But I don&#x27;t know if it can be proven there do not exist non-prime P&#x2F;Q values which produce an RSA keypair which can successfully encrypt&#x2F;decrypt messages. I&#x27;m sure this isn&#x27;t kosher for a real implementation, but I&#x27;ve never found an answer.<p>If p and q are coprime Carmichael numbers then RSA will still successfully encrypt and decrypt messages, though this will be less secure as p*q will have smaller prime factors and thus be easier to factor.</div><br/></div></div><div id="40254394" class="c"><input type="checkbox" id="c-40254394" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40254238">parent</a><span>|</span><a href="#40254948">prev</a><span>|</span><a href="#40254405">next</a><span>|</span><label class="collapse" for="c-40254394">[-]</label><label class="expand" for="c-40254394">[5 more]</label></div><br/><div class="children"><div class="content">I believe that both in most C compilers and in Rust, casting to a bigger type and multiplying does produce the exact opcode.</div><br/><div id="40254744" class="c"><input type="checkbox" id="c-40254744" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40254238">root</a><span>|</span><a href="#40254394">parent</a><span>|</span><a href="#40254498">next</a><span>|</span><label class="collapse" for="c-40254744">[-]</label><label class="expand" for="c-40254744">[2 more]</label></div><br/><div class="children"><div class="content">Of course. But that&#x27;s ugly and hard to follow compared to the C implementation I linked (at least, in my opinion).<p>And int128 support isn&#x27;t ubiquitous.</div><br/><div id="40255970" class="c"><input type="checkbox" id="c-40255970" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#40254238">root</a><span>|</span><a href="#40254744">parent</a><span>|</span><a href="#40254498">next</a><span>|</span><label class="collapse" for="c-40255970">[-]</label><label class="expand" for="c-40255970">[1 more]</label></div><br/><div class="children"><div class="content">Even so, if you wrap it in a function and make sure to document what&#x27;s happening, I would argue that a version without asm() is preferable. It gives the compiler more leeway for optimization and is easier to read for someone who isn&#x27;t well-versed in GCC&#x27;s weird asm syntax.<p>See the generated code for these two alternative implementations: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;3vno6G46j" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;3vno6G46j</a></div><br/></div></div></div></div><div id="40254498" class="c"><input type="checkbox" id="c-40254498" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#40254238">root</a><span>|</span><a href="#40254394">parent</a><span>|</span><a href="#40254744">prev</a><span>|</span><a href="#40254405">next</a><span>|</span><label class="collapse" for="c-40254498">[-]</label><label class="expand" for="c-40254498">[2 more]</label></div><br/><div class="children"><div class="content">On 64-bit hosts using the full widening multiplier requires that you use 128 bit integers-- which aren&#x27;t portable. :( (in particular, MSVC doesn&#x27;t have it last I checked).  It&#x27;s the obvious thing to do where they exist however.</div><br/><div id="40254651" class="c"><input type="checkbox" id="c-40254651" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40254238">root</a><span>|</span><a href="#40254498">parent</a><span>|</span><a href="#40254405">next</a><span>|</span><label class="collapse" for="c-40254651">[-]</label><label class="expand" for="c-40254651">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, a lack of guaranteed existence of uint128_t is problematic for C. (But __int128 <i>is</i> reasonably portable!) Rust always has u128&#x2F;i128 in comparison.</div><br/></div></div></div></div></div></div><div id="40254405" class="c"><input type="checkbox" id="c-40254405" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#40254238">parent</a><span>|</span><a href="#40254394">prev</a><span>|</span><a href="#40252010">next</a><span>|</span><label class="collapse" for="c-40254405">[-]</label><label class="expand" for="c-40254405">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I would add some notion of expanding multiplication.</i><p>C type promotion is complicated enough!<p>Intrinsics expose this adequately, don&#x27;t you think?</div><br/><div id="40254767" class="c"><input type="checkbox" id="c-40254767" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40254238">root</a><span>|</span><a href="#40254405">parent</a><span>|</span><a href="#40252010">next</a><span>|</span><label class="collapse" for="c-40254767">[-]</label><label class="expand" for="c-40254767">[1 more]</label></div><br/><div class="children"><div class="content">I want an explicit operation that gives the upper and lower half of the result separately. This is ugly, but like:<p><pre><code>  hi, lo = val1 *** val2;
</code></pre>
It isn&#x27;t necessarily intrinsically supported on all platforms: int128 is not part of the original standard. Sometimes long long is the same width as long.<p>I think the concept generalizes to non-binary and non-twos-complement CPUs easily enough.</div><br/></div></div></div></div></div></div><div id="40252010" class="c"><input type="checkbox" id="c-40252010" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#40254238">prev</a><span>|</span><a href="#40253460">next</a><span>|</span><label class="collapse" for="c-40252010">[-]</label><label class="expand" for="c-40252010">[8 more]</label></div><br/><div class="children"><div class="content">&gt; This is where things start to get interesting. At first, I found the concept of probabilistic primality tests strange and tried to look for deterministic algorithms that could handle huge numbers. I did find two - APR-CL and ECPP. Both of these are so mathematically complex that I could not make sense of their research papers at all, and there isn&#x27;t much accessible information about them on the internet for someone like me who is bad at math.<p>&gt; After taking a look at discussions online, OpenSSL&#x27;s source code and recommendations by NIST, I realized that almost everyone including RSA uses probabilistic algorithms. The catch is that if implemented properly, these algorithms have an extremely low error rate which is negligible.<p>For a given maximum number range, it&#x27;s trivial to make Miller-Rabin actually deterministic. You just choose bases that have been proven to together exclude all pseudoprimes in the given range.<p>(It doesn&#x27;t even end up being a long list, Miller-Rabin kicks ass)</div><br/><div id="40252931" class="c"><input type="checkbox" id="c-40252931" checked=""/><div class="controls bullet"><span class="by">mateo1</span><span>|</span><a href="#40252010">parent</a><span>|</span><a href="#40252502">next</a><span>|</span><label class="collapse" for="c-40252931">[-]</label><label class="expand" for="c-40252931">[1 more]</label></div><br/><div class="children"><div class="content">Besides, when you&#x27;re just looking for a prime, you can spot things that look like a prime and test them deterministically.</div><br/></div></div><div id="40252502" class="c"><input type="checkbox" id="c-40252502" checked=""/><div class="controls bullet"><span class="by">GaggiX</span><span>|</span><a href="#40252010">parent</a><span>|</span><a href="#40252931">prev</a><span>|</span><a href="#40253460">next</a><span>|</span><label class="collapse" for="c-40252502">[-]</label><label class="expand" for="c-40252502">[6 more]</label></div><br/><div class="children"><div class="content">&gt;For a given maximum number range, it&#x27;s trivial to make Miller-Rabin actually deterministic. You just choose bases that have been proven to together exclude all pseudoprimes in the given range.<p>What are the bases for the range of 1024-bit numbers? I couldn&#x27;t find an answer online.</div><br/><div id="40252648" class="c"><input type="checkbox" id="c-40252648" checked=""/><div class="controls bullet"><span class="by">glitchcomet</span><span>|</span><a href="#40252010">root</a><span>|</span><a href="#40252502">parent</a><span>|</span><a href="#40253460">next</a><span>|</span><label class="collapse" for="c-40252648">[-]</label><label class="expand" for="c-40252648">[5 more]</label></div><br/><div class="children"><div class="content">You can find the bases for N &lt; 3x10^21 on wikipedia [0] which make Miller-Rabin deterministic. 1024 bit numbers have ~300 digits and as far as i know, no known bases exist for that range.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Miller%E2%80%93Rabin_primality_test#Testing_against_small_sets_of_bases" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Miller%E2%80%93Rabin_primality...</a></div><br/><div id="40253793" class="c"><input type="checkbox" id="c-40253793" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#40252010">root</a><span>|</span><a href="#40252648">parent</a><span>|</span><a href="#40253006">next</a><span>|</span><label class="collapse" for="c-40253793">[-]</label><label class="expand" for="c-40253793">[3 more]</label></div><br/><div class="children"><div class="content">Just testing all the bases from 2 through 2 log(N)^2 doesn&#x27;t actually seem to be too bad for N around 2^1024. It would be a little under 1007600 bases.<p>I&#x27;ve got a Miller-Rabin implementation in Python 3. Testing 2^1024 + 643, which is the first prime greater than 2^1024 with 65 random bases takes about 0.25 seconds on my Mac Studio. This is with no attempts at optimization or at using multiple cores.<p>At that rate testing 1007600 bases would take under 65 minutes.<p>Certainly way longer than you&#x27;d want to wait around for something like key generation, but if you didn&#x27;t actually <i>need</i> your prime for an hour and really wanted to be certain it was a prime its not outrageous.<p>EDIT: I modified my Miller-Rabin to be the deterministic version, and made it take two parameters: cores and worker. I modified the loop that runs through the bases from 2 to floor(2 log(N)^2) to only actually test when &quot;cores == 1 or base % cores == worker&quot;. I made my test program take cores and worker on the command line.<p>Then I ran this shell script, where prime.py is a program that checks 2^1024 + 643 for primality with the aforementioned deterministic Rabin-Miller:<p><pre><code>  .&#x2F;prime.py 8 0 &amp;
  .&#x2F;prime.py 8 1 &amp;
  .&#x2F;prime.py 8 2 &amp;
  .&#x2F;prime.py 8 3 &amp;
  .&#x2F;prime.py 8 4 &amp;
  .&#x2F;prime.py 8 5 &amp;
  .&#x2F;prime.py 8 6 &amp;
  .&#x2F;prime.py 8 7 &amp;
  wait
</code></pre>
Each of those 8 copies is testing a different 1&#x2F;8th of the bases that need to be tested. My computer has 8 performance cores and the hope was that MacOS would run each on a different core. That did seem to be the case.<p>It took 392 seconds for them all to complete, with each correctly reporting that 2^1024 + 643 has passed for all their bases.</div><br/><div id="40254416" class="c"><input type="checkbox" id="c-40254416" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40252010">root</a><span>|</span><a href="#40253793">parent</a><span>|</span><a href="#40254336">next</a><span>|</span><label class="collapse" for="c-40254416">[-]</label><label class="expand" for="c-40254416">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just testing all the bases from 2 through 2 log(N)^2 doesn&#x27;t actually seem to be too bad for N around 2^1024. It would be a little under 1007600 bases.<p>Unfortunately this limit depends on the currently unproven conjecture (a subset of the generalized Riemann hypothesis). You have to check all n bases to be unconditionally correct.</div><br/></div></div><div id="40254336" class="c"><input type="checkbox" id="c-40254336" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#40252010">root</a><span>|</span><a href="#40253793">parent</a><span>|</span><a href="#40254416">prev</a><span>|</span><a href="#40253006">next</a><span>|</span><label class="collapse" for="c-40254336">[-]</label><label class="expand" for="c-40254336">[1 more]</label></div><br/><div class="children"><div class="content">Here is prime.py if anyone wants to play around with it: <a href="https:&#x2F;&#x2F;pastebin.com&#x2F;FFw4qrvU" rel="nofollow">https:&#x2F;&#x2F;pastebin.com&#x2F;FFw4qrvU</a></div><br/></div></div></div></div><div id="40253006" class="c"><input type="checkbox" id="c-40253006" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#40252010">root</a><span>|</span><a href="#40252648">parent</a><span>|</span><a href="#40253793">prev</a><span>|</span><a href="#40253460">next</a><span>|</span><label class="collapse" for="c-40253006">[-]</label><label class="expand" for="c-40253006">[1 more]</label></div><br/><div class="children"><div class="content">Oh, woops. I thought the list went way higher, my bad.<p>I did read that I think if you do up to 2*ln(n)^2 you&#x27;re always good, but that&#x27;s not _that_ short of a list. Probably better off just keeping it probabalistic, negating my original post :(</div><br/></div></div></div></div></div></div></div></div><div id="40253460" class="c"><input type="checkbox" id="c-40253460" checked=""/><div class="controls bullet"><span class="by">Ditiris</span><span>|</span><a href="#40252010">prev</a><span>|</span><a href="#40253462">next</a><span>|</span><label class="collapse" for="c-40253460">[-]</label><label class="expand" for="c-40253460">[1 more]</label></div><br/><div class="children"><div class="content">How long did this take you? Curious as I did an undergrad research project on multiplying large integers that basically took two semesters. I implemented Karatsuba, Toom-Cook, the complex FFT, a few NTTs, and Schonhage-Strassen. Primes are basically math magic. <i>A Friendly Introduction to Number Theory</i> by Silverman is an amazing math book for those interested.<p>FYI the link on your page reads 4025051 instead of 40250519.</div><br/></div></div><div id="40253462" class="c"><input type="checkbox" id="c-40253462" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40253460">prev</a><span>|</span><a href="#40252105">next</a><span>|</span><label class="collapse" for="c-40253462">[-]</label><label class="expand" for="c-40253462">[1 more]</label></div><br/><div class="children"><div class="content">Nice article! I&#x27;ve also rolled some of my own bigint code recently (for earlier versions of [0]), and I can recall how frustrating it was to translate high-level descriptions in math papers into actual operations.<p>I do have a small quibble, though:<p>&gt; At this point, the BigInt is using base-(2^64-1) or base-18446744073709551615 and it only needs 16 &quot;digits&quot; to represent a number that uses 309 digits in base-10!<p>If you use the full range of a u64, then your number will be in base 2^64, with each word ranging from 0 to 2^64-1, in the same way that base-10 digits range from 0 to 9.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;LegionMammal978&#x2F;bigfoot-sim">https:&#x2F;&#x2F;github.com&#x2F;LegionMammal978&#x2F;bigfoot-sim</a></div><br/></div></div><div id="40252105" class="c"><input type="checkbox" id="c-40252105" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40253462">prev</a><span>|</span><a href="#40255655">next</a><span>|</span><label class="collapse" for="c-40252105">[-]</label><label class="expand" for="c-40252105">[7 more]</label></div><br/><div class="children"><div class="content">note that your last optimization of increasing the number by 2 if it fails rather than generating a new random number actually breaks the security slightly. Primes aren&#x27;t evenly distributed, so doing this biases you towards primes that are directly after large prime gaps.</div><br/><div id="40252700" class="c"><input type="checkbox" id="c-40252700" checked=""/><div class="controls bullet"><span class="by">glitchcomet</span><span>|</span><a href="#40252105">parent</a><span>|</span><a href="#40255655">next</a><span>|</span><label class="collapse" for="c-40252700">[-]</label><label class="expand" for="c-40252700">[6 more]</label></div><br/><div class="children"><div class="content">Yeah i read about this in my research. It is a tradeoff between execution speed vs randomness of primes, i choose to go with speed assuming that 16 threads all starting from a random number and competing to find the prime would add enough randomness. If someone preferred more randomness in place of speed it&#x27;s an easy change to replace the +=2 with a rng() call.</div><br/><div id="40254217" class="c"><input type="checkbox" id="c-40254217" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40252105">root</a><span>|</span><a href="#40252700">parent</a><span>|</span><a href="#40254351">next</a><span>|</span><label class="collapse" for="c-40254217">[-]</label><label class="expand" for="c-40254217">[1 more]</label></div><br/><div class="children"><div class="content">IMO you really shouldn&#x27;t be bottle-necked by random number generation speed. If the kernel calls are what&#x27;s slowing you down, you could use a strong user space PRNG (e.g. aes based) that is seeded with urandom. The other approach that would be not perfect but a lot better would be to re-randomize the lower 64 or 128 bits each time. That would cut down your rng requirements by a factor of ~10 while keeping much better uniformity since your jumps would be random and much bigger than the gap between primes.</div><br/></div></div><div id="40254351" class="c"><input type="checkbox" id="c-40254351" checked=""/><div class="controls bullet"><span class="by">TheDudeMan</span><span>|</span><a href="#40252105">root</a><span>|</span><a href="#40252700">parent</a><span>|</span><a href="#40254217">prev</a><span>|</span><a href="#40253098">next</a><span>|</span><label class="collapse" for="c-40254351">[-]</label><label class="expand" for="c-40254351">[1 more]</label></div><br/><div class="children"><div class="content">Another option is to do N sequential candidate tests for each fresh random candidate.  Where N is something that gets you most of the speed advantage of doing all sequential tests.  Maybe like N=16.<p>Nice write-up!</div><br/></div></div><div id="40253098" class="c"><input type="checkbox" id="c-40253098" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#40252105">root</a><span>|</span><a href="#40252700">parent</a><span>|</span><a href="#40254351">prev</a><span>|</span><a href="#40255655">next</a><span>|</span><label class="collapse" for="c-40253098">[-]</label><label class="expand" for="c-40253098">[3 more]</label></div><br/><div class="children"><div class="content">I donât think the parallelism really helps with this; youâll still never find the second of two twin primes for instance.<p>Are there any easy  ways to mitigate this though? What about say adding 2^64 at each step instead of 2?</div><br/><div id="40253378" class="c"><input type="checkbox" id="c-40253378" checked=""/><div class="controls bullet"><span class="by">glitchcomet</span><span>|</span><a href="#40252105">root</a><span>|</span><a href="#40253098">parent</a><span>|</span><a href="#40255655">next</a><span>|</span><label class="collapse" for="c-40253378">[-]</label><label class="expand" for="c-40253378">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting idea. I don&#x27;t know enough to say if using a large offset would be enough to mitigate the downsides of +=2, i would have to read more about it. In actual use you can go directly to using random candidates for each test as a few extra seconds to generate 2 primes would be worth the benefits. In hindsight my simplistic rng() can also probably be better optimized (batch load random bits and cache) to make it faster as the slowdown primarily comes from repeated filesystem access.</div><br/><div id="40253679" class="c"><input type="checkbox" id="c-40253679" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#40252105">root</a><span>|</span><a href="#40253378">parent</a><span>|</span><a href="#40255655">next</a><span>|</span><label class="collapse" for="c-40253679">[-]</label><label class="expand" for="c-40253679">[1 more]</label></div><br/><div class="children"><div class="content">I guess so long as your increment is constant there are primes youâre never going to find. If a prime happens to be 2^64 from another prime youâll still never see it with my approach.<p>Probably the most reasonable thing to do would be to use a Mersenne twister or other PRNG to generate a stream of random bytes. Would be plenty fast and should hopefully have no relevant pattern. No reason you should need real randomness from the OS after the initial seed.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40255655" class="c"><input type="checkbox" id="c-40255655" checked=""/><div class="controls bullet"><span class="by">shanurrahman</span><span>|</span><a href="#40252105">prev</a><span>|</span><a href="#40253841">next</a><span>|</span><label class="collapse" for="c-40255655">[-]</label><label class="expand" for="c-40255655">[1 more]</label></div><br/><div class="children"><div class="content">That was an excellent article. Particularly enjoyed the iterative improvements throughout. It clearly shows the significant performance boost that can be achieved through good engineering and optimization.</div><br/></div></div><div id="40253841" class="c"><input type="checkbox" id="c-40253841" checked=""/><div class="controls bullet"><span class="by">aaplok</span><span>|</span><a href="#40255655">prev</a><span>|</span><a href="#40254357">next</a><span>|</span><label class="collapse" for="c-40253841">[-]</label><label class="expand" for="c-40253841">[1 more]</label></div><br/><div class="children"><div class="content">Nice article, and nicely written.<p>&gt; My code from attempt #3 was effectively using base-255, with each byte acting as a single &quot;digit&quot;.<p>I think the author means base-256, not base-255.</div><br/></div></div><div id="40254357" class="c"><input type="checkbox" id="c-40254357" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#40253841">prev</a><span>|</span><a href="#40251995">next</a><span>|</span><label class="collapse" for="c-40254357">[-]</label><label class="expand" for="c-40254357">[2 more]</label></div><br/><div class="children"><div class="content">This sends me back.<p>My first-year college project, a few decades ago, was to implement 4096-bit RSA encryption, the idea of my project-mate and friend (and later valedectorian) who implemented the core math.<p>I recall how slow prime number generation was in our final implementation, taking ~20 minutes to generate on PA-RISC workstations. My friend, a math nerd, took it upon themselves to continue optimizing the code long after the project was over. I remember them reading papers on prime number detection, and bignum math implementations. For example, one huge improvement came when the code would detect if a number in a component multiplication was 0, then skip the multiplication and give a 0 result!</div><br/><div id="40254501" class="c"><input type="checkbox" id="c-40254501" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#40254357">parent</a><span>|</span><a href="#40251995">next</a><span>|</span><label class="collapse" for="c-40254501">[-]</label><label class="expand" for="c-40254501">[1 more]</label></div><br/><div class="children"><div class="content">On slow hardware you&#x27;re much better off generating elliptic curve keys. Otherwise you wait a long time or compromise on future proof security.</div><br/></div></div></div></div><div id="40251995" class="c"><input type="checkbox" id="c-40251995" checked=""/><div class="controls bullet"><span class="by">opticfluorine</span><span>|</span><a href="#40254357">prev</a><span>|</span><a href="#40254469">next</a><span>|</span><label class="collapse" for="c-40251995">[-]</label><label class="expand" for="c-40251995">[9 more]</label></div><br/><div class="children"><div class="content">&gt; The random number returned is OR-ed with 0b1000000000000001 to set its first and last bit to 1. The last bit set to 1 makes it an odd number and the first bit set to 1 ensures that it is a sufficiently large number which covers the entire range of bits I need.<p>I can understand setting the low bit to 1 since an even number will never be a prime (edit: obviously except 2). But why set the high bit to 1 as well? Admittedly I don&#x27;t know much about prime numbers or crypto, but it seems to me like this is just giving up a bit of entropy unnecessarily. What am I missing here?</div><br/><div id="40254001" class="c"><input type="checkbox" id="c-40254001" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40251995">parent</a><span>|</span><a href="#40252549">next</a><span>|</span><label class="collapse" for="c-40254001">[-]</label><label class="expand" for="c-40254001">[1 more]</label></div><br/><div class="children"><div class="content">Another factor is if your high bit is always set, and you encode the prime with that bit, your prime always takes the same number of byte to encode.<p>Variable byte encoding can lead to problems, if you need to exchange the data between different software, unless the specifications are very clear, and well tested. (See problems with RSA based DHE if the server public key has leading zeros)</div><br/></div></div><div id="40252549" class="c"><input type="checkbox" id="c-40252549" checked=""/><div class="controls bullet"><span class="by">glitchcomet</span><span>|</span><a href="#40251995">parent</a><span>|</span><a href="#40254001">prev</a><span>|</span><a href="#40252048">next</a><span>|</span><label class="collapse" for="c-40252549">[-]</label><label class="expand" for="c-40252549">[1 more]</label></div><br/><div class="children"><div class="content">As the other comments have mentioned, by setting the first bit to one it looses a bit of entropy but ensures that the prime is large enough. Another thing to add is that in RSA two primes are multiplied together. If one of them is 1024 bits the other can be ~200 bits (if i remember correctly) and still reach the required number of entropy bits for the key. So, having both primes be 1024-bit adds a bit of wiggle room too.</div><br/></div></div><div id="40252048" class="c"><input type="checkbox" id="c-40252048" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#40251995">parent</a><span>|</span><a href="#40252549">prev</a><span>|</span><a href="#40252012">next</a><span>|</span><label class="collapse" for="c-40252048">[-]</label><label class="expand" for="c-40252048">[1 more]</label></div><br/><div class="children"><div class="content">You are giving up a bit of entropy, yeah, but you still have 1022, it&#x27;s probably safer than wondering if a 1020 bit prime is fine even if they asked for a 1024 bit one. Eg we usually don&#x27;t consider 00042 a 5-digit number.<p>Technically probably depends on exactly what you&#x27;re using it for which choice is optimal, but I&#x27;d think the one in the article is the safer default.</div><br/></div></div><div id="40252012" class="c"><input type="checkbox" id="c-40252012" checked=""/><div class="controls bullet"><span class="by">lordnacho</span><span>|</span><a href="#40251995">parent</a><span>|</span><a href="#40252048">prev</a><span>|</span><a href="#40252286">next</a><span>|</span><label class="collapse" for="c-40252012">[-]</label><label class="expand" for="c-40252012">[4 more]</label></div><br/><div class="children"><div class="content">Same as generating a 2 digit number. If the first digit is a zero, it is not a 2 digit number.</div><br/><div id="40252088" class="c"><input type="checkbox" id="c-40252088" checked=""/><div class="controls bullet"><span class="by">opticfluorine</span><span>|</span><a href="#40251995">root</a><span>|</span><a href="#40252012">parent</a><span>|</span><a href="#40252286">next</a><span>|</span><label class="collapse" for="c-40252088">[-]</label><label class="expand" for="c-40252088">[3 more]</label></div><br/><div class="children"><div class="content">For the purposes of key generation, however, wouldn&#x27;t you want the full n bits of entropy? Otherwise the search space for a brute force factorization (haha right) is 2^(n-1) instead of 2^n, or half as many possibilities. The domain of the product is still [0..2^(2n)] so the resulting key is the desired 2^(2n) bits.<p>I guess another way to pose my question would be: is there an issue with sampling the entire 2^n space that makes us only take the highest 2^(n-1) subset of integers instead when selecting factors for a key?</div><br/><div id="40252120" class="c"><input type="checkbox" id="c-40252120" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40251995">root</a><span>|</span><a href="#40252088">parent</a><span>|</span><a href="#40252286">next</a><span>|</span><label class="collapse" for="c-40252120">[-]</label><label class="expand" for="c-40252120">[2 more]</label></div><br/><div class="children"><div class="content">you want the nth bit to be set because otherwise there is a small but noticable chance that you generate a surprisingly weak prime.</div><br/><div id="40252183" class="c"><input type="checkbox" id="c-40252183" checked=""/><div class="controls bullet"><span class="by">opticfluorine</span><span>|</span><a href="#40251995">root</a><span>|</span><a href="#40252120">parent</a><span>|</span><a href="#40252286">next</a><span>|</span><label class="collapse" for="c-40252183">[-]</label><label class="expand" for="c-40252183">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, if it is known that the nth bit is set, don&#x27;t I also have the same risk but in (n-1) bits? Genuinely curious here.<p>Edit: Ah, nevermind, I see now why I don&#x27;t have that issue. It&#x27;s because I can&#x27;t easily iterate the primes in that domain even though I can iterate the reduced number of bits. Thanks!</div><br/></div></div></div></div></div></div></div></div><div id="40252286" class="c"><input type="checkbox" id="c-40252286" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#40251995">parent</a><span>|</span><a href="#40252012">prev</a><span>|</span><a href="#40254469">next</a><span>|</span><label class="collapse" for="c-40252286">[-]</label><label class="expand" for="c-40252286">[1 more]</label></div><br/><div class="children"><div class="content">Losing one bit of entropy to generate a prime that&#x27;s definitely not only 50 bits long seems like a worthy tradeoff.</div><br/></div></div></div></div><div id="40254469" class="c"><input type="checkbox" id="c-40254469" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40251995">prev</a><span>|</span><a href="#40254205">next</a><span>|</span><label class="collapse" for="c-40254469">[-]</label><label class="expand" for="c-40254469">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My binary implementation was probably spending almost all of its time waiting to read or write numbers from RAM due to L1 cache misses. I did not know at the time how to actually test this, but I thought let&#x27;s try a more memory efficient version anyway and see if it improves things.<p>The text never comes back to this, but the answer is that a handful of 1-2KB numbers fit into L1 just fine, and even if they didn&#x27;t there&#x27;s a megabyte or more of L2 that takes about 3ns to access.<p>&gt; It goes without saying that probably none of this is actually cryptographically secure, but that was never the point anyway.<p>Hmm.  This is just the prime generation, so it avoids most RSA pitfalls, and urandom had better be secure.  So if this code works <i>at all</i> then there&#x27;s not much that could go wrong.  RSA has a few issues with weak primes to avoid but I don&#x27;t know if they&#x27;re likely enough to matter here.</div><br/></div></div><div id="40254205" class="c"><input type="checkbox" id="c-40254205" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#40254469">prev</a><span>|</span><a href="#40254183">next</a><span>|</span><label class="collapse" for="c-40254205">[-]</label><label class="expand" for="c-40254205">[2 more]</label></div><br/><div class="children"><div class="content">One quick thing to add to this: &#x2F;dev&#x2F;urandom does not generate &quot;true&quot; random numbers.  TRNGs generate 1 bit out per bit of entropy they collect from the environment, while &#x2F;dev&#x2F;urandom will not stop generating random bits when it runs out of entropy.  That makes it a CSPRNG that is seeded by a TRNG.<p>For all practical purposes, a CSPRNG seeded by a TRNG is almost as good as a TRNG, but it isn&#x27;t quite the same.<p>Linux used to recommend &#x2F;dev&#x2F;random which actually was a TRNG (although its entropy collection would sometimes overestimate how much entropy it got, particularly on servers), but it wasn&#x27;t practical to use as your primary cryptographic RNG because it was <i>very slow</i>.</div><br/><div id="40254906" class="c"><input type="checkbox" id="c-40254906" checked=""/><div class="controls bullet"><span class="by">Jerrrry</span><span>|</span><a href="#40254205">parent</a><span>|</span><a href="#40254183">next</a><span>|</span><label class="collapse" for="c-40254906">[-]</label><label class="expand" for="c-40254906">[1 more]</label></div><br/><div class="children"><div class="content">pedantic trivia that everyone here knows. fyi.<p>Here&#x27;s another one: bring up how nothing is actually Turing Complete, because we live in a finite universe.<p>also, Elon Musk is an African American. (this one infuriates most for reasons not permitted to be articulated)</div><br/></div></div></div></div><div id="40254183" class="c"><input type="checkbox" id="c-40254183" checked=""/><div class="controls bullet"><span class="by">m1keil</span><span>|</span><a href="#40254205">prev</a><span>|</span><a href="#40253416">next</a><span>|</span><label class="collapse" for="c-40254183">[-]</label><label class="expand" for="c-40254183">[2 more]</label></div><br/><div class="children"><div class="content">Unrelated to crypto: Trying to select the word &quot;entropy&quot; (with the cool colour &amp; wave effect) grinds Chrome to halt on Android.</div><br/><div id="40254843" class="c"><input type="checkbox" id="c-40254843" checked=""/><div class="controls bullet"><span class="by">Jerrrry</span><span>|</span><a href="#40254183">parent</a><span>|</span><a href="#40253416">next</a><span>|</span><label class="collapse" for="c-40254843">[-]</label><label class="expand" for="c-40254843">[1 more]</label></div><br/><div class="children"><div class="content">Range&#x2F;Selection at user touch&#x2F;click, seven times, 60 times a second.</div><br/></div></div></div></div><div id="40253416" class="c"><input type="checkbox" id="c-40253416" checked=""/><div class="controls bullet"><span class="by">pelagicAustral</span><span>|</span><a href="#40254183">prev</a><span>|</span><a href="#40253373">next</a><span>|</span><label class="collapse" for="c-40253416">[-]</label><label class="expand" for="c-40253416">[1 more]</label></div><br/><div class="children"><div class="content">I love that the code panics when trying to divide by zero. Reminds me I should catch stuff even if it&#x27;s for my own sake, I generally opt to completely overreact.</div><br/></div></div><div id="40253373" class="c"><input type="checkbox" id="c-40253373" checked=""/><div class="controls bullet"><span class="by">cschmittiey</span><span>|</span><a href="#40253416">prev</a><span>|</span><a href="#40251987">next</a><span>|</span><label class="collapse" for="c-40253373">[-]</label><label class="expand" for="c-40253373">[2 more]</label></div><br/><div class="children"><div class="content">What are you using for your site? Loved the entropy styling!</div><br/><div id="40253836" class="c"><input type="checkbox" id="c-40253836" checked=""/><div class="controls bullet"><span class="by">glitchcomet</span><span>|</span><a href="#40253373">parent</a><span>|</span><a href="#40251987">next</a><span>|</span><label class="collapse" for="c-40253836">[-]</label><label class="expand" for="c-40253836">[1 more]</label></div><br/><div class="children"><div class="content">It is custom html&#x2F;css built with my own simple static site generator. The entropy styling is css animations delayed for each letter such that it matches up. Glad that you liked it!</div><br/></div></div></div></div><div id="40251987" class="c"><input type="checkbox" id="c-40251987" checked=""/><div class="controls bullet"><span class="by">throw0101b</span><span>|</span><a href="#40253373">prev</a><span>|</span><a href="#40251959">next</a><span>|</span><label class="collapse" for="c-40251987">[-]</label><label class="expand" for="c-40251987">[3 more]</label></div><br/><div class="children"><div class="content">I remember first trying out PGP in the early 1990s on a 80386 or 80486 on Linux and it took <i>forever</i> to generate a new key.</div><br/><div id="40252115" class="c"><input type="checkbox" id="c-40252115" checked=""/><div class="controls bullet"><span class="by">sva_</span><span>|</span><a href="#40251987">parent</a><span>|</span><a href="#40251959">next</a><span>|</span><label class="collapse" for="c-40252115">[-]</label><label class="expand" for="c-40252115">[2 more]</label></div><br/><div class="children"><div class="content">If you try to generate a PGP key using GPG on a fresh Linux system, it may flatout refuse to do so claiming there is not sufficient entropy. Or at least it was like that some years ago.</div><br/><div id="40254849" class="c"><input type="checkbox" id="c-40254849" checked=""/><div class="controls bullet"><span class="by">Jerrrry</span><span>|</span><a href="#40251987">root</a><span>|</span><a href="#40252115">parent</a><span>|</span><a href="#40251959">next</a><span>|</span><label class="collapse" for="c-40254849">[-]</label><label class="expand" for="c-40254849">[1 more]</label></div><br/><div class="children"><div class="content">On a millisecond old, virtual machine, sure.</div><br/></div></div></div></div></div></div><div id="40251959" class="c"><input type="checkbox" id="c-40251959" checked=""/><div class="controls bullet"><span class="by">timmy777</span><span>|</span><a href="#40251987">prev</a><span>|</span><a href="#40253824">next</a><span>|</span><label class="collapse" for="c-40251959">[-]</label><label class="expand" for="c-40251959">[2 more]</label></div><br/><div class="children"><div class="content">Beautiful article. Nice research</div><br/><div id="40252573" class="c"><input type="checkbox" id="c-40252573" checked=""/><div class="controls bullet"><span class="by">glitchcomet</span><span>|</span><a href="#40251959">parent</a><span>|</span><a href="#40253824">next</a><span>|</span><label class="collapse" for="c-40252573">[-]</label><label class="expand" for="c-40252573">[1 more]</label></div><br/><div class="children"><div class="content">Thanks a lot!</div><br/></div></div></div></div><div id="40253824" class="c"><input type="checkbox" id="c-40253824" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40251959">prev</a><span>|</span><a href="#40253678">next</a><span>|</span><label class="collapse" for="c-40253824">[-]</label><label class="expand" for="c-40253824">[1 more]</label></div><br/><div class="children"><div class="content">I would recommend keeping one handle open to &#x2F;dev&#x2F;urandom rather than opening and closing a new one every single time you generate a new random number.</div><br/></div></div><div id="40253678" class="c"><input type="checkbox" id="c-40253678" checked=""/><div class="controls bullet"><span class="by">paulcole</span><span>|</span><a href="#40253824">prev</a><span>|</span><label class="collapse" for="c-40253678">[-]</label><label class="expand" for="c-40253678">[1 more]</label></div><br/><div class="children"><div class="content">Tell âem Wash!</div><br/></div></div></div></div></div></div></div></body></html>