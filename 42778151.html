<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737882065672" as="style"/><link rel="stylesheet" href="styles.css?v=1737882065672"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mattrighetti.com/2025/01/20/you-dont-need-sql-builders">You probably don&#x27;t need query builders</a> <span class="domain">(<a href="https://mattrighetti.com">mattrighetti.com</a>)</span></div><div class="subtext"><span>mattrighetti</span> | <span>89 comments</span></div><br/><div><div id="42828674" class="c"><input type="checkbox" id="c-42828674" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42824953">next</a><span>|</span><label class="collapse" for="c-42828674">[-]</label><label class="expand" for="c-42828674">[2 more]</label></div><br/><div class="children"><div class="content">It seems article shows the opposite argument. SQL builders are useful not to write fragile raw sql ridden with noisy filter patterns with repeated numbered placeholders which could be easily broken on refactoring. Also it&#x27;s impossible to compose queries with abstracted parts.<p>Shameless plug: <a href="https:&#x2F;&#x2F;github.com&#x2F;baverman&#x2F;sqlbind">https:&#x2F;&#x2F;github.com&#x2F;baverman&#x2F;sqlbind</a></div><br/><div id="42828768" class="c"><input type="checkbox" id="c-42828768" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#42828674">parent</a><span>|</span><a href="#42824953">next</a><span>|</span><label class="collapse" for="c-42828768">[-]</label><label class="expand" for="c-42828768">[1 more]</label></div><br/><div class="children"><div class="content">That is a really neat library! Can see myself using it quite a lot.</div><br/></div></div></div></div><div id="42824953" class="c"><input type="checkbox" id="c-42824953" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#42828674">prev</a><span>|</span><a href="#42828510">next</a><span>|</span><label class="collapse" for="c-42824953">[-]</label><label class="expand" for="c-42824953">[21 more]</label></div><br/><div class="children"><div class="content">The recommended approach is to generate SQL that looks like:<p><pre><code>    SELECT \* FROM users
    WHERE id = $1
        AND ($2 IS NULL OR username = $2)
        AND ($3 IS NULL OR age &gt; $3)
        AND ($4 IS NULL OR age &lt; $4)

</code></pre>
It&#x27;s worth noting that this approach has significant dangers for execution performance--it creates a significant chance that you&#x27;ll get a query plan that doesn&#x27;t match your actual query. See: <a href="https:&#x2F;&#x2F;use-the-index-luke.com&#x2F;sql&#x2F;where-clause&#x2F;obfuscation&#x2F;smart-logic" rel="nofollow">https:&#x2F;&#x2F;use-the-index-luke.com&#x2F;sql&#x2F;where-clause&#x2F;obfuscation&#x2F;...</a> for some related material.</div><br/><div id="42825853" class="c"><input type="checkbox" id="c-42825853" checked=""/><div class="controls bullet"><span class="by">nycdotnet</span><span>|</span><a href="#42824953">parent</a><span>|</span><a href="#42825086">next</a><span>|</span><label class="collapse" for="c-42825853">[-]</label><label class="expand" for="c-42825853">[9 more]</label></div><br/><div class="children"><div class="content">Agree.  With patterns like this you are leaning on your db server’s CPU - among your most scarce resources - versus doing this work on the client on a relatively cheap app server.  At query time your app server knows if $2 or $3 or $4 is null and can elide those query args.  Feels bad to use a fast language like Rust on your app servers and then your perf still sucks because your single DB server is asked to contemplate all possibilities on queries like this instead of doing such simple work on your plentiful and cheap app servers.</div><br/><div id="42828304" class="c"><input type="checkbox" id="c-42828304" checked=""/><div class="controls bullet"><span class="by">BeefWellington</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42825853">parent</a><span>|</span><a href="#42827432">next</a><span>|</span><label class="collapse" for="c-42828304">[-]</label><label class="expand" for="c-42828304">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen many devs extrapolate this thinking too far into sending only the most simple queries and doing all of the record filtering on the application end. This isn&#x27;t what I think you&#x27;re saying -- just piggybacking to try and explain further.<p>The key thing here is to understand that you want the minimal correct query for what you need, not to avoid &quot;making the database work&quot;.<p>The given example is silly because there&#x27;s additional parameters that must be either NULL or have a value <i>before</i> the query is sent to the DB.
You shouldn&#x27;t send queries like:<p><pre><code>    SELECT \* FROM users
    WHERE id = 1234
        AND (NULL IS NULL OR username = NULL)
        AND (NULL IS NULL OR age &gt; NULL)
        AND (NULL IS NULL OR age &lt; NULL)
</code></pre>
But you should absolutely send:<p><pre><code>    SELECT \* FROM users
    WHERE id = 1234
        AND age &gt; 18
        AND age &lt; 35</code></pre></div><br/></div></div><div id="42827432" class="c"><input type="checkbox" id="c-42827432" checked=""/><div class="controls bullet"><span class="by">pocketarc</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42825853">parent</a><span>|</span><a href="#42828304">prev</a><span>|</span><a href="#42826040">next</a><span>|</span><label class="collapse" for="c-42827432">[-]</label><label class="expand" for="c-42827432">[6 more]</label></div><br/><div class="children"><div class="content">This is actually an incredible way of articulating something that&#x27;s been on my mind for quite a while. Thank you for this, I will use this.<p>The received wisdom is, of course, to lean on the DB as much as possible, put all the business logic in SQL because of course the DB is much more efficient. I myself have always been a big proponent of it.<p>But, as you rightly point out, you&#x27;re using up one of your infrastructure&#x27;s most scarce and hard-to-scale resources - the DB&#x27;s CPU.</div><br/><div id="42828571" class="c"><input type="checkbox" id="c-42828571" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42827432">parent</a><span>|</span><a href="#42828725">next</a><span>|</span><label class="collapse" for="c-42828571">[-]</label><label class="expand" for="c-42828571">[1 more]</label></div><br/><div class="children"><div class="content">I think there are two different concerns here though:<p>The article recommends something that may lead to using the <i>wrong</i> query plans. In the &quot;right&quot; conditions, you will do full table scans of all your data for every query.<p>This is making the DB <i>waste</i> a lot of CPU (and IO).<p>Wasting resources like that is different from just where to do work that has to be done anyway!<p>I am a proponent of shifting logic toward the DB, because likely it ends up there anyway and usually you reduce the resource consumption <i>also for the DB</i> to have as much logic as possible in the DB.<p>The extreme example is you want to sum(numbers) -- it is so much faster to sum it in one roundtrip to the DB, than to do a thousand roundtrips to the DB to fetch the numbers to sum them on the client. The latter is so much more effort <i>also for the DB server&#x27;s resources</i>.<p>My point is: Usually it is impossible to meaningfully shift CPU work to the client of the DB, because the client needs the data, so it will ask for it, and looking up the data is the most costly operation in the DB.</div><br/></div></div><div id="42828725" class="c"><input type="checkbox" id="c-42828725" checked=""/><div class="controls bullet"><span class="by">scarface_74</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42827432">parent</a><span>|</span><a href="#42828571">prev</a><span>|</span><a href="#42827710">next</a><span>|</span><label class="collapse" for="c-42828725">[-]</label><label class="expand" for="c-42828725">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The received wisdom is, of course, to lean on the DB as much as possible, put all the business logic in SQL because of course the DB is much more efficient. I myself have always been a big proponent of it.</i><p>This is not received wisdom at all and the one edict I have when leading a project is no stored procedures for any OLTP functionality.<p>Stored Procs make everything about your standard DevOps and SDLC process harder - branching, blue green deployments and rolling back deployments.</div><br/></div></div><div id="42827710" class="c"><input type="checkbox" id="c-42827710" checked=""/><div class="controls bullet"><span class="by">dinosaurdynasty</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42827432">parent</a><span>|</span><a href="#42828725">prev</a><span>|</span><a href="#42826040">next</a><span>|</span><label class="collapse" for="c-42827710">[-]</label><label class="expand" for="c-42827710">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a different reason to lean on the DB: it&#x27;s the final arbiter of your data.<p>Much harder to create bad&#x2F;poisoned data if the DB has a constraint on it (primary, foreign, check, etc) than if you have to remember it in your application (and unless you know what serializable transactions are, you are likely doing it wrong).<p>Also you can&#x27;t do indexes outside of the DB (well, you can <i>try</i>).</div><br/><div id="42828079" class="c"><input type="checkbox" id="c-42828079" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42827710">parent</a><span>|</span><a href="#42826040">next</a><span>|</span><label class="collapse" for="c-42828079">[-]</label><label class="expand" for="c-42828079">[2 more]</label></div><br/><div class="children"><div class="content">Replying to this whole sub-thread, not just this post specifically;<p>All SQL advice has to take _context_ into account. In SQL, perhaps more than anywhere else, context matters. There&#x27;s lots of excellent SQL advice, but most of it is bound to a specific context, and in a different context it&#x27;s bad advice.<p>Take for example the parent comment above; In their context the CPU of the database server is their constraining resource. I&#x27;m guessing the database if &quot;close&quot; to the app servers (ie low network latency, high bandwidth), and I&#x27;m also guessing the app developers &quot;own&quot; the database. In this context moving CPU to the app server makes complete sense. Client-side validation of data makes sense because they are the only client.<p>Of course if the context changes, then the advice has to change as well. If the network bandwidth to the server was constrained (cost, distance etc) then transporting the smallest amount of data becomes important. In this case it doesn&#x27;t matter if the filter is more work for the server, the goal is the smallest result set.<p>And so it goes. Write-heavy systems prefer fewer indexes. Read-heavy systems prefer lots of indexes. Databases where the data client is untrusted need more validation, relation integrity, access control - databases with a trusted client need less of that.<p>In my career I&#x27;ve followed a lot of good SQL advice - advice that was good for my context. I&#x27;ve also broken a lot of SQL &quot;rules&quot; because those rules were not compatible, or were harmful, in my context.<p>So my advice is this - understand your own context. Understand where you are constrained, and where you have plenty. And tailor your patterns around those parameters.</div><br/><div id="42828261" class="c"><input type="checkbox" id="c-42828261" checked=""/><div class="controls bullet"><span class="by">ki85squared</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42828079">parent</a><span>|</span><a href="#42826040">next</a><span>|</span><label class="collapse" for="c-42828261">[-]</label><label class="expand" for="c-42828261">[1 more]</label></div><br/><div class="children"><div class="content">The most sensible and pragmatic advice in this thread.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42825086" class="c"><input type="checkbox" id="c-42825086" checked=""/><div class="controls bullet"><span class="by">jasode</span><span>|</span><a href="#42824953">parent</a><span>|</span><a href="#42825853">prev</a><span>|</span><a href="#42826051">next</a><span>|</span><label class="collapse" for="c-42825086">[-]</label><label class="expand" for="c-42825086">[6 more]</label></div><br/><div class="children"><div class="content"><i>&gt; WHERE id = $1</i><p><i>&gt;It&#x27;s worth noting that this approach has significant dangers for execution performance</i><p>This <i>extra WHERE id=$1 clause</i> makes it behave different from the slow examples you cited from the Markus Winand blog.  The query planner should notice that id column is a selective index with high cardinality (and may even be the unique ids primary key).  The query optimizer can filter on id to return a single row before the dynamic NULL checks of $2,$3,$4 to avoid a full-table scan.<p>The crucial difference is the id clause doesn&#x27;t have an extra &quot;OR id IS NULL&quot; or &quot;$1 IS NULL&quot; -- like the blog examples.</div><br/><div id="42826094" class="c"><input type="checkbox" id="c-42826094" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42825086">parent</a><span>|</span><a href="#42825171">next</a><span>|</span><label class="collapse" for="c-42826094">[-]</label><label class="expand" for="c-42826094">[1 more]</label></div><br/><div class="children"><div class="content">Note that null is being used here in the “unknown value” sense in order to combine several possible queries into one query plan.  Which is a bad idea for a query you need to be performant:  $1 can be null (which is possible in the original stackoverflow question that this blog post is a reaction to), and if the parameters are passed in via a bound argument in a prepared statement (not uncommon), then the query plan won&#x27;t necessarily be taking the passed parameters into account when deciding on the plan.</div><br/></div></div><div id="42825171" class="c"><input type="checkbox" id="c-42825171" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42825086">parent</a><span>|</span><a href="#42826094">prev</a><span>|</span><a href="#42826051">next</a><span>|</span><label class="collapse" for="c-42825171">[-]</label><label class="expand" for="c-42825171">[4 more]</label></div><br/><div class="children"><div class="content">You are right. If that’s the query you need to write, you’ll be ok.<p>That said, I don’t think I’ve ever had occasion to write a query quite like that. I’ve written<p><pre><code>  select * from blah where id in (1,2,3…) and condition
</code></pre>
or<p><pre><code>  select * from blah where condition1 and condition2
</code></pre>
but never a query quite like this. Do you know of use cases for it?<p>Given that most queries don&#x27;t look like that, I think my criticism is reasonable. For most use cases, this query will have performance downsides, even if it doesn&#x27;t for some very narrow use-cases.</div><br/><div id="42825880" class="c"><input type="checkbox" id="c-42825880" checked=""/><div class="controls bullet"><span class="by">nycdotnet</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42825171">parent</a><span>|</span><a href="#42825742">next</a><span>|</span><label class="collapse" for="c-42825880">[-]</label><label class="expand" for="c-42825880">[2 more]</label></div><br/><div class="children"><div class="content">Record selector to drive a data grid.  Ex: Filter employees by location, or active&#x2F;terminated, or salary&#x2F;hourly, etc. and let the user choose one or many of these filters.</div><br/></div></div><div id="42825742" class="c"><input type="checkbox" id="c-42825742" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42825171">parent</a><span>|</span><a href="#42825880">prev</a><span>|</span><a href="#42826051">next</a><span>|</span><label class="collapse" for="c-42825742">[-]</label><label class="expand" for="c-42825742">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like the developer use case. Data scientists doing ETL and analyzing messy data with weird rules like the ones above are common (although the id is usually a contains&#x2F;in to handle lists of rows that don’t fit any of the conditions but must be included).<p>I’ve had to do some weird things to clean up data from vendor databases in several industries.</div><br/></div></div></div></div></div></div><div id="42826051" class="c"><input type="checkbox" id="c-42826051" checked=""/><div class="controls bullet"><span class="by">BeefWellington</span><span>|</span><a href="#42824953">parent</a><span>|</span><a href="#42825086">prev</a><span>|</span><a href="#42825085">next</a><span>|</span><label class="collapse" for="c-42826051">[-]</label><label class="expand" for="c-42826051">[4 more]</label></div><br/><div class="children"><div class="content">If your column named simply `id` isn&#x27;t a unique index you&#x27;ve gone very wrong.<p>The rest of the query plan probably won&#x27;t need much power.</div><br/><div id="42826117" class="c"><input type="checkbox" id="c-42826117" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42826051">parent</a><span>|</span><a href="#42827140">next</a><span>|</span><label class="collapse" for="c-42826117">[-]</label><label class="expand" for="c-42826117">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42825171">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42825171</a></div><br/></div></div><div id="42827140" class="c"><input type="checkbox" id="c-42827140" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42826051">parent</a><span>|</span><a href="#42826117">prev</a><span>|</span><a href="#42825085">next</a><span>|</span><label class="collapse" for="c-42827140">[-]</label><label class="expand" for="c-42827140">[2 more]</label></div><br/><div class="children"><div class="content">It really depends on your query engine, this would be considered a &quot;catch all query&quot; in SQL Server, and you&#x27;re going to have really bad parameter sniffing blowing you up, you do not want to do this usually.</div><br/><div id="42828242" class="c"><input type="checkbox" id="c-42828242" checked=""/><div class="controls bullet"><span class="by">BeefWellington</span><span>|</span><a href="#42824953">root</a><span>|</span><a href="#42827140">parent</a><span>|</span><a href="#42825085">next</a><span>|</span><label class="collapse" for="c-42828242">[-]</label><label class="expand" for="c-42828242">[1 more]</label></div><br/><div class="children"><div class="content">I would expect the query plan for SQL server to essentially return records matching `id` first (which again should be a situation where uniqueness comes into play) and then performing the rest of the execution on the subset that matches, which is hopefully one.<p>I leave allowances for `id` to be a stand-in for some other identity column that may represent a foreign key to another table. In which case I&#x27;d still expect SQL server&#x27;s query planner to execute as: initial set is those where said column matches the supplied number, then further applies the logic to that subset. In fact I&#x27;d love to see where that isn&#x27;t the case against a transactional DB.</div><br/></div></div></div></div></div></div><div id="42825085" class="c"><input type="checkbox" id="c-42825085" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42824953">parent</a><span>|</span><a href="#42826051">prev</a><span>|</span><a href="#42828510">next</a><span>|</span><label class="collapse" for="c-42825085">[-]</label><label class="expand" for="c-42825085">[1 more]</label></div><br/><div class="children"><div class="content">This may be a situation where you classify the parameters and create a handful of queries that include or exclude each class.<p>The same way we always have a distinct query for selecting by ID, you have one with just username, one with demographics, one with account age or activity ranges, and then C(3,2) combinations of categories.</div><br/></div></div></div></div><div id="42828510" class="c"><input type="checkbox" id="c-42828510" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42824953">prev</a><span>|</span><a href="#42828679">next</a><span>|</span><label class="collapse" for="c-42828510">[-]</label><label class="expand" for="c-42828510">[1 more]</label></div><br/><div class="children"><div class="content">At least for MSSQL: <i>Never do this</i> (before learning about query caches). Or at least, if you do, add (option recompile) to the query.<p>For each combination of parameters to search for you may want to use a different index.<p>But... the query plans are cached <i>by query string lookup</i>!<p>So it is imperative that your search string looks different for each query plan&#x2F;index being used.<p>The code suggested here will pick a more or less random index (the one optimized for the parameters of the <i>first</i> execution) and stick with it for remaining executions, leading to bad queries for combinations of non-null that doesn&#x27;t match the first query.<p>You <i>could</i> just add a comment inside the string that was different depending on what parameters are null, but that is no less complex than just generating the query.<p>PS: Of course there are situations where it fits, like if your strategy is to always use the same index to do the main scan and then filter away results from it based on postprocessing filters. Just make sure to understand this issue.</div><br/></div></div><div id="42824898" class="c"><input type="checkbox" id="c-42824898" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#42828679">prev</a><span>|</span><a href="#42824881">next</a><span>|</span><label class="collapse" for="c-42824898">[-]</label><label class="expand" for="c-42824898">[6 more]</label></div><br/><div class="children"><div class="content">All of these are simple, almost unrealistic queries. Show me how to handle optional joins in the filter.<p>&gt; My naive-self in the past used to create a fancy custom deserializer function that transformed 11,22,33,44 from a String into a Vec&lt;i64&gt; and that is useless work that could have easily been handled by the database.<p>Great, now the database has no idea what the cardinality of the IN clause is and has to generate a sub-optimal plan, because it could be 1 or it could be 10000.<p>The same for a lot of the other examples.</div><br/><div id="42825141" class="c"><input type="checkbox" id="c-42825141" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42824898">parent</a><span>|</span><a href="#42826645">next</a><span>|</span><label class="collapse" for="c-42825141">[-]</label><label class="expand" for="c-42825141">[2 more]</label></div><br/><div class="children"><div class="content">This article just gives me the impression that the Rust query builder has terrible DevEx.<p>Why is adding the clause and binding variables two calls and not one? The lack of variadic functions makes this clunky but you could limit people to 3 binds per clause and that would cover 95% of people. Formatting and cognitive load both crap out around 3 anyway.</div><br/><div id="42825808" class="c"><input type="checkbox" id="c-42825808" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#42824898">root</a><span>|</span><a href="#42825141">parent</a><span>|</span><a href="#42826645">next</a><span>|</span><label class="collapse" for="c-42825808">[-]</label><label class="expand" for="c-42825808">[1 more]</label></div><br/><div class="children"><div class="content">While clunky to implement, variadic calls is mostly a solved problem in rust by way of tuples and macro rules. It’s ugly to implement as a library author (generate K different  declarations using macro expansions, where K is the limit of the variadic expansion), but IMO that’s secondary to the library user experience, which is fine with this approach.</div><br/></div></div></div></div><div id="42826645" class="c"><input type="checkbox" id="c-42826645" checked=""/><div class="controls bullet"><span class="by">MSM</span><span>|</span><a href="#42824898">parent</a><span>|</span><a href="#42825141">prev</a><span>|</span><a href="#42826272">next</a><span>|</span><label class="collapse" for="c-42826645">[-]</label><label class="expand" for="c-42826645">[2 more]</label></div><br/><div class="children"><div class="content">Depends what you mean by optional join- if you mean you want the flexibility to build up a list of columns you actually want data from on the fly, you would probably have good results from doing left joins to the tables that contain those columns while ensuring you have a unique column (PK, Unique constraint) you&#x27;re joining to. Your query engine should be smart enough to realize that it can avoid joining that table.<p>The logic is that you&#x27;ve ensured the query engine that it&#x27;ll never return more than one row from the optional table so if you&#x27;re not returning any actual columns from that table there&#x27;s no need to think about it. Without the unique constraints the query engine has no idea how many rows may be returned (even if you aren&#x27;t selecting the data) so it still needs to go through the work.</div><br/><div id="42826698" class="c"><input type="checkbox" id="c-42826698" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#42824898">root</a><span>|</span><a href="#42826645">parent</a><span>|</span><a href="#42826272">next</a><span>|</span><label class="collapse" for="c-42826698">[-]</label><label class="expand" for="c-42826698">[1 more]</label></div><br/><div class="children"><div class="content">I mean a series of joins that are conditional on a user filter. For example, users with orders with invoices that are paid in the last 10 days.<p>Anyone can string-concat simple one table queries. That’s fine. The moment you add any non-trivial joins it gets exponentially more complex.</div><br/></div></div></div></div><div id="42826272" class="c"><input type="checkbox" id="c-42826272" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#42824898">parent</a><span>|</span><a href="#42826645">prev</a><span>|</span><a href="#42824881">next</a><span>|</span><label class="collapse" for="c-42826272">[-]</label><label class="expand" for="c-42826272">[1 more]</label></div><br/><div class="children"><div class="content">Laterel. Show me correlated subqueries, &amp; I&#x27;ll take it seriously.<p>The blog reads like exercise in Rust macros writing.</div><br/></div></div></div></div><div id="42824881" class="c"><input type="checkbox" id="c-42824881" checked=""/><div class="controls bullet"><span class="by">scott_w</span><span>|</span><a href="#42824898">prev</a><span>|</span><a href="#42828775">next</a><span>|</span><label class="collapse" for="c-42824881">[-]</label><label class="expand" for="c-42824881">[1 more]</label></div><br/><div class="children"><div class="content">I don’t get the point of this article. Just reading the samples, I strongly dislike this query builder because it looks flaky and difficult to parse by eye. And the examples get worse and worse.<p>This isn’t an argument against query builders, that just seems like an argument to make your query builder easier to use and understand. I wouldn’t argue against programming languages by picking bad C++ libraries.</div><br/></div></div><div id="42828775" class="c"><input type="checkbox" id="c-42828775" checked=""/><div class="controls bullet"><span class="by">riiii</span><span>|</span><a href="#42824881">prev</a><span>|</span><a href="#42824947">next</a><span>|</span><label class="collapse" for="c-42828775">[-]</label><label class="expand" for="c-42828775">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need them until you do. And when you do, you might first think that you can just hack your way around this minor inconvenience.<p>Then you&#x27;ll eventually learn why the road to hell is paved with good intentions.</div><br/></div></div><div id="42824947" class="c"><input type="checkbox" id="c-42824947" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42828775">prev</a><span>|</span><a href="#42824824">next</a><span>|</span><label class="collapse" for="c-42824947">[-]</label><label class="expand" for="c-42824947">[6 more]</label></div><br/><div class="children"><div class="content">Eventually people will have enough of Little Bobby Tables and url spoofing and then query engines won’t allow string concatenation at all.<p>The only alternative I know of is to make a query engine that exactly emulates the String Interpolation syntax of the host language and can detect string concatenation in the inputs.<p>But the problem with non-builders is always going to be GraphQL and advanced search boxes, where there are any of a couple dozen possible parameters and you either build one query that returns * for every unused clause or you have a factorial number of possible queries. If you don’t use a builder then Bobby always shows up. He even shows up sometimes with a builder.</div><br/><div id="42826807" class="c"><input type="checkbox" id="c-42826807" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#42824947">parent</a><span>|</span><a href="#42827199">next</a><span>|</span><label class="collapse" for="c-42826807">[-]</label><label class="expand" for="c-42826807">[1 more]</label></div><br/><div class="children"><div class="content">&gt; He even shows up sometimes with a builder<p>Something I’ve ran into a lot over the years is people not realising that (at least in MySQL) prepared statement placeholders can only be used for values, not identifiers like column names.<p>Because many query builders abstract away the creation of a prepared statement, people pass variables directly into column fields and introduce injection vulns.<p>Number one place I see this is data tables: you have some fancy table component where the user can control which columns to see and which to sort by. If you’re not checking these against a known good allow list, you’re gonna have a bad time.</div><br/></div></div><div id="42827199" class="c"><input type="checkbox" id="c-42827199" checked=""/><div class="controls bullet"><span class="by">wredcoll</span><span>|</span><a href="#42824947">parent</a><span>|</span><a href="#42826807">prev</a><span>|</span><a href="#42825088">next</a><span>|</span><label class="collapse" for="c-42827199">[-]</label><label class="expand" for="c-42827199">[1 more]</label></div><br/><div class="children"><div class="content">Javascript added &#x27;tagged templates&#x27; a while ago that allows you write a function that gets passed the &#x27;parse tree&#x27; of a template string, so js libs do a lot of &#x27;interpolation magic&#x27; for sql queries</div><br/></div></div><div id="42825088" class="c"><input type="checkbox" id="c-42825088" checked=""/><div class="controls bullet"><span class="by">electronvolt</span><span>|</span><a href="#42824947">parent</a><span>|</span><a href="#42827199">prev</a><span>|</span><a href="#42827135">next</a><span>|</span><label class="collapse" for="c-42825088">[-]</label><label class="expand" for="c-42825088">[1 more]</label></div><br/><div class="children"><div class="content">I mean, in C++ (17? 20? Whenever constexpr was introduced) it&#x27;s totally possible to create a library that allows you to build a SQL query via the language&#x27;s string concatenation libraries&#x2F;etc., but only allows you to do it with static strings unless you use ~shenanigans. (C++ unfortunately always allows ~shenanigans...)<p>I guess you do wind up needing to potentially re-implement some basic things (or I guess more complex, if you want format string support too).  But for basic string concatenation &amp; interpolation, it&#x27;s reasonable.<p>That&#x27;s a pretty useful way to get basic string concatenation while also preventing it from creating opportunities for SQL injection.<p>For example, you have a class that requires a constexpr input &amp; can be appended to&#x2F;concatenated&#x2F;etc.:<p>SqlStringPart(constexpr ...)<p>operator+(SqlStringPart ...)<p>(so on)<p>And you have a Query API that only takes SQL string expressions that are built out of compile time constants + parameters:<p>SqlQuery(SqlStringPart ..., Parameters ...);<p>This doesn&#x27;t solve the problem mentioned in the article around pagination &amp; memory usage, but at least it avoids letting someone run arbitrary SQL on your database.</div><br/></div></div><div id="42827135" class="c"><input type="checkbox" id="c-42827135" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#42824947">parent</a><span>|</span><a href="#42825088">prev</a><span>|</span><a href="#42824824">next</a><span>|</span><label class="collapse" for="c-42827135">[-]</label><label class="expand" for="c-42827135">[2 more]</label></div><br/><div class="children"><div class="content">Your post made me realize that custom string interpolation handlers from C# could probably be used to do injection-safe SQL querying (<a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;advanced-topics&#x2F;performance&#x2F;interpolated-string-handler" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;advanced-top...</a>). Makes me wonder whether scenarios like that were considered when they built that feature or if it&#x27;s just a fun coincidence from making string interpolation extensible.</div><br/><div id="42827825" class="c"><input type="checkbox" id="c-42827825" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42824947">root</a><span>|</span><a href="#42827135">parent</a><span>|</span><a href="#42824824">next</a><span>|</span><label class="collapse" for="c-42827825">[-]</label><label class="expand" for="c-42827825">[1 more]</label></div><br/><div class="children"><div class="content">This is already a thing: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;ef&#x2F;core&#x2F;querying&#x2F;sql-queries" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;ef&#x2F;core&#x2F;querying&#x2F;sql-queri...</a> although it uses an older API - <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.formattablestring" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.formatta...</a><p>Interpolated string handlers are a newer API made primarily with customization and efficiency of interpolation in mind. They are more complicated to implement and use but enable zero-cost and&#x2F;or zero-allocation use cases and performing custom behavior on appending literals or data. They are also used to implement the default string interpolation handler and a few auxiliary ones like Append handler for a string builder which writes directly into it, bypassing intermediate string construction.<p>It&#x27;s quite a mouthful to say though but very useful for advanced scenarios. Haven&#x27;t seen any other language provide anything comparable.<p>See also: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;string-interpolation-in-c-10-and-net-6&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;string-interpolation-i...</a></div><br/></div></div></div></div></div></div><div id="42824824" class="c"><input type="checkbox" id="c-42824824" checked=""/><div class="controls bullet"><span class="by">dgan</span><span>|</span><a href="#42824947">prev</a><span>|</span><a href="#42828020">next</a><span>|</span><label class="collapse" for="c-42824824">[-]</label><label class="expand" for="c-42824824">[9 more]</label></div><br/><div class="children"><div class="content">Well. Query builders are composable. You can create a builder with partial query, and reuse in many queries. With sql strings, you either have to copy paste the string, or to define sql functions. It&#x27;s a trade off!</div><br/><div id="42824839" class="c"><input type="checkbox" id="c-42824839" checked=""/><div class="controls bullet"><span class="by">nixpulvis</span><span>|</span><a href="#42824824">parent</a><span>|</span><a href="#42825135">next</a><span>|</span><label class="collapse" for="c-42824839">[-]</label><label class="expand" for="c-42824839">[2 more]</label></div><br/><div class="children"><div class="content">Good point, even though copying strings isn&#x27;t hard. Figuring out where in the string to inject new parts isn&#x27;t always as easy. You end up with `select_part`, `where_part`, etc.</div><br/><div id="42824967" class="c"><input type="checkbox" id="c-42824967" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42824824">root</a><span>|</span><a href="#42824839">parent</a><span>|</span><a href="#42825135">next</a><span>|</span><label class="collapse" for="c-42824967">[-]</label><label class="expand" for="c-42824967">[1 more]</label></div><br/><div class="children"><div class="content">Making identical updates to copies of the strings when a bug is discovered is hard though. People who act like it isn’t hard create most of the evidence that it is.</div><br/></div></div></div></div><div id="42825135" class="c"><input type="checkbox" id="c-42825135" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42824824">parent</a><span>|</span><a href="#42824839">prev</a><span>|</span><a href="#42824876">next</a><span>|</span><label class="collapse" for="c-42825135">[-]</label><label class="expand" for="c-42825135">[3 more]</label></div><br/><div class="children"><div class="content">Tried to explain ORM composability at work (without praising ORM like a fanatic), most didn&#x27;t care, someone said to pass context dicts for future open-nes... weird.</div><br/><div id="42826505" class="c"><input type="checkbox" id="c-42826505" checked=""/><div class="controls bullet"><span class="by">nixpulvis</span><span>|</span><a href="#42824824">root</a><span>|</span><a href="#42825135">parent</a><span>|</span><a href="#42824876">next</a><span>|</span><label class="collapse" for="c-42826505">[-]</label><label class="expand" for="c-42826505">[2 more]</label></div><br/><div class="children"><div class="content">Having had the same argument at work in the past, I feel your pain. Trying to migrate away from massive SQL files and random strings here and there to a collection of interdependent composable SQL builders is apparently a tough sell.</div><br/><div id="42827207" class="c"><input type="checkbox" id="c-42827207" checked=""/><div class="controls bullet"><span class="by">wredcoll</span><span>|</span><a href="#42824824">root</a><span>|</span><a href="#42826505">parent</a><span>|</span><a href="#42824876">next</a><span>|</span><label class="collapse" for="c-42827207">[-]</label><label class="expand" for="c-42827207">[1 more]</label></div><br/><div class="children"><div class="content">My experience is this sort of thing is cyclical. You start with one approach, you use it a lot, you start noticing the flaws, oh here&#x27;s a brand new approach that solves all these flaws... and the cycle repeats.</div><br/></div></div></div></div></div></div><div id="42824876" class="c"><input type="checkbox" id="c-42824876" checked=""/><div class="controls bullet"><span class="by">jpalomaki</span><span>|</span><a href="#42824824">parent</a><span>|</span><a href="#42825135">prev</a><span>|</span><a href="#42824938">next</a><span>|</span><label class="collapse" for="c-42824876">[-]</label><label class="expand" for="c-42824876">[2 more]</label></div><br/><div class="children"><div class="content">Also once you start pasting the SQL together from multiple pieces, risks of SQL injection rise.</div><br/><div id="42824995" class="c"><input type="checkbox" id="c-42824995" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42824824">root</a><span>|</span><a href="#42824876">parent</a><span>|</span><a href="#42824938">next</a><span>|</span><label class="collapse" for="c-42824995">[-]</label><label class="expand" for="c-42824995">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know if it’s still true but some databases used to be able to process prepared statements more efficiently. We ran into a bottleneck with Oracle 9i where it could only execute queries currently in the query cache. Someone fucked up our query builder so a bunch of concurrent requests weren’t using the same prepared statement and should have been.<p>Which I specifically told him not to do.</div><br/></div></div></div></div><div id="42824938" class="c"><input type="checkbox" id="c-42824938" checked=""/><div class="controls bullet"><span class="by">jprosevear</span><span>|</span><a href="#42824824">parent</a><span>|</span><a href="#42824876">prev</a><span>|</span><a href="#42828020">next</a><span>|</span><label class="collapse" for="c-42824938">[-]</label><label class="expand" for="c-42824938">[1 more]</label></div><br/><div class="children"><div class="content">And ultimately every ORM allows raw SQL if you need to fallback</div><br/></div></div></div></div><div id="42828020" class="c"><input type="checkbox" id="c-42828020" checked=""/><div class="controls bullet"><span class="by">nemothekid</span><span>|</span><a href="#42824824">prev</a><span>|</span><a href="#42824831">next</a><span>|</span><label class="collapse" for="c-42828020">[-]</label><label class="expand" for="c-42828020">[1 more]</label></div><br/><div class="children"><div class="content">The use of `push_bind` here is strange to me. The idomatic way would be do something like:<p><pre><code>    let mut builder = Query::select();

</code></pre>
then you could (optionally) add clauses like so:<p><pre><code>    builder.and_where(Expr::col(&quot;id&quot;).eq(&quot;A&quot;))
</code></pre>
it shouldn&#x27;t matter if a where clause exists or not, the builder should figure that out for you.<p>If you are going to treat your QueryBuilder as glorified StringBuilder, then of course you won&#x27;t see the value of a QueryBuilder.</div><br/></div></div><div id="42824831" class="c"><input type="checkbox" id="c-42824831" checked=""/><div class="controls bullet"><span class="by">nixpulvis</span><span>|</span><a href="#42828020">prev</a><span>|</span><a href="#42826883">next</a><span>|</span><label class="collapse" for="c-42824831">[-]</label><label class="expand" for="c-42824831">[6 more]</label></div><br/><div class="children"><div class="content">`push_bind` covers a good deal of the concerns for a query builder, while letting us think in SQL instead of translating.<p>That said, an ORM like ActiveRecord also handles joins across related tables, and helps avoid N+1 queries, while still writing consistent access to fields.<p>I find myself missing ActiveRecord frequently. I know SeaORM aims to address this space, but I don&#x27;t think it&#x27;s there yet.</div><br/><div id="42824943" class="c"><input type="checkbox" id="c-42824943" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#42824831">parent</a><span>|</span><a href="#42826883">next</a><span>|</span><label class="collapse" for="c-42824943">[-]</label><label class="expand" for="c-42824943">[5 more]</label></div><br/><div class="children"><div class="content">These (avoid N+1, join across related tables) seem like problems that could be solved by writing the SQL by hand. Is it that much of a lift to treat the database like an API and just write a thin library&#x2F;access layer around it?<p>ORMs seem like they are a good fit for dynamic queries, where the end user, not the programmer, are developing the models.<p>Maybe I’m missing the point?</div><br/><div id="42825869" class="c"><input type="checkbox" id="c-42825869" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#42824831">root</a><span>|</span><a href="#42824943">parent</a><span>|</span><a href="#42826883">next</a><span>|</span><label class="collapse" for="c-42825869">[-]</label><label class="expand" for="c-42825869">[4 more]</label></div><br/><div class="children"><div class="content">For established software where performance matters, hand-writing the SQL is reasonable.<p>Hand-writing SQL for, say, a faceted filtering UI is a tedious job that takes most of a day in even fairly simple cases, or about 20 minutes with a decent ORM.<p>ActiveRecord (and related libraries like ActiveAdmin) are _amazing_ for rapid prototyping - eg if you don&#x27;t even know whether you&#x27;re going to end up keeping the faceted search.</div><br/><div id="42826225" class="c"><input type="checkbox" id="c-42826225" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#42824831">root</a><span>|</span><a href="#42825869">parent</a><span>|</span><a href="#42826883">next</a><span>|</span><label class="collapse" for="c-42826225">[-]</label><label class="expand" for="c-42826225">[3 more]</label></div><br/><div class="children"><div class="content">&gt; For established software where performance matters, hand-writing the SQL is reasonable.<p>These things aren’t mutually exclusive though. Every ORM I know gives you an escape hatch to write whatever sql you want. ORMs are great for 90% of things and as a reviewer I don’t need to scrutinize their queries too much. It’s much easier to for me to review an ORM builder query because I know it’s going to do the correct joins on the correct columns. For example in the ORM I use id rather see:<p><pre><code>    query()
        .where()
        .eq(“parent”, parent);
</code></pre>
Instead of:<p><pre><code>    “select * from table join parent on parent.id = table.parent_id where parent.id = :parent”</code></pre></div><br/><div id="42826356" class="c"><input type="checkbox" id="c-42826356" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42824831">root</a><span>|</span><a href="#42826225">parent</a><span>|</span><a href="#42826883">next</a><span>|</span><label class="collapse" for="c-42826356">[-]</label><label class="expand" for="c-42826356">[2 more]</label></div><br/><div class="children"><div class="content">Since you’re not returning anything from `parent`, it makes much more sense to use a semijoin, which is something ORMs usually bury in an obscure section of docs, if they support them at all.<p><pre><code>    SELECT * FROM `table` t
    WHERE EXISTS (
        SELECT 1 FROM parent p
        WHERE p.id = :parent)
</code></pre>
Or, you know, just eliminate the other table entirely (which the optimizer may well do) since p.id = t.parent_id = :parent</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42826883" class="c"><input type="checkbox" id="c-42826883" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42824831">prev</a><span>|</span><a href="#42825506">next</a><span>|</span><label class="collapse" for="c-42826883">[-]</label><label class="expand" for="c-42826883">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    CASE
        WHEN $2 BETWEEN 0 AND 100 AND $1 &gt; 0
            THEN (($1 - 1) * $2)
        ELSE
            50
    END
</code></pre>
What a wonderful, maintainable language for expressing logic in &#x2F;s. Perfect for my COBOL on Cogs application.<p>The problem with SQL has never been that it&#x27;s <i>impossible</i> to put logic in it. The problem is that it&#x27;s a classic Turing Tarpit.</div><br/></div></div><div id="42825506" class="c"><input type="checkbox" id="c-42825506" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#42826883">prev</a><span>|</span><a href="#42828349">next</a><span>|</span><label class="collapse" for="c-42825506">[-]</label><label class="expand" for="c-42825506">[4 more]</label></div><br/><div class="children"><div class="content">SQL isn&#x27;t composable. It would be great if it was, but it isn&#x27;t. So we can use query builders or write our own, but we&#x27;re going to have to compose queries at some point.</div><br/><div id="42825737" class="c"><input type="checkbox" id="c-42825737" checked=""/><div class="controls bullet"><span class="by">rented_mule</span><span>|</span><a href="#42825506">parent</a><span>|</span><a href="#42825823">next</a><span>|</span><label class="collapse" for="c-42825737">[-]</label><label class="expand" for="c-42825737">[1 more]</label></div><br/><div class="children"><div class="content">Common Table Expressions enable a lot of composability. Using them can look like you&#x27;re asking the DB to repeat a lot of work, but decent query optimizers eliminate much of that.<p><a href="https:&#x2F;&#x2F;www.craigkerstiens.com&#x2F;2013&#x2F;11&#x2F;18&#x2F;best-postgres-feature-youre-not-using&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.craigkerstiens.com&#x2F;2013&#x2F;11&#x2F;18&#x2F;best-postgres-feat...</a></div><br/></div></div><div id="42825823" class="c"><input type="checkbox" id="c-42825823" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#42825506">parent</a><span>|</span><a href="#42825737">prev</a><span>|</span><a href="#42825781">next</a><span>|</span><label class="collapse" for="c-42825823">[-]</label><label class="expand" for="c-42825823">[1 more]</label></div><br/><div class="children"><div class="content">How composable do you want it?<p>When I want to make a complicated intermediate query that other queries can reference I create it as a view.<p>I will admit that future me hates this sometimes when I need to dismantle several layers of views to change something.<p>And some people hate to have logic in the database, Personaly I tolerate a little logic, but understand them who don&#x27;t like it. any way, common table expressions (with subquery as ()...) are almost as composable as views. and have the benefit of being self contained in a single query.</div><br/></div></div><div id="42825781" class="c"><input type="checkbox" id="c-42825781" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#42825506">parent</a><span>|</span><a href="#42825823">prev</a><span>|</span><a href="#42828349">next</a><span>|</span><label class="collapse" for="c-42825781">[-]</label><label class="expand" for="c-42825781">[1 more]</label></div><br/><div class="children"><div class="content">Common table expressions do exist, and they compose ~alright (with the caveats that you&#x27;re limited to unique names and they&#x27;re kinda clunky and most ORMs don&#x27;t play nice with them).</div><br/></div></div></div></div><div id="42828349" class="c"><input type="checkbox" id="c-42828349" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42825506">prev</a><span>|</span><a href="#42824959">next</a><span>|</span><label class="collapse" for="c-42828349">[-]</label><label class="expand" for="c-42828349">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know Rust well, is this what&#x27;s known as a query builder in Rust? That&#x27;s weird to me, because in other typed languages that I know, query builders are typically typesafe and don&#x27;t just concatenate strings (see e.g. jOOQ for the JVM).</div><br/></div></div><div id="42824959" class="c"><input type="checkbox" id="c-42824959" checked=""/><div class="controls bullet"><span class="by">janlugt</span><span>|</span><a href="#42828349">prev</a><span>|</span><a href="#42827251">next</a><span>|</span><label class="collapse" for="c-42824959">[-]</label><label class="expand" for="c-42824959">[2 more]</label></div><br/><div class="children"><div class="content">Shameless plug, you can use something like pg_named_args[0] to at least have named instead of numbered arguments in your queries.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;tandemdrive&#x2F;pg_named_args">https:&#x2F;&#x2F;github.com&#x2F;tandemdrive&#x2F;pg_named_args</a></div><br/><div id="42825483" class="c"><input type="checkbox" id="c-42825483" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42824959">parent</a><span>|</span><a href="#42827251">next</a><span>|</span><label class="collapse" for="c-42825483">[-]</label><label class="expand" for="c-42825483">[1 more]</label></div><br/><div class="children"><div class="content">I will jump on the plug train with my [namedsql][0] for use with the Go standard library.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dgoffredo&#x2F;namedsql&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;dgoffredo&#x2F;namedsql&#x2F;</a></div><br/></div></div></div></div><div id="42827251" class="c"><input type="checkbox" id="c-42827251" checked=""/><div class="controls bullet"><span class="by">davidwparker</span><span>|</span><a href="#42824959">prev</a><span>|</span><a href="#42826538">next</a><span>|</span><label class="collapse" for="c-42827251">[-]</label><label class="expand" for="c-42827251">[3 more]</label></div><br/><div class="children"><div class="content">Meta - anyone else not seeing a scrollbar on the blog? Chrome on OSX.</div><br/><div id="42828277" class="c"><input type="checkbox" id="c-42828277" checked=""/><div class="controls bullet"><span class="by">butz</span><span>|</span><a href="#42827251">parent</a><span>|</span><a href="#42826538">next</a><span>|</span><label class="collapse" for="c-42828277">[-]</label><label class="expand" for="c-42828277">[2 more]</label></div><br/><div class="children"><div class="content">scrollbar-width: none; - looks like decision to hide scrollbar was intended by author. Shame.</div><br/><div id="42828835" class="c"><input type="checkbox" id="c-42828835" checked=""/><div class="controls bullet"><span class="by">defanor</span><span>|</span><a href="#42827251">root</a><span>|</span><a href="#42828277">parent</a><span>|</span><a href="#42826538">next</a><span>|</span><label class="collapse" for="c-42828835">[-]</label><label class="expand" for="c-42828835">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. I was about to write about it to the author by mail, but noticed that he posted this link, and probably will read these comments, so can as well provide the feedback by joining this subthread: at least a few readers are not happy about our scrollbars being hidden.</div><br/></div></div></div></div></div></div><div id="42826538" class="c"><input type="checkbox" id="c-42826538" checked=""/><div class="controls bullet"><span class="by">maximilianroos</span><span>|</span><a href="#42827251">prev</a><span>|</span><a href="#42827438">next</a><span>|</span><label class="collapse" for="c-42826538">[-]</label><label class="expand" for="c-42826538">[3 more]</label></div><br/><div class="children"><div class="content">SQL is terrible at allowing this sort of transformation.<p>One benefit of PRQL [disclaimer: maintainer] is that it&#x27;s simple to add additional logic — just add a line filtering the result:<p><pre><code>  from users
  derive [full_name = name || &#x27; &#x27; || surname]
  filter id == 42           # conditionally added only if needed
  filter username == param  # again, only if the param is present
  take 50</code></pre></div><br/><div id="42828141" class="c"><input type="checkbox" id="c-42828141" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#42826538">parent</a><span>|</span><a href="#42827438">next</a><span>|</span><label class="collapse" for="c-42828141">[-]</label><label class="expand" for="c-42828141">[2 more]</label></div><br/><div class="children"><div class="content">I never looked into prql; does the ordering matter? As if not , that would be great; aka, is this the same:<p><pre><code>  from users
  take 50
  filter id == 42           # conditionally added only if needed
  filter username == param  # again, only if the param is present
  derive [full_name = name || &#x27; &#x27; || surname]
  </code></pre>
? As that&#x27;s more how I tend to think and write code, but in sql, I always jump around in the query as I don&#x27;t work in the order sql works.<p>I usually use knex or EF or such where ordering doesn&#x27;t matter; it&#x27;s a joy however, I prefer writing queries directly as it&#x27;s easier.</div><br/><div id="42828745" class="c"><input type="checkbox" id="c-42828745" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42826538">root</a><span>|</span><a href="#42828141">parent</a><span>|</span><a href="#42827438">next</a><span>|</span><label class="collapse" for="c-42828745">[-]</label><label class="expand" for="c-42828745">[1 more]</label></div><br/><div class="children"><div class="content">`take 50` of all `users` records in random order and after filter the result with username and id? I hope it&#x27;s the right answer and prql authors are sane.</div><br/></div></div></div></div></div></div><div id="42827438" class="c"><input type="checkbox" id="c-42827438" checked=""/><div class="controls bullet"><span class="by">econ</span><span>|</span><a href="#42826538">prev</a><span>|</span><a href="#42825389">next</a><span>|</span><label class="collapse" for="c-42827438">[-]</label><label class="expand" for="c-42827438">[1 more]</label></div><br/><div class="children"><div class="content">With only 4 optional Params you can just have 15 queries. Heh<p>I remember back when everything was someone&#x27;s idea and others would both compliment it and improve it.  Now it is like things are unchangable holy scripture. Just let `Null &lt; 42 or Null &gt; 42 or name = Null`  all be true. What is the big deal? I can barely wrap my head around joins, the extra luggage really isn&#x27;t welcome. Just have some ugly pollyfills for a decade or so. All will be fine.</div><br/></div></div><div id="42826844" class="c"><input type="checkbox" id="c-42826844" checked=""/><div class="controls bullet"><span class="by">evantbyrne</span><span>|</span><a href="#42825389">prev</a><span>|</span><a href="#42827704">next</a><span>|</span><label class="collapse" for="c-42826844">[-]</label><label class="expand" for="c-42826844">[3 more]</label></div><br/><div class="children"><div class="content">The lack of expressiveness in query builders that the author refers to in their first post as a motivation for ditching them is an easily solvable problem. It seems like most ORMs have easily solvable design issues though, and I would definitely agree that you should ditch tools that get in your way. What I&#x27;ve been doing is sporadically working on an _experimental_ Golang ORM called Trance, which solved this by allowing parameterized SQL anywhere in the builder through the use of interfaces. e.g.,<p><pre><code>    trance.Query[Account].Filter(&quot;foo&quot;, &quot;=&quot;, trance.Sql(&quot;...&quot;, trance.Param(&quot;bar&quot;))</code></pre></div><br/><div id="42827217" class="c"><input type="checkbox" id="c-42827217" checked=""/><div class="controls bullet"><span class="by">wredcoll</span><span>|</span><a href="#42826844">parent</a><span>|</span><a href="#42827704">next</a><span>|</span><label class="collapse" for="c-42827217">[-]</label><label class="expand" for="c-42827217">[2 more]</label></div><br/><div class="children"><div class="content">So now instead of writing sql I have to manually write the AST?</div><br/><div id="42827484" class="c"><input type="checkbox" id="c-42827484" checked=""/><div class="controls bullet"><span class="by">evantbyrne</span><span>|</span><a href="#42826844">root</a><span>|</span><a href="#42827217">parent</a><span>|</span><a href="#42827704">next</a><span>|</span><label class="collapse" for="c-42827484">[-]</label><label class="expand" for="c-42827484">[1 more]</label></div><br/><div class="children"><div class="content">The whole query builder is an optional abstraction built onto the ORM. It has many benefits, but will also never completely support every SQL variant in existence, as is true with all query builders. so I feel as though the only responsible way to build ORMs is with escape hatches, and this is one of them.</div><br/></div></div></div></div></div></div><div id="42828754" class="c"><input type="checkbox" id="c-42828754" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#42827704">prev</a><span>|</span><a href="#42825477">next</a><span>|</span><label class="collapse" for="c-42828754">[-]</label><label class="expand" for="c-42828754">[1 more]</label></div><br/><div class="children"><div class="content">A strong reminder that you&#x27;d have to yank ActiveRecord from my cold, dead hands.</div><br/></div></div><div id="42825477" class="c"><input type="checkbox" id="c-42825477" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#42828754">prev</a><span>|</span><a href="#42828280">next</a><span>|</span><label class="collapse" for="c-42825477">[-]</label><label class="expand" for="c-42825477">[4 more]</label></div><br/><div class="children"><div class="content">I assumed this meant &quot;graphical query builders&quot; (and who exactly is defending <i>those</i>!)<p>Is this term Rust specific or have I slept through another change in terminology (like the day I woke up to find developers were suddenly &quot;SWE&quot;s)?</div><br/><div id="42827631" class="c"><input type="checkbox" id="c-42827631" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#42825477">parent</a><span>|</span><a href="#42826569">next</a><span>|</span><label class="collapse" for="c-42827631">[-]</label><label class="expand" for="c-42827631">[1 more]</label></div><br/><div class="children"><div class="content">It’s a commonly used term. <a href="https:&#x2F;&#x2F;www.prisma.io&#x2F;dataguide&#x2F;types&#x2F;relational&#x2F;comparing-sql-query-builders-and-orms" rel="nofollow">https:&#x2F;&#x2F;www.prisma.io&#x2F;dataguide&#x2F;types&#x2F;relational&#x2F;comparing-s...</a></div><br/></div></div><div id="42826569" class="c"><input type="checkbox" id="c-42826569" checked=""/><div class="controls bullet"><span class="by">Macha</span><span>|</span><a href="#42825477">parent</a><span>|</span><a href="#42827631">prev</a><span>|</span><a href="#42825900">next</a><span>|</span><label class="collapse" for="c-42826569">[-]</label><label class="expand" for="c-42826569">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely not Rust specific, or even that new. Certainly I was hearing things (e.g. SQLAlchemy&#x27;s lower level API) referred to as query builders 15 years ago.</div><br/></div></div></div></div><div id="42828280" class="c"><input type="checkbox" id="c-42828280" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#42825477">prev</a><span>|</span><a href="#42825413">next</a><span>|</span><label class="collapse" for="c-42828280">[-]</label><label class="expand" for="c-42828280">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, the SQL injection cycle begins anew. A solved vulnerability for decades, only for the new generation of junior devs to ignore wisdom of the old generation again and introduce it anew.<p>Don&#x27;t ever do this. Query builders exist to sanitize inputs in a failsafe manner. SQL has so many pitfalls that tools like sqlmap [1] exist for a reason. You will never be able to catch all encoding schemes in a regex approach to filter unsanitized input.<p>The examples in the blog can be exploited with a simple id set to &quot;1 or 1=1;--&quot; and is literally the very first web exploitation technique that is taught in highschool-level CTFs.<p>sqlx can mitigate a lot of problems at compile time, but sanitization is completely ignored in the post, and should at least be mentioned. If you recommend to juniors that they don&#x27;t need a query builder, tell them at least why they existed in the first place.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;sqlmapproject&#x2F;sqlmap">https:&#x2F;&#x2F;github.com&#x2F;sqlmapproject&#x2F;sqlmap</a></div><br/></div></div><div id="42825413" class="c"><input type="checkbox" id="c-42825413" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#42828280">prev</a><span>|</span><a href="#42824906">next</a><span>|</span><label class="collapse" for="c-42825413">[-]</label><label class="expand" for="c-42825413">[1 more]</label></div><br/><div class="children"><div class="content">There was an essay a couple years ago that really convinced me to not use query builders, <a href="https:&#x2F;&#x2F;gajus.medium.com&#x2F;stop-using-knex-js-and-earn-30-bf410349856c" rel="nofollow">https:&#x2F;&#x2F;gajus.medium.com&#x2F;stop-using-knex-js-and-earn-30-bf41...</a> , and from that I switched to using Slonik (by the author of that blog post). There were some growing pains as the API was updated over the years, especially to support strong typing in the response, but now the API is quite stable and I love that project.</div><br/></div></div><div id="42824906" class="c"><input type="checkbox" id="c-42824906" checked=""/><div class="controls bullet"><span class="by">sebazzz</span><span>|</span><a href="#42825413">prev</a><span>|</span><a href="#42825461">next</a><span>|</span><label class="collapse" for="c-42824906">[-]</label><label class="expand" for="c-42824906">[1 more]</label></div><br/><div class="children"><div class="content">Using the OR approach can actually cause some headaches. It can cause SQL Server to make an suboptimal plan for the other queries which have the same query text but due to the parameters behave completely different.</div><br/></div></div><div id="42825461" class="c"><input type="checkbox" id="c-42825461" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#42824906">prev</a><span>|</span><a href="#42824903">next</a><span>|</span><label class="collapse" for="c-42825461">[-]</label><label class="expand" for="c-42825461">[1 more]</label></div><br/><div class="children"><div class="content">I completely disagree. I love .NET Entity Framework Core. It&#x27;s possible to build queries in code with a SQL-like syntax and a lot of helpers. But it&#x27;s also possible to provide raw SQL to the query builder. And the top notch feature: You can combine both methods into a single query.<p>Everything has it&#x27;s place though. Query builders and ORMs require some effort to keep in sync with the database schema. Sometimes it&#x27;s worth the effort, sometimes not.</div><br/></div></div><div id="42824903" class="c"><input type="checkbox" id="c-42824903" checked=""/><div class="controls bullet"><span class="by">mojuba</span><span>|</span><a href="#42825461">prev</a><span>|</span><a href="#42827047">next</a><span>|</span><label class="collapse" for="c-42824903">[-]</label><label class="expand" for="c-42824903">[1 more]</label></div><br/><div class="children"><div class="content">You probably don&#x27;t. For the same reason you don&#x27;t need a builder for writing Rust programs. You just write Rust programs.</div><br/></div></div><div id="42827047" class="c"><input type="checkbox" id="c-42827047" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#42824903">prev</a><span>|</span><a href="#42825365">next</a><span>|</span><label class="collapse" for="c-42827047">[-]</label><label class="expand" for="c-42827047">[1 more]</label></div><br/><div class="children"><div class="content">Yeah of course you don&#x27;t <i>need</i> query builders. But maybe you <i>want</i> them?</div><br/></div></div><div id="42825365" class="c"><input type="checkbox" id="c-42825365" checked=""/><div class="controls bullet"><span class="by">1270018080</span><span>|</span><a href="#42827047">prev</a><span>|</span><label class="collapse" for="c-42825365">[-]</label><label class="expand" for="c-42825365">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;m just going to stick with query builders.</div><br/><div id="42826498" class="c"><input type="checkbox" id="c-42826498" checked=""/><div class="controls bullet"><span class="by">Supermancho</span><span>|</span><a href="#42825365">parent</a><span>|</span><label class="collapse" for="c-42826498">[-]</label><label class="expand" for="c-42826498">[1 more]</label></div><br/><div class="children"><div class="content">Avoid pushing business logic into SQL. Broadly, if a solution is &quot;be more sophisticated or nuanced&quot;, you&#x27;re raising the bar for entry. That&#x27;s one of the worst things to do for development time across a set of collaborators.</div><br/></div></div></div></div></div></div></div></div></div></body></html>