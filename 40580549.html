<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717578075940" as="style"/><link rel="stylesheet" href="styles.css?v=1717578075940"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.ploeh.dk/2024/06/03/youll-regret-using-natural-keys/">You&#x27;ll regret using natural keys</a> <span class="domain">(<a href="https://blog.ploeh.dk">blog.ploeh.dk</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>137 comments</span></div><br/><div><div id="40582659" class="c"><input type="checkbox" id="c-40582659" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#40582365">next</a><span>|</span><label class="collapse" for="c-40582659">[-]</label><label class="expand" for="c-40582659">[1 more]</label></div><br/><div class="children"><div class="content">In databases, never rely on data you don&#x27;t control. &quot;Natural&quot; keys are an example of this.<p>Names can be natural keys, but you don&#x27;t control them. You don&#x27;t control when or how a name changes, or even what makes a valid name.<p>Addresses change. Or disappear. Or somehow can&#x27;t be ingested by your system suddenly.<p>Official registration numbers (SSNs, license plate numbers, business numbers etc) seem attractive, but once again you don&#x27;t control them. So if the license plate numbering scheme changes in some way that breaks your system, too bad. Or people without an SSN. Or people in transition because an SSN needs to be changed in a government system somewhere. Or any other number of things that happen in a government office that affect you, yet you have no control over.<p>Phone numbers? Well, we&#x27;ve already seen that mess with many messenger platforms.<p>Fingerprints? Guess what? They evolve over time, and your system will eventually break.<p>Use a generated unique key system that YOU ALONE control.<p>The first rule of software design is: Don&#x27;t try to be clever. You&#x27;re not clever enough to see all of the edge cases that will eventually bite you.</div><br/></div></div><div id="40582365" class="c"><input type="checkbox" id="c-40582365" checked=""/><div class="controls bullet"><span class="by">strnisa</span><span>|</span><a href="#40582659">prev</a><span>|</span><a href="#40581065">next</a><span>|</span><label class="collapse" for="c-40582365">[-]</label><label class="expand" for="c-40582365">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve become a fan of unique, relatively short and &quot;human-readable&quot; IDs, such at the ones used by Stripe, e.g. `cus_MJA953cFzEuO1z` for an ID of a customer. Here&#x27;s a Stripe dev article on the topic: <a href="https:&#x2F;&#x2F;dev.to&#x2F;stripe&#x2F;designing-apis-for-humans-object-ids-3o5a" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;stripe&#x2F;designing-apis-for-humans-object-ids-3...</a><p>If you use JavaScript&#x2F;TypeScript, you can make them like this:<p><pre><code>    function makeSlug(length: number): string {
        const validChars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;
        const randomBytes = crypto.randomBytes(length);
        let result = &quot;&quot;;
        for (let i = 0; i &lt; length; i++) {
            result += validChars[randomBytes[i] % validChars.length];
        }
        return result;
    }

    function makeId(tableName: string): string {
        const idSpec = TABLE_NAME_TO_ID_SPEC[tableName];
        const prefix = idSpec.prefix;
        const slugLength = idSpec.length - prefix.length - 1;
        return `${prefix}_${makeSlug(slugLength)}`;
    }</code></pre></div><br/><div id="40582794" class="c"><input type="checkbox" id="c-40582794" checked=""/><div class="controls bullet"><span class="by">vincentdm</span><span>|</span><a href="#40582365">parent</a><span>|</span><a href="#40582478">next</a><span>|</span><label class="collapse" for="c-40582794">[-]</label><label class="expand" for="c-40582794">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like the prefix idea: besides the duplication of information, it also becomes a liability if you ever rename things.<p>Imagine you prefix all customer IDs with `cus_`, but at some point decide to rename Customer to Organization in your codebase (e.g. because it turns out some of the entities you are storing are not actually customers). Now you have some legacy prefix that cannot be changed, is permanently out of sync with the code and will confuse every new developer.</div><br/></div></div><div id="40582478" class="c"><input type="checkbox" id="c-40582478" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#40582365">parent</a><span>|</span><a href="#40582794">prev</a><span>|</span><a href="#40582619">next</a><span>|</span><label class="collapse" for="c-40582478">[-]</label><label class="expand" for="c-40582478">[1 more]</label></div><br/><div class="children"><div class="content">Nice!<p>For the record: the valid chars string is 62 characters, so naively using a modulo on a random byte will <i>technically</i> introduce a bias (since dividing 256 values by 62 leaves a remainder). I don&#x27;t expect it to really matter here, but since you&#x27;re putting in the effort of using crypto.randomBytes I figured you might appreciate the nitpick ;).<p>Melissa E. O&#x27;Neill has a nice article explaining what the problem is, and includes a large number of ways to remove the bias as well:<p><a href="https:&#x2F;&#x2F;www.pcg-random.org&#x2F;posts&#x2F;bounded-rands.html" rel="nofollow">https:&#x2F;&#x2F;www.pcg-random.org&#x2F;posts&#x2F;bounded-rands.html</a><p>(in this case adding two more characters to the validChars string would be the easiest and most efficient fix, but I&#x27;m not sure if that is a possibility here)</div><br/></div></div><div id="40582619" class="c"><input type="checkbox" id="c-40582619" checked=""/><div class="controls bullet"><span class="by">whyever</span><span>|</span><a href="#40582365">parent</a><span>|</span><a href="#40582478">prev</a><span>|</span><a href="#40581065">next</a><span>|</span><label class="collapse" for="c-40582619">[-]</label><label class="expand" for="c-40582619">[1 more]</label></div><br/><div class="children"><div class="content">Please don&#x27;t use % to generate integers from a range, it&#x27;s not uniform, which can be disastrous if you rely on your numbers not being predictable. You can use crypto.randomInt instead.</div><br/></div></div></div></div><div id="40581065" class="c"><input type="checkbox" id="c-40581065" checked=""/><div class="controls bullet"><span class="by">jklowden</span><span>|</span><a href="#40582365">prev</a><span>|</span><a href="#40581092">next</a><span>|</span><label class="collapse" for="c-40581065">[-]</label><label class="expand" for="c-40581065">[55 more]</label></div><br/><div class="children"><div class="content">You think your surrogate key will save you?  It will not. The world has an external reality that needs to be reflected in your database. If the unique identifier for your object — VIN, CUSIP, whatever — if it changes, the world will henceforth refer to it by both.  You will need to track both. Adding a synthetic key only means you have to track all three. Plus you have to generate a meaningless number, which is actually a choke point in your data throughput.<p>The natural key forces you to think about what makes the row unique. What <i>identifies</i> it. Sometimes, it makes you go back to the SME and ask them what they mean. Sometimes it makes you reconsider time: it’s unique now, but does it change over time, and does the database need to capture that?  In short, what are the boundaries of the Closed World Assumption?  You need to know that too, to answer any &quot;not exists&quot; question.<p>To use our professor’s car’s example, we actually do not know the database design. It could well be that the original identifier remained the primary key, and the &quot;new id&quot; is entered as an alias. The ID is unique in the Car table, identifying the vehicle, and is not in the CarAlias table, where the aliases are unique.<p>Oh, you say, but what if the bad old ID gets reused?  Good question. Better question: how will the surrogate key protect you? It will not. The reused ID will be used to query the system. Without some distinguishing feature, perhaps date, it will serve up duplicates. The problem has to be handled, and the surrogate key is no defense.<p>Model your data on the real world. Do not depend on spherical horses.</div><br/><div id="40581759" class="c"><input type="checkbox" id="c-40581759" checked=""/><div class="controls bullet"><span class="by">yashap</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581197">next</a><span>|</span><label class="collapse" for="c-40581759">[-]</label><label class="expand" for="c-40581759">[10 more]</label></div><br/><div class="children"><div class="content">This is bad advice.<p>Say I have a user table, and the email is unique and required, and we don’t let users update their email, and we don’t have user deletion. If I’m going natural PK, I make email the primary key.<p>But … then we add the ability for users to update their email. But it should still be the same user! This is trivial if we have a surrogate primary key, a nightmare if we made email the natural primary key.<p>Or building on that example, maybe at first we always require an email from our users. But later we also allow phone auth, and you just need an email OR a phone number. And later we add user name auth, SSO, etc. Again, all good with surrogate primary keys, a nightmare with natural primary keys.<p>There are countless examples like this. You brought up cars, same thing with licence plates, for example. Or even Social Security Numbers&#x2F;Social Insurance Numbers - in Canada SINs are generally permanent, but temporary residents can have their SIN change if they later become permanent residents, but they’re still the same person.<p>You want your entities to have stable identity, even if things you at one time thought gave them identity change. Surrogate primary keys do that, natural primary keys do not. Don’t use natural primary keys, use surrogate primary keys with unique constraints&#x2F;indexes.<p>I challenge you to come up with a single plausible example where you’re screwing yourself by choosing surrogate PK + unique constraints&#x2F;indexes. Meanwhile there are endless examples where you’re screwing yourself by choosing natural PK.</div><br/><div id="40582224" class="c"><input type="checkbox" id="c-40582224" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581759">parent</a><span>|</span><a href="#40582123">next</a><span>|</span><label class="collapse" for="c-40582224">[-]</label><label class="expand" for="c-40582224">[2 more]</label></div><br/><div class="children"><div class="content">&gt; then we add the ability for users to update their email.<p>At this point, you should verify the new email. At least until it is verified, you must track the old email. At this point, you realize you can now introduce a synthetic key and you&#x27;re fine.<p>Let&#x27;s say you have a duplicate customer entry and the customer demands their accounts be merged. Now you can&#x27;t identify the user by their key alone, since by definition, they can&#x27;t be the same (yet.)</div><br/><div id="40582771" class="c"><input type="checkbox" id="c-40582771" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582224">parent</a><span>|</span><a href="#40582123">next</a><span>|</span><label class="collapse" for="c-40582771">[-]</label><label class="expand" for="c-40582771">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At this point, you realize you can now introduce a synthetic key and you&#x27;re fine.<p>Except for having to update all foreign references. Some of those may be external further complicating issues.<p>Emails are often among the worst keys because they are not terribly stable and they are reusable often enough to burn you.</div><br/></div></div></div></div><div id="40582123" class="c"><input type="checkbox" id="c-40582123" checked=""/><div class="controls bullet"><span class="by">maweki</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581759">parent</a><span>|</span><a href="#40582224">prev</a><span>|</span><a href="#40582237">next</a><span>|</span><label class="collapse" for="c-40582123">[-]</label><label class="expand" for="c-40582123">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I challenge you to come up with a single plausible example<p>So I come from academia, but generally if you use a natural key as PK in a foreign key constraint it may be possible to express additional consistency criteria as CHECK-constraints in the referencing table.<p>So this is a bad example, but say you have Name and Birthdate as your PK, and you have a second table where you have certain special offers sold to your customers and there is this special offer just for Virgos and Pisces, you could enforce that the birth date matches this special offer. Some modern systems also technically allow FK on alternate keys, so you could still do it that way, but database theory often ignores that.<p>But second, while I agree that surrogate keys are often a good idea, I find your argument, that you must design for every conceivable change, not convincing.</div><br/><div id="40582242" class="c"><input type="checkbox" id="c-40582242" checked=""/><div class="controls bullet"><span class="by">lstamour</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582123">parent</a><span>|</span><a href="#40582215">next</a><span>|</span><label class="collapse" for="c-40582242">[-]</label><label class="expand" for="c-40582242">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some modern systems also technically allow FK on alternate keys<p>As far as I can tell, all modern systems allow it, as it is part of the SQL standard that foreign keys can be either primary keys or unique indexes. Here&#x27;s a brief quotation from a copy of ISO&#x2F;IEC 9075-2:1999 (not the latest version) that I randomly found online:<p>&gt; If the &lt;referenced table and columns&gt; specifies a &lt;reference column list&gt;, then the set of &lt;column name&gt;s contained in that &lt;reference column list&gt; shall be equal to the set of &lt;column name&gt;s contained in the &lt;unique column list&gt; of a unique constraint of the referenced table.<p>So it mentions unique constraints first. Then afterward it says:<p>&gt; If the &lt;referenced table and columns&gt; does not specify a &lt;reference column list&gt;, then the table descriptor of the referenced table shall include a unique constraint that specifies PRIMARY KEY.<p>If I&#x27;m reading this right, it means that in the base case, where you specify the column to reference, it can be any unique constraint, where a primary key is just another possible unique constraint (as all primary keys are by definition unique). And only if you don&#x27;t specify the fields to reference does it then fall back to the primary key instead of a named unique constraint.<p>I&#x27;m not disagreeing with you entirely - it&#x27;s true that often there&#x27;s an assumption in database theory that primary keys are natural and foreign keys are primary keys. But this isn&#x27;t a hard requirement in practice or in theory, and it partly depends on the foreign key&#x27;s purpose, why you need it in the first place. This StackOverflow answer also explains it well: <a href="https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;a&#x2F;254566" rel="nofollow">https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;a&#x2F;254566</a><p>I should add that there is also a set of database design wisdom that suggests you should never use database constraints such as foreign keys, only app&#x2F;api constraints, but that&#x27;s a whole different tangent.</div><br/></div></div><div id="40582215" class="c"><input type="checkbox" id="c-40582215" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582123">parent</a><span>|</span><a href="#40582242">prev</a><span>|</span><a href="#40582183">next</a><span>|</span><label class="collapse" for="c-40582215">[-]</label><label class="expand" for="c-40582215">[1 more]</label></div><br/><div class="children"><div class="content">Why does anything need to be a primary key anywhere in order to enforce some constraint?
At least from ORMs I know I can set for example any group of attributes unique. Other constraints can be implemented in some general method that is called when persisting in the actual database.
Even if no ORM, you can write a wrapper around your persisting procedure.</div><br/></div></div><div id="40582183" class="c"><input type="checkbox" id="c-40582183" checked=""/><div class="controls bullet"><span class="by">cjfd</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582123">parent</a><span>|</span><a href="#40582215">prev</a><span>|</span><a href="#40582243">next</a><span>|</span><label class="collapse" for="c-40582183">[-]</label><label class="expand" for="c-40582183">[1 more]</label></div><br/><div class="children"><div class="content">&quot;for every conceivable change&quot;.<p>That is not what he is arguing at all. He is showing that there are very many highly plausible changes that are problematic with natural keys. And he totally correct about that. Frankly, the fact that a post arguing for natural keys makes it the top of an HN comment thread is extremely weird. The original article is correct that natural keys are bad.</div><br/></div></div><div id="40582243" class="c"><input type="checkbox" id="c-40582243" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582123">parent</a><span>|</span><a href="#40582183">prev</a><span>|</span><a href="#40582237">next</a><span>|</span><label class="collapse" for="c-40582243">[-]</label><label class="expand" for="c-40582243">[2 more]</label></div><br/><div class="children"><div class="content">Another example is where you use a service that provides you with a stable id. It makes little sense to add a surrogate id and a fk on that surrogate id. It violates data quality and integrity just for a hypothetical situation.<p>Data integrity&#x2F;quality matters. Adding friction to prevent accidents also matters. I don&#x27;t want something accidentally and trivially updating a field that&#x27;s used to reference thing externally.<p>Something about the nat key is about to change? Fine, we can write migrations. Even if it affects millions of rows, it&#x27;s not a big deal.<p>I understand people have been burnt by bad design decisions involving nat keys, but they&#x27;re not some devil&#x27;s key everyone here dogmatically makes them out to be. You can mess up using anything.</div><br/><div id="40582286" class="c"><input type="checkbox" id="c-40582286" checked=""/><div class="controls bullet"><span class="by">maweki</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582243">parent</a><span>|</span><a href="#40582237">next</a><span>|</span><label class="collapse" for="c-40582286">[-]</label><label class="expand" for="c-40582286">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a service that provides you with a stable id<p>I think there&#x27;s the important point. Is your key <i>actually natural</i> or is it someone else&#x27;s surrogate key anyway? Going back to the vehicle identification number: that&#x27;s already a surrogate key. You just did not assign it yourself.</div><br/></div></div></div></div></div></div><div id="40582237" class="c"><input type="checkbox" id="c-40582237" checked=""/><div class="controls bullet"><span class="by">brigandish</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581759">parent</a><span>|</span><a href="#40582123">prev</a><span>|</span><a href="#40581197">next</a><span>|</span><label class="collapse" for="c-40582237">[-]</label><label class="expand" for="c-40582237">[1 more]</label></div><br/><div class="children"><div class="content">You require three fields (or four): email at registration, a date for that entry (together these create a natural key), and current email (this one not part of the key and editable).<p>We&#x27;re almost all the way to a Tag URI[0], so you could combine it with the user&#x27;s name or username or any other identifier that fits the spec[1] (you could even use the website&#x27;s own name) and you have a (definitely two thirds, probably 100%) natural key.<p>It&#x27;s stable over time and unique, easy to mint, and has a standard behind it. The user also gets to change their contact details without any problem related to the key.<p>[0] <a href="https:&#x2F;&#x2F;taguri.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;taguri.org&#x2F;</a><p>[1] <a href="http:&#x2F;&#x2F;www.faqs.org&#x2F;rfcs&#x2F;rfc4151.html" rel="nofollow">http:&#x2F;&#x2F;www.faqs.org&#x2F;rfcs&#x2F;rfc4151.html</a></div><br/></div></div></div></div><div id="40581197" class="c"><input type="checkbox" id="c-40581197" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581759">prev</a><span>|</span><a href="#40581512">next</a><span>|</span><label class="collapse" for="c-40581197">[-]</label><label class="expand" for="c-40581197">[16 more]</label></div><br/><div class="children"><div class="content">The surrogate key uniquely identifies <i>a row in your database</i>, which is an entity just as real and significant as the car or the employee or what-have-you. Don&#x27;t confuse the two!<p>I agree with you that having a surrogate key isn&#x27;t going to save you from the reasons why natural keys can be difficult. The complexity has to go somewhere. But <i>not</i> having a unique identifier for each row is going to make things <i>extra</i> difficult.</div><br/><div id="40581305" class="c"><input type="checkbox" id="c-40581305" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581197">parent</a><span>|</span><a href="#40582346">next</a><span>|</span><label class="collapse" for="c-40581305">[-]</label><label class="expand" for="c-40581305">[1 more]</label></div><br/><div class="children"><div class="content">Precisely. And if I have a surrogate key to identify “a car”, <i>I</i> get to define what makes a car unique for my purposes. Maybe that really is the VIN. Maybe today it’s the VIN, but tomorrow it’s whatever vehicle is currently being driven by its owner. Maybe it’s something else.<p>Some day I may need to track multiple VINs for a vehicle (maybe it’s got parts from multiple VINs and I want to track that). I can still always decompose that table and have an n-to-1 relationship between cars and VINs <i>without migrating the rest of my data model</i>.</div><br/></div></div><div id="40582346" class="c"><input type="checkbox" id="c-40582346" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581197">parent</a><span>|</span><a href="#40581305">prev</a><span>|</span><a href="#40582012">next</a><span>|</span><label class="collapse" for="c-40582346">[-]</label><label class="expand" for="c-40582346">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The surrogate key uniquely identifies a row in your database, which is an entity just as real and significant as the car or the employee or what-have-you. Don&#x27;t confuse the two!<p>But the DBMS already maintains a row identifier (called rowid or ctid or whatever depending on the DBMS). Why do you need an explicit one?</div><br/><div id="40582824" class="c"><input type="checkbox" id="c-40582824" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582346">parent</a><span>|</span><a href="#40582483">next</a><span>|</span><label class="collapse" for="c-40582824">[-]</label><label class="expand" for="c-40582824">[1 more]</label></div><br/><div class="children"><div class="content">Be careful with those. SQLite has a rowid concept, but it&#x27;s not guaranteed to be stable - running a VACUUM against a table can reassign the rowids for every row!<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;rowidtable.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;rowidtable.html</a> says:<p>&gt; If the rowid is not aliased by INTEGER PRIMARY KEY then it is not persistent and might change. In particular the VACUUM command will change rowids for tables that do not declare an INTEGER PRIMARY KEY. Therefore, applications should not normally access the rowid directly, but instead use an INTEGER PRIMARY KEY.</div><br/></div></div><div id="40582483" class="c"><input type="checkbox" id="c-40582483" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582346">parent</a><span>|</span><a href="#40582824">prev</a><span>|</span><a href="#40582397">next</a><span>|</span><label class="collapse" for="c-40582483">[-]</label><label class="expand" for="c-40582483">[1 more]</label></div><br/><div class="children"><div class="content">In the DB we use[1] the internal row id is not stable:<p><i>The value returned by the function is not necessarily constant between queries as various operations performed on the database may result in changes to the row identifiers of a table.</i><p><i>So, users should refrain from using the ROWID function in ordinary situations; retrieval by primary key value should be used instead.</i><p>[1]: <a href="https:&#x2F;&#x2F;infocenter.sybase.com&#x2F;help&#x2F;index.jsp?topic=&#x2F;com.sybase.help.sqlanywhere.12.0.1&#x2F;dbreference&#x2F;rowid-function.html" rel="nofollow">https:&#x2F;&#x2F;infocenter.sybase.com&#x2F;help&#x2F;index.jsp?topic=&#x2F;com.syba...</a></div><br/></div></div><div id="40582397" class="c"><input type="checkbox" id="c-40582397" checked=""/><div class="controls bullet"><span class="by">unchar1</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582346">parent</a><span>|</span><a href="#40582483">prev</a><span>|</span><a href="#40582012">next</a><span>|</span><label class="collapse" for="c-40582397">[-]</label><label class="expand" for="c-40582397">[1 more]</label></div><br/><div class="children"><div class="content">It may be useful if you have data that originates from another source or if something outside of our system references your entity. In that case you need to keep some form of an externalRef, so it&#x27;s usually easier to just use an id that you can control, for referencing both internally and externally.</div><br/></div></div></div></div><div id="40582012" class="c"><input type="checkbox" id="c-40582012" checked=""/><div class="controls bullet"><span class="by">hackit2</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581197">parent</a><span>|</span><a href="#40582346">prev</a><span>|</span><a href="#40581244">next</a><span>|</span><label class="collapse" for="c-40582012">[-]</label><label class="expand" for="c-40582012">[1 more]</label></div><br/><div class="children"><div class="content">A entity can exist over more than one row in your database, but it is useful to uniquely identify each row as the lowest common denominator.</div><br/></div></div><div id="40581244" class="c"><input type="checkbox" id="c-40581244" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581197">parent</a><span>|</span><a href="#40582012">prev</a><span>|</span><a href="#40581512">next</a><span>|</span><label class="collapse" for="c-40581244">[-]</label><label class="expand" for="c-40581244">[9 more]</label></div><br/><div class="children"><div class="content">The main thing is that the synthetic key should never leave the database and never be displayed in the app - if you want to have another key that represents the human oriented key do it, but it should be another field, an indexed field even, but one that has a lot less monotonic sequential properties that are inherent to synthetic database identifiers.<p>You want to change that human key? Sure. 
You want to to complain that the keys are not sequential? Sure. 
You want to actually make them weird strings that are harmful to my brain? Why not? 
You want to update primary keys in the database? No. Absolutely not.</div><br/><div id="40581555" class="c"><input type="checkbox" id="c-40581555" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581244">parent</a><span>|</span><a href="#40581512">next</a><span>|</span><label class="collapse" for="c-40581555">[-]</label><label class="expand" for="c-40581555">[8 more]</label></div><br/><div class="children"><div class="content">I assume you hint at the security aspect of monotonic keys?<p>I&#x27;ve found this issue a bit overblown. It&#x27;s basically security by obscurity, which is a nice bonus, but not something your security model can be based on.<p>I mean, it is a good practice to expose some kind of non-sequential key (e.g. UUIDv7), but it doesn&#x27;t seem to me like a dealbreaker.</div><br/><div id="40581905" class="c"><input type="checkbox" id="c-40581905" checked=""/><div class="controls bullet"><span class="by">throwaway8486k</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581555">parent</a><span>|</span><a href="#40582199">next</a><span>|</span><label class="collapse" for="c-40581905">[-]</label><label class="expand" for="c-40581905">[3 more]</label></div><br/><div class="children"><div class="content">Security by obscurity makes it more difficult for bad actors as an additional layer that they need to break. I don&#x27;t see a reason why that&#x27;s a bad thing and doesn&#x27;t take a lot of effort to implement in this case.<p>I have been in a startup where competitors used our sequential keys to scrape a list of customers. Lesson learned the hard way with actual business consequences!<p>Sequential keys also leak information (German tank problem)<p>Your competitors can estimate number of customers, your growth rate and other stats that you often don&#x27;t want them  to know.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;German_tank_problem" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;German_tank_problem</a></div><br/><div id="40582036" class="c"><input type="checkbox" id="c-40582036" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581905">parent</a><span>|</span><a href="#40582199">next</a><span>|</span><label class="collapse" for="c-40582036">[-]</label><label class="expand" for="c-40582036">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying it&#x27;s a bad practice, the opposite actually.<p>&gt; I don&#x27;t see a reason why that&#x27;s a bad thing and doesn&#x27;t take a lot of effort to implement in this case.<p>True, if you start your application from scratch. Like if I started designing a new app today, I&#x27;d just choose the UUIDv7 for the primary key.<p>It&#x27;s not an easy thing to add into an existing application, though. I see applications leaking their internal IDs all the time, but usually it&#x27;s not worth the effort to fix that, because it&#x27;s a comparatively minor problem.</div><br/><div id="40582326" class="c"><input type="checkbox" id="c-40582326" checked=""/><div class="controls bullet"><span class="by">throwaway8486k</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582036">parent</a><span>|</span><a href="#40582199">next</a><span>|</span><label class="collapse" for="c-40582326">[-]</label><label class="expand" for="c-40582326">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not saying it&#x27;s a bad practice, the opposite actually<p>I&#x27;m sorry that I didn&#x27;t make that more clear. I saw that you mentioned it as a best practice and are aware of the advantages. It&#x27;s just that there are so many others that don&#x27;t have the balanced view as you seem to have.<p>I have been involved in many discussions at my work place where &quot;security by obscurity&quot; is used as a way to shut down discussions. They changed their minds about sequential keys after the incident I mentioned, but it still has the power to &quot;win&quot; other discussions. Sure, we need to have rate limiting on ip-addresses, auth and other mechanisms, but they are not perfect and bugs happen all the time. An &quot;unguessable&quot; id is an additional security layer<p>&gt; It&#x27;s not an easy thing to add into an existing application, though<p>I agree, but there are ways to reduce the attack surface. You could add an extra &quot;public id&quot; field that can be used for lookup in addition to the existing id. In this way you can have a gradual migration where you go through each endpoint and migrate them individually without changing the foreign keys and other relations in the database (they would still use the sequential key). Maybe you end up not having time to migrate them all, but at least you can reduce the attack surface on the most sensitive endpoints.<p>If you have low volume endpoints you could perhaps even simply add a mapping layer where you do a simple db lookup to replace the public key with the internal without changing the existing queries. You could even cache this easily to reduce the db load. (both ids are permanently fixed and can be cached forever).</div><br/></div></div></div></div></div></div><div id="40582199" class="c"><input type="checkbox" id="c-40582199" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581555">parent</a><span>|</span><a href="#40581905">prev</a><span>|</span><a href="#40582053">next</a><span>|</span><label class="collapse" for="c-40582199">[-]</label><label class="expand" for="c-40582199">[2 more]</label></div><br/><div class="children"><div class="content">UUIDv7 may not be generated sequentially, but it is still temporally ordered and discloses a timestamp, which may be an undesirable leakage for some applications&#x2F;environments. When obfuscation matters that much, use a UUIDv4 and eat the index performance hit.<p>Some might suggest, &quot;encrypt your object identifiers on the way in&#x2F;out&quot;, but there&#x27;s a ton of pitfalls involved since for most applications they are now rolling their own crypto, and it also makes identifiers much longer.</div><br/><div id="40582273" class="c"><input type="checkbox" id="c-40582273" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582199">parent</a><span>|</span><a href="#40582053">next</a><span>|</span><label class="collapse" for="c-40582273">[-]</label><label class="expand" for="c-40582273">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you can go to great depths, but they each have trade-offs - in performance, increased complexity etc. and it&#x27;s necessary to make a judgment for each particular app instead of applying the most overengineered solution everywhere.</div><br/></div></div></div></div><div id="40581896" class="c"><input type="checkbox" id="c-40581896" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581555">parent</a><span>|</span><a href="#40582053">prev</a><span>|</span><a href="#40581512">next</a><span>|</span><label class="collapse" for="c-40581896">[-]</label><label class="expand" for="c-40581896">[1 more]</label></div><br/><div class="children"><div class="content">I love it when my competitors use sequential integer IDs.</div><br/></div></div></div></div></div></div></div></div><div id="40581512" class="c"><input type="checkbox" id="c-40581512" checked=""/><div class="controls bullet"><span class="by">huygens6363</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581197">prev</a><span>|</span><a href="#40581640">next</a><span>|</span><label class="collapse" for="c-40581512">[-]</label><label class="expand" for="c-40581512">[2 more]</label></div><br/><div class="children"><div class="content">There is a model of a thing and there is a row that stores a representation of that model of a thing.<p>They both are things. Ignoring the last one might be tempting, but it’s not practical.<p>Interestingly your own way of thought is applied, but now a level deeper again.<p>How do you model a row? What makes it unique? A surrogate ID is the only sensible unique identifier for such a thing as there is no “natural key” that would make sense for instances of something so general as “Row”.<p>What you were saying amounts to “don’t model the thing holding the model”, but experience shows the thing holding the model is itself an (often unwilling) active part of systems.<p>Someone here gave the example of wrongly entered PK’s by administrative personnel handing live customers. That’s IMO a good example of why you need an extra layer on top of your Actual Model(c). I can think of more.</div><br/><div id="40581900" class="c"><input type="checkbox" id="c-40581900" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581512">parent</a><span>|</span><a href="#40581640">next</a><span>|</span><label class="collapse" for="c-40581900">[-]</label><label class="expand" for="c-40581900">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They both are things.<p>Corollary: your app is part of the real world.</div><br/></div></div></div></div><div id="40581640" class="c"><input type="checkbox" id="c-40581640" checked=""/><div class="controls bullet"><span class="by">CrimsonRain</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581512">prev</a><span>|</span><a href="#40581755">next</a><span>|</span><label class="collapse" for="c-40581640">[-]</label><label class="expand" for="c-40581640">[4 more]</label></div><br/><div class="children"><div class="content">Sorry. This is a very bad advice.
 I just had to fight tooth and nail to make my lead turn around from this disastrous decision.
Using a lot of external IDs as our own row primary keys and then they get propagated to all other tables as foreign keys and what not.
One day the foreign key chances or God forbid, the formatting changes in external systems, now we need to fix our whole database and all codes instead of a small isolated place.<p>Generate your own unique keys for everything; add a few more unique constraints if needed. A bit more work but never a regret.</div><br/><div id="40581851" class="c"><input type="checkbox" id="c-40581851" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581640">parent</a><span>|</span><a href="#40581755">next</a><span>|</span><label class="collapse" for="c-40581851">[-]</label><label class="expand" for="c-40581851">[3 more]</label></div><br/><div class="children"><div class="content">Yeesh. I once made the mistake of using an external ID as a primary key. What a day it was when they were changed on me.</div><br/><div id="40582066" class="c"><input type="checkbox" id="c-40582066" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581851">parent</a><span>|</span><a href="#40581755">next</a><span>|</span><label class="collapse" for="c-40582066">[-]</label><label class="expand" for="c-40582066">[2 more]</label></div><br/><div class="children"><div class="content">Can you share more about this? Wouldn&#x27;t you run into the same problems if you used a surrogate pk? Without the nat&#x2F;external pk and fk, you run the risk of having validity issues.<p>Conversely, if the ID changes, isn&#x27;t the friction what you want?<p>I feel like optimising for unlikely edge cases instead of integrity because of a single incident is too reactionary.<p>Writing a query or script to update a string, even for millions of rows, isn&#x27;t that big of a deal?<p>Obviously there _are_ cases where nat pks&#x2F;fks are bad, but not all of them.</div><br/><div id="40582267" class="c"><input type="checkbox" id="c-40582267" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582066">parent</a><span>|</span><a href="#40581755">next</a><span>|</span><label class="collapse" for="c-40582267">[-]</label><label class="expand" for="c-40582267">[1 more]</label></div><br/><div class="children"><div class="content">Instead of migrating one column, now you have that and every table with a foreign key to the original.  Requiring transactions and possibly locking etc.</div><br/></div></div></div></div></div></div></div></div><div id="40581755" class="c"><input type="checkbox" id="c-40581755" checked=""/><div class="controls bullet"><span class="by">SPBS</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581640">prev</a><span>|</span><a href="#40582321">next</a><span>|</span><label class="collapse" for="c-40581755">[-]</label><label class="expand" for="c-40581755">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You think your surrogate key will save you? It will not. The world has an external reality that needs to be reflected in your database.<p>Yes, it will. It is precisely because of a messy external reality that you need an  unchanging internal ID that is unaffected by changes to the external ID. If the software designer in the article had followed your advice, changing the chassis number would have likely resulted in broken car ownership records.<p>Whoever is reading this in the future, please don&#x27;t follow the parent comment&#x27;s advice. Use surrogate&#x2F;synthetic keys for your primary key.</div><br/></div></div><div id="40582321" class="c"><input type="checkbox" id="c-40582321" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581755">prev</a><span>|</span><a href="#40581815">next</a><span>|</span><label class="collapse" for="c-40582321">[-]</label><label class="expand" for="c-40582321">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, this won&#x27;t end well.  Some examples:<p>Belgium has the RNR&#x2F;INSZ identifying each person.  But it can change for a lot of reasons:  It gets reused if someone dies.  It encodes birth date, sex, asylum state, so if something changes (which happens about every day), you need to adapt your unique key.<p>Belgium also has a number identifying medical organizations.  Until they ran out of numbers.  Then someone decided to change the checksum algorithm, so the same number with a different checksum meant a different organizations.  And of course they encode things in the number and reuse them, so the number isn&#x27;t stable.<p>An internal COBOL system had a number as unique key, and this being COBOL, they also ran out of numbers.  This being COBOL, it was more easy to put characters in the fixed width record than expand it.  And this being French COBOL, that character can have accents.  So everyone using the &#x27;number&#x27; as unique key now had to change their datatype to text and add unicode normalization.  Not fun.<p>In my experience: don&#x27;t use anything as an ID that you didn&#x27;t generate yourself.     Make it an integer or UUID.  Do not put any meaning in the ID.  Then add a table (internal ID, registering entity, start date, end date or null, their key as text).   You &#x27;ll still sometimes have duplicates and external ID updates as the real world is messy, but at least you have a chance to fix them.  The overhead of that 1 lookup is negligable on any scale.</div><br/></div></div><div id="40581815" class="c"><input type="checkbox" id="c-40581815" checked=""/><div class="controls bullet"><span class="by">aswerty</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40582321">prev</a><span>|</span><a href="#40581193">next</a><span>|</span><label class="collapse" for="c-40581815">[-]</label><label class="expand" for="c-40581815">[3 more]</label></div><br/><div class="children"><div class="content">Surrogate keys do mirror reality though. As I once read in a Terry Pratchett book; if you replace the handle of an axe and then replace the head, is it still the same axe?<p>For me, the answer is yes - since we imbue the axe with an identity outside of it&#x27;s integral parts.<p>That is what a surrogate key is. An identity. Which is an abstract concept that exists in the real world.<p>And to pile on. The top comment is bad advice! Surrogate keys provide sanity - god save you if you have to work in a database solely using natural keys.</div><br/><div id="40582799" class="c"><input type="checkbox" id="c-40582799" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581815">parent</a><span>|</span><a href="#40581877">next</a><span>|</span><label class="collapse" for="c-40582799">[-]</label><label class="expand" for="c-40582799">[1 more]</label></div><br/><div class="children"><div class="content">&gt;As I once read in a Terry Pratchett book; if you replace the handle of an axe and then replace the head, is it still the same axe?<p>Yes and no. It is the Axe of Theseus ;)<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Ship_of_Theseus" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Ship_of_Theseus</a></div><br/></div></div><div id="40581877" class="c"><input type="checkbox" id="c-40581877" checked=""/><div class="controls bullet"><span class="by">vintermann</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581815">parent</a><span>|</span><a href="#40582799">prev</a><span>|</span><a href="#40581193">next</a><span>|</span><label class="collapse" for="c-40581877">[-]</label><label class="expand" for="c-40581877">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Ultimately, &quot;are these the same&quot; and &quot;are these different&quot; are philosophical questions. Or to be more precise, <i>teleological</i> questions.<p>Because those questions have no meaning except with an &quot;for our purposes here&quot; added. And it&#x27;s up to us to decide what we care about, if anything.<p>If we care about what other people want with the data though, or suspect that our own wants might not be set in stone, then we should also care to model identity independently in the system (that is, use surrogate keys).</div><br/></div></div></div></div><div id="40581193" class="c"><input type="checkbox" id="c-40581193" checked=""/><div class="controls bullet"><span class="by">kayodelycaon</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581815">prev</a><span>|</span><a href="#40582581">next</a><span>|</span><label class="collapse" for="c-40581193">[-]</label><label class="expand" for="c-40581193">[1 more]</label></div><br/><div class="children"><div class="content">Of course they won’t save you from external data. The whole point is for your system to have a way to identify rows internally so you can deal with external systems getting wonky without corrupting your own data.<p>All of your concerns are easily solved by a unique index.<p>Using external keys as a forcing function to prevent people from representing data wrong is not great.</div><br/></div></div><div id="40582581" class="c"><input type="checkbox" id="c-40582581" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581193">prev</a><span>|</span><a href="#40581208">next</a><span>|</span><label class="collapse" for="c-40582581">[-]</label><label class="expand" for="c-40582581">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Model your data on the real world. Do not depend on spherical horses.<p>Yes, and normalize it. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Database_normalization" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Database_normalization</a><p>&gt; Adding a synthetic key only means you have to track all three. Plus you have to generate a meaningless number, which is actually a choke point in your data throughput.<p>This is true up to a point. You can add more data to the system to continue to generate natural, composite keys. However at some point you move from a database to an event stream, or you have to track events that aren&#x27;t really needed for what your doing...<p>Denormalization then takes precedence and a generated key makes sense again. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Denormalization" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Denormalization</a><p>&gt; how will the surrogate key protect you?<p>It isnt about protection, it&#x27;s about not collecting the natural data to identify the event that caused the issue. Its denormalization by omission in effect.</div><br/></div></div><div id="40581208" class="c"><input type="checkbox" id="c-40581208" checked=""/><div class="controls bullet"><span class="by">polemic</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40582581">prev</a><span>|</span><a href="#40581870">next</a><span>|</span><label class="collapse" for="c-40581208">[-]</label><label class="expand" for="c-40581208">[3 more]</label></div><br/><div class="children"><div class="content">In the wise words of Patsy, &quot;it&#x27;s only a model&quot;.<p>The real world is resistent to clean abstractions and abstractions are distressingly subject to change. What made your row unique today is quite likely to become non-unique in the days&#x2F;months&#x2F;years to come.<p>Always use surrogate keys. Your future self will thank you.</div><br/><div id="40581373" class="c"><input type="checkbox" id="c-40581373" checked=""/><div class="controls bullet"><span class="by">hehdhdjehehegwv</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581208">parent</a><span>|</span><a href="#40581870">next</a><span>|</span><label class="collapse" for="c-40581373">[-]</label><label class="expand" for="c-40581373">[2 more]</label></div><br/><div class="children"><div class="content">And always kids, write code for one person, and one person only: your future self.</div><br/><div id="40582189" class="c"><input type="checkbox" id="c-40582189" checked=""/><div class="controls bullet"><span class="by">M95D</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581373">parent</a><span>|</span><a href="#40581870">next</a><span>|</span><label class="collapse" for="c-40582189">[-]</label><label class="expand" for="c-40582189">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, fsck your co-workers and your replacement when you quit.</div><br/></div></div></div></div></div></div><div id="40581870" class="c"><input type="checkbox" id="c-40581870" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581208">prev</a><span>|</span><a href="#40581263">next</a><span>|</span><label class="collapse" for="c-40581870">[-]</label><label class="expand" for="c-40581870">[1 more]</label></div><br/><div class="children"><div class="content">Adding to the list of comments damning this post to ensure none of my future colleagues follow this advice.<p>&gt; You think your surrogate key will save you? It will not.<p>It definitely will, say my 20+ years of experience.</div><br/></div></div><div id="40581263" class="c"><input type="checkbox" id="c-40581263" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581870">prev</a><span>|</span><a href="#40582159">next</a><span>|</span><label class="collapse" for="c-40581263">[-]</label><label class="expand" for="c-40581263">[1 more]</label></div><br/><div class="children"><div class="content">In that case, using this natural datum as an ID is a contradiction, because we are now removing the uniqueness constraint. It&#x27;s fine to model the real world, but the real world also includes your data, and you may want to identify unique _records_ as it is not a universal truth that data can be corrected on entry.</div><br/></div></div><div id="40582159" class="c"><input type="checkbox" id="c-40582159" checked=""/><div class="controls bullet"><span class="by">th3byrdm4n</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581263">prev</a><span>|</span><a href="#40582157">next</a><span>|</span><label class="collapse" for="c-40582159">[-]</label><label class="expand" for="c-40582159">[1 more]</label></div><br/><div class="children"><div class="content">When I integrate systems, I use that system&#x27;s natural key (love it when it&#x27;s a unique ID, but in the systems I work in - it almost never is).<p>That said, I use that natural key as the &quot;link&quot; to my internally managed, normalized database.<p>There&#x27;s nothing that says I cannot add unique identifiers that would replicate the natural key.  In fact, that&#x27;s good design.</div><br/></div></div><div id="40582157" class="c"><input type="checkbox" id="c-40582157" checked=""/><div class="controls bullet"><span class="by">RedShift1</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40582159">prev</a><span>|</span><a href="#40581656">next</a><span>|</span><label class="collapse" for="c-40582157">[-]</label><label class="expand" for="c-40582157">[1 more]</label></div><br/><div class="children"><div class="content">Every time I used a natural key I have to come to regret it.</div><br/></div></div><div id="40581656" class="c"><input type="checkbox" id="c-40581656" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40582157">prev</a><span>|</span><a href="#40581689">next</a><span>|</span><label class="collapse" for="c-40581656">[-]</label><label class="expand" for="c-40581656">[1 more]</label></div><br/><div class="children"><div class="content">In terms of the Danish CPR that is mentioned here, the way we actually solved the challenge in the national architecture strategy was to define your social security number(s) as what we call an address on your person. I’m not sure why it was called an address, but it’s basically a UUID and the information. Maybe it’s because it was first used to store addresses?<p>Anyway. Unless your system has not yet implemented the national strategies (which by now are approaching 24 years) then changing a Danish Social Security won’t actually matter because it’s just an added address to your person “object”. So basically you’ll now simply have two, and only which is marked as the active. Similar to how you’ve got an array of addresses in which you have lived but only one main address active.<p>It did indeed cause a lot of issues historically because it was used as a natural key… though with it being based on dates, it was never really a good candidate for a key since you couldn’t exactly make it into a number unless you had some way to deal with all the ones beginning with 0 being shorter than the rest. Anyway… it was used as a key, and it was stupid.<p>Anyway I both agree and disagree with you. Because we’ve successfully modelled the real world with virtual keys, but you access it by giving any number of natural keys. Like… you can find the digital “me” by giving a system my CPR number, but you can also find me by giving a system my current address. Technically you could find me by giving a name, but good luck if you’re dealing with a common name. There is a whole range of natural keys you can use to identify a “digital” person, but all of it leads from a natural key into a web of connected virtual keys.<p>All of it is behind some serious gatekeeping security if you’re worried. Or at least it’s supposed to be.</div><br/></div></div><div id="40581689" class="c"><input type="checkbox" id="c-40581689" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581656">prev</a><span>|</span><a href="#40582099">next</a><span>|</span><label class="collapse" for="c-40581689">[-]</label><label class="expand" for="c-40581689">[4 more]</label></div><br/><div class="children"><div class="content">Terrible advice.<p>Surrogate keys are keys are a layer of indirection.<p>They don&#x27;t fix all problems, but they fix some problems.<p>Not least of which is performance. Often natural keys are character strings, whereas surrogate keys can be fixed size integers, saving index sizes on your FKs.</div><br/><div id="40581868" class="c"><input type="checkbox" id="c-40581868" checked=""/><div class="controls bullet"><span class="by">mypalmike</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581689">parent</a><span>|</span><a href="#40582292">next</a><span>|</span><label class="collapse" for="c-40581868">[-]</label><label class="expand" for="c-40581868">[2 more]</label></div><br/><div class="children"><div class="content">Conversely, certain queries can be much faster by using natural keys when the FK is all that you need in the result rather than additional fields in the primary table. In this case, the primary table doesn&#x27;t need to be queried at all. This doesn&#x27;t generally overcome the benefits of synthetic keys, but it is an optimization sometimes put into practice.</div><br/><div id="40581912" class="c"><input type="checkbox" id="c-40581912" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581868">parent</a><span>|</span><a href="#40582292">next</a><span>|</span><label class="collapse" for="c-40581912">[-]</label><label class="expand" for="c-40581912">[1 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t you literally describing an index?</div><br/></div></div></div></div><div id="40582292" class="c"><input type="checkbox" id="c-40582292" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40581689">parent</a><span>|</span><a href="#40581868">prev</a><span>|</span><a href="#40582099">next</a><span>|</span><label class="collapse" for="c-40582292">[-]</label><label class="expand" for="c-40582292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; surrogate keys can be fixed size integers<p>This launches into the <i>other</i> debate about PKs: using UUIDs rather than sequential keys.</div><br/></div></div></div></div><div id="40582099" class="c"><input type="checkbox" id="c-40582099" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40581689">prev</a><span>|</span><a href="#40581634">next</a><span>|</span><label class="collapse" for="c-40582099">[-]</label><label class="expand" for="c-40582099">[2 more]</label></div><br/><div class="children"><div class="content">How do you deal with the Ship of Theseus&#x2F;Trigger&#x27;s broom? There&#x27;s literally nothing that defines said object apart from its <i>history</i>.</div><br/><div id="40582391" class="c"><input type="checkbox" id="c-40582391" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#40581065">root</a><span>|</span><a href="#40582099">parent</a><span>|</span><a href="#40581634">next</a><span>|</span><label class="collapse" for="c-40582391">[-]</label><label class="expand" for="c-40582391">[1 more]</label></div><br/><div class="children"><div class="content">Your database starts to look like git...<p>Think about a jet engine. Let&#x27;s say you figure out that a part is defective and will cause a failure. You want to identify every plane that has one of those parts in it. What if you find that some of them had a bad oil pump that shortened the life of some bearings. You want to know every engine that had one of those pumps, so you can replace other parts.<p>I dont know if they do this with jets but there are quite a few places that take thee concept much further than this.</div><br/></div></div></div></div><div id="40581634" class="c"><input type="checkbox" id="c-40581634" checked=""/><div class="controls bullet"><span class="by">jtriangle</span><span>|</span><a href="#40581065">parent</a><span>|</span><a href="#40582099">prev</a><span>|</span><a href="#40581092">next</a><span>|</span><label class="collapse" for="c-40581634">[-]</label><label class="expand" for="c-40581634">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Model your data on the real world. Do not depend on spherical horses.<p>This took me years to realize, and once I did things became much, much simpler.</div><br/></div></div></div></div><div id="40581092" class="c"><input type="checkbox" id="c-40581092" checked=""/><div class="controls bullet"><span class="by">Kon-Peki</span><span>|</span><a href="#40581065">prev</a><span>|</span><a href="#40582602">next</a><span>|</span><label class="collapse" for="c-40581092">[-]</label><label class="expand" for="c-40581092">[10 more]</label></div><br/><div class="children"><div class="content">&gt; how about a personal identification number? In Denmark we have the CPR number, and I understand that the US Social Security Number is vaguely analogous.<p>The US SSN is not guaranteed to be unique, the SSN assigned to a person could change, there is no guarantee that a person with an SSN assigned to them is a US citizen, and there is no guarantee that a US citizen has an SSN - they must be requested, and you don’t need one unless you do something that requires having one.  There are also things called ITINs and ATINs that look like an SSN but are not, yet can be used in place of an SSN in a huge range of SSN-required situations!<p>(Please don’t use the SSN as a database key!)</div><br/><div id="40581753" class="c"><input type="checkbox" id="c-40581753" checked=""/><div class="controls bullet"><span class="by">otherme123</span><span>|</span><a href="#40581092">parent</a><span>|</span><a href="#40582061">next</a><span>|</span><label class="collapse" for="c-40581753">[-]</label><label class="expand" for="c-40581753">[2 more]</label></div><br/><div class="children"><div class="content">In Spain we have the DNI number, that a lot of people asume is unique, even database designers that use is as a natural key.<p>Turns out the DNI can have, and actually have, a lot of duplicates. The police has a page explaining it (<a href="https:&#x2F;&#x2F;citapreviadnipasaporte.es&#x2F;dni&#x2F;dni-duplicados-espana&#x2F;" rel="nofollow">https:&#x2F;&#x2F;citapreviadnipasaporte.es&#x2F;dni&#x2F;dni-duplicados-espana&#x2F;</a>), and how it&#x27;s not a primary key in their databases, but a number entered manually from a pool of possible numbers. And number re-using is a possibility. They estimate the number of duplicates in 200,000 for a population of 50,000,000.<p>The point is that if you asume DNIs are unique and use them as PK your database is exposed to the bad design of the DNI database. There are some stores that use the DNI as the &quot;unique&quot; identifier for fidelity cards.</div><br/><div id="40582704" class="c"><input type="checkbox" id="c-40582704" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#40581092">root</a><span>|</span><a href="#40581753">parent</a><span>|</span><a href="#40582061">next</a><span>|</span><label class="collapse" for="c-40582704">[-]</label><label class="expand" for="c-40582704">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen banks or insurers use DNI as user login.</div><br/></div></div></div></div><div id="40582061" class="c"><input type="checkbox" id="c-40582061" checked=""/><div class="controls bullet"><span class="by">delusional</span><span>|</span><a href="#40581092">parent</a><span>|</span><a href="#40581753">prev</a><span>|</span><a href="#40581301">next</a><span>|</span><label class="collapse" for="c-40582061">[-]</label><label class="expand" for="c-40582061">[2 more]</label></div><br/><div class="children"><div class="content">We have the same problem in Denmark, most people just don&#x27;t realize it. At my dayjob we get at least one person every year who changes gender and consequently gets a new SSN (the final digit is supposed to signify gender). Most people don&#x27;t store SSNs so they never realize, but it does happen fairly frequently.</div><br/><div id="40582420" class="c"><input type="checkbox" id="c-40582420" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#40581092">root</a><span>|</span><a href="#40582061">parent</a><span>|</span><a href="#40581301">next</a><span>|</span><label class="collapse" for="c-40582420">[-]</label><label class="expand" for="c-40582420">[1 more]</label></div><br/><div class="children"><div class="content">If Denmark is anything like Sweden there&#x27;s also:<p>- SSN from different ID space gets assigned to immigrants; when they become citizens they are assigned a new permanent SSN.<p>- SSN:s have a long and a short form; the short form which cuts off century information can be the same for someone who is 5 years old and someone who is 105 years old.<p>- When an unconscious patient comes in to the E.R. you don&#x27;t know their SSN, so a temporary one is assigned for use in patient records. Such temporary SSN:s are not coordinated nation-wide so multiple patients may have the same SSN. In some hospitals they don&#x27;t even have a local standard for ID:s. The staff just makes something up on the spot. It happens that the SSN they made up collides with a valid SSN for another person.</div><br/></div></div></div></div><div id="40581301" class="c"><input type="checkbox" id="c-40581301" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#40581092">parent</a><span>|</span><a href="#40582061">prev</a><span>|</span><a href="#40582602">next</a><span>|</span><label class="collapse" for="c-40581301">[-]</label><label class="expand" for="c-40581301">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The US SSN is not guaranteed to be unique<p>The cases you listed do <i>not</i> mean SSNs are not unique, unless there are people who share the same SSN. You can still define a unique index for the SSN column. A column can be both nullable and unique as each null is different in SQL.</div><br/><div id="40581355" class="c"><input type="checkbox" id="c-40581355" checked=""/><div class="controls bullet"><span class="by">dqv</span><span>|</span><a href="#40581092">root</a><span>|</span><a href="#40581301">parent</a><span>|</span><a href="#40581314">next</a><span>|</span><label class="collapse" for="c-40581355">[-]</label><label class="expand" for="c-40581355">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It’s not as uncommon as you might think. In fact, some 40 million SSNs are associated with multiple people, according to a 2010 study by ID Analytics.<p><a href="https:&#x2F;&#x2F;www.pcworld.com&#x2F;article&#x2F;424392&#x2F;a-tale-of-two-women-same-birthday-same-social-security-number-same-big-data-mess.html" rel="nofollow">https:&#x2F;&#x2F;www.pcworld.com&#x2F;article&#x2F;424392&#x2F;a-tale-of-two-women-s...</a></div><br/><div id="40581671" class="c"><input type="checkbox" id="c-40581671" checked=""/><div class="controls bullet"><span class="by">pseudosavant</span><span>|</span><a href="#40581092">root</a><span>|</span><a href="#40581355">parent</a><span>|</span><a href="#40581314">next</a><span>|</span><label class="collapse" for="c-40581671">[-]</label><label class="expand" for="c-40581671">[1 more]</label></div><br/><div class="children"><div class="content">Funny enough, I used to work at IDA.<p>I’ll add that there is a huge difference between the SSN database that the Social Security Administration maintains, and the list of SSNs that have been associated with a person. Especially because it is very common to change a single digit of your SSN when performing credit fraud - because they’ve already burned their real one. Some people will have dozens of SSNs attached to them.<p>IDA was very good at determining who a person is through the graphs that represent identities in our world (names, DOBs, phone numbers, addresses, SSNs, etc.)</div><br/></div></div></div></div><div id="40581314" class="c"><input type="checkbox" id="c-40581314" checked=""/><div class="controls bullet"><span class="by">Kon-Peki</span><span>|</span><a href="#40581092">root</a><span>|</span><a href="#40581301">parent</a><span>|</span><a href="#40581355">prev</a><span>|</span><a href="#40581312">next</a><span>|</span><label class="collapse" for="c-40581314">[-]</label><label class="expand" for="c-40581314">[1 more]</label></div><br/><div class="children"><div class="content">EDIT - SSA claims that numbers are not recycled.  But there are known cases where the same number has been assigned to multiple people.<p>Note that in less than 100 years, more than half of all possible SSNs have already been used…</div><br/></div></div><div id="40581312" class="c"><input type="checkbox" id="c-40581312" checked=""/><div class="controls bullet"><span class="by">ars</span><span>|</span><a href="#40581092">root</a><span>|</span><a href="#40581301">parent</a><span>|</span><a href="#40581314">prev</a><span>|</span><a href="#40582602">next</a><span>|</span><label class="collapse" for="c-40581312">[-]</label><label class="expand" for="c-40581312">[1 more]</label></div><br/><div class="children"><div class="content">&gt; unless there are people who share the same SSN<p>That happens all the time. First of all people steal SSN&#x27;s and use them (and you are not the police, so it&#x27;s not your responsibility to do anything about that). Second people make up fake SSN&#x27;s because they don&#x27;t want to give you their SSN.<p>People also make typo&#x27;s, and you can end up with the same SSN.<p>An SSN is not unique in the real world.</div><br/></div></div></div></div></div></div><div id="40582602" class="c"><input type="checkbox" id="c-40582602" checked=""/><div class="controls bullet"><span class="by">mootothemax</span><span>|</span><a href="#40581092">prev</a><span>|</span><a href="#40581206">next</a><span>|</span><label class="collapse" for="c-40582602">[-]</label><label class="expand" for="c-40582602">[2 more]</label></div><br/><div class="children"><div class="content">You can get performance benefits from using natural keys, as many databases store rows in the order of a table&#x27;s primary key (sometimes called the <i>clustered</i> index, though it may or may not have a unique constraint requirement depending on the DBMS and a few other bits).<p>In the author&#x27;s example, if the first column in the natural index was the city name (or city ID!), and locations are often pulled from the database by city, you&#x27;ll see a read time performance benefit because each cityName&#x27;s restaurants will be stored together.<p>This is why UUID-based systems can suffer worse read + write performance; their rows will be stored in the order of its UUIDs (that is, randomly spread around), making read, insert, and update performance lower.<p>What to do? I favour a mixed approach: have a unique integer ID column used internally, expose a unique UUID to the public where necessary and - with a BIG DO NOT OPTIMIZE PREMATURELY warning - really think about how the data is going to be queried, updated, and inserted. Ask - does it makes sense to create a clustered index based on the table data? Is there enough data to make it worthwhile? Where can the index fail if changes need to be made? Under some circumstances, it might even make sense to use a natural key with the integer column included right at the end!<p>The only hard rule I have is using UUIDs for clustered indexes. Unless the tables are teeny-tiny, the system is most likely suffering without anyone being aware of it.</div><br/><div id="40582695" class="c"><input type="checkbox" id="c-40582695" checked=""/><div class="controls bullet"><span class="by">williamdclt</span><span>|</span><a href="#40582602">parent</a><span>|</span><a href="#40581206">next</a><span>|</span><label class="collapse" for="c-40582695">[-]</label><label class="expand" for="c-40582695">[1 more]</label></div><br/><div class="children"><div class="content">&gt; many databases store rows in the order of a table&#x27;s primary key (sometimes called the clustered index [...])<p>Note for readers: Postgres doesn&#x27;t do that</div><br/></div></div></div></div><div id="40581206" class="c"><input type="checkbox" id="c-40581206" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#40582602">prev</a><span>|</span><a href="#40580921">next</a><span>|</span><label class="collapse" for="c-40581206">[-]</label><label class="expand" for="c-40581206">[3 more]</label></div><br/><div class="children"><div class="content">Another massive annoyance with natural keys - privacy. If your table&#x27;s primary key contains personal information, that PII now infects every other table that holds a foreign key to that table.</div><br/><div id="40582640" class="c"><input type="checkbox" id="c-40582640" checked=""/><div class="controls bullet"><span class="by">whyever</span><span>|</span><a href="#40581206">parent</a><span>|</span><a href="#40581381">next</a><span>|</span><label class="collapse" for="c-40582640">[-]</label><label class="expand" for="c-40582640">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK, even using a UUID is still considered PII if it uniquely identifies the user.</div><br/></div></div><div id="40581381" class="c"><input type="checkbox" id="c-40581381" checked=""/><div class="controls bullet"><span class="by">hehdhdjehehegwv</span><span>|</span><a href="#40581206">parent</a><span>|</span><a href="#40582640">prev</a><span>|</span><a href="#40580921">next</a><span>|</span><label class="collapse" for="c-40581381">[-]</label><label class="expand" for="c-40581381">[1 more]</label></div><br/><div class="children"><div class="content">Extremely good point.</div><br/></div></div></div></div><div id="40580921" class="c"><input type="checkbox" id="c-40580921" checked=""/><div class="controls bullet"><span class="by">ray_v</span><span>|</span><a href="#40581206">prev</a><span>|</span><a href="#40582791">next</a><span>|</span><label class="collapse" for="c-40580921">[-]</label><label class="expand" for="c-40580921">[10 more]</label></div><br/><div class="children"><div class="content">Feels like this could have used a few more solid examples up-front. I think another good example would be PlayStation Network using the natural key of &quot;gamer tags&quot; as the primary key to identify players would be a good example. Since this effectively locks players into having to keep a gamertag in order to uniquely identify them in the service -- instead of having a synthetic key that carries no meaning or data other than &quot;uniqueness&quot;</div><br/><div id="40581027" class="c"><input type="checkbox" id="c-40581027" checked=""/><div class="controls bullet"><span class="by">mths</span><span>|</span><a href="#40580921">parent</a><span>|</span><a href="#40581750">next</a><span>|</span><label class="collapse" for="c-40581027">[-]</label><label class="expand" for="c-40581027">[4 more]</label></div><br/><div class="children"><div class="content">Last I checked, Steam still has me logging in with my two decade old hotmail address as my account name. At least it&#x27;s not something that shows publicly, I think.</div><br/><div id="40581447" class="c"><input type="checkbox" id="c-40581447" checked=""/><div class="controls bullet"><span class="by">petepete</span><span>|</span><a href="#40580921">root</a><span>|</span><a href="#40581027">parent</a><span>|</span><a href="#40581750">next</a><span>|</span><label class="collapse" for="c-40581447">[-]</label><label class="expand" for="c-40581447">[3 more]</label></div><br/><div class="children"><div class="content">Mine too, but with a British ISP that hasn&#x27;t existed for fifteen years.</div><br/><div id="40581553" class="c"><input type="checkbox" id="c-40581553" checked=""/><div class="controls bullet"><span class="by">t90fan</span><span>|</span><a href="#40580921">root</a><span>|</span><a href="#40581447">parent</a><span>|</span><a href="#40581750">next</a><span>|</span><label class="collapse" for="c-40581553">[-]</label><label class="expand" for="c-40581553">[2 more]</label></div><br/><div class="children"><div class="content">ntl?<p>me too!</div><br/><div id="40582300" class="c"><input type="checkbox" id="c-40582300" checked=""/><div class="controls bullet"><span class="by">petepete</span><span>|</span><a href="#40580921">root</a><span>|</span><a href="#40581553">parent</a><span>|</span><a href="#40581750">next</a><span>|</span><label class="collapse" for="c-40582300">[-]</label><label class="expand" for="c-40582300">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the one! myinitials@ntlworld.com<p>And NTL merged with Virgin in 2006, making it 18 years. Oh dear.</div><br/></div></div></div></div></div></div></div></div><div id="40581750" class="c"><input type="checkbox" id="c-40581750" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40580921">parent</a><span>|</span><a href="#40581027">prev</a><span>|</span><a href="#40582055">next</a><span>|</span><label class="collapse" for="c-40581750">[-]</label><label class="expand" for="c-40581750">[1 more]</label></div><br/><div class="children"><div class="content">This is one of those cases where examples of natural keys failing are so ubiquitous that they are almost redundant.<p>For the group who have forged a career with natural keys, and never regretted it, more power to you. Great.<p>However to the rest of us, myself included, where ill-considered natural keys have caused endless opinions and suffering, my commiserations.<p>If I could send back one piece of advice to junior-me it would be to avoid natural primary keys. (Ideally with the corollary to avoid sequences, but that&#x27;s another thread for another day.)</div><br/></div></div><div id="40582055" class="c"><input type="checkbox" id="c-40582055" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40580921">parent</a><span>|</span><a href="#40581750">prev</a><span>|</span><a href="#40580991">next</a><span>|</span><label class="collapse" for="c-40582055">[-]</label><label class="expand" for="c-40582055">[1 more]</label></div><br/><div class="children"><div class="content">On the other hand, Discord used to allow arbitrary usernames and would add a suffix for when you needed to disambiguate (e.g. if you used the username JohnDoe, your &quot;id&quot; would be something like JohnDoe#12345) but over the past year or so forced everyone to pick a fully unique username. In this case, the decision seemed to potentially be financially motivated, given that people with subscriptions were given priority for claiming usernames, and historically there really hasn&#x27;t been much reason to pay for it in the first place.</div><br/></div></div><div id="40580991" class="c"><input type="checkbox" id="c-40580991" checked=""/><div class="controls bullet"><span class="by">robomc</span><span>|</span><a href="#40580921">parent</a><span>|</span><a href="#40582055">prev</a><span>|</span><a href="#40582791">next</a><span>|</span><label class="collapse" for="c-40580991">[-]</label><label class="expand" for="c-40580991">[3 more]</label></div><br/><div class="children"><div class="content">yeah the way he described it it&#x27;s like... well who would ever do that. but foreign keying to emails or usernames is much easier to &quot;accidentally&quot; do and is a classic source of long-term headaches.</div><br/><div id="40581442" class="c"><input type="checkbox" id="c-40581442" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#40580921">root</a><span>|</span><a href="#40580991">parent</a><span>|</span><a href="#40582791">next</a><span>|</span><label class="collapse" for="c-40581442">[-]</label><label class="expand" for="c-40581442">[2 more]</label></div><br/><div class="children"><div class="content">As a great example: My steam account name is the email I was using in 2003. I have largely not used it since then. The email on the account has been updated, but the account name? Stuck.</div><br/><div id="40582807" class="c"><input type="checkbox" id="c-40582807" checked=""/><div class="controls bullet"><span class="by">jimbobthrowawy</span><span>|</span><a href="#40580921">root</a><span>|</span><a href="#40581442">parent</a><span>|</span><a href="#40582791">next</a><span>|</span><label class="collapse" for="c-40582807">[-]</label><label class="expand" for="c-40582807">[1 more]</label></div><br/><div class="children"><div class="content">I was about to ask how you got past steamguard without email access. Makes sense if you were able to navigate off it.</div><br/></div></div></div></div></div></div></div></div><div id="40582791" class="c"><input type="checkbox" id="c-40582791" checked=""/><div class="controls bullet"><span class="by">zer0tonin</span><span>|</span><a href="#40580921">prev</a><span>|</span><a href="#40581080">next</a><span>|</span><label class="collapse" for="c-40582791">[-]</label><label class="expand" for="c-40582791">[1 more]</label></div><br/><div class="children"><div class="content">Yes, except sometime whole industries come together already has developed a system of unique identifier, and I can just use this as a natural key. For example, the Nasdaq stock exchange is identified perfectly fine by the string &#x27;XNAS&#x27;, I&#x27;m not going to generate an ID on top of it.</div><br/></div></div><div id="40581080" class="c"><input type="checkbox" id="c-40581080" checked=""/><div class="controls bullet"><span class="by">mythas</span><span>|</span><a href="#40582791">prev</a><span>|</span><a href="#40580854">next</a><span>|</span><label class="collapse" for="c-40581080">[-]</label><label class="expand" for="c-40581080">[6 more]</label></div><br/><div class="children"><div class="content">Another example that happens surprisingly often in healthcare. A registration clerk will incorrectly enter a  personal health number (PHN) into the system. Then the actuall holder of that PHN shows up. If this were the PK then the system just wouldn’t handle this case and the reg clerk would have a huge mess to sort out on the spot. A surrogate key on the Person table allows this registration  to be made where 2 people have the same PHN in the system. Then cleanup can be handled after the fact to track down the first person, determine their correct PHN and update the record.</div><br/><div id="40581209" class="c"><input type="checkbox" id="c-40581209" checked=""/><div class="controls bullet"><span class="by">romdev</span><span>|</span><a href="#40581080">parent</a><span>|</span><a href="#40581199">next</a><span>|</span><label class="collapse" for="c-40581209">[-]</label><label class="expand" for="c-40581209">[2 more]</label></div><br/><div class="children"><div class="content">Finding and eliminating duplicates is a very common software problem that is rarely solved in a reusable, user-friendly way that preserves history while eliminating redundant data. 
In fact, in 40 years of working with computers I can&#x27;t think of a single UI that I&#x27;d want to emulate.</div><br/><div id="40582560" class="c"><input type="checkbox" id="c-40582560" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#40581080">root</a><span>|</span><a href="#40581209">parent</a><span>|</span><a href="#40581199">next</a><span>|</span><label class="collapse" for="c-40582560">[-]</label><label class="expand" for="c-40582560">[1 more]</label></div><br/><div class="children"><div class="content">Ultimately the key is the business-modeling that captures &quot;duplicates&quot; as Things That Happen.<p>That&#x27;s the precondition for any sane UI, and sometimes it&#x27;s not even obvious because the &quot;duplication&quot; has been transformed, reified into its own concept.</div><br/></div></div></div></div><div id="40581199" class="c"><input type="checkbox" id="c-40581199" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#40581080">parent</a><span>|</span><a href="#40581209">prev</a><span>|</span><a href="#40581157">next</a><span>|</span><label class="collapse" for="c-40581199">[-]</label><label class="expand" for="c-40581199">[1 more]</label></div><br/><div class="children"><div class="content">One of the most surprising things I learned about the US healthcare system is how often everything is mutating or being retroactively updated (assume it applies to other countries too).<p>Things you&#x27;d think would be constant after Step 1 often aren&#x27;t, and processes are tolerant of their being corrected &#x2F; re-entered after Step 52 has already been completed.</div><br/></div></div><div id="40581157" class="c"><input type="checkbox" id="c-40581157" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#40581080">parent</a><span>|</span><a href="#40581199">prev</a><span>|</span><a href="#40580854">next</a><span>|</span><label class="collapse" for="c-40581157">[-]</label><label class="expand" for="c-40581157">[2 more]</label></div><br/><div class="children"><div class="content">This sounds like it should probably be a workflow instead. Modelling the intent here is actually important.</div><br/><div id="40581187" class="c"><input type="checkbox" id="c-40581187" checked=""/><div class="controls bullet"><span class="by">mythas</span><span>|</span><a href="#40581080">root</a><span>|</span><a href="#40581157">parent</a><span>|</span><a href="#40580854">next</a><span>|</span><label class="collapse" for="c-40581187">[-]</label><label class="expand" for="c-40581187">[1 more]</label></div><br/><div class="children"><div class="content">Care to expand on this thought? Curious what you have  in mind!</div><br/></div></div></div></div></div></div><div id="40580854" class="c"><input type="checkbox" id="c-40580854" checked=""/><div class="controls bullet"><span class="by">duxup</span><span>|</span><a href="#40581080">prev</a><span>|</span><a href="#40581657">next</a><span>|</span><label class="collapse" for="c-40580854">[-]</label><label class="expand" for="c-40580854">[1 more]</label></div><br/><div class="children"><div class="content">I just have some form of unique id field &#x2F; synthetic key, everywhere.<p>Even if just for documenting issues it makes life easier.   “Table whatever id 12345 is the record in question.”<p>I’ve just seen data &#x2F; relationships change too much too often in new and interesting ways to believe in using a natural key.</div><br/></div></div><div id="40581657" class="c"><input type="checkbox" id="c-40581657" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#40580854">prev</a><span>|</span><a href="#40581039">next</a><span>|</span><label class="collapse" for="c-40581657">[-]</label><label class="expand" for="c-40581657">[2 more]</label></div><br/><div class="children"><div class="content">In Spain the ID numbers are assigned at birth, carry no information, and cannot be changed. Each police comissary that registers birth gets a unique set of IDs to assign (per year or whatever).<p>However. Mistakes still happen. A colleague had the same ID as someone else. He said he tried to change it, but it was impossible because it was such an impossible concept to any public servant involved. In the end he gave up and just lived with the fact.</div><br/><div id="40582284" class="c"><input type="checkbox" id="c-40582284" checked=""/><div class="controls bullet"><span class="by">fcatalan</span><span>|</span><a href="#40581657">parent</a><span>|</span><a href="#40581039">next</a><span>|</span><label class="collapse" for="c-40582284">[-]</label><label class="expand" for="c-40582284">[1 more]</label></div><br/><div class="children"><div class="content">Not really assigned at birth, but at the time you first request the card. It&#x27;s a very very very crappy database ID number:<p>-There&#x27;s a significant amount of duplicates, enough that if your database is big enough you will find one sooner or later.<p>-Format is variable: There are older 7 digit numbers, modern 8 digit ones, some people pad the 7-digit with a 0, some don&#x27;t, some consider the CRC letter part of the key, some don&#x27;t, some just append the letter, some hyphen it. If you deal with manual data entry anywhere, you will suffer.<p>-Foreign people exist: You start using their passport number, the format of your key is now completely arbitrary, can&#x27;t validate it. If you were using 8 digit NIFs as keys now some countries use 8 digit passports, increasing your chances of duplicates.<p>-Foreign people stay: They get a resident card and they use that. Format is almost like NIF but not really so you need to account for that. Someone you registered initially with a passport now has the card and registers for something else with it. Have fun cleaning their duplicated identity from the whole system.<p>-Foreign people become Spanish: Now they get a NIF. If you have dealt with them for a long enough time, have fun again fixing their records for the second time.</div><br/></div></div></div></div><div id="40581039" class="c"><input type="checkbox" id="c-40581039" checked=""/><div class="controls bullet"><span class="by">parpfish</span><span>|</span><a href="#40581657">prev</a><span>|</span><a href="#40581508">next</a><span>|</span><label class="collapse" for="c-40581039">[-]</label><label class="expand" for="c-40581039">[4 more]</label></div><br/><div class="children"><div class="content">There another reason not mentioned — if your key is something like a UUID, it’s very easy to define the logic for joining and filtering based on that key.<p>If you were using some sort of string like an email address or username, you have to think about case sensitivity and trimming white space and all sorts of preprocessing and then make sure you do it consistently EVERYWHERE</div><br/><div id="40581130" class="c"><input type="checkbox" id="c-40581130" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#40581039">parent</a><span>|</span><a href="#40581508">next</a><span>|</span><label class="collapse" for="c-40581130">[-]</label><label class="expand" for="c-40581130">[3 more]</label></div><br/><div class="children"><div class="content">Ideally, you should aim to sanitize&#x2F;normalize strings on the write side rather than resanitizing on every read.</div><br/><div id="40581275" class="c"><input type="checkbox" id="c-40581275" checked=""/><div class="controls bullet"><span class="by">parpfish</span><span>|</span><a href="#40581039">root</a><span>|</span><a href="#40581130">parent</a><span>|</span><a href="#40581156">next</a><span>|</span><label class="collapse" for="c-40581275">[-]</label><label class="expand" for="c-40581275">[1 more]</label></div><br/><div class="children"><div class="content">That helps part of it, but there are still places for problems to pop up.<p>- you need to do an adhoc query to look something up so you have to type in the key in a where clause<p>- Or you used different sanitation methods in two different databases and you need to join things now<p>- you try to join the table that had the sanitized email key to a different table that just so happens to have email but it wasn’t sanitized because it was an optional field and not the key</div><br/></div></div><div id="40581156" class="c"><input type="checkbox" id="c-40581156" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#40581039">root</a><span>|</span><a href="#40581130">parent</a><span>|</span><a href="#40581275">prev</a><span>|</span><a href="#40581508">next</a><span>|</span><label class="collapse" for="c-40581156">[-]</label><label class="expand" for="c-40581156">[1 more]</label></div><br/><div class="children"><div class="content">Yes but any kind of bug could later introduce tainted values. A foreign key contstraint might save you, but not always.</div><br/></div></div></div></div></div></div><div id="40581508" class="c"><input type="checkbox" id="c-40581508" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#40581039">prev</a><span>|</span><a href="#40581015">next</a><span>|</span><label class="collapse" for="c-40581508">[-]</label><label class="expand" for="c-40581508">[1 more]</label></div><br/><div class="children"><div class="content">A simpler and more compelling reason in my experience is that relating tables is so much easier with synthetic keys. You can decide how large your synthetic keys are based on uniqueness requirements, natural keys have their own size and format that would then be copied to make relations. And if uniqueness depends on several values to be unique then dealing with compound foreign keys isn&#x27;t fun or efficient. At this point, there would have to be a very compelling reason to want to use natural keys to offset this and I&#x27;ve rarely seen them. A case that may come up is for a miscellaneous table to use the synthetic key from another table with another natural value that uniquely identifies a row. I wouldn&#x27;t choose this route if you ever think you want to relate anything to rows in this table, they should be leaves related only to the synthetic key being used.</div><br/></div></div><div id="40581015" class="c"><input type="checkbox" id="c-40581015" checked=""/><div class="controls bullet"><span class="by">azlev</span><span>|</span><a href="#40581508">prev</a><span>|</span><a href="#40581862">next</a><span>|</span><label class="collapse" for="c-40581015">[-]</label><label class="expand" for="c-40581015">[2 more]</label></div><br/><div class="children"><div class="content">I think somewhat different than the article in some ways.<p>The first example is why `UPDATE CASCADE` was implemented. So it&#x27;s possible to use natural keys as identity without the fear of children table. At least in most databases it works.<p>The drawback of enumeration is real, so if you expose this key you&#x27;ll need some authentication&#x2F; authorization mecanism.<p>Another good thing in natural keys is that you can eliminate part of the joins. You don&#x27;t have to join the father table because the key in child table is known.<p>I think the biggest challenge is how to map logins to people. It&#x27;s very common to interpret both as the same, but they are not.</div><br/><div id="40581254" class="c"><input type="checkbox" id="c-40581254" checked=""/><div class="controls bullet"><span class="by">arthens</span><span>|</span><a href="#40581015">parent</a><span>|</span><a href="#40581862">next</a><span>|</span><label class="collapse" for="c-40581254">[-]</label><label class="expand" for="c-40581254">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The first example is why `UPDATE CASCADE` was implemented. So it&#x27;s possible to use natural keys as identity without the fear of children table. At least in most databases it works.<p>This is only true in a system using a single database, not replicating data in external services, and not offering APIs.<p>And while it might work today when the service&#x2F;website is still fairly small and self contained, the requirements might change at any time. So the title (You will [future] regret it) still applies to this solution</div><br/></div></div></div></div><div id="40581862" class="c"><input type="checkbox" id="c-40581862" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#40581015">prev</a><span>|</span><a href="#40580924">next</a><span>|</span><label class="collapse" for="c-40581862">[-]</label><label class="expand" for="c-40581862">[1 more]</label></div><br/><div class="children"><div class="content">As a junior dev decades ago I was once asked to change a perfectly good database (with integer IDs) to use natural keys, so to look up (or SQL join to) a particular office for instance your query would filter on Country, City and Street with the expectation that you get one result.<p>This was the dumbest technical decision I have ever been asked to be a part of.</div><br/></div></div><div id="40580924" class="c"><input type="checkbox" id="c-40580924" checked=""/><div class="controls bullet"><span class="by">davidhyde</span><span>|</span><a href="#40581862">prev</a><span>|</span><a href="#40581628">next</a><span>|</span><label class="collapse" for="c-40580924">[-]</label><label class="expand" for="c-40580924">[8 more]</label></div><br/><div class="children"><div class="content">A natural key is what I would normally call unique index. Say first, surname and date of birth in an employee table as a bad (poor design) example. As opposed to a surrogate key like personId being an auto incrementing ID which is the norm since it can be easier to use when joining tables. I wish articles like these would explain terminology up front. I found it irritating to wade into the anecdotal trivia and not know what I was reading about and I’m very familiar with how databases work!</div><br/><div id="40580976" class="c"><input type="checkbox" id="c-40580976" checked=""/><div class="controls bullet"><span class="by">bongodongobob</span><span>|</span><a href="#40580924">parent</a><span>|</span><a href="#40581628">next</a><span>|</span><label class="collapse" for="c-40580976">[-]</label><label class="expand" for="c-40580976">[7 more]</label></div><br/><div class="children"><div class="content">One reason to not do that is because you could then figure out other users IDs by their hiring date. This ended up being a problem for me once with the auxiliary systems that relied on that ID, namely when it was used in links in other applications.</div><br/><div id="40581230" class="c"><input type="checkbox" id="c-40581230" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#40580924">root</a><span>|</span><a href="#40580976">parent</a><span>|</span><a href="#40581224">next</a><span>|</span><label class="collapse" for="c-40581230">[-]</label><label class="expand" for="c-40581230">[4 more]</label></div><br/><div class="children"><div class="content">Why is knowing someone&#x27;s ID an issue?<p>They are meant for identification, if anything it should be a benefit that they are easily guessable.</div><br/><div id="40581350" class="c"><input type="checkbox" id="c-40581350" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#40580924">root</a><span>|</span><a href="#40581230">parent</a><span>|</span><a href="#40581224">next</a><span>|</span><label class="collapse" for="c-40581350">[-]</label><label class="expand" for="c-40581350">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Why is knowing someone&#x27;s ID an issue?<p>It increases the attack surface as an authorization vulnerability will allow an attacker to enumerate and access all records. Yes, it is security through obscurity, but a random (e.g. UUID) scheme makes it harder.</div><br/><div id="40581617" class="c"><input type="checkbox" id="c-40581617" checked=""/><div class="controls bullet"><span class="by">kubanczyk</span><span>|</span><a href="#40580924">root</a><span>|</span><a href="#40581350">parent</a><span>|</span><a href="#40581679">next</a><span>|</span><label class="collapse" for="c-40581617">[-]</label><label class="expand" for="c-40581617">[1 more]</label></div><br/><div class="children"><div class="content">~128 bits worth of obscurity is considered real security for the time being. Assuming a cryptographically secure PRNG.<p>Thats like guessing a password 18 ASCII chars long.</div><br/></div></div><div id="40581679" class="c"><input type="checkbox" id="c-40581679" checked=""/><div class="controls bullet"><span class="by">bongodongobob</span><span>|</span><a href="#40580924">root</a><span>|</span><a href="#40581350">parent</a><span>|</span><a href="#40581617">prev</a><span>|</span><a href="#40581224">next</a><span>|</span><label class="collapse" for="c-40581679">[-]</label><label class="expand" for="c-40581679">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, it&#x27;s not that <i>my</i> systems use security through obscurity, it&#x27;s the other ones mine ties into.<p>This was years ago and you don&#x27;t see it as much anymore, but think autogenerated links to shitty CRM, ticketing, and project management software where the link is the query aka - Blahsoftware.local&#x2F;info&#x2F;bunchofgarbage?=userid+garbage+view+sensitiveinfo.html type stuff.</div><br/></div></div></div></div></div></div><div id="40581224" class="c"><input type="checkbox" id="c-40581224" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40580924">root</a><span>|</span><a href="#40580976">parent</a><span>|</span><a href="#40581230">prev</a><span>|</span><a href="#40581024">next</a><span>|</span><label class="collapse" for="c-40581224">[-]</label><label class="expand" for="c-40581224">[1 more]</label></div><br/><div class="children"><div class="content">Another reason is sharding, in which case any non-random (to be more precise, non-uniformly distributed) bits are going to skew the partitions.</div><br/></div></div></div></div></div></div><div id="40581628" class="c"><input type="checkbox" id="c-40581628" checked=""/><div class="controls bullet"><span class="by">MikePlacid</span><span>|</span><a href="#40580924">prev</a><span>|</span><a href="#40582657">next</a><span>|</span><label class="collapse" for="c-40581628">[-]</label><label class="expand" for="c-40581628">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I already predicted that changing the number would prove to be either impossible, or have all sorts of cascading effects, ultimately terminating in official records no longer recognizing that the car is mine.<p>Oh my, I can feel that pain. Here’s what happened last week, caused by a change in… SSN? no - in our home address.<p>My wife earned some unemployment benefits three years ago, which were put on a plastic card issued by The Bank. She finally found time to access the funds (she’s a middle school teacher), but when she went to The Bank, they said they didn’t have the money anymore—they’d sent it back to California. So, she called California. They were like, “No problem, we’ll send you a check. Oh, you have a new address? Let’s change it. Wait, what is happening… oh, now your account is locked, it says: potential fraud”… They needed a supervisor to unlock it, which took 20 minutes. The supervisor unlocked the account, but because it was marked as potential fraud, they couldn’t mail a check anymore. Instead, they linked the account back to The Bank (20 more minutes), and she had to go there in person with her ID to get it checked.<p>So, she went to The Bank. But you can’t just walk in The Bank and show your ID to get it checked; you need an appointment. And to get an appointment, you need an account with The Bank. But her California benefits account? Oh, it is marked as potential fraud - it didn’t count. So, they spent 20 minutes to open a new account for her. She got an appointment for later that day, in 4 hours, went back to The Bank, and had her ID checked (yes, the second time in one day - they need to check your ID to open an account too).<p>Did she get the money then? Of course not—the account is still flagged as potential fraud. No cash possible. Call California again. California agreed to mail the check to the new address, probably by some oversight.<p>So my question is: do these “potential fraud” flags in databases ever die a natural death?<p>With some hope, sincerely, a 
Husband of a Potential Fraudster.</div><br/><div id="40582589" class="c"><input type="checkbox" id="c-40582589" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#40581628">parent</a><span>|</span><a href="#40582657">next</a><span>|</span><label class="collapse" for="c-40582589">[-]</label><label class="expand" for="c-40582589">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Mailing a check to transfer money<p>Real 1800 vibes here.</div><br/></div></div></div></div><div id="40582657" class="c"><input type="checkbox" id="c-40582657" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#40581628">prev</a><span>|</span><a href="#40582379">next</a><span>|</span><label class="collapse" for="c-40582657">[-]</label><label class="expand" for="c-40582657">[1 more]</label></div><br/><div class="children"><div class="content">The problem is: As soon as a synthetic key is used by an <i>EXTERNAL</i> system, it stops being synthetic; for all intents and purposes it is now an integral part of the record, because if you change it, the external system may not be able to find the record any more.</div><br/></div></div><div id="40582379" class="c"><input type="checkbox" id="c-40582379" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#40582657">prev</a><span>|</span><a href="#40582018">next</a><span>|</span><label class="collapse" for="c-40582379">[-]</label><label class="expand" for="c-40582379">[1 more]</label></div><br/><div class="children"><div class="content">The question is: if you have two restaurants having different scores but distinguishable only by their surrogate keys, how do you know which one to go to?<p>In other words - using surrogate key is an attempt (and the wrong one!) to fix the problem of missing important information in the database.</div><br/></div></div><div id="40582018" class="c"><input type="checkbox" id="c-40582018" checked=""/><div class="controls bullet"><span class="by">mobiuscog</span><span>|</span><a href="#40582379">prev</a><span>|</span><a href="#40581470">next</a><span>|</span><label class="collapse" for="c-40582018">[-]</label><label class="expand" for="c-40582018">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also important to put as much thought into any synthetic key.<p>It&#x27;s <i>easy</i> to just use an auto-generated sequence... but then you start having to export&#x2F;import or otherwise merge data, and other manipulations that often use the primary key and find there are collisions everywhere.
There can also be problems when needing to support multiple databases, or update versions.<p>UUIDs (or equivalent synthetic keys that are independent of the database itself) are often the best answer for this reason.<p>Having been bitten by sequences so many times in the past, I find them to often be more trouble than natural keys in the first place - just a lazy approach.</div><br/><div id="40582272" class="c"><input type="checkbox" id="c-40582272" checked=""/><div class="controls bullet"><span class="by">akvadrako</span><span>|</span><a href="#40582018">parent</a><span>|</span><a href="#40582041">next</a><span>|</span><label class="collapse" for="c-40582272">[-]</label><label class="expand" for="c-40582272">[1 more]</label></div><br/><div class="children"><div class="content">UUIDs are only good when you don&#x27;t care about ergonomics or performance.<p>Snowflake IDs are much more reasonable. 41 bits timestamp (ms) + 10 bit machine id + 12 bit serial.<p>But if you care about ergonomics and privacy the most then short and random IDs are really the best.</div><br/></div></div><div id="40582041" class="c"><input type="checkbox" id="c-40582041" checked=""/><div class="controls bullet"><span class="by">jonathan-re</span><span>|</span><a href="#40582018">parent</a><span>|</span><a href="#40582272">prev</a><span>|</span><a href="#40582147">next</a><span>|</span><label class="collapse" for="c-40582041">[-]</label><label class="expand" for="c-40582041">[1 more]</label></div><br/><div class="children"><div class="content">Well, UUIDs bring their own challenges.
Dropping that one here:<p>Be Careful with UUID or GUID as Primary Keys
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14523523">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14523523</a></div><br/></div></div><div id="40582147" class="c"><input type="checkbox" id="c-40582147" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40582018">parent</a><span>|</span><a href="#40582041">prev</a><span>|</span><a href="#40581470">next</a><span>|</span><label class="collapse" for="c-40582147">[-]</label><label class="expand" for="c-40582147">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty easy to migrate to UUIDs later if required, as long as you don&#x27;t leak your keys.<p>My work made their own uuid-like scheme, similar to UUIDv1 which incorporates several elements like machine ID and timestamp. The mistake was twofold: first they exposed them (so people started using them) but, worse, they made them easily reversible, so people started decoding the information in them. People would naturally see one and think &quot;oh this is a record from place X&quot;. Of course that might not be true following subsequent data corrections, but the key can&#x27;t change.</div><br/></div></div></div></div><div id="40581470" class="c"><input type="checkbox" id="c-40581470" checked=""/><div class="controls bullet"><span class="by">jpnc</span><span>|</span><a href="#40582018">prev</a><span>|</span><a href="#40582319">next</a><span>|</span><label class="collapse" for="c-40581470">[-]</label><label class="expand" for="c-40581470">[1 more]</label></div><br/><div class="children"><div class="content">The title could probably be extended to &#x27;You&#x27;ll regret using natural keys as primary keys&#x27; and it would be right in some ways.
Personally, I&#x27;ve come to the conclusion that it&#x27;s probably best to use both surrogate and natural keys. Surrogates (IDENTITYs, UUIDs what-have-you) as PK from a technical perspective and natural key as &#x27;PK&#x27; from a business&#x2F;data modeling perspective.</div><br/></div></div><div id="40582319" class="c"><input type="checkbox" id="c-40582319" checked=""/><div class="controls bullet"><span class="by">canary-hill</span><span>|</span><a href="#40581470">prev</a><span>|</span><a href="#40581743">next</a><span>|</span><label class="collapse" for="c-40582319">[-]</label><label class="expand" for="c-40582319">[1 more]</label></div><br/><div class="children"><div class="content">What has worked best for us is to have a sequential integer as the primary key as well as UUIDv4 as a surrogate key for every row. The applications would expose the objects only using uuid and never the primary key. The primary key always remain internal at the database level and never gets referenced or used at the application layer. In this way the security and privacy of objects are maintained and having sequential integral primary key for the object ensures the database design remains robust. Essentially, separating out the key for the database and the application. Is there any potential issue with this approach?</div><br/></div></div><div id="40581743" class="c"><input type="checkbox" id="c-40581743" checked=""/><div class="controls bullet"><span class="by">perlgeek</span><span>|</span><a href="#40582319">prev</a><span>|</span><a href="#40581296">next</a><span>|</span><label class="collapse" for="c-40581743">[-]</label><label class="expand" for="c-40581743">[3 more]</label></div><br/><div class="children"><div class="content">Natural keys have a tendency to change over time in what is considered unique.<p>For example, you have a company, and every employee has a unique employee number generated by HR... until the company merges with another, that also has unique employee numbers, and suddenly the identifier becomes the tuple (organization, employee number) that becomes unique. If you&#x27;ve used the employee number as a foreign key in other tables, you have to change those too.<p>This is a somewhat contrived example, but I&#x27;ve had enough real, annoying examples happen to me in my career that I avoid natural keys.</div><br/><div id="40582613" class="c"><input type="checkbox" id="c-40582613" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#40581743">parent</a><span>|</span><a href="#40581769">next</a><span>|</span><label class="collapse" for="c-40582613">[-]</label><label class="expand" for="c-40582613">[1 more]</label></div><br/><div class="children"><div class="content">Ah, how I remember changing my name. People think it only happens now and only to 0.1% of people who decide to change their gender in a leftist Western society, but somehow they forget that people have been changing family names for centuries.
And of course, my work email address also changed. Now THAT is fun.</div><br/></div></div></div></div><div id="40581296" class="c"><input type="checkbox" id="c-40581296" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#40581743">prev</a><span>|</span><a href="#40581888">next</a><span>|</span><label class="collapse" for="c-40581296">[-]</label><label class="expand" for="c-40581296">[2 more]</label></div><br/><div class="children"><div class="content">Just to add on to the CPR number. As mentioned it contains a birthdate and a gender identification as well as a checksum.<p>Since many refugees don’t know (or can’t prove) their birthdate, they are given first of January. And enough first of Januaries are handed out that for some years there aren’t enough valid numbers, so numbers that fail the checksum are handed out too.</div><br/><div id="40582697" class="c"><input type="checkbox" id="c-40582697" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#40581296">parent</a><span>|</span><a href="#40581888">next</a><span>|</span><label class="collapse" for="c-40582697">[-]</label><label class="expand" for="c-40582697">[1 more]</label></div><br/><div class="children"><div class="content">Shows how the assumption that everyone has, or reveals, a known or at least approximate birth date cascades through the system.</div><br/></div></div></div></div><div id="40581888" class="c"><input type="checkbox" id="c-40581888" checked=""/><div class="controls bullet"><span class="by">moi2388</span><span>|</span><a href="#40581296">prev</a><span>|</span><a href="#40582464">next</a><span>|</span><label class="collapse" for="c-40581888">[-]</label><label class="expand" for="c-40581888">[1 more]</label></div><br/><div class="children"><div class="content">I’ve just always considered natural keys public keys, and added a surrogate key as private key.<p>From the outside you won’t see it, but internally it saves a lot of headaches.<p>Space, speed, migrations, I have just never seen an actual downside to using a surrogate.<p>And if you are <i>absolutely</i> sure, add some unique constraints. Easier to change when you <i>inevitably</i> have to.<p>Mainly; I’ve learned that my initial assumptions are never correct.</div><br/></div></div><div id="40582464" class="c"><input type="checkbox" id="c-40582464" checked=""/><div class="controls bullet"><span class="by">begueradj</span><span>|</span><a href="#40581888">prev</a><span>|</span><a href="#40581563">next</a><span>|</span><label class="collapse" for="c-40582464">[-]</label><label class="expand" for="c-40582464">[3 more]</label></div><br/><div class="children"><div class="content">One of the most interesting part to me is the fact he is a university professor in a good country but rides a used&#x2F;second hand car... in an era where status and success are highlighted by displaying what one buys and owns on social media.</div><br/><div id="40582547" class="c"><input type="checkbox" id="c-40582547" checked=""/><div class="controls bullet"><span class="by">mobiuscog</span><span>|</span><a href="#40582464">parent</a><span>|</span><a href="#40582493">next</a><span>|</span><label class="collapse" for="c-40582547">[-]</label><label class="expand" for="c-40582547">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in an era where status and success are highlighted by displaying what one buys and owns on social media<p>This is no different from the people who used to show off their rolex in the pub, or park their BMW on display thinking it was impressive.<p>The &#x27;show&#x27; may have moved, but it&#x27;s still the same people who gain the same amount of &#x27;respect&#x27; that they ever did (not much).<p>Besides, I would guess that most professors are not so worried about their car (and in fact many may prefer a more sustainable mode of transport) as they are to their research and citations, and the advancement of their students.</div><br/></div></div><div id="40582493" class="c"><input type="checkbox" id="c-40582493" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#40582464">parent</a><span>|</span><a href="#40582547">prev</a><span>|</span><a href="#40581563">next</a><span>|</span><label class="collapse" for="c-40582493">[-]</label><label class="expand" for="c-40582493">[1 more]</label></div><br/><div class="children"><div class="content">Highlighted by <i>whom</i>? University professors?</div><br/></div></div></div></div><div id="40581563" class="c"><input type="checkbox" id="c-40581563" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#40582464">prev</a><span>|</span><a href="#40581013">next</a><span>|</span><label class="collapse" for="c-40581563">[-]</label><label class="expand" for="c-40581563">[1 more]</label></div><br/><div class="children"><div class="content">Every blog post about database schema should use as its example the most obvious example, a blog. People are pretty familiar with the domain, and it even has many of the same challenges. You probably have a postid field in there somewhere, but lots of blog software also uses url as a natural key. Which is why sometimes the old title appears in the url. Can&#x27;t change that. Except you can. Some software will do redirects, by creating stub records for old URLs that map to new ones. So that&#x27;s not an intractable problem. Etc.</div><br/></div></div><div id="40581013" class="c"><input type="checkbox" id="c-40581013" checked=""/><div class="controls bullet"><span class="by">projektfu</span><span>|</span><a href="#40581563">prev</a><span>|</span><a href="#40582315">next</a><span>|</span><label class="collapse" for="c-40581013">[-]</label><label class="expand" for="c-40581013">[3 more]</label></div><br/><div class="children"><div class="content">The devil&#x27;s advocate cases:<p>1. When duplication occurs and goes unnoticed because the natural key isn&#x27;t being used, and then perhaps the problem is &quot;corrected&quot; by an administrator in a way that doesn&#x27;t make sense.<p>For example, someone sets up an account with an street address A, then forgets they had it and sets up an account with street address B.  They call and complain that they can&#x27;t find an old order, or whatever, and the duplication is discovered.  The administrator later clobbers one of the addresses but both are in use.  A natural key (behaviorally speaking) may have presented the duplication, assuming address isn&#x27;t part of the natural key.  This can be satisfied by uniqueness constraints, etc.<p>2. When you are browsing the database, you see a bunch of synthetic keys and have to perform various joins to be able to see the relevant data.  The synthetic keys make joins easier to write, but make may make ad-hoc queries more time-consuming and difficult.</div><br/><div id="40581057" class="c"><input type="checkbox" id="c-40581057" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#40581013">parent</a><span>|</span><a href="#40582315">next</a><span>|</span><label class="collapse" for="c-40581057">[-]</label><label class="expand" for="c-40581057">[2 more]</label></div><br/><div class="children"><div class="content">A synthetic key is adding an additional dataum - so any problem that could be solved with the original data can be solved by the new data too (worst case, ignore the primary key). That is one of the best reasons to add a proper index - there is almost literally no downside. We&#x27;re talking maybe a few bytes&#x2F;record and arguably a trivial amount of administrative overhead.<p>Bearing that in mind:<p>1. Add a unique constraint on the natural key.<p>2. If the accuracy of joining by natural key is acceptable, join based on it. If that doesn&#x27;t work, then a table design without a synthetic key wouldn&#x27;t be fit for purpose either.</div><br/><div id="40581653" class="c"><input type="checkbox" id="c-40581653" checked=""/><div class="controls bullet"><span class="by">kubanczyk</span><span>|</span><a href="#40581013">root</a><span>|</span><a href="#40581057">parent</a><span>|</span><a href="#40582315">next</a><span>|</span><label class="collapse" for="c-40581653">[-]</label><label class="expand" for="c-40581653">[1 more]</label></div><br/><div class="children"><div class="content">In other words, don&#x27;t mistake a primary key with a key or a constraint.</div><br/></div></div></div></div></div></div><div id="40582315" class="c"><input type="checkbox" id="c-40582315" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#40581013">prev</a><span>|</span><a href="#40582529">next</a><span>|</span><label class="collapse" for="c-40582315">[-]</label><label class="expand" for="c-40582315">[1 more]</label></div><br/><div class="children"><div class="content">One of my first jobs involved an account management software which created an ID for each user based on first name and surname. So John Smith would get SMIJOH. It was the user natural key and it could not be changed once created.<p>One woman got married and changed her name; se became really upset when she found out that we couldn’t change her login.</div><br/></div></div><div id="40582529" class="c"><input type="checkbox" id="c-40582529" checked=""/><div class="controls bullet"><span class="by">lysecret</span><span>|</span><a href="#40582315">prev</a><span>|</span><label class="collapse" for="c-40582529">[-]</label><label class="expand" for="c-40582529">[1 more]</label></div><br/><div class="children"><div class="content">Again, every time I have seen natural keys in a big long lived system I have seen duplication. This is something you will have to deal with.</div><br/></div></div></div></div></div></div></div></body></html>