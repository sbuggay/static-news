<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735635663378" as="style"/><link rel="stylesheet" href="styles.css?v=1735635663378"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gianlucaventurini.com/posts/2024/factorio-sat">Learning Solver Design: Automating Factorio Balancers</a> <span class="domain">(<a href="https://gianlucaventurini.com">gianlucaventurini.com</a>)</span></div><div class="subtext"><span>kolui</span> | <span>27 comments</span></div><br/><div><div id="42552476" class="c"><input type="checkbox" id="c-42552476" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#42553271">next</a><span>|</span><label class="collapse" for="c-42552476">[-]</label><label class="expand" for="c-42552476">[1 more]</label></div><br/><div class="children"><div class="content">SAT solvers have also been thrown at the Factorio belt weaving problem (which has in-game reasons to maximize).<p><a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=2NKK_2v4jiE&amp;lc=Ugx5goGzTGz-z1g8ttd4AaABAg" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=2NKK_2v4jiE&amp;lc=Ugx5goGzTGz-z1g8t...</a><p>Search:<p>“ @Jodmangel
2 weeks ago
I wrote a quick script to find the longest belt weave with an SAT solver. It finds your 32-tile bridge, but also a 34-tile one:<p>The circles are the &quot;external&quot; belts and the squares the 34 &quot;internal&quot; ones. No longer solutions exist (unless I messed up the script, obviously).”</div><br/></div></div><div id="42553271" class="c"><input type="checkbox" id="c-42553271" checked=""/><div class="controls bullet"><span class="by">Epa095</span><span>|</span><a href="#42552476">prev</a><span>|</span><a href="#42554296">next</a><span>|</span><label class="collapse" for="c-42553271">[-]</label><label class="expand" for="c-42553271">[8 more]</label></div><br/><div class="children"><div class="content">This is a cool article! And it lead me down the path to another cool factorio compsci paper called &#x27;The steady-states of splitter networks&#x27; where they really go into the theoretical properties of the belts and splitters.<p>But I can&#x27;t help to feel that the following paragraph should be removed, since it really seems to be a bit  confused about the concepts of both Np-complete and NP-hard.<p><i>&gt; Finding a feasible solution is NP-hard because we can&#x27;t do any better than start placing the components on a 2D grid and check if the properties are respected. Furthermore, finding the optimal solution (i.e., minimum number of components) is NP-complete because it will require enumerating all the possible solutions in order to find the best one.</i></div><br/><div id="42553314" class="c"><input type="checkbox" id="c-42553314" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#42553271">parent</a><span>|</span><a href="#42554229">next</a><span>|</span><label class="collapse" for="c-42553314">[-]</label><label class="expand" for="c-42553314">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a classic undergraduate student mistake when learning computational complexity: &quot;this problem is really hard, but I can represent it as SAT - well, it is NP-hard!&quot;. Whereas what you need is to represent SAT as an instance of your problem! Otherwise computing XOR of two bits would be NP-hard, as I can write a SAT formula to express it.</div><br/><div id="42553390" class="c"><input type="checkbox" id="c-42553390" checked=""/><div class="controls bullet"><span class="by">wtallis</span><span>|</span><a href="#42553271">root</a><span>|</span><a href="#42553314">parent</a><span>|</span><a href="#42555311">next</a><span>|</span><label class="collapse" for="c-42553390">[-]</label><label class="expand" for="c-42553390">[3 more]</label></div><br/><div class="children"><div class="content">&gt; we can&#x27;t do any better than start placing the components on a 2D grid and check if the properties are respected<p>That specifically seems to be the bit where the explanation goes wrong. Proving that there&#x27;s no easier method than brute forcing is a hard problem, not something to wave away as an exercise for the reader.</div><br/><div id="42555273" class="c"><input type="checkbox" id="c-42555273" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42553271">root</a><span>|</span><a href="#42553390">parent</a><span>|</span><a href="#42555311">next</a><span>|</span><label class="collapse" for="c-42555273">[-]</label><label class="expand" for="c-42555273">[2 more]</label></div><br/><div class="children"><div class="content">Actually, you can wave it away as an exercise to the reader, you just need to be careful how you formulate it.<p>Something like &#x27;Frobbing the fnutz might be NP-hard.  The proof via reduction of SAT is left as an exercise for the reader.&#x27;<p>Not very reader friendly, but at least you haven&#x27;t said anything wrong.</div><br/></div></div></div></div><div id="42555311" class="c"><input type="checkbox" id="c-42555311" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#42553271">root</a><span>|</span><a href="#42553314">parent</a><span>|</span><a href="#42553390">prev</a><span>|</span><a href="#42554229">next</a><span>|</span><label class="collapse" for="c-42555311">[-]</label><label class="expand" for="c-42555311">[1 more]</label></div><br/><div class="children"><div class="content">Even when you get the direction correct-- e.g. that you could encode an arbitrary SAT problem as an instance of your problem... that doesn&#x27;t mean that in practice most instances of your problem can&#x27;t be solved to an arbitrarily good approximation quickly or even solved optimally in a reasonable amount of time.  It only means that in the worst case there is no efficient optimal solution or good approximation.<p>I&#x27;ve repeatedly encountered people using crappy solutions to problems because they read some result from complexity theory that made them think they couldn&#x27;t do better. .. when in reality a slightly smarter algorithm does much better on average.<p>Consider for example the min cover problem: You have a set of bit vectors and you want to find the minimum collection where at least one vector is true for every bit. (e.g. optimizing a collection of tests).  There is a simple greedy algorithm-- include the vector that covers the most yet-uncovered bits.  There is a proof that this algorithm achieves the best possible worst case approximation error.<p>But in practice this is a useless result. Worst case approximation error is driven by pathological inputs.  It&#x27;s easy to come up with modifications of the greedy algorithm that significantly improve the quality of the solutions on average (or at least do in the sorts of real problems I&#x27;ve applied it to).</div><br/></div></div></div></div><div id="42554229" class="c"><input type="checkbox" id="c-42554229" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#42553271">parent</a><span>|</span><a href="#42553314">prev</a><span>|</span><a href="#42557213">next</a><span>|</span><label class="collapse" for="c-42554229">[-]</label><label class="expand" for="c-42554229">[1 more]</label></div><br/><div class="children"><div class="content">Yes, &quot;NP-complete&quot; is not correct on the author&#x27;s part and neither is &quot;NP-hard.&quot; &quot;NP-hard&quot; is the author&#x27;s intent since the problem is solvable using a SAT solver but presumably has no polynomial algorithm (so it is harder than P but not as hard as NP), but NP-hardness actually requires the other direction to be true: for a problem to be NP-hard, an oracle for the problem needs to be able to solve everything in NP. NP-complete is a stricter condition that requires NP-hardness but also requires that the problem be in NP.<p>The author was missing the words &quot;in NP&quot; if they are talking about complexity.</div><br/></div></div><div id="42557213" class="c"><input type="checkbox" id="c-42557213" checked=""/><div class="controls bullet"><span class="by">kolui</span><span>|</span><a href="#42553271">parent</a><span>|</span><a href="#42554229">prev</a><span>|</span><a href="#42554296">next</a><span>|</span><label class="collapse" for="c-42557213">[-]</label><label class="expand" for="c-42557213">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the feedback, I fixed the claims about complexity. Let me know if you find other incorrect parts.</div><br/></div></div></div></div><div id="42554296" class="c"><input type="checkbox" id="c-42554296" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#42553271">prev</a><span>|</span><a href="#42554556">next</a><span>|</span><label class="collapse" for="c-42554296">[-]</label><label class="expand" for="c-42554296">[1 more]</label></div><br/><div class="children"><div class="content">So I started building a solver for satisfactory for someone.  Code is on GitHub if you are bored. It can do similar things, as well as finding optimal recipes and such (like some websites do) but I did it to speed up their app where their current solving of graphical models can be quite slow (20 minutes to solve a model)
I&#x27;ve tried a lot of approaches as a result, including going down the same paths.<p>The balancer issue is different in particular but in my experience, for this kind of problem, using z3 and cvc5 give much faster result than mnilp solvers or cp-sat. On smaller models they are all quite fast. But as it gets larger it&#x27;s actually much faster for me to binary search an optimal objective through sat with z3 or cvc5 than it is to ask most nlp solvers to optimize it.  I haven&#x27;t tried gurobi or cplex of course.<p>But I expect this is because of their ability to do really effective incremental solving so that binary searching the objective is very efficient (z3 has an optimizer and soft constraints but they do not advertise it as supporting non linear logic and I can get it to hang on some models)<p>Especially for this type of problem, I would consider using an SMT solver and seeing how it does<p>If you stick with Clos networks, a homegrown solver using bdds is probably quite fast and wildly memory efficient.</div><br/></div></div><div id="42554556" class="c"><input type="checkbox" id="c-42554556" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#42554296">prev</a><span>|</span><a href="#42554947">next</a><span>|</span><label class="collapse" for="c-42554556">[-]</label><label class="expand" for="c-42554556">[4 more]</label></div><br/><div class="children"><div class="content">Nice. I&#x27;m lazily hacking on some code to optimise a mana-acceleration engine for a Magic: the Gathering deck. If it works, I&#x27;ll post something about it :)</div><br/><div id="42556516" class="c"><input type="checkbox" id="c-42556516" checked=""/><div class="controls bullet"><span class="by">ProjectArcturis</span><span>|</span><a href="#42554556">parent</a><span>|</span><a href="#42554918">next</a><span>|</span><label class="collapse" for="c-42556516">[-]</label><label class="expand" for="c-42556516">[1 more]</label></div><br/><div class="children"><div class="content">Is there anything like an open source Magic emulator for optimization or ML purposes?</div><br/></div></div><div id="42554918" class="c"><input type="checkbox" id="c-42554918" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#42554556">parent</a><span>|</span><a href="#42556516">prev</a><span>|</span><a href="#42554947">next</a><span>|</span><label class="collapse" for="c-42554918">[-]</label><label class="expand" for="c-42554918">[2 more]</label></div><br/><div class="children"><div class="content">Ruby Storm player spotted? :)</div><br/><div id="42556105" class="c"><input type="checkbox" id="c-42556105" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#42554556">root</a><span>|</span><a href="#42554918">parent</a><span>|</span><a href="#42554947">next</a><span>|</span><label class="collapse" for="c-42556105">[-]</label><label class="expand" for="c-42556105">[1 more]</label></div><br/><div class="children"><div class="content">Hah! Nah, this is an M:tG Arena deck for Historic. Besides I&#x27;m too rogue for Ruby Storm :)</div><br/></div></div></div></div></div></div><div id="42554947" class="c"><input type="checkbox" id="c-42554947" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#42554556">prev</a><span>|</span><a href="#42552709">next</a><span>|</span><label class="collapse" for="c-42554947">[-]</label><label class="expand" for="c-42554947">[5 more]</label></div><br/><div class="children"><div class="content">im a factorio noob so just checking some intuitions<p>&gt; Example of 4 x 4 naïve Throughput-Limited belt balancer. This is not what we want.<p>is this because a slowdown on belt #1 doesnt then get filled by belts 3 and 4? so this isn&#x27;t a properly completely rebalancing system?<p>&gt; 4 x 4 Throughput-Unlimited belt balancer. This is what we want.<p>but then this is weird too. the top left tunnel entrance thingy goes down and then immediately up again. why? maybe it tunnels all the way to the top right, in which case it has the same exact flaw as the first throughput limited example that we didnt want -  belts 3 and 4 dont get to redistribute their stuff to it if belt 1 dies.</div><br/><div id="42555133" class="c"><input type="checkbox" id="c-42555133" checked=""/><div class="controls bullet"><span class="by">theptip</span><span>|</span><a href="#42554947">parent</a><span>|</span><a href="#42555127">next</a><span>|</span><label class="collapse" for="c-42555133">[-]</label><label class="expand" for="c-42555133">[1 more]</label></div><br/><div class="children"><div class="content">A mixer can run at the full speed of its input belts (ie given two full belts input, it will output two full belts).<p>In the naive solution you are effectively allocating a single belt output from each layer-1 mixer, so the system will run at half throughput. But the fan-out to a pair of mixers in layer-3 does mean that your 4 output belts are balanced, which might be good enough in some cases - for example of downstream smelters have lower capacity than the theoretical 4-belt max throughput.</div><br/></div></div><div id="42555127" class="c"><input type="checkbox" id="c-42555127" checked=""/><div class="controls bullet"><span class="by">maverwa</span><span>|</span><a href="#42554947">parent</a><span>|</span><a href="#42555133">prev</a><span>|</span><a href="#42552709">next</a><span>|</span><label class="collapse" for="c-42555127">[-]</label><label class="expand" for="c-42555127">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, the underground belts in the first and fourth row look odd, I currently don’t see a reason why the couldn’t be replaced by simple belts, which would be somewhat cheaper. Maybe that’s an additional UPS optimization applied in that design?</div><br/><div id="42555298" class="c"><input type="checkbox" id="c-42555298" checked=""/><div class="controls bullet"><span class="by">kolui</span><span>|</span><a href="#42554947">root</a><span>|</span><a href="#42555127">parent</a><span>|</span><a href="#42552709">next</a><span>|</span><label class="collapse" for="c-42555298">[-]</label><label class="expand" for="c-42555298">[2 more]</label></div><br/><div class="children"><div class="content">I agree that using underground belts makes harder than it should to understand the example. I replaced it with simple belts. I re-calculated the design with the latest version of the code that has an optimization function that favors normal belts to underground ones <a href="https:&#x2F;&#x2F;github.com&#x2F;gianluca-venturini&#x2F;factorio-tools&#x2F;blob&#x2F;main&#x2F;balancer.py#L440">https:&#x2F;&#x2F;github.com&#x2F;gianluca-venturini&#x2F;factorio-tools&#x2F;blob&#x2F;ma...</a></div><br/><div id="42555881" class="c"><input type="checkbox" id="c-42555881" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#42554947">root</a><span>|</span><a href="#42555298">parent</a><span>|</span><a href="#42552709">next</a><span>|</span><label class="collapse" for="c-42555881">[-]</label><label class="expand" for="c-42555881">[1 more]</label></div><br/><div class="children"><div class="content">now my comment looks out of date :)<p>thanks but also i am very intimidated by how much work you put into this game lol<p>is this why i am a bad engineer</div><br/></div></div></div></div></div></div></div></div><div id="42552709" class="c"><input type="checkbox" id="c-42552709" checked=""/><div class="controls bullet"><span class="by">piebro</span><span>|</span><a href="#42554947">prev</a><span>|</span><a href="#42554458">next</a><span>|</span><label class="collapse" for="c-42552709">[-]</label><label class="expand" for="c-42552709">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;R-O-C-K-E-T&#x2F;Factorio-SAT">https:&#x2F;&#x2F;github.com&#x2F;R-O-C-K-E-T&#x2F;Factorio-SAT</a> is another codebase trying to tackle the same problem</div><br/><div id="42554062" class="c"><input type="checkbox" id="c-42554062" checked=""/><div class="controls bullet"><span class="by">progbits</span><span>|</span><a href="#42552709">parent</a><span>|</span><a href="#42554458">next</a><span>|</span><label class="collapse" for="c-42554062">[-]</label><label class="expand" for="c-42554062">[2 more]</label></div><br/><div class="children"><div class="content">This is the one from which most balancer books are made and if I recall correctly the first one that made SAT work for this problem.</div><br/><div id="42554882" class="c"><input type="checkbox" id="c-42554882" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#42552709">root</a><span>|</span><a href="#42554062">parent</a><span>|</span><a href="#42554458">next</a><span>|</span><label class="collapse" for="c-42554882">[-]</label><label class="expand" for="c-42554882">[1 more]</label></div><br/><div class="children"><div class="content">The 4x4 with a 90 degree turn is a thing of beauty.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>