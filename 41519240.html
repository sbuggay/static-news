<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726218064028" as="style"/><link rel="stylesheet" href="styles.css?v=1726218064028"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantamagazine.org/novel-architecture-makes-neural-networks-more-understandable-20240911/">Kolmogorov-Arnold networks may make neural networks more understandable</a> <span class="domain">(<a href="https://www.quantamagazine.org">www.quantamagazine.org</a>)</span></div><div class="subtext"><span>isaacfrond</span> | <span>74 comments</span></div><br/><div><div id="41520120" class="c"><input type="checkbox" id="c-41520120" checked=""/><div class="controls bullet"><span class="by">stefanpie</span><span>|</span><a href="#41520320">next</a><span>|</span><label class="collapse" for="c-41520120">[-]</label><label class="expand" for="c-41520120">[3 more]</label></div><br/><div class="children"><div class="content">The main author of KANs did a tutorial session yesterday at MLCAD, an academic conference focused on the intersection of hardware &#x2F; semiconductor design and ML &#x2F; deep learning.
 It was super fascinating and seems really good for what they advertise it for, gaining insight and interpret for physical systems (symbolic expressions, conserved quantities , symmetries). For science and mathematics this can be useful but for engineering this might not be the main priority of an ML &#x2F; deep learning (to some extent).<p>There are still unknowns for leaning hard tasks and learning capacity over harder problems. Even choices in for things like the chosen basis function used for the KAN “activations” and what other architectures these layers can be plugged into with some gain is still unexplored. I think as people mess around with KANs we’ll get better answers to these questions.</div><br/><div id="41520432" class="c"><input type="checkbox" id="c-41520432" checked=""/><div class="controls bullet"><span class="by">notpublic</span><span>|</span><a href="#41520120">parent</a><span>|</span><a href="#41526503">next</a><span>|</span><label class="collapse" for="c-41520432">[-]</label><label class="expand" for="c-41520432">[1 more]</label></div><br/><div class="children"><div class="content">Presentation by the same author made 2 months back:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=FYYZZVV5vlY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=FYYZZVV5vlY</a></div><br/></div></div><div id="41526503" class="c"><input type="checkbox" id="c-41526503" checked=""/><div class="controls bullet"><span class="by">abhgh</span><span>|</span><a href="#41520120">parent</a><span>|</span><a href="#41520432">prev</a><span>|</span><a href="#41520320">next</a><span>|</span><label class="collapse" for="c-41526503">[-]</label><label class="expand" for="c-41526503">[1 more]</label></div><br/><div class="children"><div class="content">Is there a publicly available version of the session?</div><br/></div></div></div></div><div id="41520320" class="c"><input type="checkbox" id="c-41520320" checked=""/><div class="controls bullet"><span class="by">light_hue_1</span><span>|</span><a href="#41520120">prev</a><span>|</span><a href="#41520047">next</a><span>|</span><label class="collapse" for="c-41520320">[-]</label><label class="expand" for="c-41520320">[24 more]</label></div><br/><div class="children"><div class="content">They cannot.<p>Just because one internal operation is understandable, doesn&#x27;t imply that the whole network is understandable.<p>Take even something much simpler: decision trees. Textbooks give these as an example of understandable systems. A tree where you make one decision based on one feature at a time then at the leaves you output something. Like a bunch of if statements. And in the 90s when computers were slow and trees were small this was true.<p>Today massive decision trees and approaches like random forests can create trees with millions of nodes. Nothing is interpretable about them.<p>We have a basic math gap when it comes to understanding complex systems. Yet another network type solves nothing.</div><br/><div id="41520679" class="c"><input type="checkbox" id="c-41520679" checked=""/><div class="controls bullet"><span class="by">t_mann</span><span>|</span><a href="#41520320">parent</a><span>|</span><a href="#41527767">next</a><span>|</span><label class="collapse" for="c-41520679">[-]</label><label class="expand" for="c-41520679">[5 more]</label></div><br/><div class="children"><div class="content">I think of it as &quot;Could Newton have used this to find the expressions for the forces he was analyzing (eg gravitational force = g m_1 m_2 &#x2F; d^2)?&quot;. I once asked a physics prof whether that was conceivable in principle, and he said yes. It seems to me like KANs should be able to find expressions like these given experimental data. If that was true, then I don&#x27;t see how that wouldn&#x27;t deserve being called interpretability.</div><br/><div id="41521681" class="c"><input type="checkbox" id="c-41521681" checked=""/><div class="controls bullet"><span class="by">fjkdlsjflkds</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520679">parent</a><span>|</span><a href="#41522305">next</a><span>|</span><label class="collapse" for="c-41521681">[-]</label><label class="expand" for="c-41521681">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It seems to me like KANs should be able to find expressions like these given experimental data.<p>Perhaps, but this is not something unique to KANs: any symbolic regression method can (at least in theory) find such simple expressions. Here is an example of such type of work (using non-KAN neural networks): <a href="https:&#x2F;&#x2F;www.science.org&#x2F;doi&#x2F;10.1126&#x2F;sciadv.aay2631" rel="nofollow">https:&#x2F;&#x2F;www.science.org&#x2F;doi&#x2F;10.1126&#x2F;sciadv.aay2631</a><p>Rephrasing: just because you can reach simple expressions with symbolic regression methods based on neural networks (or KANs) does not necessarily imply that neural networks (or KANs) are inherently interpretable (particularly once you start stacking multiple layers).</div><br/></div></div><div id="41522305" class="c"><input type="checkbox" id="c-41522305" checked=""/><div class="controls bullet"><span class="by">nathan_compton</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520679">parent</a><span>|</span><a href="#41521681">prev</a><span>|</span><a href="#41527767">next</a><span>|</span><label class="collapse" for="c-41522305">[-]</label><label class="expand" for="c-41522305">[3 more]</label></div><br/><div class="children"><div class="content">Just giving the force law hardly counts as interpret-ability. You probably know that the 1&#x2F;r^2 in the force law comes from the dimensionality of space. That is the interpretation.</div><br/><div id="41527494" class="c"><input type="checkbox" id="c-41527494" checked=""/><div class="controls bullet"><span class="by">t_mann</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41522305">parent</a><span>|</span><a href="#41527751">next</a><span>|</span><label class="collapse" for="c-41527494">[-]</label><label class="expand" for="c-41527494">[1 more]</label></div><br/><div class="children"><div class="content">It seems like you&#x27;re asking for quite a lot here. Are there any examples of common interpretable ML methods that would give you anything like that answer? The most common methods that are called interpretable would give you hints like &quot;Mass and distance matter for gravity, color doesn&#x27;t&quot; or &quot;Gravity gets stronger with mass and weaker with distance&quot;. Both are clearly less informative than the formula.<p>The only way I could think of to get anywhere near such an answer would be to use symbolic regression first and then ask an LLM to interpret the result. And that would probably take quite some more original research to get it anywhere near working, and even then probably primarily for problems where the answer is already known.<p>I agree that this kind of answer would be useful, but we also have to be honest that that&#x27;s not what currently meant by interpretability. And that&#x27;s what should matter for evaluating the claim - it&#x27;s not misleading if it delivers what one can reasonably expect. Whether we should update our interpretability definitions is a different (interesting) discussion.</div><br/></div></div><div id="41527751" class="c"><input type="checkbox" id="c-41527751" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41522305">parent</a><span>|</span><a href="#41527494">prev</a><span>|</span><a href="#41527767">next</a><span>|</span><label class="collapse" for="c-41527751">[-]</label><label class="expand" for="c-41527751">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just giving the force law hardly counts as interpret-ability. You probably know that the 1&#x2F;r^2 in the force law comes from the dimensionality of space. That is the interpretation.<p>I used to think the same, but don&#x27;t the weak and strong forces decay differently?</div><br/></div></div></div></div></div></div><div id="41527767" class="c"><input type="checkbox" id="c-41527767" checked=""/><div class="controls bullet"><span class="by">deepsquirrelnet</span><span>|</span><a href="#41520320">parent</a><span>|</span><a href="#41520679">prev</a><span>|</span><a href="#41527499">next</a><span>|</span><label class="collapse" for="c-41527767">[-]</label><label class="expand" for="c-41527767">[1 more]</label></div><br/><div class="children"><div class="content">I generally agree, and I think  interpretability is a fools errand for any sufficiently complex nonlinear model.<p>That said, I’d be surprised if there weren’t eventually successful breakthroughs from the fields of nonlinear dynamics &#x2F; pattern formation.</div><br/></div></div><div id="41527499" class="c"><input type="checkbox" id="c-41527499" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#41520320">parent</a><span>|</span><a href="#41527767">prev</a><span>|</span><a href="#41521415">next</a><span>|</span><label class="collapse" for="c-41527499">[-]</label><label class="expand" for="c-41527499">[2 more]</label></div><br/><div class="children"><div class="content">Many folks call tree ensembles &quot;black boxes&quot;.<p>I would call them grey boxes or dark grey boxes. You could interpret them if you want to. But who wants to go through 500 trees in practice?</div><br/><div id="41529108" class="c"><input type="checkbox" id="c-41529108" checked=""/><div class="controls bullet"><span class="by">seventh12</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41527499">parent</a><span>|</span><a href="#41521415">next</a><span>|</span><label class="collapse" for="c-41529108">[-]</label><label class="expand" for="c-41529108">[1 more]</label></div><br/><div class="children"><div class="content">You could also interpret networks if you want to. But who wants to go through millions of neurons?</div><br/></div></div></div></div><div id="41521415" class="c"><input type="checkbox" id="c-41521415" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41520320">parent</a><span>|</span><a href="#41527499">prev</a><span>|</span><a href="#41520514">next</a><span>|</span><label class="collapse" for="c-41521415">[-]</label><label class="expand" for="c-41521415">[5 more]</label></div><br/><div class="children"><div class="content">yeah. you can run SHAP[0] on your xgboosted trees, results are kinda interesting, but it doesn&#x27;t actually explain anything IME.<p>[0] <a href="https:&#x2F;&#x2F;shap.readthedocs.io&#x2F;en&#x2F;latest&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;shap.readthedocs.io&#x2F;en&#x2F;latest&#x2F;index.html</a></div><br/><div id="41521654" class="c"><input type="checkbox" id="c-41521654" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41521415">parent</a><span>|</span><a href="#41527490">next</a><span>|</span><label class="collapse" for="c-41521654">[-]</label><label class="expand" for="c-41521654">[3 more]</label></div><br/><div class="children"><div class="content">No wonder. &quot;Shapley values&quot; have the problem that they assume all necessary conditions are equally important. Say a successful surgery needs both a surgeon and a nurse, otherwise the patient dies. Shapley values will then assume that both have contributed equally to the successful surgery. Which isn&#x27;t true, because surgeons are much less available (less replaceable) than nurses. If the nurse gets ill, a different nurse could probably do the task, while if the surgeon gets ill, the surgery may well have to be postponed. So the surgeons are more important for (contribute more to) a successful surgery.</div><br/><div id="41525165" class="c"><input type="checkbox" id="c-41525165" checked=""/><div class="controls bullet"><span class="by">adammarples</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41521654">parent</a><span>|</span><a href="#41527490">next</a><span>|</span><label class="collapse" for="c-41525165">[-]</label><label class="expand" for="c-41525165">[2 more]</label></div><br/><div class="children"><div class="content">Clearly both are equally important, 100% necessary. This doesn&#x27;t account for rarity, nor does it account for wages, agreeability, smell or any of the other things it isn&#x27;t trying to measure. You&#x27;ll need a different metric for that and if you want to take both into account you should.</div><br/><div id="41525383" class="c"><input type="checkbox" id="c-41525383" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41525165">parent</a><span>|</span><a href="#41527490">next</a><span>|</span><label class="collapse" for="c-41525383">[-]</label><label class="expand" for="c-41525383">[1 more]</label></div><br/><div class="children"><div class="content">Shapley values try to measure importance of contributions, and for this, bare necessity isn&#x27;t a sufficient indicator. I think it comes down to probability. The task of the surgeon is, from a prior perspective, less likely to be fulfilled because it is harder to get hold of a surgeon.<p>Similarly: What what was the main cause of the match getting lit? The match being struck? Or the atmosphere containing oxygen? Both are necessary in the sense that if either hadn&#x27;t occurred the match wouldn&#x27;t be lit. But it seems clear that the main cause was the match being struck, because matches being struck is relatively rare, and hence unlikely, while the atmosphere contains oxygen pretty much always.<p>So I think the contributions calculated for Shapley values should be weighted by the inverse of their prior probabilities. Though it is possible that such probabilities are not typically available in the machine learning context in which SHAP operates.</div><br/></div></div></div></div></div></div><div id="41527490" class="c"><input type="checkbox" id="c-41527490" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41521415">parent</a><span>|</span><a href="#41521654">prev</a><span>|</span><a href="#41520514">next</a><span>|</span><label class="collapse" for="c-41527490">[-]</label><label class="expand" for="c-41527490">[1 more]</label></div><br/><div class="children"><div class="content">SHAP gets a bad rap. I use them all the time for global and feature interpretation. They can be a great springboard for diving into your data and doing additional feature engineering, monotonic constraints, and leveraging regression based models.</div><br/></div></div></div></div><div id="41520514" class="c"><input type="checkbox" id="c-41520514" checked=""/><div class="controls bullet"><span class="by">ImHereToVote</span><span>|</span><a href="#41520320">parent</a><span>|</span><a href="#41521415">prev</a><span>|</span><a href="#41520583">next</a><span>|</span><label class="collapse" for="c-41520514">[-]</label><label class="expand" for="c-41520514">[1 more]</label></div><br/><div class="children"><div class="content">A formula or equation that enables you to reason about complex systems might simply not exists. It could very well be that to reason about complexity forces you to actually do the complexity.</div><br/></div></div><div id="41520583" class="c"><input type="checkbox" id="c-41520583" checked=""/><div class="controls bullet"><span class="by">empath75</span><span>|</span><a href="#41520320">parent</a><span>|</span><a href="#41520514">prev</a><span>|</span><a href="#41520047">next</a><span>|</span><label class="collapse" for="c-41520583">[-]</label><label class="expand" for="c-41520583">[9 more]</label></div><br/><div class="children"><div class="content">Even extremely complicated decision trees are interpretable to some extent because you can just walk through the tree and answer questions like: &quot;If this had not been true, would the result have been different?&quot;.  It may not be possible to hold the entire tree in your head at once, but it&#x27;s certainly possible to investigate the tree as needed to understand the path that was taken through it.</div><br/><div id="41520613" class="c"><input type="checkbox" id="c-41520613" checked=""/><div class="controls bullet"><span class="by">svboese</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520583">parent</a><span>|</span><a href="#41520047">next</a><span>|</span><label class="collapse" for="c-41520613">[-]</label><label class="expand" for="c-41520613">[8 more]</label></div><br/><div class="children"><div class="content">But couldn‘t the same be said about standard MLPs or NNs in general?</div><br/><div id="41520828" class="c"><input type="checkbox" id="c-41520828" checked=""/><div class="controls bullet"><span class="by">Scene_Cast2</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520613">parent</a><span>|</span><a href="#41522652">next</a><span>|</span><label class="collapse" for="c-41520828">[-]</label><label class="expand" for="c-41520828">[3 more]</label></div><br/><div class="children"><div class="content">LIME (local linear approximation basically) is one popular technique to do so. Still has flaws (such as not being close to a decision boundary).</div><br/><div id="41524779" class="c"><input type="checkbox" id="c-41524779" checked=""/><div class="controls bullet"><span class="by">pkage</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520828">parent</a><span>|</span><a href="#41522652">next</a><span>|</span><label class="collapse" for="c-41524779">[-]</label><label class="expand" for="c-41524779">[2 more]</label></div><br/><div class="children"><div class="content">LIME and other post-hoc explanatory techniques (deepshap, etc.) only give an explanation for a singular inference, but aren&#x27;t helpful for the model as a whole. In other words, you can make a reasonable guess as to why a specific prediction was made but you have no idea how the model will behave in the general case, even on similar inputs.</div><br/><div id="41525252" class="c"><input type="checkbox" id="c-41525252" checked=""/><div class="controls bullet"><span class="by">Narhem</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41524779">parent</a><span>|</span><a href="#41522652">next</a><span>|</span><label class="collapse" for="c-41525252">[-]</label><label class="expand" for="c-41525252">[1 more]</label></div><br/><div class="children"><div class="content">The purpose of post-prediction explanations would be to increase confidence of a practitioner to use said inference.<p>It’s a disconnect between finding a real life “AI” and trying to find something which works and you can have a form of trust with.</div><br/></div></div></div></div></div></div><div id="41522652" class="c"><input type="checkbox" id="c-41522652" checked=""/><div class="controls bullet"><span class="by">ljosifov</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520613">parent</a><span>|</span><a href="#41520828">prev</a><span>|</span><a href="#41520730">next</a><span>|</span><label class="collapse" for="c-41522652">[-]</label><label class="expand" for="c-41522652">[1 more]</label></div><br/><div class="children"><div class="content">You are right and IDK why you are downvoted. Few units of perceptrons, few nodes in a decision tree, few of anything - they are &quot;interpretable&quot;. Billions of the sames - are not interpretable any more. This b&#x2F;c our understanding of &quot;interpretable&quot; is &quot;an array of symbols that can fit a page or a white board&quot;. But there is no reason to think that all the rules of our world would be such that they can be expressed that way. Some maybe, others maybe not. Interpretable is another platitudinous term that seems appealing at 1st sight, only to be found to not be that great after all. We humans are not interpretable, we can&#x27;t explain how we come up with the actions we take, yet we don&#x27;t say &quot;now don&#x27;t move, do nothing, until you are interpretable&quot;. So - much ado about little.</div><br/></div></div><div id="41520730" class="c"><input type="checkbox" id="c-41520730" checked=""/><div class="controls bullet"><span class="by">empath75</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520613">parent</a><span>|</span><a href="#41522652">prev</a><span>|</span><a href="#41527507">next</a><span>|</span><label class="collapse" for="c-41520730">[-]</label><label class="expand" for="c-41520730">[2 more]</label></div><br/><div class="children"><div class="content">_Sometimes_, and people do find features in neural networks by tweaking stuff and seeing how the neurons activate, but in general, no.  Any given weight or layer or perceptron or whatever can be reused for multiple purposes and it&#x27;s extremely difficult to say &quot;this is responsible for that&quot;, and if you do find parts of the network responsible for a particular task, you don&#x27;t know if it&#x27;s _also_ responsible for something else. Whereas with a decision tree it&#x27;s pretty simple to trace causality and tweak things without changing unrelated parts of the tree.  Changing weights in a neural network leads to unpredictable results.</div><br/><div id="41522318" class="c"><input type="checkbox" id="c-41522318" checked=""/><div class="controls bullet"><span class="by">tomhallett</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520730">parent</a><span>|</span><a href="#41527507">next</a><span>|</span><label class="collapse" for="c-41522318">[-]</label><label class="expand" for="c-41522318">[1 more]</label></div><br/><div class="children"><div class="content">If a KAN has multiple layers, would tweaking the equations of a KAN be more similar to tweaking the weights in a MLP&#x2F;NN, or more similar to tweaking a decision tree?<p>EDIT: I gave the above thread (light_hue_1 &gt; empath75 &gt; svboese &gt; empath75) to chatgpt and had it write a question to learn more, and it gave me &quot;How do KAN networks compare to decision trees or neural networks when it comes to tracing causality and making interpretability more accessible, especially in large, complex models?&quot;.  Either shows me and ai are on the right track, or i&#x27;m as dumb as a statistical token guessing machine....<p><a href="https:&#x2F;&#x2F;imgur.com&#x2F;3dSNZrG" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;3dSNZrG</a></div><br/></div></div></div></div><div id="41527507" class="c"><input type="checkbox" id="c-41527507" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#41520320">root</a><span>|</span><a href="#41520613">parent</a><span>|</span><a href="#41520730">prev</a><span>|</span><a href="#41520047">next</a><span>|</span><label class="collapse" for="c-41527507">[-]</label><label class="expand" for="c-41527507">[1 more]</label></div><br/><div class="children"><div class="content">(IMO) to a lesser extent.</div><br/></div></div></div></div></div></div></div></div><div id="41520047" class="c"><input type="checkbox" id="c-41520047" checked=""/><div class="controls bullet"><span class="by">mansoor_</span><span>|</span><a href="#41520320">prev</a><span>|</span><a href="#41522229">next</a><span>|</span><label class="collapse" for="c-41520047">[-]</label><label class="expand" for="c-41520047">[7 more]</label></div><br/><div class="children"><div class="content">Not really. For a trivial function fitting problem, a KAN will allow you to visualise the contribution of each base function into the next layer of your network. Still, these trivial shallow networks are the ones nobody needs to introspect. A deep NN will not be explainable using this approach.</div><br/><div id="41521115" class="c"><input type="checkbox" id="c-41521115" checked=""/><div class="controls bullet"><span class="by">Taikonerd</span><span>|</span><a href="#41520047">parent</a><span>|</span><a href="#41522229">next</a><span>|</span><label class="collapse" for="c-41521115">[-]</label><label class="expand" for="c-41521115">[6 more]</label></div><br/><div class="children"><div class="content">Yeah. I&#x27;m not sure if anything with millions or billions of parameters will ever be &quot;explainable&quot; in the way we want.<p>I mean, imagine a regular multivariable function with billions of terms, written out on a (very big) whiteboard.  Are we ever really going to understand why it produces the numbers it does?<p>KANs may have an order of magnitude fewer parameters, but the basic problem is still the same.</div><br/><div id="41521706" class="c"><input type="checkbox" id="c-41521706" checked=""/><div class="controls bullet"><span class="by">etiam</span><span>|</span><a href="#41520047">root</a><span>|</span><a href="#41521115">parent</a><span>|</span><a href="#41521829">next</a><span>|</span><label class="collapse" for="c-41521706">[-]</label><label class="expand" for="c-41521706">[1 more]</label></div><br/><div class="children"><div class="content">Good points.<p>Personally I&#x27;m still basically with Geoff Hinton&#x27;s early conjecture that people will have to choose whether they want a model that&#x27;s easy to explain or one that actually works as well as it could.<p>I&#x27;d imagine the really big whiteboard would often be understandable in principle, but most people wouldn&#x27;t be very satisfied at having the model go &quot;Jolly good. Set aside the next 25 years in your calendar then, and tell me when you&#x27;re ready to start on practicing the prerequisites!&quot;.<p>On the other hand, one might question how often we really understand something complex ostensibly &quot;explained&quot; to us, rather than just gloss over real understanding. 
A lot of the time people seem to act as if they don&#x27;t care about really knowing it, and just (hopefully!) want to get an inkling what&#x27;s involved and make sure that the process could be demonstrated not to be seriously flawed.<p>The models are being held to standards that are typically not applied to people nor to most traditional software. But sure, there are also some real issues about reliability, trust and bureaucratic certifications.</div><br/></div></div><div id="41521829" class="c"><input type="checkbox" id="c-41521829" checked=""/><div class="controls bullet"><span class="by">scarmig</span><span>|</span><a href="#41520047">root</a><span>|</span><a href="#41521115">parent</a><span>|</span><a href="#41521706">prev</a><span>|</span><a href="#41522090">next</a><span>|</span><label class="collapse" for="c-41521829">[-]</label><label class="expand" for="c-41521829">[1 more]</label></div><br/><div class="children"><div class="content">I came across &quot;Learning XOR: exploring the space of a classic problem&quot; other day: <a href="https:&#x2F;&#x2F;www.maths.stir.ac.uk&#x2F;~kjt&#x2F;techreps&#x2F;pdf&#x2F;TR148.pdf" rel="nofollow">https:&#x2F;&#x2F;www.maths.stir.ac.uk&#x2F;~kjt&#x2F;techreps&#x2F;pdf&#x2F;TR148.pdf</a><p>Even something with three units and two inputs is nontrivial to understand on a deep level.</div><br/></div></div><div id="41522090" class="c"><input type="checkbox" id="c-41522090" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#41520047">root</a><span>|</span><a href="#41521115">parent</a><span>|</span><a href="#41521829">prev</a><span>|</span><a href="#41525432">next</a><span>|</span><label class="collapse" for="c-41522090">[-]</label><label class="expand" for="c-41522090">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Are we ever really going to understand why it produces the numbers it does?</i><p>I would expect so, because we can categorize things hierarchically.<p>A medium-sized library contains many billions of words, but even with just a Dewey decimal system and a card catalog you could find information relatively quickly.<p>There&#x27;s no inherent difficulty in understanding what a billion terms do, if you&#x27;re able to just drill down using some basic hierarchies. It&#x27;s just about finding the right algorithms to identify and describe the best set of hierarchies. Which is difficult, but there&#x27;s no reason to think it won&#x27;t be solvable in the near term.</div><br/></div></div><div id="41525432" class="c"><input type="checkbox" id="c-41525432" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#41520047">root</a><span>|</span><a href="#41521115">parent</a><span>|</span><a href="#41522090">prev</a><span>|</span><a href="#41521301">next</a><span>|</span><label class="collapse" for="c-41525432">[-]</label><label class="expand" for="c-41525432">[1 more]</label></div><br/><div class="children"><div class="content">KAN&#x27;s have O(N^(-4)) scaling law where N is the number of parameters. MLPs have O(N^(-1)) scaling or worse.<p>For where you need MLP with a tens of billions of parameters you may need KAN with thousands.</div><br/></div></div><div id="41521301" class="c"><input type="checkbox" id="c-41521301" checked=""/><div class="controls bullet"><span class="by">afiori</span><span>|</span><a href="#41520047">root</a><span>|</span><a href="#41521115">parent</a><span>|</span><a href="#41525432">prev</a><span>|</span><a href="#41522229">next</a><span>|</span><label class="collapse" for="c-41521301">[-]</label><label class="expand" for="c-41521301">[1 more]</label></div><br/><div class="children"><div class="content">I found these articles very interesting in the context of future ways to understand LLM&#x2F;AIs<p><a href="https:&#x2F;&#x2F;www.astralcodexten.com&#x2F;p&#x2F;the-road-to-honest-ai" rel="nofollow">https:&#x2F;&#x2F;www.astralcodexten.com&#x2F;p&#x2F;the-road-to-honest-ai</a><p><a href="https:&#x2F;&#x2F;www.astralcodexten.com&#x2F;p&#x2F;god-help-us-lets-try-to-understand" rel="nofollow">https:&#x2F;&#x2F;www.astralcodexten.com&#x2F;p&#x2F;god-help-us-lets-try-to-und...</a></div><br/></div></div></div></div></div></div><div id="41522229" class="c"><input type="checkbox" id="c-41522229" checked=""/><div class="controls bullet"><span class="by">triclops200</span><span>|</span><a href="#41520047">prev</a><span>|</span><a href="#41521838">next</a><span>|</span><label class="collapse" for="c-41522229">[-]</label><label class="expand" for="c-41522229">[1 more]</label></div><br/><div class="children"><div class="content">The (semi) automatic simplification algorithm provided in the paper for KANs seem, to me, like they&#x27;re solving a similar problem to <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2112.04035" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2112.04035</a>, but with the additional constraint of forward functional interpretability as the goal instead of just a generalized abstraction compressor.</div><br/></div></div><div id="41521838" class="c"><input type="checkbox" id="c-41521838" checked=""/><div class="controls bullet"><span class="by">throwaway2562</span><span>|</span><a href="#41522229">prev</a><span>|</span><a href="#41521355">next</a><span>|</span><label class="collapse" for="c-41521838">[-]</label><label class="expand" for="c-41521838">[3 more]</label></div><br/><div class="children"><div class="content">The point on interpretability is scientific applications is in symbolic regression - MLPs cannot always spit out an equation for some data set: KANs can.</div><br/><div id="41522724" class="c"><input type="checkbox" id="c-41522724" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#41521838">parent</a><span>|</span><a href="#41521355">next</a><span>|</span><label class="collapse" for="c-41522724">[-]</label><label class="expand" for="c-41522724">[2 more]</label></div><br/><div class="children"><div class="content">I thought that MLPs are universal function approximators? <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universal_approximation_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universal_approximation_theore...</a></div><br/><div id="41526956" class="c"><input type="checkbox" id="c-41526956" checked=""/><div class="controls bullet"><span class="by">tomrod</span><span>|</span><a href="#41521838">root</a><span>|</span><a href="#41522724">parent</a><span>|</span><a href="#41521355">next</a><span>|</span><label class="collapse" for="c-41526956">[-]</label><label class="expand" for="c-41526956">[1 more]</label></div><br/><div class="children"><div class="content">One of the beautiful cosmic injustices about mathematics is that proofs about objects need not be constructive to prove existence.</div><br/></div></div></div></div></div></div><div id="41521355" class="c"><input type="checkbox" id="c-41521355" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#41521838">prev</a><span>|</span><a href="#41519933">next</a><span>|</span><label class="collapse" for="c-41521355">[-]</label><label class="expand" for="c-41521355">[1 more]</label></div><br/><div class="children"><div class="content">Recently discussed in <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40219205">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40219205</a></div><br/></div></div><div id="41519933" class="c"><input type="checkbox" id="c-41519933" checked=""/><div class="controls bullet"><span class="by">RustySpottedCat</span><span>|</span><a href="#41521355">prev</a><span>|</span><a href="#41520638">next</a><span>|</span><label class="collapse" for="c-41519933">[-]</label><label class="expand" for="c-41519933">[19 more]</label></div><br/><div class="children"><div class="content">Can someone explain exactly what is the &quot;unknown&quot; of neural networks? We built them, we know what they comprise of and how they work. Yes, we can&#x27;t map out every single connection between nodes in this &quot;multilayer perceptron&quot; but don&#x27;t we know how these connections are formed?</div><br/><div id="41520542" class="c"><input type="checkbox" id="c-41520542" checked=""/><div class="controls bullet"><span class="by">og_kalu</span><span>|</span><a href="#41519933">parent</a><span>|</span><a href="#41525485">next</a><span>|</span><label class="collapse" for="c-41520542">[-]</label><label class="expand" for="c-41520542">[11 more]</label></div><br/><div class="children"><div class="content">Sota LLMs like GPT-4o can natively understand b64 encoded text. Now we have algorithms that can decode and encode b64 text. Is that what GPT-4o is doing ? Did training learn that algorithm ? Clearly not or at least not completely because typos in b64 that would destroy any chance of extracting meaning in the original text for our algorithms are barely an inconvenience for 4o.<p>So how is it decoding b64 then ? We have no idea.<p>We don&#x27;t built Neural Networks. Not really. We build architectures and then train them. Whatever they learn is outside the scope of human action beyond supplying the training data.<p>What they learn is largely unknown beyond trivial toy examples.<p>We know connections form, we can see the weights, we can even see the matrices multiplying. We don&#x27;t know what any of those calculations are doing. We don&#x27;t know what they mean.<p>Would an alien understand C Code just because he could see it executing ?</div><br/><div id="41522025" class="c"><input type="checkbox" id="c-41522025" checked=""/><div class="controls bullet"><span class="by">mapt</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41520542">parent</a><span>|</span><a href="#41521685">next</a><span>|</span><label class="collapse" for="c-41522025">[-]</label><label class="expand" for="c-41522025">[2 more]</label></div><br/><div class="children"><div class="content">Our DNA didn&#x27;t build our brain.  Not really.  Our DNA coded for a loose trainable architecture with a lot of features that result from emergent design, constraints of congenital development, et cetera.  Even if you include our full exome, a bunch of environmental factors in your simulation, and are examining a human with obscenely detailed tools at autopsy, you&#x27;re never going to be able to tell me with any authenticity whether a given subject possesses the skill &#x27;skateboarding&#x27;.</div><br/><div id="41523199" class="c"><input type="checkbox" id="c-41523199" checked=""/><div class="controls bullet"><span class="by">drdeca</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41522025">parent</a><span>|</span><a href="#41521685">next</a><span>|</span><label class="collapse" for="c-41523199">[-]</label><label class="expand" for="c-41523199">[1 more]</label></div><br/><div class="children"><div class="content">I find this analogy kind of confusing? Wouldn’t the analogous thing be to say that our DNA doesn’t understand, uh, how we are able to skateboard? But like, we generally don’t regard DNA as understanding anything, so that not unexpected.<p>Where does “we can’t tell whether a person possesses the skill of ‘skateboarding’?” fit in with, DNA not encoding anything specific to skateboarding? It isn’t as if we designed our genome and therefore if our genome did hard-code skateboarding skill that we would therefore (as designers of our genome) have full understanding of how skateboarding skill works at the neuron level.<p>I recognize that a metaphor&#x2F;analogy&#x2F;whatever does not have to extend to all parts of something, and indeed most metaphors&#x2F;analogies&#x2F;whatever fail at some point if pushed too far. But, I don’t understand how the commonalities you are pointing to between [NN architecture : full NN network with the specific weights] and [human genome : the whole behavior of a person’s brain including all the facts, behaviors, etc. that they’ve learned throughout their life] is supposed to apply to the example of _knowing_that_ a person knows how to skateboard?<p>It is quite possible that I’m being dense.<p>Could you please elaborate on the analogy &#x2F; the point you are making with the analogy?</div><br/></div></div></div></div><div id="41521685" class="c"><input type="checkbox" id="c-41521685" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41520542">parent</a><span>|</span><a href="#41522025">prev</a><span>|</span><a href="#41525485">next</a><span>|</span><label class="collapse" for="c-41521685">[-]</label><label class="expand" for="c-41521685">[8 more]</label></div><br/><div class="children"><div class="content">Base64 encoding is very simple - it&#x27;s just taking each 6-bits of the input and encoding (replacing) it as one of the 64 (2^6) characters A-Za-z0-9+&#x2F;. If the input is 8-bit ASCII text, then each 3 input characters will be encoded as 4 Base64 characters (3 * 8 = 24 bits = 4 * 6-bit Base64 chunks).<p>So, this is very similar to an LLM having to deal with tokenized input, but instead of sequences of tokens representing words you&#x27;ve got sequences of Base64 characters representing words.</div><br/><div id="41522127" class="c"><input type="checkbox" id="c-41522127" checked=""/><div class="controls bullet"><span class="by">og_kalu</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41521685">parent</a><span>|</span><a href="#41525485">next</a><span>|</span><label class="collapse" for="c-41522127">[-]</label><label class="expand" for="c-41522127">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about how simple B64 is or isn&#x27;t. In fact i chose a simple problem we&#x27;ve already solved algorithmically on purpose. It&#x27;s that all you&#x27;ve just said, reasonable as it may sound is entirely speculation.<p>Maybe &quot;no idea&quot; was a bit much for this example but any idea certainly didn&#x27;t come from seeing the matrices themselves fly.</div><br/><div id="41522691" class="c"><input type="checkbox" id="c-41522691" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41522127">parent</a><span>|</span><a href="#41522283">next</a><span>|</span><label class="collapse" for="c-41522691">[-]</label><label class="expand" for="c-41522691">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not entirely true in the case of base64 because of how statistical patterns within natural languages work.  For example, you can use frequency analysis to decrypt a monoalphabetic substitution cipher on pretty much any language if you have a frequency table for character n-grams of the language, even with small numbers for n.  This is a much more shallow statistical processing than what&#x27;s going on within an LLM so I don&#x27;t think many were surprised that a transformer stack and attention heads could decode base64.  Especially if there were also examples of base64-encoding in the training data (even without parallel corpora for their encodings).<p>It doesn&#x27;t explain higher level generalizations like being a transpiler between different programming languages that didn&#x27;t have any side-by-side examples in the training data.  Or giving an answer in the voice of some celebrity.  Or being able to find entire rhyming word sequences across languages.  These are probably more like the kind of unexplainable generalizations that you were referring to.<p>I think it may be better to frame it in terms of accuracy vs precision.  Many people can explain accurately what an LLM is doing under all those matrix multiplies, both during training and inference.  But, precisely why an input leads to the resulting output is not explainable.  Being able to do that would involve &quot;seeing&quot; the shape of the hypersurface of the entire language model, which as sibling commenters have mentioned is quite difficult even when aided by probing tools.</div><br/></div></div><div id="41522283" class="c"><input type="checkbox" id="c-41522283" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41522127">parent</a><span>|</span><a href="#41522691">prev</a><span>|</span><a href="#41525485">next</a><span>|</span><label class="collapse" for="c-41522283">[-]</label><label class="expand" for="c-41522283">[5 more]</label></div><br/><div class="children"><div class="content">Huh? I just pointed out what Base64 encoding actually is - not some complex algorithm, but effectively just a tokenization scheme.<p>This isn&#x27;t speculation - I&#x27;ve implemented Base64 decode&#x2F;encode myself, and you can google for the definition if you don&#x27;t believe I&#x27;ve accurately described it!</div><br/><div id="41522321" class="c"><input type="checkbox" id="c-41522321" checked=""/><div class="controls bullet"><span class="by">og_kalu</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41522283">parent</a><span>|</span><a href="#41525485">next</a><span>|</span><label class="collapse" for="c-41522321">[-]</label><label class="expand" for="c-41522321">[4 more]</label></div><br/><div class="children"><div class="content">The speculation here is not about what b64 text is. It&#x27;s about how the LLM has learnt to process it.<p>Edit: Basically, For all anyone knows, it treats b64 as another language entirely and decoding it is akin in the network to translating French rather than the very simple swapping you&#x27;ve just described.</div><br/><div id="41523548" class="c"><input type="checkbox" id="c-41523548" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41522321">parent</a><span>|</span><a href="#41525485">next</a><span>|</span><label class="collapse" for="c-41523548">[-]</label><label class="expand" for="c-41523548">[3 more]</label></div><br/><div class="children"><div class="content">LLMs, just like all modern neural nets, are trained via gradient descent which means following the most direct path (steepest gradient on the error surface) to reduce the error, with no more changes to weights once the error gradient is zero.<p>Complexity builds upon simplicity, and the LLM will begin by noticing the direct (and repeated without variation) predictive relationship between Base64 encoded text and corresponding plain text in the training set. Having learnt this simple way to predict Base64 decoding&#x2F;encoding, there is simply no mechanism whereby it could change to a more complex &quot;like translating French&quot; way of doing it. Once the training process has discovered that Base64 text decoding can be PERFECTLY predicted by a simple mapping, then the training error will be zero and no more changes (unnecessary complexification) will take place.</div><br/><div id="41525704" class="c"><input type="checkbox" id="c-41525704" checked=""/><div class="controls bullet"><span class="by">drdeca</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41523548">parent</a><span>|</span><a href="#41525468">next</a><span>|</span><label class="collapse" for="c-41525704">[-]</label><label class="expand" for="c-41525704">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t the gradient descent used, stochastic gradient descent? I think that could matter a little bit.<p>Also, the base model when responding to base64 text, most of the time the next token is also part of the base64 text, right? So presumably the first thing to learn would be like, predicting how some base64 text continues, which, when the base64 text is an encoding of some ascii text, seems like it would involve picking up on the patterns for that?<p>I would think that there would be both those cases, and cases where the plaintext is present before or after.</div><br/></div></div><div id="41525468" class="c"><input type="checkbox" id="c-41525468" checked=""/><div class="controls bullet"><span class="by">og_kalu</span><span>|</span><a href="#41519933">root</a><span>|</span><a href="#41523548">parent</a><span>|</span><a href="#41525704">prev</a><span>|</span><a href="#41525485">next</a><span>|</span><label class="collapse" for="c-41525468">[-]</label><label class="expand" for="c-41525468">[1 more]</label></div><br/><div class="children"><div class="content">Modern Neural Networks are by no means guaranteed to converge on <i>the</i> simplest solution. and examples abound in which NNs are discovered to learn weird esoteric algorithms when simpler ones exist. The reason why is kind of obvious. The simplest solution (that you&#x27;re alluding to) from the perspective of training is simply what works best first.<p>It&#x27;s no secret the order of data has an impact on what the network learns and how quickly, it&#x27;s just not feasible to police for these giant trillion token datasets.<p>If a NN learns a more complex solution that works perfectly for a less complex subset it meets later on, there is little pressure to meet the simpler solution. Especially when we&#x27;re talking about instances where the more complex solution might be more robust to any weird permutations it might meet on the internet. e.g there is probably a simpler way to translate text that never has typos and a LLM will never converge on it.<p>Decoding&#x2F;Encoding b64 is not the first thing it will learn. It will learn to predict it first as it predicts any other language carrying sequence. Then, it will learn to translate it, mostly like long after learning how to translate other languages. All that will have some impact on the exact process it carries out with b64.<p>And like i said, we already know for a fact it&#x27;s not just doing naive substitution because it can recover corrupted b64 text wholesale that our substitutions cannot.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41525485" class="c"><input type="checkbox" id="c-41525485" checked=""/><div class="controls bullet"><span class="by">_navierstokes</span><span>|</span><a href="#41519933">parent</a><span>|</span><a href="#41520542">prev</a><span>|</span><a href="#41521220">next</a><span>|</span><label class="collapse" for="c-41525485">[-]</label><label class="expand" for="c-41525485">[1 more]</label></div><br/><div class="children"><div class="content">Skipping some detail: the model applies many high-dimensional functions to the input, and we don&#x27;t know the reasoning for why these functions solve the problem. 
Reducing the dimension of the weights to human-readable values is non-trivial, and multiple neurons interact in unpredictable ways.<p>Interpretability research has resulted in many useful results and pretty visualizations[1][2], and  there are many efforts to understand Transformers[3][4] but we&#x27;re far from being able to completely explain the large models currently in use.<p>[1] - <a href="https:&#x2F;&#x2F;distill.pub&#x2F;2018&#x2F;building-blocks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;distill.pub&#x2F;2018&#x2F;building-blocks&#x2F;</a><p>[2] - <a href="https:&#x2F;&#x2F;distill.pub&#x2F;2019&#x2F;activation-atlas&#x2F;" rel="nofollow">https:&#x2F;&#x2F;distill.pub&#x2F;2019&#x2F;activation-atlas&#x2F;</a><p>[3] - <a href="https:&#x2F;&#x2F;transformer-circuits.pub&#x2F;" rel="nofollow">https:&#x2F;&#x2F;transformer-circuits.pub&#x2F;</a><p>[4] - <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2407.02646" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2407.02646</a></div><br/></div></div><div id="41521220" class="c"><input type="checkbox" id="c-41521220" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#41519933">parent</a><span>|</span><a href="#41525485">prev</a><span>|</span><a href="#41521253">next</a><span>|</span><label class="collapse" for="c-41521220">[-]</label><label class="expand" for="c-41521220">[1 more]</label></div><br/><div class="children"><div class="content">We know how they are formed(and how to form them),  we don&#x27;t know why forming in that particular way solves the problem at hand.<p>Even this characterization is not strictly valid anymore,  there is a great deal of research into what&#x27;s going on inside the black box.   The problem was never that it was a black box(we can look inside at any time), but that it was hard to understand.  KANs help some of that be placed into mathematical formulation. Generating mappings of activations over data similarly grants insight.</div><br/></div></div><div id="41521253" class="c"><input type="checkbox" id="c-41521253" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#41519933">parent</a><span>|</span><a href="#41521220">prev</a><span>|</span><a href="#41521186">next</a><span>|</span><label class="collapse" for="c-41521253">[-]</label><label class="expand" for="c-41521253">[1 more]</label></div><br/><div class="children"><div class="content">* Given the training data, and the architecture of the network, why does SGD with backprop find the given f?  vs. any other of an infinite set.<p>* Why are there are a set of f each with 0-loss that work?<p>* Given the weight space, and an f within it, why&#x2F;when is a task&#x2F;skill defined as a subset of that space covered by f?<p>I think a major reasons why these are hard to answer is that it&#x27;s assumed that NNs are operating within an inferential statistical context (ie., reversing some latent structure in the data). But they&#x27;re really bad at that. In my view, they are just representation-builders that find proxy representations in a proxy &quot;task&quot; space (def, aprox, proxy = &quot;shadow of some real structure, as captured in an unrelated space&quot;).</div><br/></div></div><div id="41521186" class="c"><input type="checkbox" id="c-41521186" checked=""/><div class="controls bullet"><span class="by">spencerchubb</span><span>|</span><a href="#41519933">parent</a><span>|</span><a href="#41521253">prev</a><span>|</span><a href="#41520094">next</a><span>|</span><label class="collapse" for="c-41521186">[-]</label><label class="expand" for="c-41521186">[1 more]</label></div><br/><div class="children"><div class="content">We know the process to train a model, but when a model makes a prediction we don&#x27;t know exactly &quot;how&quot; it predicts the way it does.<p>We can use the economy as an analogy. No single person really understands the whole supply chain. But we know that each person in the supply chain is trying to maximize their own profit, and that ultimately delivers goods and services to a consumer.</div><br/></div></div><div id="41520094" class="c"><input type="checkbox" id="c-41520094" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41519933">parent</a><span>|</span><a href="#41521186">prev</a><span>|</span><a href="#41520358">next</a><span>|</span><label class="collapse" for="c-41520094">[-]</label><label class="expand" for="c-41520094">[1 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t know what each connection means, what information is encoded in each weight. We don&#x27;t know how it would behave differently if each of the million or trillion weights was changed.<p>Compare this to dictionaey, where it&#x27;s obvious what information is on each page and each line.</div><br/></div></div><div id="41520358" class="c"><input type="checkbox" id="c-41520358" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#41519933">parent</a><span>|</span><a href="#41520094">prev</a><span>|</span><a href="#41520087">next</a><span>|</span><label class="collapse" for="c-41520358">[-]</label><label class="expand" for="c-41520358">[1 more]</label></div><br/><div class="children"><div class="content">The brain serves as a useful analogy, even though LLMs are not brains. Just as we can’t fully understand how we think by merely examining all of our neurons, understanding LLMs requires more than analyzing their individual components, though decoding LLMs is most likely easier, which doesn&#x27;t mean easy.</div><br/></div></div><div id="41520087" class="c"><input type="checkbox" id="c-41520087" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#41519933">parent</a><span>|</span><a href="#41520358">prev</a><span>|</span><a href="#41520638">next</a><span>|</span><label class="collapse" for="c-41520087">[-]</label><label class="expand" for="c-41520087">[1 more]</label></div><br/><div class="children"><div class="content">There’s a ton of research going into analysing and reverse engineering NNs, this “they’re mysterious black boxes and forever inscrutable” narrative is outdated.</div><br/></div></div></div></div><div id="41520638" class="c"><input type="checkbox" id="c-41520638" checked=""/><div class="controls bullet"><span class="by">empath75</span><span>|</span><a href="#41519933">prev</a><span>|</span><a href="#41528374">next</a><span>|</span><label class="collapse" for="c-41520638">[-]</label><label class="expand" for="c-41520638">[5 more]</label></div><br/><div class="children"><div class="content">I have a question, which might not even be related to this -- one of the keys to the power of neural networks is exploiting the massive parallelism enabled by GPUs, but are we leaving some compute on the table by using just scalar weights?  What if instead of a matrices of weights, what if they were matrices of functions?</div><br/><div id="41521312" class="c"><input type="checkbox" id="c-41521312" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#41520638">parent</a><span>|</span><a href="#41521222">next</a><span>|</span><label class="collapse" for="c-41521312">[-]</label><label class="expand" for="c-41521312">[1 more]</label></div><br/><div class="children"><div class="content">They way to think about NNs is that they are already made of functions; groups of layered nodes become complex nonlinear functions. For example a small 3-layer network can learn to model a cubic spline function. The internals of the function are learned at every step of the way; every addition and multiplication. You can assume the number of functions in a network is a fraction of the number of weights.  This makes the NN theoretically more flexible and powerful than modeling it using more complex functions, because it learns and adapts each and every function during training.<p>I would assume its possible using certain functions to, say, model a small fixed-function MLP could perhaps result in more efficient training, if we know the right functions to use. But you could end up losing perf too if not careful. I’d guess the main problems are we don’t know what functions to use, and adding nonlinear functions might come with added difficultly wrt performance and precision and new modes of initialization and normalization. Linear math is easy and powerful and already capable of modeling complex functions, but nonlinear math might be useful I’d guess… needs more study! ;)</div><br/></div></div><div id="41521222" class="c"><input type="checkbox" id="c-41521222" checked=""/><div class="controls bullet"><span class="by">mglz</span><span>|</span><a href="#41520638">parent</a><span>|</span><a href="#41521312">prev</a><span>|</span><a href="#41523154">next</a><span>|</span><label class="collapse" for="c-41521222">[-]</label><label class="expand" for="c-41521222">[1 more]</label></div><br/><div class="children"><div class="content">GPUs are optimized for matrices of floating point values, so current neural networks use this as a basis (with matrices containing the scalar weights).</div><br/></div></div><div id="41523154" class="c"><input type="checkbox" id="c-41523154" checked=""/><div class="controls bullet"><span class="by">ocular-rockular</span><span>|</span><a href="#41520638">parent</a><span>|</span><a href="#41521222">prev</a><span>|</span><a href="#41521274">next</a><span>|</span><label class="collapse" for="c-41523154">[-]</label><label class="expand" for="c-41523154">[1 more]</label></div><br/><div class="children"><div class="content">What you&#x27;re describing is very similar to deep Gaussian processes.</div><br/></div></div><div id="41521274" class="c"><input type="checkbox" id="c-41521274" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41520638">parent</a><span>|</span><a href="#41523154">prev</a><span>|</span><a href="#41528374">next</a><span>|</span><label class="collapse" for="c-41521274">[-]</label><label class="expand" for="c-41521274">[1 more]</label></div><br/><div class="children"><div class="content">Each row&#x2F;column (I always forget which way around matrices go) of weights followed by a nonlinearity is a learnable function.</div><br/></div></div></div></div><div id="41519745" class="c"><input type="checkbox" id="c-41519745" checked=""/><div class="controls bullet"><span class="by">itsthecourier</span><span>|</span><a href="#41524567">prev</a><span>|</span><a href="#41521438">next</a><span>|</span><label class="collapse" for="c-41519745">[-]</label><label class="expand" for="c-41519745">[2 more]</label></div><br/><div class="children"><div class="content">TL;DR: they are talking about KAN (Kolmogorov-Arnold networks)</div><br/><div id="41520744" class="c"><input type="checkbox" id="c-41520744" checked=""/><div class="controls bullet"><span class="by">weberer</span><span>|</span><a href="#41519745">parent</a><span>|</span><a href="#41521438">next</a><span>|</span><label class="collapse" for="c-41520744">[-]</label><label class="expand" for="c-41520744">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Thankfully, HN updated the title to be more descriptive. (Old title was &quot;Novel Architecture Makes Neural Networks More Understandable&quot;)</div><br/></div></div></div></div><div id="41519934" class="c"><input type="checkbox" id="c-41519934" checked=""/><div class="controls bullet"><span class="by">xiaodai</span><span>|</span><a href="#41521438">prev</a><span>|</span><a href="#41521834">next</a><span>|</span><label class="collapse" for="c-41519934">[-]</label><label class="expand" for="c-41519934">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t that&#x27;s the problem</div><br/></div></div><div id="41521834" class="c"><input type="checkbox" id="c-41521834" checked=""/><div class="controls bullet"><span class="by">IWeldMelons</span><span>|</span><a href="#41519934">prev</a><span>|</span><a href="#41522037">next</a><span>|</span><label class="collapse" for="c-41521834">[-]</label><label class="expand" for="c-41521834">[2 more]</label></div><br/><div class="children"><div class="content">Fad.</div><br/><div id="41525569" class="c"><input type="checkbox" id="c-41525569" checked=""/><div class="controls bullet"><span class="by">CamperBob2</span><span>|</span><a href="#41521834">parent</a><span>|</span><a href="#41522037">next</a><span>|</span><label class="collapse" for="c-41525569">[-]</label><label class="expand" for="c-41525569">[1 more]</label></div><br/><div class="children"><div class="content">What evidence would change your mind?</div><br/></div></div></div></div><div id="41522037" class="c"><input type="checkbox" id="c-41522037" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#41521834">prev</a><span>|</span><label class="collapse" for="c-41522037">[-]</label><label class="expand" for="c-41522037">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t what KANs are, but from the informal description in the article &quot;turn function on many variables into many functions of single variable&quot;, it sounds reminiscent of lambda calculus.</div><br/><div id="41522826" class="c"><input type="checkbox" id="c-41522826" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#41522037">parent</a><span>|</span><label class="collapse" for="c-41522826">[-]</label><label class="expand" for="c-41522826">[1 more]</label></div><br/><div class="children"><div class="content">Nope, that&#x27;s just currying and&#x2F;or partial application.</div><br/></div></div></div></div></div></div></div></div></div></body></html>