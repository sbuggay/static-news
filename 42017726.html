<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730538068481" as="style"/><link rel="stylesheet" href="styles.css?v=1730538068481"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lisyarus.github.io/blog/posts/implementing-a-tiny-cpu-rasterizer.html">Implementing a Tiny CPU Rasterizer</a>Â <span class="domain">(<a href="https://lisyarus.github.io">lisyarus.github.io</a>)</span></div><div class="subtext"><span>atan2</span> | <span>14 comments</span></div><br/><div><div id="42022556" class="c"><input type="checkbox" id="c-42022556" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42023597">next</a><span>|</span><label class="collapse" for="c-42022556">[-]</label><label class="expand" for="c-42022556">[2 more]</label></div><br/><div class="children"><div class="content">Nostalgia flashback. Anyone else implemented a renderer based on fatmap2.txt[1]?<p>I came up with my own approach using bresenham and storing spans, but it was slow and sucked.<p>Then my buddy found fatmap2.txt on a BBS and gave it to me, as I didn&#x27;t have a modem at the time. It was a revelation.<p>Programming in Turbo Pascal I was hampered by it being 16bit, but discovered I could prepend the assembly opcodes with 66h to turn them into 32bit instructions.<p>Later I tried converting the code to C, being only 300 lines and at that point well understood I figured it was a good task to get started with C. I was self-taught at programming but had read enough C to feel confident enough to try.<p>Converted it all line by line to C before compiling... and got literally over 3000 errors and warnings, and none of them made any sense.<p>Discouraged I left it, but a week later I was determined to get it working. After a few hours staring and bashing my head against the wall, I saw that the constant for the texture width which I had converted to a #define in C, had a semi-colon at the end...<p>So I removed it, and voila it complied flawlessly...<p>Only later did I realize my C compiler, djgpp, was actually a C++ compiler and that&#x27;s probably why I got so many seemingly weird errors.<p>Anyway, good times...<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;rcoscali&#x2F;ftke&#x2F;blob&#x2F;master&#x2F;ogles&#x2F;doc&#x2F;fatmap2.txt">https:&#x2F;&#x2F;github.com&#x2F;rcoscali&#x2F;ftke&#x2F;blob&#x2F;master&#x2F;ogles&#x2F;doc&#x2F;fatma...</a></div><br/><div id="42024816" class="c"><input type="checkbox" id="c-42024816" checked=""/><div class="controls bullet"><span class="by">ggambetta</span><span>|</span><a href="#42022556">parent</a><span>|</span><a href="#42023597">next</a><span>|</span><label class="collapse" for="c-42024816">[-]</label><label class="expand" for="c-42024816">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I ever came across fatmap2.txt, but I do miss the good ol&#x27; times. I think my reference was 3DGPL, unfortunately can&#x27;t find a live link to that.<p>Took a quick look at fatmap2 and surprisingly it doesn&#x27;t do perspective-correct texture mapping (although it points to some other document in the introduction).</div><br/></div></div></div></div><div id="42023597" class="c"><input type="checkbox" id="c-42023597" checked=""/><div class="controls bullet"><span class="by">erwincoumans</span><span>|</span><a href="#42022556">prev</a><span>|</span><a href="#42022638">next</a><span>|</span><label class="collapse" for="c-42023597">[-]</label><label class="expand" for="c-42023597">[1 more]</label></div><br/><div class="children"><div class="content">If you like this, there is also the 500 lines of C++ TinyRenderer, loading Obj files, texture mapping, clipping, and vertex&#x2F;pixel shaders on CPU only: <a href="https:&#x2F;&#x2F;github.com&#x2F;ssloy&#x2F;tinyrenderer">https:&#x2F;&#x2F;github.com&#x2F;ssloy&#x2F;tinyrenderer</a></div><br/></div></div><div id="42022638" class="c"><input type="checkbox" id="c-42022638" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42023597">prev</a><span>|</span><a href="#42020322">next</a><span>|</span><label class="collapse" for="c-42022638">[-]</label><label class="expand" for="c-42022638">[1 more]</label></div><br/><div class="children"><div class="content">I was super into this sort of thing until I hit triangle clipping concerns in homogeneous coordinate space.<p>Filling the triangle and spinning the cube are the perfect level of difficulty if you want to get your hands a bit dirty and achieve that sense of accomplishment. Anything beyond this starts to feel like a very risky time-reward tradeoff.</div><br/></div></div><div id="42020322" class="c"><input type="checkbox" id="c-42020322" checked=""/><div class="controls bullet"><span class="by">Cieric</span><span>|</span><a href="#42022638">prev</a><span>|</span><a href="#42021026">next</a><span>|</span><label class="collapse" for="c-42020322">[-]</label><label class="expand" for="c-42020322">[2 more]</label></div><br/><div class="children"><div class="content">I love looking at stuff like this, working in the GPU space has only ever renewed my ambitions to work on similar projects. The hardest thing I always ran into with the more optimized fill algorithms was working around the single pixel holes that appear when doing everything with integers.<p>Small nitpick though, there seems to be an issue with the source code views, the file names and the first line of the code are on the same line with no spacing. looks like it might be a static site generation issue since there aren&#x27;t any nodes to separate the name and the code in the raw html.<p>Edit: turns out the issue I&#x27;m seeing is somehow due to Firefox, seems to work correctly in edge.</div><br/><div id="42022635" class="c"><input type="checkbox" id="c-42022635" checked=""/><div class="controls bullet"><span class="by">jfk13</span><span>|</span><a href="#42020322">parent</a><span>|</span><a href="#42021026">next</a><span>|</span><label class="collapse" for="c-42022635">[-]</label><label class="expand" for="c-42022635">[1 more]</label></div><br/><div class="children"><div class="content">It looks like for some reason Firefox isn&#x27;t being served the same source as Safari or Chrome. In those browsers, the filename is wrapped in &lt;center&gt;, &lt;a&gt;, and &lt;tt&gt; elements, and followed by &lt;hr&gt; &lt;br&gt;.<p>But in the version of the HTML that Firefox receives, all that is missing and the filename is just some text that ends up immediately in front of the first line of code.</div><br/></div></div></div></div><div id="42021026" class="c"><input type="checkbox" id="c-42021026" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#42020322">prev</a><span>|</span><label class="collapse" for="c-42021026">[-]</label><label class="expand" for="c-42021026">[7 more]</label></div><br/><div class="children"><div class="content">Wait, what?  They rasterize a triangle by checking <i>for each pixel</i> if it intersects with the triangle?  Where are the days when you learned Bresenham [1] or fixed-point arithmetic [2] to determine the extents of a scan line, and then fill it with an ordinary for-loop?<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bresenham%27s_line_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bresenham%27s_line_algorithm</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fixed-point_arithmetic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fixed-point_arithmetic</a></div><br/><div id="42021138" class="c"><input type="checkbox" id="c-42021138" checked=""/><div class="controls bullet"><span class="by">cv5005</span><span>|</span><a href="#42021026">parent</a><span>|</span><a href="#42021100">next</a><span>|</span><label class="collapse" for="c-42021138">[-]</label><label class="expand" for="c-42021138">[2 more]</label></div><br/><div class="children"><div class="content">The thing is that modern computer architecture strikes again - like the old linked list vs array thing.<p>Doing a candidate loop over a bounding box with edge equations can be much faster than ye old scanline algorithm because it lends itself more easily to simd and parallel approches - you can divide things up into tiles and process multiple pixels at a time with wide instructions and schedule tiles on multiple threads.</div><br/><div id="42022008" class="c"><input type="checkbox" id="c-42022008" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#42021026">root</a><span>|</span><a href="#42021138">parent</a><span>|</span><a href="#42021100">next</a><span>|</span><label class="collapse" for="c-42022008">[-]</label><label class="expand" for="c-42022008">[1 more]</label></div><br/><div class="children"><div class="content">For those not in the know, things only get faster with this approach when you apply some optimization.  The article that we are discussing won&#x27;t get there until part 12.<p>For the time being one may consult Ryg&#x27;s amazing blog series: <a href="https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2013&#x2F;02&#x2F;10&#x2F;optimizing-the-basic-rasterizer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2013&#x2F;02&#x2F;10&#x2F;optimizing-the-basi...</a></div><br/></div></div></div></div><div id="42021100" class="c"><input type="checkbox" id="c-42021100" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#42021026">parent</a><span>|</span><a href="#42021138">prev</a><span>|</span><a href="#42022834">next</a><span>|</span><label class="collapse" for="c-42021100">[-]</label><label class="expand" for="c-42021100">[1 more]</label></div><br/><div class="children"><div class="content">Checking every pixel is generally faster on modern hardware due to SIMD! Of course youâll need to clip properly.<p>There are some pathological cases, like a thin long almost diagonal triangles. But those (rare) cases can be handled too by some subdivision clipping.</div><br/></div></div><div id="42022834" class="c"><input type="checkbox" id="c-42022834" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#42021026">parent</a><span>|</span><a href="#42021100">prev</a><span>|</span><a href="#42021304">next</a><span>|</span><label class="collapse" for="c-42022834">[-]</label><label class="expand" for="c-42022834">[1 more]</label></div><br/><div class="children"><div class="content">There used to be a series of articles similar to this one that did things that way as well.  As I recall, the author was making swiftshader, which I think was acquired by RAD Game Tools, then the articles got bitrot and eventually disappeared.</div><br/></div></div><div id="42021304" class="c"><input type="checkbox" id="c-42021304" checked=""/><div class="controls bullet"><span class="by">ehaliewicz2</span><span>|</span><a href="#42021026">parent</a><span>|</span><a href="#42022834">prev</a><span>|</span><label class="collapse" for="c-42021304">[-]</label><label class="expand" for="c-42021304">[2 more]</label></div><br/><div class="children"><div class="content">Those were the 90s.  Modern rasterizers* all use barycentric coordinate based algorithms for a few reasons.<p>Easier to implement with proper fill conventions and multisampling, and much easier to parallelize in hardware and software.<p>* Hardware even back in the 90s used this type of approach :)</div><br/><div id="42021433" class="c"><input type="checkbox" id="c-42021433" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#42021026">root</a><span>|</span><a href="#42021304">parent</a><span>|</span><label class="collapse" for="c-42021433">[-]</label><label class="expand" for="c-42021433">[1 more]</label></div><br/><div class="children"><div class="content">We use barycentric (both in high performance software rasterizers and in hardware) because attribute interpolation is significantly more costly than in-bounds checking (both due to the total number of interpolates, and the precision). The in-bounds check is going to be just a few instructions (a few fmas and some sign checking) for two dimensions (x, y); whereas attribute interpolation could be needed for 30â128 &#x27;dimensions&#x27;. It&#x27;s easier to push the interpolation to the use-site in the fragment shader, and let the compiler do its magic.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>