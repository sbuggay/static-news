<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695286863102" as="style"/><link rel="stylesheet" href="styles.css?v=1695286863102"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jensrantil.github.io/posts/fast-aggregate-queries-on-dynamic-data/">Fine-grained caching strategies of dynamic queries</a>Â <span class="domain">(<a href="https://jensrantil.github.io">jensrantil.github.io</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>3 comments</span></div><br/><div><div id="37594742" class="c"><input type="checkbox" id="c-37594742" checked=""/><div class="controls bullet"><span class="by">macca321</span><span>|</span><a href="#37594703">next</a><span>|</span><label class="collapse" for="c-37594742">[-]</label><label class="expand" for="c-37594742">[1 more]</label></div><br/><div class="children"><div class="content">About 15 years ago I implemented &quot;cache namespacing&quot; for memcached, where you build a final cache key for a stored item (e.g. &quot;profile_page&quot;) by doing an initial multiget cache query for all the &quot;namespace&quot; version values (e.g &quot;user_123&quot;, &quot;team_456&quot; might be needed for &quot;profile_page&quot;), which you combine together as a prefix for the final cache key.<p>You can then invalidate any final cache key that uses one of the namespaces by incrementing the namespace key.<p>I haven&#x27;t come across this technique mentioned elsewhere since, but it&#x27;s very useful.<p>See the namespaces section in the now 404ing memcached FAQ
<a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20090227062915&#x2F;http:&#x2F;&#x2F;code.google.com&#x2F;p&#x2F;memcached&#x2F;wiki&#x2F;FAQ" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20090227062915&#x2F;http:&#x2F;&#x2F;code.googl...</a><p>I guess nosql, edge caching and materialised views make it less applicable than it used to be (when inelastically scaling single&#x2F;replicated SQL instances were the only game in town and taking load off them was vital).<p>Or is this technique now a first class feature of various cache client SDKs?</div><br/></div></div><div id="37594703" class="c"><input type="checkbox" id="c-37594703" checked=""/><div class="controls bullet"><span class="by">m104</span><span>|</span><a href="#37594742">prev</a><span>|</span><label class="collapse" for="c-37594703">[-]</label><label class="expand" for="c-37594703">[1 more]</label></div><br/><div class="children"><div class="content">One aspect of this type of problem I missed from the article is whether the data mutations were applied evenly across transaction time. Data sets like these tend to be very active for recent transactions, while the updates fall off quickly as the data ages. If that&#x27;s the case, applying a single query caching solution may not be a good fit and may always suffer from major tuning&#x2F;balance issues.<p>If the data is in fact updated with clear hot&#x2F;warm&#x2F;cold sets, caching the cold sets should be extremely effective, the warm set moderately effective, and it may not even be worth caching the hot set at all, given the complexity proposed. Additionally, you should be able to offload the cold sets to persistent blob storage, away from your main database, and bulk load them as needed.<p>Finally, it can be faster and simpler to keep track of deltas to cold sets (late mutations that happen to &quot;invalidate&quot; the previously immutable data), by simply storing those updates in a separate table, loading the cold set data, and applying the delta corrections in code as an overlay when queried. Cron jobs can read those deltas, and fold them back into the cold set aggregations, making clean validated cold set data again.<p>Great article, BTW! There are entire database technologies and product dedicated to addressing these use cases, particularly as the data sets grow very large.</div><br/></div></div></div></div></div></div></div></body></html>