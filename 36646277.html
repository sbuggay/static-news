<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688893260983" as="style"/><link rel="stylesheet" href="styles.css?v=1688893260983"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://forum.ulisp.com/t/an-arm-assembler-written-in-lisp/1237">An ARM Assembler Written in Lisp</a> <span class="domain">(<a href="http://forum.ulisp.com">forum.ulisp.com</a>)</span></div><div class="subtext"><span>chrisjj</span> | <span>33 comments</span></div><br/><div><div id="36647475" class="c"><input type="checkbox" id="c-36647475" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#36646832">next</a><span>|</span><label class="collapse" for="c-36647475">[-]</label><label class="expand" for="c-36647475">[10 more]</label></div><br/><div class="children"><div class="content">A lot of lisps end up writing their own assemblers, the lisp model of 80&#x2F;20ing your own compiler with every compiler step being a different set of s-expressions as sorts of intermediate representations works best holistically.  On the old lisp machines even the microcode source would be specific s-expressions that as a final pass would be converted into the actual bit pattern needed by the machine.<p>This paradigm is well seen in the GOAL (Game Oriented Assembly Lisp) code for Jak &amp; Daxter that could mix relatively standard lisp, MIPS asm, and PS2 custom vector asm all within the same function: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20070127022728&#x2F;http:&#x2F;&#x2F;lists.midnightryder.com&#x2F;pipermail&#x2F;sweng-gamedev-midnightryder.com&#x2F;2005-August&#x2F;003804.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20070127022728&#x2F;http:&#x2F;&#x2F;lists.midn...</a></div><br/><div id="36648500" class="c"><input type="checkbox" id="c-36648500" checked=""/><div class="controls bullet"><span class="by">rprospero</span><span>|</span><a href="#36647475">parent</a><span>|</span><a href="#36648030">next</a><span>|</span><label class="collapse" for="c-36648500">[-]</label><label class="expand" for="c-36648500">[8 more]</label></div><br/><div class="children"><div class="content">Thank you for the explanation about the microcode. Many years ago, someone was explaining to me that Lisp machines were Lisp “all the way down”.  There were no layers that you couldn’t reprogram with Lisp.  When pressed for details, he claimed that even the band gap potential in the transistors of the machine could be reprogrammed, because the transistors were just an abstraction over more Lisp.<p>Your explanation makes far more sense.</div><br/><div id="36648808" class="c"><input type="checkbox" id="c-36648808" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36647475">root</a><span>|</span><a href="#36648500">parent</a><span>|</span><a href="#36648030">next</a><span>|</span><label class="collapse" for="c-36648808">[-]</label><label class="expand" for="c-36648808">[7 more]</label></div><br/><div class="children"><div class="content">In the early days the CPUs had loadable microcode. With new operating system versions came language extensions for Lisp. Then one also got a new version of the microcode, which then had been extended for, say, inclusion of an instruction for OOP method dispatch. One also could compile some code to microcode.<p>Later the CPUs were actually Microprocessors (from TI and Symbolics). At least for the Symbolics Ivory microprocessor, the microcode no longer was loadable.</div><br/><div id="36652344" class="c"><input type="checkbox" id="c-36652344" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36647475">root</a><span>|</span><a href="#36648808">parent</a><span>|</span><a href="#36651681">next</a><span>|</span><label class="collapse" for="c-36652344">[-]</label><label class="expand" for="c-36652344">[5 more]</label></div><br/><div class="children"><div class="content">Ironically we are back to loaded microcode and memory tagging.<p>The turns the world does instead of adopting good ideas from the get go.</div><br/><div id="36652404" class="c"><input type="checkbox" id="c-36652404" checked=""/><div class="controls bullet"><span class="by">msk-lywenn</span><span>|</span><a href="#36647475">root</a><span>|</span><a href="#36652344">parent</a><span>|</span><a href="#36651681">next</a><span>|</span><label class="collapse" for="c-36652404">[-]</label><label class="expand" for="c-36652404">[4 more]</label></div><br/><div class="children"><div class="content">What kind of memory tagging are you referring to? I can think of W^X, but I don&#x27;t see how well it compares to lisp stuff.</div><br/><div id="36652635" class="c"><input type="checkbox" id="c-36652635" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36647475">root</a><span>|</span><a href="#36652404">parent</a><span>|</span><a href="#36652786">next</a><span>|</span><label class="collapse" for="c-36652635">[-]</label><label class="expand" for="c-36652635">[2 more]</label></div><br/><div class="children"><div class="content">I can put on my ‘pjmlp hat and talk about how SPARC ADI is being reborn today as CHERI and MTE.</div><br/><div id="36652713" class="c"><input type="checkbox" id="c-36652713" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36647475">root</a><span>|</span><a href="#36652635">parent</a><span>|</span><a href="#36652786">next</a><span>|</span><label class="collapse" for="c-36652713">[-]</label><label class="expand" for="c-36652713">[1 more]</label></div><br/><div class="children"><div class="content">:)</div><br/></div></div></div></div><div id="36652786" class="c"><input type="checkbox" id="c-36652786" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36647475">root</a><span>|</span><a href="#36652404">parent</a><span>|</span><a href="#36652635">prev</a><span>|</span><a href="#36651681">next</a><span>|</span><label class="collapse" for="c-36652786">[-]</label><label class="expand" for="c-36652786">[1 more]</label></div><br/><div class="children"><div class="content">Armv8.5-A Memory Tagging Extension (MTE)?</div><br/></div></div></div></div></div></div><div id="36651681" class="c"><input type="checkbox" id="c-36651681" checked=""/><div class="controls bullet"><span class="by">r9550684</span><span>|</span><a href="#36647475">root</a><span>|</span><a href="#36648808">parent</a><span>|</span><a href="#36652344">prev</a><span>|</span><a href="#36648030">next</a><span>|</span><label class="collapse" for="c-36651681">[-]</label><label class="expand" for="c-36651681">[1 more]</label></div><br/><div class="children"><div class="content">don&#x27;t forget that besides microcode much of the lisp machine logic was implemented with PALs, which were themselves programmed in Lisp. the simple gates, mixers and flip-flops were describe with lisp code, so that the logic could be tested on the lisp machine. I don&#x27;t know if they built the test tables using the lisp code, or wrote them out manually, but you essentially had multiple sources of truth that could be mutually verified: lisp code, test tables, and the behavior of the specific PAL.</div><br/></div></div></div></div></div></div><div id="36648030" class="c"><input type="checkbox" id="c-36648030" checked=""/><div class="controls bullet"><span class="by">senkora</span><span>|</span><a href="#36647475">parent</a><span>|</span><a href="#36648500">prev</a><span>|</span><a href="#36646832">next</a><span>|</span><label class="collapse" for="c-36648030">[-]</label><label class="expand" for="c-36648030">[1 more]</label></div><br/><div class="children"><div class="content">Also seen in the nanopass compiler framework: <a href="http:&#x2F;&#x2F;nanopass.org&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;nanopass.org&#x2F;</a></div><br/></div></div></div></div><div id="36646832" class="c"><input type="checkbox" id="c-36646832" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#36647475">prev</a><span>|</span><a href="#36646708">next</a><span>|</span><label class="collapse" for="c-36646832">[-]</label><label class="expand" for="c-36646832">[4 more]</label></div><br/><div class="children"><div class="content">In their twilight years Symbolics implemented their own DEC Alpha assembler in Common Lisp to aid the development of their Lisp machine emulator: <a href="http:&#x2F;&#x2F;pt.withy.org&#x2F;publications&#x2F;VLM.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;pt.withy.org&#x2F;publications&#x2F;VLM.html</a><p>You can still find its leaked source code on the internet.<p>&quot;We built a prototype of the emulator in C, but it quickly became obvious that we could not achieve the level of performance desired in C. Examination of code emitted by the C compiler showed it took very poor advantage of the Alpha&#x27;s dual-issue capabilities. A second implementation was done in Alpha assembly language and is the basis for the current product.<p>We built a number of tools (in Lisp, running on Genera) that supported the level of complexity of the assembly language program we were attempting. A translator was built that allowed us to use Lisp as a macro language. One of the primary benefits of using Lisp was that we could use all our normal development tools, including incremental patching, even though we were working in another machine&#x27;s assembly language. Even more beneficial, however, was that early on in the project, we were able to easily graft on to the translator a cycle-counting tool that allowed one to easily and automatically &quot;preview&quot; any code fragment and see its total cycle cost, dual-issues that were taken or missed, and any free stall slots. Because this tool was integrated directly with the Genera editor, we were able to pro-actively optimize our code, right from the start. The full paper describes this tool in more detail, with examples, and compares it with tools that have recently become available from DEC that attempt to automatically re-organize executable files. It is our claim that our tool, because of its interactive nature, offers many more opportunities for optimization.&quot;</div><br/><div id="36647119" class="c"><input type="checkbox" id="c-36647119" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36646832">parent</a><span>|</span><a href="#36649438">next</a><span>|</span><label class="collapse" for="c-36647119">[-]</label><label class="expand" for="c-36647119">[1 more]</label></div><br/><div class="children"><div class="content">The Genera code for ARM64 and Intel 86-64 is also written that way.<p>Clozure CL should also include an inline assembler.<p>Lisp assemblers date back to the 60s.</div><br/></div></div><div id="36649438" class="c"><input type="checkbox" id="c-36649438" checked=""/><div class="controls bullet"><span class="by">jdontillman</span><span>|</span><a href="#36646832">parent</a><span>|</span><a href="#36647119">prev</a><span>|</span><a href="#36647071">next</a><span>|</span><label class="collapse" for="c-36649438">[-]</label><label class="expand" for="c-36649438">[1 more]</label></div><br/><div class="children"><div class="content">In their earlier years, the Symbolics 3600 series machines included a Motorola 68K series Front End Processor (the &quot;FEP&quot;) for booting the main processor.  And the assembler for that was written in Lisp.</div><br/></div></div><div id="36647071" class="c"><input type="checkbox" id="c-36647071" checked=""/><div class="controls bullet"><span class="by">abecedarius</span><span>|</span><a href="#36646832">parent</a><span>|</span><a href="#36649438">prev</a><span>|</span><a href="#36646708">next</a><span>|</span><label class="collapse" for="c-36647071">[-]</label><label class="expand" for="c-36647071">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of the predecessor for this 6502 assembler: <a href="https:&#x2F;&#x2F;www.pagetable.com&#x2F;?p=848" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pagetable.com&#x2F;?p=848</a> -- the comments include a note by the author, Chip Morningstar of Habitat, saying the Lisp assembler was terribly slow on a VAX.</div><br/></div></div></div></div><div id="36646708" class="c"><input type="checkbox" id="c-36646708" checked=""/><div class="controls bullet"><span class="by">nathell</span><span>|</span><a href="#36646832">prev</a><span>|</span><a href="#36647833">next</a><span>|</span><label class="collapse" for="c-36646708">[-]</label><label class="expand" for="c-36646708">[7 more]</label></div><br/><div class="children"><div class="content">I once wrote a rudimentary x86 assembler in about 250 lines of Clojure:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nathell&#x2F;lithium&#x2F;blob&#x2F;master&#x2F;src&#x2F;lithium&#x2F;assembler.clj">https:&#x2F;&#x2F;github.com&#x2F;nathell&#x2F;lithium&#x2F;blob&#x2F;master&#x2F;src&#x2F;lithium&#x2F;a...</a><p>In general, I find that s-expressions are actually a nice syntax for assembly languages. For x86, they kind of sidestep the AT&amp;T vs. Intel conundrum, and you get to write macro-like functions in the host Lisp that compile down to s-expressions.</div><br/><div id="36647400" class="c"><input type="checkbox" id="c-36647400" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36646708">parent</a><span>|</span><a href="#36647833">next</a><span>|</span><label class="collapse" for="c-36647400">[-]</label><label class="expand" for="c-36647400">[6 more]</label></div><br/><div class="children"><div class="content">doesn&#x27;t clang use a sexp like notation for some IR ?</div><br/><div id="36649265" class="c"><input type="checkbox" id="c-36649265" checked=""/><div class="controls bullet"><span class="by">excircul</span><span>|</span><a href="#36646708">root</a><span>|</span><a href="#36647400">parent</a><span>|</span><a href="#36651109">next</a><span>|</span><label class="collapse" for="c-36649265">[-]</label><label class="expand" for="c-36649265">[1 more]</label></div><br/><div class="children"><div class="content">GCC’s RTL does<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gccint&#x2F;RTL.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gccint&#x2F;RTL.html</a></div><br/></div></div><div id="36651109" class="c"><input type="checkbox" id="c-36651109" checked=""/><div class="controls bullet"><span class="by">muricula</span><span>|</span><a href="#36646708">root</a><span>|</span><a href="#36647400">parent</a><span>|</span><a href="#36649265">prev</a><span>|</span><a href="#36651821">next</a><span>|</span><label class="collapse" for="c-36651109">[-]</label><label class="expand" for="c-36651109">[1 more]</label></div><br/><div class="children"><div class="content">Clang&#x27;s ir is more c like. I can&#x27;t find a link to a good example offhand, but if you pass the right combinations of flags to clang you can dump it.</div><br/></div></div><div id="36651821" class="c"><input type="checkbox" id="c-36651821" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36646708">root</a><span>|</span><a href="#36647400">parent</a><span>|</span><a href="#36651109">prev</a><span>|</span><a href="#36647869">next</a><span>|</span><label class="collapse" for="c-36651821">[-]</label><label class="expand" for="c-36651821">[1 more]</label></div><br/><div class="children"><div class="content">To rub salt in Stallman&#x27;s wounds.</div><br/></div></div><div id="36647869" class="c"><input type="checkbox" id="c-36647869" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#36646708">root</a><span>|</span><a href="#36647400">parent</a><span>|</span><a href="#36651821">prev</a><span>|</span><a href="#36647833">next</a><span>|</span><label class="collapse" for="c-36647869">[-]</label><label class="expand" for="c-36647869">[2 more]</label></div><br/><div class="children"><div class="content">and webassembly.</div><br/><div id="36649450" class="c"><input type="checkbox" id="c-36649450" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36646708">root</a><span>|</span><a href="#36647869">parent</a><span>|</span><a href="#36647833">next</a><span>|</span><label class="collapse" for="c-36649450">[-]</label><label class="expand" for="c-36649450">[1 more]</label></div><br/><div class="children"><div class="content">Oh that&#x27;s it, I was reading some wasm articles last month.</div><br/></div></div></div></div></div></div></div></div><div id="36647833" class="c"><input type="checkbox" id="c-36647833" checked=""/><div class="controls bullet"><span class="by">cylinder714</span><span>|</span><a href="#36646708">prev</a><span>|</span><a href="#36646311">next</a><span>|</span><label class="collapse" for="c-36647833">[-]</label><label class="expand" for="c-36647833">[1 more]</label></div><br/><div class="children"><div class="content">SBCL: the ultimate assembly code breadboard (2014):<p><a href="http:&#x2F;&#x2F;pvk.ca&#x2F;Blog&#x2F;2014&#x2F;03&#x2F;15&#x2F;sbcl-the-ultimate-assembly-code-breadboard&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;pvk.ca&#x2F;Blog&#x2F;2014&#x2F;03&#x2F;15&#x2F;sbcl-the-ultimate-assembly-cod...</a></div><br/></div></div><div id="36646311" class="c"><input type="checkbox" id="c-36646311" checked=""/><div class="controls bullet"><span class="by">johndoe0815</span><span>|</span><a href="#36647833">prev</a><span>|</span><a href="#36647293">next</a><span>|</span><label class="collapse" for="c-36646311">[-]</label><label class="expand" for="c-36646311">[4 more]</label></div><br/><div class="children"><div class="content">And here&#x27;s a Lisp written in ARM Assembler :)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;marcpaq&#x2F;arpilisp">https:&#x2F;&#x2F;github.com&#x2F;marcpaq&#x2F;arpilisp</a></div><br/><div id="36646428" class="c"><input type="checkbox" id="c-36646428" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36646311">parent</a><span>|</span><a href="#36647293">next</a><span>|</span><label class="collapse" for="c-36646428">[-]</label><label class="expand" for="c-36646428">[3 more]</label></div><br/><div class="children"><div class="content">So the base components of a future Lisp Machine are available. :)</div><br/><div id="36646656" class="c"><input type="checkbox" id="c-36646656" checked=""/><div class="controls bullet"><span class="by">johndoe0815</span><span>|</span><a href="#36646311">root</a><span>|</span><a href="#36646428">parent</a><span>|</span><a href="#36647293">next</a><span>|</span><label class="collapse" for="c-36646656">[-]</label><label class="expand" for="c-36646656">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s something even better for the Raspberry Pi (2B only at the moment) - interim OS, a bare metal Lisp by Lukas Hartmann of MNT Research, the creator of the MNT Reform laptop.<p>The original site seems to be unavailable right now, but it&#x27;s mirrored on archive.org:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230331151459&#x2F;http:&#x2F;&#x2F;interim-os.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230331151459&#x2F;http:&#x2F;&#x2F;interim-os...</a></div><br/></div></div></div></div></div></div><div id="36647293" class="c"><input type="checkbox" id="c-36647293" checked=""/><div class="controls bullet"><span class="by">icedata</span><span>|</span><a href="#36646311">prev</a><span>|</span><a href="#36648668">next</a><span>|</span><label class="collapse" for="c-36647293">[-]</label><label class="expand" for="c-36647293">[1 more]</label></div><br/><div class="children"><div class="content">At LCSI we had assemblers and debugging tools for 6502, x86 and others written in LMI Lisp, which we used to create several popular commercial versions of Logo.</div><br/></div></div><div id="36648668" class="c"><input type="checkbox" id="c-36648668" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36647293">prev</a><span>|</span><a href="#36646278">next</a><span>|</span><label class="collapse" for="c-36648668">[-]</label><label class="expand" for="c-36648668">[1 more]</label></div><br/><div class="children"><div class="content">Major Lisp implementations have things like this.<p>E.g. look at the <i>defarmlap</i> function definitions in Clozure Common Lisp:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Clozure&#x2F;ccl&#x2F;blob&#x2F;master&#x2F;level-0&#x2F;ARM&#x2F;arm-hash.lisp">https:&#x2F;&#x2F;github.com&#x2F;Clozure&#x2F;ccl&#x2F;blob&#x2F;master&#x2F;level-0&#x2F;ARM&#x2F;arm-h...</a><p>.. and other files, plus other architectures in other subdirectories.</div><br/></div></div><div id="36647629" class="c"><input type="checkbox" id="c-36647629" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36646278">prev</a><span>|</span><a href="#36646880">next</a><span>|</span><label class="collapse" for="c-36647629">[-]</label><label class="expand" for="c-36647629">[2 more]</label></div><br/><div class="children"><div class="content">RISC-V next?</div><br/><div id="36649941" class="c"><input type="checkbox" id="c-36649941" checked=""/><div class="controls bullet"><span class="by">robert-brown</span><span>|</span><a href="#36647629">parent</a><span>|</span><a href="#36646880">next</a><span>|</span><label class="collapse" for="c-36649941">[-]</label><label class="expand" for="c-36649941">[1 more]</label></div><br/><div class="children"><div class="content">SBCL has been ported to RISC-V, so it has an assembler for that architecture.</div><br/></div></div></div></div><div id="36646880" class="c"><input type="checkbox" id="c-36646880" checked=""/><div class="controls bullet"><span class="by">erichocean</span><span>|</span><a href="#36647629">prev</a><span>|</span><label class="collapse" for="c-36646880">[-]</label><label class="expand" for="c-36646880">[1 more]</label></div><br/><div class="children"><div class="content">Factor (a modern stack language) has assemblers for x86 and PowerPC (last I checked), and should be easy to also incorporate ARM.</div><br/></div></div></div></div></div></div></div></body></html>