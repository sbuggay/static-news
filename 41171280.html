<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723021276192" as="style"/><link rel="stylesheet" href="styles.css?v=1723021276192"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pola.rs/posts/polars-string-type/">Why Polars rewrote its Arrow string data type</a> <span class="domain">(<a href="https://pola.rs">pola.rs</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>40 comments</span></div><br/><div><div id="41179472" class="c"><input type="checkbox" id="c-41179472" checked=""/><div class="controls bullet"><span class="by">sixtram</span><span>|</span><a href="#41175142">next</a><span>|</span><label class="collapse" for="c-41179472">[-]</label><label class="expand" for="c-41179472">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone know what tool and font was used in the illustrations in the article?</div><br/></div></div><div id="41175142" class="c"><input type="checkbox" id="c-41175142" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#41179472">prev</a><span>|</span><a href="#41178019">next</a><span>|</span><label class="collapse" for="c-41175142">[-]</label><label class="expand" for="c-41175142">[15 more]</label></div><br/><div class="children"><div class="content">&gt; “short string optimization”: A short enough string can be stored “in place” [...] An optimization that’s impossible in Rust, by the way ;).<p>Author is not aware of <a href="https:&#x2F;&#x2F;docs.rs&#x2F;compact_str&#x2F;latest&#x2F;compact_str&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;compact_str&#x2F;latest&#x2F;compact_str&#x2F;</a> or <a href="https:&#x2F;&#x2F;github.com&#x2F;bodil&#x2F;smartstring">https:&#x2F;&#x2F;github.com&#x2F;bodil&#x2F;smartstring</a></div><br/><div id="41177821" class="c"><input type="checkbox" id="c-41177821" checked=""/><div class="controls bullet"><span class="by">jtrueb</span><span>|</span><a href="#41175142">parent</a><span>|</span><a href="#41175733">next</a><span>|</span><label class="collapse" for="c-41177821">[-]</label><label class="expand" for="c-41177821">[1 more]</label></div><br/><div class="children"><div class="content">This is false. The polars api has used smart string for a long time.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;pola-rs&#x2F;polars&#x2F;blob&#x2F;32a2325b55f9bce81d0193eef26591aeba713efd&#x2F;Cargo.toml#L82">https:&#x2F;&#x2F;github.com&#x2F;pola-rs&#x2F;polars&#x2F;blob&#x2F;32a2325b55f9bce81d019...</a></div><br/></div></div><div id="41175733" class="c"><input type="checkbox" id="c-41175733" checked=""/><div class="controls bullet"><span class="by">charliermarsh</span><span>|</span><a href="#41175142">parent</a><span>|</span><a href="#41177821">prev</a><span>|</span><a href="#41175593">next</a><span>|</span><label class="collapse" for="c-41175733">[-]</label><label class="expand" for="c-41175733">[6 more]</label></div><br/><div class="children"><div class="content">Was this section removed? I&#x27;m not seeing it in the linked post.</div><br/><div id="41176051" class="c"><input type="checkbox" id="c-41176051" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41175733">parent</a><span>|</span><a href="#41175593">next</a><span>|</span><label class="collapse" for="c-41176051">[-]</label><label class="expand" for="c-41176051">[5 more]</label></div><br/><div class="children"><div class="content">It seems to be a quote from <a href="https:&#x2F;&#x2F;cedardb.com&#x2F;blog&#x2F;german_strings&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cedardb.com&#x2F;blog&#x2F;german_strings&#x2F;</a> which is about this German Strings type (implemented in Polars)<p>But yeah, it&#x27;s pretty ignorant to assume Rust can&#x27;t do this since the best available examples (as with many things) are in Rust. CompactString is <i>really</i> nice. On a typical modern (64-bit) computer CompactString takes 24 bytes and holds up to 24 bytes of UTF-8 text inline, while also having a niche.<p>I guess the confusion arises because C++ people tend to assume that anywhere Rust differs from the practice in the C++ community it&#x27;s a mistake, even though that&#x27;s often because C++ made the wrong choice? Rust&#x27;s &amp;str is &quot;just&quot; &amp;[u8] plus a rule about the meaning of these bytes, and Rust&#x27;s String is correspondingly &quot;just&quot; Vec&lt;u8&gt; plus a rule about the meaning of those bytes. C++ couldn&#x27;t have done the former because it only belatedly got the fat pointer slice reference (as the troubled std::span) years after having a string data type.<p>Rust <i>didn&#x27;t</i> do this in the stdlib, but not because it&#x27;s impossible, because it&#x27;s a trade off and they wanted the provided stdlib type to be straightforward. If you need or even just want the trade off, you can just cargo add compact_str</div><br/><div id="41177115" class="c"><input type="checkbox" id="c-41177115" checked=""/><div class="controls bullet"><span class="by">throwaway48540</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41176051">parent</a><span>|</span><a href="#41175593">next</a><span>|</span><label class="collapse" for="c-41177115">[-]</label><label class="expand" for="c-41177115">[4 more]</label></div><br/><div class="children"><div class="content">I remember some C++ colleagues raving on about the standard library having anything and everything they might ever need. Makes sense in a world without sane package managers and package registries, but that mindset just doesn&#x27;t carry over.</div><br/><div id="41178481" class="c"><input type="checkbox" id="c-41178481" checked=""/><div class="controls bullet"><span class="by">kalaksi</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41177115">parent</a><span>|</span><a href="#41178007">next</a><span>|</span><label class="collapse" for="c-41178481">[-]</label><label class="expand" for="c-41178481">[2 more]</label></div><br/><div class="children"><div class="content">A decent standard library very much makes sense even with sane package managers and registries. Just look at JS. It&#x27;s awful that you need to hunt for packages for simple stuff (or implement yourself). Stdlib is usually straightforward to use, good quality, trustworthy and good and lasting support</div><br/><div id="41178746" class="c"><input type="checkbox" id="c-41178746" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41178481">parent</a><span>|</span><a href="#41178007">next</a><span>|</span><label class="collapse" for="c-41178746">[-]</label><label class="expand" for="c-41178746">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;good and <i>lasting</i> support&quot; part is the most important IMHO. Nothing is more annoying than having to switch to another library because the one you are currently using goes unmaintained. This <i>can</i> happen in the &quot;stdlib&quot; too (e.g. PHP deprecating the mcrypt library), but it happens much less often, and typically with much more time to prepare. Also important is that, when there is a &quot;standard&quot; stdlib package, other dependencies you might use will probably use that - having two dependencies that use different packages for doing the same thing is also annoying.</div><br/></div></div></div></div><div id="41178007" class="c"><input type="checkbox" id="c-41178007" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41177115">parent</a><span>|</span><a href="#41178481">prev</a><span>|</span><a href="#41175593">next</a><span>|</span><label class="collapse" for="c-41178007">[-]</label><label class="expand" for="c-41178007">[1 more]</label></div><br/><div class="children"><div class="content">That development is quite recent. The stdlib used to be very barebones. It still is compared to for example the Python one.</div><br/></div></div></div></div></div></div></div></div><div id="41175593" class="c"><input type="checkbox" id="c-41175593" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#41175142">parent</a><span>|</span><a href="#41175733">prev</a><span>|</span><a href="#41176137">next</a><span>|</span><label class="collapse" for="c-41175593">[-]</label><label class="expand" for="c-41175593">[3 more]</label></div><br/><div class="children"><div class="content">That documentation talks about all the benefits and &quot;can mostly be used as a drop in replacement for String&quot;, but what are the tradeoffs? When cannot it be used?</div><br/><div id="41176208" class="c"><input type="checkbox" id="c-41176208" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41175593">parent</a><span>|</span><a href="#41178159">next</a><span>|</span><label class="collapse" for="c-41176208">[-]</label><label class="expand" for="c-41176208">[1 more]</label></div><br/><div class="children"><div class="content">It looks like there&#x27;s a bunch of &quot;garbage collection&quot; type activity where you may have some bytes which were once part of a string but aren&#x27;t now used, and you&#x27;re always paying for the overhead of this optimisation even if it&#x27;s useless for your problem.<p>Suppose you work only with 500-4000 byte strings, maybe they&#x27;re short reviews, and each ends with a rating in star emoji, ***** is the best  * is the worst. [[HN ate my star emoji of course]]<p>So your reviews never fit in the &quot;optimised&quot; string slot, but also the prefix is just opening words from a review, which in some review styles will be the start of seemingly unrelated anecdotes. &quot;My grandfather used to tell me&quot; it&#x27;ll get to the review eventually, and you&#x27;ll see why they&#x27;re connected, but the <i>suffix</i> is useful and that&#x27;s not stored in a &quot;German string&quot; data structure.<p>Or maybe you have a high turnover of somewhat related medium size strings, so then that garbage collection step costs quite a lot of overhead.</div><br/></div></div><div id="41178159" class="c"><input type="checkbox" id="c-41178159" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41175593">parent</a><span>|</span><a href="#41176208">prev</a><span>|</span><a href="#41176137">next</a><span>|</span><label class="collapse" for="c-41178159">[-]</label><label class="expand" for="c-41178159">[1 more]</label></div><br/><div class="children"><div class="content">Any code built closely around String&#x27;s power-of-2 reallocation pattern may have to be reworked. I don&#x27;t think there&#x27;s any case when it cannot be used as a String replacement at all, except maybe when interfacing with an API that expects a &amp;mut String as an output parameter.</div><br/></div></div></div></div><div id="41176137" class="c"><input type="checkbox" id="c-41176137" checked=""/><div class="controls bullet"><span class="by">ladyanita22</span><span>|</span><a href="#41175142">parent</a><span>|</span><a href="#41175593">prev</a><span>|</span><a href="#41178019">next</a><span>|</span><label class="collapse" for="c-41176137">[-]</label><label class="expand" for="c-41176137">[4 more]</label></div><br/><div class="children"><div class="content">Why is it impossible in Rust? Do you have any source for that?</div><br/><div id="41176227" class="c"><input type="checkbox" id="c-41176227" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41176137">parent</a><span>|</span><a href="#41178019">next</a><span>|</span><label class="collapse" for="c-41176227">[-]</label><label class="expand" for="c-41176227">[3 more]</label></div><br/><div class="children"><div class="content">It is not. It is not implemented in std::string::String, but (as pointed out elsewhere in this thread) there are other string implementations that have it.<p>It was decided explicitly against for the standard library, because not every optimization is universally good, and keeping String as a thin wrapper over Vec&lt;T&gt; is a good default.</div><br/><div id="41179181" class="c"><input type="checkbox" id="c-41179181" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41176227">parent</a><span>|</span><a href="#41178019">next</a><span>|</span><label class="collapse" for="c-41179181">[-]</label><label class="expand" for="c-41179181">[2 more]</label></div><br/><div class="children"><div class="content">When are small strings bad? Parallelism?</div><br/><div id="41179212" class="c"><input type="checkbox" id="c-41179212" checked=""/><div class="controls bullet"><span class="by">workingjubilee</span><span>|</span><a href="#41175142">root</a><span>|</span><a href="#41179181">parent</a><span>|</span><a href="#41178019">next</a><span>|</span><label class="collapse" for="c-41179212">[-]</label><label class="expand" for="c-41179212">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;small string optimization&quot; makes the strings harder to manipulate with `unsafe` code. However, being easy to manipulate with `unsafe` code is in fact a priority for most std types, so that they are easily understood, extended, rearranged, passed over FFI and then later reconstituted, etc.<p>You can tear apart these types and reassemble them very easily. For many C++ std types, you cannot do this.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41178019" class="c"><input type="checkbox" id="c-41178019" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#41175142">prev</a><span>|</span><a href="#41175354">next</a><span>|</span><label class="collapse" for="c-41178019">[-]</label><label class="expand" for="c-41178019">[3 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t you lose the in-memory interop with other libraries by doing this?  I&#x27;m thinking that duckdb will no longer be able to read polars data that has been loaded into memory, as it can currently do, due to duckdb supporting Arrow.  Isn&#x27;t the benefit of arrow that it&#x27;s supported by many languages and libraries as a standard?<p>Will there be an option to use the &quot;compatible&quot; string format?</div><br/><div id="41178870" class="c"><input type="checkbox" id="c-41178870" checked=""/><div class="controls bullet"><span class="by">mau</span><span>|</span><a href="#41178019">parent</a><span>|</span><a href="#41178033">next</a><span>|</span><label class="collapse" for="c-41178870">[-]</label><label class="expand" for="c-41178870">[1 more]</label></div><br/><div class="children"><div class="content">Arrow supports this string format: <a href="https:&#x2F;&#x2F;arrow.apache.org&#x2F;docs&#x2F;format&#x2F;Columnar.html#variable-size-binary-view-layout" rel="nofollow">https:&#x2F;&#x2F;arrow.apache.org&#x2F;docs&#x2F;format&#x2F;Columnar.html#variable-...</a><p>From the article:<p>&gt; As luck would have it, the Arrow spec was also finally making progress with adding the long anticipated German Style string types to the specification. Which, spoiler alert, is the type we implemented.</div><br/></div></div><div id="41178033" class="c"><input type="checkbox" id="c-41178033" checked=""/><div class="controls bullet"><span class="by">emidln</span><span>|</span><a href="#41178019">parent</a><span>|</span><a href="#41178870">prev</a><span>|</span><a href="#41175354">next</a><span>|</span><label class="collapse" for="c-41178033">[-]</label><label class="expand" for="c-41178033">[1 more]</label></div><br/><div class="children"><div class="content">Wouldnt you just recompile your duckdb with the hacked Arrow?</div><br/></div></div></div></div><div id="41175354" class="c"><input type="checkbox" id="c-41175354" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#41178019">prev</a><span>|</span><a href="#41177239">next</a><span>|</span><label class="collapse" for="c-41175354">[-]</label><label class="expand" for="c-41175354">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When you access a transient string, the string itself won’t know whether the data it points to is still valid, so you as a programmer need to ensure that every transient string you use is actually still valid.<p>In my mind this reads identical to &quot;if you&#x27;re a security practitioner, worry about this bit here.&quot;</div><br/></div></div><div id="41177239" class="c"><input type="checkbox" id="c-41177239" checked=""/><div class="controls bullet"><span class="by">xiaodai</span><span>|</span><a href="#41175354">prev</a><span>|</span><a href="#41177588">next</a><span>|</span><label class="collapse" for="c-41177239">[-]</label><label class="expand" for="c-41177239">[1 more]</label></div><br/><div class="children"><div class="content">For short strings, this is basically the same concept as ShortStrings.jl in julia<p><a href="https:&#x2F;&#x2F;github.com&#x2F;JuliaString&#x2F;ShortStrings.jl">https:&#x2F;&#x2F;github.com&#x2F;JuliaString&#x2F;ShortStrings.jl</a></div><br/></div></div><div id="41177588" class="c"><input type="checkbox" id="c-41177588" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#41177239">prev</a><span>|</span><a href="#41175259">next</a><span>|</span><label class="collapse" for="c-41177588">[-]</label><label class="expand" for="c-41177588">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if something like arrow&#x27;s custom extension types mechanism would streamline building novel data representations without full forks? It may highlight gaps in the extension mechanism<p>For similar reasons, we&#x27;ve been curious about new compression modes on indexes</div><br/></div></div><div id="41175116" class="c"><input type="checkbox" id="c-41175116" checked=""/><div class="controls bullet"><span class="by">ismailmaj</span><span>|</span><a href="#41175259">prev</a><span>|</span><a href="#41174648">next</a><span>|</span><label class="collapse" for="c-41175116">[-]</label><label class="expand" for="c-41175116">[3 more]</label></div><br/><div class="children"><div class="content">I might have missed it in the article but I&#x27;m not sure why the prefix is stored for strings that can&#x27;t be inlined.</div><br/><div id="41175243" class="c"><input type="checkbox" id="c-41175243" checked=""/><div class="controls bullet"><span class="by">pgwhalen</span><span>|</span><a href="#41175116">parent</a><span>|</span><a href="#41176076">next</a><span>|</span><label class="collapse" for="c-41175243">[-]</label><label class="expand" for="c-41175243">[1 more]</label></div><br/><div class="children"><div class="content">Ctrl-F for &quot;Some motivations are as follows&quot; under the &quot;String view with short string optimizations&quot; section here: <a href="https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;12aZi8Inez9L_JCtZ6gi2XDbQpCsHICNy9_EUxj4ILeE&#x2F;edit#heading=h.gunuqslkwmna" rel="nofollow">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;12aZi8Inez9L_JCtZ6gi2XDbQ...</a><p>Copying here:<p>&gt; Having the 4-byte prefix directly accessible (without indirection through an offset into a separate data buffer) can substantially improve the performance of comparisons returning false. This prefix can be encoded with multi-column hash keys to accelerate aggregations, joins. Sorts would likely also be significantly faster with this representation (experiments would tell for certain)<p>&gt; Certain algorithms (for example “prefix of string” or “suffix of string” — e.g. PREFIX(“foobar”, 3) -&gt; “bar”) can execute by manipulating StringView values only and not requiring any memory copying of large strings.<p>This document was an early proposal for adding what is now called the StringView (and ByteView) types to the Arrow format itself.</div><br/></div></div><div id="41176076" class="c"><input type="checkbox" id="c-41176076" checked=""/><div class="controls bullet"><span class="by">make3</span><span>|</span><a href="#41175116">parent</a><span>|</span><a href="#41175243">prev</a><span>|</span><a href="#41174648">next</a><span>|</span><label class="collapse" for="c-41176076">[-]</label><label class="expand" for="c-41176076">[1 more]</label></div><br/><div class="children"><div class="content">the first n bytes are likely by far the most often accessed in practices, specifically for sorting &amp; filtering, etc. Storing them inline is likely a huge optimization for little cost.</div><br/></div></div></div></div><div id="41174648" class="c"><input type="checkbox" id="c-41174648" checked=""/><div class="controls bullet"><span class="by">justinsaccount</span><span>|</span><a href="#41175116">prev</a><span>|</span><a href="#41174631">next</a><span>|</span><label class="collapse" for="c-41174648">[-]</label><label class="expand" for="c-41174648">[9 more]</label></div><br/><div class="children"><div class="content">Is there a standalone c&#x2F;c++ implementation of this string type anywhere?</div><br/><div id="41174777" class="c"><input type="checkbox" id="c-41174777" checked=""/><div class="controls bullet"><span class="by">lor_louis</span><span>|</span><a href="#41174648">parent</a><span>|</span><a href="#41174631">next</a><span>|</span><label class="collapse" for="c-41174777">[-]</label><label class="expand" for="c-41174777">[8 more]</label></div><br/><div class="children"><div class="content">It looks a lot like cedarDB&#x27;s &quot;german strings&quot;.<p>&lt;<a href="https:&#x2F;&#x2F;cedardb.com&#x2F;blog&#x2F;german_strings&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cedardb.com&#x2F;blog&#x2F;german_strings&#x2F;</a>&gt;<p>You could probably write a C++ implementation based on the article.<p>Note that it&#x27;s not all that useful if you don&#x27;t plan on searching for text based on their prefix. From my understanding, this is mostly a better way to store SStables in RAM&#x2F;partially on disk if you mmap.</div><br/><div id="41175778" class="c"><input type="checkbox" id="c-41175778" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41174648">root</a><span>|</span><a href="#41174777">parent</a><span>|</span><a href="#41178799">next</a><span>|</span><label class="collapse" for="c-41175778">[-]</label><label class="expand" for="c-41175778">[5 more]</label></div><br/><div class="children"><div class="content">Hm, both the main article and your link are wasteful for strings of length 13-15, which are still pretty common. As a rule for SSO, if you&#x27;re already take up the bytes unconditionally, it&#x27;s going to be worth complexifying your &quot;size&quot; calculation to squeeze a little more into the no-alloc case.<p>That said, note that there are a <i>lot</i> of strings around 20 bytes (stringified 64-bit integers or floats), so pushing to 24-1 is a reasonable choice too.<p>I&#x27;d use 3 size classes:<p>* 0-15 bytes, stored in-line. If you need C-string compatibility (which is fairly likely <i>somewhere</i> in your application), ensure that size 15 is encoded as a zero at the last byte.<p>* up to 3.75GB (if my mental math is right), stored with a mangled 32-bit size. Alternatively you could use a simpler cutoff if it makes the mangling easier. Another possibility would be to have a 16-bit size class.<p>* add support for very large strings (likely with a completely different allocation method) too; a 4GB limit sucks and is easily exceeded. If need be this can use an extra indirection.<p>Honestly, with a 16-byte budget, I&#x27;d consider spending more of that on the prefix - you can get 8 bytes with enough contortion elsewhere.<p>Duplicating the prefix is probably worth it in more cases than you might think, since it does speed up comparisons. Just remember, you have to check the size to distinguish &quot;a\0&quot; from &quot;a&quot; too, not just from &quot;a\0\0\0\0&quot;.</div><br/><div id="41176511" class="c"><input type="checkbox" id="c-41176511" checked=""/><div class="controls bullet"><span class="by">lor_louis</span><span>|</span><a href="#41174648">root</a><span>|</span><a href="#41175778">parent</a><span>|</span><a href="#41178799">next</a><span>|</span><label class="collapse" for="c-41176511">[-]</label><label class="expand" for="c-41176511">[4 more]</label></div><br/><div class="children"><div class="content">Yeah I tend to work with strings data around the 15 to 30 ish char count so I&#x27;m also sceptical of german strings when it comes to raw memory usage. What really interests me, is that in theory, an SSTable built from German Strings that point into a larger text buffer further down could result in less pagefaults during a binary search? Maybe?</div><br/><div id="41176845" class="c"><input type="checkbox" id="c-41176845" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41174648">root</a><span>|</span><a href="#41176511">parent</a><span>|</span><a href="#41178799">next</a><span>|</span><label class="collapse" for="c-41176845">[-]</label><label class="expand" for="c-41176845">[3 more]</label></div><br/><div class="children"><div class="content">I mean, if you&#x27;re doing binary searches, the <i>first</i> thing to do is to switch to Eytzinger searches (at least for the prefixes; it&#x27;s unclear if Eytzing-sorting large strings matters) which are <i>much</i> more cache friendly. (incidentally, Eytzinger was Austrian, not German - same language though!)<p>Second, I&#x27;d probably switch to struct-of-array instead of array-of-struct, since the search part only needs the (head of the) key. Possibly some trie-like logic would also help (that is, avoid duplicating the common prefix, instead point to an array of continuations rather than a single one), but beware of costly indirections.<p>Third, I would make sure the <i>user</i> is able to specify the SSO limit, since different domains will have different requirements.<p>Fourth ... if you&#x27;re column-oriented (or for simple data in the first place), consider implicit union of different `Set` (or whatever) implementations. For example, store all short strings in one array, and all long strings in a different array.</div><br/><div id="41177331" class="c"><input type="checkbox" id="c-41177331" checked=""/><div class="controls bullet"><span class="by">lor_louis</span><span>|</span><a href="#41174648">root</a><span>|</span><a href="#41176845">parent</a><span>|</span><a href="#41178799">next</a><span>|</span><label class="collapse" for="c-41177331">[-]</label><label class="expand" for="c-41177331">[2 more]</label></div><br/><div class="children"><div class="content">I did not know about Eytzing-sorting, I&#x27;ll look into it after my vacation, thanks! And yeah our current system is column oriented, and I already tried most of your recommendations (including tries) but the biggest limitation we face is that different kinds of queries will be better served by different kinds of data structures but you can only store a few of them on disk before the cost to index becomes too big.</div><br/><div id="41177899" class="c"><input type="checkbox" id="c-41177899" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41174648">root</a><span>|</span><a href="#41177331">parent</a><span>|</span><a href="#41178799">next</a><span>|</span><label class="collapse" for="c-41177899">[-]</label><label class="expand" for="c-41177899">[1 more]</label></div><br/><div class="children"><div class="content">Whoops, I dropped the &quot;er&quot; the second time. I&#x27;ve also seen it labeled &quot;cache-friendly binary sort&quot;, and sometimes the Breadth-First-Search aspect is played up (but that&#x27;s unsearchable).<p>Logical-order (in-order DFS) iteration is obvious and trivial (though a lot of tasks are fine with physical-order (BFS) iteration. Beware that some tasks that nominally don&#x27;t care about input order perform much better on already-sorted input though).<p>Conversion between logical index and physical index (if you need it - chances are you don&#x27;t) can still be done efficiently, but requires some (fun!) thought especially for the non-power-of-2 tail.<p>Explicit prefetching is trivial to arrange for k-great grandchildren if needed (though the width of course grows exponentially). Using an n-ary rather than binary tree is possible but I&#x27;m not sure of the cache effects in practice. Switching to linear search just at the last level may be worth it? All of this means more complex logic though.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41178799" class="c"><input type="checkbox" id="c-41178799" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#41174648">root</a><span>|</span><a href="#41174777">parent</a><span>|</span><a href="#41175778">prev</a><span>|</span><a href="#41174631">next</a><span>|</span><label class="collapse" for="c-41178799">[-]</label><label class="expand" for="c-41178799">[2 more]</label></div><br/><div class="children"><div class="content">As an aside, what is &quot;German&quot; about these?</div><br/><div id="41178938" class="c"><input type="checkbox" id="c-41178938" checked=""/><div class="controls bullet"><span class="by">danvonk</span><span>|</span><a href="#41174648">root</a><span>|</span><a href="#41178799">parent</a><span>|</span><a href="#41174631">next</a><span>|</span><label class="collapse" for="c-41178938">[-]</label><label class="expand" for="c-41178938">[1 more]</label></div><br/><div class="children"><div class="content">They were developed by the database group at TU Munich.</div><br/></div></div></div></div></div></div></div></div><div id="41174631" class="c"><input type="checkbox" id="c-41174631" checked=""/><div class="controls bullet"><span class="by">padthai</span><span>|</span><a href="#41174648">prev</a><span>|</span><a href="#41175631">next</a><span>|</span><label class="collapse" for="c-41174631">[-]</label><label class="expand" for="c-41174631">[3 more]</label></div><br/><div class="children"><div class="content">I am getting Vietnam flashbacks of all the small incompatibilities between Numpy arrays and Pandas Series</div><br/><div id="41174778" class="c"><input type="checkbox" id="c-41174778" checked=""/><div class="controls bullet"><span class="by">grahamjameson</span><span>|</span><a href="#41174631">parent</a><span>|</span><a href="#41175100">next</a><span>|</span><label class="collapse" for="c-41174778">[-]</label><label class="expand" for="c-41174778">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;youtu.be&#x2F;J0zjJKBK9ys" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;J0zjJKBK9ys</a></div><br/></div></div></div></div><div id="41175631" class="c"><input type="checkbox" id="c-41175631" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#41174631">prev</a><span>|</span><label class="collapse" for="c-41175631">[-]</label><label class="expand" for="c-41175631">[1 more]</label></div><br/><div class="children"><div class="content">Haha, quite a huge improvement in a point-release. 0.20.5 to 0.20.6.<p>This is a cool article. Good motivation. Good explanation. Plots. ~~One small thing is that the plots are missing a legend so I had to hover~~. Nevermind, I don&#x27;t know why it didn&#x27;t show (or why I thought that) because I can clearly see them on the x-axis now.</div><br/></div></div></div></div></div></div></div></body></html>