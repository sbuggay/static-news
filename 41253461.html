<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723712457157" as="style"/><link rel="stylesheet" href="styles.css?v=1723712457157"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jonathanolson.net/exact-polygonal-filtering">Exact Polygonal Filtering: Using Green&#x27;s Theorem and Clipping for Anti-Aliasing</a> <span class="domain">(<a href="https://jonathanolson.net">jonathanolson.net</a>)</span></div><div class="subtext"><span>muyyatin2</span> | <span>19 comments</span></div><br/><div><div id="41254014" class="c"><input type="checkbox" id="c-41254014" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#41253794">next</a><span>|</span><label class="collapse" for="c-41254014">[-]</label><label class="expand" for="c-41254014">[1 more]</label></div><br/><div class="children"><div class="content">The opening statement makes it out that this exact calculation is supposed to be superior to multisampling, but the opposite is the case. Computing the exact mathematical coverage of a single polygon against a background is useless for animations if you can&#x27;t seamlessly stitch multiple polygons together. And that&#x27;s why GPUs use multisampling: Each sample is an exact mathematical point that&#x27;s covered by either polygon at the seam, without the background bleeding through.</div><br/></div></div><div id="41253794" class="c"><input type="checkbox" id="c-41253794" checked=""/><div class="controls bullet"><span class="by">rsp1984</span><span>|</span><a href="#41254014">prev</a><span>|</span><a href="#41253656">next</a><span>|</span><label class="collapse" for="c-41253794">[-]</label><label class="expand" for="c-41253794">[6 more]</label></div><br/><div class="children"><div class="content">&gt; This is equivalent to applying a box filter to the polygon, which is the simplest form of filtering.<p>Am I the only one who has trouble understanding what is meant by this? What is the exact operation that&#x27;s referred to here?<p>I know box filters in the context of 2D image filtering and they&#x27;re straightforward but the concept of applying them to shapes just doesn&#x27;t make any sense to me.<p>Can someone clarify?</div><br/><div id="41253885" class="c"><input type="checkbox" id="c-41253885" checked=""/><div class="controls bullet"><span class="by">muyyatin2</span><span>|</span><a href="#41253794">parent</a><span>|</span><a href="#41254002">next</a><span>|</span><label class="collapse" for="c-41253885">[-]</label><label class="expand" for="c-41253885">[2 more]</label></div><br/><div class="children"><div class="content">It is more similar to the convolution of the shape with the filter (you can take the product of the filter, at various offsets, with the polygon)<p>Essentially if you have a polygon function p(x,y) =&gt; { 1 if inside the polygon, otherwise 0 }, and a filter function f(x,y) centered at the origin, then you can evaluate the filter at any point x_0,y_0 with the double-integral &#x2F; total sum of f(x-x_0,y-y_0)*p(x,y).</div><br/><div id="41254045" class="c"><input type="checkbox" id="c-41254045" checked=""/><div class="controls bullet"><span class="by">blauditore</span><span>|</span><a href="#41253794">root</a><span>|</span><a href="#41253885">parent</a><span>|</span><a href="#41254002">next</a><span>|</span><label class="collapse" for="c-41254045">[-]</label><label class="expand" for="c-41254045">[1 more]</label></div><br/><div class="children"><div class="content">This kind of makes sense from a mathematical point of view, but how would this look implementation-wise, in a scenario where you need to render a polygon scene? The article states that box filters are &quot;the simplest form of filtering&quot;, but it sounds quite non-trivial for that use case.</div><br/></div></div></div></div><div id="41254002" class="c"><input type="checkbox" id="c-41254002" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#41253794">parent</a><span>|</span><a href="#41253885">prev</a><span>|</span><a href="#41253656">next</a><span>|</span><label class="collapse" for="c-41254002">[-]</label><label class="expand" for="c-41254002">[3 more]</label></div><br/><div class="children"><div class="content">It literally means that you take a box-shaped piece of the polygon, ie. the intersection of the polygon and a box (a square, in this case the size of one pixel). And do this for each pixel as they’re processed by the rasterizer. If you think of a polygon as a function from R^2 to {0, 1}, where every point inside the polygon maps to 1, then it’s just a signal that you can apply filters to.</div><br/><div id="41254061" class="c"><input type="checkbox" id="c-41254061" checked=""/><div class="controls bullet"><span class="by">blauditore</span><span>|</span><a href="#41253794">root</a><span>|</span><a href="#41254002">parent</a><span>|</span><a href="#41253656">next</a><span>|</span><label class="collapse" for="c-41254061">[-]</label><label class="expand" for="c-41254061">[2 more]</label></div><br/><div class="children"><div class="content">But as I understand it, the article is about rasterization, so if we filter after rasterization, the sampling has already happened, no? In other words: Isn&#x27;t this about using the intersection of polygon x square <i>instead of</i> single sample per pixel rasterization?</div><br/><div id="41254081" class="c"><input type="checkbox" id="c-41254081" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#41253794">root</a><span>|</span><a href="#41254061">parent</a><span>|</span><a href="#41253656">next</a><span>|</span><label class="collapse" for="c-41254081">[-]</label><label class="expand" for="c-41254081">[1 more]</label></div><br/><div class="children"><div class="content">It is applying the filter <i>before</i> rasterization, and then taking a single sample of the filtered signal per pixel.</div><br/></div></div></div></div></div></div></div></div><div id="41253656" class="c"><input type="checkbox" id="c-41253656" checked=""/><div class="controls bullet"><span class="by">pixelpoet</span><span>|</span><a href="#41253794">prev</a><span>|</span><a href="#41253717">next</a><span>|</span><label class="collapse" for="c-41253656">[-]</label><label class="expand" for="c-41253656">[2 more]</label></div><br/><div class="children"><div class="content">Fantastic article, exactly my kinda thing :)<p>One significant limitation here is that the polygon needs to have constant colour, unfortunately.</div><br/><div id="41253897" class="c"><input type="checkbox" id="c-41253897" checked=""/><div class="controls bullet"><span class="by">muyyatin2</span><span>|</span><a href="#41253656">parent</a><span>|</span><a href="#41253717">next</a><span>|</span><label class="collapse" for="c-41253897">[-]</label><label class="expand" for="c-41253897">[1 more]</label></div><br/><div class="children"><div class="content">Ahh yes, for exact filtering it does need to be constant colour. I&#x27;m looking into seeing whether it can be done for gradients. However in practice, it works quite well visually to compute the &quot;average color of the polygon&quot; for each piecewise section, and blend those together.</div><br/></div></div></div></div><div id="41253717" class="c"><input type="checkbox" id="c-41253717" checked=""/><div class="controls bullet"><span class="by">mfabbri77</span><span>|</span><a href="#41253656">prev</a><span>|</span><a href="#41253647">next</a><span>|</span><label class="collapse" for="c-41253717">[-]</label><label class="expand" for="c-41253717">[7 more]</label></div><br/><div class="children"><div class="content">I am quite convinced that if the goal is the best possible output quality, then the best approach is to analytically compute the non-overlapping areas of each polygon within each pixel. Resolving all contributions (areas) together in the same single pass for each pixel.</div><br/><div id="41254090" class="c"><input type="checkbox" id="c-41254090" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#41253717">parent</a><span>|</span><a href="#41253741">next</a><span>|</span><label class="collapse" for="c-41254090">[-]</label><label class="expand" for="c-41254090">[1 more]</label></div><br/><div class="children"><div class="content">&gt; compute the non-overlapping areas of each polygon within each pixel<p>In the given example (periodic checkerboard), that would be impossible because the pixels that touch the horizon intersect an infinite amount of polygons.<p>Not that TFA solves that problem either.  As far as I know the exact rendering of a periodic pattern in perspective is an open problem.</div><br/></div></div><div id="41253741" class="c"><input type="checkbox" id="c-41253741" checked=""/><div class="controls bullet"><span class="by">muyyatin2</span><span>|</span><a href="#41253717">parent</a><span>|</span><a href="#41254090">prev</a><span>|</span><a href="#41253647">next</a><span>|</span><label class="collapse" for="c-41253741">[-]</label><label class="expand" for="c-41253741">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been looking into how viable this is as a performant strategy. If you have non-overlapping areas, then contributions to a single pixel can be made independently (since it is just the sum of contributions). The usual approach (computing coverage and blending into the color) is more constrained, where the operations need to be done in back-to-front order.</div><br/><div id="41253776" class="c"><input type="checkbox" id="c-41253776" checked=""/><div class="controls bullet"><span class="by">mfabbri77</span><span>|</span><a href="#41253717">root</a><span>|</span><a href="#41253741">parent</a><span>|</span><a href="#41253647">next</a><span>|</span><label class="collapse" for="c-41253776">[-]</label><label class="expand" for="c-41253776">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been researching this field for 20 years (I&#x27;m one of the developers of AmanithVG). Unfortunately, no matter how fast they are made, all the algorithms to analytically decompose areas involve a step to find intersections and therefore sweepline approaches that are difficult to parallelize and therefore must be done in CPU. However, we are working on it for the next AmanithVG rasterizer, so I&#x27;m keeping my eyes open for all possible alternatives.</div><br/><div id="41253846" class="c"><input type="checkbox" id="c-41253846" checked=""/><div class="controls bullet"><span class="by">muyyatin2</span><span>|</span><a href="#41253717">root</a><span>|</span><a href="#41253776">parent</a><span>|</span><a href="#41254011">next</a><span>|</span><label class="collapse" for="c-41253846">[-]</label><label class="expand" for="c-41253846">[1 more]</label></div><br/><div class="children"><div class="content">I ran across <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;72935.72950" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;72935.72950</a> a few weeks ago, it seems like a potential non-sweepline highly-parallel method. I&#x27;ve had some promising results for first doing a higher-dimensional Hilbert-sort (giving spatial locality), and then being able to prune a very large percentage of the quadratic search space. It might still be too slow on the GPU. I&#x27;m curious if you have any write-ups on things that have been explored, or if I&#x27;d be able to pick your brain some time!</div><br/></div></div><div id="41254011" class="c"><input type="checkbox" id="c-41254011" checked=""/><div class="controls bullet"><span class="by">whenc</span><span>|</span><a href="#41253717">root</a><span>|</span><a href="#41253776">parent</a><span>|</span><a href="#41253846">prev</a><span>|</span><a href="#41254001">next</a><span>|</span><label class="collapse" for="c-41254011">[-]</label><label class="expand" for="c-41254011">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s one to look at: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;2980179.2982434" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;2980179.2982434</a></div><br/></div></div><div id="41254001" class="c"><input type="checkbox" id="c-41254001" checked=""/><div class="controls bullet"><span class="by">dvdkon</span><span>|</span><a href="#41253717">root</a><span>|</span><a href="#41253776">parent</a><span>|</span><a href="#41254011">prev</a><span>|</span><a href="#41253647">next</a><span>|</span><label class="collapse" for="c-41254001">[-]</label><label class="expand" for="c-41254001">[1 more]</label></div><br/><div class="children"><div class="content">I believe Vello does this for AA (though I can&#x27;t find the source now), and it&#x27;s very fast, running on the GPU via compute shaders.</div><br/></div></div></div></div></div></div></div></div><div id="41253647" class="c"><input type="checkbox" id="c-41253647" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41253717">prev</a><span>|</span><label class="collapse" for="c-41253647">[-]</label><label class="expand" for="c-41253647">[2 more]</label></div><br/><div class="children"><div class="content">A note for other readers: this is a lot more impressive with &#x27;WebGPU&#x27; available.</div><br/></div></div></div></div></div></div></div></body></html>