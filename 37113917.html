<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692003665494" as="style"/><link rel="stylesheet" href="styles.css?v=1692003665494"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://docs.zfsbootmenu.org/en/v2.2.x/#">ZFSBootMenu</a> <span class="domain">(<a href="https://docs.zfsbootmenu.org">docs.zfsbootmenu.org</a>)</span></div><div class="subtext"><span>denysonique</span> | <span>44 comments</span></div><br/><div><div id="37114274" class="c"><input type="checkbox" id="c-37114274" checked=""/><div class="controls bullet"><span class="by">nisa</span><span>|</span><a href="#37115219">next</a><span>|</span><label class="collapse" for="c-37114274">[-]</label><label class="expand" for="c-37114274">[8 more]</label></div><br/><div class="children"><div class="content">Kudos to everyone involved in this! Love everything about this. Using it on my notebook, on dedicated servers rented at Hetzner as well as on Hetzner-Cloud, as well on a bunch of dedicated servers in a rack. Solves almost all problems related to ZFS and Linux. Booting this from SYSLINUX works very well as well as UEFI - it&#x27;s extensible and you can run it with the ZFS git version if you use the generate-zbm command. Saved my ass quite a few times already.</div><br/><div id="37114537" class="c"><input type="checkbox" id="c-37114537" checked=""/><div class="controls bullet"><span class="by">SushiHippie</span><span>|</span><a href="#37114274">parent</a><span>|</span><a href="#37116240">next</a><span>|</span><label class="collapse" for="c-37114537">[-]</label><label class="expand" for="c-37114537">[5 more]</label></div><br/><div class="children"><div class="content">May I ask how you use this on the dedicated server?</div><br/><div id="37114939" class="c"><input type="checkbox" id="c-37114939" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#37114274">root</a><span>|</span><a href="#37114537">parent</a><span>|</span><a href="#37116240">next</a><span>|</span><label class="collapse" for="c-37114939">[-]</label><label class="expand" for="c-37114939">[4 more]</label></div><br/><div class="children"><div class="content">Hetzner&#x27;s dedicated servers give you KVM access for stuff like tweaking your bios settings, installing an OS, or I guess using your boot menu. You have to request them via support ticket, but last time I did that I got it within 5 minutes, no questions asked.<p>If you have your own server in a rack somewhere chances are you bought one with a similar web interface (IMPI&#x2F;BMC&#x2F;whatever your brand calls it) on a separate always-on NIC on the mainboard.<p><a href="https:&#x2F;&#x2F;docs.hetzner.com&#x2F;robot&#x2F;dedicated-server&#x2F;maintainance&#x2F;kvm-console&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.hetzner.com&#x2F;robot&#x2F;dedicated-server&#x2F;maintainance...</a></div><br/><div id="37115253" class="c"><input type="checkbox" id="c-37115253" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37114274">root</a><span>|</span><a href="#37114939">parent</a><span>|</span><a href="#37116240">next</a><span>|</span><label class="collapse" for="c-37115253">[-]</label><label class="expand" for="c-37115253">[3 more]</label></div><br/><div class="children"><div class="content">When I installed FreeBSD on my Hetzner servers, I did so by booting the servers into the Linux based rescue mode and then I think I used dd to write the mfsBSD media onto one of the hard drives.<p>This way I didn’t have to request KVM access for my servers.<p>Perhaps a similar method can be used in order to install ZFSBootMenu</div><br/><div id="37118297" class="c"><input type="checkbox" id="c-37118297" checked=""/><div class="controls bullet"><span class="by">themoonisachees</span><span>|</span><a href="#37114274">root</a><span>|</span><a href="#37115253">parent</a><span>|</span><a href="#37116240">next</a><span>|</span><label class="collapse" for="c-37118297">[-]</label><label class="expand" for="c-37118297">[2 more]</label></div><br/><div class="children"><div class="content">Nice tip but if you fail your server is toast and that&#x27;s an interesting support ticket.</div><br/><div id="37118647" class="c"><input type="checkbox" id="c-37118647" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37114274">root</a><span>|</span><a href="#37118297">parent</a><span>|</span><a href="#37116240">next</a><span>|</span><label class="collapse" for="c-37118647">[-]</label><label class="expand" for="c-37118647">[1 more]</label></div><br/><div class="children"><div class="content">Their Linux based rescue mode boots from network.<p>I should probably specify though that I do this when setting up a new server.<p>If you fail then it should still be possible to select their Linux rescue image again from the Hetzner control panel and force reboot the server.<p>I seem to recall that I had to try a couple of times before I got it right. And that I did exactly that; select their rescue image again and force reboot.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37116240" class="c"><input type="checkbox" id="c-37116240" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37114274">parent</a><span>|</span><a href="#37114537">prev</a><span>|</span><a href="#37118047">next</a><span>|</span><label class="collapse" for="c-37116240">[-]</label><label class="expand" for="c-37116240">[1 more]</label></div><br/><div class="children"><div class="content">Void is my favorite distro, and I&#x27;m interested in giving this setup a try. So far I&#x27;ve been reluctant to use ZFS on Linux out of reliability concerns. Have you had any issues with this setup, or have any suggestions?</div><br/></div></div><div id="37118047" class="c"><input type="checkbox" id="c-37118047" checked=""/><div class="controls bullet"><span class="by">tehlike</span><span>|</span><a href="#37114274">parent</a><span>|</span><a href="#37116240">prev</a><span>|</span><a href="#37115219">next</a><span>|</span><label class="collapse" for="c-37118047">[-]</label><label class="expand" for="c-37118047">[1 more]</label></div><br/><div class="children"><div class="content">how do you use this with hetzner-cloud? Do you use it as a vm or as part of, say, k8s?</div><br/></div></div></div></div><div id="37115219" class="c"><input type="checkbox" id="c-37115219" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#37114274">prev</a><span>|</span><a href="#37114449">next</a><span>|</span><label class="collapse" for="c-37115219">[-]</label><label class="expand" for="c-37115219">[16 more]</label></div><br/><div class="children"><div class="content">It seems lame that UEFI firmware needs to &#x27;mount&#x27; a filesystem to load a bootloader.<p>That bootloader needs to mount a filesystem to find the kernel.<p>The kernel needs to mount the filesystem to run the system.<p>Each of those mount operations is done with different code, and normally each involves some config or search process to find the right disk&#x2F;partition.   If any of the searches finds the wrong partition or is misconfigured, you get a boot failure.<p>It really feels like the boot process is more complex than it needs to be, with more opportunities for failure than necessary.</div><br/><div id="37117978" class="c"><input type="checkbox" id="c-37117978" checked=""/><div class="controls bullet"><span class="by">Nextgrid</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37118678">next</a><span>|</span><label class="collapse" for="c-37117978">[-]</label><label class="expand" for="c-37117978">[1 more]</label></div><br/><div class="children"><div class="content">The firmware can execute UEFI binaries from any filesystem it can read. The spec mandates FAT32 as a supported filesystem, but nothing prevents additional filesystems from being supported - Apple&#x27;s firmware for example understands APFS (and previously, HFS+).<p>The Linux kernel can act as an EFI binary&#x2F;application using a mechanism&#x2F;feature called EFISTUB and thus can be loaded directly. The concept of a &quot;bootloader&quot; in UEFI-based Linux system is mostly vestigial (to enable feature-parity with non-UEFI systems or work around broken firmware). On a non-defective UEFI firmware, a bootloader is unnecessary, the UEFI firmware can load your kernel and initrd directly from the EFI system partition.<p>Ideally you&#x27;d want your UEFI to be able to read and understand your main filesystem (ZFS in this case) which means you no longer need a separate EFI system partition to store your kernel&#x2F;initrd (and can enjoy the redundancy and features provided by your filesystem of choice). UEFI is actually extensible so you <i>can</i> have third-party drivers (you&#x27;d need to store those drivers somewhere, but a USB stick&#x2F;memory card would do, or you could technically embed it in your firmware)?<p>The problem when it comes to ZFS specifically is that there is no UEFI-based driver with feature parity to the main ZfsOnLinux project. GRUB has a primitive implementation (extracted as stand-alone EFI drivers here: <a href="https:&#x2F;&#x2F;efi.akeo.ie" rel="nofollow noreferrer">https:&#x2F;&#x2F;efi.akeo.ie</a>) but it lacks support for many features, effectively forcing you to have a separate boot-time ZFS partition with all unsupported features disabled (if you&#x27;re going to use a separate partition, why not just use FAT32 which is natively supported).</div><br/></div></div><div id="37118678" class="c"><input type="checkbox" id="c-37118678" checked=""/><div class="controls bullet"><span class="by">loxias</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37117978">prev</a><span>|</span><a href="#37115409">next</a><span>|</span><label class="collapse" for="c-37118678">[-]</label><label class="expand" for="c-37118678">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so, so, SO, unnecessarily complicated while providing me no new features (like a faster boot).  LILO worked.  Even with LVM.  As the <i>boot</i>loader, of course it exists outside of the kernel, initrd, my rootfs.  That code would run, find the kernel, run that.<p>GRUB has some slight improvements like running other operating systems, but that&#x27;s about it.  Unsure if it&#x27;s worth the price...<p>None of this crazy modern boot-time ouroboros.  Too many layers, too much software.<p>At least we should _get_ something for this.  How about a 2s cold boot on my thinkpad?</div><br/></div></div><div id="37115409" class="c"><input type="checkbox" id="c-37115409" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37118678">prev</a><span>|</span><a href="#37118599">next</a><span>|</span><label class="collapse" for="c-37115409">[-]</label><label class="expand" for="c-37115409">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s not really a way around it unless you hardcode the bootloader rather than store it on disk.<p>That said, there are only two steps in the modern boot process on a PC: the UEFI firmware loading a basic FAT driver and the kernel mounting the other filesystems. The UEFI bootloader can use the existing FAT driver to load the kernel and the initramfs which will use the same code to mount partitions.<p>You can skip the UEFI bootloader and directly boot unified kernel images after putting them on the UEFI partition.</div><br/><div id="37115747" class="c"><input type="checkbox" id="c-37115747" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#37115219">root</a><span>|</span><a href="#37115409">parent</a><span>|</span><a href="#37118599">next</a><span>|</span><label class="collapse" for="c-37115747">[-]</label><label class="expand" for="c-37115747">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d quite like UEFI to be able to pass some kind of argv[0] to the direct-loaded kernel, so the kernel knows exactly which file on which partition of which disk it was loaded from.   That would then become the default root filesystem.<p>That effectively removes all config from the process - and means that any disk with a uefi executable kernel can be booted without the mystery step of &quot;lets try to figure out where we&#x27;re booting from&quot;.</div><br/><div id="37116045" class="c"><input type="checkbox" id="c-37116045" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#37115219">root</a><span>|</span><a href="#37115747">parent</a><span>|</span><a href="#37115803">next</a><span>|</span><label class="collapse" for="c-37116045">[-]</label><label class="expand" for="c-37116045">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I&#x27;d quite like UEFI to be able to pass some kind of argv[0] to the direct-loaded kernel, so the kernel knows exactly which file on which partition of which disk it was loaded from. That would then become the default root filesystem.<p>I think UEFI gives an EFI application (such as the Linux kernel) everything it would need for this already - but I guess Linux doesn&#x27;t use it.<p>The EFI application entry point includes a handle to your own image [0], and the EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL_GUID [1] protocol allows you to query the path it was loaded from. It is possible for an image to be loaded without a path, but it looks like EDK2 provides it at least [2].<p>[0] - <a href="https:&#x2F;&#x2F;uefi.org&#x2F;specs&#x2F;UEFI&#x2F;2.10&#x2F;07_Services_Boot_Services.html#efi-image-entry-point" rel="nofollow noreferrer">https:&#x2F;&#x2F;uefi.org&#x2F;specs&#x2F;UEFI&#x2F;2.10&#x2F;07_Services_Boot_Services.h...</a><p>[1] - <a href="https:&#x2F;&#x2F;uefi.org&#x2F;specs&#x2F;UEFI&#x2F;2.10&#x2F;09_Protocols_EFI_Loaded_Image.html#efi-loaded-image-device-path-protocol" rel="nofollow noreferrer">https:&#x2F;&#x2F;uefi.org&#x2F;specs&#x2F;UEFI&#x2F;2.10&#x2F;09_Protocols_EFI_Loaded_Ima...</a><p>[2] - <a href="https:&#x2F;&#x2F;github.com&#x2F;tianocore&#x2F;edk2&#x2F;blob&#x2F;991515a0583f65a64b3a6fa354409c64e670a762&#x2F;MdeModulePkg&#x2F;Library&#x2F;UefiBootManagerLib&#x2F;BmBoot.c#L1932">https:&#x2F;&#x2F;github.com&#x2F;tianocore&#x2F;edk2&#x2F;blob&#x2F;991515a0583f65a64b3a6...</a></div><br/></div></div><div id="37115803" class="c"><input type="checkbox" id="c-37115803" checked=""/><div class="controls bullet"><span class="by">hackmiester</span><span>|</span><a href="#37115219">root</a><span>|</span><a href="#37115747">parent</a><span>|</span><a href="#37116045">prev</a><span>|</span><a href="#37116505">next</a><span>|</span><label class="collapse" for="c-37115803">[-]</label><label class="expand" for="c-37115803">[1 more]</label></div><br/><div class="children"><div class="content">This does work inside of rEFInd, which can load a kernel EFI blob directly, and supply it args.</div><br/></div></div><div id="37116505" class="c"><input type="checkbox" id="c-37116505" checked=""/><div class="controls bullet"><span class="by">CameronNemo</span><span>|</span><a href="#37115219">root</a><span>|</span><a href="#37115747">parent</a><span>|</span><a href="#37115803">prev</a><span>|</span><a href="#37118599">next</a><span>|</span><label class="collapse" for="c-37116505">[-]</label><label class="expand" for="c-37116505">[1 more]</label></div><br/><div class="children"><div class="content">I think discoverable partitions are intended to solve this problem.<p><a href="https:&#x2F;&#x2F;uapi-group.org&#x2F;specifications&#x2F;specs&#x2F;discoverable_partitions_specification&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;uapi-group.org&#x2F;specifications&#x2F;specs&#x2F;discoverable_par...</a></div><br/></div></div></div></div></div></div><div id="37118599" class="c"><input type="checkbox" id="c-37118599" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37115409">prev</a><span>|</span><a href="#37117512">next</a><span>|</span><label class="collapse" for="c-37118599">[-]</label><label class="expand" for="c-37118599">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention the initrd, another filesystem that need to be mounted and must be kept aligned with the rest.<p>I&#x27;ve long switched to compiling my kernel including all needed modules and the EFI stub. I don&#x27;t have initrd or bootloader anymore, and can boot in a few seconds.</div><br/></div></div><div id="37117512" class="c"><input type="checkbox" id="c-37117512" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37118599">prev</a><span>|</span><a href="#37115956">next</a><span>|</span><label class="collapse" for="c-37117512">[-]</label><label class="expand" for="c-37117512">[1 more]</label></div><br/><div class="children"><div class="content"><i>That bootloader needs to mount a filesystem to find the kernel.<p>The kernel needs to mount the filesystem to run the system.<p>Each of those mount operations is done with different code...</i><p>Not on FreeBSD.  Our bootloader reuses kernel code (because, you know, developing the entire operating system together makes this possible).</div><br/></div></div><div id="37115956" class="c"><input type="checkbox" id="c-37115956" checked=""/><div class="controls bullet"><span class="by">65a</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37117512">prev</a><span>|</span><a href="#37115705">next</a><span>|</span><label class="collapse" for="c-37115956">[-]</label><label class="expand" for="c-37115956">[1 more]</label></div><br/><div class="children"><div class="content">This is precisely why UEFI is a heap of garbage, and things like coreboot, u-boot are much more appealing. It is far too complicated, and the complexity of the standard, coupled with half-assed vendor code, mean that not only is the boot process more fragile, it&#x27;s also much less secure.</div><br/></div></div><div id="37115705" class="c"><input type="checkbox" id="c-37115705" checked=""/><div class="controls bullet"><span class="by">nullifidian</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37115956">prev</a><span>|</span><a href="#37115491">next</a><span>|</span><label class="collapse" for="c-37115705">[-]</label><label class="expand" for="c-37115705">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It really feels like the boot process is more complex than it needs to be<p>You can use EFISTUB kernels directly (through efibootmgr) and use UEFI bios as the bootloader. There is no automatic kernel discovery with this method of course.</div><br/></div></div><div id="37116169" class="c"><input type="checkbox" id="c-37116169" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37115491">prev</a><span>|</span><a href="#37116569">next</a><span>|</span><label class="collapse" for="c-37116169">[-]</label><label class="expand" for="c-37116169">[1 more]</label></div><br/><div class="children"><div class="content">Is the bootloader itself considered as an operating system?<p>Does it have a kernel too?</div><br/></div></div><div id="37116569" class="c"><input type="checkbox" id="c-37116569" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#37115219">parent</a><span>|</span><a href="#37116169">prev</a><span>|</span><a href="#37116798">next</a><span>|</span><label class="collapse" for="c-37116569">[-]</label><label class="expand" for="c-37116569">[1 more]</label></div><br/><div class="children"><div class="content">More people than just you are starting to feel that way:<p>&quot;I have come to bury the BIOS, not to open it: The need for holistic systems&quot;
<a href="https:&#x2F;&#x2F;www.osfc.io&#x2F;2022&#x2F;talks&#x2F;i-have-come-to-bury-the-bios-not-to-open-it-the-need-for-holistic-systems&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.osfc.io&#x2F;2022&#x2F;talks&#x2F;i-have-come-to-bury-the-bios-...</a><p>This also talks about how you need a boot processor to do things like train up the RAM interface just so you can boot the main processor.</div><br/></div></div></div></div><div id="37114449" class="c"><input type="checkbox" id="c-37114449" checked=""/><div class="controls bullet"><span class="by">aborsy</span><span>|</span><a href="#37115219">prev</a><span>|</span><a href="#37114437">next</a><span>|</span><label class="collapse" for="c-37114449">[-]</label><label class="expand" for="c-37114449">[5 more]</label></div><br/><div class="children"><div class="content">Does ZFSBootMenu allow for entering encryption password remotely on encrypted root?</div><br/><div id="37114503" class="c"><input type="checkbox" id="c-37114503" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#37114449">parent</a><span>|</span><a href="#37114494">next</a><span>|</span><label class="collapse" for="c-37114503">[-]</label><label class="expand" for="c-37114503">[3 more]</label></div><br/><div class="children"><div class="content">Yes - both Dracut and mkinitcpio allow you to embed an SSH server in the ZFSBootMenu initramfs (dropbear, or OpenSSH) and connect to it. Once you connect, you can access the main interface and unlock any datasets prior to kexec.<p><a href="https:&#x2F;&#x2F;docs.zfsbootmenu.org&#x2F;en&#x2F;v2.2.x&#x2F;guides&#x2F;general&#x2F;remote-access.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.zfsbootmenu.org&#x2F;en&#x2F;v2.2.x&#x2F;guides&#x2F;general&#x2F;remote...</a></div><br/><div id="37116070" class="c"><input type="checkbox" id="c-37116070" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#37114449">root</a><span>|</span><a href="#37114503">parent</a><span>|</span><a href="#37114494">next</a><span>|</span><label class="collapse" for="c-37116070">[-]</label><label class="expand" for="c-37116070">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an aside - but I wish there was a way to do a kexec and keep the ZFS datasets unlocked. I don&#x27;t think there&#x27;s anything that stops it being technically possible, but I&#x27;m pretty sure it would require kernel mode changes...</div><br/><div id="37116497" class="c"><input type="checkbox" id="c-37116497" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#37114449">root</a><span>|</span><a href="#37116070">parent</a><span>|</span><a href="#37114494">next</a><span>|</span><label class="collapse" for="c-37116497">[-]</label><label class="expand" for="c-37116497">[1 more]</label></div><br/><div class="children"><div class="content">I just add the keyfile to the initramfs. It sits under an encryptionroot and is only readable by the root user, so it&#x27;s largely as safe as native encryption can be.</div><br/></div></div></div></div></div></div><div id="37114494" class="c"><input type="checkbox" id="c-37114494" checked=""/><div class="controls bullet"><span class="by">nisa</span><span>|</span><a href="#37114449">parent</a><span>|</span><a href="#37114503">prev</a><span>|</span><a href="#37114437">next</a><span>|</span><label class="collapse" for="c-37114494">[-]</label><label class="expand" for="c-37114494">[1 more]</label></div><br/><div class="children"><div class="content">yes you can add an ssh server or setup network in zfsbootmenu and use keylocation=https</div><br/></div></div></div></div><div id="37114437" class="c"><input type="checkbox" id="c-37114437" checked=""/><div class="controls bullet"><span class="by">dsp_person</span><span>|</span><a href="#37114449">prev</a><span>|</span><a href="#37114215">next</a><span>|</span><label class="collapse" for="c-37114437">[-]</label><label class="expand" for="c-37114437">[3 more]</label></div><br/><div class="children"><div class="content">I was looking at using this for my arch zfs-on-root setups, but I&#x27;ve instead just been hacking on &#x2F;etc&#x2F;grub.d&#x2F;10_linux and &#x2F;lib&#x2F;initcpio&#x2F;hooks&#x2F;zfs to get the boot menu setup I want with grub. I like the simplicity of it this way with less dependencies (especially otherwise needing to use AUR for the zfsbootmenu build or use the pre-built binary blob).<p>One concern I had with zfsbootmenu was I couldn&#x27;t figure out how to load microcode. With kexec, zfsbootmenu can only load one image and late loading microcode may be &quot;dangerous&quot; [1]. I don&#x27;t know practically if that is a real security issue or not. I tried cat&#x27;ing my images together as below, but it still didn&#x27;t work for me:<p><pre><code>  mv initramfs-linux.img initramfs-linux.img.orig
  cat intel-ucode.img initramfs-linux.img.orig &gt; initramfs-linux.img

</code></pre>
[1] <a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;arch&#x2F;x86&#x2F;microcode.html#why-is-late-loading-dangerous" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.kernel.org&#x2F;arch&#x2F;x86&#x2F;microcode.html#why-is-late-...</a></div><br/><div id="37114597" class="c"><input type="checkbox" id="c-37114597" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#37114437">parent</a><span>|</span><a href="#37114215">next</a><span>|</span><label class="collapse" for="c-37114597">[-]</label><label class="expand" for="c-37114597">[2 more]</label></div><br/><div class="children"><div class="content">There shouldn&#x27;t be any issues catting the real initramfs with microcode into another file. I do that, as does another ZBM developer. What do you see when you try it?<p>I started ZBM years ago by hacking on the same grub script, then progressed to what it is now!</div><br/><div id="37114959" class="c"><input type="checkbox" id="c-37114959" checked=""/><div class="controls bullet"><span class="by">dsp_person</span><span>|</span><a href="#37114437">root</a><span>|</span><a href="#37114597">parent</a><span>|</span><a href="#37114215">next</a><span>|</span><label class="collapse" for="c-37114959">[-]</label><label class="expand" for="c-37114959">[1 more]</label></div><br/><div class="children"><div class="content">When I booted normally with the concatenated image (ensuring removing the original microcode img from the grub.cfg initrd command), I booted and I confirmed the microcode loaded with (dmesg | grep microcode).<p>Then switching to ZBM, while it did boot with the concatenated image, I didn&#x27;t see microcode loaded in dmesg.</div><br/></div></div></div></div></div></div><div id="37114215" class="c"><input type="checkbox" id="c-37114215" checked=""/><div class="controls bullet"><span class="by">anotherhue</span><span>|</span><a href="#37114437">prev</a><span>|</span><a href="#37115667">next</a><span>|</span><label class="collapse" for="c-37114215">[-]</label><label class="expand" for="c-37114215">[5 more]</label></div><br/><div class="children"><div class="content">I used the FreeBSD version of this, I&#x27;m a shill at this point but I find nixos booting to an ephemeral tmpfs to be much better.<p>This wouldn&#x27;t apply if you needed to have divergent state though, though it&#x27;s hard to imagine a use case for that unhandled by fs snapshots.</div><br/><div id="37116317" class="c"><input type="checkbox" id="c-37116317" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37114215">parent</a><span>|</span><a href="#37115667">next</a><span>|</span><label class="collapse" for="c-37116317">[-]</label><label class="expand" for="c-37116317">[4 more]</label></div><br/><div class="children"><div class="content">In what way do you find NixOS to be better?<p>I&#x27;m actually thinking of going the other way, from NixOS to Void+ZFS. I&#x27;ve been using NixOS on 2 machines for a few months now, so I&#x27;m relatively new to it, but I still struggle with basic things, and don&#x27;t really grok the Nix language. If ZFS+ZFSBootMenu can give me easy snapshotting and rollback functionality, then I might prefer it over NixOS.<p>Sure, Nix does many more things besides snapshots, but for my use case it&#x27;s the main benefit, so I wouldn&#x27;t be missing much.</div><br/><div id="37116732" class="c"><input type="checkbox" id="c-37116732" checked=""/><div class="controls bullet"><span class="by">anotherhue</span><span>|</span><a href="#37114215">root</a><span>|</span><a href="#37116317">parent</a><span>|</span><a href="#37116900">next</a><span>|</span><label class="collapse" for="c-37116732">[-]</label><label class="expand" for="c-37116732">[2 more]</label></div><br/><div class="children"><div class="content">NixOS comes alive when you have ephemeral root. It&#x27;s generating all of &#x2F;var and &#x2F;etc as it boots, from the config, and then just mounting your home directory at the end.<p>So if I want to switch from pulse to pipewire, or some other messy change, I just edit the config, boot into it and it&#x27;s like pulse never existed. If I don&#x27;t like pipewire (I love pipewire) then I just choose the prior config option at boot and equally, pipewire never existed.<p>I don&#x27;t want my bootloader handling snapshots of my homedir, I can do that myself if I need (zfs auto snapshots, etc.). So with an ephemeral root, there is no other state to manage, making this kind of boot menu redundant.<p>Think of it this way, you can carefully manage filesystem state using snapshots, or you can slap it all in the &#x2F;nix store and have your system live assemble itself to spec on every boot. Like using git for your source tree instead of tar&#x27;ing up the whole thing everytime you make a scary change.</div><br/><div id="37116927" class="c"><input type="checkbox" id="c-37116927" checked=""/><div class="controls bullet"><span class="by">ahesford</span><span>|</span><a href="#37114215">root</a><span>|</span><a href="#37116732">parent</a><span>|</span><a href="#37116900">next</a><span>|</span><label class="collapse" for="c-37116927">[-]</label><label class="expand" for="c-37116927">[1 more]</label></div><br/><div class="children"><div class="content">I think you misunderstand what ZFSBootMenu does. It doesn&#x27;t manage any snapshots. It refuses to do anything to any file system that isn&#x27;t clearly marked as an operating system root. (There are a few well-defined criteria that must be met before ZBM will even attempt to determine if a filesystem has Linux kernels that it will allow you to boot.) Once it identifies one or more file systems that contain bootable Linux kernels, it allows the user to select a kernel from one of those file systems for booting. It also allows the user to enumerate snapshots <i>of those bootable file systems</i> and boot from them via ZFS cloning (with or without promotion) or a send-receive duplicate that avoids interdependencies.<p>Yes, Nix manages a history of past system instances and NixOS modifies the bootloader to present each of these states as a bootable option. This maps loosely to the ability to elevate ZFS snapshots to boot environments in ZBM, but the functionality is not redundant. In fact, it isn&#x27;t even a compatible alternative---we haven&#x27;t found a good way to make ZBM boot NixOS. If you want NixOS, you&#x27;re booting the NixOS way.<p>Nix is a very interesting concept that offers several advantages. It also has drawbacks. For example, it can be inordinately complex to manage small deviations from upstream configurations that aren&#x27;t represented by pre-existing options. (Ever try to add a single line to a PAM configuration file in Nix?)<p>The Nix way of booting falls apart should you want to have multiple Linux distributions coexisting on a single pool. NixOS works best when you have complete buy-in. ZFSBootMenu doesn&#x27;t care; if it can find kernels in the `&#x2F;boot` directory of a ZFS filesystem, it will show you the filesystem and let you boot it.</div><br/></div></div></div></div><div id="37116900" class="c"><input type="checkbox" id="c-37116900" checked=""/><div class="controls bullet"><span class="by">istjohn</span><span>|</span><a href="#37114215">root</a><span>|</span><a href="#37116317">parent</a><span>|</span><a href="#37116732">prev</a><span>|</span><a href="#37115667">next</a><span>|</span><label class="collapse" for="c-37116900">[-]</label><label class="expand" for="c-37116900">[1 more]</label></div><br/><div class="children"><div class="content">In case you weren&#x27;t aware:<p>Timeshift<p>&gt; System restore tool for Linux. Creates filesystem snapshots using rsync+hardlinks, or BTRFS snapshots. Supports scheduled snapshots, multiple backup levels, and exclude filters. Snapshots can be restored while system is running or from Live CD&#x2F;USB.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;linuxmint&#x2F;timeshift">https:&#x2F;&#x2F;github.com&#x2F;linuxmint&#x2F;timeshift</a></div><br/></div></div></div></div></div></div><div id="37115667" class="c"><input type="checkbox" id="c-37115667" checked=""/><div class="controls bullet"><span class="by">vermaden</span><span>|</span><a href="#37114215">prev</a><span>|</span><a href="#37114826">next</a><span>|</span><label class="collapse" for="c-37115667">[-]</label><label class="expand" for="c-37115667">[4 more]</label></div><br/><div class="children"><div class="content">Which Linux distribution provides this out of the box in its installer like FreeBSD does? ... along with optional LUKS encryption as FreeBSD offers optional GELI encryption.<p>I will wait ...</div><br/><div id="37117381" class="c"><input type="checkbox" id="c-37117381" checked=""/><div class="controls bullet"><span class="by">dizhn</span><span>|</span><a href="#37115667">parent</a><span>|</span><a href="#37117007">next</a><span>|</span><label class="collapse" for="c-37117381">[-]</label><label class="expand" for="c-37117381">[1 more]</label></div><br/><div class="children"><div class="content">OpenSuse Tumbleweed has btrfs+snapper and the installer sets it up automatically. I guess they could (technically) boot other operating systems but their focus is to boot into read only snapshots of the same OS.<p>The same setup is possible on all Linux distros but the user has to set it up.</div><br/></div></div><div id="37117007" class="c"><input type="checkbox" id="c-37117007" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#37115667">parent</a><span>|</span><a href="#37117381">prev</a><span>|</span><a href="#37114826">next</a><span>|</span><label class="collapse" for="c-37117007">[-]</label><label class="expand" for="c-37117007">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s okay for FreeBSD if Linux can do some things it can, and vice-versa. If you&#x27;re that insecure about running FreeBSD after all this time, you&#x27;d do well to think about why that is.</div><br/><div id="37118354" class="c"><input type="checkbox" id="c-37118354" checked=""/><div class="controls bullet"><span class="by">assimpleaspossi</span><span>|</span><a href="#37115667">root</a><span>|</span><a href="#37117007">parent</a><span>|</span><a href="#37114826">next</a><span>|</span><label class="collapse" for="c-37118354">[-]</label><label class="expand" for="c-37118354">[1 more]</label></div><br/><div class="children"><div class="content">Running an unencumbered FreeBSD system will never make any user insecure.</div><br/></div></div></div></div></div></div><div id="37114826" class="c"><input type="checkbox" id="c-37114826" checked=""/><div class="controls bullet"><span class="by">prabir</span><span>|</span><a href="#37115667">prev</a><span>|</span><a href="#37115526">next</a><span>|</span><label class="collapse" for="c-37114826">[-]</label><label class="expand" for="c-37114826">[1 more]</label></div><br/><div class="children"><div class="content">Been using this for arch <a href="https:&#x2F;&#x2F;github.com&#x2F;prabirshrestha&#x2F;simple-arch-installer">https:&#x2F;&#x2F;github.com&#x2F;prabirshrestha&#x2F;simple-arch-installer</a> and server <a href="https:&#x2F;&#x2F;github.com&#x2F;prabirshrestha&#x2F;simple-ubuntu-installer">https:&#x2F;&#x2F;github.com&#x2F;prabirshrestha&#x2F;simple-ubuntu-installer</a> with remote ssh unlock for zfs encryption.</div><br/></div></div></div></div></div></div></div></body></html>