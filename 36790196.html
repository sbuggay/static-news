<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689843663954" as="style"/><link rel="stylesheet" href="styles.css?v=1689843663954"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.qualys.com/vulnerabilities-threat-research/2023/07/19/cve-2023-38408-remote-code-execution-in-opensshs-forwarded-ssh-agent">Remote code execution in OpenSSH’s forwarded SSH-agent</a> <span class="domain">(<a href="https://blog.qualys.com">blog.qualys.com</a>)</span></div><div class="subtext"><span>vitplister</span> | <span>137 comments</span></div><br/><div><div id="36792299" class="c"><input type="checkbox" id="c-36792299" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36798247">next</a><span>|</span><label class="collapse" for="c-36792299">[-]</label><label class="expand" for="c-36792299">[13 more]</label></div><br/><div class="children"><div class="content">This is the bug of the year.<p>It&#x27;s well established that if Alice forwards an SSH agent to Bob, Bob can use the SSH agent protocol to make Alice open DLLs, because there&#x27;s an agent protocol command (SSH_AGENTC_ADD_SMARTCARD_KEY) that OpenSSH implements with dlopen: when you ask the agent to access a smart card, OpenSSH dlopen()&#x27;s the library corresponding to the `id` of the device. This is a Jann Horn bug from 2016, and OpenSSH fixed it by whitelisting DLLs to &#x2F;usr&#x2F;lib and directories like it.<p>The Qualys bug builds on Horn&#x27;s bug. When OpenSSH dlopen()&#x27;s the library, it then tries to look up a PKCS#11 entry point function, and, when it doesn&#x27;t find it, it dlclose()&#x27;s the library and returns an error.<p>The issue is that most of the libraries in system library paths were never intended to be opened maliciously, and so they do all sorts of stuff in their constructors and destructors (any function marked `__attribute__((constructor))` or `destructor` is called by dlopen and dlclose respectively). In particular, they register callbacks and signal handlers. Most of these libraries are never expected to dlclose at all, so they tend not to be great about cleaning up. Better still, if you randomly load oddball libraries into random programs, some of them crash, generating SIGBUS and SIGSEGV.<p>So you&#x27;ve got a classic UAF situation here: (1) force Alice to load a library that registers a SIGBUS handler; it won&#x27;t be a PKCS#11 handler so it&#x27;ll get immediately dlclose()&#x27;d, but won&#x27;t clean up the handler. (2) Load another library, which will take over the program text address the signal handler points to. (3) Finally, load a library that SIGBUS&#x27;s. If you manage to get a controlled jump swapped into place in step (2), you win.<p>If you&#x27;re thinking &quot;it&#x27;s pretty unlikely you&#x27;re going to be able to line up a controlled jump at exactly the address previously registered as a signal handler&quot;, you&#x27;re right, but there&#x27;s another quirk of dlclose() they take advantage of: there&#x27;s an ELF flag, NODELETE, that instructs the linker not to unmap a library when it&#x27;s unloaded, and a bunch of standard libraries set it, so you can use those libraries to groom the address space.<p>Finally, because some runtimes require executable stacks, there are standard libraries with an ELF flag that instructs the process to make the stack executable. If you load one of these libraries, and you have a controlled jump, you can write shellcode into the stack like it&#x27;s 1998.<p>To figure out the right sequence of steps, they basically recapitulated the original ROP gadget research idea: they swept all the standard Ubuntu libraries with a fuzzer to find combinations of loads that produced controlled jumps (ie, that died trying to execute stack addresses).<p>A working exploit loads a pattern of &quot;smartcards&quot; that looks like this (all in &#x2F;usr&#x2F;lib):<p><pre><code>    syslinux&#x2F;modules&#x2F;efi64&#x2F;gfxboot.c32 (execstack)
    pulse-15.0+dfsg1&#x2F;modules&#x2F;module-remap-sink.so (groom)
    x86_64-linux-gnu&#x2F;libgnatcoll_postgres.so.1 (SIGBUS handler)
    pulse-15.0+dfsg1&#x2F;modules&#x2F;module-http-protocol-unix.so (groom)
    x86_64-linux-gnu&#x2F;sane&#x2F;libsane-hp.so.1.0.32 (groom)
    libreoffice&#x2F;program&#x2F;libindex_data.so (groom)
    x86_64-linux-gnu&#x2F;gstreamer-1.0&#x2F;libgstaudiorate.so (groom)
    libreoffice&#x2F;program&#x2F;libscriptframe.so (groom)
    x86_64-linux-gnu&#x2F;libisccc-9.16.15-Ubuntu.so (groom)
    x86_64-linux-gnu&#x2F;libxkbregistry.so.0.0.0 (groom)
    debug&#x2F;.build-id&#x2F;15&#x2F;c0bee6bcb06fbf381d0e0e6c52f71e1d1bd694.debug (SIGBUS)
</code></pre>
The paper goes on to classify like 4 more patterns whereby you can get unexpected control transfers by dlopen() and immediately dlclosing() libraries. The kicker:<p><pre><code>    we noticed that one shared library&#x27;s constructor function
    (which can be invoked by a remote attacker via an ssh-agent forwarding)
    starts a server thread that listens on a TCP port, and we discovered a
    remotely exploitable vulnerability (a heap-based buffer overflow) in
    this server&#x27;s implementation.</code></pre></div><br/><div id="36798205" class="c"><input type="checkbox" id="c-36798205" checked=""/><div class="controls bullet"><span class="by">zwp</span><span>|</span><a href="#36792299">parent</a><span>|</span><a href="#36796539">next</a><span>|</span><label class="collapse" for="c-36798205">[-]</label><label class="expand" for="c-36798205">[1 more]</label></div><br/><div class="children"><div class="content">Tangential question: there is one reason to use NODELETE in the dlopen(3) man page:
<a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;dlopen.3.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;dlopen.3.html</a><p><pre><code>  RTLD_NODELETE (since glibc 2.2)
    Do not unload the shared object during dlclose().
    Consequently, the object&#x27;s static and global variables
    are not reinitialized if the object is reloaded with
    dlopen() at a later time.
</code></pre>
Are there any other times when it&#x27;s beneficial to use NODELETE?</div><br/></div></div><div id="36796539" class="c"><input type="checkbox" id="c-36796539" checked=""/><div class="controls bullet"><span class="by">brasic</span><span>|</span><a href="#36792299">parent</a><span>|</span><a href="#36798205">prev</a><span>|</span><a href="#36796888">next</a><span>|</span><label class="collapse" for="c-36796539">[-]</label><label class="expand" for="c-36796539">[5 more]</label></div><br/><div class="children"><div class="content">How would this even be mitigated while preserving the (wacky) existing support for runtime-selected PKCS#11 provider libraries? It strikes me that the most compatible way might be to double down on the wackiness and try to perform the required feature detection in some more indirect way like parsing the named lib with readelf(1) or the platform equivalent.<p>The sensible thing would be to force users to register available provider shared libraries in an ssh-agent config file, but that feels like a pretty big breaking change.<p>Edit: Didn’t realize a patch was already available. I see that they did in fact fix this with a breaking change, by simply disabling the functionality by default, and recommending that users allowlist their specific libraries:<p><pre><code>  Potentially-incompatible changes
  --------------------------------
  
   * ssh-agent(8): the agent will now refuse requests to load PKCS#11
     modules issued by remote clients by default. A flag has been added
     to restore the previous behaviour &quot;-Oallow-remote-pkcs11&quot;
</code></pre>
<a href="https:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html#9.3p2" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html#9.3p2</a></div><br/><div id="36797733" class="c"><input type="checkbox" id="c-36797733" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36792299">root</a><span>|</span><a href="#36796539">parent</a><span>|</span><a href="#36796580">next</a><span>|</span><label class="collapse" for="c-36797733">[-]</label><label class="expand" for="c-36797733">[3 more]</label></div><br/><div class="children"><div class="content">By finally acknowledging that loading plugins via shared objects is a bad idea, and it was only valuable in the days of resource constrained computers.<p>Any application that wants to use plugins and is security sensitive, should adopt OS IPC, and load them as separate processes.</div><br/><div id="36797877" class="c"><input type="checkbox" id="c-36797877" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#36792299">root</a><span>|</span><a href="#36797733">parent</a><span>|</span><a href="#36796580">next</a><span>|</span><label class="collapse" for="c-36797877">[-]</label><label class="expand" for="c-36797877">[2 more]</label></div><br/><div class="children"><div class="content">Would IPC help if a remote attacker was still allowed to execute arbitrary plugins?</div><br/><div id="36798125" class="c"><input type="checkbox" id="c-36798125" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36792299">root</a><span>|</span><a href="#36797877">parent</a><span>|</span><a href="#36796580">next</a><span>|</span><label class="collapse" for="c-36798125">[-]</label><label class="expand" for="c-36798125">[1 more]</label></div><br/><div class="children"><div class="content">It would help against attacks that depend on corrupting process address space, like this one.<p>Additionally, one could use OS security features to reduce API surface for each plugin, depending on what they are actually supposed to be doing, e.g. no need for file system access if they only do in-memory data processing.<p>As for &quot;would it help in 100% of the attacks?&quot;, no.<p>Even if there were no plugins support, there is still the possibility to exploit logical errors anyway.<p>What matters is having a balance between reducing attack surface, and application features, and it than regard process sandboxing is much safer than loading foreign code in-process.</div><br/></div></div></div></div></div></div><div id="36796580" class="c"><input type="checkbox" id="c-36796580" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36792299">root</a><span>|</span><a href="#36796539">parent</a><span>|</span><a href="#36797733">prev</a><span>|</span><a href="#36796888">next</a><span>|</span><label class="collapse" for="c-36796580">[-]</label><label class="expand" for="c-36796580">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How would this even be mitigated while preserving the (wacky) existing support for runtime-selected PKCS#11 provider libraries?<p>Put the pkcs11 libraries in a specific directory, configure only that directory, let users manually add others. Or stop using forwarding and configure ProxyJump where needed. (If that&#x27;s the only use case you&#x27;re interested in)</div><br/></div></div></div></div><div id="36796888" class="c"><input type="checkbox" id="c-36796888" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#36792299">parent</a><span>|</span><a href="#36796539">prev</a><span>|</span><a href="#36795944">next</a><span>|</span><label class="collapse" for="c-36796888">[-]</label><label class="expand" for="c-36796888">[3 more]</label></div><br/><div class="children"><div class="content">This is pretty wild, but if anyone had asked me previously &quot;should the SSH agent be allowed to dlopen anything?&quot; I would have said &quot;no&quot;. It really seems like for something this sensitive, running it in an empty namespace with no abilities of any kind, unless or until those abilities prove necessary, would be a good approach for those who have high security requirements. If I know I am going to use a smartcard, then I can make the PKCS library visible inside the agent&#x27;s sandbox. But I can see no reason why I would have given it access to libsane, or whatever libenca is, or any other library for that matter.</div><br/><div id="36796927" class="c"><input type="checkbox" id="c-36796927" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#36792299">root</a><span>|</span><a href="#36796888">parent</a><span>|</span><a href="#36795944">next</a><span>|</span><label class="collapse" for="c-36796927">[-]</label><label class="expand" for="c-36796927">[2 more]</label></div><br/><div class="children"><div class="content">and i quote:<p>Enca is an Extremely Naive Charset Analyser. It detects character set and
encoding of text files and can also convert them to other encodings using
either a built-in converter or external libraries and tools like libiconv,
librecode, or cstocs.<p>Currently, it has support for Belarussian, Bulgarian, Croatian, Czech,
Estonian, Latvian, Lithuanian, Polish, Russian, Slovak, Slovene, Ukrainian,
Chinese and some multibyte encodings (mostly variants of Unicode)
independent on the language.<p>This package also contains shared Enca library other programs can make use of.
Install enca if you need to cope with text files of dubious origin
and unknown encoding and convert them to some reasonable encoding.</div><br/><div id="36797360" class="c"><input type="checkbox" id="c-36797360" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#36792299">root</a><span>|</span><a href="#36796927">parent</a><span>|</span><a href="#36795944">next</a><span>|</span><label class="collapse" for="c-36797360">[-]</label><label class="expand" for="c-36797360">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Install enca if you need to cope with text files of dubious origin and unknown encoding and convert them to some reasonable encoding.<p>Install enca if you want an exploit. As far as i remember Pegasus also took advantage of parsing &quot;files of dubious origin and unknown encoding&quot;.</div><br/></div></div></div></div></div></div><div id="36795944" class="c"><input type="checkbox" id="c-36795944" checked=""/><div class="controls bullet"><span class="by">tlb</span><span>|</span><a href="#36792299">parent</a><span>|</span><a href="#36796888">prev</a><span>|</span><a href="#36798247">next</a><span>|</span><label class="collapse" for="c-36795944">[-]</label><label class="expand" for="c-36795944">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a very impressive exploit.<p>But I wonder if the PoC||GTFO maxim for security researchers leads to a lot of wasted effort. I was convinced that ssh-agent needed fixing as soon as they pointed out that it (a) accepts the name of a shared library within &#x2F;usr&#x2F;lib to dlopen over the network and (b) the range of crazy things that standard shared libraries do. Did they need to do all the extra work of developing an exploit in order to convince someone that was dangerous?</div><br/><div id="36797522" class="c"><input type="checkbox" id="c-36797522" checked=""/><div class="controls bullet"><span class="by">funcDropShadow</span><span>|</span><a href="#36792299">root</a><span>|</span><a href="#36795944">parent</a><span>|</span><a href="#36796106">next</a><span>|</span><label class="collapse" for="c-36797522">[-]</label><label class="expand" for="c-36797522">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Did they need to do all the extra work of developing an exploit in order to convince someone that was dangerous?<p>It might be clear in this case for someone who has already seen that really obscure bugs could be practically misused. But in the long-term, it is necessary to show that this is not some theoretical risk, which could be exploited in one never-heard-of hobby linux distribution. If security researchers skip these PoCs, a generation of future developers - who never saw practical PoCs - will just not believe it is relevant.<p>Saying the security researchers don&#x27;t need to show PoCs is like saying mathematicians don&#x27;t need proof, they just need to be very sure that a theorem holds.<p>That is the difference between a researcher&#x2F;scientist and an engineer. An engineer could say, well this is likely exploitable, therefore let&#x27;s safeguard against this. So that there remains a margin of security.</div><br/></div></div><div id="36796106" class="c"><input type="checkbox" id="c-36796106" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36792299">root</a><span>|</span><a href="#36795944">parent</a><span>|</span><a href="#36797522">prev</a><span>|</span><a href="#36798247">next</a><span>|</span><label class="collapse" for="c-36796106">[-]</label><label class="expand" for="c-36796106">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a great question. I think the answer is: no. They probably agree. I think, like, 80% of this is just art. There&#x27;s a notion of fleshing out the constructor&#x2F;destructor attack surface, which someone on Mastodon pointed out was pretty similar to how deserialization exploits work (they&#x27;re chains of classes you can only instantiate and not directly invoke methods on), but this might be the only time this particular variety of attack ever happens again.<p>It&#x27;s funny reading this thread full of people saying the attack is not that big a deal. It&#x27;s a really big deal! It&#x27;s just not a big deal for the reason people assume vulnerabilities are a big deal. :)</div><br/></div></div></div></div></div></div><div id="36798247" class="c"><input type="checkbox" id="c-36798247" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#36792299">prev</a><span>|</span><a href="#36791441">next</a><span>|</span><label class="collapse" for="c-36798247">[-]</label><label class="expand" for="c-36798247">[1 more]</label></div><br/><div class="children"><div class="content">Man nice job.  This is a really cool RCE and well handled.</div><br/></div></div><div id="36791441" class="c"><input type="checkbox" id="c-36791441" checked=""/><div class="controls bullet"><span class="by">sullivanmatt</span><span>|</span><a href="#36798247">prev</a><span>|</span><a href="#36790649">next</a><span>|</span><label class="collapse" for="c-36791441">[-]</label><label class="expand" for="c-36791441">[22 more]</label></div><br/><div class="children"><div class="content">This sounds way worse than it is.<p>To be clear, the &quot;remote&quot; part of the code execution is that an attacker controlling your destination server can cause your <i>client</i> to run an attacker-controlled payload, <i>if</i> the client is forwarding their credentials (`ssh -A`). Most people don&#x27;t tend to make connections to arbitrary SSH hosts, and certainly they don&#x27;t do it while forwarding their credentials along.<p>It&#x27;s a neat attack, and I applaud the Qualys team on their find, but this is not any sort of emergency situation for 99.99% of systems.</div><br/><div id="36794497" class="c"><input type="checkbox" id="c-36794497" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36791441">parent</a><span>|</span><a href="#36798170">next</a><span>|</span><label class="collapse" for="c-36794497">[-]</label><label class="expand" for="c-36794497">[2 more]</label></div><br/><div class="children"><div class="content">I beg to differ: this does <i>not</i> sound way worse than it is. If anything, it&#x27;s understating the issue.<p>Not only can it be exploited across a wide variety of clients across multiple platforms, but all that&#x27;s required is that you&#x27;re using key forwarding.<p>This is devastating, because it&#x27;s not just that you control the destination server and steal the keys, but you can take over the user&#x27;s entire workstation.<p>Once you&#x27;ve got the user&#x27;s entire workstation, you potentially have access to everything else they have, from their email, to other SSH hosts, to key loggers, to Git repos. This is about as bad as it gets, and all because someone is using Agent Forwarding.<p>Best of all, the victim has <i>no idea</i> that they&#x27;ve been completely compromised. They can live inside your machine for years, upgrade their sploits, and generally exfiltrate all of your secrets.<p>Never use agent forwarding. Just don&#x27;t. &quot;Agent forwarding should be enabled with caution&quot; in the man page is another massive understatement. Even if you <i>think</i> you need it, check the other responses in this thread for examples of how to work around it.</div><br/><div id="36794702" class="c"><input type="checkbox" id="c-36794702" checked=""/><div class="controls bullet"><span class="by">dumpsterdiver</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36794497">parent</a><span>|</span><a href="#36798170">next</a><span>|</span><label class="collapse" for="c-36794702">[-]</label><label class="expand" for="c-36794702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Never use agent forwarding<p>Agreed. As this exploit proves, it&#x27;s not even safe to log into your own servers using ssh forwarding if any service is exposed remotely, because if an attacker compromises that exposed service and gains root then they could extend the attack to your workstation, and that&#x27;s a huge deal - especially considering that you have the private key to log into that server on your computer (so it&#x27;s not an unsafe bet there might be other keys).</div><br/></div></div></div></div><div id="36798170" class="c"><input type="checkbox" id="c-36798170" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#36791441">parent</a><span>|</span><a href="#36794497">prev</a><span>|</span><a href="#36797014">next</a><span>|</span><label class="collapse" for="c-36798170">[-]</label><label class="expand" for="c-36798170">[1 more]</label></div><br/><div class="children"><div class="content">Are you saying that if you SFTP in to a client machine to upload a file to their server, it’s expected behavior that you’re willing to give them root on your machine?</div><br/></div></div><div id="36797014" class="c"><input type="checkbox" id="c-36797014" checked=""/><div class="controls bullet"><span class="by">ivlad</span><span>|</span><a href="#36791441">parent</a><span>|</span><a href="#36798170">prev</a><span>|</span><a href="#36792352">next</a><span>|</span><label class="collapse" for="c-36797014">[-]</label><label class="expand" for="c-36797014">[2 more]</label></div><br/><div class="children"><div class="content">“git pull” over SSH and have your system RCEd? I’d say it levels above “neat”.</div><br/><div id="36798169" class="c"><input type="checkbox" id="c-36798169" checked=""/><div class="controls bullet"><span class="by">franga2000</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36797014">parent</a><span>|</span><a href="#36792352">next</a><span>|</span><label class="collapse" for="c-36798169">[-]</label><label class="expand" for="c-36798169">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d need to go out of your way to make git pull do agent forwarding and I can&#x27;t really think of a reason why anyone would.</div><br/></div></div></div></div><div id="36792352" class="c"><input type="checkbox" id="c-36792352" checked=""/><div class="controls bullet"><span class="by">justsomeadvice0</span><span>|</span><a href="#36791441">parent</a><span>|</span><a href="#36797014">prev</a><span>|</span><a href="#36791957">next</a><span>|</span><label class="collapse" for="c-36792352">[-]</label><label class="expand" for="c-36792352">[3 more]</label></div><br/><div class="children"><div class="content">Lots of people end up with AgentForward on by default as a sort of &quot;make it work&quot; fix, and lots of people use `git+ssh` on untrusted servers. Here&#x27;s an example:<p><a href="https:&#x2F;&#x2F;abyssdomain.expert&#x2F;@filippo&#x2F;109659699817863532" rel="nofollow noreferrer">https:&#x2F;&#x2F;abyssdomain.expert&#x2F;@filippo&#x2F;109659699817863532</a><p>TBF this is a vulnerable config either way; but RCE on the client shouldn&#x27;t be possible.</div><br/><div id="36795479" class="c"><input type="checkbox" id="c-36795479" checked=""/><div class="controls bullet"><span class="by">doubled112</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36792352">parent</a><span>|</span><a href="#36792640">next</a><span>|</span><label class="collapse" for="c-36795479">[-]</label><label class="expand" for="c-36795479">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using a separate SSH config for git for a long time now.  Nice to see it wasn&#x27;t just paranoia.<p>Among the settings are explicitly disabling agent forwarding, and using a git specific identity (SSH key).</div><br/></div></div><div id="36792640" class="c"><input type="checkbox" id="c-36792640" checked=""/><div class="controls bullet"><span class="by">tinus_hn</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36792352">parent</a><span>|</span><a href="#36795479">prev</a><span>|</span><a href="#36791957">next</a><span>|</span><label class="collapse" for="c-36792640">[-]</label><label class="expand" for="c-36792640">[1 more]</label></div><br/><div class="children"><div class="content">I’m not so sure git is secure against a malicious server, even if you’re not simply pulling in a Makefile written by the attacker.</div><br/></div></div></div></div><div id="36791957" class="c"><input type="checkbox" id="c-36791957" checked=""/><div class="controls bullet"><span class="by">TechBro8615</span><span>|</span><a href="#36791441">parent</a><span>|</span><a href="#36792352">prev</a><span>|</span><a href="#36791776">next</a><span>|</span><label class="collapse" for="c-36791957">[-]</label><label class="expand" for="c-36791957">[1 more]</label></div><br/><div class="children"><div class="content">The attacker controlled destination server could be a compromised host, so this enables lateral movement from a deployed VM or remote dev machine into a developer laptop.</div><br/></div></div><div id="36791776" class="c"><input type="checkbox" id="c-36791776" checked=""/><div class="controls bullet"><span class="by">e28eta</span><span>|</span><a href="#36791441">parent</a><span>|</span><a href="#36791957">prev</a><span>|</span><a href="#36793804">next</a><span>|</span><label class="collapse" for="c-36791776">[-]</label><label class="expand" for="c-36791776">[5 more]</label></div><br/><div class="children"><div class="content">I don’t know how prevalent it is as a network architecture, but it seems like a bastion host &#x2F; jump box would be a juicy target for this exploit, since it’d let the attacker jump upstream.</div><br/><div id="36791920" class="c"><input type="checkbox" id="c-36791920" checked=""/><div class="controls bullet"><span class="by">jmalicki</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36791776">parent</a><span>|</span><a href="#36791923">next</a><span>|</span><label class="collapse" for="c-36791920">[-]</label><label class="expand" for="c-36791920">[3 more]</label></div><br/><div class="children"><div class="content">Sure, but first they have to root the bastion box.<p>If you root the bastion box, you have user credentials for anything inside the network.  Controlling the user&#x27;s laptop seems unlikely to be your most profitable next step.</div><br/><div id="36792996" class="c"><input type="checkbox" id="c-36792996" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36791920">parent</a><span>|</span><a href="#36792584">next</a><span>|</span><label class="collapse" for="c-36792996">[-]</label><label class="expand" for="c-36792996">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you root the bastion box, you have user credentials for anything inside the network.<p>But that&#x27;s not how a (properly-configured!) bastion host works.<p>You won&#x27;t have user credentials for anything UNLESS users are using Forward Agent (which they shouldn&#x27;t! simplest explanation here.. <a href="https:&#x2F;&#x2F;userify.com&#x2F;docs&#x2F;jumpbox" rel="nofollow noreferrer">https:&#x2F;&#x2F;userify.com&#x2F;docs&#x2F;jumpbox</a> ).<p>That&#x27;s the point behind using ProxyJump. Your connection actually jumps THROUGH the bastion box and doesn&#x27;t stop for interception along the way.<p>(And, of course, an attacker can&#x27;t do anything very useful with ssh public keys except for maybe traffic analysis or learning more target IP&#x27;s.)</div><br/></div></div><div id="36792584" class="c"><input type="checkbox" id="c-36792584" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36791920">parent</a><span>|</span><a href="#36792996">prev</a><span>|</span><a href="#36791923">next</a><span>|</span><label class="collapse" for="c-36792584">[-]</label><label class="expand" for="c-36792584">[1 more]</label></div><br/><div class="children"><div class="content">It really depends on the setup; ex. I imagine it&#x27;s easier to steal company code from a laptop than server, while data is the other way around.</div><br/></div></div></div></div><div id="36791923" class="c"><input type="checkbox" id="c-36791923" checked=""/><div class="controls bullet"><span class="by">akerl_</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36791776">parent</a><span>|</span><a href="#36791920">prev</a><span>|</span><a href="#36793804">next</a><span>|</span><label class="collapse" for="c-36791923">[-]</label><label class="expand" for="c-36791923">[1 more]</label></div><br/><div class="children"><div class="content">Increasingly, the role of a bastion host is served either by something like Teleport, which handles authn&#x2F;z and proxying without needing forwarded agents, or newer options in OpenSSH like ProxyJump where you hop via a bastion host but without ever forwarding your agent.</div><br/></div></div></div></div><div id="36793804" class="c"><input type="checkbox" id="c-36793804" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36791441">parent</a><span>|</span><a href="#36791776">prev</a><span>|</span><a href="#36791501">next</a><span>|</span><label class="collapse" for="c-36793804">[-]</label><label class="expand" for="c-36793804">[3 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t all SSH hosts potentially attacker-controlled? ;)</div><br/><div id="36794163" class="c"><input type="checkbox" id="c-36794163" checked=""/><div class="controls bullet"><span class="by">nocsi</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36793804">parent</a><span>|</span><a href="#36791501">next</a><span>|</span><label class="collapse" for="c-36794163">[-]</label><label class="expand" for="c-36794163">[2 more]</label></div><br/><div class="children"><div class="content">Yea, but there’s a security boundary wherein you don’t want the SSH host to be executing code in <i>your</i> environment. Of course, the attackers can backdoor sshd to log credentials, setup init scripts on the host to execute code every client login and other shenanigans.</div><br/><div id="36794448" class="c"><input type="checkbox" id="c-36794448" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36794163">parent</a><span>|</span><a href="#36791501">next</a><span>|</span><label class="collapse" for="c-36794448">[-]</label><label class="expand" for="c-36794448">[1 more]</label></div><br/><div class="children"><div class="content">Of course. So it&#x27;s not really that out of the question <i>if</i> you are using agent forwarding, so, yeah, this is a big deal.</div><br/></div></div></div></div></div></div><div id="36791501" class="c"><input type="checkbox" id="c-36791501" checked=""/><div class="controls bullet"><span class="by">malux85</span><span>|</span><a href="#36791441">parent</a><span>|</span><a href="#36793804">prev</a><span>|</span><a href="#36790649">next</a><span>|</span><label class="collapse" for="c-36791501">[-]</label><label class="expand" for="c-36791501">[4 more]</label></div><br/><div class="children"><div class="content">Yeah if I’m reading the technical analysis right, your conditions that you mention have to be correct and also the attacker must have “poisoned” library files on the targets machine so they can dlopen them, is that right?<p>Pretty unlikely</div><br/><div id="36791706" class="c"><input type="checkbox" id="c-36791706" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36791501">parent</a><span>|</span><a href="#36791545">next</a><span>|</span><label class="collapse" for="c-36791706">[-]</label><label class="expand" for="c-36791706">[2 more]</label></div><br/><div class="children"><div class="content">The libraries are on the client&#x27;s machine, not the server&#x27;s. And they&#x27;re not &quot;poisoned&quot;; the default distro-provided libs already provide the remote execution capabiity (eclipse-titan, libkf5sonnetui5, libns3-3v5 and systemd-boot packages from Ubuntu 22.04).</div><br/><div id="36792330" class="c"><input type="checkbox" id="c-36792330" checked=""/><div class="controls bullet"><span class="by">malux85</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36791706">parent</a><span>|</span><a href="#36791545">next</a><span>|</span><label class="collapse" for="c-36792330">[-]</label><label class="expand" for="c-36792330">[1 more]</label></div><br/><div class="children"><div class="content">Ahh I see I thought the attacker also had to have custom malicious libs deployed on the client machine I wasn&#x27;t sure if standard ones would do, thanks for clarifying that</div><br/></div></div></div></div><div id="36791545" class="c"><input type="checkbox" id="c-36791545" checked=""/><div class="controls bullet"><span class="by">sullivanmatt</span><span>|</span><a href="#36791441">root</a><span>|</span><a href="#36791501">parent</a><span>|</span><a href="#36791706">prev</a><span>|</span><a href="#36790649">next</a><span>|</span><label class="collapse" for="c-36791545">[-]</label><label class="expand" for="c-36791545">[1 more]</label></div><br/><div class="children"><div class="content">There must be a specific set of libs present on the victim (client), correct. Qualys claims that stock Ubuntu Desktop systems often have these libs, and that they haven&#x27;t looked into whether other distros tend to.<p>But yes, your point stands. Huge number of preconditions here to fulfill.</div><br/></div></div></div></div></div></div><div id="36790649" class="c"><input type="checkbox" id="c-36790649" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36791441">prev</a><span>|</span><a href="#36794006">next</a><span>|</span><label class="collapse" for="c-36790649">[-]</label><label class="expand" for="c-36790649">[34 more]</label></div><br/><div class="children"><div class="content">Even without this announcement, friends don&#x27;t let friends forward their ssh agent.  It essentially grants that machine access to your private keys.  A RCE vulnerability is strictly worse than key exposure, but you probably shouldn&#x27;t have been using it anyways.</div><br/><div id="36790842" class="c"><input type="checkbox" id="c-36790842" checked=""/><div class="controls bullet"><span class="by">willbicks</span><span>|</span><a href="#36790649">parent</a><span>|</span><a href="#36791976">next</a><span>|</span><label class="collapse" for="c-36790842">[-]</label><label class="expand" for="c-36790842">[6 more]</label></div><br/><div class="children"><div class="content">I prefer using hardware tokens (in most cases a PKCS#11 smart card) because it means that even with a forwarded SSH agent, every request to use my private key requires a PIN on my client which is verified by the isolated cryptographic processor. It&#x27;s impossible for my private key to leave that card and get cached anywhere else. While I haven&#x27;t enabled it on my Yubikey I understand they can do similar.<p>The downside is that compatibility in edge cases, while much better than I&#x27;d expect, is still not perfect. In particular Windows support outside of Putty gets challenging.</div><br/><div id="36792499" class="c"><input type="checkbox" id="c-36792499" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790842">parent</a><span>|</span><a href="#36791063">next</a><span>|</span><label class="collapse" for="c-36792499">[-]</label><label class="expand" for="c-36792499">[1 more]</label></div><br/><div class="children"><div class="content">The other downside is it&#x27;s much harder to do bulk operations against a fleet. It&#x27;s not reasonable to enter a PIN for each access when you need to push something to 1000 nodes. 100 nodes is probably ok, but not great.</div><br/></div></div><div id="36791063" class="c"><input type="checkbox" id="c-36791063" checked=""/><div class="controls bullet"><span class="by">gorkish</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790842">parent</a><span>|</span><a href="#36792499">prev</a><span>|</span><a href="#36791232">next</a><span>|</span><label class="collapse" for="c-36791063">[-]</label><label class="expand" for="c-36791063">[1 more]</label></div><br/><div class="children"><div class="content">The RCE is related to ssh-agent&#x27;s support for PKCS#11, so, yeah you are right this is a valid method to prevent key access or theft via the agent (I also have to approve every use of my PK), but in this case it&#x27;s not protecting against the RCE, and the workaround in the meantime is to disable PKCS#11 `ssh-agent -P &#x27;&#x27;`</div><br/></div></div><div id="36791232" class="c"><input type="checkbox" id="c-36791232" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790842">parent</a><span>|</span><a href="#36791063">prev</a><span>|</span><a href="#36792673">next</a><span>|</span><label class="collapse" for="c-36791232">[-]</label><label class="expand" for="c-36791232">[1 more]</label></div><br/><div class="children"><div class="content">or you could just use the -c option to ssh-add and be prompted every time the key is handed over</div><br/></div></div><div id="36792673" class="c"><input type="checkbox" id="c-36792673" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790842">parent</a><span>|</span><a href="#36791232">prev</a><span>|</span><a href="#36795516">next</a><span>|</span><label class="collapse" for="c-36792673">[-]</label><label class="expand" for="c-36792673">[1 more]</label></div><br/><div class="children"><div class="content">That won&#x27;t save you for this RCE!</div><br/></div></div><div id="36795516" class="c"><input type="checkbox" id="c-36795516" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790842">parent</a><span>|</span><a href="#36792673">prev</a><span>|</span><a href="#36791976">next</a><span>|</span><label class="collapse" for="c-36795516">[-]</label><label class="expand" for="c-36795516">[1 more]</label></div><br/><div class="children"><div class="content">ssh-agent forwarding does have some use cases with hardware keys.  However, most people aren&#x27;t using hardware keys.</div><br/></div></div></div></div><div id="36791976" class="c"><input type="checkbox" id="c-36791976" checked=""/><div class="controls bullet"><span class="by">TechBro8615</span><span>|</span><a href="#36790649">parent</a><span>|</span><a href="#36790842">prev</a><span>|</span><a href="#36791433">next</a><span>|</span><label class="collapse" for="c-36791976">[-]</label><label class="expand" for="c-36791976">[6 more]</label></div><br/><div class="children"><div class="content">I think SSH agent forwarding is a fairly common setup with VSCode Remote, where the developer wants to forward their keys to the remote dev server so that they can perform Git operations using their credentials.</div><br/><div id="36792659" class="c"><input type="checkbox" id="c-36792659" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36791976">parent</a><span>|</span><a href="#36791433">next</a><span>|</span><label class="collapse" for="c-36792659">[-]</label><label class="expand" for="c-36792659">[5 more]</label></div><br/><div class="children"><div class="content">Easy fix: generate private keys on the remote dev server and then use those keys instead of your own with git.</div><br/><div id="36794655" class="c"><input type="checkbox" id="c-36794655" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36792659">parent</a><span>|</span><a href="#36791433">next</a><span>|</span><label class="collapse" for="c-36794655">[-]</label><label class="expand" for="c-36794655">[4 more]</label></div><br/><div class="children"><div class="content">This exposes your private keys to a potentially less-trusted dev server. It also just doesn’t work with hardware tokens for the same reason.</div><br/><div id="36794815" class="c"><input type="checkbox" id="c-36794815" checked=""/><div class="controls bullet"><span class="by">TechBro8615</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36794655">parent</a><span>|</span><a href="#36791433">next</a><span>|</span><label class="collapse" for="c-36794815">[-]</label><label class="expand" for="c-36794815">[3 more]</label></div><br/><div class="children"><div class="content">Is it possible to configure SSH agent forwarding to only forward some specific private keys? Although I guess that wouldn&#x27;t protect you from the root problem of a vulnerable OpenSSH client.</div><br/><div id="36794909" class="c"><input type="checkbox" id="c-36794909" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36794815">parent</a><span>|</span><a href="#36795568">next</a><span>|</span><label class="collapse" for="c-36794909">[-]</label><label class="expand" for="c-36794909">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is it possible to configure SSH agent forwarding to only forward some specific private keys?<p>Not sure about that, but you can configure it so that it asks you for confirmation before every private key usage, so I suspect you could script a solution around that confirmation mechanism?<p>&gt; Although I guess that wouldn&#x27;t protect you from the root problem of a vulnerable OpenSSH client.<p>Yes – in the end, your SSH client, the terminal emulator it&#x27;s running in etc. are ultimately software too that could be remotely exploited.<p>I think in this particular case, there was a certain mismatch of threat expectations between the attack surfaces of ssh (the client, exposed to lots of potentially malicious input) and ssh-agent (mostly accepting input from semi-trusted processes on the same host – except for agent forwarding, of course).</div><br/></div></div><div id="36795568" class="c"><input type="checkbox" id="c-36795568" checked=""/><div class="controls bullet"><span class="by">jyxent</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36794815">parent</a><span>|</span><a href="#36794909">prev</a><span>|</span><a href="#36791433">next</a><span>|</span><label class="collapse" for="c-36795568">[-]</label><label class="expand" for="c-36795568">[1 more]</label></div><br/><div class="children"><div class="content">You can restrict keys when added so that they are only available on specific hosts: <a href="https:&#x2F;&#x2F;www.openssh.com&#x2F;agent-restrict.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.openssh.com&#x2F;agent-restrict.html</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="36791433" class="c"><input type="checkbox" id="c-36791433" checked=""/><div class="controls bullet"><span class="by">salawat</span><span>|</span><a href="#36790649">parent</a><span>|</span><a href="#36791976">prev</a><span>|</span><a href="#36790804">next</a><span>|</span><label class="collapse" for="c-36791433">[-]</label><label class="expand" for="c-36791433">[8 more]</label></div><br/><div class="children"><div class="content">Real talk though.<p>How do you manage ssh chaining then? Unique set of keys per user per machine?<p>Short of scp&#x27;ing your private key over from your starting box, I can&#x27;t really think of another way. Then again, if it&#x27;s not your box, (you don&#x27;t own the hardware have sole monopoly of root), you probably shouldn&#x27;t be ssh&#x27;ing from it anyway. I&#x27;ve always held there are no true secrets on a computer... Until multi-billion dollar companies decide to collude anyway.<p>Anywho, honest question. I&#x27;m a big fan of ssh roaming, never realized that ssh-agent was a thing, but after reading this, if I were to use it, I&#x27;d most certainly be doing it witout pkcs11 built in. Shotgunning shared libs for side-effects is absolutely mad. Need to slot that into my source code reading list.</div><br/><div id="36791477" class="c"><input type="checkbox" id="c-36791477" checked=""/><div class="controls bullet"><span class="by">jcotton42</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36791433">parent</a><span>|</span><a href="#36791488">next</a><span>|</span><label class="collapse" for="c-36791477">[-]</label><label class="expand" for="c-36791477">[1 more]</label></div><br/><div class="children"><div class="content">Depending on your usecase, ProxyJump may suffice <a href="https:&#x2F;&#x2F;www.redhat.com&#x2F;sysadmin&#x2F;ssh-proxy-bastion-proxyjump" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.redhat.com&#x2F;sysadmin&#x2F;ssh-proxy-bastion-proxyjump</a></div><br/></div></div><div id="36791488" class="c"><input type="checkbox" id="c-36791488" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36791433">parent</a><span>|</span><a href="#36791477">prev</a><span>|</span><a href="#36790804">next</a><span>|</span><label class="collapse" for="c-36791488">[-]</label><label class="expand" for="c-36791488">[6 more]</label></div><br/><div class="children"><div class="content">&gt; How do you manage ssh chaining then<p>ProxyJump in the .ssh&#x2F;config file.  If your SSH is too old to support ProxyJump, you should probably upgrade, but this works as well:<p><pre><code>   ProxyCommand ssh -q -W %h:%p jumpost</code></pre></div><br/><div id="36792243" class="c"><input type="checkbox" id="c-36792243" checked=""/><div class="controls bullet"><span class="by">salawat</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36791488">parent</a><span>|</span><a href="#36790804">next</a><span>|</span><label class="collapse" for="c-36792243">[-]</label><label class="expand" for="c-36792243">[5 more]</label></div><br/><div class="children"><div class="content">Noted... Guess I know what I&#x27;m doing today!<p>Edit: 
Nevermind, tried it, not sufficient for my use case.<p>I tend to do a lot of mesh-y bouncing around between servers, and -J seems to be more intended for a star&#x2F;hub&amp;spoke topology. Common ssh priv-key to all machines, or alternatively, a unique set of priv_keys per user per dest machine is about the way to go. You still have privilege escalations to worry about, but thems the breaks.<p>It&#x27;s a neat trick, I&#x27;ll give it that.</div><br/><div id="36793227" class="c"><input type="checkbox" id="c-36793227" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36792243">parent</a><span>|</span><a href="#36792732">next</a><span>|</span><label class="collapse" for="c-36793227">[-]</label><label class="expand" for="c-36793227">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not limited to star topologies; You can use ProxyJump for any topology that includes fixed routes from a client to a host.  Just add a separate host entry for each machine.<p>4 server example (this assumes your client can connect to only host C) with the following topology:<p><pre><code>    C -&gt; B -&gt; A
     \-&gt; D

</code></pre>
ssh configuration snippet:<p><pre><code>    Host A
      ProxyJump B

    Host B
      ProxyJump C

    Host D
      ProxyJump C
</code></pre>
This example is a tree-like topolgy, but you can use host aliases (i.e. add a HostName that is different from the host entry) to define any fixed route to any machine you like.</div><br/><div id="36794629" class="c"><input type="checkbox" id="c-36794629" checked=""/><div class="controls bullet"><span class="by">saltcured</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36793227">parent</a><span>|</span><a href="#36792732">next</a><span>|</span><label class="collapse" for="c-36794629">[-]</label><label class="expand" for="c-36794629">[1 more]</label></div><br/><div class="children"><div class="content">For me, the main use of agent-forwarding is that I need to use a command that expects to use SSH to get between leaf nodes.  For example git or rsync CLIs that need to manipulate the local filesystem and tunnel their own protocol over SSH to talk to another remote server.<p>At times, I&#x27;ve wished for something like uMatrix but for ssh-agent forwarding, so I could have policies for which peer-to-peer authentications should be allowed for which keys and whether these specific uses should require interactive confirmation.</div><br/></div></div></div></div><div id="36792732" class="c"><input type="checkbox" id="c-36792732" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36792243">parent</a><span>|</span><a href="#36793227">prev</a><span>|</span><a href="#36790804">next</a><span>|</span><label class="collapse" for="c-36792732">[-]</label><label class="expand" for="c-36792732">[2 more]</label></div><br/><div class="children"><div class="content">Just generate a new keypair there on your bounce box then. Don&#x27;t do -A because this RCE means that not only do you lose your keys, but you lose your laptop, too!</div><br/><div id="36794721" class="c"><input type="checkbox" id="c-36794721" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36792732">parent</a><span>|</span><a href="#36790804">next</a><span>|</span><label class="collapse" for="c-36794721">[-]</label><label class="expand" for="c-36794721">[1 more]</label></div><br/><div class="children"><div class="content">What if you don’t trust the box enough to store a private key, though?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36790804" class="c"><input type="checkbox" id="c-36790804" checked=""/><div class="controls bullet"><span class="by">starfallg</span><span>|</span><a href="#36790649">parent</a><span>|</span><a href="#36791433">prev</a><span>|</span><a href="#36794006">next</a><span>|</span><label class="collapse" for="c-36790804">[-]</label><label class="expand" for="c-36790804">[13 more]</label></div><br/><div class="children"><div class="content">Yup, and this is explained in detail in the ssh(1) man page. No-one should be using -A. Using a jump host via -J is the way to go.</div><br/><div id="36790864" class="c"><input type="checkbox" id="c-36790864" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790804">parent</a><span>|</span><a href="#36794006">next</a><span>|</span><label class="collapse" for="c-36790864">[-]</label><label class="expand" for="c-36790864">[12 more]</label></div><br/><div class="children"><div class="content">One use of -A, namely using the ssh server as a jumphost, is covered by -J. The general use of -A, namely doing operations on the ssh server that require keys from the ssh client, is not.<p>If I&#x27;m on machine foo and I want to connect to bar.example.org and clone a git repo there from baz.example.org, and baz.example.org requires an identity key that is in foo&#x27;s ssh agent, then -A is the only option.</div><br/><div id="36792692" class="c"><input type="checkbox" id="c-36792692" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790864">parent</a><span>|</span><a href="#36792716">next</a><span>|</span><label class="collapse" for="c-36792692">[-]</label><label class="expand" for="c-36792692">[5 more]</label></div><br/><div class="children"><div class="content">No, you might as well copy the keys over there for all the security you&#x27;re getting (actually, that&#x27;s safer given this RCE which compromises both sides, even given that there&#x27;s no real way to shred the leaked key, but of course I&#x27;m not actually suggesting this! they&#x27;re both really bad.)<p>Your best option is too easy: just generate a new keypair on foo.<p>Then you can populate baz.example.org with that public key instead of your own.</div><br/><div id="36793397" class="c"><input type="checkbox" id="c-36793397" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36792692">parent</a><span>|</span><a href="#36792716">next</a><span>|</span><label class="collapse" for="c-36793397">[-]</label><label class="expand" for="c-36793397">[4 more]</label></div><br/><div class="children"><div class="content">&gt;No, you might as well copy the keys over there<p>Only if the keys are insecure enough to be copied, ie not backed by an HSM, or backed by an HSM but marked exportable.<p>&gt;for all the security you&#x27;re getting (actually, that&#x27;s safer given this RCE which compromises both sides, even given that there&#x27;s no real way to shred the leaked key, but of course I&#x27;m not actually suggesting this! they&#x27;re both really bad.)<p>Connecting to a malicious SSH server is already dangeorous with or without this vulnerability, and with or without agent forwarding. Eg a malicious server can modify the shell to emit VT codes to mess up your terminal.<p>&gt;Your best option is too easy: just generate a new keypair on foo.<p>Sure, but this creates additional identities that baz.example.org must be taught to trust, which is not always desirable or even an option.</div><br/><div id="36793627" class="c"><input type="checkbox" id="c-36793627" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36793397">parent</a><span>|</span><a href="#36792716">next</a><span>|</span><label class="collapse" for="c-36793627">[-]</label><label class="expand" for="c-36793627">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Only if the keys are insecure enough to be copied, ie not backed by an HSM, or backed by an HSM but marked exportable.<p>Agent forwarding forwards <i>the keys</i> insecurely. If you can launch an agent-forwarded connection, then the HSM is already irrelevant.<p>&gt; &quot;Connecting to a malicious SSH server&quot; is already dangeorous with or without this vulnerability, and with or without agent forwarding. Eg a malicious server can modify the shell to emit VT codes to mess up your terminal.<p>yes, but messing up your terminal is not an RCE (and you should be able to fix it with stty sane). It&#x27;s just an annoyance and just tipped you off that obviously there&#x27;s something <i>wrong</i> there. :) Obviously you should be checking your host keys etc and ideally you woud never accidentally connect to a malicious server.<p>However, in the unlucky but perhaps inevitable event that you do connect to a malicious server, you shouldn&#x27;t risk exposing your entire client workstation! (through this or another RCE) or your SSH private keys! (through normal agent forwarding operation) with agent forwarding.<p>&gt; Sure, but this creates additional identities that baz.example.org must be taught to trust, which is not always desirable or even an option.<p>A key is not necessarily an identity. Most platforms permit more than one public key to be associated with a user, including github, gitlab, userify, etc.<p>However, ideally you are correct -- this would result in a new user account that has limited access to only the things it really needs (principle of least privilege).</div><br/><div id="36794503" class="c"><input type="checkbox" id="c-36794503" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36793627">parent</a><span>|</span><a href="#36792716">next</a><span>|</span><label class="collapse" for="c-36794503">[-]</label><label class="expand" for="c-36794503">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Agent forwarding forwards the keys insecurely. If you can launch an agent-forwarded connection, then the HSM is already irrelevant.<p>No? ssh-agent works fine with keys that are not exportable from the HSM. By the very definition it&#x27;s not possible for anything to export the key, ssh-agent or otherwise.<p>&gt;yes, but messing up your terminal is not an RCE<p>It has been, and can be again.<p><a href="https:&#x2F;&#x2F;www.cyberark.com&#x2F;resources&#x2F;threat-research-blog&#x2F;dont-trust-this-title-abusing-terminal-emulators-with-ansi-escape-characters" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cyberark.com&#x2F;resources&#x2F;threat-research-blog&#x2F;dont...</a></div><br/><div id="36797163" class="c"><input type="checkbox" id="c-36797163" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36794503">parent</a><span>|</span><a href="#36792716">next</a><span>|</span><label class="collapse" for="c-36797163">[-]</label><label class="expand" for="c-36797163">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not an RCE, it&#x27;s a DoS.<p>As the article describes most Windows terminal emulators just call SetWindowText when they get the set window title escape code. For some reason Windows implements that function very inefficiently so if it ends up being called in a tight loop your computer can freeze.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36792716" class="c"><input type="checkbox" id="c-36792716" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790864">parent</a><span>|</span><a href="#36792692">prev</a><span>|</span><a href="#36791036">next</a><span>|</span><label class="collapse" for="c-36792716">[-]</label><label class="expand" for="c-36792716">[1 more]</label></div><br/><div class="children"><div class="content">Another relatively popular use case is pam_ssh_agent_auth for passwordless-but-authenticated sudo. This, by definition, requires agent forwarding.<p>(I don&#x27;t use ssh-agent, I use gpg-agent with an SSH socket - I suppose I&#x27;m fine?)</div><br/></div></div><div id="36791036" class="c"><input type="checkbox" id="c-36791036" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36790864">parent</a><span>|</span><a href="#36792716">prev</a><span>|</span><a href="#36794006">next</a><span>|</span><label class="collapse" for="c-36791036">[-]</label><label class="expand" for="c-36791036">[5 more]</label></div><br/><div class="children"><div class="content">ssh-askpass is a great tool in these situations. It intercedes and allows you to manually control all key usage attempts.</div><br/><div id="36791554" class="c"><input type="checkbox" id="c-36791554" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36791036">parent</a><span>|</span><a href="#36791452">next</a><span>|</span><label class="collapse" for="c-36791554">[-]</label><label class="expand" for="c-36791554">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what relevance ssh-askpass has to what I wrote.</div><br/><div id="36793515" class="c"><input type="checkbox" id="c-36793515" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36791554">parent</a><span>|</span><a href="#36791452">next</a><span>|</span><label class="collapse" for="c-36793515">[-]</label><label class="expand" for="c-36793515">[2 more]</label></div><br/><div class="children"><div class="content">Right, this recipe isn&#x27;t well known.<p>`ssh-add -c` will cause your ssh agent to pop up with ssh-askpass every time it does an authentication. This is fiddly; You need to have configured your ssh-agent right, and there&#x27;s a slightly different version to use keychains on macos that&#x27;s equivalent.</div><br/><div id="36794536" class="c"><input type="checkbox" id="c-36794536" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36793515">parent</a><span>|</span><a href="#36791452">next</a><span>|</span><label class="collapse" for="c-36794536">[-]</label><label class="expand" for="c-36794536">[1 more]</label></div><br/><div class="children"><div class="content">Once again, I&#x27;m not sure what relevance this has to the discussion.</div><br/></div></div></div></div></div></div><div id="36791452" class="c"><input type="checkbox" id="c-36791452" checked=""/><div class="controls bullet"><span class="by">devnullbrain</span><span>|</span><a href="#36790649">root</a><span>|</span><a href="#36791036">parent</a><span>|</span><a href="#36791554">prev</a><span>|</span><a href="#36794006">next</a><span>|</span><label class="collapse" for="c-36791452">[-]</label><label class="expand" for="c-36791452">[1 more]</label></div><br/><div class="children"><div class="content">Ah, a skillful execution of Cunningham&#x27;s Law</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36794006" class="c"><input type="checkbox" id="c-36794006" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#36790649">prev</a><span>|</span><a href="#36790802">next</a><span>|</span><label class="collapse" for="c-36794006">[-]</label><label class="expand" for="c-36794006">[3 more]</label></div><br/><div class="children"><div class="content">musl libc refuses to implement dlclose[1] for precisely the reason that modules too often misbehave when dropped at runtime, and requiring this behavior is very rarely needed if ever. The number of modules that will be loaded is almost always bounded, and keeping a module around in memory is mostly harmless; certainly less harmful on average than trying to unload it.<p>[1] see <a href="https:&#x2F;&#x2F;wiki.musl-libc.org&#x2F;functional-differences-from-glibc.html#Unloading-libraries" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.musl-libc.org&#x2F;functional-differences-from-glibc...</a></div><br/><div id="36797375" class="c"><input type="checkbox" id="c-36797375" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#36794006">parent</a><span>|</span><a href="#36790802">next</a><span>|</span><label class="collapse" for="c-36797375">[-]</label><label class="expand" for="c-36797375">[2 more]</label></div><br/><div class="children"><div class="content">&gt; musl libc refuses to implement dlclose[1] for precisely the reason that modules too often misbehave when dropped at runtime,<p>Which is some rather silly logic, because now musl&#x27;s libdl is just <i>one more</i> module that misbehaves at runtime by refusing to clean up after itself. Other libraries being sloppy about resource cleanup is no excuse for musl to abdicate its own responsibilities.<p>&gt; and requiring this behavior is very rarely needed if ever. The number of modules that will be loaded is almost always bounded, and keeping a module around in memory is mostly harmless;<p>I take it you&#x27;ve never used an application that hot-reloads plugins? Who cares about memory leaks, right?<p>&gt; certainly less harmful on average than trying to unload it.<p>That&#x27;s for the application to decide, not musl. If I don&#x27;t trust a library to behave properly, I will either not dlopen it at all, or I&#x27;ll dlopen it in an appropriately sandboxed subprocess and interact with it via pipes.</div><br/><div id="36797648" class="c"><input type="checkbox" id="c-36797648" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#36794006">root</a><span>|</span><a href="#36797375">parent</a><span>|</span><a href="#36790802">next</a><span>|</span><label class="collapse" for="c-36797648">[-]</label><label class="expand" for="c-36797648">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I take it you&#x27;ve never used an application that hot-reloads plugins?<p>Used <i>and</i> implemented many times. Sometimes this could be a problem, but IME most plugin architectures I&#x27;ve seen don&#x27;t rely on static constructors or destructors for implicit registration&#x2F;deregistration of callbacks. Among other reasons, it&#x27;s a landmine of multi-threading issues and glibc itself has historically had many bugs related to this, albeit mostly a consequence of glibc implementing (until recently) libpthread separate from libc.<p>Also, POSIX does not guarantee that dlclose does anything: &quot;An application writer may use dlclose() to make a statement of intent on the part of the process, but this statement does not create any requirement upon the implementation.&quot;<p>&gt; Who cares about memory leaks, right?<p>I can&#x27;t find the blog post now, but IIRC Solaris made getenv thread-safe by never deallocating any memory allocated for the environ array or its contents. The blog post had a curious and memorable defense which explained how the memory usage was asymptotically bounded, similar to how hash table operations are described as asymptotically O(1) in time. And Solaris cares very much about memory management--unlike Linux or FreeBSD it implements strict memory accounting, so no OOM killer non-sense.<p>Is it ideal? No. But these are legitimate decisions taken in light of lots of experience, and if you want to write truly robust applications one has to pay attention to standards, implementation details, and best practices. IME best practice wrt module systems on Unix and the open source world generally has always been to avoid implicit registration&#x2F;deregistration of callbacks. I believe the same is true in the Windows world, though I&#x27;ve never written much software for Windows. (Anyone know if FreeLibrary immediately invokes static destructors?)<p>FWIW, I have implemented hacks which relied on static constructors and where hot reloading was more problematic in the absence of static destructors. For example, I once implemented a proof of concept for automatic runtime reloading of SSL certificates and keys in the Splunk server by writing a library interposer (supporting FreeBSD, Linux, macOS, and Solaris) that installed global OpenSSL SSL_CTX callbacks. So I know why these things could be useful. But that example was a PoC hack. And even in situations where dlcose is supported as one might naively expect, you can still easily run into similar gotchas, like a user loading a module twice under different names. You have to choose either to deal with it the hard way, or disclaim support for such niche cases.</div><br/></div></div></div></div></div></div><div id="36790802" class="c"><input type="checkbox" id="c-36790802" checked=""/><div class="controls bullet"><span class="by">apienx</span><span>|</span><a href="#36794006">prev</a><span>|</span><a href="#36790632">next</a><span>|</span><label class="collapse" for="c-36790802">[-]</label><label class="expand" for="c-36790802">[1 more]</label></div><br/><div class="children"><div class="content">Agent forwarding is discouraged by the OpenSSH crew. Yet, it&#x27;s commonly used because of the convenience it affords.<p>&quot;Agent forwarding should be enabled with caution. Users with the ability to bypass file permissions on the remote host (for the agent&#x27;s UNIX-domain socket) can access the local agent through the forwarded connection.&quot;
<a href="https:&#x2F;&#x2F;man.openbsd.org&#x2F;ssh.1" rel="nofollow noreferrer">https:&#x2F;&#x2F;man.openbsd.org&#x2F;ssh.1</a><p>Glad the vulnerability got fixed.</div><br/></div></div><div id="36790632" class="c"><input type="checkbox" id="c-36790632" checked=""/><div class="controls bullet"><span class="by">binkHN</span><span>|</span><a href="#36790802">prev</a><span>|</span><a href="#36792374">next</a><span>|</span><label class="collapse" for="c-36790632">[-]</label><label class="expand" for="c-36790632">[1 more]</label></div><br/><div class="children"><div class="content">Full details: <a href="https:&#x2F;&#x2F;www.qualys.com&#x2F;2023&#x2F;07&#x2F;19&#x2F;cve-2023-38408&#x2F;rce-openssh-forwarded-ssh-agent.txt" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.qualys.com&#x2F;2023&#x2F;07&#x2F;19&#x2F;cve-2023-38408&#x2F;rce-openssh...</a></div><br/></div></div><div id="36792374" class="c"><input type="checkbox" id="c-36792374" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790632">prev</a><span>|</span><a href="#36791058">next</a><span>|</span><label class="collapse" for="c-36792374">[-]</label><label class="expand" for="c-36792374">[11 more]</label></div><br/><div class="children"><div class="content">Note: you are not vulnerable if you&#x27;re not doing agent forwarding (-A).<p>Honestly, you probably should never do -A anyway; use -J (proxyjump) instead.<p><a href="https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man1&#x2F;ssh.1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man1&#x2F;ssh.1.html</a><p><a href="https:&#x2F;&#x2F;userify.com&#x2F;docs&#x2F;jumpbox" rel="nofollow noreferrer">https:&#x2F;&#x2F;userify.com&#x2F;docs&#x2F;jumpbox</a></div><br/><div id="36792489" class="c"><input type="checkbox" id="c-36792489" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#36792374">parent</a><span>|</span><a href="#36792526">next</a><span>|</span><label class="collapse" for="c-36792489">[-]</label><label class="expand" for="c-36792489">[7 more]</label></div><br/><div class="children"><div class="content">There are situations where `-J` won&#x27;t work.<p>For example, if I&#x27;m on a remote server and I want to clone or pull from a private repository, or push to any repository<p>In fact, VS code expects you to forward an agent when developing on a remote instance with the remote-ssh extension. I believe it uses it for syncing repo changes primarily<p>I agree though that you should consider it insecure to forward a connection to a shared host if it has other users who are equally privileged, or more privileged</div><br/><div id="36792631" class="c"><input type="checkbox" id="c-36792631" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36792374">root</a><span>|</span><a href="#36792489">parent</a><span>|</span><a href="#36797448">next</a><span>|</span><label class="collapse" for="c-36792631">[-]</label><label class="expand" for="c-36792631">[5 more]</label></div><br/><div class="children"><div class="content">&gt; There are situations where `-J` won&#x27;t work.<p>That is true, but actually you should avoid -A in those situations also.<p>&gt; In fact, VS code expects you to forward an agent when developing on a remote instance with the remote-ssh extension. I believe it uses it for syncing repo changes primarily<p>That&#x27;s the case if you&#x27;re ever trying to initiate an SSH connection via Git <i>from</i> a remote host. That&#x27;s because the actual SSH connection isn&#x27;t being triggered on your desktop or laptop, where -J would do it, but because it&#x27;s being initiated right on the remote server itself.<p>Let&#x27;s call the remote server VSCODE (your desktop-in-the-cloud), your laptop&#x2F;desktop LAPTOP, and the remote repo GITHUB.<p>So, the correct answer there is actually counter-intuitive:<p>Generate a private key on VSCODE (not LAPTOP) for that GITHUB repo. This key will be used only on that originating remote server (VSCODE), never anywhere else.<p>In fact, that repo key will ideally be scoped as tightly as possible in Github&#x2F;Gitlab&#x2F;etc.<p>As a general rule of thumb, generate at least one SSH key for each &quot;location&quot; where you&#x27;ll be logging into another location. Keep your connections point-to-point unless you can use proxyjump.</div><br/><div id="36792733" class="c"><input type="checkbox" id="c-36792733" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#36792374">root</a><span>|</span><a href="#36792631">parent</a><span>|</span><a href="#36794955">next</a><span>|</span><label class="collapse" for="c-36792733">[-]</label><label class="expand" for="c-36792733">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Generate a private key on VSCODE (not LAPTOP) for that GITHUB repo. This key will be used only on that originating remote server (VSCODE), never anywhere else.<p>Deploy keys are more secure in most situations, but I&#x27;m not convinced that generating a bunch of additional keys with write access to your repo is <i>always</i> more secure.<p>Regardless, it doesn&#x27;t really fulfill the same need of &quot;get access to repo from cloud desktop asap&quot;. I work with 20-30 private repos at my company, and I don&#x27;t have admin access to most of them (so I couldn&#x27;t create deploy keys for them). That would need to be kicked up and down a request pipeline, for each user accessing remotely, for each host they&#x27;re accessing it from. It&#x27;s <i>much</i> easier to Get The Work Done if I just forward my agent.<p>And sure, the company could maybe set up better practices (though again, I&#x27;m not even really clear on how much more secure it would be to generate untold numbers of deploy keys), but I&#x27;m more likely to get the axe for not producing fast enough than they are to make sweeping changes to their security practices.</div><br/><div id="36793031" class="c"><input type="checkbox" id="c-36793031" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36792374">root</a><span>|</span><a href="#36792733">parent</a><span>|</span><a href="#36794955">next</a><span>|</span><label class="collapse" for="c-36793031">[-]</label><label class="expand" for="c-36793031">[2 more]</label></div><br/><div class="children"><div class="content">Then just create a key on that box and use it for <i>all</i> of your repos (add it to your github keychain); you&#x27;re still much better off than with one key to rule them all (and one RCE to rule your laptop ha)</div><br/><div id="36793679" class="c"><input type="checkbox" id="c-36793679" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#36792374">root</a><span>|</span><a href="#36793031">parent</a><span>|</span><a href="#36794955">next</a><span>|</span><label class="collapse" for="c-36793679">[-]</label><label class="expand" for="c-36793679">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good point, probably the best way to do this, but does require manual management steps for every VM you want to use (which is perhaps a feature)</div><br/></div></div></div></div></div></div><div id="36794955" class="c"><input type="checkbox" id="c-36794955" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36792374">root</a><span>|</span><a href="#36792631">parent</a><span>|</span><a href="#36792733">prev</a><span>|</span><a href="#36797448">next</a><span>|</span><label class="collapse" for="c-36794955">[-]</label><label class="expand" for="c-36794955">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Generate a private key on VSCODE (not LAPTOP) for that GITHUB repo. This key will be used only on that originating remote server (VSCODE), never anywhere else.<p>This gives anyone compromising the server at a point in time persistent access to your Github repo.<p>Ultimately, there&#x27;s two or three different possible models here (transparent SSH proxying, agent forwarding, key-per-host), with different tradeoffs. Although transparent proxying is usually the safest, it doesn&#x27;t always work and here&#x27;s no one-size-fits-all.</div><br/></div></div></div></div><div id="36797448" class="c"><input type="checkbox" id="c-36797448" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#36792374">root</a><span>|</span><a href="#36792489">parent</a><span>|</span><a href="#36792631">prev</a><span>|</span><a href="#36792526">next</a><span>|</span><label class="collapse" for="c-36797448">[-]</label><label class="expand" for="c-36797448">[1 more]</label></div><br/><div class="children"><div class="content">VS Code forcing people to follow bad practice, I&#x27;m shocked, SHOCKED, I tell you.</div><br/></div></div></div></div><div id="36792526" class="c"><input type="checkbox" id="c-36792526" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36792374">parent</a><span>|</span><a href="#36792489">prev</a><span>|</span><a href="#36791058">next</a><span>|</span><label class="collapse" for="c-36792526">[-]</label><label class="expand" for="c-36792526">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Honestly, you probably should never do -A anyway; use -J (proxyjump) instead.<p>I want to copy files between servers, ex. `ssh -A serverA` then `rsync .&#x2F;foo serverB:`. Is there a way to do that without `ssh -A`? (And obviously without creating an actual private SSH key on either server)</div><br/><div id="36792752" class="c"><input type="checkbox" id="c-36792752" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36792374">root</a><span>|</span><a href="#36792526">parent</a><span>|</span><a href="#36791058">next</a><span>|</span><label class="collapse" for="c-36792752">[-]</label><label class="expand" for="c-36792752">[2 more]</label></div><br/><div class="children"><div class="content">Yes. Create a temporary (or permanent) private key on server A and then put its public key in server B.<p>That&#x27;s the correct way to handle this situation, definitely not -A.</div><br/><div id="36794970" class="c"><input type="checkbox" id="c-36794970" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36792374">root</a><span>|</span><a href="#36792752">parent</a><span>|</span><a href="#36791058">next</a><span>|</span><label class="collapse" for="c-36794970">[-]</label><label class="expand" for="c-36794970">[1 more]</label></div><br/><div class="children"><div class="content">This implies a much higher level of trust in a dev server than might be warranted, since an attacker can exfiltrate keys from that server and then permanently use them from elsewhere. Agent forwarding doesn&#x27;t have that problem.<p>&gt; That&#x27;s the correct way to handle this situation, definitely not -A.<p>Maybe for your situation; certainly not for all. If agent forwarding was strictly inferior to ProxyJump&#x2F;ProxyCommand, it would have been deprecated.</div><br/></div></div></div></div></div></div></div></div><div id="36791058" class="c"><input type="checkbox" id="c-36791058" checked=""/><div class="controls bullet"><span class="by">shandor</span><span>|</span><a href="#36792374">prev</a><span>|</span><a href="#36790408">next</a><span>|</span><label class="collapse" for="c-36791058">[-]</label><label class="expand" for="c-36791058">[5 more]</label></div><br/><div class="children"><div class="content">I can’t parse the exact meaning of the ”victim system” and ”attacker controlled system” in the OpenSSH release page.<p>Does this vulnerability allow the attacker to compromise the original system where the user starts the agent-forwarded connection? Or ”only” compromise machines forward from the jump host?<p><a href="http:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html#9.3p2" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html#9.3p2</a></div><br/><div id="36791188" class="c"><input type="checkbox" id="c-36791188" checked=""/><div class="controls bullet"><span class="by">perlgeek</span><span>|</span><a href="#36791058">parent</a><span>|</span><a href="#36790408">next</a><span>|</span><label class="collapse" for="c-36791188">[-]</label><label class="expand" for="c-36791188">[4 more]</label></div><br/><div class="children"><div class="content">If an attacker can compromise the jump host, they can compromise the system where the user starts the agent-forwarded connection.</div><br/><div id="36792784" class="c"><input type="checkbox" id="c-36792784" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36791058">root</a><span>|</span><a href="#36791188">parent</a><span>|</span><a href="#36791431">next</a><span>|</span><label class="collapse" for="c-36792784">[-]</label><label class="expand" for="c-36792784">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s 100% correct. This is why no one should use agent forwarding with a jumpbox. Only -J. (see <a href="https:&#x2F;&#x2F;userify.com&#x2F;docs&#x2F;jumpbox" rel="nofollow noreferrer">https:&#x2F;&#x2F;userify.com&#x2F;docs&#x2F;jumpbox</a> )<p>Another point is that no one should have any real access to the jumpbox and it should be as minimal and stripped-down as possible. It&#x27;s literally your bastion host, so you&#x27;ve got to keep it as strong as possible.</div><br/></div></div><div id="36791431" class="c"><input type="checkbox" id="c-36791431" checked=""/><div class="controls bullet"><span class="by">shandor</span><span>|</span><a href="#36791058">root</a><span>|</span><a href="#36791188">parent</a><span>|</span><a href="#36792784">prev</a><span>|</span><a href="#36790408">next</a><span>|</span><label class="collapse" for="c-36791431">[-]</label><label class="expand" for="c-36791431">[2 more]</label></div><br/><div class="children"><div class="content">Ouch, that’s horrible.<p>Time to prompt everyone at $WORK to upgrade…</div><br/><div id="36791481" class="c"><input type="checkbox" id="c-36791481" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36791058">root</a><span>|</span><a href="#36791431">parent</a><span>|</span><a href="#36790408">next</a><span>|</span><label class="collapse" for="c-36791481">[-]</label><label class="expand" for="c-36791481">[1 more]</label></div><br/><div class="children"><div class="content">To be clear, agent-forwarding to a (potentially) malicious ssh server has always been a bad idea. Yes TFA&#x27;s bug makes it a <i>worse</i> idea and it&#x27;s absolutely worth it to patch it, but you should not be agent-forwarding to (potentially) malicious ssh servers in the first place.</div><br/></div></div></div></div></div></div></div></div><div id="36790408" class="c"><input type="checkbox" id="c-36790408" checked=""/><div class="controls bullet"><span class="by">WhackyIdeas</span><span>|</span><a href="#36791058">prev</a><span>|</span><a href="#36795342">next</a><span>|</span><label class="collapse" for="c-36790408">[-]</label><label class="expand" for="c-36790408">[12 more]</label></div><br/><div class="children"><div class="content">Am I reading this right - any system with ssh-agent installed by default is vulnerable?<p>The link is short on specifics.</div><br/><div id="36790504" class="c"><input type="checkbox" id="c-36790504" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#36790408">parent</a><span>|</span><a href="#36790521">next</a><span>|</span><label class="collapse" for="c-36790504">[-]</label><label class="expand" for="c-36790504">[7 more]</label></div><br/><div class="children"><div class="content">As far as I read it, it&#x27;s about <i>forwarded</i> ssh agents. Basically, if you `ssh -A user@system`, something might be able to execute commands locally. For example, this might turn messy for infrastructures using jump-hosts extensively, if people are used to &lt;ssh -A jumphost&gt; so they can easily &lt;ssh system&gt; afterwards. If you pop the jump host, you could pivot to the workstations with this.<p>At the same time, ssh-agent forwarding makes me queasy from a security perspective even without this. As far as I know, if you &lt;ssh -A&gt; into a system, admins with privileges on the system can gain access to your local ssh-agent already. In the example of the jump host, if you popped the jump host and stuck around for a while, you could probably harvest SSH keys and have some fun later.</div><br/><div id="36790538" class="c"><input type="checkbox" id="c-36790538" checked=""/><div class="controls bullet"><span class="by">spladug</span><span>|</span><a href="#36790408">root</a><span>|</span><a href="#36790504">parent</a><span>|</span><a href="#36790521">next</a><span>|</span><label class="collapse" for="c-36790538">[-]</label><label class="expand" for="c-36790538">[6 more]</label></div><br/><div class="children"><div class="content">FWIW, `ProxyJump` is a safer way to go through a bastion without having to expose your agent to either the bastion or the target host behind it.</div><br/><div id="36790655" class="c"><input type="checkbox" id="c-36790655" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#36790408">root</a><span>|</span><a href="#36790538">parent</a><span>|</span><a href="#36790620">next</a><span>|</span><label class="collapse" for="c-36790655">[-]</label><label class="expand" for="c-36790655">[4 more]</label></div><br/><div class="children"><div class="content">Useful, I didn&#x27;t know that so far.<p>We don&#x27;t use bastion servers. My only real use case for ssh agent forwarding is if I need some scp &#x2F; rsync between two remote systems during emergencies and those systems have no trust via SSH keys setup between them. In that very specific case, I don&#x27;t know a better way than &lt;ssh -A&gt; to the first system and have some &lt;rsync -e ssh&gt; from there to the second system. Still doesn&#x27;t feel great, even though I know only the people who could steal my keys are on my team.</div><br/><div id="36790749" class="c"><input type="checkbox" id="c-36790749" checked=""/><div class="controls bullet"><span class="by">spladug</span><span>|</span><a href="#36790408">root</a><span>|</span><a href="#36790655">parent</a><span>|</span><a href="#36790620">next</a><span>|</span><label class="collapse" for="c-36790749">[-]</label><label class="expand" for="c-36790749">[3 more]</label></div><br/><div class="children"><div class="content">Ah yeah. Not sure on that one. scp does have the `-3` option to copy between two remote hosts via the local host, but that can  be significantly slower if the remote hosts are in the same network and local host is not.</div><br/><div id="36790989" class="c"><input type="checkbox" id="c-36790989" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#36790408">root</a><span>|</span><a href="#36790749">parent</a><span>|</span><a href="#36790620">next</a><span>|</span><label class="collapse" for="c-36790989">[-]</label><label class="expand" for="c-36790989">[2 more]</label></div><br/><div class="children"><div class="content">Exactly. If I need to move a few megabytes around, &lt;scp -3&gt; and a coffee or a few simple tickets is a good way. A year ago or so, I needed 600GB moved between two systems ASAP during an outage that&#x27;d turn into a money-bleed at 6am. If I piped that through the VPN and my workstation, I&#x27;d probably still be waiting today.</div><br/><div id="36791154" class="c"><input type="checkbox" id="c-36791154" checked=""/><div class="controls bullet"><span class="by">LinuxBender</span><span>|</span><a href="#36790408">root</a><span>|</span><a href="#36790989">parent</a><span>|</span><a href="#36790620">next</a><span>|</span><label class="collapse" for="c-36791154">[-]</label><label class="expand" for="c-36791154">[1 more]</label></div><br/><div class="children"><div class="content">Some time take a look at lftp [1] <i>and its mirror subsystem</i> for this.  It can break up a batch of files or even one large file into multiple SFTP streams.  Another upside is that it can replicate most rsync behavior in a SFTP-Only Chroot account.  Downside is that without a corresponding daemon <i>like rsync</i> on the other end directory enumeration is slow which isn&#x27;t a problem if one does not have a complex directory structure.<p>Play around with the built in rate limit options <i>total and per thread</i> to keep the network people happy.<p>[1] - <a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;lftp" rel="nofollow noreferrer">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;lftp</a></div><br/></div></div></div></div></div></div></div></div><div id="36790620" class="c"><input type="checkbox" id="c-36790620" checked=""/><div class="controls bullet"><span class="by">chaosite</span><span>|</span><a href="#36790408">root</a><span>|</span><a href="#36790538">parent</a><span>|</span><a href="#36790655">prev</a><span>|</span><a href="#36790521">next</a><span>|</span><label class="collapse" for="c-36790620">[-]</label><label class="expand" for="c-36790620">[1 more]</label></div><br/><div class="children"><div class="content">And since the person you&#x27;re replying to was mentioning command-line parameters, it&#x27;s worth mentioning that this can be done with `ssh -J jumphost user@system`.</div><br/></div></div></div></div></div></div><div id="36790521" class="c"><input type="checkbox" id="c-36790521" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36790408">parent</a><span>|</span><a href="#36790504">prev</a><span>|</span><a href="#36790455">next</a><span>|</span><label class="collapse" for="c-36790521">[-]</label><label class="expand" for="c-36790521">[1 more]</label></div><br/><div class="children"><div class="content">Well, any system that auto maps the stack executable when loading a library. There are details on the specific requirements in the advisory.<p><a href="https:&#x2F;&#x2F;www.qualys.com&#x2F;2023&#x2F;07&#x2F;19&#x2F;cve-2023-38408&#x2F;rce-openssh-forwarded-ssh-agent.txt" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.qualys.com&#x2F;2023&#x2F;07&#x2F;19&#x2F;cve-2023-38408&#x2F;rce-openssh...</a></div><br/></div></div><div id="36790455" class="c"><input type="checkbox" id="c-36790455" checked=""/><div class="controls bullet"><span class="by">kam</span><span>|</span><a href="#36790408">parent</a><span>|</span><a href="#36790521">prev</a><span>|</span><a href="#36790471">next</a><span>|</span><label class="collapse" for="c-36790455">[-]</label><label class="expand" for="c-36790455">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s exploitable only by a SSH server that you connect to with agent forwarding enabled (i.e. one that you&#x27;re already trusting with access to your SSH keys).</div><br/></div></div><div id="36790471" class="c"><input type="checkbox" id="c-36790471" checked=""/><div class="controls bullet"><span class="by">jonas-w</span><span>|</span><a href="#36790408">parent</a><span>|</span><a href="#36790455">prev</a><span>|</span><a href="#36790777">next</a><span>|</span><label class="collapse" for="c-36790471">[-]</label><label class="expand" for="c-36790471">[1 more]</label></div><br/><div class="children"><div class="content">If I read this correctly it is only when you forward your ssh-agent with the &quot;-A&quot; or &quot;ForwardAgent&quot; option</div><br/></div></div><div id="36790777" class="c"><input type="checkbox" id="c-36790777" checked=""/><div class="controls bullet"><span class="by">more_corn</span><span>|</span><a href="#36790408">parent</a><span>|</span><a href="#36790471">prev</a><span>|</span><a href="#36795342">next</a><span>|</span><label class="collapse" for="c-36790777">[-]</label><label class="expand" for="c-36790777">[1 more]</label></div><br/><div class="children"><div class="content">I’d you forward your agent to a remote host, that host can mess with you.</div><br/></div></div></div></div><div id="36795342" class="c"><input type="checkbox" id="c-36795342" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#36790408">prev</a><span>|</span><a href="#36790484">next</a><span>|</span><label class="collapse" for="c-36795342">[-]</label><label class="expand" for="c-36795342">[1 more]</label></div><br/><div class="children"><div class="content">Why in the year of our Lord two thousand and twenty three do we still tolerate loading shared libraries with executable stacks?</div><br/></div></div><div id="36790484" class="c"><input type="checkbox" id="c-36790484" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#36795342">prev</a><span>|</span><a href="#36791522">next</a><span>|</span><label class="collapse" for="c-36790484">[-]</label><label class="expand" for="c-36790484">[6 more]</label></div><br/><div class="children"><div class="content">why publish this before the patches are out?</div><br/><div id="36790498" class="c"><input type="checkbox" id="c-36790498" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36790484">parent</a><span>|</span><a href="#36791522">next</a><span>|</span><label class="collapse" for="c-36790498">[-]</label><label class="expand" for="c-36790498">[5 more]</label></div><br/><div class="children"><div class="content">The patches are out.</div><br/><div id="36794984" class="c"><input type="checkbox" id="c-36794984" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36790484">root</a><span>|</span><a href="#36790498">parent</a><span>|</span><a href="#36790542">next</a><span>|</span><label class="collapse" for="c-36794984">[-]</label><label class="expand" for="c-36794984">[1 more]</label></div><br/><div class="children"><div class="content">It was arguably still not necessary to post the complete exploit chain&#x2F;proof-of-concept on the same day, since the chaining of four different shared libraries present in Ubuntu probably does not immediately follow from the diff introduced by the fix.</div><br/></div></div><div id="36790542" class="c"><input type="checkbox" id="c-36790542" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#36790484">root</a><span>|</span><a href="#36790498">parent</a><span>|</span><a href="#36794984">prev</a><span>|</span><a href="#36791522">next</a><span>|</span><label class="collapse" for="c-36790542">[-]</label><label class="expand" for="c-36790542">[3 more]</label></div><br/><div class="children"><div class="content">where? i couldn&#x27;t find them on the openssh webpage and my distro has not released a new openssh either.<p>edit: nvm. i see the release now. just no release for openbsd itself it seems.</div><br/><div id="36790694" class="c"><input type="checkbox" id="c-36790694" checked=""/><div class="controls bullet"><span class="by">davidcuddeback</span><span>|</span><a href="#36790484">root</a><span>|</span><a href="#36790542">parent</a><span>|</span><a href="#36790613">next</a><span>|</span><label class="collapse" for="c-36790694">[-]</label><label class="expand" for="c-36790694">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>just no release for openbsd itself it seems.</i><p>It was posted to announce@openbsd.org a few hours ago. Binary patches are available through syspatch and source patches on the errata page.</div><br/></div></div><div id="36790613" class="c"><input type="checkbox" id="c-36790613" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36790484">root</a><span>|</span><a href="#36790542">parent</a><span>|</span><a href="#36790694">prev</a><span>|</span><a href="#36791522">next</a><span>|</span><label class="collapse" for="c-36790613">[-]</label><label class="expand" for="c-36790613">[1 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html#9.3p2" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html#9.3p2</a></div><br/></div></div></div></div></div></div></div></div><div id="36791522" class="c"><input type="checkbox" id="c-36791522" checked=""/><div class="controls bullet"><span class="by">kneebonian</span><span>|</span><a href="#36790484">prev</a><span>|</span><a href="#36794113">next</a><span>|</span><label class="collapse" for="c-36791522">[-]</label><label class="expand" for="c-36791522">[2 more]</label></div><br/><div class="children"><div class="content">Can I just say I know it&#x27;s really dumb, but I loved that they published the explanation as a simple txt file, instead of setting up some whizbang website for it, or embedding it in their company blog.<p><a href="https:&#x2F;&#x2F;www.qualys.com&#x2F;2023&#x2F;07&#x2F;19&#x2F;cve-2023-38408&#x2F;rce-openssh-forwarded-ssh-agent.txt" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.qualys.com&#x2F;2023&#x2F;07&#x2F;19&#x2F;cve-2023-38408&#x2F;rce-openssh...</a></div><br/><div id="36797024" class="c"><input type="checkbox" id="c-36797024" checked=""/><div class="controls bullet"><span class="by">py4</span><span>|</span><a href="#36791522">parent</a><span>|</span><a href="#36794113">next</a><span>|</span><label class="collapse" for="c-36797024">[-]</label><label class="expand" for="c-36797024">[1 more]</label></div><br/><div class="children"><div class="content">Used to be common for hacking-related docs. Miss those<p><a href="http:&#x2F;&#x2F;phrack.org&#x2F;issues&#x2F;49&#x2F;15.html#article" rel="nofollow noreferrer">http:&#x2F;&#x2F;phrack.org&#x2F;issues&#x2F;49&#x2F;15.html#article</a></div><br/></div></div></div></div><div id="36794113" class="c"><input type="checkbox" id="c-36794113" checked=""/><div class="controls bullet"><span class="by">1letterunixname</span><span>|</span><a href="#36791522">prev</a><span>|</span><a href="#36790883">next</a><span>|</span><label class="collapse" for="c-36794113">[-]</label><label class="expand" for="c-36794113">[1 more]</label></div><br/><div class="children"><div class="content">I use a USB security key for gpg-agent.<p>gpg-agent is used as an ssh-agent replacement (also replaces the venerable monkeysphere script). gpg agent forwarding is also needed via StreamLocalBindUnlink for signing built RPMs in a docker container on a remote (local LAN) Docker host. Sometimes rarely, I need to enable &quot;ssh-agent&quot; forwarding where I probably could proxyjump instead. My interactive ssh workflow is sometimes slowed as I use TOTP (via PAM) for 2FA. Noninteractive system accounts get dedicated ssh keys. host keys are constantly scanned and compared to a source of truth. Maybe I&#x27;ll get around to deploying LDAP with OpenSSH-LPK to move away from flat files.<p><i>Knee-jerk suggestion to rewrite the world in Rust combined with formal verification.</i><p>But seriously, being an expert knife juggler is still gambling with the obvious compared to using safer tools in a safer manner. Rust needs the ubiquity of GCC[0] (partially by adding them to LLVM and adding std crates) and more attention paid to bloat (cargo-bloat, etc) before attempting to rewrite the world (apart from special cases).<p>0. <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;backends.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;backends.html</a></div><br/></div></div><div id="36790883" class="c"><input type="checkbox" id="c-36790883" checked=""/><div class="controls bullet"><span class="by">berkle4455</span><span>|</span><a href="#36794113">prev</a><span>|</span><a href="#36791071">next</a><span>|</span><label class="collapse" for="c-36790883">[-]</label><label class="expand" for="c-36790883">[17 more]</label></div><br/><div class="children"><div class="content">What&#x27;s a better solution if you want to be able to SSH across multiple machines? Do you need to always close the current connection to get back to localhost prior to a fresh SSH?<p>e.g. how would I ssh into foo, and then later into bar, or perhaps pull some code from github onto foo that is authenticated by my key?<p><pre><code>    localhost -&gt; foo -&gt; bar
    localhost -&gt; foo -&gt; github access
</code></pre>
It seems like the answer is either: a) ssh -A, or b) install my private key on foo.</div><br/><div id="36792832" class="c"><input type="checkbox" id="c-36792832" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790883">parent</a><span>|</span><a href="#36792444">next</a><span>|</span><label class="collapse" for="c-36792832">[-]</label><label class="expand" for="c-36792832">[4 more]</label></div><br/><div class="children"><div class="content">Better options:<p>c) use proxyjump (-J) to access bar (<a href="https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man1&#x2F;ssh.1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man1&#x2F;ssh.1.html</a>), and&#x2F;or<p>d) generate a new private key on foo and use that to access github.<p>You might think that&#x27;s a crazy waste of time compared to forwarding, but it&#x27;s actually much, much safer and actually only takes a moment:<p><pre><code>    ssh-keygen -t ed25519
    cat ~&#x2F;.ssh&#x2F;id_ed25519.pub
</code></pre>
and then just paste that in Github.<p>See also <a href="https:&#x2F;&#x2F;userify.com&#x2F;docs&#x2F;jumpbox" rel="nofollow noreferrer">https:&#x2F;&#x2F;userify.com&#x2F;docs&#x2F;jumpbox</a> for more jumpbox docs.</div><br/><div id="36795001" class="c"><input type="checkbox" id="c-36795001" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36790883">root</a><span>|</span><a href="#36792832">parent</a><span>|</span><a href="#36795262">next</a><span>|</span><label class="collapse" for="c-36795001">[-]</label><label class="expand" for="c-36795001">[1 more]</label></div><br/><div class="children"><div class="content">&gt; d) generate a new private key on foo and use that to access github.<p>&gt; [...] only takes a moment [...]<p>Not every org&#x27;s policy allows adding unaudited ad-hoc SSH keys.<p>&gt; [...] much, much safer [...]<p>Definitely not always, if the hosts you store these keys on are not as hardened as you local machine (or a hardware key connected to it).</div><br/></div></div><div id="36795262" class="c"><input type="checkbox" id="c-36795262" checked=""/><div class="controls bullet"><span class="by">berkle4455</span><span>|</span><a href="#36790883">root</a><span>|</span><a href="#36792832">parent</a><span>|</span><a href="#36795001">prev</a><span>|</span><a href="#36792444">next</a><span>|</span><label class="collapse" for="c-36795262">[-]</label><label class="expand" for="c-36795262">[2 more]</label></div><br/><div class="children"><div class="content">I need to read the source, I’m confused how -J actually works. Is the bastion doing auth and the downstream machines trusting? Or does it auth first and then forwarding a :22 connection from downstream back to localhost? Or something else entirely?</div><br/><div id="36798042" class="c"><input type="checkbox" id="c-36798042" checked=""/><div class="controls bullet"><span class="by">momentoftop</span><span>|</span><a href="#36790883">root</a><span>|</span><a href="#36795262">parent</a><span>|</span><a href="#36792444">next</a><span>|</span><label class="collapse" for="c-36798042">[-]</label><label class="expand" for="c-36798042">[1 more]</label></div><br/><div class="children"><div class="content">Just my understanding of the manpage and TCP forwarding (-L): an SSH connection will be established to the jump host, which then establishes a connection on port 22 to the destination. The local machine now has a forwarded connection to the destination and uses that to establish a second SSH connection between them.<p>Between local and jump host, there will be two layers of encryption. The jump host decrypts the outer layer, and the two ends the inner layer.</div><br/></div></div></div></div></div></div><div id="36791074" class="c"><input type="checkbox" id="c-36791074" checked=""/><div class="controls bullet"><span class="by">cassianoleal</span><span>|</span><a href="#36790883">parent</a><span>|</span><a href="#36792444">prev</a><span>|</span><a href="#36791280">next</a><span>|</span><label class="collapse" for="c-36791074">[-]</label><label class="expand" for="c-36791074">[4 more]</label></div><br/><div class="children"><div class="content">As others have pointed out already, JumpHost or -J is the preferred way.</div><br/><div id="36792517" class="c"><input type="checkbox" id="c-36792517" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790883">root</a><span>|</span><a href="#36791074">parent</a><span>|</span><a href="#36792390">next</a><span>|</span><label class="collapse" for="c-36792517">[-]</label><label class="expand" for="c-36792517">[2 more]</label></div><br/><div class="children"><div class="content">I agree!<p>The Github example complicates things, but the correct solution is actually another key:<p>Generate a separate private key on foo and place that one in github, ideally per project as a deploy key.</div><br/><div id="36795041" class="c"><input type="checkbox" id="c-36795041" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36790883">root</a><span>|</span><a href="#36792517">parent</a><span>|</span><a href="#36792390">next</a><span>|</span><label class="collapse" for="c-36795041">[-]</label><label class="expand" for="c-36795041">[1 more]</label></div><br/><div class="children"><div class="content">Please don’t call this the &quot;correct&quot; solution. It might work for you; it&#x27;s not a general rule or widely accepted best practice.<p>Generating a key per host is just a different security model than key forwarding, and arguably a worse one if key forwarding is done defensively (i.e. forward a separate key, with only those permissions you would give to a key present on the connected host itself).</div><br/></div></div></div></div></div></div><div id="36791280" class="c"><input type="checkbox" id="c-36791280" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#36790883">parent</a><span>|</span><a href="#36791074">prev</a><span>|</span><a href="#36791180">next</a><span>|</span><label class="collapse" for="c-36791280">[-]</label><label class="expand" for="c-36791280">[3 more]</label></div><br/><div class="children"><div class="content">Make an ssh connection to foo with a port forward. Then make an ssh connection to bar through foo. Keys stay on your machine. I&#x27;m pretty sure there&#x27;s built in features to do this.</div><br/><div id="36792467" class="c"><input type="checkbox" id="c-36792467" checked=""/><div class="controls bullet"><span class="by">gunapologist99</span><span>|</span><a href="#36790883">root</a><span>|</span><a href="#36791280">parent</a><span>|</span><a href="#36791180">next</a><span>|</span><label class="collapse" for="c-36792467">[-]</label><label class="expand" for="c-36792467">[2 more]</label></div><br/><div class="children"><div class="content">That won&#x27;t work for a connection to github that&#x27;s being initiated from foo.<p>The best solution in that situation is a separate key that&#x27;s private to foo.</div><br/><div id="36795017" class="c"><input type="checkbox" id="c-36795017" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#36790883">root</a><span>|</span><a href="#36792467">parent</a><span>|</span><a href="#36791180">next</a><span>|</span><label class="collapse" for="c-36795017">[-]</label><label class="expand" for="c-36795017">[1 more]</label></div><br/><div class="children"><div class="content">No, the best solution would be partial key forwarding of one or several separate keys only scoped to git access.</div><br/></div></div></div></div></div></div><div id="36791180" class="c"><input type="checkbox" id="c-36791180" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36790883">parent</a><span>|</span><a href="#36791280">prev</a><span>|</span><a href="#36791120">next</a><span>|</span><label class="collapse" for="c-36791180">[-]</label><label class="expand" for="c-36791180">[2 more]</label></div><br/><div class="children"><div class="content">I use hashi corp&#x27;s stack: Boundary + Vault for ssh credential injection<p><a href="https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;boundary&#x2F;tutorials&#x2F;credential-management&#x2F;hcp-private-vault-cred-injection" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;boundary&#x2F;tutorials&#x2F;credentia...</a><p>it completely replaces the need for bastion hosts and ssh-agent at scale (I&#x27;m a hashicorp&#x27;s paying customer)<p>compared to Teleport, boundary is lightweight (you dont need to install agent on each target server) and is integrated with the Vault for certificate based auth or simple cred brokering</div><br/><div id="36794108" class="c"><input type="checkbox" id="c-36794108" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#36790883">root</a><span>|</span><a href="#36791180">parent</a><span>|</span><a href="#36791120">next</a><span>|</span><label class="collapse" for="c-36794108">[-]</label><label class="expand" for="c-36794108">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a macOS app that supports using Vault Transit Engine keys with OpenSSH, as well as GnuPG and PKCS#11. (OpenSSH is supported via both the agent protocol and PKCS#11.) You can even use an Apple T2 (Secure Enclave) key for peer mTLS authentication to the Vault server. <a href="https:&#x2F;&#x2F;www.keymux.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.keymux.com&#x2F;</a><p>Using this teams can <i>share</i> an SSH key without exposing the key; nor do you need to configure certificate PKI, use jump hosts, or otherwise change your existing software or workflows.</div><br/></div></div></div></div><div id="36791120" class="c"><input type="checkbox" id="c-36791120" checked=""/><div class="controls bullet"><span class="by">totallywrong</span><span>|</span><a href="#36790883">parent</a><span>|</span><a href="#36791180">prev</a><span>|</span><a href="#36791272">next</a><span>|</span><label class="collapse" for="c-36791120">[-]</label><label class="expand" for="c-36791120">[1 more]</label></div><br/><div class="children"><div class="content">You can set up an ssh tunnel on localhost to any port on bar or github via foo.</div><br/></div></div><div id="36791272" class="c"><input type="checkbox" id="c-36791272" checked=""/><div class="controls bullet"><span class="by">aberoham</span><span>|</span><a href="#36790883">parent</a><span>|</span><a href="#36791120">prev</a><span>|</span><a href="#36791071">next</a><span>|</span><label class="collapse" for="c-36791272">[-]</label><label class="expand" for="c-36791272">[1 more]</label></div><br/><div class="children"><div class="content">Teleport is far and away the leading solution in this area — certificate based end-to-end bastion style topology with many nice features including support for kubectl.</div><br/></div></div></div></div><div id="36791071" class="c"><input type="checkbox" id="c-36791071" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36790883">prev</a><span>|</span><label class="collapse" for="c-36791071">[-]</label><label class="expand" for="c-36791071">[6 more]</label></div><br/><div class="children"><div class="content">what is CVSS&#x2F;severity of this? Critical? 9+?</div><br/><div id="36791701" class="c"><input type="checkbox" id="c-36791701" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36791071">parent</a><span>|</span><a href="#36791195">next</a><span>|</span><label class="collapse" for="c-36791701">[-]</label><label class="expand" for="c-36791701">[1 more]</label></div><br/><div class="children"><div class="content">CVSS is meaningless, literally a Ouija board that reflects the intuition of whoever&#x27;s computing the score. A more reasonable way to look at severity is on a two dimensional scale of lo-hi severity and lo-hi situationality. This is a high-severity, moderately situational bug (it would be highly situational if it required user interaction, and not situational at all if it didn&#x27;t require control over the remote SSH server).</div><br/></div></div><div id="36791195" class="c"><input type="checkbox" id="c-36791195" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36791071">parent</a><span>|</span><a href="#36791701">prev</a><span>|</span><a href="#36791725">next</a><span>|</span><label class="collapse" for="c-36791195">[-]</label><label class="expand" for="c-36791195">[3 more]</label></div><br/><div class="children"><div class="content">CVSS with rice: 10&#x2F;10</div><br/><div id="36791389" class="c"><input type="checkbox" id="c-36791389" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36791071">root</a><span>|</span><a href="#36791195">parent</a><span>|</span><a href="#36791725">next</a><span>|</span><label class="collapse" for="c-36791389">[-]</label><label class="expand" for="c-36791389">[2 more]</label></div><br/><div class="children"><div class="content">do you have a source for this by any chance? or screenshot?<p>thank you</div><br/><div id="36794314" class="c"><input type="checkbox" id="c-36794314" checked=""/><div class="controls bullet"><span class="by">wiml</span><span>|</span><a href="#36791071">root</a><span>|</span><a href="#36791389">parent</a><span>|</span><a href="#36791725">next</a><span>|</span><label class="collapse" for="c-36794314">[-]</label><label class="expand" for="c-36794314">[1 more]</label></div><br/><div class="children"><div class="content">He&#x27;s just making a reference to an old reddit joke, I don&#x27;t think it&#x27;s a CVSS 10</div><br/></div></div></div></div></div></div><div id="36791725" class="c"><input type="checkbox" id="c-36791725" checked=""/><div class="controls bullet"><span class="by">NoZebra120vClip</span><span>|</span><a href="#36791071">parent</a><span>|</span><a href="#36791195">prev</a><span>|</span><label class="collapse" for="c-36791725">[-]</label><label class="expand" for="c-36791725">[1 more]</label></div><br/><div class="children"><div class="content">CVSS are bunk. <a href="https:&#x2F;&#x2F;portswigger.net&#x2F;daily-swig&#x2F;cvss-system-criticized-for-failure-to-address-real-world-impact" rel="nofollow noreferrer">https:&#x2F;&#x2F;portswigger.net&#x2F;daily-swig&#x2F;cvss-system-criticized-fo...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>