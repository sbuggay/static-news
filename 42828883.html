<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738141265766" as="style"/><link rel="stylesheet" href="styles.css?v=1738141265766"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://borretti.me/article/composable-sql">Composable SQL</a> <span class="domain">(<a href="https://borretti.me">borretti.me</a>)</span></div><div class="subtext"><span>earnestinger</span> | <span>58 comments</span></div><br/><div><div id="42862780" class="c"><input type="checkbox" id="c-42862780" checked=""/><div class="controls bullet"><span class="by">yujzgzc</span><span>|</span><a href="#42862812">next</a><span>|</span><label class="collapse" for="c-42862780">[-]</label><label class="expand" for="c-42862780">[1 more]</label></div><br/><div class="children"><div class="content">I work on a project that does tons of SQL based data transformations (thousands). A lot of it isn&#x27;t backed by unit tests. Some of our people with more of a C++ background have got the idea that this is crazy, every bit of business logic should be encapsulated into a function just like in every other civilized language, so that it could be unit tested. They built a framework like this for SQL and implemented quite a few jobs with it.<p>The problem is most of the SQL-first devs hate it and would rather write untested code, or rely on alternative test automation techniques like bringing up a local DB instance with fake data, than have to refit their business logic into pure functions. The truth is that it&#x27;s just not a way of working that comes naturally to people who write a lot of SQL for a living.</div><br/></div></div><div id="42862812" class="c"><input type="checkbox" id="c-42862812" checked=""/><div class="controls bullet"><span class="by">yujzgzc</span><span>|</span><a href="#42862780">prev</a><span>|</span><a href="#42861686">next</a><span>|</span><label class="collapse" for="c-42862812">[-]</label><label class="expand" for="c-42862812">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot more composability problems with SQL.<p>As an example, can you write a function that you can invoke on a column in a select statement and will compute the cumulative distribution function of that column?<p>The expression to do this is enormous &quot;SUM(column) OVER (ORDER BY column ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) &#x2F; SUM(column) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)&quot; and there is no choice but to inline it. I think it would be reasonable to expect users to be able to describe this and then write simply &quot;CDF(column)&quot;. The only systems that do this I believe are text processing macros on top of SQL...</div><br/></div></div><div id="42861686" class="c"><input type="checkbox" id="c-42861686" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#42862812">prev</a><span>|</span><a href="#42860409">next</a><span>|</span><label class="collapse" for="c-42861686">[-]</label><label class="expand" for="c-42861686">[4 more]</label></div><br/><div class="children"><div class="content">The article talks about how CTEs are efficiency minefields and how Postgres doesn&#x27;t do a good job of pushing down predicates, for example.<p>TBH, the solution is to improve the Postgres engine in this regard?<p>For example, in Bigquery I often use CTEs and see predictable speedups that are explained by predicate pushdown when slapping a WHERE clause on the user of a CTE etc.  Bigquery has plenty of performance gotchas but I don&#x27;t think CTEs are one of them; they seem to be transparent to the optimiser.<p>Something else that Bigquery supports is user-defined &#x27;table&#x27; functions.  These are like the &#x27;functors&#x27; the article creates.<p>However, in practice they aren&#x27;t very widely used, and I think this hints that they aren&#x27;t as useful as the article is hoping for.<p>The thing I _really_ want is scoping.  If only functions could be described like CTE WITH blocks, e.g.<p><pre><code>   WITH visits AS (
      SELECT ...
      FROM web_logs
      WHERE ...
   ),
   foo(bar INT, baz STRING) AS (
      ... function body here
   )
   SELECT ..., foo(a, b), ...
   FROM visits
   WHERE ...
</code></pre>
Apart from the tidiness of this, this allows inlining of functions into the SQL statement body rather than as separate statements.  Often various tooling e.g. DBT makes it really hard to with separate function definitions etc, and being able to inline logic would make things possible.<p>Bigquery also supports user-defined aggregate functions.  Although there is rarely the need to stray from the standard builtin aggregate functions, when you need them they are brilliant.<p>(Anyone working _on_ Bigquery reading?  If so, please ping me, I have loads of feedback on what works well and where the user pain and toil is ;) )</div><br/><div id="42861830" class="c"><input type="checkbox" id="c-42861830" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#42861686">parent</a><span>|</span><a href="#42862779">next</a><span>|</span><label class="collapse" for="c-42861830">[-]</label><label class="expand" for="c-42861830">[1 more]</label></div><br/><div class="children"><div class="content">As of Postgres 12 (Oct. 2019) CTEs are no longer materialized by default and are eligible for predicate push down.<p>The planner may still struggle but it’s not true that a CTE is an optimization fence.<p><a href="https:&#x2F;&#x2F;www.depesz.com&#x2F;2019&#x2F;02&#x2F;19&#x2F;waiting-for-postgresql-12-allow-user-control-of-cte-materialization-and-change-the-default-behavior&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.depesz.com&#x2F;2019&#x2F;02&#x2F;19&#x2F;waiting-for-postgresql-12-...</a></div><br/></div></div><div id="42862779" class="c"><input type="checkbox" id="c-42862779" checked=""/><div class="controls bullet"><span class="by">zetalyrae</span><span>|</span><a href="#42861686">parent</a><span>|</span><a href="#42861830">prev</a><span>|</span><a href="#42862241">next</a><span>|</span><label class="collapse" for="c-42862779">[-]</label><label class="expand" for="c-42862779">[1 more]</label></div><br/><div class="children"><div class="content">This suffers from the &quot;sufficiently smart compiler&quot; problem. The query planner that can do what I mean with maximal efficiency is always just over the horizon. There&#x27;s always yet another query that can&#x27;t be optimized automatically.</div><br/></div></div><div id="42862241" class="c"><input type="checkbox" id="c-42862241" checked=""/><div class="controls bullet"><span class="by">vprcic</span><span>|</span><a href="#42861686">parent</a><span>|</span><a href="#42862779">prev</a><span>|</span><a href="#42860409">next</a><span>|</span><label class="collapse" for="c-42862241">[-]</label><label class="expand" for="c-42862241">[1 more]</label></div><br/><div class="children"><div class="content">Functions in WITH clause really are a blessing. Oracle DB supported these for a decade now and that was a gamechanger for me.<p><a href="https:&#x2F;&#x2F;oracle-base.com&#x2F;articles&#x2F;12c&#x2F;with-clause-enhancements-12cr1#functions" rel="nofollow">https:&#x2F;&#x2F;oracle-base.com&#x2F;articles&#x2F;12c&#x2F;with-clause-enhancement...</a></div><br/></div></div></div></div><div id="42860409" class="c"><input type="checkbox" id="c-42860409" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#42861686">prev</a><span>|</span><a href="#42860726">next</a><span>|</span><label class="collapse" for="c-42860409">[-]</label><label class="expand" for="c-42860409">[18 more]</label></div><br/><div class="children"><div class="content">SQL cannot be &quot;fixed&quot;. It&#x27;s too broken, too ubiquitous, too customized, too optimized. Will these functors integrate with the thousands of optimizations modern database systems rely on?<p>This post has the format: &quot;SQL is extremely terribly awful at writing business logic. But if people implemented this one half-baked, unrealistic idea, then it would suck <i>a little bit less</i>!&quot; The first part is spot-on: SQL is a horrible language for writing business logic. So: stop. Stop doing that.<p><i>Stop writing business logic in SQL!</i><p>Imagine you joined a new team, and they said: our program uses a bunch of XML files as its data format, and that&#x27;s why most of our business logic is implemented in XPath. Just sit there and ponder that situation for a little bit. This is what you all sound like to me. Stop it!<p>&gt; Testing the simplest query requires building up a massive object graph, just to test an infinitesimal slice of it.<p>Yes, correct, because SQL is awful at representing business logic, and <i>foreign key constraints are business logic!</i> The fact that an employee has one supervisor who is also an employee (FK Employee.SupervisorID -&gt; Employee.ID) is a business constraint. (And one that can easily change, by the way.) All these database engineers who can&#x27;t pull themselves away from their stored procedures will argue with me to their graves about foreign key constraints, but they&#x27;re generally terrible. They&#x27;re a business constraint that just happens to be supported by the database engine, but they&#x27;re still a business constraint. Stop putting your business logic in your persistence layer.<p>We&#x27;ve been getting better at building programming languages that actually support software engineering every year. Use one of those. SQL is an <i>output</i> of one of your program layers. Just like XPath would be an output of your program. Compose SQL in an actual real programming language that isn&#x27;t horrible instead of doing any of this.</div><br/><div id="42861996" class="c"><input type="checkbox" id="c-42861996" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42862809">next</a><span>|</span><label class="collapse" for="c-42861996">[-]</label><label class="expand" for="c-42861996">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, correct, because SQL is awful at representing business logic, and foreign key constraints are business logic!<p>This strikes me as a unnecessary all-or-nothing argument.  I would agree that you shouldn&#x27;t put all your business logic in the database but that doesn&#x27;t mean you shouldn&#x27;t put any business logic in your database.  If foreign key constraints are business logic then so are table definitions and column types.  It&#x27;s not awful for those things as it&#x27;s literally built right in.<p>My advice is to ensure, as best as possible, that invalid states are impossible to represent.  If you can&#x27;t have an address without being attached to a client, make that impossible to represent in the database.  It&#x27;s one less thing you&#x27;ll ever have to worry about.</div><br/></div></div><div id="42862809" class="c"><input type="checkbox" id="c-42862809" checked=""/><div class="controls bullet"><span class="by">dicytea</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42861996">prev</a><span>|</span><a href="#42860505">next</a><span>|</span><label class="collapse" for="c-42862809">[-]</label><label class="expand" for="c-42862809">[1 more]</label></div><br/><div class="children"><div class="content">I agree with most of this, but I don&#x27;t understand why you&#x27;d treat FKs as business logic. IMO, it&#x27;s clearly a part of the data structure. Like, say if you have a domain that looks like:<p><pre><code>    type User = {
      username: string;
      posts: Post[];
    }

    type Post = {
      content: string;
    }
</code></pre>
(for the DDD-brained, assume User is an aggregate and Post is a value object here)<p>The natural way to represent this in the database is:<p><pre><code>    CREATE TABLE users (
        username text PRIMARY KEY
    );

    CREATE TABLE posts (
        author text NOT NULL REFERENCES users (username),
        content text NOT NULL
    );
</code></pre>
I just don&#x27;t see why you&#x27;d do it in any other way.</div><br/></div></div><div id="42860505" class="c"><input type="checkbox" id="c-42860505" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42862809">prev</a><span>|</span><a href="#42862341">next</a><span>|</span><label class="collapse" for="c-42860505">[-]</label><label class="expand" for="c-42860505">[1 more]</label></div><br/><div class="children"><div class="content">What is business logic? What specifically is SQL bad at?<p>I’m not sold by your foreign key example. Constraints are great. I guess you can do that in python? Good like getting ACID right<p>As soon as your data stops resembling a tree and starts looking like a graph than all your “business logic” looks a lot like operations on relations and you are back to where you started.</div><br/></div></div><div id="42862341" class="c"><input type="checkbox" id="c-42862341" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42860505">prev</a><span>|</span><a href="#42862734">next</a><span>|</span><label class="collapse" for="c-42862341">[-]</label><label class="expand" for="c-42862341">[1 more]</label></div><br/><div class="children"><div class="content">I agree that SQL has problems as a language.<p>I disagree that we should be happy about moving data out of the storage layer into the backend in cases where it does not make sense performance wise.<p>The problem is doing some processing in SQL in some cases has a huge performance advantages over moving data to the backend.<p>If your business logic requires you to take a million rows from table A, apply some rule, and output a million rows into table B -- then piping all that data through a backend is a bad solution performance wise. I reject the idea that all that extra IO (+extra overhead also for the database) is worth it just to use another programming language than SQL.<p>What we need is better alternatives that execute at the storage layer. Probably starting with proper languages that compile to SQL, like we saw with JavaScript.</div><br/></div></div><div id="42862734" class="c"><input type="checkbox" id="c-42862734" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42862341">prev</a><span>|</span><a href="#42862656">next</a><span>|</span><label class="collapse" for="c-42862734">[-]</label><label class="expand" for="c-42862734">[1 more]</label></div><br/><div class="children"><div class="content">Agree not to putting your business logic in stored procs, but hard neg on getting rid of all constraints.<p>I consider it defense in depth. Sure your application should absolutely ensure order lines aren&#x27;t referencing a non-existing order, but bugs happen and I prefer the database returning an error to the database getting full of inconsistent data.</div><br/></div></div><div id="42862656" class="c"><input type="checkbox" id="c-42862656" checked=""/><div class="controls bullet"><span class="by">tacone</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42862734">prev</a><span>|</span><a href="#42862207">next</a><span>|</span><label class="collapse" for="c-42862656">[-]</label><label class="expand" for="c-42862656">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine you joined a new team, and they said: our program uses a bunch of XML files as its data format, and that&#x27;s why most of our business logic is implemented in XPath. Just sit there and ponder that situation for a little bit.<p>Been there 20 years ago! It sucks at unimaginable levels!</div><br/></div></div><div id="42862207" class="c"><input type="checkbox" id="c-42862207" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42862656">prev</a><span>|</span><a href="#42861505">next</a><span>|</span><label class="collapse" for="c-42862207">[-]</label><label class="expand" for="c-42862207">[1 more]</label></div><br/><div class="children"><div class="content">I think you’re throwing the baby out with the bath water here a bit.<p>I agree that stored-price are rarely, if ever the solution.<p>I do however think that having something that enforces certain constraints across all your data, and forces you to handle schema evolutions reasonably over time is really powerful. Database implementations are (mostly) full of hard-fought correctness decisions, and I don’t think most devs are in a position to “whip out” an implementation that cares for a number of these on-demand.<p>We had the whole NoSQL thing, we saw what when we threw most of this stuff away.<p>Is sql good enough? For many problems yeah. Is it _really_ good enough? Nah probably not, we could do a lot better, but I think a better design looks more like a better sql-like language and less like a full programming language.</div><br/></div></div><div id="42861505" class="c"><input type="checkbox" id="c-42861505" checked=""/><div class="controls bullet"><span class="by">halflife</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42862207">prev</a><span>|</span><a href="#42862395">next</a><span>|</span><label class="collapse" for="c-42861505">[-]</label><label class="expand" for="c-42861505">[7 more]</label></div><br/><div class="children"><div class="content">100% completely agree.<p>You just can’t scale SQL code. If you have a small app, then sure. But then I don’t know why you’d invest so much in testing.
But if you need to scale your code to more than 3 people, SQL should only be your persistent state store. You probably already have a BL layer in another, more manageable programming language, so use that.<p>In my team I set a rule to remove all SQL functions and views, and move all the logic to our typescript backend. That resulted in code which is much easier to test, and is version controlled.</div><br/><div id="42861782" class="c"><input type="checkbox" id="c-42861782" checked=""/><div class="controls bullet"><span class="by">agluszak</span><span>|</span><a href="#42860409">root</a><span>|</span><a href="#42861505">parent</a><span>|</span><a href="#42862730">next</a><span>|</span><label class="collapse" for="c-42861782">[-]</label><label class="expand" for="c-42861782">[3 more]</label></div><br/><div class="children"><div class="content">And what are the results of your decision in terms of performance?</div><br/><div id="42862413" class="c"><input type="checkbox" id="c-42862413" checked=""/><div class="controls bullet"><span class="by">halflife</span><span>|</span><a href="#42860409">root</a><span>|</span><a href="#42861782">parent</a><span>|</span><a href="#42861858">next</a><span>|</span><label class="collapse" for="c-42862413">[-]</label><label class="expand" for="c-42862413">[1 more]</label></div><br/><div class="children"><div class="content">The DB is rarely our bottleneck. 
Our reads are very simple, mostly paged sets from a table with a 1 level join.
When we need complex abstractions or transformations, instead of using function or views, we listen to table changes, and with a TS transformation layer we save a new row in a specific table for the abstraction. That way the BL is handled in TS, and performed in writes asynchronously instead of in-line in reads. The only downside is that the transformed data is not real time.<p>That mechanism allowed us to scale our data very easily without any performance hits.</div><br/></div></div><div id="42861858" class="c"><input type="checkbox" id="c-42861858" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42860409">root</a><span>|</span><a href="#42861782">parent</a><span>|</span><a href="#42862413">prev</a><span>|</span><a href="#42862730">next</a><span>|</span><label class="collapse" for="c-42861858">[-]</label><label class="expand" for="c-42861858">[1 more]</label></div><br/><div class="children"><div class="content">These days? It doesn&#x27;t really matter. For most purposes, you can just hold the entire important dataset in RAM.<p>For example, a humongous company with 500000 employees (Amazon) can trivially hold on a fairly low-end server the database of all the personnel, and all their salary payments, and all their employment history, badge photos, and office access logs.</div><br/></div></div></div></div><div id="42862730" class="c"><input type="checkbox" id="c-42862730" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#42860409">root</a><span>|</span><a href="#42861505">parent</a><span>|</span><a href="#42861782">prev</a><span>|</span><a href="#42862395">next</a><span>|</span><label class="collapse" for="c-42862730">[-]</label><label class="expand" for="c-42862730">[3 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s what people who don&#x27;t have much data do with good results. If you can do that, it&#x27;s the right choice.<p>Once you have data you move code to data and not data to code. It isn&#x27;t a decision you get to make. You only decide how you do it.</div><br/><div id="42862790" class="c"><input type="checkbox" id="c-42862790" checked=""/><div class="controls bullet"><span class="by">halflife</span><span>|</span><a href="#42860409">root</a><span>|</span><a href="#42862730">parent</a><span>|</span><a href="#42862395">next</a><span>|</span><label class="collapse" for="c-42862790">[-]</label><label class="expand" for="c-42862790">[2 more]</label></div><br/><div class="children"><div class="content">I’m sorry, but we have a lot of data. We just implemented the right procedures to consume it</div><br/><div id="42862853" class="c"><input type="checkbox" id="c-42862853" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#42860409">root</a><span>|</span><a href="#42862790">parent</a><span>|</span><a href="#42862395">next</a><span>|</span><label class="collapse" for="c-42862853">[-]</label><label class="expand" for="c-42862853">[1 more]</label></div><br/><div class="children"><div class="content">If you can do processing outside of the database you don&#x27;t have a lot, that&#x27;s basically the definition of a lot of data. Don&#x27;t be sorry, try to not have more data.</div><br/></div></div></div></div></div></div></div></div><div id="42862395" class="c"><input type="checkbox" id="c-42862395" checked=""/><div class="controls bullet"><span class="by">geysersam</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42861505">prev</a><span>|</span><a href="#42861083">next</a><span>|</span><label class="collapse" for="c-42862395">[-]</label><label class="expand" for="c-42862395">[1 more]</label></div><br/><div class="children"><div class="content">I think the fact that these functions&#x2F;functors&#x2F;macros already exist in a few different varieties in mainstream database systems presents a challenge to your argument.<p>SQL can be fixed, has been fixed, and is a underutilized tool in my personal opinion.</div><br/></div></div><div id="42861083" class="c"><input type="checkbox" id="c-42861083" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42862395">prev</a><span>|</span><a href="#42860529">next</a><span>|</span><label class="collapse" for="c-42861083">[-]</label><label class="expand" for="c-42861083">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Compose SQL in an actual real programming language that isn&#x27;t horrible instead of doing any of this.<p>Got any recommendations? That&#x27;s a serious question, I&#x27;ve tried many (and built my own) and some are okay but none feel remotely good enough when you consider how much progress we&#x27;ve made basically everywhere else in the wider world of software engineering. Relational databases are so good; they deserve better than SQL!</div><br/></div></div><div id="42860529" class="c"><input type="checkbox" id="c-42860529" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#42860409">parent</a><span>|</span><a href="#42861083">prev</a><span>|</span><a href="#42860726">next</a><span>|</span><label class="collapse" for="c-42860529">[-]</label><label class="expand" for="c-42860529">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know why you are getting downvoted, and I generally don&#x27;t like a lot of business logic in the persistence layer, but representing the things you absolutely dont want another part of your app doing via FKs is...pretty normal.<p>If you are arguing it spreads out your business logic into multiple places, that&#x27;s fair, but so does... a lot of things. Databases with decent fks and constraints have a tendency to outlive the apps that build atop them, and communicating these constraints in long lived fashions can be ... good actually.</div><br/></div></div></div></div><div id="42860726" class="c"><input type="checkbox" id="c-42860726" checked=""/><div class="controls bullet"><span class="by">geysersam</span><span>|</span><a href="#42860409">prev</a><span>|</span><a href="#42862772">next</a><span>|</span><label class="collapse" for="c-42860726">[-]</label><label class="expand" for="c-42860726">[6 more]</label></div><br/><div class="children"><div class="content">Similar functionality already exists in some SQL implementations, notably DuckDB:<p><pre><code>  create table macro author_books() as   
  (
    select
        a.name as author,
        b.title,
    from
        a
    inner join
        b on b.author_id = a.author_id
  );
</code></pre>
is the same as the example in the article and it is called like:<p><pre><code>  with a as (...),
       b as (...)
       from author_books();

</code></pre>
<a href="https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;sql&#x2F;statements&#x2F;create_macro.html#table-macros" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;sql&#x2F;statements&#x2F;create_macro.html#tab...</a></div><br/><div id="42861461" class="c"><input type="checkbox" id="c-42861461" checked=""/><div class="controls bullet"><span class="by">_dark_matter_</span><span>|</span><a href="#42860726">parent</a><span>|</span><a href="#42861962">next</a><span>|</span><label class="collapse" for="c-42861461">[-]</label><label class="expand" for="c-42861461">[1 more]</label></div><br/><div class="children"><div class="content">I really dislike leading off with &quot;create table&quot;. My brain is unable to read it except as DDL.</div><br/></div></div><div id="42861962" class="c"><input type="checkbox" id="c-42861962" checked=""/><div class="controls bullet"><span class="by">krembo</span><span>|</span><a href="#42860726">parent</a><span>|</span><a href="#42861461">prev</a><span>|</span><a href="#42862205">next</a><span>|</span><label class="collapse" for="c-42861962">[-]</label><label class="expand" for="c-42861962">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this an abstraction of functions?</div><br/><div id="42862378" class="c"><input type="checkbox" id="c-42862378" checked=""/><div class="controls bullet"><span class="by">tankenmate</span><span>|</span><a href="#42860726">root</a><span>|</span><a href="#42861962">parent</a><span>|</span><a href="#42862205">next</a><span>|</span><label class="collapse" for="c-42862378">[-]</label><label class="expand" for="c-42862378">[1 more]</label></div><br/><div class="children"><div class="content">It is an abstraction, it may be arguable if it is an abstraction of functions.<p>I once built a web app where we had a library of CTEs that we used to manage all the layers of indirection in the data, it was performant and made it much easier for users to be able to search and manipulate the data; especially for ad hoc data analysis.</div><br/></div></div></div></div><div id="42862205" class="c"><input type="checkbox" id="c-42862205" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#42860726">parent</a><span>|</span><a href="#42861962">prev</a><span>|</span><a href="#42862772">next</a><span>|</span><label class="collapse" for="c-42862205">[-]</label><label class="expand" for="c-42862205">[2 more]</label></div><br/><div class="children"><div class="content">How does it differ from a view?</div><br/><div id="42862321" class="c"><input type="checkbox" id="c-42862321" checked=""/><div class="controls bullet"><span class="by">geysersam</span><span>|</span><a href="#42860726">root</a><span>|</span><a href="#42862205">parent</a><span>|</span><a href="#42862772">next</a><span>|</span><label class="collapse" for="c-42862321">[-]</label><label class="expand" for="c-42862321">[1 more]</label></div><br/><div class="children"><div class="content">It can take arguments. I didn&#x27;t use any though so it&#x27;s not a good example</div><br/></div></div></div></div></div></div><div id="42862772" class="c"><input type="checkbox" id="c-42862772" checked=""/><div class="controls bullet"><span class="by">dgan</span><span>|</span><a href="#42860726">prev</a><span>|</span><a href="#42860165">next</a><span>|</span><label class="collapse" for="c-42862772">[-]</label><label class="expand" for="c-42862772">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking about this exact problem, one year ago, and even started to sketch out what a better &quot;meta-sql&quot; would look like. However, i did lose myself in the weeds.<p>Notably :<p>- the metasql has to be embedded in the host language, the way normal sql is. This means, it also has to handle in&#x2F;out bound parameters from the host. I guess this could be handled by a codegen step, where the functions of the host language are generated based on metasql. The alternative is to provide a runtime for each host language.. So this one is out<p>- i wanted a way to compose &quot;columns sets&quot;. This is because you might want for example, to indicate that the query returns &quot;all the columns in this table, minus thia and that&quot;. Or, for example &quot;the union of this column set union in-column set&quot;. This feature looks like adding another meta-language on top of the metasql already lol I stopped at that point because i could find a graceful&#x2F;looknice solution, let alone implement it.</div><br/></div></div><div id="42860165" class="c"><input type="checkbox" id="c-42860165" checked=""/><div class="controls bullet"><span class="by">throwaway201606</span><span>|</span><a href="#42862772">prev</a><span>|</span><a href="#42862591">next</a><span>|</span><label class="collapse" for="c-42860165">[-]</label><label class="expand" for="c-42860165">[5 more]</label></div><br/><div class="children"><div class="content">I understand the primary premise about the difficulty with testing SQL and fully agree with it.<p>I do have a question though - while I understand how functors can help make the problem easier to tackle, I am not sure I fully understand how functors are different from a similar existing tool - stored procedures.<p>Some DB flavors:<p>- can take tables as arguments to stored procedures 
- can return tables 
- also offer the additional benefit of being able to run almost all flavors of SQL commands ( DDL, DML, DQL, DCL, TCL) in those stored procedures<p>Netezza stored procedures, for example, can do what you describe here:<p><a href="https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;en&#x2F;netezza?topic=nsg-return-result-set" rel="nofollow">https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;en&#x2F;netezza?topic=nsg-return-result-...</a><p>As can SQL Server &amp; Oracle (which both return cursors, which are just ordered tables):<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;stored-procedures&#x2F;return-data-from-a-stored-procedure?view=sql-server-ver16" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;s...</a><p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;B28359_01&#x2F;appdev.111&#x2F;b28843&#x2F;tdddg_procedures.htm#CIHDDIFG" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;B28359_01&#x2F;appdev.111&#x2F;b28843&#x2F;tdddg...</a><p>Am I missing something fundamental here? How are functors different from stored procedures? To me, they seem to be just a sub-class &#x2F; sub-type of stored procedures.</div><br/><div id="42860997" class="c"><input type="checkbox" id="c-42860997" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#42860165">parent</a><span>|</span><a href="#42860833">next</a><span>|</span><label class="collapse" for="c-42860997">[-]</label><label class="expand" for="c-42860997">[2 more]</label></div><br/><div class="children"><div class="content">The goal is that the composable parts get woven into an efficient, planner-friendly query. Stored procedures completely undermine that unless something very exciting has happened since last I checked (SQL Server, but probably applies to all of them). You will likely end up in a &quot;row by agonizing row&quot; situation.<p>(Okay, maybe you can find a few cases where stored procs work decently, but in general both composability and performance will be much worse than the proposed functors.)</div><br/><div id="42861524" class="c"><input type="checkbox" id="c-42861524" checked=""/><div class="controls bullet"><span class="by">throwaway201606</span><span>|</span><a href="#42860165">root</a><span>|</span><a href="#42860997">parent</a><span>|</span><a href="#42860833">next</a><span>|</span><label class="collapse" for="c-42861524">[-]</label><label class="expand" for="c-42861524">[1 more]</label></div><br/><div class="children"><div class="content">OK, this I understand, that is a good insight - cursors are row-processing based so its gonna be slow<p>I think Netezza, SQL Server and Oracle are all cursor-based processing &quot;by default&quot; so this makes a lot of sense. I suspect that they all have bulk operation capability but can&#x27;t immediately think of how I would have worked bulk processing in a way that maps to this article - maybe something like analytic functions like windowing, partitioning etc. that is  definitely not row by row.<p>Having said that, the examples I see for actual testing in the article are DQL &#x2F; DML so would be multiple row processing by default  .. yes, the functor definition &#x2F; creation is a DDL process but it is a &quot;do once and reuse the definition&quot; thing (like, the author correctly observes, a view, which is the point of functors) and the functor in use would just be DML. In which case, functors go back to looking like stored procedures...<p>I also understood composability as being built in for SQL - for example, in Oracle, packages allow composability of stored procedures, triggers, sequences etc allow composability of DML and views allow composability of queries and tables - which the author points out in the article.<p>With functors, DDL, DML, DQL, DCL, TCL would still be the only command tools available unless a new command language was invented for SQL for testing - let call that something like DTL (Data Test Language), with a whole new bunch of associated new SQL keywords, capability and functionality that are built right into the core of the DB engine that are optimized for what functors are trying to achieve.</div><br/></div></div></div></div><div id="42860833" class="c"><input type="checkbox" id="c-42860833" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#42860165">parent</a><span>|</span><a href="#42860997">prev</a><span>|</span><a href="#42862591">next</a><span>|</span><label class="collapse" for="c-42860833">[-]</label><label class="expand" for="c-42860833">[2 more]</label></div><br/><div class="children"><div class="content">They seem somewhat like stored procedures, but not stored? As in a query can contain a functor in it and then use it immediately. I didn&#x27;t see those `create functor` statements as anything other than ephemeral - or am I wrong?<p>EDIT: also stored procs that use imperative logic and cursors can be quite a bit slower than queries that achieve the same logic - the capability here is purposefully a subset of that and is just to help build standard SQL queries that can go through the standard query planner.</div><br/><div id="42861579" class="c"><input type="checkbox" id="c-42861579" checked=""/><div class="controls bullet"><span class="by">throwaway201606</span><span>|</span><a href="#42860165">root</a><span>|</span><a href="#42860833">parent</a><span>|</span><a href="#42862591">next</a><span>|</span><label class="collapse" for="c-42861579">[-]</label><label class="expand" for="c-42861579">[1 more]</label></div><br/><div class="children"><div class="content">I think they have to be long lived  else they cannot make sense for performant testing. ie they are created as DB objects, using DDL, in the same way tables, views, functions etc are made.<p>They can certainly be created at test run time but that would slow things down a lot - you would essentially be creating a ton of objects every time you run the test which means having a setup to test if they exist or not, take them down if they do or fix them if they don&#x27;t match spec  ( e.g. column and data type changes etc etc )<p>The more I think about this, the more complicated I realize it would be to manage this dynamically:<p>You essentially have to build a test harness enviroment that figures out your testing elements dynamically from your data environment (with some kind of parameterization engine and data set to tell it what to look for so as to &quot;make functors and run them&quot; (e.g. all PKs of FKs or all columns starting with a certain prefix or all columns of a certain data type etc etc), gets the most up to date definitions of those elements from system tables and uses that data to create or update or drop functor objects ... wow, ok, this is getting complicated, I am going to stop now before I see the void.</div><br/></div></div></div></div></div></div><div id="42862591" class="c"><input type="checkbox" id="c-42862591" checked=""/><div class="controls bullet"><span class="by">tie-in</span><span>|</span><a href="#42860165">prev</a><span>|</span><a href="#42861015">next</a><span>|</span><label class="collapse" for="c-42862591">[-]</label><label class="expand" for="c-42862591">[1 more]</label></div><br/><div class="children"><div class="content">While I appreciate the functional approach outlined in the article, there are alternative and, in my opinion, more practical ways to write composable and functional SQL queries embedded in a host programming language using query builders. For example: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42265668">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42265668</a></div><br/></div></div><div id="42861015" class="c"><input type="checkbox" id="c-42861015" checked=""/><div class="controls bullet"><span class="by">iforgot22</span><span>|</span><a href="#42862591">prev</a><span>|</span><a href="#42860559">next</a><span>|</span><label class="collapse" for="c-42861015">[-]</label><label class="expand" for="c-42861015">[1 more]</label></div><br/><div class="children"><div class="content">I prefer to keep the SQL itself as simple as possible. I&#x27;ve gotten by OK by composing SQL in my outer code as needed. Despite relying crazy heavily on SQL, that&#x27;s rarely needed. And the outer code has tests.<p>It&#x27;d just be nice if Postgres could loosen the syntax in a few annoying places, like allowing a trailing comma in &quot;WITH q1 AS (...), q2 AS (...)&quot; Or if something could be done to avoid needing the &quot;WHERE true AND&quot; trick.</div><br/></div></div><div id="42860559" class="c"><input type="checkbox" id="c-42860559" checked=""/><div class="controls bullet"><span class="by">r1b</span><span>|</span><a href="#42861015">prev</a><span>|</span><a href="#42861814">next</a><span>|</span><label class="collapse" for="c-42860559">[-]</label><label class="expand" for="c-42860559">[2 more]</label></div><br/><div class="children"><div class="content">Nodding along furiously. One area where this comes up is when you want to export some piece of logic that effectively “returns a table”.<p>For example, I work with a source of data that requires a particularly hairy JOIN strategy. The logic is the same for any table with the same “shape”, but no one can reuse it without copy &#x2F; paste.</div><br/><div id="42862189" class="c"><input type="checkbox" id="c-42862189" checked=""/><div class="controls bullet"><span class="by">virtualwhys</span><span>|</span><a href="#42860559">parent</a><span>|</span><a href="#42861814">next</a><span>|</span><label class="collapse" for="c-42862189">[-]</label><label class="expand" for="c-42862189">[1 more]</label></div><br/><div class="children"><div class="content">See Esqueleto in Haskell, Slick and Quill in Scala, probably LINQ or some variant on .NET in C#&#x2F;F#.<p>All support building up arbitrarily complex queries based on statically typed query fragments.<p>String fragment &quot;composition&quot; is like banging rocks together.</div><br/></div></div></div></div><div id="42861814" class="c"><input type="checkbox" id="c-42861814" checked=""/><div class="controls bullet"><span class="by">mrtimo</span><span>|</span><a href="#42860559">prev</a><span>|</span><a href="#42861735">next</a><span>|</span><label class="collapse" for="c-42861814">[-]</label><label class="expand" for="c-42861814">[1 more]</label></div><br/><div class="children"><div class="content">Malloy is a newish data language with semantic models... Perhaps what semantic SQL would look like: <a href="https:&#x2F;&#x2F;www.malloydata.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.malloydata.dev&#x2F;</a></div><br/></div></div><div id="42861735" class="c"><input type="checkbox" id="c-42861735" checked=""/><div class="controls bullet"><span class="by">brikym</span><span>|</span><a href="#42861814">prev</a><span>|</span><a href="#42861344">next</a><span>|</span><label class="collapse" for="c-42861735">[-]</label><label class="expand" for="c-42861735">[2 more]</label></div><br/><div class="children"><div class="content">This what Kusto Query Language looks like:<p><pre><code>  StormEvents
  | summarize 
      TotalStormsInState = count(),
      StormsWithCropDamage = countif(DamageCrops &gt; 0)
      by State
  | extend PercentWithCropDamage = 
      round((todouble(StormsWithCropDamage) &#x2F; 
  TotalStormsInState \* 100), 2)
  | sort by StormsWithCropDamage

</code></pre>
I find it to be much more readable. With SQL CTEs is as close as you can get.</div><br/><div id="42861918" class="c"><input type="checkbox" id="c-42861918" checked=""/><div class="controls bullet"><span class="by">__thecoldwine__</span><span>|</span><a href="#42861735">parent</a><span>|</span><a href="#42861344">next</a><span>|</span><label class="collapse" for="c-42861918">[-]</label><label class="expand" for="c-42861918">[1 more]</label></div><br/><div class="children"><div class="content">Kusto is fine, but joins are quite horrendous there. To be frank, I don&#x27;t really get complains about &quot;SQL is not readable&quot;. Most of the time SQL is the most compact, clear and to the purpose way to fetch the data (given the data had been modeled in a manner suitable for queriying).<p>Luckily, most of the tables for KQL in Azure are flat and not complex and that is partially what makes kusto so compelling.</div><br/></div></div></div></div><div id="42861344" class="c"><input type="checkbox" id="c-42861344" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#42861735">prev</a><span>|</span><a href="#42859842">next</a><span>|</span><label class="collapse" for="c-42861344">[-]</label><label class="expand" for="c-42861344">[1 more]</label></div><br/><div class="children"><div class="content">Ah but “functor,” is a name from category theory and algebraic topology. I had read along thinking that this would come up in the conclusion! Instead it seems it’s not even mentioned in the sources for the name.<p>There’s potentially something like this in the “esqueleto” package for Haskell. But it has some limitations. It composes on syntactic fragments.<p>Although speaking of functors, the category theory ones, maybe categorical databases would fit the bill: <a href="https:&#x2F;&#x2F;categoricaldata.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;categoricaldata.net&#x2F;</a></div><br/></div></div><div id="42859842" class="c"><input type="checkbox" id="c-42859842" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#42861344">prev</a><span>|</span><a href="#42860703">next</a><span>|</span><label class="collapse" for="c-42859842">[-]</label><label class="expand" for="c-42859842">[1 more]</label></div><br/><div class="children"><div class="content">Very nice. Adding this one to my list of &quot;things other people wrote that nicely elucidate a shortcoming of SQL&quot;<p>&gt; Why would this be useful? Because SQL tables are global variables. By vanishing global variables, we automatically make every query fully testable.<p>And even if you don&#x27;t care about testability, certainly you can appreciate that global variables are bad for composability.</div><br/></div></div><div id="42860703" class="c"><input type="checkbox" id="c-42860703" checked=""/><div class="controls bullet"><span class="by">gremgoth</span><span>|</span><a href="#42859842">prev</a><span>|</span><a href="#42862510">next</a><span>|</span><label class="collapse" for="c-42860703">[-]</label><label class="expand" for="c-42860703">[1 more]</label></div><br/><div class="children"><div class="content">SQL select-from-where queries can indeed be formalized as &quot;pro-functors&quot;: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1602.03501" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1602.03501</a></div><br/></div></div><div id="42862510" class="c"><input type="checkbox" id="c-42862510" checked=""/><div class="controls bullet"><span class="by">zapkyeskrill</span><span>|</span><a href="#42860703">prev</a><span>|</span><a href="#42861512">next</a><span>|</span><label class="collapse" for="c-42862510">[-]</label><label class="expand" for="c-42862510">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re creating fake tables for your solution, couldn&#x27;t you then also create a fake table books(title) to satisfy the first problem statement?</div><br/></div></div><div id="42861512" class="c"><input type="checkbox" id="c-42861512" checked=""/><div class="controls bullet"><span class="by">beart</span><span>|</span><a href="#42862510">prev</a><span>|</span><a href="#42860444">next</a><span>|</span><label class="collapse" for="c-42861512">[-]</label><label class="expand" for="c-42861512">[1 more]</label></div><br/><div class="children"><div class="content">On the testing aspect - The TSQLT assembly (<a href="https:&#x2F;&#x2F;tsqlt.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tsqlt.org&#x2F;</a>) is an attempt at unit testing within MSSQL. It works okayish for what it is. I&#x27;ve at least found it to be nice when testing inputs for SQL functions and procedures, as well as some business rules within tables and views.<p>A few IDEs provide integrations for TSQLT: Management Studio with the redgate extension, Datagrip, maybe others.</div><br/></div></div><div id="42860444" class="c"><input type="checkbox" id="c-42860444" checked=""/><div class="controls bullet"><span class="by">brianhama</span><span>|</span><a href="#42861512">prev</a><span>|</span><a href="#42860615">next</a><span>|</span><label class="collapse" for="c-42860444">[-]</label><label class="expand" for="c-42860444">[1 more]</label></div><br/><div class="children"><div class="content">MS-SQL would seem to already support everything you’ve suggested.</div><br/></div></div><div id="42860615" class="c"><input type="checkbox" id="c-42860615" checked=""/><div class="controls bullet"><span class="by">froderick</span><span>|</span><a href="#42860444">prev</a><span>|</span><a href="#42828899">next</a><span>|</span><label class="collapse" for="c-42860615">[-]</label><label class="expand" for="c-42860615">[2 more]</label></div><br/><div class="children"><div class="content">I already have functors, effectively, by writing sql queries in clojure with honeysql. The clojure data structures make behavior composition from reusable sql snippets easy, and the testing of sql snippets is just based on literals as the article describes. Works really well.</div><br/><div id="42860962" class="c"><input type="checkbox" id="c-42860962" checked=""/><div class="controls bullet"><span class="by">nateroling</span><span>|</span><a href="#42860615">parent</a><span>|</span><a href="#42828899">next</a><span>|</span><label class="collapse" for="c-42860962">[-]</label><label class="expand" for="c-42860962">[1 more]</label></div><br/><div class="children"><div class="content">I’ve done the same with SQLAlchemy in Python and SQLKata in C#.<p>Sadly the whole idea of composable query builders seems to have fallen out of fashion.</div><br/></div></div></div></div><div id="42828899" class="c"><input type="checkbox" id="c-42828899" checked=""/><div class="controls bullet"><span class="by">earnestinger</span><span>|</span><a href="#42860615">prev</a><span>|</span><a href="#42859858">next</a><span>|</span><label class="collapse" for="c-42828899">[-]</label><label class="expand" for="c-42828899">[1 more]</label></div><br/><div class="children"><div class="content">prior art:<p><a href="https:&#x2F;&#x2F;research.google&#x2F;pubs&#x2F;sql-has-problems-we-can-fix-them-pipe-syntax-in-sql&#x2F;" rel="nofollow">https:&#x2F;&#x2F;research.google&#x2F;pubs&#x2F;sql-has-problems-we-can-fix-the...</a><p><a href="https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;against-sql&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;against-sql&#x2F;</a> - talks about compositionality<p><a href="https:&#x2F;&#x2F;www.edgedb.com&#x2F;blog&#x2F;we-can-do-better-than-sql" rel="nofollow">https:&#x2F;&#x2F;www.edgedb.com&#x2F;blog&#x2F;we-can-do-better-than-sql</a> (2019)<p>(List taken from <a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;vmyk7d&#x2F;composable_sql#c_layb8n" rel="nofollow">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;vmyk7d&#x2F;composable_sql#c_layb8n</a>)</div><br/></div></div><div id="42859858" class="c"><input type="checkbox" id="c-42859858" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#42828899">prev</a><span>|</span><a href="#42862296">next</a><span>|</span><label class="collapse" for="c-42859858">[-]</label><label class="expand" for="c-42859858">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it table-valued function? IIRC, the SQL standard still doesn&#x27;t have it but it&#x27;s almost universally supported extension across vendors.</div><br/><div id="42860051" class="c"><input type="checkbox" id="c-42860051" checked=""/><div class="controls bullet"><span class="by">zetalyrae</span><span>|</span><a href="#42859858">parent</a><span>|</span><a href="#42862296">next</a><span>|</span><label class="collapse" for="c-42860051">[-]</label><label class="expand" for="c-42860051">[2 more]</label></div><br/><div class="children"><div class="content">At least in Postgres, table-valued functions can&#x27;t take tables as arguments, only scalars. That&#x27;s the main difference: functors can not just return tables, but take tables satisfying some interface as arguments.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;7.3&#x2F;xfunc-tablefunctions.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;7.3&#x2F;xfunc-tablefunctions.htm...</a><p>I thought I had written a footnote or appendix about this but I guess I forgot.</div><br/><div id="42862376" class="c"><input type="checkbox" id="c-42862376" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42859858">root</a><span>|</span><a href="#42860051">parent</a><span>|</span><a href="#42862296">next</a><span>|</span><label class="collapse" for="c-42862376">[-]</label><label class="expand" for="c-42862376">[1 more]</label></div><br/><div class="children"><div class="content">MSSQL can take tables as arguments if they are temporary tables declared to be of a certain type. But that restriction limits their use a lot.</div><br/></div></div></div></div></div></div><div id="42862296" class="c"><input type="checkbox" id="c-42862296" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#42859858">prev</a><span>|</span><a href="#42828884">next</a><span>|</span><label class="collapse" for="c-42862296">[-]</label><label class="expand" for="c-42862296">[1 more]</label></div><br/><div class="children"><div class="content">I tried before with <a href="https:&#x2F;&#x2F;yaml2sql.netlify.app&#x2F;" rel="nofollow">https:&#x2F;&#x2F;yaml2sql.netlify.app&#x2F;</a></div><br/></div></div><div id="42828884" class="c"><input type="checkbox" id="c-42828884" checked=""/><div class="controls bullet"><span class="by">earnestinger</span><span>|</span><a href="#42862296">prev</a><span>|</span><label class="collapse" for="c-42828884">[-]</label><label class="expand" for="c-42828884">[1 more]</label></div><br/><div class="children"><div class="content">Attempt at sql composability.</div><br/></div></div></div></div></div></div></div></body></html>