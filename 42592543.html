<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736067652868" as="style"/><link rel="stylesheet" href="styles.css?v=1736067652868"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pages.cs.wisc.edu/~remzi/Naur.pdf">Programming as Theory Building (1985) [pdf]</a> <span class="domain">(<a href="https://pages.cs.wisc.edu">pages.cs.wisc.edu</a>)</span></div><div class="subtext"><span>beryilma</span> | <span>38 comments</span></div><br/><div><div id="42594377" class="c"><input type="checkbox" id="c-42594377" checked=""/><div class="controls bullet"><span class="by">peterkelly</span><span>|</span><a href="#42593791">next</a><span>|</span><label class="collapse" for="c-42594377">[-]</label><label class="expand" for="c-42594377">[13 more]</label></div><br/><div class="children"><div class="content">One of the most important papers in software engineering, which I believe everyone in this profession should read and internalize.<p>Every time I see another startup trying use LLMs for code generation I sigh in despair. As AI technology improves and becomes better at producing code, what looks like a win in the short term will end up creating more and more code that has been created without a human going through the necessary thought processes and problem solving steps to build the theory of the software as described in this paper.<p>It&#x27;s also why its critically important for companies to do what they can to retain the people who built the software in the first place, or at least ensure there&#x27;s enough continuity as new people join the team so they can build their mental model by working alongside the original developers.</div><br/><div id="42594586" class="c"><input type="checkbox" id="c-42594586" checked=""/><div class="controls bullet"><span class="by">szvsw</span><span>|</span><a href="#42594377">parent</a><span>|</span><a href="#42595208">next</a><span>|</span><label class="collapse" for="c-42594586">[-]</label><label class="expand" for="c-42594586">[6 more]</label></div><br/><div class="children"><div class="content">&gt; without a human going through the necessary thought processes and problem solving steps to build the theory of the software as described in this paper<p>We might not be there yet (well we definitely are not) but it does not seem out of the question that within a generous 10 years we will have systems which can leverage graphs, descriptive language, interpreters, and so on to plan out and document and iterate and refine the structure of a problem and its architectural solution in tandem with developing the solution itself iteratively at a very effective level, given a sufficient explanation of the goals&#x2F;problem - or more importantly&#x2F;phrased another way, following the initial theory of a problem formulated by the human; the kind of documentation produced by such systems can also be more easily ingested by other non-human systems, potentially remedying some of the challenges with outlining&#x2F;documenting&#x2F;transferring the theory of the problem that humans have.<p>And what prevents a human from doing code review on such a system’s outputs? Now maybe your point was that the simple expense of a human’s time is the barrier, especially given that you were talking about the context of companies using LLMs to speed up their code production (read: eliminate cost centers), but in that case the errors that may come from poorly designed procedurally generated codebases just reads like bad project management to me for which the chickens will ultimately come home to roost; the companies which can successfully integrate such procedurally codegen engines while still maintaining strong design principles, maintainability, simplicity, etc ought to outcompete their competitors’ slop in the long run, right?<p>Having said all that, I think the more important loss is that the human fails to build as much intuition for the problem space themself by not being on the ground in the weeds solving the problems with their own solutions, and this will struggle to develop their own effective theories of the problem (as indicated by the title of the article in the first place).</div><br/><div id="42595018" class="c"><input type="checkbox" id="c-42595018" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42594377">root</a><span>|</span><a href="#42594586">parent</a><span>|</span><a href="#42595208">next</a><span>|</span><label class="collapse" for="c-42595018">[-]</label><label class="expand" for="c-42595018">[5 more]</label></div><br/><div class="children"><div class="content">What you&#x27;re describing is the siren call of No Code, which has been tempting manager-types for decades and which has so far failed every single time.<p>The trouble with No Code is that your first paragraph is already my job description: I plan out and document and refine the structure of a problem and its architectural solution while simultaneously developing the system itself. The &quot;sufficient explanation of the goals&#x2F;problem&quot; <i>is the code</i>—anything less is totally insufficient. And once I have the code, it is both the fully-documented problem <i>and</i> the spec for the solution.<p>I won&#x27;t pretend to know the final end state for these tools, but it&#x27;s definitely not that engineers will write natural-language specs and the LLMs will translate them, because <i>code</i> (in varying degrees of high- and low-level languages) is the preferred language for solution specification for a reason. It&#x27;s precise, unambiguous, and well understood by all engineers on a project. There is no need to be filled by swapping that out with natural language unless you&#x27;re taking engineers out of the loop entirely.</div><br/><div id="42596145" class="c"><input type="checkbox" id="c-42596145" checked=""/><div class="controls bullet"><span class="by">quick_brown_fox</span><span>|</span><a href="#42594377">root</a><span>|</span><a href="#42595018">parent</a><span>|</span><a href="#42595406">next</a><span>|</span><label class="collapse" for="c-42596145">[-]</label><label class="expand" for="c-42596145">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;sufficient explanation of the goals&#x2F;problem&quot; is the code—anything less is totally insufficient.<p>somewhat in that spirit, I like Gerald Sussman&#x27;s interpretation of software development as &quot;problem solving by debugging-almost right plans&quot;, in e.g. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2MYzvQ1v8Ww" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2MYzvQ1v8Ww</a></div><br/></div></div><div id="42595406" class="c"><input type="checkbox" id="c-42595406" checked=""/><div class="controls bullet"><span class="by">szvsw</span><span>|</span><a href="#42594377">root</a><span>|</span><a href="#42595018">parent</a><span>|</span><a href="#42596145">prev</a><span>|</span><a href="#42595208">next</a><span>|</span><label class="collapse" for="c-42595406">[-]</label><label class="expand" for="c-42595406">[3 more]</label></div><br/><div class="children"><div class="content">I mostly agree with what you were saying, but I don’t think I was advocating for “no code” entirely, and certainly not the elimination of engineers entirely.<p>I was trying to articulate the idea that code generation <i>tools</i> will become increasingly sophisticated and capable, but still be tools that require operation by engineers for maximal effect. I see them as just another abstraction mechanism that will exist within the various layers that separate a dev from the metal. That doesn’t mean the capabilities of such tools are limited to where they are today, and it doesn’t mean that programmers won’t need to learn new ways of operating their tools.<p>I also hinted at it, but there’s nothing to say that our orchestration of such systems needs to be done in natural language. We are already skilled at representing procedures and systems in code like you said; there’s no reason to think we wouldn’t be adept at learning new languages specialized for specifying higher order designs in a more compact but still rigorous form to codegen systems. it seems reasonable to think that we will start developing DSLs and the like for communicating program and system design to codegen systems in a precise manner. One obvious way of thinking about that is by specifying interfaces and test cases in a rigorous manner and letting the details be filled in - obviously attempts at that now exhibit lots of poor implementation decisions <i>inside</i> of the methods, but that is not a universal phenomenon that will always hold.</div><br/><div id="42597467" class="c"><input type="checkbox" id="c-42597467" checked=""/><div class="controls bullet"><span class="by">noddybear</span><span>|</span><a href="#42594377">root</a><span>|</span><a href="#42595406">parent</a><span>|</span><a href="#42595208">next</a><span>|</span><label class="collapse" for="c-42597467">[-]</label><label class="expand" for="c-42597467">[2 more]</label></div><br/><div class="children"><div class="content">The DSL paradigm is generally how I go about using LLMs on new projects, I.e use the LLM to design a language that best represents the abstractions and concepts of the project - and once the language is defined, the LLM can express usecases with the DSL and ultimately convert them into an existing high level language like Python.</div><br/><div id="42597877" class="c"><input type="checkbox" id="c-42597877" checked=""/><div class="controls bullet"><span class="by">szvsw</span><span>|</span><a href="#42594377">root</a><span>|</span><a href="#42597467">parent</a><span>|</span><a href="#42595208">next</a><span>|</span><label class="collapse" for="c-42597877">[-]</label><label class="expand" for="c-42597877">[1 more]</label></div><br/><div class="children"><div class="content">Do you have any repos or examples you can share? Would love to see an example of that in action!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42595208" class="c"><input type="checkbox" id="c-42595208" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42594377">parent</a><span>|</span><a href="#42594586">prev</a><span>|</span><a href="#42594738">next</a><span>|</span><label class="collapse" for="c-42595208">[-]</label><label class="expand" for="c-42595208">[3 more]</label></div><br/><div class="children"><div class="content">Unfortunately, the book this was included in: _Computing: A Human Activity_<p><a href="https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;4594604-computing" rel="nofollow">https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;4594604-computing</a><p>is out of print, as is _Concise survey of computer methods_ and rather pricey.<p>Oddly, _Knowing and the Mystique of Logic and Rules_ (which has an even lengthier title after a colon...) has four entries at Goodreads and is listed under &quot;P. Naur&quot; and is even pricier, quite expensive on Amazon:<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Knowing-Mystique-Logic-Rules-Statements-ebook&#x2F;dp&#x2F;B00FB9H3QY" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Knowing-Mystique-Logic-Rules-Statemen...</a><p>even as an ebook.<p>It would be more influential if it was affordably in print....</div><br/><div id="42595655" class="c"><input type="checkbox" id="c-42595655" checked=""/><div class="controls bullet"><span class="by">justincormack</span><span>|</span><a href="#42594377">root</a><span>|</span><a href="#42595208">parent</a><span>|</span><a href="#42597716">next</a><span>|</span><label class="collapse" for="c-42595655">[-]</label><label class="expand" for="c-42595655">[1 more]</label></div><br/><div class="children"><div class="content">It was reprinted elsewhere, in an agile book (which one?) which this (more readable than linked) copy [1] is from. I think the other one might be from another edition of the same book. I ordered Computing A Human Activity a few weeks ago, its still in shipping, probably got the cheapest remaining copy.<p>[1] <a href="https:&#x2F;&#x2F;pablo.rauzy.name&#x2F;dev&#x2F;naur1985programming.pdf" rel="nofollow">https:&#x2F;&#x2F;pablo.rauzy.name&#x2F;dev&#x2F;naur1985programming.pdf</a></div><br/></div></div><div id="42597716" class="c"><input type="checkbox" id="c-42597716" checked=""/><div class="controls bullet"><span class="by">federalauth</span><span>|</span><a href="#42594377">root</a><span>|</span><a href="#42595208">parent</a><span>|</span><a href="#42595655">prev</a><span>|</span><a href="#42594738">next</a><span>|</span><label class="collapse" for="c-42597716">[-]</label><label class="expand" for="c-42597716">[1 more]</label></div><br/><div class="children"><div class="content">Paging Stripe Press</div><br/></div></div></div></div><div id="42594738" class="c"><input type="checkbox" id="c-42594738" checked=""/><div class="controls bullet"><span class="by">pbw</span><span>|</span><a href="#42594377">parent</a><span>|</span><a href="#42595208">prev</a><span>|</span><a href="#42597419">next</a><span>|</span><label class="collapse" for="c-42594738">[-]</label><label class="expand" for="c-42594738">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think using AI to write code precludes learning deeply about the problem domain and even the solution. However, it could lead to those problems depending on how it&#x27;s done. But done well you can still have a very knowledgeable team that understands the domain and large portions of the code, I believe anyway.<p>I think software engineers will drift towards only understanding the domain and creating tasks and then reviewing code written by AI. But the reviews will be necessary and will matter, at least for a while.</div><br/></div></div><div id="42597419" class="c"><input type="checkbox" id="c-42597419" checked=""/><div class="controls bullet"><span class="by">wwarner</span><span>|</span><a href="#42594377">parent</a><span>|</span><a href="#42594738">prev</a><span>|</span><a href="#42596774">next</a><span>|</span><label class="collapse" for="c-42597419">[-]</label><label class="expand" for="c-42597419">[1 more]</label></div><br/><div class="children"><div class="content">Respectfully, this seems upside down to me. Tools incorporating LLMs will be the knowledge repository for s&#x2F;w projects of the future, and will capture and then summarize ideas, create mocks and finally render code (on command with guidance and iterations involving teams). My point being that the LLM era will be a deeper realization of code as theory building.</div><br/></div></div><div id="42596774" class="c"><input type="checkbox" id="c-42596774" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#42594377">parent</a><span>|</span><a href="#42597419">prev</a><span>|</span><a href="#42593791">next</a><span>|</span><label class="collapse" for="c-42596774">[-]</label><label class="expand" for="c-42596774">[1 more]</label></div><br/><div class="children"><div class="content">I thought it&#x27;s about solving Leetcode problems.</div><br/></div></div></div></div><div id="42593791" class="c"><input type="checkbox" id="c-42593791" checked=""/><div class="controls bullet"><span class="by">triska</span><span>|</span><a href="#42594377">prev</a><span>|</span><a href="#42600304">next</a><span>|</span><label class="collapse" for="c-42593791">[-]</label><label class="expand" for="c-42593791">[1 more]</label></div><br/><div class="children"><div class="content">As relevant as ever, arguably more relevant than ever as more programs are being written and need to be adapted, in more and more complex domains.<p>Note what Naur means with <i>Theory</i> here. Quoting from the paper:<p><i>&quot;What will be considered here is the suggestion that the programmers&#x27; knowledge properly should be regarded as a theory, in the sense of Ryle [Gilbert Ryle, The Concept of Mind, 1946]. Very briefly, a person who has or possesses a theory in this sense knows how to do certain things and in addition can support the actual doing with explanations, justifications, and answers to queries, about the activity of concern.&quot;</i><p>This is not &quot;theory&quot; in the sense we sometimes encounter in colloquial speech in the sense of (exclusively) &quot;assumption&quot;, especially not with the connotation &quot;<i>unjustified</i> assumption&quot;. It is also not a set of rules:<p>&quot;<i>The dependence of a theory on a grasp of certain kinds of similarity between situations and events of the real world gives the reason why the knowledge held by someone who has the theory could not, in principle, be expressed in terms of rules. In fact, the similarities in question are not, and cannot be, expressed in terms of criteria, no more than the similarities of many other kinds of objects, such as human faces, tunes, or tastes of wine, can thus be expressed.</i>&quot;<p>Yet, it plays a central role in programming:<p><i>&quot;For a program to retain its quality it is mandatory that each modification is firmly grounded in the theory of it. Indeed, the very notion of qualities such as simplicity and good structure can only be understood in terms of the theory of the program, since they characterize the actual program text in relation to such program texts that might have been written to achieve the same execution behaviour, but which exist only as possibilities in the programmer&#x27;s understanding.&quot;</i></div><br/></div></div><div id="42600304" class="c"><input type="checkbox" id="c-42600304" checked=""/><div class="controls bullet"><span class="by">Abishek_Muthian</span><span>|</span><a href="#42593791">prev</a><span>|</span><a href="#42598607">next</a><span>|</span><label class="collapse" for="c-42600304">[-]</label><label class="expand" for="c-42600304">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t declarative programming and by extension functional programming adhere more to the ethos of ‘Programming as Theory Building’ ?<p>I recently started building mobile apps using Flutter after a decade of developing apps using imperative programming languages and I’m really in love with the declarative nature of flutter.<p>Similarly for web development, I always loved HTML and so HTMX has been a boon for me. I’m using Go for backend, but I’ve been thinking whether I should move on to a proper functional programming language like Elixir with Phoenix since I’m liking declarative programming very much?</div><br/></div></div><div id="42598607" class="c"><input type="checkbox" id="c-42598607" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42600304">prev</a><span>|</span><a href="#42595988">next</a><span>|</span><label class="collapse" for="c-42598607">[-]</label><label class="expand" for="c-42598607">[1 more]</label></div><br/><div class="children"><div class="content">Related. Others?<p><i>Programming as Theory Building (1985)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38907366">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38907366</a> - Jan 2024 (12 comments)<p><i>Programming as Theory Building (1985) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37263121">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37263121</a> - Aug 2023 (36 comments)<p><i>Programming as Theory Building (1985) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33659795">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33659795</a> - Nov 2022 (1 comment)<p><i>Naur on Programming as Theory Building (1985) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31500174">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31500174</a> - May 2022 (4 comments)<p><i>Naur on Programming as Theory Building (1985) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30861573">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30861573</a> - March 2022 (3 comments)<p><i>Programming as Theory Building (1985)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23375193">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23375193</a> - June 2020 (35 comments)<p><i>Programming as Theory Building (1985) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20736145">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20736145</a> - Aug 2019 (11 comments)<p><i>Peter Naur – Programming as Theory Building (1985) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10833278">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10833278</a> - Jan 2016 (15 comments)<p><i>Naur’s “Programming as Theory Building” (2011)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7491661">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7491661</a> - March 2014 (14 comments)<p><i>Programming as Theory Building (by Naur of BNF)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=121291">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=121291</a> - Feb 2008 (2 comments)</div><br/></div></div><div id="42595988" class="c"><input type="checkbox" id="c-42595988" checked=""/><div class="controls bullet"><span class="by">softwaredoug</span><span>|</span><a href="#42598607">prev</a><span>|</span><a href="#42594808">next</a><span>|</span><label class="collapse" for="c-42595988">[-]</label><label class="expand" for="c-42595988">[2 more]</label></div><br/><div class="children"><div class="content">This has so many implications for software team design<p>Like hiring that one unicorn dev to solve X hard problem isn&#x27;t a great &quot;theory building&quot; exercise. It can build theories for that one person, but without feedback they&#x27;re never tested, they&#x27;re never adopted by the whole team<p>So you actually NEED juniors, &#x27;stupid&#x27; questions, outside points of view, and ways of openly and scientifically evaluating theories instead of defaulting to the authority of supposed experts. You also need to retain seniors who have context and a good historical working definition of the problem.<p>But a lot of teams are focused on just the next problem and &quot;shipping it&quot;. Rather than using &quot;shipping&quot; to help the team develop a better theory of the problem.<p>The value isn&#x27;t what&#x27;s shipped, its the working knowledge of the team.</div><br/><div id="42598612" class="c"><input type="checkbox" id="c-42598612" checked=""/><div class="controls bullet"><span class="by">antistaph</span><span>|</span><a href="#42595988">parent</a><span>|</span><a href="#42594808">next</a><span>|</span><label class="collapse" for="c-42598612">[-]</label><label class="expand" for="c-42598612">[1 more]</label></div><br/><div class="children"><div class="content">Value of a product tends to be measured by the number of features shipped, the quality of service and time to market. But knowledge of the team is hard to evaluate and to sell to a manager.<p>It is good if developer has already it, he is more productive then. But when he explicitly puts effort into gaining knowledge, then he does not deliver during that time so maybe he should not be paid for it.<p>I can&#x27;t imagine a relationship between a manager and a developer where knowledge is valued higher than delivery. It could work only if the manager also believes in this value. I think he could believe in it only if he is sure that this project will pay off in the long run. In the era of a fast-changing world, he is putting the value of delivery and satisfying stakeholders on a higher rung.</div><br/></div></div></div></div><div id="42594808" class="c"><input type="checkbox" id="c-42594808" checked=""/><div class="controls bullet"><span class="by">digdugdirk</span><span>|</span><a href="#42595988">prev</a><span>|</span><a href="#42595709">next</a><span>|</span><label class="collapse" for="c-42594808">[-]</label><label class="expand" for="c-42594808">[2 more]</label></div><br/><div class="children"><div class="content">Relevant episode from a great podcast:<p><a href="https:&#x2F;&#x2F;futureofcoding.org&#x2F;episodes&#x2F;061.html" rel="nofollow">https:&#x2F;&#x2F;futureofcoding.org&#x2F;episodes&#x2F;061.html</a></div><br/><div id="42597459" class="c"><input type="checkbox" id="c-42597459" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#42594808">parent</a><span>|</span><a href="#42595709">next</a><span>|</span><label class="collapse" for="c-42597459">[-]</label><label class="expand" for="c-42597459">[1 more]</label></div><br/><div class="children"><div class="content">This episode was my introduction to the paper. It is a really great discussion, and Ivan&#x27;s editing and audio production is really fun.</div><br/></div></div></div></div><div id="42595709" class="c"><input type="checkbox" id="c-42595709" checked=""/><div class="controls bullet"><span class="by">myflash13</span><span>|</span><a href="#42594808">prev</a><span>|</span><a href="#42593923">next</a><span>|</span><label class="collapse" for="c-42595709">[-]</label><label class="expand" for="c-42595709">[1 more]</label></div><br/><div class="children"><div class="content">This also explains the unreasonable effectiveness of solo programmers and small teams, and why the famous adage is so true: adding programmers to a late project makes it even later.</div><br/></div></div><div id="42593923" class="c"><input type="checkbox" id="c-42593923" checked=""/><div class="controls bullet"><span class="by">stevan</span><span>|</span><a href="#42595709">prev</a><span>|</span><a href="#42595199">next</a><span>|</span><label class="collapse" for="c-42593923">[-]</label><label class="expand" for="c-42593923">[5 more]</label></div><br/><div class="children"><div class="content">It seems to me that one consequence of the &quot;Theory Building View&quot; is that: instead of focusing on delivering the artifact or the documentation of said artifact, one should instead focus on documenting how the artifact can be re-implemented by somebody else. Or in other words optimise for &quot;revival&quot; of a &quot;dead&quot; programs.<p>This seems especially relevant in open source, or in blog posts &#x2F; papers, where we rarely have teams which continuously transfer theories to newcomers. Focusing on documenting &quot;how it works under the hood&quot; and helping others re-implement your ideas also seems more useful to break silos between programming language communities.<p>For example a blog post that introduces some library in some programming language and only explains how to use its API to solve some concrete problems is of little use to programmers that use other programming languages, compared to a post which would explain how the library works on a level where other programmers could build a theory and re-implement it themselves in their language of choice.<p>I also feel like there&#x27;s a connection between the &quot;Theory Building View&quot; and the people that encourage rewriting your software. For example in the following interview[0] Joe Armstrong explains that he often wrote a piece of code and the next day he threw it away and rewrote it from scratch. Perhaps this has to do with the fact that after your first iteration, you&#x27;ve a better theory and therefore in a better position to implement it in a better way?<p>I also believe there&#x27;s some connection to program size here. In the early days of Erlang it was possible to do a total rewrite of the whole language in less than a week. New language features were added in one work session, if you couldn’t get the idea out of your brain and code it up in that time then you didn’t do it, Joe explained[1] (17:10).<p>In a later talk[2] he elaborated saying:<p><pre><code>    “We need to break systems down into small understandable components with message passing between them and with contracts describing whats going on between them so we can understand them, otherwise we just won’t be able to make software that works. I think the limit of human understandability is something like 128KB of code in any language. So we really need to box things down into small units of computation and formally verify them and the protocols in particular.”
</code></pre>
I found the 128KB interesting. It reminds me of Forth here you are forced to fit your code in blocks (1024 chars or 16 lines on 64 characters).<p>Speaking of Forth, Chuck Moore also appears to be a rewriter. He said[3] something in similar:<p><pre><code>    “Instead of being rewritten, software has features added. And becomes more complex. So complex that no one dares change it, or improve it, for fear of unintended consequences. But adding to it seems relatively safe. We need dedicated programmers who commit their careers to single applications. Rewriting them over and over until they’re perfect.” (2009)
</code></pre>
Chuck re-implemented the his Forth many times, in fact Forth’s design seems to be centered around being easily re-implementable on new hardware (this was back when new CPUs had new instruction sets). Another example is Chuck’s OKAD, VLSI design tools, to which he comments:<p><pre><code>    “I’ve spent more time with it that any other; have re-written it multiple times; and carried it to a satisfying level of maturity.”
</code></pre>
Something I’m curious about is: what would tools and processes that encourage the &quot;Theory Building View&quot; look like?<p>[0]: <a href="https:&#x2F;&#x2F;vimeo.com&#x2F;1344065#t=8m30s" rel="nofollow">https:&#x2F;&#x2F;vimeo.com&#x2F;1344065#t=8m30s</a><p>[1]: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;action&#x2F;downloadSupplement?doi=10.1145%2F1238844.1238850&amp;file=m6-armstrong-h.mov" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;action&#x2F;downloadSupplement?doi=10.1145%2F1...</a><p>[2]: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;rQIE22e0cW8?t=3492" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;rQIE22e0cW8?t=3492</a><p>[3]: <a href="https:&#x2F;&#x2F;www.red-gate.com&#x2F;simple-talk&#x2F;opinion&#x2F;geek-of-the-week&#x2F;chuck-moore-geek-of-the-week&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.red-gate.com&#x2F;simple-talk&#x2F;opinion&#x2F;geek-of-the-wee...</a></div><br/><div id="42594530" class="c"><input type="checkbox" id="c-42594530" checked=""/><div class="controls bullet"><span class="by">szvsw</span><span>|</span><a href="#42593923">parent</a><span>|</span><a href="#42594213">next</a><span>|</span><label class="collapse" for="c-42594530">[-]</label><label class="expand" for="c-42594530">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It seems to me that one consequence of the &quot;Theory Building View&quot; is that: instead of focusing on delivering the artifact or the documentation of said artifact, one should instead focus on documenting how the artifact can be re-implemented by somebody else. Or in other words optimise for &quot;revival&quot; of a &quot;dead&quot; programs.<p>Arguably, this is the entire spirit of academia, which mildly serves as a counter example, or at least illustrates the challenges with what you are describing - even in something where the stated goal is reproducibility, you still have a replication crisis. Though to be fair, I think part of the problem there is that, like you said, people focus too much on “documenting the artifact” and not “documenting how to produce the artifact,” but this is often because the process is often “merely” technical and not theoretical (and thus not publishable) despite being where most of the hard work and problem solving and edge case resolution and so on happened.<p>Edit: oh, and I would also mentioned, that the kind of comment you’ve described which focuses on <i>why</i> some process exists in the form it does to better explain <i>how</i> it does what it does aligns closely with Osterhout’s notion of a <i>good</i> comment in <i>A Philosophy of Software Design</i>.</div><br/></div></div><div id="42594213" class="c"><input type="checkbox" id="c-42594213" checked=""/><div class="controls bullet"><span class="by">dambi0</span><span>|</span><a href="#42593923">parent</a><span>|</span><a href="#42594530">prev</a><span>|</span><a href="#42596048">next</a><span>|</span><label class="collapse" for="c-42594213">[-]</label><label class="expand" for="c-42594213">[1 more]</label></div><br/><div class="children"><div class="content">Literate programming could be seen as one way to encourage a focus on theory building.</div><br/></div></div><div id="42596048" class="c"><input type="checkbox" id="c-42596048" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42593923">parent</a><span>|</span><a href="#42594213">prev</a><span>|</span><a href="#42595137">next</a><span>|</span><label class="collapse" for="c-42596048">[-]</label><label class="expand" for="c-42596048">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a job for &quot;Literate Programming&quot;:<p><a href="http:&#x2F;&#x2F;literateprogramming.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;literateprogramming.com&#x2F;</a><p>I couldn&#x27;t easily count the number of re-writes for my current project, but it keeps getting better, and each new iteration has had an updated architecture allowing for new features. When I re-wrote it as a Literate Program (first a .dtx, now a &quot;normal&quot; .tex) things got much more expressive and easier to work with.</div><br/></div></div><div id="42595137" class="c"><input type="checkbox" id="c-42595137" checked=""/><div class="controls bullet"><span class="by">crvdgc</span><span>|</span><a href="#42593923">parent</a><span>|</span><a href="#42596048">prev</a><span>|</span><a href="#42595199">next</a><span>|</span><label class="collapse" for="c-42595137">[-]</label><label class="expand" for="c-42595137">[1 more]</label></div><br/><div class="children"><div class="content">A co-worker once said: a good language specification should allow others to derive an independent implementation of the language.</div><br/></div></div></div></div><div id="42595199" class="c"><input type="checkbox" id="c-42595199" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#42593923">prev</a><span>|</span><a href="#42597177">next</a><span>|</span><label class="collapse" for="c-42595199">[-]</label><label class="expand" for="c-42595199">[2 more]</label></div><br/><div class="children"><div class="content">Is there an OCR&#x27;d version of the provided paper?</div><br/><div id="42595672" class="c"><input type="checkbox" id="c-42595672" checked=""/><div class="controls bullet"><span class="by">justincormack</span><span>|</span><a href="#42595199">parent</a><span>|</span><a href="#42597177">next</a><span>|</span><label class="collapse" for="c-42595672">[-]</label><label class="expand" for="c-42595672">[1 more]</label></div><br/><div class="children"><div class="content">This copy is readable <a href="https:&#x2F;&#x2F;pablo.rauzy.name&#x2F;dev&#x2F;naur1985programming.pdf" rel="nofollow">https:&#x2F;&#x2F;pablo.rauzy.name&#x2F;dev&#x2F;naur1985programming.pdf</a></div><br/></div></div></div></div><div id="42597177" class="c"><input type="checkbox" id="c-42597177" checked=""/><div class="controls bullet"><span class="by">fussylogic</span><span>|</span><a href="#42595199">prev</a><span>|</span><a href="#42594717">next</a><span>|</span><label class="collapse" for="c-42597177">[-]</label><label class="expand" for="c-42597177">[2 more]</label></div><br/><div class="children"><div class="content">better quality scan<p><a href="https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;Naur.pdf" rel="nofollow">https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;Naur.pdf</a></div><br/><div id="42597272" class="c"><input type="checkbox" id="c-42597272" checked=""/><div class="controls bullet"><span class="by">beryilma</span><span>|</span><a href="#42597177">parent</a><span>|</span><a href="#42594717">next</a><span>|</span><label class="collapse" for="c-42597272">[-]</label><label class="expand" for="c-42597272">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly the same file as the original post.</div><br/></div></div></div></div><div id="42594717" class="c"><input type="checkbox" id="c-42594717" checked=""/><div class="controls bullet"><span class="by">pbw</span><span>|</span><a href="#42597177">prev</a><span>|</span><a href="#42593523">next</a><span>|</span><label class="collapse" for="c-42594717">[-]</label><label class="expand" for="c-42594717">[2 more]</label></div><br/><div class="children"><div class="content">I always heard it as &quot;software development is an exercise in knowledge acquisition.&quot;</div><br/><div id="42599520" class="c"><input type="checkbox" id="c-42599520" checked=""/><div class="controls bullet"><span class="by">hcarvalhoalves</span><span>|</span><a href="#42594717">parent</a><span>|</span><a href="#42593523">next</a><span>|</span><label class="collapse" for="c-42599520">[-]</label><label class="expand" for="c-42599520">[1 more]</label></div><br/><div class="children"><div class="content">The best programmers eventually become experts in a problem domain they’ve worked on, because to teach a computer to automate a process well requires thinking like an expert and resolving incoherences. Weak programmers complain stakeholders don’t know what they want or that there’s no spec; I have a hunch these are going to be replaced by AI.</div><br/></div></div></div></div><div id="42597324" class="c"><input type="checkbox" id="c-42597324" checked=""/><div class="controls bullet"><span class="by">n00b101</span><span>|</span><a href="#42593523">prev</a><span>|</span><label class="collapse" for="c-42597324">[-]</label><label class="expand" for="c-42597324">[4 more]</label></div><br/><div class="children"><div class="content">I think you nerds need to stop reading obsolete academic fad papers from 1985. Imagine if your girlfriend was unironically reading articles of Cosmo from 1985 to figure out what to wear.<p>A computer program is a &quot;model&quot; of some thing. For example:<p><pre><code>    float m = 1e10f;
    float a = 9.8f;
    float F = m*a;
</code></pre>
Another example:<p><pre><code>    if(employee is still employed):
       float paycheque = getSalary(employee);

    else: 
       float paycheque = 0.00f;</code></pre></div><br/><div id="42597427" class="c"><input type="checkbox" id="c-42597427" checked=""/><div class="controls bullet"><span class="by">Centigonal</span><span>|</span><a href="#42597324">parent</a><span>|</span><a href="#42600418">next</a><span>|</span><label class="collapse" for="c-42597427">[-]</label><label class="expand" for="c-42597427">[1 more]</label></div><br/><div class="children"><div class="content">Fashion changes quickly over time, while good models of real-life processes are infrequently supplanted.<p>For your argument to work, you need to prove that the original article is closer to a 1985 Cosmo article than it is to something like Clayton Christensen&#x27;s 1995 article on Disruptive Innovation, which remains relevant today (or disprove one of the premises in my comment).</div><br/></div></div><div id="42600418" class="c"><input type="checkbox" id="c-42600418" checked=""/><div class="controls bullet"><span class="by">gavmor</span><span>|</span><a href="#42597324">parent</a><span>|</span><a href="#42597427">prev</a><span>|</span><a href="#42599179">next</a><span>|</span><label class="collapse" for="c-42600418">[-]</label><label class="expand" for="c-42600418">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not unreasonable to explore historical eras for fashion inspiration.</div><br/></div></div><div id="42599179" class="c"><input type="checkbox" id="c-42599179" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#42597324">parent</a><span>|</span><a href="#42600418">prev</a><span>|</span><label class="collapse" for="c-42599179">[-]</label><label class="expand" for="c-42599179">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes there&#x27;s a glitch and the employee continues to get paid after being laid off.</div><br/></div></div></div></div></div></div></div></div></div></body></html>