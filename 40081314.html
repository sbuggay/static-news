<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713517254413" as="style"/><link rel="stylesheet" href="styles.css?v=1713517254413"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mcyoung.xyz/2024/04/17/calling-convention/">The Rust calling convention we deserve</a> <span class="domain">(<a href="https://mcyoung.xyz">mcyoung.xyz</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>68 comments</span></div><br/><div><div id="40083439" class="c"><input type="checkbox" id="c-40083439" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#40082189">next</a><span>|</span><label class="collapse" for="c-40083439">[-]</label><label class="expand" for="c-40083439">[11 more]</label></div><br/><div class="children"><div class="content">The main thing you want to do when optimizing the calling convention is measure its perf, not ruminate about what you think is good. Code performs well if it runs fast, not if it looks like it will.<p>Sometimes, what the author calls bad code is actually the fastest thing you can do for totally not obvious reasons. The only way to find out is to measure the performance on some large benchmark.<p>One reason why sometimes bad looking calling conventions perform well is just that they conserve argument registers, which makes the register allocator’s life a tad easier.<p>Another reason is that the CPUs of today are optimized on traces of instructions generated by C compilers. If you generate code that looks like what the C compiler would do - which passes on the stack surprisingly often, especially if you’re MSVC - then you hit the CPU’s sweet spot somehow.<p>Another reason is that inlining is so successful, so calls are a kind of unusual boundary on the hot path. It’s fine to have some jank on that boundary if it makes other things simpler.<p>Not saying that the changes done here are bad, but I am saying that it’s weird to just talk about what looks like weird code without measuring.<p>(Source: I optimized calling conventions for a living when I worked on JavaScriptCore. I also optimized other things too but calling conventions are quite dear to my heart. It was surprising how often bad-looking pass-on-the-stack code won on big, real code. Weird but true.)</div><br/><div id="40083668" class="c"><input type="checkbox" id="c-40083668" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#40083439">parent</a><span>|</span><a href="#40083952">next</a><span>|</span><label class="collapse" for="c-40083668">[-]</label><label class="expand" for="c-40083668">[4 more]</label></div><br/><div class="children"><div class="content">I very much agree with that especially since - like you said - code that looks like it will perform well, not always does.<p>That being said I&#x27;d like to add that  in my opinion performance measurement results should not be the only guiding principle.<p>You said it yourself: <i>&quot;Another reason is that the CPUs of today are optimized [..]&quot;</i><p>The important word is <i>&quot;today&quot;</i>. CPUs evolved and still do and a calling convention should be designed for the long term.<p>Sadly, it means that it is beneficial to not deviate too much from what C++ does [1], because it is likely that future processor optimizations will be targeted in that direction.<p>Apart from that it might be worthwhile to consider general principles that are not likely to change (e.g. conserve argument registers, as you mentioned), to make the calling convention robust and future proof.<p>[1] It feels a bit strange, when I say that because I think Rust has become a bit too conservative in recent years, when it comes to its <i>weirdness budget</i> (<a href="https:&#x2F;&#x2F;steveklabnik.com&#x2F;writing&#x2F;the-language-strangeness-budget" rel="nofollow">https:&#x2F;&#x2F;steveklabnik.com&#x2F;writing&#x2F;the-language-strangeness-bu...</a>). You cannot be better without being different, after all.</div><br/><div id="40083874" class="c"><input type="checkbox" id="c-40083874" checked=""/><div class="controls bullet"><span class="by">workingjubilee</span><span>|</span><a href="#40083439">root</a><span>|</span><a href="#40083668">parent</a><span>|</span><a href="#40084082">next</a><span>|</span><label class="collapse" for="c-40083874">[-]</label><label class="expand" for="c-40083874">[2 more]</label></div><br/><div class="children"><div class="content">The Rust calling convention is actually defined as unstable, so 1.79 is allowed to have a different calling convention than 1.80 and so on. I don&#x27;t think designing one for the long term is a real concern right now.</div><br/><div id="40083923" class="c"><input type="checkbox" id="c-40083923" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#40083439">root</a><span>|</span><a href="#40083874">parent</a><span>|</span><a href="#40084082">next</a><span>|</span><label class="collapse" for="c-40083923">[-]</label><label class="expand" for="c-40083923">[1 more]</label></div><br/><div class="children"><div class="content">I know, but from what I understand there are initiatives to stabilize the ABI, which would also mean stabilizing calling conventions. I read the article in that broader context, even if it does not talk about that directly.</div><br/></div></div></div></div><div id="40084082" class="c"><input type="checkbox" id="c-40084082" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40083439">root</a><span>|</span><a href="#40083668">parent</a><span>|</span><a href="#40083874">prev</a><span>|</span><a href="#40083952">next</a><span>|</span><label class="collapse" for="c-40084082">[-]</label><label class="expand" for="c-40084082">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and a calling convention should be designed for the long term<p>...isn&#x27;t the article just about Rust code calling Rust code? That&#x27;s a much more flexible situation than calling into operating system functions or into other languages. For calling within the same language a stable ABI is by for not as important as on the &#x27;ecosystem boundaries&#x27;, and might actually be harmful (see the related drama in the C++ world).</div><br/></div></div></div></div><div id="40083952" class="c"><input type="checkbox" id="c-40083952" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40083439">parent</a><span>|</span><a href="#40083668">prev</a><span>|</span><a href="#40083635">next</a><span>|</span><label class="collapse" for="c-40083952">[-]</label><label class="expand" for="c-40083952">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Also whether passing in registers is faster or not also depends on the function body. It doesn&#x27;t make much sense if the first thing the function does is to take the address of the parameter and passes it to some opaque function. Then it needs to be spilled onto the stack anyway.<p>It would be interesting to see calling convention optimizations based on function body. I think that would be safe for static functions in C, as long as their address is not taken.</div><br/></div></div><div id="40083635" class="c"><input type="checkbox" id="c-40083635" checked=""/><div class="controls bullet"><span class="by">mkj</span><span>|</span><a href="#40083439">parent</a><span>|</span><a href="#40083952">prev</a><span>|</span><a href="#40083667">next</a><span>|</span><label class="collapse" for="c-40083635">[-]</label><label class="expand" for="c-40083635">[3 more]</label></div><br/><div class="children"><div class="content">And remember that performance can include binary size, not just runtime speed. Current Rust seems to suffer in that regard for small platforms, calling convention could possibly help there wrt Result returns.</div><br/><div id="40084370" class="c"><input type="checkbox" id="c-40084370" checked=""/><div class="controls bullet"><span class="by">fleventynine</span><span>|</span><a href="#40083439">root</a><span>|</span><a href="#40083635">parent</a><span>|</span><a href="#40083667">next</a><span>|</span><label class="collapse" for="c-40084370">[-]</label><label class="expand" for="c-40084370">[2 more]</label></div><br/><div class="children"><div class="content">The current calling convention is terrible for small platforms, especially when using Result&lt;&gt; in return position. For large enums, the compiler should put the discriminant in a register and the large variants on the stack. As is, you pay a significant code size penalty for idiomatic rust error handling.</div><br/><div id="40084591" class="c"><input type="checkbox" id="c-40084591" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#40083439">root</a><span>|</span><a href="#40084370">parent</a><span>|</span><a href="#40083667">next</a><span>|</span><label class="collapse" for="c-40084591">[-]</label><label class="expand" for="c-40084591">[1 more]</label></div><br/><div class="children"><div class="content">There were proposals for optimizing this kind of stuff for C++ in particular for error handling, like:<p><a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2019&#x2F;p0709r4.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2019&#x2F;p07...</a><p>&gt; Throwing such values behaves as-if the function returned union{R;E;}+bool where on success the function returns the normal return value R and on error the function returns the error value type E, both in the same return channel including using the same registers. The discriminant can use an unused CPU flag or a register</div><br/></div></div></div></div></div></div><div id="40083667" class="c"><input type="checkbox" id="c-40083667" checked=""/><div class="controls bullet"><span class="by">workingjubilee</span><span>|</span><a href="#40083439">parent</a><span>|</span><a href="#40083635">prev</a><span>|</span><a href="#40082189">next</a><span>|</span><label class="collapse" for="c-40083667">[-]</label><label class="expand" for="c-40083667">[2 more]</label></div><br/><div class="children"><div class="content">Your experience is not perfectly transferable. JITs have it easy on this because they&#x27;ve already gathered a wealth of information about the actually-executing-on CPU by the time they generate a single line of assembly. Calls appear on the hot path more often in purely statically compiled code because things like the runtime architectural feature set are not known, so you often reach inlining barriers precisely in the code that you would <i>most</i> like to optimize.</div><br/><div id="40084492" class="c"><input type="checkbox" id="c-40084492" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40083439">root</a><span>|</span><a href="#40083667">parent</a><span>|</span><a href="#40082189">next</a><span>|</span><label class="collapse" for="c-40084492">[-]</label><label class="expand" for="c-40084492">[1 more]</label></div><br/><div class="children"><div class="content">The people who write JITs also write a bunch of C++ that gets statically compiled.</div><br/></div></div></div></div></div></div><div id="40082189" class="c"><input type="checkbox" id="c-40082189" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40083439">prev</a><span>|</span><a href="#40084273">next</a><span>|</span><label class="collapse" for="c-40082189">[-]</label><label class="expand" for="c-40082189">[15 more]</label></div><br/><div class="children"><div class="content">Reasonable sketch. This is missing the caller&#x2F;called save distinction and makes the usual error of assigning a subset of the input registers to output.<p>It&#x27;s optimistic about debuggers understanding non-C-like calling conventions which I&#x27;d expect to be an abject failure, regardless of what dwarf might be able to encode.<p>Changing ABI with optimization setting interacts really badly with separate compilation.<p>Shuffling arguments around in bin packing fashion does work but introduces a lot of complexity in the compiler, not sure it&#x27;s worth it relative to left to right first fit. It also makes it difficult for the developer to predict where arguments will end up.<p>The general plan of having different calling conventions for addresses that escape than for those that don&#x27;t is sound. Peeling off a prologue that does the impedance matching works well.<p>Rust probably should be willing to have a different calling convention to C, though I&#x27;m not sure it should be a hardcoded one that every function uses. Seems an obvious thing to embed in the type system to me and allowing developer control over calling convention removes one of the performance advantages of assembly.</div><br/><div id="40082307" class="c"><input type="checkbox" id="c-40082307" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40082189">parent</a><span>|</span><a href="#40083724">next</a><span>|</span><label class="collapse" for="c-40082307">[-]</label><label class="expand" for="c-40082307">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This is missing the caller&#x2F;called save distinction and makes the usual error of assigning a subset of the input registers to output.<p>Out of curiosity, what&#x27;s so problematic about using some input registers as output registers? On the caller&#x27;s side, you&#x27;d want to vacate the output registers between any two function calls regardless. And it occurs pretty widely in syscall conventions, to my binary-golfing detriment.<p>Is it for the ease of the callee, so that it can set up the output values while keeping the input values in place? That would suggest trying to avoid overlap (by placing the output registers at the end of the input sequence), but I don&#x27;t see how it would totally contraindicate any overlap.</div><br/><div id="40082354" class="c"><input type="checkbox" id="c-40082354" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40082307">parent</a><span>|</span><a href="#40083724">next</a><span>|</span><label class="collapse" for="c-40082354">[-]</label><label class="expand" for="c-40082354">[4 more]</label></div><br/><div class="children"><div class="content">You should use all the input registers as output registers, unless your arch is doing some sliding window thing. The x64 proposal linked uses six to pass arguments in and three to return results. So returning six integers means three in registers, three on the stack, with three registers that were free to use containing nothing in particular.</div><br/><div id="40082375" class="c"><input type="checkbox" id="c-40082375" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40082354">parent</a><span>|</span><a href="#40083724">next</a><span>|</span><label class="collapse" for="c-40082375">[-]</label><label class="expand" for="c-40082375">[3 more]</label></div><br/><div class="children"><div class="content">The LLVM calling conventions for x86 only allow returning 3 integer registers, 4 vector registers, and 2 x87 floating point registers (er, stack slots technically because x87 is weird).</div><br/><div id="40084637" class="c"><input type="checkbox" id="c-40084637" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40082375">parent</a><span>|</span><a href="#40084319">next</a><span>|</span><label class="collapse" for="c-40084637">[-]</label><label class="expand" for="c-40084637">[1 more]</label></div><br/><div class="children"><div class="content">Sure. That would be an instance of the &quot;usual error&quot;. The argument registers are usually caller save, where any unused ones get treated as scratch in the callee, in which case making them all available for returning data as well is zero cost.<p>There&#x27;s no reason not to, other than C makes returning multiple things awkward and splitting a struct across multiple registers is slightly annoying for the compiler.</div><br/></div></div><div id="40084319" class="c"><input type="checkbox" id="c-40084319" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40082375">parent</a><span>|</span><a href="#40084637">prev</a><span>|</span><a href="#40083724">next</a><span>|</span><label class="collapse" for="c-40084319">[-]</label><label class="expand" for="c-40084319">[1 more]</label></div><br/><div class="children"><div class="content">Limiting a newly designed Rust ABI to whatever LLVM happens to support at the moment seems unnecessarily limiting. Yeah, you&#x27;d need to write some C++ to implement it, but that&#x27;s not the end of the world, especially compared to getting stuck with arbitrary limits in your ABI for the next decade or two.</div><br/></div></div></div></div></div></div></div></div><div id="40083724" class="c"><input type="checkbox" id="c-40083724" checked=""/><div class="controls bullet"><span class="by">workingjubilee</span><span>|</span><a href="#40082189">parent</a><span>|</span><a href="#40082307">prev</a><span>|</span><a href="#40082302">next</a><span>|</span><label class="collapse" for="c-40083724">[-]</label><label class="expand" for="c-40083724">[1 more]</label></div><br/><div class="children"><div class="content">Allowing developer control over calling conventions is also simultaneous with disallowing optimization in the case that Function A calls Function B calls Function C calls Function D etc. but along the way one or more of those functions could have their arguments swapped around to a different convention to reduce overhead. What semantics would preserve such an optimization but allow control? Would it just be illusory?<p>And in practice assembly has the performance disadvantage of not being subject to most compiler optimizations, often including &quot;introspecting on its operation, determining it is fully redundant, and eliminating it entirely&quot;. It&#x27;s not the 1990s anymore.<p>In the cases where that kind of optimization is not even possible to consider, though, the only place I&#x27;d expect inline assembly to be decisively beaten is using profile-guided optimization. That&#x27;s the only way to extract more information than &quot;perfect awareness of how the application code works&quot;, which the app dev has and the compiler dev does not. The call overhead can be eliminated by simply writing more assembly until you&#x27;ve covered the relevant hot boundaries.</div><br/></div></div><div id="40082302" class="c"><input type="checkbox" id="c-40082302" checked=""/><div class="controls bullet"><span class="by">khuey</span><span>|</span><a href="#40082189">parent</a><span>|</span><a href="#40083724">prev</a><span>|</span><a href="#40083056">next</a><span>|</span><label class="collapse" for="c-40082302">[-]</label><label class="expand" for="c-40082302">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s optimistic about debuggers understanding non-C-like calling conventions which I&#x27;d expect to be an abject failure, regardless of what dwarf might be able to encode.<p>DWARF doesn&#x27;t encode bespoke calling conventions at all today.</div><br/></div></div><div id="40083056" class="c"><input type="checkbox" id="c-40083056" checked=""/><div class="controls bullet"><span class="by">t0b1</span><span>|</span><a href="#40082189">parent</a><span>|</span><a href="#40082302">prev</a><span>|</span><a href="#40082348">next</a><span>|</span><label class="collapse" for="c-40083056">[-]</label><label class="expand" for="c-40083056">[3 more]</label></div><br/><div class="children"><div class="content">The bin packing will probably make it slower though, especially in the bool case since it will create dependency chains.
For bools on x64, I don‘t think there‘s a better way than first having to get them in a register, shift them and then OR them into the result. The simple way creates a dependency chain of length 64 (which should also incur a 64 cycle penalty) but you might be able to do 6 (more like 12 realistically) cycles.
But then again, where do these 64 bools come from? There aren‘t that many registers so you will have to reload them from the stack. 
Maybe the rust ABI already packs bools in structs this tightly so it‘s work that has to be done anyway but I don‘t know too much about it.<p>And then the caller will have to unpack everything again.
It might be easier to just teach the compiler to spill values into the result space on the stack (in cases the IR doesn‘t already store the result after the computation) which will likely also perform better.</div><br/><div id="40083178" class="c"><input type="checkbox" id="c-40083178" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40083056">parent</a><span>|</span><a href="#40082348">next</a><span>|</span><label class="collapse" for="c-40083178">[-]</label><label class="expand" for="c-40083178">[2 more]</label></div><br/><div class="children"><div class="content">Unpacking bools is cheap - to move any bit into a flag is just a single &#x27;test&#x27; instruction, which is as good as it gets if you have multiple bools (other than passing each in a separate flag, which is quite undesirable).<p>Doing the packing in a tree fashion to reduce latency is trivial, and store→load latency isn&#x27;t free either depending on the microarchitecture (and at the counts where log2(n) latency becomes significant you&#x27;ll be at IPC limit anyway). Packing vs store should end up at roughly the same instruction counts too - a store vs an &#x27;or&#x27;, and exact same amount of moving between flags ang GPRs.<p>Reaching 64 bools might be a bit crazy, but 4-8 seems reasonably attainable from each of many arguments being an Option&lt;T&gt;, where the packing would reduce needed register&#x2F;stack slot count by ~2.<p>Where possible it would of course make sense to pass values in separate registers instead of in one, but when the alternative is spilling to stack, packing is still worthy of consideration.</div><br/><div id="40083268" class="c"><input type="checkbox" id="c-40083268" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40083178">parent</a><span>|</span><a href="#40082348">next</a><span>|</span><label class="collapse" for="c-40083268">[-]</label><label class="expand" for="c-40083268">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Reaching 64 bools might be a bit crazy, but 4-8 seems reasonably attainable from each of many arguments being an Option&lt;T&gt;, where the packing would reduce needed register&#x2F;stack slot count by ~2<p>I don&#x27;t have a strong sense of how much more common owned `Option` types are than references, but it&#x27;s worth noting that if `T` is a reference, `Option&lt;T&gt;` will just use a pointer and treat the null value as `None` under the hood to avoid needing any tag. There are probably other types where this is done as well (maybe `NonZero` integer types?)</div><br/></div></div></div></div></div></div><div id="40082348" class="c"><input type="checkbox" id="c-40082348" checked=""/><div class="controls bullet"><span class="by">rayiner</span><span>|</span><a href="#40082189">parent</a><span>|</span><a href="#40083056">prev</a><span>|</span><a href="#40084273">next</a><span>|</span><label class="collapse" for="c-40082348">[-]</label><label class="expand" for="c-40082348">[4 more]</label></div><br/><div class="children"><div class="content">Also, most modern processors will easily forward the store to the subsequent read and has a bunch of tricks for tracking the stack state. So much does putting things in registers help anyway?</div><br/><div id="40082819" class="c"><input type="checkbox" id="c-40082819" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40082348">parent</a><span>|</span><a href="#40083634">next</a><span>|</span><label class="collapse" for="c-40082819">[-]</label><label class="expand" for="c-40082819">[2 more]</label></div><br/><div class="children"><div class="content">More broadly: processor design has been optimised around C style antics for a long time, trying to optimise the code produced away from that could well inhibit processor tricks in such a way that the result is _slower_ than if you stuck with the &quot;looks terrible but is expected &amp; optimised&quot; status quo</div><br/><div id="40083323" class="c"><input type="checkbox" id="c-40083323" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40082819">parent</a><span>|</span><a href="#40083634">next</a><span>|</span><label class="collapse" for="c-40083323">[-]</label><label class="expand" for="c-40083323">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of Fortran compilers recognising the naive three-nested-loops matrix multiplication and optimising it to something sensible.</div><br/></div></div></div></div><div id="40083634" class="c"><input type="checkbox" id="c-40083634" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#40082189">root</a><span>|</span><a href="#40082348">parent</a><span>|</span><a href="#40082819">prev</a><span>|</span><a href="#40084273">next</a><span>|</span><label class="collapse" for="c-40083634">[-]</label><label class="expand" for="c-40083634">[1 more]</label></div><br/><div class="children"><div class="content">Forwarding isn&#x27;t unlimited, though, as I understand it. The CPU has limited-size queues and buffers through which reordering, forwarding, etc. can happen. So I wouldn&#x27;t be surprised if using registers well takes pressure off of that machinery and ensures that it works as you expect for the data that <i>isn&#x27;t</i> in registers.<p>(Looked around randomly to find example data for this) <a href="https:&#x2F;&#x2F;chipsandcheese.com&#x2F;2022&#x2F;11&#x2F;08&#x2F;amds-zen-4-part-2-memory-subsystem-and-conclusion&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chipsandcheese.com&#x2F;2022&#x2F;11&#x2F;08&#x2F;amds-zen-4-part-2-memo...</a> claims that Zen 4&#x27;s store queue only holds 64 entries, for example, and a 512-bit register store eats up two. I can imagine how an algorithm could fill that queue up by juggling enough data.</div><br/></div></div></div></div></div></div><div id="40084273" class="c"><input type="checkbox" id="c-40084273" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#40082189">prev</a><span>|</span><a href="#40082084">next</a><span>|</span><label class="collapse" for="c-40084273">[-]</label><label class="expand" for="c-40084273">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Debuggers<p>Simply throw it in as a Cargo.toml flag and sidestep the worry. Yes, you do sometimes have to debug release code - but there you can use the not-quite-perfect debugging that the author mentions.<p>Also, why aren&#x27;t we size-sorting fields already? That seems like an easy optimization, and can be turned off with a repr.</div><br/></div></div><div id="40082084" class="c"><input type="checkbox" id="c-40082084" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#40084273">prev</a><span>|</span><a href="#40081795">next</a><span>|</span><label class="collapse" for="c-40082084">[-]</label><label class="expand" for="c-40082084">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If a non-polymorphic, non-inline function may have its address taken (as a function pointer), either because it is exported out of the crate or the crate takes a function pointer to it, generate a shim that uses -Zcallconv=legacy and immediately tail-calls the real implementation. This is necessary to preserve function pointer equality.<p>If the legacy shim tail calls the Rust-calling-convention function, won&#x27;t that prevent it from fixing any return value differences in the calling convention?</div><br/><div id="40082102" class="c"><input type="checkbox" id="c-40082102" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40082084">parent</a><span>|</span><a href="#40081795">next</a><span>|</span><label class="collapse" for="c-40082102">[-]</label><label class="expand" for="c-40082102">[1 more]</label></div><br/><div class="children"><div class="content">Yes. People tend to forget about the return half of the calling convention though so it&#x27;s an understandable typographical error.</div><br/></div></div></div></div><div id="40081795" class="c"><input type="checkbox" id="c-40081795" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#40082084">prev</a><span>|</span><a href="#40082931">next</a><span>|</span><label class="collapse" for="c-40081795">[-]</label><label class="expand" for="c-40081795">[3 more]</label></div><br/><div class="children"><div class="content">In contrast: &quot;How Swift Achieved Dynamic Linking Where Rust Couldn&#x27;t &quot; (2019) [1]<p>On the one hand I&#x27;m disappointed that Rust still doesn&#x27;t have a calling convention for Rust-level semantics. On the other hand the above article demonstrates the tremendous amount of work that&#x27;s required to get there. Apple was deeply motivated to build this as a requirement to make Swift a viable system language that applications could rely on, but Rust does not have that kind of backing.<p>[1] <a href="https:&#x2F;&#x2F;faultlore.com&#x2F;blah&#x2F;swift-abi&#x2F;" rel="nofollow">https:&#x2F;&#x2F;faultlore.com&#x2F;blah&#x2F;swift-abi&#x2F;</a><p>HN discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21488415">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21488415</a></div><br/><div id="40081986" class="c"><input type="checkbox" id="c-40081986" checked=""/><div class="controls bullet"><span class="by">fl0ki</span><span>|</span><a href="#40081795">parent</a><span>|</span><a href="#40082931">next</a><span>|</span><label class="collapse" for="c-40081986">[-]</label><label class="expand" for="c-40081986">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only fair to point out that Swift&#x27;s approach has runtime costs. It would be good to have more supported options for this tradeoff in Rust, including but not limited to <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3470">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3470</a></div><br/><div id="40082076" class="c"><input type="checkbox" id="c-40082076" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#40081795">root</a><span>|</span><a href="#40081986">parent</a><span>|</span><a href="#40082931">next</a><span>|</span><label class="collapse" for="c-40082076">[-]</label><label class="expand" for="c-40082076">[1 more]</label></div><br/><div class="children"><div class="content">Notably these runtime costs only occur if you’re calling into another library. For calls within a given swift library, you don’t incur the runtime costs: size checks are elided (since size is known), calls can be inlined, generics are monomorphized… the costs only happen when you’re calling into code that the compiler can’t see.</div><br/></div></div></div></div></div></div><div id="40082931" class="c"><input type="checkbox" id="c-40082931" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#40081795">prev</a><span>|</span><a href="#40082014">next</a><span>|</span><label class="collapse" for="c-40082931">[-]</label><label class="expand" for="c-40082931">[4 more]</label></div><br/><div class="children"><div class="content">I just spent a bunch of time on inspect element trying to figure out how the section headings are set at an angle and (at least with Safari tools), I’m stumped. So how did he do this?</div><br/><div id="40082959" class="c"><input type="checkbox" id="c-40082959" checked=""/><div class="controls bullet"><span class="by">caperfee</span><span>|</span><a href="#40082931">parent</a><span>|</span><a href="#40083107">next</a><span>|</span><label class="collapse" for="c-40082959">[-]</label><label class="expand" for="c-40082959">[1 more]</label></div><br/><div class="children"><div class="content">The style is on the `.post-title` element: `transform: skewY(-2deg) translate(-1rem, -0.4rem);`</div><br/></div></div><div id="40083107" class="c"><input type="checkbox" id="c-40083107" checked=""/><div class="controls bullet"><span class="by">skgough</span><span>|</span><a href="#40082931">parent</a><span>|</span><a href="#40082959">prev</a><span>|</span><a href="#40082977">next</a><span>|</span><label class="collapse" for="c-40083107">[-]</label><label class="expand" for="c-40083107">[1 more]</label></div><br/><div class="children"><div class="content">related, I thought the minimap was using the CSS element() function [0], but it turns out it&#x27;s actually just a copy of the article shrunk down real small.<p>[0] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;element" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;element</a></div><br/></div></div><div id="40082977" class="c"><input type="checkbox" id="c-40082977" checked=""/><div class="controls bullet"><span class="by">aaron_seattle2</span><span>|</span><a href="#40082931">parent</a><span>|</span><a href="#40083107">prev</a><span>|</span><a href="#40082014">next</a><span>|</span><label class="collapse" for="c-40082977">[-]</label><label class="expand" for="c-40082977">[1 more]</label></div><br/><div class="children"><div class="content">h1,
h2,
h3,
h4,
h5,
h6 {
  transform:skewY(-2deg) translate(-1rem,0rem);
  transform-origin:top;
  font-style:italic;
  text-decoration-line:underline;
  text-decoration-color:goldenrod;
  text-underline-offset:4%;
  text-decoration-thickness:.25ex
}</div><br/></div></div></div></div><div id="40082014" class="c"><input type="checkbox" id="c-40082014" checked=""/><div class="controls bullet"><span class="by">yogorenapan</span><span>|</span><a href="#40082931">prev</a><span>|</span><a href="#40083759">next</a><span>|</span><label class="collapse" for="c-40082014">[-]</label><label class="expand" for="c-40082014">[12 more]</label></div><br/><div class="children"><div class="content">Tangentially related: Is it currently possible to have interop between Go and Rust? I remember seeing someone achieving it with Zig in the middle but can’t for the sake of me find it. Have some legacy Rust code (what??) that I’m hoping to slowly port to Go piece by piece</div><br/><div id="40082364" class="c"><input type="checkbox" id="c-40082364" checked=""/><div class="controls bullet"><span class="by">100k</span><span>|</span><a href="#40082014">parent</a><span>|</span><a href="#40082075">next</a><span>|</span><label class="collapse" for="c-40082364">[-]</label><label class="expand" for="c-40082364">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you can use CGO to call Rust functions using extern &quot;C&quot; FFI. I gave a talk about how we use it for GitHub code search at RustConf 2023 (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KYdlqhb267c" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KYdlqhb267c</a>) and afterwards I talked to some other folks (like 1Password) who are doing similar things.<p>It&#x27;s not a lot of fun because moving types across the C interop boundary is tedious, but it is possible and allows code reuse.</div><br/></div></div><div id="40082075" class="c"><input type="checkbox" id="c-40082075" checked=""/><div class="controls bullet"><span class="by">apendleton</span><span>|</span><a href="#40082014">parent</a><span>|</span><a href="#40082364">prev</a><span>|</span><a href="#40082332">next</a><span>|</span><label class="collapse" for="c-40082075">[-]</label><label class="expand" for="c-40082075">[1 more]</label></div><br/><div class="children"><div class="content">If you want to call from Go into Rust, you can declare any Rust function as `extern &quot;C&quot;` and then call it the same way you would call C from Go. Not sure about going the other way.</div><br/></div></div><div id="40082332" class="c"><input type="checkbox" id="c-40082332" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40082014">parent</a><span>|</span><a href="#40082075">prev</a><span>|</span><a href="#40082769">next</a><span>|</span><label class="collapse" for="c-40082332">[-]</label><label class="expand" for="c-40082332">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s usually unwise to mix managed and unmanaged memory since the managed code needs to be able to own the memory its freeing and moving whereas the unmanaged code needs to reason about when memory is freed or moved. cgo (and other variants) let you mix FFI calls into unmanaged memory from managed code in Go, but you pay a penalty for it.<p>In language implementations where GC isn&#x27;t shared by the different languages calling each other you&#x27;re always going to have this problem. Mixing managed&#x2F;unmanaged code is both an old idea and actively researched.<p>It&#x27;s almost always a terrible idea to call into managed code from unmanaged code unless you&#x27;re working directly with an embedded runtime that&#x27;s been designed for it. And when you do, there&#x27;s usually a serialization layer in between.</div><br/><div id="40082603" class="c"><input type="checkbox" id="c-40082603" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40082014">root</a><span>|</span><a href="#40082332">parent</a><span>|</span><a href="#40082769">next</a><span>|</span><label class="collapse" for="c-40082603">[-]</label><label class="expand" for="c-40082603">[6 more]</label></div><br/><div class="children"><div class="content">Mixing managed and unmanaged code being an issue is simply not true in programming in general.<p>It <i>may</i> be an issue in Go or Java, but it just isn&#x27;t in C# or Swift.<p>Calling `write` in C# on Unix is as easy as the following snippet and has almost no overhead:<p><pre><code>    var text = &quot;Hello, World!\n&quot;u8;
    Interop.Write(1, text, text.Length);

    static unsafe partial class Interop
    {
        [LibraryImport(&quot;libc&quot;, EntryPoint = &quot;write&quot;)]
        public static partial void Write(
            nint fd, ReadOnlySpan&lt;byte&gt; buffer, nint length);
    }
</code></pre>
In addition, unmanaged-&gt;managed calls are also rarely an issue, both via function pointers and plain C exports if you build a binary with NativeAOT:<p><pre><code>    public static class Exports
    {
        [UnmanagedCallersOnly(EntryPoint = &quot;sum&quot;)]
        public static nint Sum(nint a, nint b) =&gt; a + b;
    }
</code></pre>
It is indeed true that more complex scenarios may require some form of bespoke embedding&#x2F;hosting of the runtime, but that is more of a peculiarity of Go and Java, not an actual technical limitation.</div><br/><div id="40082637" class="c"><input type="checkbox" id="c-40082637" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40082014">root</a><span>|</span><a href="#40082603">parent</a><span>|</span><a href="#40083200">next</a><span>|</span><label class="collapse" for="c-40082637">[-]</label><label class="expand" for="c-40082637">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the direction being talked about here. Try calling the C# method from C or C++ or Rust.<p>(I somewhat recently did try setting up mono to be able to do this... it wasn&#x27;t fun.)</div><br/><div id="40082675" class="c"><input type="checkbox" id="c-40082675" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40082014">root</a><span>|</span><a href="#40082637">parent</a><span>|</span><a href="#40083200">next</a><span>|</span><label class="collapse" for="c-40082675">[-]</label><label class="expand" for="c-40082675">[3 more]</label></div><br/><div class="children"><div class="content">What you may have been looking for is these:<p>- <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;deploying&#x2F;native-aot&#x2F;interop#native-exports" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;deploying&#x2F;nati...</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;samples&#x2F;blob&#x2F;main&#x2F;core&#x2F;nativeaot&#x2F;NativeLibrary&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;samples&#x2F;blob&#x2F;main&#x2F;core&#x2F;nativeaot&#x2F;N...</a><p>With that said, Mono has been a staple choice for embedding in game-script style scenarios, in particular, because of the ability to directly call its methods inside (provided the caller honors the calling convention correctly), but it has been slowly becoming more of a liability as you are missing out on <i>a lot</i> of performance by not hosting CoreCLR instead.<p>For .dll&#x2F;.so&#x2F;.dylib&#x27;s, it is easier and often better to just build a native library with naot instead (the links above, you <i>can</i> also produce statically linkable binaries but it might have issues on e.g. macOS which has...not the most reliable linker that likes to take breaking changes).<p>This type of library works in almost every scenario a library implemented in C&#x2F;C++&#x2F;Rust with C exports does. For example, here someone implemented a hello-world demonstration of using C# to write an OBS plugin: <a href="https:&#x2F;&#x2F;sharovarskyi.com&#x2F;blog&#x2F;posts&#x2F;dotnet-obs-plugin-with-nativeaot&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sharovarskyi.com&#x2F;blog&#x2F;posts&#x2F;dotnet-obs-plugin-with-n...</a><p>Using the exports boils down to just this <a href="https:&#x2F;&#x2F;github.com&#x2F;kostya9&#x2F;DotnetObsPluginWithNativeAOT&#x2F;blob&#x2F;main&#x2F;ObsPlugin.cs">https:&#x2F;&#x2F;github.com&#x2F;kostya9&#x2F;DotnetObsPluginWithNativeAOT&#x2F;blob...</a> and specifying correct build flags.</div><br/><div id="40083314" class="c"><input type="checkbox" id="c-40083314" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40082014">root</a><span>|</span><a href="#40082675">parent</a><span>|</span><a href="#40083200">next</a><span>|</span><label class="collapse" for="c-40083314">[-]</label><label class="expand" for="c-40083314">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t been looking for those because I don&#x27;t work with .NET. Regardless, what you&#x27;re linking still needs callers and callees to agree on calling convention and special binding annotations across FFI boundaries which isn&#x27;t particularly interesting from the perspective of language implementation like the promises of Graal or WASM + GC + component model.</div><br/><div id="40083496" class="c"><input type="checkbox" id="c-40083496" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40082014">root</a><span>|</span><a href="#40083314">parent</a><span>|</span><a href="#40083200">next</a><span>|</span><label class="collapse" for="c-40083496">[-]</label><label class="expand" for="c-40083496">[1 more]</label></div><br/><div class="children"><div class="content">There is no free lunch. WASM just means another lowest common denominator abstraction for FFI. I&#x27;m also looking forward to WASM getting actually good so .NET could <i>properly</i> target it (because shipping WASM-compiled GC is really, really painful, it works acceptably today, but could be better). Current WasmGC spec is pretty much unusable by any language that has non-primitive GC implementation.<p>Just please don&#x27;t run WASM on the server, we&#x27;re already getting diminishing generational performance gains in hardware, no need to reduce them further.<p>The exports in the examples follow C ABI with respective OS&#x2F;ISA-specific calling convention.</div><br/></div></div></div></div></div></div></div></div><div id="40083200" class="c"><input type="checkbox" id="c-40083200" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40082014">root</a><span>|</span><a href="#40082603">parent</a><span>|</span><a href="#40082637">prev</a><span>|</span><a href="#40082769">next</a><span>|</span><label class="collapse" for="c-40083200">[-]</label><label class="expand" for="c-40083200">[1 more]</label></div><br/><div class="children"><div class="content">There are more managed langauges than Go, Java, and C#. Swift (and Objective C with ARC) are a bit different in that they don&#x27;t use mark and sweep&#x2F;generational GCs for automatic memory management so it&#x27;s significantly less of an issue. Compare with Lua, Python, JS, etc where there&#x27;s a serialization boundary between the two.<p>But I stand by what I said. It&#x27;s generally unwise to mix the two, particularly calling unmanaged code from managed code.<p>I wouldn&#x27;t say it&#x27;s &quot;not a problem&quot; because there are very few environments where you don&#x27;t pay some cost for mixing and matching between managed&#x2F;unmanaged code, and the environments designed around it are built from first principles to support it, like .NET. More interesting to me are Graal and WASM (once GC support lands) which should make it much easier to deal with.</div><br/></div></div></div></div></div></div><div id="40082769" class="c"><input type="checkbox" id="c-40082769" checked=""/><div class="controls bullet"><span class="by">mrits</span><span>|</span><a href="#40082014">parent</a><span>|</span><a href="#40082332">prev</a><span>|</span><a href="#40082576">next</a><span>|</span><label class="collapse" for="c-40082769">[-]</label><label class="expand" for="c-40082769">[1 more]</label></div><br/><div class="children"><div class="content">I have to use Rust and Swift quite a bit. I basically just landed on sending a byte array of serialized protobufs back and forth with cookie cutter function calls. If this is your full time job I can see how you might think that is lame, but I really got tired of coming back to the code every few weeks and not remembering how to do anything.</div><br/></div></div><div id="40082576" class="c"><input type="checkbox" id="c-40082576" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40082014">parent</a><span>|</span><a href="#40082769">prev</a><span>|</span><a href="#40083759">next</a><span>|</span><label class="collapse" for="c-40082576">[-]</label><label class="expand" for="c-40082576">[1 more]</label></div><br/><div class="children"><div class="content">You have to <i>go</i> through C bindings, but FFI is very far from being Go&#x27;s strongest suit (if we don&#x27;t count Cgo), so if that&#x27;s what interests you, it might be better to explore a different language.</div><br/></div></div></div></div><div id="40083759" class="c"><input type="checkbox" id="c-40083759" checked=""/><div class="controls bullet"><span class="by">vrotaru</span><span>|</span><a href="#40082014">prev</a><span>|</span><a href="#40082209">next</a><span>|</span><label class="collapse" for="c-40083759">[-]</label><label class="expand" for="c-40083759">[4 more]</label></div><br/><div class="children"><div class="content">There was an interesting aproach to this, in an experimental language some time ago<p><pre><code>   fn f1 (x, y) #-&gt; &#x2F;&#x2F; Use C calling conventions

   fn f2 (x, y) -&gt; &#x2F;&#x2F; use fast calling conventions
</code></pre>
The first one was mostly for interacting with C code, and the compiler knew how to 
call each function.</div><br/><div id="40084356" class="c"><input type="checkbox" id="c-40084356" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40083759">parent</a><span>|</span><a href="#40083877">next</a><span>|</span><label class="collapse" for="c-40084356">[-]</label><label class="expand" for="c-40084356">[1 more]</label></div><br/><div class="children"><div class="content">Delphi, and I&#x27;m sure others, have had[1] this for ages:<p><i>When you declare a procedure or function, you can specify a calling convention using one of the directives register, pascal, cdecl, stdcall, safecall, and winapi.</i><p>As in your example, cdecl is for calling C code, while stdcall&#x2F;winapi on Windows for calling Windows APIs.<p>[1]: <a href="https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Sydney&#x2F;en&#x2F;Procedures_and_Functions_(Delphi)" rel="nofollow">https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Sydney&#x2F;en&#x2F;Procedur...</a></div><br/></div></div><div id="40083877" class="c"><input type="checkbox" id="c-40083877" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#40083759">parent</a><span>|</span><a href="#40084356">prev</a><span>|</span><a href="#40082209">next</a><span>|</span><label class="collapse" for="c-40083877">[-]</label><label class="expand" for="c-40083877">[2 more]</label></div><br/><div class="children"><div class="content">Is it similar to Zig’s callconv keyword?</div><br/><div id="40084067" class="c"><input type="checkbox" id="c-40084067" checked=""/><div class="controls bullet"><span class="by">vrotaru</span><span>|</span><a href="#40083759">root</a><span>|</span><a href="#40083877">parent</a><span>|</span><a href="#40082209">next</a><span>|</span><label class="collapse" for="c-40084067">[-]</label><label class="expand" for="c-40084067">[1 more]</label></div><br/><div class="children"><div class="content">Guess so. Unfamiliar with Zig. The point is that not a &quot;all or nothing&quot; strategy for a compilation unit.<p>Debugger writers may not be happy, but maybe lldb supports all conventions supported by llvm.</div><br/></div></div></div></div></div></div><div id="40082209" class="c"><input type="checkbox" id="c-40082209" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40083759">prev</a><span>|</span><a href="#40082304">next</a><span>|</span><label class="collapse" for="c-40082209">[-]</label><label class="expand" for="c-40082209">[3 more]</label></div><br/><div class="children"><div class="content">Given that the current Rust compiler does aggressive inlining and then optimizes, is this worth the trouble? If the function being called is tiny, it should be inlined. If it&#x27;s big, you&#x27;re probably going to spend some time in it and the call overhead is minor.</div><br/><div id="40082421" class="c"><input type="checkbox" id="c-40082421" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#40082209">parent</a><span>|</span><a href="#40082352">next</a><span>|</span><label class="collapse" for="c-40082421">[-]</label><label class="expand" for="c-40082421">[1 more]</label></div><br/><div class="children"><div class="content">Runtime functions (eg dyn Trait) can’t be inlined for one, so this would help there. But also if you can make calls cheaper then you don’t have to be so aggressive with inlining, which can help with code size and compile times.</div><br/></div></div><div id="40082352" class="c"><input type="checkbox" id="c-40082352" checked=""/><div class="controls bullet"><span class="by">jonstewart</span><span>|</span><a href="#40082209">parent</a><span>|</span><a href="#40082421">prev</a><span>|</span><a href="#40082304">next</a><span>|</span><label class="collapse" for="c-40082352">[-]</label><label class="expand" for="c-40082352">[1 more]</label></div><br/><div class="children"><div class="content">Probably? A complex function that’s not a good fit for inlining will probably access memory a few times and those accesses are likely to be the bottlenecks for the function. Passing on the stack squeezes that bottleneck tighter — more cache pressure, load&#x2F;stores, etc. If Rust can pass arguments optimally in a decent ratio of function calls, not only is it avoiding the several clocks of L1 access, it’s hopefully letting the CPU get to those essential memory bottlenecks faster. There are probably several percentage points of win here…? But I am drinking wine and not doing the math, so…</div><br/></div></div></div></div><div id="40082304" class="c"><input type="checkbox" id="c-40082304" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#40082209">prev</a><span>|</span><a href="#40082119">next</a><span>|</span><label class="collapse" for="c-40082304">[-]</label><label class="expand" for="c-40082304">[3 more]</label></div><br/><div class="children"><div class="content">The C calling convention kind of sucks. True, can&#x27;t change the C calling convention, but that doesn&#x27;t make it any less unfortunate.<p>We should use every available caller-saved register for arguments and return values, but in the traditional SysV ABI, we use only one register (sometimes two) for return values. If you return a struct Point3D { long x, y, z }, you spill the stack even though we could damned well put Point3D in rax, rdi, and rsi.<p>There are other tricks other systems use. For example, if I recall correctly, in SBCL, functions set the carry flag on exit if they&#x27;re returning multiple values. Wouldn&#x27;t it be nice if we used the carry flag in indicate, e.g. whether a Result contains an error.</div><br/><div id="40084162" class="c"><input type="checkbox" id="c-40084162" checked=""/><div class="controls bullet"><span class="by">fch42</span><span>|</span><a href="#40082304">parent</a><span>|</span><a href="#40082119">next</a><span>|</span><label class="collapse" for="c-40084162">[-]</label><label class="expand" for="c-40084162">[2 more]</label></div><br/><div class="children"><div class="content">&quot;sucks&quot; is a strong word but with respect to return values, you&#x27;re right. The C calling conventions, everywhere really, support what C supports - returning one argument. Well, not even that (struct returns ... nope).
Kind of &quot;who&#x27;d have thought&quot; in C I guess. And then there&#x27;s the C++ argument &quot;just make it inline then&quot;.<p>On the other hand, memory spills happen. For SPARC, for example, the gracious register space (windows) ended up with lots of unused regs in simple functions and a cache-busting huge stack size footprint, definitely so if you ever spilled the register ring. Even with all the mov in x86 (and there is always lots of it, at least in compiled C code) to rearrange data to &quot;where it needed to be&quot;, it often ended up faster.<p>When you only look at the callee code (code generated for a given function signature), it&#x27;s tempting to say &quot;oh it&#x27;ll definitely be fastest if this arg is here and that return there&quot;. You don&#x27;t know the callers though. There&#x27;s no guarantee the argument marshalling will end up &quot;pass through&quot; or the returns are &quot;hot&quot; consumed. Say, a struct Point { x: i32, y: i32, z: i32 } as arg&#x2F;return; if the caller does something like mystruct.deepinside.point[i] = func(mystruct.deepinside.point[i]) in a loop then moving it in&#x2F;out of regs may be overhead or even prevent vectorisation. But the callee cannot know. Unless... the compiler can see both and inline (back to the C++ excuse). Yes, for function call chaining javascript&#x2F;rust style it might be nice&#x2F;useful &quot;in principle&quot;.  But in practice only if the compiler has enough caller&#x2F;callee insight to keep the hot working set &quot;passthrough&quot; (no spills).<p>The lowest hanging fruit on calling is probably to remove the &quot;functions return one primitive thing&quot; that&#x27;s ingrained in the C ABIs almost everywhere. For the rest ? A lot of benchmarking and code generation statistics. I&#x27;d love to see more of that. Even if it&#x27;s dry stuff.</div><br/><div id="40084563" class="c"><input type="checkbox" id="c-40084563" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40082304">root</a><span>|</span><a href="#40084162">parent</a><span>|</span><a href="#40082119">next</a><span>|</span><label class="collapse" for="c-40084563">[-]</label><label class="expand" for="c-40084563">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Well, not even that (struct returns ... nope).<p>C compilers actually pack small struct return values into registers:<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;3vqs1v88W" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;3vqs1v88W</a><p>It&#x27;s just limited that on x86-64, GCC and Clang use up to two registers while MSVC only uses one.<p>Also, AFAIK there is no such thing as a &quot;C calling convention&quot;, there are many different calling conventions that are defined by the runtime environment (usually the combination of CPU architecture and operating system). C compilers just must adhere to those calling conventions, but that doesn&#x27;t make it a &quot;C calling convention&quot;. A Rust or Swift compiler must adhere to those &quot;runtime ABIs&quot; too if they want to call into operating system functions.<p>IMHO the whole topic is overblown though, for &#x27;high frequency functions&#x27; the compiler should inline the function  body anyway. And for situations where that&#x27;s not possible (e.g. calling into DLLs), the DLL should not expose such &#x27;high frequency functions&#x27; in the first place.</div><br/></div></div></div></div></div></div><div id="40082119" class="c"><input type="checkbox" id="c-40082119" checked=""/><div class="controls bullet"><span class="by">sheepscreek</span><span>|</span><a href="#40082304">prev</a><span>|</span><a href="#40082369">next</a><span>|</span><label class="collapse" for="c-40082119">[-]</label><label class="expand" for="c-40082119">[4 more]</label></div><br/><div class="children"><div class="content">Very interesting but pretty quickly went over my head. I have a question that is slightly related to SIMD and LLVM.<p>Can someone explain simply where does MLIR fit into all of this? Does it standardize more advanced operations across programming languages - such as linear algebra and convolutions?<p>Side-note: Mojo has been designed by the creator of LLVM and MLIR to prioritize and optimize vector hardware use, as a language that is similar to Python (and somewhat syntax compatible).</div><br/><div id="40082714" class="c"><input type="checkbox" id="c-40082714" checked=""/><div class="controls bullet"><span class="by">fpgamlirfanboy</span><span>|</span><a href="#40082119">parent</a><span>|</span><a href="#40082429">next</a><span>|</span><label class="collapse" for="c-40082714">[-]</label><label class="expand" for="c-40082714">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Side-note: Mojo has been designed by the creator of LLVM and MLIR to prioritize and optimize vector hardware use, as a language that is similar to Python (and somewhat syntax compatible).<p>Are people getting paid to repeat this ad nauseum?</div><br/></div></div><div id="40082429" class="c"><input type="checkbox" id="c-40082429" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40082119">parent</a><span>|</span><a href="#40082714">prev</a><span>|</span><a href="#40082900">next</a><span>|</span><label class="collapse" for="c-40082429">[-]</label><label class="expand" for="c-40082429">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can someone explain simply where does MLIR fit into all of this?<p>It doesn&#x27;t.<p>MLIR is a design for a family of intermediate languages (called &#x27;dialects&#x27;) that allow you to progressively lower high-level languages into low-level code.</div><br/></div></div><div id="40082900" class="c"><input type="checkbox" id="c-40082900" checked=""/><div class="controls bullet"><span class="by">jadodev</span><span>|</span><a href="#40082119">parent</a><span>|</span><a href="#40082429">prev</a><span>|</span><a href="#40082369">next</a><span>|</span><label class="collapse" for="c-40082900">[-]</label><label class="expand" for="c-40082900">[1 more]</label></div><br/><div class="children"><div class="content">MLIR includes a &quot;linalg&quot; dialect that contains common operations.
You can see those here: <a href="https:&#x2F;&#x2F;mlir.llvm.org&#x2F;docs&#x2F;Dialects&#x2F;Linalg&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mlir.llvm.org&#x2F;docs&#x2F;Dialects&#x2F;Linalg&#x2F;</a><p>This post is rather unrelated. The linalg dialect can be lowered to LLVM IR, SPIR-V, or you could write your own pass to lower it to e.g. your custom chip.</div><br/></div></div></div></div><div id="40082369" class="c"><input type="checkbox" id="c-40082369" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#40082119">prev</a><span>|</span><a href="#40081888">next</a><span>|</span><label class="collapse" for="c-40082369">[-]</label><label class="expand" for="c-40082369">[2 more]</label></div><br/><div class="children"><div class="content">interesting website - the title text is slanted.<p>Sometimes people who dig deep into the technical details end up being creative with those details.</div><br/><div id="40084521" class="c"><input type="checkbox" id="c-40084521" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#40082369">parent</a><span>|</span><a href="#40081888">next</a><span>|</span><label class="collapse" for="c-40084521">[-]</label><label class="expand" for="c-40084521">[1 more]</label></div><br/><div class="children"><div class="content">True, creative, but usually in a quality degrading way like here (slanted text is harder to read, also due to the underline being too thick, and takes more space) or like with those poorly legible bg&#x2F;fg color combinations</div><br/></div></div></div></div><div id="40081888" class="c"><input type="checkbox" id="c-40081888" checked=""/><div class="controls bullet"><span class="by">retox</span><span>|</span><a href="#40082369">prev</a><span>|</span><label class="collapse" for="c-40081888">[-]</label><label class="expand" for="c-40081888">[3 more]</label></div><br/><div class="children"><div class="content">Meta: the minimap is quite interesting, it&#x27;s &#x27;just&#x27; a smaller copy of all the content.</div><br/><div id="40082214" class="c"><input type="checkbox" id="c-40082214" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#40081888">parent</a><span>|</span><a href="#40081938">next</a><span>|</span><label class="collapse" for="c-40082214">[-]</label><label class="expand" for="c-40082214">[1 more]</label></div><br/><div class="children"><div class="content">Clever! Should probably have aria-hidden though.</div><br/></div></div></div></div></div></div></div></div></div></body></html>