<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692003665494" as="style"/><link rel="stylesheet" href="styles.css?v=1692003665494"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://blog.ezyang.com/2013/05/the-ast-typing-problem/">The AST Typing Problem</a> <span class="domain">(<a href="http://blog.ezyang.com">blog.ezyang.com</a>)</span></div><div class="subtext"><span>smasher164</span> | <span>18 comments</span></div><br/><div><div id="37117446" class="c"><input type="checkbox" id="c-37117446" checked=""/><div class="controls bullet"><span class="by">nemo1618</span><span>|</span><a href="#37118782">next</a><span>|</span><label class="collapse" for="c-37117446">[-]</label><label class="expand" for="c-37117446">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll contribute another solution, used in the Go compiler: build a big map from AST node -&gt; typeinfo. This approach is very flexible (e.g. you can add more maps later without changing the AST struct), but, like Nullable, it&#x27;s not correct-by-construction -- and worse, you &quot;just have to know&quot; that this map exists and how to access&#x2F;update it. Seems to be working ok for them, though!</div><br/><div id="37117913" class="c"><input type="checkbox" id="c-37117913" checked=""/><div class="controls bullet"><span class="by">mbid</span><span>|</span><a href="#37117446">parent</a><span>|</span><a href="#37117657">next</a><span>|</span><label class="collapse" for="c-37117913">[-]</label><label class="expand" for="c-37117913">[1 more]</label></div><br/><div class="children"><div class="content">This is also the natural solution when you&#x27;re using Datalog to compute with the AST: Datalog operates on relations&#x2F;tables, so associating types to AST nodes can be accomplished using a table with two columns: One for the ID representing an AST node, and one for the type associated to the AST node. I&#x27;ve recently written about this approach in the series starting here: <a href="https:&#x2F;&#x2F;www.mbid.me&#x2F;posts&#x2F;type-checking-with-eqlog-parsing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.mbid.me&#x2F;posts&#x2F;type-checking-with-eqlog-parsing&#x2F;</a></div><br/></div></div><div id="37117657" class="c"><input type="checkbox" id="c-37117657" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#37117446">parent</a><span>|</span><a href="#37117913">prev</a><span>|</span><a href="#37118782">next</a><span>|</span><label class="collapse" for="c-37117657">[-]</label><label class="expand" for="c-37117657">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this is what MyPy does internally too<p>You just have a big dict of types, which are keyed by the AST node<p>It seemed a bit weird to me, but certainly works.  I guess I usually use dicts that are keyed by value and not by address of the instance</div><br/></div></div></div></div><div id="37118782" class="c"><input type="checkbox" id="c-37118782" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#37117446">prev</a><span>|</span><a href="#37118661">next</a><span>|</span><label class="collapse" for="c-37118782">[-]</label><label class="expand" for="c-37118782">[1 more]</label></div><br/><div class="children"><div class="content">Am I the only one lost at the very first paragraph? It shows something that looks like a grammar, but I can&#x27;t understand what &quot;Num&quot;, &quot;Int&quot;, &quot;If&quot; are... Are they literals? terms? types? And what does &quot;data&quot; mean?<p>So it&#x27;s not a grammar. &quot;data Exp&quot; might describe each internal node of the AST, where the first word is the node&#x27;s variety and the following words describe the children nodes. But what does &quot;data Type&quot; mean, then?</div><br/></div></div><div id="37118661" class="c"><input type="checkbox" id="c-37118661" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#37118782">prev</a><span>|</span><a href="#37116766">next</a><span>|</span><label class="collapse" for="c-37118661">[-]</label><label class="expand" for="c-37118661">[1 more]</label></div><br/><div class="children"><div class="content">Restrictive static typing creates a lot of problems that wouldn&#x27;t exist... if you didn&#x27;t use restrictive static typing. Maybe because my language designs are toys I use in my projects (for now), but everything is nested heterogenous sparse sequences, so it&#x27;s a list, but also a map, and I can attach any associative keys to it without breaking the pattern match on the rest of it, and I&#x27;m never out of place to add information should I need it.<p>I think the problem is we write compilers like it&#x27;s the 90s, and it&#x27;s not the 90s.<p>But also it&#x27;s full of data structure solutions to this even for static types: give nodes a simple autoincrementing id (if your language has no object maps), then put any extra information in a sidecar if you want. Think relations and joins. It&#x27;s easy.</div><br/></div></div><div id="37116766" class="c"><input type="checkbox" id="c-37116766" checked=""/><div class="controls bullet"><span class="by">chrisaycock</span><span>|</span><a href="#37118661">prev</a><span>|</span><a href="#37118642">next</a><span>|</span><label class="collapse" for="c-37116766">[-]</label><label class="expand" for="c-37116766">[2 more]</label></div><br/><div class="children"><div class="content">The beauty of separate IRs is that each can represent a separate stage of compilation. For example, Rust goes from abstract syntax tree (AST) to high-level IR (HIR) to typed high-level IR (THIR):<p><a href="https:&#x2F;&#x2F;rustc-dev-guide.rust-lang.org&#x2F;part-3-intro.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;rustc-dev-guide.rust-lang.org&#x2F;part-3-intro.html</a><p>Additionally, Many language implementations use a mid-level IR to sit above LLVM: Rust has MIR, Swift has SIL, Julia has an SSA-form IR, etc. The article mentions GHC&#x27;s Core, which is also an example of an IR that comes after type checking but before LLVM.</div><br/><div id="37118258" class="c"><input type="checkbox" id="c-37118258" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37116766">parent</a><span>|</span><a href="#37118642">next</a><span>|</span><label class="collapse" for="c-37118258">[-]</label><label class="expand" for="c-37118258">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;rustc-dev-guide.rust-lang.org&#x2F;rustc-driver-interacting-with-the-ast.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;rustc-dev-guide.rust-lang.org&#x2F;rustc-driver-interacti...</a><p>Love seeing that even Rust compiler devs are forced to be verbose and dont bother breaking some of this code out into functions, because specifying the constraints is too much work</div><br/></div></div></div></div><div id="37118642" class="c"><input type="checkbox" id="c-37118642" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37116766">prev</a><span>|</span><a href="#37117056">next</a><span>|</span><label class="collapse" for="c-37118642">[-]</label><label class="expand" for="c-37118642">[1 more]</label></div><br/><div class="children"><div class="content">What about separate IR that incrementally add to the base IR without replacing it? They will have the same shape so they can be encoded efficiently I think, and can be traversed in parallel.</div><br/></div></div><div id="37117056" class="c"><input type="checkbox" id="c-37117056" checked=""/><div class="controls bullet"><span class="by">jeswin</span><span>|</span><a href="#37118642">prev</a><span>|</span><a href="#37116121">next</a><span>|</span><label class="collapse" for="c-37117056">[-]</label><label class="expand" for="c-37117056">[4 more]</label></div><br/><div class="children"><div class="content">&gt; How does one go about adding “extra information” (e.g. types) to an AST?<p>Can someone who&#x27;s more familiar with compilers ELI10 the problem? A layman like me is left wondering - Why not add (say) a type field to each node?</div><br/><div id="37117099" class="c"><input type="checkbox" id="c-37117099" checked=""/><div class="controls bullet"><span class="by">jez</span><span>|</span><a href="#37117056">parent</a><span>|</span><a href="#37117295">next</a><span>|</span><label class="collapse" for="c-37117099">[-]</label><label class="expand" for="c-37117099">[1 more]</label></div><br/><div class="children"><div class="content">Your solution is the second alternative proposed in the article: the “Nullable field” solution.<p>It’s an example of a classic tradeoff between enforcing correctness and invariants “by construction” vs at runtime. Since the field is nullable, the AST is not necessarily correct by construction, as the programmer may have forgotten to include a type when required. The correctness of compilers using such representations involves either checked or unchecked assertions where the type field is used to ensure that it is set appropriately.<p>The article continues with various strategies to avoid needing to defer this correctness checking to the runtime by providing various statically-checked alternatives.</div><br/></div></div><div id="37117295" class="c"><input type="checkbox" id="c-37117295" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#37117056">parent</a><span>|</span><a href="#37117099">prev</a><span>|</span><a href="#37117072">next</a><span>|</span><label class="collapse" for="c-37117295">[-]</label><label class="expand" for="c-37117295">[1 more]</label></div><br/><div class="children"><div class="content">Because there is a lot of additional stuff you may want to add to a node at the later stages of translation, not only the type field: you may also want a usage count, reference from usages, reference to the defining function, global&#x2F;local value numbers, &quot;can be an immediate in an instruction&#x2F;requires load from constant pool&quot; flags, the allocated register, the allocated spill slot, etc. Surely you don&#x27;t put <i>all</i> of that backend-specific (or even single-pass specific) stuff into a supposedly generic AST node that your frontend produces?</div><br/></div></div><div id="37117072" class="c"><input type="checkbox" id="c-37117072" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#37117056">parent</a><span>|</span><a href="#37117295">prev</a><span>|</span><a href="#37116121">next</a><span>|</span><label class="collapse" for="c-37117072">[-]</label><label class="expand" for="c-37117072">[1 more]</label></div><br/><div class="children"><div class="content">This is not possible since this information is not available at all times. For example imagine C++ where a variable is typed with auto. Just after parsing you have an AST which doesn&#x27;t yet include the real static type the variable has.</div><br/></div></div></div></div><div id="37116121" class="c"><input type="checkbox" id="c-37116121" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#37117056">prev</a><span>|</span><a href="#37118197">next</a><span>|</span><label class="collapse" for="c-37116121">[-]</label><label class="expand" for="c-37116121">[4 more]</label></div><br/><div class="children"><div class="content">An even easier way is to add type parameter to every AST that resolves to either a type or null. It can be relatively easily implemented using type families in Haskell. And it doesn&#x27;t suffer the tying the knot shenanigans. The main advantage is that you can still reason about your AST in a straight forward generic manner. In fact this is not only useful for typing. Any kind of metadata that needs to be added can be described in this way.<p>In a compiler I build you had a simple ASTState type parameter for every node in the AST which indicated what is available in the AST. But you could traverse over the entire AST generically as long as you did not depend on any of the additional information.<p>You can basically lift the implementation from this paper: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2016&#x2F;11&#x2F;trees-that-grow.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2016&#x2F;1...</a></div><br/><div id="37117153" class="c"><input type="checkbox" id="c-37117153" checked=""/><div class="controls bullet"><span class="by">jez</span><span>|</span><a href="#37116121">parent</a><span>|</span><a href="#37118197">next</a><span>|</span><label class="collapse" for="c-37117153">[-]</label><label class="expand" for="c-37117153">[3 more]</label></div><br/><div class="children"><div class="content">Am I correct in understanding that this means you can only have a list of typed ASTs, or a list of not-yet-typed ASTs, but not a list with a mix?<p>Obviously I understand that if this is the limitation, then there are ways to work around this, and it all depends on how annoying the workarounds are.<p>But I’m curious is there a trick that allows it. All the tricks I can think of involve boxing the the ASTs you’re about to store in the list (which then come with memory&#x2F;performance hits), and I’d love to be proven wrong.</div><br/><div id="37117551" class="c"><input type="checkbox" id="c-37117551" checked=""/><div class="controls bullet"><span class="by">jmgrosen</span><span>|</span><a href="#37116121">root</a><span>|</span><a href="#37117153">parent</a><span>|</span><a href="#37117980">next</a><span>|</span><label class="collapse" for="c-37117551">[-]</label><label class="expand" for="c-37117551">[1 more]</label></div><br/><div class="children"><div class="content">Use an existential type, usually called Some in Haskell: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;some-1.0.5&#x2F;docs&#x2F;Data-Some.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;some-1.0.5&#x2F;docs&#x2F;Data-Som...</a> The implementation of this type one has in their head (a GADT) adds a boxing overhead, but the actual implementation in this library uses a newtype.<p>That way if you have a type Expr a, you can have a list type [Some Expr].</div><br/></div></div><div id="37117980" class="c"><input type="checkbox" id="c-37117980" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#37116121">root</a><span>|</span><a href="#37117153">parent</a><span>|</span><a href="#37117551">prev</a><span>|</span><a href="#37118197">next</a><span>|</span><label class="collapse" for="c-37117980">[-]</label><label class="expand" for="c-37117980">[1 more]</label></div><br/><div class="children"><div class="content">You could make an intermediate step that&#x27;s only used during type checking which may have partial type information. Then after type checking you lock it down.<p>You can even have HLists but then you are also pretty far along the Ivory tower. I don&#x27;t think that&#x27;s worth it.</div><br/></div></div></div></div></div></div><div id="37118197" class="c"><input type="checkbox" id="c-37118197" checked=""/><div class="controls bullet"><span class="by">BSEdlMMldESB</span><span>|</span><a href="#37116121">prev</a><span>|</span><label class="collapse" for="c-37118197">[-]</label><label class="expand" for="c-37118197">[1 more]</label></div><br/><div class="children"><div class="content">2013!<p>what&#x27;s the difference between running a program (interpreting it), and compiling it?<p>where&#x27;s (and what&#x27;s) the line that distinguishes the program from the output of the program where both parts are just software?<p>--<p>the most interesting thing about turning machines is the universal turing machine because it actually invents&#x2F;defines&#x2F;showcases software as we understand it nowadays; this makes me reflect on how the busy beaber problem just misses out on this realization</div><br/></div></div></div></div></div></div></div></body></html>