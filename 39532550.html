<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709283672982" as="style"/><link rel="stylesheet" href="styles.css?v=1709283672982"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://williamjbowman.com/resources/geller2023-wasm-prechk-current-preprint.pdf">Indexed types for a statically safe WebAssembly [pdf]</a>Â <span class="domain">(<a href="https://williamjbowman.com">williamjbowman.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>4 comments</span></div><br/><div><div id="39557399" class="c"><input type="checkbox" id="c-39557399" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><label class="collapse" for="c-39557399">[-]</label><label class="expand" for="c-39557399">[3 more]</label></div><br/><div class="children"><div class="content">The paper waits until page 2 to mention that their scheme would not help standard WebAssembly implementations at all: those implementations already eliminate all bounds checks using a virtual memory trick, so reducing the number of required bounds checks makes no difference.<p>However, it would help implementations that can&#x27;t use the virtual memory trick, such as if they need to support a 64-bit WebAssembly address space, or run on a 32-bit host, or have a huge number of WebAssembly VMs in the same host process.<p>And if I understand their (extremely hard to read) graph correctly, the scheme reduces the bounds checking overhead in that case quite close to zero, which is pretty impressive.<p>On the other hand, any approach based on software bounds checking is ripe for speculative-execution attacks.  Maybe that doesn&#x27;t matter because in the browser it&#x27;s a lost cause already?</div><br/><div id="39557910" class="c"><input type="checkbox" id="c-39557910" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#39557399">parent</a><span>|</span><a href="#39558192">next</a><span>|</span><label class="collapse" for="c-39557910">[-]</label><label class="expand" for="c-39557910">[1 more]</label></div><br/><div class="children"><div class="content">That sounds harsh: page 2 is opening phrase of the 3rd paragraph of the introduction.</div><br/></div></div><div id="39558192" class="c"><input type="checkbox" id="c-39558192" checked=""/><div class="controls bullet"><span class="by">cmrx64</span><span>|</span><a href="#39557399">parent</a><span>|</span><a href="#39557910">prev</a><span>|</span><label class="collapse" for="c-39558192">[-]</label><label class="expand" for="c-39558192">[1 more]</label></div><br/><div class="children"><div class="content">this sort of static verifiability is important for applications like smartcard programs though, where the runtime environment cannot afford dynamic MMU.<p>additionally, this lets you inline verifiable code into your protection domain instead of forcing it into its own module somewhere else.</div><br/></div></div></div></div></div></div></div></div></div></body></html>