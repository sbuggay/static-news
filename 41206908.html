<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723280461035" as="style"/><link rel="stylesheet" href="styles.css?v=1723280461035"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.screenshotbot.io/2024/08/10/building-a-highly-available-web-service-without-a-database/">Building a highly-available web service without a database</a> <span class="domain">(<a href="https://blog.screenshotbot.io">blog.screenshotbot.io</a>)</span></div><div class="subtext"><span>tdrhq</span> | <span>62 comments</span></div><br/><div><div id="41207172" class="c"><input type="checkbox" id="c-41207172" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41208201">next</a><span>|</span><label class="collapse" for="c-41207172">[-]</label><label class="expand" for="c-41207172">[13 more]</label></div><br/><div class="children"><div class="content">Seems weird to start with “not talking about using something like SQLite where your data is still serialized”, then end up with a home grown transaction log that requires serialization and needs to be replicated, which is how databases are replicated anyway.<p>If your load fits entirely on one server, then just run the database on that damn server and forget about “special architectures to reduce round-trips to your database”. If your data fits entirely in RAM, then use a ramdisk for the database if you want, and replicate it to permanent storage with standard tools. Now that’s actually simple.</div><br/><div id="41207629" class="c"><input type="checkbox" id="c-41207629" checked=""/><div class="controls bullet"><span class="by">bingo-bongo</span><span>|</span><a href="#41207172">parent</a><span>|</span><a href="#41207389">next</a><span>|</span><label class="collapse" for="c-41207629">[-]</label><label class="expand" for="c-41207629">[2 more]</label></div><br/><div class="children"><div class="content">You don’t even need a ram disk imho, databases already cache everything in memory and only writes reach the disk.<p>Just try and cold-start your database and run a fairly large select twice.</div><br/><div id="41208014" class="c"><input type="checkbox" id="c-41208014" checked=""/><div class="controls bullet"><span class="by">piker</span><span>|</span><a href="#41207172">root</a><span>|</span><a href="#41207629">parent</a><span>|</span><a href="#41207389">next</a><span>|</span><label class="collapse" for="c-41208014">[-]</label><label class="expand" for="c-41208014">[1 more]</label></div><br/><div class="children"><div class="content">Also the OS will cache a lot of the reads even if your database isn’t sophisticated enough or tuned correctly. Still could be a fun exercise, as with all things on here.</div><br/></div></div></div></div><div id="41207389" class="c"><input type="checkbox" id="c-41207389" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41207172">parent</a><span>|</span><a href="#41207629">prev</a><span>|</span><a href="#41207638">next</a><span>|</span><label class="collapse" for="c-41207389">[-]</label><label class="expand" for="c-41207389">[4 more]</label></div><br/><div class="children"><div class="content">I do feel like this largely summarizes as &quot;we built our own sqlite + raft replication&quot;, yeah. But without sqlite&#x27;s battle-tested reliability or the ability to efficiently offload memory back to disk.<p>So, basically, <a href="https:&#x2F;&#x2F;litestream.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;litestream.io&#x2F;</a> . But perhaps faster switching thanks to an explicit Raft setup? I&#x27;m not a litestream user so I&#x27;m not sure about the subtleties, but it sounds awfully similar.<p>That overly-simplified summary aside, I quite like the idea and I think the post does a pretty good job of selling the concept. For a lot of systems it&#x27;ll scale more than well enough to handle most or all of your business even if you become abnormally successful, and the performance will be absurdly good compared to almost anything else.</div><br/><div id="41207637" class="c"><input type="checkbox" id="c-41207637" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#41207172">root</a><span>|</span><a href="#41207389">parent</a><span>|</span><a href="#41207934">next</a><span>|</span><label class="collapse" for="c-41207637">[-]</label><label class="expand" for="c-41207637">[1 more]</label></div><br/><div class="children"><div class="content">Rqlite would be a better comparison.  It is actually SQLite + raft<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rqlite&#x2F;rqlite">https:&#x2F;&#x2F;github.com&#x2F;rqlite&#x2F;rqlite</a></div><br/></div></div><div id="41207934" class="c"><input type="checkbox" id="c-41207934" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41207172">root</a><span>|</span><a href="#41207389">parent</a><span>|</span><a href="#41207637">prev</a><span>|</span><a href="#41208133">next</a><span>|</span><label class="collapse" for="c-41207934">[-]</label><label class="expand" for="c-41207934">[1 more]</label></div><br/><div class="children"><div class="content">They basically only save on serialization &amp; deserialization at query time, which I would consider an infinitesimal saving in the vast majority of use cases. They claim to be able to build some magical index that&#x27;s not possible with existing disk-based databases (I didn&#x27;t read the linked blog post). They lose access to a nice query language and entire ecosystems of tools and domain knowledge.<p>I fail to see how this little bit of saving justifies all the complexity for run-of-the-mill web services that fit on one or a few servers as described in the article. The context isn&#x27;t large scale services where 1ms&#x2F;request saving translates to $$$, and the proposal doesn&#x27;t (vertically) scale anyway.</div><br/></div></div><div id="41208133" class="c"><input type="checkbox" id="c-41208133" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#41207172">root</a><span>|</span><a href="#41207389">parent</a><span>|</span><a href="#41207934">prev</a><span>|</span><a href="#41207638">next</a><span>|</span><label class="collapse" for="c-41208133">[-]</label><label class="expand" for="c-41208133">[1 more]</label></div><br/><div class="children"><div class="content">SQlite doesn&#x27;t do Raft. There isn&#x27;t any simple way to do replicated SQlite. (In fact, writing your own database is probably the simplest way currently, if SQlite+Raft is actually what you want.)</div><br/></div></div></div></div><div id="41207689" class="c"><input type="checkbox" id="c-41207689" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41207172">parent</a><span>|</span><a href="#41207638">prev</a><span>|</span><a href="#41207400">next</a><span>|</span><label class="collapse" for="c-41207689">[-]</label><label class="expand" for="c-41207689">[2 more]</label></div><br/><div class="children"><div class="content">Trading systems bluntly keep everything in RAM, in preallocated structures. It all depends on the kind of tradeoffs you&#x27;re willing to make.</div><br/><div id="41208017" class="c"><input type="checkbox" id="c-41208017" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#41207172">root</a><span>|</span><a href="#41207689">parent</a><span>|</span><a href="#41207400">next</a><span>|</span><label class="collapse" for="c-41208017">[-]</label><label class="expand" for="c-41208017">[1 more]</label></div><br/><div class="children"><div class="content">I used to work on a telecom platform (think something that runs 4G services), where every node was just part of an in-memory database that replicated using 2PC and just did periodic snapshot to avoid losing data. Basically processes were colocated with their data in the DB.</div><br/></div></div></div></div><div id="41207400" class="c"><input type="checkbox" id="c-41207400" checked=""/><div class="controls bullet"><span class="by">robertclaus</span><span>|</span><a href="#41207172">parent</a><span>|</span><a href="#41207689">prev</a><span>|</span><a href="#41208201">next</a><span>|</span><label class="collapse" for="c-41207400">[-]</label><label class="expand" for="c-41207400">[3 more]</label></div><br/><div class="children"><div class="content">Agreed. Reinventing the WAL means reinventing (or ignoring) all the headaches that come with it. I got the impression it takes them a long time to recover from the logs, so they likely haven&#x27;t even gotten as far as log checkpointing.</div><br/><div id="41207646" class="c"><input type="checkbox" id="c-41207646" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41207172">root</a><span>|</span><a href="#41207400">parent</a><span>|</span><a href="#41207831">next</a><span>|</span><label class="collapse" for="c-41207646">[-]</label><label class="expand" for="c-41207646">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Agreed. Reinventing the WAL means reinventing (or ignoring) all the headaches that come with it.<p>But if the blogger learned SQLite, how would they have a topic to blog about?<p>Also, no benchmarks. It&#x27;s quite odd that an argument grounded on performance claims does not bother to put out any hard data comparing the output of this project. I&#x27;m talking about basic things like how does this contrived custom ad-hoc setup compare with vanilla, out-of-the-box SQLite deployment? Which one performs worse and by how much? How does the performance difference reflect in request times and infrastructure cost? Does it actually pay off to replace the dozen lines of code of on boarding SQLite with a custom, in-development, ad-hoc setup? I mean, I get the weekend personal project vibe of this blog post, but if this is supposed to be a production-minded project then step zero would have been a performance test on the default solution. Where is it?</div><br/></div></div><div id="41207831" class="c"><input type="checkbox" id="c-41207831" checked=""/><div class="controls bullet"><span class="by">bjornsing</span><span>|</span><a href="#41207172">root</a><span>|</span><a href="#41207400">parent</a><span>|</span><a href="#41207646">prev</a><span>|</span><a href="#41208201">next</a><span>|</span><label class="collapse" for="c-41207831">[-]</label><label class="expand" for="c-41207831">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I got the impression it takes them a long time to recover from the logs, so they likely haven&#x27;t even gotten as far as log checkpointing.<p>The OP starts out by talking about periodically dumping everything in RAM to disk. I’d say that’s your checkpointing.</div><br/></div></div></div></div></div></div><div id="41208201" class="c"><input type="checkbox" id="c-41208201" checked=""/><div class="controls bullet"><span class="by">leokennis</span><span>|</span><a href="#41207172">prev</a><span>|</span><a href="#41207175">next</a><span>|</span><label class="collapse" for="c-41208201">[-]</label><label class="expand" for="c-41208201">[1 more]</label></div><br/><div class="children"><div class="content">I’m not from “start up world” but in the end, few things give me more comfort and lack of surprises down the line than just having a relational database with built in redundancy&#x2F;transaction logs&#x2F;back up&#x2F;recovery. Sure there might always be edge cases (lack of money, regulations, specialist software offering) but in the vast majority of cases - just get a database.</div><br/></div></div><div id="41207175" class="c"><input type="checkbox" id="c-41207175" checked=""/><div class="controls bullet"><span class="by">theideaofcoffee</span><span>|</span><a href="#41208201">prev</a><span>|</span><a href="#41207040">next</a><span>|</span><label class="collapse" for="c-41207175">[-]</label><label class="expand" for="c-41207175">[2 more]</label></div><br/><div class="children"><div class="content">I get the desire to experiment with interesting things, but it seems like such a huge waste of time to avoid having to learn the most basic aspects of MySQL or postgres. You could &quot;just&quot; build on top of and be done with it, especially if you&#x27;re running in a public cloud provider. I don&#x27;t buy the increased RTT or troubles with concurrency issues, the latter having simple solutions by basic tuning, or breaking out your noisy customers. There&#x27;s another post on their blog mentioning the possibility of adding 10 million rows per day and the challenges of indexing that. That&#x27;s... literally nothing and I don&#x27;t think even 10x that justifies having to engineer a custom solution.<p>Worse is better until you absolutely need to be less worse, then you&#x27;ll know for sure. At that point you&#x27;ll know your pain points and can address them more wisely than building more up front.</div><br/><div id="41207680" class="c"><input type="checkbox" id="c-41207680" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41207175">parent</a><span>|</span><a href="#41207040">next</a><span>|</span><label class="collapse" for="c-41207680">[-]</label><label class="expand" for="c-41207680">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I get the desire to experiment with interesting things, but it seems like such a huge waste of time to avoid having to learn the most basic aspects of MySQL or postgres.<p>For server-based database engines you can still make an argument on shedding network calls. It&#x27;s dubious, but you can.<p>What&#x27;s baffling is that the blogger tries to justify not picking up SQLite claiming it might have features that they don&#x27;t need, which is absurd and does not justify anything.<p>The blog post reads like a desperate attempt to start with a poor solution to a fictitions problem and proceed to come up with far-fetched arguments hoping to reject the obvious solution.</div><br/></div></div></div></div><div id="41207040" class="c"><input type="checkbox" id="c-41207040" checked=""/><div class="controls bullet"><span class="by">nephy</span><span>|</span><a href="#41207175">prev</a><span>|</span><a href="#41208183">next</a><span>|</span><label class="collapse" for="c-41207040">[-]</label><label class="expand" for="c-41207040">[4 more]</label></div><br/><div class="children"><div class="content">We didn’t want to build something complicated, so we implemented our own raft consensus layer. Have you considered just using Redis?</div><br/><div id="41207050" class="c"><input type="checkbox" id="c-41207050" checked=""/><div class="controls bullet"><span class="by">tdrhq</span><span>|</span><a href="#41207040">parent</a><span>|</span><a href="#41208183">next</a><span>|</span><label class="collapse" for="c-41207050">[-]</label><label class="expand" for="c-41207050">[3 more]</label></div><br/><div class="children"><div class="content">Haha, I totally hear you. But but, we didn&#x27;t really build the raft consensus layer from scratch. We used an existing robust library for that: <a href="https:&#x2F;&#x2F;github.com&#x2F;baidu&#x2F;braft">https:&#x2F;&#x2F;github.com&#x2F;baidu&#x2F;braft</a></div><br/><div id="41207837" class="c"><input type="checkbox" id="c-41207837" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#41207040">root</a><span>|</span><a href="#41207050">parent</a><span>|</span><a href="#41207071">next</a><span>|</span><label class="collapse" for="c-41207837">[-]</label><label class="expand" for="c-41207837">[1 more]</label></div><br/><div class="children"><div class="content">You completely skipped the question though</div><br/></div></div></div></div></div></div><div id="41208183" class="c"><input type="checkbox" id="c-41208183" checked=""/><div class="controls bullet"><span class="by">antman</span><span>|</span><a href="#41207040">prev</a><span>|</span><a href="#41207104">next</a><span>|</span><label class="collapse" for="c-41208183">[-]</label><label class="expand" for="c-41208183">[1 more]</label></div><br/><div class="children"><div class="content">As a side question is there a python library for braft or a production grade raft library for python?</div><br/></div></div><div id="41207104" class="c"><input type="checkbox" id="c-41207104" checked=""/><div class="controls bullet"><span class="by">Zak</span><span>|</span><a href="#41208183">prev</a><span>|</span><a href="#41207117">next</a><span>|</span><label class="collapse" for="c-41207104">[-]</label><label class="expand" for="c-41207104">[7 more]</label></div><br/><div class="children"><div class="content">Decades ago, PG wrote that he didn&#x27;t use a database for Viaweb, and that it seemed odd for web apps to be frontends to databases when desktop apps were not[0]. HN also doesn&#x27;t use a database.<p>That&#x27;s no longer true, with modern desktop and mobile apps often using a database (usually SQLite) because relational data storage and queries turn out to be pretty useful in a wide range of applications.<p>[0] <a href="https:&#x2F;&#x2F;www.paulgraham.com&#x2F;vwfaq.html" rel="nofollow">https:&#x2F;&#x2F;www.paulgraham.com&#x2F;vwfaq.html</a></div><br/><div id="41207787" class="c"><input type="checkbox" id="c-41207787" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41207104">parent</a><span>|</span><a href="#41207550">next</a><span>|</span><label class="collapse" for="c-41207787">[-]</label><label class="expand" for="c-41207787">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Decades ago, PG wrote that he didn&#x27;t use a database for Viaweb, and that it seemed odd for web apps to be frontends to databases when desktop apps were not[0].<p>After reading the link, I don&#x27;t think that database means the same thing for everyone.<p>The vwfaq still mentions loading data from disk, and also mention &quot;start up a process to respond to an HTTP request.&quot; This suggests that by &quot;database&quot; they meant a separate server dedicated to persist data, and having to communicate with another server to fetch that data.<p>Obviously, this leaves SQLite out of this definition of database. Also, if you&#x27;re loading data from disk already, either you&#x27;re using a database or you&#x27;re implementing your own ad-hoc persistence layer. Would you still consider you&#x27;re using a database if you load data from SQLite at app start?<p>The problem with this sort of mental model is that it ignores the fact that the whole point of a database is to persist and fetch data in a way that is convenient to you without having to bother about low-level details. Storing data in a database does not mean running a postgres instance somewhere and fetching data over the web. If you store all your data in-memory and have a process that saves snapshots to disk using a log-structured data structure... Congratulations, you just developed your own database.</div><br/></div></div><div id="41207550" class="c"><input type="checkbox" id="c-41207550" checked=""/><div class="controls bullet"><span class="by">tdrhq</span><span>|</span><a href="#41207104">parent</a><span>|</span><a href="#41207787">prev</a><span>|</span><a href="#41207334">next</a><span>|</span><label class="collapse" for="c-41207550">[-]</label><label class="expand" for="c-41207550">[1 more]</label></div><br/><div class="children"><div class="content">I was certainly inspired by PG&#x27;s writing (after all we do use Common Lisp, and it&#x27;s hard to avoid PG in this space). But I don&#x27;t think they did things like transaction logs like how bknr.datastore does, which makes the development process a lot more seamless.</div><br/></div></div><div id="41207334" class="c"><input type="checkbox" id="c-41207334" checked=""/><div class="controls bullet"><span class="by">never_inline</span><span>|</span><a href="#41207104">parent</a><span>|</span><a href="#41207550">prev</a><span>|</span><a href="#41207393">next</a><span>|</span><label class="collapse" for="c-41207334">[-]</label><label class="expand" for="c-41207334">[1 more]</label></div><br/><div class="children"><div class="content">I think even SQLite itself wasn&#x27;t as ubiquitous (edit: it didn&#x27;t exist) when pg write viaweb. If SQLite wasn&#x27;t there and my options were basically key value stores, I could as well use filesystem in most cases.<p>Second, querying the RDBMS has been much simplified in past 20 years. We have all kind of ORMs and row mappers to reduce the boilerplate.<p>We also got advanced features like FTS which are useful for desktop and mobile apps.<p>Today it&#x27;s a good choice to use RDBMS for desktop apps.</div><br/></div></div><div id="41207393" class="c"><input type="checkbox" id="c-41207393" checked=""/><div class="controls bullet"><span class="by">endorphine</span><span>|</span><a href="#41207104">parent</a><span>|</span><a href="#41207334">prev</a><span>|</span><a href="#41207117">next</a><span>|</span><label class="collapse" for="c-41207393">[-]</label><label class="expand" for="c-41207393">[3 more]</label></div><br/><div class="children"><div class="content">HN does not use a database?! Can you expand on that? It&#x27;s very surprising to me.</div><br/><div id="41207603" class="c"><input type="checkbox" id="c-41207603" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#41207104">root</a><span>|</span><a href="#41207393">parent</a><span>|</span><a href="#41207117">next</a><span>|</span><label class="collapse" for="c-41207603">[-]</label><label class="expand" for="c-41207603">[2 more]</label></div><br/><div class="children"><div class="content">probably uses the filesystem as the backing store</div><br/><div id="41208105" class="c"><input type="checkbox" id="c-41208105" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#41207104">root</a><span>|</span><a href="#41207603">parent</a><span>|</span><a href="#41207117">next</a><span>|</span><label class="collapse" for="c-41208105">[-]</label><label class="expand" for="c-41208105">[1 more]</label></div><br/><div class="children"><div class="content">Filesystems these days are like dbs</div><br/></div></div></div></div></div></div></div></div><div id="41207117" class="c"><input type="checkbox" id="c-41207117" checked=""/><div class="controls bullet"><span class="by">Sn0wCoder</span><span>|</span><a href="#41207104">prev</a><span>|</span><a href="#41207444">next</a><span>|</span><label class="collapse" for="c-41207117">[-]</label><label class="expand" for="c-41207117">[3 more]</label></div><br/><div class="children"><div class="content">Not sure I would call that setup simple, but it is interesting.  I have honestly never heard of ‘Raft’ or the Raft Consensus Protocol or bknr.datastore, so always happy to learn something on a Friday night.</div><br/><div id="41207123" class="c"><input type="checkbox" id="c-41207123" checked=""/><div class="controls bullet"><span class="by">tdrhq</span><span>|</span><a href="#41207117">parent</a><span>|</span><a href="#41207411">next</a><span>|</span><label class="collapse" for="c-41207123">[-]</label><label class="expand" for="c-41207123">[1 more]</label></div><br/><div class="children"><div class="content">Author here.<p>I agree, the infrastructure required to make this happen eventually gets quite complicated. But the developer experience is what&#x27;s super simple. If somebody had to take all our infrastructure and just use it to build their next big app, they can get the simplicity without worrying about the internal plumbing.</div><br/></div></div><div id="41207411" class="c"><input type="checkbox" id="c-41207411" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#41207117">parent</a><span>|</span><a href="#41207123">prev</a><span>|</span><a href="#41207444">next</a><span>|</span><label class="collapse" for="c-41207411">[-]</label><label class="expand" for="c-41207411">[1 more]</label></div><br/><div class="children"><div class="content">Raft is fantastic and most modern systems with more than one node are built on Raft. It is actually proven to be equivalent to Paxos, but the semantics of it are closer to what you would prefer as a software writer and the implementation is much simpler.</div><br/></div></div></div></div><div id="41207444" class="c"><input type="checkbox" id="c-41207444" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#41207117">prev</a><span>|</span><a href="#41207143">next</a><span>|</span><label class="collapse" for="c-41207444">[-]</label><label class="expand" for="c-41207444">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine all the wonderful things you could build if you never had to serialize data into SQL queries.<p>This exists in sufficiently mature Actor model[0] implementations, such as Akka Event Sourcing[1], which also addresses:<p>&gt; But then comes the important part: how do you recover when your process crashes? It turns out that answer is easy, periodically just take a snapshot of everything in RAM.<p>Intrinsically and without having to create &quot;a new architecture for web development&quot;.  There are even open source efforts which explore the RAFT protocol using actors here[2] and here[3].<p>0 - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;History_of_the_Actor_model" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;History_of_the_Actor_model</a><p>1 - <a href="https:&#x2F;&#x2F;doc.akka.io&#x2F;docs&#x2F;akka&#x2F;current&#x2F;typed&#x2F;persistence.html" rel="nofollow">https:&#x2F;&#x2F;doc.akka.io&#x2F;docs&#x2F;akka&#x2F;current&#x2F;typed&#x2F;persistence.html</a><p>2 - <a href="https:&#x2F;&#x2F;github.com&#x2F;Michael-Dratch&#x2F;RAFT_Implementation">https:&#x2F;&#x2F;github.com&#x2F;Michael-Dratch&#x2F;RAFT_Implementation</a><p>3 - <a href="https:&#x2F;&#x2F;github.com&#x2F;invkrh&#x2F;akka-raft">https:&#x2F;&#x2F;github.com&#x2F;invkrh&#x2F;akka-raft</a></div><br/></div></div><div id="41207143" class="c"><input type="checkbox" id="c-41207143" checked=""/><div class="controls bullet"><span class="by">oconnore</span><span>|</span><a href="#41207444">prev</a><span>|</span><a href="#41207299">next</a><span>|</span><label class="collapse" for="c-41207143">[-]</label><label class="expand" for="c-41207143">[1 more]</label></div><br/><div class="children"><div class="content">My first thought was, “oh, I used to do this when I wrote Common Lisp, it’s funny someone rediscovered that technique in &lt;rust&#x2F;typescript&#x2F;java&#x2F;whatever&gt;”.<p>But no, just more lispers.</div><br/></div></div><div id="41207299" class="c"><input type="checkbox" id="c-41207299" checked=""/><div class="controls bullet"><span class="by">Tehdasi</span><span>|</span><a href="#41207143">prev</a><span>|</span><a href="#41207189">next</a><span>|</span><label class="collapse" for="c-41207299">[-]</label><label class="expand" for="c-41207299">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, but the problem with having in-memory objects rather than a db is you end up having to replicate alot of the features of a relational database to get a usable system. And adding all these extra features you want from those dbs end up making a simple solution not very simple at all.</div><br/><div id="41208187" class="c"><input type="checkbox" id="c-41208187" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#41207299">parent</a><span>|</span><a href="#41207189">next</a><span>|</span><label class="collapse" for="c-41208187">[-]</label><label class="expand" for="c-41208187">[1 more]</label></div><br/><div class="children"><div class="content">To some extent I think this is an &quot;if all you have is a hammer...&quot; situation. Relational DBs are often not a great fit for how contemporary software manages data in memory (hence the proliferation of ORMs, and adapter layers like graphql). I think it&#x27;s often easier to write out one&#x27;s relations in the data structures directly, rather than mapping them to queries and joins</div><br/></div></div></div></div><div id="41207189" class="c"><input type="checkbox" id="c-41207189" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41207299">prev</a><span>|</span><a href="#41207587">next</a><span>|</span><label class="collapse" for="c-41207189">[-]</label><label class="expand" for="c-41207189">[2 more]</label></div><br/><div class="children"><div class="content">This sounds a lot like Prevayler. <a href="https:&#x2F;&#x2F;prevayler.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;prevayler.org&#x2F;</a></div><br/><div id="41207218" class="c"><input type="checkbox" id="c-41207218" checked=""/><div class="controls bullet"><span class="by">tdrhq</span><span>|</span><a href="#41207189">parent</a><span>|</span><a href="#41207587">next</a><span>|</span><label class="collapse" for="c-41207218">[-]</label><label class="expand" for="c-41207218">[1 more]</label></div><br/><div class="children"><div class="content">[Author here] Indeed, bknr.datastore was inspired by Prevayler and similar libraries</div><br/></div></div></div></div><div id="41207587" class="c"><input type="checkbox" id="c-41207587" checked=""/><div class="controls bullet"><span class="by">nilirl</span><span>|</span><a href="#41207189">prev</a><span>|</span><a href="#41207159">next</a><span>|</span><label class="collapse" for="c-41207587">[-]</label><label class="expand" for="c-41207587">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m baffled at the arguments made in this article. This is supposed to be a simpler and faster way to build stateful applications?<p>The premises are weak and the claims absurd. The author uses overstatement of the difficulties of serialization just to make their weak claim stronger.</div><br/><div id="41207617" class="c"><input type="checkbox" id="c-41207617" checked=""/><div class="controls bullet"><span class="by">t0mas88</span><span>|</span><a href="#41207587">parent</a><span>|</span><a href="#41207960">next</a><span>|</span><label class="collapse" for="c-41207617">[-]</label><label class="expand" for="c-41207617">[1 more]</label></div><br/><div class="children"><div class="content">And then they implement serialization to write their transactions to a log and replicate them to the other nodes...</div><br/></div></div><div id="41207960" class="c"><input type="checkbox" id="c-41207960" checked=""/><div class="controls bullet"><span class="by">voidfunc</span><span>|</span><a href="#41207587">parent</a><span>|</span><a href="#41207617">prev</a><span>|</span><a href="#41207159">next</a><span>|</span><label class="collapse" for="c-41207960">[-]</label><label class="expand" for="c-41207960">[1 more]</label></div><br/><div class="children"><div class="content">Big vibes of &quot;We are very smart, see how smart we are?&quot; from the blog post.<p>These kind of people usually suck to work with. I&#x27;m glad they&#x27;ve found a startup to sink so I don&#x27;t have to deal with them.</div><br/></div></div></div></div><div id="41207159" class="c"><input type="checkbox" id="c-41207159" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#41207587">prev</a><span>|</span><a href="#41207462">next</a><span>|</span><label class="collapse" for="c-41207159">[-]</label><label class="expand" for="c-41207159">[3 more]</label></div><br/><div class="children"><div class="content">This is cool! I’m always excited by people trying simpler things, as a big fan of using Boring Technology.<p>But I have some bad news: you haven’t built a system without a database, you’ve just built your own database without transactions and weak durability properties.<p>&gt; Hold on, what if you’ve made changes since the last snapshot? And this is the clever bit: you ensure that every time you change parts of RAM, we write a transaction to disk.<p>This is actually not an easy thing to do. If your shutdowns are always clean SIGSTOPs, yes, you can reliably flush writes to disk. But if you get a SIGKILL at the wrong time, or don’t handle an io error correctly, you’re probably going to lose data. (Postgres’ 20-year fsync issue was one of these: <a href="https:&#x2F;&#x2F;archive.fosdem.org&#x2F;2019&#x2F;schedule&#x2F;event&#x2F;postgresql_fsync&#x2F;" rel="nofollow">https:&#x2F;&#x2F;archive.fosdem.org&#x2F;2019&#x2F;schedule&#x2F;event&#x2F;postgresql_fs...</a>)<p>The open secret in database land is that for all we talk about transactional guarantees and durability, the reality is that those properties only start to show up in the very, very, _very_ long tail of edge cases, many of which are easily remedied by some combination of humans getting paged and end users developing workarounds (eg double entry bookkeeping). This is why MySQL’s default isolation level can lose writes: there are usually enough safeguards in any given system that it doesn’t matter.<p>A lot of what you’re describing as “database issues” problem don’t sound to me like DB issues, so much as latency issues caused by not colocating your service with your DB. By hand-rolling a DB implementation using Raft, you’ve also colocated storage with your service.<p>&gt; Screenshotbot runs on their CI, so we get API requests 100s of times for every single commit and Pull Request.<p>I’m sorry, but I don’t think this was as persuasive as you meant it to be. This is the type of workload that, to be snarky about, I could run off my phone[0]<p>[0]: <a href="https:&#x2F;&#x2F;tailscale.com&#x2F;blog&#x2F;new-internet" rel="nofollow">https:&#x2F;&#x2F;tailscale.com&#x2F;blog&#x2F;new-internet</a></div><br/><div id="41207602" class="c"><input type="checkbox" id="c-41207602" checked=""/><div class="controls bullet"><span class="by">tdrhq</span><span>|</span><a href="#41207159">parent</a><span>|</span><a href="#41207462">next</a><span>|</span><label class="collapse" for="c-41207602">[-]</label><label class="expand" for="c-41207602">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is actually not an easy thing to do. If your shutdowns are always clean SIGSTOPs, yes, you can reliably flush writes to disk. But if you get a SIGKILL at the wrong time, or don’t handle an io error correctly, you’re probably going to lose data.<p>Thanks for the comment! This is handled correctly by Raft&#x2F;Braft. With Raft, before a transaction is considered committed it must be committed by a majority of nodes. So if the transaction log gets corrupted, it will restore and get the latest transaction logs from the other node.<p>&gt; I’m sorry, but I don’t think this was as persuasive as you meant it to be.<p>I wasn&#x27;t trying to be persuasive about this. :) I was trying to drive home the point that you don&#x27;t need a massively distributed system to make a useful startup. I think some founders go the opposite direction and try to build something that scales to a billion users before they even get their first user.</div><br/><div id="41208125" class="c"><input type="checkbox" id="c-41208125" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#41207159">root</a><span>|</span><a href="#41207602">parent</a><span>|</span><a href="#41207462">next</a><span>|</span><label class="collapse" for="c-41208125">[-]</label><label class="expand" for="c-41208125">[1 more]</label></div><br/><div class="children"><div class="content">Wait, so you’re blocking on a Raft round-trip to make forward progress? That’s the correct decision wrt durability, but…<p>I’m now completely lost as to why you believe this was a good idea over using something like MySQL&#x2F;Postgres&#x2F;Aurora. As I see it, you’ve added complexity in three different dimensions (novel DB API, novel infra&#x2F;maintenance, and novel oncall&#x2F;incident response) with minimal gain in availability and no gain in performance. What am I missing?<p>(FWIW, I worked on Bigtable&#x2F;Megastore&#x2F;Spanner&#x2F;Firestore in a previous job. I’m pretty familiar with what goes into consensus, although it’s been a few years since I’ve had to debug Paxos.)<p>&gt; I was trying to drive home the point that you don&#x27;t need a massively distributed system to make a useful startup. I think some founders go the opposite direction and try to build something that scales to a billion users before they even get their first user.<p>This reads to me as exactly the opposite: overengineering for a problem that you don’t have.<p>For exactly the reasons you describe, I would argue the burden of proof is on you to demonstrate why Redis, MySQL, Postgres, SQLite, and other comparable options are insufficient for your use case.<p>To offer you an example: let’s say your Big Customer decides “hey, let’s split our repo into N micro repos!” and they now want you to create N copies of their instance so they can split things up. As implemented, you’ll now need to implement a ton of custom logic for the necessary data transforms. With Postgres, there’s a really good chance you could do all of that by manipulating the backups with a few lines of SQL.</div><br/></div></div></div></div></div></div><div id="41207462" class="c"><input type="checkbox" id="c-41207462" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#41207159">prev</a><span>|</span><a href="#41207497">next</a><span>|</span><label class="collapse" for="c-41207462">[-]</label><label class="expand" for="c-41207462">[1 more]</label></div><br/><div class="children"><div class="content">When I start a new project, the data structure usually is a &quot;list of items with attributes&quot;. For example right now, I am writing a fitness app. The data consists of a list of exercises and each exercise has a title, a description, a video url and some other attributes.<p>I usually start by putting those items into YAML files in a &quot;data&quot; directory. Actually a custom YAML dialect without the quirks of the original. Each value is a string. No magic type conversions. Creating a new item is just &quot;vim crunches.yaml&quot; and putting the data in. Editing, deleting etc all is just wonderfully easy with this data structure.<p>Then when the project grows, I usually create a DB schema and move the items into MariaDB or SQLite.<p>This time, I think I will move the items (exercises) into a JSON column of an SQLite DB. All attributes of an item will be stored in a single JSON field. And then write a little DB explorer which lets me edit JSON fields as YAML. So I keep the convenience of editing human readable data.<p>Writing the DB explorer should be rather straight forward. A bit of ncurses to browse through tables, select one, browse through rows, insert and delete rows. And for editing a field, it will fire up Vim. And if the field is a JSON field, it converts it to YAML before it sends it to Vim and back to JSON when the user quits Vim.</div><br/></div></div><div id="41207497" class="c"><input type="checkbox" id="c-41207497" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#41207462">prev</a><span>|</span><a href="#41207176">next</a><span>|</span><label class="collapse" for="c-41207497">[-]</label><label class="expand" for="c-41207497">[1 more]</label></div><br/><div class="children"><div class="content">It’ll be interesting to do something like this in Elixir where clustering is almost a runtime primitive.</div><br/></div></div><div id="41207176" class="c"><input type="checkbox" id="c-41207176" checked=""/><div class="controls bullet"><span class="by">ibash</span><span>|</span><a href="#41207497">prev</a><span>|</span><a href="#41207781">next</a><span>|</span><label class="collapse" for="c-41207176">[-]</label><label class="expand" for="c-41207176">[3 more]</label></div><br/><div class="children"><div class="content">1. If your entire cluster goes down do you permanently lose state?<p>2. Are network requests &#x2F; other ephemeral things also saved to the snapshot?</div><br/><div id="41207231" class="c"><input type="checkbox" id="c-41207231" checked=""/><div class="controls bullet"><span class="by">tdrhq</span><span>|</span><a href="#41207176">parent</a><span>|</span><a href="#41207781">next</a><span>|</span><label class="collapse" for="c-41207231">[-]</label><label class="expand" for="c-41207231">[2 more]</label></div><br/><div class="children"><div class="content">[Author here] The transactions and snapshots are still logged to disk. So if the cluster goes down and comes back up, each one just reloads the state. Until at least two machines are back up, we won&#x27;t be able to serve requests though.<p>Not sure what you mean by ephemeral things. If you mean things like file descriptors, they are not stored. Technically the snapshot is not a simple snapshot of RAM, it snapshots through all the objects in memory that are set up to be part of the datastore. (It&#x27;s a bit more complicated and flexible than this, but that&#x27;s the general idea.)</div><br/><div id="41207341" class="c"><input type="checkbox" id="c-41207341" checked=""/><div class="controls bullet"><span class="by">ibash</span><span>|</span><a href="#41207176">root</a><span>|</span><a href="#41207231">parent</a><span>|</span><a href="#41207781">next</a><span>|</span><label class="collapse" for="c-41207341">[-]</label><label class="expand" for="c-41207341">[1 more]</label></div><br/><div class="children"><div class="content">Ah awesome! Thank you!</div><br/></div></div></div></div></div></div><div id="41207781" class="c"><input type="checkbox" id="c-41207781" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#41207176">prev</a><span>|</span><a href="#41207476">next</a><span>|</span><label class="collapse" for="c-41207781">[-]</label><label class="expand" for="c-41207781">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine all the wonderful things you could build if you never had to serialize data into SQL queries.<p>No transactions, no WAL, no relational schema to keep data design sane, no query planner doing all kinds of optimisations and memory layout things I don&#x27;t have to think about?<p>You could say that transactions, for example, would be redundant if there is no external communication between app server and the database. But it is far from the only thing they&#x27;re useful for. Transactions are a great way of fulfilling important invariants about the data, just like a good strict database schema. You rollback a transaction if an internal error throws. You make sure that transaction data changes get serialised to disk all at once. You remove a possibility that statements from two simultaneous transactions access the same data in a random order (at least if you pick a proper transaction isolation level, which you usually should).<p>&gt; You also won’t need special architectures to reduce round-trips to your database. In particular, you won’t need any of that Async-IO business, because your threads are no longer IO bound. Retrieving data is just a matter of reading RAM. Suddenly debugging code has become a lot easier too.<p>Database is far from the only other server I have to communicate with when I&#x27;m working on user&#x27;s HTTP request. As a web developer, I don&#x27;t think I&#x27;ve worked on a single product in the last 4 years that didn&#x27;t have some kind of server-server communication for integrations with other tools and social media sites.<p>&gt; You don’t need crazy concurrency protocols, because most of your concurrency requirements can be satisfied with simple in-memory mutexes and condition variables.<p>Ah, mutexes. Something that programmers never shot themselves in a foot with. Also, deadlocks don&#x27;t exist.<p>&gt; Hold on, what if you’ve made changes since the last snapshot? And this is the clever bit: you ensure that every time you change parts of RAM, we write a transaction to disk. So if you have a line like foo.setBar(2), this will first write a transaction that says we’ve changed the bar field of foo to 2, and then actually set the field to 2. An operation like new Foo() writes a transaction to disk to say that a Foo object was created, and then returns the new object.<p>A disk write latency is added to every RAM write. It has no performance cost and nobody notices this.<p>I apologise if this comes off too snarky. Despite all of the above, I really like this idea — and already think of implementing it in a hobby project, just to see how well it really works. I&#x27;m still not sure if it&#x27;s practical, but I love the creative thinking behind this, and a fact that it actually helped them build a business.</div><br/></div></div><div id="41207476" class="c"><input type="checkbox" id="c-41207476" checked=""/><div class="controls bullet"><span class="by">aorloff</span><span>|</span><a href="#41207781">prev</a><span>|</span><a href="#41206909">next</a><span>|</span><label class="collapse" for="c-41207476">[-]</label><label class="expand" for="c-41207476">[1 more]</label></div><br/><div class="children"><div class="content">This is like an example case of a lambda + kinesis</div><br/></div></div><div id="41207337" class="c"><input type="checkbox" id="c-41207337" checked=""/><div class="controls bullet"><span class="by">iammrpayments</span><span>|</span><a href="#41206909">prev</a><span>|</span><a href="#41207136">next</a><span>|</span><label class="collapse" for="c-41207337">[-]</label><label class="expand" for="c-41207337">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t this like redis?</div><br/></div></div><div id="41207136" class="c"><input type="checkbox" id="c-41207136" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#41207337">prev</a><span>|</span><a href="#41207424">next</a><span>|</span><label class="collapse" for="c-41207136">[-]</label><label class="expand" for="c-41207136">[1 more]</label></div><br/><div class="children"><div class="content">What they described early on in the article was basically how NUMA machines worked (eg SGI Altix or UV). Also, their claimed benefit was being able to parallelize things with multithreading in low-latency, huge RAM. Clustering came as a low-cost alternative to $1+ million machines. There’s similarities to persistence in AS&#x2F;400, too, where apps just wrote memory that gets transparently mapped to disk.<p>Now, with cheap hardware, they’re going back in time to the benefits of clustered, NUMA machines. They’ve improved on it along the way. I did enjoy the article.<p>Another trick from the past was eliminating TCP&#x2F;IP stacks from within clusters to knock out their issues. Solutions like Active Messages were a thin layer on top of the hardware. There’s also designs for network routers that have strong consistency built into them. Quite a few things they could do.<p>If they get big, there’s hardware opportunities. On CPU side, SGI did two things. Their NUMA machines expanded the number of CPU’s and RAM for one system. They also allowed FPGA’s to plug directly into the memory bus to do custom accelerators. Finally, some CompSci papers modified processor ISA’s, networks on a chip, etc to remove or reduce bottlenecks in multithreading. Also, chips like OpenPiton increase core counts (eg 32) with open, customizable cores.</div><br/></div></div><div id="41207424" class="c"><input type="checkbox" id="c-41207424" checked=""/><div class="controls bullet"><span class="by">apexkid</span><span>|</span><a href="#41207136">prev</a><span>|</span><a href="#41207413">next</a><span>|</span><label class="collapse" for="c-41207424">[-]</label><label class="expand" for="c-41207424">[2 more]</label></div><br/><div class="children"><div class="content">&gt; periodically just take a snapshot of everything in RAM.<p>Sound similar to `stop the world Garbage collection` in Java. Does your entire processing comes to halt when you do this? How frequently do you need to take snapshots? Or do you have a way to do this without halting everything</div><br/><div id="41207543" class="c"><input type="checkbox" id="c-41207543" checked=""/><div class="controls bullet"><span class="by">tdrhq</span><span>|</span><a href="#41207424">parent</a><span>|</span><a href="#41207413">next</a><span>|</span><label class="collapse" for="c-41207543">[-]</label><label class="expand" for="c-41207543">[1 more]</label></div><br/><div class="children"><div class="content">Good catch! Snapshotting was certainly a bottleneck that I chose not to write about.<p>But we aren&#x27;t really taking the snapshot of RAM, instead we&#x27;re running some code asking each object to snapshot itself into a stream. If you do this naively, it will block writes on the server until the snapshot is done (reads will continue to work).<p>But Raft has a protocol for asynchronous snapshots. So in the first step we take an immutable fast snapshot of the state we care about which happens quickly, then writes can keep going while in the background we serialize the state to disk.</div><br/></div></div></div></div><div id="41207413" class="c"><input type="checkbox" id="c-41207413" checked=""/><div class="controls bullet"><span class="by">jhardy54</span><span>|</span><a href="#41207424">prev</a><span>|</span><a href="#41207406">next</a><span>|</span><label class="collapse" for="c-41207413">[-]</label><label class="expand" for="c-41207413">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hold on, what if you’ve made changes since the last snapshot? And this is the clever bit: you ensure that every time you change parts of RAM, we write a transaction to disk. So if you have a line like foo.setBar(2), this will first write a transaction that says we’ve changed the bar field of foo to 2, and then actually set the field to 2. An operation like new Foo() writes a transaction to disk to say that a Foo object was created, and then returns the new object.<p>&gt;<p>&gt; And so, if your process crashes and restarts, it first reloads the snapshot, and replays the transaction logs to fully recover the state. (Notice that index changes don’t need to be part of the transaction log. For instance if there’s an index on field bar from Foo, then setBar should just update the index, which will get updated whether it’s read from a snapshot, or from a transaction.)<p>That’s a database. You even linked to the specific database you’re using [0], which describes itself as:<p>&gt; […] in-memory database with transactions […]<p>Am I misunderstanding something?<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;bknr-datastore&#x2F;bknr-datastore">https:&#x2F;&#x2F;github.com&#x2F;bknr-datastore&#x2F;bknr-datastore</a></div><br/></div></div><div id="41207406" class="c"><input type="checkbox" id="c-41207406" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#41207413">prev</a><span>|</span><a href="#41207100">next</a><span>|</span><label class="collapse" for="c-41207406">[-]</label><label class="expand" for="c-41207406">[2 more]</label></div><br/><div class="children"><div class="content">But why, when you can build things in an ordinary way with ordinary tech like Python&#x2F;Java&#x2F;C#&#x2F;TypeScript and Postgres. Lots of developers know it, lots of answers to your questions online, the AI knows how to write it.<p>Reading posts like this makes me think the founders&#x2F;CTO is mixing hobby programming with professional programming.</div><br/><div id="41207494" class="c"><input type="checkbox" id="c-41207494" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#41207406">parent</a><span>|</span><a href="#41207100">next</a><span>|</span><label class="collapse" for="c-41207494">[-]</label><label class="expand" for="c-41207494">[1 more]</label></div><br/><div class="children"><div class="content">Why not, though? Because you only know the languages you listed?</div><br/></div></div></div></div><div id="41207100" class="c"><input type="checkbox" id="c-41207100" checked=""/><div class="controls bullet"><span class="by">localfirst</span><span>|</span><a href="#41207406">prev</a><span>|</span><a href="#41207025">next</a><span>|</span><label class="collapse" for="c-41207100">[-]</label><label class="expand" for="c-41207100">[2 more]</label></div><br/><div class="children"><div class="content">I would use cloudflare R2 but its not globally distributed so its pointless using it on edge<p>otherwise I get the messaging with edge you the database is the bottleneck<p>just need a one stop shop to do edge functions + edge db</div><br/><div id="41207929" class="c"><input type="checkbox" id="c-41207929" checked=""/><div class="controls bullet"><span class="by">tazu</span><span>|</span><a href="#41207100">parent</a><span>|</span><a href="#41207025">next</a><span>|</span><label class="collapse" for="c-41207929">[-]</label><label class="expand" for="c-41207929">[1 more]</label></div><br/><div class="children"><div class="content">Cloudflare&#x27;s durable objects seem similar to this article&#x27;s &quot;objects in RAM&quot;, but I think you still have to do some minimal serialization.</div><br/></div></div></div></div></div></div></div></div></div></body></html>