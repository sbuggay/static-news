<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721034065349" as="style"/><link rel="stylesheet" href="styles.css?v=1721034065349"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mazeppa-dev/mazeppa">Mazeppa: A modern supercompiler for call-by-value functional languages</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>Jhsto</span> | <span>18 comments</span></div><br/><div><div id="40964773" class="c"><input type="checkbox" id="c-40964773" checked=""/><div class="controls bullet"><span class="by">batterseapower</span><span>|</span><a href="#40961871">next</a><span>|</span><label class="collapse" for="c-40964773">[-]</label><label class="expand" for="c-40964773">[4 more]</label></div><br/><div class="children"><div class="content">My PhD was on supercompilation for Haskell (thanks for the cite in the repo :-))<p>Cool to see that people are still working on it, but I think that the main barrier to practical use of these techniques still remains unsolved. The problem is that it&#x27;s just so easy for the supercomplier to go into some crazy exponential blowup of function unfolding, making the compilation step take impractically long.<p>Even if you avoid a literal exponential blowup you can easily end up generating tons of specializations that bloat your code cache but don&#x27;t reveal any useful optimization opportunities&#x2F;are infrequently used in practice. Similar performance problems also plague related techniques like trace-based JITs, even though the trace JIT happens at runtime and thus has access to strictly more information about the frequency with which a trace might be used.<p>You can try to use annotations like the @extract proposed in the article to control these problems, but it can be hard to predict in advance when this is going to occur.<p>One interesting research direction might be to use deep reinforcement learning to try to guide the generalization&#x2F;termination decisions, where the reward is based on A) whether the unfolding leads to a tie-back later on, and B) to what extent the unfolding allowed deforestation&#x2F;beta reduction to take place.</div><br/><div id="40964893" class="c"><input type="checkbox" id="c-40964893" checked=""/><div class="controls bullet"><span class="by">c0balt</span><span>|</span><a href="#40964773">parent</a><span>|</span><a href="#40961871">next</a><span>|</span><label class="collapse" for="c-40964893">[-]</label><label class="expand" for="c-40964893">[3 more]</label></div><br/><div class="children"><div class="content">Maybe this is naive but couldn&#x27;t you use the same approach with profiles collected at runtime as PGO like LLVM&#x2F;GCC? In my experience it can help quite a lot with guiding inlining both by hand and via a compiler.</div><br/><div id="40964936" class="c"><input type="checkbox" id="c-40964936" checked=""/><div class="controls bullet"><span class="by">batterseapower</span><span>|</span><a href="#40964773">root</a><span>|</span><a href="#40964893">parent</a><span>|</span><a href="#40961871">next</a><span>|</span><label class="collapse" for="c-40964936">[-]</label><label class="expand" for="c-40964936">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s naive - it could definitely help ameliorate the issues. To my knowledge noone has tried this approach.<p>The other idea I had when I was working on this stuff was to do JIT supercompliation. Clasically, supercompilers expand the whole graph at compile time, but it would be straightforward to delay the supercompilation process until the first time that the code is actually executed, which helps tame the problem of generating lots of specializations that may never actually be executed in practice.<p>(Choosing a generalization heuristic becomes more important in the JIT setting because you always have access to the full info about all parameters to the function you are specializing, and naively you would end up e.g. specializing sigmoid(x)=1&#x2F;(1+exp(x)) for each value of x observed at runtime.)</div><br/><div id="40965914" class="c"><input type="checkbox" id="c-40965914" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40964773">root</a><span>|</span><a href="#40964936">parent</a><span>|</span><a href="#40961871">next</a><span>|</span><label class="collapse" for="c-40965914">[-]</label><label class="expand" for="c-40965914">[1 more]</label></div><br/><div class="children"><div class="content">Do current JIT implementation already have something to control specialization? I have heard many times for example that JavaScript engines will specialize hot paths.</div><br/></div></div></div></div></div></div></div></div><div id="40961871" class="c"><input type="checkbox" id="c-40961871" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40964773">prev</a><span>|</span><a href="#40947303">next</a><span>|</span><label class="collapse" for="c-40961871">[-]</label><label class="expand" for="c-40961871">[2 more]</label></div><br/><div class="children"><div class="content">That was such a good Readme. Wonderful explanations for those unfamiliar with the space, full examples, a bit of history&#x2F;context. Thanks!</div><br/><div id="40961915" class="c"><input type="checkbox" id="c-40961915" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#40961871">parent</a><span>|</span><a href="#40947303">next</a><span>|</span><label class="collapse" for="c-40961915">[-]</label><label class="expand" for="c-40961915">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I&#x27;m glad the explanations were helpful.</div><br/></div></div></div></div><div id="40947303" class="c"><input type="checkbox" id="c-40947303" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#40961871">prev</a><span>|</span><a href="#40960637">next</a><span>|</span><label class="collapse" for="c-40947303">[-]</label><label class="expand" for="c-40947303">[2 more]</label></div><br/><div class="children"><div class="content">Is the manual annotation is because deciding whether or not a graph will blow up upon supercompilation by trying, but checking for blowup during the process, doesn&#x27;t work?<p>&gt; <i>In Mazeppa, we have call-by-value functions and call-by-name (call-by-need) constructors, which 1) makes deforestation possible and 2) preserves the original semantics of code.</i><p>Are there any other notable differences between this approach and call-by-value constructors? (I guess one might have to carry around the original context in closures for a little while, but presumably even that disappears in residual programs?)<p>[Stepan Razin lost his black hat during his ride, but the supercompiler has already removed Ivan Mazepa&#x27;s?]</div><br/><div id="40961237" class="c"><input type="checkbox" id="c-40961237" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#40947303">parent</a><span>|</span><a href="#40960637">next</a><span>|</span><label class="collapse" for="c-40961237">[-]</label><label class="expand" for="c-40961237">[1 more]</label></div><br/><div class="children"><div class="content">Checking for blowup sort of works; for example, this paper [1] suggests exactly this approach. However, I&#x27;m not leaning to it due to the following reasons:<p>1. The approach involves magic numbers to implement heuristics. They worked for the samples provided by the authors, but will they work for large programs?<p>2. I think that there&#x27;s a smarter approach to detect blowups. Specifically, there can be &quot;good&quot; and &quot;bad&quot; interactions in the form `f(g(...), ...)`, where `f` and `g` are functions; an interaction is good if `g` produces information that is known at compile-time (to be subsequently deconstructed by `f`), and bad if it doesn&#x27;t. If the interaction is bad, `f` and `g` should be transformed separately.<p>In general, I see manual annotations as a low-level mechanism that can be used for predictable supercompilation. We haven&#x27;t yet implemented heuristics that would guarantee predictability, but this is on our priority list.<p>&gt; Are there any other notable differences between this approach and call-by-value constructors?<p>Yes, lazy constructors must be implemented differently than eager ones. The standard approach is to enclose constructor arguments under an environment of values, just as we implement closure functions. I don&#x27;t think that supercompilation can remove all laziness from the constructors.<p>[1] Jonsson, Peter &amp; Nordlander, Johan. (2011). Taming code explosion in supercompilation. PERM&#x27;11 - Proceedings of the 20th ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation. 33-42. 10.1145&#x2F;1929501.1929507.</div><br/></div></div></div></div><div id="40964643" class="c"><input type="checkbox" id="c-40964643" checked=""/><div class="controls bullet"><span class="by">voldacar</span><span>|</span><a href="#40960637">prev</a><span>|</span><a href="#40960564">next</a><span>|</span><label class="collapse" for="c-40964643">[-]</label><label class="expand" for="c-40964643">[2 more]</label></div><br/><div class="children"><div class="content">Cool. How necessary is the type system? Could you make something similar for lispy languages?</div><br/><div id="40964779" class="c"><input type="checkbox" id="c-40964779" checked=""/><div class="controls bullet"><span class="by">batterseapower</span><span>|</span><a href="#40964643">parent</a><span>|</span><a href="#40960564">next</a><span>|</span><label class="collapse" for="c-40964779">[-]</label><label class="expand" for="c-40964779">[1 more]</label></div><br/><div class="children"><div class="content">Supercompilation doesn&#x27;t depend on having a typed language - you can more or less derive a supercompiler mechanically from any operational semantics, typed or untyped.</div><br/></div></div></div></div><div id="40960564" class="c"><input type="checkbox" id="c-40960564" checked=""/><div class="controls bullet"><span class="by">keiferski</span><span>|</span><a href="#40964643">prev</a><span>|</span><label class="collapse" for="c-40960564">[-]</label><label class="expand" for="c-40960564">[6 more]</label></div><br/><div class="children"><div class="content">The likely origin of the name, if you’re curious:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mazeppa_(poem)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mazeppa_(poem)</a></div><br/><div id="40964841" class="c"><input type="checkbox" id="c-40964841" checked=""/><div class="controls bullet"><span class="by">alekseiprokopev</span><span>|</span><a href="#40960564">parent</a><span>|</span><a href="#40961155">next</a><span>|</span><label class="collapse" for="c-40964841">[-]</label><label class="expand" for="c-40964841">[1 more]</label></div><br/><div class="children"><div class="content">The first thing I though was this guy lol <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ivan_Mazepa" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ivan_Mazepa</a>
I support Ukraine btw.</div><br/></div></div><div id="40961155" class="c"><input type="checkbox" id="c-40961155" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#40960564">parent</a><span>|</span><a href="#40964841">prev</a><span>|</span><a href="#40961087">next</a><span>|</span><label class="collapse" for="c-40961155">[-]</label><label class="expand" for="c-40961155">[2 more]</label></div><br/><div class="children"><div class="content">The name was inspired by Transcendental Étude No. 4 [1], as correctly suggested by the other comment.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MYSFTtYc4P4" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MYSFTtYc4P4</a></div><br/><div id="40961357" class="c"><input type="checkbox" id="c-40961357" checked=""/><div class="controls bullet"><span class="by">keiferski</span><span>|</span><a href="#40960564">root</a><span>|</span><a href="#40961155">parent</a><span>|</span><a href="#40961087">next</a><span>|</span><label class="collapse" for="c-40961357">[-]</label><label class="expand" for="c-40961357">[1 more]</label></div><br/><div class="children"><div class="content">It looks like those compositions were ultimately inspired by the poem. So we’re both right ;)<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cultural_legacy_of_Mazeppa" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cultural_legacy_of_Mazeppa</a></div><br/></div></div></div></div><div id="40961087" class="c"><input type="checkbox" id="c-40961087" checked=""/><div class="controls bullet"><span class="by">rottc0dd</span><span>|</span><a href="#40960564">parent</a><span>|</span><a href="#40961155">prev</a><span>|</span><a href="#40960806">next</a><span>|</span><label class="collapse" for="c-40961087">[-]</label><label class="expand" for="c-40961087">[1 more]</label></div><br/><div class="children"><div class="content">Oh! I thought it was this:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;CXGeOHdiHrE" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;CXGeOHdiHrE</a><p>TIL</div><br/></div></div></div></div></div></div></div></div></div></body></html>