<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700989258610" as="style"/><link rel="stylesheet" href="styles.css?v=1700989258610"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://flix.dev/">The Flix Programming Language</a> <span class="domain">(<a href="https://flix.dev">flix.dev</a>)</span></div><div class="subtext"><span>sivakon</span> | <span>38 comments</span></div><br/><div><div id="38419695" class="c"><input type="checkbox" id="c-38419695" checked=""/><div class="controls bullet"><span class="by">subarctic</span><span>|</span><a href="#38419675">next</a><span>|</span><label class="collapse" for="c-38419695">[-]</label><label class="expand" for="c-38419695">[3 more]</label></div><br/><div class="children"><div class="content">Lots of interesting bits in the FAQ: <a href="https:&#x2F;&#x2F;flix.dev&#x2F;faq&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;flix.dev&#x2F;faq&#x2F;</a><p>Particularly in the sections titled &quot;What features are not supported&quot; (no exceptions or panics, so e.g. indexing has to return an Option in case it&#x27;s out of bounds) and &quot;What controversial design choices are made&quot;. Some pithy remarks towards the end as well.<p>To follow HN tradition and find the most controversial topic to discuss, my guess is it&#x27;s either not allowing name shadowing, or divide by zero equals zero. Or the site not working without javascript (see the section on that near the end, but you&#x27;ll need to turn on javascript to read it I guess)</div><br/><div id="38419769" class="c"><input type="checkbox" id="c-38419769" checked=""/><div class="controls bullet"><span class="by">xcdzvyn</span><span>|</span><a href="#38419695">parent</a><span>|</span><a href="#38419909">next</a><span>|</span><label class="collapse" for="c-38419769">[-]</label><label class="expand" for="c-38419769">[1 more]</label></div><br/><div class="children"><div class="content">I did like seeing the FAQ become more and more deranged the further I scrolled!<p>I&#x27;ll perhaps be the first to jump on the 1&#x2F;0 != 0 hate train though; they mention they designed the stdlib to avoid the partial-function pitfalls of Haskell&#x27;s, but the article they linked to support their design decision of 1&#x2F;0 being 0 mentions that it boils down to division being a partial function - x&#x2F;0 is not a case division can handle. Would it not then be reasonable to make division return an Option?</div><br/></div></div><div id="38419909" class="c"><input type="checkbox" id="c-38419909" checked=""/><div class="controls bullet"><span class="by">brigandish</span><span>|</span><a href="#38419695">parent</a><span>|</span><a href="#38419769">prev</a><span>|</span><a href="#38419675">next</a><span>|</span><label class="collapse" for="c-38419909">[-]</label><label class="expand" for="c-38419909">[1 more]</label></div><br/><div class="children"><div class="content">I also don&#x27;t like &quot;Unused definitions, type declarations, etc. are compile-time errors&quot; as I often want to test the validity of a statement, like a type declaration, by compiling before using it. Much prefer warnings.<p>I don&#x27;t mind the disallowing name shadowing, but I really, <i>really</i> hate (I mean that) websites that are just good ol&#x27; text and the odd picture that require Javascript. The excuse of &quot;we used React, it&#x27;s easy&quot; seems odd given that HTML is much easier.</div><br/></div></div></div></div><div id="38419675" class="c"><input type="checkbox" id="c-38419675" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38419695">prev</a><span>|</span><a href="#38419739">next</a><span>|</span><label class="collapse" for="c-38419675">[-]</label><label class="expand" for="c-38419675">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Region-based Local Mutation<p>&gt; Flix supports region-based local mutation, which makes it possible to implement pure functions that internally uses mutable state and destructive operations, as long as these operations are confined to the region.<p>&gt; We can use local mutation when it is more natural to write a function using mutable data and in a familiar imperative-style while still remaining pure to the outside world.<p>&gt; We can also use local mutation when it is more efficient to use mutable data structures, e.g. when implementing a sorting algorithm.<p>Another language with a feature like this is F* (or FStar), but I think it uses a different kind of compile-time analysis.<p>Haskell actually kind of lets you do it through the ST monad (there&#x27;s a function called runST that turns mutable code inside the ST monad into pure code). But F* (and Flix) can do it implicitly</div><br/></div></div><div id="38419739" class="c"><input type="checkbox" id="c-38419739" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38419675">prev</a><span>|</span><a href="#38419934">next</a><span>|</span><label class="collapse" for="c-38419739">[-]</label><label class="expand" for="c-38419739">[1 more]</label></div><br/><div class="children"><div class="content">Related. Others?<p><i>Flix – Safe, reliable, concise, and functional-first programming language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31448889">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31448889</a> - May 2022 (42 comments)<p><i>Flix – Next-generation reliable, concise, functional-first programming language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25513397">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25513397</a> - Dec 2020 (84 comments)<p><i>The Flix Programming Language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19928153">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19928153</a> - May 2019 (2 comments)</div><br/></div></div><div id="38419934" class="c"><input type="checkbox" id="c-38419934" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38419739">prev</a><span>|</span><a href="#38419638">next</a><span>|</span><label class="collapse" for="c-38419934">[-]</label><label class="expand" for="c-38419934">[1 more]</label></div><br/><div class="children"><div class="content">One problém of Flix has been the split of the world in &quot;normal&quot; und &quot;graded&quot; type classes, because of the effects as types. Is this solved now?<p>Example see:
<a href="https:&#x2F;&#x2F;github.com&#x2F;Release-Candidate&#x2F;flix-test">https:&#x2F;&#x2F;github.com&#x2F;Release-Candidate&#x2F;flix-test</a></div><br/></div></div><div id="38419638" class="c"><input type="checkbox" id="c-38419638" checked=""/><div class="controls bullet"><span class="by">globalnode</span><span>|</span><a href="#38419934">prev</a><span>|</span><a href="#38419648">next</a><span>|</span><label class="collapse" for="c-38419638">[-]</label><label class="expand" for="c-38419638">[12 more]</label></div><br/><div class="children"><div class="content">do functional languages mainly appeal to computer language enthusiasts&#x2F;researchers? im just not seeing the benefit personally.</div><br/><div id="38419783" class="c"><input type="checkbox" id="c-38419783" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#38419638">parent</a><span>|</span><a href="#38419661">next</a><span>|</span><label class="collapse" for="c-38419783">[-]</label><label class="expand" for="c-38419783">[2 more]</label></div><br/><div class="children"><div class="content">Functional Programming was, for a long time, talked about as yet-another-solution to solve the issue of complexity in larger codebases, primarily the complexity of controlling state getting out o hand.<p>Similar to OOP, which promised to do this by encapsulating state, FP promised to do this via purity, aka. getting rid of as much state as possible, and only allowing stateful transition at certain well defined sections of the program.<p>The &quot;market advantage&quot; of OOP was that, via Java, it was already so well established, and so many coders had been trained in OOP languages, that it remained alive. FP on the other hand, coming out of academia and requiring all these industry people to suddenly do things in syntactically and conceptually different ways, never really gained traction. OOP simply came first, it is as simple as that.<p>Whether FP would have actually solved the problem is anyones guess, since it never gained the traction of OOP and Procedural languages. My best guess is that it wouldn&#x27;t, because I don&#x27;t believe in silver bullets.<p>It should be noted that both approaches contributed valueable things to contemporary languages. E.g. first order functions being the norm comes from FP.</div><br/><div id="38420066" class="c"><input type="checkbox" id="c-38420066" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419783">parent</a><span>|</span><a href="#38419661">next</a><span>|</span><label class="collapse" for="c-38420066">[-]</label><label class="expand" for="c-38420066">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OOP simply came first<p>Not really. Lisp is a functional programming language and has existed since at least 1960. Some claim there were many other proto-functional languages since the early 60&#x27;s, and the FP language [1] (a clearly functional programming language and the result of the famous paper &quot;Can Programming Be Liberated From the von Neumann Style?&quot;) appeared in 1977 - was inspired by much earlier efforts like APL.<p>OOP really only became a thing with Simula in 1967, but was not popular until the 1980&#x27;s with Smalltalk and Common Lisp&#x27;s Object System (CLOS) came about (so yes, there was a OOP&#x2F;FP hybrid already decades ago), and then C++ and finally Java much later... at which time Functional Programming languages already included Miranda (1985) which later evolved into Haskell, and Erlang (1986). That is, FPP languages were at least as common as OOP languages by the 80&#x27;s.<p>As far as I know, however, pure functional languages were not really very efficient until Haskell came about, while OOP languages were nearly on par with procedural style: which mattered a lot in 1980&#x27;s machines.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FP_(programming_language)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FP_(programming_language)</a></div><br/></div></div></div></div><div id="38419661" class="c"><input type="checkbox" id="c-38419661" checked=""/><div class="controls bullet"><span class="by">michaelsbradley</span><span>|</span><a href="#38419638">parent</a><span>|</span><a href="#38419783">prev</a><span>|</span><a href="#38419648">next</a><span>|</span><label class="collapse" for="c-38419661">[-]</label><label class="expand" for="c-38419661">[9 more]</label></div><br/><div class="children"><div class="content">Do you worry about side-effects that leak beyond the scope of the routines you&#x27;re authoring?<p>Why &#x2F; why not?</div><br/><div id="38419670" class="c"><input type="checkbox" id="c-38419670" checked=""/><div class="controls bullet"><span class="by">globalnode</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419661">parent</a><span>|</span><a href="#38419648">next</a><span>|</span><label class="collapse" for="c-38419670">[-]</label><label class="expand" for="c-38419670">[8 more]</label></div><br/><div class="children"><div class="content">i do, does functional programming make this a non issue? maybe im just not smart enough to wrap my head around it.</div><br/><div id="38419683" class="c"><input type="checkbox" id="c-38419683" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419670">parent</a><span>|</span><a href="#38419823">next</a><span>|</span><label class="collapse" for="c-38419683">[-]</label><label class="expand" for="c-38419683">[1 more]</label></div><br/><div class="children"><div class="content">Generally, yes. Some languages are really hardcore about it (notably Haskell), while others just strongly encourage you to write functions without side effects. Ed: that&#x27;s the &quot;purity&quot; they&#x27;re talking about in OP.<p>The other major neat thing about functional languages is how they let you treat functions like objects, but most modern programming languages have adopted that as well, so it&#x27;s not a big differentiator anymore.</div><br/></div></div><div id="38419823" class="c"><input type="checkbox" id="c-38419823" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419670">parent</a><span>|</span><a href="#38419683">prev</a><span>|</span><a href="#38419707">next</a><span>|</span><label class="collapse" for="c-38419823">[-]</label><label class="expand" for="c-38419823">[5 more]</label></div><br/><div class="children"><div class="content">Yes and no.<p>In theory, writing in a functional language that allows only &quot;pure&quot; functions (aka. functions w.o. side effects), makes it easier to control state.<p>In practice, side effects exists and are required for programs to do anything useful.<p>In my opinion, one mistake of many purely functional languages was to be so focused on this purity, that it made it needlessly hard to write useful code in them, especially for people coming from an imperative&#x2F;procedural&#x2F;oop style of doing things. And you need these people if you want your method to gain traction, because the vast majority of code written, is imperative.<p>The irony is, that FP could probably have had a lot more success if it didn&#x27;t clamour on about pure functions so much, and was less focused on implementations (aka. languages) than on methodology (aka. coding style) Because it is perfectly possible to write pure functions in most languages, including OOP language, even if those functions are not &quot;pure&quot; internally, or are not &quot;pure&quot; all the time and under all circumstances.<p>And yes, doing so has really nice advantages. I have refactored quite alot of codebases into using a more functional approach, and what I found was that this makes it harder to introduce bugs, makes it easier to track bugs, and makes it easier to reason about my code.<p>So yeah, functional programming, used if and where it makes sense, does work, and is useful.</div><br/><div id="38419893" class="c"><input type="checkbox" id="c-38419893" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419823">parent</a><span>|</span><a href="#38419906">next</a><span>|</span><label class="collapse" for="c-38419893">[-]</label><label class="expand" for="c-38419893">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The irony is, that FP could probably have had a lot more success if it didn&#x27;t clamour on about pure functions so much<p>Except functional languages like Lisps and the MLs never were pure, the only (used by a significant number of people) has been Miranda&#x2F;Haskell (ignoring Coq and the other proof assistents).
Or, to put it in other words: 
ML (no, not that ML) turned 50 this year, Scheme is oder than 50 too and Miranda&#x2F;Haskell ~36. There never had been a shortage of &quot;impure&quot; functional languages since OOP  existed.</div><br/><div id="38419955" class="c"><input type="checkbox" id="c-38419955" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419893">parent</a><span>|</span><a href="#38419906">next</a><span>|</span><label class="collapse" for="c-38419955">[-]</label><label class="expand" for="c-38419955">[2 more]</label></div><br/><div class="children"><div class="content">Yes, there have. And not a single one of them was able to even gain a sizeable fraction of the mindspace that imperative languages have, let alone replace or obsolete <i>even a single one of them</i>.<p>So maybe it&#x27;s time for FP as a whole to accept the fact, that there seems to be something fundamental about the way it&#x27;s paraded implementations look and feel like, that puts off a lot of programmers.<p>Maybe it&#x27;s time for FP to accept that the paradigm as a whole has a lot to contribute that is useful to everyone, but doesn&#x27;t need a new language with largely different syntactic constructs to do so.</div><br/><div id="38420100" class="c"><input type="checkbox" id="c-38420100" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419955">parent</a><span>|</span><a href="#38419906">next</a><span>|</span><label class="collapse" for="c-38420100">[-]</label><label class="expand" for="c-38420100">[1 more]</label></div><br/><div class="children"><div class="content">Strict&#x2F;constrained things are generally less appealing. That does not mean they are not the right approach. I dont agree with the popularity contest approach though.<p>Many languages are in use for different things without the need for a language to win. It is a bit anthropomorphic to approach tools like that IMO.<p>Instead, there has been a healthy influence of more research FP languages into mainstream languages (as you mention), more interesting experimental languages, etc. Aka everything working as intended.</div><br/></div></div></div></div></div></div><div id="38419906" class="c"><input type="checkbox" id="c-38419906" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419823">parent</a><span>|</span><a href="#38419893">prev</a><span>|</span><a href="#38419707">next</a><span>|</span><label class="collapse" for="c-38419906">[-]</label><label class="expand" for="c-38419906">[1 more]</label></div><br/><div class="children"><div class="content">&gt; FP could probably have had a lot more success if it didn&#x27;t clamour on about pure functions so much<p>Note that there are many functional languages which don’t care about purity at all: for instance, Scheme, OCaml, SML and Elixir. I get annoyed when people confuse Haskell for the broader paradigm of functional programming. (Even though Haskell is my main programming language!)</div><br/></div></div></div></div><div id="38419707" class="c"><input type="checkbox" id="c-38419707" checked=""/><div class="controls bullet"><span class="by">imoverclocked</span><span>|</span><a href="#38419638">root</a><span>|</span><a href="#38419670">parent</a><span>|</span><a href="#38419823">prev</a><span>|</span><a href="#38419648">next</a><span>|</span><label class="collapse" for="c-38419707">[-]</label><label class="expand" for="c-38419707">[1 more]</label></div><br/><div class="children"><div class="content">Functional languages that require calling out side-effects (eg: &quot;\ IO&quot; in Flix)  allow you to write functions that are &quot;pure&quot; (aka: they can do no mutation of data or perform IO) and will always give you the same result for a given input. Writing the majority of your code as pure functions makes the code much easier to reason about, especially as the system scales. IMHO, it also makes testing simpler.<p>It&#x27;s definitely a different way of thinking and it has a lot of benefits. However, some of the downsides (which Flix seems to fix with region-based local mutation) might be implementing a sort that keeps two copies of a list in memory just to return the second list and discard the first. Depending on your list, this may not be an issue.</div><br/></div></div></div></div></div></div></div></div><div id="38419648" class="c"><input type="checkbox" id="c-38419648" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#38419638">prev</a><span>|</span><a href="#38419522">next</a><span>|</span><label class="collapse" for="c-38419648">[-]</label><label class="expand" for="c-38419648">[1 more]</label></div><br/><div class="children"><div class="content">This looks interesting with lots of feature packed.  Looks like a promising language.<p>One thing not clear is what&#x27;s the reference vs value model, lifetime, and mutable vs immutable model.</div><br/></div></div><div id="38419522" class="c"><input type="checkbox" id="c-38419522" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#38419648">prev</a><span>|</span><a href="#38419592">next</a><span>|</span><label class="collapse" for="c-38419522">[-]</label><label class="expand" for="c-38419522">[4 more]</label></div><br/><div class="children"><div class="content">Woah, the effect system looks really neat at first glance. Also, “region-based local mutation” so your pure functions can use mutation under the hood for performance? Sweet!</div><br/><div id="38419647" class="c"><input type="checkbox" id="c-38419647" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#38419522">parent</a><span>|</span><a href="#38419592">next</a><span>|</span><label class="collapse" for="c-38419647">[-]</label><label class="expand" for="c-38419647">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to see an experimental language that leans hard into the concept of controlled mutation.<p>I always say that purely in terms of design my ideal language is high-level Haskell, low-level C. Conceptually, purely functional design is how programming &quot;should&quot; (note the quotes) be, but doing so down to the level of functions is both not very practical (some algorithms are just easier to express in terms pointers moving around rather than folds, reduces and the like), and makes it hard to reason about performance (especially memory, and most especially if you throw laziness in the mix).<p>But then again, I write my own stuff in python because I&#x27;m a lazy fuck, so probably it&#x27;s not meant to be :(</div><br/><div id="38419794" class="c"><input type="checkbox" id="c-38419794" checked=""/><div class="controls bullet"><span class="by">Hemospectrum</span><span>|</span><a href="#38419522">root</a><span>|</span><a href="#38419647">parent</a><span>|</span><a href="#38419592">next</a><span>|</span><label class="collapse" for="c-38419794">[-]</label><label class="expand" for="c-38419794">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I always say that purely in terms of design my ideal language is high-level Haskell, low-level C.<p>That&#x27;s similar to what I used to say. I was devastated to see the BitC project implode, but then Rust appeared and took up the mantle. It&#x27;s not perfect by any means but it&#x27;s influential enough to drag the whole field of PL development kicking and screaming in that general direction.</div><br/><div id="38419861" class="c"><input type="checkbox" id="c-38419861" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#38419522">root</a><span>|</span><a href="#38419794">parent</a><span>|</span><a href="#38419592">next</a><span>|</span><label class="collapse" for="c-38419861">[-]</label><label class="expand" for="c-38419861">[1 more]</label></div><br/><div class="children"><div class="content">I agree in re Rust.<p>In spite of all the retarded monkeys in its fanbase, I always thought it was an interesting project. Popular languages today are much more similar than they used to be, they are basically &quot;converging&quot;, Rust&#x27;s willingness to try something new must be applauded.<p>Still many pain points, still a bit of a &quot;puzzle language&quot;, too much of a scatterbrain approach in the governance and design direction, but even if it had no other influence than to force people to think about the problems of low-level programming, that would be still a massive plus in my book.</div><br/></div></div></div></div></div></div></div></div><div id="38419592" class="c"><input type="checkbox" id="c-38419592" checked=""/><div class="controls bullet"><span class="by">linter</span><span>|</span><a href="#38419522">prev</a><span>|</span><a href="#38419734">next</a><span>|</span><label class="collapse" for="c-38419592">[-]</label><label class="expand" for="c-38419592">[4 more]</label></div><br/><div class="children"><div class="content">Great, But \ is ugly</div><br/><div id="38419619" class="c"><input type="checkbox" id="c-38419619" checked=""/><div class="controls bullet"><span class="by">subarctic</span><span>|</span><a href="#38419592">parent</a><span>|</span><a href="#38419737">next</a><span>|</span><label class="collapse" for="c-38419619">[-]</label><label class="expand" for="c-38419619">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just what I was thinking too haha. Honestly I really like the rest of the syntax though. (And of course, the type system features look neat but it&#x27;s easier to have an opinion on syntax.)</div><br/></div></div><div id="38419737" class="c"><input type="checkbox" id="c-38419737" checked=""/><div class="controls bullet"><span class="by">imoverclocked</span><span>|</span><a href="#38419592">parent</a><span>|</span><a href="#38419619">prev</a><span>|</span><a href="#38419716">next</a><span>|</span><label class="collapse" for="c-38419737">[-]</label><label class="expand" for="c-38419737">[1 more]</label></div><br/><div class="children"><div class="content">Your username matches your comment!<p>Also, I agree but I&#x27;m not sure what I would propose as a better token. Maybe another colon?<p>def printAndInc(x: Int32): Int32 \ IO =<p>becomes:<p>def printAndInc(x: Int32): Int32 : IO =<p>Or maybe, since functions need something after the \, even for pure functions, we just drop the \ and use the last argument?<p>def printAndInc(x: Int32): Int32 IO =</div><br/></div></div><div id="38419716" class="c"><input type="checkbox" id="c-38419716" checked=""/><div class="controls bullet"><span class="by">nikolay</span><span>|</span><a href="#38419592">parent</a><span>|</span><a href="#38419737">prev</a><span>|</span><a href="#38419734">next</a><span>|</span><label class="collapse" for="c-38419716">[-]</label><label class="expand" for="c-38419716">[1 more]</label></div><br/><div class="children"><div class="content">And so are forA and forM!</div><br/></div></div></div></div><div id="38419734" class="c"><input type="checkbox" id="c-38419734" checked=""/><div class="controls bullet"><span class="by">liamilan</span><span>|</span><a href="#38419592">prev</a><span>|</span><a href="#38419855">next</a><span>|</span><label class="collapse" for="c-38419734">[-]</label><label class="expand" for="c-38419734">[2 more]</label></div><br/><div class="children"><div class="content">Just a friendly UBC piggyback on Waterloo’s programming language ;)<p>Over summer, I built my own little functional language, Crumb (<a href="https:&#x2F;&#x2F;github.com&#x2F;liam-ilan&#x2F;crumb">https:&#x2F;&#x2F;github.com&#x2F;liam-ilan&#x2F;crumb</a>). Unlike Flix, the scope is tiny, but some pretty awesome stuff has been done with it. (Checkout this pixel art editor in your terminal, 100% Crumb: <a href="https:&#x2F;&#x2F;github.com&#x2F;ronilan&#x2F;crumbicon">https:&#x2F;&#x2F;github.com&#x2F;ronilan&#x2F;crumbicon</a>).<p>There’s a template (<a href="https:&#x2F;&#x2F;github.com&#x2F;liam-ilan&#x2F;crumb-template">https:&#x2F;&#x2F;github.com&#x2F;liam-ilan&#x2F;crumb-template</a>) and vscode highlighter (<a href="https:&#x2F;&#x2F;github.com&#x2F;liam-ilan&#x2F;crumb-vscode">https:&#x2F;&#x2F;github.com&#x2F;liam-ilan&#x2F;crumb-vscode</a>) for anyone who wants to mess around with it. Any feedback super appreciated :D</div><br/></div></div><div id="38419855" class="c"><input type="checkbox" id="c-38419855" checked=""/><div class="controls bullet"><span class="by">imoverclocked</span><span>|</span><a href="#38419734">prev</a><span>|</span><a href="#38419594">next</a><span>|</span><label class="collapse" for="c-38419855">[-]</label><label class="expand" for="c-38419855">[1 more]</label></div><br/><div class="children"><div class="content">Flix seems to be implemented in Scala 2.13. Should we expect Flix to work anywhere Scala 2.13 works? ie: if Scala 2.13 supports JDK 8, should we expect that Flix will not take advantage of later JVM features?</div><br/></div></div><div id="38419594" class="c"><input type="checkbox" id="c-38419594" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#38419855">prev</a><span>|</span><a href="#38419849">next</a><span>|</span><label class="collapse" for="c-38419594">[-]</label><label class="expand" for="c-38419594">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m disappointed this is not from Netflix.</div><br/></div></div><div id="38419849" class="c"><input type="checkbox" id="c-38419849" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38419594">prev</a><span>|</span><a href="#38419843">next</a><span>|</span><label class="collapse" for="c-38419849">[-]</label><label class="expand" for="c-38419849">[1 more]</label></div><br/><div class="children"><div class="content">Top marks for the website - passes all the tests:<p>* Example at the top<p>* Link to playground<p>* Explanation of all the features, with examples!<p>* Says which features are unique<p>The only thing I was found wondering was &quot;why datalog&quot;?<p>Language looks pretty good.</div><br/></div></div><div id="38419843" class="c"><input type="checkbox" id="c-38419843" checked=""/><div class="controls bullet"><span class="by">thefourthchime</span><span>|</span><a href="#38419849">prev</a><span>|</span><label class="collapse" for="c-38419843">[-]</label><label class="expand" for="c-38419843">[5 more]</label></div><br/><div class="children"><div class="content">In today&#x27;s world, i think that English is the only programming language that people should focus on.<p>With the rapid rise of AI, most tasks will soon involve the management of AI models rather than writing code. However, it is still important to have a basic understanding of coding.<p>Introducing a new programming language at this point seems silly to me.</div><br/><div id="38419866" class="c"><input type="checkbox" id="c-38419866" checked=""/><div class="controls bullet"><span class="by">dangerlibrary</span><span>|</span><a href="#38419843">parent</a><span>|</span><a href="#38419892">next</a><span>|</span><label class="collapse" for="c-38419866">[-]</label><label class="expand" for="c-38419866">[1 more]</label></div><br/><div class="children"><div class="content">This reads like a take from a mid-level manager rationalizing that they never learned to code, and convincing themselves that they&#x27;ll never need to.</div><br/></div></div><div id="38419892" class="c"><input type="checkbox" id="c-38419892" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#38419843">parent</a><span>|</span><a href="#38419866">prev</a><span>|</span><a href="#38420022">next</a><span>|</span><label class="collapse" for="c-38419892">[-]</label><label class="expand" for="c-38419892">[2 more]</label></div><br/><div class="children"><div class="content">Security-critical tasks and programming language research will involve humans coding for the foreseeable future. I don&#x27;t think you&#x27;d like your surgical robot to be programmed in English.</div><br/><div id="38419990" class="c"><input type="checkbox" id="c-38419990" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#38419843">root</a><span>|</span><a href="#38419892">parent</a><span>|</span><a href="#38420022">next</a><span>|</span><label class="collapse" for="c-38419990">[-]</label><label class="expand" for="c-38419990">[1 more]</label></div><br/><div class="children"><div class="content">Yes, because English is a cut-put language. So instead of <i>cut</i>ting some organ (open) (to treat it), the robot might <i>put</i> it in the dustbin instead, due to a speech recognition bug.<p>;)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38157851">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38157851</a></div><br/></div></div></div></div><div id="38420022" class="c"><input type="checkbox" id="c-38420022" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#38419843">parent</a><span>|</span><a href="#38419892">prev</a><span>|</span><label class="collapse" for="c-38420022">[-]</label><label class="expand" for="c-38420022">[1 more]</label></div><br/><div class="children"><div class="content">Lol. The random bullshit generators can write basic code, or make auto-complete smarter, but good luck making one solve complex problems, solve obscure problems without generating bullshit (aka hallucinations) or reason about large codebases. Random bullshit generators see far too much hype and will never replace programming languages for most things, where determinism is needed.</div><br/></div></div></div></div></div></div></div></div></div></body></html>