<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687338073373" as="style"/><link rel="stylesheet" href="styles.css?v=1687338073373"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://redsymbol.net/articles/bash-exit-traps/">“Exit traps” can make your Bash scripts more robust and reliable (2013)</a> <span class="domain">(<a href="http://redsymbol.net">redsymbol.net</a>)</span></div><div class="subtext"><span>ekiauhce</span> | <span>110 comments</span></div><br/><div><div id="36410411" class="c"><input type="checkbox" id="c-36410411" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36410186">next</a><span>|</span><label class="collapse" for="c-36410411">[-]</label><label class="expand" for="c-36410411">[28 more]</label></div><br/><div class="children"><div class="content">I used an exit trap to kill an SSH agent that I am running, and I noticed that dash did not kill if the script was interrupted, but only if it ran to successful completion.<p>I asked on the mailing list if this was expected behavior, and it turns out that POSIX only requires EXIT to run on a clean shutdown; to catch interruptions, add more signals.<p><pre><code>  trap &#x27;eval $(ssh-agent -k)&#x27; EXIT INT ABRT KILL TERM</code></pre></div><br/><div id="36413887" class="c"><input type="checkbox" id="c-36413887" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36410411">parent</a><span>|</span><a href="#36411786">next</a><span>|</span><label class="collapse" for="c-36413887">[-]</label><label class="expand" for="c-36413887">[1 more]</label></div><br/><div class="children"><div class="content">I found my original submission to the email list.<p><a href="https:&#x2F;&#x2F;www.spinics.net&#x2F;lists&#x2F;dash&#x2F;msg02208.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.spinics.net&#x2F;lists&#x2F;dash&#x2F;msg02208.html</a><p>&quot;Signal terminations are not caught by EXIT. It only catches normal
exits. Unfortunately, the EXIT condition is not well-defined by POSIX, so it&#x27;s left to interpretation.&quot;<p>...<p>POSIX is making it unspecified what happens here:<p><a href="https:&#x2F;&#x2F;austingroupbugs.net&#x2F;view.php?id=621" rel="nofollow noreferrer">https:&#x2F;&#x2F;austingroupbugs.net&#x2F;view.php?id=621</a><p>The EXIT condition shall occur when the shell terminates normally (exits), and may occur when the shell terminates abnormally as a
result of delivery of a signal (other than SIGKILL) whose trap
action is the default.</div><br/></div></div><div id="36411786" class="c"><input type="checkbox" id="c-36411786" checked=""/><div class="controls bullet"><span class="by">lgsymons</span><span>|</span><a href="#36410411">parent</a><span>|</span><a href="#36413887">prev</a><span>|</span><a href="#36411051">next</a><span>|</span><label class="collapse" for="c-36411786">[-]</label><label class="expand" for="c-36411786">[5 more]</label></div><br/><div class="children"><div class="content">The signals EXIT HUP INT TERM cover everything I&#x27;ve run into (I&#x27;m actually using EXIT SIGHUP SIGINT SIGTERM but presumably it&#x27;s equivalent).<p>In basic terms for my purposes these respectively account for a clean exit, the terminal emulator being closed, ctrl-c, the kill command (edit: the default SIGTERM kill -15, not the SIGKILL kill -9)</div><br/><div id="36412054" class="c"><input type="checkbox" id="c-36412054" checked=""/><div class="controls bullet"><span class="by">thelastparadise</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411786">parent</a><span>|</span><a href="#36411051">next</a><span>|</span><label class="collapse" for="c-36412054">[-]</label><label class="expand" for="c-36412054">[4 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the signal for SIGKILL?</div><br/><div id="36412084" class="c"><input type="checkbox" id="c-36412084" checked=""/><div class="controls bullet"><span class="by">EscapeFromNY</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36412054">parent</a><span>|</span><a href="#36411051">next</a><span>|</span><label class="collapse" for="c-36412084">[-]</label><label class="expand" for="c-36412084">[3 more]</label></div><br/><div class="children"><div class="content">SIGKILL can&#x27;t be handled. It&#x27;s the signal you send when you don&#x27;t want to give the process a chance to handle it.</div><br/><div id="36413188" class="c"><input type="checkbox" id="c-36413188" checked=""/><div class="controls bullet"><span class="by">moehm</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36412084">parent</a><span>|</span><a href="#36411051">next</a><span>|</span><label class="collapse" for="c-36413188">[-]</label><label class="expand" for="c-36413188">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the difference between kill -15 (SIGTERM) and kill -9 (SIGKILL), where SIGTERM shuts down a process gracefully.</div><br/><div id="36413290" class="c"><input type="checkbox" id="c-36413290" checked=""/><div class="controls bullet"><span class="by">w-ll</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36413188">parent</a><span>|</span><a href="#36411051">next</a><span>|</span><label class="collapse" for="c-36413290">[-]</label><label class="expand" for="c-36413290">[1 more]</label></div><br/><div class="children"><div class="content">Relevant: Monzy performs at Stanford Univ. &quot;Kill Dash Nine&quot; 
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Fow7iUaKrq4">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Fow7iUaKrq4</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="36411051" class="c"><input type="checkbox" id="c-36411051" checked=""/><div class="controls bullet"><span class="by">simcop2387</span><span>|</span><a href="#36410411">parent</a><span>|</span><a href="#36411786">prev</a><span>|</span><a href="#36411377">next</a><span>|</span><label class="collapse" for="c-36411051">[-]</label><label class="expand" for="c-36411051">[10 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t trap kill can you? doesn&#x27;t that just go kill your process without any possibility of intervention or other actions?  Also you probably want to handle HUP there too I would think (depending on what the script does)</div><br/><div id="36411336" class="c"><input type="checkbox" id="c-36411336" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411051">parent</a><span>|</span><a href="#36412609">next</a><span>|</span><label class="collapse" for="c-36411336">[-]</label><label class="expand" for="c-36411336">[6 more]</label></div><br/><div class="children"><div class="content">SIGABRT would have to come from the process itself; IDK when if ever the shell would do that.<p>And SIGKILL can&#x27;t be handled, so that is indeed pointless.</div><br/><div id="36413702" class="c"><input type="checkbox" id="c-36413702" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411336">parent</a><span>|</span><a href="#36411378">next</a><span>|</span><label class="collapse" for="c-36413702">[-]</label><label class="expand" for="c-36413702">[2 more]</label></div><br/><div class="children"><div class="content">In sufficiently old Unix (I remember doing this on 32V) there was a fun little hack you could do with SIGKILL. If you sent SIGKILL to a process and that process was being debugged it would <i>not</i> kill the process. It would just pause it and notify the debugger that the process had received a signal, and tell the debugger which signal.<p>The debugger could then allow the signal to go through to the process as is, or to replace it with another signal, or have it be ignored.<p>I made a program that looked like sh in ps, but actually was a simple debugger that just ran a specific other processes of mine. When that process hit a signal the debugger poked the signal number into a fixed location in the process&#x27; memory, then changed the signal to something innocuous like SIGALRM, and let that be delivered.<p>The process&#x27; SIGALRM handler would get the original signal number that the debugger had poked in, and print some obnoxious message like &quot;Stupid sysadmin...your wimpy SIGxxx cannot hurt me!&quot; where xxx was whatever signal someone had tried to send it.<p>I then told my fellow admins I had a stuck process that I could not kill, and asked them to kill it.<p>It took quite a while before someone got suspicious enough to suspect that the sh that was the parent of the &quot;stuck&quot; process wasn&#x27;t actually a normal shell and try killing it.</div><br/><div id="36413862" class="c"><input type="checkbox" id="c-36413862" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36413702">parent</a><span>|</span><a href="#36411378">next</a><span>|</span><label class="collapse" for="c-36413862">[-]</label><label class="expand" for="c-36413862">[1 more]</label></div><br/><div class="children"><div class="content">That is quite a story!</div><br/></div></div></div></div><div id="36411378" class="c"><input type="checkbox" id="c-36411378" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411336">parent</a><span>|</span><a href="#36413702">prev</a><span>|</span><a href="#36412609">next</a><span>|</span><label class="collapse" for="c-36411378">[-]</label><label class="expand" for="c-36411378">[3 more]</label></div><br/><div class="children"><div class="content">POSIX says that &quot;setting a trap for SIGKILL or SIGSTOP produces undefined results&quot;, but for signals it describes SIGKILL as &quot;Kill (cannot be caught or ignored)&quot;.<p>I&#x27;m guessing this is some relic from 80s Unix systems where SIGKILL behaved different, or perhaps just an inconsistency&#x2F;oversight.</div><br/><div id="36411739" class="c"><input type="checkbox" id="c-36411739" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411378">parent</a><span>|</span><a href="#36412609">next</a><span>|</span><label class="collapse" for="c-36411739">[-]</label><label class="expand" for="c-36411739">[2 more]</label></div><br/><div class="children"><div class="content">I read that as undefined in terms of how the shell itself handles it, because the OS doesn&#x27;t care.</div><br/><div id="36413377" class="c"><input type="checkbox" id="c-36413377" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411739">parent</a><span>|</span><a href="#36412609">next</a><span>|</span><label class="collapse" for="c-36413377">[-]</label><label class="expand" for="c-36413377">[1 more]</label></div><br/><div class="children"><div class="content">I think it means that it is valid for OSes to return an error instead of doing nothing, if you attempt it.</div><br/></div></div></div></div></div></div></div></div><div id="36412609" class="c"><input type="checkbox" id="c-36412609" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411051">parent</a><span>|</span><a href="#36411336">prev</a><span>|</span><a href="#36411155">next</a><span>|</span><label class="collapse" for="c-36412609">[-]</label><label class="expand" for="c-36412609">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t, though probably common for a parent to spin off a child and handle the SIGKILLed child via waitpid().</div><br/></div></div><div id="36411155" class="c"><input type="checkbox" id="c-36411155" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411051">parent</a><span>|</span><a href="#36412609">prev</a><span>|</span><a href="#36411199">next</a><span>|</span><label class="collapse" for="c-36411155">[-]</label><label class="expand" for="c-36411155">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what they put on the ticket, so that&#x27;s what I&#x27;m using, but you&#x27;re probably right.</div><br/></div></div><div id="36411199" class="c"><input type="checkbox" id="c-36411199" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411051">parent</a><span>|</span><a href="#36411155">prev</a><span>|</span><a href="#36411377">next</a><span>|</span><label class="collapse" for="c-36411199">[-]</label><label class="expand" for="c-36411199">[1 more]</label></div><br/><div class="children"><div class="content">SIGABRT is also not a normal termination signal. Seems out of place here.</div><br/></div></div></div></div><div id="36411377" class="c"><input type="checkbox" id="c-36411377" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#36410411">parent</a><span>|</span><a href="#36411051">prev</a><span>|</span><a href="#36410784">next</a><span>|</span><label class="collapse" for="c-36411377">[-]</label><label class="expand" for="c-36411377">[7 more]</label></div><br/><div class="children"><div class="content">I think you want:<p><pre><code>  trap &#x27;ssh-agent -k&#x27; EXIT INT TERM
</code></pre>
I don&#x27;t see any reason for the eval as &quot;ssh-agent -k&quot; doesn&#x27;t return anything useful you want the shell to evaluate.</div><br/><div id="36411557" class="c"><input type="checkbox" id="c-36411557" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411377">parent</a><span>|</span><a href="#36410784">next</a><span>|</span><label class="collapse" for="c-36411557">[-]</label><label class="expand" for="c-36411557">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what the eval is for.<p>The &quot;ssh-agent -k&quot; command will emit shell commands that the shell must then execute which will kill the agent daemon and unset the socket environment variable.</div><br/><div id="36411756" class="c"><input type="checkbox" id="c-36411756" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411557">parent</a><span>|</span><a href="#36411655">next</a><span>|</span><label class="collapse" for="c-36411756">[-]</label><label class="expand" for="c-36411756">[1 more]</label></div><br/><div class="children"><div class="content">If all you care about is killing it, you don&#x27;t need to eval the output. The output just unsets two environment variables which only matters in the current shell context.<p><pre><code>  $ ssh-agent
  SSH_AUTH_SOCK=&#x2F;var&#x2F;folders&#x2F;8p&#x2F;_pwq997168s7vdwwdg_qr1j40000gn&#x2F;T&#x2F;&#x2F;ssh-DE0IoJfU5rrM&#x2F;agent.15015; export SSH_AUTH_SOCK;
  SSH_AGENT_PID=15016; export SSH_AGENT_PID;
  echo Agent pid 15016;

  $ SSH_AGENT_PID=15016; export SSH_AGENT_PID;
  $ ssh-agent -k
  unset SSH_AUTH_SOCK;
  unset SSH_AGENT_PID;
  echo Agent pid 15016 killed;
</code></pre>
That said, it doesn&#x27;t hurt to eval it, so I overstated my case in my original comment.</div><br/></div></div><div id="36411655" class="c"><input type="checkbox" id="c-36411655" checked=""/><div class="controls bullet"><span class="by">leodag</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411557">parent</a><span>|</span><a href="#36411756">prev</a><span>|</span><a href="#36410784">next</a><span>|</span><label class="collapse" for="c-36411655">[-]</label><label class="expand" for="c-36411655">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;ssh-agent -k&quot; command will emit shell commands<p>Does it really? I&#x27;ve executed it here and it just runs kill, doesn&#x27;t emit any bash. Running just ssh-agent (without any args) does that though, which is what&#x27;s probably causing the confusion.</div><br/><div id="36411799" class="c"><input type="checkbox" id="c-36411799" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411655">parent</a><span>|</span><a href="#36410784">next</a><span>|</span><label class="collapse" for="c-36411799">[-]</label><label class="expand" for="c-36411799">[3 more]</label></div><br/><div class="children"><div class="content">I am on OpenBSD 7.2, and I see:<p><pre><code>  $ eval $(ssh-agent)
  Agent pid 56785

  $ ssh-agent -k
  unset SSH_AUTH_SOCK;
  unset SSH_AGENT_PID;
  echo Agent pid 56785 killed;
</code></pre>
The correct processing of that output requires an eval.<p>Did you have any other questions?</div><br/><div id="36412560" class="c"><input type="checkbox" id="c-36412560" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36411799">parent</a><span>|</span><a href="#36410784">next</a><span>|</span><label class="collapse" for="c-36412560">[-]</label><label class="expand" for="c-36412560">[2 more]</label></div><br/><div class="children"><div class="content">Why do you need to eval it?<p>$(ssh-agent)<p>won’t substitute that with the stdout and run that?</div><br/><div id="36412789" class="c"><input type="checkbox" id="c-36412789" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36412560">parent</a><span>|</span><a href="#36410784">next</a><span>|</span><label class="collapse" for="c-36412789">[-]</label><label class="expand" for="c-36412789">[1 more]</label></div><br/><div class="children"><div class="content">Because the intended use for &quot;ssh-agent -k&quot; is for eval.<p>While redirecting to &#x2F;dev&#x2F;null will certainly work, the agent is holding sensitive credentials (by design), and confirmation of shutdown has a tangible security benefit.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36410784" class="c"><input type="checkbox" id="c-36410784" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#36410411">parent</a><span>|</span><a href="#36411377">prev</a><span>|</span><a href="#36411333">next</a><span>|</span><label class="collapse" for="c-36410784">[-]</label><label class="expand" for="c-36410784">[3 more]</label></div><br/><div class="children"><div class="content">Harsh lesson, those five signal names are identical if one squints real good. Would have never known.</div><br/><div id="36410999" class="c"><input type="checkbox" id="c-36410999" checked=""/><div class="controls bullet"><span class="by">hoherd</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36410784">parent</a><span>|</span><a href="#36411333">next</a><span>|</span><label class="collapse" for="c-36410999">[-]</label><label class="expand" for="c-36410999">[2 more]</label></div><br/><div class="children"><div class="content">`man 7 signal` on linux or just `man signal` on macOS will give you more information about the different signals, and shows what the different meanings of those are.</div><br/><div id="36411835" class="c"><input type="checkbox" id="c-36411835" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#36410411">root</a><span>|</span><a href="#36410999">parent</a><span>|</span><a href="#36411333">next</a><span>|</span><label class="collapse" for="c-36411835">[-]</label><label class="expand" for="c-36411835">[1 more]</label></div><br/><div class="children"><div class="content">&quot;kill -l&quot; gives you a terse (but complete) list.</div><br/></div></div></div></div></div></div></div></div><div id="36410186" class="c"><input type="checkbox" id="c-36410186" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#36410411">prev</a><span>|</span><a href="#36414367">next</a><span>|</span><label class="collapse" for="c-36410186">[-]</label><label class="expand" for="c-36410186">[17 more]</label></div><br/><div class="children"><div class="content">An annoying thing about bash is that EXIT will <i>also</i> run on SIGINT (^C), which most other shells won&#x27;t (in my reading it&#x27;s also not POSIX compliant, although the document is a bit vague). Some might argue this is a feature, but IMHO it&#x27;s a bug – sometimes you really <i>don&#x27;t</i> want cleanup to happen so people can inspect the contents of temporary files for debugging. Because trap doesn&#x27;t pass the signal information to the handler it&#x27;s hard to not do cleanup on SIGINT, so it&#x27;s certainly less flexible, and it&#x27;s an annoying incompatibility between bash and any other shell.<p>Also, zsh has a much nicer mechanism for the common case:<p><pre><code>  {
      echo lol
  } always {
      # Ensure *all* temporary files are cleaned up.
      nohup rm -rf &#x2F; &amp;
  }</code></pre></div><br/><div id="36411501" class="c"><input type="checkbox" id="c-36411501" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#36410186">parent</a><span>|</span><a href="#36411205">next</a><span>|</span><label class="collapse" for="c-36411501">[-]</label><label class="expand" for="c-36411501">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Because trap doesn&#x27;t pass the signal information to the handler<p>You can examine $? on entry to the trap function. On signals, it will be 128 + signal. i.e. on TERM (15) it will be 143. On INT (2) it will be 130.<p><pre><code>  #!&#x2F;bin&#x2F;bash

  skip_exit=
  on_exit() {
    code=$?
    if test $code == 130; then
      skip_exit=1
    fi
    if test -n &quot;$skip_exit&quot;; then
      return
    fi
    echo &quot;Exiting with: $code&quot;
    return $code
  }

  trap on_exit INT EXIT

  sleep 2
  false
</code></pre>
With ctrl-c:<p><pre><code>  $ .&#x2F;foo.sh
  ^C
</code></pre>
After 2 seconds:<p><pre><code>  $ .&#x2F;foo.sh
  Exiting with: 1
</code></pre>
You can also setup separate handlers for each signal and use a sentinel:<p><pre><code>  $ cat foo.sh
  #!&#x2F;bin&#x2F;bash
  
  skip_exit=
  
  on_int() {
    echo int
    skip_exit=1
  }
  
  on_exit() {
    test -n &quot;$skip_exit&quot; &amp;&amp; return
    echo exit
  }
  
  
  trap on_int INT
  trap on_exit EXIT
  
  sleep 2
</code></pre>
With ctrl-c:<p><pre><code>  $ .&#x2F;foo.sh
  ^Cint
</code></pre>
After 2 seconds:  
  $ .&#x2F;foo.sh
  exit</div><br/><div id="36413556" class="c"><input type="checkbox" id="c-36413556" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36411501">parent</a><span>|</span><a href="#36412513">next</a><span>|</span><label class="collapse" for="c-36413556">[-]</label><label class="expand" for="c-36413556">[2 more]</label></div><br/><div class="children"><div class="content">For robust code you should also use set -e.<p>This changes things again. Often a process started by the shell will get the signal, too (depends of course on how it is sent) and exit with a non-zero return value (depends on the process of course). I believe (not at the computer right now) the handler for EXIT is called in that case.<p>Was it so that bash can also trap ERR, but dash cannot?<p>It&#x27;s not perfectly easy to handle all possible cases, and certainly impossible in a fully portable way.</div><br/><div id="36414575" class="c"><input type="checkbox" id="c-36414575" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36413556">parent</a><span>|</span><a href="#36412513">next</a><span>|</span><label class="collapse" for="c-36414575">[-]</label><label class="expand" for="c-36414575">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>For robust code you should also use set -e.</i><p>Highly debatable.</div><br/></div></div></div></div><div id="36412513" class="c"><input type="checkbox" id="c-36412513" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36411501">parent</a><span>|</span><a href="#36413556">prev</a><span>|</span><a href="#36411205">next</a><span>|</span><label class="collapse" for="c-36412513">[-]</label><label class="expand" for="c-36412513">[1 more]</label></div><br/><div class="children"><div class="content">I mean, it&#x27;s possible, but it&#x27;s not exactly pretty, and it won&#x27;t necessarily work in <i>all</i> POSIX compliant shells either (although I believe it will in most, but I didn&#x27;t test – things the trap execution order and exact status codes are not exactly defined IIRC).</div><br/></div></div></div></div><div id="36411205" class="c"><input type="checkbox" id="c-36411205" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36410186">parent</a><span>|</span><a href="#36411501">prev</a><span>|</span><a href="#36412111">next</a><span>|</span><label class="collapse" for="c-36411205">[-]</label><label class="expand" for="c-36411205">[8 more]</label></div><br/><div class="children"><div class="content">Some temporary file remover. Lol indeed</div><br/><div id="36411420" class="c"><input type="checkbox" id="c-36411420" checked=""/><div class="controls bullet"><span class="by">wkat4242</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36411205">parent</a><span>|</span><a href="#36411310">next</a><span>|</span><label class="collapse" for="c-36411420">[-]</label><label class="expand" for="c-36411420">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;&#x2F; Thinks about that type I typed rm -rf &#x2F;&lt;space&gt;something by mistake.<p>It took a few seconds before I thought... &quot;Why does it take that long for only a handful of files?&quot;<p>I never did that again.<p>Had my DOS filesystem mounted under Linux too (yes that long ago), and I spent a few days guessing the first letter of each deleted file with norton disk doctor or undeleter or something. That was fun (FAT16 filesystems overwrote the first letter of each filename to delete it)<p>At least it wasn&#x27;t a mistake I made at work on some production thing. Though there is a reason I make all the desktops on windows production servers bright red. One time I was tired and shut down &quot;my laptop&quot; forgetting I was still logged into a remote server 200km away..... :&#x2F; Of course the iLO wasn&#x27;t hooked up but I was extremely happy to find that HP servers listen to wake on LAN even when they&#x27;re off. Another one for the never again books :P</div><br/></div></div><div id="36411310" class="c"><input type="checkbox" id="c-36411310" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36411205">parent</a><span>|</span><a href="#36411420">prev</a><span>|</span><a href="#36415375">next</a><span>|</span><label class="collapse" for="c-36411310">[-]</label><label class="expand" for="c-36411310">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Keep non-temporary files intact&quot; was not part of the design document.</div><br/></div></div><div id="36415375" class="c"><input type="checkbox" id="c-36415375" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36411205">parent</a><span>|</span><a href="#36411310">prev</a><span>|</span><a href="#36412591">next</a><span>|</span><label class="collapse" for="c-36415375">[-]</label><label class="expand" for="c-36415375">[2 more]</label></div><br/><div class="children"><div class="content">All files are temporary if your timespan is long enough.</div><br/><div id="36416000" class="c"><input type="checkbox" id="c-36416000" checked=""/><div class="controls bullet"><span class="by">abwizz</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36415375">parent</a><span>|</span><a href="#36412591">next</a><span>|</span><label class="collapse" for="c-36416000">[-]</label><label class="expand" for="c-36416000">[1 more]</label></div><br/><div class="children"><div class="content">my oldest file (sadly) is only from 2003.<p>how about you?</div><br/></div></div></div></div><div id="36412591" class="c"><input type="checkbox" id="c-36412591" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36411205">parent</a><span>|</span><a href="#36415375">prev</a><span>|</span><a href="#36412111">next</a><span>|</span><label class="collapse" for="c-36412591">[-]</label><label class="expand" for="c-36412591">[3 more]</label></div><br/><div class="children"><div class="content">The nice thing about temp files is that the OS will eventually remove them, even if you don&#x27;t</div><br/><div id="36413062" class="c"><input type="checkbox" id="c-36413062" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36412591">parent</a><span>|</span><a href="#36412111">next</a><span>|</span><label class="collapse" for="c-36413062">[-]</label><label class="expand" for="c-36413062">[2 more]</label></div><br/><div class="children"><div class="content">Only if Cron is set up to do it. I have hosts without &#x2F;tmp and &#x2F;var&#x2F;tmp clearance and they have data states which persist across reboot.<p>with UNIX&#x2F;POSIX systems it pays to say &quot;it depends&quot; often.</div><br/><div id="36413522" class="c"><input type="checkbox" id="c-36413522" checked=""/><div class="controls bullet"><span class="by">inadequatespace</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36413062">parent</a><span>|</span><a href="#36412111">next</a><span>|</span><label class="collapse" for="c-36413522">[-]</label><label class="expand" for="c-36413522">[1 more]</label></div><br/><div class="children"><div class="content">macOS does it on reboot, not sure if it inherited this from BSD proper</div><br/></div></div></div></div></div></div></div></div><div id="36412111" class="c"><input type="checkbox" id="c-36412111" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#36410186">parent</a><span>|</span><a href="#36411205">prev</a><span>|</span><a href="#36411183">next</a><span>|</span><label class="collapse" for="c-36412111">[-]</label><label class="expand" for="c-36412111">[1 more]</label></div><br/><div class="children"><div class="content">if you&#x27;re debugging hit ctrl+z and it will suspend the script in place</div><br/></div></div><div id="36411183" class="c"><input type="checkbox" id="c-36411183" checked=""/><div class="controls bullet"><span class="by">jcotton42</span><span>|</span><a href="#36410186">parent</a><span>|</span><a href="#36412111">prev</a><span>|</span><a href="#36410461">next</a><span>|</span><label class="collapse" for="c-36411183">[-]</label><label class="expand" for="c-36411183">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Because trap doesn&#x27;t pass the signal information to the handler it&#x27;s not hard not to do cleanup on SIGINT<p>Did you mean &quot;it&#x27;s hard&quot; instead of &quot;it&#x27;s not hard&quot;?</div><br/><div id="36411250" class="c"><input type="checkbox" id="c-36411250" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#36410186">root</a><span>|</span><a href="#36411183">parent</a><span>|</span><a href="#36410461">next</a><span>|</span><label class="collapse" for="c-36411250">[-]</label><label class="expand" for="c-36411250">[1 more]</label></div><br/><div class="children"><div class="content">Oops, yes, thanks; seems a &quot;not&quot; got duplicated in editing – still within edit window.</div><br/></div></div></div></div></div></div><div id="36414367" class="c"><input type="checkbox" id="c-36414367" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#36410186">prev</a><span>|</span><a href="#36410781">next</a><span>|</span><label class="collapse" for="c-36414367">[-]</label><label class="expand" for="c-36414367">[3 more]</label></div><br/><div class="children"><div class="content">I have given up the unequal struggle to learn Bash.<p>For me it is &quot;read only&quot;.<p>It is too arcane, even for me.<p>I use Perl now.  I tried to reform last year as I was building a system from lots of executable pieces, the perfect job for Bash<p>After much pain and suffering I re-wrote it in Perl.  What a (relative) breeze.<p>Just.  Don&#x27;t. Do. Bash.<p>Works for me!</div><br/><div id="36415788" class="c"><input type="checkbox" id="c-36415788" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#36414367">parent</a><span>|</span><a href="#36410781">next</a><span>|</span><label class="collapse" for="c-36415788">[-]</label><label class="expand" for="c-36415788">[2 more]</label></div><br/><div class="children"><div class="content">+1. Bash is riddled with absurd footguns. You want to set hack together three git commands and pipe to fzf? Fine. Anything more complex than that? Python, Perl, or any other proper programming language is there for you.</div><br/><div id="36416021" class="c"><input type="checkbox" id="c-36416021" checked=""/><div class="controls bullet"><span class="by">abwizz</span><span>|</span><a href="#36414367">root</a><span>|</span><a href="#36415788">parent</a><span>|</span><a href="#36410781">next</a><span>|</span><label class="collapse" for="c-36416021">[-]</label><label class="expand" for="c-36416021">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;d argue that every language is somewhat imperfect, but there is something to be said in favor of pitfalls&#x2F;footguns&#x2F;inperfections that are somewhat well defined and understood for more than a decade.</div><br/></div></div></div></div></div></div><div id="36410781" class="c"><input type="checkbox" id="c-36410781" checked=""/><div class="controls bullet"><span class="by">abathur</span><span>|</span><a href="#36414367">prev</a><span>|</span><a href="#36411893">next</a><span>|</span><label class="collapse" for="c-36410781">[-]</label><label class="expand" for="c-36410781">[4 more]</label></div><br/><div class="children"><div class="content">I like combining this with a bash implementation of an event API (<a href="https:&#x2F;&#x2F;github.com&#x2F;bashup&#x2F;events">https:&#x2F;&#x2F;github.com&#x2F;bashup&#x2F;events</a>). This makes it easy&#x2F;idiomatic, for example, to conditionally add cleanup as you go.<p>Glossing over some complexity, but roughly:<p><pre><code>    add_cleanup(){
        event on cleanup &quot;$@&quot;
    }
    
    trap &quot;event emit &#x27;cleanup&#x27;&quot; HUP EXIT
    
    start_postgres(){
        add_cleanup stop_postgres
        # actually start pg
    }
    
    start_apache(){
        add_cleanup stop_apache
        # actually start apache
    }
</code></pre>
I wrote a little about some other places where I&#x27;ve used it in <a href="https:&#x2F;&#x2F;www.t-ravis.com&#x2F;post&#x2F;shell&#x2F;neighborly_shell_with_bashup.events&#x2F;#a-quick-look-at-bashupevents" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.t-ravis.com&#x2F;post&#x2F;shell&#x2F;neighborly_shell_with_bas...</a> and <a href="https:&#x2F;&#x2F;t-ravis.com&#x2F;post&#x2F;nix&#x2F;avoid_trap_clobbering_in_nix-shell&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;t-ravis.com&#x2F;post&#x2F;nix&#x2F;avoid_trap_clobbering_in_nix-sh...</a> (though I make the best use of it in my private bootstrap and backup scripts...)</div><br/><div id="36411831" class="c"><input type="checkbox" id="c-36411831" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#36410781">parent</a><span>|</span><a href="#36411893">next</a><span>|</span><label class="collapse" for="c-36411831">[-]</label><label class="expand" for="c-36411831">[3 more]</label></div><br/><div class="children"><div class="content">Thank you for sharing - if i understand the code, the queue is serialized into bash variable(s) (arrays)?<p>I must admit I find the code somewhat painfully terse and hard to read.<p>Still, interesting idea. I wonder if using a temporary SQLite&#x2F;Berkeley DB&#x2F;etc for queue might generalize the idea to a &quot;Unix&quot; event system - allowing other programs and scripts to use it for coordinating? (Like logger(1) does for logging)?</div><br/><div id="36412699" class="c"><input type="checkbox" id="c-36412699" checked=""/><div class="controls bullet"><span class="by">abathur</span><span>|</span><a href="#36410781">root</a><span>|</span><a href="#36411831">parent</a><span>|</span><a href="#36411893">next</a><span>|</span><label class="collapse" for="c-36412699">[-]</label><label class="expand" for="c-36412699">[2 more]</label></div><br/><div class="children"><div class="content">Yep. Definitely something you can do manually, but the API makes it easier to reason about and coordinate across otherwise disconnected&#x2F;unrelated code.</div><br/><div id="36412928" class="c"><input type="checkbox" id="c-36412928" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#36410781">root</a><span>|</span><a href="#36412699">parent</a><span>|</span><a href="#36411893">next</a><span>|</span><label class="collapse" for="c-36412928">[-]</label><label class="expand" for="c-36412928">[1 more]</label></div><br/><div class="children"><div class="content">Was thinking more as a &quot;global&quot; queue (like how psql&#x2F;libpq will go look for a socket to local postgres in &quot;the right place&quot;) - and a binary&#x2F;program &quot;event&quot; could &quot;magically&quot; store (&quot;on&quot;) and process (&quot;emit&quot;) events in a db file &#x2F;tmp&#x2F;event.&lt;namespace&gt;&lt;random&gt;.sqlite3 - creating&#x2F;initializing or re-using db file as needed...<p>So keep the api, but support cross process queues, more or less.</div><br/></div></div></div></div></div></div></div></div><div id="36411893" class="c"><input type="checkbox" id="c-36411893" checked=""/><div class="controls bullet"><span class="by">ch33zer</span><span>|</span><a href="#36410781">prev</a><span>|</span><a href="#36411499">next</a><span>|</span><label class="collapse" for="c-36411893">[-]</label><label class="expand" for="c-36411893">[4 more]</label></div><br/><div class="children"><div class="content">Should go without saying, but don&#x27;t rely on this for anything critical. It&#x27;s not guaranteed this will run, even on successful completion of the script. Simple example: power is cut between the last line of the script and before the trap runs. Just a heads up</div><br/><div id="36412098" class="c"><input type="checkbox" id="c-36412098" checked=""/><div class="controls bullet"><span class="by">hermannj314</span><span>|</span><a href="#36411893">parent</a><span>|</span><a href="#36413502">next</a><span>|</span><label class="collapse" for="c-36412098">[-]</label><label class="expand" for="c-36412098">[2 more]</label></div><br/><div class="children"><div class="content">If you were building a critical system, what would do if power is cut after the last line of a script runs?</div><br/><div id="36412200" class="c"><input type="checkbox" id="c-36412200" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#36411893">root</a><span>|</span><a href="#36412098">parent</a><span>|</span><a href="#36413502">next</a><span>|</span><label class="collapse" for="c-36412200">[-]</label><label class="expand" for="c-36412200">[1 more]</label></div><br/><div class="children"><div class="content">Idempotency is usually the best approach - have each step of a process examine the state of the disk and act only if it&#x27;s an appropriate input then output something that isn&#x27;t an appropriate input.  Assuming you can ignore midstream corruption (which can safely be done by adding an atomically safe linking layer on top) then if power suddenly cuts out reboot and run the script until a clause finds an appropriate input and executes it continuing from there.<p>The concepts are simple, the implementation is a pain and (honestly) if you need something truly resilient you&#x27;re probably better off leaning on a system that can provide that guarantee for you (like using a database for state storage).</div><br/></div></div></div></div><div id="36413502" class="c"><input type="checkbox" id="c-36413502" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#36411893">parent</a><span>|</span><a href="#36412098">prev</a><span>|</span><a href="#36411499">next</a><span>|</span><label class="collapse" for="c-36413502">[-]</label><label class="expand" for="c-36413502">[1 more]</label></div><br/><div class="children"><div class="content">Not even a power cut- a SIGKILL (such as an OOMKill) is enough to cause the trap not to be run.</div><br/></div></div></div></div><div id="36411499" class="c"><input type="checkbox" id="c-36411499" checked=""/><div class="controls bullet"><span class="by">filereaper</span><span>|</span><a href="#36411893">prev</a><span>|</span><a href="#36412027">next</a><span>|</span><label class="collapse" for="c-36411499">[-]</label><label class="expand" for="c-36411499">[10 more]</label></div><br/><div class="children"><div class="content">&gt;The secret sauce is a pseudo-signal provided by bash, called EXIT, that you can trap; commands or functions trapped on it will execute when the script exits for any reason.<p>&quot;Secret Sauce&quot;, why is this secret at all.<p>Nothing against the author who&#x27;s helping the ecosystem here, but is there an authoritative guide on Bash that anyone can recommend?<p>Hopefully something that&#x27;s portable between Mac &amp; Linux.<p>The web is full of contradictory guides and shellcheck seems to be the last line of defense.<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;koalaman&#x2F;shellcheck">https:&#x2F;&#x2F;github.com&#x2F;koalaman&#x2F;shellcheck</a></div><br/><div id="36412189" class="c"><input type="checkbox" id="c-36412189" checked=""/><div class="controls bullet"><span class="by">inimino</span><span>|</span><a href="#36411499">parent</a><span>|</span><a href="#36412101">next</a><span>|</span><label class="collapse" for="c-36412189">[-]</label><label class="expand" for="c-36412189">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s secret enough to be well documented in the man page. The real question is, why do people look to random web pages prior to having digested everything in the manual? People used to say &quot;rtfm&quot; all the time, this would be regarded as shockingly rude in today&#x27;s tech culture but it was a valuable public service to have it repeated, like being reminded to eat your vegetables.</div><br/><div id="36412330" class="c"><input type="checkbox" id="c-36412330" checked=""/><div class="controls bullet"><span class="by">joshSzep</span><span>|</span><a href="#36411499">root</a><span>|</span><a href="#36412189">parent</a><span>|</span><a href="#36412271">next</a><span>|</span><label class="collapse" for="c-36412330">[-]</label><label class="expand" for="c-36412330">[4 more]</label></div><br/><div class="children"><div class="content">Because ain&#x27;t nobody got time for that. ;)<p>More seriously, I think that we have been trained to rely on just in time searches (or ChatGPT sessions) when we encounter the next thing we need to learn. RTFM is just so time consuming and I personally don&#x27;t recall everything I have read, leading me to rely on search&#x2F;AI to re-learn the next thing just in time anyways.<p>In some ways this is a vast improvement, which is why it&#x27;s the default behavior now. Why cream your brain with information you might never use?<p>But it DEFINITELY has a weakness in that you don&#x27;t know what you don&#x27;t know. I never knew about this &#x27;trap&#x27; trick, for example... and I didn&#x27;t know I didn&#x27;t know it, despite it being something I see as quite useful.<p>Side note: I think RTFM has historically meant &quot;try to find the answer first before asking for it&quot;, leading to me designating LMGTFY (Let Me Google That For You) as the modern equivalent in this just in time searches reality we live in. I wonder how long it will be before we start saying LMAAIFY (Let Me Ask AI For You)...</div><br/><div id="36413146" class="c"><input type="checkbox" id="c-36413146" checked=""/><div class="controls bullet"><span class="by">inimino</span><span>|</span><a href="#36411499">root</a><span>|</span><a href="#36412330">parent</a><span>|</span><a href="#36415120">next</a><span>|</span><label class="collapse" for="c-36413146">[-]</label><label class="expand" for="c-36413146">[2 more]</label></div><br/><div class="children"><div class="content">The thing is that reading the manual isn&#x27;t easy. If it was, everyone would do it, because the benefit is that, eventually, you know every topic or section that appears in the bash man page, and then eventually you know most of what that page says about most of those features. These efforts compound over time. If you reach that point, you know that if you don&#x27;t know of a feature in that software, it doesn&#x27;t exist. You eventually get a shape of the feature set, often as it was intended to be used by the author of the tool.<p>You can spend twice as much time over twice as many years reading random blog posts and googling, and you&#x27;ll have no cohesive, comprehensive picture of the full tool and all its features. In this case, if you look at `man bash` and find the trap builtin function you&#x27;ll learn about the DEBUG and ERR traps, for example, which I didn&#x27;t see mentioned in the discussion here. These things might be useful to just file away; in case you ever need it someday, then you&#x27;ll know it&#x27;s there and exactly where to find it, not some half-remembered blog post you can&#x27;t find again.<p>Over ten or twenty years, the difference between these two habits is night and day. The people who read the documentation first, and only then ask for help, and the people who ask for help first and get it and so never read the docs, end up in a totally different place with respect to overall confidence and comfort with the tools. Reading the man page means you don&#x27;t get your answer right away, it&#x27;s slower, less enjoyable, and less fun than googling. It&#x27;s competing with content that was literally filtered by an engagement selection process. Of <i>course</i> it&#x27;s less immediate gratification. The only reason people will do it is if they internalize the habit long enough to appreciate the benefits.<p>&quot;RTFM&quot; was a bit of social shaming, to tell people &quot;don&#x27;t be lazy, the answer you seek is literally in the documentation, please just read it&quot;. Shaming strangers on the internet turns out to not work well at scale, so generally we don&#x27;t do this now, and the message just doesn&#x27;t get passed on at all.<p>I&#x27;ve been shocked at the attitude even in some companies that reading docs is some kind of unnecessary or obsolete practice. As you say, it&#x27;s become the default option to seek answers online. A culture of reading documentation still exists, but now it has to be maintained inside organizations that care about it, because it&#x27;s no longer understood as the basic professional attitude.</div><br/><div id="36413814" class="c"><input type="checkbox" id="c-36413814" checked=""/><div class="controls bullet"><span class="by">joshSzep</span><span>|</span><a href="#36411499">root</a><span>|</span><a href="#36413146">parent</a><span>|</span><a href="#36415120">next</a><span>|</span><label class="collapse" for="c-36413814">[-]</label><label class="expand" for="c-36413814">[1 more]</label></div><br/><div class="children"><div class="content">Excellent comment, inimino.<p>&gt; Over ten or twenty years, the difference between these two habits is night and day. The people who read the documentation first, and only then ask for help, and the people who ask for help first and get it and so never read the docs, end up in a totally different place with respect to overall confidence and comfort with the tools.<p>Ooof! This one&#x27;s hit home.</div><br/></div></div></div></div></div></div><div id="36412271" class="c"><input type="checkbox" id="c-36412271" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#36411499">root</a><span>|</span><a href="#36412189">parent</a><span>|</span><a href="#36412330">prev</a><span>|</span><a href="#36412773">next</a><span>|</span><label class="collapse" for="c-36412271">[-]</label><label class="expand" for="c-36412271">[1 more]</label></div><br/><div class="children"><div class="content">Possibly?  At this point there are a lot of manuals out there and it&#x27;s unreasonable to try and read them all.  Developers work with a plethora of tools and I think modern tools are getting better at not being surprising but some of these old tools have design choices that differ from modern habits.<p>I think this might be a bit easier to appreciate if you&#x27;ve ever worked at a young company and made choices because you have to (oh, we&#x27;ll use MySQL, that sounds better than Postgres) and then give yourself an extra three months work in two years when you finally come up against a shortcoming in the tech.  We have to make an awful lot of decisions and generally don&#x27;t have the budget in time or money to fully grok the options we&#x27;re deciding between.</div><br/></div></div><div id="36412773" class="c"><input type="checkbox" id="c-36412773" checked=""/><div class="controls bullet"><span class="by">abathur</span><span>|</span><a href="#36411499">root</a><span>|</span><a href="#36412189">parent</a><span>|</span><a href="#36412271">prev</a><span>|</span><a href="#36412101">next</a><span>|</span><label class="collapse" for="c-36412773">[-]</label><label class="expand" for="c-36412773">[1 more]</label></div><br/><div class="children"><div class="content">As an aside, I love fat manuals (and change&#x2F;release notes) that have a bit of interesting arcana tucked away in one or two calm sentences here and there.<p>Not that I regularly read them all myself, but it&#x27;s nice to be rewarded with a new dark art (like alias-based ~metaprogramming) every once in a while.</div><br/></div></div></div></div><div id="36412101" class="c"><input type="checkbox" id="c-36412101" checked=""/><div class="controls bullet"><span class="by">r3trohack3r</span><span>|</span><a href="#36411499">parent</a><span>|</span><a href="#36412189">prev</a><span>|</span><a href="#36413988">next</a><span>|</span><label class="collapse" for="c-36412101">[-]</label><label class="expand" for="c-36412101">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if it checks the right box as authoritative, but my goto guide has been tldp:<p><a href="https:&#x2F;&#x2F;tldp.org&#x2F;LDP&#x2F;abs&#x2F;html&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tldp.org&#x2F;LDP&#x2F;abs&#x2F;html&#x2F;</a></div><br/></div></div><div id="36413988" class="c"><input type="checkbox" id="c-36413988" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#36411499">parent</a><span>|</span><a href="#36412101">prev</a><span>|</span><a href="#36412027">next</a><span>|</span><label class="collapse" for="c-36413988">[-]</label><label class="expand" for="c-36413988">[1 more]</label></div><br/><div class="children"><div class="content">Clearly it&#x27;s a rhetorical device that may be a bit more heavy handed than one you&#x27;d used.</div><br/></div></div></div></div><div id="36412027" class="c"><input type="checkbox" id="c-36412027" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#36411499">prev</a><span>|</span><a href="#36414475">next</a><span>|</span><label class="collapse" for="c-36412027">[-]</label><label class="expand" for="c-36412027">[10 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t use traps unless you have to. They are subtly complex and require a great deal more code to deal with edge cases. There is almost always a simpler way to accomplish what you want.<p>If Bash has taught me anything, it&#x27;s that many advanced features should seldom be used. Always resist the temptation to be fancy.</div><br/><div id="36415143" class="c"><input type="checkbox" id="c-36415143" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36412027">parent</a><span>|</span><a href="#36412047">next</a><span>|</span><label class="collapse" for="c-36415143">[-]</label><label class="expand" for="c-36415143">[1 more]</label></div><br/><div class="children"><div class="content">If Bash has taught me anything it&#x27;s that Bash should seldom be used. Always resist the temptation to be lazy.</div><br/></div></div><div id="36412047" class="c"><input type="checkbox" id="c-36412047" checked=""/><div class="controls bullet"><span class="by">thelastparadise</span><span>|</span><a href="#36412027">parent</a><span>|</span><a href="#36415143">prev</a><span>|</span><a href="#36414171">next</a><span>|</span><label class="collapse" for="c-36412047">[-]</label><label class="expand" for="c-36412047">[7 more]</label></div><br/><div class="children"><div class="content">How have exit traps come back to bite you?</div><br/><div id="36412079" class="c"><input type="checkbox" id="c-36412079" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#36412027">root</a><span>|</span><a href="#36412047">parent</a><span>|</span><a href="#36412456">next</a><span>|</span><label class="collapse" for="c-36412079">[-]</label><label class="expand" for="c-36412079">[4 more]</label></div><br/><div class="children"><div class="content">The first is that the trap can come at any time. You can&#x27;t assume at what point in the script it was running, so you have to test for different cases to find out what you now can&#x2F;should do. Forget an edge case and now you&#x27;ve got an extra bug. Not using traps, it&#x27;s clearer what happens at specific points in the execution of the rest of the code, so simpler to reason about how to deal with those cases as&#x2F;where they happen.<p>The second is different events can trigger an exit trap, and those may have different implications on what&#x27;s going on.<p>The third is there&#x27;s parts of standards left out about what happens during&#x2F;after a trap or when they get called, what data you have available, and different implementations can behave differently.<p>Fourth is that sometimes people will use an exit trap to, say, report on a failure, but they may have lost context of what block they were in when it exited, and now the error reporting doesn&#x27;t tell you everything you wanted to know.<p>I can&#x27;t remember more specifics atm because I stopped using them like a decade ago. I&#x27;ll still use them to clean up temp files, but I also have to add the cleanup logic to the start of the script in case it didn&#x27;t run.</div><br/><div id="36412276" class="c"><input type="checkbox" id="c-36412276" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#36412027">root</a><span>|</span><a href="#36412079">parent</a><span>|</span><a href="#36412266">next</a><span>|</span><label class="collapse" for="c-36412276">[-]</label><label class="expand" for="c-36412276">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a bit more nuance in my opinion.<p>If your cleanup logic is no more complicated than &quot;perform some cleanup whenever the script exits for any reason, without concern for what state the things to clean up are in&quot;, I think trapping everything and calling  the cleanup function is fine.<p>If you have to do anything more complicated, it&#x27;s <i>probably</i> a better idea to stick all that logic into a non-bash program. You can do it in Bash if you know what you&#x27;re doing, but it&#x27;s going to be ugly, hacky, error-prone, and tedious.<p><pre><code>    Not using traps, it&#x27;s clearer what happens at specific points in the execution of the rest of the code, so simpler to reason about how to deal with those cases as&#x2F;where they happen.
</code></pre>
You <i>can</i> stick all kinds of logic into the cleanup function, but again, it&#x27;s ugly.<p><pre><code>    The second is different events can trigger an exit trap, and those may have different implications on what&#x27;s going on.
    The third is there&#x27;s parts of standards left out about what happens during&#x2F;after a trap or when they get called, what data you have available, and different implementations can behave differently.
</code></pre>
Which is why I think it&#x27;s preferable not to do this in bash if you have any concern for <i>why</i> the program is exiting<p><pre><code>    Fourth is that sometimes people will use an exit trap to, say, report on a failure, but they may have lost context of what block they were in when it exited, and now the error reporting doesn&#x27;t tell you everything you wanted to know.
</code></pre>
If you need any tracing, the only way this makes sense in bash is when running with -evx (errexit, verbose, trace) so you know exactly where you exited. This isn&#x27;t always a bad idea, though -vx probably is most of the time.<p>If you think you can do any complex logic in the trap function then you have to consider whether <i>that logic</i> might fail at any point, and depending on the signal there&#x27;s a good chance you&#x27;re on a clock as well.</div><br/></div></div><div id="36412266" class="c"><input type="checkbox" id="c-36412266" checked=""/><div class="controls bullet"><span class="by">xmprt</span><span>|</span><a href="#36412027">root</a><span>|</span><a href="#36412079">parent</a><span>|</span><a href="#36412276">prev</a><span>|</span><a href="#36412456">next</a><span>|</span><label class="collapse" for="c-36412266">[-]</label><label class="expand" for="c-36412266">[2 more]</label></div><br/><div class="children"><div class="content">As with most things in programming, it sounds like if you use the wrong tool for the wrong job, then you&#x27;re prone to writing bugs. Using traps is a great idea when used properly and dismissing it outright isn&#x27;t doing anyone any favors.</div><br/><div id="36412355" class="c"><input type="checkbox" id="c-36412355" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#36412027">root</a><span>|</span><a href="#36412266">parent</a><span>|</span><a href="#36412456">next</a><span>|</span><label class="collapse" for="c-36412355">[-]</label><label class="expand" for="c-36412355">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you but also the person you&#x27;re responding to; I think the article sells traps too hard as a handy multi-purpose tool like a swiss army knife, when they&#x27;re really more like a letter-opener; there are situations where it makes sense to use them, but you&#x27;d usually be better off with something else, and not knowing the difference can result in trying to use it as a precision blade, which ends up mangling things.</div><br/></div></div></div></div></div></div><div id="36412456" class="c"><input type="checkbox" id="c-36412456" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#36412027">root</a><span>|</span><a href="#36412047">parent</a><span>|</span><a href="#36412079">prev</a><span>|</span><a href="#36414171">next</a><span>|</span><label class="collapse" for="c-36412456">[-]</label><label class="expand" for="c-36412456">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    # usage : utility NEW_DIRECTORY -- user : I think not
    #
    trap &#x27;cleanup&#x27; INT HUP TERM
    cleanup() { rm -rf &quot;${mydir}&quot; ;}
    
    # stuff
    mydir=&quot;${HOME}&#x2F;$1&quot; # but $1 is empty
    if test -z &quot;$1&quot;; then
        # handle; but while stuff is happening,
        # user presses Ctrl-C
    fi</code></pre></div><br/></div></div></div></div><div id="36414171" class="c"><input type="checkbox" id="c-36414171" checked=""/><div class="controls bullet"><span class="by">dangus</span><span>|</span><a href="#36412027">parent</a><span>|</span><a href="#36412047">prev</a><span>|</span><a href="#36414475">next</a><span>|</span><label class="collapse" for="c-36414171">[-]</label><label class="expand" for="c-36414171">[1 more]</label></div><br/><div class="children"><div class="content">In my mind, as soon as you approach anything remotely resembling &quot;fancy,&quot; you should move on to a different language or framework that isn&#x27;t a bash or shell script at all.<p>I start questioning whether I should be writing bash as soon as I hit about ten lines. I won&#x27;t even consider writing functions or loops.<p>If I&#x27;m manipulating the system, I&#x27;m probably using configuration management, and for most other tasks, I&#x27;m using a full-blown programming language with a nice set of standard libraries.<p>E.g., Python and Ansible.</div><br/></div></div></div></div><div id="36414475" class="c"><input type="checkbox" id="c-36414475" checked=""/><div class="controls bullet"><span class="by">chrismarlow9</span><span>|</span><a href="#36412027">prev</a><span>|</span><a href="#36410025">next</a><span>|</span><label class="collapse" for="c-36414475">[-]</label><label class="expand" for="c-36414475">[3 more]</label></div><br/><div class="children"><div class="content">Just as an alternative suggestion, consider using a &quot;down file&quot; instead if you can and letting the code gracefully end. Plus you get to write &quot;touch down&quot; and do an end zone dance.</div><br/><div id="36414544" class="c"><input type="checkbox" id="c-36414544" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#36414475">parent</a><span>|</span><a href="#36410025">next</a><span>|</span><label class="collapse" for="c-36414544">[-]</label><label class="expand" for="c-36414544">[2 more]</label></div><br/><div class="children"><div class="content">I think you need to be a little more specific about what the &quot;down file&quot; is for, especially since you can&#x27;t for google it.</div><br/><div id="36414654" class="c"><input type="checkbox" id="c-36414654" checked=""/><div class="controls bullet"><span class="by">chrismarlow9</span><span>|</span><a href="#36414475">root</a><span>|</span><a href="#36414544">parent</a><span>|</span><a href="#36410025">next</a><span>|</span><label class="collapse" for="c-36414654">[-]</label><label class="expand" for="c-36414654">[1 more]</label></div><br/><div class="children"><div class="content">Apologies. It&#x27;s for ending execution prematurely. Here&#x27;s an example:<p>while true; do<p><pre><code>  echo hello

  test -f down &amp;&amp; exit
</code></pre>
done<p>Now to stop early you execute &quot;touch down&quot;.</div><br/></div></div></div></div></div></div><div id="36410025" class="c"><input type="checkbox" id="c-36410025" checked=""/><div class="controls bullet"><span class="by">phh</span><span>|</span><a href="#36414475">prev</a><span>|</span><a href="#36410512">next</a><span>|</span><label class="collapse" for="c-36410025">[-]</label><label class="expand" for="c-36410025">[1 more]</label></div><br/><div class="children"><div class="content">This 100%.<p>I&#x27;ll complete with patterns I&#x27;m using for exit traps:<p>- for temporary files I have a global array that lists files to remove (and for my use case umount them beforehand)<p>- in the EC2 example, I add a line with just &quot;bash&quot;, so I have an env with the container still running to debug what happened and I just need to close that shell to clear the allocated resources</div><br/></div></div><div id="36410512" class="c"><input type="checkbox" id="c-36410512" checked=""/><div class="controls bullet"><span class="by">ipnon</span><span>|</span><a href="#36410025">prev</a><span>|</span><a href="#36410969">next</a><span>|</span><label class="collapse" for="c-36410512">[-]</label><label class="expand" for="c-36410512">[1 more]</label></div><br/><div class="children"><div class="content">I just learned about these through “pair” programming with ChatGPT. It is the quintessential ML-enhanced programming trick: Using some old, robust language feature I’m skilled enough to grok but never had the time to learn about through endless documentation spelunking.<p>My opinion is that LLM pair programming is most or maybe only beneficial to already skilled programmers. ChatGPT can open the door for you, but it can’t show you where the door is. I needed the experience to ask it for a Bash script that handles exit codes gracefully, which is not a question all junior programmers would be able to ask.</div><br/></div></div><div id="36410969" class="c"><input type="checkbox" id="c-36410969" checked=""/><div class="controls bullet"><span class="by">telotortium</span><span>|</span><a href="#36410512">prev</a><span>|</span><a href="#36413106">next</a><span>|</span><label class="collapse" for="c-36410969">[-]</label><label class="expand" for="c-36410969">[1 more]</label></div><br/><div class="children"><div class="content">@redsymbol your site has a TLS certificate error. On Chrome I get NET::ERR_CERT_COMMON_NAME_INVALID because your certificate is from mobilewebup.com<p>Otherwise a good article. I use the following code to enable passing the signal name to the trap handler, so that I can kill the Bash process with the correct signal name, which is best practice for Unix signal handling (EXIT would have to be handled specially in `sig_rekill`):<p><pre><code>    # Set trap for several signals and pass signal name to trap function.
    # https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;2183063&#x2F;207384
    trap_with_arg() {
        func=&quot;$1&quot; ; shift
        for sig ; do
            trap &quot;$func $sig&quot; &quot;$sig&quot;
        done
    }
    sig_rekill() {
        # Kill whole process group.
        trap &quot;$1&quot;; kill -&quot;$1&quot; -$$
    }
    # Catch signal and kill whole process group.
    trap_with_arg sig_rekill HUP INT QUIT PIPE TERM</code></pre></div><br/></div></div><div id="36413106" class="c"><input type="checkbox" id="c-36413106" checked=""/><div class="controls bullet"><span class="by">ranger207</span><span>|</span><a href="#36410969">prev</a><span>|</span><a href="#36411636">next</a><span>|</span><label class="collapse" for="c-36413106">[-]</label><label class="expand" for="c-36413106">[1 more]</label></div><br/><div class="children"><div class="content">Related, but I use exit traps (or actually ERR traps) to make debugging bash scripts at runtime a little easier. This will print the number of the line of the script that failed along with any error messages from the line that failed. This is useful if for whatever reason your logging system or whatever doesn&#x27;t capture stderr<p>```<p>failure() {<p><pre><code>  local lineno=&quot;$1&quot;

  local msg=&quot;$2&quot;

  echo &quot;Failed at ${lineno}: ${msg}&quot;
</code></pre>
}<p>trap &#x27;failure &quot;$LINENO&quot; &quot;BASH_COMMAND&quot;&#x27; ERR<p>```</div><br/></div></div><div id="36411636" class="c"><input type="checkbox" id="c-36411636" checked=""/><div class="controls bullet"><span class="by">rgrau</span><span>|</span><a href="#36413106">prev</a><span>|</span><a href="#36411134">next</a><span>|</span><label class="collapse" for="c-36411636">[-]</label><label class="expand" for="c-36411636">[1 more]</label></div><br/><div class="children"><div class="content">I couldn&#x27;t find a way to have more than one callback per signal, and created a system to have an array of callbacks:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kidd&#x2F;scripting-field-guide&#x2F;blob&#x2F;master&#x2F;book.org#array-of-callbacks-on_exit">https:&#x2F;&#x2F;github.com&#x2F;kidd&#x2F;scripting-field-guide&#x2F;blob&#x2F;master&#x2F;bo...</a><p>A nice bonus is that it also keeps the return value of the last non-callback function, so your script behaves better when called from other scripts.</div><br/></div></div><div id="36411134" class="c"><input type="checkbox" id="c-36411134" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#36411636">prev</a><span>|</span><a href="#36411260">next</a><span>|</span><label class="collapse" for="c-36411134">[-]</label><label class="expand" for="c-36411134">[1 more]</label></div><br/><div class="children"><div class="content">I like to use these in combination with set -e and report the error that happened to whatever is capturing stdout for logging.<p>You can report the error code with $? at the start of your trap, IIRC.</div><br/></div></div><div id="36411260" class="c"><input type="checkbox" id="c-36411260" checked=""/><div class="controls bullet"><span class="by">waselighis</span><span>|</span><a href="#36411134">prev</a><span>|</span><a href="#36412625">next</a><span>|</span><label class="collapse" for="c-36411260">[-]</label><label class="expand" for="c-36411260">[3 more]</label></div><br/><div class="children"><div class="content">I wish there was a nicer shell scripting language that simply transpiled to Bash and would generate all this boilerplate code for me. There is <a href="https:&#x2F;&#x2F;batsh.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;batsh.org&#x2F;</a> which has a nice syntax but it doesn&#x27;t even support pipes or redirection, making it pretty worthless for shell scripting. I haven&#x27;t found any other such scripting languages.</div><br/><div id="36411353" class="c"><input type="checkbox" id="c-36411353" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36411260">parent</a><span>|</span><a href="#36412625">next</a><span>|</span><label class="collapse" for="c-36411353">[-]</label><label class="expand" for="c-36411353">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the difference between that and Go?</div><br/><div id="36411534" class="c"><input type="checkbox" id="c-36411534" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#36411260">root</a><span>|</span><a href="#36411353">parent</a><span>|</span><a href="#36412625">next</a><span>|</span><label class="collapse" for="c-36411534">[-]</label><label class="expand" for="c-36411534">[1 more]</label></div><br/><div class="children"><div class="content">Go doesnt seem related at all?</div><br/></div></div></div></div></div></div><div id="36412625" class="c"><input type="checkbox" id="c-36412625" checked=""/><div class="controls bullet"><span class="by">collinvandyck76</span><span>|</span><a href="#36411260">prev</a><span>|</span><a href="#36412122">next</a><span>|</span><label class="collapse" for="c-36412625">[-]</label><label class="expand" for="c-36412625">[1 more]</label></div><br/><div class="children"><div class="content">I like this but the lazy part of me just treats anything i write into $(mktemp -d) as something that will be eventually GC&#x27;d by the operating system. I have no idea when it actually happens, or if it does at all, but that&#x27;s how i roll.</div><br/></div></div><div id="36412122" class="c"><input type="checkbox" id="c-36412122" checked=""/><div class="controls bullet"><span class="by">michaelmior</span><span>|</span><a href="#36412625">prev</a><span>|</span><a href="#36413935">next</a><span>|</span><label class="collapse" for="c-36412122">[-]</label><label class="expand" for="c-36412122">[4 more]</label></div><br/><div class="children"><div class="content">&gt; and may have security implications too<p>While it&#x27;s certainly true that leaving around files with sensitive data is a security problem, you probably don&#x27;t want to put sensitive data in &#x2F;tmp to begin with.</div><br/><div id="36412131" class="c"><input type="checkbox" id="c-36412131" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36412122">parent</a><span>|</span><a href="#36413935">next</a><span>|</span><label class="collapse" for="c-36412131">[-]</label><label class="expand" for="c-36412131">[3 more]</label></div><br/><div class="children"><div class="content">Why not?</div><br/><div id="36412226" class="c"><input type="checkbox" id="c-36412226" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#36412122">root</a><span>|</span><a href="#36412131">parent</a><span>|</span><a href="#36413935">next</a><span>|</span><label class="collapse" for="c-36412226">[-]</label><label class="expand" for="c-36412226">[2 more]</label></div><br/><div class="children"><div class="content">The program could get paused mid-execution. Moreover, I’m pretty sure a malicious process can put file watchers in &#x2F;tmp and read all written contents.</div><br/><div id="36412536" class="c"><input type="checkbox" id="c-36412536" checked=""/><div class="controls bullet"><span class="by">ericbarrett</span><span>|</span><a href="#36412122">root</a><span>|</span><a href="#36412226">parent</a><span>|</span><a href="#36413935">next</a><span>|</span><label class="collapse" for="c-36412536">[-]</label><label class="expand" for="c-36412536">[1 more]</label></div><br/><div class="children"><div class="content">If your script calls<p><pre><code>  umask 077
</code></pre>
...before creating temp files then they won&#x27;t be world-readable. Still lots of pitfalls. (What user are you running as, and who else is running as that user? What&#x27;s the mount point file system, and does it have POSIX permissions? Why are you persisting secrets to disk in the first place? Etc.)</div><br/></div></div></div></div></div></div></div></div><div id="36413935" class="c"><input type="checkbox" id="c-36413935" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#36412122">prev</a><span>|</span><a href="#36412358">next</a><span>|</span><label class="collapse" for="c-36413935">[-]</label><label class="expand" for="c-36413935">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like a way to do this for bash functions which I use quite extensively.</div><br/></div></div><div id="36412358" class="c"><input type="checkbox" id="c-36412358" checked=""/><div class="controls bullet"><span class="by">thangalin</span><span>|</span><a href="#36413935">prev</a><span>|</span><a href="#36411459">next</a><span>|</span><label class="collapse" for="c-36412358">[-]</label><label class="expand" for="c-36412358">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;keenwrite&#x2F;blob&#x2F;main&#x2F;scripts&#x2F;build-template">https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;keenwrite&#x2F;blob&#x2F;main&#x2F;scripts&#x2F;bu...</a><p>My template script provides a way to make user-friendly shell scripts. In a script that uses the template, you define the dependencies and their sources as comma-separated values:<p><pre><code>    DEPENDENCIES=(
      &quot;gradle,https:&#x2F;&#x2F;gradle.org&quot;
      &quot;warp-packer,https:&#x2F;&#x2F;github.com&#x2F;Reisz&#x2F;warp&#x2F;releases&quot;
      &quot;tar,https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;tar&quot;
      &quot;wine,https:&#x2F;&#x2F;www.winehq.org&quot;
      &quot;unzip,http:&#x2F;&#x2F;infozip.sourceforge.net&quot;
    )
</code></pre>
You define the command-line arguments:<p><pre><code>    ARGUMENTS+=(
      &quot;a,arch,Target operating system architecture (amd64)&quot;
      &quot;o,os,Target operating system (linux, windows, mac)&quot;
      &quot;u,update,Java update version number (${ARG_JAVA_UPDATE})&quot;
      &quot;v,version,Full Java version (${ARG_JAVA_VERSION})&quot;
    )
</code></pre>
You define the &quot;execute()&quot; method that is called after the arguments are parsed:<p><pre><code>    execute() {
      &#x2F;&#x2F; Make the computer do the work.

      return 1
    }
</code></pre>
If the script takes arguments, handle each one individually:<p><pre><code>    argument() {
      local consume=2

      case &quot;$1&quot; in
        -a|--arch)
        ARG_JAVA_ARCH=&quot;$2&quot;
        ;;
        -o|--os)
        ARG_JAVA_OS=&quot;$2&quot;
        ;;
      esac

      return ${consume}
    }
</code></pre>
Then call the template&#x27;s main to start the script rolling:<p><pre><code>    main &quot;$@&quot;
</code></pre>
For 99% of the scripts I write, this provides:<p>* Built-in software dependencies verification.<p>* Instructions to the user when requirements are missing.<p>* Simple command-line argument parsing.<p>* Help and logging using ANSI colour.<p>Here&#x27;s a complete script that builds the Windows, Linux, and Mac installers for my Markdown editor:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;KeenWrite&#x2F;blob&#x2F;main&#x2F;installer.sh">https:&#x2F;&#x2F;github.com&#x2F;DaveJarvis&#x2F;KeenWrite&#x2F;blob&#x2F;main&#x2F;installer....</a><p>There&#x27;s a write-up about creating the script that has a lot more details about how the template works:<p><a href="https:&#x2F;&#x2F;dave.autonoma.ca&#x2F;blog&#x2F;2019&#x2F;05&#x2F;22&#x2F;typesetting-markdown-part-1&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dave.autonoma.ca&#x2F;blog&#x2F;2019&#x2F;05&#x2F;22&#x2F;typesetting-markdow...</a><p>Note that it is technically possible to improve the scripts such that handling individual arguments can be done in the template itself. This would require a slightly different argument definition semantics:<p><pre><code>    ARGUMENTS+=(
      &quot;ARG_JAVA_ARCH,a,arch,Target operating system architecture (amd64)&quot;
      &quot;ARG_JAVA_OS,o,os,Target operating system (linux, windows, mac)&quot;
      &quot;usage=utile_usage,h,help,Show this help message then exit&quot;    
    )
</code></pre>
By detecting an `=` symbol for the first item in the lists, it&#x27;s possible to know whether a command-line argument is assigning a variable value, or whether it means to perform additional functionality. (PR welcome!)</div><br/></div></div><div id="36411459" class="c"><input type="checkbox" id="c-36411459" checked=""/><div class="controls bullet"><span class="by">gscho</span><span>|</span><a href="#36412358">prev</a><span>|</span><a href="#36409972">next</a><span>|</span><label class="collapse" for="c-36411459">[-]</label><label class="expand" for="c-36411459">[1 more]</label></div><br/><div class="children"><div class="content">Off topic but I really enjoy the lofi website design!</div><br/></div></div><div id="36409972" class="c"><input type="checkbox" id="c-36409972" checked=""/><div class="controls bullet"><span class="by">sigg3</span><span>|</span><a href="#36411459">prev</a><span>|</span><a href="#36401249">next</a><span>|</span><label class="collapse" for="c-36409972">[-]</label><label class="expand" for="c-36409972">[1 more]</label></div><br/><div class="children"><div class="content">Yes. I use them for cleanup in every non-trivial script I write.</div><br/></div></div><div id="36401249" class="c"><input type="checkbox" id="c-36401249" checked=""/><div class="controls bullet"><span class="by">smcleod</span><span>|</span><a href="#36409972">prev</a><span>|</span><a href="#36411405">next</a><span>|</span><label class="collapse" for="c-36401249">[-]</label><label class="expand" for="c-36401249">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I use these all the time, they’re very useful indeed.</div><br/></div></div><div id="36411405" class="c"><input type="checkbox" id="c-36411405" checked=""/><div class="controls bullet"><span class="by">franknord23</span><span>|</span><a href="#36401249">prev</a><span>|</span><a href="#36413515">next</a><span>|</span><label class="collapse" for="c-36411405">[-]</label><label class="expand" for="c-36411405">[2 more]</label></div><br/><div class="children"><div class="content">I wish Bash had &#x27;defer&#x27; like Go.</div><br/><div id="36411580" class="c"><input type="checkbox" id="c-36411580" checked=""/><div class="controls bullet"><span class="by">c7DJTLrn</span><span>|</span><a href="#36411405">parent</a><span>|</span><a href="#36413515">next</a><span>|</span><label class="collapse" for="c-36411580">[-]</label><label class="expand" for="c-36411580">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;cedwards.xyz&#x2F;defer-for-shell&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;cedwards.xyz&#x2F;defer-for-shell&#x2F;</a><p>Enjoy. (blog post is mine)</div><br/></div></div></div></div><div id="36413515" class="c"><input type="checkbox" id="c-36413515" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#36411405">prev</a><span>|</span><a href="#36411225">next</a><span>|</span><label class="collapse" for="c-36413515">[-]</label><label class="expand" for="c-36413515">[1 more]</label></div><br/><div class="children"><div class="content">Emacs C-c C-t will insert that for ya in shell-script-mode</div><br/></div></div><div id="36412285" class="c"><input type="checkbox" id="c-36412285" checked=""/><div class="controls bullet"><span class="by">honkycat</span><span>|</span><a href="#36411225">prev</a><span>|</span><a href="#36412106">next</a><span>|</span><label class="collapse" for="c-36412285">[-]</label><label class="expand" for="c-36412285">[1 more]</label></div><br/><div class="children"><div class="content">What if instead of using a bunch of features bolted onto a shitty scripting language, we just used a real language like Python?<p>I&#x27;ve read enough hacked-together bash BS to just despise the language.</div><br/></div></div><div id="36412106" class="c"><input type="checkbox" id="c-36412106" checked=""/><div class="controls bullet"><span class="by">cabalamat</span><span>|</span><a href="#36412285">prev</a><span>|</span><a href="#36410065">next</a><span>|</span><label class="collapse" for="c-36412106">[-]</label><label class="expand" for="c-36412106">[3 more]</label></div><br/><div class="children"><div class="content">Just use Python or any other proper high-level language that has proper control structures.</div><br/><div id="36412268" class="c"><input type="checkbox" id="c-36412268" checked=""/><div class="controls bullet"><span class="by">AHOHA</span><span>|</span><a href="#36412106">parent</a><span>|</span><a href="#36410065">next</a><span>|</span><label class="collapse" for="c-36412268">[-]</label><label class="expand" for="c-36412268">[2 more]</label></div><br/><div class="children"><div class="content">Sometimes you can “just use python”, like openwrt script or similar.</div><br/><div id="36415000" class="c"><input type="checkbox" id="c-36415000" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishc</span><span>|</span><a href="#36412106">root</a><span>|</span><a href="#36412268">parent</a><span>|</span><a href="#36410065">next</a><span>|</span><label class="collapse" for="c-36415000">[-]</label><label class="expand" for="c-36415000">[1 more]</label></div><br/><div class="children"><div class="content">OpenWrt has both CPython and MicroPython packaged.</div><br/></div></div></div></div></div></div><div id="36410065" class="c"><input type="checkbox" id="c-36410065" checked=""/><div class="controls bullet"><span class="by">tommica</span><span>|</span><a href="#36412106">prev</a><span>|</span><a href="#36410979">next</a><span>|</span><label class="collapse" for="c-36410065">[-]</label><label class="expand" for="c-36410065">[1 more]</label></div><br/><div class="children"><div class="content">This is very useful to know - thanks for sharing!</div><br/></div></div><div id="36410979" class="c"><input type="checkbox" id="c-36410979" checked=""/><div class="controls bullet"><span class="by">jeron</span><span>|</span><a href="#36410065">prev</a><span>|</span><a href="#36409922">next</a><span>|</span><label class="collapse" for="c-36410979">[-]</label><label class="expand" for="c-36410979">[1 more]</label></div><br/><div class="children"><div class="content">I thought exit traps were just SPACs</div><br/></div></div><div id="36409922" class="c"><input type="checkbox" id="c-36409922" checked=""/><div class="controls bullet"><span class="by">snapcaster</span><span>|</span><a href="#36410979">prev</a><span>|</span><label class="collapse" for="c-36409922">[-]</label><label class="expand" for="c-36409922">[1 more]</label></div><br/><div class="children"><div class="content">Very cool! didn&#x27;t know about these</div><br/></div></div></div></div></div></div></div></body></html>