<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688979649196" as="style"/><link rel="stylesheet" href="styles.css?v=1688979649196"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nathanotterness.com/2021/10/tiny_elf_modernized.html">Tiny ELF Files: Revisited in 2021</a>Â <span class="domain">(<a href="https://nathanotterness.com">nathanotterness.com</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>4 comments</span></div><br/><div><div id="36662849" class="c"><input type="checkbox" id="c-36662849" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#36662991">next</a><span>|</span><label class="collapse" for="c-36662849">[-]</label><label class="expand" for="c-36662849">[1 more]</label></div><br/><div class="children"><div class="content">Last November, I looked into this problem a bit more thoroughly, studying all the conditions that the Linux kernel actually checks. My conclusion was that the absolute smallest possible 64-bit ELF file in Linux was 80 bytes. (The smallest 32-bit ELF file was indeed 45 bytes, as in the original article.) This version was written to simply call _exit(0), but I recall that there are a few more opcode bytes to spare:<p><pre><code>  00000000: 7f45 4c46 b0e7 0f05 0000 0000 0000 0000  .ELF............
  00000010: 0200 3e00 0000 0000 0100 0000 0100 0000  ..&gt;.............
  00000020: 1800 0000 0000 0000 1800 0000 0100 0000  ................
  00000030: 0000 0000 0000 3800 0100 0000 0000 0000  ......8.........
  00000040: 0100 0000 0000 0000 0000 0000 0000 0000  ................
</code></pre>
I wonder if this version could be modified to create a Hello World smaller than 105 bytes? Unfortunately, I can&#x27;t find where I put all my notes for this, though I did keep the snippet I used to generate it:<p><pre><code>  alignas(Elf64_Ehdr) char data[80] = {0};
  Elf64_Ehdr *elf_ex = (Elf64_Ehdr *)data;
  memcpy(elf_ex-&gt;e_ident, ELFMAG, SELFMAG);
  elf_ex-&gt;e_type = ET_EXEC;
  elf_ex-&gt;e_machine = EM_X86_64;
  elf_ex-&gt;e_entry = 0x0000000100000001;
  elf_ex-&gt;e_phoff = 24;
  elf_ex-&gt;e_phentsize = sizeof(Elf64_Phdr);
  elf_ex-&gt;e_phnum = 1;
  Elf64_Phdr *elf_ppnt = (Elf64_Phdr *)(data + 24);
  &#x2F;&#x2F; elf_ppnt-&gt;p_type = PT_LOAD;
  &#x2F;&#x2F; elf_ppnt-&gt;p_flags = PF_X;
  &#x2F;&#x2F; elf_ppnt-&gt;p_offset = 24;
  elf_ppnt-&gt;p_vaddr = 0x0000000100000018;
  &#x2F;&#x2F; elf_ppnt-&gt;p_paddr = 0x0038000000000000;
  &#x2F;&#x2F; elf_ppnt-&gt;p_filesz = 1;
  elf_ppnt-&gt;p_memsz = 1;
  &#x2F;&#x2F; elf_ppnt-&gt;p_align = 0;
  memcpy(data + 4, &quot;\260\347\17\5&quot;, 4);</code></pre></div><br/></div></div><div id="36662991" class="c"><input type="checkbox" id="c-36662991" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#36662849">prev</a><span>|</span><a href="#36662792">next</a><span>|</span><label class="collapse" for="c-36662991">[-]</label><label class="expand" for="c-36662991">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I haven&#x27;t been able to track down the original date, but it was already around in the early 2000&#x27;s.<p>I remember reading the original article when working on our 4k intro Sesamstr [1] for a demoparty in September 1999.  (The ELF Kickers [2] changelog lists July 1999 for the initial release.)  We wanted to dynamically link libvga.so, which requires some more features of the ELF header to play with.  It turns out that the linker hash table can overlap with other parts of the header, to shave off some bytes.<p>As an additional shot of nostalgia, I remember some other sceners (Wedge, Viznut, XeF4?) trying to avoid SVGAlib entirely, so that one could use the smaller &quot;a.out&quot; format.  Because one could not simply use movl $0x13, %eax &#x2F; int $0x10 in Linux, there were some crude attempts to set all the required VGA registers &quot;by hand&quot;.  I think that required a couple of hundred bytes to pull off.  Back then, you could probably get away with not restoring text mode at the end :)<p>[1] <a href="https:&#x2F;&#x2F;www.pouet.net&#x2F;prod.php?which=1318" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pouet.net&#x2F;prod.php?which=1318</a><p>[2] <a href="http:&#x2F;&#x2F;www.muppetlabs.com&#x2F;~breadbox&#x2F;software&#x2F;elfkickers.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.muppetlabs.com&#x2F;~breadbox&#x2F;software&#x2F;elfkickers.html</a></div><br/></div></div><div id="36662792" class="c"><input type="checkbox" id="c-36662792" checked=""/><div class="controls bullet"><span class="by">BruceEel</span><span>|</span><a href="#36662991">prev</a><span>|</span><label class="collapse" for="c-36662792">[-]</label><label class="expand" for="c-36662792">[1 more]</label></div><br/><div class="children"><div class="content">Nice. One thing I liked about the original MuppetLabs article is that it included a dl example with a call to libc.so (which adds a whole additional layer of complexity.)  I&#x27;d be very interested in seeing a &#x27;modern&#x27;, 64 bit nasm example doing this in &quot;raw&quot; binary mode (nasm -f bin), tiny or not so tiny.</div><br/></div></div></div></div></div></div></div></body></html>