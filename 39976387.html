<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712653274363" as="style"/><link rel="stylesheet" href="styles.css?v=1712653274363"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>How might software development have unfolded if CPU speeds were 20x slower?</a>Â </div><div class="subtext"><span>EvanWard97</span> | <span>20 comments</span></div><br/><div><div id="39977508" class="c"><input type="checkbox" id="c-39977508" checked=""/><div class="controls bullet"><span class="by">r0ckarong</span><span>|</span><a href="#39977489">next</a><span>|</span><label class="collapse" for="c-39977508">[-]</label><label class="expand" for="c-39977508">[1 more]</label></div><br/><div class="children"><div class="content">HN answer:<p>To stick with your analogy: There would be more optimization and the rate of releasing stuff would be slower because it would have to be tested. That&#x27;s it. Remember catrdige based console games? How many patches or day one updated did you have to install there? How many times would they crash or soft-lock themselves? People tested more and optimized more because there were constraints.<p>Today we have plenty of resources and thus you can be wasteful. Managers trade speed over waste. If you can make it work unoptimized, ship a 150 GB installer and 80 GB day1 patch do it NOW. Money today, not when you&#x27;re done making it &quot;better&quot; for the user.<p>Sci-Fi answer:
We wouldn&#x27;t be playing the same type of games. Why would we have to rely on something like our representation of graphics? If the cognition would be 20x faster and more powerful we probably wouldn&#x27;t need abstractions but would have found a way to dump data into the cognition stream more directly.<p>I think the idea that 20x faster cognition would just mean &quot;could watch a movie at 480fps&quot; is too limited. More like you could play 24 movies per second and still understand what&#x27;s going on.</div><br/></div></div><div id="39977489" class="c"><input type="checkbox" id="c-39977489" checked=""/><div class="controls bullet"><span class="by">JaumeGreen</span><span>|</span><a href="#39977508">prev</a><span>|</span><a href="#39977347">next</a><span>|</span><label class="collapse" for="c-39977489">[-]</label><label class="expand" for="c-39977489">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Might the overall greater pressure for performance have kept us writing lower-level code with more bugs while shipping less features?<p>Are you living in the same world as the rest of us? Nowadays programs are shipped with plenty of bugs, mostly because patching them afterwards is &quot;cheap&quot;. In the old days that wasn&#x27;t as cheap.<p>So having lower powered computers would have made us write programs with less features, but also less bugs. Formal coding would be up, and instead of moving fast and break things most serious business would be writing coq or idris tests for their programs.<p>Bootcamps also wouldn&#x27;t be a thing, unless they were at least a couple of years long. We&#x27;d need people knowing about complexity, big O, defensive programming, and plenty of other things.<p>And plenty of things we take for granted would be far away. Starting with LLMs and maybe even most forms of autocomplete and automatic tooling.</div><br/></div></div><div id="39977347" class="c"><input type="checkbox" id="c-39977347" checked=""/><div class="controls bullet"><span class="by">moshegramovsky</span><span>|</span><a href="#39977489">prev</a><span>|</span><a href="#39977430">next</a><span>|</span><label class="collapse" for="c-39977347">[-]</label><label class="expand" for="c-39977347">[2 more]</label></div><br/><div class="children"><div class="content">I write C++ for high-performance Windows desktop applications that are used on a wide variety of form factors. This means that I still optimize a lot of things, such as what happens when a user edits a property in an edit box. How can that edit be minimized? How do I make sure that commands operate in less than a second? How can we hide latency when a long execution time can&#x27;t be avoided? 99% of the time, optimizations are about doing less, not doing something faster or with lower-level code. You&#x27;ll never write faster code than code that doesn&#x27;t run.<p>I think the GPU would do a lot more work in most applications than it does today. If a process needs to be super fast, when applicable, I write a compute shader. I&#x27;ve written ridiculous compute shaders that do ridiculous things. They are stupidly fast. One time I reduced something from a 15 minute execution time to running hundreds of times per second. And I didn&#x27;t even do that good of a job with the shader code.</div><br/><div id="39977436" class="c"><input type="checkbox" id="c-39977436" checked=""/><div class="controls bullet"><span class="by">iKlsR</span><span>|</span><a href="#39977347">parent</a><span>|</span><a href="#39977430">next</a><span>|</span><label class="collapse" for="c-39977436">[-]</label><label class="expand" for="c-39977436">[1 more]</label></div><br/><div class="children"><div class="content">Tangential but funny story from some years ago, did the same on a virtual reality app (Qt, Oculus SDK) so talking multi-threaded renderer, tons of background activity, even spawned a mini helper server to process tasks and such and did custom hacking (registry, window flags) to override windows features to make the app snappy. Distinctly remember spending weeks on startup time to get the app to consistently drop the user into a session between 250 - 500ms even from cold launch which involved something like a mini page file to capture state and other things only for my boss at the time to come and say the app was &quot;too fast&quot;, users couldn&#x27;t see the splash screen so we added a random(1.f, 3.f) second sleep...</div><br/></div></div></div></div><div id="39977430" class="c"><input type="checkbox" id="c-39977430" checked=""/><div class="controls bullet"><span class="by">koliber</span><span>|</span><a href="#39977347">prev</a><span>|</span><a href="#39977373">next</a><span>|</span><label class="collapse" for="c-39977430">[-]</label><label class="expand" for="c-39977430">[1 more]</label></div><br/><div class="children"><div class="content">No electron apps.</div><br/></div></div><div id="39977373" class="c"><input type="checkbox" id="c-39977373" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#39977430">prev</a><span>|</span><a href="#39977106">next</a><span>|</span><label class="collapse" for="c-39977373">[-]</label><label class="expand" for="c-39977373">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand the premise, because CPU speeds were 20x slower. Just go back a decade or two.<p>They weren&#x27;t some halcyon days of bug-free software back then, quite the opposite.</div><br/><div id="39977498" class="c"><input type="checkbox" id="c-39977498" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#39977373">parent</a><span>|</span><a href="#39977106">next</a><span>|</span><label class="collapse" for="c-39977498">[-]</label><label class="expand" for="c-39977498">[1 more]</label></div><br/><div class="children"><div class="content">Software wasn&#x27;t bug-free, but it was responsive.</div><br/></div></div></div></div><div id="39977106" class="c"><input type="checkbox" id="c-39977106" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#39977373">prev</a><span>|</span><a href="#39976568">next</a><span>|</span><label class="collapse" for="c-39977106">[-]</label><label class="expand" for="c-39977106">[1 more]</label></div><br/><div class="children"><div class="content">One way to answer this question is to look at the software produced when clock speeds were 20x slower.<p>The limitations, and features we had then are a minimum starting point.<p>So I&#x27;m thinking around the era of a 486 100mhz machine. We&#x27;d have at least that (think mylti-player Doom and Quake era as a starting point.)<p>We had Windows, preemptive multi threading, networks, internet, large hard drives, pretty much the base bones of today.<p>Of course cpu-intensive things would be constrained. Voice recognition. CGI. But we&#x27;d have a lot more cores, and likely more multi-thread approaches to programming in general.</div><br/></div></div><div id="39976568" class="c"><input type="checkbox" id="c-39976568" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#39977106">prev</a><span>|</span><a href="#39976578">next</a><span>|</span><label class="collapse" for="c-39976568">[-]</label><label class="expand" for="c-39976568">[3 more]</label></div><br/><div class="children"><div class="content">We&#x27;d still be using triple-DES to protect data, arguing that the NIST time to break it was still far out beyond. And hash functions would be like the CRC32 in TCP, not the modern stuff.<p>CISC computers which did more in parallel per instruction would be common because they existed for concrete reasons: the settling time for things in a discrete logic system was high, you needed to try and do as much as possible inside the time. (thats a stretch argument. they were what they were, but I do think the DEC 5 operand instruction model in part reflected &quot;god, what can we do while we&#x27;re here&quot; attitudes) -We&#x27;d probably have a lot more Cray-1 like parallelism where a high frequency clock drove simple logic to do things in parallel over matrices, so I guess thats GPU cards.</div><br/><div id="39977327" class="c"><input type="checkbox" id="c-39977327" checked=""/><div class="controls bullet"><span class="by">EvanWard97</span><span>|</span><a href="#39976568">parent</a><span>|</span><a href="#39977449">next</a><span>|</span><label class="collapse" for="c-39977327">[-]</label><label class="expand" for="c-39977327">[1 more]</label></div><br/><div class="children"><div class="content">20x more compute isn&#x27;t much in terms of cryptographic security concerns, no? Ah but triple-DES was recently depreciated.<p>Definitely sounds right that we&#x27;d get an earlier, heavier emphasis on parallelism and hardware acceleration. I&#x27;m guessing the slower speed of causality also applies to propagation delay and memory latencies, so there wouldn&#x27;t be new motivation for particular architectural decisions beyond &quot;God please make this fast enough for our real-time control systems or human interaction needs&quot;.<p>If we got deep learning years or decades earlier, that also seems scary for AI existential risk, as we are just barely starting to figure out how the big inscrutable matrices work, and that&#x27;s with the benefit of more time people have had to sound the alarm bells and attract talent and funding for AI interpretability research.</div><br/></div></div><div id="39977449" class="c"><input type="checkbox" id="c-39977449" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#39976568">parent</a><span>|</span><a href="#39977327">prev</a><span>|</span><a href="#39976578">next</a><span>|</span><label class="collapse" for="c-39977449">[-]</label><label class="expand" for="c-39977449">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact: 3DES is slower than modern standards, namely AES.</div><br/></div></div></div></div><div id="39976578" class="c"><input type="checkbox" id="c-39976578" checked=""/><div class="controls bullet"><span class="by">farseer</span><span>|</span><a href="#39976568">prev</a><span>|</span><a href="#39977450">next</a><span>|</span><label class="collapse" for="c-39976578">[-]</label><label class="expand" for="c-39976578">[1 more]</label></div><br/><div class="children"><div class="content">More C&#x2F;C++ based business apps that run locally. Cloud would be less relevant. No large browser engines, which means a lot less JS and of-course no Electron :)</div><br/></div></div><div id="39977450" class="c"><input type="checkbox" id="c-39977450" checked=""/><div class="controls bullet"><span class="by">Am4TIfIsER0ppos</span><span>|</span><a href="#39976578">prev</a><span>|</span><a href="#39976579">next</a><span>|</span><label class="collapse" for="c-39977450">[-]</label><label class="expand" for="c-39977450">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d probably be out of a job because we wouldn&#x27;t be doing this crap in software.<p>You wouldn&#x27;t have people wasting cpu cycles on pointless animation.  You&#x27;d have people thinking about how long it takes to follow a pointer.  You&#x27;d have people seriously thinking about whether the Specter and Meltdown and subsequent bugs really need to be worked around when it costs you 50% of the meager performance you still have.<p>I might ask if everything else is 20x times slower too.  GPU speeds, memory bandwidth, network bandwidth.</div><br/></div></div><div id="39976393" class="c"><input type="checkbox" id="c-39976393" checked=""/><div class="controls bullet"><span class="by">throwitaway222</span><span>|</span><a href="#39976579">prev</a><span>|</span><a href="#39976526">next</a><span>|</span><label class="collapse" for="c-39976393">[-]</label><label class="expand" for="c-39976393">[3 more]</label></div><br/><div class="children"><div class="content">A lot more chess games online instead.<p>Probably higher IQ as the IQ lowering social media we use would barely work.</div><br/><div id="39976573" class="c"><input type="checkbox" id="c-39976573" checked=""/><div class="controls bullet"><span class="by">EvanWard97</span><span>|</span><a href="#39976393">parent</a><span>|</span><a href="#39976478">next</a><span>|</span><label class="collapse" for="c-39976573">[-]</label><label class="expand" for="c-39976573">[1 more]</label></div><br/><div class="children"><div class="content">Sounds right to me. Without being able to rely on flashy visuals and low-latency so much, games would&#x27;ve had to be somewhat more strategic and intellectual to sell (although I imagine graphics would eventually catch up due to its fitness for parallel processing). Even if brain rotting visual spectacles were just pushed 7 years down the line, they still would probably have a more sophisticated flavor that might be cemented with time (e.g. this counterfactual TikTok might have given users much more direct control over their feed algorithm).</div><br/></div></div><div id="39976478" class="c"><input type="checkbox" id="c-39976478" checked=""/><div class="controls bullet"><span class="by">theGeatZhopa</span><span>|</span><a href="#39976393">parent</a><span>|</span><a href="#39976573">prev</a><span>|</span><a href="#39976526">next</a><span>|</span><label class="collapse" for="c-39976478">[-]</label><label class="expand" for="c-39976478">[1 more]</label></div><br/><div class="children"><div class="content">Everything is optimized for efficiency, size and speed. Like it was in the early days.  With sparkles in creativity for finding a way to achieve O(n)<p>I think the only solution to the problem is to keep the memory and disks space very low.</div><br/></div></div></div></div><div id="39976526" class="c"><input type="checkbox" id="c-39976526" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#39976393">prev</a><span>|</span><label class="collapse" for="c-39976526">[-]</label><label class="expand" for="c-39976526">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If human cognition were say, 20x faster relative to the speed of light<p>What would that even mean, being 20x faster than the speed of light? What does it imply?</div><br/><div id="39976567" class="c"><input type="checkbox" id="c-39976567" checked=""/><div class="controls bullet"><span class="by">joegibbs</span><span>|</span><a href="#39976526">parent</a><span>|</span><label class="collapse" for="c-39976567">[-]</label><label class="expand" for="c-39976567">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;Relative to&#x27; rather than &#x27;faster than&#x27;, as in the speed of light being 20x slower or human perception and reflexes being 20x faster, or some mix of the two. If people were thinking way faster then the lag would be unbearable, and there would be no way around it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>