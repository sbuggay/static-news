<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730365268680" as="style"/><link rel="stylesheet" href="styles.css?v=1730365268680"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://despairlabs.com/blog/posts/2024-10-27-openzfs-dedup-is-good-dont-use-it/">OpenZFS deduplication is good now and you shouldn&#x27;t use it</a> <span class="domain">(<a href="https://despairlabs.com">despairlabs.com</a>)</span></div><div class="subtext"><span>type0</span> | <span>136 comments</span></div><br/><div><div id="42001497" class="c"><input type="checkbox" id="c-42001497" checked=""/><div class="controls bullet"><span class="by">kderbe</span><span>|</span><a href="#42004636">next</a><span>|</span><label class="collapse" for="c-42001497">[-]</label><label class="expand" for="c-42001497">[3 more]</label></div><br/><div class="children"><div class="content">I clicked because of the bait-y title, but ended up reading pretty much the whole post, even though I have no reason to be interested in ZFS. (I skipped most of the stuff about logs...) Everything was explained clearly, I enjoyed the writing style, and the mobile CSS theme was particularly pleasing to my eyes. (It appears to be Pixyll theme with text set to the all-important #000, although I shouldn&#x27;t derail this discussion with opinions on contrast ratios...)<p>For less patient readers, note that the concise summary is at the bottom of the post, not the top.</div><br/><div id="42003973" class="c"><input type="checkbox" id="c-42003973" checked=""/><div class="controls bullet"><span class="by">emptiestplace</span><span>|</span><a href="#42001497">parent</a><span>|</span><a href="#42004636">next</a><span>|</span><label class="collapse" for="c-42003973">[-]</label><label class="expand" for="c-42003973">[2 more]</label></div><br/><div class="children"><div class="content">It scrolls horizontally :(</div><br/><div id="42004177" class="c"><input type="checkbox" id="c-42004177" checked=""/><div class="controls bullet"><span class="by">going_north</span><span>|</span><a href="#42001497">root</a><span>|</span><a href="#42003973">parent</a><span>|</span><a href="#42004636">next</a><span>|</span><label class="collapse" for="c-42004177">[-]</label><label class="expand" for="c-42004177">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s because of this element in one of the final sections [1]:<p><pre><code>    &lt;code&gt;kstat.zfs.&lt;pool&gt;.misc.ddt_stats_&lt;checksum&gt;&lt;&#x2F;code&gt;
</code></pre>
Typesetting code on a narrow screen is tricky!<p>[1] <a href="https:&#x2F;&#x2F;despairlabs.com&#x2F;blog&#x2F;posts&#x2F;2024-10-27-openzfs-dedup-is-good-dont-use-it&#x2F;#thats-a-lot-anything-else" rel="nofollow">https:&#x2F;&#x2F;despairlabs.com&#x2F;blog&#x2F;posts&#x2F;2024-10-27-openzfs-dedup-...</a></div><br/></div></div></div></div></div></div><div id="42004636" class="c"><input type="checkbox" id="c-42004636" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#42001497">prev</a><span>|</span><a href="#42001870">next</a><span>|</span><label class="collapse" for="c-42004636">[-]</label><label class="expand" for="c-42004636">[1 more]</label></div><br/><div class="children"><div class="content">You should use:<p><pre><code>   cp --reflink=auto
</code></pre>
You get file level deduplication. The command above performs a lightweight copy (ZFS clone in file level), where the data blocks are copied only when modified. Its a copy, not a hard link. The same should work in other copy-on-write transactional filesystems as well if they have reflink support.</div><br/></div></div><div id="42001870" class="c"><input type="checkbox" id="c-42001870" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42004636">prev</a><span>|</span><a href="#42001288">next</a><span>|</span><label class="collapse" for="c-42001870">[-]</label><label class="expand" for="c-42001870">[40 more]</label></div><br/><div class="children"><div class="content">&quot;And this is the fundamental issue with traditional dedup: these overheads are so outrageous that you are unlikely to ever get them back except on rare and specific workloads.&quot;<p>This struck me as a very odd claim. I&#x27;ve worked with Pure and Dell&#x2F;EMC arrays and for VMWare workloads they normally got at least 3:1 dedupe&#x2F;compression savings. Only storing one copy of the base VM image works extremely well. Dedupe&#x2F;compression works really well on syslog servers where I&#x27;ve seen 6:1 savings.<p>The effectiveness of dedupe is strongly affected by the size of the blocks being hashed, with the smaller the better. As the blocks get smaller the odds of having a matching block grow rapidly. In my experience 4KB is my preferred block size.</div><br/><div id="42002295" class="c"><input type="checkbox" id="c-42002295" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002898">next</a><span>|</span><label class="collapse" for="c-42002295">[-]</label><label class="expand" for="c-42002295">[5 more]</label></div><br/><div class="children"><div class="content">Couple of comments. Firstly, you are talking about highly redundant information when referencing VM images (e.g. the C drive on all Windows Serer images will be virtually identical), whereas he was using his own laptop contents as an example.<p>Secondly, I think you are conflating two different features: compression &amp; de-duplication. In ZFS you can have compression turned on (almost always worth it) for a pool, but still have de-duplication disabled.</div><br/><div id="42002332" class="c"><input type="checkbox" id="c-42002332" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002295">parent</a><span>|</span><a href="#42002898">next</a><span>|</span><label class="collapse" for="c-42002332">[-]</label><label class="expand" for="c-42002332">[4 more]</label></div><br/><div class="children"><div class="content">Fair point. My experience is with enterprise storage arrays and I have always used dedupe&#x2F;compression at the same time. Dedupe is going to be a lot less useful on single computers.<p>I consider dedupe&#x2F;compression to be two different forms of the same thing. compression reduces short range duplication while deduplication reduces long range duplication of data.</div><br/><div id="42002720" class="c"><input type="checkbox" id="c-42002720" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002332">parent</a><span>|</span><a href="#42002898">next</a><span>|</span><label class="collapse" for="c-42002720">[-]</label><label class="expand" for="c-42002720">[3 more]</label></div><br/><div class="children"><div class="content">Yeah agreed, very closely related - even more so on ZFS where the compression (AFAIK) is on a block level rather than a file level.</div><br/><div id="42003252" class="c"><input type="checkbox" id="c-42003252" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002720">parent</a><span>|</span><a href="#42002898">next</a><span>|</span><label class="collapse" for="c-42003252">[-]</label><label class="expand" for="c-42003252">[2 more]</label></div><br/><div class="children"><div class="content">ZFS compression is for sure at the block level - it&#x27;s fully transparent to the userland tools.</div><br/><div id="42003454" class="c"><input type="checkbox" id="c-42003454" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42003252">parent</a><span>|</span><a href="#42002898">next</a><span>|</span><label class="collapse" for="c-42003454">[-]</label><label class="expand" for="c-42003454">[1 more]</label></div><br/><div class="children"><div class="content">It could be at a file level and still transparent to user land tools, FYI. Depending on what you mean by ‘file level’, I guess.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42002898" class="c"><input type="checkbox" id="c-42002898" checked=""/><div class="controls bullet"><span class="by">phil21</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002295">prev</a><span>|</span><a href="#42004065">next</a><span>|</span><label class="collapse" for="c-42002898">[-]</label><label class="expand" for="c-42002898">[1 more]</label></div><br/><div class="children"><div class="content">Base VM images would be a rare and specific workload.  One of the few cases dedupe makes sense.  However you are likely using better strategies like block or filesystem cloning if you are doing VM hosting off a ZFS filesystem.  Not doing so would be throwing away one of it&#x27;s primary differentiators as a filesystem in such an environment.<p>General purpose fileserving or personal desktop&#x2F;laptop use generally has very few duplicated blocks and is not worth the overhead.  Backups are hit or miss depending on both how the backups are implemented, and if they are encrypted prior to the filesystem level.<p>Compression is a totally different thing and current ZFS best-practice is to enable it by default for pretty much every workload - the CPU used is barely worth mentioning these days, and the I&#x2F;O savings can be considerable ignoring any storage space savings.  Log storage is going to likely see a lot better than 6:1 savings if you have typical logging, at least in my experience.</div><br/></div></div><div id="42004065" class="c"><input type="checkbox" id="c-42004065" checked=""/><div class="controls bullet"><span class="by">Maakuth</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002898">prev</a><span>|</span><a href="#42002071">next</a><span>|</span><label class="collapse" for="c-42004065">[-]</label><label class="expand" for="c-42004065">[1 more]</label></div><br/><div class="children"><div class="content">Certainly it makes sense to not have deep copies of VM base images, but the deduplication is not the right way to do it in ZFS. Instead, you can clone the base image and before changes it will take almost no space at all. This is thanks to the copy-on-write nature of ZFS.<p>ZFS deduplication instead tries to find existing copies of data that is being written to the volume. For some use cases it could make a lot of sense (container image storage maybe?), but it&#x27;s very inefficient if you already know some datasets to be clones of the others, at least initially.</div><br/></div></div><div id="42002071" class="c"><input type="checkbox" id="c-42002071" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42004065">prev</a><span>|</span><a href="#42002181">next</a><span>|</span><label class="collapse" for="c-42002071">[-]</label><label class="expand" for="c-42002071">[8 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t tried it myself, but the widely quoted number for old ZFS dedup is that you need 5GB of RAM for every 1TB of disk space. Considering that 1 TB of disk space currently costs about $15 and 5GB of server RAM about $25, you need a 3:1 dedupe ratio just to break even.<p>If your data is a good fit you might get away with 1GB per TB, but if you are out of luck the 5GB might not even be enough. That&#x27;s why the article speaks of ZFS dedup having a small sweet spot that your data has to hit, and why most people don&#x27;t bother<p>Other file systems tend to prefer offline dedupe which has more favorable economics</div><br/><div id="42002099" class="c"><input type="checkbox" id="c-42002099" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002071">parent</a><span>|</span><a href="#42002174">next</a><span>|</span><label class="collapse" for="c-42002099">[-]</label><label class="expand" for="c-42002099">[3 more]</label></div><br/><div class="children"><div class="content">Why does it need so much RAM? It should only need to store the block hashes which should not need anywhere near that much RAM. Inline dedupe is pretty much standard on high-end storage arrays nowadays.</div><br/><div id="42002717" class="c"><input type="checkbox" id="c-42002717" checked=""/><div class="controls bullet"><span class="by">AndrewDavis</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002099">parent</a><span>|</span><a href="#42002473">next</a><span>|</span><label class="collapse" for="c-42002717">[-]</label><label class="expand" for="c-42002717">[1 more]</label></div><br/><div class="children"><div class="content">The linked blog post covers this, and the improvements made to make the new dedup better.</div><br/></div></div><div id="42002473" class="c"><input type="checkbox" id="c-42002473" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002099">parent</a><span>|</span><a href="#42002717">prev</a><span>|</span><a href="#42002174">next</a><span>|</span><label class="collapse" for="c-42002473">[-]</label><label class="expand" for="c-42002473">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    (5GiB &#x2F; 1TiB) * 4KiB to bits

      ((5 gibibytes) &#x2F; (1 tebibyte)) × (4 kibibytes) = 160 bits</code></pre></div><br/></div></div></div></div><div id="42002174" class="c"><input type="checkbox" id="c-42002174" checked=""/><div class="controls bullet"><span class="by">floating-io</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002071">parent</a><span>|</span><a href="#42002099">prev</a><span>|</span><a href="#42002181">next</a><span>|</span><label class="collapse" for="c-42002174">[-]</label><label class="expand" for="c-42002174">[4 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t account for OpEx, though, such as power...</div><br/><div id="42002251" class="c"><input type="checkbox" id="c-42002251" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002174">parent</a><span>|</span><a href="#42002181">next</a><span>|</span><label class="collapse" for="c-42002251">[-]</label><label class="expand" for="c-42002251">[3 more]</label></div><br/><div class="children"><div class="content">Assuming something reasonable like 20TB Toshiba MG10 HDDs and 64GB DDR4 ECC RAM, quick googling suggests that 1TB of disk space uses about 0.2-0.4W of power (0.2 in idle, 0.4 while writing), 5GB of RAM about 0.3-0.5W. So your break even on power is a bit earlier depending on the access pattern, but in the same ball park.</div><br/><div id="42002538" class="c"><input type="checkbox" id="c-42002538" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002251">parent</a><span>|</span><a href="#42002181">next</a><span>|</span><label class="collapse" for="c-42002538">[-]</label><label class="expand" for="c-42002538">[2 more]</label></div><br/><div class="children"><div class="content">What about rack space?</div><br/><div id="42003565" class="c"><input type="checkbox" id="c-42003565" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002538">parent</a><span>|</span><a href="#42002181">next</a><span>|</span><label class="collapse" for="c-42003565">[-]</label><label class="expand" for="c-42003565">[1 more]</label></div><br/><div class="children"><div class="content">Not just rack space. At a certain amount of disks you also need to get a separate server (chassis + main board + cpu + ram) to host the disks. Maybe you need that for performance reasons any way. But saving disk space and only paying for it with some ram sounds cost effective.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42002181" class="c"><input type="checkbox" id="c-42002181" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002071">prev</a><span>|</span><a href="#42002040">next</a><span>|</span><label class="collapse" for="c-42002181">[-]</label><label class="expand" for="c-42002181">[7 more]</label></div><br/><div class="children"><div class="content">VMs are known to benefit from dedupe so yes, you&#x27;ll see benefits there. ZFS is a general-purpose filesystem not just an enterprise SAN so many ZFS users aren&#x27;t running VMs.<p><i>Dedupe&#x2F;compression works really well on syslog</i><p>I apologize for the pedantry but dedupe and compression aren&#x27;t the same thing (although they tend to be bundled in the enterprise storage world). Logs are probably benefiting from compression not dedupe and ZFS had compression all along.</div><br/><div id="42002300" class="c"><input type="checkbox" id="c-42002300" checked=""/><div class="controls bullet"><span class="by">tw04</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002181">parent</a><span>|</span><a href="#42002275">next</a><span>|</span><label class="collapse" for="c-42002300">[-]</label><label class="expand" for="c-42002300">[5 more]</label></div><br/><div class="children"><div class="content">They are not the same thing, but when you boil it down to the raw math, they aren&#x27;t identical twins, but they&#x27;re absolutely fraternal twins.<p>Both are trying to eliminate repeating data, it&#x27;s just the frame of reference that changes.  Compression in this context is operating on a given block or handful of blocks.  Deduplication is operating on the entire &quot;volume&quot; of data.  &quot;Volume&quot; having a different meaning depending on the filesystem&#x2F;storage array in question.</div><br/><div id="42002356" class="c"><input type="checkbox" id="c-42002356" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002300">parent</a><span>|</span><a href="#42002520">next</a><span>|</span><label class="collapse" for="c-42002356">[-]</label><label class="expand" for="c-42002356">[1 more]</label></div><br/><div class="children"><div class="content">Well put. I like to say compression is just short range dedupe. Hash based dedupe wouldn&#x27;t be needed if you could just to real-time LZMA on all of the data on a storage array but that just isn&#x27;t feasible and hash-based dedupe is a very effective compromise.</div><br/></div></div><div id="42002520" class="c"><input type="checkbox" id="c-42002520" checked=""/><div class="controls bullet"><span class="by">ShroudedNight</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002300">parent</a><span>|</span><a href="#42002356">prev</a><span>|</span><a href="#42004331">next</a><span>|</span><label class="collapse" for="c-42002520">[-]</label><label class="expand" for="c-42002520">[2 more]</label></div><br/><div class="children"><div class="content">Is &quot;paternal twins&quot; a linguistic borrowing of some sort? It seems a relatively novel form of what I&#x27;ve mostly seen referred to as monozygotic &#x2F; &#x27;identical&#x27; twins. Searching for some kind of semi-canonical confirmation of its widespread use turns up one, maybe two articles where it&#x27;s treated as an orthodox term, and at least an equal number of discussions admonishing its use.</div><br/><div id="42003579" class="c"><input type="checkbox" id="c-42003579" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002520">parent</a><span>|</span><a href="#42004331">next</a><span>|</span><label class="collapse" for="c-42003579">[-]</label><label class="expand" for="c-42003579">[1 more]</label></div><br/><div class="children"><div class="content">If anything I would expect the term “maternal” twin to be used as whether or not a twin is monozygotic or “identical” depends on the amount of eggs from the mother.</div><br/></div></div></div></div><div id="42004331" class="c"><input type="checkbox" id="c-42004331" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002300">parent</a><span>|</span><a href="#42002520">prev</a><span>|</span><a href="#42002275">next</a><span>|</span><label class="collapse" for="c-42004331">[-]</label><label class="expand" for="c-42004331">[1 more]</label></div><br/><div class="children"><div class="content">compression tends NOT to use a global dictionary. So to me they are vastly different even if they have the same goal of reducing the output size.<p>Compression with a global dict would like do better than dedup yet it will have a lot of other issues.</div><br/></div></div></div></div><div id="42002275" class="c"><input type="checkbox" id="c-42002275" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002181">parent</a><span>|</span><a href="#42002300">prev</a><span>|</span><a href="#42002040">next</a><span>|</span><label class="collapse" for="c-42002275">[-]</label><label class="expand" for="c-42002275">[1 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re being pedants, then storing the same information in fewer bits than the input is by definition a form of compression, no?<p>(Although yes I understand that file-level compression with a standard algorithm is a different thing than dedup)</div><br/></div></div></div></div><div id="42002040" class="c"><input type="checkbox" id="c-42002040" checked=""/><div class="controls bullet"><span class="by">Joe_Cool</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002181">prev</a><span>|</span><a href="#42004129">next</a><span>|</span><label class="collapse" for="c-42002040">[-]</label><label class="expand" for="c-42002040">[2 more]</label></div><br/><div class="children"><div class="content">Even with the rudimentary Dedup features of NTFS on a Windows Hyper-V Server all running the same base image I can overprovision the 512GB partition to almost 2 GB.<p>You need to be careful and do staggered updates in the VMs or it&#x27;ll spectacularly explode but it&#x27;s possible and quite performant for less than mission critical VMs.</div><br/><div id="42002314" class="c"><input type="checkbox" id="c-42002314" checked=""/><div class="controls bullet"><span class="by">tw04</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002040">parent</a><span>|</span><a href="#42004129">next</a><span>|</span><label class="collapse" for="c-42002314">[-]</label><label class="expand" for="c-42002314">[1 more]</label></div><br/><div class="children"><div class="content">I think you mean 2TB volume?  But yes, this works.  But also: if you&#x27;re doing anything production, I&#x27;d strongly recommend doing deduplication on the back-end storage array, not at the NTFS layer.  It&#x27;ll be more performant and almost assuredly have better space savings.</div><br/></div></div></div></div><div id="42004129" class="c"><input type="checkbox" id="c-42004129" checked=""/><div class="controls bullet"><span class="by">mrgaro</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002040">prev</a><span>|</span><a href="#42002029">next</a><span>|</span><label class="collapse" for="c-42004129">[-]</label><label class="expand" for="c-42004129">[1 more]</label></div><br/><div class="children"><div class="content">For text based logs I&#x27;m almost entirely sure that just using compression is more than enough. ZFS supports compression natively on block level and it&#x27;s almost always turned on. Trying to use dedup alongside of compression for syslog most likely will not yield any benefits.</div><br/></div></div><div id="42002029" class="c"><input type="checkbox" id="c-42002029" checked=""/><div class="controls bullet"><span class="by">jorvi</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42004129">prev</a><span>|</span><a href="#42003105">next</a><span>|</span><label class="collapse" for="c-42002029">[-]</label><label class="expand" for="c-42002029">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience 4KB is my preferred block size<p>That makes sense considering Advanced Format harddrives already have a 4K physical sector size, and if you properly low-level format them (to get rid of the ridiculous Windows XP compatibility) they also have 4K logical sector size. I imagine there might be some real performance benefits to having all of those match up.</div><br/><div id="42002112" class="c"><input type="checkbox" id="c-42002112" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002029">parent</a><span>|</span><a href="#42003105">next</a><span>|</span><label class="collapse" for="c-42002112">[-]</label><label class="expand" for="c-42002112">[1 more]</label></div><br/><div class="children"><div class="content">In the early days of VMware people had a lot of VMs that were converted from physical machines and this causes a nasty alignment issue between the VMDK blocks and the blocks on your storage array. The effect was to always add one block to every read operation, and in the worst case of reading one block would double the load on the storage array. On NetApp this could only be fixed when the VM wasn&#x27;t running.</div><br/></div></div></div></div><div id="42003105" class="c"><input type="checkbox" id="c-42003105" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002029">prev</a><span>|</span><a href="#42002951">next</a><span>|</span><label class="collapse" for="c-42003105">[-]</label><label class="expand" for="c-42003105">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience 4KB is my preferred block size.<p>This probably has something to do with the VM&#x27;s filesystem block size. If you have a 4KB filesystem and an 8KB file, the file might be fragmented differently but is still the same 2x4KB blocks just in different places.<p>Now I wonder if filesystems zero the slack space at the end of the last block in a file in hopes of better host compression. Vs leaving it as past bytes.</div><br/></div></div><div id="42002951" class="c"><input type="checkbox" id="c-42002951" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42003105">prev</a><span>|</span><a href="#42002948">next</a><span>|</span><label class="collapse" for="c-42002951">[-]</label><label class="expand" for="c-42002951">[1 more]</label></div><br/><div class="children"><div class="content">I would think VMs qualify as a specific workload, since cloning is almost a given.</div><br/></div></div><div id="42002948" class="c"><input type="checkbox" id="c-42002948" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002951">prev</a><span>|</span><a href="#42001929">next</a><span>|</span><label class="collapse" for="c-42002948">[-]</label><label class="expand" for="c-42002948">[1 more]</label></div><br/><div class="children"><div class="content">I figured he was mostly talking about using dedup on your work (dev machine) computer or family computer at home, not on something like a cloud or streaming server or other back end type operations.</div><br/></div></div><div id="42001929" class="c"><input type="checkbox" id="c-42001929" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#42001870">parent</a><span>|</span><a href="#42002948">prev</a><span>|</span><a href="#42001288">next</a><span>|</span><label class="collapse" for="c-42001929">[-]</label><label class="expand" for="c-42001929">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Dedupe&#x2F;compression works really well on syslog servers where I&#x27;ve seen 6:1 savings.<p>Don’t you compress these directly? I normally see at least twice that for logs doing it at the process level.</div><br/><div id="42002502" class="c"><input type="checkbox" id="c-42002502" checked=""/><div class="controls bullet"><span class="by">pezezin</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42001929">parent</a><span>|</span><a href="#42002027">next</a><span>|</span><label class="collapse" for="c-42002502">[-]</label><label class="expand" for="c-42002502">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that ratio is very small.<p>I built a very simple, custom syslog solution, a syslog-ng server writing directly to a TimescaleDB hypertable (<a href="https:&#x2F;&#x2F;www.timescale.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.timescale.com&#x2F;</a>) that is then presented as a Grafana dashboard, and I am getting a 30x compression ratio.</div><br/></div></div><div id="42002027" class="c"><input type="checkbox" id="c-42002027" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42001929">parent</a><span>|</span><a href="#42002502">prev</a><span>|</span><a href="#42001288">next</a><span>|</span><label class="collapse" for="c-42002027">[-]</label><label class="expand" for="c-42002027">[7 more]</label></div><br/><div class="children"><div class="content">What software?</div><br/><div id="42002106" class="c"><input type="checkbox" id="c-42002106" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002027">parent</a><span>|</span><a href="#42002448">next</a><span>|</span><label class="collapse" for="c-42002106">[-]</label><label class="expand" for="c-42002106">[3 more]</label></div><br/><div class="children"><div class="content">Log rotate, cron, or simply having something like Varnish or Apache log to a pipe which is something like bzip2 or zstd.  The main question is whether you want to easily access the current stream - e.g. I had uncompressed logs being forwarded to CloudWatch so I had daemons logging to timestamped files with a post-rotate compression command which would run after the last write.</div><br/><div id="42002150" class="c"><input type="checkbox" id="c-42002150" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002106">parent</a><span>|</span><a href="#42002448">next</a><span>|</span><label class="collapse" for="c-42002150">[-]</label><label class="expand" for="c-42002150">[2 more]</label></div><br/><div class="children"><div class="content">That is one wrinkle of using storage based dedupe&#x2F;compression is you need to avoid doing compression on the client to avoid compressing already compressed data. When a company I worked at first got their Pure array they were using windows file compression heavily and had to disable it as the storage array was now doing it automatically.</div><br/><div id="42002184" class="c"><input type="checkbox" id="c-42002184" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002150">parent</a><span>|</span><a href="#42002448">next</a><span>|</span><label class="collapse" for="c-42002184">[-]</label><label class="expand" for="c-42002184">[1 more]</label></div><br/><div class="children"><div class="content">Definitely. We love building abstraction layers but at some point you really need to make decisions across the entire stack.</div><br/></div></div></div></div></div></div><div id="42002448" class="c"><input type="checkbox" id="c-42002448" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002027">parent</a><span>|</span><a href="#42002106">prev</a><span>|</span><a href="#42002066">next</a><span>|</span><label class="collapse" for="c-42002448">[-]</label><label class="expand" for="c-42002448">[2 more]</label></div><br/><div class="children"><div class="content">Logrotate is the rhel utility, likely present in Fedora, that is easily adapted for custom log handling. I still have rhel5 and I use it there.<p>CentOS made it famous. I don&#x27;t know if it has a foothold in the Debian family.</div><br/><div id="42003278" class="c"><input type="checkbox" id="c-42003278" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002448">parent</a><span>|</span><a href="#42002066">next</a><span>|</span><label class="collapse" for="c-42003278">[-]</label><label class="expand" for="c-42003278">[1 more]</label></div><br/><div class="children"><div class="content">logrotate is used on Debian and plenty of other distros. It seems pretty widely used, though maybe not as much so now that things log through systemd.</div><br/></div></div></div></div><div id="42002066" class="c"><input type="checkbox" id="c-42002066" checked=""/><div class="controls bullet"><span class="by">SteveNuts</span><span>|</span><a href="#42001870">root</a><span>|</span><a href="#42002027">parent</a><span>|</span><a href="#42002448">prev</a><span>|</span><a href="#42001288">next</a><span>|</span><label class="collapse" for="c-42002066">[-]</label><label class="expand" for="c-42002066">[1 more]</label></div><br/><div class="children"><div class="content">Logrotate</div><br/></div></div></div></div></div></div></div></div><div id="42001288" class="c"><input type="checkbox" id="c-42001288" checked=""/><div class="controls bullet"><span class="by">Wowfunhappy</span><span>|</span><a href="#42001870">prev</a><span>|</span><a href="#42001154">next</a><span>|</span><label class="collapse" for="c-42001288">[-]</label><label class="expand" for="c-42001288">[33 more]</label></div><br/><div class="children"><div class="content">I want &quot;offline&quot; dedupe, or &quot;lazy&quot; dedupe that doesn&#x27;t require the pool to be fully offline, but doesn&#x27;t happen immediately.<p>Because:<p>&gt; When dedup is enabled [...] every single write and free operation requires a lookup and a then a write to the dedup table, regardless of whether or not the write or free proper was actually done by the pool.<p>To me, this is &quot;obviously&quot; the wrong approach in most cases. When I&#x27;m writing data, I want that write to complete as fast as possible, even at the cost of disk space. That&#x27;s why I don&#x27;t save files I&#x27;m actively working on in 7zip archives.<p>But later on, when the system is quiet, I would love for ZFS to go back and figure out which data is duplicated, and use the BRT or whatever to reclaim space. This could be part of a normal scrub operation.</div><br/><div id="42002643" class="c"><input type="checkbox" id="c-42002643" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42001483">next</a><span>|</span><label class="collapse" for="c-42002643">[-]</label><label class="expand" for="c-42002643">[1 more]</label></div><br/><div class="children"><div class="content">Lazy&#x2F;off-line dedup requires block pointer rewrite, but ZFS _cannot_ and will not ever get true BP rewrite because ZFS is not truly a CAS system.  The problem is that physical locations are hashed into the Merkle hash tree, and that makes moving physical locations prohibitively expensive as you have to rewrite all the interior nodes on the way to the nodes you want to rewrite.<p>A better design would have been to split every node that has block pointers into two sections, one that has only logical block pointers and all of whose contents gets hashed into the tree, and one that has only the physical locations (as if it were a cache) of the corresponding logical block pointers in the first section, with the second section _not_ hashed into the Merkle hash tree.  Then BP rewrite would only require re-writing blocks that are not part of the Merkle hash tree.<p>But as it is you can&#x27;t get BP rewrite to work on ZFS, so you can&#x27;t get what you&#x27;re asking for.<p>Well... maybe.  Perhaps on read hash mismatch ZFS could attempt to locate the pointed-to block in the dedup table using the hash from the pointer.  Then ZFS could reallocate the dedup&#x27;ed block.  The price you&#x27;d pay then is one pointless read -- not too bad.  The impossibility of BP rewrite generally leads to band-aids like this.</div><br/></div></div><div id="42001483" class="c"><input type="checkbox" id="c-42001483" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42002643">prev</a><span>|</span><a href="#42001903">next</a><span>|</span><label class="collapse" for="c-42001483">[-]</label><label class="expand" for="c-42001483">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I just wish we had &quot;offline&quot; dedupe, or even &quot;lazy&quot; dedupe...<p>This is the Windows dedupe methodology. I&#x27;ve used it pretty extensively and I&#x27;m generally happy with it when the underlying hardware is sufficient. It&#x27;s very RAM and I&#x2F;O hungry but you can schedule and throttle the &quot;groveler&quot;.<p>I have had some data eating corruption from bugs in the Windows 2012 R2 timeframe.</div><br/></div></div><div id="42001903" class="c"><input type="checkbox" id="c-42001903" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42001483">prev</a><span>|</span><a href="#42001360">next</a><span>|</span><label class="collapse" for="c-42001903">[-]</label><label class="expand" for="c-42001903">[4 more]</label></div><br/><div class="children"><div class="content">The neat thing about inline dedupe is that if the block hash already exists than the block doesn&#x27;t have to be written. This can save a LOT of write IO in many situations. There are even extensions where a file copy between to VMs on a dedupe storage array will not actually copy any data but just increment the original blocks reference counter. You will see absurd TB&#x2F;s write speeds in the OS, it is pretty cool.</div><br/><div id="42002407" class="c"><input type="checkbox" id="c-42002407" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42001903">parent</a><span>|</span><a href="#42001360">next</a><span>|</span><label class="collapse" for="c-42002407">[-]</label><label class="expand" for="c-42002407">[3 more]</label></div><br/><div class="children"><div class="content">This is only a win if the dedupe table fits in RAM; otherwise you pay for it in a LOT of read IO.  I have a storage array where dedupe would give me about a 2.2x reduction in disk usage, but there isn&#x27;t nearly enough RAM for it.</div><br/><div id="42002426" class="c"><input type="checkbox" id="c-42002426" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002407">parent</a><span>|</span><a href="#42001360">next</a><span>|</span><label class="collapse" for="c-42002426">[-]</label><label class="expand" for="c-42002426">[2 more]</label></div><br/><div class="children"><div class="content">yes inline dedupe has to fit in RAM. Perhaps enterprise storage arrays have spoiled me.</div><br/><div id="42003224" class="c"><input type="checkbox" id="c-42003224" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002426">parent</a><span>|</span><a href="#42001360">next</a><span>|</span><label class="collapse" for="c-42003224">[-]</label><label class="expand" for="c-42003224">[1 more]</label></div><br/><div class="children"><div class="content">This array is a bit long-in-the-tooth and only has 192GB of RAM, but a bit over 40TB of net storage, which would be a 200GB dedup table size using the back-of-the-envelope estimate of 5GB&#x2F;TB.<p>A more precise calculation on my actual data shows that today&#x27;s data would allow the dedup table to fit in RAM, but if I ever want to actually use most of the 40TB of storage, I&#x27;d need more RAM.  I&#x27;ve had a ZFS system swap dedup to disk before, and the performance dropped to approximately zero; fixing it was a PITA, so I&#x27;m not doing that anytime soon.</div><br/></div></div></div></div></div></div></div></div><div id="42001360" class="c"><input type="checkbox" id="c-42001360" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42001903">prev</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42001360">[-]</label><label class="expand" for="c-42001360">[9 more]</label></div><br/><div class="children"><div class="content">The ability to alter existing snapshots, even in ways that fully preserve the data, is extremely limited in ZFS.  So yes that would be great, but if I was holding my breath for Block Pointer Rewrite I&#x27;d be long dead.</div><br/><div id="42002257" class="c"><input type="checkbox" id="c-42002257" checked=""/><div class="controls bullet"><span class="by">Wowfunhappy</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42001360">parent</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42002257">[-]</label><label class="expand" for="c-42002257">[8 more]</label></div><br/><div class="children"><div class="content">You need block pointer rewrite for this?</div><br/><div id="42002623" class="c"><input type="checkbox" id="c-42002623" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002257">parent</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42002623">[-]</label><label class="expand" for="c-42002623">[7 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need it to dedup writable files.  But redundant copies in snapshots are stuck there as far as I&#x27;m aware.  So if you search for duplicates every once in a while, you&#x27;re not going to reap the space savings until your snapshots fully rotate.</div><br/><div id="42003486" class="c"><input type="checkbox" id="c-42003486" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002623">parent</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42003486">[-]</label><label class="expand" for="c-42003486">[6 more]</label></div><br/><div class="children"><div class="content">The issue with this, in my experience, is that at some point that pro (exactly, and literally, only one copy of a specific bit of data despite many apparent copies) can become a con if there is some data corruption somewhere.<p>Sometimes it can be a similar issue in some edge cases performance wise, but usually caching can address those problems.<p>Efficiency being the enemy of reliability, sometimes.</div><br/><div id="42004019" class="c"><input type="checkbox" id="c-42004019" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42003486">parent</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42004019">[-]</label><label class="expand" for="c-42004019">[5 more]</label></div><br/><div class="children"><div class="content">Redundant copies on a single volume are a waste of resources.  Spend less on size, spend more on an extra parity drive, or another backup of your most important files.  That way you get more safety per gigabyte.</div><br/><div id="42004047" class="c"><input type="checkbox" id="c-42004047" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42004019">parent</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42004047">[-]</label><label class="expand" for="c-42004047">[4 more]</label></div><br/><div class="children"><div class="content">Notably, having to duplicate all data x2 (or more) is <i>more</i> of a waste than having 2 copies of a few files - if full drive failure is not the expected failure mode, and not all files should be protected this heavily.<p>It’s why metadata gets duplicated in ZFS the way it does on all volumes.<p>Having seen this play out a bunch of times, it isn’t an uncommon need either.</div><br/><div id="42004094" class="c"><input type="checkbox" id="c-42004094" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42004047">parent</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42004094">[-]</label><label class="expand" for="c-42004094">[3 more]</label></div><br/><div class="children"><div class="content">&gt; having to duplicate all data x2<p>Well I didn&#x27;t suggest that.  I said important files only for the extra backup, and I was talking about reallocating resources not getting new ones.<p>The simplest version is the scenario where turning on dedup means you need one less drive of space.  Convert that drive to parity and you&#x27;ll be better off.  Split that drive from the pool and use it to backup the most important files and you&#x27;ll be better off.<p>If you can&#x27;t save much space with dedup then don&#x27;t bother.</div><br/><div id="42004238" class="c"><input type="checkbox" id="c-42004238" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42004094">parent</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42004238">[-]</label><label class="expand" for="c-42004238">[2 more]</label></div><br/><div class="children"><div class="content">There was an implication in your statement that volume level was the level of granularity, yeah?<p>I’m noting that during on volume wide dedup can have the con that you can’t choose (but it looks like you can!) to manually duplicate data.</div><br/><div id="42004560" class="c"><input type="checkbox" id="c-42004560" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42004238">parent</a><span>|</span><a href="#42002155">next</a><span>|</span><label class="collapse" for="c-42004560">[-]</label><label class="expand" for="c-42004560">[1 more]</label></div><br/><div class="children"><div class="content">Note: I assume volume means pool?<p>&gt; There was an implication in your statement that volume level was the level of granularity, yeah?<p>There was an implication that the volume level was the level of granularity for adding parity.<p>But that was not the implication for &quot;another backup <i>of your most important files</i>&quot;.<p>&gt; I’m noting that during on volume wide dedup can have the con that you can’t choose (but it looks like you can!) to manually duplicate data.<p>You can&#x27;t choose just by copying files around, but it&#x27;s pretty easy to set copies=2 on specific directories.  And I&#x27;d say that&#x27;s generally a better option, because it keeps your copies up to date at all times.  Just make sure snapshots are happening, and files in there will be very safe.<p>Manual duplication is the worst kind of duplication, so while it&#x27;s good to warn people that it won&#x27;t work with dedup on, actually losing the ability is not a big deal when you look at the variety of alternatives.  It only tips the balance in situations where dedup is near-useless to start with.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42002155" class="c"><input type="checkbox" id="c-42002155" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42001360">prev</a><span>|</span><a href="#42001330">next</a><span>|</span><label class="collapse" for="c-42002155">[-]</label><label class="expand" for="c-42002155">[1 more]</label></div><br/><div class="children"><div class="content">You can use any of the offline dupe finders to do this.<p>Like jdupes or duperemove.<p>I sent PR&#x27;s to both the ZFS folks and the duperemove folks to support the syscalls needed.<p>I actually have to go followup on the ZFS one, it took a while to review and i realized i completely forget to finish it up.</div><br/></div></div><div id="42001330" class="c"><input type="checkbox" id="c-42001330" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42002155">prev</a><span>|</span><a href="#42001923">next</a><span>|</span><label class="collapse" for="c-42001330">[-]</label><label class="expand" for="c-42001330">[1 more]</label></div><br/><div class="children"><div class="content">The author of the new file-based block cloning code had this in mind. A backround process would scan files and identify dupes, delete the dupes and replace them with cloned versions.<p>There are of course edge cases to consider to avoid data loss, but I imagine it might come soon, either officially or as a third-party tool.</div><br/></div></div><div id="42001923" class="c"><input type="checkbox" id="c-42001923" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42001330">prev</a><span>|</span><a href="#42002290">next</a><span>|</span><label class="collapse" for="c-42001923">[-]</label><label class="expand" for="c-42001923">[1 more]</label></div><br/><div class="children"><div class="content">I get the feeling that a hypothetical ZFS maintainer reading some literature on concurrent mark and sweep would be... inspirational, if not immediately helpful.<p>You should be able to detect duplicates online. Low priority sweeping is something else. But you can at least reduce pause times.</div><br/></div></div><div id="42002290" class="c"><input type="checkbox" id="c-42002290" checked=""/><div class="controls bullet"><span class="by">tiagod</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42001923">prev</a><span>|</span><a href="#42001970">next</a><span>|</span><label class="collapse" for="c-42002290">[-]</label><label class="expand" for="c-42002290">[7 more]</label></div><br/><div class="children"><div class="content">I run rdfind[1] as a cronjob to replace duplicates with hardlinks. Works fine!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;pauldreik&#x2F;rdfind">https:&#x2F;&#x2F;github.com&#x2F;pauldreik&#x2F;rdfind</a></div><br/><div id="42004449" class="c"><input type="checkbox" id="c-42004449" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002290">parent</a><span>|</span><a href="#42003419">next</a><span>|</span><label class="collapse" for="c-42004449">[-]</label><label class="expand" for="c-42004449">[1 more]</label></div><br/><div class="children"><div class="content">Quite cool, though it&#x27;s not as storage saving as deduplicating at e.g. N byte blocks, at block level.</div><br/></div></div><div id="42003419" class="c"><input type="checkbox" id="c-42003419" checked=""/><div class="controls bullet"><span class="by">AndrewDavis</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002290">parent</a><span>|</span><a href="#42004449">prev</a><span>|</span><a href="#42002307">next</a><span>|</span><label class="collapse" for="c-42003419">[-]</label><label class="expand" for="c-42003419">[3 more]</label></div><br/><div class="children"><div class="content">So this is great, if you&#x27;re just looking to deduplicate read only files.  Less so if you intend to write to them.  Write to one and they&#x27;re both updated.<p>Anyway.  Offline&#x2F;lazy dedup (not in the zfs dedup sense) is something that could be done in userspace,  at the file level on any filesystem that supports reflinks.  When a tool like rdfind finds a duplicate, instead of replacing with a hardlink, create a copy of the file with `copy_file_range(2)` and let the filesystem create a reflink to it.  Now you&#x27;ve got space savings and they&#x27;re two separate files so if one is written to the other remains the same.</div><br/><div id="42003625" class="c"><input type="checkbox" id="c-42003625" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42003419">parent</a><span>|</span><a href="#42003822">next</a><span>|</span><label class="collapse" for="c-42003625">[-]</label><label class="expand" for="c-42003625">[1 more]</label></div><br/><div class="children"><div class="content">How would this work if I have snapshots? Wouldn’t then the version of the file I just replaced still be in use there? But maybe I also need to store the copy again if I make another snapshot because the “original “ file isn’t part of the snapshot? So now I’m effectively storing more not less?</div><br/></div></div><div id="42003822" class="c"><input type="checkbox" id="c-42003822" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42003419">parent</a><span>|</span><a href="#42003625">prev</a><span>|</span><a href="#42002307">next</a><span>|</span><label class="collapse" for="c-42003822">[-]</label><label class="expand" for="c-42003822">[1 more]</label></div><br/><div class="children"><div class="content">copy_file_range already works on zfs, but it doesn&#x27;t guarantee anything interesting.<p>Basically all dupe tools that are modern use fideduprange, which is meant to tell the FS which things should be sharing data, and let it take care of the rest.
(BTRFS, bcachefs, etc support this ioctl, and zfs will soon too)<p>Unlike copy_file_range, it is meant for exactly this use case, and will tell you how many bytes were dedup&#x27;d, etc.</div><br/></div></div></div></div><div id="42002307" class="c"><input type="checkbox" id="c-42002307" checked=""/><div class="controls bullet"><span class="by">Wowfunhappy</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002290">parent</a><span>|</span><a href="#42003419">prev</a><span>|</span><a href="#42001970">next</a><span>|</span><label class="collapse" for="c-42002307">[-]</label><label class="expand" for="c-42002307">[2 more]</label></div><br/><div class="children"><div class="content">But then you have to be careful not to remove the one which happens to be the &quot;original&quot; or the hardlinks will break, right?</div><br/><div id="42002698" class="c"><input type="checkbox" id="c-42002698" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002307">parent</a><span>|</span><a href="#42001970">next</a><span>|</span><label class="collapse" for="c-42002698">[-]</label><label class="expand" for="c-42002698">[1 more]</label></div><br/><div class="children"><div class="content">No, pointing to an original is how soft links work.<p>Hard links are all equivalent.  A file has any number of hard links, and at least in theory you can&#x27;t distinguish between them.<p>The risk with hardlinks is that you might alter the file.  Reflinks remove that risk, and also perform very well.</div><br/></div></div></div></div></div></div><div id="42001970" class="c"><input type="checkbox" id="c-42001970" checked=""/><div class="controls bullet"><span class="by">LeoPanthera</span><span>|</span><a href="#42001288">parent</a><span>|</span><a href="#42002290">prev</a><span>|</span><a href="#42001154">next</a><span>|</span><label class="collapse" for="c-42001970">[-]</label><label class="expand" for="c-42001970">[7 more]</label></div><br/><div class="children"><div class="content">btrfs has this. You can deduplicate a filesystem after the fact, as an overnight cron job or whatever. I really wish ZFS could do this.</div><br/><div id="42002178" class="c"><input type="checkbox" id="c-42002178" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42001970">parent</a><span>|</span><a href="#42001154">next</a><span>|</span><label class="collapse" for="c-42002178">[-]</label><label class="expand" for="c-42002178">[6 more]</label></div><br/><div class="children"><div class="content">I sent a PR to add support for the necessary syscall (FIDUPERANGE) to zfs that i just have to clean up again.<p>Once that is in, any of the existing dupe finding tools that use it (IE jdupes, duperemove) will just work on ZFS.</div><br/><div id="42003956" class="c"><input type="checkbox" id="c-42003956" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002178">parent</a><span>|</span><a href="#42003758">next</a><span>|</span><label class="collapse" for="c-42003956">[-]</label><label class="expand" for="c-42003956">[1 more]</label></div><br/><div class="children"><div class="content">Note - anyone bored enough could already make any of these tools work by using FICLONERANGE (which ZFS already supports), but you&#x27;d have to do locking - lock, compare file ranges, clone, unlock.<p>Because FIDEDUPRANGE has the compare as part of the atomic guarantee, you don&#x27;t need to lock in userspace around using it, and so no dedup utility bothers to do FICLONERANGE + locking.
Also, ZFS is the only FS that implements FICLONERANGE but not FIDEDUPRANGE :)</div><br/></div></div><div id="42003758" class="c"><input type="checkbox" id="c-42003758" checked=""/><div class="controls bullet"><span class="by">edelbitter</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002178">parent</a><span>|</span><a href="#42003956">prev</a><span>|</span><a href="#42003813">next</a><span>|</span><label class="collapse" for="c-42003758">[-]</label><label class="expand" for="c-42003758">[2 more]</label></div><br/><div class="children"><div class="content">Knowing what you had to know to write that, would you dare using it?<p>Compression, encryption and streaming sparse files together are impressive already. But now we get a new BRT entry appearing out of nowhere, dedup index pruning one that was there a moment ago, all while correctly handling arbitrary errors in whatever simultaneous deduped writes, O_DIRECT writes, FALLOC_FL_PUNCH_HOLE and reads were waiting for the same range? Sounds like adding six new places to hold the wrong lock to me.</div><br/><div id="42003873" class="c"><input type="checkbox" id="c-42003873" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42003758">parent</a><span>|</span><a href="#42003813">next</a><span>|</span><label class="collapse" for="c-42003873">[-]</label><label class="expand" for="c-42003873">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Knowing what you had to know to write that, would you dare using it?&quot;<p>It&#x27;s no worse than anything else related to block cloning :)<p>ZFS already supports FICLONERANGE, the thing FIDEDUPRANGE changes is that the compare is part of the atomic guarantee.<p>So in fact, i&#x27;d argue it&#x27;s actually better than what is there now - yes, the hardest part is the locking, but the locking is handled by the dedup range call getting the right locks upfront, and passing them along, so nothing else is grabbing the wrong locks.  It actually has to because of the requirements to implement the ioctl properly. We have to be able to read both ranges, compare them, and clone them, all as an atomic operation wrt to concurrent writes. So instead of random things grabbing random locks, we pass the right locks around and everything verifies the locks.<p>This means fideduprange is not as fast as it maybe could be, but it does not run into the &quot;oops we forgot the right kind of lock&quot; issue.  At worst, it would deadlock, because it&#x27;s holding exclusive locks on all that it could need before it starts to do anything in order to guarantee both the compare and the clone are atomic.  So something trying to grab a lock forever under it will just deadlock.<p>This seemed the safest course of implementation.<p>ficlonerange is only atomic in the cloning, which means it does not have to read anything first, it can just do blind block cloning.  So it actually has a more complex (but theoretically faster) lock structure because of the relaxed constraints.</div><br/></div></div></div></div><div id="42003813" class="c"><input type="checkbox" id="c-42003813" checked=""/><div class="controls bullet"><span class="by">rattt</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42002178">parent</a><span>|</span><a href="#42003758">prev</a><span>|</span><a href="#42001154">next</a><span>|</span><label class="collapse" for="c-42003813">[-]</label><label class="expand" for="c-42003813">[2 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t jdupes like tools already work now that ZFS has reflink copy support?</div><br/><div id="42003839" class="c"><input type="checkbox" id="c-42003839" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#42001288">root</a><span>|</span><a href="#42003813">parent</a><span>|</span><a href="#42001154">next</a><span>|</span><label class="collapse" for="c-42003839">[-]</label><label class="expand" for="c-42003839">[1 more]</label></div><br/><div class="children"><div class="content">No, because none of these tools use copy_file_range. Because copy_file_range doesn&#x27;t guarantee deduplication or anything. It is meant to copy data.  So you could just end up copying data, when you aren&#x27;t even trying to copy anything at all.<p>All modern tools use FIDEDUPRANGE, which is an ioctl meant for explicitly this use case - telling the FS that two files have bytes that should be shared.<p>Under the covers, the FS does block cloning or whatever to make it happen.<p>Nothing is copied.<p>ZFS does support FICLONERANGE, which is the same as FIDEDUPRANGE but it does not verify the contents are the same prior to cloning.<p>Both are atomic WRT to concurrent writes, but for FIDEDUPRANGE that means the compare is part of the atomicness. So you don&#x27;t have to do any locking.<p>If you used FICLONERANGE, you&#x27;d need to lock the two file ranges, verify, clone, unlock<p>FIDEDUPRANGE does this for you.<p>So it is possible, with no changes to ZFS, to modify dedup tools to work on ZFS by changing them to use FICLONERANGE + locking if FIDEDUPRANGE does not exist.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42001154" class="c"><input type="checkbox" id="c-42001154" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42001288">prev</a><span>|</span><a href="#42004547">next</a><span>|</span><label class="collapse" for="c-42001154">[-]</label><label class="expand" for="c-42001154">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m so excited about fast dedup. I&#x27;ve been wanting to use ZFS deduping for ArchiveBox data for years, as I think fast dedup may finally make it viable to archive many millions of URLs in one collection and let the filesystem take care of compression across everything. So much of archive data is the same jquery.min.js, bootstrap.min.css, logo images, etc. repeated over and over in thousands of snapshots. Other tools compress within a crawl to create wacz or warc.gz files, but I don&#x27;t think anyone has tried to do compression across the entire database of all snapshots ever taken by a tool.<p>Big thank you to all the people that worked on it!<p>BTW has anyone tried a probabilistic dedup approach using soemthing like a bloom filter so you don&#x27;t have to store the entire dedup table of hashes verbatim? Collect groups of ~100 block hashes into a bucket each, and store a hyper compressed representation in a bloom filter. On write, lookup the hash of the block to write in the bloom filter, and if a potential dedup hit is detected, walk the 100 blocks in the matching bucket manually to look for any identical hashes. In theory you could do this with layers of bloom filters with different resolutions and dynamically swap out the heavier ones to disk when memory pressure is too high to keep the high resolution ones in RAM. Allowing the accuracy of the bloom filter to be changed as a tunable parameter would let people choose their preference around CPU time&#x2F;overhead:bytes saved ratio.</div><br/><div id="42001510" class="c"><input type="checkbox" id="c-42001510" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#42001154">parent</a><span>|</span><a href="#42001446">next</a><span>|</span><label class="collapse" for="c-42001510">[-]</label><label class="expand" for="c-42001510">[2 more]</label></div><br/><div class="children"><div class="content">Even with this change ZFS dedupe is still block-aligned, so it will not match repeated web assets well unless they exist at consistently identical offsets within the warc archives.<p>dm-vdo has the same behaviour.<p>You may be better off with long-range solid compression instead, or unpacking the warc files into a directory equivalent, or maybe there is some CDC-based FUSE system out there (Seafile perhaps)</div><br/><div id="42001583" class="c"><input type="checkbox" id="c-42001583" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42001154">root</a><span>|</span><a href="#42001510">parent</a><span>|</span><a href="#42001446">next</a><span>|</span><label class="collapse" for="c-42001583">[-]</label><label class="expand" for="c-42001583">[1 more]</label></div><br/><div class="children"><div class="content">I should clarify I don&#x27;t use WARCs at all with archivebox, it just stores raw files on the filsystem because I rely on ZFS for all my compression, so there is no offset alignment issue.<p>The wget extractor within archivebox can produce WARCs as an output but no parts of ArchiveBox are built to rely on those, they are just one of the optional extractors that can be run.</div><br/></div></div></div></div><div id="42001446" class="c"><input type="checkbox" id="c-42001446" checked=""/><div class="controls bullet"><span class="by">uniqueuid</span><span>|</span><a href="#42001154">parent</a><span>|</span><a href="#42001510">prev</a><span>|</span><a href="#42001693">next</a><span>|</span><label class="collapse" for="c-42001446">[-]</label><label class="expand" for="c-42001446">[4 more]</label></div><br/><div class="children"><div class="content">I get the use case, but in most cases (and particularly this one) I&#x27;m sure it would be much better to implement that client-side.<p>You may have seen in the WARC standard that they <i>already</i> do de-duplication based on hashes and use pointers after the first store. So this is exactly a case where FS-level dedup is not all that good.</div><br/><div id="42001481" class="c"><input type="checkbox" id="c-42001481" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42001154">root</a><span>|</span><a href="#42001446">parent</a><span>|</span><a href="#42001693">next</a><span>|</span><label class="collapse" for="c-42001481">[-]</label><label class="expand" for="c-42001481">[3 more]</label></div><br/><div class="children"><div class="content">WARC only does deduping within a single WARC, I&#x27;m talking about deduping across millions of WARCs.</div><br/><div id="42001506" class="c"><input type="checkbox" id="c-42001506" checked=""/><div class="controls bullet"><span class="by">uniqueuid</span><span>|</span><a href="#42001154">root</a><span>|</span><a href="#42001481">parent</a><span>|</span><a href="#42001693">next</a><span>|</span><label class="collapse" for="c-42001506">[-]</label><label class="expand" for="c-42001506">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not true, you commonly have CDX index files which allow for de-duplication across arbitrarily large archives. The internet archive could not reasonably operate without this level of abstraction.<p>[edit] Should add a link, this is a pretty good overview, but you can also look at implementations such as the new zeno crawler.<p><a href="https:&#x2F;&#x2F;support.archive-it.org&#x2F;hc&#x2F;en-us&#x2F;articles&#x2F;208001016-About-data-de-duplication" rel="nofollow">https:&#x2F;&#x2F;support.archive-it.org&#x2F;hc&#x2F;en-us&#x2F;articles&#x2F;208001016-A...</a></div><br/><div id="42001572" class="c"><input type="checkbox" id="c-42001572" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42001154">root</a><span>|</span><a href="#42001506">parent</a><span>|</span><a href="#42001693">next</a><span>|</span><label class="collapse" for="c-42001572">[-]</label><label class="expand" for="c-42001572">[1 more]</label></div><br/><div class="children"><div class="content">Ah cool, TIL, thanks for the link. I didn&#x27;t realize that was possible.<p>I know of the CDX index files produced by some tools but don&#x27;t know anything about the details&#x2F;that they could be used to dedup across WARCs, I&#x27;ve only been referencing the WARC file specs via IIPC&#x27;s old standards docs.</div><br/></div></div></div></div></div></div></div></div><div id="42001693" class="c"><input type="checkbox" id="c-42001693" checked=""/><div class="controls bullet"><span class="by">alchemist1e9</span><span>|</span><a href="#42001154">parent</a><span>|</span><a href="#42001446">prev</a><span>|</span><a href="#42004547">next</a><span>|</span><label class="collapse" for="c-42001693">[-]</label><label class="expand" for="c-42001693">[1 more]</label></div><br/><div class="children"><div class="content">While a slightly different use case, I suspect you’d like zbackup if you don’t know about it.</div><br/></div></div></div></div><div id="42004547" class="c"><input type="checkbox" id="c-42004547" checked=""/><div class="controls bullet"><span class="by">david_draco</span><span>|</span><a href="#42001154">prev</a><span>|</span><a href="#42002952">next</a><span>|</span><label class="collapse" for="c-42004547">[-]</label><label class="expand" for="c-42004547">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the copy_file_range discussion at the end, it would be great to be able to applying deduplication to selected files, identified by searching the filesystem for say &gt;1MB files which have identical hash.</div><br/></div></div><div id="42002952" class="c"><input type="checkbox" id="c-42002952" checked=""/><div class="controls bullet"><span class="by">rodarmor</span><span>|</span><a href="#42004547">prev</a><span>|</span><a href="#42003907">next</a><span>|</span><label class="collapse" for="c-42002952">[-]</label><label class="expand" for="c-42002952">[1 more]</label></div><br/><div class="children"><div class="content">General-purpose deduplication sounds good in theory but tends not to work out in practice. IPFS uses a rolling hash with variable-sized pieces, in an attempt to deduplicate data rysnc-style. However, in practice, it doesn&#x27;t actually make a difference, and adds complexity for no reason.</div><br/></div></div><div id="42003907" class="c"><input type="checkbox" id="c-42003907" checked=""/><div class="controls bullet"><span class="by">watersb</span><span>|</span><a href="#42002952">prev</a><span>|</span><a href="#42003801">next</a><span>|</span><label class="collapse" for="c-42003907">[-]</label><label class="expand" for="c-42003907">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used ZFS dedupe for a personal archive since dedupe was first introduced.<p>Currently, it seems to be reducing on-disk footprint by a factor of 3.<p>When I first started this project, 2TB hard drives were the largest available.<p>My current setup uses slow 2.5-inch hard drives; I attempt to improve things somewhat via NVMe-based Optane drives for cache.<p>Every few years, I try to do a better job of things but at this point, the best improvement would be radical simplification.<p>ZFS has served very well in terms of reliability. I haven&#x27;t lost data, and I&#x27;ve been able to catch lots of episodes of almost losing data. Or writing the wrong data.<p>Not entirely sure how I&#x27;d replace it, if I want something that can spot bit rot and correct it. ZFS scrub.</div><br/><div id="42003944" class="c"><input type="checkbox" id="c-42003944" checked=""/><div class="controls bullet"><span class="by">roygbiv2</span><span>|</span><a href="#42003907">parent</a><span>|</span><a href="#42003976">next</a><span>|</span><label class="collapse" for="c-42003944">[-]</label><label class="expand" for="c-42003944">[1 more]</label></div><br/><div class="children"><div class="content">Do you have data that is very obviously dedupeable? Or just a mix of things? A factor of three is not to be sniffed at.</div><br/></div></div><div id="42003976" class="c"><input type="checkbox" id="c-42003976" checked=""/><div class="controls bullet"><span class="by">emptiestplace</span><span>|</span><a href="#42003907">parent</a><span>|</span><a href="#42003944">prev</a><span>|</span><a href="#42003801">next</a><span>|</span><label class="collapse" for="c-42003976">[-]</label><label class="expand" for="c-42003976">[1 more]</label></div><br/><div class="children"><div class="content">Cache or ZIL (SLOG device)?</div><br/></div></div></div></div><div id="42003801" class="c"><input type="checkbox" id="c-42003801" checked=""/><div class="controls bullet"><span class="by">rkagerer</span><span>|</span><a href="#42003907">prev</a><span>|</span><a href="#42001336">next</a><span>|</span><label class="collapse" for="c-42003801">[-]</label><label class="expand" for="c-42003801">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love if dedicated hardware existing in disk controllers for calculating stuff like ECC could be enhanced to expose hashes of blocks to the system.  Getting this for free for all your I&#x2F;O would allow some pretty awesome things.</div><br/></div></div><div id="42001336" class="c"><input type="checkbox" id="c-42001336" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#42003801">prev</a><span>|</span><a href="#42001317">next</a><span>|</span><label class="collapse" for="c-42001336">[-]</label><label class="expand" for="c-42001336">[6 more]</label></div><br/><div class="children"><div class="content">I really wish we just had a completely different API as a filesystem. The API surface of filesystem on every OS is a complete disaster that we are locked into via backwards compatibility.</div><br/><div id="42001400" class="c"><input type="checkbox" id="c-42001400" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42001336">parent</a><span>|</span><a href="#42001977">next</a><span>|</span><label class="collapse" for="c-42001400">[-]</label><label class="expand" for="c-42001400">[1 more]</label></div><br/><div class="children"><div class="content">Internally ZFS is essentially an object store. There was some work which tried to expose it through an object store API. Sadly it seems to not have gone anywhere.<p>Tried to find the talk but failed, was sure I had seen it on a Delveloper Summit but alas.</div><br/></div></div><div id="42001977" class="c"><input type="checkbox" id="c-42001977" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001336">parent</a><span>|</span><a href="#42001400">prev</a><span>|</span><a href="#42001317">next</a><span>|</span><label class="collapse" for="c-42001977">[-]</label><label class="expand" for="c-42001977">[4 more]</label></div><br/><div class="children"><div class="content">Why is it a disaster and what would you replace it with? Is the AWS S3 style API an improvement?</div><br/><div id="42002724" class="c"><input type="checkbox" id="c-42002724" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#42001336">root</a><span>|</span><a href="#42001977">parent</a><span>|</span><a href="#42004546">prev</a><span>|</span><a href="#42003502">next</a><span>|</span><label class="collapse" for="c-42002724">[-]</label><label class="expand" for="c-42002724">[1 more]</label></div><br/><div class="children"><div class="content">High-density drives are usually zoned storage, and it&#x27;s pretty difficult to implement the regular filesystem API on top of that with any kind of reasonable performance (device- vs host- managed SMR). The S3 API can work great on zones, but only because it doesn&#x27;t let you modify an existing object without rewriting the whole thing, which is an extremely rough tradeoff.</div><br/></div></div><div id="42003502" class="c"><input type="checkbox" id="c-42003502" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#42001336">root</a><span>|</span><a href="#42001977">parent</a><span>|</span><a href="#42002724">prev</a><span>|</span><a href="#42001317">next</a><span>|</span><label class="collapse" for="c-42003502">[-]</label><label class="expand" for="c-42003502">[1 more]</label></div><br/><div class="children"><div class="content">It’s only a ‘disaster’ if you are using it exclusively programmatically and want to do special tuning.<p>File systems are pretty good if you have a mix of human and programmatic uses, especially when the programmatic cases are not very heavy duty.<p>The programmatic scenarios are often entirely human hostile, if you try to imagine what would be involved in actually using them. Like direct S3 access, for example.</div><br/></div></div></div></div></div></div><div id="42001317" class="c"><input type="checkbox" id="c-42001317" checked=""/><div class="controls bullet"><span class="by">tilt_error</span><span>|</span><a href="#42001336">prev</a><span>|</span><a href="#42001757">next</a><span>|</span><label class="collapse" for="c-42001317">[-]</label><label class="expand" for="c-42001317">[5 more]</label></div><br/><div class="children"><div class="content">If writing performance is critical, why bother with deduplication at writing time? Do deduplication afterwards, concurrently and with lower priority?</div><br/><div id="42002053" class="c"><input type="checkbox" id="c-42002053" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42001317">parent</a><span>|</span><a href="#42001867">next</a><span>|</span><label class="collapse" for="c-42002053">[-]</label><label class="expand" for="c-42002053">[1 more]</label></div><br/><div class="children"><div class="content">Keep in mind ZFS was created at a time when disks were glacial in comparison to CPUs. And, the fastest write is the one you don&#x27;t perform, so you can afford some CPU time to check for duplicate blocks.<p>That said, NVMe has changed that balance a lot, and you can afford a <i>lot</i> less before you&#x27;re bottlenecking the drives.</div><br/></div></div><div id="42001867" class="c"><input type="checkbox" id="c-42001867" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#42001317">parent</a><span>|</span><a href="#42002053">prev</a><span>|</span><a href="#42001994">next</a><span>|</span><label class="collapse" for="c-42001867">[-]</label><label class="expand" for="c-42001867">[1 more]</label></div><br/><div class="children"><div class="content">Because to make this work without a lot of copying, you would need to mutate things that ZFS absolutely does not want to make mutable.</div><br/></div></div><div id="42001994" class="c"><input type="checkbox" id="c-42001994" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001317">parent</a><span>|</span><a href="#42001867">prev</a><span>|</span><a href="#42001327">next</a><span>|</span><label class="collapse" for="c-42001994">[-]</label><label class="expand" for="c-42001994">[1 more]</label></div><br/><div class="children"><div class="content">If the block to be written is already being stored then you will match the hash and the block won&#x27;t have to be written. This can save a lot of write IO in real world use.</div><br/></div></div><div id="42001327" class="c"><input type="checkbox" id="c-42001327" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#42001317">parent</a><span>|</span><a href="#42001994">prev</a><span>|</span><a href="#42001757">next</a><span>|</span><label class="collapse" for="c-42001327">[-]</label><label class="expand" for="c-42001327">[1 more]</label></div><br/><div class="children"><div class="content">Kinda like log structured merge tree?</div><br/></div></div></div></div><div id="42001757" class="c"><input type="checkbox" id="c-42001757" checked=""/><div class="controls bullet"><span class="by">bastloing</span><span>|</span><a href="#42001317">prev</a><span>|</span><a href="#42002186">next</a><span>|</span><label class="collapse" for="c-42001757">[-]</label><label class="expand" for="c-42001757">[2 more]</label></div><br/><div class="children"><div class="content">Forget dedupe just use zfs compression, a lot more bang for your buck</div><br/><div id="42001895" class="c"><input type="checkbox" id="c-42001895" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#42001757">parent</a><span>|</span><a href="#42002186">next</a><span>|</span><label class="collapse" for="c-42001895">[-]</label><label class="expand" for="c-42001895">[1 more]</label></div><br/><div class="children"><div class="content">Unless your data-set is highly compressed media files.<p>In general, even during rsync operations one often turns off compression on large video files, as the compression operation has low or negative impact on storage&#x2F;transfers while eating ram and cpu power.<p>De-duplication is good for Virtual Machine OS images, as the majority of the storage cost is a replicated backing image.   =3</div><br/></div></div></div></div><div id="42002186" class="c"><input type="checkbox" id="c-42002186" checked=""/><div class="controls bullet"><span class="by">wpollock</span><span>|</span><a href="#42001757">prev</a><span>|</span><a href="#42001922">next</a><span>|</span><label class="collapse" for="c-42002186">[-]</label><label class="expand" for="c-42002186">[1 more]</label></div><br/><div class="children"><div class="content">When the lookup key is a hash, there&#x27;s no locality over the megabytes of the table. So don&#x27;t all the extra memory accesses to support dedup affect the L1 and L2 caches?  Has anyone at OpenZFS measured that?<p>It also occurs to me that spacial locality on spinning rust disks might be affected,  also affecting performance.</div><br/></div></div><div id="42001922" class="c"><input type="checkbox" id="c-42001922" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42002186">prev</a><span>|</span><a href="#42002615">next</a><span>|</span><label class="collapse" for="c-42001922">[-]</label><label class="expand" for="c-42001922">[1 more]</label></div><br/><div class="children"><div class="content">Knowing that your storage has really good inline dedupe is awesome and will affect how you design systems. Solid dedupe lets you effectively treat multiple copies of data as symlinks.</div><br/></div></div><div id="42002615" class="c"><input type="checkbox" id="c-42002615" checked=""/><div class="controls bullet"><span class="by">hhdhdbdb</span><span>|</span><a href="#42001922">prev</a><span>|</span><a href="#42002321">next</a><span>|</span><label class="collapse" for="c-42002615">[-]</label><label class="expand" for="c-42002615">[2 more]</label></div><br/><div class="children"><div class="content">Any timing attacks possible on a virtualized system using dedupe?<p>Eg find out what my neighbours have installed.<p>Or if the data before an SSH key is predictable, keep writing that out to disk guessing the next byte or something like that.</div><br/><div id="42003253" class="c"><input type="checkbox" id="c-42003253" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42002615">parent</a><span>|</span><a href="#42002321">next</a><span>|</span><label class="collapse" for="c-42003253">[-]</label><label class="expand" for="c-42003253">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you even need timing attacks if you can read the zpool statistics; you can ask for a histogram of deduped blocks.<p>Guessing one byte at a time is not possible though because dedupe is block-level in ZFS.</div><br/></div></div></div></div><div id="42002321" class="c"><input type="checkbox" id="c-42002321" checked=""/><div class="controls bullet"><span class="by">girishso</span><span>|</span><a href="#42002615">prev</a><span>|</span><a href="#42001245">next</a><span>|</span><label class="collapse" for="c-42002321">[-]</label><label class="expand" for="c-42002321">[2 more]</label></div><br/><div class="children"><div class="content">Off topic, any tool to deduplicate files across different external Hard disks?<p>Over the years I made multiple copies of my laptop HDD to different external HDDs, ended up with lots of duplicate copies of files.</div><br/><div id="42002466" class="c"><input type="checkbox" id="c-42002466" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42002321">parent</a><span>|</span><a href="#42001245">next</a><span>|</span><label class="collapse" for="c-42002466">[-]</label><label class="expand" for="c-42002466">[1 more]</label></div><br/><div class="children"><div class="content">How would you want the duplicates resolved? Just reported in some interface or would you want the duplicates deleted off some machines automatically?<p>There are a few different ways you could solve it but it depends on what final outcome you need.</div><br/></div></div></div></div><div id="42001245" class="c"><input type="checkbox" id="c-42001245" checked=""/><div class="controls bullet"><span class="by">dark-star</span><span>|</span><a href="#42002321">prev</a><span>|</span><a href="#42001853">next</a><span>|</span><label class="collapse" for="c-42001245">[-]</label><label class="expand" for="c-42001245">[5 more]</label></div><br/><div class="children"><div class="content">I wonder why they are having so much trouble getting this working properly with smaller RAM footprints. We have been using commercial storage appliances that have been able to do this for about a decade (at least) now, even on systems with &quot;little&quot; RAM (compared to the amount of disk storage attached).<p>Just store fingerprints in a database and run through that at night and fixup the block pointers...</div><br/><div id="42004704" class="c"><input type="checkbox" id="c-42004704" checked=""/><div class="controls bullet"><span class="by">olavgg</span><span>|</span><a href="#42001245">parent</a><span>|</span><a href="#42001299">next</a><span>|</span><label class="collapse" for="c-42004704">[-]</label><label class="expand" for="c-42004704">[1 more]</label></div><br/><div class="children"><div class="content">You can also use DragonFlyBSD with Hammer2, which supports both online and offline deduplication. It is very similar to ZFS in many ways. The big drawback though, is lack of file transfer protocols using RDMA.<p>I&#x27;ve also heard there are some experimental branches that makes it possible to run Hammer2 on FreeBSD. But FreeBSD also lacks RDMA support. For FreeBSD 15, Chelsio has sponsored NVMe-oF target, and initiator support. I think this is just TCP though.</div><br/></div></div><div id="42001299" class="c"><input type="checkbox" id="c-42001299" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42001245">parent</a><span>|</span><a href="#42004704">prev</a><span>|</span><a href="#42001293">next</a><span>|</span><label class="collapse" for="c-42001299">[-]</label><label class="expand" for="c-42001299">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and fixup the block pointers<p>That&#x27;s why. Due to reasons[1], ZFS does not have the capability to rewrite block pointers. It&#x27;s been a long requested feature[2] as it would also allow for defragmentation.<p>I&#x27;ve been thinking this could be solved using block pointer  indirection, like virtual memory, at the cost of a bit of speed.<p>But I&#x27;m by no means a ZFS developer, so there&#x27;s surely something I&#x27;m missing.<p>[1]: <a href="http:&#x2F;&#x2F;eworldproblems.mbaynton.com&#x2F;posts&#x2F;2014&#x2F;zfs-block-pointer-rewrite-status-2013&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;eworldproblems.mbaynton.com&#x2F;posts&#x2F;2014&#x2F;zfs-block-poin...</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;issues&#x2F;3582">https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;issues&#x2F;3582</a></div><br/><div id="42001699" class="c"><input type="checkbox" id="c-42001699" checked=""/><div class="controls bullet"><span class="by">phongn</span><span>|</span><a href="#42001245">root</a><span>|</span><a href="#42001299">parent</a><span>|</span><a href="#42001293">next</a><span>|</span><label class="collapse" for="c-42001699">[-]</label><label class="expand" for="c-42001699">[1 more]</label></div><br/><div class="children"><div class="content">It looks like they’re playing more with indirection features now (created for vdev removal) for other features. One of the recent summit hackathons sketched out using indirect vdevs to perform rebalancing.<p>Once you get a lot of snapshots, though, the indirection costs start to rise.</div><br/></div></div></div></div><div id="42001293" class="c"><input type="checkbox" id="c-42001293" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42001245">parent</a><span>|</span><a href="#42001299">prev</a><span>|</span><a href="#42001853">next</a><span>|</span><label class="collapse" for="c-42001293">[-]</label><label class="expand" for="c-42001293">[1 more]</label></div><br/><div class="children"><div class="content">Fixup block pointers is the one thing ZFS didn&#x27;t want to do.</div><br/></div></div></div></div><div id="42001853" class="c"><input type="checkbox" id="c-42001853" checked=""/><div class="controls bullet"><span class="by">eek2121</span><span>|</span><a href="#42001245">prev</a><span>|</span><a href="#42001926">next</a><span>|</span><label class="collapse" for="c-42001853">[-]</label><label class="expand" for="c-42001853">[6 more]</label></div><br/><div class="children"><div class="content">So many flaws. I want to see the author repeat this across 100TB of random data from multiple clients. He&#x2F;she&#x2F;whatever will quickly realize why this feature exists. One scenario I am aware of that uses another filesystem in a cloud setup saved 43% of disk space by using dedupe.<p>No, you won&#x27;t save much on a client system. That isn&#x27;t what the feature is made for.</div><br/><div id="42001900" class="c"><input type="checkbox" id="c-42001900" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42001853">parent</a><span>|</span><a href="#42003576">next</a><span>|</span><label class="collapse" for="c-42001900">[-]</label><label class="expand" for="c-42001900">[1 more]</label></div><br/><div class="children"><div class="content">When ZFS first came out I had visions of it being a turnkey RAID array replacement for nontechnical users. Pop out the oldest disk, pop in a new (larger one), wait for the pretty lights to change color. Done.<p>It is very clear that consumer was never a priority, and so I wonder what the venn diagram is of &#x27;client system&#x27; and &#x27;zfs filesystem&#x27;. Not that big right?</div><br/></div></div><div id="42003576" class="c"><input type="checkbox" id="c-42003576" checked=""/><div class="controls bullet"><span class="by">doublepg23</span><span>|</span><a href="#42001853">parent</a><span>|</span><a href="#42001900">prev</a><span>|</span><a href="#42001944">next</a><span>|</span><label class="collapse" for="c-42003576">[-]</label><label class="expand" for="c-42003576">[1 more]</label></div><br/><div class="children"><div class="content">I assuming the author is aware why the feature exists since they state in the second sentence they funded the improvement over the course of two years?</div><br/></div></div><div id="42001944" class="c"><input type="checkbox" id="c-42001944" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001853">parent</a><span>|</span><a href="#42003576">prev</a><span>|</span><a href="#42003312">next</a><span>|</span><label class="collapse" for="c-42001944">[-]</label><label class="expand" for="c-42001944">[2 more]</label></div><br/><div class="children"><div class="content">My reaction also. Dedupe is a must have for when you are storing hundreds of VMs. you WILL save so much data and inline dedupe will save a lot of write IO.</div><br/><div id="42001995" class="c"><input type="checkbox" id="c-42001995" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42001853">root</a><span>|</span><a href="#42001944">parent</a><span>|</span><a href="#42003312">next</a><span>|</span><label class="collapse" for="c-42001995">[-]</label><label class="expand" for="c-42001995">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an odd notion in the age of containers where dedupe is like, one of the core things we do (but stupidly: amongst dissimilar images there&#x27;s definitely more identical files then different ones).</div><br/></div></div></div></div><div id="42003312" class="c"><input type="checkbox" id="c-42003312" checked=""/><div class="controls bullet"><span class="by">edelbitter</span><span>|</span><a href="#42001853">parent</a><span>|</span><a href="#42001944">prev</a><span>|</span><a href="#42001926">next</a><span>|</span><label class="collapse" for="c-42003312">[-]</label><label class="expand" for="c-42003312">[1 more]</label></div><br/><div class="children"><div class="content">I tried two of the most non-random archives I had and was disappointed just as the author. For mail archives, I got 10%. For entire filesystems, I got.. just as much as with any other COW. Because indeed, I duplicate them only once. Later shared blocks are all over the place.</div><br/></div></div></div></div><div id="42001926" class="c"><input type="checkbox" id="c-42001926" checked=""/><div class="controls bullet"><span class="by">nisten</span><span>|</span><a href="#42001853">prev</a><span>|</span><a href="#42002231">next</a><span>|</span><label class="collapse" for="c-42001926">[-]</label><label class="expand" for="c-42001926">[3 more]</label></div><br/><div class="children"><div class="content">can someone smarter than me explain what happens when instead of the regular 4kb block size in kernel builds we use 16kb or 64kb block size or is that only for the memory part, i am confused. Will a larger block size make this thing good or bad?</div><br/><div id="42001969" class="c"><input type="checkbox" id="c-42001969" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42001926">parent</a><span>|</span><a href="#42002231">next</a><span>|</span><label class="collapse" for="c-42001969">[-]</label><label class="expand" for="c-42001969">[2 more]</label></div><br/><div class="children"><div class="content">Generally the smaller the dedupe block the better as you are far more likely to find a matching block. But larger blocks will reduce the number of hashes you have to store. In my experience 4KB is the sweet spot to maximize how much data you save.</div><br/><div id="42003657" class="c"><input type="checkbox" id="c-42003657" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42001926">root</a><span>|</span><a href="#42001969">parent</a><span>|</span><a href="#42002231">next</a><span>|</span><label class="collapse" for="c-42003657">[-]</label><label class="expand" for="c-42003657">[1 more]</label></div><br/><div class="children"><div class="content">So in this case I think it would make sense to have a separate pool where you store large files like media so you can save on the dedup for them.<p>Is there an inherent performance loss of using 64kB blocks on FS level when using storage devices that are 4kB under the hood?</div><br/></div></div></div></div></div></div><div id="42002231" class="c"><input type="checkbox" id="c-42002231" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42001926">prev</a><span>|</span><a href="#42002009">next</a><span>|</span><label class="collapse" for="c-42002231">[-]</label><label class="expand" for="c-42002231">[2 more]</label></div><br/><div class="children"><div class="content">My dream Git successor would use either dedupe or a simple cache plus copy-on-write so that repos can commit toolchains and dependencies and users wouldn’t need to worry about disk drive bloat.<p>Maybe someday…</div><br/><div id="42002868" class="c"><input type="checkbox" id="c-42002868" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42002231">parent</a><span>|</span><a href="#42002009">next</a><span>|</span><label class="collapse" for="c-42002868">[-]</label><label class="expand" for="c-42002868">[1 more]</label></div><br/><div class="children"><div class="content">It does dedup using Sha-1 on entire files. you might try git-lfs for your usecase though.</div><br/></div></div></div></div><div id="42002009" class="c"><input type="checkbox" id="c-42002009" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#42002231">prev</a><span>|</span><a href="#42001219">next</a><span>|</span><label class="collapse" for="c-42002009">[-]</label><label class="expand" for="c-42002009">[5 more]</label></div><br/><div class="children"><div class="content">OT: does anyone have a good way to dedupe iCloud Photos. Or my Dropbox photos?</div><br/><div id="42004733" class="c"><input type="checkbox" id="c-42004733" checked=""/><div class="controls bullet"><span class="by">EraYaN</span><span>|</span><a href="#42002009">parent</a><span>|</span><a href="#42002179">next</a><span>|</span><label class="collapse" for="c-42004733">[-]</label><label class="expand" for="c-42004733">[1 more]</label></div><br/><div class="children"><div class="content">digiKam can dedupe on actual similarity (so different resizes and formats of the same image). But it does take some time to calculate all the hashes.</div><br/></div></div><div id="42002179" class="c"><input type="checkbox" id="c-42002179" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42002009">parent</a><span>|</span><a href="#42004733">prev</a><span>|</span><a href="#42002201">next</a><span>|</span><label class="collapse" for="c-42002179">[-]</label><label class="expand" for="c-42002179">[1 more]</label></div><br/><div class="children"><div class="content">- <a href="https:&#x2F;&#x2F;github.com&#x2F;markfasheh&#x2F;duperemove">https:&#x2F;&#x2F;github.com&#x2F;markfasheh&#x2F;duperemove</a><p>- <a href="https:&#x2F;&#x2F;codeberg.org&#x2F;jbruchon&#x2F;jdupes" rel="nofollow">https:&#x2F;&#x2F;codeberg.org&#x2F;jbruchon&#x2F;jdupes</a> &#x2F; <a href="https:&#x2F;&#x2F;www.jdupes.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.jdupes.com&#x2F;</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;adrianlopezroche&#x2F;fdupes">https:&#x2F;&#x2F;github.com&#x2F;adrianlopezroche&#x2F;fdupes</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;pauldreik&#x2F;rdfind">https:&#x2F;&#x2F;github.com&#x2F;pauldreik&#x2F;rdfind</a></div><br/></div></div><div id="42002201" class="c"><input type="checkbox" id="c-42002201" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#42002009">parent</a><span>|</span><a href="#42002179">prev</a><span>|</span><a href="#42003689">next</a><span>|</span><label class="collapse" for="c-42002201">[-]</label><label class="expand" for="c-42002201">[1 more]</label></div><br/><div class="children"><div class="content">The built in Photos duplicate feature is the best choice for most people: it’s not just generic file-level dedupe but smart enough to do things like take three versions of the same photo and pick the highest-quality one, which is great if you ever had something like a RAW&#x2F;TIFF+JPEG workflow or mixed full res and thumbnails.</div><br/></div></div><div id="42003689" class="c"><input type="checkbox" id="c-42003689" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42002009">parent</a><span>|</span><a href="#42002201">prev</a><span>|</span><a href="#42001219">next</a><span>|</span><label class="collapse" for="c-42003689">[-]</label><label class="expand" for="c-42003689">[1 more]</label></div><br/><div class="children"><div class="content">Or better yet. A single photo I take of the kids will be stored in my camera roll. I will then share it with family using three different messengers. Now I have 4 copies. Each of the individual (recoded) are stored inside those messengers and also backed up. This even happens when sharing the same photo multiple times in different chats with the same messenger.<p>Is there any way to do de duplication here? Or just outright delete all the derivatives?</div><br/></div></div></div></div><div id="42001425" class="c"><input type="checkbox" id="c-42001425" checked=""/><div class="controls bullet"><span class="by">tjwds</span><span>|</span><a href="#42001219">prev</a><span>|</span><label class="collapse" for="c-42001425">[-]</label><label class="expand" for="c-42001425">[3 more]</label></div><br/><div class="children"><div class="content">Edit: disregard this, I was wrong and missed the comment deletion window.</div><br/><div id="42001459" class="c"><input type="checkbox" id="c-42001459" checked=""/><div class="controls bullet"><span class="by">gtirloni</span><span>|</span><a href="#42001425">parent</a><span>|</span><a href="#42001458">next</a><span>|</span><label class="collapse" for="c-42001459">[-]</label><label class="expand" for="c-42001459">[1 more]</label></div><br/><div class="children"><div class="content">HN will automatically redirect the submitter to a recent submission instead of allowing a new post... if it had a significant number of comments.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsfaq.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsfaq.html</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>