<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700470865350" as="style"/><link rel="stylesheet" href="styles.css?v=1700470865350"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://brooker.co.za/blog/2023/10/18/optimism.html">Optimism vs. Pessimism in Distributed Systems</a> <span class="domain">(<a href="https://brooker.co.za">brooker.co.za</a>)</span></div><div class="subtext"><span>surprisetalk</span> | <span>11 comments</span></div><br/><div><div id="38339942" class="c"><input type="checkbox" id="c-38339942" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#38338264">next</a><span>|</span><label class="collapse" for="c-38339942">[-]</label><label class="expand" for="c-38339942">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a beginner at distributed systems but I am curious many solutions seem in common with multithreaded systems: &quot;sharding&quot; which is to avoid coordination allows embarrassingly parallel scaling.<p>Time is the thing that we don&#x27;t have enough of at request time because a round trip takes years in computer time. (See &quot;latency numbers every programmer should know&quot;)<p>It seems contention is the critical factor: if I have a database key and I want to scale concurrent access to it, we are contended on that key to see if other users are writing conflicting changes to the same key, such as MVCC.<p>Optimistic - assume no contention (and handle it when it happens)<p>Pessimistic - assume lots of contention (prepare to handle it before it happens)</div><br/><div id="38344399" class="c"><input type="checkbox" id="c-38344399" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#38339942">parent</a><span>|</span><a href="#38341966">next</a><span>|</span><label class="collapse" for="c-38344399">[-]</label><label class="expand" for="c-38344399">[1 more]</label></div><br/><div class="children"><div class="content">As you noted, there are a lot of similarities between parallel programming and distributed computing.<p>The coordination of shared resources is the key problem in both fields. Distributed computing is more complex since you&#x27;re adding in the concept of communication which may be unreliable.</div><br/></div></div><div id="38341966" class="c"><input type="checkbox" id="c-38341966" checked=""/><div class="controls bullet"><span class="by">adra</span><span>|</span><a href="#38339942">parent</a><span>|</span><a href="#38344399">prev</a><span>|</span><a href="#38341696">next</a><span>|</span><label class="collapse" for="c-38341966">[-]</label><label class="expand" for="c-38341966">[2 more]</label></div><br/><div class="children"><div class="content">Even a naive sharded approach requires coordination if you want a scalable solution. Where do you send keys when there are 4 shard buckets? What happens when we want 5, or 8, or 32 shard groups? Just yolo turn off all writes, toggle some config and turn everything back on? Not great. You&#x27;ve changed the shard selection of a key from 2 to 11? What happens to all the previously persisted keys that were written to 2? The answer is unsurprisingly complicated, and depending on the system you&#x27;re writing, this can be a really hard to solve against if you haven&#x27;t prepared to grow (or shrink).</div><br/><div id="38342253" class="c"><input type="checkbox" id="c-38342253" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#38339942">root</a><span>|</span><a href="#38341966">parent</a><span>|</span><a href="#38341696">next</a><span>|</span><label class="collapse" for="c-38342253">[-]</label><label class="expand" for="c-38342253">[1 more]</label></div><br/><div class="children"><div class="content">All your questions seem to revolve around “how does sharding even work?”</div><br/></div></div></div></div><div id="38341696" class="c"><input type="checkbox" id="c-38341696" checked=""/><div class="controls bullet"><span class="by">uluyol</span><span>|</span><a href="#38339942">parent</a><span>|</span><a href="#38341966">prev</a><span>|</span><a href="#38340420">next</a><span>|</span><label class="collapse" for="c-38341696">[-]</label><label class="expand" for="c-38341696">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the main difference would be that distributed systems have more failure modes to be concerned with and that dictates a lot.</div><br/><div id="38342249" class="c"><input type="checkbox" id="c-38342249" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38339942">root</a><span>|</span><a href="#38341696">parent</a><span>|</span><a href="#38340420">next</a><span>|</span><label class="collapse" for="c-38342249">[-]</label><label class="expand" for="c-38342249">[1 more]</label></div><br/><div class="children"><div class="content">In theory it&#x27;s the same if your model allows for the scheduler to preempt a thread and never schedule it again.</div><br/></div></div></div></div><div id="38340420" class="c"><input type="checkbox" id="c-38340420" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#38339942">parent</a><span>|</span><a href="#38341696">prev</a><span>|</span><a href="#38338264">next</a><span>|</span><label class="collapse" for="c-38340420">[-]</label><label class="expand" for="c-38340420">[1 more]</label></div><br/><div class="children"><div class="content">Yes,distributed systems problems and multi threading problems tend to have very similar solutions. Contention is the critical factor indeed - if there&#x27;s no coordination needed, then we can keep scaling forever.</div><br/></div></div></div></div><div id="38338264" class="c"><input type="checkbox" id="c-38338264" checked=""/><div class="controls bullet"><span class="by">slowhadoken</span><span>|</span><a href="#38339942">prev</a><span>|</span><label class="collapse" for="c-38338264">[-]</label><label class="expand" for="c-38338264">[3 more]</label></div><br/><div class="children"><div class="content">Yeah optimism and pessimism both agree something is wrong</div><br/><div id="38339948" class="c"><input type="checkbox" id="c-38339948" checked=""/><div class="controls bullet"><span class="by">cdot2</span><span>|</span><a href="#38338264">parent</a><span>|</span><label class="collapse" for="c-38339948">[-]</label><label class="expand" for="c-38339948">[2 more]</label></div><br/><div class="children"><div class="content">I think by &quot;something is wrong&quot; you mean that data has changed and if data hasn&#x27;t changed then the coordinating method of a distributed system isn&#x27;t very relevant</div><br/><div id="38341773" class="c"><input type="checkbox" id="c-38341773" checked=""/><div class="controls bullet"><span class="by">slowhadoken</span><span>|</span><a href="#38338264">root</a><span>|</span><a href="#38339948">parent</a><span>|</span><label class="collapse" for="c-38341773">[-]</label><label class="expand" for="c-38341773">[1 more]</label></div><br/><div class="children"><div class="content">problems have solutions. I don&#x27;t mean &quot;wrong&quot; as in &quot;end of the world&quot;</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>