<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735376451365" as="style"/><link rel="stylesheet" href="styles.css?v=1735376451365"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fhur.me/posts/2024/thats-not-an-abstraction">That&#x27;s not an abstraction, that&#x27;s a layer of indirection</a> <span class="domain">(<a href="https://fhur.me">fhur.me</a>)</span></div><div class="subtext"><span>fagnerbrack</span> | <span>76 comments</span></div><br/><div><div id="42528941" class="c"><input type="checkbox" id="c-42528941" checked=""/><div class="controls bullet"><span class="by">voidhorse</span><span>|</span><a href="#42528266">next</a><span>|</span><label class="collapse" for="c-42528941">[-]</label><label class="expand" for="c-42528941">[8 more]</label></div><br/><div class="children"><div class="content">The best way to achieve a good abstraction is to recall what the word meant before computer science: namely, something closer to <i>generalization</i>.<p>In computing, we emphasize the communicational (i.e. interface) aspects of our code, and, in this respect, tend to focus on an &quot;abstraction&quot;&#x27;s role in hiding information. But a <i>good</i> abstraction does more than simply hide detail, it <i>generalizes</i> particulars into a new kind of &quot;object&quot; that is easier to reason about.<p>If you keep this in mind, you&#x27;ll realize that having a lot of particulars to identify <i>shared properties</i> that you can abstract away is a prerequisite. The best abstractions I&#x27;ve seen have always come into being only <i>after</i> a significant amount of particularized code had already been written. It is only then that you can identify the actual common properties and patterns of use. Contrarily, abstractions that are built upfront to try and do little more than hide details or to account for potential similarities or complexity, instead of <i>actual</i> already existent complexity are typically far more confusing and poorly designed.</div><br/><div id="42529144" class="c"><input type="checkbox" id="c-42529144" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#42528941">parent</a><span>|</span><a href="#42529115">next</a><span>|</span><label class="collapse" for="c-42529144">[-]</label><label class="expand" for="c-42529144">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly the point, also in other comments, quoting Dijkstra.<p>Abstraction not only hide details, but also add semantic value.</div><br/></div></div><div id="42529115" class="c"><input type="checkbox" id="c-42529115" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#42528941">parent</a><span>|</span><a href="#42529144">prev</a><span>|</span><a href="#42528266">next</a><span>|</span><label class="collapse" for="c-42529115">[-]</label><label class="expand" for="c-42529115">[6 more]</label></div><br/><div class="children"><div class="content">Computers are to manipulate data.<p>Data = representations = abstractions<p>This article is so fundamentally lost that it forgets what computers are for.<p>Computers exist to implement abstractions.</div><br/><div id="42529482" class="c"><input type="checkbox" id="c-42529482" checked=""/><div class="controls bullet"><span class="by">javcasas</span><span>|</span><a href="#42528941">root</a><span>|</span><a href="#42529115">parent</a><span>|</span><a href="#42529123">next</a><span>|</span><label class="collapse" for="c-42529482">[-]</label><label class="expand" for="c-42529482">[1 more]</label></div><br/><div class="children"><div class="content">Computers are to manipulate data, not to manipulate a pointer to a pointer to a pointer to a pointer to data.<p>They can do that too, but the cache miss cost already makes that expensive.</div><br/></div></div><div id="42529123" class="c"><input type="checkbox" id="c-42529123" checked=""/><div class="controls bullet"><span class="by">dishsoap</span><span>|</span><a href="#42528941">root</a><span>|</span><a href="#42529115">parent</a><span>|</span><a href="#42529482">prev</a><span>|</span><a href="#42528266">next</a><span>|</span><label class="collapse" for="c-42529123">[-]</label><label class="expand" for="c-42529123">[4 more]</label></div><br/><div class="children"><div class="content">Did you even read it?</div><br/><div id="42529126" class="c"><input type="checkbox" id="c-42529126" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#42528941">root</a><span>|</span><a href="#42529123">parent</a><span>|</span><a href="#42528266">next</a><span>|</span><label class="collapse" for="c-42529126">[-]</label><label class="expand" for="c-42529126">[3 more]</label></div><br/><div class="children"><div class="content">Unfortunately, I did. It is an attempt to approach complexity, cognitive load and high entropy in code, jumping to conclusions prematurely while suggesting a solution that is worse than the problem.</div><br/><div id="42529153" class="c"><input type="checkbox" id="c-42529153" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#42528941">root</a><span>|</span><a href="#42529126">parent</a><span>|</span><a href="#42528266">next</a><span>|</span><label class="collapse" for="c-42529153">[-]</label><label class="expand" for="c-42529153">[2 more]</label></div><br/><div class="children"><div class="content">I would really like to convince you that you are missing something very important. Please try to make sense of the article, reading it again a trying to find cases where it makes sense for you.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42528266" class="c"><input type="checkbox" id="c-42528266" checked=""/><div class="controls bullet"><span class="by">danparsonson</span><span>|</span><a href="#42528941">prev</a><span>|</span><a href="#42529504">next</a><span>|</span><label class="collapse" for="c-42528266">[-]</label><label class="expand" for="c-42528266">[17 more]</label></div><br/><div class="children"><div class="content">Perhaps this is a minor nitpick, but<p>&gt; Abstractions are also the enemy of simplicity. Each new abstraction is supposed to make things simpler—that’s the promise, right?<p>Not exactly, no. The purpose of abstraction is to hide implementation detail, and thereby insulate one part of the codebase&#x2F;application&#x2F;system from variations in another. Graphics APIs for example - yes your code may be simpler for not having to deal with the register-level minutiae of pushing individual triangles, but the core benefit is that the same code should work on multiple different hardware devices.<p>Good abstractions break a codebase up into compartments - if you drop a grenade in one (change the requirements for example), then the others are unaffected and the remedial work required is much less.</div><br/><div id="42528515" class="c"><input type="checkbox" id="c-42528515" checked=""/><div class="controls bullet"><span class="by">cpeterso</span><span>|</span><a href="#42528266">parent</a><span>|</span><a href="#42528995">next</a><span>|</span><label class="collapse" for="c-42528515">[-]</label><label class="expand" for="c-42528515">[4 more]</label></div><br/><div class="children"><div class="content">“The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.” — Edsger Dijkstra<p>But sometimes a new semantic level isn’t needed. Abstraction gets so much press when you might just need some good ol’ fashioned information hiding and separation of concerns.</div><br/><div id="42528724" class="c"><input type="checkbox" id="c-42528724" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528515">parent</a><span>|</span><a href="#42528852">next</a><span>|</span><label class="collapse" for="c-42528724">[-]</label><label class="expand" for="c-42528724">[1 more]</label></div><br/><div class="children"><div class="content">This is such a great quote, and helps explain what is a good abstraction.<p>Because CRDTs have been in the zeitgeist a lot lately, I want to pick them as an example of a &quot;good&quot; abstraction.<p>CRDTs have mathematical properties which can be described and understood independently of a specific implementation. And importantly, you can judge whether an implementation is correct with reference to these abstract rules.<p>This means that when using a CRDT, you largely can treat it as a reliably-solved problem. Once you understand the concepts, and work out how to use the library you&#x27;ve picked, you don&#x27;t have to think about the details. Though that doesn&#x27;t mean sometimes the behaviour can be surprising:<p><a href="https:&#x2F;&#x2F;www.moment.dev&#x2F;blog&#x2F;lies-i-was-told-pt-1" rel="nofollow">https:&#x2F;&#x2F;www.moment.dev&#x2F;blog&#x2F;lies-i-was-told-pt-1</a><p>TCP and HTTP are great examples too, though interestingly I don&#x27;t know if they rely on mathematical definitions so much as just being extremely widespread to the point that reliable implementations are available anywhere you care to write code.<p>I like this article which also leans on the Dijkstra quote:<p><a href="https:&#x2F;&#x2F;www.pathsensitive.com&#x2F;2022&#x2F;03&#x2F;abstraction-not-what-you-think-it-is.html?m=1" rel="nofollow">https:&#x2F;&#x2F;www.pathsensitive.com&#x2F;2022&#x2F;03&#x2F;abstraction-not-what-y...</a></div><br/></div></div><div id="42528852" class="c"><input type="checkbox" id="c-42528852" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528515">parent</a><span>|</span><a href="#42528724">prev</a><span>|</span><a href="#42528995">next</a><span>|</span><label class="collapse" for="c-42528852">[-]</label><label class="expand" for="c-42528852">[2 more]</label></div><br/><div class="children"><div class="content">&gt; some good ol’ fashioned information hiding and separation of concerns.<p>that&#x27;s exactly what you do to implement an abstraction isnt it?</div><br/><div id="42529070" class="c"><input type="checkbox" id="c-42529070" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528852">parent</a><span>|</span><a href="#42528995">next</a><span>|</span><label class="collapse" for="c-42529070">[-]</label><label class="expand" for="c-42529070">[1 more]</label></div><br/><div class="children"><div class="content">In the same way wood is used to build a house.<p>That you used wood doesn’t mean you built a house.</div><br/></div></div></div></div></div></div><div id="42528995" class="c"><input type="checkbox" id="c-42528995" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#42528266">parent</a><span>|</span><a href="#42528515">prev</a><span>|</span><a href="#42529590">next</a><span>|</span><label class="collapse" for="c-42528995">[-]</label><label class="expand" for="c-42528995">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The purpose of abstraction is to hide implementation detail<p>Technically, that&#x27;s encapsulation, though the sentiment is close, I think.<p>I rather view it as a matter of semantics. At one low level, you have operations that deal with some concrete interface or API, etc. You bundle those operations up behind an abstraction, providing methods whose names involve your application domain. Perhaps they are still at a technical level, and you bundle those up behind another abstraction, whose method names involve your <i>business</i> domain.<p>Yes, the lower level details are hidden from the higher levels, but <i>the hiding is not the point</i>. The point is to be able to write code that readily corresponds to the problem you are trying to solve.</div><br/></div></div><div id="42529590" class="c"><input type="checkbox" id="c-42529590" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42528266">parent</a><span>|</span><a href="#42528995">prev</a><span>|</span><a href="#42528976">next</a><span>|</span><label class="collapse" for="c-42529590">[-]</label><label class="expand" for="c-42529590">[1 more]</label></div><br/><div class="children"><div class="content">That would be encapsulation, not abstraction.</div><br/></div></div><div id="42528976" class="c"><input type="checkbox" id="c-42528976" checked=""/><div class="controls bullet"><span class="by">voidhorse</span><span>|</span><a href="#42528266">parent</a><span>|</span><a href="#42529590">prev</a><span>|</span><a href="#42528513">next</a><span>|</span><label class="collapse" for="c-42528976">[-]</label><label class="expand" for="c-42528976">[1 more]</label></div><br/><div class="children"><div class="content">While this is how the term is often used, I think it&#x27;s cavalier use of language and confuses abstraction for <i>modularity</i>, and this linguistic confusion is one of the reasons a lot of programmers write bad &quot;abstractions&quot;.<p>Organizing your code into components that are as independent as possible is a good practice and is the pursuit of modularity. A proper abstraction on the other hand, is a generalization that simplifies a <i>conceptual layer</i> in your code base.<p>Abstraction often <i>enables</i> greater modularity as a consequence, but they are not the same thing. For example, in the problem of text editing, people eventually realized that the manipulation of text is typically line oriented. Thinking of a text file as a collection of lines may seem like an obvious and modest abstraction, but it works well. This abstraction, in turn, leads to other couplings (e.g. line oriented motion is highly dependent on the line abstraction), but it also leads to potential modularity (e.g. printer code may no longer need to understand exactly how a display renders each character of text in a grid, instead, it too can work on &quot;lines&quot;). Good abstractions support modularity to the extent that they establish a shared domain of objects to communicate about and across systems, but they do not necessarily produce modularity in themselves.</div><br/></div></div><div id="42528513" class="c"><input type="checkbox" id="c-42528513" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#42528266">parent</a><span>|</span><a href="#42528976">prev</a><span>|</span><a href="#42528373">next</a><span>|</span><label class="collapse" for="c-42528513">[-]</label><label class="expand" for="c-42528513">[5 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; but the core benefit is that the same code should work on multiple different hardware devices.<p>I came here to say this. Attractions act as a bridge between things which allow those things to change independently.<p>Using an ORM allows my program to easily work against multiple sql databases. Using a compiler allows me to target different hardware. Using standard protocols allows me to communicate with different programs. Using libraries to do say email hides me from those protocols and allows me to adapt to service providers Using APIs not protocols.<p>In other words the abstraction is designed to hide a layer (which can change) from a program not interested in that level of change.<p>The key is to stop abstracting when the program cares. By all means encapsulate rules and processes, but they&#x27;re a direct implementation of those rules and processes.<p>One can argue my &quot;calculateLeaveForEmployee&quot; function is an &quot;abstraction&quot; - but that would be a misnomer. Since there&#x27;s only one set of rules in play (the set that matters now) its an implementation. An abstraction supports (at least) two things at the same time.</div><br/><div id="42528838" class="c"><input type="checkbox" id="c-42528838" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528513">parent</a><span>|</span><a href="#42529602">next</a><span>|</span><label class="collapse" for="c-42528838">[-]</label><label class="expand" for="c-42528838">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Using an ORM allows my program to easily work against multiple sql databases.<p>A curious example, since most developers who&#x27;ve worked on any project with significant amount of data in a database would likely disagree.<p>IMO, ORMs mostly allow using programming-language-of-choice as a syntax for relational queries instead of constructing it by hand on top of serialization and deserialization of objects into rows and vice versa.</div><br/><div id="42529573" class="c"><input type="checkbox" id="c-42529573" checked=""/><div class="controls bullet"><span class="by">zharknado</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528838">parent</a><span>|</span><a href="#42528922">next</a><span>|</span><label class="collapse" for="c-42529573">[-]</label><label class="expand" for="c-42529573">[1 more]</label></div><br/><div class="children"><div class="content">Yes, ORMs came to mind for me as an example of indirection without abstraction. If you accept OP’s litmus test of “how often do I have to peek under the hood” I think ORMs generally don’t score particularly well.</div><br/></div></div><div id="42528922" class="c"><input type="checkbox" id="c-42528922" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528838">parent</a><span>|</span><a href="#42529573">prev</a><span>|</span><a href="#42529602">next</a><span>|</span><label class="collapse" for="c-42528922">[-]</label><label class="expand" for="c-42528922">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, given that most sql dialects have subtle differences that make them noncompatible with one another, and most ORMs have support for dipping into raw sql, sufficiently large systems tend to end up coupled with a particular database anyway. That&#x27;s not to mention that the BAs will want raw sql access for report writing and switching systems breaks all of their scripts too.</div><br/></div></div></div></div><div id="42529602" class="c"><input type="checkbox" id="c-42529602" checked=""/><div class="controls bullet"><span class="by">javcasas</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528513">parent</a><span>|</span><a href="#42528838">prev</a><span>|</span><a href="#42528373">next</a><span>|</span><label class="collapse" for="c-42529602">[-]</label><label class="expand" for="c-42529602">[1 more]</label></div><br/><div class="children"><div class="content">&gt; allows my program to easily work against multiple sql databases<p>How many times have you required that your program runs against different sql databases without modification?<p>I mean, how many times have you required your plane to be able to fly in the different atmospheres of different planets of the Solar System?<p>Unless you are NASA, I suggest you cut the complexity and just make a plane that can fly well on Earth&#x27;s atmosphere.</div><br/></div></div></div></div><div id="42528373" class="c"><input type="checkbox" id="c-42528373" checked=""/><div class="controls bullet"><span class="by">uoaei</span><span>|</span><a href="#42528266">parent</a><span>|</span><a href="#42528513">prev</a><span>|</span><a href="#42528437">next</a><span>|</span><label class="collapse" for="c-42528373">[-]</label><label class="expand" for="c-42528373">[3 more]</label></div><br/><div class="children"><div class="content">In short: good abstractions simplify by centralizing operational logic. But it&#x27;s not until a certain scale where that option is more efficient from bespoke implementations.</div><br/><div id="42528896" class="c"><input type="checkbox" id="c-42528896" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528373">parent</a><span>|</span><a href="#42528437">next</a><span>|</span><label class="collapse" for="c-42528896">[-]</label><label class="expand" for="c-42528896">[2 more]</label></div><br/><div class="children"><div class="content">A heuristic we use at work is to not introduce an abstraction layer until there are at least two different implementations required.<p>That is if you think you&#x27;ll probably need multiple implications, delay introducing an abstraction until you actually do.<p>Also, there are different ways of providing abstraction.<p>Perhaps you don&#x27;t need to abstract the entire implementation but, as an example, rather change one parameter from passing a value to passing a function returning a value.</div><br/><div id="42529143" class="c"><input type="checkbox" id="c-42529143" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42528266">root</a><span>|</span><a href="#42528896">parent</a><span>|</span><a href="#42528437">next</a><span>|</span><label class="collapse" for="c-42529143">[-]</label><label class="expand" for="c-42529143">[1 more]</label></div><br/><div class="children"><div class="content">That touches on a couple related principles:<p>- not doing extra work now if it&#x27;s not necessary yet and if it&#x27;s as cheap to do later<p>- delaying building a thing till you know what that thing should be</div><br/></div></div></div></div></div></div><div id="42528437" class="c"><input type="checkbox" id="c-42528437" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#42528266">parent</a><span>|</span><a href="#42528373">prev</a><span>|</span><a href="#42529504">next</a><span>|</span><label class="collapse" for="c-42528437">[-]</label><label class="expand" for="c-42528437">[1 more]</label></div><br/><div class="children"><div class="content">A good abstraction is like documentation written in code.</div><br/></div></div></div></div><div id="42529504" class="c"><input type="checkbox" id="c-42529504" checked=""/><div class="controls bullet"><span class="by">aktenlage</span><span>|</span><a href="#42528266">prev</a><span>|</span><a href="#42529582">next</a><span>|</span><label class="collapse" for="c-42529504">[-]</label><label class="expand" for="c-42529504">[1 more]</label></div><br/><div class="children"><div class="content">Interesting read, although I don&#x27;t agree with everything. I like the distinction between different qualities of abstractions, made in the beginning. The following bashing of abstractions is too generalized for my taste.<p>The best part comes close to the end:<p>&gt; Asymmetry of abstraction costs<p>&gt; There’s also a certain asymmetry to abstraction. The author of an abstraction enjoys its benefits immediately—it makes their code look cleaner, easier to write, more elegant, or perhaps more flexible. But the cost of maintaining that abstraction often falls on others: future developers, maintainers, and performance engineers who have to work with the code. They’re the ones who have to peel back the layers, trace the indirections, and make sense of how things fit together. They’re the ones paying the real cost of unnecessary abstraction.</div><br/></div></div><div id="42529582" class="c"><input type="checkbox" id="c-42529582" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42529504">prev</a><span>|</span><a href="#42528745">next</a><span>|</span><label class="collapse" for="c-42529582">[-]</label><label class="expand" for="c-42529582">[1 more]</label></div><br/><div class="children"><div class="content">Lots of crud apps add 3-tier architecture that end up something that could be 2 tier.<p>People add it just in case but the case never materializes- for some probably do but ones I worked with not.</div><br/></div></div><div id="42528745" class="c"><input type="checkbox" id="c-42528745" checked=""/><div class="controls bullet"><span class="by">Darmani</span><span>|</span><a href="#42529582">prev</a><span>|</span><a href="#42528656">next</a><span>|</span><label class="collapse" for="c-42528745">[-]</label><label class="expand" for="c-42528745">[2 more]</label></div><br/><div class="children"><div class="content">TCP is great. Long chains of one-line functions that just permute the arguments really suck. These both get called abstraction, and yet they&#x27;re quite different.<p>But then you hear people describe abstraction <i>ahem</i> abstractly. &quot;Abstraction lets you think at a higher level,&quot; &quot;abstraction hides implementation detail,&quot; and it&#x27;s clear that neither of those things are really abstractions.<p>As the OP mentions, we have a great term for those long chains of one-line functions: indirection. But what is TCP? TCP is a <i>protocol</i>. It is not just giving a higher-level way to think about the levels underneath it in the 7-layer networking model. It is not just something that hides the implementations of the IP or Ethernet protocols. It is its own implementation of a new thing. TCP has its own interface and its own promises made to consumers. It is implemented using lower-level protocols, yes, but it adds something that was fundamentally not there before.<p>I think things like TCP, the idea of a file, and the idea of a thread are best put into another category. They are not simply higher level lenses to the network, the hard drive, or the preemptive interrupt feature of a processor. They are concepts, as described in Daniel Jackson&#x27;s book &quot;The Essence of Software,&quot; by far the best software design book I&#x27;ve read.<p>There is something else that does match the way people talk about abstraction. When you say &quot;This function changes this library from the uninitialized state to the initialized state,&quot; you have collapsed the exponentially-large number of settings of bits it could actually be in down to two abstract states, &quot;uninitialized&quot; and &quot;initialized,&quot; while claiming that this simpler description provides a useful model for describing the behavior of that and other functions. That&#x27;s the thing that fulfills Dijkstra&#x27;s famous edict about abstraction, that it &quot;create[s] a new semantic level in which one can be absolutely precise.&quot; And it&#x27;s not part of the code itself, but rather a tool that can be used to describe code.<p>It takes a lot more to explain true abstraction, but I&#x27;ve already written this up (cf.: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30840873">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30840873</a> ). And I encourage anyone who still wants to understand abstraction more deeply to go to the primary sources and try to understand abstract interpretation in program analysis or abstraction refinement in formal verification and program derivation.</div><br/><div id="42529527" class="c"><input type="checkbox" id="c-42529527" checked=""/><div class="controls bullet"><span class="by">cloogshicer</span><span>|</span><a href="#42528745">parent</a><span>|</span><a href="#42528656">next</a><span>|</span><label class="collapse" for="c-42529527">[-]</label><label class="expand" for="c-42529527">[1 more]</label></div><br/><div class="children"><div class="content">Hey Jimmy, I&#x27;ve read your comment and also your article in the past with great interest. This topic is absolutely <i>fascinating</i> to me.<p>I just re-read your article but unfortunately I still struggle to really understand it. I believe you have a lot of experience in this, so I&#x27;d love to read a more dumbed down version of it with less math and references to PL concepts and more practical examples. Like, this piece of code does not contain an abstraction, because X, and this piece of code does, because Y.<p>Keep up the good work!</div><br/></div></div></div></div><div id="42528656" class="c"><input type="checkbox" id="c-42528656" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#42528745">prev</a><span>|</span><a href="#42529576">next</a><span>|</span><label class="collapse" for="c-42528656">[-]</label><label class="expand" for="c-42528656">[4 more]</label></div><br/><div class="children"><div class="content">I got a piece of advice writing UI code a long time ago: Don&#x27;t marry your display code to your business logic.<p>I&#x27;d like to say this has served me well. It&#x27;s the reason I never went for JSX or other frameworks that put logical code into templates or things like that. That is one abstraction I found unhelpful.<p>However, I&#x27;ve come around to not taking that advice as literally as I used to. Looking back over 25 years of code, I can see a lot of times I tried to abstract away display code in ways that made it exceedingly difficult to detect why it only failed on certain pieces of data. Sometimes this was sheep shaving tightly bound code into generic routines, and sometimes it was planned that way. This is another type of abstraction that adds cognitive load: One where instead of writing wrappers for a specific use case, you try to generalize everything you write to account for all possible use cases in advance.<p>There&#x27;s some sort of balance that has to be struck between these two poles. The older I get, though, the more I suspect that whatever balance I strike today I&#x27;ll find unsatisfactory if I have to revisit the code in ten years.</div><br/><div id="42528728" class="c"><input type="checkbox" id="c-42528728" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42528656">parent</a><span>|</span><a href="#42528674">next</a><span>|</span><label class="collapse" for="c-42528728">[-]</label><label class="expand" for="c-42528728">[2 more]</label></div><br/><div class="children"><div class="content">I learned that lesson building an utility with JavaFX. I&#x27;ve done a few years with React and the usual pattern was to move almost everything out of the components. Unless it&#x27;s an event handler, a data transformer for the view, or something that manipulates the view, it has no business belonging to this layer.<p>I don&#x27;t try to generalize it, I just try to make the separation clear using functions&#x2F;methods&#x2F;classes. Instead of having the post button&#x27;s handler directly send the request, I create a function inside the `api` module that does it. It does have the effect on putting names on code patterns inside the project.</div><br/><div id="42528934" class="c"><input type="checkbox" id="c-42528934" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#42528656">root</a><span>|</span><a href="#42528728">parent</a><span>|</span><a href="#42528674">next</a><span>|</span><label class="collapse" for="c-42528934">[-]</label><label class="expand" for="c-42528934">[1 more]</label></div><br/><div class="children"><div class="content">When you say &quot;components&quot; do you mean that in the mixed React sense where a component could contain HTML? In my own usual cases, I call the Javascript a component, and the HTML a template. I usually take a handlebars approach on the template content and something like &quot;data-role&quot; to identify the template tags to the JS, and beyond that don&#x27;t mix them. However, my client-facing JS components themselves are totally bound to the templates they load up - they expect the presence of certain fields to work with. I&#x27;m talking more about not mixing any business logic into those JS components: Let&#x27;s say, in a form component, not anticipating that a dropdown menu will have any particular shape or size of dropdown item, which means those items need to be specified separately. This leads to JS components relying on lots of other components, when sometimes you just need one type of dropdown item for a particular component, and having dropdown items be a 20-headed beast makes everything upstream need to define them first.<p>Sometimes you just need a form to do what it says on the label.</div><br/></div></div></div></div><div id="42528674" class="c"><input type="checkbox" id="c-42528674" checked=""/><div class="controls bullet"><span class="by">josh2600</span><span>|</span><a href="#42528656">parent</a><span>|</span><a href="#42528728">prev</a><span>|</span><a href="#42529576">next</a><span>|</span><label class="collapse" for="c-42528674">[-]</label><label class="expand" for="c-42528674">[1 more]</label></div><br/><div class="children"><div class="content">Ahh yes, the labor of love that is code maintenance.<p>Done is better than perfect until you’re reviewing the code in 10 years (or maybe 3 years with a more adept set of eyes over your shoulders).<p>These days I ask my teams to be less clever and more simple.<p>Simple usually wins over clever in the long run.</div><br/></div></div></div></div><div id="42529062" class="c"><input type="checkbox" id="c-42529062" checked=""/><div class="controls bullet"><span class="by">noodletheworld</span><span>|</span><a href="#42529576">prev</a><span>|</span><a href="#42529200">next</a><span>|</span><label class="collapse" for="c-42529062">[-]</label><label class="expand" for="c-42529062">[3 more]</label></div><br/><div class="children"><div class="content">Pretty easy to give generic advice without examples.<p>“Write more tests, but not too many”<p>“Use good abstractions where appropriate?”<p>“The next time you reach for an abstraction, ask yourself: Is this truly simplifying the system? Or is it just another layer of indirection?”<p>It’s easy to create a strawman here (the FactoryAdaptorMapper or whatever) but in reality this kind of generic advice doesn’t help anyone.<p>Of <i>course</i> people want to use good abstractions.<p>That’s <i>not</i> the problem.<p>The problem is being able to tell the difference between generic arbitrary advice (like this post) and how <i>your specific code base</i> needs to use abstractions.<p>…and bluntly, the only way to know, is to either a) get experience in the code base or b) read the code that others have left there before you.<p>If it’s a new project, and you’re not familiar with the domain you’ll do it wrong.<p>Every. Single. Time.<p>So, picking “good” abstractions is a fools game.<p>You’ll pick the wrong ones. You’ll have to refactor.<p>That’s the skill; the advice to take away; how to peel back the wrong abstraction and replace it with your next best guess at a good one. How to read what’s there and understand what the smart folk before did and why.<p>…so, I find this kind of article sort of arrogant.<p>Oh, you want to be a great programmer?<p>Just program good code.
Use good abstractions. Don’t leave any technical debt. Job done!<p>…a few concrete examples would go a long way here…</div><br/><div id="42529122" class="c"><input type="checkbox" id="c-42529122" checked=""/><div class="controls bullet"><span class="by">jchmbrln</span><span>|</span><a href="#42529062">parent</a><span>|</span><a href="#42529200">next</a><span>|</span><label class="collapse" for="c-42529122">[-]</label><label class="expand" for="c-42529122">[2 more]</label></div><br/><div class="children"><div class="content">I can see the value of examples, but in this case I appreciate the post largely for its universality and lack of examples. On reading it, examples from past and present experience spring immediately to mind, and I&#x27;m tucking this away as a succinct description of the problem. Maybe I can share it with others when more concrete examples come up in future code review.<p>A principle takes skill the apply, but it&#x27;s still worth stating and pondering.</div><br/><div id="42529553" class="c"><input type="checkbox" id="c-42529553" checked=""/><div class="controls bullet"><span class="by">noodletheworld</span><span>|</span><a href="#42529062">root</a><span>|</span><a href="#42529122">parent</a><span>|</span><a href="#42529200">next</a><span>|</span><label class="collapse" for="c-42529553">[-]</label><label class="expand" for="c-42529553">[1 more]</label></div><br/><div class="children"><div class="content">&gt; examples from past and present experience spring immediately to mind<p>Examples of what?<p>Picking the wrong abstraction? Regretting your mistakes?<p>I can certainly think of many examples of that.<p>How you unwrapped an abstraction and made things better by removing it?<p>I have dozens of battle stories.<p>Choosing not to use an abstraction because it was indirection?<p>Which is what the article says to do?<p>I’m skeptical.<p>I suspect you’ll find most examples of that are <i>extremely</i> open to debate.<p>After all, you <i>didn&#x27;t</i> use the abstraction so you <i>don’t know</i> if it was good or not, and you can only <i>speculate</i> that the decision you made was actually a good one.<p>So, sharing that experience with others would be armchair architecture wouldn&#x27;t it?<p>That’s why this article is arrogant; because it says to make decisions based on gut feel without actually justifying it.<p>“Is this truly simplifying the system?”<p>Well, is it?<p>It’s an enormously difficult question to answer.<p><i>Did</i> it simplify the system <i>after doing it</i> is a much easier one, and again that should be the advice to people;<p>Not: magically do the right thing somehow.<p>Rather: here is how to undo a mistake.<p>…because fixing things is a more important skill and (always) <i>magically</i> doing the right thing from the start is impossible; so it’s meaningless advice.<p>That’s the problem with universal advice; it’s impossible to apply.</div><br/></div></div></div></div></div></div><div id="42529200" class="c"><input type="checkbox" id="c-42529200" checked=""/><div class="controls bullet"><span class="by">mixermachine</span><span>|</span><a href="#42529062">prev</a><span>|</span><a href="#42528344">next</a><span>|</span><label class="collapse" for="c-42529200">[-]</label><label class="expand" for="c-42529200">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of an old Java Android project I encountered.<p>EVERY class implemented an interface. 
98% of interfaces had one implementation.<p>Every programmer was applying a different programming pattern.
A lot of abstractions seemed incomplete and did not work.<p>Proguard (mostly used for code obfuscation for Android apps) definitions were collected in the top module even though the project had multiple modules.
Half of the definitions were no longer needed and the code was badly obfuscated.
Problems were solved by continuesly adding classes and checking what sticks.<p>The UI was controlled by a stateful machine. State transitions were scatter everywhere in the code with lots of conditions in unforeseen places.<p>Legacy code was everywhere because no one wanted to risk a very long debugging session of an unforseen change.<p>No API definitions. Just Maps that get send via REST to URLs.<p>By biggest mistake was to not directly rewrite this project when I entered the team. 
We did after one year.</div><br/></div></div><div id="42528344" class="c"><input type="checkbox" id="c-42528344" checked=""/><div class="controls bullet"><span class="by">mightyham</span><span>|</span><a href="#42529200">prev</a><span>|</span><a href="#42528357">next</a><span>|</span><label class="collapse" for="c-42528344">[-]</label><label class="expand" for="c-42528344">[2 more]</label></div><br/><div class="children"><div class="content">I forget which programming talk I watched which pointed this out, but one extremely common example of this in Java is recreating subsets of the Collections API. I&#x27;ve done this before, heck even the Java standard library is guilty of this problem. When a class has a full set of get&#x2F;put&#x2F;has&#x2F;remove methods, it is often not actually hiding the complexity of its component data structures.</div><br/><div id="42529113" class="c"><input type="checkbox" id="c-42529113" checked=""/><div class="controls bullet"><span class="by">oftenwrong</span><span>|</span><a href="#42528344">parent</a><span>|</span><a href="#42528357">next</a><span>|</span><label class="collapse" for="c-42529113">[-]</label><label class="expand" for="c-42529113">[1 more]</label></div><br/><div class="children"><div class="content">Rich Hickey on HttpServletRequest?<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aSEQfqNYNAc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aSEQfqNYNAc</a></div><br/></div></div></div></div><div id="42528357" class="c"><input type="checkbox" id="c-42528357" checked=""/><div class="controls bullet"><span class="by">getnormality</span><span>|</span><a href="#42528344">prev</a><span>|</span><a href="#42529011">next</a><span>|</span><label class="collapse" for="c-42528357">[-]</label><label class="expand" for="c-42528357">[14 more]</label></div><br/><div class="children"><div class="content">How did &quot;abstraction&quot; and &quot;hiding complexity&quot; become perceived as such fundamental virtues in software development? There are actual virtues in that ballpark - reusable, reliable, flexible - but creating abstractions and hiding complexity does not necessarily lead to these virtues. Abstraction sounds no more virtuous to me than indirection.</div><br/><div id="42528451" class="c"><input type="checkbox" id="c-42528451" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42528357">parent</a><span>|</span><a href="#42528472">next</a><span>|</span><label class="collapse" for="c-42528451">[-]</label><label class="expand" for="c-42528451">[3 more]</label></div><br/><div class="children"><div class="content">Decades ago, when <i>The Structure and Interpretation of Computer Programs</i> taught us that programmers fundamentally do two things: abstraction and combination; and we are interested in programming languages insofar as they provide means to those two ends.<p>The two classic &quot;hard problems&quot; of computer science - cache invalidation and naming things - are both aspects of abstraction. Cache invalidation is a special case of making sure the abstraction does what it&#x27;s supposed to, and naming is the most important part of causing the abstraction to have meaning.</div><br/><div id="42528584" class="c"><input type="checkbox" id="c-42528584" checked=""/><div class="controls bullet"><span class="by">wombatpm</span><span>|</span><a href="#42528357">root</a><span>|</span><a href="#42528451">parent</a><span>|</span><a href="#42528472">next</a><span>|</span><label class="collapse" for="c-42528584">[-]</label><label class="expand" for="c-42528584">[2 more]</label></div><br/><div class="children"><div class="content">I thought the two problems were cache invalidation, naming things, and off by one errors</div><br/><div id="42528739" class="c"><input type="checkbox" id="c-42528739" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42528357">root</a><span>|</span><a href="#42528584">parent</a><span>|</span><a href="#42528472">next</a><span>|</span><label class="collapse" for="c-42528739">[-]</label><label class="expand" for="c-42528739">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. And by similar logic, abstraction is the <i>only</i> thing we do. ;)</div><br/></div></div></div></div></div></div><div id="42528472" class="c"><input type="checkbox" id="c-42528472" checked=""/><div class="controls bullet"><span class="by">Starlevel004</span><span>|</span><a href="#42528357">parent</a><span>|</span><a href="#42528451">prev</a><span>|</span><a href="#42528368">next</a><span>|</span><label class="collapse" for="c-42528472">[-]</label><label class="expand" for="c-42528472">[4 more]</label></div><br/><div class="children"><div class="content">90% of modern programming takes are shadowboxing Java 6</div><br/><div id="42528564" class="c"><input type="checkbox" id="c-42528564" checked=""/><div class="controls bullet"><span class="by">flocciput</span><span>|</span><a href="#42528357">root</a><span>|</span><a href="#42528472">parent</a><span>|</span><a href="#42528368">next</a><span>|</span><label class="collapse" for="c-42528564">[-]</label><label class="expand" for="c-42528564">[3 more]</label></div><br/><div class="children"><div class="content">Elaborate on that?</div><br/><div id="42528612" class="c"><input type="checkbox" id="c-42528612" checked=""/><div class="controls bullet"><span class="by">bluepizza</span><span>|</span><a href="#42528357">root</a><span>|</span><a href="#42528564">parent</a><span>|</span><a href="#42528638">next</a><span>|</span><label class="collapse" for="c-42528612">[-]</label><label class="expand" for="c-42528612">[1 more]</label></div><br/><div class="children"><div class="content">Not parent, but I have a similar impression. Design patterns, clean code, and several of these well known tools were particularly useful during C++ and early Java eras, where footguns were abundant, and we had very little discussion about them - the Internet was a much smaller place back then. Most of the developer work was around building and maintaining huge code bases, be it desktop or server, monoliths were mostly the only game. And many initiatives grew trying to tame the inherent hazard.<p>I think that microservices (or at least, smaller services) and modern languages allow the code to stay more manageable, to the point where Java devs now are able to dismiss Spring and go for a much simpler Quarkus.</div><br/></div></div></div></div></div></div><div id="42528368" class="c"><input type="checkbox" id="c-42528368" checked=""/><div class="controls bullet"><span class="by">lizzas</span><span>|</span><a href="#42528357">parent</a><span>|</span><a href="#42528472">prev</a><span>|</span><a href="#42528809">next</a><span>|</span><label class="collapse" for="c-42528368">[-]</label><label class="expand" for="c-42528368">[1 more]</label></div><br/><div class="children"><div class="content">It can be good if done well. The goal is not abstraction but understandability.<p>Any function call is abstraction after all. Unabstracted you would just inline that code or use goto.</div><br/></div></div><div id="42528809" class="c"><input type="checkbox" id="c-42528809" checked=""/><div class="controls bullet"><span class="by">brookst</span><span>|</span><a href="#42528357">parent</a><span>|</span><a href="#42528368">prev</a><span>|</span><a href="#42528783">next</a><span>|</span><label class="collapse" for="c-42528809">[-]</label><label class="expand" for="c-42528809">[1 more]</label></div><br/><div class="children"><div class="content">What languages do you work in? Would you be happier or more productive if you had to be aware of the quirks of every ISA and interrupt controller your code might run on?<p>Abstraction is good, in the way that leverage is good in the physical world: it is not always necessary, but people who are aware of the tool are vastly more capable than those who are not.</div><br/></div></div><div id="42528783" class="c"><input type="checkbox" id="c-42528783" checked=""/><div class="controls bullet"><span class="by">parpfish</span><span>|</span><a href="#42528357">parent</a><span>|</span><a href="#42528809">prev</a><span>|</span><a href="#42528629">next</a><span>|</span><label class="collapse" for="c-42528783">[-]</label><label class="expand" for="c-42528783">[1 more]</label></div><br/><div class="children"><div class="content">Part of it has to be that finding and defining abstractions is <i>fun</i> like a puzzle so programmers like doing it and finding ways to justify it after the fact</div><br/></div></div><div id="42528629" class="c"><input type="checkbox" id="c-42528629" checked=""/><div class="controls bullet"><span class="by">Barrin92</span><span>|</span><a href="#42528357">parent</a><span>|</span><a href="#42528783">prev</a><span>|</span><a href="#42528445">next</a><span>|</span><label class="collapse" for="c-42528629">[-]</label><label class="expand" for="c-42528629">[1 more]</label></div><br/><div class="children"><div class="content">&gt;How did &quot;abstraction&quot; and &quot;hiding complexity&quot; become perceived as such fundamental virtues in software development?<p>They aren&#x27;t just fundamental virtues in software development, they&#x27;re the fundamental basis of all cognition. If I twiddled with every bit in my computer I&#x27;d never write a hello world program, if I wrestled with every atom in my coffee cup I&#x27;d never drink a sip of coffee.<p>Abstraction and information hiding is the only way we ever accomplish anything because the amount of information fitting in our heads is astonishingly small compared to the systems we build. Without systems of abstraction we would literally get nothing meaningful done.</div><br/></div></div><div id="42528445" class="c"><input type="checkbox" id="c-42528445" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#42528357">parent</a><span>|</span><a href="#42528629">prev</a><span>|</span><a href="#42529011">next</a><span>|</span><label class="collapse" for="c-42528445">[-]</label><label class="expand" for="c-42528445">[2 more]</label></div><br/><div class="children"><div class="content">The only way we accomplish anything is abstraction.  It&#x27;s the basis of all computing.</div><br/><div id="42528833" class="c"><input type="checkbox" id="c-42528833" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#42528357">root</a><span>|</span><a href="#42528445">parent</a><span>|</span><a href="#42529011">next</a><span>|</span><label class="collapse" for="c-42528833">[-]</label><label class="expand" for="c-42528833">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. There are base abstractions you can’t avoid, of course, like the machine code of your computer, or the syscalls presented by it. Using these is not abstraction, unless you choose to build up interfaces of reusable pieces. Abstraction is structure. You still have to actually write some code that can be organized into structure. You could write code using just those base abstractions if you wanted, or as many do, choose libc as your base abstraction. Watching a program through strace gives you basically this view, regardless of the abstractions the program actually used to achieve the result.</div><br/></div></div></div></div></div></div><div id="42529011" class="c"><input type="checkbox" id="c-42529011" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#42528357">prev</a><span>|</span><a href="#42529206">next</a><span>|</span><label class="collapse" for="c-42529011">[-]</label><label class="expand" for="c-42529011">[4 more]</label></div><br/><div class="children"><div class="content">Abstraction hides detail, but at what coat?<p>A network close call at a high level closes a network socket. But at the tcp level there&#x27;s a difference between close and reset. Which do you want? Your api has removed that choice from you, and if you look you will have no idea if rhe close api does a close or a reset.<p>Is the difference important? If depends. If you have a bunch of half open sockets and run out of file descriptors then it becomes very important.<p>Another example: you call read() on a file, and read 10k bytes. Did you know your library was reading 1 byte at a time unbuffered? This abstraction will&#x2F;can cause massive performance problems.<p>My favorite one is when a programmer iterates over an ORM-enabled array. Yes, let&#x27;s do 50,000 queries instead of one because databases are too complicated to learn.<p>Just like any tool, abstraction has costs and benefits. The problem is that lots of people ignore the cost, and assume the benefit.</div><br/><div id="42529074" class="c"><input type="checkbox" id="c-42529074" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#42529011">parent</a><span>|</span><a href="#42529191">next</a><span>|</span><label class="collapse" for="c-42529074">[-]</label><label class="expand" for="c-42529074">[1 more]</label></div><br/><div class="children"><div class="content">I think an important distinction is hiding details from other parts of the program, and having details being hidden from you.<p>99.9% of the time I don&#x27;t care what the tcp socket closes with as long as it isn&#x27;t leaking a resource.<p>And if I did care, then I picked the wrong level of network abstraction to engage with. I should&#x27;ve used something more raw.<p>Regarding ORM arrays. I have myself recently debugged such a case. I chortled a bit at the amateur who wrote the code (me last year) and the schmuck who accidentally wrapped it in a loop (me 3 weeks ago). Then I changed it slightly to avoid the N queries and went on with my day. No need to lambast the tooling or the programmers. Just write something maintainable that works. No need to throw the entire ORM away just because we accidentally made a web page kinda slow that one time.<p>And don&#x27;t worry, I too lament when web pages I don&#x27;t control are slow. You may rest uneasily knowing that that page would be slow regardless of whether ORMs existed because it is not slow because of ORMs, but because there is no incentive for the business to care enough to make it faster.</div><br/></div></div><div id="42529191" class="c"><input type="checkbox" id="c-42529191" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#42529011">parent</a><span>|</span><a href="#42529074">prev</a><span>|</span><a href="#42529202">next</a><span>|</span><label class="collapse" for="c-42529191">[-]</label><label class="expand" for="c-42529191">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;  But at the tcp level there&#x27;s a difference between close and reset. Which do you want? Your api has removed that choice from you, and if you look you will have no idea if rhe close api does a close or a reset.<p>If you are doing a „TCP application” of course it makes no sense to abstract the TCP layer. Is not about cost. Now if you have an application that has to communicate <i>somehow</i> with other system, and you want to not depend on specific protocols, then the communication part should abstract away that part.<p>How to deal with your example? Well, if you can say “I will always want X, you can make a configuration option “TCP.close” or “TCP.reset”. If “it depends” then you have to build the logic for the selection in the abstraction layer, which keeps hidden.</div><br/></div></div><div id="42529202" class="c"><input type="checkbox" id="c-42529202" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#42529011">parent</a><span>|</span><a href="#42529191">prev</a><span>|</span><a href="#42529206">next</a><span>|</span><label class="collapse" for="c-42529202">[-]</label><label class="expand" for="c-42529202">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Your api has removed that choice from you<p>It has? Can&#x27;t you rely on connect(2) with AF_UNSPEC doing a RST, and shutdown(2) with SHUT_WR doing a FIN?</div><br/></div></div></div></div><div id="42529206" class="c"><input type="checkbox" id="c-42529206" checked=""/><div class="controls bullet"><span class="by">anonytrary</span><span>|</span><a href="#42529011">prev</a><span>|</span><a href="#42528799">next</a><span>|</span><label class="collapse" for="c-42529206">[-]</label><label class="expand" for="c-42529206">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what it&#x27;s called (abstraction vs. indirection) but I dislike when everything needs a class&#x2F;object with some odd combination of curried functions. Some programming languages force this on you more than others I think? As a contrived example &quot;StringManager.SlicingManager.sliceStringMaker(0)(24)(myStr)&quot;, I&#x27;ve seen code that reminds me of this and wonder why anyone uses a language where this not only an acceptable idiom, but a preferred one.</div><br/></div></div><div id="42528799" class="c"><input type="checkbox" id="c-42528799" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#42529206">prev</a><span>|</span><a href="#42529133">next</a><span>|</span><label class="collapse" for="c-42528799">[-]</label><label class="expand" for="c-42528799">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; a bad one turns every small bug into an excavation.</i><p>I find that I need to debug my abstractions frequently, <i>while I’m first writing my code</i>, then I never need to dig into them, ever again, or they do their job, and let me deal with adding&#x2F;removing functionality, in the future, while not touching most of the code.<p>That’s why I use them. That’s what they are supposed to do.<p>Because they are abstractions, this initial debugging is often a lot harder than it might be for “straight-through” code, but is made easier, because the code architecture is still fresh in my mind; where it would be quite challenging, coming at it without that knowledge.<p>If I decide it’s a “bad abstraction,” because of that initial debugging, and destroy or perforate it, then what happens after, is my own fault.<p>I’ve been using layers, modules, and abstractions, for decades.<p>Just today, I released an update to a shipping app, that adds some <i>huge</i> changes, while barely affecting the user experience (except maybe, making it better).<p>I had to spend a great deal of time testing (and addressing small issues, far above the abstractions), but implementing the major changes was insanely easy. I swapped out an entire server SDK for the “killer feature” of the app.</div><br/></div></div><div id="42529133" class="c"><input type="checkbox" id="c-42529133" checked=""/><div class="controls bullet"><span class="by">ericflo</span><span>|</span><a href="#42528799">prev</a><span>|</span><a href="#42528692">next</a><span>|</span><label class="collapse" for="c-42529133">[-]</label><label class="expand" for="c-42529133">[1 more]</label></div><br/><div class="children"><div class="content">Classic post in this genre: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20151217104831&#x2F;https:&#x2F;&#x2F;zedshaw.com&#x2F;archive&#x2F;indirection-is-not-abstraction&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20151217104831&#x2F;https:&#x2F;&#x2F;zedshaw.c...</a></div><br/></div></div><div id="42528692" class="c"><input type="checkbox" id="c-42528692" checked=""/><div class="controls bullet"><span class="by">thomasjudge</span><span>|</span><a href="#42529133">prev</a><span>|</span><a href="#42529536">next</a><span>|</span><label class="collapse" for="c-42528692">[-]</label><label class="expand" for="c-42528692">[1 more]</label></div><br/><div class="children"><div class="content">I wish this article had more examples&#x2F;details; as it is, it is kind of .. abstract</div><br/></div></div><div id="42529536" class="c"><input type="checkbox" id="c-42529536" checked=""/><div class="controls bullet"><span class="by">eunonia12</span><span>|</span><a href="#42528692">prev</a><span>|</span><a href="#42528306">next</a><span>|</span><label class="collapse" for="c-42529536">[-]</label><label class="expand" for="c-42529536">[1 more]</label></div><br/><div class="children"><div class="content">specify</div><br/></div></div><div id="42528306" class="c"><input type="checkbox" id="c-42528306" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#42529536">prev</a><span>|</span><a href="#42528289">next</a><span>|</span><label class="collapse" for="c-42528306">[-]</label><label class="expand" for="c-42528306">[1 more]</label></div><br/><div class="children"><div class="content">This is a great point. Most modern software is riddled with unnecessary complexity which adds mental load, forces you to learn new concepts that are equally complex or more complex than the logic which they claim to abstract away from.<p>I find myself saying this over and over again; if the abstraction does not bring the code closer to the business domain; if it does not make it easier for you to explain the code to a non-technical person, then it&#x27;s a poor abstraction.<p>Inventing technical constructs which simply shift the focus away from other technical constructs adds no value at all. Usually such reframing of logic only serves the person who wrote &#x27;the abstraction&#x27; to navigate their own biased mental models, it doesn&#x27;t simplify the logic from the perspective of anyone else.</div><br/></div></div><div id="42528289" class="c"><input type="checkbox" id="c-42528289" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#42528306">prev</a><span>|</span><a href="#42528526">next</a><span>|</span><label class="collapse" for="c-42528289">[-]</label><label class="expand" for="c-42528289">[1 more]</label></div><br/><div class="children"><div class="content">Tailwind anyone?</div><br/></div></div><div id="42528526" class="c"><input type="checkbox" id="c-42528526" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#42528289">prev</a><span>|</span><a href="#42528598">next</a><span>|</span><label class="collapse" for="c-42528526">[-]</label><label class="expand" for="c-42528526">[2 more]</label></div><br/><div class="children"><div class="content">What about java?</div><br/><div id="42529297" class="c"><input type="checkbox" id="c-42529297" checked=""/><div class="controls bullet"><span class="by">praptak</span><span>|</span><a href="#42528526">parent</a><span>|</span><a href="#42528598">next</a><span>|</span><label class="collapse" for="c-42529297">[-]</label><label class="expand" for="c-42529297">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a huge ecosystem which turns 30 in May. Yes, it accumulated lots stuff that was cool back then and isn&#x27;t so cool now but overall is doing pretty well (COBOL was 36 when Java got public).</div><br/></div></div></div></div><div id="42528598" class="c"><input type="checkbox" id="c-42528598" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#42528526">prev</a><span>|</span><a href="#42528618">next</a><span>|</span><label class="collapse" for="c-42528598">[-]</label><label class="expand" for="c-42528598">[2 more]</label></div><br/><div class="children"><div class="content">The operating system is an abstraction, your programming language compiler, tooling, CPU instruction set and microcode are abstractions, the controllers for your hardware and their drivers are abstractions too.<p>Even data structures and algorithms are abstractions, and digital electronics, and the physics models that enabled them, and mathematics and logic. Even numbers or any form of notation you use are an abstraction.<p>The very words used in the article are abstractions for the concepts and sounds they represent.<p>If you don&#x27;t know exactly how those work, or at least do not need to think at that level of detail all the time, that is a testament that those abstractions are working.<p>If using an abstraction is so natural that you stop thinking about it as such is also a sign that it is a good abstraction. And those concepts themselves may be abstractions too.<p>To say all abstractions leak, assume they are a performance penalty, that they are the enemy of simplicity, etc. is just wrong. Not only wrong, it is irresponsible and evil to publish an article saying that because at least one person will take it seriously and ruin their whole career.<p>What this article proposes is a world of irrationality and nonsense where all levels of detail are the same and everything is ruined forever beyond repair becoming a supervolcano of entropy.<p>This article should be redacted, all its copies destroyed and thrown into lava.<p>When you think about it this article is against everything computer science is for. Data itself are abstract representations. The whole reason computers exist is to facilitate abstractions.<p>Money is also an abstraction and indirection, try bartering instead. Do you even realize what you have done? [punches wall in infinite frustration]</div><br/></div></div><div id="42528296" class="c"><input type="checkbox" id="c-42528296" checked=""/><div class="controls bullet"><span class="by">fnord77</span><span>|</span><a href="#42528618">prev</a><span>|</span><a href="#42528651">next</a><span>|</span><label class="collapse" for="c-42528296">[-]</label><label class="expand" for="c-42528296">[1 more]</label></div><br/><div class="children"><div class="content">cough Spring Framework cough</div><br/></div></div><div id="42528651" class="c"><input type="checkbox" id="c-42528651" checked=""/><div class="controls bullet"><span class="by">VirusNewbie</span><span>|</span><a href="#42528296">prev</a><span>|</span><label class="collapse" for="c-42528651">[-]</label><label class="expand" for="c-42528651">[4 more]</label></div><br/><div class="children"><div class="content">&gt;There’s a well-known saying: &quot;All abstractions leak.&quot; It’s true. No matter how good the abstraction, eventually, you’ll run into situations where you need to understand the underlying implementation details<p>This is false.  One can read up on Theorem&#x27;s for Free by Wadler to see that not all abstractions are leaky.</div><br/><div id="42528933" class="c"><input type="checkbox" id="c-42528933" checked=""/><div class="controls bullet"><span class="by">abstra4free</span><span>|</span><a href="#42528651">parent</a><span>|</span><a href="#42528734">next</a><span>|</span><label class="collapse" for="c-42528933">[-]</label><label class="expand" for="c-42528933">[2 more]</label></div><br/><div class="children"><div class="content">Theorems for Free tells you that some abstractions satisfy some mathematical properties (for free!) under some circumstances.<p>If you write down a function with signature<p><pre><code>  {T : Type} -&gt; T -&gt; T
</code></pre>
then it must be the identity function, if you do not use &quot;malicious&quot; extensions of the type system.<p>But what is the performance of the identity function?<p>Here is an identity function:<p><pre><code>  lambda T, lambda t, if (2 + 2 = 4) then t else t
</code></pre>
In other words: I can hide pretty much arbitrary computation in my identity function.<p>Users of my identity functuon will notice that it is wicked slow (in reality, I let my identity function compute Busy Beaver 5, before doing nothing). Their complaints are evidence of leaky abstraction.<p>Now you might have a smart optimizing compiler that knows about Thm4Free... But that&#x27;s another story.</div><br/><div id="42529531" class="c"><input type="checkbox" id="c-42529531" checked=""/><div class="controls bullet"><span class="by">javcasas</span><span>|</span><a href="#42528651">root</a><span>|</span><a href="#42528933">parent</a><span>|</span><a href="#42528734">next</a><span>|</span><label class="collapse" for="c-42529531">[-]</label><label class="expand" for="c-42529531">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you can have such compiler, at least for a general case, without solving the halting problem first. After all, you can encode arbitrary computations at the type level.</div><br/></div></div></div></div><div id="42528734" class="c"><input type="checkbox" id="c-42528734" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#42528651">parent</a><span>|</span><a href="#42528933">prev</a><span>|</span><label class="collapse" for="c-42528734">[-]</label><label class="expand" for="c-42528734">[1 more]</label></div><br/><div class="children"><div class="content">This has such potential to be an interesting thread of conversation but all I get is a reference to a book that I haven&#x27;t read and am unlikely to.<p>What examples of non-leaky abstractions do you have?<p>I could imagine something like &quot;newtonian physics&quot; but that leaks into my daily life every time I fire up google maps and get a GPS fix.<p>The OP&#x27;s example of TCP seems close to the mark, but to be totally honest I&#x27;m not convinced. Every time I have to run ping to check whether my hung connection is due to connectivity, I&#x27;m breaking the abstraction. And I&#x27;ve had to debug network issues with Ethereal (yes, I&#x27;m dating myself). TCP does leak, it&#x27;s just that most people don&#x27;t know what to do with it when it does.</div><br/></div></div></div></div></div></div></div></div></div></body></html>