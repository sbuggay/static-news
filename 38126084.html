<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699261260895" as="style"/><link rel="stylesheet" href="styles.css?v=1699261260895"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://linuxgizmos.com/new-beaglev-single-board-computer-adopts-microchips-polarfire-soc/">New BeagleV single board computer adopts Microchip&#x27;s PolarFire SoC with FPGA</a> <span class="domain">(<a href="https://linuxgizmos.com">linuxgizmos.com</a>)</span></div><div class="subtext"><span>teleforce</span> | <span>45 comments</span></div><br/><div><div id="38157452" class="c"><input type="checkbox" id="c-38157452" checked=""/><div class="controls bullet"><span class="by">PAPPPmAc</span><span>|</span><a href="#38158280">next</a><span>|</span><label class="collapse" for="c-38157452">[-]</label><label class="expand" for="c-38157452">[4 more]</label></div><br/><div class="children"><div class="content">Last I looked Microchip&#x27;s Libero FPGA&#x2F;FPGASoC development tools were paid, either on an expensive one-time fee for a specific version, or an expensive-compared-to-this-board annual subscription.  It won&#x27;t even show me current pricing without logging in, which is a bad sign, and none of the press has mentioned if these come with a comped board-locked license or something to make them tenable for hobbyists.<p>The big FPGA players have mostly quit that shit; AMD&#x2F;Xilinx, Intel&#x2F;Altera&#x2F;Whatever dumb name its about to be spun back out as, and Lattice all have free versions of their dev tools for at least their parts small players can afford.  They just want you to buy chips and IP.<p>I haven&#x27;t heard of the Yosis folks making a PolarFire backend, so I don&#x27;t think there&#x27;s an open alternative.<p>Libero is even FlexLM based licensing like the bad old days of proprietary dev tools.</div><br/><div id="38159360" class="c"><input type="checkbox" id="c-38159360" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#38157452">parent</a><span>|</span><a href="#38157577">next</a><span>|</span><label class="collapse" for="c-38159360">[-]</label><label class="expand" for="c-38159360">[1 more]</label></div><br/><div class="children"><div class="content">They even switched to mandatory yearly renewals a while back when Libero SoC launched. Buy a copy of Libero Gold for $999? You lose access after 365 days unless you renew. Every license tier used to be perpetual upon purchase, but now a single node perpetual license is some ridiculous bullshit like $20,000 USD.<p>At least when you buy Vivado and Quartus you can actually keep using it...</div><br/></div></div><div id="38157577" class="c"><input type="checkbox" id="c-38157577" checked=""/><div class="controls bullet"><span class="by">NextHendrix</span><span>|</span><a href="#38157452">parent</a><span>|</span><a href="#38159360">prev</a><span>|</span><a href="#38158280">next</a><span>|</span><label class="collapse" for="c-38157577">[-]</label><label class="expand" for="c-38157577">[2 more]</label></div><br/><div class="children"><div class="content">You can generate yourself a free Libero Silver license, which needs regenerating every year, but yes flexlm is annoying.</div><br/><div id="38159586" class="c"><input type="checkbox" id="c-38159586" checked=""/><div class="controls bullet"><span class="by">hmry</span><span>|</span><a href="#38157452">root</a><span>|</span><a href="#38157577">parent</a><span>|</span><a href="#38158280">next</a><span>|</span><label class="collapse" for="c-38159586">[-]</label><label class="expand" for="c-38159586">[1 more]</label></div><br/><div class="children"><div class="content">Seems the MPFS025T is not supported on the silver license unfortunately</div><br/></div></div></div></div></div></div><div id="38158280" class="c"><input type="checkbox" id="c-38158280" checked=""/><div class="controls bullet"><span class="by">wildzzz</span><span>|</span><a href="#38157452">prev</a><span>|</span><a href="#38158225">next</a><span>|</span><label class="collapse" for="c-38158280">[-]</label><label class="expand" for="c-38158280">[1 more]</label></div><br/><div class="children"><div class="content">Pretty amazing price point considering a Polarfire board is normally like $1000 although those have a lot more features (socketed RAM, PCIe edge connector, SERDES breakout, etc). IGLOO is a little more affordable but Polarfire is nicer.<p>Microsemi (now Microchip) does not really cater to the low-price hobbyist market. A lot of their sales are high-reliability FPGAs and weird things like anti-fuse FPGAs (one-time programmable). I will say that they were very early adopters of RISC-V. We&#x27;ve been using their core in our product for something like 5 years now.</div><br/></div></div><div id="38158225" class="c"><input type="checkbox" id="c-38158225" checked=""/><div class="controls bullet"><span class="by">sargun</span><span>|</span><a href="#38158280">prev</a><span>|</span><a href="#38156741">next</a><span>|</span><label class="collapse" for="c-38158225">[-]</label><label class="expand" for="c-38158225">[2 more]</label></div><br/><div class="children"><div class="content">So, AFAICT, pricing hasn&#x27;t been officially released on this, but the original source (<a href="https:&#x2F;&#x2F;www.beagleboard.org&#x2F;blog&#x2F;2023-11-02-beaglev-fire-announcement" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.beagleboard.org&#x2F;blog&#x2F;2023-11-02-beaglev-fire-ann...</a>), states around $150.<p>They had announced this board sometime ago with totally different specs (<a href="https:&#x2F;&#x2F;old.beagleboard.org&#x2F;static&#x2F;beagleV&#x2F;beagleV.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;old.beagleboard.org&#x2F;static&#x2F;beagleV&#x2F;beagleV.html</a>).<p>That being said, I&#x27;m actually looking forward to this board. I see this as kind of an alternative to the Xilinx Zynq boards.</div><br/><div id="38159265" class="c"><input type="checkbox" id="c-38159265" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#38158225">parent</a><span>|</span><a href="#38156741">next</a><span>|</span><label class="collapse" for="c-38159265">[-]</label><label class="expand" for="c-38159265">[1 more]</label></div><br/><div class="children"><div class="content">Mouser.com has it listed at $149 in the USA, at least.</div><br/></div></div></div></div><div id="38156741" class="c"><input type="checkbox" id="c-38156741" checked=""/><div class="controls bullet"><span class="by">pmorici</span><span>|</span><a href="#38158225">prev</a><span>|</span><a href="#38157910">next</a><span>|</span><label class="collapse" for="c-38156741">[-]</label><label class="expand" for="c-38156741">[2 more]</label></div><br/><div class="children"><div class="content">Is this the first Beagleboard that doesn’t use a TI chip?</div><br/><div id="38156779" class="c"><input type="checkbox" id="c-38156779" checked=""/><div class="controls bullet"><span class="by">roland35</span><span>|</span><a href="#38156741">parent</a><span>|</span><a href="#38157910">next</a><span>|</span><label class="collapse" for="c-38156779">[-]</label><label class="expand" for="c-38156779">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I was thinking! I always assumed TI spun off Beagle since I&#x27;ve never seen their chips anywhere else!<p>I suppose the bigger news is that this is a RISC-V device with some FPGA fun mixed in.</div><br/></div></div></div></div><div id="38157910" class="c"><input type="checkbox" id="c-38157910" checked=""/><div class="controls bullet"><span class="by">spott</span><span>|</span><a href="#38156741">prev</a><span>|</span><a href="#38156925">next</a><span>|</span><label class="collapse" for="c-38157910">[-]</label><label class="expand" for="c-38157910">[3 more]</label></div><br/><div class="children"><div class="content">I always get excited by these kind of devices… until I realize I honestly can’t think of what I would use it for.<p>Anyone have plans for something like this that they would like to share?  I’d love some project ideas.</div><br/><div id="38158161" class="c"><input type="checkbox" id="c-38158161" checked=""/><div class="controls bullet"><span class="by">inamberclad</span><span>|</span><a href="#38157910">parent</a><span>|</span><a href="#38158891">next</a><span>|</span><label class="collapse" for="c-38158161">[-]</label><label class="expand" for="c-38158161">[1 more]</label></div><br/><div class="children"><div class="content">Best application I can think of is a mid-level robot prototype. Small enough that you don&#x27;t need a lot of computing horsepower, but also need lots of high speed I&#x2F;O for cameras, LiDAR, etc. This is a small niche since most robots that need that kind of I&#x2F;O also need much more computational horsepower.</div><br/></div></div><div id="38158891" class="c"><input type="checkbox" id="c-38158891" checked=""/><div class="controls bullet"><span class="by">retrocryptid</span><span>|</span><a href="#38157910">parent</a><span>|</span><a href="#38158161">prev</a><span>|</span><a href="#38156925">next</a><span>|</span><label class="collapse" for="c-38158891">[-]</label><label class="expand" for="c-38158891">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m doing some 900Mhz ISM band SDR stuff.  I&#x27;m mildly afraid, the polarfire toolchain is pretty wonky.  F4PGA is wonky in a different way, but at least it&#x27;s open and I know a few people using it.  It would be cool if I could use F4PGA with PolarFire FPGAs.</div><br/></div></div></div></div><div id="38156925" class="c"><input type="checkbox" id="c-38156925" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#38157910">prev</a><span>|</span><a href="#38157532">next</a><span>|</span><label class="collapse" for="c-38156925">[-]</label><label class="expand" for="c-38156925">[16 more]</label></div><br/><div class="children"><div class="content">Someone in the previous thread mentioned programming fpga is very hard. Could anyone opine?</div><br/><div id="38157546" class="c"><input type="checkbox" id="c-38157546" checked=""/><div class="controls bullet"><span class="by">NextHendrix</span><span>|</span><a href="#38156925">parent</a><span>|</span><a href="#38157049">next</a><span>|</span><label class="collapse" for="c-38157546">[-]</label><label class="expand" for="c-38157546">[4 more]</label></div><br/><div class="children"><div class="content">Software engineers can sometimes find it difficult as with a HDL you (should) describe hardware that exhibits the intended behaviour, rather than just directly describing the behaviour.<p>HDLs have familiar syntax that makes it seem like you can just program algorithms imperatively (for loops, if statements, functions etc) but it&#x27;s all just a mean trick to catch software people out, and generally won&#x27;t give the results you expect.<p>On top there&#x27;s then the fact everything happens at the same time, the faff of making everything synchronised and making sure it meets timing and fighting the frankly awful tooling every step of the way.<p>Once you get it, it&#x27;s fine, but you have to unlearn a lot of software muscle memory and keep the actual design work (boxes and lines) almost entirely separate from the implementation (typing your boxes and lines into a text editor).</div><br/><div id="38159691" class="c"><input type="checkbox" id="c-38159691" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38156925">root</a><span>|</span><a href="#38157546">parent</a><span>|</span><a href="#38157049">next</a><span>|</span><label class="collapse" for="c-38159691">[-]</label><label class="expand" for="c-38159691">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written software for decades and didn&#x27;t find it very difficult at all to pick up HDLs <i>conceptually</i>. The idea that you&#x27;re writing a circuit that all executes in parallel is really not a difficult one.<p>The biggest issues are really:<p>1. The tooling is generally awful. Open source tooling is very primitive and not usable. Commercial tooling is unaffordable to hobbyists. There are a couple of exceptions:<p>a) Vivado which I haven&#x27;t used extensively but seems fairly nice. Unfortunately the FPGAs it works with are not cheap.<p>b) I discovered that Intel provides a free version of ModelSim. I&#x27;ve used Questa a lot (the &quot;pro&quot; version of ModelSim more or less; their branding is confusing) and it&#x27;s great.<p>It also doesn&#x27;t help that all the tools use TCL which is also awful.<p>2. SystemVerilog is just a really bad, ancient language. It wasn&#x27;t even designed for synthesising ASICs, let alone FPGAs! You&#x27;re writing a <i>simulation</i> of an ASIC, and then some other tool tries to infer how it should run that simulation on an FPGA. It&#x27;s a completely bonkers system.<p>It&#x27;s not just the system that is bonkers. The language is too. Implicit casts all over the place, undefined values as part of the language (though not in Verilator!), multiple assignment types, ridiculously flexible array indexing.<p>Maybe VHDL is better... but unfortunately SystemVerilog won the language war in the ASIC space so that&#x27;s what I know.<p>It also doesn&#x27;t seem like we&#x27;ll get a replacement any time soon. You&#x27;d need buy-in from the big vendors otherwise debugging will always be a total nightmare.<p>Though it would be nice if there was something like Typescript for SystemVerilog - something that fixed all the very rough edges and footguns but didn&#x27;t change the code so much that debugging is painful.</div><br/><div id="38159985" class="c"><input type="checkbox" id="c-38159985" checked=""/><div class="controls bullet"><span class="by">proto_lambda</span><span>|</span><a href="#38156925">root</a><span>|</span><a href="#38159691">parent</a><span>|</span><a href="#38157049">next</a><span>|</span><label class="collapse" for="c-38159985">[-]</label><label class="expand" for="c-38159985">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Open source tooling is very primitive and not usable<p>Maybe you&#x27;re working off old information, but the FOSS tooling (ghdl, yosys, nextpnr) is completely sufficient for hobbyists. If you&#x27;re doing huge, high-speed designs on expensive FPGAs, sure, use the vendor tools, but for your average iCE40&#x2F;ECP5-scale design, FOSS is the way to go.</div><br/><div id="38160195" class="c"><input type="checkbox" id="c-38160195" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38156925">root</a><span>|</span><a href="#38159985">parent</a><span>|</span><a href="#38157049">next</a><span>|</span><label class="collapse" for="c-38160195">[-]</label><label class="expand" for="c-38160195">[1 more]</label></div><br/><div class="children"><div class="content"><i>Sufficient</i>, sure. But in terms of usability it&#x27;s like giving someone sed and grep and saying &quot;this is sufficient for writing a novel&quot;.<p>Maybe in time they&#x27;ll move on from the &quot;here&#x27;s a bunch of random poorly documented tools, you only have to do all of the integration work!&quot; stage, but they aren&#x27;t there yet.</div><br/></div></div></div></div></div></div></div></div><div id="38157049" class="c"><input type="checkbox" id="c-38157049" checked=""/><div class="controls bullet"><span class="by">0x000xca0xfe</span><span>|</span><a href="#38156925">parent</a><span>|</span><a href="#38157546">prev</a><span>|</span><a href="#38157255">next</a><span>|</span><label class="collapse" for="c-38157049">[-]</label><label class="expand" for="c-38157049">[5 more]</label></div><br/><div class="children"><div class="content">FPGA programming is like another level below assembly programming.<p>In high-level languages you got functions, variables and scopes while in assembly you need to build them yourself using more primitive units, i.e. instructions and registers.<p>In assembly you got many helpful instructions and easy memory access while in FPGAs and ASICs you have... nothing. Only wires and boolean logic.<p>It allows you to build some things extremely efficiently, e.g.: Press button 1 and 2 to activate LED 1. No clocks, no memory accesses, no I&#x2F;O polling or interrupts, just a direct connection from some inputs to others with some logic in between.<p>Although there are many modern tools, libraries and IP blocks to make FPGA programming easier or even possible with languages like Scala or C++, it usually takes way more time to build anything compared to doing it with the help of a CPU.</div><br/><div id="38157177" class="c"><input type="checkbox" id="c-38157177" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#38156925">root</a><span>|</span><a href="#38157049">parent</a><span>|</span><a href="#38157255">next</a><span>|</span><label class="collapse" for="c-38157177">[-]</label><label class="expand" for="c-38157177">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always been interested in coaxing extreme performance in a computational task by using FPGA or ASIC.<p>This seems like a mad science. Is there a recommended entry point like a book or learning resource?<p>The only exposure I have is from the FPGA stereo disparity module on the Mars Rover. And sadly I left before I could really pick any brains. Or ASIC Bitcoin mining.</div><br/><div id="38157450" class="c"><input type="checkbox" id="c-38157450" checked=""/><div class="controls bullet"><span class="by">0x000xca0xfe</span><span>|</span><a href="#38156925">root</a><span>|</span><a href="#38157177">parent</a><span>|</span><a href="#38159995">next</a><span>|</span><label class="collapse" for="c-38157450">[-]</label><label class="expand" for="c-38157450">[1 more]</label></div><br/><div class="children"><div class="content">Well first you need a problem where using a FPGA is a good fit.<p>FPGAs usually clock much lower than CPUs. If you want to beat a modern multicore CPU running at 5GHz with a 100MHz FPGA, you need to do a lot more per cycle to win. Your optimal problem is either highly parallel or solvable using a deep pipeline that gives you crazy throughput.<p>Since accessing external RAM is much more complicated on a FPGA and you don&#x27;t have all the nice prefetching and caching levels of a CPU, you better make do with the limited on-board memory.<p>Usually this limits you to real-time stream processing like audio, video, packet filtering or I&#x2F;O muxing.<p>But if you have an interesting problem in these spaces, FPGAs can be crazy power efficient and fun.<p>At my university, we used a ZynqBerry (Raspberry Pi format and only around $100) with the Vivado tools, so maybe that would be a good start for you as well.</div><br/></div></div><div id="38159995" class="c"><input type="checkbox" id="c-38159995" checked=""/><div class="controls bullet"><span class="by">MaKey</span><span>|</span><a href="#38156925">root</a><span>|</span><a href="#38157177">parent</a><span>|</span><a href="#38157450">prev</a><span>|</span><a href="#38158867">next</a><span>|</span><label class="collapse" for="c-38159995">[-]</label><label class="expand" for="c-38159995">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This seems like a mad science. Is there a recommended entry point like a book or learning resource?<p>There is this new book: <a href="https:&#x2F;&#x2F;nostarch.com&#x2F;gettingstartedwithfpgas" rel="nofollow noreferrer">https:&#x2F;&#x2F;nostarch.com&#x2F;gettingstartedwithfpgas</a></div><br/></div></div><div id="38158867" class="c"><input type="checkbox" id="c-38158867" checked=""/><div class="controls bullet"><span class="by">porsupah</span><span>|</span><a href="#38156925">root</a><span>|</span><a href="#38157177">parent</a><span>|</span><a href="#38159995">prev</a><span>|</span><a href="#38157255">next</a><span>|</span><label class="collapse" for="c-38158867">[-]</label><label class="expand" for="c-38158867">[1 more]</label></div><br/><div class="children"><div class="content">You might find &quot;Digital Design and Computer Architecture&quot; by Sarah Harris &amp; David Harris helpful. (Note that it comes in ARM and RISC-V editions)<p><a href="https:&#x2F;&#x2F;www.waterstones.com&#x2F;book&#x2F;digital-design-and-computer-architecture-risc-v-edition&#x2F;sarah-harris&#x2F;david-harris&#x2F;9780128200643" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.waterstones.com&#x2F;book&#x2F;digital-design-and-computer...</a></div><br/></div></div></div></div></div></div><div id="38157255" class="c"><input type="checkbox" id="c-38157255" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#38156925">parent</a><span>|</span><a href="#38157049">prev</a><span>|</span><a href="#38156959">next</a><span>|</span><label class="collapse" for="c-38157255">[-]</label><label class="expand" for="c-38157255">[1 more]</label></div><br/><div class="children"><div class="content">FPGAs are actually not that hard to program, in theory. If you understand basic logic gates (and&#x2F;not&#x2F;nor&#x2F;etc) and other logic concepts (flip-flops, latches, clocks) you can understand vhdl or verilog. And then you can write your own vhdl&#x2F;verilog code (really, is it code though?). The actual difficult part is using the tooling. Intel&#x27;s and AMD&#x27;s development environments are designed for professionals, so they&#x27;re hard to work with if you&#x27;re just starting out. Add to that a liberal sprinkling of annoying bugs and workarounds, and it&#x27;s actually quite frustrating to do if you aren&#x27;t getting paid for the effort.</div><br/></div></div><div id="38156959" class="c"><input type="checkbox" id="c-38156959" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#38156925">parent</a><span>|</span><a href="#38157255">prev</a><span>|</span><a href="#38157264">next</a><span>|</span><label class="collapse" for="c-38156959">[-]</label><label class="expand" for="c-38156959">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it’s a very different paradigm than typical programming. By default, everything in hardware happens at all at once, unless you add what’a called sequential logic, which is clocked and holds state.</div><br/></div></div><div id="38157264" class="c"><input type="checkbox" id="c-38157264" checked=""/><div class="controls bullet"><span class="by">hackcasual</span><span>|</span><a href="#38156925">parent</a><span>|</span><a href="#38156959">prev</a><span>|</span><a href="#38157879">next</a><span>|</span><label class="collapse" for="c-38157264">[-]</label><label class="expand" for="c-38157264">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not necessarily harder, it&#x27;s very different from writing code for CPUs and it&#x27;s used to accomplish different things. Though it&#x27;s different, a usually what what you&#x27;re writing is smaller in scope than something written for a CPU.<p>It&#x27;s great for stuff like driving LED matrixes, offloading crypto operations, or signal processing. Anywhere you want low latency, but simple processing.</div><br/></div></div><div id="38157879" class="c"><input type="checkbox" id="c-38157879" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#38156925">parent</a><span>|</span><a href="#38157264">prev</a><span>|</span><a href="#38157661">next</a><span>|</span><label class="collapse" for="c-38157879">[-]</label><label class="expand" for="c-38157879">[1 more]</label></div><br/><div class="children"><div class="content">FPGAs are &quot;programmed&quot;, or perhaps more accurately, &quot;Synthesized&quot; with hardware description languages like Verilog or VHDL.<p>With typical programming, you&#x27;re describing software. With VHDL &#x2F; Verilog, you&#x27;re describing hardware. When Verilog&#x2F;VHDL &quot;runs&quot;, its just the hardware existing, ready to react to whatever happens later. There&#x27;s no code that &quot;steps&quot; through if-statements or loops... there&#x27;s instead state-machines that get stored into memory... with their outputs being directed upon physical wires you name.<p>As far as a &quot;language&quot; goes, I&#x27;d say its close to C++ Template Metaprogramming, though the syntax is very different. But the concepts are surprisingly close. C++ Templates do not compile into code, they compile into concepts and layouts... so to speak.<p>Well, of course C++ Templates eventually turn into C++ code. But imagine if the end result were flipflops, wires, and 1-bit memory instead. Maybe I&#x27;m describing it wrong... or maybe the only way to really know is to try it yourself.</div><br/></div></div><div id="38157661" class="c"><input type="checkbox" id="c-38157661" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38156925">parent</a><span>|</span><a href="#38157879">prev</a><span>|</span><a href="#38157532">next</a><span>|</span><label class="collapse" for="c-38157661">[-]</label><label class="expand" for="c-38157661">[2 more]</label></div><br/><div class="children"><div class="content">The hard part is not the &quot;programming&quot; part; it&#x27;s boolean logic, if you understand how your machine works at the gate level, it makes sense as a kind of pseudo-declarative model of the bits of the machine. I found Verilog &#x2F; SystemVerilog very intuitive and fun to work in. Not that I ever did it for a living, but it was entirely comprehensible to me after some practice. I went from newbie to wiring up my own simple video chip &amp; character generator to a RISC-V core in a month or two.<p>The hard parts are...<p>a) the &quot;fuzzy&quot; bits -- timing, propagation delays, etc. the tool will warn you about it but it&#x27;s not always easy to understand. It&#x27;s easy to end up with a mess that makes perfect sense &quot;logically&quot; and works in your sim, etc. but actually only sorta works in meatspace.<p>b) the tools. They all want to ram you into their shitty 1000lb IDEs which are forks of Eclipse from 15 years ago with a heaping dose of Tcl on the side and only work in some specific version of RedHat or whatever. Forget about using your preferred editor or IDE or build tool, they want to ram you through their GUI. You can sometimes route around it, by reverse engineering their Tcl and figuring out what command line invocations rae actually happening behind the heap of wizards they want to herd you through... but you&#x27;ll always end up back in Quartus or whatever at some point. HW Engineers seem to be suckers for this kind of punishment.</div><br/><div id="38157799" class="c"><input type="checkbox" id="c-38157799" checked=""/><div class="controls bullet"><span class="by">MegaDeKay</span><span>|</span><a href="#38156925">root</a><span>|</span><a href="#38157661">parent</a><span>|</span><a href="#38157532">next</a><span>|</span><label class="collapse" for="c-38157799">[-]</label><label class="expand" for="c-38157799">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it is quite fair to say that HW Engineers are suckers for that kind of punishment.  They don&#x27;t enjoy it either but their options are pretty limited.  The Yosys suite of tools is proof they are trying to fight back but it is an uphill battle as they try to decipher the encrypted bitstreams each vendor uses to hide what goes on between the curtain of their proprietary tools.  With few exceptions (some Lattice chips), the various architectures are only semi-reverse engineered at best.  The &quot;suckers&quot; can&#x27;t leave that capability on the table in the meantime.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;YosysHQ">https:&#x2F;&#x2F;github.com&#x2F;YosysHQ</a></div><br/></div></div></div></div></div></div><div id="38157532" class="c"><input type="checkbox" id="c-38157532" checked=""/><div class="controls bullet"><span class="by">photonbeam</span><span>|</span><a href="#38156925">prev</a><span>|</span><a href="#38157189">next</a><span>|</span><label class="collapse" for="c-38157532">[-]</label><label class="expand" for="c-38157532">[1 more]</label></div><br/><div class="children"><div class="content">Are these the ones with the SiFive U54 riscv cpus?</div><br/></div></div><div id="38157189" class="c"><input type="checkbox" id="c-38157189" checked=""/><div class="controls bullet"><span class="by">ShadowBanThis01</span><span>|</span><a href="#38157532">prev</a><span>|</span><label class="collapse" for="c-38157189">[-]</label><label class="expand" for="c-38157189">[15 more]</label></div><br/><div class="children"><div class="content">Just curious: This is a computer, so why say it has USB &quot;OTG&quot; (a dumb term anyway)? I would expect any computer with USB to act as a USB host.</div><br/><div id="38157895" class="c"><input type="checkbox" id="c-38157895" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#38157189">parent</a><span>|</span><a href="#38157218">next</a><span>|</span><label class="collapse" for="c-38157895">[-]</label><label class="expand" for="c-38157895">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I would expect any computer with USB to act as a USB host.<p>Do you expect your Keyboard to act as a USB Host?<p>If your Keyboard were USB OTG, then it would be a keyboard when plugged into a computer, but a mouse could plug into the keyboard and then the keyboard would be the USB Host. This bi-directional feature would be useful for maybe a modern Commodore 64 like device or something (I dunno, just making stuff up).<p>Traditionally, USB OTG was for phones. They want to be a device when plugged into a computer, but the phones also want to accept a mouse&#x2F;keyboard&#x2F;USB Mass Storage.</div><br/><div id="38159386" class="c"><input type="checkbox" id="c-38159386" checked=""/><div class="controls bullet"><span class="by">ShadowBanThis01</span><span>|</span><a href="#38157189">root</a><span>|</span><a href="#38157895">parent</a><span>|</span><a href="#38157218">next</a><span>|</span><label class="collapse" for="c-38159386">[-]</label><label class="expand" for="c-38159386">[3 more]</label></div><br/><div class="children"><div class="content">That question is nonsensical. A keyboard is not a computer; it&#x27;s CONNECTED to a computer. This device IS a computer, and you would typically connect a keyboard to IT.<p>&quot;OTG&quot; is inherently meaningless. Kind of like a &quot;red flag warning&quot; (for any CA readers).</div><br/><div id="38159949" class="c"><input type="checkbox" id="c-38159949" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38157189">root</a><span>|</span><a href="#38159386">parent</a><span>|</span><a href="#38159603">next</a><span>|</span><label class="collapse" for="c-38159949">[-]</label><label class="expand" for="c-38159949">[1 more]</label></div><br/><div class="children"><div class="content">Nope!<p>a) A keyboard has a little computer in it too. Fundamentally they&#x27;re both computers. It&#x27;s not the &quot;computerness&quot; that matters, it&#x27;s &quot;is this normally a peripheral?&quot;<p>b) This <i>is</i> normally a peripheral - you connect it to a host computer to program it.</div><br/></div></div><div id="38159603" class="c"><input type="checkbox" id="c-38159603" checked=""/><div class="controls bullet"><span class="by">stonogo</span><span>|</span><a href="#38157189">root</a><span>|</span><a href="#38159386">parent</a><span>|</span><a href="#38159949">prev</a><span>|</span><a href="#38157218">next</a><span>|</span><label class="collapse" for="c-38159603">[-]</label><label class="expand" for="c-38159603">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Inherently meaningless&quot; is fine for a name.  Anyway this one has an externally-applied meaning in the form of an actual specification, which defines OTG explicitly:<p><pre><code>   On-The-Go: An OTG product is a portable device that uses a single Micro-AB receptacle (and no other USB receptacles) to operate at times as a USB Targeted Host and at times as a USB peripheral. OTG devices shall always operate as a standard peripheral when connected to a standard USB host.
</code></pre>
You can get the rest of the details from the specification itself: <a href="https:&#x2F;&#x2F;www.usb.org&#x2F;document-library&#x2F;go-and-embedded-host-supplement-usb-revision-30-specification-revision-11" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.usb.org&#x2F;document-library&#x2F;go-and-embedded-host-su...</a></div><br/></div></div></div></div></div></div><div id="38157218" class="c"><input type="checkbox" id="c-38157218" checked=""/><div class="controls bullet"><span class="by">horse_dung</span><span>|</span><a href="#38157189">parent</a><span>|</span><a href="#38157895">prev</a><span>|</span><a href="#38157615">next</a><span>|</span><label class="collapse" for="c-38157218">[-]</label><label class="expand" for="c-38157218">[4 more]</label></div><br/><div class="children"><div class="content">OTG means the BeagleBoard can act as a device (like a keyboard, pendrive, etc) when connected to something else which is the host.</div><br/><div id="38159930" class="c"><input type="checkbox" id="c-38159930" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38157189">root</a><span>|</span><a href="#38157218">parent</a><span>|</span><a href="#38159420">next</a><span>|</span><label class="collapse" for="c-38159930">[-]</label><label class="expand" for="c-38159930">[1 more]</label></div><br/><div class="children"><div class="content">No it means it can act as a <i>host</i>, when it would normally be a device.</div><br/></div></div><div id="38159420" class="c"><input type="checkbox" id="c-38159420" checked=""/><div class="controls bullet"><span class="by">ShadowBanThis01</span><span>|</span><a href="#38157189">root</a><span>|</span><a href="#38157218">parent</a><span>|</span><a href="#38159930">prev</a><span>|</span><a href="#38159377">next</a><span>|</span><label class="collapse" for="c-38159420">[-]</label><label class="expand" for="c-38159420">[1 more]</label></div><br/><div class="children"><div class="content">Hm, I usually see this called out as being able to act as an HID.<p>&quot;OTG&quot; is such a gallingly stupid, uninformative term.</div><br/></div></div></div></div><div id="38157615" class="c"><input type="checkbox" id="c-38157615" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#38157189">parent</a><span>|</span><a href="#38157218">prev</a><span>|</span><a href="#38157224">next</a><span>|</span><label class="collapse" for="c-38157615">[-]</label><label class="expand" for="c-38157615">[1 more]</label></div><br/><div class="children"><div class="content">Beagle can use USB OTG for cheap networking over RNDIS&#x2F;CDC-ECM, or mount the device as a simulated thumb drive.</div><br/></div></div><div id="38157224" class="c"><input type="checkbox" id="c-38157224" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#38157189">parent</a><span>|</span><a href="#38157615">prev</a><span>|</span><a href="#38157538">next</a><span>|</span><label class="collapse" for="c-38157224">[-]</label><label class="expand" for="c-38157224">[1 more]</label></div><br/><div class="children"><div class="content">Probably a case of infectious terminology. Microchip has sold microcontrollers that could act as both a USB device or a USB host, and lacking a better term they used (misappropriated?) the term &quot;USB OTG&quot;. Probably this FPGA is reusing the silicon block from those microcontrollers, so the term was copy-pasted also.</div><br/></div></div><div id="38157538" class="c"><input type="checkbox" id="c-38157538" checked=""/><div class="controls bullet"><span class="by">syntaxing</span><span>|</span><a href="#38157189">parent</a><span>|</span><a href="#38157224">prev</a><span>|</span><a href="#38159594">next</a><span>|</span><label class="collapse" for="c-38157538">[-]</label><label class="expand" for="c-38157538">[3 more]</label></div><br/><div class="children"><div class="content">Someone mentioned this already but it means the beaglebone can act as a peripheral. Only RPi 4 and above has this feature so its not necessarily mainstream until maybe the past 5 years.</div><br/><div id="38157584" class="c"><input type="checkbox" id="c-38157584" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#38157189">root</a><span>|</span><a href="#38157538">parent</a><span>|</span><a href="#38159388">next</a><span>|</span><label class="collapse" for="c-38157584">[-]</label><label class="expand" for="c-38157584">[1 more]</label></div><br/><div class="children"><div class="content">No, the Raspberry Pi models A and Zero can also do USB OTG because they do not have a USB hub chip in the way like the models B.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>