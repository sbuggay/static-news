<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724058071688" as="style"/><link rel="stylesheet" href="styles.css?v=1724058071688"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kevinboone.me/cpm-c.html">Getting back into C programming for CP/M</a> <span class="domain">(<a href="https://kevinboone.me">kevinboone.me</a>)</span></div><div class="subtext"><span>AlexeyBrin</span> | <span>86 comments</span></div><br/><div><div id="41282338" class="c"><input type="checkbox" id="c-41282338" checked=""/><div class="controls bullet"><span class="by">stevekemp</span><span>|</span><a href="#41282207">next</a><span>|</span><label class="collapse" for="c-41282338">[-]</label><label class="expand" for="c-41282338">[2 more]</label></div><br/><div class="children"><div class="content">I put together a simple CP&#x2F;M emulator here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;skx&#x2F;cpmulator&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;skx&#x2F;cpmulator&#x2F;</a><p>Alongside that there is a collection of CP&#x2F;M binaries, including the Aztec C compiler:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;skx&#x2F;cpm-dist&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;skx&#x2F;cpm-dist&#x2F;</a><p>So you can easily have a stab at compiling code.  I added a simple file-manager, in C, along with other sources, to give a useful demo.  (Of course I spend more time writing code in Z80 assembler, or Turbo Pascal, rather than C).<p>The author has a followup post here for thos interested:<p>* Getting back into C programming for CP&#x2F;M -- part 2
* <a href="https:&#x2F;&#x2F;kevinboone.me&#x2F;cpm-c2.html" rel="nofollow">https:&#x2F;&#x2F;kevinboone.me&#x2F;cpm-c2.html</a></div><br/><div id="41287614" class="c"><input type="checkbox" id="c-41287614" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#41282338">parent</a><span>|</span><a href="#41282207">next</a><span>|</span><label class="collapse" for="c-41287614">[-]</label><label class="expand" for="c-41287614">[1 more]</label></div><br/><div class="children"><div class="content">Nice. File system integration is a nice feature that I&#x27;d like to see in more retrocomputing emulators.<p>I also like RunCPM, which can also run on some microcontroller boards, for a very tiny CP&#x2F;M 2.2 system: <a href="https:&#x2F;&#x2F;github.com&#x2F;MockbaTheBorg&#x2F;RunCPM">https:&#x2F;&#x2F;github.com&#x2F;MockbaTheBorg&#x2F;RunCPM</a><p>The README links to the author&#x27;s CP&#x2F;M software library as well.</div><br/></div></div></div></div><div id="41282207" class="c"><input type="checkbox" id="c-41282207" checked=""/><div class="controls bullet"><span class="by">jmclnx</span><span>|</span><a href="#41282338">prev</a><span>|</span><a href="#41282192">next</a><span>|</span><label class="collapse" for="c-41282207">[-]</label><label class="expand" for="c-41282207">[10 more]</label></div><br/><div class="children"><div class="content">&gt;The Aztec C compiler would have originally be distributed on floppy disks, and is very small by moden standards.<p>If I remember correctly, Aztec C was from Mark Williams.  It was also the basis for the c Compiler that came with Coherent OS.<p>But yes, things were far easier in the 80s, even on Minis which I worked on back then.  These days development is just a series of Meetings, Agile Points, Scrums with maybe 2 hours of real work per week.  Many people now tend to do their real work off-hours, a sad situation.<p>But I am looking for 1 more piece of hardware, then I can set up a DOS Machine to play with myself :)<p>&gt;The Aztec compiler pre-dates ANSI C, and follows the archaic Kernigan &amp; Ritchie syntax<p>I still do not like ANSI C standards after all these years.</div><br/><div id="41284643" class="c"><input type="checkbox" id="c-41284643" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#41282207">parent</a><span>|</span><a href="#41283125">next</a><span>|</span><label class="collapse" for="c-41284643">[-]</label><label class="expand" for="c-41284643">[1 more]</label></div><br/><div class="children"><div class="content">While we&#x27;re ranting don&#x27;t forget developers in the 80&#x27;s didn&#x27;t sit in a noisy open space!<p>This was totally me ~15 years ago in a Scrum place with an open floor plan, doing most of my work after everyone left in the evening or on holidays because it was quiet and I could finally get some stuff done. I wrote big pieces of the product by myself.<p>My first C compiler was on a VAX. I did have some C compiler for my ZX Spectrum at some much later point but I don&#x27;t remember doing much with it. Then a series of compilers for PCs. One random memory is some sort of REPL C, maybe Interactive-C or something? But pretty quickly it was Microsoft and Borland.<p>EDIT: On a more serious note re: meetings and such. Part of the difference is that working in much larger teams and projects becomes less efficient and requires more communication. Mature projects also require less of the builder thing and more of the maintainer thing. Software lasts a long time and inevitably maintenance becomes the work most people end up doing.</div><br/></div></div><div id="41283125" class="c"><input type="checkbox" id="c-41283125" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#41282207">parent</a><span>|</span><a href="#41284643">prev</a><span>|</span><a href="#41282284">next</a><span>|</span><label class="collapse" for="c-41283125">[-]</label><label class="expand" for="c-41283125">[1 more]</label></div><br/><div class="children"><div class="content">That sounds familiar so I looked it up[0]. I used Mark Williams C compiler on the Atari ST--<i>eventually settling on Megamax C as it ran better on my small floppy-based machine.</i><p>Computing was a smaller world back then, the company was founded by Robert Swartz (father of Aaron Swartz) and named after his father William Mark Swartz.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mark_Williams_Company" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mark_Williams_Company</a></div><br/></div></div><div id="41282284" class="c"><input type="checkbox" id="c-41282284" checked=""/><div class="controls bullet"><span class="by">nils-m-holm</span><span>|</span><a href="#41282207">parent</a><span>|</span><a href="#41283125">prev</a><span>|</span><a href="#41287664">next</a><span>|</span><label class="collapse" for="c-41282284">[-]</label><label class="expand" for="c-41282284">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If I remember correctly, Aztec C was from Mark Williams. It was also the basis for the c Compiler that came with Coherent OS.<p>That would have been &quot;Mark Williams C&quot;, also marketed as &quot;Let&#x27;s C&quot; for MDSOS.</div><br/><div id="41282368" class="c"><input type="checkbox" id="c-41282368" checked=""/><div class="controls bullet"><span class="by">flyinghamster</span><span>|</span><a href="#41282207">root</a><span>|</span><a href="#41282284">parent</a><span>|</span><a href="#41283038">next</a><span>|</span><label class="collapse" for="c-41282368">[-]</label><label class="expand" for="c-41282368">[1 more]</label></div><br/><div class="children"><div class="content">Yup. Let&#x27;s C was the cut-down version of MWC86, with no large-model support. This limited you to 64K code and 64K data. I got a copy of it one Christmas, but never used it much because of this limitation.</div><br/></div></div><div id="41283038" class="c"><input type="checkbox" id="c-41283038" checked=""/><div class="controls bullet"><span class="by">jmclnx</span><span>|</span><a href="#41282207">root</a><span>|</span><a href="#41282284">parent</a><span>|</span><a href="#41282368">prev</a><span>|</span><a href="#41287664">next</a><span>|</span><label class="collapse" for="c-41283038">[-]</label><label class="expand" for="c-41283038">[1 more]</label></div><br/><div class="children"><div class="content">Correct, that was it, &quot;Lets C&quot;.</div><br/></div></div></div></div><div id="41287664" class="c"><input type="checkbox" id="c-41287664" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#41282207">parent</a><span>|</span><a href="#41282284">prev</a><span>|</span><a href="#41283212">next</a><span>|</span><label class="collapse" for="c-41287664">[-]</label><label class="expand" for="c-41287664">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Many people now tend to do their real work off-hours, a sad situation<p>It&#x27;s the only practical approach when offices are designed to be distracting and productivity-killing, meetings are incessant, and groupware delivers a constant stream of interrupts which one is expected to monitor and respond to quickly - especially while working remotely.</div><br/></div></div><div id="41283212" class="c"><input type="checkbox" id="c-41283212" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#41282207">parent</a><span>|</span><a href="#41287664">prev</a><span>|</span><a href="#41282523">next</a><span>|</span><label class="collapse" for="c-41283212">[-]</label><label class="expand" for="c-41283212">[2 more]</label></div><br/><div class="children"><div class="content">Back in the early 90&#x27;s, before Linux took off, I ran Coherent. It came with incredible documentation, and I still remember the huge book with the shell on it.<p>And you&#x27;re absolutely right about all the agile bull...</div><br/><div id="41287126" class="c"><input type="checkbox" id="c-41287126" checked=""/><div class="controls bullet"><span class="by">AstroJetson</span><span>|</span><a href="#41282207">root</a><span>|</span><a href="#41283212">parent</a><span>|</span><a href="#41282523">next</a><span>|</span><label class="collapse" for="c-41287126">[-]</label><label class="expand" for="c-41287126">[1 more]</label></div><br/><div class="children"><div class="content">I loved Coherent, and I still have the “shell” book.  It was one of the best things about using those tiny machines.</div><br/></div></div></div></div><div id="41282523" class="c"><input type="checkbox" id="c-41282523" checked=""/><div class="controls bullet"><span class="by">reaperducer</span><span>|</span><a href="#41282207">parent</a><span>|</span><a href="#41283212">prev</a><span>|</span><a href="#41282192">next</a><span>|</span><label class="collapse" for="c-41282523">[-]</label><label class="expand" for="c-41282523">[1 more]</label></div><br/><div class="children"><div class="content"><i>These days development is just a series of Meetings, Agile Points, Scrums with maybe 2 hours of real work per week.</i><p>Think about early video game development at large companies: One person (maybe two), six months.  The company gave them room to practice their art, and the result sold a million copies.<p>These days everyone wants to cosplay Big Tech and worship abstraction layers, so you can&#x27;t get all of the &quot;stakeholders&quot; in the same meeting in six months.</div><br/></div></div></div></div><div id="41282192" class="c"><input type="checkbox" id="c-41282192" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41282207">prev</a><span>|</span><a href="#41282637">next</a><span>|</span><label class="collapse" for="c-41282192">[-]</label><label class="expand" for="c-41282192">[9 more]</label></div><br/><div class="children"><div class="content">Personally I see the use of a cross-compiler and other dev tools on a bigger machine as even more retro than running them in an 8-bit micro because it is what many software vendors did at the dawn of the microcomputer age.<p>Also if you like the Z80 you should try<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zilog_eZ80" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zilog_eZ80</a><p>Which is crazy fast not to mention the only 8-bit architecture that got extended to 24-bit addressing in a sane way with index registers. (Sorry the 65816 sucks)</div><br/><div id="41283066" class="c"><input type="checkbox" id="c-41283066" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#41282192">parent</a><span>|</span><a href="#41282637">next</a><span>|</span><label class="collapse" for="c-41283066">[-]</label><label class="expand" for="c-41283066">[8 more]</label></div><br/><div class="children"><div class="content">&gt; because it is what many software vendors did at the dawn of the microcomputer age.<p>They really didn&#x27;t have any choice if they wanted to actually accomplish something.<p>The 8-bit machines of the day, CP&#x2F;M running 1-2MHz 8080s, 2-4MHz Z80, with no memory, and glacial disk drives (with not a lot of capacity).<p>Go ahead and fire up a CP&#x2F;M simulator that lets you change the clock rate, and dial it down to heritage levels (and even then it&#x27;s not quite the same, the I&#x2F;O is still too fast). Watching the clock tick by as you load the editor, load the file, make your changes, quit the editor, load the compiler, load the linker, test the program, then back to the editor. There is friction here, the process just drrraaagggsss.<p>Turbo Pascal was usable for small programs. In memory editor, compiling to memory, running from memory. Ziinng! Start writing things to disk, and you were back to square one. The best thing Turbo did was eliminate the linking step (at the cost of having to INCLUDE and recompile things every time).<p>It was a different time.<p>As someone who lived through that, we simply didn&#x27;t know any better. Each generation got incrementally faster. There were few leaps in orders of magnitude.<p>But going back, whoo boy. Amazing anything got accomplished.</div><br/><div id="41284417" class="c"><input type="checkbox" id="c-41284417" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41282192">root</a><span>|</span><a href="#41283066">parent</a><span>|</span><a href="#41287460">next</a><span>|</span><label class="collapse" for="c-41284417">[-]</label><label class="expand" for="c-41284417">[1 more]</label></div><br/><div class="children"><div class="content">I got paid to develop some software for a teacher at my school and wrote it in some kind of basic (GWBASIC?) for my IBM PC AT clone,  then found out she had a CP&#x2F;M machine.<p>I had just read in Byte magazine that there was a good CP&#x2F;M emulator that ran several times faster than any real CP&#x2F;M system already in 1988 or so.  So I used that software to run a CP&#x2F;M environment and port the code to some BASIC variant there.</div><br/></div></div><div id="41287460" class="c"><input type="checkbox" id="c-41287460" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41282192">root</a><span>|</span><a href="#41283066">parent</a><span>|</span><a href="#41284417">prev</a><span>|</span><a href="#41287632">next</a><span>|</span><label class="collapse" for="c-41287460">[-]</label><label class="expand" for="c-41287460">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>They really didn&#x27;t have any choice if they wanted to actually accomplish something.</i><p>microsoft in particular did their initial development of altair basic on harvard&#x27;s pdp-10, using pdp-10 assemblers and debuggers; not only did they not have an altair, nobody had an altair<p>but an awful lot of pc software was written on pcs. woz wrote integer basic on the apple. bds c was assembled on cp&#x2F;m. probably the majority of pc developers didn&#x27;t have access to a bigger computer<p>those who did had an advantage, but sometimes it backfired. i remember the ucsd p-system as being unbearably slow, and i suspect that part of the reason was that its authors didn&#x27;t empathize enough with their users&#x27; frustration to commit the efficiency hacks used by systems like eumel and basic-80</div><br/></div></div><div id="41287632" class="c"><input type="checkbox" id="c-41287632" checked=""/><div class="controls bullet"><span class="by">jrdres</span><span>|</span><a href="#41282192">root</a><span>|</span><a href="#41283066">parent</a><span>|</span><a href="#41287460">prev</a><span>|</span><a href="#41284132">next</a><span>|</span><label class="collapse" for="c-41287632">[-]</label><label class="expand" for="c-41287632">[1 more]</label></div><br/><div class="children"><div class="content">One of the first CP&#x2F;M C&#x27;s was BDS-C. It&#x27;s claim to fame was that it compiled the source in-memory, so it was at least that part was nice and fast.<p>Certainly compared to Whitesmiths C for CP&#x2F;M, and not just for the $700 price vs $150 for BDS-C. Whitesmiths was real, official C, direct from P. J. Plauger and V6 Unix. But each compile went through many, many, many passes on the poor floppy (including pseudo-assembly &quot;A-Natural&quot; for the 8080 that then translated to real assembly). Everybody complained that while very professional, it just took too long to go through the cycle.<p>Contemporary BYTE recommendation was to develop &amp; iterate on BDS-C, then at the end re-compile on Whitesmiths to squeeze the best performance.</div><br/></div></div><div id="41284132" class="c"><input type="checkbox" id="c-41284132" checked=""/><div class="controls bullet"><span class="by">andyjohnson0</span><span>|</span><a href="#41282192">root</a><span>|</span><a href="#41283066">parent</a><span>|</span><a href="#41287632">prev</a><span>|</span><a href="#41283666">next</a><span>|</span><label class="collapse" for="c-41284132">[-]</label><label class="expand" for="c-41284132">[1 more]</label></div><br/><div class="children"><div class="content">Android development with an emulator on my 8-core 64Gb desktop system feels a bit like this nowadays</div><br/></div></div><div id="41283666" class="c"><input type="checkbox" id="c-41283666" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41282192">root</a><span>|</span><a href="#41283066">parent</a><span>|</span><a href="#41284132">prev</a><span>|</span><a href="#41282637">next</a><span>|</span><label class="collapse" for="c-41283666">[-]</label><label class="expand" for="c-41283666">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, all my learnings were from  books, bought or local library, computer magazines, and occasional demoscene meetings.<p>I was able to connect to BBS only during the summer internship I did, at the end of my vocational school training in computer programming.<p>When I afterwards arrived into the university, Gopher was still a thing.<p>Lots of paper based programming, and wild guessing, there was no Stack Overflow to help us out.</div><br/><div id="41286857" class="c"><input type="checkbox" id="c-41286857" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41282192">root</a><span>|</span><a href="#41283666">parent</a><span>|</span><a href="#41282637">next</a><span>|</span><label class="collapse" for="c-41286857">[-]</label><label class="expand" for="c-41286857">[2 more]</label></div><br/><div class="children"><div class="content">But you could learn BASIC, or Pascal, or C from one pretty thin book.  And you could learn pretty much <i>all</i> of the language from that thin book.<p>There was less to learn, and so you could learn it pretty thoroughly from more meager resources.</div><br/><div id="41288065" class="c"><input type="checkbox" id="c-41288065" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41282192">root</a><span>|</span><a href="#41286857">parent</a><span>|</span><a href="#41282637">next</a><span>|</span><label class="collapse" for="c-41288065">[-]</label><label class="expand" for="c-41288065">[1 more]</label></div><br/><div class="children"><div class="content">That was the easy part, coming up with algorithms, data structures (what is that?), and the actual hardware and OS mappings, was already beyond that book.<p>Until I got hold of Input magazines collection, I was pretty much stuck with my Timex 2068 manual, and its set of demos.<p>It is like learning a foreign language from a dictionary without anything else, until someone else shows the structure of the sentences.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41282637" class="c"><input type="checkbox" id="c-41282637" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#41282192">prev</a><span>|</span><a href="#41284712">next</a><span>|</span><label class="collapse" for="c-41282637">[-]</label><label class="expand" for="c-41282637">[7 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s no obvious way to create a lower-case filename on CP&#x2F;M<p>That&#x27;s because the FAT file system used by CP&#x2F;M didn&#x27;t allow lower case letters, at all.  In this case &quot;no obvious way&quot; == &quot;impossible&quot;.<p>The stack problems mentioned were real.  The stack size was set at compile time, and there was no way to extend it.  Plus the stack was not just used by your software, but also hardware interrupts and their functions.</div><br/><div id="41282992" class="c"><input type="checkbox" id="c-41282992" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#41282637">parent</a><span>|</span><a href="#41283031">next</a><span>|</span><label class="collapse" for="c-41282992">[-]</label><label class="expand" for="c-41282992">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s because the FAT file system used by CP&#x2F;M didn&#x27;t allow lower case letters, at all.<p>That&#x27;s not true.<p>You could use lowercase file names.<p>Just fire up MS-BASIC, and save your file as &quot;test.bas&quot;. You now have a lower case file name.<p>The problem is that all of the CCP utilities implicitly upshifted everything from the command line. So, with the stock set, you were out of luck.<p>You can go back into BASIC and KILL the file, so all was not lost.<p>But, the file system was perfectly capable of coping with lower case file names, just nothing else was.</div><br/></div></div><div id="41283031" class="c"><input type="checkbox" id="c-41283031" checked=""/><div class="controls bullet"><span class="by">nils-m-holm</span><span>|</span><a href="#41282637">parent</a><span>|</span><a href="#41282992">prev</a><span>|</span><a href="#41283862">next</a><span>|</span><label class="collapse" for="c-41283031">[-]</label><label class="expand" for="c-41283031">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s because the FAT file system used by CP&#x2F;M didn&#x27;t allow lower case letters, at all.<p>Sure it did. Just start Microsoft BASIC on CP&#x2F;M, type a program and save it as &quot;hello&quot;. It will appear in the directory as &quot;hello.BAS&quot;. Of course the CCP, the
console command processor, will convert all file names to upper case, so you can neither type nor copy nor erase the file, but still it exists. You can even load it from MBASIC using LOAD.<p>You can have any characters you like in your CP&#x2F;M file names. Sometimes I ended up with file names consisting of all blanks. I usually used a disk editor to deal with those, but there were lots of more convenient tools for the job.</div><br/></div></div><div id="41283862" class="c"><input type="checkbox" id="c-41283862" checked=""/><div class="controls bullet"><span class="by">CodeWriter23</span><span>|</span><a href="#41282637">parent</a><span>|</span><a href="#41283031">prev</a><span>|</span><a href="#41282990">next</a><span>|</span><label class="collapse" for="c-41283862">[-]</label><label class="expand" for="c-41283862">[1 more]</label></div><br/><div class="children"><div class="content">CP&#x2F;M was FCB&#x2F;Extents not FAT</div><br/></div></div><div id="41282990" class="c"><input type="checkbox" id="c-41282990" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#41282637">parent</a><span>|</span><a href="#41283862">prev</a><span>|</span><a href="#41285886">next</a><span>|</span><label class="collapse" for="c-41282990">[-]</label><label class="expand" for="c-41282990">[2 more]</label></div><br/><div class="children"><div class="content">Not FAT, but something even more rudimentary.</div><br/><div id="41285145" class="c"><input type="checkbox" id="c-41285145" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#41282637">root</a><span>|</span><a href="#41282990">parent</a><span>|</span><a href="#41285886">next</a><span>|</span><label class="collapse" for="c-41285145">[-]</label><label class="expand" for="c-41285145">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, my bad.</div><br/></div></div></div></div><div id="41285886" class="c"><input type="checkbox" id="c-41285886" checked=""/><div class="controls bullet"><span class="by">fortran77</span><span>|</span><a href="#41282637">parent</a><span>|</span><a href="#41282990">prev</a><span>|</span><a href="#41284712">next</a><span>|</span><label class="collapse" for="c-41285886">[-]</label><label class="expand" for="c-41285886">[1 more]</label></div><br/><div class="children"><div class="content">CP&#x2F;M was not fat.</div><br/></div></div></div></div><div id="41284712" class="c"><input type="checkbox" id="c-41284712" checked=""/><div class="controls bullet"><span class="by">opless</span><span>|</span><a href="#41282637">prev</a><span>|</span><a href="#41281838">next</a><span>|</span><label class="collapse" for="c-41284712">[-]</label><label class="expand" for="c-41284712">[1 more]</label></div><br/><div class="children"><div class="content">&gt; CP&#x2F;M systems rarely had more than 64Mb of RAM<p>True. But I think you meant KB.<p>Back in the days when CP&#x2F;M was king, even 20MB Winchester hard drives were rare</div><br/></div></div><div id="41281838" class="c"><input type="checkbox" id="c-41281838" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41284712">prev</a><span>|</span><a href="#41282887">next</a><span>|</span><label class="collapse" for="c-41281838">[-]</label><label class="expand" for="c-41281838">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Many programmers, including myself, have gotten out of the habit of doing this on modern systems like Linux, because a malloc() call always succeeds, regardless how much memory is available.<p>Not if you use setrusage().</div><br/><div id="41282226" class="c"><input type="checkbox" id="c-41282226" checked=""/><div class="controls bullet"><span class="by">jmclnx</span><span>|</span><a href="#41281838">parent</a><span>|</span><a href="#41282189">next</a><span>|</span><label class="collapse" for="c-41282226">[-]</label><label class="expand" for="c-41282226">[2 more]</label></div><br/><div class="children"><div class="content">Not me :)<p>What I develop I always make sure I test on NetBSD and OpenBSD.  That keeps me honest and those systems will find issues that Linux does not care about.  I found many issues by testing on those systems.<p>Also, ignoring malloc() returns is dangerous if you want to port your application to a UNIX like AIX.</div><br/><div id="41282309" class="c"><input type="checkbox" id="c-41282309" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#41281838">root</a><span>|</span><a href="#41282226">parent</a><span>|</span><a href="#41282189">next</a><span>|</span><label class="collapse" for="c-41282309">[-]</label><label class="expand" for="c-41282309">[1 more]</label></div><br/><div class="children"><div class="content">Ignoring failures is a bad idea, but in many applications quitting on malloc() retiring NULL is the most sensibile thing to do. Many, but not all kinds of applications.</div><br/></div></div></div></div><div id="41282189" class="c"><input type="checkbox" id="c-41282189" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#41281838">parent</a><span>|</span><a href="#41282226">prev</a><span>|</span><a href="#41282582">next</a><span>|</span><label class="collapse" for="c-41282189">[-]</label><label class="expand" for="c-41282189">[3 more]</label></div><br/><div class="children"><div class="content">&gt;setrusage()<p>Is it old version of setrlimit()? Couldn&#x27;t locate it in any of the man.*bsd.org.</div><br/><div id="41282553" class="c"><input type="checkbox" id="c-41282553" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41281838">root</a><span>|</span><a href="#41282189">parent</a><span>|</span><a href="#41282582">next</a><span>|</span><label class="collapse" for="c-41282553">[-]</label><label class="expand" for="c-41282553">[2 more]</label></div><br/><div class="children"><div class="content">My bad, that&#x27;s what I intended to say.</div><br/><div id="41282689" class="c"><input type="checkbox" id="c-41282689" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#41281838">root</a><span>|</span><a href="#41282553">parent</a><span>|</span><a href="#41282582">next</a><span>|</span><label class="collapse" for="c-41282689">[-]</label><label class="expand" for="c-41282689">[1 more]</label></div><br/><div class="children"><div class="content">I did found plenty of docs and books mentioning setrusage() though, like a proper Mandela Effect.</div><br/></div></div></div></div></div></div><div id="41282582" class="c"><input type="checkbox" id="c-41282582" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#41281838">parent</a><span>|</span><a href="#41282189">prev</a><span>|</span><a href="#41282887">next</a><span>|</span><label class="collapse" for="c-41282582">[-]</label><label class="expand" for="c-41282582">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not if you use setrusage().<p>Or if memory overcommit is disabled or an &#x27;unreasonable&#x27; amount of memory was requested.  So, no, malloc() doesn&#x27;t always succeed.</div><br/></div></div></div></div><div id="41282887" class="c"><input type="checkbox" id="c-41282887" checked=""/><div class="controls bullet"><span class="by">dpb001</span><span>|</span><a href="#41281838">prev</a><span>|</span><a href="#41282550">next</a><span>|</span><label class="collapse" for="c-41282887">[-]</label><label class="expand" for="c-41282887">[1 more]</label></div><br/><div class="children"><div class="content">This brought back some memories. Back in the day I couldn&#x27;t afford the Aztec compiler (or it wouldn&#x27;t fit onto my dual floppy 48K Heathkit H89, can&#x27;t remember which).  I ended up buying Leor Zolman&#x27;s BDS C compiler.  Just looked him up and it looks like he&#x27;s still around!<p><a href="https:&#x2F;&#x2F;www.bdsoft.com" rel="nofollow">https:&#x2F;&#x2F;www.bdsoft.com</a></div><br/></div></div><div id="41282550" class="c"><input type="checkbox" id="c-41282550" checked=""/><div class="controls bullet"><span class="by">anonymousiam</span><span>|</span><a href="#41282887">prev</a><span>|</span><a href="#41282056">next</a><span>|</span><label class="collapse" for="c-41282550">[-]</label><label class="expand" for="c-41282550">[1 more]</label></div><br/><div class="children"><div class="content">Many of the complaints by the author are in the context of differences between C today and C back then, but back when CP&#x2F;M was in common use, C compilers typically did not do much optimization, and K&amp;R C was all there was.<p>I did not use Aztec C until a few years after I switched from CP&#x2F;M to DOS, but I really liked it, and used it for several 68k bare-metal projects.  I did poke around with BDS C on CP&#x2F;M, but was immediately turned off by the lack of standard floating point support.  (It did offer an odd BCD float library.)<p><a href="https:&#x2F;&#x2F;www.bdsoft.com&#x2F;dist&#x2F;bdsc-guide.pdf" rel="nofollow">https:&#x2F;&#x2F;www.bdsoft.com&#x2F;dist&#x2F;bdsc-guide.pdf</a></div><br/></div></div><div id="41282056" class="c"><input type="checkbox" id="c-41282056" checked=""/><div class="controls bullet"><span class="by">nils-m-holm</span><span>|</span><a href="#41282550">prev</a><span>|</span><a href="#41282129">next</a><span>|</span><label class="collapse" for="c-41282056">[-]</label><label class="expand" for="c-41282056">[10 more]</label></div><br/><div class="children"><div class="content">Funny how most of the article reads (to me) &quot;back in the days things were done in the obvious way, while now everything is weird&quot;. In other words I still program like in the 1980&#x27;s. :)<p>CP&#x2F;M programming is a lot of fun, even these days! I have a growing collection of retro machines running CP&#x2F;M, my latest compiler has a CP&#x2F;M backend, and I have even written a book about the design of a CP&#x2F;M compiler: <a href="http:&#x2F;&#x2F;t3x.org&#x2F;t3x&#x2F;0&#x2F;book.html" rel="nofollow">http:&#x2F;&#x2F;t3x.org&#x2F;t3x&#x2F;0&#x2F;book.html</a></div><br/><div id="41282126" class="c"><input type="checkbox" id="c-41282126" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41282056">parent</a><span>|</span><a href="#41282429">next</a><span>|</span><label class="collapse" for="c-41282126">[-]</label><label class="expand" for="c-41282126">[8 more]</label></div><br/><div class="children"><div class="content">There has been an incredible amount of principles and practices added to our profession. Most of which are silly. Like Clean Code which is just out right terrible in terms of causing CPU cache misses as well as getting you into vtable for your class hierarchies. Most modern developers wouldn’t know what a L1 cache is though, so they don’t think too much about the cost. What is worse is that people like uncle Bob haven’t actually worked in programming for several decades. Yet these are the people who teach modern programmers how they are supposed to write code.<p>I get it though, if what you’re selling is “best practices” you’re obviously going to over complicate things. You’re likely also going to be very successful in marketing it to a profession where things are just… bad. I mean, in how many other branches of engineering is it considered natural that things just flat out fail as often as they do in IT? So it’s easy to sell “best practices”. Of course after three decades of peddling various principles and strategies and so on, our business is in even worse state than it was before.<p>In my country we’ve spent a literal metric fuck ton of money trying to replace some of the COBOL systems powering a lot of our most critical financial systems. From the core or our tax agency to banking. So far no one have been capable of doing it, despite various major contractors applying all sorts of “modern” strategies and tools.</div><br/><div id="41282287" class="c"><input type="checkbox" id="c-41282287" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#41282056">root</a><span>|</span><a href="#41282126">parent</a><span>|</span><a href="#41282205">next</a><span>|</span><label class="collapse" for="c-41282287">[-]</label><label class="expand" for="c-41282287">[3 more]</label></div><br/><div class="children"><div class="content">The issue here is all these caches. Back in my day we didn&#x27;t have caches and memory access time was deterministic - and expensive! We kept things in our 4-8 registers and we were happy with it. Programs larger than that weren&#x27;t meant to be fast!</div><br/><div id="41284313" class="c"><input type="checkbox" id="c-41284313" checked=""/><div class="controls bullet"><span class="by">NikkiA</span><span>|</span><a href="#41282056">root</a><span>|</span><a href="#41282287">parent</a><span>|</span><a href="#41282205">next</a><span>|</span><label class="collapse" for="c-41284313">[-]</label><label class="expand" for="c-41284313">[2 more]</label></div><br/><div class="children"><div class="content">In reality those caches are going to be relatively meaningless except for short bursts of speed, because the 100,000 API calls and user&#x2F;kernel switches, that windows does because of absurd abstractions, that happen in the time slice your program isn&#x27;t running will destroy any cache coloring you attempt to code for.</div><br/><div id="41288669" class="c"><input type="checkbox" id="c-41288669" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41282056">root</a><span>|</span><a href="#41284313">parent</a><span>|</span><a href="#41282205">next</a><span>|</span><label class="collapse" for="c-41288669">[-]</label><label class="expand" for="c-41288669">[1 more]</label></div><br/><div class="children"><div class="content">Unless you’re doing your computation on DDR5 ram you’re easily looking running your code 100 times slower when you’re hitting L1 and L2 cache misses. Add to this that even a relatively simple loop over a 1000 entities where you alter 4 properties on each will run 20 times slower with a class hierarchy compared to a flat structure and you’re quickly adding a large performance loss to what you’re already paying for your 100.000 api calls.<p>Which might be worth it if something like Clean Code by the book was actually easier to read, maintain or do any form of team work on. I’d wager it’s not just your hardware which is going to have memory issues when you split that code out over 9 files and 3 projects though. It’s very likely that your own memory load struggles to cope, especially if it’s not code you’ve worked on recently.</div><br/></div></div></div></div></div></div><div id="41282193" class="c"><input type="checkbox" id="c-41282193" checked=""/><div class="controls bullet"><span class="by">ImHereToVote</span><span>|</span><a href="#41282056">root</a><span>|</span><a href="#41282126">parent</a><span>|</span><a href="#41282205">prev</a><span>|</span><a href="#41282429">next</a><span>|</span><label class="collapse" for="c-41282193">[-]</label><label class="expand" for="c-41282193">[3 more]</label></div><br/><div class="children"><div class="content">The issue is that there is a vast chasm between software written by some competent guy and software written by a development team.</div><br/><div id="41282300" class="c"><input type="checkbox" id="c-41282300" checked=""/><div class="controls bullet"><span class="by">steveBK123</span><span>|</span><a href="#41282056">root</a><span>|</span><a href="#41282193">parent</a><span>|</span><a href="#41282428">next</a><span>|</span><label class="collapse" for="c-41282300">[-]</label><label class="expand" for="c-41282300">[1 more]</label></div><br/><div class="children"><div class="content">Yes and &quot;software written by some competent dev&quot; is a thing that stops scaling after an org reaches 100s or 1000s of devs.<p>Management then moves to a model of minimizing outlier behavior to reduce risk of any one dev doing stupid things.  However this process tends to squeeze the &quot;some competent dev&quot; types out as they are outliers on the positive side of the scale..</div><br/></div></div><div id="41282428" class="c"><input type="checkbox" id="c-41282428" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41282056">root</a><span>|</span><a href="#41282193">parent</a><span>|</span><a href="#41282300">prev</a><span>|</span><a href="#41282429">next</a><span>|</span><label class="collapse" for="c-41282428">[-]</label><label class="expand" for="c-41282428">[1 more]</label></div><br/><div class="children"><div class="content">True, but maybe we should utilise principles which don’t suck. Things like onion architecture, SOLID, DRY and similar don’t appear to scale well considering software is still a mess. Because not only can’t your hardware find your functions and data, your developers can’t either.<p>It’s a balancing act of course, but I think a major part of the issue with “best practices” is that there are no best practices for every thing. Clean Code will work well for somethings. If you’re iterating through a list of a thousand objects it’s one and a half time slower than a flat structure. If you were changing 4 properties in every element it might be 20 times less performant though. So obviously this wouldn’t be a good place to split your code out into four different files in 3 different projects. On the flip side something like the single responsibility principle is completely solid for the most part.<p>Maybe if people like Uncle Bob didn’t respond with “they misunderstood the principle” when faced with criticism we might have some useful ways to work with code in large teams. I’d like to see someone do research which actually proves that the “modern” ways work as intended. As far as I’m aware, nobody has been able to prove that something like Clean Code actually works. You can really say the same thing for something like by the book SCRUM or any form of strategy. It’s all a load of pseudo science until we have had evidence that it actually makes the difference it claims to do.<p>That being said. I don’t think it’s unreasonable to expect that developers know how a computer works.</div><br/></div></div></div></div></div></div></div></div><div id="41282129" class="c"><input type="checkbox" id="c-41282129" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#41282056">prev</a><span>|</span><a href="#41281800">next</a><span>|</span><label class="collapse" for="c-41282129">[-]</label><label class="expand" for="c-41282129">[2 more]</label></div><br/><div class="children"><div class="content">I did a shedload of programming in CP&#x2F;M back in the 80s, and frankly I&#x27;d rather do it in Z80 assembler (assuming we were targeting Z80-based systems) than the rather poor compilers (not just C compilers) that were available. Using a compiler&#x2F;linker on a floppy-based CP&#x2F;M machine was quite a pain, as the compiler took up a lot more space than an assembler, and was typically much slower.<p>And I like writing assembler!</div><br/><div id="41285308" class="c"><input type="checkbox" id="c-41285308" checked=""/><div class="controls bullet"><span class="by">julian55</span><span>|</span><a href="#41282129">parent</a><span>|</span><a href="#41281800">next</a><span>|</span><label class="collapse" for="c-41285308">[-]</label><label class="expand" for="c-41285308">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I agree. I did write some C software for Z80 but mostly I used assembler.</div><br/></div></div></div></div><div id="41281800" class="c"><input type="checkbox" id="c-41281800" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41282129">prev</a><span>|</span><a href="#41286888">next</a><span>|</span><label class="collapse" for="c-41281800">[-]</label><label class="expand" for="c-41281800">[13 more]</label></div><br/><div class="children"><div class="content">A very good example how C wasn&#x27;t as portable and as high performance back in the 1980&#x27;s, as many nowadays think it was.</div><br/><div id="41282196" class="c"><input type="checkbox" id="c-41282196" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#41281800">parent</a><span>|</span><a href="#41283436">next</a><span>|</span><label class="collapse" for="c-41282196">[-]</label><label class="expand" for="c-41282196">[8 more]</label></div><br/><div class="children"><div class="content">Not on 8 bit machines, no.  Look at  what Perl did with C in that timeframe though, and it&#x27;s true for a different subset of machines.<p>Within Perl 1.0, part of the Configure script, you can see the list of machines it could build on here: <a href="https:&#x2F;&#x2F;github.com&#x2F;kaworu&#x2F;perl1&#x2F;blob&#x2F;ba165bbde4eef698ff9cc697ab2ff7d0f388714d&#x2F;Configure#L121">https:&#x2F;&#x2F;github.com&#x2F;kaworu&#x2F;perl1&#x2F;blob&#x2F;ba165bbde4eef698ff9cc69...</a><p><pre><code>  attrlist=&quot;mc68000 sun gcos unix ibm gimpel interdata tss os mert pyr&quot;
  attrlist=&quot;$attrlist vax pdp11 i8086 z8000 u3b2 u3b5 u3b20 u3b200&quot;
  attrlist=&quot;$attrlist ns32000 ns16000 iAPX286 mc300 mc500 mc700 sparc&quot;</code></pre></div><br/><div id="41282795" class="c"><input type="checkbox" id="c-41282795" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41282196">parent</a><span>|</span><a href="#41283436">next</a><span>|</span><label class="collapse" for="c-41282795">[-]</label><label class="expand" for="c-41282795">[7 more]</label></div><br/><div class="children"><div class="content">Not even on 16 bit home machines, which is why any serious game, or winning demoscene entries, were written in Assembly, until we reached the days of 486 and DOS extenders.<p>As a read through the Amiga and PC literature of the time will show.</div><br/><div id="41283002" class="c"><input type="checkbox" id="c-41283002" checked=""/><div class="controls bullet"><span class="by">kelsey98765431</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41282795">parent</a><span>|</span><a href="#41283752">next</a><span>|</span><label class="collapse" for="c-41283002">[-]</label><label class="expand" for="c-41283002">[2 more]</label></div><br/><div class="children"><div class="content">The problem here is much more the unix wars and a lack of confidence in BSD under legal fire rather than a lack of ability. The principal concern of unix vendors of the early PC era was to maintain their market share in mini and mainframe product sectors rather than growth into the consumer market. This spurred a rewrite of BSD fragments tied to the legacy unix codebase which fully portablized C and the GCC downstream projects which ended up benefiting the weird hobby OS linux disproportionately, and had it not had to be written from scratch we may have ended up with a wonderful 286-BSD rather than a 486-BSD, which at the time was still not fully clean room foss and unburdened. This was a time when large customers of OS products were trying to squeeze all the performance juice out of the existing systems instead of looking at new paradigms. We have things like the full SAST and warn-free release of sunOS around this time, where Sun was focused on getting a rock stable platform to then optimize around rather than efforts to produce products for the emerging Micro market. We can see that the concept of a portable unix system and c library as early as Xenix on the Apple Lisa in 1984. That&#x27;s only 3 short years after the IBM collaboration for PC-DOS, showing even a rookie uncoordinated and low technical skill team such as microsoft (Paraphrasing Dave Cutler, chief NT kernel lead - Zachary, G. Pascal (2014). Showstopper!: The Breakneck Race to Create Windows NT and the Next Generation at Microsoft. Open Road Media. ISBN 978-1-4804-9484-8).</div><br/><div id="41283040" class="c"><input type="checkbox" id="c-41283040" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41283002">parent</a><span>|</span><a href="#41283752">next</a><span>|</span><label class="collapse" for="c-41283040">[-]</label><label class="expand" for="c-41283040">[1 more]</label></div><br/><div class="children"><div class="content">Xenix was my introduction to UNIX, I wouldn&#x27;t claim it would win any performance price, specially when considering graphics programming.<p>Also my first C book was &quot;A book on C&quot;, which had a type in listing for RatC dialect, like many others in those early 1980&#x27;s, which were nothing more than a plain macro assembler without opcodes, for all practical purposes.<p>Compiler optimizations in those 8 and 16 bit compilers were what someone nowadays would do in a introduction to compilers, as the bare minimum, like constant propagation and peephole optimizations.</div><br/></div></div></div></div><div id="41283752" class="c"><input type="checkbox" id="c-41283752" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41282795">parent</a><span>|</span><a href="#41283002">prev</a><span>|</span><a href="#41283436">next</a><span>|</span><label class="collapse" for="c-41283752">[-]</label><label class="expand" for="c-41283752">[4 more]</label></div><br/><div class="children"><div class="content">A fair amount of non-game Amiga scene, including the OS, was either BCPL or C.</div><br/><div id="41288311" class="c"><input type="checkbox" id="c-41288311" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41283752">parent</a><span>|</span><a href="#41283798">next</a><span>|</span><label class="collapse" for="c-41288311">[-]</label><label class="expand" for="c-41288311">[1 more]</label></div><br/><div class="children"><div class="content">&gt;BCPL<p>Was used by some parts of AmigaDOS (dos.library) and it is unfortunate.<p>AFAIK nothing third party uses BCPL.</div><br/></div></div><div id="41283798" class="c"><input type="checkbox" id="c-41283798" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41283752">parent</a><span>|</span><a href="#41288311">prev</a><span>|</span><a href="#41283436">next</a><span>|</span><label class="collapse" for="c-41283798">[-]</label><label class="expand" for="c-41283798">[2 more]</label></div><br/><div class="children"><div class="content">Sure, when performance didn&#x27;t matter.<p>Just like on MS-DOS side, I did plenty of stuff on Turbo BASIC, Turbo Pascal, Turbo C (quickly replaced by Turbo C++), and Clipper, until Windows 3.x and OS&#x2F;2 came to be.<p>Small utilities, or business applications, without big resources demands.</div><br/><div id="41286041" class="c"><input type="checkbox" id="c-41286041" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41283798">parent</a><span>|</span><a href="#41283436">next</a><span>|</span><label class="collapse" for="c-41286041">[-]</label><label class="expand" for="c-41286041">[1 more]</label></div><br/><div class="children"><div class="content">Or, where portability did matter.  That was still true much later...web servers were often mostly C, then inline ASM for the SSL parts.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41283436" class="c"><input type="checkbox" id="c-41283436" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#41281800">parent</a><span>|</span><a href="#41282196">prev</a><span>|</span><a href="#41287530">next</a><span>|</span><label class="collapse" for="c-41283436">[-]</label><label class="expand" for="c-41283436">[3 more]</label></div><br/><div class="children"><div class="content">As I experienced that era, C wasn&#x27;t really a practical language choice on 8-bit systems. Ok yes you could <i>get</i> a C compiler but it would typically need overlays hence be very slow. Assembler was pretty much where it was at on that generation of systems, or special-purpose languages such as BASIC and PL&#x2F;M.<p>C worked ok on a pdp-11&#x2F;45, but that had 256K of memory and 10s of MB of fixed disk. That level of hardware didn&#x27;t appear for micro systems until the 68k generation, or I suppose IBM PC, but I don&#x27;t remember the PC being too important in C coding circles until the 386, much later.</div><br/><div id="41284220" class="c"><input type="checkbox" id="c-41284220" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41283436">parent</a><span>|</span><a href="#41283772">next</a><span>|</span><label class="collapse" for="c-41284220">[-]</label><label class="expand" for="c-41284220">[1 more]</label></div><br/><div class="children"><div class="content">I did a lot of C programming on an IBM XT - 8088, 10mb hard disk, WordStar and DeSmet C. All worked very well.</div><br/></div></div><div id="41283772" class="c"><input type="checkbox" id="c-41283772" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41281800">root</a><span>|</span><a href="#41283436">parent</a><span>|</span><a href="#41284220">prev</a><span>|</span><a href="#41287530">next</a><span>|</span><label class="collapse" for="c-41283772">[-]</label><label class="expand" for="c-41283772">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that was indeed the case, while I did some C and C++ even on MS-DOS, it was Assembly, Turbo BASIC, Turbo Pascal and Clipper where I spent most of my time.<p>Even during my early days coding for Windows 3.x, I was doing Turbo Pascal for Windows, before eventually changing into Turbo C++ for Windows, as writing binding units for Win16 APIs, beyond what Borland provided, was getting tiresome, and both had OWL anyway.</div><br/></div></div></div></div><div id="41287530" class="c"><input type="checkbox" id="c-41287530" checked=""/><div class="controls bullet"><span class="by">jrdres</span><span>|</span><a href="#41281800">parent</a><span>|</span><a href="#41283436">prev</a><span>|</span><a href="#41286888">next</a><span>|</span><label class="collapse" for="c-41287530">[-]</label><label class="expand" for="c-41287530">[1 more]</label></div><br/><div class="children"><div class="content">As other commenters have said, C didn&#x27;t actually generate fast programs for 8-bit processors, or even 16-bit processors for a long time. C is a poor fit for most of them, so assembly language was the only way to go.<p>A contemporary source is the opinionated &quot;DTACK-Grounded&quot; newsletter from 1981-1985. <a href="http:&#x2F;&#x2F;www.easy68k.com&#x2F;paulrsm&#x2F;dg&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.easy68k.com&#x2F;paulrsm&#x2F;dg&#x2F;</a> Hal Hardenbergh raved about the fast 68000 chip and it&#x27;s wonderfully easy assembly, but lamented that everyone switched to &quot;portable&quot; Pascal and C to write 16-bit programs so they seemed even slower than 8-bit ones. His favorite example was a direct comparison: Lotus 1-2-3, written in 8088 assembly, vs Context MBA with the same features but written in Pascal for portability. 1-2-3 was MUCH faster than Context on the PC, and no one remembers Context today. Or the $16,000 Unix-based AT&amp;T workstation whose floating-point benchmarks are beaten by a $69 VIC-20. (Obviously due to the C-written runtime, which even followed the C standard of promoting all single precision calculations to double so single was no faster!)<p>His opinion of C was &quot;slightly-disguised PDP&#x2F;11 assembly&quot;. Not too bad for the 68000, but a terrible fit for the 8088 or Z80.</div><br/></div></div></div></div><div id="41286888" class="c"><input type="checkbox" id="c-41286888" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#41281800">prev</a><span>|</span><a href="#41284671">next</a><span>|</span><label class="collapse" for="c-41286888">[-]</label><label class="expand" for="c-41286888">[1 more]</label></div><br/><div class="children"><div class="content">I remember using Aztec after using Software Toolworks C for a a few years. It was incredibly advanced in terms of standard C at the time. It was the first time I could just type code from the &quot;C Programming Language&quot; in and it would work unchanged.</div><br/></div></div><div id="41284671" class="c"><input type="checkbox" id="c-41284671" checked=""/><div class="controls bullet"><span class="by">nj5rq</span><span>|</span><a href="#41286888">prev</a><span>|</span><a href="#41281973">next</a><span>|</span><label class="collapse" for="c-41284671">[-]</label><label class="expand" for="c-41284671">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the first time I ever see the function parameters declared like this:<p><pre><code>    int my_function (a, b)
    int a; char *b;
      {
      ... body of function ...
      }
</code></pre>
What do you even call this?</div><br/><div id="41284690" class="c"><input type="checkbox" id="c-41284690" checked=""/><div class="controls bullet"><span class="by">omerhj</span><span>|</span><a href="#41284671">parent</a><span>|</span><a href="#41281973">next</a><span>|</span><label class="collapse" for="c-41284690">[-]</label><label class="expand" for="c-41284690">[1 more]</label></div><br/><div class="children"><div class="content">K&amp;R C</div><br/></div></div></div></div><div id="41281973" class="c"><input type="checkbox" id="c-41281973" checked=""/><div class="controls bullet"><span class="by">ghuysmans</span><span>|</span><a href="#41284671">prev</a><span>|</span><a href="#41283349">next</a><span>|</span><label class="collapse" for="c-41281973">[-]</label><label class="expand" for="c-41281973">[3 more]</label></div><br/><div class="children"><div class="content">Nice article, thanks!<p>Minor nitpick: PUN is not a device in Windows 11 (I haven&#x27;t tested on previous versions).
&gt; echo hello&gt;pun:
&gt; type pun
hello<p>In the section about paging, are there actual systems working in the megabyte range?</div><br/><div id="41282154" class="c"><input type="checkbox" id="c-41282154" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41281973">parent</a><span>|</span><a href="#41282594">next</a><span>|</span><label class="collapse" for="c-41282154">[-]</label><label class="expand" for="c-41282154">[1 more]</label></div><br/><div class="children"><div class="content">PUN wasn’t even in MS-DOS. However, later versions of CP&#x2F;M used AUX instead of PUN, which DOS adopted and still exists in Windows.</div><br/></div></div><div id="41282594" class="c"><input type="checkbox" id="c-41282594" checked=""/><div class="controls bullet"><span class="by">anonymousiam</span><span>|</span><a href="#41281973">parent</a><span>|</span><a href="#41282154">prev</a><span>|</span><a href="#41283349">next</a><span>|</span><label class="collapse" for="c-41282594">[-]</label><label class="expand" for="c-41282594">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a lot of years, but as I recall, the raw I&#x2F;O devices had one set of names, and the logical devices had another.  So things like STAT PUN:=PTP: (if I remembered the syntax correctly) would set the logical &quot;punch&quot; device to be the physical paper tape punch, which was the default.  I may also be confusing CP&#x2F;M I&#x2F;O redirection syntax (which only worked if your BIOS supported it), with DEC RT-11 syntax.  It has been over 40 years since I have used either one.</div><br/></div></div></div></div><div id="41283349" class="c"><input type="checkbox" id="c-41283349" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41281973">prev</a><span>|</span><a href="#41282019">next</a><span>|</span><label class="collapse" for="c-41283349">[-]</label><label class="expand" for="c-41283349">[2 more]</label></div><br/><div class="children"><div class="content">minor 1000× error: &#x27;CP&#x2F;M systems rarely had more than 64Mb of RAM&#x27; should read &#x27;CP&#x2F;M systems rarely had more than 64 kibibytes of RAM&#x27; (because memory addresses were 16 bits and there wasn&#x27;t much demand for bank-switching in cp&#x2F;m&#x27;s heyday, though later 8-bit machines like the nes and the msx did use bank-switching extensively)<p>(disclaimer, i never programmed in c on cp&#x2F;m, and although i used to use cp&#x2F;m daily, i haven&#x27;t used it for about 35 years)<p>he&#x27;s using aztec c, but anyone who&#x27;s considering this needs to know that aztec c isn&#x27;t under a free-software license.  bds c is a properly open-source alternative which seemed to be more popular at the time (though it wasn&#x27;t open source then)<p><a href="https:&#x2F;&#x2F;www.aztecmuseum.ca&#x2F;docs&#x2F;az80106d.txt" rel="nofollow">https:&#x2F;&#x2F;www.aztecmuseum.ca&#x2F;docs&#x2F;az80106d.txt</a> says<p>&gt; <i>This compiler is both the MS-DOS cross-compiler and the native mode CP&#x2F;M
80 Aztec CZ80 Version 1.06d (C) Copyright Manx Software Systems, Inc. and
also includes the earlier Aztec CZ80 Version 1.05 for native mode CP&#x2F;M 80.
I cannot provide you with a legally licenced copy.</i><p>&gt; <i>I herewith grant you a non-exclusive conditional licence to use any and
all of my work included with this compiler for whatever use you deem fit,
provided you do not take credit for my work, and that you leave my
copyright notices intact in all of it.</i><p>&gt; <i>I believe everything I have written to be correct. Regardless, I, Bill
Buckels...</i><p>but <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aztec_C" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aztec_C</a> explains that manx software &#x27;was started by Harry Suckow, with partners Thomas Fenwick, and James Goodnow II, the two principal developers (...) Suckow is still the copyright holder for Aztec C.&#x27;<p>so it&#x27;s not just that the source code has been lost; the licensing situation is basically &#x27;don&#x27;t ask, don&#x27;t tell&#x27;<p>bds c comes with some integration with an open-source (?) cp&#x2F;m text editor whose name i forget, so you can quickly jump to compiler errors even though you don&#x27;t have enough ram to have both the compiler and the editor in memory at once.  other ides for cp&#x2F;m such as turbo pascal and the f83 forth system do manage this.  f83 also has multithreading, virtual memory, and &#x27;go to definition&#x27; but it&#x27;s even more untyped than k&amp;r c<p>bds c is not quite a subset of k&amp;r c, and i doubt boone&#x27;s claim that aztec c is a strict subset of k&amp;r c as implemented by gcc<p>sdcc is another free-software compiler that can generate z80 code <a href="https:&#x2F;&#x2F;sdcc.sourceforge.net&#x2F;doc&#x2F;sdccman.pdf#subsection.3.3.8" rel="nofollow">https:&#x2F;&#x2F;sdcc.sourceforge.net&#x2F;doc&#x2F;sdccman.pdf#subsection.3.3....</a> but it can&#x27;t run on a z80 itself; it&#x27;s purely a cross-compiler<p>a thing that might not be apparent if you&#x27;re using a modernized system is how constraining floppy disks are.  the data transfer rate was about 2 kilobytes per second, the drive was obtrusively loud, and the total disk capacity was typically 90 kilobytes (up to over a megabyte for some 8-inchers).  this means that if a person needed data from the disk, such as wordstar&#x27;s printing overlay, you had to request it and then wait for the disk to find it.  so it wasn&#x27;t a good idea to do this for no user-apparent reason<p>with respect to<p><pre><code>  int elems[5][300];
  ...
  int i, j;
  for (i = 0; i &lt; m; i++)
    {
    for (j = 0; j &lt; n; j++)
      {
      int elem = elems[i][j];
      ... process the value ...
      }
    }
</code></pre>
if i wanted efficiency on a compiler that didn&#x27;t do the strength-reduction for me, i would write it as<p><pre><code>  int elems[5][300];
  ...
  int i, *p, *end, elem;
  for (i = 0; i &lt; m; i++) {
    end = elems[i+1];
    for (p = elems[i]; p != end; p++) {
      elem = *p;
      ... process the value ...
    }
  }
</code></pre>
this avoids any multiplications in the inner loop while obscuring the structure of the program less than boone&#x27;s version<p>cp&#x2F;m machines are interesting to me as being a good approximation of the weakest computers on which self-hosted development is tolerable.  as boone points out, you don&#x27;t have valgrind, you don&#x27;t have type-checking for subroutine arguments (in k&amp;r c; you do in pascal), the cpu is slow, the fcb interface is bletcherous, and, as i said, floppy disks are very limited; but the machine is big enough and fast enough to support high-level languages, a filesystem, and full-screen tuis like wordstar, supercalc, turbo pascal, the ucsd p-system, etc.<p>(second disclaimer: i say &#x27;tolerable&#x27; but i also wrote a c program in ed on my cellphone last night; your liver may vary)<p>on the other hand, if you want to develop on a (logically) small computer, there are many interesting logically small computers available today, including the popular and easy-to-use atmega328p; the astounding rp2350; the popular and astonishing arm stm32f103c8t6 (and its improved chinese clones such as the gd32f103); the ultra-low-power ambiq apollo3; the 1.5¢ cy8c4045fni-ds400t, a 48-megahertz arm with 32 kibibytes of flash and 4 kibibytes of sram; and the tiny and simple 1.8¢ pic12f-like ny8a051h.  the avr and arm instruction sets are much nicer than the z80 (though the ny8a051h isn&#x27;t), and the hardware is vastly cheaper, lower power, physically smaller, and faster.  and flash memory is also vastly cheaper, lower power, physically smaller, and faster than a floppy disk</div><br/><div id="41288013" class="c"><input type="checkbox" id="c-41288013" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#41283349">parent</a><span>|</span><a href="#41282019">next</a><span>|</span><label class="collapse" for="c-41288013">[-]</label><label class="expand" for="c-41288013">[1 more]</label></div><br/><div class="children"><div class="content">F83 is an astonishing system. If you want to see the remnants of just a boatload of work, dig deep into the F83 system.<p>F83 is a top drawer Forth system. It implements the Forth 83 standard, and it’s in the public domain.<p>It runs on CP&#x2F;M and MS-DOS.<p>It has the editor, a single step debugger, virtual memory, multi tasking, an assembler, full source code, and it is self hosting (on top of its host OS) via its meta-compiler. But you could readily port it to a system with no real OS, needing little more than console I&#x2F;O and some kind of block device.<p>It’s a hybrid block file based system. Historically you would just hand entire block volumes that would then be managed by Forth directly. Here, you create pre-allocated files that are then used in a customary Forth block style. It did not use text files for source code. It also has shadow screens for documentation. Shadow screens are where you divide the block volume in two, and the first half is source code, and the second is documentation. So if you have a 200 block volume, then screen 4 is code and screen 104 is documentation.<p>If you want to see the source code of a word, just type VIEW &lt;word&gt; and it will show you the screen that defines the word. The compiler embeds the source screen in each definition. A simple command will bring up the shadow screen to show the documentation.<p>It also has a word decompiler, and a threaded dictionary for better search performance. It has hundreds of words.<p>The real trick is imagining the work that went into this system. The bootstrapping process that converted this from a likely hand keyed, assembly based FIG Forth to what became F83. Starting with a pure, block screen based system to one that works with a file system, shifting code around on disk with little more than offsets and a copy routine that’s little more than a block move.<p>On a slow, 2 floppy 8080, where resetting the system was the routine way to get back to a known state. Using a powerful, yet very dangerous language, rife with traps. It’s like doing self surgery with a mirror.<p>The holes they must have blasted in the floor trying to avoid shooting themselves in the foot. Repeatedly. I’ve spent hundreds of hours studying this system, it’s really an amazing effort.</div><br/></div></div></div></div><div id="41282905" class="c"><input type="checkbox" id="c-41282905" checked=""/><div class="controls bullet"><span class="by">kelsey98765431</span><span>|</span><a href="#41282019">prev</a><span>|</span><a href="#41281753">next</a><span>|</span><label class="collapse" for="c-41282905">[-]</label><label class="expand" for="c-41282905">[1 more]</label></div><br/><div class="children"><div class="content">RIP Gary, you had so much more to give.<p>My next whiskey will be in your honor my man.<p>See you space cowboy</div><br/></div></div><div id="41281753" class="c"><input type="checkbox" id="c-41281753" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#41282905">prev</a><span>|</span><a href="#41287247">next</a><span>|</span><label class="collapse" for="c-41281753">[-]</label><label class="expand" for="c-41281753">[9 more]</label></div><br/><div class="children"><div class="content">Interesting; but why actually C and not PL&#x2F;M?</div><br/><div id="41282730" class="c"><input type="checkbox" id="c-41282730" checked=""/><div class="controls bullet"><span class="by">guestbest</span><span>|</span><a href="#41281753">parent</a><span>|</span><a href="#41281813">next</a><span>|</span><label class="collapse" for="c-41282730">[-]</label><label class="expand" for="c-41282730">[1 more]</label></div><br/><div class="children"><div class="content">PL&#x2F;M is a less transferable skill and a ‘dead’ language. I think Gary Kildall promotes PL&#x2F;M but honestly C is the best for portability and popularity followed by Forth and Pascal.</div><br/></div></div><div id="41281813" class="c"><input type="checkbox" id="c-41281813" checked=""/><div class="controls bullet"><span class="by">katzinsky</span><span>|</span><a href="#41281753">parent</a><span>|</span><a href="#41282730">prev</a><span>|</span><a href="#41287247">next</a><span>|</span><label class="collapse" for="c-41281813">[-]</label><label class="expand" for="c-41281813">[7 more]</label></div><br/><div class="children"><div class="content">Yeah C does not work well on these odd 8-bit ISAs. Pascal, basic, and PL&#x2F;M (and fortran?) seem to have been way more common and Pascal environments on these were really on the edge of what the contemporary hardware could handle.</div><br/><div id="41282438" class="c"><input type="checkbox" id="c-41282438" checked=""/><div class="controls bullet"><span class="by">flyinghamster</span><span>|</span><a href="#41281753">root</a><span>|</span><a href="#41281813">parent</a><span>|</span><a href="#41282348">next</a><span>|</span><label class="collapse" for="c-41282438">[-]</label><label class="expand" for="c-41282438">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t ever recall seeing PL&#x2F;M compilers advertised by anyone back in the day. I have a feeling that the few that existed were offered at &quot;meet our sales guy at the golf course&quot; pricing.</div><br/><div id="41287493" class="c"><input type="checkbox" id="c-41287493" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#41281753">root</a><span>|</span><a href="#41282438">parent</a><span>|</span><a href="#41282348">next</a><span>|</span><label class="collapse" for="c-41287493">[-]</label><label class="expand" for="c-41287493">[1 more]</label></div><br/><div class="children"><div class="content">PL&#x2F;M was developed by Gary Kildall for Intel, and the only compilers I&#x27;ve used ran under Intel&#x27;s ISIS family of operating systems, originally on Intel Intellec MDS hardware, and only much later under first-party ISIS emulation on MS-DOS.<p>AFAIK, Intel never marketed its first-party development systems to hobbyists, so you&#x27;re probably in the ballpark with &quot;golf course&quot; pricing.</div><br/></div></div></div></div><div id="41282348" class="c"><input type="checkbox" id="c-41282348" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41281753">root</a><span>|</span><a href="#41281813">parent</a><span>|</span><a href="#41282438">prev</a><span>|</span><a href="#41287247">next</a><span>|</span><label class="collapse" for="c-41282348">[-]</label><label class="expand" for="c-41282348">[4 more]</label></div><br/><div class="children"><div class="content">My take it was the other away around. In its own strange way C was portable to machines with unusual word sizes like the DEC PDP-10 with 36 bit words.  I used C on Z-80 on CP&#x2F;M and on the 6809 with Microware’s OS-9.<p>In the 1980s there were books on FORTRAN, COBOL and PASCAL.  I know compilers for the first two existed for micros but I never saw them,  these were mainly on minicomputers and mainframes and I didn’t touch them until I was using 32-bit machines in college<p>There were academics who saw the popularity of BASIC as a crisis and unsuccessfully tried to push alternatives like PASCAL and LOGO, the first of which was an unmitigated disaster because ISO Pascal gave you only what you need to work leetcode problems,  even BASIC was better for “systems programming” because at least you had PEEK and POKE though neither language would let you hook interrupts.<p>Early PASCALs for micros were also based on the atrociously slow UCSD Pascal.  Towards the end of the 1980s there was the excellent Turbo Pascal for the 8086 that did what NiklausWirthDont and I thought was better than C but I switched to C because it portable to 32-but machines.<p>I’d also contrast chips like the Z-80 and 6809 which had enough registers and address modes to compile code for and others like the 6502 where you are likely to resort to virtual machine techniques right away,  see<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SWEET16" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SWEET16</a><p>I saw plenty of spammy books on microcomputers in the late 1970s and early 1980s that seemed to copy press releases from vendors and many of these said a lot about PL&#x2F;M being a big deal although I never saw a compiler, source code, or knew anybody who coded it.</div><br/><div id="41282452" class="c"><input type="checkbox" id="c-41282452" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#41281753">root</a><span>|</span><a href="#41282348">parent</a><span>|</span><a href="#41282846">next</a><span>|</span><label class="collapse" for="c-41282452">[-]</label><label class="expand" for="c-41282452">[2 more]</label></div><br/><div class="children"><div class="content"><i>Towards the end of the 1980s there was the excellent Turbo Pascal for the 8086</i><p>TurboPascal was released at the tail end of 1983 targeting CP&#x2F;M and the Z80. It was hugely popular on the platform.</div><br/><div id="41283104" class="c"><input type="checkbox" id="c-41283104" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41281753">root</a><span>|</span><a href="#41282452">parent</a><span>|</span><a href="#41282846">next</a><span>|</span><label class="collapse" for="c-41283104">[-]</label><label class="expand" for="c-41283104">[1 more]</label></div><br/><div class="children"><div class="content">Correct.<p>My own experience in Turbo Pascal started with (I think) version 4 when I got an 80286 machine in 1987.  In that time frame Borland was coming out with a new version every year that radically improved the language,  it got OO functionality in 5.5, inline assembly in 6, etc.  I remember replacing many of the stdlib functions such as move and copy w&#x2F; ones that were twice as fast because the used 16 bit instructions that were faster on the 80286.  With the IDE and interactive debugger it was one my favorite programming environments ever.</div><br/></div></div></div></div><div id="41282846" class="c"><input type="checkbox" id="c-41282846" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41281753">root</a><span>|</span><a href="#41282348">parent</a><span>|</span><a href="#41282452">prev</a><span>|</span><a href="#41287247">next</a><span>|</span><label class="collapse" for="c-41282846">[-]</label><label class="expand" for="c-41282846">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft had FORTRAN and COBOL compilers for CP&#x2F;M. I have used them on both Intel 8080 and Zilog Z80.<p>The MS FORTRAN compiler was decent enough. It could be used to make programs that were much faster than those using the Microsoft BASIC interpreter.<p>Even if you preferred to write some program in assembly, if that program needed to do some numeric computations it was convenient to use the MS Fortran run-time library, which contained most of the Fortran implementation work, because the Fortran compiler generated machine code which consisted mostly of invocations of the functions from the run-time library.<p>However, for that you had to reverse-engineer the library first, because it was not documented by Microsoft. Nevertheless, reverse-engineering CP&#x2F;M applications was very easy, because an experienced programmer could read a hexadecimal dump almost as easy as the assembly language source code. Microsoft used a few code obfuscation tricks, but those could not be very effective in such small programs.</div><br/></div></div></div></div></div></div></div></div><div id="41287247" class="c"><input type="checkbox" id="c-41287247" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#41281753">prev</a><span>|</span><a href="#41282685">next</a><span>|</span><label class="collapse" for="c-41287247">[-]</label><label class="expand" for="c-41287247">[1 more]</label></div><br/><div class="children"><div class="content">I think the author has a typo:<p>&quot;CP&#x2F;M systems rarely had more than 64Mb of RAM&quot;<p>This probably was intended as 64Kb of RAM.<p>Great piece.  I found it interesting.  Nice work.</div><br/></div></div><div id="41282685" class="c"><input type="checkbox" id="c-41282685" checked=""/><div class="controls bullet"><span class="by">jacknews</span><span>|</span><a href="#41287247">prev</a><span>|</span><label class="collapse" for="c-41282685">[-]</label><label class="expand" for="c-41282685">[2 more]</label></div><br/><div class="children"><div class="content">I would be more interested to see how modern techniques could improve the then-state of the art.<p>A lot of the modern stack is layers of abstraction, which probably wouldn&#x27;t be appropriate for such limited machines, but maybe superoptimizers and so on, and just more modern algorithms, etc, could help show what&#x27;s really possible on these old machines. Sort of retro demoscene, but for useful apps.</div><br/><div id="41284799" class="c"><input type="checkbox" id="c-41284799" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41282685">parent</a><span>|</span><label class="collapse" for="c-41284799">[-]</label><label class="expand" for="c-41284799">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure this: <a href="https:&#x2F;&#x2F;ourworldindata.org&#x2F;grapher&#x2F;historical-cost-of-computer-memory-and-storage">https:&#x2F;&#x2F;ourworldindata.org&#x2F;grapher&#x2F;historical-cost-of-comput...</a> has had way more to do with changes in the way we program than anything we&#x27;ve learned about modern techniques.</div><br/></div></div></div></div></div></div></div></div></div></body></html>