<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715936463905" as="style"/><link rel="stylesheet" href="styles.css?v=1715936463905"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantamagazine.org/computer-scientists-invent-an-efficient-new-way-to-count-20240516/">Computer scientists invent an efficient new way to count</a> <span class="domain">(<a href="https://www.quantamagazine.org">www.quantamagazine.org</a>)</span></div><div class="subtext"><span>jasondavies</span> | <span>37 comments</span></div><br/><div><div id="40387154" class="c"><input type="checkbox" id="c-40387154" checked=""/><div class="controls bullet"><span class="by">pixelmonkey</span><span>|</span><a href="#40387508">next</a><span>|</span><label class="collapse" for="c-40387154">[-]</label><label class="expand" for="c-40387154">[2 more]</label></div><br/><div class="children"><div class="content">This algorithm seems to resemble HyperLogLog (and all its variants), which is also cited in the research paper. Using the same insight of the estimation value of tracking whether we&#x27;ve hit a &quot;run&quot; of heads or tails, but flipping the idea on its head (heh), it leads to the simpler algorithm described, which is about discarding memorized values on the basis of runs of heads&#x2F;tails.<p>This also works especially well (that is, efficiently) in the streaming case, allowing you to keep something resembling a &quot;counter&quot; for the distinct elements, albeit with a error rate.<p>The benefit of HyperLogLog is that it behaves similarly to a hash set in some respects -- you can add items, count distinct them, and, importantly, merge two HLLs together (union), all the while keeping memory fixed to mere kilobytes even for billion-item sets. In distributed data stores, this is the trick behind Elasticsearch&#x2F;OpenSearch cardinality agg, as well as behind Redis&#x2F;Redict with its PFADD&#x2F;PFMERGE&#x2F;PFCOUNT.<p>I am not exactly sure how this CVM algorithm compares to HLL, but they got Knuth to review it, and they claim an undergrad can implement it easily, so it must be pretty good!</div><br/><div id="40387614" class="c"><input type="checkbox" id="c-40387614" checked=""/><div class="controls bullet"><span class="by">hmottestad</span><span>|</span><a href="#40387154">parent</a><span>|</span><a href="#40387508">next</a><span>|</span><label class="collapse" for="c-40387614">[-]</label><label class="expand" for="c-40387614">[1 more]</label></div><br/><div class="children"><div class="content">It’s also possible to use HLL to estimate the cardinality of joins since it’s possible to estimate both the union and the intersection of two HLLs.<p><a href="http:&#x2F;&#x2F;oertl.github.io&#x2F;hyperloglog-sketch-estimation-paper&#x2F;" rel="nofollow">http:&#x2F;&#x2F;oertl.github.io&#x2F;hyperloglog-sketch-estimation-paper&#x2F;</a></div><br/></div></div></div></div><div id="40387508" class="c"><input type="checkbox" id="c-40387508" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#40387154">prev</a><span>|</span><a href="#40387827">next</a><span>|</span><label class="collapse" for="c-40387508">[-]</label><label class="expand" for="c-40387508">[3 more]</label></div><br/><div class="children"><div class="content">I found the paper took about as long to read as the blog post and is more informative:<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2301.10191" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2301.10191</a><p>It is about estimating the cardinality of a set of elements derived from a stream. The algorithm is so simple, you can code it and play with it whilst you read the paper.<p>The authors are explicit about the target audience and purpose for the algorithm: undergraduates and textbooks.</div><br/><div id="40387733" class="c"><input type="checkbox" id="c-40387733" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#40387508">parent</a><span>|</span><a href="#40387827">next</a><span>|</span><label class="collapse" for="c-40387733">[-]</label><label class="expand" for="c-40387733">[2 more]</label></div><br/><div class="children"><div class="content">If you refer to the subtitle of the paper - <i>An Algorithm for the (Text) Book</i> - I think that is actually a reference to something Knuth allegedly said about some algorithms are so elegant in their simplicity and beauty that they are &quot;from The Book&quot;, like representing some divine Platonic ideal.<p>Given that Knuth himself reviewed it, he might have remarked that this was one of those algorithms! Perhaps the authors decided to include it in the title as a not-so-humble brag (which would be well-earned if that&#x27;s the case!)</div><br/><div id="40387815" class="c"><input type="checkbox" id="c-40387815" checked=""/><div class="controls bullet"><span class="by">kibibu</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40387733">parent</a><span>|</span><a href="#40387827">next</a><span>|</span><label class="collapse" for="c-40387815">[-]</label><label class="expand" for="c-40387815">[1 more]</label></div><br/><div class="children"><div class="content">I thought The Book was an Erdos thing. I wonder who used it first.</div><br/></div></div></div></div></div></div><div id="40387827" class="c"><input type="checkbox" id="c-40387827" checked=""/><div class="controls bullet"><span class="by">kromem</span><span>|</span><a href="#40387508">prev</a><span>|</span><a href="#40387291">next</a><span>|</span><label class="collapse" for="c-40387827">[-]</label><label class="expand" for="c-40387827">[1 more]</label></div><br/><div class="children"><div class="content">Ah, so Thanos was just conducting a census.</div><br/></div></div><div id="40387291" class="c"><input type="checkbox" id="c-40387291" checked=""/><div class="controls bullet"><span class="by">akamoonknight</span><span>|</span><a href="#40387827">prev</a><span>|</span><a href="#40387548">next</a><span>|</span><label class="collapse" for="c-40387291">[-]</label><label class="expand" for="c-40387291">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know a word or phrase for this, but I really enjoy any examples of &quot;thinking outside the box&quot; like this because it&#x27;s something I struggle with in my professional career. Learning not only the right ways to solve problems, but figuring out the questions to ask that make solving the problems you have easier or even in some cases possible. In this case, it&#x27;s hey, we don&#x27;t need  exact numbers if we can define a probabilistic range given defined parameters. Other problems are gonna have other questions. I guess my hope is that if I see enough examples I&#x27;ll be able to eventually internalize the thought process and apply it correctly.</div><br/><div id="40387378" class="c"><input type="checkbox" id="c-40387378" checked=""/><div class="controls bullet"><span class="by">wmwragg</span><span>|</span><a href="#40387291">parent</a><span>|</span><a href="#40387548">next</a><span>|</span><label class="collapse" for="c-40387378">[-]</label><label class="expand" for="c-40387378">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s generally thought of as &quot;lateral thinking&quot;, Edward de Bono has written a few books about it you might find interesting.</div><br/></div></div></div></div><div id="40387548" class="c"><input type="checkbox" id="c-40387548" checked=""/><div class="controls bullet"><span class="by">melq</span><span>|</span><a href="#40387291">prev</a><span>|</span><a href="#40387704">next</a><span>|</span><label class="collapse" for="c-40387548">[-]</label><label class="expand" for="c-40387548">[3 more]</label></div><br/><div class="children"><div class="content">Estimating the amount of unique elements in a set and counting the amount of unique elements in a set are very different things. Cool method, bad headline.</div><br/><div id="40387753" class="c"><input type="checkbox" id="c-40387753" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#40387548">parent</a><span>|</span><a href="#40387704">next</a><span>|</span><label class="collapse" for="c-40387753">[-]</label><label class="expand" for="c-40387753">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an approximation, not an estimation.</div><br/><div id="40387789" class="c"><input type="checkbox" id="c-40387789" checked=""/><div class="controls bullet"><span class="by">ranguna</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40387753">parent</a><span>|</span><a href="#40387704">next</a><span>|</span><label class="collapse" for="c-40387789">[-]</label><label class="expand" for="c-40387789">[1 more]</label></div><br/><div class="children"><div class="content">Still very different things, no?</div><br/></div></div></div></div></div></div><div id="40387704" class="c"><input type="checkbox" id="c-40387704" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#40387548">prev</a><span>|</span><a href="#40387212">next</a><span>|</span><label class="collapse" for="c-40387704">[-]</label><label class="expand" for="c-40387704">[1 more]</label></div><br/><div class="children"><div class="content">HyperLogLog uses additions, it keeps sums. Thus, you can subtract one HLL sums from other. This is useful if stream supports deletion. Streams with deletions can be found in log-structured merge trees, for one example, so one can estimate count of distinct elements in all of the LSM tree hierarchy.<p>The algorithm in the paper does not allow for deletions.<p>Also, if one counts statistics of the stream of large elements (say, SHA-512 hashes, 64 bytes per hash), this algorithm requires some storage for elements from this stream, so memory requirement is O(table size * element size).</div><br/></div></div><div id="40387212" class="c"><input type="checkbox" id="c-40387212" checked=""/><div class="controls bullet"><span class="by">imoverclocked</span><span>|</span><a href="#40387704">prev</a><span>|</span><a href="#40387402">next</a><span>|</span><label class="collapse" for="c-40387212">[-]</label><label class="expand" for="c-40387212">[8 more]</label></div><br/><div class="children"><div class="content">When do we stop calling this counting and start calling it estimation?</div><br/><div id="40387490" class="c"><input type="checkbox" id="c-40387490" checked=""/><div class="controls bullet"><span class="by">card_zero</span><span>|</span><a href="#40387212">parent</a><span>|</span><a href="#40387272">next</a><span>|</span><label class="collapse" for="c-40387490">[-]</label><label class="expand" for="c-40387490">[2 more]</label></div><br/><div class="children"><div class="content">Seems this is one of those things like UUIDs where we rely on it being very unlikely to be wrong, because statistics.<p>&gt; the accuracy of this technique scales with the size of the memory.<p>I wonder if that&#x27;s proportional to the number of distinct items to count, though.<p>&gt; if the [memory] is so big that it fits all the words, then we can get 100% accuracy<p>Yes, but then the algorithm isn&#x27;t being used any more, that&#x27;s just normal counting.<p>They counted the distinct words in Hamlet with a memory size of 100 words, about 2.5% of the number to find, and got a result that was off by 2. If you do the same with the whole of Shakespeare, again using 2.5% of the memory needed to hold all the distinct words, is the accuracy better?<p>Anyway, this is limited to counting, and doesn&#x27;t help list what the words <i>are,</i> though quickly counting them first is perhaps a way to speed up the task of actually finding them?</div><br/></div></div><div id="40387272" class="c"><input type="checkbox" id="c-40387272" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40387212">parent</a><span>|</span><a href="#40387490">prev</a><span>|</span><a href="#40387264">next</a><span>|</span><label class="collapse" for="c-40387272">[-]</label><label class="expand" for="c-40387272">[4 more]</label></div><br/><div class="children"><div class="content">As soon as people start reading past the headline.</div><br/><div id="40387330" class="c"><input type="checkbox" id="c-40387330" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387272">parent</a><span>|</span><a href="#40387264">next</a><span>|</span><label class="collapse" for="c-40387330">[-]</label><label class="expand" for="c-40387330">[3 more]</label></div><br/><div class="children"><div class="content">tbh, the title (and introduction) did a lot to dissuade me from finishing the (really good) article. It was actually informative, why dress it as a SEO blogspam?</div><br/><div id="40387426" class="c"><input type="checkbox" id="c-40387426" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387330">parent</a><span>|</span><a href="#40387449">next</a><span>|</span><label class="collapse" for="c-40387426">[-]</label><label class="expand" for="c-40387426">[1 more]</label></div><br/><div class="children"><div class="content">Presumably so it is optimised for search engines and people find it.<p>Publishers generally have good data about where their audience comes from. They wouldn&#x27;t do this if it wasn&#x27;t the best way they know of to maximise readership.</div><br/></div></div><div id="40387449" class="c"><input type="checkbox" id="c-40387449" checked=""/><div class="controls bullet"><span class="by">HDThoreaun</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387330">parent</a><span>|</span><a href="#40387426">prev</a><span>|</span><a href="#40387264">next</a><span>|</span><label class="collapse" for="c-40387449">[-]</label><label class="expand" for="c-40387449">[1 more]</label></div><br/><div class="children"><div class="content">So they can get paid for their work? Are you giving them anything?</div><br/></div></div></div></div></div></div><div id="40387264" class="c"><input type="checkbox" id="c-40387264" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#40387212">parent</a><span>|</span><a href="#40387272">prev</a><span>|</span><a href="#40387402">next</a><span>|</span><label class="collapse" for="c-40387264">[-]</label><label class="expand" for="c-40387264">[1 more]</label></div><br/><div class="children"><div class="content">Yes, even the subtile states &quot;a simple algorithm for estimating large numbers of distinct objects&quot;.</div><br/></div></div></div></div><div id="40387402" class="c"><input type="checkbox" id="c-40387402" checked=""/><div class="controls bullet"><span class="by">saulrh</span><span>|</span><a href="#40387212">prev</a><span>|</span><a href="#40387546">next</a><span>|</span><label class="collapse" for="c-40387402">[-]</label><label class="expand" for="c-40387402">[1 more]</label></div><br/><div class="children"><div class="content">Huh, that&#x27;s a clever twist on reservoir sampling. Neat.</div><br/></div></div><div id="40387546" class="c"><input type="checkbox" id="c-40387546" checked=""/><div class="controls bullet"><span class="by">hum3hum3</span><span>|</span><a href="#40387402">prev</a><span>|</span><a href="#40387395">next</a><span>|</span><label class="collapse" for="c-40387546">[-]</label><label class="expand" for="c-40387546">[1 more]</label></div><br/><div class="children"><div class="content">The counting&#x2F;estimstion technique is rather like a floating point number.  An integer exponent k and a mantissa of a population.</div><br/></div></div><div id="40387395" class="c"><input type="checkbox" id="c-40387395" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40387546">prev</a><span>|</span><a href="#40387280">next</a><span>|</span><label class="collapse" for="c-40387395">[-]</label><label class="expand" for="c-40387395">[5 more]</label></div><br/><div class="children"><div class="content">After skimming Knuth&#x27;s paper — does the algorithm work if values are hashed, that is, the &quot;uniform deviate&quot; is selected deterministically for each unique value of the stream?</div><br/><div id="40387651" class="c"><input type="checkbox" id="c-40387651" checked=""/><div class="controls bullet"><span class="by">devnonymous</span><span>|</span><a href="#40387395">parent</a><span>|</span><a href="#40387280">next</a><span>|</span><label class="collapse" for="c-40387651">[-]</label><label class="expand" for="c-40387651">[4 more]</label></div><br/><div class="children"><div class="content">Not sure which Knuth paper you&#x27;re referring to but skimming through the article my understanding is this algorithm works &#x2F;only&#x2F; if the values are hashable. IOW how else does one define unique&#x2F;distinct values ?</div><br/><div id="40387751" class="c"><input type="checkbox" id="c-40387751" checked=""/><div class="controls bullet"><span class="by">hcs</span><span>|</span><a href="#40387395">root</a><span>|</span><a href="#40387651">parent</a><span>|</span><a href="#40387743">next</a><span>|</span><label class="collapse" for="c-40387751">[-]</label><label class="expand" for="c-40387751">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf" rel="nofollow">https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf</a><p>Looks like it was posted at the time <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36079213">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36079213</a> but not much discussed. I found it over here <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40387594">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40387594</a></div><br/></div></div><div id="40387743" class="c"><input type="checkbox" id="c-40387743" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40387395">root</a><span>|</span><a href="#40387651">parent</a><span>|</span><a href="#40387751">prev</a><span>|</span><a href="#40387280">next</a><span>|</span><label class="collapse" for="c-40387743">[-]</label><label class="expand" for="c-40387743">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf" rel="nofollow">https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf</a><p>note how &quot;u&quot;s are selected every time value is not in a list. I don&#x27;t read it as being a hash.</div><br/><div id="40387806" class="c"><input type="checkbox" id="c-40387806" checked=""/><div class="controls bullet"><span class="by">hcs</span><span>|</span><a href="#40387395">root</a><span>|</span><a href="#40387743">parent</a><span>|</span><a href="#40387280">next</a><span>|</span><label class="collapse" for="c-40387806">[-]</label><label class="expand" for="c-40387806">[1 more]</label></div><br/><div class="children"><div class="content">I think the analysis relies on independent random &quot;u&quot;s, even for the same key.</div><br/></div></div></div></div></div></div></div></div><div id="40387280" class="c"><input type="checkbox" id="c-40387280" checked=""/><div class="controls bullet"><span class="by">biscuit1v9</span><span>|</span><a href="#40387395">prev</a><span>|</span><a href="#40387594">next</a><span>|</span><label class="collapse" for="c-40387280">[-]</label><label class="expand" for="c-40387280">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The trick, he said, is to rely on randomization.<p>&gt; When the space is full, press pause and flip a coin for each word. Heads, and the word stays on the list; tails, and you delete it.<p>I wasn&#x27;t expecting to go that far: randomization. How can you verify if the answer is good? Only approximation, maybe..</div><br/><div id="40387437" class="c"><input type="checkbox" id="c-40387437" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40387280">parent</a><span>|</span><a href="#40387461">next</a><span>|</span><label class="collapse" for="c-40387437">[-]</label><label class="expand" for="c-40387437">[1 more]</label></div><br/><div class="children"><div class="content">The proof is pretty straightforward and is included in the paper <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2301.10191" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2301.10191</a></div><br/></div></div><div id="40387461" class="c"><input type="checkbox" id="c-40387461" checked=""/><div class="controls bullet"><span class="by">HDThoreaun</span><span>|</span><a href="#40387280">parent</a><span>|</span><a href="#40387437">prev</a><span>|</span><a href="#40387428">next</a><span>|</span><label class="collapse" for="c-40387461">[-]</label><label class="expand" for="c-40387461">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the result is an estimation.</div><br/></div></div><div id="40387428" class="c"><input type="checkbox" id="c-40387428" checked=""/><div class="controls bullet"><span class="by">8372049</span><span>|</span><a href="#40387280">parent</a><span>|</span><a href="#40387461">prev</a><span>|</span><a href="#40387594">next</a><span>|</span><label class="collapse" for="c-40387428">[-]</label><label class="expand" for="c-40387428">[1 more]</label></div><br/><div class="children"><div class="content">Did you read the (entire) article?</div><br/></div></div></div></div><div id="40387594" class="c"><input type="checkbox" id="c-40387594" checked=""/><div class="controls bullet"><span class="by">aaron695</span><span>|</span><a href="#40387280">prev</a><span>|</span><a href="#40387257">next</a><span>|</span><label class="collapse" for="c-40387594">[-]</label><label class="expand" for="c-40387594">[1 more]</label></div><br/><div class="children"><div class="content">Knuth talks about this paper here  - &quot;The CVM Algorithm for Estimating Distinct Elements in Streams&quot; - <a href="https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf" rel="nofollow">https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf</a></div><br/></div></div><div id="40387257" class="c"><input type="checkbox" id="c-40387257" checked=""/><div class="controls bullet"><span class="by">matt3210</span><span>|</span><a href="#40387594">prev</a><span>|</span><label class="collapse" for="c-40387257">[-]</label><label class="expand" for="c-40387257">[4 more]</label></div><br/><div class="children"><div class="content">CS guys always wanting to throw away a good system and start from scratch.</div><br/><div id="40387316" class="c"><input type="checkbox" id="c-40387316" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40387257">parent</a><span>|</span><a href="#40387281">next</a><span>|</span><label class="collapse" for="c-40387316">[-]</label><label class="expand" for="c-40387316">[1 more]</label></div><br/><div class="children"><div class="content">Which good system are you referring to?</div><br/></div></div><div id="40387281" class="c"><input type="checkbox" id="c-40387281" checked=""/><div class="controls bullet"><span class="by">Miraltar</span><span>|</span><a href="#40387257">parent</a><span>|</span><a href="#40387316">prev</a><span>|</span><a href="#40387465">next</a><span>|</span><label class="collapse" for="c-40387281">[-]</label><label class="expand" for="c-40387281">[1 more]</label></div><br/><div class="children"><div class="content">Which good system are we talking about ?</div><br/></div></div><div id="40387465" class="c"><input type="checkbox" id="c-40387465" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#40387257">parent</a><span>|</span><a href="#40387281">prev</a><span>|</span><label class="collapse" for="c-40387465">[-]</label><label class="expand" for="c-40387465">[1 more]</label></div><br/><div class="children"><div class="content">Tell me you didn&#x27;t read the article without telling me you didn&#x27;t read the article.<p>...but actually, I think you didn&#x27;t even read the headline...?</div><br/></div></div></div></div></div></div></div></div></div></body></html>