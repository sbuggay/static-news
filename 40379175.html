<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716022854490" as="style"/><link rel="stylesheet" href="styles.css?v=1716022854490"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantamagazine.org/computer-scientists-invent-an-efficient-new-way-to-count-20240516/">Computer scientists invent an efficient new way to count</a> <span class="domain">(<a href="https://www.quantamagazine.org">www.quantamagazine.org</a>)</span></div><div class="subtext"><span>jasondavies</span> | <span>182 comments</span></div><br/><div><div id="40392831" class="c"><input type="checkbox" id="c-40392831" checked=""/><div class="controls bullet"><span class="by">zero_k</span><span>|</span><a href="#40387154">next</a><span>|</span><label class="collapse" for="c-40392831">[-]</label><label class="expand" for="c-40392831">[19 more]</label></div><br/><div class="children"><div class="content">I was involved with implementing the DNF volume counting version of this with the authors. You can see my blog post of it here:<p><a href="https:&#x2F;&#x2F;www.msoos.org&#x2F;2023&#x2F;09&#x2F;pepin-our-probabilistic-approximate-volume-counter" rel="nofollow">https:&#x2F;&#x2F;www.msoos.org&#x2F;2023&#x2F;09&#x2F;pepin-our-probabilistic-approx...</a><p>And the code here: <a href="https:&#x2F;&#x2F;github.com&#x2F;meelgroup&#x2F;pepin">https:&#x2F;&#x2F;github.com&#x2F;meelgroup&#x2F;pepin</a><p>Often, 30% of the time is spent in IO of reading the file, that&#x27;s how incredibly fast this algorithm is. Crazy stuff.<p>BTW, Knuth contributed to the algo, Knuths&#x27; notes: <a href="https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf" rel="nofollow">https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf</a><p>He actually took time off (a whole month) from TAOCP to do this. Also, he is exactly as crazy good as you&#x27;d imagine. Just mind-blowing.</div><br/><div id="40393191" class="c"><input type="checkbox" id="c-40393191" checked=""/><div class="controls bullet"><span class="by">Hnrobert42</span><span>|</span><a href="#40392831">parent</a><span>|</span><a href="#40394422">next</a><span>|</span><label class="collapse" for="c-40393191">[-]</label><label class="expand" for="c-40393191">[10 more]</label></div><br/><div class="children"><div class="content">That’s really interesting and thanks for sharing.<p>I am very curious about the extraordinarily gifted. What made you think Knuth is crazy good? Was there a particularly moment? Was it how fast he groked ideas? Was it his ability to ELI5?</div><br/><div id="40393859" class="c"><input type="checkbox" id="c-40393859" checked=""/><div class="controls bullet"><span class="by">zero_k</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40393191">parent</a><span>|</span><a href="#40394422">next</a><span>|</span><label class="collapse" for="c-40393859">[-]</label><label class="expand" for="c-40393859">[9 more]</label></div><br/><div class="children"><div class="content">What made me realize is that I saw some snippets of emails he wrote to a colleague. It was... insane. You could see his mind race. He recognized patterns in minutes that would take me days, if not weeks, to recognize. Also, he actually writes and runs code, overnight if need be. It was as bit of a shock to me. He&#x27;s not in an ivory tower. He&#x27;s very much hands on, and when he&#x27;s behind the wheel, you&#x27;re in for a ride.</div><br/><div id="40394115" class="c"><input type="checkbox" id="c-40394115" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40393859">parent</a><span>|</span><a href="#40394520">next</a><span>|</span><label class="collapse" for="c-40394115">[-]</label><label class="expand" for="c-40394115">[4 more]</label></div><br/><div class="children"><div class="content">&gt; He recognized patterns in minutes that would take me days, if not weeks, to recognize... he actually writes and runs code, overnight if need be<p>70-80 years of actually being hands-on and i bet you&#x27;d be pretty quick too. dude is definitely naturally &quot;gifted&quot; but it seems pretty obvious being hands-on has a lot to do with it.</div><br/><div id="40394253" class="c"><input type="checkbox" id="c-40394253" checked=""/><div class="controls bullet"><span class="by">gspetr</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40394115">parent</a><span>|</span><a href="#40394520">next</a><span>|</span><label class="collapse" for="c-40394253">[-]</label><label class="expand" for="c-40394253">[3 more]</label></div><br/><div class="children"><div class="content">Experience and age have diminishing returns.<p>Biden&#x27;s been hands-on in his domain for over 50 years, yet &quot;quick&quot; is definitely not the word that comes to most people&#x27;s mind when they think of him nowadays.</div><br/><div id="40394477" class="c"><input type="checkbox" id="c-40394477" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40394253">parent</a><span>|</span><a href="#40395885">next</a><span>|</span><label class="collapse" for="c-40394477">[-]</label><label class="expand" for="c-40394477">[1 more]</label></div><br/><div class="children"><div class="content">Actually quick is definitely something that comes to mind.  Quick in politics is of course relative, but the speed with which he has enacted major changes (for example marijuana legalization) is pretty quick in the realm of politics when congress is of the other party.</div><br/></div></div><div id="40395885" class="c"><input type="checkbox" id="c-40395885" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40394253">parent</a><span>|</span><a href="#40394477">prev</a><span>|</span><a href="#40394520">next</a><span>|</span><label class="collapse" for="c-40395885">[-]</label><label class="expand" for="c-40395885">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Biden&#x27;s been hands-on in his domain for over 50 years, yet &quot;quick&quot; is definitely not the word that comes to most people&#x27;s mind when they think of him nowadays.<p>Please don&#x27;t post flamebaity political tangents on HN.<p>&gt; Eschew flamebait. Avoid generic tangents.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div></div></div></div></div><div id="40394520" class="c"><input type="checkbox" id="c-40394520" checked=""/><div class="controls bullet"><span class="by">devnonymous</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40393859">parent</a><span>|</span><a href="#40394115">prev</a><span>|</span><a href="#40394018">next</a><span>|</span><label class="collapse" for="c-40394520">[-]</label><label class="expand" for="c-40394520">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, he actually writes and runs code, overnight if need be...He&#x27;s not in an ivory tower. He&#x27;s very much hands on, and when he&#x27;s behind the wheel, you&#x27;re in for a ride.<p>That&#x27;s such an admirable thing. Something to aspire to, given his age. I wonder if one can say the same thing of all the &#x27;thought leaders&#x27; of the industry who go around pontificating about code hygiene and tidiness.</div><br/></div></div><div id="40394018" class="c"><input type="checkbox" id="c-40394018" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40393859">parent</a><span>|</span><a href="#40394520">prev</a><span>|</span><a href="#40394422">next</a><span>|</span><label class="collapse" for="c-40394018">[-]</label><label class="expand" for="c-40394018">[3 more]</label></div><br/><div class="children"><div class="content">I feel extremely jealous of you.</div><br/><div id="40396761" class="c"><input type="checkbox" id="c-40396761" checked=""/><div class="controls bullet"><span class="by">khazhoux</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40394018">parent</a><span>|</span><a href="#40394422">next</a><span>|</span><label class="collapse" for="c-40396761">[-]</label><label class="expand" for="c-40396761">[2 more]</label></div><br/><div class="children"><div class="content">You are <i>envious</i> of him.<p>Jealous is when you possess something you don’t want taken away by someone else</div><br/><div id="40397176" class="c"><input type="checkbox" id="c-40397176" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40396761">parent</a><span>|</span><a href="#40394422">next</a><span>|</span><label class="collapse" for="c-40397176">[-]</label><label class="expand" for="c-40397176">[1 more]</label></div><br/><div class="children"><div class="content">Well, that use of jealousy is only really common in certain romantic situations. Like if some super good looking dude hits on your girl and she responds in an ambiguously-flirty way, you might definitely be said to be jealous, even though she didn&#x27;t run off with him.<p>In most other domains, though, like this one, jealousy and envy are synonyms. <a href="https:&#x2F;&#x2F;www.merriam-webster.com&#x2F;dictionary&#x2F;jealousy#did-you-know" rel="nofollow">https:&#x2F;&#x2F;www.merriam-webster.com&#x2F;dictionary&#x2F;jealousy#did-you-...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40394422" class="c"><input type="checkbox" id="c-40394422" checked=""/><div class="controls bullet"><span class="by">sesteel</span><span>|</span><a href="#40392831">parent</a><span>|</span><a href="#40393191">prev</a><span>|</span><a href="#40393974">next</a><span>|</span><label class="collapse" for="c-40394422">[-]</label><label class="expand" for="c-40394422">[6 more]</label></div><br/><div class="children"><div class="content">Maybe you&#x27;d know, but why would one choose to not sort favoring larger counts and drop the bottom half when full?  It may be obvious to others, but I&#x27;d be curious.</div><br/><div id="40397431" class="c"><input type="checkbox" id="c-40397431" checked=""/><div class="controls bullet"><span class="by">sufiyan</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40394422">parent</a><span>|</span><a href="#40394800">next</a><span>|</span><label class="collapse" for="c-40397431">[-]</label><label class="expand" for="c-40397431">[1 more]</label></div><br/><div class="children"><div class="content">Let’s prove it by contradiction:
Lets say you pick the larger ones and drop the smaller ones every single round, you have lost the probabilistic guarantee of 1&#x2F;2^k that the authors show because the most frequent words will be the lost frequent in subsequent rounds as well. This is the intuition, the math might be more illuminating.</div><br/></div></div><div id="40394800" class="c"><input type="checkbox" id="c-40394800" checked=""/><div class="controls bullet"><span class="by">zero_k</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40394422">parent</a><span>|</span><a href="#40397431">prev</a><span>|</span><a href="#40395756">next</a><span>|</span><label class="collapse" for="c-40394800">[-]</label><label class="expand" for="c-40394800">[2 more]</label></div><br/><div class="children"><div class="content">The guarantees would not hold, I&#x27;m pretty sure ;) Maybe one of the authors could chip in, but my hunch is that with that you could actually introduce arbitrarily large errors. The beauty of this algorithm really is its simplicity. Of course, simple is.. not always easy. This absolute masterpiece by Knuth should demonstrate this quite well:<p><a href="https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;pii&#x2F;002200007890020X" rel="nofollow">https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;pii&#x2F;0022000078...</a><p>It&#x27;s an absolutely trivial algorithm. Its average-case analysis is ridiculously hard. Hence why I think this whole Ordo obsessions needs to be refined -- worst case complexity has often little to do with real-world behavior.</div><br/><div id="40397452" class="c"><input type="checkbox" id="c-40397452" checked=""/><div class="controls bullet"><span class="by">PeterisP</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40394800">parent</a><span>|</span><a href="#40395756">next</a><span>|</span><label class="collapse" for="c-40397452">[-]</label><label class="expand" for="c-40397452">[1 more]</label></div><br/><div class="children"><div class="content">Worst case complexity matters when the input data can be manipulated by someone malicious, who can then intentionally engineer the degenerate worst case to happen - as we have seen historically in e.g. denial of service attacks exploiting common hash table implementations with bad worst case complexity.</div><br/></div></div></div></div><div id="40395756" class="c"><input type="checkbox" id="c-40395756" checked=""/><div class="controls bullet"><span class="by">lokar</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40394422">parent</a><span>|</span><a href="#40394800">prev</a><span>|</span><a href="#40393974">next</a><span>|</span><label class="collapse" for="c-40395756">[-]</label><label class="expand" for="c-40395756">[2 more]</label></div><br/><div class="children"><div class="content">You want every distinct item to have the same chance at the end.  So when items repeat you need to reduce (not increase) the odds of keeping any given occurrence.</div><br/><div id="40396538" class="c"><input type="checkbox" id="c-40396538" checked=""/><div class="controls bullet"><span class="by">throwaway14356</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40395756">parent</a><span>|</span><a href="#40393974">next</a><span>|</span><label class="collapse" for="c-40396538">[-]</label><label class="expand" for="c-40396538">[1 more]</label></div><br/><div class="children"><div class="content">does that mean you could also split the set in half multiple times then run it on each half of a half (etc) and combine it with its other half?<p>that would seem simpler to me.<p>edit: oh but then you would need to keep the results which defeats the purpose</div><br/></div></div></div></div></div></div><div id="40393974" class="c"><input type="checkbox" id="c-40393974" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#40392831">parent</a><span>|</span><a href="#40394422">prev</a><span>|</span><a href="#40387154">next</a><span>|</span><label class="collapse" for="c-40393974">[-]</label><label class="expand" for="c-40393974">[2 more]</label></div><br/><div class="children"><div class="content">So now we have you to blame for a delay on the release of his next book. :)</div><br/><div id="40394060" class="c"><input type="checkbox" id="c-40394060" checked=""/><div class="controls bullet"><span class="by">zero_k</span><span>|</span><a href="#40392831">root</a><span>|</span><a href="#40393974">parent</a><span>|</span><a href="#40387154">next</a><span>|</span><label class="collapse" for="c-40394060">[-]</label><label class="expand" for="c-40394060">[1 more]</label></div><br/><div class="children"><div class="content">Not me, the authors -- I&#x27;m a fly on the wall compared to them ;) This is some serious work, I just did a fast implementation. Re implementation -- it turns out that there are parts of some standard libraries that this problem pushes to its limits, that we had to go around during implementation. So there were still some cool challenges involved. I was also pretty happy about the late binding&#x2F;lazy evaluation thing I came up with. Of course Knuth just did it (check his notes), without even thinking about it :D What is an achievement for me is a lazy Monday coffee for him, but oh well!</div><br/></div></div></div></div></div></div><div id="40387154" class="c"><input type="checkbox" id="c-40387154" checked=""/><div class="controls bullet"><span class="by">pixelmonkey</span><span>|</span><a href="#40392831">prev</a><span>|</span><a href="#40397482">next</a><span>|</span><label class="collapse" for="c-40387154">[-]</label><label class="expand" for="c-40387154">[13 more]</label></div><br/><div class="children"><div class="content">This algorithm seems to resemble HyperLogLog (and all its variants), which is also cited in the research paper. Using the same insight of the estimation value of tracking whether we&#x27;ve hit a &quot;run&quot; of heads or tails, but flipping the idea on its head (heh), it leads to the simpler algorithm described, which is about discarding memorized values on the basis of runs of heads&#x2F;tails.<p>This also works especially well (that is, efficiently) in the streaming case, allowing you to keep something resembling a &quot;counter&quot; for the distinct elements, albeit with a error rate.<p>The benefit of HyperLogLog is that it behaves similarly to a hash set in some respects -- you can add items, count distinct them, and, importantly, merge two HLLs together (union), all the while keeping memory fixed to mere kilobytes even for billion-item sets. In distributed data stores, this is the trick behind Elasticsearch&#x2F;OpenSearch cardinality agg, as well as behind Redis&#x2F;Redict with its PFADD&#x2F;PFMERGE&#x2F;PFCOUNT.<p>I am not exactly sure how this CVM algorithm compares to HLL, but they got Knuth to review it, and they claim an undergrad can implement it easily, so it must be pretty good!</div><br/><div id="40387614" class="c"><input type="checkbox" id="c-40387614" checked=""/><div class="controls bullet"><span class="by">hmottestad</span><span>|</span><a href="#40387154">parent</a><span>|</span><a href="#40396603">next</a><span>|</span><label class="collapse" for="c-40387614">[-]</label><label class="expand" for="c-40387614">[7 more]</label></div><br/><div class="children"><div class="content">It’s also possible to use HLL to estimate the cardinality of joins since it’s possible to estimate both the union and the intersection of two HLLs.<p><a href="http:&#x2F;&#x2F;oertl.github.io&#x2F;hyperloglog-sketch-estimation-paper&#x2F;" rel="nofollow">http:&#x2F;&#x2F;oertl.github.io&#x2F;hyperloglog-sketch-estimation-paper&#x2F;</a></div><br/><div id="40391212" class="c"><input type="checkbox" id="c-40391212" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40387614">parent</a><span>|</span><a href="#40391418">next</a><span>|</span><label class="collapse" for="c-40391212">[-]</label><label class="expand" for="c-40391212">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a really interesting open problem to get the cost of these down so that they can be used to heuristically select the variable order for worst case optimal joins during evaluation.<p>It&#x27;s somewhere on the back of my todo list, and I have the hunch that it would enable instance optimal join algorithms.<p>I&#x27;ve dubbed these the Atreides Family of Joins:<p><pre><code>  - Jessicas Join: The cost of each variable is based on the smallest number of rows that might be proposed for that variable by each joined relation.
  - Pauls join: The cost of each variable is based on the smallest number of distinct values that will actually be proposed for that variable from each joined relation.
  - Letos join: The cost of each variable is based on the actual size of the intersection.
</code></pre>
In a sense each of the variants can look further into the future.<p>I&#x27;m using the first and the second in a triplestore I build in Rust [1] and it&#x27;s a lot faster than Oxigraph. But I suspect that the constant factors would make the third infeasable (yet).<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;triblespace&#x2F;tribles-rust&#x2F;blob&#x2F;master&#x2F;src&#x2F;query.rs">https:&#x2F;&#x2F;github.com&#x2F;triblespace&#x2F;tribles-rust&#x2F;blob&#x2F;master&#x2F;src&#x2F;...</a></div><br/><div id="40391478" class="c"><input type="checkbox" id="c-40391478" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40391212">parent</a><span>|</span><a href="#40391418">next</a><span>|</span><label class="collapse" for="c-40391478">[-]</label><label class="expand" for="c-40391478">[4 more]</label></div><br/><div class="children"><div class="content">Having read something vaguely related recently [0] I believe &quot;Lookahead Information Passing&quot; is the common term for this general idea. That paper discusses the use of bloom filters (not HLL) in the context of typical binary join trees.<p>&gt; Letos join<p>God-Emperor Join has a nice ring to it.<p>[0] &quot;Simple Adaptive Query Processing vs. Learned Query Optimizers:
Observations and Analysis&quot; - <a href="https:&#x2F;&#x2F;www.vldb.org&#x2F;pvldb&#x2F;vol16&#x2F;p2962-zhang.pdf" rel="nofollow">https:&#x2F;&#x2F;www.vldb.org&#x2F;pvldb&#x2F;vol16&#x2F;p2962-zhang.pdf</a></div><br/><div id="40391727" class="c"><input type="checkbox" id="c-40391727" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40391478">parent</a><span>|</span><a href="#40391418">next</a><span>|</span><label class="collapse" for="c-40391727">[-]</label><label class="expand" for="c-40391727">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for the interesting paper!<p><pre><code>  We now formally define our _God-Emperor Join_ henceforth denoted join_ge...
</code></pre>
Nice work with TXDB btw, it&#x27;s funny how much impact Clojure, Datomic and Datascript had outside their own ecosystem!<p>Let me return the favour with an interesting paper [1] that should be especially relevant to the columnar data layout of TXDB. I&#x27;m currently building a succinct on-disk format with it [2], but you might be able to simply add some auxiliary structures to your arrow columns instead.<p>1: <a href="https:&#x2F;&#x2F;aidanhogan.com&#x2F;docs&#x2F;ring-graph-wco.pdf" rel="nofollow">https:&#x2F;&#x2F;aidanhogan.com&#x2F;docs&#x2F;ring-graph-wco.pdf</a><p>2: <a href="https:&#x2F;&#x2F;github.com&#x2F;triblespace&#x2F;tribles-rust&#x2F;blob&#x2F;archive&#x2F;src&#x2F;triblearchive&#x2F;succinctarchive&#x2F;succinctarchiveconstraint.rs">https:&#x2F;&#x2F;github.com&#x2F;triblespace&#x2F;tribles-rust&#x2F;blob&#x2F;archive&#x2F;src...</a></div><br/><div id="40391982" class="c"><input type="checkbox" id="c-40391982" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40391727">parent</a><span>|</span><a href="#40391418">next</a><span>|</span><label class="collapse" for="c-40391982">[-]</label><label class="expand" for="c-40391982">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Nice work with TXDB btw</i><p>It&#x27;s X.T. (as in &#x27;Cross-Time&#x27; &#x2F; <a href="https:&#x2F;&#x2F;xtdb.com" rel="nofollow">https:&#x2F;&#x2F;xtdb.com</a>), but thank you! :)<p><i>&gt; 1: <a href="https:&#x2F;&#x2F;aidanhogan.com&#x2F;docs&#x2F;ring-graph-wco.pdf" rel="nofollow">https:&#x2F;&#x2F;aidanhogan.com&#x2F;docs&#x2F;ring-graph-wco.pdf</a></i><p>Oh nice, I recall skimming this team&#x27;s precursor paper &quot;Worst-Case Optimal Graph Joins in Almost No Space&quot; (2021) - seems like they&#x27;ve done a lot more work since though, so definitely looking forward to reading it:<p><i>&gt; The conference version presented the ring in terms of the Burrows–Wheeler transform. We present a new formulation of the ring in terms of stable sorting on column databases, which we hope will be more accessible to a broader audience not familiar with text indexing</i></div><br/><div id="40392234" class="c"><input type="checkbox" id="c-40392234" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40391982">parent</a><span>|</span><a href="#40391418">next</a><span>|</span><label class="collapse" for="c-40392234">[-]</label><label class="expand" for="c-40392234">[1 more]</label></div><br/><div class="children"><div class="content">My apologies! It&#x27;s even more emberrasing given the fact that I looked up the website, knowing that I _always_ swap them after having written too many `tx-listen` in my career.<p>They expanded their work to wider relations and made the whole framework a lot more penetrable. I think they over-complicate things a bit with their forward-extension, so I&#x27;m keeping every column twice (still much better than all permutations), which in turn allows for ad-hoc cardinality estimation.<p>Also the 1 based indexing with inclusive ranges is really not doing them any favours. Most formula become much more streamlined and simpler with 0 based indexing and exclusive ranges. (see `base_range` and `restrict_range` in [0])<p>0: <a href="https:&#x2F;&#x2F;github.com&#x2F;triblespace&#x2F;tribles-rust&#x2F;blob&#x2F;e3ad6f21cdc02897943b2380d04f7a2c04d1332f&#x2F;src&#x2F;triblearchive&#x2F;succinctarchive&#x2F;succinctarchiveconstraint.rs#L45">https:&#x2F;&#x2F;github.com&#x2F;triblespace&#x2F;tribles-rust&#x2F;blob&#x2F;e3ad6f21cdc...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40391418" class="c"><input type="checkbox" id="c-40391418" checked=""/><div class="controls bullet"><span class="by">jalk</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40387614">parent</a><span>|</span><a href="#40391212">prev</a><span>|</span><a href="#40396603">next</a><span>|</span><label class="collapse" for="c-40391418">[-]</label><label class="expand" for="c-40391418">[1 more]</label></div><br/><div class="children"><div class="content">Iirc intersection requires the HLLs to have similar cardinality, otherwise the result is way off.</div><br/></div></div></div></div><div id="40396603" class="c"><input type="checkbox" id="c-40396603" checked=""/><div class="controls bullet"><span class="by">snewman</span><span>|</span><a href="#40387154">parent</a><span>|</span><a href="#40387614">prev</a><span>|</span><a href="#40389058">next</a><span>|</span><label class="collapse" for="c-40396603">[-]</label><label class="expand" for="c-40396603">[1 more]</label></div><br/><div class="children"><div class="content">You could merge these data structures as well. If the two instances to be merged are not at the same &quot;round&quot;, take the one that&#x27;s at an earlier round and advance it (by discarding half the entries at random) by the difference in rounds. Then just insert the values from one list to the other, ignoring duplicates; if the result is too large, discard half at random and increment the round number.<p>I implemented exactly this algorithm at my previous employer, except that alongside each value, we stored an estimate of the number of times that value appeared. This allowed us to generate an approximate list of the most common values and estimated count for each value.</div><br/></div></div><div id="40389058" class="c"><input type="checkbox" id="c-40389058" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#40387154">parent</a><span>|</span><a href="#40396603">prev</a><span>|</span><a href="#40397482">next</a><span>|</span><label class="collapse" for="c-40389058">[-]</label><label class="expand" for="c-40389058">[4 more]</label></div><br/><div class="children"><div class="content">Just curious, dusting off my distant school memories :)<p>How do the HLL and CVM that I hear about relate to reservoir sampling which I remember learning?<p>I once had a job at a hospital (back when &#x27;whiz kids&#x27; were being hired by pretty much every business) where I used reservoir sampling to make small subsets of records that were stored on DAT tapes.</div><br/><div id="40389845" class="c"><input type="checkbox" id="c-40389845" checked=""/><div class="controls bullet"><span class="by">michaelmior</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40389058">parent</a><span>|</span><a href="#40394063">next</a><span>|</span><label class="collapse" for="c-40389845">[-]</label><label class="expand" for="c-40389845">[2 more]</label></div><br/><div class="children"><div class="content">I guess there is a connection in the sense that with reservoir sampling, each sample observed has an equal chance of remaining when you&#x27;re done. However, if you have duplicates in your samples, traditional algorithms for reservoir sampling do not do anything special with duplicates. So you can end up with duplicates in your output with some probability.<p>I guess maybe it&#x27;s more interesting to look at the other way. How is the set of samples you&#x27;re left with at the end of CVM related to the set of samples you get with reservoir sampling?</div><br/><div id="40391787" class="c"><input type="checkbox" id="c-40391787" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40389845">parent</a><span>|</span><a href="#40394063">next</a><span>|</span><label class="collapse" for="c-40391787">[-]</label><label class="expand" for="c-40391787">[1 more]</label></div><br/><div class="children"><div class="content">Was wondering the same, thanks for an answer.</div><br/></div></div></div></div><div id="40394063" class="c"><input type="checkbox" id="c-40394063" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#40387154">root</a><span>|</span><a href="#40389058">parent</a><span>|</span><a href="#40389845">prev</a><span>|</span><a href="#40397482">next</a><span>|</span><label class="collapse" for="c-40394063">[-]</label><label class="expand" for="c-40394063">[1 more]</label></div><br/><div class="children"><div class="content">Knuth&#x27;s presentation of this [1] seems very very similar to the heap-version (top-k on a uniform deviate) of reservoir sampling as mentioned in [2]. The difference is in how duplicates are handled. I wouldn&#x27;t be surprised if this algorithm was in fact already in use somewhere!<p>[1] <a href="https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf" rel="nofollow">https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf</a>
[2] <a href="https:&#x2F;&#x2F;florian.github.io&#x2F;reservoir-sampling&#x2F;" rel="nofollow">https:&#x2F;&#x2F;florian.github.io&#x2F;reservoir-sampling&#x2F;</a><p>Edit: Another commenter [3] brought up the BJKST algorithm which seems to be similar procedure except using a suitably &quot;uniform&quot; hash function (pairwise independence) as the deviate instead of a random number.<p>[3] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40389178">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40389178</a></div><br/></div></div></div></div></div></div><div id="40397482" class="c"><input type="checkbox" id="c-40397482" checked=""/><div class="controls bullet"><span class="by">leduyquang753</span><span>|</span><a href="#40387154">prev</a><span>|</span><a href="#40387508">next</a><span>|</span><label class="collapse" for="c-40397482">[-]</label><label class="expand" for="c-40397482">[1 more]</label></div><br/><div class="children"><div class="content">In the algorithm depicted in the paper, if no elements manage to be eliminated from the set, why not just retry rather than return ⊥?</div><br/></div></div><div id="40387508" class="c"><input type="checkbox" id="c-40387508" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#40397482">prev</a><span>|</span><a href="#40389592">next</a><span>|</span><label class="collapse" for="c-40387508">[-]</label><label class="expand" for="c-40387508">[29 more]</label></div><br/><div class="children"><div class="content">I found the paper took about as long to read as the blog post and is more informative:<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2301.10191" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2301.10191</a><p>It is about estimating the cardinality of a set of elements derived from a stream. The algorithm is so simple, you can code it and play with it whilst you read the paper.<p>The authors are explicit about the target audience and purpose for the algorithm: undergraduates and textbooks.</div><br/><div id="40387733" class="c"><input type="checkbox" id="c-40387733" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#40387508">parent</a><span>|</span><a href="#40389210">next</a><span>|</span><label class="collapse" for="c-40387733">[-]</label><label class="expand" for="c-40387733">[8 more]</label></div><br/><div class="children"><div class="content">If you refer to the subtitle of the paper - <i>An Algorithm for the (Text) Book</i> - I think that is actually a reference to something *Paul Erdos allegedly said about some proofs are so elegant in their simplicity and beauty that they are &quot;from The Book&quot;, like representing some divine Platonic ideal.<p>Given that Knuth himself reviewed it, he might have remarked that this was one of those algorithms! Perhaps the authors decided to include it in the title as a not-so-humble brag (which would be well-earned if that&#x27;s the case!)<p><i>edit: originally this comment said Knuth was the one who said this about some algorithms being from The Book, but that was my faulty memory.</i></div><br/><div id="40391301" class="c"><input type="checkbox" id="c-40391301" checked=""/><div class="controls bullet"><span class="by">cschmidt</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40387733">parent</a><span>|</span><a href="#40388305">next</a><span>|</span><label class="collapse" for="c-40391301">[-]</label><label class="expand" for="c-40391301">[1 more]</label></div><br/><div class="children"><div class="content">I liked this part.  They got Knuth to review it, and found mistakes.  That&#x27;s kind of cool, in its own way.<p><pre><code>    We are deeply grateful to Donald E. Knuth for his thorough review, 
    which not only enhanced the quality of this paper (including fixing
    several errors) but has also inspired us for higher standards.</code></pre></div><br/></div></div><div id="40388305" class="c"><input type="checkbox" id="c-40388305" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40387733">parent</a><span>|</span><a href="#40391301">prev</a><span>|</span><a href="#40387815">next</a><span>|</span><label class="collapse" for="c-40388305">[-]</label><label class="expand" for="c-40388305">[3 more]</label></div><br/><div class="children"><div class="content">From the abstract: &quot;... All the current state-of-the-art algorithms are, however, beyond the reach of an undergraduate textbook owing to their reliance on the usage of notions such as pairwise independence and universal hash functions. We present a simple, intuitive, sampling-based space-efficient algorithm whose description and the proof are accessible to undergraduates with the knowledge of basic probability theory ....&quot;</div><br/><div id="40389178" class="c"><input type="checkbox" id="c-40389178" checked=""/><div class="controls bullet"><span class="by">dchftcs</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40388305">parent</a><span>|</span><a href="#40389111">next</a><span>|</span><label class="collapse" for="c-40389178">[-]</label><label class="expand" for="c-40389178">[1 more]</label></div><br/><div class="children"><div class="content">This is really twisting it, I don&#x27;t find pairwise indepedence to be more advanced than applying a Chernoff bound. In this problem it&#x27;d mostly be the difference of using a Cherbyshev type bound or Chernoff bound.<p>Pairwise independence is to give the algorithm stronger guarantees and let it work with a simple hash function like ax+b, otherwise probably most existing algorithms can be simplified in the same way. The most similar algorithm is BJKST, which is almost identical except for specifyimg the sampling mechanism to require less randomness.<p>To someone who worked on this type of thing before, it&#x27;s like seeing people familar with LLMs say &quot;oh yet another X-billion parameter model on github doing more or less the same&quot;.</div><br/></div></div><div id="40389111" class="c"><input type="checkbox" id="c-40389111" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40388305">parent</a><span>|</span><a href="#40389178">prev</a><span>|</span><a href="#40387815">next</a><span>|</span><label class="collapse" for="c-40389111">[-]</label><label class="expand" for="c-40389111">[1 more]</label></div><br/><div class="children"><div class="content">The point is that the subtitle&#x27;s is pretty clearly intended to have a dual meaning, it wouldn&#x27;t be phrased like that otherwise.</div><br/></div></div></div></div><div id="40387815" class="c"><input type="checkbox" id="c-40387815" checked=""/><div class="controls bullet"><span class="by">kibibu</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40387733">parent</a><span>|</span><a href="#40388305">prev</a><span>|</span><a href="#40389210">next</a><span>|</span><label class="collapse" for="c-40387815">[-]</label><label class="expand" for="c-40387815">[3 more]</label></div><br/><div class="children"><div class="content">I thought The Book was an Erdos thing. I wonder who used it first.</div><br/><div id="40387939" class="c"><input type="checkbox" id="c-40387939" checked=""/><div class="controls bullet"><span class="by">stevesimmons</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40387815">parent</a><span>|</span><a href="#40388113">next</a><span>|</span><label class="collapse" for="c-40387939">[-]</label><label class="expand" for="c-40387939">[1 more]</label></div><br/><div class="children"><div class="content">&quot;During a lecture in 1985, Erdős said, `You don&#x27;t have to believe in God, but you should believe in The Book.`&quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proofs_from_THE_BOOK" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proofs_from_THE_BOOK</a></div><br/></div></div><div id="40388113" class="c"><input type="checkbox" id="c-40388113" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40387815">parent</a><span>|</span><a href="#40387939">prev</a><span>|</span><a href="#40389210">next</a><span>|</span><label class="collapse" for="c-40388113">[-]</label><label class="expand" for="c-40388113">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re right, I must have confused the two. I&#x27;ll edit my comment to reduce the spread of misinformation.</div><br/></div></div></div></div></div></div><div id="40389210" class="c"><input type="checkbox" id="c-40389210" checked=""/><div class="controls bullet"><span class="by">cb321</span><span>|</span><a href="#40387508">parent</a><span>|</span><a href="#40387733">prev</a><span>|</span><a href="#40388638">next</a><span>|</span><label class="collapse" for="c-40389210">[-]</label><label class="expand" for="c-40389210">[5 more]</label></div><br/><div class="children"><div class="content">I agree the paper is better than the blog post, although one criticism I have of the CVM paper is that it has some termination&#x2F;algo exit condition instead of what Knuth&#x27;s CVM notes (refed else-thread here) do which is just a loop to ensure getting more space in the reservoir halving-step.  It seems more work to explain the <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Up_tack" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Up_tack</a> than just do the loop. [1]<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40388878">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40388878</a></div><br/><div id="40389828" class="c"><input type="checkbox" id="c-40389828" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40389210">parent</a><span>|</span><a href="#40391821">next</a><span>|</span><label class="collapse" for="c-40389828">[-]</label><label class="expand" for="c-40389828">[3 more]</label></div><br/><div class="children"><div class="content">On that note, I&#x27;m also unfamiliar with this \ operator notation which is used without explanation.<p><pre><code>    X ← X \ {ai}</code></pre></div><br/><div id="40389984" class="c"><input type="checkbox" id="c-40389984" checked=""/><div class="controls bullet"><span class="by">jtanderson</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40389828">parent</a><span>|</span><a href="#40390021">next</a><span>|</span><label class="collapse" for="c-40389984">[-]</label><label class="expand" for="c-40389984">[1 more]</label></div><br/><div class="children"><div class="content">That is conventional set subtraction notation. &quot;Assign to X the same set minus all elements of the set {a_i}&quot;.<p>One example source, but it is pretty common in general: <a href="http:&#x2F;&#x2F;www.mathwords.com&#x2F;s&#x2F;set_subtraction.htm" rel="nofollow">http:&#x2F;&#x2F;www.mathwords.com&#x2F;s&#x2F;set_subtraction.htm</a></div><br/></div></div><div id="40390021" class="c"><input type="checkbox" id="c-40390021" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40389828">parent</a><span>|</span><a href="#40389984">prev</a><span>|</span><a href="#40391821">next</a><span>|</span><label class="collapse" for="c-40390021">[-]</label><label class="expand" for="c-40390021">[1 more]</label></div><br/><div class="children"><div class="content">Set difference.<p>Set X becomes X without element ai. This is the case whether ai was in the set X before the step was taken.</div><br/></div></div></div></div><div id="40391821" class="c"><input type="checkbox" id="c-40391821" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40389210">parent</a><span>|</span><a href="#40389828">prev</a><span>|</span><a href="#40388638">next</a><span>|</span><label class="collapse" for="c-40391821">[-]</label><label class="expand" for="c-40391821">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve known that symbol for decades, never knew it&#x27;s name - up-tack it is. Ta!</div><br/></div></div></div></div><div id="40388638" class="c"><input type="checkbox" id="c-40388638" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#40387508">parent</a><span>|</span><a href="#40389210">prev</a><span>|</span><a href="#40395172">next</a><span>|</span><label class="collapse" for="c-40388638">[-]</label><label class="expand" for="c-40388638">[1 more]</label></div><br/><div class="children"><div class="content">The blog post was more than half padding. Good that the algorithm is so simple it&#x27;s hard to write a full length blog post about it!</div><br/></div></div><div id="40395172" class="c"><input type="checkbox" id="c-40395172" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#40387508">parent</a><span>|</span><a href="#40388638">prev</a><span>|</span><a href="#40388003">next</a><span>|</span><label class="collapse" for="c-40395172">[-]</label><label class="expand" for="c-40395172">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while, and maybe my brain has smoothened since my time in CS, but man this looks more confusing than it needs to be.<p>First, the contradiction thing. It&#x27;s just.. An error&#x2F;panic, why? Anyway, fine.<p>Then, there&#x27;s the whole premise of 1..m: I&#x27;m still not sure if the size needs to be known upfront or not. Looking at it a bit more, it seems like no you don&#x27;t. You pick a threshold, and then depending on the size of the stream the probability changes. But the algorithm is described as if it had a single output, which is not the case(?).<p>And btw, I didn&#x27;t know about the Chernoff bounds and delta&#x2F;epsilon are not explained at all in the paper, which added to the confusion a lot.<p>Anyway, here&#x27;s my take in Golang: <a href="https:&#x2F;&#x2F;github.com&#x2F;betamos&#x2F;distinct">https:&#x2F;&#x2F;github.com&#x2F;betamos&#x2F;distinct</a><p>I factored out the threshold parts into a helper instead, which makes a lot more sense than accidentally allocating too much memory.<p>Perhaps there should be a method for estimating the confidence&#x2F;error rate. Nobody knows the size of a stream upfront, so it would make more sense to update these values as you go. Brain is not strong enough to implement it, but feel free to send a PR.</div><br/><div id="40397205" class="c"><input type="checkbox" id="c-40397205" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40395172">parent</a><span>|</span><a href="#40397156">next</a><span>|</span><label class="collapse" for="c-40397205">[-]</label><label class="expand" for="c-40397205">[1 more]</label></div><br/><div class="children"><div class="content">&gt; First, the contradiction thing. It&#x27;s just.. An error&#x2F;panic, why? Anyway, fine.<p>I suspect due to the details of the proof. This condition looks likely to me for very small set cardinality making the algorithm inappropriate for all-weather. See page 3 of the paper where Algorithm 2 is introduced. They show that in the failure condition, the likelihood of the algorithm returning a value outside of the epsilon bounds is higher.<p>&gt; Then, there&#x27;s the whole premise of 1..m: I&#x27;m still not sure if the size needs to be known upfront or not.<p>m sizes the threshold, if it is too small, the error bounds guaranteed by the algorithm will be larger than expected, and vice versa if m is too large.<p>&gt; And btw, I didn&#x27;t know about the Chernoff bounds and delta&#x2F;epsilon are not explained at all in the paper, which added to the confusion a lot.<p>Papers typically do not spend words on basics and those are standard concepts.<p>&gt; Perhaps there should be a method for estimating the confidence&#x2F;error rate.<p>You can&#x27;t resize the stream easily because p implicitly depends on m via the thresh cardinality condition and if you were to change m then your p updates would not correspond. As a result you may not be able to rely on the error bounds. Note though that stream doesn&#x27;t mean infinite or very large: take it to mean one item at a time. The point of this algorithm is to bound space complexity to something small. Have a look at thresh and note that log2(1e50) is just 166: if you did have a very large stream of indeterminate length you could also just pick a very large m.</div><br/></div></div><div id="40397156" class="c"><input type="checkbox" id="c-40397156" checked=""/><div class="controls bullet"><span class="by">kuldeepmeel</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40395172">parent</a><span>|</span><a href="#40397205">prev</a><span>|</span><a href="#40388003">next</a><span>|</span><label class="collapse" for="c-40397156">[-]</label><label class="expand" for="c-40397156">[1 more]</label></div><br/><div class="children"><div class="content">[I am one of the authors].<p>We have a follow-up work (admittedly, more technical) that can remove reliance on m completely: <a href="https:&#x2F;&#x2F;www.cs.toronto.edu&#x2F;~meel&#x2F;Papers&#x2F;pods22.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.toronto.edu&#x2F;~meel&#x2F;Papers&#x2F;pods22.pdf</a><p>But yes, our theorems can be reworked to estimate the confidence&#x2F;error rate; that&#x27;s what Knuth did: <a href="https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf" rel="nofollow">https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~knuth&#x2F;papers&#x2F;cvm-note.pdf</a></div><br/></div></div></div></div><div id="40388003" class="c"><input type="checkbox" id="c-40388003" checked=""/><div class="controls bullet"><span class="by">swores</span><span>|</span><a href="#40387508">parent</a><span>|</span><a href="#40395172">prev</a><span>|</span><a href="#40387945">next</a><span>|</span><label class="collapse" for="c-40388003">[-]</label><label class="expand" for="c-40388003">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>&quot;The authors are explicit about the target audience and purpose for the algorithm: undergraduates and textbooks.&quot;</i><p>If you&#x27;re saying it&#x27;s just for &quot;undergraduates and textbooks&quot;, as opposed to just being simple enough for them to use but not limited to them, would you mind explaining what makes it useful for undergrads but not for professionals?</div><br/><div id="40388274" class="c"><input type="checkbox" id="c-40388274" checked=""/><div class="controls bullet"><span class="by">pfsalter</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40388003">parent</a><span>|</span><a href="#40388315">next</a><span>|</span><label class="collapse" for="c-40388274">[-]</label><label class="expand" for="c-40388274">[1 more]</label></div><br/><div class="children"><div class="content">My interpretation from the paper is that this algorithm is simpler than other options but also worse. So in a professional context you&#x27;d use one of those instead</div><br/></div></div><div id="40388315" class="c"><input type="checkbox" id="c-40388315" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40388003">parent</a><span>|</span><a href="#40388274">prev</a><span>|</span><a href="#40387945">next</a><span>|</span><label class="collapse" for="c-40388315">[-]</label><label class="expand" for="c-40388315">[5 more]</label></div><br/><div class="children"><div class="content">From the abstract: &quot;All the current state-of-the-art algorithms are, however, beyond the reach of an undergraduate textbook owing to their reliance on the usage of notions such as pairwise independence and universal hash functions. We present a simple, intuitive, sampling-based space-efficient algorithm whose description and the proof are accessible to undergraduates with the knowledge of basic probability theory.&quot;</div><br/><div id="40388338" class="c"><input type="checkbox" id="c-40388338" checked=""/><div class="controls bullet"><span class="by">swores</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40388315">parent</a><span>|</span><a href="#40387945">next</a><span>|</span><label class="collapse" for="c-40388338">[-]</label><label class="expand" for="c-40388338">[4 more]</label></div><br/><div class="children"><div class="content">That still only speaks to it being simple enough for students, not whether its too simple for any other use vs. useful enough that students who learn it will spend the rest of their lives using it.<p>For example word processor software is commonly described as simple enough for children to use at school, that doesn&#x27;t mean that word processor software is of no use to adults.</div><br/><div id="40394522" class="c"><input type="checkbox" id="c-40394522" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40388338">parent</a><span>|</span><a href="#40389724">next</a><span>|</span><label class="collapse" for="c-40394522">[-]</label><label class="expand" for="c-40394522">[1 more]</label></div><br/><div class="children"><div class="content">Simplicity in an algorithm has limited direct impact on its usefulness in industry where libraries are prevalent.<p>Consider mapping structures with Θ(k) expected lookup times.  The simplest implementation is a hash table with chaining.  Open-addressing is a bit more complicated, but also more common.  Tries, which have O(k) worst-case lookup times are often covered in Undergraduate courses and are definitely easier to analyze and implement than forms of open-addressed hash-tables that have O(k) guarantees (e.g. Cuckoo hashing).</div><br/></div></div><div id="40389724" class="c"><input type="checkbox" id="c-40389724" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40388338">parent</a><span>|</span><a href="#40394522">prev</a><span>|</span><a href="#40389334">next</a><span>|</span><label class="collapse" for="c-40389724">[-]</label><label class="expand" for="c-40389724">[1 more]</label></div><br/><div class="children"><div class="content">the reason it&#x27;s too simple for most real world use is that hyper-log-log is the &quot;good&quot; version of this technique (but is harder to prove that it works)</div><br/></div></div></div></div></div></div></div></div><div id="40387945" class="c"><input type="checkbox" id="c-40387945" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40387508">parent</a><span>|</span><a href="#40388003">prev</a><span>|</span><a href="#40389040">next</a><span>|</span><label class="collapse" for="c-40387945">[-]</label><label class="expand" for="c-40387945">[3 more]</label></div><br/><div class="children"><div class="content">&gt;<i>The authors are explicit about the target audience and purpose for the algorithm: undergraduates and textbooks.</i><p>Doesn&#x27;t seem like it. Seems like an algorithm (similar to other approximate cardinality estimation algorithms) with huge applicability.</div><br/><div id="40388332" class="c"><input type="checkbox" id="c-40388332" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40387945">parent</a><span>|</span><a href="#40389040">next</a><span>|</span><label class="collapse" for="c-40388332">[-]</label><label class="expand" for="c-40388332">[2 more]</label></div><br/><div class="children"><div class="content">From the abstract: &quot;All the current state-of-the-art algorithms are, however, beyond the reach of an undergraduate textbook owing to their reliance on the usage of notions such as pairwise independence and universal hash functions. We present a simple, intuitive, sampling-based space-efficient algorithm whose description and the proof are accessible to undergraduates with the knowledge of basic probability theory.&quot;</div><br/><div id="40389388" class="c"><input type="checkbox" id="c-40389388" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40387508">root</a><span>|</span><a href="#40388332">parent</a><span>|</span><a href="#40389040">next</a><span>|</span><label class="collapse" for="c-40389388">[-]</label><label class="expand" for="c-40389388">[1 more]</label></div><br/><div class="children"><div class="content">That just says that this is also simpler and more accessible algorithm, suitable even for undegraduate textbooks.<p>Not that this is just useful for textbooks, a mere academic toy example, which would be something else entirely.<p>This is both accessible AND efficient.</div><br/></div></div></div></div></div></div><div id="40389040" class="c"><input type="checkbox" id="c-40389040" checked=""/><div class="controls bullet"><span class="by">aspenmayer</span><span>|</span><a href="#40387508">parent</a><span>|</span><a href="#40387945">prev</a><span>|</span><a href="#40389592">next</a><span>|</span><label class="collapse" for="c-40389040">[-]</label><label class="expand" for="c-40389040">[1 more]</label></div><br/><div class="children"><div class="content">Link to abstract: 
<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2301.10191" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2301.10191</a></div><br/></div></div></div></div><div id="40389592" class="c"><input type="checkbox" id="c-40389592" checked=""/><div class="controls bullet"><span class="by">pytness</span><span>|</span><a href="#40387508">prev</a><span>|</span><a href="#40389878">next</a><span>|</span><label class="collapse" for="c-40389592">[-]</label><label class="expand" for="c-40389592">[10 more]</label></div><br/><div class="children"><div class="content">Is it me or is the description of the algo wrong?<p><pre><code>    &gt; Round 1. Keep going through Hamlet, adding new words as you go. If you come to a word that’s already on your list, flip a coin again. If it’s tails, delete the word;
</code></pre>
If i follow this description of &quot;check if exists in list -&gt; delete&quot;:<p><pre><code>    if hash_set.contains(word) {
        if !keep_a_word(round) {
            hash_set.remove(word);
            continue;
        }
    } else {
        hash_set.insert(word.to_string());
    }
</code></pre>
The algorithm runs for ~20 iterations:<p><pre><code>    Total word count: 31955 | limit: 1000
    End Round: 20, word count: 737
    Unique word count: 7233
    Estimated unique word count: 772800512
</code></pre>
But if I save the word first and then delete the same word:<p><pre><code>    hash_set.insert(word.to_string());

    if !keep_a_word(round) {
        hash_set.remove(word);
        continue;
    }
</code></pre>
It gets the correct answer:<p><pre><code>    Total word count: 31955 | 1000
    End Round: 3, word count: 905
    Unique word count: 7233
    Estimated unique word count: 7240</code></pre></div><br/><div id="40389764" class="c"><input type="checkbox" id="c-40389764" checked=""/><div class="controls bullet"><span class="by">josephernest</span><span>|</span><a href="#40389592">parent</a><span>|</span><a href="#40389730">next</a><span>|</span><label class="collapse" for="c-40389764">[-]</label><label class="expand" for="c-40389764">[7 more]</label></div><br/><div class="children"><div class="content">I got the same problem.<p>When implementing the exact method as described in quanta magazine (without looking at the arxiv paper), I always had estimates like 461746372167462146216468796214962164.<p>Then after reading the arxiv paper, I got the the correct estimate, with this code (very close to mudiadamz&#x27;s comment solution):<p><pre><code>    import numpy as np
    L = np.random.randint(0, 3900, 30557)
    print(f&quot;{len(set(L))=}&quot;)
    thresh = 100
    p = 1
    mem =  set()  
    for k in L:
        if k in mem:
            mem.remove(k)
        if np.random.rand() &lt; p:
            mem.add(k)
        if len(mem) == thresh:
            mem = {m for m in mem if np.random.rand() &lt; 0.5}
            p &#x2F;= 2
    print(f&quot;{len(mem)=} {p=} {len(mem)&#x2F;p=}&quot;)

</code></pre>
Or equivalently:<p><pre><code>    import numpy as np
    L = np.random.randint(0, 3900, 30557)
    print(f&quot;{len(set(L))=}&quot;)
    thresh = 100
    p = 1
    mem = []
    for k in L:
        if k not in mem:
            mem += [k]
        if np.random.rand() &gt; p:
            mem.remove(k)
        if len(mem) == thresh:
            mem = [m for m in mem if np.random.rand() &lt; 0.5]
            p &#x2F;= 2
    print(f&quot;{len(mem)=} {p=} {len(mem)&#x2F;p=}&quot;)

</code></pre>
Now I found the quanta magazine formulation problem. By reading:<p>&gt; Round 1. Keep going through Hamlet, adding new words as you go. If you come to a word that’s already on your list, flip a coin again. If it’s tails, delete the word; heads, and the word stays on the list. Proceed in this fashion until you have 100 words on the whiteboard. Then randomly delete about half again, based on the outcome of 100 coin tosses. That concludes Round 1.<p>we want to write:<p><pre><code>    for k in L:
        if k not in mem:
            mem += [k]
        else:
            if np.random.rand() &gt; p:
                mem.remove(k)
        if len(mem) == thresh:
            mem = [m for m in mem if np.random.rand() &lt; 0.5]
            p &#x2F;= 2
</code></pre>
whereas it should be (correct):<p><pre><code>    for k in L:
        if k not in mem:
            mem += [k]
        if np.random.rand() &gt; p:    # without the else
            mem.remove(k)
        if len(mem) == thresh:
            mem = [m for m in mem if np.random.rand() &lt; 0.5]
            p &#x2F;= 2
</code></pre>
Just this little &quot;else&quot; made it wrong!</div><br/><div id="40397197" class="c"><input type="checkbox" id="c-40397197" checked=""/><div class="controls bullet"><span class="by">kuldeepmeel</span><span>|</span><a href="#40389592">root</a><span>|</span><a href="#40389764">parent</a><span>|</span><a href="#40389854">next</a><span>|</span><label class="collapse" for="c-40397197">[-]</label><label class="expand" for="c-40397197">[1 more]</label></div><br/><div class="children"><div class="content">Yes, there is an error in the Quanta article [at the same time, I must add that writing popular science articles is very hard, so it would be wrong to blame them]<p>Your fix is indeed correct; we may want to have either while loop instead of &quot;if len(mem) == thresh&quot; as there is very small (but non-zero) probability that length of mem is still thresh after executing: 
mem = [m for m in mem if np.random.rand() &lt; 0.5]<p>[&quot;While&quot; was Knuth&#x27;s idea; and has added benefit of providing unbiased estimator.]</div><br/></div></div><div id="40389854" class="c"><input type="checkbox" id="c-40389854" checked=""/><div class="controls bullet"><span class="by">Alexanfa</span><span>|</span><a href="#40389592">root</a><span>|</span><a href="#40389764">parent</a><span>|</span><a href="#40397197">prev</a><span>|</span><a href="#40389870">next</a><span>|</span><label class="collapse" for="c-40389854">[-]</label><label class="expand" for="c-40389854">[4 more]</label></div><br/><div class="children"><div class="content">Quanta:<p><pre><code>    Round 1. Keep going through Hamlet, adding new words as you go. If you come to a word that’s already on your list, flip a coin again. If it’s tails, delete the word; heads, and the word stays on the list.

</code></pre>
To:<p><pre><code>    Round 1. Keep going through Hamlet, but now flipping a coin for each word. If it’s tails, delete the word if it exists; heads, and add the word  if it&#x27;s not already on the list.

</code></pre>
Old edit:<p><pre><code>    Round 1. Keep going through Hamlet, adding words but now flipping a coin immediately after adding it. If it’s tails, delete the word; heads, and the word stays on the list.</code></pre></div><br/><div id="40390029" class="c"><input type="checkbox" id="c-40390029" checked=""/><div class="controls bullet"><span class="by">josephernest</span><span>|</span><a href="#40389592">root</a><span>|</span><a href="#40389854">parent</a><span>|</span><a href="#40389870">next</a><span>|</span><label class="collapse" for="c-40390029">[-]</label><label class="expand" for="c-40390029">[3 more]</label></div><br/><div class="children"><div class="content">&gt; adding words but now flipping a coin immediately after adding it<p>Edit: I thought your formulation was correct but not really:<p>We flip the coin after adding, but we also flip the coin <i>even if we didn&#x27;t add the word</i> (because it was already there). This is subtle!<p>wrong:<p><pre><code>    if k not in mem:
        mem += [k]
        if np.random.rand() &gt; p:
            mem.remove(k)
</code></pre>
wrong:<p><pre><code>    if k not in mem:
        mem += [k]
    else:
        if np.random.rand() &gt; p:
            mem.remove(k)
</code></pre>
correct:<p><pre><code>    if k not in mem:
        mem += [k]
    if k in mem:      # not the same than &quot;else&quot; here
        if np.random.rand() &gt; p:
            mem.remove(k)
</code></pre>
correct:<p><pre><code>    if k not in mem:
        mem += [k]
    if np.random.rand() &gt; p:
        mem.remove(k)</code></pre></div><br/><div id="40397175" class="c"><input type="checkbox" id="c-40397175" checked=""/><div class="controls bullet"><span class="by">kuldeepmeel</span><span>|</span><a href="#40389592">root</a><span>|</span><a href="#40390029">parent</a><span>|</span><a href="#40390260">next</a><span>|</span><label class="collapse" for="c-40397175">[-]</label><label class="expand" for="c-40397175">[1 more]</label></div><br/><div class="children"><div class="content">The following is also not correct.<p><pre><code>    if k not in mem:
        mem += [k]
    if k in mem:      # not the same than &quot;else&quot; here
        if np.random.rand() &gt; p:
            mem.remove(k)
</code></pre>
Your final solution is indeed correct, and I think more elegant than what we had in our paper [I am one of the authors].</div><br/></div></div><div id="40390260" class="c"><input type="checkbox" id="c-40390260" checked=""/><div class="controls bullet"><span class="by">Alexanfa</span><span>|</span><a href="#40389592">root</a><span>|</span><a href="#40390029">parent</a><span>|</span><a href="#40397175">prev</a><span>|</span><a href="#40389870">next</a><span>|</span><label class="collapse" for="c-40390260">[-]</label><label class="expand" for="c-40390260">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I&#x27;m using a set instead of list so I just always add and then toss remove.</div><br/></div></div></div></div></div></div></div></div><div id="40389730" class="c"><input type="checkbox" id="c-40389730" checked=""/><div class="controls bullet"><span class="by">Alexanfa</span><span>|</span><a href="#40389592">parent</a><span>|</span><a href="#40389764">prev</a><span>|</span><a href="#40389878">next</a><span>|</span><label class="collapse" for="c-40389730">[-]</label><label class="expand" for="c-40389730">[2 more]</label></div><br/><div class="children"><div class="content">Was just now solving it and came to see if others had the same issue. Yep, you are right.<p><pre><code>    function generateRandomNumbers(c, n) {
      let randomNumbers = new Array(c);
      for (let i = 0; i &lt; randomNumbers.length; i++) {
        let randomNumber = Math.floor(Math.random() * (n + 1));
        randomNumbers[i] = randomNumber;
      }
      return randomNumbers;
    }
    function run(w, wS, m, r) {
        function round(r) {
            while(wS.size &lt; m) {
                const next = w.next()
                if (next.done) return true;
                wS.add(next.value)
                prune(next.value, r)
            }
            return false
        }
        function prune(v,r) {
            for (let i = 0; i &lt; r; i++) {
                const flip = new Boolean(Math.round(Math.random()))
                if (flip == false) {
                    wS.delete(v)
                }
            }
        }
        function purge(wS) {
            const copy = new Set(wS)
            copy.forEach(ith=&gt;{
                const flip = new Boolean(Math.round(Math.random()))
                if (flip == false) {
                    wS.delete(ith)
                }
            })
        }
        const done = round(r);
        if (!done) {
            purge(wS)
            return run(w, wS, r+1,m)
        }
        console.log(`Round ${r} done. ${wS.size} Estimate: ${wS.size &#x2F; (1&#x2F;Math.pow(2,r))}`)
    }
    const memory = 1000
    const words = generateRandomNumbers(3000000,15000)
    const w = words[Symbol.iterator]() &#x2F;&#x2F; create an iterator
    const wS = new Set();
    run(w,wS, memory,0);</code></pre></div><br/><div id="40391846" class="c"><input type="checkbox" id="c-40391846" checked=""/><div class="controls bullet"><span class="by">Alexanfa</span><span>|</span><a href="#40389592">root</a><span>|</span><a href="#40389730">parent</a><span>|</span><a href="#40389878">next</a><span>|</span><label class="collapse" for="c-40391846">[-]</label><label class="expand" for="c-40391846">[1 more]</label></div><br/><div class="children"><div class="content">Noticed an error;<p><pre><code>    return run(w, wS, r+1,m)
</code></pre>
Should be changed to:<p><pre><code>    return run(w, wS, m, r+1)</code></pre></div><br/></div></div></div></div></div></div><div id="40389878" class="c"><input type="checkbox" id="c-40389878" checked=""/><div class="controls bullet"><span class="by">jtanderson</span><span>|</span><a href="#40389592">prev</a><span>|</span><a href="#40387548">next</a><span>|</span><label class="collapse" for="c-40389878">[-]</label><label class="expand" for="c-40389878">[1 more]</label></div><br/><div class="children"><div class="content">Given the topic of the paper[0], the footnote is especially charming:<p>&gt; the authors decided to forgo the old convention of alphabetical ordering of authors in favor of a randomized ordering, denoted by r⃝. The publicly verifiable record of the randomization is available at <a href="https:&#x2F;&#x2F;www.aeaweb.org&#x2F;journals&#x2F;policies&#x2F;random-author-order&#x2F;search" rel="nofollow">https:&#x2F;&#x2F;www.aeaweb.org&#x2F;journals&#x2F;policies&#x2F;random-author-order...</a><p>[0]: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2301.10191" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2301.10191</a><p>edit: formatting</div><br/></div></div><div id="40387548" class="c"><input type="checkbox" id="c-40387548" checked=""/><div class="controls bullet"><span class="by">melq</span><span>|</span><a href="#40389878">prev</a><span>|</span><a href="#40387291">next</a><span>|</span><label class="collapse" for="c-40387548">[-]</label><label class="expand" for="c-40387548">[30 more]</label></div><br/><div class="children"><div class="content">Estimating the amount of unique elements in a set and counting the amount of unique elements in a set are very different things. Cool method, bad headline.</div><br/><div id="40389202" class="c"><input type="checkbox" id="c-40389202" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#40387548">parent</a><span>|</span><a href="#40394015">next</a><span>|</span><label class="collapse" for="c-40389202">[-]</label><label class="expand" for="c-40389202">[14 more]</label></div><br/><div class="children"><div class="content">They’re not <i>very</i> different things; the terms are used interchangeably in most contexts because in the real world all counting methods have some nonzero error rate.<p>We talk about ‘counting votes’ in elections, for example, yet when things are close we perform ‘recounts’ which we fully expect can produce slightly different numbers than the original count.<p>That means that vote counting is actually vote estimating, and recounting is just estimating with a tighter error bound.<p>I kind of think the mythology of the ‘countless stones’ (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Countless_stones" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Countless_stones</a>) is a sort of folk-reminder that you can never be too certain that you counted something right. Even something as big and solid and static as a standing stone.<p>The situations where counting is not estimating are limited to the mathematical, where you can assure yourself of exhaustively never missing any item or ever mistaking one thing’s identity for another’s.</div><br/><div id="40392591" class="c"><input type="checkbox" id="c-40392591" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40389202">parent</a><span>|</span><a href="#40389238">next</a><span>|</span><label class="collapse" for="c-40392591">[-]</label><label class="expand" for="c-40392591">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>the terms are used interchangeably in most contexts</i><p>Counting and estimating are not used interchangeably in most contexts.<p>&gt; <i>because in the real world all counting methods have some nonzero error rate.</i><p>The possibility that the counting process may be defective does not make it an estimation.<p>&gt; <i>We talk about ‘counting votes’ in elections, for example, yet when things are close we perform ‘recounts’ which we fully expect can produce slightly different numbers than the original count.</i><p>We talk about counting votes in elections because votes are counted. The fact that the process isn&#x27;t perfect is a defect; this does not make it estimation.<p>&gt; <i>That means that vote counting is actually vote estimating, and recounting is just estimating with a tighter error bound.</i><p>No. Exit polling is estimation. Vote counting is counting. Vote recounting is also counting, and does not necessarily impose a tighter error bound, nor necessarily derive a different number.<p>&gt; <i>The situations where counting is not estimating are limited to the mathematical, where you can assure yourself of exhaustively never missing any item or ever mistaking one thing’s identity for another’s.</i><p>So like, computers? Regardless, this is wrong. Estimating something and counting it are not the same thing. Estimation has uncertainty, counting may have error.<p>This is like saying addition estimates a sum because you might get it wrong. It&#x27;s just not true.</div><br/><div id="40392936" class="c"><input type="checkbox" id="c-40392936" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40392591">parent</a><span>|</span><a href="#40389238">next</a><span>|</span><label class="collapse" for="c-40392936">[-]</label><label class="expand" for="c-40392936">[3 more]</label></div><br/><div class="children"><div class="content">So, IEEE floating point doesn’t support ‘addition’ then.</div><br/><div id="40393215" class="c"><input type="checkbox" id="c-40393215" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40392936">parent</a><span>|</span><a href="#40389238">next</a><span>|</span><label class="collapse" for="c-40393215">[-]</label><label class="expand" for="c-40393215">[2 more]</label></div><br/><div class="children"><div class="content">IEEE 754 defines an exact binary result for the addition of any two floats.<p>That this bit-identical result is not the same operation as addition of real numbers is irrelevant, because floats aren&#x27;t reals.<p>f1 + f2 is not an estimation. Even treating it as an approximation will get you into trouble. It&#x27;s not that either, it&#x27;s a floating-point result, and algorithms making heavy use of floating point had better understand precisely what f1 + f2 is going to give you if they want to obtain maximum precision and accuracy.</div><br/><div id="40394550" class="c"><input type="checkbox" id="c-40394550" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40393215">parent</a><span>|</span><a href="#40389238">next</a><span>|</span><label class="collapse" for="c-40394550">[-]</label><label class="expand" for="c-40394550">[1 more]</label></div><br/><div class="children"><div class="content">Cool, so next time I have numbers that aren&#x27;t reals to perform math on, I can use floats.</div><br/></div></div></div></div></div></div></div></div><div id="40389238" class="c"><input type="checkbox" id="c-40389238" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40389202">parent</a><span>|</span><a href="#40392591">prev</a><span>|</span><a href="#40394015">next</a><span>|</span><label class="collapse" for="c-40389238">[-]</label><label class="expand" for="c-40389238">[9 more]</label></div><br/><div class="children"><div class="content">Come on. There is a fundamental difference between trying to get an exactly answer and not trying to get an exactly correct answer.</div><br/><div id="40389367" class="c"><input type="checkbox" id="c-40389367" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40389238">parent</a><span>|</span><a href="#40394015">next</a><span>|</span><label class="collapse" for="c-40389367">[-]</label><label class="expand" for="c-40389367">[8 more]</label></div><br/><div class="children"><div class="content">It’s not a fundamental difference, it’s a fundamental constraint.<p>There are circumstances - and in real life those circumstances are <i>very common</i> - where you must accept that getting an exactly correct answer is not realistic.  Yet nonetheless you want to ‘count’ things anyway.<p>We still call procedures for counting things under those circumstances ‘counting’.<p>The constraints on this problem (insufficient memory to remember all the unique items you encounter) are one such situation where even computerized counting isn’t going to be exact.</div><br/><div id="40390858" class="c"><input type="checkbox" id="c-40390858" checked=""/><div class="controls bullet"><span class="by">Levitz</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40389367">parent</a><span>|</span><a href="#40394056">next</a><span>|</span><label class="collapse" for="c-40390858">[-]</label><label class="expand" for="c-40390858">[4 more]</label></div><br/><div class="children"><div class="content">I agree with you, but we are talking theory here. The algorithm doesn&#x27;t count, it estimates.<p>You can make an algorithm that counts, you can make an algorithm that estimates, this is the second.</div><br/><div id="40392025" class="c"><input type="checkbox" id="c-40392025" checked=""/><div class="controls bullet"><span class="by">sangnoir</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40390858">parent</a><span>|</span><a href="#40394056">next</a><span>|</span><label class="collapse" for="c-40392025">[-]</label><label class="expand" for="c-40392025">[3 more]</label></div><br/><div class="children"><div class="content">Estimation <i>is</i> counting with error bars.<p>Frankly, most of what you consider counting in your comment needs error bars - ask anyone who operated an all-cash cash-register how frequently end-of-day reconciliation didn&#x27;t match the actual cash in the drawer (to the nearest dollar.)<p>The following is a list from my personal  experience - of presumably precisely countable things that didn&#x27;t turn out to be the case: the number of computers owned by an fairly large regional business, the number of (virtual) servers operated by a moderately sized team, the number of batteries sold in a financial year by a battery company.</div><br/><div id="40393657" class="c"><input type="checkbox" id="c-40393657" checked=""/><div class="controls bullet"><span class="by">shkkmo</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40392025">parent</a><span>|</span><a href="#40394056">next</a><span>|</span><label class="collapse" for="c-40393657">[-]</label><label class="expand" for="c-40393657">[2 more]</label></div><br/><div class="children"><div class="content">Counting is a subset of estimation, not a synonym.<p>If I estimated the number of quarters in a stack by weighing them, that would be different from estimating the number of quaters in a stack by counting them. Both methods of estimation have error bars.<p>The list you provide is of categories that don&#x27;t have clear definitions. If you have a sufficiently clear definition for a category given your population, it has a precise count (though your counting methodologies will still be estimates.) If your definition is too fuzzy, then you don&#x27;t actually have a countable set.</div><br/><div id="40397304" class="c"><input type="checkbox" id="c-40397304" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40393657">parent</a><span>|</span><a href="#40394056">next</a><span>|</span><label class="collapse" for="c-40397304">[-]</label><label class="expand" for="c-40397304">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s close enough to counting for the purposes of a magazine article like uuids are close enough to being unique for the purposes of programming.</div><br/></div></div></div></div></div></div></div></div><div id="40394056" class="c"><input type="checkbox" id="c-40394056" checked=""/><div class="controls bullet"><span class="by">seadan83</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40389367">parent</a><span>|</span><a href="#40390858">prev</a><span>|</span><a href="#40394015">next</a><span>|</span><label class="collapse" for="c-40394056">[-]</label><label class="expand" for="c-40394056">[3 more]</label></div><br/><div class="children"><div class="content">Counting and estimation are different by definition. One is a full enumeration, the latter an extrapolation from sampled data. In both cases &#x27;accuracy&#x27; is a factor. Even if we are counting the number of stars, it is still a difference of technique compared to estimating the number if stars.<p>I could try to count fibers in muscle or grains of sand in the beach, chances are accuracy would be low. One can be smart about technique for more accurate counts, eg: get 10M sand counters and give them each 1kg of sand which they then count the grains with tweezer and microscope. That is counting. At the same time, we could find an average count of grains in 1kg sand from a random 100 of our counters, and then estimate what an expected total would be. The estimate can be used to confirm the accuracy of the counts.</div><br/><div id="40395024" class="c"><input type="checkbox" id="c-40395024" checked=""/><div class="controls bullet"><span class="by">naijaboiler</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40394056">parent</a><span>|</span><a href="#40394779">next</a><span>|</span><label class="collapse" for="c-40395024">[-]</label><label class="expand" for="c-40395024">[1 more]</label></div><br/><div class="children"><div class="content">They are not really as far apart a you think. At small numbers, yes get are distinct. At large enough numbers, they in all practicality the same thing. E.g what’s the population of the US</div><br/></div></div><div id="40394779" class="c"><input type="checkbox" id="c-40394779" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40394056">parent</a><span>|</span><a href="#40395024">prev</a><span>|</span><a href="#40394015">next</a><span>|</span><label class="collapse" for="c-40394779">[-]</label><label class="expand" for="c-40394779">[1 more]</label></div><br/><div class="children"><div class="content">And by that definition this is a counting algorithm.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40394015" class="c"><input type="checkbox" id="c-40394015" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#40387548">parent</a><span>|</span><a href="#40389202">prev</a><span>|</span><a href="#40387753">next</a><span>|</span><label class="collapse" for="c-40394015">[-]</label><label class="expand" for="c-40394015">[4 more]</label></div><br/><div class="children"><div class="content">True - for (relatively) small numbers. For large (huge) numbers estimation is usually considered to be equivalent to counting, and the result is sometimes represented using the &quot;scientific&quot; notation (i.e. &quot;floating-point&quot;) rather than as an integer. For example, the mole is an integer whose value is only known approximately (and no one cares about the exact value anyway).</div><br/><div id="40394327" class="c"><input type="checkbox" id="c-40394327" checked=""/><div class="controls bullet"><span class="by">OutOfHere</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40394015">parent</a><span>|</span><a href="#40395656">next</a><span>|</span><label class="collapse" for="c-40394327">[-]</label><label class="expand" for="c-40394327">[2 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t justify estimation to be equivalent to counting even if some mathematicians consider them to be the same. Floating points are for estimation. Integers are for counting. The two are not the same, not even for large numbers.</div><br/><div id="40394347" class="c"><input type="checkbox" id="c-40394347" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40394327">parent</a><span>|</span><a href="#40395656">next</a><span>|</span><label class="collapse" for="c-40394347">[-]</label><label class="expand" for="c-40394347">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Equivalent&quot; and &quot;the same&quot; are sometimes equivalent. (Or the same.)<p><i>It depends on what the meaning of the word &#x27;is&#x27; is.</i><p><a href="https:&#x2F;&#x2F;libquotes.com&#x2F;bill-clinton&#x2F;quote&#x2F;lby0h7o" rel="nofollow">https:&#x2F;&#x2F;libquotes.com&#x2F;bill-clinton&#x2F;quote&#x2F;lby0h7o</a></div><br/></div></div></div></div><div id="40395656" class="c"><input type="checkbox" id="c-40395656" checked=""/><div class="controls bullet"><span class="by">YoshiRulz</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40394015">parent</a><span>|</span><a href="#40394327">prev</a><span>|</span><a href="#40387753">next</a><span>|</span><label class="collapse" for="c-40395656">[-]</label><label class="expand" for="c-40395656">[1 more]</label></div><br/><div class="children"><div class="content">As of May 2019, the mole has an exact value, and Carbon-12&#x27;s molar mass is the empirically-determined value.</div><br/></div></div></div></div><div id="40387753" class="c"><input type="checkbox" id="c-40387753" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#40387548">parent</a><span>|</span><a href="#40394015">prev</a><span>|</span><a href="#40387291">next</a><span>|</span><label class="collapse" for="c-40387753">[-]</label><label class="expand" for="c-40387753">[11 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an approximation, not an estimation.</div><br/><div id="40388223" class="c"><input type="checkbox" id="c-40388223" checked=""/><div class="controls bullet"><span class="by">blackkettle</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40387753">parent</a><span>|</span><a href="#40387789">next</a><span>|</span><label class="collapse" for="c-40388223">[-]</label><label class="expand" for="c-40388223">[2 more]</label></div><br/><div class="children"><div class="content">Actually, my understanding is that it is an estimation because in the given context we don&#x27;t know or cannot compute the true answer due to some kind of constraint (here memory or the size of |X|).  An approximation is when we use a simplified or rounded version of an exact number that we actually know.</div><br/><div id="40397273" class="c"><input type="checkbox" id="c-40397273" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40388223">parent</a><span>|</span><a href="#40387789">next</a><span>|</span><label class="collapse" for="c-40397273">[-]</label><label class="expand" for="c-40397273">[1 more]</label></div><br/><div class="children"><div class="content">Wikipedia is on your side:<p>&quot;In mathematics, approximation describes the process of finding estimates in the form of upper or lower bounds for a quantity that cannot readily be evaluated precisely&quot;<p>This process doesn&#x27;t use upper and lower bounds.<p>However, it still seems more like approximation than estimation to me because of this:<p>“Of course,” Variyam said, “if the [memory] is so big that it fits all the words, then we can get 100% accuracy.<p>It seems that in estimation the answer should be unknowable without additional information, whereas in this case it&#x27;s just a matter of resolution or granularity because of the memory size.<p>Anyhoo ...<p>EDIT: also the paper says &quot;estimate&quot; and the article says both &quot;approximate&quot; and &quot;estimate&quot; at different times so it seems everyone except me thinks it&#x27;s either an estimation or that estimation and approximation are interchangeable.</div><br/></div></div></div></div><div id="40387789" class="c"><input type="checkbox" id="c-40387789" checked=""/><div class="controls bullet"><span class="by">ranguna</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40387753">parent</a><span>|</span><a href="#40388223">prev</a><span>|</span><a href="#40389142">next</a><span>|</span><label class="collapse" for="c-40387789">[-]</label><label class="expand" for="c-40387789">[3 more]</label></div><br/><div class="children"><div class="content">Still very different things, no?</div><br/><div id="40387961" class="c"><input type="checkbox" id="c-40387961" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40387789">parent</a><span>|</span><a href="#40389142">next</a><span>|</span><label class="collapse" for="c-40387961">[-]</label><label class="expand" for="c-40387961">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the same thing at different degrees of accuracy. The goal is the same.</div><br/><div id="40388344" class="c"><input type="checkbox" id="c-40388344" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40387961">parent</a><span>|</span><a href="#40389142">next</a><span>|</span><label class="collapse" for="c-40388344">[-]</label><label class="expand" for="c-40388344">[1 more]</label></div><br/><div class="children"><div class="content">Still, counting things and counting unique things are two different procedures.</div><br/></div></div></div></div></div></div><div id="40389142" class="c"><input type="checkbox" id="c-40389142" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40387753">parent</a><span>|</span><a href="#40387789">prev</a><span>|</span><a href="#40388893">next</a><span>|</span><label class="collapse" for="c-40389142">[-]</label><label class="expand" for="c-40389142">[3 more]</label></div><br/><div class="children"><div class="content">For someone who&#x27;s pretty well-versed in English, but not a math-oriented computer scientist, this seems like a distinction without a difference. Please remedy my ignorance.</div><br/><div id="40389315" class="c"><input type="checkbox" id="c-40389315" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40389142">parent</a><span>|</span><a href="#40388893">next</a><span>|</span><label class="collapse" for="c-40389315">[-]</label><label class="expand" for="c-40389315">[2 more]</label></div><br/><div class="children"><div class="content">My GP was wrong, but the words are different.<p>Eatimation is a procedure the generates an estimate, which is a kind of approximation, while approximation is a result value.  They are different &quot;types&quot;, as a computer scientist would say. An approximation is any value that is justifiably considered to be nearly exact.  (&quot;prox&quot; means &quot;near&quot;. See also &quot;proximate&quot; and &quot;proxy&quot;.)<p>Estimation is one way to generate an approximation. An estimate is a subtype of an approximation. There are non-estimation ways to generate an approximation. For example, take an exact value and round it to the nearest multiple of 100. That generates an approximation, but does not use estimation.</div><br/><div id="40389722" class="c"><input type="checkbox" id="c-40389722" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40389315">parent</a><span>|</span><a href="#40388893">next</a><span>|</span><label class="collapse" for="c-40389722">[-]</label><label class="expand" for="c-40389722">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure the linguistic differences here are as cut and dried as you would like them to be. Estimate and approximate are both verbs, so you can derive nouns from them both for the process of doing the thing, and for the thing that results from such a process.<p>Estimation is the process of estimating. It produces an estimate.<p>Approximation is the process of approximating. It produces an approximation.<p>You can also derive adjectives from the verbs as well.<p>An estimate is an estimated value.<p>An approximation is an approximate value.<p>But you’re right that the ‘approximate’ terms make claims about the <i>result</i> - that it is in some way near to the correct value - while the
 ‘estimate’ derived terms all make a claim about the <i>process that produced the result</i> (ie that it was based on data that is known to be incomplete, uncertain, or approximate)</div><br/></div></div></div></div></div></div><div id="40388893" class="c"><input type="checkbox" id="c-40388893" checked=""/><div class="controls bullet"><span class="by">davidmurdoch</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40387753">parent</a><span>|</span><a href="#40389142">prev</a><span>|</span><a href="#40387291">next</a><span>|</span><label class="collapse" for="c-40388893">[-]</label><label class="expand" for="c-40388893">[2 more]</label></div><br/><div class="children"><div class="content">The authors of the article disagree with you.</div><br/><div id="40397242" class="c"><input type="checkbox" id="c-40397242" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#40387548">root</a><span>|</span><a href="#40388893">parent</a><span>|</span><a href="#40387291">next</a><span>|</span><label class="collapse" for="c-40397242">[-]</label><label class="expand" for="c-40397242">[1 more]</label></div><br/><div class="children"><div class="content">The authors of the paper disagree with me, the authors of the article don&#x27;t (they use both approximate and estimate, but the paper does say estimate).</div><br/></div></div></div></div></div></div></div></div><div id="40387291" class="c"><input type="checkbox" id="c-40387291" checked=""/><div class="controls bullet"><span class="by">akamoonknight</span><span>|</span><a href="#40387548">prev</a><span>|</span><a href="#40388982">next</a><span>|</span><label class="collapse" for="c-40387291">[-]</label><label class="expand" for="c-40387291">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know a word or phrase for this, but I really enjoy any examples of &quot;thinking outside the box&quot; like this because it&#x27;s something I struggle with in my professional career. Learning not only the right ways to solve problems, but figuring out the questions to ask that make solving the problems you have easier or even in some cases possible. In this case, it&#x27;s hey, we don&#x27;t need  exact numbers if we can define a probabilistic range given defined parameters. Other problems are gonna have other questions. I guess my hope is that if I see enough examples I&#x27;ll be able to eventually internalize the thought process and apply it correctly.</div><br/><div id="40389692" class="c"><input type="checkbox" id="c-40389692" checked=""/><div class="controls bullet"><span class="by">dentemple</span><span>|</span><a href="#40387291">parent</a><span>|</span><a href="#40387378">next</a><span>|</span><label class="collapse" for="c-40389692">[-]</label><label class="expand" for="c-40389692">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, this was a university research team.  Literally, a team of folks who can, all day everyday, iterate over a single topic using the Scientific Method.<p>If you were paid by a big company to sit at a whiteboard all day with a team of equally intelligent engineers, I&#x27;m sure you&#x27;d be come up with SOMETHING that would look like an &quot;outside the box&quot; solution to the rest of the world.<p>However, most of us are paid to work the JIRA factory line instead, which limits the amount of time we can spend experimenting on just one single problem.</div><br/></div></div><div id="40387378" class="c"><input type="checkbox" id="c-40387378" checked=""/><div class="controls bullet"><span class="by">wmwragg</span><span>|</span><a href="#40387291">parent</a><span>|</span><a href="#40389692">prev</a><span>|</span><a href="#40388982">next</a><span>|</span><label class="collapse" for="c-40387378">[-]</label><label class="expand" for="c-40387378">[4 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s generally thought of as &quot;lateral thinking&quot;, Edward de Bono has written a few books about it you might find interesting.</div><br/><div id="40387956" class="c"><input type="checkbox" id="c-40387956" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40387291">root</a><span>|</span><a href="#40387378">parent</a><span>|</span><a href="#40389293">next</a><span>|</span><label class="collapse" for="c-40387956">[-]</label><label class="expand" for="c-40387956">[1 more]</label></div><br/><div class="children"><div class="content">And some more commonplace words like &quot;creativity&quot; (as in &quot;creative solution&quot;) etc. would apply.</div><br/></div></div><div id="40389293" class="c"><input type="checkbox" id="c-40389293" checked=""/><div class="controls bullet"><span class="by">bzuker</span><span>|</span><a href="#40387291">root</a><span>|</span><a href="#40387378">parent</a><span>|</span><a href="#40387956">prev</a><span>|</span><a href="#40388982">next</a><span>|</span><label class="collapse" for="c-40389293">[-]</label><label class="expand" for="c-40389293">[2 more]</label></div><br/><div class="children"><div class="content">any particular one you&#x27;d recommend?</div><br/><div id="40395040" class="c"><input type="checkbox" id="c-40395040" checked=""/><div class="controls bullet"><span class="by">wmwragg</span><span>|</span><a href="#40387291">root</a><span>|</span><a href="#40389293">parent</a><span>|</span><a href="#40388982">next</a><span>|</span><label class="collapse" for="c-40395040">[-]</label><label class="expand" for="c-40395040">[1 more]</label></div><br/><div class="children"><div class="content">I think the classic is &quot;Lateral Thinking: A Textbook of Creativity&quot;</div><br/></div></div></div></div></div></div></div></div><div id="40388982" class="c"><input type="checkbox" id="c-40388982" checked=""/><div class="controls bullet"><span class="by">eterevsky</span><span>|</span><a href="#40387291">prev</a><span>|</span><a href="#40388551">next</a><span>|</span><label class="collapse" for="c-40388982">[-]</label><label class="expand" for="c-40388982">[5 more]</label></div><br/><div class="children"><div class="content">Computer scientists invent a memory-efficient way to estimate the size of a subset</div><br/><div id="40394150" class="c"><input type="checkbox" id="c-40394150" checked=""/><div class="controls bullet"><span class="by">seadan83</span><span>|</span><a href="#40388982">parent</a><span>|</span><a href="#40394094">prev</a><span>|</span><a href="#40389792">next</a><span>|</span><label class="collapse" for="c-40394150">[-]</label><label class="expand" for="c-40394150">[2 more]</label></div><br/><div class="children"><div class="content">The subset is very important, it is the subset of unique elements.</div><br/><div id="40394192" class="c"><input type="checkbox" id="c-40394192" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#40388982">root</a><span>|</span><a href="#40394150">parent</a><span>|</span><a href="#40389792">next</a><span>|</span><label class="collapse" for="c-40394192">[-]</label><label class="expand" for="c-40394192">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a &quot;subset,&quot; it&#x27;s &quot;the set of equivalence classes.&quot;</div><br/></div></div></div></div><div id="40389792" class="c"><input type="checkbox" id="c-40389792" checked=""/><div class="controls bullet"><span class="by">m3kw9</span><span>|</span><a href="#40388982">parent</a><span>|</span><a href="#40394150">prev</a><span>|</span><a href="#40388551">next</a><span>|</span><label class="collapse" for="c-40389792">[-]</label><label class="expand" for="c-40389792">[1 more]</label></div><br/><div class="children"><div class="content">It seems fast too as you can use less rounds of flips and get an estimate meaning you may not need to go thru the entire “book” to get an estimate of distinct words</div><br/></div></div></div></div><div id="40388551" class="c"><input type="checkbox" id="c-40388551" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#40388982">prev</a><span>|</span><a href="#40396771">next</a><span>|</span><label class="collapse" for="c-40388551">[-]</label><label class="expand" for="c-40388551">[2 more]</label></div><br/><div class="children"><div class="content">On the topic of counting things, I would like to mention this efficient and easily-implemented algorithm for finding the top-<i>k</i> items in a stream, which I think is perhaps not as well known as it should be:<p><i>A Simple Algorithm for Finding Frequent Elements in Streams and Bags</i><p><i>Karp, Shenker &amp; Papadimitriou</i><p><a href="https:&#x2F;&#x2F;www.cs.umd.edu&#x2F;~samir&#x2F;498&#x2F;karp.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.umd.edu&#x2F;~samir&#x2F;498&#x2F;karp.pdf</a></div><br/><div id="40389565" class="c"><input type="checkbox" id="c-40389565" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#40388551">parent</a><span>|</span><a href="#40396771">next</a><span>|</span><label class="collapse" for="c-40389565">[-]</label><label class="expand" for="c-40389565">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>the top-k items in a stream</i><p>Hmm, this is phrased in a way that sounds different (to my ears) than the abstract, which says:<p>&gt; <i>it is often desirable to identify from a very long sequence of symbols (or tuples, or packets) coming from a large alphabet those symbols whose frequency is above a given threshold</i><p>Your description suggests a finding fixed nr of k items, with the guarantee that it will be the top ones. The abstract sounds like if determines an a priori unknown number of items that meet the criteria of having a particular value greater than k.<p>So &quot;find the 100 oldest users&quot; vs &quot;find all users older than 30&quot;.<p>Am I misunderstanding you or the abstract? (English is not my first language)</div><br/></div></div></div></div><div id="40396771" class="c"><input type="checkbox" id="c-40396771" checked=""/><div class="controls bullet"><span class="by">igammarays</span><span>|</span><a href="#40388551">prev</a><span>|</span><a href="#40389460">next</a><span>|</span><label class="collapse" for="c-40396771">[-]</label><label class="expand" for="c-40396771">[1 more]</label></div><br/><div class="children"><div class="content">Can LLM’s invent a new simple  algorithm like this which it has never seen before? I tried to induce ChatGPT to invent this algorithm, giving it hints along the way, but it came up with something else that I’m unsure is correct. Then again, most humans wouldn’t be able to do that either. But how intelligent is AI if it can’t invent anything truly novel and significant?</div><br/></div></div><div id="40389460" class="c"><input type="checkbox" id="c-40389460" checked=""/><div class="controls bullet"><span class="by">mudiadamz</span><span>|</span><a href="#40396771">prev</a><span>|</span><a href="#40387212">next</a><span>|</span><label class="collapse" for="c-40389460">[-]</label><label class="expand" for="c-40389460">[32 more]</label></div><br/><div class="children"><div class="content">Python implementation:<p><pre><code>  def streaming_algorithm(A, epsilon, delta):
      # Initialize parameters
      p = 1
      X = set()
      thresh = math.ceil((12 &#x2F; epsilon ** 2) * math.log(8 * len(A) &#x2F; delta))

      # Process the stream
      for ai in A:
          if ai in X:
              X.remove(ai)
          if random.random() &lt; p:
              X.add(ai)
          if len(X) == thresh:
              X = {x for x in X if random.random() &gt;= 0.5}
              p &#x2F;= 2
              if len(X) == thresh:
                  return &#x27;⊥&#x27;

      return len(X) &#x2F; p


  # Example usage
  A = [1, 2, 3, 1, 2, 3]
  epsilon = 0.1
  delta = 0.01

  output = streaming_algorithm(A, epsilon, delta)
  print(output)</code></pre></div><br/><div id="40389666" class="c"><input type="checkbox" id="c-40389666" checked=""/><div class="controls bullet"><span class="by">ericmcer</span><span>|</span><a href="#40389460">parent</a><span>|</span><a href="#40395036">next</a><span>|</span><label class="collapse" for="c-40389666">[-]</label><label class="expand" for="c-40389666">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there is a single variable name or comment in this entire code block that conveys any information. Name stuff well! Especially if you want random strangers to gaze upon your code in wonder.</div><br/><div id="40389832" class="c"><input type="checkbox" id="c-40389832" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389666">parent</a><span>|</span><a href="#40389859">next</a><span>|</span><label class="collapse" for="c-40389832">[-]</label><label class="expand" for="c-40389832">[2 more]</label></div><br/><div class="children"><div class="content">The names are literally taken from the paper.</div><br/><div id="40391965" class="c"><input type="checkbox" id="c-40391965" checked=""/><div class="controls bullet"><span class="by">seaman1921</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389832">parent</a><span>|</span><a href="#40389859">next</a><span>|</span><label class="collapse" for="c-40391965">[-]</label><label class="expand" for="c-40391965">[1 more]</label></div><br/><div class="children"><div class="content">well the paper also contains the code so I doubt anyone who looked at the paper cares about this paste - for folks who did not read the paper this is not very readable</div><br/></div></div></div></div><div id="40389859" class="c"><input type="checkbox" id="c-40389859" checked=""/><div class="controls bullet"><span class="by">sneva</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389666">parent</a><span>|</span><a href="#40389832">prev</a><span>|</span><a href="#40389767">next</a><span>|</span><label class="collapse" for="c-40389859">[-]</label><label class="expand" for="c-40389859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Name stuff well<p>OP is following the same variable names of the article. I prefer that over changing the variable names and then figuring out what variable name maps in code to the article.</div><br/></div></div><div id="40389767" class="c"><input type="checkbox" id="c-40389767" checked=""/><div class="controls bullet"><span class="by">foobarian</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389666">parent</a><span>|</span><a href="#40389859">prev</a><span>|</span><a href="#40395036">next</a><span>|</span><label class="collapse" for="c-40389767">[-]</label><label class="expand" for="c-40389767">[3 more]</label></div><br/><div class="children"><div class="content">Speaking of, one of my favorite discoveries with Unicode is that there is a ton of code points acceptable for symbol identifiers in various languages that I just can&#x27;t wait to abuse.<p>&gt;&gt;&gt; ᚨ=3<p>&gt;&gt;&gt; ᛒ=6<p>&gt;&gt;&gt; ᚨ+ᛒ<p>9</div><br/><div id="40391264" class="c"><input type="checkbox" id="c-40391264" checked=""/><div class="controls bullet"><span class="by">8372049</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389767">parent</a><span>|</span><a href="#40391634">next</a><span>|</span><label class="collapse" for="c-40391264">[-]</label><label class="expand" for="c-40391264">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re even using a and b, very good.</div><br/></div></div><div id="40391634" class="c"><input type="checkbox" id="c-40391634" checked=""/><div class="controls bullet"><span class="by">pragma_x</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389767">parent</a><span>|</span><a href="#40391264">prev</a><span>|</span><a href="#40395036">next</a><span>|</span><label class="collapse" for="c-40391634">[-]</label><label class="expand" for="c-40391634">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, programming like the vikings intended.</div><br/></div></div></div></div></div></div><div id="40395036" class="c"><input type="checkbox" id="c-40395036" checked=""/><div class="controls bullet"><span class="by">abootstrapper</span><span>|</span><a href="#40389460">parent</a><span>|</span><a href="#40389666">prev</a><span>|</span><a href="#40389818">next</a><span>|</span><label class="collapse" for="c-40395036">[-]</label><label class="expand" for="c-40395036">[1 more]</label></div><br/><div class="children"><div class="content">New leetcode hard question just dropped.</div><br/></div></div><div id="40389818" class="c"><input type="checkbox" id="c-40389818" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#40389460">parent</a><span>|</span><a href="#40395036">prev</a><span>|</span><a href="#40389516">next</a><span>|</span><label class="collapse" for="c-40389818">[-]</label><label class="expand" for="c-40389818">[8 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not streaming if you&#x27;re already aware of the length of the iterable.</div><br/><div id="40391707" class="c"><input type="checkbox" id="c-40391707" checked=""/><div class="controls bullet"><span class="by">axitanull</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389818">parent</a><span>|</span><a href="#40389516">next</a><span>|</span><label class="collapse" for="c-40391707">[-]</label><label class="expand" for="c-40391707">[7 more]</label></div><br/><div class="children"><div class="content">In python, you can simply substitute `A` with an iterable or generator object, which can be a of unknown length.</div><br/><div id="40393759" class="c"><input type="checkbox" id="c-40393759" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40391707">parent</a><span>|</span><a href="#40392335">next</a><span>|</span><label class="collapse" for="c-40393759">[-]</label><label class="expand" for="c-40393759">[1 more]</label></div><br/><div class="children"><div class="content">I know that. See: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40390192">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40390192</a></div><br/></div></div><div id="40392335" class="c"><input type="checkbox" id="c-40392335" checked=""/><div class="controls bullet"><span class="by">mattkrause</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40391707">parent</a><span>|</span><a href="#40393759">prev</a><span>|</span><a href="#40389516">next</a><span>|</span><label class="collapse" for="c-40392335">[-]</label><label class="expand" for="c-40392335">[5 more]</label></div><br/><div class="children"><div class="content">But for this algorithm, you need to know the total length (&quot;m&quot;) to set the threshold for the register purges.<p>Does it still work if you update m as you go?</div><br/><div id="40393805" class="c"><input type="checkbox" id="c-40393805" checked=""/><div class="controls bullet"><span class="by">cb321</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40392335">parent</a><span>|</span><a href="#40393356">next</a><span>|</span><label class="collapse" for="c-40393805">[-]</label><label class="expand" for="c-40393805">[1 more]</label></div><br/><div class="children"><div class="content">Besides the ideas from istjohn, empath-nirvana, and rcarmo, you can also just &quot;flip the script&quot;: solve for epsilon and report that as 1-delta confidence interval for the worst case data distribution as here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40388878">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40388878</a><p>Best case error is of course zero, but if you look at my output then you will see as I did that the worst case is a very conservative bound (i.e. 15X bigger than what might &quot;tend to happen&quot;.  That matters a lot for &quot;space usage&quot; since the error =~ 1&#x2F;sqrt(space) implying you need a lot more space for lower errors.  15^2 = 225X more space.  Space optimization is usually well attended for this kind of problem.  And, hey, maybe you know something about the input data distribution?<p>So, in addition to the worst case bound, average case errors under various distributional scenarios would be very interesting.  Or even better &quot;measuring as you go&quot; enough distributional meta data to get a tighter error bound.  That latter starts to sound like it&#x27;s one of Knuth&#x27;s Hard Questions Which if You Solve He&#x27;ll Sign your PhD Thesis territory, though.  Maybe a starting point would be some kind of online entropy(distribution) estimation, perhaps inspired by <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2105.07408" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2105.07408</a> . And sure, maybe you need to bound the error ahead of time instead of inspecting it at any point in the stream.</div><br/></div></div><div id="40393356" class="c"><input type="checkbox" id="c-40393356" checked=""/><div class="controls bullet"><span class="by">istjohn</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40392335">parent</a><span>|</span><a href="#40393805">prev</a><span>|</span><a href="#40393164">next</a><span>|</span><label class="collapse" for="c-40393356">[-]</label><label class="expand" for="c-40393356">[1 more]</label></div><br/><div class="children"><div class="content">You would want to calculate the threshold by choosing your target epsilon and delta and an &#x27;m&#x27; equal to the largest conceivable size of the stream. Fortunately, the threshold increases with log(m), so it&#x27;s inexpensive to anticipate several orders of magnitude more data than necessary. If you wanted, you could work backwards to calculate the actual &#x27;epsilon&#x27; and &#x27;delta&#x27; values for the actual &#x27;m&#x27; of the stream after the fact.</div><br/></div></div><div id="40393164" class="c"><input type="checkbox" id="c-40393164" checked=""/><div class="controls bullet"><span class="by">empath-nirvana</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40392335">parent</a><span>|</span><a href="#40393356">prev</a><span>|</span><a href="#40389516">next</a><span>|</span><label class="collapse" for="c-40393164">[-]</label><label class="expand" for="c-40393164">[2 more]</label></div><br/><div class="children"><div class="content">You actually don&#x27;t need to do that part in the algorithm.  If you don&#x27;t know the length of the list, you can just choose a threshold that seems reasonable and calculate the margin of error after you&#x27;re done processing. (or i guess at whatever checkpoints you want if it&#x27;s continuous)<p>In this example, they have the length of the list and choose the threshold to give them a desired margin of error.</div><br/><div id="40393758" class="c"><input type="checkbox" id="c-40393758" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40393164">parent</a><span>|</span><a href="#40389516">next</a><span>|</span><label class="collapse" for="c-40393758">[-]</label><label class="expand" for="c-40393758">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40390192">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40390192</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40389516" class="c"><input type="checkbox" id="c-40389516" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#40389460">parent</a><span>|</span><a href="#40389818">prev</a><span>|</span><a href="#40389626">next</a><span>|</span><label class="collapse" for="c-40389516">[-]</label><label class="expand" for="c-40389516">[13 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  return &#x27;⊥&#x27;
</code></pre>
what&#x27;s this?</div><br/><div id="40390192" class="c"><input type="checkbox" id="c-40390192" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389516">parent</a><span>|</span><a href="#40389553">next</a><span>|</span><label class="collapse" for="c-40390192">[-]</label><label class="expand" for="c-40390192">[2 more]</label></div><br/><div class="children"><div class="content">An error condition. I decided to do away with it and take a small hit on the error by assuming the chances of the trimmed set being equal to the threshold are very small and that the error condition is effectively doing nothing.<p>I also changed the logic from == to &gt;= to trigger unfailingly, and pass in the &quot;window&quot;&#x2F;threshold to allow my code to work without internal awareness of the length of the iterable:<p><pre><code>    from random import random

    def estimate_uniques(iterable, window_size=100):
        p = 1
        seen = set()

        for i in iterable:
            if i not in seen:
                seen.add(i)
            if random() &gt; p:
                seen.remove(i)
            if len(seen) &gt;= window_size:
                seen = {s for s in seen if random() &lt; 0.5}
                p &#x2F;= 2
        return int(len(seen) &#x2F; p)
</code></pre>
I also didn&#x27;t like the possible &quot;set thrashing&quot; when an item is removed and re-added for high values of p, so I inverted the logic. This should work fine for any iterable.</div><br/></div></div><div id="40389553" class="c"><input type="checkbox" id="c-40389553" checked=""/><div class="controls bullet"><span class="by">jbaber</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389516">parent</a><span>|</span><a href="#40390192">prev</a><span>|</span><a href="#40389573">next</a><span>|</span><label class="collapse" for="c-40389553">[-]</label><label class="expand" for="c-40389553">[6 more]</label></div><br/><div class="children"><div class="content">In some symbolic logic classes, that character &quot;bottom&quot; represents &quot;false&quot; ad flipped &quot;top&quot; means true.<p>Don&#x27;t know what they&#x27;re getting at in the code, though.</div><br/><div id="40389672" class="c"><input type="checkbox" id="c-40389672" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389553">parent</a><span>|</span><a href="#40389639">next</a><span>|</span><label class="collapse" for="c-40389672">[-]</label><label class="expand" for="c-40389672">[4 more]</label></div><br/><div class="children"><div class="content">&gt;In some symbolic logic classes, that character &quot;bottom&quot; represents &quot;false&quot;<p>That&#x27;s unfortunate, because in the study of computer programming languages, it means &quot;undefined&quot; (raise an error).</div><br/><div id="40390548" class="c"><input type="checkbox" id="c-40390548" checked=""/><div class="controls bullet"><span class="by">tsss</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389672">parent</a><span>|</span><a href="#40397026">prev</a><span>|</span><a href="#40389639">next</a><span>|</span><label class="collapse" for="c-40390548">[-]</label><label class="expand" for="c-40390548">[2 more]</label></div><br/><div class="children"><div class="content">Not always. It is also the uninhabited bottom type.</div><br/><div id="40391007" class="c"><input type="checkbox" id="c-40391007" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40390548">parent</a><span>|</span><a href="#40389639">next</a><span>|</span><label class="collapse" for="c-40391007">[-]</label><label class="expand" for="c-40391007">[1 more]</label></div><br/><div class="children"><div class="content">My point is that there is a difference between a Python function&#x27;s returning false and the function&#x27;s raising an error, and sometimes the difference really matters, so it would be regrettable if logic teachers actually did use ⊥ to mean false because programming-language theorists use it to mean something whose only reasonable translation in the domain of practical programming is to raise an error.<p>I have no idea what your point is.</div><br/></div></div></div></div></div></div><div id="40389639" class="c"><input type="checkbox" id="c-40389639" checked=""/><div class="controls bullet"><span class="by">dentemple</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389553">parent</a><span>|</span><a href="#40389672">prev</a><span>|</span><a href="#40389573">next</a><span>|</span><label class="collapse" for="c-40389639">[-]</label><label class="expand" for="c-40389639">[1 more]</label></div><br/><div class="children"><div class="content">Once again proving the need for comments in code.  Especially for comments that are more useful than &quot;initialize parameters&quot;</div><br/></div></div></div></div><div id="40389573" class="c"><input type="checkbox" id="c-40389573" checked=""/><div class="controls bullet"><span class="by">martinsnow</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389516">parent</a><span>|</span><a href="#40389553">prev</a><span>|</span><a href="#40389608">next</a><span>|</span><label class="collapse" for="c-40389573">[-]</label><label class="expand" for="c-40389573">[3 more]</label></div><br/><div class="children"><div class="content">An easy way to identify who copies code without understanding it.</div><br/><div id="40389622" class="c"><input type="checkbox" id="c-40389622" checked=""/><div class="controls bullet"><span class="by">mudiadamz</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389573">parent</a><span>|</span><a href="#40389608">next</a><span>|</span><label class="collapse" for="c-40389622">[-]</label><label class="expand" for="c-40389622">[2 more]</label></div><br/><div class="children"><div class="content">You can just replace it with something like: print (&#x27;Invalid thresh or something&#x27;)</div><br/><div id="40392043" class="c"><input type="checkbox" id="c-40392043" checked=""/><div class="controls bullet"><span class="by">martinsnow</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389622">parent</a><span>|</span><a href="#40389608">next</a><span>|</span><label class="collapse" for="c-40392043">[-]</label><label class="expand" for="c-40392043">[1 more]</label></div><br/><div class="children"><div class="content">This however looks scary so an innocent copy&#x2F;paste programmer wouldn&#x27;t touch it.</div><br/></div></div></div></div></div></div></div></div><div id="40389626" class="c"><input type="checkbox" id="c-40389626" checked=""/><div class="controls bullet"><span class="by">sestep</span><span>|</span><a href="#40389460">parent</a><span>|</span><a href="#40389516">prev</a><span>|</span><a href="#40387212">next</a><span>|</span><label class="collapse" for="c-40389626">[-]</label><label class="expand" for="c-40389626">[2 more]</label></div><br/><div class="children"><div class="content">Is this ChatGPT? Also, I feel like this would be more useful if it included import statements.</div><br/><div id="40389633" class="c"><input type="checkbox" id="c-40389633" checked=""/><div class="controls bullet"><span class="by">mudiadamz</span><span>|</span><a href="#40389460">root</a><span>|</span><a href="#40389626">parent</a><span>|</span><a href="#40387212">next</a><span>|</span><label class="collapse" for="c-40389633">[-]</label><label class="expand" for="c-40389633">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  import math
  import random</code></pre></div><br/></div></div></div></div></div></div><div id="40387212" class="c"><input type="checkbox" id="c-40387212" checked=""/><div class="controls bullet"><span class="by">imoverclocked</span><span>|</span><a href="#40389460">prev</a><span>|</span><a href="#40388190">next</a><span>|</span><label class="collapse" for="c-40387212">[-]</label><label class="expand" for="c-40387212">[12 more]</label></div><br/><div class="children"><div class="content">When do we stop calling this counting and start calling it estimation?</div><br/><div id="40387490" class="c"><input type="checkbox" id="c-40387490" checked=""/><div class="controls bullet"><span class="by">card_zero</span><span>|</span><a href="#40387212">parent</a><span>|</span><a href="#40388196">next</a><span>|</span><label class="collapse" for="c-40387490">[-]</label><label class="expand" for="c-40387490">[2 more]</label></div><br/><div class="children"><div class="content">Seems this is one of those things like UUIDs where we rely on it being very unlikely to be wrong, because statistics.<p>&gt; the accuracy of this technique scales with the size of the memory.<p>I wonder if that&#x27;s proportional to the number of distinct items to count, though.<p>&gt; if the [memory] is so big that it fits all the words, then we can get 100% accuracy<p>Yes, but then the algorithm isn&#x27;t being used any more, that&#x27;s just normal counting.<p>They counted the distinct words in Hamlet with a memory size of 100 words, about 2.5% of the number to find, and got a result that was off by 2. If you do the same with the whole of Shakespeare, again using 2.5% of the memory needed to hold all the distinct words, is the accuracy better?<p>Anyway, this is limited to counting, and doesn&#x27;t help list what the words <i>are,</i> though quickly counting them first is perhaps a way to speed up the task of actually finding them?</div><br/></div></div><div id="40388196" class="c"><input type="checkbox" id="c-40388196" checked=""/><div class="controls bullet"><span class="by">BlackFly</span><span>|</span><a href="#40387212">parent</a><span>|</span><a href="#40387490">prev</a><span>|</span><a href="#40387272">next</a><span>|</span><label class="collapse" for="c-40388196">[-]</label><label class="expand" for="c-40388196">[1 more]</label></div><br/><div class="children"><div class="content">When it is actually impossible to count something and when the error between estimation and an exact answer is not significant the pedantic distinction is not helpful.<p>The same thing happens with measurement. No measurement is ever exact. If I said I was measuring a count, someone would probably correct to say that I am counting.<p>Common speech is like that.</div><br/></div></div><div id="40387272" class="c"><input type="checkbox" id="c-40387272" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40387212">parent</a><span>|</span><a href="#40388196">prev</a><span>|</span><a href="#40387264">next</a><span>|</span><label class="collapse" for="c-40387272">[-]</label><label class="expand" for="c-40387272">[6 more]</label></div><br/><div class="children"><div class="content">As soon as people start reading past the headline.</div><br/><div id="40387330" class="c"><input type="checkbox" id="c-40387330" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387272">parent</a><span>|</span><a href="#40387264">next</a><span>|</span><label class="collapse" for="c-40387330">[-]</label><label class="expand" for="c-40387330">[5 more]</label></div><br/><div class="children"><div class="content">tbh, the title (and introduction) did a lot to dissuade me from finishing the (really good) article. It was actually informative, why dress it as a SEO blogspam?</div><br/><div id="40387426" class="c"><input type="checkbox" id="c-40387426" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387330">parent</a><span>|</span><a href="#40387449">next</a><span>|</span><label class="collapse" for="c-40387426">[-]</label><label class="expand" for="c-40387426">[2 more]</label></div><br/><div class="children"><div class="content">Presumably so it is optimised for search engines and people find it.<p>Publishers generally have good data about where their audience comes from. They wouldn&#x27;t do this if it wasn&#x27;t the best way they know of to maximise readership.</div><br/><div id="40393374" class="c"><input type="checkbox" id="c-40393374" checked=""/><div class="controls bullet"><span class="by">a57721</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387426">parent</a><span>|</span><a href="#40387449">next</a><span>|</span><label class="collapse" for="c-40393374">[-]</label><label class="expand" for="c-40393374">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been following Quanta for some time, I&#x27;m sure they don&#x27;t care about SEO and number of visitors, they care about the quality of texts. They write for the general audience, and even though they try to preserve the scientific accuracy, sometimes their explanations may seem oversimplified and even a bit confusing when you come from the same field. It&#x27;s not clickbait, it&#x27;s their popular science style.</div><br/></div></div></div></div><div id="40387449" class="c"><input type="checkbox" id="c-40387449" checked=""/><div class="controls bullet"><span class="by">HDThoreaun</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387330">parent</a><span>|</span><a href="#40387426">prev</a><span>|</span><a href="#40389221">next</a><span>|</span><label class="collapse" for="c-40387449">[-]</label><label class="expand" for="c-40387449">[1 more]</label></div><br/><div class="children"><div class="content">So they can get paid for their work? Are you giving them anything?</div><br/></div></div><div id="40389221" class="c"><input type="checkbox" id="c-40389221" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387330">parent</a><span>|</span><a href="#40387449">prev</a><span>|</span><a href="#40387264">next</a><span>|</span><label class="collapse" for="c-40389221">[-]</label><label class="expand" for="c-40389221">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s Quanta. Their mission is to make laypeople like math (not understand math), so they drown the math in sugar.</div><br/></div></div></div></div></div></div><div id="40387264" class="c"><input type="checkbox" id="c-40387264" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#40387212">parent</a><span>|</span><a href="#40387272">prev</a><span>|</span><a href="#40388190">next</a><span>|</span><label class="collapse" for="c-40387264">[-]</label><label class="expand" for="c-40387264">[2 more]</label></div><br/><div class="children"><div class="content">Yes, even the subtile states &quot;a simple algorithm for estimating large numbers of distinct objects&quot;.</div><br/><div id="40388054" class="c"><input type="checkbox" id="c-40388054" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#40387212">root</a><span>|</span><a href="#40387264">parent</a><span>|</span><a href="#40388190">next</a><span>|</span><label class="collapse" for="c-40388054">[-]</label><label class="expand" for="c-40388054">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t excuse the title though.</div><br/></div></div></div></div></div></div><div id="40388190" class="c"><input type="checkbox" id="c-40388190" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40387212">prev</a><span>|</span><a href="#40387704">next</a><span>|</span><label class="collapse" for="c-40388190">[-]</label><label class="expand" for="c-40388190">[1 more]</label></div><br/><div class="children"><div class="content">&gt;What if you’re Facebook, and you want to count the number of distinct users who log in each day, even if some of them log in from multiple devices and at multiple times?<p>Seems like a bad example of when this algorithm could be useful in practice.<p>If you already know you will want this info when designing the login process, it&#x27;s simple: keep track of the date of last login for each account, and increment the unique user counter when the stored value is different from the current one.<p>And even if not, it should still be possible to &quot;replay&quot; a stream of login events from the database later to do this analysis. Unless maybe you already had years worth of data?</div><br/></div></div><div id="40387704" class="c"><input type="checkbox" id="c-40387704" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#40388190">prev</a><span>|</span><a href="#40389450">next</a><span>|</span><label class="collapse" for="c-40387704">[-]</label><label class="expand" for="c-40387704">[1 more]</label></div><br/><div class="children"><div class="content">HyperLogLog uses additions, it keeps sums. Thus, you can subtract one HLL sums from other. This is useful if stream supports deletion. Streams with deletions can be found in log-structured merge trees, for one example, so one can estimate count of distinct elements in all of the LSM tree hierarchy.<p>The algorithm in the paper does not allow for deletions.<p>Also, if one counts statistics of the stream of large elements (say, SHA-512 hashes, 64 bytes per hash), this algorithm requires some storage for elements from this stream, so memory requirement is O(table size * element size).</div><br/></div></div><div id="40389450" class="c"><input type="checkbox" id="c-40389450" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#40387704">prev</a><span>|</span><a href="#40393097">next</a><span>|</span><label class="collapse" for="c-40389450">[-]</label><label class="expand" for="c-40389450">[1 more]</label></div><br/><div class="children"><div class="content">From the paper [0]:<p>&gt; We state the following well-known concentration bound, Chernoff bound, for completeness.<p>Which variant of the Chernoff bound is this? This is almost the (looser variant of the) multiplicative form, but it&#x27;s not quite right (per the use of 1+delta instead of a single parameter beta). In particular, that bound is only guaranteed to hold for delta &gt;= 0 (not beta = 1 + delta &gt; 0 as asserted in the paper)<p>[0] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2301.10191" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2301.10191</a><p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chernoff_bound#Multiplicative_form_(relative_error)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chernoff_bound#Multiplicative_...</a><p>edit: to be clear: I&#x27;m not sure at all whether this breaks the proof of correctness, although I&#x27;m having a bit of difficulty following the actual details (I think I&#x27;d need to work through the intermediate steps on paper).</div><br/></div></div><div id="40393097" class="c"><input type="checkbox" id="c-40393097" checked=""/><div class="controls bullet"><span class="by">pierrebai</span><span>|</span><a href="#40389450">prev</a><span>|</span><a href="#40392639">next</a><span>|</span><label class="collapse" for="c-40393097">[-]</label><label class="expand" for="c-40393097">[1 more]</label></div><br/><div class="children"><div class="content">IDK, if my explanation is correct, but I do believe it is. I t goes as follow.<p>Imagine that you have a container of potential limitless capacity. The container starts with smalls capacity, equal to the real limited capacity that the real algorithm uses. As you add elements, when the container is full, its capacity is doubled, but all elements are then placed in a random position.<p>When you&#x27;re done, you&#x27;re told the occupancy of the subset of the large container corresponding to the initial size and how many times the container size was doubled. Multiplying that occupancy by the power of two of the number of doubling gives you an approximation of the real size.<p>The small catch is that in the actual algorithm, due to the discarding, the final number of elements, the occupancy, is somewhat erroneous.<p>EDIT<p>Another way to say this: you got a container of limited capacity S. When full, you &quot;virtually&quot; double its size and then randomly move elements over the full &quot;imaginary&quot; size of the virtual container. So after the first filling, you end up with about 1&#x2F;2 the elements. After the second filling 1&#x2F;4, etc. Also, since now your &quot;virtual&quot; container is larger, when you add a new element, there is only 1&#x2F;2^n the it will be place inside your limited-capacity view of the entire virtual container.<p>At the end, the approximate real count is the number of elements you got multiplied by 2 to the power of the number of size doubling.<p>Again, it is as if you have a small window into a limitless container.</div><br/></div></div><div id="40392639" class="c"><input type="checkbox" id="c-40392639" checked=""/><div class="controls bullet"><span class="by">burjui</span><span>|</span><a href="#40393097">prev</a><span>|</span><a href="#40387402">next</a><span>|</span><label class="collapse" for="c-40392639">[-]</label><label class="expand" for="c-40392639">[2 more]</label></div><br/><div class="children"><div class="content">The algorithm uses less memory, but more CPU time because of rather frequent deletions, so it&#x27;s a tradeoff, not just generally better algorithm, as article may suggest.</div><br/><div id="40393134" class="c"><input type="checkbox" id="c-40393134" checked=""/><div class="controls bullet"><span class="by">empath-nirvana</span><span>|</span><a href="#40392639">parent</a><span>|</span><a href="#40387402">next</a><span>|</span><label class="collapse" for="c-40393134">[-]</label><label class="expand" for="c-40393134">[1 more]</label></div><br/><div class="children"><div class="content">the list is small so the cost of deletions should be small.</div><br/></div></div></div></div><div id="40387402" class="c"><input type="checkbox" id="c-40387402" checked=""/><div class="controls bullet"><span class="by">saulrh</span><span>|</span><a href="#40392639">prev</a><span>|</span><a href="#40389081">next</a><span>|</span><label class="collapse" for="c-40387402">[-]</label><label class="expand" for="c-40387402">[1 more]</label></div><br/><div class="children"><div class="content">Huh, that&#x27;s a clever twist on reservoir sampling. Neat.</div><br/></div></div><div id="40387827" class="c"><input type="checkbox" id="c-40387827" checked=""/><div class="controls bullet"><span class="by">kromem</span><span>|</span><a href="#40389081">prev</a><span>|</span><a href="#40394414">next</a><span>|</span><label class="collapse" for="c-40387827">[-]</label><label class="expand" for="c-40387827">[2 more]</label></div><br/><div class="children"><div class="content">Ah, so Thanos was just conducting a census.</div><br/><div id="40389613" class="c"><input type="checkbox" id="c-40389613" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#40387827">parent</a><span>|</span><a href="#40394414">next</a><span>|</span><label class="collapse" for="c-40389613">[-]</label><label class="expand" for="c-40389613">[1 more]</label></div><br/><div class="children"><div class="content">I see what you did there.</div><br/></div></div></div></div><div id="40394414" class="c"><input type="checkbox" id="c-40394414" checked=""/><div class="controls bullet"><span class="by">u8</span><span>|</span><a href="#40387827">prev</a><span>|</span><a href="#40391109">next</a><span>|</span><label class="collapse" for="c-40394414">[-]</label><label class="expand" for="c-40394414">[1 more]</label></div><br/><div class="children"><div class="content">I took a crack at implementing this in Go. For anyone curious I settled for algorithm 2 as I can just use a map as the base set structure.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tristanisham&#x2F;f0">https:&#x2F;&#x2F;github.com&#x2F;tristanisham&#x2F;f0</a></div><br/></div></div><div id="40391109" class="c"><input type="checkbox" id="c-40391109" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#40394414">prev</a><span>|</span><a href="#40390880">next</a><span>|</span><label class="collapse" for="c-40391109">[-]</label><label class="expand" for="c-40391109">[1 more]</label></div><br/><div class="children"><div class="content">New interview question: Tell me how you would estimate the number of unique words in <i>Hamlet</i> using only 100 elements.</div><br/></div></div><div id="40390880" class="c"><input type="checkbox" id="c-40390880" checked=""/><div class="controls bullet"><span class="by">prerok</span><span>|</span><a href="#40391109">prev</a><span>|</span><a href="#40392367">next</a><span>|</span><label class="collapse" for="c-40390880">[-]</label><label class="expand" for="c-40390880">[1 more]</label></div><br/><div class="children"><div class="content">While the algorithm is interesting and I commend the authors for the algorithm, it should be noted that this is a guesstimate only. So, it&#x27;s not really an efficient way to count distinct values but an efficient way to get an approximate count of distinct values.</div><br/></div></div><div id="40392367" class="c"><input type="checkbox" id="c-40392367" checked=""/><div class="controls bullet"><span class="by">brianhorakh</span><span>|</span><a href="#40390880">prev</a><span>|</span><a href="#40387546">next</a><span>|</span><label class="collapse" for="c-40392367">[-]</label><label class="expand" for="c-40392367">[1 more]</label></div><br/><div class="children"><div class="content">Wondering if this approach could I found myself be applied to CFD (computational flow dynamics) methods to reduce the total volume of data points while still getting approximately close to the correct final answer?</div><br/></div></div><div id="40387546" class="c"><input type="checkbox" id="c-40387546" checked=""/><div class="controls bullet"><span class="by">hum3hum3</span><span>|</span><a href="#40392367">prev</a><span>|</span><a href="#40391034">next</a><span>|</span><label class="collapse" for="c-40387546">[-]</label><label class="expand" for="c-40387546">[1 more]</label></div><br/><div class="children"><div class="content">The counting&#x2F;estimstion technique is rather like a floating point number.  An integer exponent k and a mantissa of a population.</div><br/></div></div><div id="40391034" class="c"><input type="checkbox" id="c-40391034" checked=""/><div class="controls bullet"><span class="by">deadeye</span><span>|</span><a href="#40387546">prev</a><span>|</span><a href="#40389580">next</a><span>|</span><label class="collapse" for="c-40391034">[-]</label><label class="expand" for="c-40391034">[2 more]</label></div><br/><div class="children"><div class="content">Am I correct in thinking the accuracy of this method has more to do with the distribution in the sample than the algo itself.  Meaning, given a 100% unique list of items, how far off would this estimate be?</div><br/><div id="40391550" class="c"><input type="checkbox" id="c-40391550" checked=""/><div class="controls bullet"><span class="by">MarkusQ</span><span>|</span><a href="#40391034">parent</a><span>|</span><a href="#40389580">next</a><span>|</span><label class="collapse" for="c-40391550">[-]</label><label class="expand" for="c-40391550">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t appear to be heavily dependent on the distribution.  It mostly depends on how large your buffer is compared to the number of unique items in the list.  If the buffer is the same size or larger, it would be exact.  If it&#x27;s half the size needed to hold all the unique items, you drop O(1 bit) of precision; at one quarter, O(2 bits), etc.</div><br/></div></div></div></div><div id="40389580" class="c"><input type="checkbox" id="c-40389580" checked=""/><div class="controls bullet"><span class="by">klaussilveira</span><span>|</span><a href="#40391034">prev</a><span>|</span><a href="#40388070">next</a><span>|</span><label class="collapse" for="c-40389580">[-]</label><label class="expand" for="c-40389580">[1 more]</label></div><br/><div class="children"><div class="content">This actually comes at a good time. I&#x27;m currently refactoring a system that counts visits using inserts into a table, with a tuple of date and IP. I was planning to replace it with a HLL approach, but this is really interesting.</div><br/></div></div><div id="40390968" class="c"><input type="checkbox" id="c-40390968" checked=""/><div class="controls bullet"><span class="by">unbalancedevh</span><span>|</span><a href="#40388070">prev</a><span>|</span><label class="collapse" for="c-40390968">[-]</label><label class="expand" for="c-40390968">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how the error changes if you start a new round just before finishing the stream, compared to if the last word in the stream just fills the buffer and ends a round.</div><br/></div></div></div></div></div></div></div></body></html>