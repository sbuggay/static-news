<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738227667500" as="style"/><link rel="stylesheet" href="styles.css?v=1738227667500"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://thenewstack.io/from-c-to-clojure-new-language-promises-best-of-both/">From C++ to Clojure: Jank language promises best of both</a> <span class="domain">(<a href="https://thenewstack.io">thenewstack.io</a>)</span></div><div class="subtext"><span>Jeaye</span> | <span>49 comments</span></div><br/><div><div id="42872858" class="c"><input type="checkbox" id="c-42872858" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#42876079">next</a><span>|</span><label class="collapse" for="c-42872858">[-]</label><label class="expand" for="c-42872858">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very excited for Jank, I wish the creator well.<p>If I could make one tiny plea, it would be to focus on tooling too, and ensuring the experience for someone trying Jank out is as smooth as possible. Don&#x27;t assume everyone is already set up with paredit and can fire off emacs chords without a thought. I suspect that Jank will be of particular interest to C++ programmers, many of whom are used to a very different dev paradigm.<p>The Clojure community has done a great job at trying to smooth out the rough edges of Lisp tooling, and ensure there are on-ramps for newcomers (e.g. things like Calva for VS Code). I hope Jank keeps this up, because those first impressions really do matter. I&#x27;d hate to watch people bounce off Jank because they get stuck on trying to figure emacs out, or because they get frustrated trying to keep parentheses matched in Notepad.</div><br/><div id="42873613" class="c"><input type="checkbox" id="c-42873613" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#42872858">parent</a><span>|</span><a href="#42873459">next</a><span>|</span><label class="collapse" for="c-42873613">[-]</label><label class="expand" for="c-42873613">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re absolutely right. To start with, I&#x27;m focusing on capturing and converting existing Clojure devs. However, there&#x27;s a very large pool of C++ devs who could benefit from jank. As you said, jank not only needs to be ready for them, they need to be educated on lisps, functional programming, data-oriented programming, REPL-based interactive development, etc. It&#x27;s not an easy learning curve right now, into Clojure.<p>I aim to focus a good deal of time, post jank&#x27;s launch, to create materials which enable this. Materials specifically targeted at OOP devs coming from the native space.</div><br/><div id="42875040" class="c"><input type="checkbox" id="c-42875040" checked=""/><div class="controls bullet"><span class="by">butterisgood</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42873613">parent</a><span>|</span><a href="#42874262">next</a><span>|</span><label class="collapse" for="c-42875040">[-]</label><label class="expand" for="c-42875040">[1 more]</label></div><br/><div class="children"><div class="content">I can imagine Jank being incredible “glue” to start until it takes over by osmosis. (For c++ of course)<p>Maybe I should play some advent of code games with it to get comfy!</div><br/></div></div></div></div><div id="42873459" class="c"><input type="checkbox" id="c-42873459" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#42872858">parent</a><span>|</span><a href="#42873613">prev</a><span>|</span><a href="#42873926">next</a><span>|</span><label class="collapse" for="c-42873459">[-]</label><label class="expand" for="c-42873459">[1 more]</label></div><br/><div class="children"><div class="content">This seems like an opportunity to plug the good work <a href="https:&#x2F;&#x2F;www.clojuriststogether.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.clojuriststogether.org&#x2F;</a> do. They do good work. Plug concludes.<p>Clojure - like many languages - seems to be benefiting a lot from the work the IDE people have been putting in to good infrastructure. A lot of the magic is being moved out of Emacs towards tools like Treesitter and the LSP server which are more platform independent. Not a huge amount to do with Clojure per say, but the Clojure ecosystem is benefiting a lot from it. The Emacs specific stuff is becoming very Emacs-specific (like paraedit, bless its socks).</div><br/></div></div><div id="42873926" class="c"><input type="checkbox" id="c-42873926" checked=""/><div class="controls bullet"><span class="by">ab5tract</span><span>|</span><a href="#42872858">parent</a><span>|</span><a href="#42873459">prev</a><span>|</span><a href="#42876079">next</a><span>|</span><label class="collapse" for="c-42873926">[-]</label><label class="expand" for="c-42873926">[11 more]</label></div><br/><div class="children"><div class="content">The “use emacs” prerequisite that shows up frequently when exploring Lisps has been such a dealbreaker for me in the past. I have no patience for learning “chords” or even using a non-modal-but-still-not-just-normal-input editor simply to explore a language.  My impression being that these chords morph depending on “modes” doesn’t help at all. At least with vim you can learn a piece at a time (sorry, not trying to revive  last century’s favorite flame war, but it’s true).<p>Also: no one has managed to explain to me what makes emacs so uniquely capable of interacting with a running interpreter, despite this usually being the USP I hear for “needing” emacs when attempting to Lisp.</div><br/><div id="42875669" class="c"><input type="checkbox" id="c-42875669" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42873926">parent</a><span>|</span><a href="#42874000">next</a><span>|</span><label class="collapse" for="c-42875669">[-]</label><label class="expand" for="c-42875669">[2 more]</label></div><br/><div class="children"><div class="content">The proper answer for Lisps should be use Allegro or LispWorks, which actually provide a full blown environment as Lisp environments of by gone eras.<p>Does vim display inline graphics in a repl, with editing capabilities?<p>This is one of the basic features of classical graphical Lisp environments from the 1980&#x27;s, IPython and Jupyter notebooks, or better, Mathematica are only building upon this.<p>Emacs and vim are not quite at the same experience level.</div><br/><div id="42876111" class="c"><input type="checkbox" id="c-42876111" checked=""/><div class="controls bullet"><span class="by">disgruntledphd2</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42875669">parent</a><span>|</span><a href="#42874000">next</a><span>|</span><label class="collapse" for="c-42876111">[-]</label><label class="expand" for="c-42876111">[1 more]</label></div><br/><div class="children"><div class="content">Org mode in emacs does this. It&#x27;s a little clunky but it definitely works (better than notebooks IMO).</div><br/></div></div></div></div><div id="42874000" class="c"><input type="checkbox" id="c-42874000" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42873926">parent</a><span>|</span><a href="#42875669">prev</a><span>|</span><a href="#42875860">next</a><span>|</span><label class="collapse" for="c-42874000">[-]</label><label class="expand" for="c-42874000">[6 more]</label></div><br/><div class="children"><div class="content">As the guy building jank, I agree with you about emacs, chords, etc. I&#x27;m a vimmer and I can tell you that Clojure is superb in Vim land (Conjure), VS Code land (Calva), Emacs land (??? some major mode), and IntelliJ land (Cursive).</div><br/><div id="42875546" class="c"><input type="checkbox" id="c-42875546" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42874000">parent</a><span>|</span><a href="#42874105">next</a><span>|</span><label class="collapse" for="c-42875546">[-]</label><label class="expand" for="c-42875546">[2 more]</label></div><br/><div class="children"><div class="content">realistically, it&#x27;s the REPL, not the editor, that makes lisp what it is - not just having a repl running, but to have your app be part of the repl, and you develop it bit by bit.<p>The javascript&#x2F;UI people have found live reloading&#x2F;editing to be a game changer, but this has been the case for lisp development since...well, the beginning!</div><br/><div id="42875651" class="c"><input type="checkbox" id="c-42875651" checked=""/><div class="controls bullet"><span class="by">fmbb</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42875546">parent</a><span>|</span><a href="#42874105">next</a><span>|</span><label class="collapse" for="c-42875651">[-]</label><label class="expand" for="c-42875651">[1 more]</label></div><br/><div class="children"><div class="content">Live reloading (recompiling per method, editing values in your live runtime image) has been with UI development since since the beginning of GUIs. Smalltalk is great.<p>The 90s with C++ and Java broke with history. Thankfully the rise of web apps has given us iteration speed back!</div><br/></div></div></div></div><div id="42874105" class="c"><input type="checkbox" id="c-42874105" checked=""/><div class="controls bullet"><span class="by">ab5tract</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42874000">parent</a><span>|</span><a href="#42875546">prev</a><span>|</span><a href="#42874277">next</a><span>|</span><label class="collapse" for="c-42874105">[-]</label><label class="expand" for="c-42874105">[2 more]</label></div><br/><div class="children"><div class="content">Awesome to read this!<p>Since I’ve got you here, can I ask you for your thoughts on LispE and how it contrasts with jank’s approach? It seems clear that they both arrive from different lineages of the Lisp kingdom. LispE is also found dangling a few toes at depth within the icy waters of array programming.<p>Perhaps the only connection between the two is that the one makes me think of the other. But if there’s more, though, I’d love to read about it.</div><br/><div id="42874704" class="c"><input type="checkbox" id="c-42874704" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42874105">parent</a><span>|</span><a href="#42874277">next</a><span>|</span><label class="collapse" for="c-42874704">[-]</label><label class="expand" for="c-42874704">[1 more]</label></div><br/><div class="children"><div class="content">This is the first I&#x27;ve seen of LispE, so not a very informed opinion.<p>Different lineages, for sure. Clojure really stands on its own in the lisp world and some die-hard lispers claim that it&#x27;s not a lisp at all. However, for Clojure devs, I think we generally aren&#x27;t interested in using the other lisps in practice, for building practical software. We just appreciate them for their lispiness. So the main difference will be that LispE is more like CL than like Clojure.<p>Aside from that, LispE is interpreted, whereas jank is JIT compiled with full AOT compilation support, using LLVM. By using Clang&#x2F;LLVM, jank also has full access to C++ interop, whereas most interpreted lisps are sandboxes on their own.<p>I&#x27;m not familiar with this side of traditional lisps very much. Someone may be able to jump in to embellish or correct.</div><br/></div></div></div></div></div></div><div id="42875860" class="c"><input type="checkbox" id="c-42875860" checked=""/><div class="controls bullet"><span class="by">pritambaral</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42873926">parent</a><span>|</span><a href="#42874000">prev</a><span>|</span><a href="#42874179">next</a><span>|</span><label class="collapse" for="c-42875860">[-]</label><label class="expand" for="c-42875860">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also: no one has managed to explain to me what makes emacs so uniquely capable of interacting with a running interpreter, despite this usually being the USP I hear for “needing” emacs when attempting to Lisp.<p>As an Emacs user that has to work in teams of non-Emacs users, the answer to this boils down to culture and ecosystem maturity.<p>Purely technically, there&#x27;s nothing that Emacs allows me to do with REPL Driven Development that _couldn&#x27;t _ be done in another editor. Practically? I still haven&#x27;t been able to even get (sufficiently) started with any editor.<p>I often have to work on a Rails codebase that takes tens of seconds just to start. Dev cycles in the traditional Edit-Restart flow were so painful that I wished badly to burn this codebase down and rewrite it all in a language and style that supports a Lisp-style REPL. Then I discovered inf-ruby.el in Emacs. It allows me to just edit the code and reload only what&#x27;s changed. It automatically inserts the correct `module Xyz; ...; end` etc. No more restarts.<p>I showed it to my coworkers. They shared the pain with restarts. And yet, to this day, none of them have an equivalent to inf-ruby in their editors.<p>inf-ruby.el is less than 1400 lines of code. It&#x27;s easy enough to implement in Vim, IntelliJ, VS Code, anything really. But it exists only in Emacs, so far. Why? I&#x27;m sure because some Emacs user, once upon a time, wished similarly to have a more Lispy REPL for their Ruby dev work, and just built it. Because they were used to it, from having used Emacs or other Lisps with Emacs.<p>Compare that to when I first tried to support Common Lisp development on VS Code. A language that already has full support for REPL Driven Development with an interactive debugger built-in. Nope, we aren&#x27;t gonna use any of that, because in VS Code land, we use LSP. A model that really only works for languages that can be statically analyzed. You want Go To Definition on a method that&#x27;s included from a module and called on a receiver that&#x27;s a dynamic variable? Well, sucks to be you, I guess.<p>So, while people make do with the severe limitations of Solargraph or Ruby-LSP, I use robe.el — which adds lisp style code intelligence by running inside your Ruby process — and get code intelligence that actually works with a language as dynamic as Ruby. Again, robe.el was just there for me to use. Again, there&#x27;s nothing about Emacs that makes robe.el possible in Emacs but not in other editors. Again, there&#x27;s no equivalent to it (that I&#x27;ve found) in the ecosystems of other editors.</div><br/></div></div><div id="42874179" class="c"><input type="checkbox" id="c-42874179" checked=""/><div class="controls bullet"><span class="by">veqq</span><span>|</span><a href="#42872858">root</a><span>|</span><a href="#42873926">parent</a><span>|</span><a href="#42875860">prev</a><span>|</span><a href="#42876079">next</a><span>|</span><label class="collapse" for="c-42874179">[-]</label><label class="expand" for="c-42874179">[1 more]</label></div><br/><div class="children"><div class="content">&gt; what makes emacs so uniquely capable<p>Emacs is easily programmable (and in lisp), more unixy than modern Linux, like a whole operating system. Lispers make tools for it because it&#x27;s very easy for them. Lisp tools have been far advanced of others; LSP wasn&#x27;t initially adopted in Lisp communities because better tools (swank) were already around.</div><br/></div></div></div></div></div></div><div id="42876079" class="c"><input type="checkbox" id="c-42876079" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#42872858">prev</a><span>|</span><a href="#42872222">next</a><span>|</span><label class="collapse" for="c-42876079">[-]</label><label class="expand" for="c-42876079">[2 more]</label></div><br/><div class="children"><div class="content">Somehow I completely missed this. I mostly stopped using Clojure solely because of the JVM madness (yes, I know about babaskha, won’t use it due to the GraalVM dependency and possible Oracle tentacles lurking there) and have fallen back to things like Hy (which can be clunky but at least runs everywhere I have a Python interpreter). Something that has better Clojure-like syntax and uses LLVM aid very appealing, provided it can do (and serve) HTTP requests sanely and has enough batteries included.<p>Any good pointers to existing libraries to get a feel for the ecosystem?</div><br/><div id="42876131" class="c"><input type="checkbox" id="c-42876131" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#42876079">parent</a><span>|</span><a href="#42872222">next</a><span>|</span><label class="collapse" for="c-42876131">[-]</label><label class="expand" for="c-42876131">[1 more]</label></div><br/><div class="children"><div class="content">As far as I&#x27;m aware, jank isn&#x27;t at the point where libraries exist. It&#x27;s still under initial development and doesn&#x27;t implement all of Clojure just yet.</div><br/></div></div></div></div><div id="42872222" class="c"><input type="checkbox" id="c-42872222" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42876079">prev</a><span>|</span><a href="#42875811">next</a><span>|</span><label class="collapse" for="c-42872222">[-]</label><label class="expand" for="c-42872222">[1 more]</label></div><br/><div class="children"><div class="content">Related. Others?<p><i>I quit my job to work on my programming language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42658898">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42658898</a> - Jan 2025 (32 comments)<p><i>Jank: Programming Language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42477992">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42477992</a> - Dec 2024 (3 comments)<p><i>Jank is now running on LLVM IR</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42276672">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42276672</a> - Nov 2024 (16 comments)<p><i>Jank development update – Moving to LLVM IR</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41845669">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41845669</a> - Oct 2024 (49 comments)<p><i>The Jank Language: LLVM Hosted Clojure</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32493217">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32493217</a> - Aug 2022 (79 comments)</div><br/></div></div><div id="42875811" class="c"><input type="checkbox" id="c-42875811" checked=""/><div class="controls bullet"><span class="by">danbolt</span><span>|</span><a href="#42872222">prev</a><span>|</span><a href="#42872427">next</a><span>|</span><label class="collapse" for="c-42875811">[-]</label><label class="expand" for="c-42875811">[1 more]</label></div><br/><div class="children"><div class="content">I really appreciate the seamless rawdogging into C++ that this language provides. It’s the sort of ambition I’m here for.<p>Or, I find a lot of script runtimes in games have a strict boundary separating them from the native code (often for good reasons), but I wonder if we could integrate more tightly given static analysis has come a long way.</div><br/></div></div><div id="42872427" class="c"><input type="checkbox" id="c-42872427" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42875811">prev</a><span>|</span><a href="#42873171">next</a><span>|</span><label class="collapse" for="c-42872427">[-]</label><label class="expand" for="c-42872427">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not super familiar with this project, so forgive a bit of ignorance on this; what does this buy you over vanilla Clojure and native-image compiling with GraalVM.<p>This is a genuine question, not meant to dismiss the project!<p>ETA:<p>Sorry, further down the article answered my question:<p>&gt; “jank is also a good fit for any Clojure devs who want a lighter runtime without sacrificing JIT compilation, as they would if they used a Graal native image, or if they want easy access to native libraries for whatever reason.”</div><br/><div id="42873639" class="c"><input type="checkbox" id="c-42873639" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#42872427">parent</a><span>|</span><a href="#42872823">next</a><span>|</span><label class="collapse" for="c-42873639">[-]</label><label class="expand" for="c-42873639">[2 more]</label></div><br/><div class="children"><div class="content">The two biggest things are:<p>1. You get a native binary without sacrificing interactive programming. With a Graal native image, all of that goes away. With jank, you can still REPL in, change things, JIT compile code, etc.<p>2. You get Clojure -&gt; JVM level of seamless interop from jank -&gt; C++. I am pretty darn sure that this will be unprecedented, given the challenges of the native space (no standard reflection, differing ABIs, C++ templates, etc).<p>Aside from that, jank is making some huge quality of life improvements over Clojure JVM. I&#x27;ve shared some of this already, but I&#x27;ll have a post coming out EOQ which will demonstrate the difference in compiler errors between the two. It&#x27;s night and day.</div><br/><div id="42873689" class="c"><input type="checkbox" id="c-42873689" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42872427">root</a><span>|</span><a href="#42873639">parent</a><span>|</span><a href="#42872823">next</a><span>|</span><label class="collapse" for="c-42873689">[-]</label><label class="expand" for="c-42873689">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m looking forward to it; being able to utilize C and C++ libraries directly from Clojure is something that I could see being pretty valuable.<p>I&#x27;ve been debating trying my hand at making a simple game engine...it would be great if I could use a Lisp to do it.</div><br/></div></div></div></div><div id="42872823" class="c"><input type="checkbox" id="c-42872823" checked=""/><div class="controls bullet"><span class="by">joeevans1000</span><span>|</span><a href="#42872427">parent</a><span>|</span><a href="#42873639">prev</a><span>|</span><a href="#42873171">next</a><span>|</span><label class="collapse" for="c-42872823">[-]</label><label class="expand" for="c-42872823">[1 more]</label></div><br/><div class="children"><div class="content">You can compile a native program. Not one that requires the JVM. And it also interops with a number of more native graphical tools (as opposed to having other use things that require&#x2F;work-from java). To those coming to this thread who might not be familiar with Clojure: Clojure already can sit on top of javascript (as Clojurescript) and there was work making it work on top of, if I recall right, some of the C languages. But those latter ones don&#x27;t seem to be anywhere near the capabilities of this project.</div><br/></div></div></div></div><div id="42873171" class="c"><input type="checkbox" id="c-42873171" checked=""/><div class="controls bullet"><span class="by">vmsp</span><span>|</span><a href="#42872427">prev</a><span>|</span><a href="#42874123">next</a><span>|</span><label class="collapse" for="c-42873171">[-]</label><label class="expand" for="c-42873171">[4 more]</label></div><br/><div class="children"><div class="content">Looks similar to Clasp but implements Clojure instead of Common Lisp.<p><a href="https:&#x2F;&#x2F;clasp-developers.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;clasp-developers.github.io&#x2F;</a></div><br/><div id="42875199" class="c"><input type="checkbox" id="c-42875199" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42873171">parent</a><span>|</span><a href="#42875136">next</a><span>|</span><label class="collapse" for="c-42875199">[-]</label><label class="expand" for="c-42875199">[1 more]</label></div><br/><div class="children"><div class="content">Clasp is really cool but it’s a shame that it does not support Windows properly.  A lot of C++ is used on Windows.  I’ve seen this pattern repeated elsewhere — I think it has to do with Windows exception handling being different and complicated.  Hopefully jank does not suffer the same fate, since author is a gamedev!</div><br/></div></div><div id="42875136" class="c"><input type="checkbox" id="c-42875136" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42873171">parent</a><span>|</span><a href="#42875199">prev</a><span>|</span><a href="#42874081">next</a><span>|</span><label class="collapse" for="c-42875136">[-]</label><label class="expand" for="c-42875136">[1 more]</label></div><br/><div class="children"><div class="content">The Jank creator talking with folks at CERN about integrating with their C++ codebase makes sense too. Clasp was originally used to do some molecular simulation if memory recalls.</div><br/></div></div><div id="42874081" class="c"><input type="checkbox" id="c-42874081" checked=""/><div class="controls bullet"><span class="by">hatmatrix</span><span>|</span><a href="#42873171">parent</a><span>|</span><a href="#42875136">prev</a><span>|</span><a href="#42874123">next</a><span>|</span><label class="collapse" for="c-42874081">[-]</label><label class="expand" for="c-42874081">[1 more]</label></div><br/><div class="children"><div class="content">Good point. When Clojure first came out it was questioned whether it&#x27;s a lisp at all, but now I commonly hear many say it is the best Lisp.</div><br/></div></div></div></div><div id="42874123" class="c"><input type="checkbox" id="c-42874123" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#42873171">prev</a><span>|</span><a href="#42872180">next</a><span>|</span><label class="collapse" for="c-42874123">[-]</label><label class="expand" for="c-42874123">[3 more]</label></div><br/><div class="children"><div class="content">&gt;Seamless C++ interop<p>More detail would be appreciated, I&#x27;m not aware of any non-transpiling language that actually support full C++ RTTI&#x2F;exceptions interop.</div><br/><div id="42875920" class="c"><input type="checkbox" id="c-42875920" checked=""/><div class="controls bullet"><span class="by">pritambaral</span><span>|</span><a href="#42874123">parent</a><span>|</span><a href="#42875730">next</a><span>|</span><label class="collapse" for="c-42875920">[-]</label><label class="expand" for="c-42875920">[1 more]</label></div><br/><div class="children"><div class="content">Clasp, and implementation of Common Lisp in C++ on LLVM, has exceptions interop. The creator of Clasp even hooked up the Lisp GC to be able to automatically manage C++ objects. A compacting GC, mind, that automatically updates pointers to the managed C++ objects that it moves.</div><br/></div></div><div id="42875730" class="c"><input type="checkbox" id="c-42875730" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#42874123">parent</a><span>|</span><a href="#42875920">prev</a><span>|</span><a href="#42872180">next</a><span>|</span><label class="collapse" for="c-42875730">[-]</label><label class="expand" for="c-42875730">[1 more]</label></div><br/><div class="children"><div class="content">More detail to come. You&#x27;re right, it&#x27;s unprecedented.</div><br/></div></div></div></div><div id="42872180" class="c"><input type="checkbox" id="c-42872180" checked=""/><div class="controls bullet"><span class="by">Tcepsa</span><span>|</span><a href="#42874123">prev</a><span>|</span><a href="#42872531">next</a><span>|</span><label class="collapse" for="c-42872180">[-]</label><label class="expand" for="c-42872180">[1 more]</label></div><br/><div class="children"><div class="content">As a long-time fan of Clojure (I&#x27;ve been using it to varying degrees since 2008 and it is my favorite programming language) I&#x27;m really excited about the interpretability it sounds like this will open up!!</div><br/></div></div><div id="42872531" class="c"><input type="checkbox" id="c-42872531" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#42872180">prev</a><span>|</span><a href="#42874385">next</a><span>|</span><label class="collapse" for="c-42872531">[-]</label><label class="expand" for="c-42872531">[2 more]</label></div><br/><div class="children"><div class="content">Curious what the story is for slotting Jank into gaming. Seems like a fit for Unreal, but I really love the Component-Based-Architecture of Unity. Would you get it into your Unity project the same was as getting normal C++ into your project?</div><br/><div id="42872689" class="c"><input type="checkbox" id="c-42872689" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#42872531">parent</a><span>|</span><a href="#42874385">next</a><span>|</span><label class="collapse" for="c-42872689">[-]</label><label class="expand" for="c-42872689">[1 more]</label></div><br/><div class="children"><div class="content">jank can embed into any native program like lua would. But it the offers seamless interop back into C++, including the ability to instantiate new templates. So, anywhere lua is being embedded, jank could be used while providing a tighter integration to C++, interactive dev with a REPL, and proper lisp macros.</div><br/></div></div></div></div><div id="42874385" class="c"><input type="checkbox" id="c-42874385" checked=""/><div class="controls bullet"><span class="by">jwr</span><span>|</span><a href="#42872531">prev</a><span>|</span><a href="#42872907">next</a><span>|</span><label class="collapse" for="c-42874385">[-]</label><label class="expand" for="c-42874385">[1 more]</label></div><br/><div class="children"><div class="content">This is very cool and I intend to check on it from time to time. I use Clojure (and ClojureScript) all the time, and while performance on the JVM has never been an issue for me (the JVM is an impressive piece of engineering), I&#x27;m always on the lookout for new things!</div><br/></div></div><div id="42873944" class="c"><input type="checkbox" id="c-42873944" checked=""/><div class="controls bullet"><span class="by">systems</span><span>|</span><a href="#42872907">prev</a><span>|</span><a href="#42873727">next</a><span>|</span><label class="collapse" for="c-42873944">[-]</label><label class="expand" for="c-42873944">[2 more]</label></div><br/><div class="children"><div class="content">My only comment, there are must nicer system programming languages that could have been host, I am mainly thinking OCaml, as for me zig would have also been nicer than C++<p>My main objection to C++ is that in 2025 its not a language I would want to learn or use, nothing about its inherit qualities</div><br/><div id="42873981" class="c"><input type="checkbox" id="c-42873981" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#42873944">parent</a><span>|</span><a href="#42873727">next</a><span>|</span><label class="collapse" for="c-42873981">[-]</label><label class="expand" for="c-42873981">[1 more]</label></div><br/><div class="children"><div class="content">I hear you! There are millions upon millions of lines of C++ in production, though. C++ is still the de facto language in game dev and many other industries. I&#x27;d choose Rust over C++ for any greenfield project, but C++ isn&#x27;t going anywhere.<p>I&#x27;m starting with C++ interop but will aim to provide interop with other native langs going forward, thanks to LLVM.</div><br/></div></div></div></div><div id="42873727" class="c"><input type="checkbox" id="c-42873727" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#42873944">prev</a><span>|</span><a href="#42873368">next</a><span>|</span><label class="collapse" for="c-42873727">[-]</label><label class="expand" for="c-42873727">[1 more]</label></div><br/><div class="children"><div class="content">As someone who wants more in the space of Lisp-style languages with more interest in native, I&#x27;m going to be keeping an eye on Jank. Actually had this article recommended on my phone earlier.</div><br/></div></div><div id="42873368" class="c"><input type="checkbox" id="c-42873368" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#42873727">prev</a><span>|</span><a href="#42873042">next</a><span>|</span><label class="collapse" for="c-42873368">[-]</label><label class="expand" for="c-42873368">[2 more]</label></div><br/><div class="children"><div class="content">Very excited for jank. I&#x27;ve been hacking together my weekend projects in Common Lisp for roughly a year. I&#x27;ve been wanting to look at Clojure as a modern lisp, but I want no truck with the JVM.</div><br/><div id="42874700" class="c"><input type="checkbox" id="c-42874700" checked=""/><div class="controls bullet"><span class="by">cutler</span><span>|</span><a href="#42873368">parent</a><span>|</span><a href="#42873042">next</a><span>|</span><label class="collapse" for="c-42874700">[-]</label><label class="expand" for="c-42874700">[1 more]</label></div><br/><div class="children"><div class="content">JVM isn&#x27;t the only option. There&#x27;s nbb (Clojurescript for Node.js) and Babashka (Bash in Clojure). You can also use GraalVM for native compilation.</div><br/></div></div></div></div><div id="42873042" class="c"><input type="checkbox" id="c-42873042" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#42873368">prev</a><span>|</span><a href="#42872830">next</a><span>|</span><label class="collapse" for="c-42873042">[-]</label><label class="expand" for="c-42873042">[1 more]</label></div><br/><div class="children"><div class="content">super excited about the potential for native gui apps</div><br/></div></div><div id="42872830" class="c"><input type="checkbox" id="c-42872830" checked=""/><div class="controls bullet"><span class="by">joeevans1000</span><span>|</span><a href="#42873042">prev</a><span>|</span><a href="#42873531">next</a><span>|</span><label class="collapse" for="c-42872830">[-]</label><label class="expand" for="c-42872830">[1 more]</label></div><br/><div class="children"><div class="content">This. Is. Awesome. Please keep moving forward with it. If it works well it will be a total game changer.</div><br/></div></div><div id="42875692" class="c"><input type="checkbox" id="c-42875692" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#42873531">prev</a><span>|</span><label class="collapse" for="c-42875692">[-]</label><label class="expand" for="c-42875692">[4 more]</label></div><br/><div class="children"><div class="content">As an ex-clojure dev that picked up Rust, I have no interest in this as long as it doesn&#x27;t have ownership.<p>Once you used lexical scoping, you&#x27;re not going back to dynamic scope either, the same goes for the ability to reason about &quot;where an object currently is&quot; lexicographically.<p>I think Carp (<a href="https:&#x2F;&#x2F;github.com&#x2F;carp-lang&#x2F;Carp">https:&#x2F;&#x2F;github.com&#x2F;carp-lang&#x2F;Carp</a>) is a much more interesting contender for a native clojure, simply because it has lexical ownership.</div><br/><div id="42875808" class="c"><input type="checkbox" id="c-42875808" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#42875692">parent</a><span>|</span><a href="#42875785">next</a><span>|</span><label class="collapse" for="c-42875808">[-]</label><label class="expand" for="c-42875808">[1 more]</label></div><br/><div class="children"><div class="content">Cool, dude! I also dig Rust.<p>Carp is a very neat project, though it&#x27;s not a Clojure. It&#x27;s just Clojure-like. jank <i>is</i> Clojure.</div><br/></div></div><div id="42875785" class="c"><input type="checkbox" id="c-42875785" checked=""/><div class="controls bullet"><span class="by">Guthur</span><span>|</span><a href="#42875692">parent</a><span>|</span><a href="#42875808">prev</a><span>|</span><label class="collapse" for="c-42875785">[-]</label><label class="expand" for="c-42875785">[2 more]</label></div><br/><div class="children"><div class="content">I think if you&#x27;re overly using dynamic scoping in clojure you are probably doing it very wrong.<p>I used clojure professionally for a number of years and I can&#x27;t remember ever really using it.</div><br/><div id="42875990" class="c"><input type="checkbox" id="c-42875990" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42875692">root</a><span>|</span><a href="#42875785">parent</a><span>|</span><label class="collapse" for="c-42875990">[-]</label><label class="expand" for="c-42875990">[1 more]</label></div><br/><div class="children"><div class="content">Parent&#x27;s not talking about dynamic scoping in clojure.  It&#x27;s a comparison to designed to elicit a reaction, e.g. &quot;probably doing it very wrong&quot;.<p>I.e. if you&#x27;re not tracking ownership in new-lang, you&#x27;re probably doing it very wrong.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>