<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686560474982" as="style"/><link rel="stylesheet" href="styles.css?v=1686560474982"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.ralfj.de/blog/2023/06/02/tree-borrows.html">From Stacks to Trees: A new aliasing model for Rust</a> <span class="domain">(<a href="https://www.ralfj.de">www.ralfj.de</a>)</span></div><div class="subtext"><span>obl</span> | <span>32 comments</span></div><br/><div><div id="36286382" class="c"><input type="checkbox" id="c-36286382" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36289109">next</a><span>|</span><label class="collapse" for="c-36286382">[-]</label><label class="expand" for="c-36286382">[5 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m understanding correct, the major change here for Rust users (rather than people who hack on the compiler) is that mutable references will not be considered to be &quot;interfering&quot; with other references being made at the same time until they&#x27;re actually written to for the first time. This makes intuitive sense to me, but I suspect that there may be a bit of concern that this will make things more confusing when reading code and trying to understand what&#x27;s going on. I&#x27;d be lying if I said that thought didn&#x27;t occur to me, but at this point being surprised at how much I end up liking the way things turned out has become the norm for me; I remember having misgivings about nested import paths (rather than only being able to use `{`...`}` at the very end), match ergonomics, and `.await` as a postfix keyword but pretty quickly became glad they decided things the way they did after using each of them a bit when they finally got stabilized. I think I did realize that I&#x27;d like NLL (i.e. the borrow checker detecting the final use of a reference and not considering it as conflicting for the remainder of the scope) before it landed, but I know a lot of people had misgivings about that as well. I imagine this will be one of those things that in a few years will seem weird it wasn&#x27;t always how it worked!</div><br/><div id="36286786" class="c"><input type="checkbox" id="c-36286786" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#36286382">parent</a><span>|</span><a href="#36289109">next</a><span>|</span><label class="collapse" for="c-36286786">[-]</label><label class="expand" for="c-36286786">[4 more]</label></div><br/><div class="children"><div class="content">To be clear, this doesn&#x27;t change what programs get accepted by the borrow checker, so for most rust users it changes absolutely nothing.<p>It changes the abstract rules behind rust&#x27;s safety model, which impacts which unsafe functions are considered sound, and which optimizations the compiler is allowed to perform.</div><br/><div id="36287980" class="c"><input type="checkbox" id="c-36287980" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36286382">root</a><span>|</span><a href="#36286786">parent</a><span>|</span><a href="#36287875">next</a><span>|</span><label class="collapse" for="c-36287980">[-]</label><label class="expand" for="c-36287980">[1 more]</label></div><br/><div class="children"><div class="content">To expand a little on this, by pulling out one key piece of the article:<p>This is what the footnote of the bit about &amp;(i32, Cell&lt;i32&gt;) clarifies (which footnote was added due to this misunderstanding, discussed in <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;13y8a9b&#x2F;from_stacks_to_trees_a_new_aliasing_model_for_rust&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;13y8a9b&#x2F;from_stacks_t...</a>).<p>&gt; <i>In particular, for &amp;(i32, Cell&lt;i32&gt;), TB allows mutating both fields, including the first field which is a regular i32, since it just treats the entire reference as “this allows aliasing”.¹</i><p>&gt; <i>¹ This does not mean that we bless such mutation! It just means that the compiler cannot use immutability of the first field for its optimizations. Basically, immutability of that field becomes a safety invariant instead of a validity invariant […]</i><p>This matter of safety versus validity invariants is key (<a href="https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2018&#x2F;08&#x2F;22&#x2F;two-kinds-of-invariants.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2018&#x2F;08&#x2F;22&#x2F;two-kinds-of-invariants...</a>).</div><br/></div></div><div id="36287875" class="c"><input type="checkbox" id="c-36287875" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36286382">root</a><span>|</span><a href="#36286786">parent</a><span>|</span><a href="#36287980">prev</a><span>|</span><a href="#36289109">next</a><span>|</span><label class="collapse" for="c-36287875">[-]</label><label class="expand" for="c-36287875">[2 more]</label></div><br/><div class="children"><div class="content">Ah, I guess I did misunderstand then. I see now rereading that the &quot;don&#x27;t treat as a mutable borrow until first write&quot; is already how things behave today and have since NLL.</div><br/><div id="36289232" class="c"><input type="checkbox" id="c-36289232" checked=""/><div class="controls bullet"><span class="by">k1t</span><span>|</span><a href="#36286382">root</a><span>|</span><a href="#36287875">parent</a><span>|</span><a href="#36289109">next</a><span>|</span><label class="collapse" for="c-36289232">[-]</label><label class="expand" for="c-36289232">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not really true. If it were, this would compile since there are no writes.<p><pre><code>  fn main() {
    let mut x = [1,2,3,4,5];
    let y = &amp;mut x[0];
    let z = &amp;x[1];
    println!(&quot;y {}... z {} &quot;, y,  z);
  }
</code></pre>
But it doesn&#x27;t.</div><br/></div></div></div></div></div></div></div></div><div id="36289109" class="c"><input type="checkbox" id="c-36289109" checked=""/><div class="controls bullet"><span class="by">weitzj</span><span>|</span><a href="#36286382">prev</a><span>|</span><a href="#36286540">next</a><span>|</span><label class="collapse" for="c-36289109">[-]</label><label class="expand" for="c-36289109">[2 more]</label></div><br/><div class="children"><div class="content">I have not programmed Rust, yet. But this article gives me a feeling that this looks similar to database transactions. This might be wildly wrong but for me I see an analogy:<p>Once you get the &amp;mut reference, you have your tree, which then looks to me like you have created a transaction. An in this transaction context you do your things.</div><br/><div id="36289221" class="c"><input type="checkbox" id="c-36289221" checked=""/><div class="controls bullet"><span class="by">oslac</span><span>|</span><a href="#36289109">parent</a><span>|</span><a href="#36286540">next</a><span>|</span><label class="collapse" for="c-36289221">[-]</label><label class="expand" for="c-36289221">[1 more]</label></div><br/><div class="children"><div class="content">This is a good intuition, Rust&#x27;s references can be thought of as a r&#x2F;w locks.</div><br/></div></div></div></div><div id="36286540" class="c"><input type="checkbox" id="c-36286540" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#36289109">prev</a><span>|</span><a href="#36285543">next</a><span>|</span><label class="collapse" for="c-36286540">[-]</label><label class="expand" for="c-36286540">[9 more]</label></div><br/><div class="children"><div class="content">&gt; ...by the time x.len() gets executed, arg0 already exists...<p>So, I realize that this is the way that Java does it--and, presumably, one still doesn&#x27;t get fired for doing whatever Java does ;P--but, would it not actually make more sense for the arguments to be evaluated before the target reference, making the argument order more like Haskell&#x2F;Erlang (but very sadly not Elixir, which makes it awkwardly incompatible with Erlang and breaks some of the basic stuff like fold&#x2F;reduce)? Particularly so, given that, as far as I can tell from this example, what makes arg0 have the type that it does is the type of the function that hasn&#x27;t even been called yet? (As in, the semantic gap I am seeing between what the user probably meant and what the compiler wants to do is that &quot;x&quot; shouldn&#x27;t really be mutably-borrowed until the call happens, and the call here clearly shouldn&#x27;t happen until after the arguments are evaluated.) (Note: I do not program in Rust currently; I just have spent a number of decades analyzing languages and at times teaching college language design courses. I might be missing something obvious elsewhere that forces Rust to do this, but that one example, in isolation, at least feels like an unforced error.)</div><br/><div id="36286585" class="c"><input type="checkbox" id="c-36286585" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#36286540">parent</a><span>|</span><a href="#36288041">next</a><span>|</span><label class="collapse" for="c-36286585">[-]</label><label class="expand" for="c-36286585">[4 more]</label></div><br/><div class="children"><div class="content">In Rust, `reciever.some_method(whatever)` is supposed to be relatively thin sugar for `TypeOfReciever::some_method(receiver, whatever)`. So the evaluation order should be the same for those two forms.</div><br/><div id="36286649" class="c"><input type="checkbox" id="c-36286649" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#36286540">root</a><span>|</span><a href="#36286585">parent</a><span>|</span><a href="#36288041">next</a><span>|</span><label class="collapse" for="c-36286649">[-]</label><label class="expand" for="c-36286649">[3 more]</label></div><br/><div class="children"><div class="content">Sure, but I am saying it would actually have made more sense to put receiver as the last such argument--as one might expect from having used Haskell&#x2F;Erlang--given the other design decisions clearly in play here, as the target reference isn&#x27;t really the first argument for any obvious reason other than visual effect and some historical baggage from implementations of some object-oriented languages (including Java) with different constraints.</div><br/><div id="36287035" class="c"><input type="checkbox" id="c-36287035" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#36286540">root</a><span>|</span><a href="#36286649">parent</a><span>|</span><a href="#36288041">next</a><span>|</span><label class="collapse" for="c-36287035">[-]</label><label class="expand" for="c-36287035">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not wrong, but making self be the last argument would cause confusion for almost everyone coming from other languages, and for Rust it is too late to change that now. You could special case the behavior of the method call syntax to operate that way without breaking backwards compatibility (at the cost of making going back and forth between that syntax and the fully qualified call no longer being a straight forward syntactical transformation).</div><br/><div id="36287740" class="c"><input type="checkbox" id="c-36287740" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#36286540">root</a><span>|</span><a href="#36287035">parent</a><span>|</span><a href="#36288041">next</a><span>|</span><label class="collapse" for="c-36287740">[-]</label><label class="expand" for="c-36287740">[1 more]</label></div><br/><div class="children"><div class="content">It would still break backward compatibility.  As a trivial example,<p><pre><code>    {println!(&quot;first&quot;); 1u32}.wrapping_add({println!(&quot;second&quot;); 1});
</code></pre>
currently prints &quot;first&quot; before &quot;second&quot;, but would switch.<p>But this could theoretically be done at an edition boundary.</div><br/></div></div></div></div></div></div></div></div><div id="36288041" class="c"><input type="checkbox" id="c-36288041" checked=""/><div class="controls bullet"><span class="by">codesnik</span><span>|</span><a href="#36286540">parent</a><span>|</span><a href="#36286585">prev</a><span>|</span><a href="#36285543">next</a><span>|</span><label class="collapse" for="c-36288041">[-]</label><label class="expand" for="c-36288041">[4 more]</label></div><br/><div class="children"><div class="content">interesting. Can you expand on Elixir incompatibility? How is it different?</div><br/><div id="36289201" class="c"><input type="checkbox" id="c-36289201" checked=""/><div class="controls bullet"><span class="by">fredrikholm</span><span>|</span><a href="#36286540">root</a><span>|</span><a href="#36288041">parent</a><span>|</span><a href="#36285543">next</a><span>|</span><label class="collapse" for="c-36289201">[-]</label><label class="expand" for="c-36289201">[3 more]</label></div><br/><div class="children"><div class="content">Elixir does:<p><pre><code>  Enum.map(list, func)
</code></pre>
This is backwards to how partial application works:<p><pre><code>  def mapper(func), do: Enum.map(func)
  incrementer = mapper(fn x -&gt; x + 1 end)
  incrementer(list)
</code></pre>
It&#x27;s not the end of the world to not have it this way, but it removes a lot of patterns that are common in other functional languages.</div><br/><div id="36289662" class="c"><input type="checkbox" id="c-36289662" checked=""/><div class="controls bullet"><span class="by">bPspGiJT8Y</span><span>|</span><a href="#36286540">root</a><span>|</span><a href="#36289201">parent</a><span>|</span><a href="#36285543">next</a><span>|</span><label class="collapse" for="c-36289662">[-]</label><label class="expand" for="c-36289662">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t remove or break anything, it just changes the order of arguments to be compatible with Elixir&#x27;s (|&gt;) operator and consistent data-first design across the language.</div><br/><div id="36289754" class="c"><input type="checkbox" id="c-36289754" checked=""/><div class="controls bullet"><span class="by">fredrikholm</span><span>|</span><a href="#36286540">root</a><span>|</span><a href="#36289662">parent</a><span>|</span><a href="#36285543">next</a><span>|</span><label class="collapse" for="c-36289754">[-]</label><label class="expand" for="c-36289754">[1 more]</label></div><br/><div class="children"><div class="content">Definitely, I missed to mention that partial application via currying isn&#x27;t something you do in Erlang either.<p>If you did however, swapping the arguments would break most partial application patterns you see in languages like Haskell, OCaml, Elm and even JS.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36285543" class="c"><input type="checkbox" id="c-36285543" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#36286540">prev</a><span>|</span><label class="collapse" for="c-36285543">[-]</label><label class="expand" for="c-36285543">[15 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    fn two_phase(mut x: Vec&lt;usize&gt;) {
        let arg0 = &amp;mut x;
        let arg1 = Vec::len(&amp;x);
        Vec::push(arg0, arg1);
    }
</code></pre>
&gt; This code clearly violates the regular borrow checking rules since x is mutably borrowed to arg0 when we call x.len()! And yet, the compiler will accept this code<p>Does anybody else wish the compiler wouldn&#x27;t and would be even more verbose? I know one of the biggest learning curves (personally) for Rust is the borrow checker complaining hardcore and &quot;getting in your way&quot; preventing you from basically doing anything you&#x27;re used to (passing around pointers in C or objects in JavaScript (even though you should be following immutable practices and not doing object mutation... most of the time))<p>I&#x27;m sure there&#x27;s probably been discussions on how to make the borrow checker less &quot;mean&#x2F;rigid&#x2F;obtuse&quot; but silently passing something as &quot;non mut&quot; and it actually does &quot;mut&quot; stuff, I wouldn&#x27;t have guessed Rust allowed that.<p>Edit: gah, I did not realize the function signature is (mut x), I thought it was just (x) and the mut was implied which is what I was trying to call out, apologies.</div><br/><div id="36285735" class="c"><input type="checkbox" id="c-36285735" checked=""/><div class="controls bullet"><span class="by">denotational</span><span>|</span><a href="#36285543">parent</a><span>|</span><a href="#36285660">next</a><span>|</span><label class="collapse" for="c-36285735">[-]</label><label class="expand" for="c-36285735">[1 more]</label></div><br/><div class="children"><div class="content">The original code (which desugars to the snippet you posted) is:<p><pre><code>    fn two_phase(mut x: Vec&lt;usize&gt;) {
        x.push(x.len());
    }
</code></pre>
This should clearly be accepted (this is self evident in my opinion); if you need to jump through loops to write code like this then the language is too restrictive to write normal code.<p>The standard implementation of Rust does indeed accept this, and there is no soundness hole here.<p>The existing semantics for aliasing and borrowing from MPI (Stacked Borrows) don’t allow this, which means the semantics are overly restrictive; we <i>want</i> this to be accepted.<p>This work “fixes” this issue by extending the semantics to admit the behaviour exhibited by the standard implementation.<p>The rules for the borrow checker are not fully formalised and to some extent the rustc implementation <i>is</i> the specification; formalising the rules (i.e. RustBelt, Stacked Borrows, etc.) is important, but we don’t want to formalise something that is strictly more restrictive than the reference implementation, especially if there’s no soundness hole.</div><br/></div></div><div id="36285660" class="c"><input type="checkbox" id="c-36285660" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#36285543">parent</a><span>|</span><a href="#36285735">prev</a><span>|</span><a href="#36285657">next</a><span>|</span><label class="collapse" for="c-36285660">[-]</label><label class="expand" for="c-36285660">[1 more]</label></div><br/><div class="children"><div class="content">The borrow checker was made for correctness, not correctness for the borrow checker.<p>You have ownership of a Vec, you get its length, then you push to it through a mutable reference; nothing evil happens here except the order of the statements (which is an implementation detail that people might not think about when writing the short form x.push(x.len())). The code above is perfectly safe if written in C, which is why the borrow checker was extended to also allow it in Rust. You could make the argument that simpler borrow checker rules lead to a simpler mental model. The counterargument (that won in the end) is that &quot;if it&#x27;s safe, the borrow checker allows it&quot; is a mental model worth pursuing.</div><br/></div></div><div id="36285657" class="c"><input type="checkbox" id="c-36285657" checked=""/><div class="controls bullet"><span class="by">TazeTSchnitzel</span><span>|</span><a href="#36285543">parent</a><span>|</span><a href="#36285660">prev</a><span>|</span><a href="#36286220">next</a><span>|</span><label class="collapse" for="c-36285657">[-]</label><label class="expand" for="c-36285657">[1 more]</label></div><br/><div class="children"><div class="content">&gt; silently passing something as &quot;non mut&quot; and it actually does &quot;mut&quot; stuff<p>No, it&#x27;s the opposite that&#x27;s happening here: a mutable borrow of the vector is made, and then a non-mutable thing is done with it (getting the length), before finally mutating it (pushing).</div><br/></div></div><div id="36286220" class="c"><input type="checkbox" id="c-36286220" checked=""/><div class="controls bullet"><span class="by">Osiris</span><span>|</span><a href="#36285543">parent</a><span>|</span><a href="#36285657">prev</a><span>|</span><a href="#36285624">next</a><span>|</span><label class="collapse" for="c-36286220">[-]</label><label class="expand" for="c-36286220">[3 more]</label></div><br/><div class="children"><div class="content">I’ve been learning rust and I spend the vast majority of my time dealing with lifetimes and borrow checking. Common ways in used to doing things simply don’t work in rust and a lot of effort has to go into keeping track of how and where data is used.<p>I’ve worked in OOP languages, functional languages, and dynamic languages but all of them were essentially garbage collected, so having to keep track in my head of how data ownership is managed is a big learning curve.</div><br/><div id="36286375" class="c"><input type="checkbox" id="c-36286375" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36286220">parent</a><span>|</span><a href="#36285624">next</a><span>|</span><label class="collapse" for="c-36286375">[-]</label><label class="expand" for="c-36286375">[2 more]</label></div><br/><div class="children"><div class="content">As a c++ programmer, one of the great things about rust is that I no longer have to keep track of data ownership and management in head.<p>I can outsource this to the compiler and if I get it wrong the program won’t compile.<p>In c++ you still need to do all the same tracking and management if you want safe and correct programs, but you don’t get nearly as much help from the compiler if you make a mistake.</div><br/><div id="36286571" class="c"><input type="checkbox" id="c-36286571" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36286375">parent</a><span>|</span><a href="#36285624">next</a><span>|</span><label class="collapse" for="c-36286571">[-]</label><label class="expand" for="c-36286571">[1 more]</label></div><br/><div class="children"><div class="content">I think this is largely overblown if one uses modern C++. One of the things I do is stateful multi-threaded business servers and frankly comparatively to the overall project this &quot;data ownership maintenance&quot; is small to the point of being practically absent.</div><br/></div></div></div></div></div></div><div id="36285624" class="c"><input type="checkbox" id="c-36285624" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36285543">parent</a><span>|</span><a href="#36286220">prev</a><span>|</span><label class="collapse" for="c-36285624">[-]</label><label class="expand" for="c-36285624">[8 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;Does anybody else wish the compiler wouldn&#x27;t&quot;<p>Compiler being obtuse and not being able to figure when it is safe to &quot;break rules&quot; is the problem. Not twisting brain of the programmer into being &quot;safe compiler&quot;. This sounds like a Stockholm syndrome.<p>&gt;&quot;you should be following immutable practices&quot;<p>No I should not. I should do what makes sense in particular situation and not bending over for some zealots trying to enforce one and the only way.</div><br/><div id="36288116" class="c"><input type="checkbox" id="c-36288116" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36285624">parent</a><span>|</span><a href="#36286533">next</a><span>|</span><label class="collapse" for="c-36288116">[-]</label><label class="expand" for="c-36288116">[1 more]</label></div><br/><div class="children"><div class="content">In C++ or C, you are <i>always</i> twisting the brain of the programmer into being a &quot;safe compiler&quot;. I don&#x27;t think that is an advantage personally.<p>Lifetimes don&#x27;t go away just because there isn&#x27;t a borrow checker or way to define them in the source code.</div><br/></div></div><div id="36286533" class="c"><input type="checkbox" id="c-36286533" checked=""/><div class="controls bullet"><span class="by">neerajsi</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36285624">parent</a><span>|</span><a href="#36288116">prev</a><span>|</span><a href="#36286591">next</a><span>|</span><label class="collapse" for="c-36286533">[-]</label><label class="expand" for="c-36286533">[3 more]</label></div><br/><div class="children"><div class="content">I think one measurable outcome here is what kind of error message you get when you do violate a rule and whether rust users know what to do to fix their code. As a person who loves to explore the complexity behind seemingly simple interfaces, this stuff is really cool. On the other hand, I don&#x27;t relish having people break their brains to understand why similar code is accepted vs not.<p>I&#x27;m not a rust user myself, but I&#x27;m guessing from all the references to raw pointers that a lot of the code referenced here is actually not idiomatic for all but small snippets of high perf code, so maybe the complexity is not going to affect too many people.</div><br/><div id="36286605" class="c"><input type="checkbox" id="c-36286605" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36286533">parent</a><span>|</span><a href="#36286591">next</a><span>|</span><label class="collapse" for="c-36286605">[-]</label><label class="expand" for="c-36286605">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;so maybe the complexity is not going to affect too many people&quot;<p>I think this approach shows a high level of disrespect for users.</div><br/><div id="36288133" class="c"><input type="checkbox" id="c-36288133" checked=""/><div class="controls bullet"><span class="by">neerajsi</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36286605">parent</a><span>|</span><a href="#36286591">next</a><span>|</span><label class="collapse" for="c-36288133">[-]</label><label class="expand" for="c-36288133">[1 more]</label></div><br/><div class="children"><div class="content">I work with many people who are quite intelligent but early in their career or not domain experts in PL implementation. These people are perfectly respectable, but how long would it take to teach them how to map their source to the lifetime dependency tree with subtle rules in order to understand a borrow checker result that triggers an error? Without that understanding, a dev using rust would maybe try poking at their code unsystematically in hopes of getting it to work. I&#x27;ve seen this happen in other domains while people are ascending the learning curve.</div><br/></div></div></div></div></div></div><div id="36286591" class="c"><input type="checkbox" id="c-36286591" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36285624">parent</a><span>|</span><a href="#36286533">prev</a><span>|</span><label class="collapse" for="c-36286591">[-]</label><label class="expand" for="c-36286591">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Compiler being obtuse and not being able to figure when it is safe to &quot;break rules&quot; is the problem.<p>Compiler afaik will never be able to correctly 100% identify you are or aren&#x27;t breaking some properties due to Rice&#x27;s Theorem.<p>That said, you&#x27;re committing a Nirvana fallacy. Perfect doesn&#x27;t prevent improvement.<p>E.g. seatbelts don&#x27;t prevent being stabbed by a large metal pole, ergo it&#x27;s useless.<p>Every week I see newbies coming and asking why won&#x27;t compiler allow this - and then point a hugely unsafe action.<p>Hell, I ran into a similar issue. I wanted to expose something mutable as immutable. My argumentation was but it was immutable at time of calling. However as someone in Rust discord pointed, using that you could cause UB trivially.</div><br/><div id="36287427" class="c"><input type="checkbox" id="c-36287427" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36286591">parent</a><span>|</span><label class="collapse" for="c-36287427">[-]</label><label class="expand" for="c-36287427">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;Compiler afaik will never be able to correctly 100% identify&quot;<p>Nobody here is talking about 100%. I responded to a post that has left me with the impression that it is up to the user to bend backwards and make their brains work as a compiler rather than try to improve compiler.</div><br/><div id="36288009" class="c"><input type="checkbox" id="c-36288009" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#36285543">root</a><span>|</span><a href="#36287427">parent</a><span>|</span><label class="collapse" for="c-36288009">[-]</label><label class="expand" for="c-36288009">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that it is up to the user to bend backwards and make their brains work as a compiler<p>What do you mean? You always have to track lifetimes and what outlives what (i.e. work of a compiler). Especially in C++. Not doing that results in UB.<p>In Rust you have a compiler double checking you. And it errs on side of caution. And no, errors aren&#x27;t horrible, they come with suggestions for fixing them.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>