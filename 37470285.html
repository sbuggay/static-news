<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694509266329" as="style"/><link rel="stylesheet" href="styles.css?v=1694509266329"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://phylactery.org/antimirov/">Calculate the difference and intersection of any two regexes</a> <span class="domain">(<a href="http://phylactery.org">phylactery.org</a>)</span></div><div class="subtext"><span>posco</span> | <span>110 comments</span></div><br/><div><div id="37472840" class="c"><input type="checkbox" id="c-37472840" checked=""/><div class="controls bullet"><span class="by">oever</span><span>|</span><a href="#37472279">next</a><span>|</span><label class="collapse" for="c-37472840">[-]</label><label class="expand" for="c-37472840">[16 more]</label></div><br/><div class="children"><div class="content">This library can be used to create string class hierarchies. That, in turn, can help to use typed strings more.<p>For example, e-mails and urls are a special syntax. Their value space is a subset of all non-empty string which is a subset of all strings.<p>An e-mail address could be passed into a function that requires a non-empty string as input. When the type-system knows that an e-mail string is a subclass of non-empty string, it knows that an email address is valid.<p>This library can be used to check the definitions and hierarchy of such string types. The implementation of the hierarchy differs per programming language (subclassing, trait boundaries, etc).</div><br/><div id="37473604" class="c"><input type="checkbox" id="c-37473604" checked=""/><div class="controls bullet"><span class="by">1-more</span><span>|</span><a href="#37472840">parent</a><span>|</span><a href="#37473693">next</a><span>|</span><label class="collapse" for="c-37473604">[-]</label><label class="expand" for="c-37473604">[6 more]</label></div><br/><div class="children"><div class="content">In languages with tagged union types you do this a lot! Some Haskell pseudocode for ya<p><pre><code>    module Email (Address, fromText, toText) where -- note we do not export the constructor of Address, just the type

    data Address = Address Text

    fromString :: Text -&gt; Maybe Address
    fromString =
        -- you&#x27;d do your validation in here and return Nothing if it&#x27;s a bad address.
        -- Signal validity out of band, not in band with the data.

    toText :: Address -&gt; Text
    toText (Address addr) = addr -- for when you need to output it somewhere</code></pre></div><br/><div id="37475636" class="c"><input type="checkbox" id="c-37475636" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37473604">parent</a><span>|</span><a href="#37473640">next</a><span>|</span><label class="collapse" for="c-37475636">[-]</label><label class="expand" for="c-37475636">[3 more]</label></div><br/><div class="children"><div class="content">Pedantic note: ‘Address’ should really be a ‘newtype’…</div><br/><div id="37476885" class="c"><input type="checkbox" id="c-37476885" checked=""/><div class="controls bullet"><span class="by">1-more</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37475636">parent</a><span>|</span><a href="#37473640">next</a><span>|</span><label class="collapse" for="c-37476885">[-]</label><label class="expand" for="c-37476885">[2 more]</label></div><br/><div class="children"><div class="content">Haha sorry, I get those backwards a lot. I was gonna do elm but then it’d be a conversation about why we’re writing our own email address validation on the front end instead of using the platform.</div><br/><div id="37477001" class="c"><input type="checkbox" id="c-37477001" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37476885">parent</a><span>|</span><a href="#37473640">next</a><span>|</span><label class="collapse" for="c-37477001">[-]</label><label class="expand" for="c-37477001">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t worry, that&#x27;s normal -- in this forum we only talk about how good obscure languages are, nobody actually uses Haskell.</div><br/></div></div></div></div></div></div><div id="37473640" class="c"><input type="checkbox" id="c-37473640" checked=""/><div class="controls bullet"><span class="by">alexeldeib</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37473604">parent</a><span>|</span><a href="#37475636">prev</a><span>|</span><a href="#37473693">next</a><span>|</span><label class="collapse" for="c-37473640">[-]</label><label class="expand" for="c-37473640">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Signal validity out of band, not in band with the data.<p>Could you expand on this?</div><br/><div id="37473943" class="c"><input type="checkbox" id="c-37473943" checked=""/><div class="controls bullet"><span class="by">1-more</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37473640">parent</a><span>|</span><a href="#37473693">next</a><span>|</span><label class="collapse" for="c-37473943">[-]</label><label class="expand" for="c-37473943">[1 more]</label></div><br/><div class="children"><div class="content">Sure! Sorry that was a little too obtuse. So in this case we can imagine an app where we don&#x27;t use any tagged unions and just use primitive types (your strings, booleans, integers, things of that nature). And we want to signal the validity of some data. Say a user ID and an email address. We store the User ID as an integer to keep space down and store the email address as a string. We use semaphore values: if the user ID is invalid we store -1 (it&#x27;s JS and there are no unsigned numbers) and if the email address is invalid we store the empty string.<p>Whenever we consume these values, we need to make sure that userId &gt; 0 and email != &quot;&quot; I mean email !== &quot;&quot;. We are testing for special values of the data. Data and &quot;this is for sure not meaningful data&quot; are the same shape! So your functions need to handle those cases.<p>But with tagged unions you can check these things at the edge of the program and thereafter accept that the contents of the tagged data are valid (because you wrote good tests for your decoders).<p>So your data is a different shape when it&#x27;s valid vs when it&#x27;s invalid, and you can write functions that only accept data that&#x27;s the valid shape. If you got Json that was hit by cosmic rays when trying to build your User model, you can fail right then and not build a model and find a way to handle that.<p>It&#x27;s out of band because you don&#x27;t guard for special values of your morphologically identical data.<p>If you want examples of any specific part of this let me know. IDK your level of familiarity and don&#x27;t want to overburden you with things you already get.</div><br/></div></div></div></div></div></div><div id="37473693" class="c"><input type="checkbox" id="c-37473693" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#37472840">parent</a><span>|</span><a href="#37473604">prev</a><span>|</span><a href="#37472279">next</a><span>|</span><label class="collapse" for="c-37473693">[-]</label><label class="expand" for="c-37473693">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Their value space...<p>wossis mean? TIA<p>Edit: instread of downvoting try answering. I&#x27;d like to know. TIA{2}</div><br/><div id="37475035" class="c"><input type="checkbox" id="c-37475035" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37473693">parent</a><span>|</span><a href="#37473940">next</a><span>|</span><label class="collapse" for="c-37475035">[-]</label><label class="expand" for="c-37475035">[4 more]</label></div><br/><div class="children"><div class="content">People are downvoting you because quirky&#x2F;jokey super-colloquial language like “wossis mean? TIA” is hard to understand, and also just doesn’t really mesh with the vibe of the site.</div><br/><div id="37475775" class="c"><input type="checkbox" id="c-37475775" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37475035">parent</a><span>|</span><a href="#37473940">next</a><span>|</span><label class="collapse" for="c-37475775">[-]</label><label class="expand" for="c-37475775">[3 more]</label></div><br/><div class="children"><div class="content">What does TIA even mean?</div><br/><div id="37475815" class="c"><input type="checkbox" id="c-37475815" checked=""/><div class="controls bullet"><span class="by">Tommstein</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37475775">parent</a><span>|</span><a href="#37475829">next</a><span>|</span><label class="collapse" for="c-37475815">[-]</label><label class="expand" for="c-37475815">[1 more]</label></div><br/><div class="children"><div class="content">Thanks In Advance.</div><br/></div></div></div></div></div></div><div id="37473940" class="c"><input type="checkbox" id="c-37473940" checked=""/><div class="controls bullet"><span class="by">oever</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37473693">parent</a><span>|</span><a href="#37475035">prev</a><span>|</span><a href="#37474405">next</a><span>|</span><label class="collapse" for="c-37473940">[-]</label><label class="expand" for="c-37473940">[3 more]</label></div><br/><div class="children"><div class="content">Value space is the set of values a type can have. A boolean has only two values in its value space. An unsigned byte has 256 possible values, so does a signed byte.<p>A string enumeration has a limited number of values. E.g. type A (&quot;Yes&quot; | &quot;No&quot; | &quot;Maybe&quot;) has three values and is a superset of type B (&quot;Yes&quot; | &quot;No&quot;). A function that accepts type A can also accept type B as valid input.<p>If the value space is defined by a regular expression, as is often the case, the mentioned library could be used to check, at compile-time, which type are subsets of others.</div><br/><div id="37474053" class="c"><input type="checkbox" id="c-37474053" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37473940">parent</a><span>|</span><a href="#37474405">next</a><span>|</span><label class="collapse" for="c-37474053">[-]</label><label class="expand" for="c-37474053">[2 more]</label></div><br/><div class="children"><div class="content">Thank you. I guess I misread.<p>&quot;For example, e-mails and urls are a special syntax. Their value space...&quot; seemed to talk about the &#x27;value space&#x27; of strings (these being e-mails and urls), not types (of e-mails and urls), which confused me.</div><br/><div id="37474150" class="c"><input type="checkbox" id="c-37474150" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37474053">parent</a><span>|</span><a href="#37474405">next</a><span>|</span><label class="collapse" for="c-37474150">[-]</label><label class="expand" for="c-37474150">[1 more]</label></div><br/><div class="children"><div class="content">It is bout the &#x27;value space&#x27; of strings. Think of all possible strings. That is the entire value space of strings. Not every possible string is an email. Only a subset of this value space is a valid email. This subset is the &#x27;value space&#x27; of strings which are valid emails.</div><br/></div></div></div></div></div></div><div id="37474405" class="c"><input type="checkbox" id="c-37474405" checked=""/><div class="controls bullet"><span class="by">brianpan</span><span>|</span><a href="#37472840">root</a><span>|</span><a href="#37473693">parent</a><span>|</span><a href="#37473940">prev</a><span>|</span><a href="#37472279">next</a><span>|</span><label class="collapse" for="c-37474405">[-]</label><label class="expand" for="c-37474405">[1 more]</label></div><br/><div class="children"><div class="content">If I hadn&#x27;t seen your edit, I might have downvoted the comment for not being intelligible.</div><br/></div></div></div></div></div></div><div id="37472279" class="c"><input type="checkbox" id="c-37472279" checked=""/><div class="controls bullet"><span class="by">JoelJacobson</span><span>|</span><a href="#37472840">prev</a><span>|</span><a href="#37476796">next</a><span>|</span><label class="collapse" for="c-37472279">[-]</label><label class="expand" for="c-37472279">[5 more]</label></div><br/><div class="children"><div class="content">I created a similar regex web demo that shows how a regex is parsed -&gt; NFA -&gt; DFA -&gt; minimal DFA, and finally outputs LLVMIR&#x2F;Javascript&#x2F;WebAssembly for from the minimal DFA:<p><a href="http:&#x2F;&#x2F;compiler.org&#x2F;reason-re-nfa&#x2F;src&#x2F;index.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;compiler.org&#x2F;reason-re-nfa&#x2F;src&#x2F;index.html</a></div><br/><div id="37475792" class="c"><input type="checkbox" id="c-37475792" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37472279">parent</a><span>|</span><a href="#37476796">next</a><span>|</span><label class="collapse" for="c-37475792">[-]</label><label class="expand" for="c-37475792">[4 more]</label></div><br/><div class="children"><div class="content">Though going from NFA to explicit DFA isn&#x27;t always a good idea.<p>Btw, you might also like looking into the Brzozowski derivative <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Brzozowski_derivative" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Brzozowski_derivative</a> which can be used as an alternative way to match regular expressions.</div><br/><div id="37477474" class="c"><input type="checkbox" id="c-37477474" checked=""/><div class="controls bullet"><span class="by">mikhailfranco</span><span>|</span><a href="#37472279">root</a><span>|</span><a href="#37475792">parent</a><span>|</span><a href="#37476211">next</a><span>|</span><label class="collapse" for="c-37477474">[-]</label><label class="expand" for="c-37477474">[1 more]</label></div><br/><div class="children"><div class="content">You could implement the NFA directly
with concurrent exploration of all paths:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mike-french&#x2F;myrex">https:&#x2F;&#x2F;github.com&#x2F;mike-french&#x2F;myrex</a></div><br/></div></div><div id="37476211" class="c"><input type="checkbox" id="c-37476211" checked=""/><div class="controls bullet"><span class="by">alphablended</span><span>|</span><a href="#37472279">root</a><span>|</span><a href="#37475792">parent</a><span>|</span><a href="#37477474">prev</a><span>|</span><a href="#37476796">next</a><span>|</span><label class="collapse" for="c-37476211">[-]</label><label class="expand" for="c-37476211">[2 more]</label></div><br/><div class="children"><div class="content">I think it is also worth mentioning that the site linked at the top uses the antimirov extension to brzozovzki work on regex deivatives.</div><br/><div id="37477232" class="c"><input type="checkbox" id="c-37477232" checked=""/><div class="controls bullet"><span class="by">lubutu</span><span>|</span><a href="#37472279">root</a><span>|</span><a href="#37476211">parent</a><span>|</span><a href="#37476796">next</a><span>|</span><label class="collapse" for="c-37477232">[-]</label><label class="expand" for="c-37477232">[1 more]</label></div><br/><div class="children"><div class="content">To expand, Brzozowski introduced derivatives and Antimirov partial derivatives. Essentially the former correspond to DFAs and the latter to NFAs.</div><br/></div></div></div></div></div></div></div></div><div id="37476796" class="c"><input type="checkbox" id="c-37476796" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#37472279">prev</a><span>|</span><a href="#37471276">next</a><span>|</span><label class="collapse" for="c-37476796">[-]</label><label class="expand" for="c-37476796">[2 more]</label></div><br/><div class="children"><div class="content">Ha, trying to paste &quot;regex filter numbers divisible by 3&quot; and the page froze to death  <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;10992279&#x2F;41948" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;10992279&#x2F;41948</a><p><pre><code>    ^(?:[0369]+|[147](?:[0369]*[147][0369]*[258])*(?:[0369]*[258]|[0369]*[147][0369]*[147])|[258](?:[0369]*[258][0369]*[147])*(?:[0369]*[147]|[0369]*[258][0369]*[258]))+$

    ^([0369]|[147][0369]*[258]|(([258]|[147][0369]*[147])([0369]|[258][0369]*[147])*([147]|[258][0369]\*[258])))+$

</code></pre>
I wonder if there&#x27;s a shortest one.</div><br/><div id="37478233" class="c"><input type="checkbox" id="c-37478233" checked=""/><div class="controls bullet"><span class="by">abareplace</span><span>|</span><a href="#37476796">parent</a><span>|</span><a href="#37471276">next</a><span>|</span><label class="collapse" for="c-37478233">[-]</label><label class="expand" for="c-37478233">[1 more]</label></div><br/><div class="children"><div class="content">The web page hangs on the regular expressions that produce a DFA with a lot of states. For example, these ones:<p>(ab+c+)+<p>(abc){100}<p>a.*quick brown fox jumps over the lazy dog</div><br/></div></div></div></div><div id="37471276" class="c"><input type="checkbox" id="c-37471276" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#37476796">prev</a><span>|</span><a href="#37476116">next</a><span>|</span><label class="collapse" for="c-37471276">[-]</label><label class="expand" for="c-37471276">[9 more]</label></div><br/><div class="children"><div class="content">Regular expressions are a great example of bundling up some really neat and complex mathematical theory into a valuable interface. Linear algebra feels similar to me.</div><br/><div id="37472641" class="c"><input type="checkbox" id="c-37472641" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#37471276">parent</a><span>|</span><a href="#37471675">next</a><span>|</span><label class="collapse" for="c-37472641">[-]</label><label class="expand" for="c-37472641">[4 more]</label></div><br/><div class="children"><div class="content">It always amazes me how given the appropriate field, so much math can be transformed into linear algebra. Even Möbius transformations on the complex plane w=(az+b)&#x2F;(cz+d) can be turned into linear algebra.</div><br/><div id="37474805" class="c"><input type="checkbox" id="c-37474805" checked=""/><div class="controls bullet"><span class="by">pishpash</span><span>|</span><a href="#37471276">root</a><span>|</span><a href="#37472641">parent</a><span>|</span><a href="#37473633">next</a><span>|</span><label class="collapse" for="c-37474805">[-]</label><label class="expand" for="c-37474805">[2 more]</label></div><br/><div class="children"><div class="content">Linear transformations preserve the structure of the space so you can keep applying them. It&#x27;s not surprising that you can always find some &quot;space-preserving&quot; part of a problem and fold the rest (the &quot;non-linear&quot; structure) into transformations or the definition of the space itself.</div><br/><div id="37476059" class="c"><input type="checkbox" id="c-37476059" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37471276">root</a><span>|</span><a href="#37474805">parent</a><span>|</span><a href="#37473633">next</a><span>|</span><label class="collapse" for="c-37476059">[-]</label><label class="expand" for="c-37476059">[1 more]</label></div><br/><div class="children"><div class="content">Linear transformations preserve some structure, not &#x27;the&#x27; structure.</div><br/></div></div></div></div></div></div><div id="37471675" class="c"><input type="checkbox" id="c-37471675" checked=""/><div class="controls bullet"><span class="by">abecedarius</span><span>|</span><a href="#37471276">parent</a><span>|</span><a href="#37472641">prev</a><span>|</span><a href="#37472052">next</a><span>|</span><label class="collapse" for="c-37471675">[-]</label><label class="expand" for="c-37471675">[3 more]</label></div><br/><div class="children"><div class="content">iirc connections with linear algebra come up in Conway&#x27;s <a href="https:&#x2F;&#x2F;store.doverpublications.com&#x2F;0486485838.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;store.doverpublications.com&#x2F;0486485838.html</a> (which I only skimmed).</div><br/><div id="37471870" class="c"><input type="checkbox" id="c-37471870" checked=""/><div class="controls bullet"><span class="by">Jaxan</span><span>|</span><a href="#37471276">root</a><span>|</span><a href="#37471675">parent</a><span>|</span><a href="#37471892">next</a><span>|</span><label class="collapse" for="c-37471870">[-]</label><label class="expand" for="c-37471870">[1 more]</label></div><br/><div class="children"><div class="content">There is a whole field of “weighted automata” which combine linear algebra and automata theory.</div><br/></div></div></div></div><div id="37472052" class="c"><input type="checkbox" id="c-37472052" checked=""/><div class="controls bullet"><span class="by">pishpash</span><span>|</span><a href="#37471276">parent</a><span>|</span><a href="#37471675">prev</a><span>|</span><a href="#37476116">next</a><span>|</span><label class="collapse" for="c-37472052">[-]</label><label class="expand" for="c-37472052">[1 more]</label></div><br/><div class="children"><div class="content">That usually means the representation is getting close to the truth. Good interfaces have intrinsic value, which many result-focused people do not appreciate.</div><br/></div></div></div></div><div id="37476116" class="c"><input type="checkbox" id="c-37476116" checked=""/><div class="controls bullet"><span class="by">jepler</span><span>|</span><a href="#37471276">prev</a><span>|</span><a href="#37470286">next</a><span>|</span><label class="collapse" for="c-37476116">[-]</label><label class="expand" for="c-37476116">[2 more]</label></div><br/><div class="children"><div class="content">This is neat!<p>I was surprised then not surprised that the union &amp; intersection REs it comes up with are not particularly concise. For example the two expressions &quot;y.+&quot; and &quot;.+z&quot; have a very simple intersection: &quot;y.*z&quot; (equality verified by the page, assuming I haven&#x27;t typo&#x27;d anything). But the tool gives<p><pre><code>    yz([^z][^z]*z|z)*|y[^z](zz*[^z]|[^z])*zz*
</code></pre>
instead. I think there are <i>reasons</i> it gives the answer it does, and giving a minimal (by RE length in characters or whatever) regular expression is probably a lot harder.</div><br/><div id="37476448" class="c"><input type="checkbox" id="c-37476448" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#37476116">parent</a><span>|</span><a href="#37470286">next</a><span>|</span><label class="collapse" for="c-37476448">[-]</label><label class="expand" for="c-37476448">[1 more]</label></div><br/><div class="children"><div class="content">I think one of the reasons is the &quot;.+z&quot; gets bigger and uglier after you convert it to a deterministic automaton.</div><br/></div></div></div></div><div id="37470286" class="c"><input type="checkbox" id="c-37470286" checked=""/><div class="controls bullet"><span class="by">posco</span><span>|</span><a href="#37476116">prev</a><span>|</span><a href="#37478210">next</a><span>|</span><label class="collapse" for="c-37470286">[-]</label><label class="expand" for="c-37470286">[11 more]</label></div><br/><div class="children"><div class="content">The amazing page computes binary relations between pairs of regular expressions and shows a graphical representation of the DFA.<p>It’s a really incredible demonstration of some highly non-trivial operations on regular expressions.</div><br/><div id="37470668" class="c"><input type="checkbox" id="c-37470668" checked=""/><div class="controls bullet"><span class="by">vintermann</span><span>|</span><a href="#37470286">parent</a><span>|</span><a href="#37472538">next</a><span>|</span><label class="collapse" for="c-37470668">[-]</label><label class="expand" for="c-37470668">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very cool, but also no wonder that it doesn&#x27;t support all those features of regexes which technically make them not regular expressions anymore. Though, I would have thought ^ and $ anchors shouldn&#x27;t be a problem?</div><br/><div id="37472305" class="c"><input type="checkbox" id="c-37472305" checked=""/><div class="controls bullet"><span class="by">rntz</span><span>|</span><a href="#37470286">root</a><span>|</span><a href="#37470668">parent</a><span>|</span><a href="#37478267">next</a><span>|</span><label class="collapse" for="c-37472305">[-]</label><label class="expand" for="c-37472305">[1 more]</label></div><br/><div class="children"><div class="content">^ and $ <i>are</i> a problem, although one with a workaround.<p>The standard theory of regular expressions focuses entirely on regex matching, rather than searching. For matching, ^ and $ don&#x27;t really mean anything. In particular, regexp theory is defined in terms of the &quot;language of&quot; a regexp: the set of strings which match it. What&#x27;s the set of strings that &quot;^&quot; matches? Well, it&#x27;s the empty string, but only if it comes at the beginning of a line (or sometimes the beginning of the document). This beginning-of-line constraint doesn&#x27;t fit nicely into the &quot;a regexp is defined by its language&#x2F;set of strings&quot; theory, much the same way lookahead&#x2F;lookbehind assertions don&#x27;t quite fit the theory of regular expressions.<p>The standard workaround is to augment your alphabet with special beginning&#x2F;end-of-line characters (or beginning&#x2F;end-of-document), and say that &quot;^&quot; matches the beginning-of-line character.</div><br/></div></div><div id="37478267" class="c"><input type="checkbox" id="c-37478267" checked=""/><div class="controls bullet"><span class="by">abareplace</span><span>|</span><a href="#37470286">root</a><span>|</span><a href="#37470668">parent</a><span>|</span><a href="#37472305">prev</a><span>|</span><a href="#37471175">next</a><span>|</span><label class="collapse" for="c-37478267">[-]</label><label class="expand" for="c-37478267">[1 more]</label></div><br/><div class="children"><div class="content">The double quote (&quot;) is also broken. If you use it in the regex, then no DFA is displayed.</div><br/></div></div><div id="37471175" class="c"><input type="checkbox" id="c-37471175" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#37470286">root</a><span>|</span><a href="#37470668">parent</a><span>|</span><a href="#37478267">prev</a><span>|</span><a href="#37472774">next</a><span>|</span><label class="collapse" for="c-37471175">[-]</label><label class="expand" for="c-37471175">[1 more]</label></div><br/><div class="children"><div class="content">This page implements regex <i>matching</i>, not searching. So in effect, every pattern has an implicit ^ at the beginning and $ at the end.</div><br/></div></div><div id="37472774" class="c"><input type="checkbox" id="c-37472774" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37470286">root</a><span>|</span><a href="#37470668">parent</a><span>|</span><a href="#37471175">prev</a><span>|</span><a href="#37473932">next</a><span>|</span><label class="collapse" for="c-37472774">[-]</label><label class="expand" for="c-37472774">[1 more]</label></div><br/><div class="children"><div class="content">A <i>lack</i> of `^` is equivalent to prepending `(.*)`, then trimming the match span to the end of that capture. And similarly for a lack of `$` (but suddenly I remember how nasty Python was before `.fullmatch` was added ...).<p>More interesting is word boundaries:<p>`\b` is just `\&lt;|\&gt;` though that should be bubbled up and usually only one side will actually produce a matchable regex.<p>`A\&lt;B` is just `(A&amp;\W)(\w&amp;B)`, and similar for `\&gt;`.</div><br/></div></div><div id="37472895" class="c"><input type="checkbox" id="c-37472895" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#37470286">root</a><span>|</span><a href="#37470668">parent</a><span>|</span><a href="#37473932">prev</a><span>|</span><a href="#37472538">next</a><span>|</span><label class="collapse" for="c-37472895">[-]</label><label class="expand" for="c-37472895">[3 more]</label></div><br/><div class="children"><div class="content">As ^ and $ are implicit, you can opt <i>out</i> of them simply by affixing `.*`.</div><br/><div id="37476283" class="c"><input type="checkbox" id="c-37476283" checked=""/><div class="controls bullet"><span class="by">zeroimpl</span><span>|</span><a href="#37470286">root</a><span>|</span><a href="#37472895">parent</a><span>|</span><a href="#37472538">next</a><span>|</span><label class="collapse" for="c-37476283">[-]</label><label class="expand" for="c-37476283">[2 more]</label></div><br/><div class="children"><div class="content">Only when the ^ or $ were at the start&#x2F;end of your string is it simple. Eg:<p><pre><code>    (a|b|^)(c|d|^)foo
</code></pre>
Rewriting without ^ can require much longer regex.</div><br/><div id="37476890" class="c"><input type="checkbox" id="c-37476890" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#37470286">root</a><span>|</span><a href="#37476283">parent</a><span>|</span><a href="#37472538">next</a><span>|</span><label class="collapse" for="c-37476890">[-]</label><label class="expand" for="c-37476890">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that just<p><pre><code>    ((a|b)?(c|d)|c|d)?foo
</code></pre>
Unless you mean it as a search expression, in which case it&#x27;s more like<p><pre><code>    ((.*a|.*b)(c|d)|c|d)?foo
</code></pre>
Which I have to admit was a lot harder to figure out than I thought it would be (and may not even be right!)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37472852" class="c"><input type="checkbox" id="c-37472852" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#37478210">prev</a><span>|</span><a href="#37473480">next</a><span>|</span><label class="collapse" for="c-37472852">[-]</label><label class="expand" for="c-37472852">[8 more]</label></div><br/><div class="children"><div class="content">I wanted to see the intersection between syntactically valid URLs and email addresses, but just entering the URL regex (cf. below) already takes too long to process for the page.<p>[\-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([\-a-zA-Z0-9()@:%_+.~#?&amp;&#x2F;&#x2F;=]*)<p>(source: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;3809435&#x2F;623763" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;3809435&#x2F;623763</a>)</div><br/><div id="37472922" class="c"><input type="checkbox" id="c-37472922" checked=""/><div class="controls bullet"><span class="by">d66</span><span>|</span><a href="#37472852">parent</a><span>|</span><a href="#37473480">next</a><span>|</span><label class="collapse" for="c-37472922">[-]</label><label class="expand" for="c-37472922">[7 more]</label></div><br/><div class="children"><div class="content">expressions like (...){1,256} are very heavyweight and the scala JS code ends up timing out or crashing the browser.<p>if you replace that with (...)+ then it seems to work (at least for me). smaller expressions like (...){1,6} should be fine.</div><br/><div id="37473553" class="c"><input type="checkbox" id="c-37473553" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#37472852">root</a><span>|</span><a href="#37472922">parent</a><span>|</span><a href="#37473480">next</a><span>|</span><label class="collapse" for="c-37473553">[-]</label><label class="expand" for="c-37473553">[6 more]</label></div><br/><div class="children"><div class="content">Just wondering, what is it about testing repetition [a-z]{1,256} with an upper bound that&#x27;s so heavy? Intuitively it feels like greedy testing [a-z]+ should actually be worse since it has to work back from the end of the input.</div><br/><div id="37473673" class="c"><input type="checkbox" id="c-37473673" checked=""/><div class="controls bullet"><span class="by">rntz</span><span>|</span><a href="#37472852">root</a><span>|</span><a href="#37473553">parent</a><span>|</span><a href="#37473622">next</a><span>|</span><label class="collapse" for="c-37473673">[-]</label><label class="expand" for="c-37473673">[2 more]</label></div><br/><div class="children"><div class="content">This depends heavily on how repetition is implemented.<p>With a backtracking-search implementation of regexes, bounded iteration is pretty easy.<p>But the linked webpage appears to compile regexes to finite state machines (it shows you their finite-state-machine, for instance), and eg [a-z]{1,256} will have 256 states: 256 times the 1 state needed for [a-z]. If [a-z] were a complex regex, you could get a combinatorial explosion.<p>This alone probably isn&#x27;t the issue? 256 is not a very large number. But I suspect there are follow-on algorithmic issues. This is just speculation, but I wouldn&#x27;t be surprised if that 256-state machine were computed by applying DFA minimization, an algorithm with worst-case exponential running time, to a more naively generated machine.</div><br/><div id="37473747" class="c"><input type="checkbox" id="c-37473747" checked=""/><div class="controls bullet"><span class="by">d66</span><span>|</span><a href="#37472852">root</a><span>|</span><a href="#37473673">parent</a><span>|</span><a href="#37473622">next</a><span>|</span><label class="collapse" for="c-37473747">[-]</label><label class="expand" for="c-37473747">[1 more]</label></div><br/><div class="children"><div class="content">you&#x27;re right. inclusion&#x2F;intersection&#x2F;etc. aren&#x27;t actually computed via DFA but instead are computed directly on the regular expression representation itself. and large disjunctions (with 256 branches) are what is very heavy.<p>(it&#x27;s possible to instead do these operations on DFAs but at the time i found it hard to get from an automata back to a reasonable-looking regular expression.)</div><br/></div></div></div></div><div id="37473622" class="c"><input type="checkbox" id="c-37473622" checked=""/><div class="controls bullet"><span class="by">d66</span><span>|</span><a href="#37472852">root</a><span>|</span><a href="#37473553">parent</a><span>|</span><a href="#37473673">prev</a><span>|</span><a href="#37473480">next</a><span>|</span><label class="collapse" for="c-37473622">[-]</label><label class="expand" for="c-37473622">[3 more]</label></div><br/><div class="children"><div class="content">the library uses a fairly simple data representation where x{m,n} is compiled using conjunction and disjunction. so x{1,4} ends up being represented as x|xx|xxx|xxxx.<p>this simplifies the code for testing equality and inclusion, since logically x{n} is just xx... (n times) and x{m,n} is just x{m}|x{m+1}|...|x{n}.<p>but when you have x{m,n} and n-m is large you can imagine what kind of problems that causes.</div><br/><div id="37474108" class="c"><input type="checkbox" id="c-37474108" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#37472852">root</a><span>|</span><a href="#37473622">parent</a><span>|</span><a href="#37473480">next</a><span>|</span><label class="collapse" for="c-37474108">[-]</label><label class="expand" for="c-37474108">[2 more]</label></div><br/><div class="children"><div class="content">Seems like it should at least be x(|x(|x(|x))) instead of x|xx|xxx|xxxx to avoid quadratic blow-up.</div><br/><div id="37474195" class="c"><input type="checkbox" id="c-37474195" checked=""/><div class="controls bullet"><span class="by">d66</span><span>|</span><a href="#37472852">root</a><span>|</span><a href="#37474108">parent</a><span>|</span><a href="#37473480">next</a><span>|</span><label class="collapse" for="c-37474195">[-]</label><label class="expand" for="c-37474195">[1 more]</label></div><br/><div class="children"><div class="content">yes, that is the actual construction: the disjunction data type only supports a lhs and rhs, so that is the only possible way to represent it.<p>i wrote it the way i did for clarity in the comments.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37473480" class="c"><input type="checkbox" id="c-37473480" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#37472852">prev</a><span>|</span><a href="#37472767">next</a><span>|</span><label class="collapse" for="c-37473480">[-]</label><label class="expand" for="c-37473480">[1 more]</label></div><br/><div class="children"><div class="content">Suggestion: turn off auto suggest in the regex input fields to make it more usable on mobile.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;35513968&#x2F;disable-autocorrect-in-safari-text-input" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;35513968&#x2F;disable-autocor...</a></div><br/></div></div><div id="37472767" class="c"><input type="checkbox" id="c-37472767" checked=""/><div class="controls bullet"><span class="by">rsstack</span><span>|</span><a href="#37473480">prev</a><span>|</span><a href="#37475869">next</a><span>|</span><label class="collapse" for="c-37472767">[-]</label><label class="expand" for="c-37472767">[5 more]</label></div><br/><div class="children"><div class="content">I used this concept once to write the validation logic for an &quot;IP RegEx filter&quot; setting. The goal was to let users configure an IP filter using RegEx (no, marketing people don&#x27;t get CIDRs, and they knew RegEx&#x27;s from Google Analytics). How could I define a valid RegEx for this? The intersection with the RegEx of &quot;all IPv4 addresses&quot; is not empty, and not equal to the RegEx of &quot;all IPv4 addresses&quot;. Prevented many complaints about the filter not doing anything, but of course didn&#x27;t prevent wrong filters from being entered.</div><br/><div id="37472866" class="c"><input type="checkbox" id="c-37472866" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#37472767">parent</a><span>|</span><a href="#37475869">next</a><span>|</span><label class="collapse" for="c-37472866">[-]</label><label class="expand" for="c-37472866">[4 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t a simpler solution work here? Instead of trying to validate the filter regex, show some sample IP addresses or let the user insert a set of addresses, and then show which ones the filter matches and which ones it doesn&#x27;t. Also helps address the problem of incorrect filters.</div><br/><div id="37472894" class="c"><input type="checkbox" id="c-37472894" checked=""/><div class="controls bullet"><span class="by">rsstack</span><span>|</span><a href="#37472767">root</a><span>|</span><a href="#37472866">parent</a><span>|</span><a href="#37475869">next</a><span>|</span><label class="collapse" for="c-37472894">[-]</label><label class="expand" for="c-37472894">[3 more]</label></div><br/><div class="children"><div class="content">The odds of the sample addresses matching is essentially zero, and adding work to the user is counterproductive.</div><br/><div id="37472906" class="c"><input type="checkbox" id="c-37472906" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#37472767">root</a><span>|</span><a href="#37472894">parent</a><span>|</span><a href="#37475869">next</a><span>|</span><label class="collapse" for="c-37472906">[-]</label><label class="expand" for="c-37472906">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I agree — most common regex editing tools available online include a section for adding test strings to verify what you actually wrote is correct. Clearly there is a benefit to it. In similar vein, allowing the user to test before they commit and then test actually reduces their work load, they don&#x27;t have to drop and then reload the whole regex in their mind.</div><br/><div id="37472946" class="c"><input type="checkbox" id="c-37472946" checked=""/><div class="controls bullet"><span class="by">rsstack</span><span>|</span><a href="#37472767">root</a><span>|</span><a href="#37472906">parent</a><span>|</span><a href="#37475869">next</a><span>|</span><label class="collapse" for="c-37472946">[-]</label><label class="expand" for="c-37472946">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I use that when authoring and editing a RegEx. That&#x27;s not the same as entry validation.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37475869" class="c"><input type="checkbox" id="c-37475869" checked=""/><div class="controls bullet"><span class="by">x-complexity</span><span>|</span><a href="#37472767">prev</a><span>|</span><a href="#37475181">next</a><span>|</span><label class="collapse" for="c-37475869">[-]</label><label class="expand" for="c-37475869">[1 more]</label></div><br/><div class="children"><div class="content">I used 2 similar divide-by-3 regexes to test the page (after removing the ^ and $ to their ends), and it froze up:<p>Regex 1: ([0369]|([258]|[147][0369]*[147])([0369]|([147][0369]*[258]|[258][0369]*[147]))*([147]|[258][0369]*[258])|([147]|[258][0369]*[258])([0369]|([147][0369]*[258]|[258][0369]*[147]))*([258]|[147][0369]*[147]))*<p>Regex 2: ([0369]|[258][0369]*[147]|(([147]|[258][0369]*[258])([0369]|[147][0369]*[258])*([258]|[147][0369]*[147])))*<p>Everything up until the last &#x27;*&#x27; is parsable. The moment I put in the *, the entire page freezes up.<p>Without the *, it produced a valid verifier for parsing chunks of digits whose sum mod 3 = 0.</div><br/></div></div><div id="37475181" class="c"><input type="checkbox" id="c-37475181" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#37475869">prev</a><span>|</span><a href="#37471109">next</a><span>|</span><label class="collapse" for="c-37475181">[-]</label><label class="expand" for="c-37475181">[1 more]</label></div><br/><div class="children"><div class="content">One possible application: If an input to a function parameter must match a certain regex, and the output of a function produces results matching another regex, we can know if the functions are compatible: if the intersection of regular expressions is empty, then you cannot connect one function to the other.<p>Combined with the fact the regular expressions can be used not only on strings but more generally (e.g. for JSON schema validation [1]), this could be a possible implementation of static checks, similar to &quot;design by contract&quot;.<p>--<p>1: <a href="https:&#x2F;&#x2F;www.balisage.net&#x2F;Proceedings&#x2F;vol23&#x2F;html&#x2F;Holstege01&#x2F;BalisageVol23-Holstege01.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.balisage.net&#x2F;Proceedings&#x2F;vol23&#x2F;html&#x2F;Holstege01&#x2F;B...</a></div><br/></div></div><div id="37471109" class="c"><input type="checkbox" id="c-37471109" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#37475181">prev</a><span>|</span><a href="#37473067">next</a><span>|</span><label class="collapse" for="c-37471109">[-]</label><label class="expand" for="c-37471109">[27 more]</label></div><br/><div class="children"><div class="content">Kinda related but I&#x27;m looking for something that could give me the number of possible matching strings for a simple regex. Does such a tool exist ?</div><br/><div id="37471180" class="c"><input type="checkbox" id="c-37471180" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37477517">next</a><span>|</span><label class="collapse" for="c-37471180">[-]</label><label class="expand" for="c-37471180">[9 more]</label></div><br/><div class="children"><div class="content">I feel like it shouldn&#x27;t be too hard to calculate from the finite automaton that encodes the regular expression, but surely in most cases it will simply be infinite?</div><br/><div id="37472579" class="c"><input type="checkbox" id="c-37472579" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471180">parent</a><span>|</span><a href="#37471261">next</a><span>|</span><label class="collapse" for="c-37472579">[-]</label><label class="expand" for="c-37472579">[1 more]</label></div><br/><div class="children"><div class="content">This is hitting back a long time. But the algorithm - if I recall right - is a simple DFS on the determinstic automaton for the regular expression and it can output the full set of matching strings if you&#x27;re allowed to use *s in the output.<p>Basically, you need an accumulator of &quot;stuff up to here&quot;. If you move from a node to a second node, you add the character annotating that edge to the accumulator. And whenever you end up with an edge to a visited node, you add a &#x27;*&#x27; and output that, and for leaf nodes, you output the accumulator.<p>And then you add a silly jumble of parenthesis on entry and output to make it right. This was kinda simple to figure out with stuff like (a(ab)*b)* and such.<p>This is in O(states) for R and O(2^states) for NR if I recall right.</div><br/></div></div><div id="37471261" class="c"><input type="checkbox" id="c-37471261" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471180">parent</a><span>|</span><a href="#37472579">prev</a><span>|</span><a href="#37473466">next</a><span>|</span><label class="collapse" for="c-37471261">[-]</label><label class="expand" for="c-37471261">[6 more]</label></div><br/><div class="children"><div class="content">Maybe the number of possible matchings for a given length (or range of lengths) might be interesting?</div><br/><div id="37471468" class="c"><input type="checkbox" id="c-37471468" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471261">parent</a><span>|</span><a href="#37471732">next</a><span>|</span><label class="collapse" for="c-37471468">[-]</label><label class="expand" for="c-37471468">[4 more]</label></div><br/><div class="children"><div class="content">Say you want to compute all strings of length 5 that the automaton can generate. Conceptually the nicest way is to create an automaton that matches any five characters and then compute the intersection between that automaton and the regex automaton. Then you can generate all the strings in the intersection automaton. Of course, IRL, you wouldn&#x27;t actually generate the intersection automaton (you can easily do this on the fly), but you get the idea.<p>Automata are really a lost art in modern natural language processing. We used to do things like store a large vocabulary in an deterministic acyclic minimized automaton (nice and compact, so-called dictionary automaton). And then to find, say all words within Levenshtein distance 2 of <i>hacker</i>, create a Levenshtein automaton for <i>hacker</i> and then compute (on the fly) the intersection between the Levenshtein automaton and the dictionary automaton. The language of the automaton is then all words within the intersection automaton.<p>I wrote a Java package a decade ago that implements some of this stuff:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;danieldk&#x2F;dictomaton">https:&#x2F;&#x2F;github.com&#x2F;danieldk&#x2F;dictomaton</a></div><br/><div id="37471759" class="c"><input type="checkbox" id="c-37471759" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471468">parent</a><span>|</span><a href="#37471732">next</a><span>|</span><label class="collapse" for="c-37471759">[-]</label><label class="expand" for="c-37471759">[3 more]</label></div><br/><div class="children"><div class="content">&gt; deterministic acyclic minimized automaton<p>That&#x27;s basically a Trie right? To be fair I have only heard of them and know they can be used to do neat tricks, I&#x27;ve rarely used one myself.</div><br/><div id="37472692" class="c"><input type="checkbox" id="c-37472692" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471759">parent</a><span>|</span><a href="#37472743">next</a><span>|</span><label class="collapse" for="c-37472692">[-]</label><label class="expand" for="c-37472692">[1 more]</label></div><br/><div class="children"><div class="content">If you do not plan to update it often and don’t need to store extra data with each word, a dawg (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Deterministic_acyclic_finite_state_automaton" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Deterministic_acyclic_finite_s...</a>) is more compact. You often can merge leaf nodes.<p>For example, if you have words<p><pre><code>   talk
   talked
   talking
   talks
   walk
   walked
   walking
   walks
</code></pre>
there’s no need to repeat the “”, “ed”, “ing”, “s” parts.</div><br/></div></div><div id="37472743" class="c"><input type="checkbox" id="c-37472743" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471759">parent</a><span>|</span><a href="#37472692">prev</a><span>|</span><a href="#37471732">next</a><span>|</span><label class="collapse" for="c-37472743">[-]</label><label class="expand" for="c-37472743">[1 more]</label></div><br/><div class="children"><div class="content">No. In a minimized automaton shared string suffixes also share states&#x2F;transitions.</div><br/></div></div></div></div></div></div><div id="37471732" class="c"><input type="checkbox" id="c-37471732" checked=""/><div class="controls bullet"><span class="by">abecedarius</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471261">parent</a><span>|</span><a href="#37471468">prev</a><span>|</span><a href="#37473466">next</a><span>|</span><label class="collapse" for="c-37471732">[-]</label><label class="expand" for="c-37471732">[1 more]</label></div><br/><div class="children"><div class="content">That was one of the short examples in Norvig&#x27;s Python program-design course for Udacity. <a href="https:&#x2F;&#x2F;github.com&#x2F;darius&#x2F;cant&#x2F;blob&#x2F;master&#x2F;library&#x2F;regex-gen.cant">https:&#x2F;&#x2F;github.com&#x2F;darius&#x2F;cant&#x2F;blob&#x2F;master&#x2F;library&#x2F;regex-gen...</a> (I don&#x27;t have the Python handy.)</div><br/></div></div></div></div><div id="37473466" class="c"><input type="checkbox" id="c-37473466" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471180">parent</a><span>|</span><a href="#37471261">prev</a><span>|</span><a href="#37477517">next</a><span>|</span><label class="collapse" for="c-37473466">[-]</label><label class="expand" for="c-37473466">[1 more]</label></div><br/><div class="children"><div class="content">see <a href="https:&#x2F;&#x2F;www.cs.dartmouth.edu&#x2F;~doug&#x2F;nfa.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.dartmouth.edu&#x2F;~doug&#x2F;nfa.pdf</a></div><br/></div></div></div></div><div id="37477517" class="c"><input type="checkbox" id="c-37477517" checked=""/><div class="controls bullet"><span class="by">mikhailfranco</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37471180">prev</a><span>|</span><a href="#37472170">next</a><span>|</span><label class="collapse" for="c-37477517">[-]</label><label class="expand" for="c-37477517">[1 more]</label></div><br/><div class="children"><div class="content">Another interesting question is: how many possible successful matches are there for a given input string. For example:<p><i>How many ways can</i> (a?){m}(a*){m} <i>match the string</i> a{m}<p>i.e. input <i>m</i> repetitions of the letter &#x27;a&#x27;.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mike-french&#x2F;myrex#ambiguous-example">https:&#x2F;&#x2F;github.com&#x2F;mike-french&#x2F;myrex#ambiguous-example</a><p>The answer is a dot product of two vectors sliced from Pascal&#x27;s Triangle.<p>For m=9, there are 864,146 successful matches.</div><br/></div></div><div id="37472170" class="c"><input type="checkbox" id="c-37472170" checked=""/><div class="controls bullet"><span class="by">d66</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37477517">prev</a><span>|</span><a href="#37474926">next</a><span>|</span><label class="collapse" for="c-37472170">[-]</label><label class="expand" for="c-37472170">[1 more]</label></div><br/><div class="children"><div class="content">the page actually does give these. for α := [a-z]{2,4} the page gives |α| = 475228.<p>however, as others have pointed out any non-trivial use of the kleene star means the result will be ∞. in this case the page will list numbers that roughly correspond to &quot;number of strings with N applications of kleene star&quot; in addition to infinity.</div><br/></div></div><div id="37474926" class="c"><input type="checkbox" id="c-37474926" checked=""/><div class="controls bullet"><span class="by">rntz</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37472170">prev</a><span>|</span><a href="#37473050">next</a><span>|</span><label class="collapse" for="c-37474926">[-]</label><label class="expand" for="c-37474926">[3 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a simple Haskell program to do it:<p>(EDIT: this code is completely wrongheaded and does not work; it assumes that when sequencing regexes, you can take the product of their sizes to find the overall size. This is just not true. See reply, below, for an example.)<p><pre><code>    -- https:&#x2F;&#x2F;gist.github.com&#x2F;rntz&#x2F;03604e36888a8c6f08bb5e8c665ba9d0

    import qualified Data.List as List

    data Regex = Class [Char]   -- character class
               | Seq [Regex]    -- sequence, ABC
               | Choice [Regex] -- choice, A|B|C
               | Star Regex     -- zero or more, A*
                 deriving (Show)

    data Size = Finite Int | Infinite deriving (Show, Eq)

    instance Num Size where
      abs = undefined; signum = undefined; negate = undefined -- unnecessary
      fromInteger = Finite . fromInteger
      Finite x + Finite y = Finite (x + y)
      _ + _ = Infinite
      Finite x * Finite y = Finite (x * y)
      x * y = if x == 0 || y == 0 then 0 else Infinite

    -- computes size &amp; language (list of matching strings, if regex is finite)
    eval :: Regex -&gt; (Size, [String])
    eval (Class chars) = (Finite (length cset), [[c] | c &lt;- cset])
      where cset = List.nub chars
    eval (Seq regexes) = (product sizes, concat &lt;$&gt; sequence langs)
      where (sizes, langs) = unzip $ map eval regexes
    eval (Choice regexes) = (size, lang)
      where (sizes, langs) = unzip $ map eval regexes
            lang = concat langs
            size = if elem Infinite sizes then Infinite
                   -- finite, so just count &#x27;em. inefficient but works.
                   else Finite (length (List.nub lang))
    eval (Star r) = (size, lang)
      where (rsize, rlang) = eval r
            size | rsize == 0 = 1
                 | rsize == 1 &amp;&amp; List.nub rlang == [&quot;&quot;] = 1
                 | otherwise = Infinite
            lang = [&quot;&quot;] ++ ((++) &lt;$&gt; [x | x &lt;- rlang, x &#x2F;= &quot;&quot;] &lt;*&gt; lang)

    size :: Regex -&gt; Size
    size = fst . eval
</code></pre>
NB. Besides the utter wrong-headedness of the `product` call, the generated string-sets may not be exhaustive for infinite languages, and the original version (I have since edited it) was wrong in several cases for Star (if the argument was nullable or empty).</div><br/><div id="37475179" class="c"><input type="checkbox" id="c-37475179" checked=""/><div class="controls bullet"><span class="by">sebzim4500</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37474926">parent</a><span>|</span><a href="#37473050">next</a><span>|</span><label class="collapse" for="c-37475179">[-]</label><label class="expand" for="c-37475179">[2 more]</label></div><br/><div class="children"><div class="content">Surely that fails for e.g. a?a?a?. I&#x27;d imagine you could do some sort of simplification first though to avoid this redundancy.</div><br/><div id="37475504" class="c"><input type="checkbox" id="c-37475504" checked=""/><div class="controls bullet"><span class="by">rntz</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37475179">parent</a><span>|</span><a href="#37473050">next</a><span>|</span><label class="collapse" for="c-37475504">[-]</label><label class="expand" for="c-37475504">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re correct, and I don&#x27;t see any good way to avoid this that doesn&#x27;t involve enumerating the actual language (at least when the language is finite).<p>Oof, my hubris.</div><br/></div></div></div></div></div></div><div id="37473050" class="c"><input type="checkbox" id="c-37473050" checked=""/><div class="controls bullet"><span class="by">someguy101010</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37474926">prev</a><span>|</span><a href="#37472045">next</a><span>|</span><label class="collapse" for="c-37473050">[-]</label><label class="expand" for="c-37473050">[1 more]</label></div><br/><div class="children"><div class="content">might be something like this <a href="https:&#x2F;&#x2F;jvns.ca&#x2F;blog&#x2F;2016&#x2F;04&#x2F;24&#x2F;how-regular-expressions-go-fast&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jvns.ca&#x2F;blog&#x2F;2016&#x2F;04&#x2F;24&#x2F;how-regular-expressions-go-f...</a> which refs <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Brzozowski_derivative" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Brzozowski_derivative</a></div><br/></div></div><div id="37472045" class="c"><input type="checkbox" id="c-37472045" checked=""/><div class="controls bullet"><span class="by">Drup</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37473050">prev</a><span>|</span><a href="#37472188">next</a><span>|</span><label class="collapse" for="c-37472045">[-]</label><label class="expand" for="c-37472045">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;regex-generate.github.io&#x2F;regenerate&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;regex-generate.github.io&#x2F;regenerate&#x2F;</a> (I&#x27;m one of the authors) enumerates all the matching (and non-matching) strings, which incidentally answers the question, but doesn&#x27;t terminate in the infinite case.</div><br/></div></div><div id="37472188" class="c"><input type="checkbox" id="c-37472188" checked=""/><div class="controls bullet"><span class="by">clord</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37472045">prev</a><span>|</span><a href="#37471215">next</a><span>|</span><label class="collapse" for="c-37472188">[-]</label><label class="expand" for="c-37472188">[1 more]</label></div><br/><div class="children"><div class="content">I feel like it might be possible with dataflow analysis. Stepping through the regex maintaining a liveness set or something like that. Sort of like computing exemplar inputs, but with repetition as permitted exemplars. Honestly probably end up re-encoding the regex in some other format, perhaps with &#x27;optimizations applied.&#x27;</div><br/></div></div><div id="37471215" class="c"><input type="checkbox" id="c-37471215" checked=""/><div class="controls bullet"><span class="by">stvltvs</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37472188">prev</a><span>|</span><a href="#37473494">next</a><span>|</span><label class="collapse" for="c-37471215">[-]</label><label class="expand" for="c-37471215">[8 more]</label></div><br/><div class="children"><div class="content">The answer is usually an infinite number, except for very, very simple cases. Anything involving * for example means infinity is your answer.</div><br/><div id="37471335" class="c"><input type="checkbox" id="c-37471335" checked=""/><div class="controls bullet"><span class="by">skulk</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471215">parent</a><span>|</span><a href="#37473494">next</a><span>|</span><label class="collapse" for="c-37471335">[-]</label><label class="expand" for="c-37471335">[7 more]</label></div><br/><div class="children"><div class="content">I wonder if it makes sense to compute an &quot;order type&quot; for a regexp. For example, a* is omega, a*b* is 2 omega.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Order_type" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Order_type</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ordinal_number" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ordinal_number</a></div><br/><div id="37471692" class="c"><input type="checkbox" id="c-37471692" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471335">parent</a><span>|</span><a href="#37473494">next</a><span>|</span><label class="collapse" for="c-37471692">[-]</label><label class="expand" for="c-37471692">[6 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s just the ordinal corresponding to lexicographic order on the words in the language, so yeah that should work. I wonder how easy it is to calculate...</div><br/><div id="37472315" class="c"><input type="checkbox" id="c-37472315" checked=""/><div class="controls bullet"><span class="by">d66</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37471692">parent</a><span>|</span><a href="#37473494">next</a><span>|</span><label class="collapse" for="c-37472315">[-]</label><label class="expand" for="c-37472315">[5 more]</label></div><br/><div class="children"><div class="content">normally you would use an ordinal number [1] to label individual elements of an infinite set while using a cardinal number [2] to measure the size of the set.<p>i believe the cardinality of a set of words from a finite alphabet (with more than one member) is equivalent to the cardinality of the real numbers. this means that the cardinality of .* is c.<p>unfortunately, i don&#x27;t think that cardinality gets us very far when trying to differentiate the &quot;complexity&quot; of expressions like [ab]* from ([ab]*c[de]*)*[x-z]*. probably some other metric should be used (maybe something like kolmogorov complexity).<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ordinal_number" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ordinal_number</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cardinal_number" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cardinal_number</a></div><br/><div id="37473265" class="c"><input type="checkbox" id="c-37473265" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37472315">parent</a><span>|</span><a href="#37473494">next</a><span>|</span><label class="collapse" for="c-37473265">[-]</label><label class="expand" for="c-37473265">[4 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say that&#x27;s their &#x27;normal&#x27; usage, I mean sure you can use them like that but fundamentally ordinal numbers are equivalence classes of ordered sets in the same way that cardinal numbers are equivalence classes of sets.<p>As you&#x27;ve rightly noted the latter equivalence class gets us nothing so throwing away the ordering is a bit of a waste. Of all mathematical concepts &#x27;size&#x27; is easily the most subjective so picking one that is interesting is better than trying to be &#x27;correct&#x27;.<p>In particular a*b* is exactly equivalent to ω^2, since a^n b^m &lt; a^x b^y iff n &lt; x or n=x and m&lt;y. This gives an order preserving isomorphism between words of the form a^n b^m and tuples (n,m) with lexicographic ordering.</div><br/><div id="37473351" class="c"><input type="checkbox" id="c-37473351" checked=""/><div class="controls bullet"><span class="by">d66</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37473265">parent</a><span>|</span><a href="#37473494">next</a><span>|</span><label class="collapse" for="c-37473351">[-]</label><label class="expand" for="c-37473351">[3 more]</label></div><br/><div class="children"><div class="content">interesting!<p>what would [ab]* be? for computing an ordinal number the only real difficulty is how to handle kleene star: given ord(X) how do we calculate ord(X*)?<p>but as you probably noticed i&#x27;m a bit out of my depth when dealing with ordinals.</div><br/><div id="37474944" class="c"><input type="checkbox" id="c-37474944" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37473351">parent</a><span>|</span><a href="#37475528">next</a><span>|</span><label class="collapse" for="c-37474944">[-]</label><label class="expand" for="c-37474944">[1 more]</label></div><br/><div class="children"><div class="content">Unless I&#x27;m very mistaken adding onto the end of a string doesn&#x27;t affect lexicographic order, so that&#x27;s effectively [ab]*. The ordinality of [ab] is simple, it&#x27;s 2, but the kleene star is a bit of an odd one, it&#x27;s not quite exponentiation.<p>To reason about the kleene star it&#x27;s a bit simpler to consider something like R^*n, where you repeat <i>up to</i> n times. Obviously R^*0 = 1 and R^*S(n) can be built from R^*n by picking an element of R^*n and appending either nothing or an element of R, here the element of R^*n determines most of the order and &#x27;nothing&#x27; orders in front. For technical reasons the corresponding ordinal is (1+R) R^*n, which is <i>backwards</i> from how you&#x27;d expect it and how you&#x27;d normally define exponentiation.<p>The kleene star can be recovered by taking the limit, identifying R^*n with it&#x27;s image in R^*S(n). Which also doesn&#x27;t quite work as nicely as you&#x27;d hope (normally the image is just a downward closed subset, it&#x27;s not in this case).<p>I think [ab]* is equivalent to something like the rational part of the Cantor set. Not sure if there&#x27;s a <i>simpler</i> way to describe it, it&#x27;s nowhere near as simple as 2^ω, which is just ω.</div><br/></div></div><div id="37475528" class="c"><input type="checkbox" id="c-37475528" checked=""/><div class="controls bullet"><span class="by">skulk</span><span>|</span><a href="#37471109">root</a><span>|</span><a href="#37473351">parent</a><span>|</span><a href="#37474944">prev</a><span>|</span><a href="#37473494">next</a><span>|</span><label class="collapse" for="c-37475528">[-]</label><label class="expand" for="c-37475528">[1 more]</label></div><br/><div class="children"><div class="content">I would say [ab]* has order type omega. That&#x27;s because the set of strings it represents is: {epsilon, ab, abab, ababab, abababab, ...} which looks a lot like omega. (epsilon = empty string)<p>What this exercise really is is finding a canonical way to order a regular language (the set of strings a regexp matches). For example, a*b* could be {epsilon, a, aa, aaa, aaa, aaaa, ..., b, bb, bbb, bbbb, bbbbb, bbbbbb, ..., ab, aab, aaab, aaaab, ..., abb, aabb, ..., ...}
which looks a lot like omega ^ 2 (not 2 * omega like I said before). However, you could also re-arrange the set to look like omega: {epsilon, a, b, aa, bb, ab, aaa, bbb, aab, abb, bbb, ...} (strings of length 1, length 2, length 3, etc)<p>I propose the following: for any two strings in the regular language, the one that comes first is the one whose kleene-star repetition counts come first lexicographically. More concretely, for the language a*b*, aaaab represents a repetition count of (4, 1) which and bbb represents (0, 3). (0, 3) comes before (4, 1) lexicographically, so bbb comes before aaaab. This admits the following ordering: {epsilon, b, bb, bbb, bbbb, ..., a, abb, abbb, abbbb, ..., aa, aab, aabb, aabbb, ..., ...} which is omega ^ 2 which &quot;feels&quot; right to me. Another rule is for the regular language (X|Y) and two strings x from X and y from Y, x should always come before y in our ordered set representation.<p>Hold on, what about nested kleene-stars? (a*)* is just a*, but (a*b*)* is distinct from a*b*. However, the &quot;kleene-star counts&quot; analysis from above breaks down because there are now multiple ways to parse strings like aab. I don&#x27;t really know how to classify these regular languages as ordinals yet.<p>I don&#x27;t really see any useful applications of this, but it&#x27;s still fun to think about. The game I&#x27;m playing is thinking about a random ordinal and trying to come up with a regular language that, under my ordering rule above, looks like that ordinal. Let&#x27;s try 2 * omega (which looks like this: {0, 1, 2, 3, 4, 5, ..., omega, omega + 1, omega + 2, omega + 3, ...} e.g. 2 copies of omega &quot;concatenated&quot;):<p>a*|b* = {epsilon, a, aa, aaa, aaaa, aaaaa, ..., b, bb, bbb, bbbb, ...} =&gt; 2 * omega.<p>Some more examples:<p>omega ^ 3: a*b*c*<p>omega ^ 2 + omega: a*b*|c*<p>Maybe we can write down some composition rules:<p>let X and Y be regular languages and ord(X) and ord(Y) be their ordinal representations. Then,<p>X|Y =&gt; ord(X) + ord(Y)<p>XY =&gt; ord(X) * ord(Y)<p>X* =&gt; ord(X) * omega<p>I haven&#x27;t checked if these actually work, this is just a long rambly comment of dubious mathematical value.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37473494" class="c"><input type="checkbox" id="c-37473494" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#37471109">parent</a><span>|</span><a href="#37471215">prev</a><span>|</span><a href="#37473067">next</a><span>|</span><label class="collapse" for="c-37473494">[-]</label><label class="expand" for="c-37473494">[1 more]</label></div><br/><div class="children"><div class="content">What’s your use case?</div><br/></div></div></div></div><div id="37473067" class="c"><input type="checkbox" id="c-37473067" checked=""/><div class="controls bullet"><span class="by">less_less</span><span>|</span><a href="#37471109">prev</a><span>|</span><a href="#37470723">next</a><span>|</span><label class="collapse" for="c-37473067">[-]</label><label class="expand" for="c-37473067">[2 more]</label></div><br/><div class="children"><div class="content">Interesting.  I think this problem is actually EXPSPACE-complete in general?  But still has a straightforward algorithm.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;EXPSPACE" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;EXPSPACE</a></div><br/><div id="37475522" class="c"><input type="checkbox" id="c-37475522" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#37473067">parent</a><span>|</span><a href="#37470723">next</a><span>|</span><label class="collapse" for="c-37475522">[-]</label><label class="expand" for="c-37475522">[1 more]</label></div><br/><div class="children"><div class="content">It depends on your operators.  For these, no.<p>Equivalence of DFA or NFA is PSPACE complete by savitch&#x27;s theorem, regardless of time bound.  As such, most types of regex  equivalence is  pspace-complete.<p><a href="https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;viewdoc&#x2F;summary?doi=10.1.1.89.3636" rel="nofollow noreferrer">https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;viewdoc&#x2F;summary?doi=10.1.1.89....</a><p>Has a detailed breakdown of operators vs complexity.<p>In particular, the paper cited in the expspace page is talking about allowing a squaring operator.<p>It is EXPSPACE complete if you allow squaring, but not if you use repetition.<p>IE it is expspace complete if you allow e^2, but not if you only allow ee.</div><br/></div></div></div></div><div id="37470881" class="c"><input type="checkbox" id="c-37470881" checked=""/><div class="controls bullet"><span class="by">baggy_trough</span><span>|</span><a href="#37470723">prev</a><span>|</span><a href="#37472398">next</a><span>|</span><label class="collapse" for="c-37470881">[-]</label><label class="expand" for="c-37470881">[4 more]</label></div><br/><div class="children"><div class="content">I love how it looks like a CS textbook.</div><br/><div id="37472326" class="c"><input type="checkbox" id="c-37472326" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#37470881">parent</a><span>|</span><a href="#37472151">next</a><span>|</span><label class="collapse" for="c-37472326">[-]</label><label class="expand" for="c-37472326">[2 more]</label></div><br/><div class="children"><div class="content">The graphics look identical to those in Hopcroft &amp; Ullman&#x27;s <i>&quot;Introduction to Automata Theory, Languages, and Computation&quot;</i> (like the convention that they use a double-circle to denote accepting states). I imagine they&#x27;re GraphViz-based: it&#x27;s very easy [0] to draw these in GraphViz. I don&#x27;t know what Hopcroft &amp; Ullman used though, because that one was published in 1979, and GraphViz didn&#x27;t exist before 1991. Suddenly I&#x27;m curious what the state of the art for vector diagrams was in 1979...?<p>[0] e.g. <a href="https:&#x2F;&#x2F;graphviz.org&#x2F;Gallery&#x2F;directed&#x2F;fsm.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;graphviz.org&#x2F;Gallery&#x2F;directed&#x2F;fsm.html</a></div><br/><div id="37474850" class="c"><input type="checkbox" id="c-37474850" checked=""/><div class="controls bullet"><span class="by">therealcamino</span><span>|</span><a href="#37470881">root</a><span>|</span><a href="#37472326">parent</a><span>|</span><a href="#37472151">next</a><span>|</span><label class="collapse" for="c-37474850">[-]</label><label class="expand" for="c-37474850">[1 more]</label></div><br/><div class="children"><div class="content">Maybe something related to &#x27;pic&#x27;? This doc on it is a revised version of a 1984 edition, so maybe it&#x27;s a little too late, but there are references to other systems back to 1977 or so.<p><a href="https:&#x2F;&#x2F;pikchr.org&#x2F;home&#x2F;uv&#x2F;pic.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;pikchr.org&#x2F;home&#x2F;uv&#x2F;pic.pdf</a></div><br/></div></div></div></div><div id="37472151" class="c"><input type="checkbox" id="c-37472151" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#37470881">parent</a><span>|</span><a href="#37472326">prev</a><span>|</span><a href="#37472398">next</a><span>|</span><label class="collapse" for="c-37472151">[-]</label><label class="expand" for="c-37472151">[1 more]</label></div><br/><div class="children"><div class="content">It has the look of graphviz about it, which is an excellent tool. Often helpful in debugging anything related to graphs.<p><a href="https:&#x2F;&#x2F;graphviz.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;graphviz.org&#x2F;</a></div><br/></div></div></div></div><div id="37472398" class="c"><input type="checkbox" id="c-37472398" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#37470881">prev</a><span>|</span><a href="#37470605">next</a><span>|</span><label class="collapse" for="c-37472398">[-]</label><label class="expand" for="c-37472398">[1 more]</label></div><br/><div class="children"><div class="content">it always bugged me as a student that had to sit through all those discrete maths lectures that standard regex libraries don&#x27;t allow you to union&#x2F;intersect two &quot;compiled&quot; regular expression objects together<p>(having to try them one an a time is pretty sad)</div><br/></div></div><div id="37470605" class="c"><input type="checkbox" id="c-37470605" checked=""/><div class="controls bullet"><span class="by">snoble</span><span>|</span><a href="#37472398">prev</a><span>|</span><a href="#37472266">next</a><span>|</span><label class="collapse" for="c-37470605">[-]</label><label class="expand" for="c-37470605">[1 more]</label></div><br/><div class="children"><div class="content">Oh neat, this is scala via scalajs.</div><br/></div></div><div id="37472266" class="c"><input type="checkbox" id="c-37472266" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#37470605">prev</a><span>|</span><a href="#37475760">next</a><span>|</span><label class="collapse" for="c-37472266">[-]</label><label class="expand" for="c-37472266">[2 more]</label></div><br/><div class="children"><div class="content">On mobile: are the rectangle glyphs as suffixes on the states on purpose or am I missing a font?</div><br/><div id="37472299" class="c"><input type="checkbox" id="c-37472299" checked=""/><div class="controls bullet"><span class="by">progbits</span><span>|</span><a href="#37472266">parent</a><span>|</span><a href="#37475760">next</a><span>|</span><label class="collapse" for="c-37472299">[-]</label><label class="expand" for="c-37472299">[1 more]</label></div><br/><div class="children"><div class="content">The states are numbered, $\alpha_0, ..., \alpha_N$ and $\beta_0, ...$. You might be missing the font for the digits.</div><br/></div></div></div></div><div id="37475760" class="c"><input type="checkbox" id="c-37475760" checked=""/><div class="controls bullet"><span class="by">bjt12345</span><span>|</span><a href="#37472266">prev</a><span>|</span><a href="#37473783">next</a><span>|</span><label class="collapse" for="c-37475760">[-]</label><label class="expand" for="c-37475760">[1 more]</label></div><br/><div class="children"><div class="content">.</div><br/></div></div><div id="37473783" class="c"><input type="checkbox" id="c-37473783" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#37475760">prev</a><span>|</span><a href="#37474158">next</a><span>|</span><label class="collapse" for="c-37473783">[-]</label><label class="expand" for="c-37473783">[2 more]</label></div><br/><div class="children"><div class="content">Any def for &#x27;difference and intersection of regexes&#x27; might actually mean?<p>I guess for regexes r1 and r2 this means the diff and intersect of their extensional sets, expressed intensionally as a regex. I guess. But nothing seems defined, including what ^ is, or &gt; or whatever. It&#x27;s not helpful</div><br/><div id="37474117" class="c"><input type="checkbox" id="c-37474117" checked=""/><div class="controls bullet"><span class="by">d66</span><span>|</span><a href="#37473783">parent</a><span>|</span><a href="#37474158">next</a><span>|</span><label class="collapse" for="c-37474117">[-]</label><label class="expand" for="c-37474117">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  negation (~α): strings not matched by α
  difference (α - β): strings matched by α but not β
  intersection (α &amp; β): strings matched by α and β
  exclusive-or (α ^ β): strings matched by α or β but not both
  inclusion (α &gt; β): does α matches all strings β matches?
  equality (α = β): do α and β match exactly the same strings?</code></pre></div><br/></div></div></div></div><div id="37474158" class="c"><input type="checkbox" id="c-37474158" checked=""/><div class="controls bullet"><span class="by">themusicgod1</span><span>|</span><a href="#37473783">prev</a><span>|</span><a href="#37473440">next</a><span>|</span><label class="collapse" for="c-37474158">[-]</label><label class="expand" for="c-37474158">[1 more]</label></div><br/><div class="children"><div class="content">ugh STOP USING GITHUB</div><br/></div></div><div id="37473440" class="c"><input type="checkbox" id="c-37473440" checked=""/><div class="controls bullet"><span class="by">haltist</span><span>|</span><a href="#37474158">prev</a><span>|</span><label class="collapse" for="c-37473440">[-]</label><label class="expand" for="c-37473440">[5 more]</label></div><br/><div class="children"><div class="content">Can LLMs do this?</div><br/><div id="37473478" class="c"><input type="checkbox" id="c-37473478" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37473440">parent</a><span>|</span><label class="collapse" for="c-37473478">[-]</label><label class="expand" for="c-37473478">[4 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t use an LLM for anything that can be done 100% precisely, like this.</div><br/><div id="37473852" class="c"><input type="checkbox" id="c-37473852" checked=""/><div class="controls bullet"><span class="by">haltist</span><span>|</span><a href="#37473440">root</a><span>|</span><a href="#37473478">parent</a><span>|</span><label class="collapse" for="c-37473852">[-]</label><label class="expand" for="c-37473852">[3 more]</label></div><br/><div class="children"><div class="content">OK, just curious how LLMs are stacking up in logical tasks like this. I kept hearing we were close to AGI so just wondering how far there is to go.</div><br/><div id="37475101" class="c"><input type="checkbox" id="c-37475101" checked=""/><div class="controls bullet"><span class="by">clbrmbr</span><span>|</span><a href="#37473440">root</a><span>|</span><a href="#37473852">parent</a><span>|</span><a href="#37476769">next</a><span>|</span><label class="collapse" for="c-37475101">[-]</label><label class="expand" for="c-37475101">[1 more]</label></div><br/><div class="children"><div class="content">Humans can do these intersections, but we don’t do it by riffing off the top of our heads. We carefully develop and apply a formal system. LLMs are just (a very important) component.</div><br/></div></div><div id="37476769" class="c"><input type="checkbox" id="c-37476769" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37473440">root</a><span>|</span><a href="#37473852">parent</a><span>|</span><a href="#37475101">prev</a><span>|</span><label class="collapse" for="c-37476769">[-]</label><label class="expand" for="c-37476769">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been &quot;close&quot; to AGI for like 40+ years.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>