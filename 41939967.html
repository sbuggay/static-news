<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729846877298" as="style"/><link rel="stylesheet" href="styles.css?v=1729846877298"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.circle-lang.org/draft-profiles.html">Why Safety Profiles Failed</a> <span class="domain">(<a href="https://www.circle-lang.org">www.circle-lang.org</a>)</span></div><div class="subtext"><span>pjmlp</span> | <span>98 comments</span></div><br/><div><div id="41940723" class="c"><input type="checkbox" id="c-41940723" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#41941467">next</a><span>|</span><label class="collapse" for="c-41940723">[-]</label><label class="expand" for="c-41940723">[15 more]</label></div><br/><div class="children"><div class="content">At this point I&#x27;m wondering if the purpose of safety profiles is simply to serve as a distraction. In other words, safety profiles are just something people can point to when the topic of memory safety comes up, that’s it. The objectives of the initiative always seemed hopelessly optimistic, if not absurd. In particular, I don&#x27;t understand why littering a codebase with auto, const, constexpr, inline, [[nodiscard]], noexcept, etc is wonderful, yet lifetime annotations are somehow an intolerable tyranny.</div><br/><div id="41942648" class="c"><input type="checkbox" id="c-41942648" checked=""/><div class="controls bullet"><span class="by">rswail</span><span>|</span><a href="#41940723">parent</a><span>|</span><a href="#41941486">next</a><span>|</span><label class="collapse" for="c-41942648">[-]</label><label class="expand" for="c-41942648">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a tick-the-box-for-compliance item like when Microsoft had a POSIX layer for Windows NT.</div><br/></div></div><div id="41941486" class="c"><input type="checkbox" id="c-41941486" checked=""/><div class="controls bullet"><span class="by">ameliaquining</span><span>|</span><a href="#41940723">parent</a><span>|</span><a href="#41942648">prev</a><span>|</span><a href="#41942327">next</a><span>|</span><label class="collapse" for="c-41941486">[-]</label><label class="expand" for="c-41941486">[12 more]</label></div><br/><div class="children"><div class="content">I think maybe it&#x27;s because lifetime annotations can get arbitrarily complicated. If you look at enough Rust code you&#x27;ll definitely see some function signatures that make your head hurt, even if they&#x27;re vastly outnumbered by simple ones. A guarantee that the comprehension complexity of that part of your code will always be below some low ceiling is tempting.</div><br/><div id="41942266" class="c"><input type="checkbox" id="c-41942266" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41941486">parent</a><span>|</span><a href="#41941567">next</a><span>|</span><label class="collapse" for="c-41942266">[-]</label><label class="expand" for="c-41942266">[2 more]</label></div><br/><div class="children"><div class="content">The thing is, if you were to make the same design in C++ the code might look &quot;cleaner&quot; because there is less code&#x2F;fewer annotations, but the other side of that coin is that the <i>developer also has less information</i> about how things are meant to fit together. You not only lose the compiler having your back, you also don&#x27;t have useful documentation, even if that documentation would be too complicated to grasp at once. Without that documentation you might be fooled into thinking that you <i>do</i> understand what&#x27;s going on even if you don&#x27;t in reality.</div><br/><div id="41942610" class="c"><input type="checkbox" id="c-41942610" checked=""/><div class="controls bullet"><span class="by">yellow_lead</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41942266">parent</a><span>|</span><a href="#41941567">next</a><span>|</span><label class="collapse" for="c-41942610">[-]</label><label class="expand" for="c-41942610">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good point. There&#x27;s many times in a C++ codebase, where I&#x27;d see or write a seemingly innocuous function, but it has so many assumptions about lifetimes, threads, etc that it would make your brain hurt. Of course we try to remove those or add a comment, but it&#x27;s still difficult to deal with.</div><br/></div></div></div></div><div id="41941567" class="c"><input type="checkbox" id="c-41941567" checked=""/><div class="controls bullet"><span class="by">whimsicalism</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41941486">parent</a><span>|</span><a href="#41942266">prev</a><span>|</span><a href="#41942345">next</a><span>|</span><label class="collapse" for="c-41941567">[-]</label><label class="expand" for="c-41941567">[4 more]</label></div><br/><div class="children"><div class="content">Rust has nothing on template meta programming and the type signatures you get there, though</div><br/><div id="41941833" class="c"><input type="checkbox" id="c-41941833" checked=""/><div class="controls bullet"><span class="by">nickitolas</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41941567">parent</a><span>|</span><a href="#41941856">next</a><span>|</span><label class="collapse" for="c-41941833">[-]</label><label class="expand" for="c-41941833">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention the error messages when you get something slightly wrong</div><br/></div></div><div id="41941856" class="c"><input type="checkbox" id="c-41941856" checked=""/><div class="controls bullet"><span class="by">crest</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41941567">parent</a><span>|</span><a href="#41941833">prev</a><span>|</span><a href="#41942052">next</a><span>|</span><label class="collapse" for="c-41941856">[-]</label><label class="expand" for="c-41941856">[1 more]</label></div><br/><div class="children"><div class="content">Give the proc macro fans a little more time...</div><br/></div></div><div id="41942052" class="c"><input type="checkbox" id="c-41942052" checked=""/><div class="controls bullet"><span class="by">jimbob45</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41941567">parent</a><span>|</span><a href="#41941856">prev</a><span>|</span><a href="#41942345">next</a><span>|</span><label class="collapse" for="c-41942052">[-]</label><label class="expand" for="c-41942052">[1 more]</label></div><br/><div class="children"><div class="content">I’ve spent a fair amount of time writing C++ but F12’ing any of the std data structures makes me feel like I’ve never seen C++ before in my life.</div><br/></div></div></div></div><div id="41942345" class="c"><input type="checkbox" id="c-41942345" checked=""/><div class="controls bullet"><span class="by">myworkinisgood</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41941486">parent</a><span>|</span><a href="#41941567">prev</a><span>|</span><a href="#41942081">next</a><span>|</span><label class="collapse" for="c-41942345">[-]</label><label class="expand" for="c-41942345">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s because those people are lying. They are letting their egos and panic get to their technical decision making.</div><br/></div></div><div id="41942081" class="c"><input type="checkbox" id="c-41942081" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41941486">parent</a><span>|</span><a href="#41942345">prev</a><span>|</span><a href="#41942327">next</a><span>|</span><label class="collapse" for="c-41942081">[-]</label><label class="expand" for="c-41942081">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s deceptively easy to look at a number of examples and think: &quot;If I can see that aliasing would be a problem in this function, then a computer should be able to see that too.&quot;<p>The article states &quot;A C++ compiler can infer nothing about aliasing from a function declaration.&quot; Which is true, but assumes that the compiler only <i>looks</i> at the function declaration. In the examples given, an analyzer could look at the function bodies and propagate the aliasing requirements upward, attaching them to the function declaration in some internal data structure. Then the analyzer ensures that those functions are used correctly at every call site. Start at leaf functions and walk your way back up the program until you&#x27;re done. If you run into a situation where there is an ambiguity, you throw an error and let the developer know. Do the same for lifetimes. Heck, we just got &#x27;auto&#x27; type inference working in C++11, shouldn&#x27;t we be able to do this too?<p>I like not having to see and think about lifetimes and aliasing problems most of the time, and it would be nice if the compiler (or borrow checker) just kept track of those without requiring me to explicitly annotate them everywhere.</div><br/><div id="41942126" class="c"><input type="checkbox" id="c-41942126" checked=""/><div class="controls bullet"><span class="by">seanbax</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41942081">parent</a><span>|</span><a href="#41942649">next</a><span>|</span><label class="collapse" for="c-41942126">[-]</label><label class="expand" for="c-41942126">[1 more]</label></div><br/><div class="children"><div class="content">From P3465: &quot;why this is a scalable compile-time solution, because it requires only function-local analysis&quot;<p>From P1179: &quot;This paper ... shows how to efficiently diagnose many common cases of dangling (use-after-free) in C++ code, using only local analysis to report them as deterministic readable errors at compile time.&quot;<p>Local analysis only. It&#x27;s not looking in function definitions.<p>Whole program analysis is extremely complicated and costly to compute. It&#x27;s not comparable to return type deduction or something like that.</div><br/></div></div><div id="41942649" class="c"><input type="checkbox" id="c-41942649" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41942081">parent</a><span>|</span><a href="#41942126">prev</a><span>|</span><a href="#41942327">next</a><span>|</span><label class="collapse" for="c-41942649">[-]</label><label class="expand" for="c-41942649">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Start at leaf functions and walk your way back up the program until you&#x27;re done. If you run into a situation where there is an ambiguity, you throw an error and let the developer know.<p>This assumes no recursive functions, no virtual functions&#x2F;function pointers, no external functions etc etc<p>&gt; Heck, we just got &#x27;auto&#x27; type inference working in C++11, shouldn&#x27;t we be able to do this too?<p>Aliasing is much trickier than  type inference.<p>For example aliasing can change over time (i.e. some variables may alias at some point but not at a later point, while types are always the same) and you want any analysis to reflect it because you will likely rely on that.<p>Granularity is also much more important: does a pointer alias with every element of a vector or only one? The former is surely easier to represent, but it may unnecessary propagate and result in errors.<p>So effectively you have an infinite domain of places that can alias, while type inference is limited to locals, parameters, functions, etc etc. And even then, aliasing is quadratic, because you want to know which <i>pairs</i> of places alias.<p>I hope you can see how this can quickly get impractical, both due to the complexity of the analysis and the fact that small imprecisions can result in very big false positives.</div><br/><div id="41943253" class="c"><input type="checkbox" id="c-41943253" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#41940723">root</a><span>|</span><a href="#41942649">parent</a><span>|</span><a href="#41942327">next</a><span>|</span><label class="collapse" for="c-41943253">[-]</label><label class="expand" for="c-41943253">[1 more]</label></div><br/><div class="children"><div class="content">Hence the term &#x27;deceptively&#x27;.<p>Even if a sufficiently advanced proof assistant could internally maintain and  propagate constraints up through functions (eg. &#x27;vec must not alias x&#x27;), your point about small imprecisions cascading into large false positives is well made.<p>Bottom up constraints become increasingly difficult to untangle the further away they get from their inception, whereas top down rules such as &quot;no mutable aliasing&quot; are much easier to reason about locally.</div><br/></div></div></div></div></div></div></div></div><div id="41942327" class="c"><input type="checkbox" id="c-41942327" checked=""/><div class="controls bullet"><span class="by">myworkinisgood</span><span>|</span><a href="#41940723">parent</a><span>|</span><a href="#41941486">prev</a><span>|</span><a href="#41941467">next</a><span>|</span><label class="collapse" for="c-41942327">[-]</label><label class="expand" for="c-41942327">[1 more]</label></div><br/><div class="children"><div class="content">You are more correct than you think you are!!!</div><br/></div></div></div></div><div id="41941467" class="c"><input type="checkbox" id="c-41941467" checked=""/><div class="controls bullet"><span class="by">ameliaquining</span><span>|</span><a href="#41940723">prev</a><span>|</span><a href="#41942380">next</a><span>|</span><label class="collapse" for="c-41941467">[-]</label><label class="expand" for="c-41941467">[5 more]</label></div><br/><div class="children"><div class="content">These considerations all seem so self-evident that I can&#x27;t imagine the architects of Safety Profiles weren&#x27;t aware of them; they are basically just the statement of the problem. And yet these smart people presumably thought they had some kind of solution to them. Why did they think that? What did this solution look like? I would be very interested to read more context on this.</div><br/><div id="41941641" class="c"><input type="checkbox" id="c-41941641" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41941467">parent</a><span>|</span><a href="#41942329">next</a><span>|</span><label class="collapse" for="c-41941641">[-]</label><label class="expand" for="c-41941641">[2 more]</label></div><br/><div class="children"><div class="content">As always with different designs from smart people, it’s about priorities.<p>The profiles proposal focuses on a lack of annotations (I think there’s reasonable criticism that this isn’t achieved by it though…), and believing they can get 80% of the benefit for 20% of the effort (at least conceptually, obviously not those exact numbers). They aren’t shooting for full memory safety.<p>The Safe C++ proposal asks “how do we achieve 100% memory safety by default?”. And then asks what is needed to achieve that goal.</div><br/><div id="41942468" class="c"><input type="checkbox" id="c-41942468" checked=""/><div class="controls bullet"><span class="by">ameliaquining</span><span>|</span><a href="#41941467">root</a><span>|</span><a href="#41941641">parent</a><span>|</span><a href="#41942329">next</a><span>|</span><label class="collapse" for="c-41942468">[-]</label><label class="expand" for="c-41942468">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s with the &quot;this model detects all possible errors&quot; quote at the beginning of the post, then?</div><br/></div></div></div></div><div id="41942329" class="c"><input type="checkbox" id="c-41942329" checked=""/><div class="controls bullet"><span class="by">myworkinisgood</span><span>|</span><a href="#41941467">parent</a><span>|</span><a href="#41941641">prev</a><span>|</span><a href="#41941664">next</a><span>|</span><label class="collapse" for="c-41942329">[-]</label><label class="expand" for="c-41942329">[1 more]</label></div><br/><div class="children"><div class="content">They are lying.</div><br/></div></div></div></div><div id="41942380" class="c"><input type="checkbox" id="c-41942380" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#41941467">prev</a><span>|</span><a href="#41940251">next</a><span>|</span><label class="collapse" for="c-41942380">[-]</label><label class="expand" for="c-41942380">[1 more]</label></div><br/><div class="children"><div class="content">This article is really good, and covers many important issues.<p>There were many similar issues when it came to the earlier attempts to add concepts to C++ (which would improve template dispatch), although the outcome was more about improving C++ programmer&#x27;s lives, not safety.<p>It turned out trying to encapsulate all the things C++ functions, even in the standard library, as a list of concepts, was basically impossible. There are so many little corner-cases in C++ which  need representing as a concept, the list of &#x27;concepts&#x27; a function needed often ended up being longer than the function itself.</div><br/></div></div><div id="41940251" class="c"><input type="checkbox" id="c-41940251" checked=""/><div class="controls bullet"><span class="by">alilleybrinker</span><span>|</span><a href="#41942380">prev</a><span>|</span><a href="#41940568">next</a><span>|</span><label class="collapse" for="c-41940251">[-]</label><label class="expand" for="c-41940251">[1 more]</label></div><br/><div class="children"><div class="content">The article makes the particularly good point that you generally can’t effectively add new inferences without constraining optionality in code somehow. Put another way, you can’t draw new conclusions without new available assumptions.<p>In Sean’s “Safe C++” proposal, he extends C++ to enable new code to embed new assumptions, then subsets that extension to permit drawing new conclusions for safety by eliminating code that would violate the path to those safety conclusions.</div><br/></div></div><div id="41940568" class="c"><input type="checkbox" id="c-41940568" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41940251">prev</a><span>|</span><a href="#41943329">next</a><span>|</span><label class="collapse" for="c-41940568">[-]</label><label class="expand" for="c-41940568">[36 more]</label></div><br/><div class="children"><div class="content">Really glad to see this thorough examination of the weaknesses of profiles. Safe C++ is a really important project, and I hope the committee ends up making the right call here.</div><br/><div id="41940950" class="c"><input type="checkbox" id="c-41940950" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#41940568">parent</a><span>|</span><a href="#41942698">next</a><span>|</span><label class="collapse" for="c-41940950">[-]</label><label class="expand" for="c-41940950">[3 more]</label></div><br/><div class="children"><div class="content">&gt;...I hope the committee ends up making the right call here.<p>WG21 hasn&#x27;t been able to solve the <i>restrict</i> type qualifier, or make a better alternative, in over twenty years. IMO, hoping that WG21 adequately solves Safe C++ is nothing more than wishful thinking, to put it charitably.</div><br/><div id="41943484" class="c"><input type="checkbox" id="c-41943484" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940950">parent</a><span>|</span><a href="#41941086">next</a><span>|</span><label class="collapse" for="c-41943484">[-]</label><label class="expand" for="c-41943484">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this one is so weird. You&#x27;ve been able to do that forever in C, and virtually all big compilers have this keyword in C++ as well, just named __restrict. Why is it so hard to get into the standard, at least for pointers? I can imagine that there are complex semantics with regards to references that are tricky to get right, but can&#x27;t we at least have &quot;&#x27;restrict&quot; can only be used on raw pointer types, and it means the same thing as it does in C&quot;?</div><br/></div></div><div id="41941086" class="c"><input type="checkbox" id="c-41941086" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940950">parent</a><span>|</span><a href="#41943484">prev</a><span>|</span><a href="#41942698">next</a><span>|</span><label class="collapse" for="c-41941086">[-]</label><label class="expand" for="c-41941086">[1 more]</label></div><br/><div class="children"><div class="content">I am intimately familiar with the dysfunctions of various language committees.<p>I never said it would be easy, or probable. But I’m also the kind who hopes for the best.</div><br/></div></div></div></div><div id="41942698" class="c"><input type="checkbox" id="c-41942698" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41940568">parent</a><span>|</span><a href="#41940950">prev</a><span>|</span><a href="#41943369">next</a><span>|</span><label class="collapse" for="c-41942698">[-]</label><label class="expand" for="c-41942698">[1 more]</label></div><br/><div class="children"><div class="content">Given how C++0x concepts, C++20 contracts, ABI discussion went down, where key people involved on those processes left to other programming language communities, not sure if the right call will be done in the end.<p>This is a very political subject, and WG21 doesn&#x27;t have a core team, rather everything goes through votes.<p>It suffices to have the wrong count in the room when it is time to vote.</div><br/></div></div><div id="41943369" class="c"><input type="checkbox" id="c-41943369" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#41940568">parent</a><span>|</span><a href="#41942698">prev</a><span>|</span><a href="#41942338">next</a><span>|</span><label class="collapse" for="c-41943369">[-]</label><label class="expand" for="c-41943369">[1 more]</label></div><br/><div class="children"><div class="content">I have a long standing debate with a friend about whether the future of C++ will be evolution or extinction.<p>Safe C++ looks excellent - its adoption would go a long way toward validating his steadfast belief that C++ can evolve to keep up with the world.</div><br/></div></div><div id="41942338" class="c"><input type="checkbox" id="c-41942338" checked=""/><div class="controls bullet"><span class="by">myworkinisgood</span><span>|</span><a href="#41940568">parent</a><span>|</span><a href="#41943369">prev</a><span>|</span><a href="#41940637">next</a><span>|</span><label class="collapse" for="c-41942338">[-]</label><label class="expand" for="c-41942338">[3 more]</label></div><br/><div class="children"><div class="content">Profiles it the wunderkind and magic child of people in  committee like Bjarne and GDR, who are lying their way to get their way, and people are too afraid to call them out on it.</div><br/><div id="41943444" class="c"><input type="checkbox" id="c-41943444" checked=""/><div class="controls bullet"><span class="by">biorach</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41942338">parent</a><span>|</span><a href="#41943311">next</a><span>|</span><label class="collapse" for="c-41943444">[-]</label><label class="expand" for="c-41943444">[1 more]</label></div><br/><div class="children"><div class="content">Wild accusations without any backup... please don&#x27;t.</div><br/></div></div><div id="41943311" class="c"><input type="checkbox" id="c-41943311" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41942338">parent</a><span>|</span><a href="#41943444">prev</a><span>|</span><a href="#41940637">next</a><span>|</span><label class="collapse" for="c-41943311">[-]</label><label class="expand" for="c-41943311">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with the politics there. What do they get by having their way?</div><br/></div></div></div></div><div id="41940637" class="c"><input type="checkbox" id="c-41940637" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#41940568">parent</a><span>|</span><a href="#41942338">prev</a><span>|</span><a href="#41943329">next</a><span>|</span><label class="collapse" for="c-41940637">[-]</label><label class="expand" for="c-41940637">[27 more]</label></div><br/><div class="children"><div class="content">&gt; Safe C++ is a really important project<p>What makes you say this? It seems to me like we already have a lower-overhead approach to reach the same goal (a low-level language with substantially improved semantic specificity, memory safety, etc.); namely, we have Rust, which has already improved substantially over the safety properties of C++, and offers a better-designed platform for further safety research.</div><br/><div id="41940821" class="c"><input type="checkbox" id="c-41940821" checked=""/><div class="controls bullet"><span class="by">alilleybrinker</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940637">parent</a><span>|</span><a href="#41940654">next</a><span>|</span><label class="collapse" for="c-41940821">[-]</label><label class="expand" for="c-41940821">[8 more]</label></div><br/><div class="children"><div class="content">Not everything will be rewritten in Rust. I&#x27;ve broken down the arguments for why this is, and why it&#x27;s a good thing, elsewhere [1].<p>Google&#x27;s recent analysis on their own experiences transitioning toward memory safety provide even more evidence that you don&#x27;t need to fully transition to get strong safety benefits. They incentivized moving new code to memory safe languages, and continued working to actively assure the existing memory unsafe code they had. In practice, they found that vulnerability density in a stable codebase decays exponentially as you continue to fix bugs. So you can reap the benefits of built-in memory safety for new code while driving down latent memory unsafety in existing code to great effect. [2]<p>[1]: <a href="https:&#x2F;&#x2F;www.alilleybrinker.com&#x2F;blog&#x2F;cpp-must-become-safer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.alilleybrinker.com&#x2F;blog&#x2F;cpp-must-become-safer&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;09&#x2F;eliminating-memory-safety-vulnerabilities-Android.html" rel="nofollow">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;09&#x2F;eliminating-memory-s...</a></div><br/><div id="41943439" class="c"><input type="checkbox" id="c-41943439" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940821">parent</a><span>|</span><a href="#41941274">next</a><span>|</span><label class="collapse" for="c-41943439">[-]</label><label class="expand" for="c-41943439">[1 more]</label></div><br/><div class="children"><div class="content">Nah. The idea that sustained bugfixing could occur on a project that was not undergoing active development is purely wishful thinking, as is the idea that a project could continue to provide useful functionality without vulnerabilities becoming newly exposed. And the idea of a meaningfully safer C++ is something that has been tried and failed for 20+ years.<p>Eventually everything will be rewritten in Rust or successors thereof. It&#x27;s the only approach that works, and the only approach that <i>can</i> work, and as the cost of bugs continues to increase, continuing to use memory-unsafe code will cease to be a viable option.</div><br/></div></div><div id="41941274" class="c"><input type="checkbox" id="c-41941274" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940821">parent</a><span>|</span><a href="#41943439">prev</a><span>|</span><a href="#41940654">next</a><span>|</span><label class="collapse" for="c-41941274">[-]</label><label class="expand" for="c-41941274">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Not everything will be rewritten in Rust.<p>Yeah, but it&#x27;s also not going to be rewritten in safe C++.</div><br/><div id="41941447" class="c"><input type="checkbox" id="c-41941447" checked=""/><div class="controls bullet"><span class="by">pavon</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41941274">parent</a><span>|</span><a href="#41941428">next</a><span>|</span><label class="collapse" for="c-41941447">[-]</label><label class="expand" for="c-41941447">[3 more]</label></div><br/><div class="children"><div class="content">Why not? C++ has evolved over the years, and every C++ project I have worked on, we&#x27;ve adopted new features that make the language safer or clearer as they are supported by the compilers we target.  It doesn&#x27;t get applied to the entire codebase overnight, but all new code uses these features, refactors adopt them as much as possible, and classes of bugs found by static code scanning cause them to be adopted sprinkled through the rest of the code. Our C++ software is more stable than it has ever been because of it.<p>Meanwhile, throwing everything away and rewriting it from scratch in another language has never been an option for any of those projects. Furthermore, even when there has been interest and buy-in to incrementally move to Rust in principle, in practice most of the time we evaluate using Rust for new features, the amount of existing code it must touch and the difficulty integrating Rust and C++ meant that we usually ended up using C++ instead.<p>If features of Circle C++ were standardized, or at least stabilized with wider support, we would certainly start adopting them as well.</div><br/><div id="41941500" class="c"><input type="checkbox" id="c-41941500" checked=""/><div class="controls bullet"><span class="by">ameliaquining</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41941447">parent</a><span>|</span><a href="#41941728">next</a><span>|</span><label class="collapse" for="c-41941500">[-]</label><label class="expand" for="c-41941500">[1 more]</label></div><br/><div class="children"><div class="content">What I&#x27;m really hoping is that <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;crubit">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;crubit</a> eventually gets good enough to facilitate incremental migration of brownfield C++ codebases to Rust. That seems like it would address this concern.</div><br/></div></div><div id="41941728" class="c"><input type="checkbox" id="c-41941728" checked=""/><div class="controls bullet"><span class="by">safercplusplus</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41941447">parent</a><span>|</span><a href="#41941500">prev</a><span>|</span><a href="#41941428">next</a><span>|</span><label class="collapse" for="c-41941728">[-]</label><label class="expand" for="c-41941728">[1 more]</label></div><br/><div class="children"><div class="content">You might consider experimenting with the scpptool-enforced safe subset of C++ (my project). It should be even less disruptive.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;duneroadrunner&#x2F;scpptool">https:&#x2F;&#x2F;github.com&#x2F;duneroadrunner&#x2F;scpptool</a></div><br/></div></div></div></div><div id="41941428" class="c"><input type="checkbox" id="c-41941428" checked=""/><div class="controls bullet"><span class="by">alilleybrinker</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41941274">parent</a><span>|</span><a href="#41941447">prev</a><span>|</span><a href="#41941698">next</a><span>|</span><label class="collapse" for="c-41941428">[-]</label><label class="expand" for="c-41941428">[1 more]</label></div><br/><div class="children"><div class="content">There’s likely some amount of code which would not be rewritten into Rust but which would be rewritten into safe C++. Migrating to a whole new language is a much bigger lift than updating the compiler you’re already using and then modifying code to use things the newer compiler supports. Projects do the latter all the time.</div><br/></div></div><div id="41941698" class="c"><input type="checkbox" id="c-41941698" checked=""/><div class="controls bullet"><span class="by">safercplusplus</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41941274">parent</a><span>|</span><a href="#41941428">prev</a><span>|</span><a href="#41940654">next</a><span>|</span><label class="collapse" for="c-41941698">[-]</label><label class="expand" for="c-41941698">[1 more]</label></div><br/><div class="children"><div class="content">In theory it could be auto-converted to a safe subset of C++ [1]. In theory it could be done at build-time, like the sanitizers.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;duneroadrunner&#x2F;SaferCPlusPlus-AutoTranslation2">https:&#x2F;&#x2F;github.com&#x2F;duneroadrunner&#x2F;SaferCPlusPlus-AutoTransla...</a></div><br/></div></div></div></div></div></div><div id="41940654" class="c"><input type="checkbox" id="c-41940654" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940637">parent</a><span>|</span><a href="#41940821">prev</a><span>|</span><a href="#41940658">next</a><span>|</span><label class="collapse" for="c-41940654">[-]</label><label class="expand" for="c-41940654">[8 more]</label></div><br/><div class="children"><div class="content">I am pro any movement towards memory safety. Sure, I won&#x27;t stop writing Rust and start moving towards C++ for this. But not everyone is interested in introducing a second toolchain, for example. Also, as this paper mentions, Safe C++ can improve C++ &lt;-&gt; Rust interop, because Safe C++ can express some semantics Rust can understand. Right now, interop works but isn&#x27;t very nice.<p>Basically, I want a variety of approaches, not a Rust monoculture.</div><br/><div id="41942012" class="c"><input type="checkbox" id="c-41942012" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940654">parent</a><span>|</span><a href="#41940658">next</a><span>|</span><label class="collapse" for="c-41942012">[-]</label><label class="expand" for="c-41942012">[7 more]</label></div><br/><div class="children"><div class="content">&gt; But not everyone is interested in introducing a second toolchain, for example.<p>Not that this invalidates your broader point about Safe C++, but this particular issue could also be solved by Rust shipping clang &#x2F; a frontend that can also compile C and C++.</div><br/><div id="41942060" class="c"><input type="checkbox" id="c-41942060" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41942012">parent</a><span>|</span><a href="#41942524">next</a><span>|</span><label class="collapse" for="c-41942060">[-]</label><label class="expand" for="c-41942060">[4 more]</label></div><br/><div class="children"><div class="content">I have long thought that rust needs to copy Zig here but nobody seems to want to do it, so…</div><br/><div id="41942101" class="c"><input type="checkbox" id="c-41942101" checked=""/><div class="controls bullet"><span class="by">anp</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41942060">parent</a><span>|</span><a href="#41942153">next</a><span>|</span><label class="collapse" for="c-41942101">[-]</label><label class="expand" for="c-41942101">[2 more]</label></div><br/><div class="children"><div class="content">I’ve often joked that rustup with a little buildscript copy&#x2F;paste to use the cc crate could be the fastest way to set up a C++ toolchain and project on lots of systems, but I also haven’t received much enthusiasm on the topic from people involved more with upstream.</div><br/><div id="41942298" class="c"><input type="checkbox" id="c-41942298" checked=""/><div class="controls bullet"><span class="by">citelao</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41942101">parent</a><span>|</span><a href="#41942153">next</a><span>|</span><label class="collapse" for="c-41942298">[-]</label><label class="expand" for="c-41942298">[1 more]</label></div><br/><div class="children"><div class="content">I did that yesterday with a project: I took a Rust package that compiled a C project, then had the Rust project generate a C-compatible DLL that I could consume in dotnet.<p>It was so much easier (for me; I am bad at build systems) that I plan to do that for future projects.<p>There’s just something about `cargo run`…</div><br/></div></div></div></div><div id="41942153" class="c"><input type="checkbox" id="c-41942153" checked=""/><div class="controls bullet"><span class="by">evntdrvn</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41942060">parent</a><span>|</span><a href="#41942101">prev</a><span>|</span><a href="#41942524">next</a><span>|</span><label class="collapse" for="c-41942153">[-]</label><label class="expand" for="c-41942153">[1 more]</label></div><br/><div class="children"><div class="content">how about just having rustup bundle zig as part of its tooling… It would make getting Rust going on Windows ten times easier, among a bunch of other benefits.</div><br/></div></div></div></div><div id="41942524" class="c"><input type="checkbox" id="c-41942524" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41942012">parent</a><span>|</span><a href="#41942060">prev</a><span>|</span><a href="#41940658">next</a><span>|</span><label class="collapse" for="c-41942524">[-]</label><label class="expand" for="c-41942524">[2 more]</label></div><br/><div class="children"><div class="content">On the one hand, I think that it would be a winning strategy. On the other, that effectively turns C++ part of the Rust language. And that is even before looking at the need to extend the Rust compiler to express things that the Rust language doesn&#x27;t have&#x2F;need but C++ does, like move constructors.</div><br/><div id="41942594" class="c"><input type="checkbox" id="c-41942594" checked=""/><div class="controls bullet"><span class="by">gauge_field</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41942524">parent</a><span>|</span><a href="#41940658">next</a><span>|</span><label class="collapse" for="c-41942594">[-]</label><label class="expand" for="c-41942594">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure if you understand the parent correctly (or I understand your reply). They mean shipping a different C&#x2F;C+ frontend (e.g. Clang) together with Rust, which does not require any change in Rust frontend</div><br/></div></div></div></div></div></div></div></div><div id="41940658" class="c"><input type="checkbox" id="c-41940658" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940637">parent</a><span>|</span><a href="#41940654">prev</a><span>|</span><a href="#41940762">next</a><span>|</span><label class="collapse" for="c-41940658">[-]</label><label class="expand" for="c-41940658">[3 more]</label></div><br/><div class="children"><div class="content">This is a thread about a C++ language feature; it&#x27;s probably most productive for us to stipulate for this thread that C++ will continue to exist. Practical lessons C++ can learn moving forward from Rust are a good reason to talk about Rust; &quot;C++ should not be improved for safety because code can be rewritten in Rust&quot; is less useful.</div><br/><div id="41941281" class="c"><input type="checkbox" id="c-41941281" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940658">parent</a><span>|</span><a href="#41940762">next</a><span>|</span><label class="collapse" for="c-41941281">[-]</label><label class="expand" for="c-41941281">[2 more]</label></div><br/><div class="children"><div class="content">Actually, this subthread is about whether this is a &quot;really important project&quot;</div><br/><div id="41941519" class="c"><input type="checkbox" id="c-41941519" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41941281">parent</a><span>|</span><a href="#41940762">next</a><span>|</span><label class="collapse" for="c-41941519">[-]</label><label class="expand" for="c-41941519">[1 more]</label></div><br/><div class="children"><div class="content"><i>to the C++ language</i></div><br/></div></div></div></div></div></div><div id="41940762" class="c"><input type="checkbox" id="c-41940762" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940637">parent</a><span>|</span><a href="#41940658">prev</a><span>|</span><a href="#41941245">next</a><span>|</span><label class="collapse" for="c-41940762">[-]</label><label class="expand" for="c-41940762">[3 more]</label></div><br/><div class="children"><div class="content">Things like web browsers will continue to have millions of lines of C++ code regardless of how successful Rust becomes. It would be a huge improvement for everyone if such projects had a tractable path towards memory safety</div><br/><div id="41941290" class="c"><input type="checkbox" id="c-41941290" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940762">parent</a><span>|</span><a href="#41941245">next</a><span>|</span><label class="collapse" for="c-41941290">[-]</label><label class="expand" for="c-41941290">[2 more]</label></div><br/><div class="children"><div class="content">As this article discusses, it&#x27;s not really viable that existing codebases will be able to benefit from safe C++ research without massive rewrites anyway</div><br/><div id="41941478" class="c"><input type="checkbox" id="c-41941478" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41941290">parent</a><span>|</span><a href="#41941245">next</a><span>|</span><label class="collapse" for="c-41941478">[-]</label><label class="expand" for="c-41941478">[1 more]</label></div><br/><div class="children"><div class="content">Yes, absolutely. But it is still easier and more practical for those codebases to write new functionality in a Safe C++ dialect than it would be to use Rust.</div><br/></div></div></div></div></div></div><div id="41941245" class="c"><input type="checkbox" id="c-41941245" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940637">parent</a><span>|</span><a href="#41940762">prev</a><span>|</span><a href="#41940771">next</a><span>|</span><label class="collapse" for="c-41941245">[-]</label><label class="expand" for="c-41941245">[2 more]</label></div><br/><div class="children"><div class="content">For new projects on mainstream architectures that don&#x27;t have to depend on legacy C++ baggage, Rust is great (and, I think, practically always the better choice).<p>But, realistically, C++ will survive for as long as global technological civilization does. There are still people out there maintaining Fortran codebases.<p>(also, IDK if you already realized this, but it&#x27;s funny that the person you&#x27;re replying to is one of the most famous Rust boosters out there, in fact probably the most famous, at least on HN).</div><br/><div id="41941413" class="c"><input type="checkbox" id="c-41941413" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41941245">parent</a><span>|</span><a href="#41940771">next</a><span>|</span><label class="collapse" for="c-41941413">[-]</label><label class="expand" for="c-41941413">[1 more]</label></div><br/><div class="children"><div class="content">I have realized this. Sean and I have talked about it.<p>I became a Rust fan because of its innovations in the space. That its innovations may spread elsewhere is a good thing, not a bad thing. If a language comes along that speaks to me more than Rust does, I’ll switch to that. I’m not a partisan, even if it may feel that way from the outside.</div><br/></div></div></div></div><div id="41940771" class="c"><input type="checkbox" id="c-41940771" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940637">parent</a><span>|</span><a href="#41941245">prev</a><span>|</span><a href="#41943329">next</a><span>|</span><label class="collapse" for="c-41940771">[-]</label><label class="expand" for="c-41940771">[2 more]</label></div><br/><div class="children"><div class="content">Cool.<p>Do you mind if we have more than one approach?</div><br/><div id="41941284" class="c"><input type="checkbox" id="c-41941284" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#41940568">root</a><span>|</span><a href="#41940771">parent</a><span>|</span><a href="#41943329">next</a><span>|</span><label class="collapse" for="c-41941284">[-]</label><label class="expand" for="c-41941284">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it does not matter to me, but that wasn&#x27;t what we were talking about</div><br/></div></div></div></div></div></div></div></div><div id="41943329" class="c"><input type="checkbox" id="c-41943329" checked=""/><div class="controls bullet"><span class="by">mimd</span><span>|</span><a href="#41940568">prev</a><span>|</span><a href="#41941238">next</a><span>|</span><label class="collapse" for="c-41943329">[-]</label><label class="expand" for="c-41943329">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused over lines such as &quot;Profiles have to reject pointer arithmetic, because there’s no static analysis protection against indexing past the end of the allocation.&quot; Can&#x27;t frama-c&#x2F;etc do that? Additionally, section 2.3 is narrower than what is implied by the words &quot;safe&quot; and &quot;out-of-contract&quot; and is more concerned with what C&#x2F;C++ call &quot;undefined behavior&quot; requirements than contract correctness. Ie. An integer which is defined to wrap overflows and violates the requirement of the function contract, which I can cause in a safe release build rust.</div><br/><div id="41943387" class="c"><input type="checkbox" id="c-41943387" checked=""/><div class="controls bullet"><span class="by">bjornsing</span><span>|</span><a href="#41943329">parent</a><span>|</span><a href="#41941238">next</a><span>|</span><label class="collapse" for="c-41943387">[-]</label><label class="expand" for="c-41943387">[1 more]</label></div><br/><div class="children"><div class="content">How is it supposed to do that (in the general case)? If I write a C++ program that will index out of bounds iif the Riemann hypothesis is true, then frama-c would have to win the millennium prize to do its job. I bet it can’t.</div><br/></div></div></div></div><div id="41941238" class="c"><input type="checkbox" id="c-41941238" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#41943329">prev</a><span>|</span><a href="#41943191">next</a><span>|</span><label class="collapse" for="c-41941238">[-]</label><label class="expand" for="c-41941238">[4 more]</label></div><br/><div class="children"><div class="content">I know Sean said on Twitter that he probably won&#x27;t submit this to WG21, but I wish he would...  It is a fantastic rebuttal of certain individual&#x27;s continued hand-waving about how C++ is safe enough as-is.</div><br/><div id="41941509" class="c"><input type="checkbox" id="c-41941509" checked=""/><div class="controls bullet"><span class="by">bfrog</span><span>|</span><a href="#41941238">parent</a><span>|</span><a href="#41942341">next</a><span>|</span><label class="collapse" for="c-41941509">[-]</label><label class="expand" for="c-41941509">[2 more]</label></div><br/><div class="children"><div class="content">This seems to be a common theme with many c++ developers honestly.</div><br/><div id="41941839" class="c"><input type="checkbox" id="c-41941839" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41941238">root</a><span>|</span><a href="#41941509">parent</a><span>|</span><a href="#41942341">next</a><span>|</span><label class="collapse" for="c-41941839">[-]</label><label class="expand" for="c-41941839">[1 more]</label></div><br/><div class="children"><div class="content">Some of them are unfortunately on language committees.</div><br/></div></div></div></div><div id="41942341" class="c"><input type="checkbox" id="c-41942341" checked=""/><div class="controls bullet"><span class="by">myworkinisgood</span><span>|</span><a href="#41941238">parent</a><span>|</span><a href="#41941509">prev</a><span>|</span><a href="#41943191">next</a><span>|</span><label class="collapse" for="c-41942341">[-]</label><label class="expand" for="c-41942341">[1 more]</label></div><br/><div class="children"><div class="content">You mean certain individual&#x27;s lying?</div><br/></div></div></div></div><div id="41943191" class="c"><input type="checkbox" id="c-41943191" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#41941238">prev</a><span>|</span><a href="#41941561">next</a><span>|</span><label class="collapse" for="c-41943191">[-]</label><label class="expand" for="c-41943191">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A C++ compiler can infer nothing about aliasing from a function declaration.<p>True.
but you don&#x27;t solely rely on the declaration, do you?
lots of power comes from static analysis.</div><br/></div></div><div id="41941561" class="c"><input type="checkbox" id="c-41941561" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41943191">prev</a><span>|</span><a href="#41941069">next</a><span>|</span><label class="collapse" for="c-41941561">[-]</label><label class="expand" for="c-41941561">[2 more]</label></div><br/><div class="children"><div class="content">What actually is this circle-lang site, and who runs it? The main page seems to just redirect to example.com, and I don&#x27;t recognize the name of the author.</div><br/><div id="41941582" class="c"><input type="checkbox" id="c-41941582" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41941561">parent</a><span>|</span><a href="#41941069">next</a><span>|</span><label class="collapse" for="c-41941582">[-]</label><label class="expand" for="c-41941582">[1 more]</label></div><br/><div class="children"><div class="content">Circle is a C++ compiler by Sean Baxter, with various extensions. One of those is an implementation of the Safe C++ proposal I’ve linked downthread.</div><br/></div></div></div></div><div id="41941069" class="c"><input type="checkbox" id="c-41941069" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41941561">prev</a><span>|</span><a href="#41940672">next</a><span>|</span><label class="collapse" for="c-41941069">[-]</label><label class="expand" for="c-41941069">[6 more]</label></div><br/><div class="children"><div class="content">Section 6 seems to propose adding essentially every Rust feature to C++? Am I reading that right?  Why would someone use this new proposed C++-with-Rust-annotations in place of just Rust?</div><br/><div id="41943449" class="c"><input type="checkbox" id="c-41943449" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41941069">parent</a><span>|</span><a href="#41941097">next</a><span>|</span><label class="collapse" for="c-41943449">[-]</label><label class="expand" for="c-41943449">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why would someone use this new proposed C++-with-Rust-annotations in place of just Rust?<p>They wouldn&#x27;t. The point is, if you were serious about making a memory-safe C++, this is what you&#x27;d need to do.</div><br/></div></div><div id="41941097" class="c"><input type="checkbox" id="c-41941097" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41941069">parent</a><span>|</span><a href="#41943449">prev</a><span>|</span><a href="#41942600">next</a><span>|</span><label class="collapse" for="c-41941097">[-]</label><label class="expand" for="c-41941097">[1 more]</label></div><br/><div class="children"><div class="content">Because the millions of lines of existing C++ aren&#x27;t going anywhere. You need transition capability if you&#x27;re ever gonna see widespread adoption. See: C++&#x27;s own adoption story; transpiling into C to get wider adoption into existing codebases.</div><br/></div></div><div id="41942600" class="c"><input type="checkbox" id="c-41942600" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41941069">parent</a><span>|</span><a href="#41941097">prev</a><span>|</span><a href="#41941080">next</a><span>|</span><label class="collapse" for="c-41942600">[-]</label><label class="expand" for="c-41942600">[1 more]</label></div><br/><div class="children"><div class="content">Features C++ has that Rust doesn&#x27;t:<p>* template specialisations<p>* function overloading<p>* I believe const generics is still not there in Rust, or its necessarily more restricted.<p>In general metaprogramming facilities are more expressive in C++, with different other tradeoffs to Rust. But the tradeoffs don&#x27;t include memory safety.</div><br/></div></div><div id="41941080" class="c"><input type="checkbox" id="c-41941080" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41941069">parent</a><span>|</span><a href="#41942600">prev</a><span>|</span><a href="#41941455">next</a><span>|</span><label class="collapse" for="c-41941080">[-]</label><label class="expand" for="c-41941080">[1 more]</label></div><br/><div class="children"><div class="content">Here’s the actual proposal: <a href="https:&#x2F;&#x2F;safecpp.org&#x2F;draft.html" rel="nofollow">https:&#x2F;&#x2F;safecpp.org&#x2F;draft.html</a><p>It explains its own motivation.</div><br/></div></div><div id="41941455" class="c"><input type="checkbox" id="c-41941455" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#41941069">parent</a><span>|</span><a href="#41941080">prev</a><span>|</span><a href="#41940672">next</a><span>|</span><label class="collapse" for="c-41941455">[-]</label><label class="expand" for="c-41941455">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Why would someone use this new proposed C++-with-Rust-annotations in place of just Rust?<p>Simply making C++ compilers compatible with one another is a constant struggle. Making Rust work well with existing C++ code is even more difficult. Thus, it is far easier to make something like Clang understand and compile C++-specific annotations alongside legacy C++ code than making rustc understand C++ types. Moreover, teams of C++ programmers will have an easier time writing annotated C++ than they would learning an entirely new language. And it&#x27;s important to recognize how deeply entrenched C++ is in many areas, especially when you consider things like OpenMP, OpenACC, CUDA, HIP&#x2F;ROCm, Kokkos, etc etc <i>etc</i>.</div><br/></div></div></div></div><div id="41940672" class="c"><input type="checkbox" id="c-41940672" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41941069">prev</a><span>|</span><a href="#41941645">next</a><span>|</span><label class="collapse" for="c-41940672">[-]</label><label class="expand" for="c-41940672">[23 more]</label></div><br/><div class="children"><div class="content">&quot;No mutable aliases&quot; is a mistake; it prevents many useful programs.<p>Now that virtual address space is cheap, it&#x27;s <i>possible</i> to recompile C (or presumably C++) with a fully-safe runtime (requiring annotation only around nasty things like `union sigval`), but this is an ABI break and has nontrivial overhead (note that AddressSanitizers has ~2x overhead and only catches some optimistic cases) unless you mandate additional annotation.</div><br/><div id="41940707" class="c"><input type="checkbox" id="c-41940707" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41940672">parent</a><span>|</span><a href="#41942615">next</a><span>|</span><label class="collapse" for="c-41940707">[-]</label><label class="expand" for="c-41940707">[1 more]</label></div><br/><div class="children"><div class="content">&gt; AddressSanitizer has ~2x overhead<p>I’ve got some programs where the ASan overhead is 10× or more. Admittedly, they are somewhat peculiar—one’s an interpreter for a low-level bytecode, the other’s largely a do-nothing benchmark for measuring the overhead of a heartbeat scheduler. The point is, the overhead can vary a lot depending on e.g. how many mallocs your code does.<p>This does not contradict your point in any way, to be clear. I was just very surprised when I first hit that behaviour expecting ASan’s usual overhead of “not bad, definitely not Valgrind”, so I wanted to share it.</div><br/></div></div><div id="41942615" class="c"><input type="checkbox" id="c-41942615" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41940672">parent</a><span>|</span><a href="#41940707">prev</a><span>|</span><a href="#41940789">next</a><span>|</span><label class="collapse" for="c-41942615">[-]</label><label class="expand" for="c-41942615">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t deploy ASAN builds to production, it&#x27;s a debugging tool. It might very well introduce attack vectors on its own, it&#x27;s not designed to be a hardening feature.</div><br/></div></div><div id="41940789" class="c"><input type="checkbox" id="c-41940789" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#41940672">parent</a><span>|</span><a href="#41942615">prev</a><span>|</span><a href="#41940749">next</a><span>|</span><label class="collapse" for="c-41940789">[-]</label><label class="expand" for="c-41940789">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it prevents many useful programs<p>Every set of constraints prevents many useful programs. If those useful programs can still be specified in slightly different ways but it prevents many more <i>broken</i> programs, those constraints may be a net improvement on the status quo.</div><br/></div></div><div id="41940749" class="c"><input type="checkbox" id="c-41940749" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41940672">parent</a><span>|</span><a href="#41940789">prev</a><span>|</span><a href="#41941568">next</a><span>|</span><label class="collapse" for="c-41940749">[-]</label><label class="expand" for="c-41940749">[6 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;No mutable aliases&quot; is a mistake; it prevents many useful programs.<p>Does it? You didn&#x27;t list any. It certainly prevents writing a tremendous number of programs which are nonsense.</div><br/><div id="41940813" class="c"><input type="checkbox" id="c-41940813" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940749">parent</a><span>|</span><a href="#41942073">next</a><span>|</span><label class="collapse" for="c-41940813">[-]</label><label class="expand" for="c-41940813">[4 more]</label></div><br/><div class="children"><div class="content">The entirety of Rust&#x27;s `std::cell` is a confession that yes, we really do need mutable aliases. We just pretend they the aliases aren&#x27;t mutable except for a nanosecond around the actual mutation.</div><br/><div id="41940845" class="c"><input type="checkbox" id="c-41940845" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940813">parent</a><span>|</span><a href="#41940831">next</a><span>|</span><label class="collapse" for="c-41940845">[-]</label><label class="expand" for="c-41940845">[1 more]</label></div><br/><div class="children"><div class="content">It’s more than that, they disable the aliasing based optimizations, and provide APIs that restrict how and when you can mutate in order to make sure data races don’t happen.<p>Controlled mutable aliasing is fine. Uncontrolled is dangerous.</div><br/></div></div><div id="41940831" class="c"><input type="checkbox" id="c-41940831" checked=""/><div class="controls bullet"><span class="by">alilleybrinker</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940813">parent</a><span>|</span><a href="#41940845">prev</a><span>|</span><a href="#41940958">next</a><span>|</span><label class="collapse" for="c-41940831">[-]</label><label class="expand" for="c-41940831">[1 more]</label></div><br/><div class="children"><div class="content">Alternatively, Rust&#x27;s cell types are proof that you usually don&#x27;t need mutable aliasing, and you can have it at hand when you need it while reaping the benefits of stronger static guarantees without it most of the time.</div><br/></div></div><div id="41940958" class="c"><input type="checkbox" id="c-41940958" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940813">parent</a><span>|</span><a href="#41940831">prev</a><span>|</span><a href="#41942073">next</a><span>|</span><label class="collapse" for="c-41940958">[-]</label><label class="expand" for="c-41940958">[1 more]</label></div><br/><div class="children"><div class="content">Cells still don&#x27;t allow <i>simultaneous</i> mutable aliases; they just allow the partitioning of regions of mutable access to occur at runtime rather than compile time.</div><br/></div></div></div></div><div id="41942073" class="c"><input type="checkbox" id="c-41942073" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940749">parent</a><span>|</span><a href="#41940813">prev</a><span>|</span><a href="#41941568">next</a><span>|</span><label class="collapse" for="c-41942073">[-]</label><label class="expand" for="c-41942073">[1 more]</label></div><br/><div class="children"><div class="content">OP mentioned std::sort and the rest of std::algorithm as useful functions that use mutable aliasing.</div><br/></div></div></div></div><div id="41941568" class="c"><input type="checkbox" id="c-41941568" checked=""/><div class="controls bullet"><span class="by">morning-coffee</span><span>|</span><a href="#41940672">parent</a><span>|</span><a href="#41940749">prev</a><span>|</span><a href="#41942003">next</a><span>|</span><label class="collapse" for="c-41941568">[-]</label><label class="expand" for="c-41941568">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;No mutable aliases&quot; is a mistake; it prevents many useful programs.<p>Yes, it prevents many useful programs.<p>I think it also prevents many many many more useless broken incorrect programs from wreaking havoc or being used as exploit delivery vehicles.</div><br/></div></div><div id="41942003" class="c"><input type="checkbox" id="c-41942003" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41940672">parent</a><span>|</span><a href="#41941568">prev</a><span>|</span><a href="#41940706">next</a><span>|</span><label class="collapse" for="c-41942003">[-]</label><label class="expand" for="c-41942003">[4 more]</label></div><br/><div class="children"><div class="content">How would this fix memory safety issues like std::sort(vec1.begin(), vec2.end()) (where vec1 and vec2 are different vectors, of course)? Or strlen(malloc(100))?</div><br/><div id="41943486" class="c"><input type="checkbox" id="c-41943486" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41942003">parent</a><span>|</span><a href="#41943349">next</a><span>|</span><label class="collapse" for="c-41943486">[-]</label><label class="expand" for="c-41943486">[1 more]</label></div><br/><div class="children"><div class="content">These two examples come from bad library design, not bad language design. The first one was fixed with ranges. The second one would be fixed if C used an explicit string type in it&#x27;s standard library.</div><br/></div></div><div id="41943349" class="c"><input type="checkbox" id="c-41943349" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41942003">parent</a><span>|</span><a href="#41943486">prev</a><span>|</span><a href="#41942635">next</a><span>|</span><label class="collapse" for="c-41943349">[-]</label><label class="expand" for="c-41943349">[1 more]</label></div><br/><div class="children"><div class="content">With a safe runtime, a pointer is really something like a `struct { u32 allocation_base, allocation_offset;}`. (it may be worth doing fancy variable-bit-width math to allow many small allocations but only a few large ones; it&#x27;s also likely worth it to have a dedicated &quot;leaf&quot; section of memory that is intended not to contain any pointers)<p>An implementation of `sort` would start with: `assert (begin.allocation_base == end.allocation_base)`. Most likely, this would be implicit when `end - begin` or `begin &lt; end` is called (but not `!=`, which is well-defined between unrelated pointers).<p>If we ignore the uninitialized data (which is not the same kind of UB, and usually not interesting), the `strlen` loop would assert when, after not encountering a NUL, `s.allocation_offset` exceeds `100` (which is known in the allocation metadata).</div><br/></div></div></div></div><div id="41940706" class="c"><input type="checkbox" id="c-41940706" checked=""/><div class="controls bullet"><span class="by">murderfs</span><span>|</span><a href="#41940672">parent</a><span>|</span><a href="#41942003">prev</a><span>|</span><a href="#41942343">next</a><span>|</span><label class="collapse" for="c-41940706">[-]</label><label class="expand" for="c-41940706">[7 more]</label></div><br/><div class="children"><div class="content">virtual address space is cheap, but changing it is massively expensive. If you have to do a TLB shootdown on every free, you&#x27;re likely going to have worse performance than just using ASan.</div><br/><div id="41940770" class="c"><input type="checkbox" id="c-41940770" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940706">parent</a><span>|</span><a href="#41942343">next</a><span>|</span><label class="collapse" for="c-41940770">[-]</label><label class="expand" for="c-41940770">[6 more]</label></div><br/><div class="children"><div class="content">Dealing with malloc&#x2F;free is trivial and cheap - just give every allocated object a couple of reference counts.<p>The hard part is figuring out which words of memory should be treated as pointers, so that you know <i>when</i> to alter the reference counts.<p>Most C programs don&#x27;t rely on all the weird guarantees that C mandates (relying on asm, which is also problematic, is probably more common), but for the ones that do it is quite problematic.</div><br/><div id="41941092" class="c"><input type="checkbox" id="c-41941092" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940770">parent</a><span>|</span><a href="#41941032">next</a><span>|</span><label class="collapse" for="c-41941092">[-]</label><label class="expand" for="c-41941092">[2 more]</label></div><br/><div class="children"><div class="content">The borrow checker works irrespective of the heap. Memory safety involves all pointers, not just ones that own a heap allocation.</div><br/><div id="41941533" class="c"><input type="checkbox" id="c-41941533" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41941092">parent</a><span>|</span><a href="#41941032">next</a><span>|</span><label class="collapse" for="c-41941533">[-]</label><label class="expand" for="c-41941533">[1 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re trying to minimize annotation while maximizing C compatibility, it will be necessary to heap-allocate stack frames. This cost can be mitigated with annotations, once again. In this case, a global &quot;forbid leaks even if unused&quot; flag would cover it.<p>Static allocations only need full heap compatibility if `dlclose` isn&#x27;t a nop.<p>And TLS is the forgotten step-child, but at the lowest level it&#x27;s ultimately just implemented on normal allocations.</div><br/></div></div></div></div><div id="41941032" class="c"><input type="checkbox" id="c-41941032" checked=""/><div class="controls bullet"><span class="by">acbits</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940770">parent</a><span>|</span><a href="#41941092">prev</a><span>|</span><a href="#41940787">next</a><span>|</span><label class="collapse" for="c-41941032">[-]</label><label class="expand" for="c-41941032">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;acbits&#x2F;reftrack-plugin">https:&#x2F;&#x2F;github.com&#x2F;acbits&#x2F;reftrack-plugin</a><p>I wrote a compiler extension just for this issue since there wasn&#x27;t any.</div><br/></div></div><div id="41940787" class="c"><input type="checkbox" id="c-41940787" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940770">parent</a><span>|</span><a href="#41941032">prev</a><span>|</span><a href="#41942343">next</a><span>|</span><label class="collapse" for="c-41940787">[-]</label><label class="expand" for="c-41940787">[2 more]</label></div><br/><div class="children"><div class="content">&gt; just give every allocated object a couple of reference counts.<p>Works great with a single thread.</div><br/><div id="41940860" class="c"><input type="checkbox" id="c-41940860" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41940672">root</a><span>|</span><a href="#41940787">parent</a><span>|</span><a href="#41942343">next</a><span>|</span><label class="collapse" for="c-41940860">[-]</label><label class="expand" for="c-41940860">[1 more]</label></div><br/><div class="children"><div class="content">Multi-threaded refcounts aren&#x27;t actually that hard?<p>There&#x27;s overhead (depending on how much you&#x27;re willing to annotate it and how much you can infer), but the only &quot;hard&quot; thing is the race between accessing a field and and changing the refcount of the object it points to, and [even ignoring alternative CAS approaches] that&#x27;s easy enough if you control the allocator (do not return memory to the OS until all running threads have checked in).<p>Note that, in contrast the the common refcount approach, it&#x27;s probably better to introduce a &quot;this is in use; crash on free&quot; flag to significantly reduce the overhead.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41941645" class="c"><input type="checkbox" id="c-41941645" checked=""/><div class="controls bullet"><span class="by">prophesi</span><span>|</span><a href="#41940672">prev</a><span>|</span><label class="collapse" for="c-41941645">[-]</label><label class="expand" for="c-41941645">[1 more]</label></div><br/><div class="children"><div class="content">For those without a dark mode extension:<p>body {<p><pre><code>  background-color: #1f1f1f;

  color: #efefef;
</code></pre>
}<p>.sourceCode {<p><pre><code>  background-color: #3f3f3f;

}</code></pre></div><br/></div></div></div></div></div></div></div></body></html>