<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1682568400931" as="style"/><link rel="stylesheet" href="styles.css?v=1682568400931"/><link rel="apple-touch-startup-image" href="https://png.pngtree.com/png-clipart/20210309/original/pngtree-a-squatting-tabby-cat-png-image_5803660.jpg"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.nango.dev/blog/why-is-oauth-still-hard">Why is OAuth still hard in 2023?</a> <span class="domain">(<a href="https://www.nango.dev">www.nango.dev</a>)</span></div><div class="subtext"><span>bastienbeurier</span> | <span>163 comments</span></div><br/><div><div id="35720006" class="c"><input type="checkbox" id="c-35720006" checked=""/><div class="controls bullet"><span class="by">thepasswordis</span><span>|</span><a href="#35718456">next</a><span>|</span><label class="collapse" for="c-35720006">[-]</label><label class="expand" for="c-35720006">[59 more]</label></div><br/><div class="children"><div class="content">Because the documentation is bad.  Oauth is really simple:<p>Lets say you want to use google as an auth provider.  You do this:<p>&quot;Hey google who is this guy?  I&#x27;m going to send them to google.com&#x2F;oauth, send them back to example.com&#x2F;oauth, and in the headers of the request include the word &quot;Authorization: bearer&quot; followed by a bunch of text&quot;<p>Google says &quot;Oh yeah I know that guy, here I&#x27;ll send them back to where you said with a token&quot;<p>Then later on you can take the token and say &quot;Hey google, somebody gave me this token, who is it?&quot;<p>That&#x27;s <i>pretty much it</i>.  You have to trust that google isn&#x27;t lying to you, but that&#x27;s kindof the point of oauth.<p>But that&#x27;s never what the documentation says.  It&#x27;s always 10 pages long and the examples are like &quot;here&#x27;s a fully functioning python web server using flask and function decorators, oh the actual auth flow, which is really like 3 lines of code, is hidden inside of a library&quot;.<p>To people who write documentation: PLEASE for the love of god show me how to talk to your API both using your library, but <i>also</i> using something like urllib2 or requests or something.<p>Ideally the documentation is the absolute most minimal way of making the service work, and then adds more and more usefulness on top of that.  I&#x27;m not going to judge you for writing bad code <i>in an example</i>.  The example could practically be pseudocode for all I care.  I just want to see <i>generally</i> how your API is supposed to work.<p>edit: yes, auth0, I <i>am</i> looking at you.</div><br/><div id="35720336" class="c"><input type="checkbox" id="c-35720336" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35723135">next</a><span>|</span><label class="collapse" for="c-35720336">[-]</label><label class="expand" for="c-35720336">[30 more]</label></div><br/><div class="children"><div class="content">In my experience with OAuth, one of the principle issues is that it&#x27;s less a protocol and more a skeleton of a protocol. Actually go to the core RFCs for OAuth, and you realize that basically everything is implementation-dependent. You somehow register with the provider as a client (out of band and completely implementation-dependent).<p>Then you ask them to log you in by sending a request to an implementation-dependent webpage, with implementation-dependent parameters (which ones are required are--you guessed it--implementation-dependent), telling them to redirect you to your page when you&#x27;re done. Well, actually, that assumes you&#x27;re building a website. If you&#x27;re a desktop application, you&#x27;ll do something else. If you&#x27;re on an embedded system that can&#x27;t open up a webpage, there&#x27;s another option. And there&#x27;s yet more flows. Which ones are supported by the provider? You guessed it, it&#x27;s all implementation-dependent. Oh, and maybe you need to refresh tokens to login the future. When? If? You guessed it, implementation-dependent!<p>It makes writing a generic OAuth client library hard because there&#x27;s basically no commonality there. Really, it makes me long for Kerberos as a much saner SSO system than OAuth.</div><br/><div id="35721707" class="c"><input type="checkbox" id="c-35721707" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720336">parent</a><span>|</span><a href="#35720644">next</a><span>|</span><label class="collapse" for="c-35721707">[-]</label><label class="expand" for="c-35721707">[6 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience with OAuth, one of the principle issues is that it&#x27;s less a protocol and more a skeleton of a protocol<p>OAuth supports lots of different scenarios. Many people when they say “OAuth” they are only thinking of one or two of those scenarios, and ignoring all the others which aren’t relevant to them personally-but may be relevant to someone else<p>I worked on a system where we had a micro-service which had a token from OAuth server 1, and it needed to exchange it for a token from OAuth server 2, and we needed some policies to decide whether that token exchange was allowed or not. And that’s totally a use case the OAuth RFCs support (there is even an RFC specifically on token exchange), but a person wanting to add a “login with Google” button to their website isn’t interested in anything remotely like that.<p>&gt; Which ones are supported by the provider? You guessed it, it&#x27;s all implementation-dependent.<p>Security needs vary widely from system to system. So they defined a protocol which supports many different scenarios. But if your application only needs two of them, why implement the other N? OTOH, for someone who actually needs one of those other scenarios, having it standardised makes their life easier. You can’t expect the protocol to tell you which scenario you have, that’s inherently “implementation-dependent”, to the point that calling it that is getting tautologous</div><br/><div id="35721968" class="c"><input type="checkbox" id="c-35721968" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721707">parent</a><span>|</span><a href="#35722099">next</a><span>|</span><label class="collapse" for="c-35721968">[-]</label><label class="expand" for="c-35721968">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; In my experience with OAuth, one of the principle issues is that it&#x27;s less a protocol and more a skeleton of a protocol<p>&gt; OAuth supports lots of different scenarios.<p>But it&#x27;s literally only the skeleton of a protocol (&quot;framework&quot; of a protocol, as the actual spec puts it).  That important &quot;Then later on you can take the token and say &#x27;Hey google, somebody gave me this token, who is it?&#x27;&quot; part is totally unspecified by OAuth.  How do you validate tokens? (Either on the resource-server end, or on the client-end to know if trying to talk to a resource-server is a waste of time, or to know if your post-redirect-uri is getting spoofed):<p>- OAuth: implementation defined<p>- most implementations: use our library, which validates the token using undocumented logic<p>- OIDC: there&#x27;s a user-info endpoint you can call to, but lots of OAuth authorization servers don&#x27;t fully implement OIDC, and even if they do, that&#x27;s a lot of extra round trips<p>- RFC7523: The token is a JWT, validate the signature and claims... but everyone issues RFC6750 &quot;bearer&quot; tokens, not RFC7523 &quot;urn:ietf:params:oauth:grant-type:jwt-bearer&quot; tokens. But if you just close your eyes and pretend that your 6750 opaque token is actually a 7523 JWT and parse+validate it as such, that&#x27;ll work most of the time.<p>So yeah, OAuth is hard because there&#x27;s no great generic library, because a core part of it is implementation-defined, so you have to either do it yourself or use a specific implementation&#x27;s library, and none of those libraries work quite the same.<p>(In the above, and for 99% of folks, &quot;OAuth&quot; = RFC6749+RFC6750)</div><br/><div id="35722426" class="c"><input type="checkbox" id="c-35722426" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721968">parent</a><span>|</span><a href="#35722099">next</a><span>|</span><label class="collapse" for="c-35722426">[-]</label><label class="expand" for="c-35722426">[2 more]</label></div><br/><div class="children"><div class="content">In all honesty, though, &quot;I have to look at the provider&#x27;s documentation to determine like 4 URLs to add to a configuration&quot; is not that wild of a thing? How much friction is too much friction?<p>&gt; How do you validate tokens? (Either on the resource-server end, or on the client-end to know if trying to talk to a resource-server is a waste of time, or to know if your post-redirect-uri is getting spoofed):<p>At the beginning of the &quot;standard&quot; OAuth flow you can pass in client state. So you generate a signed nonce. Remember, you are starting this flow, so you mix in some user data (avoids CSRF problems), and you are pointing to some HTTPS site.<p>This is not 100% perfect compared to &quot;remote server has some signing&quot; but it does allow purely local verification of tokens when they are first received, as you can stick stuff into the &quot;state&quot; request parameter (as anyone should be anyways to avoid trickery).</div><br/><div id="35722837" class="c"><input type="checkbox" id="c-35722837" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35722426">parent</a><span>|</span><a href="#35722099">next</a><span>|</span><label class="collapse" for="c-35722837">[-]</label><label class="expand" for="c-35722837">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In all honesty, though, &quot;I have to look at the provider&#x27;s documentation to determine like 4 URLs to add to a configuration&quot; is not that wild of a thing? How much friction is too much friction?<p>If it&#x27;s something dumb&#x2F;simple like grabbing a JWKS URL and an &quot;issuer&quot; URL, and then doing JWT validation, sure.  Maybe you need to make a weird bespoke request to some other endpoint.  Maybe you need to implement some uncommon signature verification.  It could be anything.<p>&gt; At the beginning of the &quot;standard&quot; OAuth flow you can pass in client state. So you generate a signed nonce. Remember, you are starting this flow, so you mix in some user data (avoids CSRF problems), and you are pointing to some HTTPS site.<p>So you redirect the user&#x27;s browser to the IDP, with the nonce in the URL.  The user grabs that nonce from the URL bar, then manually navigates to your redirection-endpoint, putting that nonce and their own fabricated token in the URL.</div><br/></div></div></div></div></div></div><div id="35722099" class="c"><input type="checkbox" id="c-35722099" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721707">parent</a><span>|</span><a href="#35721968">prev</a><span>|</span><a href="#35720644">next</a><span>|</span><label class="collapse" for="c-35722099">[-]</label><label class="expand" for="c-35722099">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And that’s totally a use case the OAuth RFCs support (there is even an RFC specifically on token exchange), but a person wanting to add a “login with Google” button to their website isn’t interested in anything remotely like that.<p>That&#x27;s because OAuth in the industry has been changed to only talk about authentication (AuthN) and not (or very lightly) authorization (AuthZ).<p>And, for the better, AuthZ is so use-case specific that bundling it together with AuthN is just asking for trouble.<p>Consider AWS and IAM permissions.  How would you implement an IAM AuthZ policy system with OAuth?  Would you actually want to?<p>AuthN is a relatively simple process which is why that flow through OAuth (and specifically OIDC) is fairly well trodden and defined.  The OAuth Authz capabilities are infrequently used which is why you see them being so spotty.</div><br/><div id="35722739" class="c"><input type="checkbox" id="c-35722739" checked=""/><div class="controls bullet"><span class="by">evntdrvn</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35722099">parent</a><span>|</span><a href="#35720644">next</a><span>|</span><label class="collapse" for="c-35722739">[-]</label><label class="expand" for="c-35722739">[1 more]</label></div><br/><div class="children"><div class="content">huh? OAuth is literally a &quot;delegated authorization framework&quot;</div><br/></div></div></div></div></div></div><div id="35720644" class="c"><input type="checkbox" id="c-35720644" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720336">parent</a><span>|</span><a href="#35721707">prev</a><span>|</span><a href="#35721192">next</a><span>|</span><label class="collapse" for="c-35720644">[-]</label><label class="expand" for="c-35720644">[4 more]</label></div><br/><div class="children"><div class="content">This is my experience. It&#x27;s hard because it&#x27;s very complex. As a non-domain-expert it&#x27;s hard to separate necessary complexity from unnecessary complexity, but it feels like there&#x27;s a lot of the latter, plus enough gotchas in the former (&quot;oh, you didn&#x27;t specify an encryption algorithm that we support in your request, and our logs are terribly unhelpful for realizing that&quot;) to make it a giant pain.</div><br/><div id="35721062" class="c"><input type="checkbox" id="c-35721062" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720644">parent</a><span>|</span><a href="#35721192">next</a><span>|</span><label class="collapse" for="c-35721062">[-]</label><label class="expand" for="c-35721062">[3 more]</label></div><br/><div class="children"><div class="content">Is Webauthn a better standard?</div><br/><div id="35721187" class="c"><input type="checkbox" id="c-35721187" checked=""/><div class="controls bullet"><span class="by">lstamour</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721062">parent</a><span>|</span><a href="#35721510">next</a><span>|</span><label class="collapse" for="c-35721187">[-]</label><label class="expand" for="c-35721187">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly. With webauthn the complexity lies in frontend - you have to explain how and why users should use this and what it is, how to manage enrolments and so on. Touch ID, Windows Hello and Passkeys might simplify this but it is still more complex to explain to less technical customers than, say, Face ID on an iPhone app to remember your login.<p>If you want an easy all-purpose login flow, sign in by clicking a link in email is still an easy fallback.<p>OAuth from multiple providers also has complexity - Auth0 makes it so you have to maintain separate databases for passwords if you want to support login via OAuth and login from password. You have to link accounts to login from multiple providers.<p>Logins are simply hard work no matter how you slice it. Eventually they will be easy but… I’m not holding my breath. :)</div><br/></div></div><div id="35721510" class="c"><input type="checkbox" id="c-35721510" checked=""/><div class="controls bullet"><span class="by">waboremo</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721062">parent</a><span>|</span><a href="#35721187">prev</a><span>|</span><a href="#35721192">next</a><span>|</span><label class="collapse" for="c-35721510">[-]</label><label class="expand" for="c-35721510">[1 more]</label></div><br/><div class="children"><div class="content">If you were generally comparing standards: yes. Documentation with it is a breeze.<p>If you&#x27;re talking about a &quot;replace one standard with the next&quot; type of comparison, then no. You can read more about why here <a href="https:&#x2F;&#x2F;oauth.net&#x2F;webauthn&#x2F;" rel="nofollow">https:&#x2F;&#x2F;oauth.net&#x2F;webauthn&#x2F;</a></div><br/></div></div></div></div></div></div><div id="35721192" class="c"><input type="checkbox" id="c-35721192" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720336">parent</a><span>|</span><a href="#35720644">prev</a><span>|</span><a href="#35721754">next</a><span>|</span><label class="collapse" for="c-35721192">[-]</label><label class="expand" for="c-35721192">[5 more]</label></div><br/><div class="children"><div class="content">And this is why there&#x27;s five &quot;log in with X&quot; buttons on every webapp, but no &quot;tell us your IdP and we&#x27;ll send you there&quot;; let alone any kind of magical &quot;we&#x27;ll take your email address and check the DNS record of the domain to figure out who your IdP is, and then send you there.&quot;<p>Not because the &quot;figuring out who to OAuth with from DNS&quot; part would be hard to design; but because there&#x27;s no way to &quot;autodiscover&quot; all those implementation-dependent details of how you&#x27;re supposed to talk to an OAuth IdP.<p>Compare&#x2F;contrast: SAML. SAML binding a webapp to an arbitrary IdPs just by punching in the IdP&#x27;s SAML config endpoint URL? Works perfectly.</div><br/><div id="35722316" class="c"><input type="checkbox" id="c-35722316" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721192">parent</a><span>|</span><a href="#35721649">next</a><span>|</span><label class="collapse" for="c-35722316">[-]</label><label class="expand" for="c-35722316">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a single URL for OIDC IdPs too. It&#x27;s not supported in every web app for the same reason SAML isn&#x27;t: it&#x27;s a two-way exchange to set up, not a one-way exchange. In OIDC (OAuth 2) you need to register a client first. In SAML you need to register a Service Provider first. Only after you&#x27;ve done those steps will you be able to plug the magic configuration in and have it work.<p>SAML is too limited to compete with OIDC&#x2F;OAuth2 on the web, but it&#x27;s got some advantages for enterprise authentication, so it won&#x27;t be going anywhere.</div><br/></div></div><div id="35721649" class="c"><input type="checkbox" id="c-35721649" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721192">parent</a><span>|</span><a href="#35722316">prev</a><span>|</span><a href="#35721754">next</a><span>|</span><label class="collapse" for="c-35721649">[-]</label><label class="expand" for="c-35721649">[3 more]</label></div><br/><div class="children"><div class="content">OIDC Discovery to the rescue!<p><a href="https:&#x2F;&#x2F;swagger.io&#x2F;docs&#x2F;specification&#x2F;authentication&#x2F;openid-connect-discovery&#x2F;" rel="nofollow">https:&#x2F;&#x2F;swagger.io&#x2F;docs&#x2F;specification&#x2F;authentication&#x2F;openid-...</a></div><br/><div id="35721811" class="c"><input type="checkbox" id="c-35721811" checked=""/><div class="controls bullet"><span class="by">pl4nty</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721649">parent</a><span>|</span><a href="#35721754">next</a><span>|</span><label class="collapse" for="c-35721811">[-]</label><label class="expand" for="c-35721811">[2 more]</label></div><br/><div class="children"><div class="content">As much as I love OIDC, it still doesn&#x27;t handle out-of-band client registration</div><br/><div id="35722410" class="c"><input type="checkbox" id="c-35722410" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721811">parent</a><span>|</span><a href="#35721754">next</a><span>|</span><label class="collapse" for="c-35722410">[-]</label><label class="expand" for="c-35722410">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;rfc7591&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;rfc7591&#x2F;</a><p>The only reason an authorisation server would support dynamic client registration, however, is because it&#x27;s meant to be pluggable as the back-end for an API integration suite like Kong Enterprise.<p>The solutions that are one big well-known IdP have no reason to want it, so Google Auth, Amazon Cognito, and similar all don&#x27;t support it.<p>The solutions that are aimed at letting organisations be an IdP do have reason to offer it: it makes being an IdP easier, because you can stand up a client registration service without using vendor-specific interfaces.<p>No-one who operates an IdP wants arbitrary, uncontrolled public client registration. It&#x27;ll get abused directly, and it&#x27;ll enable further abuse of the systems the IdP is meant to protect.</div><br/></div></div></div></div></div></div></div></div><div id="35721754" class="c"><input type="checkbox" id="c-35721754" checked=""/><div class="controls bullet"><span class="by">mattpallissard</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720336">parent</a><span>|</span><a href="#35721192">prev</a><span>|</span><a href="#35722209">next</a><span>|</span><label class="collapse" for="c-35721754">[-]</label><label class="expand" for="c-35721754">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Kerberos as a much saner SSO system than OAuth.<p>+1, it really solves nearly all the authn and federation problems.  You still find KDC  installations in places with large *nix footprints.  Sometimes it&#x27;s AD, sometimes it&#x27;s MIT with a cross-realm trust.<p>It&#x27;s incredibly flexible and transparent to the user.  It&#x27;s easy for sysadmins, and various service owners to implement as it&#x27;s basically drop a keytab in place, and set an environment variable for many daemons and libraries.<p>IMO, the only reason it fell out of favor with the web crowd is there wasn&#x27;t a gaggle of centralized providers that let them stand up services without thinking about the infrastructure.  It wasn&#x27;t packaged up nicely.</div><br/><div id="35722201" class="c"><input type="checkbox" id="c-35722201" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721754">parent</a><span>|</span><a href="#35722278">next</a><span>|</span><label class="collapse" for="c-35722201">[-]</label><label class="expand" for="c-35722201">[2 more]</label></div><br/><div class="children"><div class="content">Kerberos just doesn&#x27;t solve the same problem: it starts by giving your username and password to a fully trusted client.<p>OAuth was invented to avoid the need to do that. If I use some finance package and I&#x27;d like it to download my transactions from my bank, I&#x27;d really rather not have to give it my username and password, with the full access that grants including the ability to lock me out of my bank account and transfer my money. OAuth lets you instead grant permissions for that program to do something more limited, like just read your transaction history.<p>Kerberos was never popular with the web crowd because it&#x27;s not capable of solving the problem of authorizing web applications. Before OAuth everywhere just asked for your username and password to log in on your behalf.<p>And the only reason Kerberos works well today is that it&#x27;s always now a single-vendor solution, homogeneous across the deployment. It&#x27;s an interoperability nightmare otherwise.</div><br/><div id="35722735" class="c"><input type="checkbox" id="c-35722735" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35722201">parent</a><span>|</span><a href="#35722278">next</a><span>|</span><label class="collapse" for="c-35722735">[-]</label><label class="expand" for="c-35722735">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Kerberos just doesn&#x27;t solve the same problem: it starts by giving your username and password to a fully trusted client.<p>Not really. In practice, Kerberos means just loading the gssapi or sspi library, essentially using the user&#x27;s login to already have the ticket-granting-ticket generated and usable for the subsequent tickets. As the client application, I never see the user&#x27;s password; it&#x27;s all handled for me by the OS.</div><br/></div></div></div></div><div id="35722278" class="c"><input type="checkbox" id="c-35722278" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721754">parent</a><span>|</span><a href="#35722201">prev</a><span>|</span><a href="#35722209">next</a><span>|</span><label class="collapse" for="c-35722278">[-]</label><label class="expand" for="c-35722278">[1 more]</label></div><br/><div class="children"><div class="content">As a developer that needs to use Kerberos for authentication between hosted services, I can say that Kerberos is simply awful to debug.  When you have a failed login (refuse to auth), it is <i>so</i> hard for the _average_ developer to debug.  We have pages and pages of cookbook solutions to various problems.  Some issues are purely due to Kerberos complexity, and other issues are due to each programming language and their implementation of Kerberos.  Most developers have no idea how SPNEGO works (Kerberos auth over HTTPS).  I spend a lot of time on these issues, and I only have a surface understanding of SPNEGO.  Oh yeah, and there are many subtle issues of Microsoft Active Directory (AD) vs MIT Kerberos.</div><br/></div></div></div></div><div id="35722209" class="c"><input type="checkbox" id="c-35722209" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720336">parent</a><span>|</span><a href="#35721754">prev</a><span>|</span><a href="#35721235">next</a><span>|</span><label class="collapse" for="c-35722209">[-]</label><label class="expand" for="c-35722209">[2 more]</label></div><br/><div class="children"><div class="content">Dynamic client registration is standardised (<a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7591.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7591.html</a>), the authorization code flow is standardised (<a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6749.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6749.html</a>). The device authorization flow is also standardised (<a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8628.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8628.html</a>). The preferred desktop app authorization process is described in a best current practice document (<a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8252.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8252.html</a>). A metadata URL for auto-configuration of OAuth2 Authorization Servers is specified (<a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8414.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8414.html</a>). How to validate an access token, which also lets you know if you need to refresh it, is specified (<a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7662.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7662.html</a> via an API endpoint, <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9068.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9068.html</a> for JWT tokens) - or just use it, and if it fails, refresh it.<p>It&#x27;s fully specified. It&#x27;s well implemented - you&#x27;d have to go out of your way to find an authorization server that doesn&#x27;t do everything above, with the exception of dynamic client registration, because that&#x27;s not intended for clients but rather for integration with developer portals and similar. Google Auth and Amazon Cognito don&#x27;t support dynamic registration for third parties, eg, because if you&#x27;re doing dynamic registration it&#x27;ll be because you&#x27;re operating your own AS - Okta, Auth0, and Keycloak all support it.<p>There&#x27;s also plenty of good generic OAuth client libraries. Spring Security, the oauth2 crate for Rust, etc.</div><br/><div id="35722484" class="c"><input type="checkbox" id="c-35722484" checked=""/><div class="controls bullet"><span class="by">smackeyacky</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35722209">parent</a><span>|</span><a href="#35721235">next</a><span>|</span><label class="collapse" for="c-35722484">[-]</label><label class="expand" for="c-35722484">[1 more]</label></div><br/><div class="children"><div class="content">Just because the standards exist doesn&#x27;t mean everybody follows them.  Most and maybe all implementations have some crazy customisation.  It makes the standards and docs almost worthless.</div><br/></div></div></div></div><div id="35721235" class="c"><input type="checkbox" id="c-35721235" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720336">parent</a><span>|</span><a href="#35722209">prev</a><span>|</span><a href="#35720709">next</a><span>|</span><label class="collapse" for="c-35721235">[-]</label><label class="expand" for="c-35721235">[1 more]</label></div><br/><div class="children"><div class="content">I think the problem with the spec is that it’s way too large to fully implement when you only need some secure token exchange, so everyone does only the stuff they need.<p>If the spec was smaller people would go all the way to be fully compliant since the marginal effort would be minimal.</div><br/></div></div><div id="35720709" class="c"><input type="checkbox" id="c-35720709" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720336">parent</a><span>|</span><a href="#35721235">prev</a><span>|</span><a href="#35721282">next</a><span>|</span><label class="collapse" for="c-35720709">[-]</label><label class="expand" for="c-35720709">[6 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience with OAuth, one of the principle issues is that it&#x27;s less a protocol and more a skeleton of a protocol.<p>Because it is, really.<p>OAuth (2.0) is really the backbone for OpenID.</div><br/><div id="35720946" class="c"><input type="checkbox" id="c-35720946" checked=""/><div class="controls bullet"><span class="by">TallGuyShort</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720709">parent</a><span>|</span><a href="#35721282">next</a><span>|</span><label class="collapse" for="c-35720946">[-]</label><label class="expand" for="c-35720946">[5 more]</label></div><br/><div class="children"><div class="content">OpenID Connect, specifically, where a lot of people mix those up and start looking at using OAuth for authentication. And if I&#x27;m not mistaken, logging out is implementation-dependent in OpenID Connect. There&#x27;s some pseudo-standards but implementations vary in my experience. And OpenID Connect also has multiple flows for different kinds of applications. There&#x27;s still a lot of confusion and complexity here.</div><br/><div id="35721589" class="c"><input type="checkbox" id="c-35721589" checked=""/><div class="controls bullet"><span class="by">neurostimulant</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720946">parent</a><span>|</span><a href="#35721816">next</a><span>|</span><label class="collapse" for="c-35721589">[-]</label><label class="expand" for="c-35721589">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still salty about how keycloak changed their openid logout behavior, removed the old behavior in the new version when there are still a lot of oidc clients out there that still expect the old behavior. I have two inatances of keycloak using the same version and somehow both have different iodc logout behaviors. I think it&#x27;s due to one instance was upgraded from older version and inherited the old behavior, but I can&#x27;t get the other instance to use the old behavior (the flag mentioned in the docs didn&#x27;t work) unless I downgrade the version first.</div><br/><div id="35721851" class="c"><input type="checkbox" id="c-35721851" checked=""/><div class="controls bullet"><span class="by">grepfru_it</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721589">parent</a><span>|</span><a href="#35721816">next</a><span>|</span><label class="collapse" for="c-35721851">[-]</label><label class="expand" for="c-35721851">[2 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on this a bit? My logout process through keycloak is through a hidden (back channel) url. As long as I hit that client url it will end the session. Applications, I find, have different behaviors. Gitea logs out the session, portainer just clears browser cookies but the session remains active<p>I’m using the same keycloak setup for almost 2 years now, with upgrades</div><br/><div id="35722521" class="c"><input type="checkbox" id="c-35722521" checked=""/><div class="controls bullet"><span class="by">neurostimulant</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721851">parent</a><span>|</span><a href="#35721816">next</a><span>|</span><label class="collapse" for="c-35722521">[-]</label><label class="expand" for="c-35722521">[1 more]</label></div><br/><div class="children"><div class="content">I was referring to this one: <a href="https:&#x2F;&#x2F;keycloak.discourse.group&#x2F;t&#x2F;keycloak-redirect-uri-logout&#x2F;17255" rel="nofollow">https:&#x2F;&#x2F;keycloak.discourse.group&#x2F;t&#x2F;keycloak-redirect-uri-log...</a><p>There is a flag to restore the old behavior but it doesn&#x27;t work in newer version. Strangely, an older instance of keycloak I run still uses the old behavior even after being upgraded to latest version, so this issue seems to only affect new instance only.</div><br/></div></div></div></div></div></div><div id="35721816" class="c"><input type="checkbox" id="c-35721816" checked=""/><div class="controls bullet"><span class="by">sytringy05</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720946">parent</a><span>|</span><a href="#35721589">prev</a><span>|</span><a href="#35721282">next</a><span>|</span><label class="collapse" for="c-35721816">[-]</label><label class="expand" for="c-35721816">[1 more]</label></div><br/><div class="children"><div class="content">Yes, single log out is an ongoing nightmare. &lt;Stares at Ping&gt;
As many here have said the size and range of use cases that OAuth and OIDC support is off its head. And that&#x27;s with the big boys who have millions of users, throw in ${EveryCorp} that implements its own token server and bespoke implementation of the auth, well.. good luck to the AI trying to take over our jobs.</div><br/></div></div></div></div></div></div><div id="35721282" class="c"><input type="checkbox" id="c-35721282" checked=""/><div class="controls bullet"><span class="by">yacine_</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720336">parent</a><span>|</span><a href="#35720709">prev</a><span>|</span><a href="#35723135">next</a><span>|</span><label class="collapse" for="c-35721282">[-]</label><label class="expand" for="c-35721282">[1 more]</label></div><br/><div class="children"><div class="content">OAuth isn&#x27;t an SSO system :P</div><br/></div></div></div></div><div id="35723135" class="c"><input type="checkbox" id="c-35723135" checked=""/><div class="controls bullet"><span class="by">arwhatever</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35720336">prev</a><span>|</span><a href="#35720367">next</a><span>|</span><label class="collapse" for="c-35723135">[-]</label><label class="expand" for="c-35723135">[1 more]</label></div><br/><div class="children"><div class="content">OAuth document writers love abstract, lofty nomenclature for everything.<p>I like what you’ve done here with your explanation - I can practically envision a couple (or three!) literal sock puppets giving me this perfectly adequate overview.</div><br/></div></div><div id="35720367" class="c"><input type="checkbox" id="c-35720367" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35723135">prev</a><span>|</span><a href="#35720213">next</a><span>|</span><label class="collapse" for="c-35720367">[-]</label><label class="expand" for="c-35720367">[12 more]</label></div><br/><div class="children"><div class="content">One reason is that the protocol itself is more complicated than you&#x27;ve described.<p>For example, Google won&#x27;t give you a long-lived access token. You need a refresh token, and then you use that to retrieve access tokens, and continue doing that as they expire.<p>Why? I have not a flipping idea. Please, HN enlighten me how refresh&#x2F;access token dichotomy improves the API.</div><br/><div id="35720597" class="c"><input type="checkbox" id="c-35720597" checked=""/><div class="controls bullet"><span class="by">dflock</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720367">parent</a><span>|</span><a href="#35720610">next</a><span>|</span><label class="collapse" for="c-35720597">[-]</label><label class="expand" for="c-35720597">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really trying to solve a problem they created by statlessly handing out tokens instead of keeping session state on the backend - they have no way to revoke a token once issued, so long lived tokens are a liability. Solution? More complexity! Hand out very short lived tokens, along with a slightly longer lived refresh token, which only allows you get a new bearer&#x2F;access token.</div><br/><div id="35721197" class="c"><input type="checkbox" id="c-35721197" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720597">parent</a><span>|</span><a href="#35720799">next</a><span>|</span><label class="collapse" for="c-35721197">[-]</label><label class="expand" for="c-35721197">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re free to handle a billion qps in authentication requests if you want. I don&#x27;t suggest it.</div><br/><div id="35721781" class="c"><input type="checkbox" id="c-35721781" checked=""/><div class="controls bullet"><span class="by">asdfman123</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721197">parent</a><span>|</span><a href="#35720799">next</a><span>|</span><label class="collapse" for="c-35721781">[-]</label><label class="expand" for="c-35721781">[1 more]</label></div><br/><div class="children"><div class="content">Greatly reducing hosting costs at the expense of making someone else do a little more work sounds like a win to me.</div><br/></div></div></div></div><div id="35720799" class="c"><input type="checkbox" id="c-35720799" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720597">parent</a><span>|</span><a href="#35721197">prev</a><span>|</span><a href="#35720610">next</a><span>|</span><label class="collapse" for="c-35720799">[-]</label><label class="expand" for="c-35720799">[5 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t they still require some state to be able t invalidate refresh tokens?</div><br/><div id="35720829" class="c"><input type="checkbox" id="c-35720829" checked=""/><div class="controls bullet"><span class="by">johnmaguire</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720799">parent</a><span>|</span><a href="#35720610">next</a><span>|</span><label class="collapse" for="c-35720829">[-]</label><label class="expand" for="c-35720829">[4 more]</label></div><br/><div class="children"><div class="content">Yes, but checking refresh tokens will occur much less frequently than checking access tokens. So you can imagine, for example, access tokens being JWT, so they are cheap to check. But every so often you have to validate the refresh token against MySQL (or BigQuery or what-have-you), which is more expensive.</div><br/><div id="35720962" class="c"><input type="checkbox" id="c-35720962" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720829">parent</a><span>|</span><a href="#35720610">next</a><span>|</span><label class="collapse" for="c-35720962">[-]</label><label class="expand" for="c-35720962">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s all clear to me. But technically there exists a method to revoke an issued token. It&#x27;s just that long lived tokens mean potentially lots of them == increased storage cost. It would be pretty silly not to check for revocation. How would one implement logout otherwise? Relying on just clearing session cookies? What if I obtained those cookies using something else than a browser and I can hold on to the cookie jar? Not checking for revocation == doing it wrong.<p>The purpose of a refresh token to allow the app to short circuit the login process. Regardless of how long the token is issued for. It&#x27;s perfectly okay to ignore refresh tokens altogether, if one wants to.</div><br/><div id="35721893" class="c"><input type="checkbox" id="c-35721893" checked=""/><div class="controls bullet"><span class="by">sytringy05</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720962">parent</a><span>|</span><a href="#35722105">next</a><span>|</span><label class="collapse" for="c-35721893">[-]</label><label class="expand" for="c-35721893">[1 more]</label></div><br/><div class="children"><div class="content">The whole point of access tokens is to not do expensive checks on every request. Signature checks out and isn&#x27;t expired - you are free to go. This is a core design  thing of OAuth, once access tokens are out the door they are very hard to stop, so only let them last for 5 or 10 mins and use refresh tokens to get new access tokens.<p>Refresh tokens are your chance to do all the expensive checks - maybe you are IP restricted or want to step up with MFA etc etc. Check revocation etc</div><br/></div></div><div id="35722105" class="c"><input type="checkbox" id="c-35722105" checked=""/><div class="controls bullet"><span class="by">uriah</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720962">parent</a><span>|</span><a href="#35721893">prev</a><span>|</span><a href="#35720610">next</a><span>|</span><label class="collapse" for="c-35722105">[-]</label><label class="expand" for="c-35722105">[1 more]</label></div><br/><div class="children"><div class="content">Login state for the identity provider and for the client application are different. Cookies are a reasonable way to implement it. Cookies + session storage backend will allow you delete sessions on the server side if you are worried about users keeping themselves logged in (?).<p>Your app is also responsible for deciding who has access. The identity provider is just handling the “is this person who they say they are” part.<p>Checking for revocation is checking whether the IdP still thinks that token identifies the user correctly. I don’t think it’s universally true or desirable that refresh tokens get revoked on logout. I don’t necessarily want logging out of Gmail to log out of Spotify just because I used Google auth for both.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35720610" class="c"><input type="checkbox" id="c-35720610" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720367">parent</a><span>|</span><a href="#35720597">prev</a><span>|</span><a href="#35721434">next</a><span>|</span><label class="collapse" for="c-35720610">[-]</label><label class="expand" for="c-35720610">[1 more]</label></div><br/><div class="children"><div class="content">Very simple, actually. Access tokens are short-lived and are irrevocable - google services only check validity and expiration of those tokens.<p>Refresh tokens are more like session tokens&#x2F;cookies - those get checked every time. At Google scale, checking it probably expensive, so they are using refresh tokens.<p>These aren&#x27;t for end-user or development experience, those are for AS performance.</div><br/></div></div><div id="35721434" class="c"><input type="checkbox" id="c-35721434" checked=""/><div class="controls bullet"><span class="by">matthewaveryusa</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720367">parent</a><span>|</span><a href="#35720610">prev</a><span>|</span><a href="#35720739">next</a><span>|</span><label class="collapse" for="c-35721434">[-]</label><label class="expand" for="c-35721434">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s the issue of scale, but also the issue of reducing the scope of a compromise.<p>If a short-lived token gets leaked the damage is limited to the TTL of the short-lived token.<p>If you were to pass around the long-lived token you would need to do forensics on the entire life of the token to figure out how&#x2F;if the credential was used.<p>Just think very pragmatically about the probability to keep a short-lived token secret across all the places it&#x27;s being transmitted vs. keeping the single API that exchanges the refresh token for a short-lived token super secure.</div><br/></div></div><div id="35720739" class="c"><input type="checkbox" id="c-35720739" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720367">parent</a><span>|</span><a href="#35721434">prev</a><span>|</span><a href="#35720213">next</a><span>|</span><label class="collapse" for="c-35720739">[-]</label><label class="expand" for="c-35720739">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why? I have not a flipping idea.<p><a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6749.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6749.html</a> contains everything you might want to know about OAuth in great detail :)</div><br/></div></div></div></div><div id="35720213" class="c"><input type="checkbox" id="c-35720213" checked=""/><div class="controls bullet"><span class="by">cjbgkagh</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35720367">prev</a><span>|</span><a href="#35720691">next</a><span>|</span><label class="collapse" for="c-35720213">[-]</label><label class="expand" for="c-35720213">[2 more]</label></div><br/><div class="children"><div class="content">Auth0 has a business incentive to have people think their core competency is more difficult than it is.</div><br/></div></div><div id="35720691" class="c"><input type="checkbox" id="c-35720691" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35720213">prev</a><span>|</span><a href="#35721345">next</a><span>|</span><label class="collapse" for="c-35720691">[-]</label><label class="expand" for="c-35720691">[4 more]</label></div><br/><div class="children"><div class="content">That drove me up the wall in Python so much - ALL the documentation just described how to put a massive library into a cookie cutter example and never explained how it&#x27;s supposed to work so I could debug the darn thing.</div><br/><div id="35720723" class="c"><input type="checkbox" id="c-35720723" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720691">parent</a><span>|</span><a href="#35721345">next</a><span>|</span><label class="collapse" for="c-35720723">[-]</label><label class="expand" for="c-35720723">[3 more]</label></div><br/><div class="children"><div class="content">when it comes to this kind of things there&#x27;s really no way around it: you&#x27;re supposed to read the RFCs:<p>- <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6749.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6749.html</a>: The OAuth 2.0 Authorization Framework<p>- <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6750.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc6750.html</a>: The OAuth 2.0 Authorization Framework: Bearer Token Usage</div><br/><div id="35721822" class="c"><input type="checkbox" id="c-35721822" checked=""/><div class="controls bullet"><span class="by">asdfman123</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35720723">parent</a><span>|</span><a href="#35721345">next</a><span>|</span><label class="collapse" for="c-35721822">[-]</label><label class="expand" for="c-35721822">[2 more]</label></div><br/><div class="children"><div class="content">As someone who is hired to sling out features as rapidly as possible, that’s not going to happen.<p>I mean, you might say “but you should” or “it would actually help” or “in an ideal world…” but it is still, realistically, not going to happen.</div><br/><div id="35721928" class="c"><input type="checkbox" id="c-35721928" checked=""/><div class="controls bullet"><span class="by">sytringy05</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721822">parent</a><span>|</span><a href="#35721345">next</a><span>|</span><label class="collapse" for="c-35721928">[-]</label><label class="expand" for="c-35721928">[1 more]</label></div><br/><div class="children"><div class="content">Well hopefully someone has taken the time to, or there will be nasty surprises<p>I certainly don&#x27;t want people building security sensitive parts of an app to be slinging the features out.</div><br/></div></div></div></div></div></div></div></div><div id="35721345" class="c"><input type="checkbox" id="c-35721345" checked=""/><div class="controls bullet"><span class="by">danesparza</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35720691">prev</a><span>|</span><a href="#35722420">next</a><span>|</span><label class="collapse" for="c-35721345">[-]</label><label class="expand" for="c-35721345">[2 more]</label></div><br/><div class="children"><div class="content">Yeah -- I think you just described OpenID (not OAuth).<p>And to be honest, this is part of the problem.  We use confusing (and sometimes conflicting) terminology to describe both authentication (identifying somebody) and authorization (making sure you have the right permissions to do something).<p>More information: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;1087071&#x2F;19020" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;1087071&#x2F;19020</a></div><br/><div id="35721491" class="c"><input type="checkbox" id="c-35721491" checked=""/><div class="controls bullet"><span class="by">eddiezane</span><span>|</span><a href="#35720006">root</a><span>|</span><a href="#35721345">parent</a><span>|</span><a href="#35722420">next</a><span>|</span><label class="collapse" for="c-35721491">[-]</label><label class="expand" for="c-35721491">[1 more]</label></div><br/><div class="children"><div class="content">I recently gave a talk on this and agree. While it was fun to learn, the difference between oauth and oidc isn&#x27;t clear. Especially with what I&#x27;ve been referring to as oidc &quot;wave 2&quot; - machine to machine authentication without OAuth seemingly involved at all.<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;nW3xK6sh1Ck" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;nW3xK6sh1Ck</a></div><br/></div></div></div></div><div id="35722420" class="c"><input type="checkbox" id="c-35722420" checked=""/><div class="controls bullet"><span class="by">onetimeusename</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35721345">prev</a><span>|</span><a href="#35722299">next</a><span>|</span><label class="collapse" for="c-35722420">[-]</label><label class="expand" for="c-35722420">[1 more]</label></div><br/><div class="children"><div class="content">I have seen a lot of people get caught up on things like the client_id,  client_secret, redirect URL, and scopes. This is relevant when you have a lot of tenancies for your customers and want them to log in via some OAuth provider. Do you create a new client_id for every tenant? Should you distribute a client_secret? Did you properly configure the redirect? Proving identity is the easy part though. Are scopes too broad or too narrow to accomplish the app&#x27;s goals? Are there unintended consequences? Those kinds of things can slow down development.</div><br/></div></div><div id="35722299" class="c"><input type="checkbox" id="c-35722299" checked=""/><div class="controls bullet"><span class="by">wildrhythms</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35722420">prev</a><span>|</span><a href="#35721361">next</a><span>|</span><label class="collapse" for="c-35722299">[-]</label><label class="expand" for="c-35722299">[1 more]</label></div><br/><div class="children"><div class="content">I completely agree. What I want 99% of the time is basically a Javadoc showing the methods, the inputs, and the outputs, and all of the types. And if there&#x27;s a short summary and an example as supplemental material, that&#x27;s great.<p>Unfortunately, developers seem to think their contrived examples are a stand-in for actually documenting the methods. I deal with a lot of Javascript libraries like this and it drives me insane.</div><br/></div></div><div id="35721361" class="c"><input type="checkbox" id="c-35721361" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35722299">prev</a><span>|</span><a href="#35721549">next</a><span>|</span><label class="collapse" for="c-35721361">[-]</label><label class="expand" for="c-35721361">[1 more]</label></div><br/><div class="children"><div class="content">My personal frustration with the docs is that very similar words are used in sequence and for both generic and specific meanings.<p>“The possessor of the bearer token is authorised to re-request a refresh token code cookie.” is only a very slight exaggeration.<p>I also want to slap the Microsoft employees that use six different similar terms for three GUIDs that look identically random. E.g.: “Client ID (Principal ID)”.<p>It’s maddening.</div><br/></div></div><div id="35721549" class="c"><input type="checkbox" id="c-35721549" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35721361">prev</a><span>|</span><a href="#35721287">next</a><span>|</span><label class="collapse" for="c-35721549">[-]</label><label class="expand" for="c-35721549">[1 more]</label></div><br/><div class="children"><div class="content">Except HTTP prohibits copying headers from redirect responses to redirected requests.  That&#x27;s why OIDC exists, to deal with that by abusing URI q-params.<p>I&#x27;ve an Internet-Draft somewhere to fix this by making it possible to indicate on a 3xx that this is for authentication (so copy Authorization: from redirect responses to redirected requests) and to allow 401s to have Location: headers that make it more like a 3xx, and 3xxs have WWW-Authenticate:, so you can negotiate between legacy HTTP auth and redirect-based authentication.</div><br/></div></div><div id="35721287" class="c"><input type="checkbox" id="c-35721287" checked=""/><div class="controls bullet"><span class="by">Krisjohn</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35721549">prev</a><span>|</span><a href="#35720221">next</a><span>|</span><label class="collapse" for="c-35721287">[-]</label><label class="expand" for="c-35721287">[1 more]</label></div><br/><div class="children"><div class="content">I’m happy when someone explains something with words strung together into sentences, rather than code. Code is an example, an example is not an explanation.<p>Then your examples can be simple, rather than trying to be a complete explanation of everything.</div><br/></div></div><div id="35720139" class="c"><input type="checkbox" id="c-35720139" checked=""/><div class="controls bullet"><span class="by">garbagecoder</span><span>|</span><a href="#35720006">parent</a><span>|</span><a href="#35720221">prev</a><span>|</span><a href="#35718456">next</a><span>|</span><label class="collapse" for="c-35720139">[-]</label><label class="expand" for="c-35720139">[1 more]</label></div><br/><div class="children"><div class="content">Somebody print this comment out, frame it, and mail it to every major API author.</div><br/></div></div></div></div><div id="35718456" class="c"><input type="checkbox" id="c-35718456" checked=""/><div class="controls bullet"><span class="by">remus</span><span>|</span><a href="#35720006">prev</a><span>|</span><a href="#35722217">next</a><span>|</span><label class="collapse" for="c-35718456">[-]</label><label class="expand" for="c-35718456">[33 more]</label></div><br/><div class="children"><div class="content">It&#x27;d be interesting to hear about people who have had a good time implementing OAuth, as my experience is similar to that in the article. I&#x27;ve played with adding it to a few side projects and the process usually goes:<p>1. Read loads of docs, end up pretty confused<p>2. Find a library that seems to do what I want<p>3. Install this huge library full of opaque code 
doing...things<p>4. Have an impossible time troubleshooting issues<p>5. Get scared (&quot;I&#x27;m almost certainly doing something wrong here&quot;) and give up<p>I find it hard to have much faith in security standards like this. I want them small, well defined and understandable and OAuth does not meet any of these criteria in my experience.</div><br/><div id="35718816" class="c"><input type="checkbox" id="c-35718816" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35721654">next</a><span>|</span><label class="collapse" for="c-35718816">[-]</label><label class="expand" for="c-35718816">[12 more]</label></div><br/><div class="children"><div class="content">I have read many docs.<p>The one that I find easiest to understanding is still the one that I wrote about a decade ago when I first had to work with OAuth 2.  All others I understanding by mapping what they said to concepts in mine, and that seems to work pretty well.<p>My document is available at <a href="https:&#x2F;&#x2F;metacpan.org&#x2F;dist&#x2F;LWP-Authen-OAuth2&#x2F;view&#x2F;lib&#x2F;LWP&#x2F;Authen&#x2F;OAuth2&#x2F;Overview.pod" rel="nofollow">https:&#x2F;&#x2F;metacpan.org&#x2F;dist&#x2F;LWP-Authen-OAuth2&#x2F;view&#x2F;lib&#x2F;LWP&#x2F;Aut...</a>.  Even though you&#x27;re unlikely to ever use that library or language, you may find it worthwhile.</div><br/><div id="35719796" class="c"><input type="checkbox" id="c-35719796" checked=""/><div class="controls bullet"><span class="by">interroboink</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35718816">parent</a><span>|</span><a href="#35718941">next</a><span>|</span><label class="collapse" for="c-35719796">[-]</label><label class="expand" for="c-35719796">[2 more]</label></div><br/><div class="children"><div class="content">As a fan of Perl, this situation of having an obscure, meticulously-documented CPAN module to not only explain but implement some common-but-surprisingly-hard pattern is just so ... Perl-y (:<p>Perhaps it&#x27;s a semi-consequence of Perl being perceived as old and crusty, and popular with old crusty people who are merely trying to get things done without fluff (at least speaking for myself).<p>Reminds me of Data::Manip, another favorite of mine.<p>Thanks for taking the time to write this (and implement all that nonsense).</div><br/><div id="35720976" class="c"><input type="checkbox" id="c-35720976" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35719796">parent</a><span>|</span><a href="#35718941">next</a><span>|</span><label class="collapse" for="c-35720976">[-]</label><label class="expand" for="c-35720976">[1 more]</label></div><br/><div class="children"><div class="content">Thanks.<p>The crustiness in this case was enhanced by my grumpiness over some frustrating debugging sessions, and having to go through a lot of very confusing documentation to get there.  That grumpiness shows through in a couple of places.<p>For example I understand why Google decided that I was asking for the same permission too often, and began handing me codes that would not work.  And also wouldn&#x27;t explain what was wrong with the code that I just got.</div><br/></div></div></div></div><div id="35718941" class="c"><input type="checkbox" id="c-35718941" checked=""/><div class="controls bullet"><span class="by">sebmellen</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35718816">parent</a><span>|</span><a href="#35719796">prev</a><span>|</span><a href="#35720832">next</a><span>|</span><label class="collapse" for="c-35718941">[-]</label><label class="expand" for="c-35718941">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty astounded, because this is by far the best OAuth 2 doc I&#x27;ve ever read, and that&#x27;s after reading and watching many hours of content from leaders and companies in the space.</div><br/><div id="35721020" class="c"><input type="checkbox" id="c-35721020" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35718941">parent</a><span>|</span><a href="#35720832">next</a><span>|</span><label class="collapse" for="c-35721020">[-]</label><label class="expand" for="c-35721020">[1 more]</label></div><br/><div class="children"><div class="content">Thank you.<p>It summarized my understanding after a month of reading documentation, doing experiments, and generally banging my head against the wall.</div><br/></div></div></div></div><div id="35720832" class="c"><input type="checkbox" id="c-35720832" checked=""/><div class="controls bullet"><span class="by">jkubicek</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35718816">parent</a><span>|</span><a href="#35718941">prev</a><span>|</span><a href="#35720237">next</a><span>|</span><label class="collapse" for="c-35720832">[-]</label><label class="expand" for="c-35720832">[4 more]</label></div><br/><div class="children"><div class="content">Your documentation is amongst the best I&#x27;ve seen on OAuth, but it suffers from the same naming confusion I <i>always</i> run into when I&#x27;m reading OAuth docs.<p>&gt; OAuth 2 makes it easy for large <i>service providers</i> to write many APIs that <i>users</i> can securely authorize third party <i>consumers</i><p>If I&#x27;m trying to write a Mastodon client, I&#x27;m reading this line piece by piece:<p>&gt; OAuth 2 makes it easy for large <i>service providers</i><p>&quot;service providers&quot; OK, that must be the Mastodon service.<p>&gt; ... to write many APIs that <i>users</i><p>&quot;users&quot; That must be me<p>&gt; ... can securely authorize third party <i>consumers</i><p>&quot;consumers&quot; OK... that&#x27;s also me?</div><br/><div id="35720953" class="c"><input type="checkbox" id="c-35720953" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35720832">parent</a><span>|</span><a href="#35722482">next</a><span>|</span><label class="collapse" for="c-35720953">[-]</label><label class="expand" for="c-35720953">[1 more]</label></div><br/><div class="children"><div class="content">That is why there is a terminology section: <a href="https:&#x2F;&#x2F;metacpan.org&#x2F;dist&#x2F;LWP-Authen-OAuth2&#x2F;view&#x2F;lib&#x2F;LWP&#x2F;Authen&#x2F;OAuth2&#x2F;Overview.pod#Terminology" rel="nofollow">https:&#x2F;&#x2F;metacpan.org&#x2F;dist&#x2F;LWP-Authen-OAuth2&#x2F;view&#x2F;lib&#x2F;LWP&#x2F;Aut...</a><p>If you&#x27;re trying to write a Mastadon client, then the Mastadon service is the service provider, you are the consumer, and the people who wish to use your client are the users.</div><br/></div></div><div id="35722482" class="c"><input type="checkbox" id="c-35722482" checked=""/><div class="controls bullet"><span class="by">mekoka</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35720832">parent</a><span>|</span><a href="#35720953">prev</a><span>|</span><a href="#35720900">next</a><span>|</span><label class="collapse" for="c-35722482">[-]</label><label class="expand" for="c-35722482">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s helpful to not stray too far away from the standard terminology.  I found that &quot;third party&quot; was an excellent indicator that the <i>consumer</i> is probably not me, especially since I&#x27;ve already qualified as a user.</div><br/></div></div><div id="35720900" class="c"><input type="checkbox" id="c-35720900" checked=""/><div class="controls bullet"><span class="by">Operyl</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35720832">parent</a><span>|</span><a href="#35722482">prev</a><span>|</span><a href="#35720237">next</a><span>|</span><label class="collapse" for="c-35720900">[-]</label><label class="expand" for="c-35720900">[1 more]</label></div><br/><div class="children"><div class="content">Users are your users shared with the users of that API service (which may include you if you use your own service), consumer in this case is you (the application you&#x27;re running).</div><br/></div></div></div></div><div id="35720237" class="c"><input type="checkbox" id="c-35720237" checked=""/><div class="controls bullet"><span class="by">count</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35718816">parent</a><span>|</span><a href="#35720832">prev</a><span>|</span><a href="#35720653">next</a><span>|</span><label class="collapse" for="c-35720237">[-]</label><label class="expand" for="c-35720237">[1 more]</label></div><br/><div class="children"><div class="content">Please publish this on its own somewhere!  This is fantastic.</div><br/></div></div><div id="35720653" class="c"><input type="checkbox" id="c-35720653" checked=""/><div class="controls bullet"><span class="by">adammarples</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35718816">parent</a><span>|</span><a href="#35720237">prev</a><span>|</span><a href="#35719646">next</a><span>|</span><label class="collapse" for="c-35720653">[-]</label><label class="expand" for="c-35720653">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m bookmarking this to go through the next time I need to bang my head against this wall, thanks</div><br/></div></div><div id="35719646" class="c"><input type="checkbox" id="c-35719646" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35718816">parent</a><span>|</span><a href="#35720653">prev</a><span>|</span><a href="#35721654">next</a><span>|</span><label class="collapse" for="c-35719646">[-]</label><label class="expand" for="c-35719646">[1 more]</label></div><br/><div class="children"><div class="content">Looks great, taking a look and favoriting.<p>(Only feedback I can think of is that it would be great to have a few diagrams... like from excalidraw or something.  Am largely a visual learner.)</div><br/></div></div></div></div><div id="35721654" class="c"><input type="checkbox" id="c-35721654" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35718816">prev</a><span>|</span><a href="#35718775">next</a><span>|</span><label class="collapse" for="c-35721654">[-]</label><label class="expand" for="c-35721654">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve both had to acquire and validate[1] tokens from Azure AD, both Client Credentials[2] and Authorization Code[3] flows, and found Microsofts documentation quite good. I&#x27;ve also had to acquire tokens using certificate-based Client Credentials flow from another party.<p>Overall I found it fairly OK, it&#x27;s a bit of a learning curve when you&#x27;re just used to basic user&#x2F;pass, but it&#x27;s fine.<p>However the main issue is that when it&#x27;s not working it&#x27;s very opaque. This is even worse when trying to _use_ the tokens.<p>I spent many hours trying to figure out why my Client Credentials tokens wouldn&#x27;t work for logging on to Office365&#x27;s IMAP server, only to spend half an hour searching and finding some Microsoft community forum post saying it wasn&#x27;t implemented yet... they only supported Authorization Code flow. This has been fixed they say, I&#x27;ll know later today cause that just came up as a priority ticket...<p>All you get back is some &quot;nope&quot;, with no way to figure out why.<p>[1]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;active-directory&#x2F;develop&#x2F;access-tokens" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;active-directory&#x2F;dev...</a><p>[2]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;active-directory&#x2F;develop&#x2F;v2-oauth2-client-creds-grant-flow" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;active-directory&#x2F;dev...</a><p>[3]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;active-directory&#x2F;develop&#x2F;v2-oauth2-auth-code-flow" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;active-directory&#x2F;dev...</a></div><br/></div></div><div id="35718775" class="c"><input type="checkbox" id="c-35718775" checked=""/><div class="controls bullet"><span class="by">zippergz</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35721654">prev</a><span>|</span><a href="#35721729">next</a><span>|</span><label class="collapse" for="c-35718775">[-]</label><label class="expand" for="c-35718775">[1 more]</label></div><br/><div class="children"><div class="content">3b. realize that library is deprecated or hasn&#x27;t been updated in many years and is either totally broken, or incompatible with something else you&#x27;re using.</div><br/></div></div><div id="35721729" class="c"><input type="checkbox" id="c-35721729" checked=""/><div class="controls bullet"><span class="by">gpspake</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35718775">prev</a><span>|</span><a href="#35721564">next</a><span>|</span><label class="collapse" for="c-35721729">[-]</label><label class="expand" for="c-35721729">[1 more]</label></div><br/><div class="children"><div class="content">I had a good experience when I went in to a project with the attitude that &quot;Ok, I&#x27;m going to wire up auth0 in perfect accordance with how they want me to, absolutely from scratch with the most perfect clean official documentation&#x2F;library (in my case the react auth0 sdk) conforming approach possible.<p>I spent a lot of time making sure I did everything as by the book as possible and , in the end, I had a good experience and felt confident in my implementation, and like I understood all the moving parts. I even got help in a SO thread from an auth0 employee.<p>Auth0 could have been anything, here... On the same project, I kind of did the same thing with vite&#x2F;react&#x2F;tailwind client and fast api backend where I touched every piece of it, made every decision, and made sure I was really confident.
This was in my own little vacuum where a big part of the app was just creating my perfect little sandbox. Stuff gets way more complicated when you have to hustle to get stuff over the line or you&#x27;re trying to cram so new auth implementation in to an 8 yr old app that&#x27;s been walked around on by dozens of engineers slamming out slop to close a ticket.<p>(Note: I know auth0 is a little more on-rails than implementing auth0 without it. They tend to have pretty good guides if you&#x27;re using current hotness like react or fastapi)</div><br/></div></div><div id="35721564" class="c"><input type="checkbox" id="c-35721564" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35721729">prev</a><span>|</span><a href="#35719929">next</a><span>|</span><label class="collapse" for="c-35721564">[-]</label><label class="expand" for="c-35721564">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve reimplemented oauth for the same provider (bungie.net) countless times. I think it might seem daunting, but when you break it down into the steps it&#x27;s pretty simple:<p>- Send user to example.com<p>- Eventually they&#x27;re sent back to yoursite.com with a ?code=abc<p>- Call example.com&#x2F;OAuth to exchange ?code=abc for access token and refresh token<p>- You&#x27;re done (for now)<p>- When access token expires, call example.com&#x2F;OAuth to exchange refresh token for a new access token and refresh token<p>The tricky part is that a bunch <i>is</i> implementation specific, so memorising the above only gets you half way to implementing with another provider.</div><br/><div id="35722021" class="c"><input type="checkbox" id="c-35722021" checked=""/><div class="controls bullet"><span class="by">chasd00</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35721564">parent</a><span>|</span><a href="#35719929">next</a><span>|</span><label class="collapse" for="c-35722021">[-]</label><label class="expand" for="c-35722021">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I don’t see what the big deal is. You don’t need to know every oauth flow by heart and most of the time you’re going to be using the authorization code flow anyway. There are tons of articles and comments on HN about much more complex things than oauth every day.</div><br/></div></div></div></div><div id="35719929" class="c"><input type="checkbox" id="c-35719929" checked=""/><div class="controls bullet"><span class="by">titaniczero</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35721564">prev</a><span>|</span><a href="#35721275">next</a><span>|</span><label class="collapse" for="c-35719929">[-]</label><label class="expand" for="c-35719929">[1 more]</label></div><br/><div class="children"><div class="content">My experience is similar but tbh I feel it&#x27;s mainly due to the fact that oauth is implementing an important security layer (authentication&#x2F;authorization) and that&#x27;s hard by definition. There are lots of steps and things you can&#x27;t afford to overlook or you&#x27;ll be vulnerable to multiple different attacks</div><br/></div></div><div id="35721275" class="c"><input type="checkbox" id="c-35721275" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35719929">prev</a><span>|</span><a href="#35720096">next</a><span>|</span><label class="collapse" for="c-35721275">[-]</label><label class="expand" for="c-35721275">[2 more]</label></div><br/><div class="children"><div class="content">When I stopped using libraries and implemented my own things got a lot less frustrating. Still a pain in the ass, but I didn’t feel like the errors came out of nowhere any more anyway.</div><br/><div id="35722431" class="c"><input type="checkbox" id="c-35722431" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35721275">parent</a><span>|</span><a href="#35720096">next</a><span>|</span><label class="collapse" for="c-35722431">[-]</label><label class="expand" for="c-35722431">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;ve just implemented it myself. Google, Microsoft and some other OIDC provider.<p>I abstracted it away behind a &quot;token provider&quot; interface, so I can just instantiate the right one for the job.<p>There&#x27;s some incantations to get the request right, but I found most documentation decent so just follow that.<p>One service required I implemented RFC 8693 token exchange, which turned out to be trivial since I could represent it as one &quot;token provider&quot; instance wrapping another.<p>Failures can still be opaque though, especially when using the tokens.</div><br/></div></div></div></div><div id="35720096" class="c"><input type="checkbox" id="c-35720096" checked=""/><div class="controls bullet"><span class="by">tarsinge</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35721275">prev</a><span>|</span><a href="#35719755">next</a><span>|</span><label class="collapse" for="c-35720096">[-]</label><label class="expand" for="c-35720096">[1 more]</label></div><br/><div class="children"><div class="content">I found doing a custom (without a library) OAuth integration for only one service relatively straightforward, i.e. when it’s not treated as a standard. For example for a plug-in exclusively for Shopify (random example, didn’t try it) you would just treat it as the rest of their API and write custom code.<p>In short it works when you can see it as a guideline instead of a standard.</div><br/></div></div><div id="35719755" class="c"><input type="checkbox" id="c-35719755" checked=""/><div class="controls bullet"><span class="by">missingdays</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35720096">prev</a><span>|</span><a href="#35721831">next</a><span>|</span><label class="collapse" for="c-35719755">[-]</label><label class="expand" for="c-35719755">[2 more]</label></div><br/><div class="children"><div class="content">OAuth specification was the best source for me. All provider docs are simplified and usually specific to the provider</div><br/><div id="35722040" class="c"><input type="checkbox" id="c-35722040" checked=""/><div class="controls bullet"><span class="by">chasd00</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35719755">parent</a><span>|</span><a href="#35721831">next</a><span>|</span><label class="collapse" for="c-35722040">[-]</label><label class="expand" for="c-35722040">[1 more]</label></div><br/><div class="children"><div class="content">It’s been a while since I’ve read the RFCs but I recall them being very accessible and clearly written.</div><br/></div></div></div></div><div id="35721831" class="c"><input type="checkbox" id="c-35721831" checked=""/><div class="controls bullet"><span class="by">asdfman123</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35719755">prev</a><span>|</span><a href="#35719545">next</a><span>|</span><label class="collapse" for="c-35721831">[-]</label><label class="expand" for="c-35721831">[1 more]</label></div><br/><div class="children"><div class="content">My preferred development style is<p>1) skimming for limited context<p>2) copying and pasting random code<p>3) trying it with print statements<p>4) getting stuck<p>5) repeating steps 1-3 until it works</div><br/></div></div><div id="35719545" class="c"><input type="checkbox" id="c-35719545" checked=""/><div class="controls bullet"><span class="by">butisaidsudo</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35721831">prev</a><span>|</span><a href="#35719918">next</a><span>|</span><label class="collapse" for="c-35719545">[-]</label><label class="expand" for="c-35719545">[1 more]</label></div><br/><div class="children"><div class="content">I read so many docs when I was trying to implement OAuth and got more and more confused. This video was a huge help though for explaining all of the concepts:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=996OiexHze0">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=996OiexHze0</a></div><br/></div></div><div id="35719918" class="c"><input type="checkbox" id="c-35719918" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#35718456">parent</a><span>|</span><a href="#35719545">prev</a><span>|</span><a href="#35722217">next</a><span>|</span><label class="collapse" for="c-35719918">[-]</label><label class="expand" for="c-35719918">[7 more]</label></div><br/><div class="children"><div class="content">We really deserve a less over-engineered actual standard that has a very restricted feature set.<p>In practice, isn’t OAuth predominantly used to verify proof of email ownership? If so, why not just use magic links as sign up &amp; sign in?<p>1. Sign in&#x2F;up: Enter email (can be pre-filled by browser&#x2F;app)<p>2. Click the email verification link or enter code if on different device.<p>3. Profit. No manual typing necessary, only clicks.<p>This is trivial to implement, and can be extended in the future with a simple standard for browsers&#x2F;apps to automatically verify in the background (to avoid the tab-switching inconvenience in  step 2). On iOS they auto-populate SMS codes in a similar fashion.<p>2FA can be out of scope, (many times not needed because email providers already have it). But if needed, it can be added as a second step after the email proof.<p>Please tell me what I’m missing. This seems, to me, like an excellent trade off between implementation simplicity, extensibility, user convenience and security.</div><br/><div id="35721321" class="c"><input type="checkbox" id="c-35721321" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35719918">parent</a><span>|</span><a href="#35720521">next</a><span>|</span><label class="collapse" for="c-35721321">[-]</label><label class="expand" for="c-35721321">[3 more]</label></div><br/><div class="children"><div class="content">Email and SMS are inherently insecure, and it would be a lot harder for whoever&#x27;s on the other end to apply security practices (e.g. look at where logins are coming from, rate-limit authorization attempts). They can&#x27;t pass extra metadata back (user&#x27;s name&#x2F;address&#x2F;avatar&#x2F;etc.) and they can&#x27;t do fine-grained permissions (grant me access to this github repo but not that one, grant me read but not write, ...). Plus I don&#x27;t want to have to switch apps a bunch, and may not have my email with me; doing it all in the browser is much nicer.<p>(On a side note, I&#x27;m constantly annoyed&#x2F;frustrated that after about 20 years of development, authentication codes&#x2F;apps and smartcode verification are starting to be almost as secure and usable as the HTTPS client certificate support that was built into every browser as far back as the &#x27;90s)</div><br/><div id="35721705" class="c"><input type="checkbox" id="c-35721705" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35721321">parent</a><span>|</span><a href="#35720521">next</a><span>|</span><label class="collapse" for="c-35721705">[-]</label><label class="expand" for="c-35721705">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Email and SMS are inherently insecure<p>But nevertheless widely used as de-facto identity, I assume because account recovery in case of lost credentials is paramount. At least 90% of my accounts would be stolen or lost, today, should I lose access to my email.<p>I don’t particularly like email, for many reasons. Especially that most people’s email can be blocked by a faceless corporation that suddenly bans you. That said, I think there are far worse options, such as endless iterations on proprietary and ad-hoc auth “standards”. At least to me, the technical challenges of hardening email seem far less intimidating than educating the public on a new system.<p>&gt; apps and smartcode verification are starting to be almost as secure and usable as the HTTPS client certificate support<p>I agree that client certs are greatly under-utilized and poorly supported by eg reverse proxies, but how would they help here? What’s the user flow for non-technical Joe to acquire a client cert to pay his bills?</div><br/><div id="35722670" class="c"><input type="checkbox" id="c-35722670" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35721705">parent</a><span>|</span><a href="#35720521">next</a><span>|</span><label class="collapse" for="c-35722670">[-]</label><label class="expand" for="c-35722670">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But nevertheless widely used as de-facto identity, I assume because account recovery in case of lost credentials is paramount. At least 90% of my accounts would be stolen or lost, today, should I lose access to my email.<p>Sure, but that&#x27;s your choice. If you want to make your Google account require 3 factor authentication and a 10 minute timeout, you can, and from the perspective of any site logging you in via OAuth from Google, nothing changes. Even if 90% of users are going to use email only, it&#x27;s nice to not force everyone down to that lowest common denominator.<p>&gt; I agree that client certs are greatly under-utilized and poorly supported by eg reverse proxies, but how would they help here? What’s the user flow for non-technical Joe to acquire a client cert to pay his bills?<p>I just feel that if we&#x27;d put half the effort people put into SMS 2FA, authenticator apps, password managers and all that into making a better UX for client certificates, we&#x27;d be further along. Ah well.</div><br/></div></div></div></div></div></div><div id="35720521" class="c"><input type="checkbox" id="c-35720521" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35719918">parent</a><span>|</span><a href="#35721321">prev</a><span>|</span><a href="#35722217">next</a><span>|</span><label class="collapse" for="c-35720521">[-]</label><label class="expand" for="c-35720521">[3 more]</label></div><br/><div class="children"><div class="content">It would simply not handle pretty much any case that I have used OAuth2 to implement so far.<p>For example - login system that merged LDAP&#x2F;Kerberos&#x2F;client cert&#x2F;long-lived application token authentication into single system, that also linked said authentication system into all applications in the network, including making it possible to login to AWS Console using Kerberos (that one was twisty to get running, not because of OAuth2 but because of how it is handled by AWS IAM).<p>Also, I have used it to link in MFA systems of different kinds (it was definitely easier side than industry standard of using Radius)<p>In addition, this proposed system requires that every app has ability to send emails, which honestly is less simple than it sounds, especially today when sending to arbitrary public emails.</div><br/><div id="35720964" class="c"><input type="checkbox" id="c-35720964" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35720521">parent</a><span>|</span><a href="#35722217">next</a><span>|</span><label class="collapse" for="c-35720964">[-]</label><label class="expand" for="c-35720964">[2 more]</label></div><br/><div class="children"><div class="content">For service accounts, email is clearly not the right choice. I don’t have experience with enterprise auth, are Kerberos etc not using company email for human identity?<p>&gt; this proposed system requires that every app has ability to send emails, which honestly is less simple than it sounds<p>For humans and especially end-users of consumer services, my observation is that the elaborate auth dances are using email ownership as last resort anyway, ie for account recovery and&#x2F;or a trusted 3p that has verified the email. So the thought is simply to make that flow more convenient. Perhaps this is misguided.</div><br/><div id="35721544" class="c"><input type="checkbox" id="c-35721544" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#35718456">root</a><span>|</span><a href="#35720964">parent</a><span>|</span><a href="#35722217">next</a><span>|</span><label class="collapse" for="c-35721544">[-]</label><label class="expand" for="c-35721544">[1 more]</label></div><br/><div class="children"><div class="content">In case of OAuth2&#x2F;OIDC, if I do not use external providers (like Google etc.), I can still deploy one of the many OAuth2&#x2F;OIDC providers myself and centralise handling of user database this way.<p>This also means I have one place to support sending last resort emails<p>As for enterprise auth, a lot of places in fact do not use emails for identity. Sometimes there&#x27;s more than one login id mapping to one identity (noticeable case - Kerberos&#x2F;LDAP as done by Active Directory, where your login can come in email-style form and pre-AD form, and the email-style one doesn&#x27;t have to correspond to an email)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35722217" class="c"><input type="checkbox" id="c-35722217" checked=""/><div class="controls bullet"><span class="by">schlowmo</span><span>|</span><a href="#35718456">prev</a><span>|</span><a href="#35720651">next</a><span>|</span><label class="collapse" for="c-35722217">[-]</label><label class="expand" for="c-35722217">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OAuth is a standard protocol. Right? And there are client libraries for OAuth 2.0 available in basically every programming language you can imagine.<p>Here lies another pain point of integrating OAuth flows: In my experience those client libraries are a lot better in following the RFCs than the authorization server implementations.<p>It can cause a great deal of pain using such client library with a botched authorization server. If you take a look at the issue trackers of some client libraries you see a lot of &quot;Please make this library work with auth provider XYZ&quot; reports to which the maintainers (rightfully but painfully) respond: &quot;Won&#x27;t fix! We&#x27;re following the RFCs here, we can&#x27;t deal with every crooked  authorization server implementation. Get it fixed at the other side.&quot;<p>And then you have to take the decision if you want to patch the client library youself to make it work (with the risk that this patches break on updates of the client library) or if you roll your own client for that particular auth provider. This decision gets even more complex if you have to support multiple authorization servers. If it&#x27;s only one auth provider the third option would be using a vendor specific client library, which may be as botched as the authorization server, but at least they can talk with each other.</div><br/></div></div><div id="35720651" class="c"><input type="checkbox" id="c-35720651" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#35722217">prev</a><span>|</span><a href="#35718601">next</a><span>|</span><label class="collapse" for="c-35720651">[-]</label><label class="expand" for="c-35720651">[1 more]</label></div><br/><div class="children"><div class="content">1. because it&#x27;s conceptually not an easy thing<p>2. because the standard was messed up (instead of specificing a protocol with _at most_ one clearly specified flow per use-case (you can use it for more then SSO&#x2F;Cross App Auth) they specified something more like a framework to build your own standard, but still pretended it&#x27;s a single protocol, but if you can&#x27;t use the standard to &quot;blindly&quot; build a client which works without knowing anything about the vendor then it&#x27;s not a protocol, at least not a complete one)<p>3. because the standard covers too much potential use cases<p>4. because vendors haven&#x27;t yet converged their implementations enough and might never do so (time for OAuth 3 which just specified on specific OAuth2 flow implementation??)<p>Given that OAuth2 was started with clearly very different goals in mind and the main profiteers of the current situation are a few big companies like Google, Facebook and Microsoft I have heard people stating that OAuth2 being messed up was intentionally. _I don&#x27;t believe so_, it more looks like a typical case of accidentally over engineering by trying to doing so much.<p>I still don&#x27;t like the situation as OAuth2 was too some degree a coffin nail to the idea of generic SSO (i.e. you as a customer can freely choose a SSO provider when signing one) and that sucks really hard and if we had generic SSO passwords would be _way_ less of an issue today (imagine _any_ email provider could _easily_ also provide a SSO service for any side you can have an account with).</div><br/></div></div><div id="35718601" class="c"><input type="checkbox" id="c-35718601" checked=""/><div class="controls bullet"><span class="by">coderintherye</span><span>|</span><a href="#35720651">prev</a><span>|</span><a href="#35718499">next</a><span>|</span><label class="collapse" for="c-35718601">[-]</label><label class="expand" for="c-35718601">[6 more]</label></div><br/><div class="children"><div class="content">Related gripe: Your API doesn&#x27;t always need OAuth. If I&#x27;m using your product as your customer and I directly want to leverage my own product data via your API then I shouldn&#x27;t be forced to have to implement [your almost invariably non-standard and difficult] OAuth implementation. An API key should be an option or HMAC if the extra security is felt to be warranted, but not the absurdity of needing to go through a client flow to check the boxes to say yes I consent to share my own data with my own self for this API use that will never be seen or used by a 3rd-party.</div><br/><div id="35719200" class="c"><input type="checkbox" id="c-35719200" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35718601">parent</a><span>|</span><a href="#35720420">next</a><span>|</span><label class="collapse" for="c-35719200">[-]</label><label class="expand" for="c-35719200">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If I&#x27;m using your product as your customer and I directly want to leverage my own product data<p>Correct. Fortunately, in my personal experience many services offer exactly this (JIRA, Hubspot, Slack).<p>OAuth is only relevant where the resource owner and client are different parties. I.e. it&#x27;s for third party clients, not second party clients.</div><br/></div></div><div id="35720420" class="c"><input type="checkbox" id="c-35720420" checked=""/><div class="controls bullet"><span class="by">TRiG_Ireland</span><span>|</span><a href="#35718601">parent</a><span>|</span><a href="#35719200">prev</a><span>|</span><a href="#35719724">next</a><span>|</span><label class="collapse" for="c-35720420">[-]</label><label class="expand" for="c-35720420">[1 more]</label></div><br/><div class="children"><div class="content">I ran into that recently trying to connect a web shop we&#x27;ve built to an accounting platform. The web shop handles the entire checkout flow, but the owners also want a copy of the invoice stored in their accounting platform. The platform has an API. So our web shop can ping the accounting platform after an order is placed, and sent them a record of what was purchased? No. Because the API requires authorization. So the admin has to occasionally log into our website and hit a button to send invoices to the accounting platform. (At least we can send multiple invoices at once, so it doesn&#x27;t require them to hit a button on each individual one.)</div><br/></div></div><div id="35719724" class="c"><input type="checkbox" id="c-35719724" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#35718601">parent</a><span>|</span><a href="#35720420">prev</a><span>|</span><a href="#35720365">next</a><span>|</span><label class="collapse" for="c-35719724">[-]</label><label class="expand" for="c-35719724">[1 more]</label></div><br/><div class="children"><div class="content">OAuth client credential flow is this easy mode you ask for. It’s one call with a secret in it and back comes a token.</div><br/></div></div><div id="35720365" class="c"><input type="checkbox" id="c-35720365" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#35718601">parent</a><span>|</span><a href="#35719724">prev</a><span>|</span><a href="#35719356">next</a><span>|</span><label class="collapse" for="c-35720365">[-]</label><label class="expand" for="c-35720365">[1 more]</label></div><br/><div class="children"><div class="content">If you want to have password reset, OTP, 2FA, webauthn and so on, you probably want to use an external authentication provider. Integrating it with oidc&#x2F;oauth is much easier, than doing all that stuff by yourself.</div><br/></div></div><div id="35719356" class="c"><input type="checkbox" id="c-35719356" checked=""/><div class="controls bullet"><span class="by">justrealist</span><span>|</span><a href="#35718601">parent</a><span>|</span><a href="#35720365">prev</a><span>|</span><a href="#35718499">next</a><span>|</span><label class="collapse" for="c-35719356">[-]</label><label class="expand" for="c-35719356">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention needing to create awkward shared service accounts to impersonate.</div><br/></div></div></div></div><div id="35718499" class="c"><input type="checkbox" id="c-35718499" checked=""/><div class="controls bullet"><span class="by">mkl95</span><span>|</span><a href="#35718601">prev</a><span>|</span><a href="#35719279">next</a><span>|</span><label class="collapse" for="c-35718499">[-]</label><label class="expand" for="c-35718499">[11 more]</label></div><br/><div class="children"><div class="content">OAuth sucks. It&#x27;s one of the worst abstractions of our time. It&#x27;s incredibly easy to implement some half assed spaghetti and call it &quot;standard OAuth&quot;.</div><br/><div id="35718559" class="c"><input type="checkbox" id="c-35718559" checked=""/><div class="controls bullet"><span class="by">lloydatkinson</span><span>|</span><a href="#35718499">parent</a><span>|</span><a href="#35720222">next</a><span>|</span><label class="collapse" for="c-35718559">[-]</label><label class="expand" for="c-35718559">[2 more]</label></div><br/><div class="children"><div class="content">I suspect it’s either by design that it is this terrible and hard to deal with or larger auth companies have a vested interest in keeping it this terrible.</div><br/><div id="35719314" class="c"><input type="checkbox" id="c-35719314" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#35718499">root</a><span>|</span><a href="#35718559">parent</a><span>|</span><a href="#35720222">next</a><span>|</span><label class="collapse" for="c-35719314">[-]</label><label class="expand" for="c-35719314">[1 more]</label></div><br/><div class="children"><div class="content">There is no grand conspiracy here, and the problems OAuth is trying to solve can be pretty messy regardless of the approach.<p>When the environment involves delegating authentication across service providers, dealing with browsers and native clients, mobile apps, etc, there will not be a simple solution.<p>This is made even more challenging by constantly evolving application and edge deployment architectures, each bringing with it a new element of complexity.<p>OAuth sucks, and I’m sure it could be replaced with something better, but that replacement will also suck and bear a passing resemblance to OAuth, because the underlying problem is a messy one that isn’t going away soon.</div><br/></div></div></div></div><div id="35720222" class="c"><input type="checkbox" id="c-35720222" checked=""/><div class="controls bullet"><span class="by">zmxz</span><span>|</span><a href="#35718499">parent</a><span>|</span><a href="#35718559">prev</a><span>|</span><a href="#35719279">next</a><span>|</span><label class="collapse" for="c-35720222">[-]</label><label class="expand" for="c-35720222">[8 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t suck, it&#x27;s literally bare-minimum what you need in order to securely retrieve the token.<p>It&#x27;s by far not THE worst, you&#x27;re spouting total nonsense. What&#x27;s THE worst is lack of attention, and one needs quite literally 10 minutes to read the RFC and understand it&#x27;s fairly simple protocol with minimal number of parameters.<p>I&#x27;m sorry you had a hard time with OAuth, but have you ever thought the problem is in you and not the protocol? Reason I&#x27;m asking is because you declare it sucks but you are not providing any kind of alternative of how it would not suck.</div><br/><div id="35720325" class="c"><input type="checkbox" id="c-35720325" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#35718499">root</a><span>|</span><a href="#35720222">parent</a><span>|</span><a href="#35719279">next</a><span>|</span><label class="collapse" for="c-35720325">[-]</label><label class="expand" for="c-35720325">[7 more]</label></div><br/><div class="children"><div class="content">&gt; and one needs quite literally 10 minutes to read the RFC<p>rfc 6749 is 4259 words according to wc -l. You mean that it takes 10 minutes to carelessly skim it.<p>Never mind that there are several other OAuth RFCs.</div><br/><div id="35720434" class="c"><input type="checkbox" id="c-35720434" checked=""/><div class="controls bullet"><span class="by">zmxz</span><span>|</span><a href="#35718499">root</a><span>|</span><a href="#35720325">parent</a><span>|</span><a href="#35719279">next</a><span>|</span><label class="collapse" for="c-35720434">[-]</label><label class="expand" for="c-35720434">[6 more]</label></div><br/><div class="children"><div class="content">You need 10 minutes of focused reading to understand what the purpose of the protocol is and you don&#x27;t need all of the OAuth RFCs to implement the bare-minimum nor do you have to support all the grants available.<p>Most people I worked with don&#x27;t understand the purpose of OAuth and that&#x27;s what the 10 minutes should be invested into.<p>Or, you can, you know - nitpick and live in the world of gloom and doom where everything sucks.</div><br/><div id="35721079" class="c"><input type="checkbox" id="c-35721079" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#35718499">root</a><span>|</span><a href="#35720434">parent</a><span>|</span><a href="#35719279">next</a><span>|</span><label class="collapse" for="c-35721079">[-]</label><label class="expand" for="c-35721079">[5 more]</label></div><br/><div class="children"><div class="content">For what it’s worth, I taught a series of classes&#x2F;labs intended to help developers within my former employer’s ecosystem understand OAuth.<p>What I learned after delivering the content to hundreds of devs over the years: OAuth confuses people, and for completely understandable reasons. Most people think about auth in terms of usernames&#x2F;passwords or API keys. The mental models associated with these do not transfer to OAuth, and there are enough moving parts with client and server-side interactions that someone not already steeped in the authn&#x2F;authz space will have some catching up to do.<p>Forming an understanding of the basic concepts rarely happens in 10 minutes, and if that’s your experience, good on you. Most of us  bang our head against the wall for a bit and some of us go on to teach classes about it.<p>Bottom line: OAuth is hard. That is not the same thing as the general concept being simple.</div><br/><div id="35721556" class="c"><input type="checkbox" id="c-35721556" checked=""/><div class="controls bullet"><span class="by">zmxz</span><span>|</span><a href="#35718499">root</a><span>|</span><a href="#35721079">parent</a><span>|</span><a href="#35721465">next</a><span>|</span><label class="collapse" for="c-35721556">[-]</label><label class="expand" for="c-35721556">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Forming an understanding of the basic concepts rarely happens in 10 minutes<p>It happens when you&#x27;re working and have sufficient experience, knowledge and practice when it comes to web, programming and HTTP.<p>It&#x27;s impractical, irresponsible and insane to have anyone other than a person with sufficient knowledge to work on application &#x2F; API that supports OAuth and for person with proper expertise - the protocol is simple because it&#x27;s literally the bare minimum needed to establish secure request&#x2F;response pattern.<p>I work with SAML 2.0 and OAuth2&#x2F;OIDC, I deal with programmers and other people within areas of API, authentication, authorization and it is true that majority of people I interacted with are having troubles understanding these protocols.
 However, what I can attest to is that they&#x27;re also extremely underwhelming as people working in IT, with bad work habits and misplaced focus. It&#x27;s impossible to explain or clear up the protocol to such audience because they lack much more when it comes to knowledge and discipline. But, I did interact with several brilliant people with far less experience compared to me who did get the purpose of this protocol and who implemented it successfully and have done so quite fast.<p>What the wall of text means is that where there&#x27;s will - there&#x27;s a way. You can&#x27;t force knowledge into audience who can&#x27;t or refuse to understand it, so there&#x27;s no point in even trying to do it let alone draw conclusions how the protocol is hard, confusing or difficult when there&#x27;s whole knowledge void in other pre-requisite areas.</div><br/><div id="35722151" class="c"><input type="checkbox" id="c-35722151" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#35718499">root</a><span>|</span><a href="#35721556">parent</a><span>|</span><a href="#35721465">next</a><span>|</span><label class="collapse" for="c-35722151">[-]</label><label class="expand" for="c-35722151">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>it is true that majority of people I interacted with are having troubles understanding these protocols. However, what I can attest to is that they&#x27;re also extremely underwhelming as people working in IT, with bad work habits and misplaced focus. It&#x27;s impossible to explain or clear up the protocol to such audience because they lack much more when it comes to knowledge and discipline.</i><p>In my experience, IT generalists are dealing with a thousand problems, and that has little to do with misplaced focus and more to do with the fact that management just spent $$$ on this new platform and needs it integrated with internal systems, and they&#x27;re encountering this OAuth thing out of necessity.<p>Part of the reason my training materials were successful within that community was because they distilled all of the usual questions about how and why someone would use OAuth relative to the platform and presented essentially a menu of recommended options to be explored further depending on their use case.<p>And people found success with this approach because it helped them solve their very immediate and concrete problem while also explaining <i>why</i> the approach solves that problem.<p>&gt; <i>You can&#x27;t force knowledge into audience who can&#x27;t or refuse to understand it, so there&#x27;s no point in even trying to do it let alone draw conclusions how the protocol is hard, confusing or difficult when there&#x27;s whole knowledge void in other pre-requisite areas.</i><p>Different people have vastly different learning styles, and some people just don&#x27;t do well if you hand them a dense specification. Working from concrete use cases can be far more productive since it meets users where they are and gives them a pathway to understanding how their use cases connects to the OAuth concepts.<p>In a perfect world, everyone who works on auth would be experts. In the world we have, quite a few people have no choice but to do their best to learn the subject matter to solve the problem at hand.<p>Unfortunately this also leads to quite a bit of confusion and some really problematic OAuth implementations.</div><br/></div></div></div></div><div id="35721465" class="c"><input type="checkbox" id="c-35721465" checked=""/><div class="controls bullet"><span class="by">dwaite</span><span>|</span><a href="#35718499">root</a><span>|</span><a href="#35721079">parent</a><span>|</span><a href="#35721556">prev</a><span>|</span><a href="#35719279">next</a><span>|</span><label class="collapse" for="c-35721465">[-]</label><label class="expand" for="c-35721465">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Most people think about auth in terms of usernames&#x2F;passwords or API keys.<p>OAuth is hard to explain here because it is not an authentication protocol, and without extensions has severe security flaws in being one. OpenID Connect is the most popular effort extending OAuth to also handle authentication.<p>But that doesn&#x27;t change that the thing OAuth is most associated with is not what it actually sets out to accomplish.</div><br/><div id="35722036" class="c"><input type="checkbox" id="c-35722036" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#35718499">root</a><span>|</span><a href="#35721465">parent</a><span>|</span><a href="#35719279">next</a><span>|</span><label class="collapse" for="c-35722036">[-]</label><label class="expand" for="c-35722036">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this misconception is at the heart of so much confusion, and far too many OAuth implementations were clearly borne of &quot;well, the customer was demanding we support OAuth so we implemented it&quot;, and there was clearly no understanding of the distinction between authn and authz, or what use cases are actually getting solved.<p>I once worked with a vendor who provided an API and required all API clients to use OAuth with Auth Code Grant Flow. The API was designed to support backend automation use cases within the product, and could execute functionality behind the scenes headlessly. Auth Code Grant Flow requires interactive login by a user sitting at a keyboard, and they never stopped to consider that backend automation use cases are not going to work well if someone has to periodically execute an interactive auth flow. This wasn&#x27;t a once-in-a-year occurrence since they enforced relatively short refresh token timeouts.<p>The degree of confusion and the <i>prevalence</i> of that confusion on this subject is quite high. Someone gets a task to &quot;Implement OAuth&quot;, and they see that Auth Code Grant Flow is the most common, so that must be what we should implement.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="35719279" class="c"><input type="checkbox" id="c-35719279" checked=""/><div class="controls bullet"><span class="by">stcroixx</span><span>|</span><a href="#35718499">prev</a><span>|</span><a href="#35722198">next</a><span>|</span><label class="collapse" for="c-35719279">[-]</label><label class="expand" for="c-35719279">[3 more]</label></div><br/><div class="children"><div class="content">Probably because the part most of the world is actually interested in was later renamed &#x27;Open ID Connect&#x27; and any attempt to research using the term OAuth will bring you nothing but incorrect, old, ad-hoc implementations and presentations by snake oil selling &#x27;personalities&#x27; claiming they understand it.</div><br/><div id="35721073" class="c"><input type="checkbox" id="c-35721073" checked=""/><div class="controls bullet"><span class="by">bootloop</span><span>|</span><a href="#35719279">parent</a><span>|</span><a href="#35719566">next</a><span>|</span><label class="collapse" for="c-35721073">[-]</label><label class="expand" for="c-35721073">[1 more]</label></div><br/><div class="children"><div class="content">And once you realize you actually want OpenID Connect and none of the OAuth 2.0 features, you stumble about the fact that  OpenID is not what you want because they just share a name... Where was I again ???</div><br/></div></div><div id="35719566" class="c"><input type="checkbox" id="c-35719566" checked=""/><div class="controls bullet"><span class="by">411111111111111</span><span>|</span><a href="#35719279">parent</a><span>|</span><a href="#35721073">prev</a><span>|</span><a href="#35722198">next</a><span>|</span><label class="collapse" for="c-35719566">[-]</label><label class="expand" for="c-35719566">[1 more]</label></div><br/><div class="children"><div class="content">Naw, the same applies to oidc.   Especially in the browser.<p>The issue itself also sounds easy enough to implement that you might get suckered into rolling your own (you only need to do a redirect and a request every n-minutes) ... But it&#x27;s surprisingly hard as there are a lot of edge cases with long running timers and potentially multiple browser tabs&#x2F;windows etc.</div><br/></div></div></div></div><div id="35722198" class="c"><input type="checkbox" id="c-35722198" checked=""/><div class="controls bullet"><span class="by">tommoor</span><span>|</span><a href="#35719279">prev</a><span>|</span><a href="#35717793">next</a><span>|</span><label class="collapse" for="c-35722198">[-]</label><label class="expand" for="c-35722198">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not particularly hard, this article is just self-serving content marketing because their product is an OAuth wrapper.</div><br/></div></div><div id="35717793" class="c"><input type="checkbox" id="c-35717793" checked=""/><div class="controls bullet"><span class="by">welder</span><span>|</span><a href="#35722198">prev</a><span>|</span><a href="#35720378">next</a><span>|</span><label class="collapse" for="c-35717793">[-]</label><label class="expand" for="c-35717793">[1 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s too flexible, and allows the OAuth provider to choose which features they support. That puts all the complexity on the client to support every possible implementation.</div><br/></div></div><div id="35720378" class="c"><input type="checkbox" id="c-35720378" checked=""/><div class="controls bullet"><span class="by">idlewords</span><span>|</span><a href="#35717793">prev</a><span>|</span><a href="#35718169">next</a><span>|</span><label class="collapse" for="c-35720378">[-]</label><label class="expand" for="c-35720378">[4 more]</label></div><br/><div class="children"><div class="content">I never understood how Oauth as a user experience is supposed to be distinguishable from phishing.</div><br/><div id="35721551" class="c"><input type="checkbox" id="c-35721551" checked=""/><div class="controls bullet"><span class="by">dwaite</span><span>|</span><a href="#35720378">parent</a><span>|</span><a href="#35721264">next</a><span>|</span><label class="collapse" for="c-35721551">[-]</label><label class="expand" for="c-35721551">[1 more]</label></div><br/><div class="children"><div class="content">Many authentication systems push all phishing mitigation onto the user, e.g. &quot;check the lock&quot; (doesn&#x27;t do anything) or &quot;check the address bar&quot; (not realistic for most users, ignores the ability to register official-looking DNS names).<p>So the answer is - OAuth doesn&#x27;t solve the phishing issues around authentication any more than any other sort of non-curated hyperlink on the web.<p>WebAuthn, mutual TLS and Kerberos are the systems where that authentication is bound to a DNS domain or communications channel. Password managers also can provide this, although there are security considerations there such as competing web extensions, and it is a mechanism that the server cannot vet for risk analysis.<p>Such phishing-resistant mechanisms raise the bar for a successful attack from someone sending out a creative email to something a lot closer to coordinated&#x2F;state-sponsored attacks on internet infrastructure.</div><br/></div></div><div id="35721264" class="c"><input type="checkbox" id="c-35721264" checked=""/><div class="controls bullet"><span class="by">mdavidn</span><span>|</span><a href="#35720378">parent</a><span>|</span><a href="#35721551">prev</a><span>|</span><a href="#35718169">next</a><span>|</span><label class="collapse" for="c-35721264">[-]</label><label class="expand" for="c-35721264">[2 more]</label></div><br/><div class="children"><div class="content">Password managers mitigate this. If the form doesn&#x27;t offer to fill my saved password, that immediately raises red flags in my head. I immediately bail out or manually validate domains.</div><br/><div id="35722322" class="c"><input type="checkbox" id="c-35722322" checked=""/><div class="controls bullet"><span class="by">idlewords</span><span>|</span><a href="#35720378">root</a><span>|</span><a href="#35721264">parent</a><span>|</span><a href="#35718169">next</a><span>|</span><label class="collapse" for="c-35722322">[-]</label><label class="expand" for="c-35722322">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found that if I haven&#x27;t updated Chrome then my password manager plugin stops working, which happens frequently enough that this would no longer raise red flags for me. Every layer of security conspires to defeat every other one.</div><br/></div></div></div></div></div></div><div id="35718169" class="c"><input type="checkbox" id="c-35718169" checked=""/><div class="controls bullet"><span class="by">mikeknoop</span><span>|</span><a href="#35720378">prev</a><span>|</span><a href="#35722434">next</a><span>|</span><label class="collapse" for="c-35718169">[-]</label><label class="expand" for="c-35718169">[1 more]</label></div><br/><div class="children"><div class="content">We have a joke about this at Zapier -- don&#x27;t be an oauth butt!<p>&quot;We support standard oauth butttt...&quot;</div><br/></div></div><div id="35722434" class="c"><input type="checkbox" id="c-35722434" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#35718169">prev</a><span>|</span><a href="#35720381">next</a><span>|</span><label class="collapse" for="c-35722434">[-]</label><label class="expand" for="c-35722434">[1 more]</label></div><br/><div class="children"><div class="content">Personally, I have transitioned away from these third party IdPs. I have turned to spinning up my own authentication and authorization stack using an open source ecosystem like &quot;Ory&quot;.<p>With just a single helmfile, I can deploy the entire application stack on my local machine (authN, authZ, smtp server,app db, application). Gives me ease that I don&#x27;t have to rely on a third party vendor just for testing simple app flows. Transitioning to production is a simple swap of DSNs (database connection strings, real smtp servers, ...). Also, no more burning money when running simple tests or performing load tests with dummy users when using an external&#x2F;managed IdP.<p>Still need to experiment with how upgrading will work and migration of user data. But otherwise I am a happy user&#x2F;developer.</div><br/></div></div><div id="35720381" class="c"><input type="checkbox" id="c-35720381" checked=""/><div class="controls bullet"><span class="by">kierank</span><span>|</span><a href="#35722434">prev</a><span>|</span><a href="#35718230">next</a><span>|</span><label class="collapse" for="c-35720381">[-]</label><label class="expand" for="c-35720381">[5 more]</label></div><br/><div class="children"><div class="content">Is there any good way to do OAuth on a headless system? I want to be able to run batch jobs without a browser involved. There&#x27;s OAuth for devices but that has limited real world use.</div><br/><div id="35720614" class="c"><input type="checkbox" id="c-35720614" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#35720381">parent</a><span>|</span><a href="#35721494">next</a><span>|</span><label class="collapse" for="c-35720614">[-]</label><label class="expand" for="c-35720614">[1 more]</label></div><br/><div class="children"><div class="content">Yes, multiple.<p>You can implement client credential mode - this means storing a credential and using it to acquire a token from OAuth2&#x2F;OIDC provider, then using that token as Bearer Token in your API calls.<p>EDIT: I can add that I have implemented client credential mode in what was effectively raw PowerShell and similarly it can be done with curl from any shell script, even pretty dumb ones. Just do a single POST containing the necessary JSON structure to your OAuth2&#x2F;OIDC provider, parse returned JSON to grab bearer token value, use said token value in header<p><pre><code>  curl -H &quot;Authorization: Bearer ${token}&quot;

</code></pre>
You can also implement any kind of authentication in your provider (or configure a 3rd party one) and make it accept it - then ensure that this authentication model is supported by your headless program when it receives a redirect to login page. For example I have implemented Kerberos 5 login this way - CLI program would connect to OIDC provider (keycloak), get offered HTTP Negotiate GSSAPI auth, perform it using users kerberos identity, get token, use that token to access AWS STS to acquire AWS token. Completely transparent to end user&#x2F;service.</div><br/></div></div><div id="35721494" class="c"><input type="checkbox" id="c-35721494" checked=""/><div class="controls bullet"><span class="by">dwaite</span><span>|</span><a href="#35720381">parent</a><span>|</span><a href="#35720614">prev</a><span>|</span><a href="#35721277">next</a><span>|</span><label class="collapse" for="c-35721494">[-]</label><label class="expand" for="c-35721494">[1 more]</label></div><br/><div class="children"><div class="content">OAuth is typically meant for a user (resource owner) to delegate some authorizations on a protected resource to a client. If your headless system is trying to hit an API with authorizations granted by particular users, you&#x27;ll need some way for the users to grant that access.<p>But the client credential flow assumes the client _is_ a resource owner and already has authorizations to do its business. Thats what you would typically use for pure system-to-system use cases, and basically amounts to &quot;hit this endpoint periodically to get the current API key&quot;</div><br/></div></div><div id="35721277" class="c"><input type="checkbox" id="c-35721277" checked=""/><div class="controls bullet"><span class="by">mdavidn</span><span>|</span><a href="#35720381">parent</a><span>|</span><a href="#35721494">prev</a><span>|</span><a href="#35720712">next</a><span>|</span><label class="collapse" for="c-35721277">[-]</label><label class="expand" for="c-35721277">[1 more]</label></div><br/><div class="children"><div class="content">OAuth for devices was created for TV set top boxes and game consoles, network-connected devices with displays but limited password input. Device code flow is _widely_ used for this. To the user, this displays an activation URL or QR code.<p>You&#x27;re looking for client credentials.</div><br/></div></div><div id="35720712" class="c"><input type="checkbox" id="c-35720712" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#35720381">parent</a><span>|</span><a href="#35721277">prev</a><span>|</span><a href="#35718230">next</a><span>|</span><label class="collapse" for="c-35720712">[-]</label><label class="expand" for="c-35720712">[1 more]</label></div><br/><div class="children"><div class="content">Client credential flow. It’s one call with a secret in it, and back comes the Access Token. If you want better security, it’s one call with a JWT signed by a private key. No browser, really easy to implement.</div><br/></div></div></div></div><div id="35718230" class="c"><input type="checkbox" id="c-35718230" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35720381">prev</a><span>|</span><a href="#35722225">next</a><span>|</span><label class="collapse" for="c-35718230">[-]</label><label class="expand" for="c-35718230">[10 more]</label></div><br/><div class="children"><div class="content">Example: What is the purpose of OAuth having specifications for redirect URI allowlist <i>AND</i> PKCE?<p>None. They are entirely duplicative features.<p>But ... reason, reason, reason ... they both exist, and are going to exist, forever.<p>EDIT: I should say, PKCE is a functional superset of redirect URI allowlist.</div><br/><div id="35718900" class="c"><input type="checkbox" id="c-35718900" checked=""/><div class="controls bullet"><span class="by">dwaite</span><span>|</span><a href="#35718230">parent</a><span>|</span><a href="#35720304">next</a><span>|</span><label class="collapse" for="c-35718900">[-]</label><label class="expand" for="c-35718900">[3 more]</label></div><br/><div class="children"><div class="content">If one uses a redirect_uri with PKCE parameters to send a response a non-oauth endpoint, the AS is still acting as a redirector.<p>It&#x27;s typically not a list. You typically will have one redirect uri (at least, one per AS), because thats the communication endpoint defined by your client. There are other parameters like state to remember what you wanted to do after you had an access token.<p>PKCE exists to bind the front-channel authorization request and back-channel token request together as being by the same client. There is otherwise no evidence that the two parts are by the same software instance, which causes other security issues.</div><br/><div id="35719147" class="c"><input type="checkbox" id="c-35719147" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35718230">root</a><span>|</span><a href="#35718900">parent</a><span>|</span><a href="#35720304">next</a><span>|</span><label class="collapse" for="c-35719147">[-]</label><label class="expand" for="c-35719147">[2 more]</label></div><br/><div class="children"><div class="content">The redirect_uri parameter is not a list.<p>I am referring to the redirect allowlist registered out-of-band by the client: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc6749#section-2" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc6749#section-2</a></div><br/><div id="35719733" class="c"><input type="checkbox" id="c-35719733" checked=""/><div class="controls bullet"><span class="by">dwaite</span><span>|</span><a href="#35718230">root</a><span>|</span><a href="#35719147">parent</a><span>|</span><a href="#35720304">next</a><span>|</span><label class="collapse" for="c-35719733">[-]</label><label class="expand" for="c-35719733">[1 more]</label></div><br/><div class="children"><div class="content">right. I was speaking to registration of redirect URIs - most clients should only register one, because they have only one endpoint (for that AS at least) for handling authorization responses. You should not use redirect URI for deep links, for example - you should capture pending actions to take after authorization separately.<p>You could hypothetically register redirect URI for the DNS names of your individual client cluster nodes, but there&#x27;s no guarantee an AS will let you register as many URI as you have cluster nodes - and you will have a failure case to handle if the cluster node goes down mid-authorization, and coordination if you need to grow said cluster.</div><br/></div></div></div></div></div></div><div id="35720304" class="c"><input type="checkbox" id="c-35720304" checked=""/><div class="controls bullet"><span class="by">zmxz</span><span>|</span><a href="#35718230">parent</a><span>|</span><a href="#35718900">prev</a><span>|</span><a href="#35719430">next</a><span>|</span><label class="collapse" for="c-35720304">[-]</label><label class="expand" for="c-35720304">[1 more]</label></div><br/><div class="children"><div class="content">Correct me if I&#x27;m wrong, but what you&#x27;re implying here is that PKCE and URI allowlist are the same feature because if you specify URI allowlist while initializing the flow - it somehow helps public clients to prove they&#x27;re the apps that initialized the flow and are the ones who are finalizing it?<p>Could you please expand on that thought, I&#x27;m genuinely curious if you actually might be right or whether this assumption of yours is how we get security holes.</div><br/></div></div><div id="35719430" class="c"><input type="checkbox" id="c-35719430" checked=""/><div class="controls bullet"><span class="by">cellularmitosis</span><span>|</span><a href="#35718230">parent</a><span>|</span><a href="#35720304">prev</a><span>|</span><a href="#35718466">next</a><span>|</span><label class="collapse" for="c-35719430">[-]</label><label class="expand" for="c-35719430">[1 more]</label></div><br/><div class="children"><div class="content">On iOS, two applications can register as handling the same callback URI scheme.  Which one gets the callback is non-deterministic.  Thus, it is possible for some other app to get the token.  I don’t see how an allowlist would mitigate this.<p>With PKCE, the other app can still intercept the token, but the token is incomplete and useless.</div><br/></div></div><div id="35718466" class="c"><input type="checkbox" id="c-35718466" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#35718230">parent</a><span>|</span><a href="#35719430">prev</a><span>|</span><a href="#35722225">next</a><span>|</span><label class="collapse" for="c-35718466">[-]</label><label class="expand" for="c-35718466">[4 more]</label></div><br/><div class="children"><div class="content">My understanding is that PKCE allows you to more safely operate a client that does not have a client secret.</div><br/><div id="35718723" class="c"><input type="checkbox" id="c-35718723" checked=""/><div class="controls bullet"><span class="by">maxwellg</span><span>|</span><a href="#35718230">root</a><span>|</span><a href="#35718466">parent</a><span>|</span><a href="#35722225">next</a><span>|</span><label class="collapse" for="c-35718723">[-]</label><label class="expand" for="c-35718723">[3 more]</label></div><br/><div class="children"><div class="content">The React Native docs have a good writeup on how PKCE reduces vulnerabilities with deep linking &amp; session hijacking - <a href="https:&#x2F;&#x2F;reactnative.dev&#x2F;docs&#x2F;security#authentication-and-deep-linking" rel="nofollow">https:&#x2F;&#x2F;reactnative.dev&#x2F;docs&#x2F;security#authentication-and-dee...</a><p>PKCE also gives you nice assurances that the device finishing the flow is the same as the device that started it. Without PKCE, the classic client credentials flow risks login CSRF - <a href="https:&#x2F;&#x2F;support.detectify.com&#x2F;support&#x2F;solutions&#x2F;articles&#x2F;48001048951-login-csrf" rel="nofollow">https:&#x2F;&#x2F;support.detectify.com&#x2F;support&#x2F;solutions&#x2F;articles&#x2F;480...</a> - which may or may not be an attack vector you care about.</div><br/><div id="35718928" class="c"><input type="checkbox" id="c-35718928" checked=""/><div class="controls bullet"><span class="by">dwaite</span><span>|</span><a href="#35718230">root</a><span>|</span><a href="#35718723">parent</a><span>|</span><a href="#35718895">next</a><span>|</span><label class="collapse" for="c-35718928">[-]</label><label class="expand" for="c-35718928">[1 more]</label></div><br/><div class="children"><div class="content">&gt; well yeah, but there was already state, but nobody used it for that<p>state was meant to be application state. The problem is that there _wasn&#x27;t_ anything like PKCE in vanilla OAuth 2, so the client was told to overload state with protocol state with particular processing rules, rather than just its own application state.<p>With PKCE, the AS can see whether it is the same client instance and reject the request. The state workarounds meant the client had to implement the rejection, which many did not do.</div><br/></div></div></div></div></div></div></div></div><div id="35722225" class="c"><input type="checkbox" id="c-35722225" checked=""/><div class="controls bullet"><span class="by">domrdy</span><span>|</span><a href="#35718230">prev</a><span>|</span><a href="#35720553">next</a><span>|</span><label class="collapse" for="c-35722225">[-]</label><label class="expand" for="c-35722225">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using WorkOS for my SaaS products and I&#x27;m pretty satisfied with it. It&#x27;s straightforward to set up Google&#x2F;Microsoft&#x2F;MagicLink (free), including staging and production environments. The best part, though, is that it lets my enterprise customers configure their own SAML&#x2F;OpenID Connect IDPs.<p>I get charged per connection, so I just pass that cost onto my customers. As a solo developer, I&#x27;d have a hard time supporting so many IDPs with a unified API without this.<p>They did recently hike up the cost per connection, but they&#x27;re giving a one-year extension at the old rates, which seems fair.</div><br/></div></div><div id="35720553" class="c"><input type="checkbox" id="c-35720553" checked=""/><div class="controls bullet"><span class="by">dpcx</span><span>|</span><a href="#35722225">prev</a><span>|</span><a href="#35721319">next</a><span>|</span><label class="collapse" for="c-35720553">[-]</label><label class="expand" for="c-35720553">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know why it&#x27;s still hard, but I can tell you, from the perspective of trying to prototype something, I would love to not have to use it just to find out if this functionality I want to build is worthwhile. I don&#x27;t want to have to create a client, get some keys, worry about refresh tokens, etc. I want to hit an endpoint with an easily accessible token and get some data.<p>Make it so that the token is only valid for 30 days or something and then it requires moving to OAuth. But for prototyping stuff with curl and bash scripts, it&#x27;s a giant pain.</div><br/><div id="35722107" class="c"><input type="checkbox" id="c-35722107" checked=""/><div class="controls bullet"><span class="by">chasd00</span><span>|</span><a href="#35720553">parent</a><span>|</span><a href="#35721319">next</a><span>|</span><label class="collapse" for="c-35722107">[-]</label><label class="expand" for="c-35722107">[1 more]</label></div><br/><div class="children"><div class="content">If you’re prototyping use postman to get the tokens for you then copy&#x2F;paste them into your prototype.</div><br/></div></div></div></div><div id="35721319" class="c"><input type="checkbox" id="c-35721319" checked=""/><div class="controls bullet"><span class="by">defaultcompany</span><span>|</span><a href="#35720553">prev</a><span>|</span><a href="#35722942">next</a><span>|</span><label class="collapse" for="c-35721319">[-]</label><label class="expand" for="c-35721319">[1 more]</label></div><br/><div class="children"><div class="content">See &quot;OAuth 2.0 and the Road to Hell&quot; - Eran Hammer&#x27;s resignation letter from his role as Oauth 2.0 spec lead author and editor:<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;nckroy&#x2F;dd2d4dfc86f7d13045ad715377b6a48f" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;nckroy&#x2F;dd2d4dfc86f7d13045ad715377b6a...</a></div><br/></div></div><div id="35722942" class="c"><input type="checkbox" id="c-35722942" checked=""/><div class="controls bullet"><span class="by">indus</span><span>|</span><a href="#35721319">prev</a><span>|</span><a href="#35720758">next</a><span>|</span><label class="collapse" for="c-35722942">[-]</label><label class="expand" for="c-35722942">[1 more]</label></div><br/><div class="children"><div class="content">Not one mention of flickr in your post...Would have loved it.</div><br/></div></div><div id="35720758" class="c"><input type="checkbox" id="c-35720758" checked=""/><div class="controls bullet"><span class="by">smackeyacky</span><span>|</span><a href="#35722942">prev</a><span>|</span><a href="#35721095">next</a><span>|</span><label class="collapse" for="c-35720758">[-]</label><label class="expand" for="c-35720758">[1 more]</label></div><br/><div class="children"><div class="content">My various brushes with OAuth and OIDC and FAPI have been horrible.  The spec is written poorly, everybody seems to have their own idea of how it should work, nobody seems to implement the same thing.<p>Add to that the various version of OAuth&#x2F;OIDC&#x2F;FAPI and no clear migration path laid out to upgrade and it&#x27;s a basic nightmare.<p>The Australia CDR (Consumer Data Right) notionally supports FAPI but they have their own interpretation of what is right so you simply can&#x27;t use an off-the-shelf library to do anything.<p>The only way to preserve any kind of inter-operability is to wait for some other sucker to release their interpretation of this standard and everybody else in the eco-system has to test against that and eventually call it good.<p>Add to that - I just can&#x27;t see why it has to be that complicated.  Sometimes you can request signed+encrypted tokens, sometimes not, you can query the provider to ask them what they support but there are holes and gray area defaults for algorithms and encryption schemes and the whole thing needs to be set fire to and abandoned.</div><br/></div></div><div id="35721095" class="c"><input type="checkbox" id="c-35721095" checked=""/><div class="controls bullet"><span class="by">littlecranky67</span><span>|</span><a href="#35720758">prev</a><span>|</span><a href="#35719939">next</a><span>|</span><label class="collapse" for="c-35721095">[-]</label><label class="expand" for="c-35721095">[2 more]</label></div><br/><div class="children"><div class="content">My rant about OAuth: It is overly complex because it has too many features to satisfy each and every enterprise case.<p>For me who runs a simple website (no 3rd party login), I learned that OAuth2 is just not a good choice. JWE&#x2F;JWT and samesite=strict plus HttpOnly cookies are reasonably simple, yet secure enough.</div><br/><div id="35722120" class="c"><input type="checkbox" id="c-35722120" checked=""/><div class="controls bullet"><span class="by">chasd00</span><span>|</span><a href="#35721095">parent</a><span>|</span><a href="#35719939">next</a><span>|</span><label class="collapse" for="c-35722120">[-]</label><label class="expand" for="c-35722120">[1 more]</label></div><br/><div class="children"><div class="content">A simple website with no third party login nor needing access to a third party API on behalf of the user should never use Oauth to begin with. a standard session cookie works just fine in those situations (as you discovered).</div><br/></div></div></div></div><div id="35719939" class="c"><input type="checkbox" id="c-35719939" checked=""/><div class="controls bullet"><span class="by">codingclaws</span><span>|</span><a href="#35721095">prev</a><span>|</span><a href="#35722589">next</a><span>|</span><label class="collapse" for="c-35719939">[-]</label><label class="expand" for="c-35719939">[3 more]</label></div><br/><div class="children"><div class="content">I am in the middle of implementing an OAuth 2 server for my internet forum [0]. The last 10 or so commits are OAuth related. I read docs for about a month and now I feel like I can code it. One thing that confuses me is how it can work without a client secret (it&#x27;s recommended to not use a client secret for SPAs and native smart phone apps).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;ferg1e&#x2F;comment-castles">https:&#x2F;&#x2F;github.com&#x2F;ferg1e&#x2F;comment-castles</a></div><br/><div id="35720194" class="c"><input type="checkbox" id="c-35720194" checked=""/><div class="controls bullet"><span class="by">whatusername</span><span>|</span><a href="#35719939">parent</a><span>|</span><a href="#35720268">next</a><span>|</span><label class="collapse" for="c-35720194">[-]</label><label class="expand" for="c-35720194">[1 more]</label></div><br/><div class="children"><div class="content">So make sure you are doing PKCE for public clients.<p>With that, and the redirect URL (and therefore trusting DNS), and the other browser security model stuff….  You’re in fairly good shape.<p>There’s newer standards coming like DPoP - but it’s probably not worth it yet.</div><br/></div></div><div id="35720268" class="c"><input type="checkbox" id="c-35720268" checked=""/><div class="controls bullet"><span class="by">ollien</span><span>|</span><a href="#35719939">parent</a><span>|</span><a href="#35720194">prev</a><span>|</span><a href="#35722589">next</a><span>|</span><label class="collapse" for="c-35720268">[-]</label><label class="expand" for="c-35720268">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;archive.is&#x2F;26yI3" rel="nofollow">https:&#x2F;&#x2F;archive.is&#x2F;26yI3</a><p>This explainer is pretty good. Sorry for the archive link, the original seems to be down</div><br/></div></div></div></div><div id="35722589" class="c"><input type="checkbox" id="c-35722589" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#35719939">prev</a><span>|</span><a href="#35721933">next</a><span>|</span><label class="collapse" for="c-35722589">[-]</label><label class="expand" for="c-35722589">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know, I look at oauth and it seems like its insecurity by design. Huge complex spec, with lots of corner cases, and requires really complex functionality like HTTP and JS. All of which can hide obscure bugs. Its like no one has learned from history.<p>Frankly, I&#x27;m not sure what keeps people from simply putting fake Oauth screens on random phishing emails. Figure out what a companies default auth screen looks like, pop up a similar looking web page.. bam plaintext passwords that can be used to authenticate with real services.</div><br/></div></div><div id="35721933" class="c"><input type="checkbox" id="c-35721933" checked=""/><div class="controls bullet"><span class="by">0xbkt</span><span>|</span><a href="#35722589">prev</a><span>|</span><a href="#35718138">next</a><span>|</span><label class="collapse" for="c-35721933">[-]</label><label class="expand" for="c-35721933">[1 more]</label></div><br/><div class="children"><div class="content">Tangentially related: what do you use today to make authn&#x2F;z work for your web sites&#x2F;applications where you only do first party login (i.e. you don&#x27;t do social login etc.)? Create a `users` table in your database and implement the logic on your own? Or proxy to stuff like Ory Kratos and act as a translation layer through a network call?</div><br/></div></div><div id="35718138" class="c"><input type="checkbox" id="c-35718138" checked=""/><div class="controls bullet"><span class="by">Analemma_</span><span>|</span><a href="#35721933">prev</a><span>|</span><a href="#35718781">next</a><span>|</span><label class="collapse" for="c-35718138">[-]</label><label class="expand" for="c-35718138">[4 more]</label></div><br/><div class="children"><div class="content">Because &quot;OAuth&quot; is not a thing, it&#x27;s a label you can glue on any wild-and-wacky authentication mechanism someone hacks together. It is structurally impossible for OAuth to ever become &quot;easy&quot;.</div><br/><div id="35718747" class="c"><input type="checkbox" id="c-35718747" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#35718138">parent</a><span>|</span><a href="#35718542">next</a><span>|</span><label class="collapse" for="c-35718747">[-]</label><label class="expand" for="c-35718747">[2 more]</label></div><br/><div class="children"><div class="content">Yep. OAuth is more of a concept than a standard. There are common patterns, and you might get lucky and find 2 integrations that handle it the same way... but I wouldn&#x27;t bet on it. I worked on a system that OAuth&#x27;d with about 5 different 3rd party systems and each one was a little bit different.</div><br/><div id="35719215" class="c"><input type="checkbox" id="c-35719215" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#35718138">root</a><span>|</span><a href="#35718747">parent</a><span>|</span><a href="#35718542">next</a><span>|</span><label class="collapse" for="c-35719215">[-]</label><label class="expand" for="c-35719215">[1 more]</label></div><br/><div class="children"><div class="content">I agree and disagree. The OAuth 2 spec is pretty explicit. People do not follow it.<p>The industry has played fast and loose with the spec because too many people implementing OAuth support in their app do not understand OAuth and&#x2F;or insist on bleeding application or architecture-specific behavior into their authentication flow.<p>The end result is what you describe: a proliferation of approaches that roughly follow the spec. But this should not be mistaken for the spec being loose IMO. Rather that the state of auth is abysmally non-standard and homegrown.<p>I owned the authentication stack for a large enterprise platform company, and worked directly with the biggest players on ensuring compatibility between our platform and their auth flows, and the typical deviations from spec are almost always unnecessary and duplicate something that was already possible.<p>To be fair, Auth Code flow gets pretty funky with browser redirects + backend calls and can be hard to grok at first.<p>The other major issue is that once some custom auth thing exists in production, it&#x27;s never going away if there are enterprise customers relying on the behavior. I suspect that a lot of customized implementations were never meant to be long term solutions.</div><br/></div></div></div></div><div id="35718542" class="c"><input type="checkbox" id="c-35718542" checked=""/><div class="controls bullet"><span class="by">noughtme</span><span>|</span><a href="#35718138">parent</a><span>|</span><a href="#35718747">prev</a><span>|</span><a href="#35718781">next</a><span>|</span><label class="collapse" for="c-35718542">[-]</label><label class="expand" for="c-35718542">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I’ve noticed that a lot of companies implement “OAuth” differently. I’ve found the only way to reliably implement it is to read each company’s docs and also test their API. Once you implement their flow and signing (or not signing) method, it’s really not that complicated.</div><br/></div></div></div></div><div id="35718781" class="c"><input type="checkbox" id="c-35718781" checked=""/><div class="controls bullet"><span class="by">kayodelycaon</span><span>|</span><a href="#35718138">prev</a><span>|</span><a href="#35719448">next</a><span>|</span><label class="collapse" for="c-35718781">[-]</label><label class="expand" for="c-35718781">[1 more]</label></div><br/><div class="children"><div class="content">OAuth is such a pain in the ass for small projects. I miss api keys.</div><br/></div></div><div id="35719448" class="c"><input type="checkbox" id="c-35719448" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#35718781">prev</a><span>|</span><a href="#35718636">next</a><span>|</span><label class="collapse" for="c-35719448">[-]</label><label class="expand" for="c-35719448">[1 more]</label></div><br/><div class="children"><div class="content">My favourite are the appendices that amend the protocol to fix security issues that almost no API seems to implement properly. These can get quite long and are frequently amended with new drafts every year or two.<p>For example, most APIs don&#x27;t implement PKCE in order to prevent injection attacks against the authorization code grant type.<p>Just keeping up with security practices is a full time job for teams.</div><br/></div></div><div id="35718636" class="c"><input type="checkbox" id="c-35718636" checked=""/><div class="controls bullet"><span class="by">cco</span><span>|</span><a href="#35719448">prev</a><span>|</span><a href="#35721761">next</a><span>|</span><label class="collapse" for="c-35718636">[-]</label><label class="expand" for="c-35718636">[2 more]</label></div><br/><div class="children"><div class="content">Love this post by Nango, it&#x27;s exactly right!<p>Agreed that the biggest reason is that OAuth is a framework and not a protocol. That means different companies can do it ever so slightly differently, and as a dev, you need to understand the differences and normalize it for your use case.<p>At Stytch we&#x27;ve run into the same issues, normalization problems, security implications, flaky IdPs; a hard problem, but one you _have_ to get right!</div><br/><div id="35719791" class="c"><input type="checkbox" id="c-35719791" checked=""/><div class="controls bullet"><span class="by">dwaite</span><span>|</span><a href="#35718636">parent</a><span>|</span><a href="#35721761">next</a><span>|</span><label class="collapse" for="c-35719791">[-]</label><label class="expand" for="c-35719791">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OAuth is a framework and not a protocol<p>Indeed, a lot of people do not realize the difference. Frameworks do not provide interoperability, and at most we can push to try to get people to solve problems the same way.<p>Profiles (such as OpenID Connect or FAPI) constrain frameworks allowing implementations to be interoperable.<p>OAuth is somewhat like the multitude of different dialects in some places like the United Kingdom.<p>The original article was talking about the problems due to trying to support all those different OAuth dialects. I&#x27;d argue most developers will never know that degree of pain, because they are only trying to solve problems within their particular application space.</div><br/></div></div></div></div><div id="35721761" class="c"><input type="checkbox" id="c-35721761" checked=""/><div class="controls bullet"><span class="by">bebop</span><span>|</span><a href="#35718636">prev</a><span>|</span><a href="#35721472">next</a><span>|</span><label class="collapse" for="c-35721761">[-]</label><label class="expand" for="c-35721761">[1 more]</label></div><br/><div class="children"><div class="content">If you want to read the rfc’s I had chatgpt explain the parts of the authorization code flow and link where in the rfc’s the parts are defined.<p><a href="https:&#x2F;&#x2F;bryce.groff.family&#x2F;oauth-2-1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bryce.groff.family&#x2F;oauth-2-1&#x2F;</a></div><br/></div></div><div id="35721472" class="c"><input type="checkbox" id="c-35721472" checked=""/><div class="controls bullet"><span class="by">lukev</span><span>|</span><a href="#35721761">prev</a><span>|</span><a href="#35720002">next</a><span>|</span><label class="collapse" for="c-35721472">[-]</label><label class="expand" for="c-35721472">[2 more]</label></div><br/><div class="children"><div class="content">Given that this seems to describe a real problem, why hasn&#x27;t anyone launched a proxy service that normalizes across the varying implementations?<p>Why should tens of thousands of developers have to discover the particular quirks of an implementation instead of doing it once and re-using the results?</div><br/><div id="35722065" class="c"><input type="checkbox" id="c-35722065" checked=""/><div class="controls bullet"><span class="by">fordsmith</span><span>|</span><a href="#35721472">parent</a><span>|</span><a href="#35720002">next</a><span>|</span><label class="collapse" for="c-35722065">[-]</label><label class="expand" for="c-35722065">[1 more]</label></div><br/><div class="children"><div class="content">They have. <a href="https:&#x2F;&#x2F;clerk.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;clerk.com&#x2F;</a> is an example that I have been looking to use lately</div><br/></div></div></div></div><div id="35720002" class="c"><input type="checkbox" id="c-35720002" checked=""/><div class="controls bullet"><span class="by">rglover</span><span>|</span><a href="#35721472">prev</a><span>|</span><label class="collapse" for="c-35720002">[-]</label><label class="expand" for="c-35720002">[1 more]</label></div><br/><div class="children"><div class="content">From my experience, the blame lands on documentation and consistency at the implementation level. What should be a fairly simple process (redirect -&gt; receive an HTTP request w&#x2F; code to exchange -&gt; perform an HTTP request to exchange code for token) is always made into some esoteric spaghetti.<p>I recently wasted hours implementing OAuth login for Bitbucket because their docs have bad links, bad explanation of params to pass, and bad explanation of endpoints to hit. I implemented Github and Gitlab just before in ~30 minutes total, so it really is a YMMV by provider problem.</div><br/></div></div></div></div></div></div></div></body></html>