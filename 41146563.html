<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722762051907" as="style"/><link rel="stylesheet" href="styles.css?v=1722762051907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://media.ccc.de/v/cosin2024-56234-fpga-selber-bauen-mit-74">An FPGA built with 7400 series logic [video]</a> <span class="domain">(<a href="https://media.ccc.de">media.ccc.de</a>)</span></div><div class="subtext"><span>chrsw</span> | <span>15 comments</span></div><br/><div><div id="41147659" class="c"><input type="checkbox" id="c-41147659" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#41147190">next</a><span>|</span><label class="collapse" for="c-41147659">[-]</label><label class="expand" for="c-41147659">[5 more]</label></div><br/><div class="children"><div class="content">Back in the late 70s and 80s, many computers and other digital systems were actually designed using basic blocks similar to this.  Since chip layout is by far the biggest expense (especially back then) it made sense to design just one customizable chip, and then produce it with different metal layers to configure it into various arrangements, so it is relatively easily &quot;programmed&quot; just before manufacturing.  DEC&#x27;s ill-fated VAX 9000 was done in this way, probably the last great pre-CMOS processor design, with hundreds of ECL gate array chips all based on a couple die patterns.  Unfortunately the benefits of sheer density from CMOS were undeniable.  When they crammed the VAX into a $1000 CMOS microprocessor, it outperformed the $1 million VAX 9000 four years later.  These days it&#x27;s relatively uncommon as a technique except for rapid prototyping.  With standard cell ASIC designs, a gate array cell able to perform any function is still an option, but modern design tools make it much easier to use more optimized logic.</div><br/><div id="41151290" class="c"><input type="checkbox" id="c-41151290" checked=""/><div class="controls bullet"><span class="by">mafuyu</span><span>|</span><a href="#41147659">parent</a><span>|</span><a href="#41151002">next</a><span>|</span><label class="collapse" for="c-41151290">[-]</label><label class="expand" for="c-41151290">[3 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m remembering correctly, Jeri Ellsworth said in an interview that the CastAR glasses were fabbed on a gate array. I thought it was super cool how they were able to prototype a device on FPGA and get chips fabbed as a consumer electronics startup. It probably makes less and less sense nowadays, with how cheap and capable MCUs have gotten.</div><br/><div id="41151903" class="c"><input type="checkbox" id="c-41151903" checked=""/><div class="controls bullet"><span class="by">EgoIncarnate</span><span>|</span><a href="#41147659">root</a><span>|</span><a href="#41151290">parent</a><span>|</span><a href="#41151002">next</a><span>|</span><label class="collapse" for="c-41151903">[-]</label><label class="expand" for="c-41151903">[2 more]</label></div><br/><div class="children"><div class="content">I think you might be confusing CastAR with the C64 toy stuff she did early on. That was initially FPGA and then converted to custom gate array. If I recall there was an issue in that the FPGA initialzed it&#x27;s memory and the custom silicon didn&#x27;t which lead to some heart pounding moments when it failed initial bring up.<p>I don&#x27;t think CastAR&#x2F;Tilt5 isn&#x27;t doing enough units to justify custom silicon. 
I believe they settled on the Intel Movidius VPU for the bulk of the glasses &quot;brains&quot;.</div><br/><div id="41152026" class="c"><input type="checkbox" id="c-41152026" checked=""/><div class="controls bullet"><span class="by">mafuyu</span><span>|</span><a href="#41147659">root</a><span>|</span><a href="#41151903">parent</a><span>|</span><a href="#41151002">next</a><span>|</span><label class="collapse" for="c-41152026">[-]</label><label class="expand" for="c-41152026">[1 more]</label></div><br/><div class="children"><div class="content">Ahh, yeah I think you’re right. The story left a big  impression on me, but I guess not well enough for me to remember the details. :)</div><br/></div></div></div></div></div></div><div id="41151002" class="c"><input type="checkbox" id="c-41151002" checked=""/><div class="controls bullet"><span class="by">basementcat</span><span>|</span><a href="#41147659">parent</a><span>|</span><a href="#41151290">prev</a><span>|</span><a href="#41147190">next</a><span>|</span><label class="collapse" for="c-41151002">[-]</label><label class="expand" for="c-41151002">[1 more]</label></div><br/><div class="children"><div class="content">I think a &quot;field programmable&quot; device is distinct from a &quot;mask programmable&quot; device. The latter is potentially much simpler (no RAM, potentially a &quot;sea of muxes&quot; (or nands) while the former needs RAM, shift register logic, additional I&#x2F;O and so on.</div><br/></div></div></div></div><div id="41147190" class="c"><input type="checkbox" id="c-41147190" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#41147659">prev</a><span>|</span><a href="#41146853">next</a><span>|</span><label class="collapse" for="c-41147190">[-]</label><label class="expand" for="c-41147190">[5 more]</label></div><br/><div class="children"><div class="content">Full writeup (first in series, each post links to the next): <a href="https:&#x2F;&#x2F;mnemocron.github.io&#x2F;2023-12-08-DIY-FPGA-diary-0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mnemocron.github.io&#x2F;2023-12-08-DIY-FPGA-diary-0&#x2F;</a></div><br/><div id="41147688" class="c"><input type="checkbox" id="c-41147688" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#41147190">parent</a><span>|</span><a href="#41146853">next</a><span>|</span><label class="collapse" for="c-41147688">[-]</label><label class="expand" for="c-41147688">[4 more]</label></div><br/><div class="children"><div class="content">If you took <i>the right half of his CLB</i> from his second entry[1], and connected each input bit to one of it&#x27;s neighbors, that&#x27;s enough to have a computing fabric.<p>Latching them in 2 phase adds delay, but removes the need for worry about timing, as it becomes known.<p>If you put 4 of them in parallel, so each neighbor gets it&#x27;s own output, it&#x27;s a BitGrid[2,3], which I&#x27;ve been tinkering with since the 1980s.<p>He referenced an earlier effort 2012 in his video[4,5] that goes down the same detour towards computing fabrics. The HDL for that fabric, <i>might</i> prove useful for programming a bitgrid.[6]<p>I see the appeal of routing fabric and saving silicon, and especially wanting to keep the latency to bare minimum, but the trade-offs aren&#x27;t worth it in my opinion. Routing becomes a nightmare, as does getting the timing of things right, and watching out for race conditions.<p>If you give up and embrace latency, and the wasting of gates to route signal, you end up with a homogenous, isolinear core. (The same in any linear direction) You can rather easily shift a part in any direction, rotate it, and flip it. You can route around defective cells (assuming the shift register chain doesn&#x27;t break, of course).  Latency goes to hell, but because every single operation is pipelined, your throughput can go through the roof, none of the data lines ever has to make it all the way across the chip, except the clock signals. The shift registers, and only have to load things before the computing starts, so they don&#x27;t have to be fast at all.<p>[1] <a href="https:&#x2F;&#x2F;mnemocron.github.io&#x2F;2023-12-08-DIY-FPGA-diary-1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mnemocron.github.io&#x2F;2023-12-08-DIY-FPGA-diary-1&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;esolangs.org&#x2F;wiki&#x2F;Bitgrid" rel="nofollow">https:&#x2F;&#x2F;esolangs.org&#x2F;wiki&#x2F;Bitgrid</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;mikewarot&#x2F;Bitgrid">https:&#x2F;&#x2F;github.com&#x2F;mikewarot&#x2F;Bitgrid</a><p>[4] <a href="https:&#x2F;&#x2F;hackaday.com&#x2F;2012&#x2F;11&#x2F;01&#x2F;discrete-fpga-will-probably-win-the-7400-logic-competition&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hackaday.com&#x2F;2012&#x2F;11&#x2F;01&#x2F;discrete-fpga-will-probably-...</a><p>[5] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150621104100&#x2F;http:&#x2F;&#x2F;blog.notdot.net&#x2F;2012&#x2F;10&#x2F;Build-your-own-FPGA" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150621104100&#x2F;http:&#x2F;&#x2F;blog.notdo...</a><p>[6] <a href="https:&#x2F;&#x2F;github.com&#x2F;Arachnid&#x2F;dfpga&#x2F;tree&#x2F;master">https:&#x2F;&#x2F;github.com&#x2F;Arachnid&#x2F;dfpga&#x2F;tree&#x2F;master</a></div><br/><div id="41147820" class="c"><input type="checkbox" id="c-41147820" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#41147190">root</a><span>|</span><a href="#41147688">parent</a><span>|</span><a href="#41146853">next</a><span>|</span><label class="collapse" for="c-41147820">[-]</label><label class="expand" for="c-41147820">[3 more]</label></div><br/><div class="children"><div class="content">seems like you could get pretty far bootstrapping a higher level language. how far have people gotten?</div><br/><div id="41149267" class="c"><input type="checkbox" id="c-41149267" checked=""/><div class="controls bullet"><span class="by">bobsh</span><span>|</span><a href="#41147190">root</a><span>|</span><a href="#41147820">parent</a><span>|</span><a href="#41146853">next</a><span>|</span><label class="collapse" for="c-41149267">[-]</label><label class="expand" for="c-41149267">[2 more]</label></div><br/><div class="children"><div class="content">Not sure if this is quite the same idea, but <a href="https:&#x2F;&#x2F;www.greenarraychips.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.greenarraychips.com&#x2F;</a> ?</div><br/><div id="41149534" class="c"><input type="checkbox" id="c-41149534" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#41147190">root</a><span>|</span><a href="#41149267">parent</a><span>|</span><a href="#41146853">next</a><span>|</span><label class="collapse" for="c-41149534">[-]</label><label class="expand" for="c-41149534">[1 more]</label></div><br/><div class="children"><div class="content">No, but you could certainly use a GreenArray chip to emulate a BitGrid faster than a normal embedded processor could.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41146853" class="c"><input type="checkbox" id="c-41146853" checked=""/><div class="controls bullet"><span class="by">djfergus</span><span>|</span><a href="#41147190">prev</a><span>|</span><a href="#41150079">next</a><span>|</span><label class="collapse" for="c-41146853">[-]</label><label class="expand" for="c-41146853">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;mnemocron&#x2F;my-discrete-fpga">https:&#x2F;&#x2F;github.com&#x2F;mnemocron&#x2F;my-discrete-fpga</a></div><br/><div id="41147647" class="c"><input type="checkbox" id="c-41147647" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41146853">parent</a><span>|</span><a href="#41150079">next</a><span>|</span><label class="collapse" for="c-41147647">[-]</label><label class="expand" for="c-41147647">[1 more]</label></div><br/><div class="children"><div class="content">Very nice educational project, even if the main reason to use an FPGA is to no longer have to deal with the limitations of the 7400 series logic.</div><br/></div></div></div></div><div id="41150079" class="c"><input type="checkbox" id="c-41150079" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#41146853">prev</a><span>|</span><label class="collapse" for="c-41150079">[-]</label><label class="expand" for="c-41150079">[2 more]</label></div><br/><div class="children"><div class="content">Completely tangential, but I recently realized how annoying 7400 series is.<p>First annoyance is that manufacturers generally put the logic tech family in the middle, so you got 74HCxxx or 74LVCxxx. This makes searching information very annoying because you can&#x27;t just do a simple prefix&#x2F;suffix match. And of course those logic family names have no rhyme or reason, nor are they consistent across vendors.<p>Some parts are also available as 5400 series logic, which makes things even more confusing.<p>Some manufacturers like to throw some letters like SN in front of the 74... part number, making even more difficult to search, or visually scan them. Others don&#x27;t put any letters in the front<p>At some point some people thought to integrate all of 4000 series logic into 7400 series, so you got some parts that are seemingly logically equivalent but have different part numbers because they come originally from 4000 series instead of 7400 series.<p>The logic family names can also contain digits, so figuring out where the family name ends is not that easy.<p>Like almost all parts, manufacturers love throwing some extra characters in the end to indicate stuff like packaging.<p>The part specs can vary quite a lot between manufacturers, even on nominally same logic family like the popular &quot;74HC&quot; series<p>basically we have gone from 7404 to something like SN74AUP1T04DCKR<p>all this adds up to finding parts being very annoying when building stuff</div><br/><div id="41151714" class="c"><input type="checkbox" id="c-41151714" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#41150079">parent</a><span>|</span><label class="collapse" for="c-41151714">[-]</label><label class="expand" for="c-41151714">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the other way around.<p>The series started by 1 manufacturer with the prefix SN54&#x2F;SN64&#x2F;SN74 for military&#x2F;industrial&#x2F;commercial grade ships.   Other manufacturers made compatible clones with other starting characters than SN, and 74 proved much more popular than 54 and 64.  So the whole ecosystem became known as the 74 chips.<p>Technological advances made the 74 series obsolete qua speed and power usage, so center characters like HC&#x2F;HCT made improved variants with functional or full backward compatibility.<p>I&#x27;m not sure but assume the 4000 series to be an equivalent but incompatible family that &#x27;lost&#x27;, much like vhs vs betamax.</div><br/></div></div></div></div></div></div></div></div></div></body></html>