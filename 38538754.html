<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701939658803" as="style"/><link rel="stylesheet" href="styles.css?v=1701939658803"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lemire.me/blog/2023/10/19/for-processing-strings-streams-in-c-can-be-slow/">For processing strings, streams in C++ can be slow</a>Â <span class="domain">(<a href="https://lemire.me">lemire.me</a>)</span></div><div class="subtext"><span>greghn</span> | <span>50 comments</span></div><br/><div><div id="38552168" class="c"><input type="checkbox" id="c-38552168" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#38552608">next</a><span>|</span><label class="collapse" for="c-38552168">[-]</label><label class="expand" for="c-38552168">[22 more]</label></div><br/><div class="children"><div class="content">&gt; When performing string concatenation operations, it is more advantageous in terms of performance to use std::ostringstream rather than std::string. This approach is also used elsewhere, such as debug_utils and node_errors.<p>(From the Node.js GitHub issue.) Sounds like this guy is mixing up his Java knowledge with C++ knowledge.<p>C++ streams are frankly insane: Loads of implicit state, needing to set about a half dozen flags to do any nontrivial formatting, running the risk of accidentally &quot;poisoning&quot; all downstream operations if you forget to reset any of that state, the useless callbacks API [1], obfuscated function names (xsgetn, epptr, egptr), a ridiculously convoluted inheritance hierarchy that includes virtual&#x2F;diamond inheritance [2], and use of virtual functions for simple buffer manipulation. These were all bad decisions even at the time.<p>[1] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;io&#x2F;ios_base&#x2F;register_callback" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;io&#x2F;ios_base&#x2F;register_callb...</a><p>[2] <a href="https:&#x2F;&#x2F;i.stack.imgur.com&#x2F;dXhXP.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;i.stack.imgur.com&#x2F;dXhXP.png</a></div><br/><div id="38552834" class="c"><input type="checkbox" id="c-38552834" checked=""/><div class="controls bullet"><span class="by">thefourthchime</span><span>|</span><a href="#38552168">parent</a><span>|</span><a href="#38552761">next</a><span>|</span><label class="collapse" for="c-38552834">[-]</label><label class="expand" for="c-38552834">[8 more]</label></div><br/><div class="children"><div class="content">C++ dev for 20+ years. I refused to use them, they encapsulated everything with C++ I hated. A ton of implicit actions and gotchas. It&#x27;s a gun in hand, foot in target.</div><br/><div id="38552963" class="c"><input type="checkbox" id="c-38552963" checked=""/><div class="controls bullet"><span class="by">jnwatson</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38552834">parent</a><span>|</span><a href="#38553859">next</a><span>|</span><label class="collapse" for="c-38552963">[-]</label><label class="expand" for="c-38552963">[6 more]</label></div><br/><div class="children"><div class="content">streams is the best evidence that C++ was an experiment.  It was a sandbox to try a bunch of different language ideas.<p>Overloading the shift operators for this purpose is prima facie insane, and anyone who has single-stepped through a C++ &quot;hello world&quot; program can figure out it isn&#x27;t remotely efficient, but it was certainly creative.</div><br/><div id="38553013" class="c"><input type="checkbox" id="c-38553013" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38552963">parent</a><span>|</span><a href="#38553859">next</a><span>|</span><label class="collapse" for="c-38553013">[-]</label><label class="expand" for="c-38553013">[5 more]</label></div><br/><div class="children"><div class="content">The shift operators are literally the nicest and most innocuous design decision of C++ streams.<p>What&#x27;s broken with them has nothing to do with bikeshedding about operator choice.</div><br/><div id="38553532" class="c"><input type="checkbox" id="c-38553532" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38553013">parent</a><span>|</span><a href="#38553859">next</a><span>|</span><label class="collapse" for="c-38553532">[-]</label><label class="expand" for="c-38553532">[4 more]</label></div><br/><div class="children"><div class="content">But still not without problems, because you can&#x27;t naturally write `cout &lt;&lt; x &amp; 0x1f &lt;&lt; endl;`...</div><br/><div id="38553740" class="c"><input type="checkbox" id="c-38553740" checked=""/><div class="controls bullet"><span class="by">snovv_crash</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38553532">parent</a><span>|</span><a href="#38553859">next</a><span>|</span><label class="collapse" for="c-38553740">[-]</label><label class="expand" for="c-38553740">[3 more]</label></div><br/><div class="children"><div class="content">Just put some brackets like you should for any operator chaining. Explicit over implicit etc.</div><br/><div id="38553777" class="c"><input type="checkbox" id="c-38553777" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38553740">parent</a><span>|</span><a href="#38553859">next</a><span>|</span><label class="collapse" for="c-38553777">[-]</label><label class="expand" for="c-38553777">[2 more]</label></div><br/><div class="children"><div class="content">But here `&lt;&lt;` doesn&#x27;t really feel like an actual operator here, just an ordinary separator like `,`. (Of course, `,` is actually an operator in C++. But anyway.) It is just completely alien to other existing C++ conventions before and after that.</div><br/><div id="38554361" class="c"><input type="checkbox" id="c-38554361" checked=""/><div class="controls bullet"><span class="by">jarlesincharge</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38553777">parent</a><span>|</span><a href="#38553859">next</a><span>|</span><label class="collapse" for="c-38554361">[-]</label><label class="expand" for="c-38554361">[1 more]</label></div><br/><div class="children"><div class="content">C++20 ranges went a bitwise operator overload (OR this time).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38553859" class="c"><input type="checkbox" id="c-38553859" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38552834">parent</a><span>|</span><a href="#38552963">prev</a><span>|</span><a href="#38552761">next</a><span>|</span><label class="collapse" for="c-38553859">[-]</label><label class="expand" for="c-38553859">[1 more]</label></div><br/><div class="children"><div class="content">Using C++ since 1993, I love them.</div><br/></div></div></div></div><div id="38552761" class="c"><input type="checkbox" id="c-38552761" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#38552168">parent</a><span>|</span><a href="#38552834">prev</a><span>|</span><a href="#38552717">next</a><span>|</span><label class="collapse" for="c-38552761">[-]</label><label class="expand" for="c-38552761">[2 more]</label></div><br/><div class="children"><div class="content">&gt; (From the Node.js GitHub issue.) Sounds like this guy is mixing up his Java knowledge with C++ knowledge.<p>That is exactly it. C++ string streams have had atrocious performance since forever. Good abstraction, not very useful in practice.<p>In Java, if I remember correctly, strings are immutable, so the StringBuilder or whatever ridiculous name it had was the faster way to build a string.<p>&gt; &quot;I recently learned that some Node.js engineers prefer stream classes when building strings, for performance reasons.&quot;<p>Pretty much tells you everything you need to know about node js, I guess.</div><br/><div id="38553766" class="c"><input type="checkbox" id="c-38553766" checked=""/><div class="controls bullet"><span class="by">Rebelgecko</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38552761">parent</a><span>|</span><a href="#38552717">next</a><span>|</span><label class="collapse" for="c-38553766">[-]</label><label class="expand" for="c-38553766">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, even in Java the compiler is often smart enough to replace naive string concatenation with equivalent StringBuilder usage (although I don&#x27;t know if it is smart enough to do that in a for loop like this)</div><br/></div></div></div></div><div id="38552717" class="c"><input type="checkbox" id="c-38552717" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38552168">parent</a><span>|</span><a href="#38552761">prev</a><span>|</span><a href="#38553071">next</a><span>|</span><label class="collapse" for="c-38552717">[-]</label><label class="expand" for="c-38552717">[3 more]</label></div><br/><div class="children"><div class="content">A bigger problem is that iostream is still the only C++ way to read and write files. Yeah, you can still use `std::fopen` and so on, but the modern C++ strives to minimize type-ignorant C functions right? The introduction of `std::format` made the formatting aspect of iostream obsolete, but iostream still has no standard alternative for other aspects.</div><br/><div id="38554164" class="c"><input type="checkbox" id="c-38554164" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38552717">parent</a><span>|</span><a href="#38552961">next</a><span>|</span><label class="collapse" for="c-38554164">[-]</label><label class="expand" for="c-38554164">[1 more]</label></div><br/><div class="children"><div class="content">std::filebuf can be used directly without std::fstream if you just want to read and write bytes without doing formatted operations.</div><br/></div></div><div id="38552961" class="c"><input type="checkbox" id="c-38552961" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38552717">parent</a><span>|</span><a href="#38554164">prev</a><span>|</span><a href="#38553071">next</a><span>|</span><label class="collapse" for="c-38552961">[-]</label><label class="expand" for="c-38552961">[1 more]</label></div><br/><div class="children"><div class="content">std::print is coming with C++23. In the meantime, there&#x27;s std::format_to. You still have to dump the output into an std::ostream, but at least you don&#x27;t have to use the disgusting ostream interface directly.</div><br/></div></div></div></div><div id="38553071" class="c"><input type="checkbox" id="c-38553071" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#38552168">parent</a><span>|</span><a href="#38552717">prev</a><span>|</span><a href="#38552242">next</a><span>|</span><label class="collapse" for="c-38553071">[-]</label><label class="expand" for="c-38553071">[1 more]</label></div><br/><div class="children"><div class="content">The github issue:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;node&#x2F;pull&#x2F;50253">https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;node&#x2F;pull&#x2F;50253</a><p>Note that the person mixing java knowledge and C++ isn&#x27;t Daniel Lemire.</div><br/></div></div><div id="38552242" class="c"><input type="checkbox" id="c-38552242" checked=""/><div class="controls bullet"><span class="by">AndrewStephens</span><span>|</span><a href="#38552168">parent</a><span>|</span><a href="#38553071">prev</a><span>|</span><a href="#38554150">next</a><span>|</span><label class="collapse" for="c-38552242">[-]</label><label class="expand" for="c-38552242">[1 more]</label></div><br/><div class="children"><div class="content">iostreams are such a messy design, for all the reasons you mention and more. They are rightly avoided in all code that cares about performance.</div><br/></div></div><div id="38554150" class="c"><input type="checkbox" id="c-38554150" checked=""/><div class="controls bullet"><span class="by">uxp8u61q</span><span>|</span><a href="#38552168">parent</a><span>|</span><a href="#38552242">prev</a><span>|</span><a href="#38552872">next</a><span>|</span><label class="collapse" for="c-38554150">[-]</label><label class="expand" for="c-38554150">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the alternative to string streams for building strings pieces by pieces in C++? Plain old string concatenation? Asking for a friend... I should run benchmarks I guess.</div><br/></div></div><div id="38552872" class="c"><input type="checkbox" id="c-38552872" checked=""/><div class="controls bullet"><span class="by">calamari4065</span><span>|</span><a href="#38552168">parent</a><span>|</span><a href="#38554150">prev</a><span>|</span><a href="#38552608">next</a><span>|</span><label class="collapse" for="c-38552872">[-]</label><label class="expand" for="c-38552872">[5 more]</label></div><br/><div class="children"><div class="content">Huh. I don&#x27;t know much at all about C++ streams, but this sounds only marginally worse than C#&#x27;s streams</div><br/><div id="38553544" class="c"><input type="checkbox" id="c-38553544" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38552872">parent</a><span>|</span><a href="#38552608">next</a><span>|</span><label class="collapse" for="c-38553544">[-]</label><label class="expand" for="c-38553544">[4 more]</label></div><br/><div class="children"><div class="content">Maybe not. The problem is that C++ (before C++20) has no normal print and format function. You supposed to do everything with streams. To switch to two decimal places you would first output some magic value that sets an internal flag in the stream. Then you need to remember to restore it again.<p>Of course you could just use good old C printf to get some work done. But if you did that the &quot;real&quot; C++ programmers would sneer at you.</div><br/><div id="38553775" class="c"><input type="checkbox" id="c-38553775" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38553544">parent</a><span>|</span><a href="#38553757">next</a><span>|</span><label class="collapse" for="c-38553775">[-]</label><label class="expand" for="c-38553775">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Of course you could just use good old C printf<p>The fun thing with printf is that variadic functions cannot handle C++ classes. In the past was doubly fun because compilers proactively compiled an error into the binary instead of raising an error at compile time. So any forgotten c_str() became a crash waiting to happen.<p>C Printf never was, never could be and never will be a suitable way to output data from C++. Now excuse me while I go through the list of thousands of predefined format macros to find out which I need to use to output a uint_fast16_t without making the compiler vomit nonsense.</div><br/></div></div><div id="38553757" class="c"><input type="checkbox" id="c-38553757" checked=""/><div class="controls bullet"><span class="by">snovv_crash</span><span>|</span><a href="#38552168">root</a><span>|</span><a href="#38553544">parent</a><span>|</span><a href="#38553775">prev</a><span>|</span><a href="#38552608">next</a><span>|</span><label class="collapse" for="c-38553757">[-]</label><label class="expand" for="c-38553757">[1 more]</label></div><br/><div class="children"><div class="content">printf is fast, but has safety problems. Also frankly I don&#x27;t like the fact that the formatting and the variable the data comes from are separated and you have to count out the argument orders to figure which one is which. Python&#x27;s fstring gets this right.</div><br/></div></div></div></div></div></div></div></div><div id="38552608" class="c"><input type="checkbox" id="c-38552608" checked=""/><div class="controls bullet"><span class="by">ewalk153</span><span>|</span><a href="#38552168">prev</a><span>|</span><a href="#38551922">next</a><span>|</span><label class="collapse" for="c-38552608">[-]</label><label class="expand" for="c-38552608">[7 more]</label></div><br/><div class="children"><div class="content">Danielâs PR to implement this in node.js[1] is case study in:<p>- crafting a high context yet succinct description<p>- addressing PR feedback well<p>- giving respect to a pedantic commenter who understands the inner workings far less than Daniel while not conceded to make a destructive change.<p>I will share this PR widely as arole model in open source contributions.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;node&#x2F;pull&#x2F;50288">https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;node&#x2F;pull&#x2F;50288</a></div><br/><div id="38553009" class="c"><input type="checkbox" id="c-38553009" checked=""/><div class="controls bullet"><span class="by">pitaj</span><span>|</span><a href="#38552608">parent</a><span>|</span><a href="#38553228">next</a><span>|</span><label class="collapse" for="c-38553009">[-]</label><label class="expand" for="c-38553009">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised that the reviewer was so ignorant of amortized constant time insertion.</div><br/><div id="38553425" class="c"><input type="checkbox" id="c-38553425" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38552608">root</a><span>|</span><a href="#38553009">parent</a><span>|</span><a href="#38553245">next</a><span>|</span><label class="collapse" for="c-38553425">[-]</label><label class="expand" for="c-38553425">[1 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m being super pedantic, I would argue that while `string::push_back` should take amortized constant time, `string::append` has no such guarantee [1]. So it is <i>technically</i> possible for `my_string += &quot;a&quot;;` (same to `string::append`) will reallocate every time. Very pedantic indeed, but I have seen some C++ implementation where `std::vector&lt;T&gt;` is an alias to `std::deque&lt;T&gt;`, so...<p>One thing I don&#x27;t like about lemire&#x27;s phrasing is that he only looks at the current, often only most available, implementations and doesn&#x27;t make this point explicit for most cases.<p>EDIT: Thankfully he does acknowledge that in a later post [2].<p>[1] <a href="https:&#x2F;&#x2F;timsong-cpp.github.io&#x2F;cppwp&#x2F;n4861&#x2F;strings#string.append" rel="nofollow noreferrer">https:&#x2F;&#x2F;timsong-cpp.github.io&#x2F;cppwp&#x2F;n4861&#x2F;strings#string.app...</a><p>[2] <a href="https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2023&#x2F;10&#x2F;23&#x2F;appending-to-an-stdstring-character-by-character-how-does-the-capacity-grow&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2023&#x2F;10&#x2F;23&#x2F;appending-to-an-stdstring-...</a></div><br/></div></div><div id="38553245" class="c"><input type="checkbox" id="c-38553245" checked=""/><div class="controls bullet"><span class="by">rossjudson</span><span>|</span><a href="#38552608">root</a><span>|</span><a href="#38553009">parent</a><span>|</span><a href="#38553425">prev</a><span>|</span><a href="#38553228">next</a><span>|</span><label class="collapse" for="c-38553245">[-]</label><label class="expand" for="c-38553245">[2 more]</label></div><br/><div class="children"><div class="content">I am not at all surprised. Kids these days have no idea what CPUs can do. ;)<p>I periodically have interview candidates work through problems involving binary search, then switch to bounded and ask them how to make it go faster over N elements, where N is &lt; 1e3. The answer is &quot;just linear search, because CPUs really like to do that&quot;.</div><br/><div id="38554068" class="c"><input type="checkbox" id="c-38554068" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#38552608">root</a><span>|</span><a href="#38553245">parent</a><span>|</span><a href="#38553228">next</a><span>|</span><label class="collapse" for="c-38554068">[-]</label><label class="expand" for="c-38554068">[1 more]</label></div><br/><div class="children"><div class="content">But amortized analysis has nothing to do with what CPUs can do. CS students learn it in an algorithm course, not in a computer architecture course.</div><br/></div></div></div></div></div></div><div id="38553228" class="c"><input type="checkbox" id="c-38553228" checked=""/><div class="controls bullet"><span class="by">rossjudson</span><span>|</span><a href="#38552608">parent</a><span>|</span><a href="#38553009">prev</a><span>|</span><a href="#38553113">next</a><span>|</span><label class="collapse" for="c-38553228">[-]</label><label class="expand" for="c-38553228">[1 more]</label></div><br/><div class="children"><div class="content">The same thing struck me as well. This is one of the best optimization professionals <i>on the planet</i>, showing up with a huge improvement, and receiving some misplaced arrogance.<p>The lesson here is to always, always watch your <i>own</i> review tone, and not make this mistake.<p>The other lesson is that when a PR shows up with this kind of technical information attached to it, spend the 60 seconds it takes to Google for &quot;lemire&quot;.</div><br/></div></div></div></div><div id="38551922" class="c"><input type="checkbox" id="c-38551922" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38552608">prev</a><span>|</span><a href="#38552678">next</a><span>|</span><label class="collapse" for="c-38551922">[-]</label><label class="expand" for="c-38551922">[9 more]</label></div><br/><div class="children"><div class="content">My impression is that C++ streams are on their way out -- unlikely to be deprecated (too much existing code) but also unlikely to receive any more attention.  They are old enough to likely not have any actual implementation bugs at this point, but in retrospect the design bugs from the 1980s are pretty serious.<p>The rapid incorporation of the excellent `format` package for printing points to a future falling back at least to ANSI buffered IO and possibly raw POSIX IO.</div><br/><div id="38553050" class="c"><input type="checkbox" id="c-38553050" checked=""/><div class="controls bullet"><span class="by">jujube3</span><span>|</span><a href="#38551922">parent</a><span>|</span><a href="#38552161">next</a><span>|</span><label class="collapse" for="c-38553050">[-]</label><label class="expand" for="c-38553050">[4 more]</label></div><br/><div class="children"><div class="content">Is there any reason to use the format package rather than printf? Aside from C++ people who claim to hate C needing to save face?</div><br/><div id="38553982" class="c"><input type="checkbox" id="c-38553982" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38551922">root</a><span>|</span><a href="#38553050">parent</a><span>|</span><a href="#38553865">next</a><span>|</span><label class="collapse" for="c-38553982">[-]</label><label class="expand" for="c-38553982">[1 more]</label></div><br/><div class="children"><div class="content">I like C much more than C++, but even with that must say that <a href="https:&#x2F;&#x2F;github.com&#x2F;fmtlib&#x2F;fmt">https:&#x2F;&#x2F;github.com&#x2F;fmtlib&#x2F;fmt</a> is pretty nice (which is the base for std::format). Together with pystring (<a href="https:&#x2F;&#x2F;github.com&#x2F;imageworks&#x2F;pystring">https:&#x2F;&#x2F;github.com&#x2F;imageworks&#x2F;pystring</a>) it makes string processing in C++ somewhat bearable (pystring is slow though because it still uses the std::string type which excessively allocates, but at least it&#x27;s convenient compared to &#x27;raw&#x27; C++ string functionality).</div><br/></div></div><div id="38553865" class="c"><input type="checkbox" id="c-38553865" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38551922">root</a><span>|</span><a href="#38553050">parent</a><span>|</span><a href="#38553982">prev</a><span>|</span><a href="#38553124">next</a><span>|</span><label class="collapse" for="c-38553865">[-]</label><label class="expand" for="c-38553865">[1 more]</label></div><br/><div class="children"><div class="content">Other than caring about type safety, and possible CVEs due to misuse of format strings?</div><br/></div></div><div id="38553124" class="c"><input type="checkbox" id="c-38553124" checked=""/><div class="controls bullet"><span class="by">IcyWindows</span><span>|</span><a href="#38551922">root</a><span>|</span><a href="#38553050">parent</a><span>|</span><a href="#38553865">prev</a><span>|</span><a href="#38552161">next</a><span>|</span><label class="collapse" for="c-38553124">[-]</label><label class="expand" for="c-38553124">[1 more]</label></div><br/><div class="children"><div class="content">The library overview goes over the reasons fairly succinctly:
 <a href="https:&#x2F;&#x2F;fmt.dev&#x2F;latest&#x2F;index.html#overview" rel="nofollow noreferrer">https:&#x2F;&#x2F;fmt.dev&#x2F;latest&#x2F;index.html#overview</a></div><br/></div></div></div></div><div id="38552161" class="c"><input type="checkbox" id="c-38552161" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#38551922">parent</a><span>|</span><a href="#38553050">prev</a><span>|</span><a href="#38552678">next</a><span>|</span><label class="collapse" for="c-38552161">[-]</label><label class="expand" for="c-38552161">[4 more]</label></div><br/><div class="children"><div class="content">you mean format + printf&#x2F;scanf from C?</div><br/><div id="38552227" class="c"><input type="checkbox" id="c-38552227" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#38551922">root</a><span>|</span><a href="#38552161">parent</a><span>|</span><a href="#38552517">next</a><span>|</span><label class="collapse" for="c-38552227">[-]</label><label class="expand" for="c-38552227">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;header&#x2F;format" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;header&#x2F;format</a><p>Which is based on<p><a href="https:&#x2F;&#x2F;fmt.dev&#x2F;latest&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;fmt.dev&#x2F;latest&#x2F;index.html</a></div><br/></div></div><div id="38552517" class="c"><input type="checkbox" id="c-38552517" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38551922">root</a><span>|</span><a href="#38552161">parent</a><span>|</span><a href="#38552227">prev</a><span>|</span><a href="#38552222">next</a><span>|</span><label class="collapse" for="c-38552517">[-]</label><label class="expand" for="c-38552517">[1 more]</label></div><br/><div class="children"><div class="content">As others have pointed out I mean `std::format` et al in &lt;format&gt;.<p>There&#x27;s also a proposal for a type safe scanf: scnlib, sort of format in reverse: <a href="https:&#x2F;&#x2F;scnlib.dev&#x2F;en&#x2F;master&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;scnlib.dev&#x2F;en&#x2F;master&#x2F;</a></div><br/></div></div><div id="38552222" class="c"><input type="checkbox" id="c-38552222" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#38551922">root</a><span>|</span><a href="#38552161">parent</a><span>|</span><a href="#38552517">prev</a><span>|</span><a href="#38552678">next</a><span>|</span><label class="collapse" for="c-38552222">[-]</label><label class="expand" for="c-38552222">[1 more]</label></div><br/><div class="children"><div class="content">this: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;format&#x2F;format" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;format&#x2F;format</a> most likely.</div><br/></div></div></div></div></div></div><div id="38552678" class="c"><input type="checkbox" id="c-38552678" checked=""/><div class="controls bullet"><span class="by">linuxhansl</span><span>|</span><a href="#38551922">prev</a><span>|</span><a href="#38551681">next</a><span>|</span><label class="collapse" for="c-38552678">[-]</label><label class="expand" for="c-38552678">[2 more]</label></div><br/><div class="children"><div class="content">Yep. stringstreams make copies of passed strings too. I had to hack around that once like this:<p><pre><code>  struct ZeroCopyBuf : public std::streambuf
  {
   ZeroCopyBuf(const std::string &amp;s) : ZeroCopyBuf(s.c_str(), s.length()) {}
   ZeroCopyBuf(const char *c, std::size_t l) : ZeroCopyBuf(const_cast&lt;char*&gt;(c), l) {}
   ZeroCopyBuf(char *c, std::size_t l) { setg(c, c, c + l); }
  };
  ...
  std::string s ...;
  ZeroCopyBuf buf(s);
  std::istream is(&amp;buf);
</code></pre>
Terrible.
C++-20 makes it better by adding move semantics to most methods... Still.</div><br/><div id="38554193" class="c"><input type="checkbox" id="c-38554193" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#38552678">parent</a><span>|</span><a href="#38551681">next</a><span>|</span><label class="collapse" for="c-38554193">[-]</label><label class="expand" for="c-38554193">[1 more]</label></div><br/><div class="children"><div class="content">Just use the Boost Iostreams library<p>The array_source device can be used with any buffer (char*, size_t)</div><br/></div></div></div></div><div id="38551681" class="c"><input type="checkbox" id="c-38551681" checked=""/><div class="controls bullet"><span class="by">taspeotis</span><span>|</span><a href="#38552678">prev</a><span>|</span><a href="#38553598">next</a><span>|</span><label class="collapse" for="c-38551681">[-]</label><label class="expand" for="c-38551681">[5 more]</label></div><br/><div class="children"><div class="content">When I did competitive programming in C++ nobody used fstream for reading input because it was much slower compared to fscanf.</div><br/><div id="38552026" class="c"><input type="checkbox" id="c-38552026" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#38551681">parent</a><span>|</span><a href="#38553598">next</a><span>|</span><label class="collapse" for="c-38552026">[-]</label><label class="expand" for="c-38552026">[4 more]</label></div><br/><div class="children"><div class="content">It always surprises me how slow streams are. fscanf should be relatively slow because it has to parse the format string at runtime. So the new C++ format should be (and I believe is) much faster</div><br/><div id="38553138" class="c"><input type="checkbox" id="c-38553138" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#38551681">root</a><span>|</span><a href="#38552026">parent</a><span>|</span><a href="#38553609">next</a><span>|</span><label class="collapse" for="c-38553138">[-]</label><label class="expand" for="c-38553138">[1 more]</label></div><br/><div class="children"><div class="content">Parsing a string is significantly faster than disk io, so this is not an issue unless you are reading minuscule amounts of data.</div><br/></div></div><div id="38553609" class="c"><input type="checkbox" id="c-38553609" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38551681">root</a><span>|</span><a href="#38552026">parent</a><span>|</span><a href="#38553138">prev</a><span>|</span><a href="#38552444">next</a><span>|</span><label class="collapse" for="c-38553609">[-]</label><label class="expand" for="c-38553609">[1 more]</label></div><br/><div class="children"><div class="content">I believe the Abseil library has formatting functions that&#x27;s capable of parsing the format string at compile time.</div><br/></div></div></div></div></div></div><div id="38553598" class="c"><input type="checkbox" id="c-38553598" checked=""/><div class="controls bullet"><span class="by">roeles</span><span>|</span><a href="#38551681">prev</a><span>|</span><a href="#38553614">next</a><span>|</span><label class="collapse" for="c-38553598">[-]</label><label class="expand" for="c-38553598">[2 more]</label></div><br/><div class="children"><div class="content">Lots of complaints about stream performance here.<p>std::sync_with_stdio(false);<p>Helps with that a bit.</div><br/><div id="38554196" class="c"><input type="checkbox" id="c-38554196" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#38553598">parent</a><span>|</span><a href="#38553614">next</a><span>|</span><label class="collapse" for="c-38554196">[-]</label><label class="expand" for="c-38554196">[1 more]</label></div><br/><div class="children"><div class="content">Setting the classic locale too</div><br/></div></div></div></div><div id="38553614" class="c"><input type="checkbox" id="c-38553614" checked=""/><div class="controls bullet"><span class="by">atemerev</span><span>|</span><a href="#38553598">prev</a><span>|</span><label class="collapse" for="c-38553614">[-]</label><label class="expand" for="c-38553614">[2 more]</label></div><br/><div class="children"><div class="content">OK, so, what is the right way then?</div><br/><div id="38554025" class="c"><input type="checkbox" id="c-38554025" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38553614">parent</a><span>|</span><label class="collapse" for="c-38554025">[-]</label><label class="expand" for="c-38554025">[1 more]</label></div><br/><div class="children"><div class="content">If performance matters most, write your own specialized string processing code which works on &quot;raw&quot; data in memory buffers. If convenience matters look at <a href="https:&#x2F;&#x2F;github.com&#x2F;fmtlib&#x2F;fmt">https:&#x2F;&#x2F;github.com&#x2F;fmtlib&#x2F;fmt</a> (or std::format which AFAIK is less feature rich) and <a href="https:&#x2F;&#x2F;github.com&#x2F;imageworks&#x2F;pystring">https:&#x2F;&#x2F;github.com&#x2F;imageworks&#x2F;pystring</a>.</div><br/></div></div></div></div></div></div></div></div></div></body></html>