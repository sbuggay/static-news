<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719910855186" as="style"/><link rel="stylesheet" href="styles.css?v=1719910855186"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://db.cs.cmu.edu/papers/2024/whatgoesaround-sigmodrec2024.pdf">What goes around comes around and around [pdf]</a> <span class="domain">(<a href="https://db.cs.cmu.edu">db.cs.cmu.edu</a>)</span></div><div class="subtext"><span>craigkerstiens</span> | <span>22 comments</span></div><br/><div><div id="40847266" class="c"><input type="checkbox" id="c-40847266" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#40847359">next</a><span>|</span><label class="collapse" for="c-40847266">[-]</label><label class="expand" for="c-40847266">[1 more]</label></div><br/><div class="children"><div class="content">This paper is a really good treatment of the space from my perspective.<p>I think the greatest power in the relational model comes from its ability to directly represent cyclical dependencies without forcing weird workarounds. Many real-world domains have ambiguities regarding which types should be strict dependents of another. This confounds approaches relying on serialization. As mentioned in the paper, many major providers offer extensions to SQL which allow you to iterate through the graph implied by these relations with a single logical command.<p>&gt; The impact of AI&#x2F;ML on DBMSs will be significant<p>I agree with this but not in the way the authors may have intended. I think the impact will be mostly negative. The amount of energy being spent on blackbox query generator approaches could be better spent elsewhere. You can get extremely close, but this often doesn&#x27;t matter.<p>&gt; Do not ignore the out-of-box experience.<p>This is why everyone says to start with SQLite now.</div><br/></div></div><div id="40847359" class="c"><input type="checkbox" id="c-40847359" checked=""/><div class="controls bullet"><span class="by">simonz05</span><span>|</span><a href="#40847266">prev</a><span>|</span><a href="#40850392">next</a><span>|</span><label class="collapse" for="c-40847359">[-]</label><label class="expand" for="c-40847359">[2 more]</label></div><br/><div class="children"><div class="content">The paper is inspired by a hacker news comment: <a href="https:&#x2F;&#x2F;x.com&#x2F;andy_pavlo&#x2F;status&#x2F;1807799839616614856" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;andy_pavlo&#x2F;status&#x2F;1807799839616614856</a></div><br/><div id="40847434" class="c"><input type="checkbox" id="c-40847434" checked=""/><div class="controls bullet"><span class="by">neonate</span><span>|</span><a href="#40847359">parent</a><span>|</span><a href="#40850392">next</a><span>|</span><label class="collapse" for="c-40847434">[-]</label><label class="expand" for="c-40847434">[1 more]</label></div><br/><div class="children"><div class="content">This one, apparently: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28736405">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28736405</a> - mentioned here <a href="https:&#x2F;&#x2F;x.com&#x2F;andy_pavlo&#x2F;status&#x2F;1807799843693396420" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;andy_pavlo&#x2F;status&#x2F;1807799843693396420</a></div><br/></div></div></div></div><div id="40850392" class="c"><input type="checkbox" id="c-40850392" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#40847359">prev</a><span>|</span><a href="#40849618">next</a><span>|</span><label class="collapse" for="c-40850392">[-]</label><label class="expand" for="c-40850392">[2 more]</label></div><br/><div class="children"><div class="content">In a technology career that started in the early 1990s, one of the constants has been relational databases and SQL. There is no better general-purpose data storage and query architecture, and it&#x27;s the first (and usually last) thing I consider for almost any new development project that involves storing and retreiving data.</div><br/><div id="40853169" class="c"><input type="checkbox" id="c-40853169" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#40850392">parent</a><span>|</span><a href="#40849618">next</a><span>|</span><label class="collapse" for="c-40853169">[-]</label><label class="expand" for="c-40853169">[1 more]</label></div><br/><div class="children"><div class="content">I’d also add, being decent at sql queries and design&#x2F;tuning is a massive advantage over programmers who are not. It’s like being tasked with bulk editing text and one person knowing regular expressions and the other person just knowing string manipulation functions.</div><br/></div></div></div></div><div id="40849618" class="c"><input type="checkbox" id="c-40849618" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#40850392">prev</a><span>|</span><a href="#40848042">next</a><span>|</span><label class="collapse" for="c-40849618">[-]</label><label class="expand" for="c-40849618">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how I feel about this paper: on the one hand, I agree with the sentiment that the relational data model is the natural end state if you keep adding features to a data system (and it perfectly captures my sentiment about vector DBs) and it&#x27;s silly to not use SQL out of the gate.<p>On the other hand, the paper is kind of dismissive about engineering nuance and gets some details blatantly wrong.<p>- MapReduce is alive and well, it just has a different name now (for Googlers, that name is Flume). I&#x27;m pretty confident that your cloud bill - whether or not you use GCP, AWS, or Azure, is powered by a couple hundred, if not thousand, of jobs like this.<p>- Pretty sure anyone running in production has a hard serving dependency on Redis or Memcache _somewhere_ in their stack, because even if you&#x27;re not using it directly, I would bet that one of your cloud service providers uses a distributed, shared-nothing KV cache under the hood.<p>- The vast majority of software is not backed by a truly serializable ACID database implementation.<p>-- MySQL&#x27;s default isolation level has internal consistency violations[1] and its DDL is non-transactional.<p>-- The classic transaction example of a &quot;bank transfer&quot; is hilariously mis-representative - ACH is very obviously not implemented using an inter-bank database that supports serializable transactions.<p>-- A lot of search applications - I would venture to say most - don&#x27;t need transactional semantics. Do you think Google Search is transactional? Or GitHub code search?<p>[1]: <a href="https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;mysql-8.0.34" rel="nofollow">https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;mysql-8.0.34</a></div><br/><div id="40849734" class="c"><input type="checkbox" id="c-40849734" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#40849618">parent</a><span>|</span><a href="#40848042">next</a><span>|</span><label class="collapse" for="c-40849734">[-]</label><label class="expand" for="c-40849734">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The classic transaction example of a &quot;bank transfer&quot; is hilariously mis-representative - ACH is very obviously not implemented using an inter-bank database that supports serializable transactions.<p>This is meant more as a pedagogical tool rather than a literal representation of how the system works. The <i>intra</i>-bank aspects of ACH absolutely do rely on serializable transactions.</div><br/></div></div></div></div><div id="40848042" class="c"><input type="checkbox" id="c-40848042" checked=""/><div class="controls bullet"><span class="by">didgetmaster</span><span>|</span><a href="#40849618">prev</a><span>|</span><a href="#40848257">next</a><span>|</span><label class="collapse" for="c-40848042">[-]</label><label class="expand" for="c-40848042">[4 more]</label></div><br/><div class="children"><div class="content">When I was building an object store years ago; I needed a way to attach metadata tags to each object. The objects themselves could be files like a picture, a document, or some music; and I wanted to allow tags to denote things like the author, the camera, or the music genre.<p>Most systems use things like file extended attributes or a separate database to store such metadata; but I wanted something different. It needed to be able to attach tags to hundreds of millions of objects and find things that matched certain tags quickly.<p>I invented a key-value store to hold the metadata and got it working well. When it started to look like a big columnar store with sparsely populated rows; I decided to see if it could handle queries like a relational database. To my surprise it not only did it well, it could outperform many of them.<p>There are data models besides relational that can work extremely well for certain data sets.</div><br/><div id="40850679" class="c"><input type="checkbox" id="c-40850679" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#40848042">parent</a><span>|</span><a href="#40848257">next</a><span>|</span><label class="collapse" for="c-40850679">[-]</label><label class="expand" for="c-40850679">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not going to have 100&#x27;s of millions of objects, so I can&#x27;t speak to that.<p>But for my one hobby project, I&#x27;m using RDF and a triple store. Even with a &quot;small&quot; dataset, you can get an explosion of properties.<p>I want to be able to add arbitrary properties to arbitrary things and relate them all together. Build the graph organically.<p>So far, its working really well. But underneath, its (likely) just a couple of b+trees do all of the heavy lifting.</div><br/><div id="40851380" class="c"><input type="checkbox" id="c-40851380" checked=""/><div class="controls bullet"><span class="by">enord</span><span>|</span><a href="#40848042">root</a><span>|</span><a href="#40850679">parent</a><span>|</span><a href="#40848257">next</a><span>|</span><label class="collapse" for="c-40851380">[-]</label><label class="expand" for="c-40851380">[2 more]</label></div><br/><div class="children"><div class="content">Most vendors use three indexes for triples and 4 or 6 for quads. All the indexes are covering, which is to say they triplicate all data—-in other words the database consists only of indexes.<p>Aint that just neat?</div><br/><div id="40851781" class="c"><input type="checkbox" id="c-40851781" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#40848042">root</a><span>|</span><a href="#40851380">parent</a><span>|</span><a href="#40848257">next</a><span>|</span><label class="collapse" for="c-40851781">[-]</label><label class="expand" for="c-40851781">[1 more]</label></div><br/><div class="children"><div class="content">I refer to RDF as the &quot;absurd normal form&quot;. When my friends and I do DB design, it&#x27;s almost inevitable we fall into what might inevitably become the &quot;ThingThing&quot; table thats a many-to-many joiner of everything to everything else. (That&#x27;s when we giggle, leave the room, go to lunch, and then come back when we&#x27;ve returned to our senses.)<p>But, for RDF its exactly what I want, I&#x27;m not interested in schemas and such for this work, so it&#x27;s perfect for my scenario.</div><br/></div></div></div></div></div></div></div></div><div id="40848257" class="c"><input type="checkbox" id="c-40848257" checked=""/><div class="controls bullet"><span class="by">burcs</span><span>|</span><a href="#40848042">prev</a><span>|</span><a href="#40848470">next</a><span>|</span><label class="collapse" for="c-40848257">[-]</label><label class="expand" for="c-40848257">[1 more]</label></div><br/><div class="children"><div class="content">What an amazing read, here&#x27;s hoping they&#x27;ll both be around for the 2044 edition. 101 is not too old to write another research paper Dr. Stonebraker!</div><br/></div></div><div id="40848470" class="c"><input type="checkbox" id="c-40848470" checked=""/><div class="controls bullet"><span class="by">paulsutter</span><span>|</span><a href="#40848257">prev</a><span>|</span><a href="#40848259">next</a><span>|</span><label class="collapse" for="c-40848470">[-]</label><label class="expand" for="c-40848470">[1 more]</label></div><br/><div class="children"><div class="content">Great article, one bit of errata: actually ChatGPT does not expose its internal embedding, so the use of embeddings for RAG are just optional or even coincidental. You can also use ordinary search like Elasticsearch (a point that&#x27;s somehow often lost).<p>Besides, the internal embedding for ChatGPT is per-token (~word), whereas the embedding used for RAG search is per-document (retrieval document might be small like a paragraph or page, or could be as large the the whole source document), so these wouldn&#x27;t be usable for this purpose anyway<p>&gt; One compelling feature of vector DBMSs is that they provide better integration with AI tools (e.g., Chat- GPT [16], LangChain [36]) than RDBMSs. These sys- tems natively support transforming a record’s data into an embedding upon insertion using these tools and then uses the same transformation to convert a query’s in- put arguments into an embedding to perform the ANN search; other DBMSs require the application to perform these transformations outside of the database.</div><br/></div></div><div id="40848259" class="c"><input type="checkbox" id="c-40848259" checked=""/><div class="controls bullet"><span class="by">paulsutter</span><span>|</span><a href="#40848470">prev</a><span>|</span><a href="#40848795">next</a><span>|</span><label class="collapse" for="c-40848259">[-]</label><label class="expand" for="c-40848259">[3 more]</label></div><br/><div class="children"><div class="content">This paper has a very concise and easier-to-understand definition of Google&#x27;s Mapreduce:<p>&gt; To a first approximation, MR runs a single query:<p>&gt; SELECT map() FROM crawl_table GROUP BY reduce()<p>Or you could read the entire Google Mapreduce paper</div><br/><div id="40849711" class="c"><input type="checkbox" id="c-40849711" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#40848259">parent</a><span>|</span><a href="#40848795">next</a><span>|</span><label class="collapse" for="c-40849711">[-]</label><label class="expand" for="c-40849711">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the GROUP BY run before the SELECT though, e.g. &quot;SELECT MAX(t) FROM foo GROUP BY t&quot;? I think to do it the way they suggest you&#x27;d probably need to create a temp table like<p>WITH mapped as SELECT map() from crawl_table
SELECT * FROM mapped GROUP BY reduce()</div><br/><div id="40850050" class="c"><input type="checkbox" id="c-40850050" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#40848259">root</a><span>|</span><a href="#40849711">parent</a><span>|</span><a href="#40848795">next</a><span>|</span><label class="collapse" for="c-40850050">[-]</label><label class="expand" for="c-40850050">[1 more]</label></div><br/><div class="children"><div class="content">Yes. MapReduce&#x27;s model is basically:<p><pre><code>  1. Map (key, value) -&gt; (new_key, tmp_value)
  2. Group by new_key
  3. Reduce (new_key, all tmp_values for that key) -&gt; (new_key, new_values)
</code></pre>
In that respect, it&#x27;s not that far from SQL with custom aggregates. I guess the most precise SQL representation would be<p><pre><code>  SELECT REDUCE(MAP(t)) FROM foo GROUP BY KEY(MAP(t))
</code></pre>
(I&#x27;ve both been on the MapReduce team, and worked on an SQL database. I don&#x27;t honestly think they&#x27;re that comparable.)</div><br/></div></div></div></div></div></div><div id="40848795" class="c"><input type="checkbox" id="c-40848795" checked=""/><div class="controls bullet"><span class="by">paulsutter</span><span>|</span><a href="#40848259">prev</a><span>|</span><a href="#40847488">next</a><span>|</span><label class="collapse" for="c-40848795">[-]</label><label class="expand" for="c-40848795">[1 more]</label></div><br/><div class="children"><div class="content">More specifically, blockchains are designed to avoid double-spending in a low-trust environment. If you&#x27;re not trying to avoid double-spending, OR you&#x27;re not in a low-trust environment, you probably dont need a blockchain.<p>&gt; The ideal use case for blockchain databases is peer-to- peer applications where one cannot trust anybody. There is no centralized authority that controls the ordering of updates to the database. Thus, blockchain implementa- tions use a BFT commit protocol to determine which transaction to apply to the database next.</div><br/></div></div><div id="40848568" class="c"><input type="checkbox" id="c-40848568" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40847488">prev</a><span>|</span><label class="collapse" for="c-40848568">[-]</label><label class="expand" for="c-40848568">[3 more]</label></div><br/><div class="children"><div class="content">The relational model is to data what Lisp is to code: despite attempts to beat it, nothing really can because all those other models are expressible in terms of it (and, usually, can be made very efficient in practice).<p>RDBMS and Lisp sit near the tao of their respective domains, which is why I advise people to stick with an RDBMS unless they have a really, really, really good reason not to. Or as Nik Suresh put it, &quot;Just use Postgres. You nerd. You dweeb.&quot;</div><br/><div id="40848964" class="c"><input type="checkbox" id="c-40848964" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#40848568">parent</a><span>|</span><a href="#40849988">next</a><span>|</span><label class="collapse" for="c-40848964">[-]</label><label class="expand" for="c-40848964">[1 more]</label></div><br/><div class="children"><div class="content">LOL, you just outed yourself as a smug Lisp weenie. Utter confidence is absence of any evidence. The obvious glaring difference is RDMS utterly dominate the database space something Lisp doesn&#x27;t even come close to.</div><br/></div></div><div id="40849988" class="c"><input type="checkbox" id="c-40849988" checked=""/><div class="controls bullet"><span class="by">redbar0n</span><span>|</span><a href="#40848568">parent</a><span>|</span><a href="#40848964">prev</a><span>|</span><label class="collapse" for="c-40849988">[-]</label><label class="expand" for="c-40849988">[1 more]</label></div><br/><div class="children"><div class="content">If you like Lisp I presume you would prefer Datalog over SQL, as that is used in the Clojure related database Datomic. Datalog is much more elegant and composable than SQL.</div><br/></div></div></div></div></div></div></div></div></div></body></html>