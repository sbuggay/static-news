<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730883683750" as="style"/><link rel="stylesheet" href="styles.css?v=1730883683750"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/fortress-build/whirlwind">Show HN: Whirlwind – Async concurrent hashmap for Rust</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>willothy</span> | <span>56 comments</span></div><br/><div><div id="42055015" class="c"><input type="checkbox" id="c-42055015" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#42054347">next</a><span>|</span><label class="collapse" for="c-42055015">[-]</label><label class="expand" for="c-42055015">[14 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I&#x27;d recommend using this in production. The benchmarks look good, but by immediately waking the waker[0], you&#x27;ve effectively created a spin-lock. They may work in some very specific circumstances, but they will most likely in practice be more costly to your scheduler (which likely uses locks btw) than just using locks<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;fortress-build&#x2F;whirlwind&#x2F;blob&#x2F;0e4ae5a2aba14870f64828b7bb3a1059b78bb171&#x2F;src&#x2F;shard&#x2F;futures.rs#L27">https:&#x2F;&#x2F;github.com&#x2F;fortress-build&#x2F;whirlwind&#x2F;blob&#x2F;0e4ae5a2aba...</a></div><br/><div id="42055098" class="c"><input type="checkbox" id="c-42055098" checked=""/><div class="controls bullet"><span class="by">sujayakar</span><span>|</span><a href="#42055015">parent</a><span>|</span><a href="#42055087">next</a><span>|</span><label class="collapse" for="c-42055098">[-]</label><label class="expand" for="c-42055098">[3 more]</label></div><br/><div class="children"><div class="content">+1. I&#x27;d be curious how much of a pessimization to uncontended workloads it&#x27;d be to just use `tokio::sync::RwLock`.<p>and, if we want to keep it as a spinlock, I&#x27;m curious how much the immediate wakeup compares to using `tokio::task::yield_now`: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;fn.yield_now.html" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;fn.yield_now.html</a></div><br/><div id="42055192" class="c"><input type="checkbox" id="c-42055192" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055098">parent</a><span>|</span><a href="#42055087">next</a><span>|</span><label class="collapse" for="c-42055192">[-]</label><label class="expand" for="c-42055192">[2 more]</label></div><br/><div class="children"><div class="content">This is an interesting idea. I am gonna try this out - especially with dashmap, I think that could perform very well.</div><br/><div id="42055509" class="c"><input type="checkbox" id="c-42055509" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055192">parent</a><span>|</span><a href="#42055087">next</a><span>|</span><label class="collapse" for="c-42055509">[-]</label><label class="expand" for="c-42055509">[1 more]</label></div><br/><div class="children"><div class="content">You could also look into shamelessly &quot;taking inspiration&quot; from async-lock.</div><br/></div></div></div></div></div></div><div id="42055087" class="c"><input type="checkbox" id="c-42055087" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42055015">parent</a><span>|</span><a href="#42055098">prev</a><span>|</span><a href="#42054347">next</a><span>|</span><label class="collapse" for="c-42055087">[-]</label><label class="expand" for="c-42055087">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe that waking the waker in `poll` synchronously waits &#x2F; runs poll again immediately. I think it is more likely just adding the future back to the global queue to be polled. I could be wrong though, I&#x27;ll look into this more. Thanks for the info!</div><br/><div id="42055110" class="c"><input type="checkbox" id="c-42055110" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055087">parent</a><span>|</span><a href="#42054347">next</a><span>|</span><label class="collapse" for="c-42055110">[-]</label><label class="expand" for="c-42055110">[9 more]</label></div><br/><div class="children"><div class="content">It does immediately put itself into the queue to be polled again. But that&#x27;s no different in effect to a spin-lock. If you have other tasks in your runtime, this will be putting excess pressure on your scheduler</div><br/><div id="42055155" class="c"><input type="checkbox" id="c-42055155" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055110">parent</a><span>|</span><a href="#42055649">next</a><span>|</span><label class="collapse" for="c-42055155">[-]</label><label class="expand" for="c-42055155">[2 more]</label></div><br/><div class="children"><div class="content">Expanding on this. If you have a lot of concurrent tasks, you will overflow[0] the task local queue and be bottlenecked by the global queue mutex[1]<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&#x2F;blob&#x2F;8897885425bf3d89053f896319eeb8777cf255fc&#x2F;tokio&#x2F;src&#x2F;runtime&#x2F;scheduler&#x2F;multi_thread&#x2F;queue.rs#L63">https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&#x2F;blob&#x2F;8897885425bf3d89053f8...</a> 
[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&#x2F;blob&#x2F;8897885425bf3d89053f896319eeb8777cf255fc&#x2F;tokio&#x2F;src&#x2F;runtime&#x2F;scheduler&#x2F;inject&#x2F;rt_multi_thread.rs#L77">https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&#x2F;blob&#x2F;8897885425bf3d89053f8...</a></div><br/><div id="42055183" class="c"><input type="checkbox" id="c-42055183" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055155">parent</a><span>|</span><a href="#42055649">next</a><span>|</span><label class="collapse" for="c-42055183">[-]</label><label class="expand" for="c-42055183">[1 more]</label></div><br/><div class="children"><div class="content">Oh this is really good to know, thank you!</div><br/></div></div></div></div><div id="42055649" class="c"><input type="checkbox" id="c-42055649" checked=""/><div class="controls bullet"><span class="by">binarycoffee</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055110">parent</a><span>|</span><a href="#42055155">prev</a><span>|</span><a href="#42055363">next</a><span>|</span><label class="collapse" for="c-42055649">[-]</label><label class="expand" for="c-42055649">[3 more]</label></div><br/><div class="children"><div class="content">Another offender is AtomicWaker [1] which does the same on contention.<p>[1] <a href="https:&#x2F;&#x2F;docs.rs&#x2F;atomic-waker&#x2F;latest&#x2F;atomic_waker&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;atomic-waker&#x2F;latest&#x2F;atomic_waker&#x2F;</a></div><br/><div id="42056198" class="c"><input type="checkbox" id="c-42056198" checked=""/><div class="controls bullet"><span class="by">SabrinaJewson</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055649">parent</a><span>|</span><a href="#42055363">next</a><span>|</span><label class="collapse" for="c-42056198">[-]</label><label class="expand" for="c-42056198">[2 more]</label></div><br/><div class="children"><div class="content">AtomicWaker is much less bad, because it will only spin in the case that another thread has spuriously called `wake` – i.e. called `wake` despite that fact that the future it’s waking is in fact unable to progress.<p>In the common case, the waker side will operate some logic like:<p><pre><code>    set_flag();
    atomic_waker.wake();
</code></pre>
and the future will run:<p><pre><code>    atomic_waker.register(cx.waker());
    if flag_is_set() {
        Poll::Ready(())
    } else {
        Poll::Pending
    }
</code></pre>
Thus, even if `register` decides to “spin”, the flag will already be set, and so the future will not spin in reality (it may be polled unnecessarily, but this will only happen once).<p>I can’t immediately think of examples where support for spurious waking is necessary.</div><br/><div id="42056410" class="c"><input type="checkbox" id="c-42056410" checked=""/><div class="controls bullet"><span class="by">binarycoffee</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42056198">parent</a><span>|</span><a href="#42055363">next</a><span>|</span><label class="collapse" for="c-42056410">[-]</label><label class="expand" for="c-42056410">[1 more]</label></div><br/><div class="children"><div class="content">The producers of an MPSC queue may use an AtomicWaker::wake to signal to the consumer that a new item is ready. In this case all wake-ups are necessary (not spurious).</div><br/></div></div></div></div></div></div><div id="42055363" class="c"><input type="checkbox" id="c-42055363" checked=""/><div class="controls bullet"><span class="by">jkelleyrtp</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055110">parent</a><span>|</span><a href="#42055649">prev</a><span>|</span><a href="#42055178">next</a><span>|</span><label class="collapse" for="c-42055363">[-]</label><label class="expand" for="c-42055363">[2 more]</label></div><br/><div class="children"><div class="content">Tokio has a task budget that will cap at 32 or 256 polls of the same task before switching to another task. So, yes a spinlock, but not likely to deadlock.</div><br/><div id="42055391" class="c"><input type="checkbox" id="c-42055391" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055363">parent</a><span>|</span><a href="#42055178">next</a><span>|</span><label class="collapse" for="c-42055391">[-]</label><label class="expand" for="c-42055391">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, after looking into this more I think this was a big oversight on my part. Working on a (hopefully) better way of doing this right now - I&#x27;m thinking per-shard waker queues and only falling back to spinlocking like this if the queues are full.</div><br/></div></div></div></div><div id="42055178" class="c"><input type="checkbox" id="c-42055178" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42055015">root</a><span>|</span><a href="#42055110">parent</a><span>|</span><a href="#42055363">prev</a><span>|</span><a href="#42054347">next</a><span>|</span><label class="collapse" for="c-42055178">[-]</label><label class="expand" for="c-42055178">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, imo it&#x27;s definitely better than directly spinlocking to have many spinlocks running cooperatively, but you&#x27;re right that it may not be ideal. Thanks for pointing this out. I&#x27;ll see if I can find a better way to coordinate the polling&#x2F;waking of lock acquisition futures.</div><br/></div></div></div></div></div></div></div></div><div id="42054347" class="c"><input type="checkbox" id="c-42054347" checked=""/><div class="controls bullet"><span class="by">judofyr</span><span>|</span><a href="#42055015">prev</a><span>|</span><a href="#42054331">next</a><span>|</span><label class="collapse" for="c-42054347">[-]</label><label class="expand" for="c-42054347">[4 more]</label></div><br/><div class="children"><div class="content">One thing which wasn’t obvious to me from the benchmark: What’s the key distribution? A sharded map will probably have great performance on uniform keys, but in my experience it’s far more common to have power law distribution in real life scenarios.<p>It would be good to see a benchmark where it only touches a _single_ key. If Whirlwind is still fast than the others I would be far more convinced to use it unconditionally.<p>EDIT: I also see that you&#x27;re benchmarking on a M3 Max. Note that this has 6 performance cores and 6 efficiency cores. This means that if you&#x27;re running at &lt;6 cores it will most likely start out running it at the efficiency core. From my experience it&#x27;s quite important to do warmup phases in order to get stable results at low thread count. And even then I find it hard to reason about the results since you&#x27;re running in mixed set of cores…</div><br/><div id="42054376" class="c"><input type="checkbox" id="c-42054376" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054347">parent</a><span>|</span><a href="#42054331">next</a><span>|</span><label class="collapse" for="c-42054376">[-]</label><label class="expand" for="c-42054376">[3 more]</label></div><br/><div class="children"><div class="content">Definitely a good point. I used dashmap&#x27;s benchmark suite because it was already setup to bench many popular libraries, but I definitely want to get this tested in more varied scenarios. I&#x27;ll try to add a benchmark for a single key only this week.<p>Regarding your edit: damn I hadn&#x27;t thought of that. I&#x27;ll rerun the benchmarks on my Linux desktop with a Ryzen chip and update the readme.</div><br/><div id="42054495" class="c"><input type="checkbox" id="c-42054495" checked=""/><div class="controls bullet"><span class="by">judofyr</span><span>|</span><a href="#42054347">root</a><span>|</span><a href="#42054376">parent</a><span>|</span><a href="#42054331">next</a><span>|</span><label class="collapse" for="c-42054495">[-]</label><label class="expand" for="c-42054495">[2 more]</label></div><br/><div class="children"><div class="content">Very fascinating results though! The sharding approach is quite a simple way of doing more fine-grained locking, making sure that writes don&#x27;t block all the reads. Pretty cool to see that it actually pays off even with the overhead of Tokie scheduling everything!<p>There might be some fairness concerns here? Since we&#x27;re polling the lock (instead of adding ourselves to a queue) it could be the case that some requests are constantly &quot;too late&quot; to acquire it? Could be interesting to see the min&#x2F;max&#x2F;median&#x2F;P99 of the requests themselves. It seems that Bustle only reports the <i>average</i> latency[1] which honestly doesn&#x27;t tell us much more than the throughputs.<p>[1]: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;bustle&#x2F;latest&#x2F;bustle&#x2F;struct.Measurement.html" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;bustle&#x2F;latest&#x2F;bustle&#x2F;struct.Measurement.html</a></div><br/><div id="42054923" class="c"><input type="checkbox" id="c-42054923" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054347">root</a><span>|</span><a href="#42054495">parent</a><span>|</span><a href="#42054331">next</a><span>|</span><label class="collapse" for="c-42054923">[-]</label><label class="expand" for="c-42054923">[1 more]</label></div><br/><div class="children"><div class="content">This is a great point too - I definitely want to run some more varied benchmarks to get a better idea of how this performs in different settings. We&#x27;ll also be using it in prod soon, so we&#x27;ll see how it does in a real use setting too :)</div><br/></div></div></div></div></div></div></div></div><div id="42054331" class="c"><input type="checkbox" id="c-42054331" checked=""/><div class="controls bullet"><span class="by">phlip9</span><span>|</span><a href="#42054347">prev</a><span>|</span><a href="#42054313">next</a><span>|</span><label class="collapse" for="c-42054331">[-]</label><label class="expand" for="c-42054331">[2 more]</label></div><br/><div class="children"><div class="content">Benches look promising! My main concern is validating correctness; implementing good concurrency primitives is always challenging. Have you looked into testing against a purpose-built concurrency model checker like tokio-rs&#x2F;loom [1] or awslabs&#x2F;shuttle [2]? IMO that would go a long way towards building trust in this impl.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;loom">https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;loom</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;shuttle">https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;shuttle</a></div><br/><div id="42054361" class="c"><input type="checkbox" id="c-42054361" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054331">parent</a><span>|</span><a href="#42054313">next</a><span>|</span><label class="collapse" for="c-42054361">[-]</label><label class="expand" for="c-42054361">[1 more]</label></div><br/><div class="children"><div class="content">Yep, someone suggested loom on our Reddit r&#x2F;rust post as well - I&#x27;m actively working on that. Somehow I&#x27;d just never heard of loom before this.</div><br/></div></div></div></div><div id="42054313" class="c"><input type="checkbox" id="c-42054313" checked=""/><div class="controls bullet"><span class="by">olix0r</span><span>|</span><a href="#42054331">prev</a><span>|</span><a href="#42054415">next</a><span>|</span><label class="collapse" for="c-42054313">[-]</label><label class="expand" for="c-42054313">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Just as dashmap is a replacement for std::sync::RwLock&lt;HashMap&gt;, whirlwind aims to be a replacement for tokio::sync::RwLock&lt;HashMap&gt;.<p>I&#x27;m curious about the practical benefits of handling a HashMap with an async interface. My long-standing understanding is that `tokio::sync::RwLock&lt;HashMap&gt;` is only useful when you&#x27;d want to hold the lock guard across another `await` operation; but when the lock guard is not held across an await, it is always preferable to use the synchronous version.<p>This would lead me to assume that same applies for dashmap--it should be sufficient for async use cases and doesn&#x27;t need an async API unless we expect to be blocked, but the benchmarks indicate that whirlwind outperforms dashmap in various situations. Do you have a sense of where this blocking occurs in dashmap?</div><br/><div id="42054350" class="c"><input type="checkbox" id="c-42054350" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054313">parent</a><span>|</span><a href="#42054415">next</a><span>|</span><label class="collapse" for="c-42054350">[-]</label><label class="expand" for="c-42054350">[8 more]</label></div><br/><div class="children"><div class="content">The blocking mainly occurs due to contention - imo most of the performance gain comes from being able to poll the lock instead of blocking until it&#x27;s available when acquiring locks on shards.<p>In all honesty I was quite surprised by the benchmarks as well though, I wouldn&#x27;t expect <i>that</i> much performance gain, but in high-contention scenarios it definitely makes sense.</div><br/><div id="42054966" class="c"><input type="checkbox" id="c-42054966" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#42054313">root</a><span>|</span><a href="#42054350">parent</a><span>|</span><a href="#42054415">next</a><span>|</span><label class="collapse" for="c-42054966">[-]</label><label class="expand" for="c-42054966">[7 more]</label></div><br/><div class="children"><div class="content">Benchmarks will always look good when using a spin-lock like you seem to be using here <a href="https:&#x2F;&#x2F;github.com&#x2F;fortress-build&#x2F;whirlwind&#x2F;blob&#x2F;0e4ae5a2aba14870f64828b7bb3a1059b78bb171&#x2F;src&#x2F;shard&#x2F;futures.rs#L27">https:&#x2F;&#x2F;github.com&#x2F;fortress-build&#x2F;whirlwind&#x2F;blob&#x2F;0e4ae5a2aba...</a></div><br/><div id="42055781" class="c"><input type="checkbox" id="c-42055781" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42054313">root</a><span>|</span><a href="#42054966">parent</a><span>|</span><a href="#42054415">next</a><span>|</span><label class="collapse" for="c-42055781">[-]</label><label class="expand" for="c-42055781">[6 more]</label></div><br/><div class="children"><div class="content">I believe that doesn&#x27;t indicate it&#x27;s spinlocking; the `poll` API is specified to not block.</div><br/><div id="42055911" class="c"><input type="checkbox" id="c-42055911" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#42054313">root</a><span>|</span><a href="#42055781">parent</a><span>|</span><a href="#42054415">next</a><span>|</span><label class="collapse" for="c-42055911">[-]</label><label class="expand" for="c-42055911">[5 more]</label></div><br/><div class="children"><div class="content">&gt; In software engineering, a spinlock is a lock that causes a thread trying to acquire it to simply wait in a loop (&quot;spin&quot;) while repeatedly checking whether the lock is available<p>Immediately waking itself, the task is scheduled and will be polled again shortly. This creates the loop in which is checks if the lock is available. This has no effective difference compared to using hint::spin_loop() but in async.<p>A more traditional lock will use a queue in which the task will not be polled until it&#x27;s likely available, rather than blindly trying on repeat.</div><br/><div id="42056066" class="c"><input type="checkbox" id="c-42056066" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42054313">root</a><span>|</span><a href="#42055911">parent</a><span>|</span><a href="#42054415">next</a><span>|</span><label class="collapse" for="c-42056066">[-]</label><label class="expand" for="c-42056066">[4 more]</label></div><br/><div class="children"><div class="content">The code linked does the following:<p>- attempt to acquire an RWLock  without blocking<p>- if it does, wake the task waiting for the lock<p>- if it doesn&#x27;t, return &quot;not ready yet&quot;<p>The RWLock is straight from the standard lib; there&#x27;s no loop and no spinning involved. Every single Future you look at will look like this, by specification they cannot block, only return &quot;ready&quot; (and wake the task), or return &quot;not ready&quot;.</div><br/><div id="42056120" class="c"><input type="checkbox" id="c-42056120" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#42054313">root</a><span>|</span><a href="#42056066">parent</a><span>|</span><a href="#42056132">next</a><span>|</span><label class="collapse" for="c-42056120">[-]</label><label class="expand" for="c-42056120">[2 more]</label></div><br/><div class="children"><div class="content">By waking itself, the task goes back to the scheduler queue. It then returns pending, going back to the scheduler where it picks a new task. It will eventually pick the scheduled task again and poll the rwlock. This is a loop, even if it&#x27;s a long-winded one, and is by all accounts spinning.<p>It really is not much different to a thread blocking on a loop, where the OS thread scheduler will pre-empt the thread, rescheduling it for later. In this case it&#x27;s an async task instead of a thread, and cooperative instead of preemptive, but it&#x27;s still unfair and not very effective use of scheduler resources</div><br/><div id="42056201" class="c"><input type="checkbox" id="c-42056201" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42054313">root</a><span>|</span><a href="#42056120">parent</a><span>|</span><a href="#42056132">next</a><span>|</span><label class="collapse" for="c-42056201">[-]</label><label class="expand" for="c-42056201">[1 more]</label></div><br/><div class="children"><div class="content">Oh my mistake. I wonder what the benchmarks would look like without the wake loop</div><br/></div></div></div></div><div id="42056132" class="c"><input type="checkbox" id="c-42056132" checked=""/><div class="controls bullet"><span class="by">ibraheemdev</span><span>|</span><a href="#42054313">root</a><span>|</span><a href="#42056066">parent</a><span>|</span><a href="#42056120">prev</a><span>|</span><a href="#42054415">next</a><span>|</span><label class="collapse" for="c-42056132">[-]</label><label class="expand" for="c-42056132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Every single Future you look at will look like this,<p>That&#x27;s not true. A Future is supposed to schedule itself to be woken up again <i>when it&#x27;s ready</i>. This Future schedules it to be woken immediately. Most runtimes, like Tokio, will put a Future that acts like this at the end of the run queue, so in practice it&#x27;s not as egregious. However, it&#x27;s unquestionably a spin lock, equivalent to back off with thread::yield.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42054415" class="c"><input type="checkbox" id="c-42054415" checked=""/><div class="controls bullet"><span class="by">gsliepen</span><span>|</span><a href="#42054313">prev</a><span>|</span><a href="#42054856">next</a><span>|</span><label class="collapse" for="c-42054415">[-]</label><label class="expand" for="c-42054415">[12 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure this library does the thing it claims to do very nicely. However, as a programmer I am saddened that so many things that should have been in the standard library by now need to come from external repositories and have a weird and unintuitive names.</div><br/><div id="42054542" class="c"><input type="checkbox" id="c-42054542" checked=""/><div class="controls bullet"><span class="by">lesuorac</span><span>|</span><a href="#42054415">parent</a><span>|</span><a href="#42054513">next</a><span>|</span><label class="collapse" for="c-42054542">[-]</label><label class="expand" for="c-42054542">[3 more]</label></div><br/><div class="children"><div class="content">I kind of like the &quot;thin&quot; stdlib approach tbh.<p>Rather than having 3-5 ways to do a say a GUI from the stdlib you have 0 and instead you can pick a dependency that suits your way.<p>That then boils down to even data structures, there&#x27;s a bunch of trade-offs to be made where one is better than the other and if Rust had to maintain 30 different types of maps for each use case that seems like a waste of their time. Push that work off to the people that need those maps.</div><br/><div id="42055449" class="c"><input type="checkbox" id="c-42055449" checked=""/><div class="controls bullet"><span class="by">seanw444</span><span>|</span><a href="#42054415">root</a><span>|</span><a href="#42054542">parent</a><span>|</span><a href="#42055023">next</a><span>|</span><label class="collapse" for="c-42055449">[-]</label><label class="expand" for="c-42055449">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m torn. I don&#x27;t write Rust much at all, but I have been playing around with it a little here and there for the last couple years. When I first tried it out, I was shocked that almost nothing I was looking for could be found in the stdlib. I thought I was looking in the wrong place. Coming mostly from the Go world, it was jarring to me when it turned out that out no, it really just barely has a stdlib.<p>Now after on some pondering though, there is a strength in that the Rust team doesn&#x27;t have to focus on maintaining such a large stdlib, as you said. I find myself using external libraries for many things in Go already, so why not just extend that to slightly more fundamental things with lots of variance too.<p>I think the largest downside with this approach, however, is that it&#x27;s hard for me to know what the de facto, collectively-agreed-upon standard is for a given task.</div><br/></div></div><div id="42055023" class="c"><input type="checkbox" id="c-42055023" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054415">root</a><span>|</span><a href="#42054542">parent</a><span>|</span><a href="#42055449">prev</a><span>|</span><a href="#42054513">next</a><span>|</span><label class="collapse" for="c-42055023">[-]</label><label class="expand" for="c-42055023">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this take a lot. I think having lots of custom implementations is inevitable for systems languages - the only reason why Rust is different is because Cargo&#x2F;crates.io makes things available for everyone, where in C&#x2F;C++ land you will often just DIY everything to avoid managing a bunch of dependencies by hand or with cmake&#x2F;similar.</div><br/></div></div></div></div><div id="42054513" class="c"><input type="checkbox" id="c-42054513" checked=""/><div class="controls bullet"><span class="by">ghotli</span><span>|</span><a href="#42054415">parent</a><span>|</span><a href="#42054542">prev</a><span>|</span><a href="#42054461">next</a><span>|</span><label class="collapse" for="c-42054513">[-]</label><label class="expand" for="c-42054513">[1 more]</label></div><br/><div class="children"><div class="content">I try to tell all new programmers that ask me for advice that keeping abreast of the words of tools that are available for use is a big part of the work and shouldn&#x27;t be left out. If I quit my daily &#x2F; weekly trawl of what&#x27;s out there, I&#x27;d surely start to atrophy.</div><br/></div></div><div id="42054461" class="c"><input type="checkbox" id="c-42054461" checked=""/><div class="controls bullet"><span class="by">bryanlarsen</span><span>|</span><a href="#42054415">parent</a><span>|</span><a href="#42054513">prev</a><span>|</span><a href="#42054432">next</a><span>|</span><label class="collapse" for="c-42054461">[-]</label><label class="expand" for="c-42054461">[5 more]</label></div><br/><div class="children"><div class="content">tokio itself is not mature&#x2F;stable enough to be in the standard library, IMO, let alone anything based on tokio.</div><br/><div id="42054531" class="c"><input type="checkbox" id="c-42054531" checked=""/><div class="controls bullet"><span class="by">rsanders</span><span>|</span><a href="#42054415">root</a><span>|</span><a href="#42054461">parent</a><span>|</span><a href="#42054432">next</a><span>|</span><label class="collapse" for="c-42054531">[-]</label><label class="expand" for="c-42054531">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty new to Rust so forgive me if I&#x27;m mistaken, but it seems to me that this crate doesn&#x27;t require the use of tokio.</div><br/><div id="42054547" class="c"><input type="checkbox" id="c-42054547" checked=""/><div class="controls bullet"><span class="by">lesuorac</span><span>|</span><a href="#42054415">root</a><span>|</span><a href="#42054531">parent</a><span>|</span><a href="#42054432">next</a><span>|</span><label class="collapse" for="c-42054547">[-]</label><label class="expand" for="c-42054547">[3 more]</label></div><br/><div class="children"><div class="content">When all the examples are marked with `#[tokio::main]`, it probably requires tokio.<p>Although I guess they do implement Future on their own so it shouldn&#x27;t need a specific runtime then.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;fortress-build&#x2F;whirlwind&#x2F;blob&#x2F;main&#x2F;src&#x2F;shard&#x2F;futures.rs">https:&#x2F;&#x2F;github.com&#x2F;fortress-build&#x2F;whirlwind&#x2F;blob&#x2F;main&#x2F;src&#x2F;sh...</a></div><br/><div id="42054584" class="c"><input type="checkbox" id="c-42054584" checked=""/><div class="controls bullet"><span class="by">macawfish</span><span>|</span><a href="#42054415">root</a><span>|</span><a href="#42054547">parent</a><span>|</span><a href="#42054621">next</a><span>|</span><label class="collapse" for="c-42054584">[-]</label><label class="expand" for="c-42054584">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re just using tokio as a dev dependency. You could use this with any async runtime<p><a href="https:&#x2F;&#x2F;github.com&#x2F;fortress-build&#x2F;whirlwind&#x2F;blob&#x2F;main&#x2F;Cargo.toml#L14">https:&#x2F;&#x2F;github.com&#x2F;fortress-build&#x2F;whirlwind&#x2F;blob&#x2F;main&#x2F;Cargo....</a></div><br/></div></div><div id="42054621" class="c"><input type="checkbox" id="c-42054621" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054415">root</a><span>|</span><a href="#42054547">parent</a><span>|</span><a href="#42054584">prev</a><span>|</span><a href="#42054432">next</a><span>|</span><label class="collapse" for="c-42054621">[-]</label><label class="expand" for="c-42054621">[1 more]</label></div><br/><div class="children"><div class="content">Tokio is just used for async tests and the examples, the crate doesn’t depend on any specific async runtime :)</div><br/></div></div></div></div></div></div></div></div><div id="42054432" class="c"><input type="checkbox" id="c-42054432" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054415">parent</a><span>|</span><a href="#42054461">prev</a><span>|</span><a href="#42054588">next</a><span>|</span><label class="collapse" for="c-42054432">[-]</label><label class="expand" for="c-42054432">[1 more]</label></div><br/><div class="children"><div class="content">Hey, I think the name is cool!<p>Fair point though, there would definitely be some benefit to having some of these things in the stdlib.</div><br/></div></div><div id="42054588" class="c"><input type="checkbox" id="c-42054588" checked=""/><div class="controls bullet"><span class="by">schainks</span><span>|</span><a href="#42054415">parent</a><span>|</span><a href="#42054432">prev</a><span>|</span><a href="#42054856">next</a><span>|</span><label class="collapse" for="c-42054588">[-]</label><label class="expand" for="c-42054588">[1 more]</label></div><br/><div class="children"><div class="content">The teams who compile the standard libraries are still made up of people, and sometimes better libraries get written outside of those teams. It&#x27;s just a natural consequence of the intense collaboration we have in this industry. In fact, I am GLAD things happen this way, because it shows how flexible and open minded folks are when it comes to such libraries.<p>Naming things is... well, you know...</div><br/></div></div></div></div><div id="42054856" class="c"><input type="checkbox" id="c-42054856" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#42054415">prev</a><span>|</span><a href="#42054146">next</a><span>|</span><label class="collapse" for="c-42054856">[-]</label><label class="expand" for="c-42054856">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This crate is in development, and breaking changes may be made up until a 1.0 release.<p>When will this happen? I imagine a lot of people who want use it might just forget about it if you say &quot;do not use this until some unspecified point in the future&quot;.</div><br/><div id="42054869" class="c"><input type="checkbox" id="c-42054869" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054856">parent</a><span>|</span><a href="#42054146">next</a><span>|</span><label class="collapse" for="c-42054869">[-]</label><label class="expand" for="c-42054869">[2 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a pretty big difference between committing to semantic versioning and saying &quot;do not use this until some unspecified point in the future.&quot; Maybe I&#x27;m just not clear enough in the note - I just mean that the API could change. But as long as a consumer doesn&#x27;t use `version = &quot;*&quot;` in their Cargo.toml, breaking changes will always be opt-in and builds won&#x27;t start failing if I release something with a big API change.</div><br/><div id="42055881" class="c"><input type="checkbox" id="c-42055881" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#42054856">root</a><span>|</span><a href="#42054869">parent</a><span>|</span><a href="#42054146">next</a><span>|</span><label class="collapse" for="c-42055881">[-]</label><label class="expand" for="c-42055881">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m a bit weird, but I would never commit to using something if the person making it wasn&#x27;t providing a consistent interface. It could well be different in your case, but as a general rule, a sub 1.0 version is software that isn&#x27;t yet ready to be used. The vast vast majority of projects that say &quot;you can use this, but we won&#x27;t provide a consistent interface yet&quot; end up either dying before they get to v1 or causing so much pain they weren&#x27;t worth using. I can see this issue being especially bad in Rust, where small API changes can create big issues with lifetimes and such.</div><br/></div></div></div></div></div></div><div id="42054146" class="c"><input type="checkbox" id="c-42054146" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#42054856">prev</a><span>|</span><a href="#42054362">next</a><span>|</span><label class="collapse" for="c-42054146">[-]</label><label class="expand" for="c-42054146">[2 more]</label></div><br/><div class="children"><div class="content">Looks interesting! We used quick-cache [1] for that purpose right now, might be interesting to add comparison with those types of Key-Value caching crates.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;arthurprs&#x2F;quick-cache">https:&#x2F;&#x2F;github.com&#x2F;arthurprs&#x2F;quick-cache</a></div><br/><div id="42054161" class="c"><input type="checkbox" id="c-42054161" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054146">parent</a><span>|</span><a href="#42054362">next</a><span>|</span><label class="collapse" for="c-42054161">[-]</label><label class="expand" for="c-42054161">[1 more]</label></div><br/><div class="children"><div class="content">Good point, thanks! I&#x27;ll look into adding that crate to the benchmarks.</div><br/></div></div></div></div><div id="42054362" class="c"><input type="checkbox" id="c-42054362" checked=""/><div class="controls bullet"><span class="by">shepardrtc</span><span>|</span><a href="#42054146">prev</a><span>|</span><a href="#42054916">next</a><span>|</span><label class="collapse" for="c-42054362">[-]</label><label class="expand" for="c-42054362">[3 more]</label></div><br/><div class="children"><div class="content">How do you determine the number of shards to use?</div><br/><div id="42054391" class="c"><input type="checkbox" id="c-42054391" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054362">parent</a><span>|</span><a href="#42054392">next</a><span>|</span><label class="collapse" for="c-42054391">[-]</label><label class="expand" for="c-42054391">[1 more]</label></div><br/><div class="children"><div class="content">I use a multiple of `std::thread::available_paralellism()`. Tbh I borrowed the strategy from dashmap, but I tested others and this seemed to work quite well. Considering making that configurable in the future so that it can be specialized for different use-cases or used in single-threaded but cooperatively scheduled contexts.</div><br/></div></div><div id="42054392" class="c"><input type="checkbox" id="c-42054392" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#42054362">parent</a><span>|</span><a href="#42054391">prev</a><span>|</span><a href="#42054916">next</a><span>|</span><label class="collapse" for="c-42054392">[-]</label><label class="expand" for="c-42054392">[1 more]</label></div><br/><div class="children"><div class="content">(std::thread::available_parallelism().map_or(1, usize::from) * 4).next_power_of_two()</div><br/></div></div></div></div><div id="42054916" class="c"><input type="checkbox" id="c-42054916" checked=""/><div class="controls bullet"><span class="by">KolmogorovComp</span><span>|</span><a href="#42054362">prev</a><span>|</span><a href="#42056087">next</a><span>|</span><label class="collapse" for="c-42054916">[-]</label><label class="expand" for="c-42054916">[4 more]</label></div><br/><div class="children"><div class="content">Great crate! Why use a hashmap instead of a Btreemap which is usually advised in rust?</div><br/><div id="42054959" class="c"><input type="checkbox" id="c-42054959" checked=""/><div class="controls bullet"><span class="by">willothy</span><span>|</span><a href="#42054916">parent</a><span>|</span><a href="#42054957">next</a><span>|</span><label class="collapse" for="c-42054959">[-]</label><label class="expand" for="c-42054959">[1 more]</label></div><br/><div class="children"><div class="content">There are a few reasons - For one, I&#x27;m not sure BTreeMap is always faster in Rust... it may be sometimes but lookups are still O(log(n)) due to the searching where with a HashMap it&#x27;s (mostly) O(1). They both have their uses - I usually go for BTreeMap when I explicitly need the collection to be ordered.<p>A second reason is sharding - sharding based on a hash is quite simple to do, but sharding an ordered collection would be quite difficult since some reads would need to search across multiple shards and thus take multiple locks.<p>If you mean internally (like for each shard), we&#x27;re using hashbrown&#x27;s raw HashTable API because it allows us to manage hashing entirely ourselves, and avoid recomputing the hash when determining the shard and looking up a key within a shard.</div><br/></div></div><div id="42054957" class="c"><input type="checkbox" id="c-42054957" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#42054916">parent</a><span>|</span><a href="#42054959">prev</a><span>|</span><a href="#42056052">next</a><span>|</span><label class="collapse" for="c-42054957">[-]</label><label class="expand" for="c-42054957">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why use a hashmap instead of a Btreemap which is usually advised in rust?<p>Is this actually the case? I can&#x27;t say I&#x27;ve seen the same.</div><br/></div></div><div id="42056052" class="c"><input type="checkbox" id="c-42056052" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#42054916">parent</a><span>|</span><a href="#42054957">prev</a><span>|</span><a href="#42056087">next</a><span>|</span><label class="collapse" for="c-42056052">[-]</label><label class="expand" for="c-42056052">[1 more]</label></div><br/><div class="children"><div class="content">Why would you use a b tree if you don&#x27;t need sorting? It will not only be slower but require a lot more to make lock free (is this hash map lock free?).</div><br/></div></div></div></div></div></div></div></div></div></body></html>