<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714899712614" as="style"/><link rel="stylesheet" href="styles.css?v=1714899712614"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.cprover.org/cbmc/">CBMC: C bounded model checker (2021)</a>Â <span class="domain">(<a href="http://www.cprover.org">www.cprover.org</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>29 comments</span></div><br/><div><div id="40260372" class="c"><input type="checkbox" id="c-40260372" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#40260048">next</a><span>|</span><label class="collapse" for="c-40260372">[-]</label><label class="expand" for="c-40260372">[4 more]</label></div><br/><div class="children"><div class="content">I have been using CBMC to formally verify C for six, make that seven years now (edit: time flies). The latest release is actually pretty good.<p>The secret to model checking is to understand that you&#x27;re building and verifying a specification in code. It works best if specifications are built function by function. For each function, I&#x27;ll build &quot;shadow functions&quot; that simplify any functions it calls with a range of potential non-deterministic behavior that matches that function&#x27;s contract. In this way, formal specifications can be built from the ground up by first verifying a lower-level function and then replacing it with a shadow function that mimics its behavior in a non-deterministic but SMT solver friendly way.<p>There are things that model checking doesn&#x27;t do well. Anything with recursion or looping that can&#x27;t be easily broken down will not perform well with a model checker. While algorithms like balanced binary trees or sorting can be broken down in a way that can be model checked, other algorithms may require the sort of induction one gets with constructive proofs to sufficiently verify. There is an art to this which will lead to style changes in C and a slightly different way of building up functions from pieces that can be trivially model checked. Honestly, that&#x27;s not a bad thing.<p>For the parts that can&#x27;t be easily model checked, I&#x27;m working on a C parser library that can be formally verified, which will import C directly into Coq or Lean. I consider that the &quot;last mile&quot; before formal methods in firmware and system software is to the point that it&#x27;s generally available.</div><br/><div id="40262508" class="c"><input type="checkbox" id="c-40262508" checked=""/><div class="controls bullet"><span class="by">tooltower</span><span>|</span><a href="#40260372">parent</a><span>|</span><a href="#40261131">next</a><span>|</span><label class="collapse" for="c-40262508">[-]</label><label class="expand" for="c-40262508">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  [...] other algorithms may require the sort of induction one gets with constructive proofs to sufficiently verify. There is an art to this which will lead to style changes in C and a slightly different way of building up functions from pieces that can be trivially model checked.<p>Is there a book or article that talks more about this? I.e. how to write code in a way that is more amenable to model-checking (bounded or otherwise)?</div><br/></div></div><div id="40261131" class="c"><input type="checkbox" id="c-40261131" checked=""/><div class="controls bullet"><span class="by">zzz95</span><span>|</span><a href="#40260372">parent</a><span>|</span><a href="#40262508">prev</a><span>|</span><a href="#40260048">next</a><span>|</span><label class="collapse" for="c-40261131">[-]</label><label class="expand" for="c-40261131">[2 more]</label></div><br/><div class="children"><div class="content">I am very curious about what kind of industry domains lets you have this kind of fun? Unless of course, you are in academia.</div><br/><div id="40262558" class="c"><input type="checkbox" id="c-40262558" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40260372">root</a><span>|</span><a href="#40261131">parent</a><span>|</span><a href="#40260048">next</a><span>|</span><label class="collapse" for="c-40262558">[-]</label><label class="expand" for="c-40262558">[1 more]</label></div><br/><div class="children"><div class="content">Not fun, a serious tool, and extremely easy to use, unlike other formal methods. It works with your source code, not on some rewritten abstraction of it.<p>Embedded, automotive, space use it regularly.<p>I&#x27;ve setup cbmc and goto-analyzer for string searching algos here <a href="https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;smart">https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;smart</a> and really found some bugs in old published algos.</div><br/></div></div></div></div></div></div><div id="40260048" class="c"><input type="checkbox" id="c-40260048" checked=""/><div class="controls bullet"><span class="by">xxmarkuski</span><span>|</span><a href="#40260372">prev</a><span>|</span><a href="#40258500">next</a><span>|</span><label class="collapse" for="c-40260048">[-]</label><label class="expand" for="c-40260048">[1 more]</label></div><br/><div class="children"><div class="content">CBMC ist pretty cool, I&#x27;ve used it in my bachelor&#x27;s thesis for verification of fairness properties in proportional voting. Another use case I&#x27;ve seen is using CBMC in multiparty computation. What you have there is methods that work on boolean circuits. Flange CBMC in front of this and you got multiparty computation of C code.</div><br/></div></div><div id="40258500" class="c"><input type="checkbox" id="c-40258500" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#40260048">prev</a><span>|</span><a href="#40258738">next</a><span>|</span><label class="collapse" for="c-40258500">[-]</label><label class="expand" for="c-40258500">[11 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t this project be more usefully done at the LLVM IR level so we could plug in any existing LLVM frontend and gain full support for language features like C++ templates?</div><br/><div id="40258536" class="c"><input type="checkbox" id="c-40258536" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40258500">parent</a><span>|</span><a href="#40258698">next</a><span>|</span><label class="collapse" for="c-40258536">[-]</label><label class="expand" for="c-40258536">[1 more]</label></div><br/><div class="children"><div class="content">My guess is that LLVM IR preserves too little semantic information to implement such a feature.</div><br/></div></div><div id="40258698" class="c"><input type="checkbox" id="c-40258698" checked=""/><div class="controls bullet"><span class="by">rjmunro</span><span>|</span><a href="#40258500">parent</a><span>|</span><a href="#40258536">prev</a><span>|</span><a href="#40259291">next</a><span>|</span><label class="collapse" for="c-40258698">[-]</label><label class="expand" for="c-40258698">[3 more]</label></div><br/><div class="children"><div class="content">I think the LLVM level doesn&#x27;t work as it throws away too much semantic information, but much of the CLANG front end can be used via it&#x27;s API.<p>There is a fork of CBMC called ESBMC that does this and many other changes: <a href="https:&#x2F;&#x2F;ssvlab.github.io&#x2F;esbmc&#x2F;documentation.html" rel="nofollow">https:&#x2F;&#x2F;ssvlab.github.io&#x2F;esbmc&#x2F;documentation.html</a></div><br/><div id="40258740" class="c"><input type="checkbox" id="c-40258740" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#40258500">root</a><span>|</span><a href="#40258698">parent</a><span>|</span><a href="#40259291">next</a><span>|</span><label class="collapse" for="c-40258740">[-]</label><label class="expand" for="c-40258740">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious about what relevant details get thrown away in translation to LLVM IR and that we can&#x27;t add back with annotations. It&#x27;s a shame that it&#x27;s not possible to use these analysis tools on modern C++ codebases.</div><br/><div id="40259221" class="c"><input type="checkbox" id="c-40259221" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#40258500">root</a><span>|</span><a href="#40258740">parent</a><span>|</span><a href="#40259291">next</a><span>|</span><label class="collapse" for="c-40259221">[-]</label><label class="expand" for="c-40259221">[1 more]</label></div><br/><div class="children"><div class="content">Undefined behavior around void pointers springs to mind.</div><br/></div></div></div></div></div></div><div id="40259291" class="c"><input type="checkbox" id="c-40259291" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#40258500">parent</a><span>|</span><a href="#40258698">prev</a><span>|</span><a href="#40258614">next</a><span>|</span><label class="collapse" for="c-40259291">[-]</label><label class="expand" for="c-40259291">[2 more]</label></div><br/><div class="children"><div class="content">klee is a similar tool that operates on llvm bytecode: <a href="http:&#x2F;&#x2F;klee-se.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;klee-se.org&#x2F;</a></div><br/><div id="40262088" class="c"><input type="checkbox" id="c-40262088" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#40258500">root</a><span>|</span><a href="#40259291">parent</a><span>|</span><a href="#40258614">next</a><span>|</span><label class="collapse" for="c-40262088">[-]</label><label class="expand" for="c-40262088">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t work on real software though. Anything non-trivial.</div><br/></div></div></div></div><div id="40258614" class="c"><input type="checkbox" id="c-40258614" checked=""/><div class="controls bullet"><span class="by">SnowflakeOnIce</span><span>|</span><a href="#40258500">parent</a><span>|</span><a href="#40259291">prev</a><span>|</span><a href="#40258913">next</a><span>|</span><label class="collapse" for="c-40258614">[-]</label><label class="expand" for="c-40258614">[1 more]</label></div><br/><div class="children"><div class="content">It predates LLVM. That&#x27;s one reason, anyway.</div><br/></div></div><div id="40258913" class="c"><input type="checkbox" id="c-40258913" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#40258500">parent</a><span>|</span><a href="#40258614">prev</a><span>|</span><a href="#40258738">next</a><span>|</span><label class="collapse" for="c-40258913">[-]</label><label class="expand" for="c-40258913">[3 more]</label></div><br/><div class="children"><div class="content">Another problem with LLVM Iâve heard about is that itâs intermediate language or API or something is a moving, informally-specified target. People who know LLVM internals might weigh in on that claim. If true, itâs actually easier to target C or a subset of Rust just because itâs static and well-understood.<p>Two projects sought to mitigate these issues by going in different directions. One was a compiler backend that aimed to be easy to learn with well-specified IL. The other aimed to formalize LLVMâs IL.<p><a href="http:&#x2F;&#x2F;c9x.me&#x2F;compile&#x2F;" rel="nofollow">http:&#x2F;&#x2F;c9x.me&#x2F;compile&#x2F;</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;AliveToolkit&#x2F;alive2">https:&#x2F;&#x2F;github.com&#x2F;AliveToolkit&#x2F;alive2</a><p>There have also been typed, assembly languages to support verification from groups like FLINT. One can also compile language-specific analysis with a certified to LLVM IL compiler. Integrating pieces from different languages can have risks. That (IIRC) is being mitigated by people doing secure, abstract compilation.</div><br/><div id="40262113" class="c"><input type="checkbox" id="c-40262113" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#40258500">root</a><span>|</span><a href="#40258913">parent</a><span>|</span><a href="#40258738">next</a><span>|</span><label class="collapse" for="c-40262113">[-]</label><label class="expand" for="c-40262113">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the textual IR format is not an API. It&#x27;s an internal implementation detail which changes somewhat rapidly. It&#x27;s well specified but there&#x27;s no guarantees that if you write some IR which works in LLVM 16 that it&#x27;ll work as expected in LLVM 17, etc. Inside of LLVM itself IR and its related manipulation and analysis functions are &quot;API&quot; in so far as there&#x27;s an expectation that if you change how the IR works that you won&#x27;t break existing in-tree passes&#x2F;that you&#x27;ll work with maintainers to fix them.</div><br/><div id="40262133" class="c"><input type="checkbox" id="c-40262133" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#40258500">root</a><span>|</span><a href="#40262113">parent</a><span>|</span><a href="#40258738">next</a><span>|</span><label class="collapse" for="c-40262133">[-]</label><label class="expand" for="c-40262133">[1 more]</label></div><br/><div class="children"><div class="content">That makes more sense. Thanks!</div><br/></div></div></div></div></div></div></div></div><div id="40258738" class="c"><input type="checkbox" id="c-40258738" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40258500">prev</a><span>|</span><a href="#40259450">next</a><span>|</span><label class="collapse" for="c-40258738">[-]</label><label class="expand" for="c-40258738">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used this before. It&#x27;s pretty great. Also used as the backend for Kani I believe (Amazon&#x27;s Rust formal verification tool).</div><br/><div id="40260208" class="c"><input type="checkbox" id="c-40260208" checked=""/><div class="controls bullet"><span class="by">mrnoone</span><span>|</span><a href="#40258738">parent</a><span>|</span><a href="#40259132">next</a><span>|</span><label class="collapse" for="c-40260208">[-]</label><label class="expand" for="c-40260208">[1 more]</label></div><br/><div class="children"><div class="content">Some other tool (Coq-based) to formally verify unsafe Rust <a href="https:&#x2F;&#x2F;gitlab.mpi-sws.org&#x2F;lgaeher&#x2F;refinedrust-dev" rel="nofollow">https:&#x2F;&#x2F;gitlab.mpi-sws.org&#x2F;lgaeher&#x2F;refinedrust-dev</a></div><br/></div></div><div id="40259132" class="c"><input type="checkbox" id="c-40259132" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#40258738">parent</a><span>|</span><a href="#40260208">prev</a><span>|</span><a href="#40259450">next</a><span>|</span><label class="collapse" for="c-40259132">[-]</label><label class="expand" for="c-40259132">[6 more]</label></div><br/><div class="children"><div class="content">This is achieved by latching on to rustc, and then compiling to gotoc, which is then used with CBMC.<p>Removed due to my misunderstanding:<p>~~I don&#x27;t think Kani counts as a &quot;formal&quot; verification tool, emphasis on &quot;formal&quot;, but it is a verification tool for rust code and is powered by CBMC.~~</div><br/><div id="40259254" class="c"><input type="checkbox" id="c-40259254" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40258738">root</a><span>|</span><a href="#40259132">parent</a><span>|</span><a href="#40259450">next</a><span>|</span><label class="collapse" for="c-40259254">[-]</label><label class="expand" for="c-40259254">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you&#x27;re implying. Kani absolutely is formal verification. CBMC stands for C Bounded Model Checker and model checking is one of the main forms of formal verification.</div><br/><div id="40259311" class="c"><input type="checkbox" id="c-40259311" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#40258738">root</a><span>|</span><a href="#40259254">parent</a><span>|</span><a href="#40259450">next</a><span>|</span><label class="collapse" for="c-40259311">[-]</label><label class="expand" for="c-40259311">[4 more]</label></div><br/><div class="children"><div class="content">Edit:<p>Seems like I misread the documentation...<p>~~What I was implying is that Kani just can&#x27;t figure out all of the paths;~~
~~Consider this example from Kani documentation [1]:~~<p><pre><code>    fn estimate_size(x: u32) -&gt; u32 {
       if x &lt; 256 {
            if x &lt; 128 {
                return 1;
            } else {
                return 3;
            }
        } else if x &lt; 1024 {
            if x &gt; 1022 {
                panic!(&quot;Oh no, a failing corner case!&quot;);
            } else {
                return 5;
            }
        } else {
            if x &lt; 2048 {
                return 7;
            } else {
                return 9;
            }
        }
    }
</code></pre>
~~Kani is very unlikely to find x=1023.~~<p><a href="https:&#x2F;&#x2F;model-checking.github.io&#x2F;kani&#x2F;tutorial-first-steps.html" rel="nofollow">https:&#x2F;&#x2F;model-checking.github.io&#x2F;kani&#x2F;tutorial-first-steps.h...</a></div><br/><div id="40259340" class="c"><input type="checkbox" id="c-40259340" checked=""/><div class="controls bullet"><span class="by">accelbred</span><span>|</span><a href="#40258738">root</a><span>|</span><a href="#40259311">parent</a><span>|</span><a href="#40259707">next</a><span>|</span><label class="collapse" for="c-40259340">[-]</label><label class="expand" for="c-40259340">[1 more]</label></div><br/><div class="children"><div class="content">Kani will find 1023 unless you constrain the input. The link you posted is saying a property test is unlikely to find it but Kani will find it.</div><br/></div></div><div id="40259707" class="c"><input type="checkbox" id="c-40259707" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40258738">root</a><span>|</span><a href="#40259311">parent</a><span>|</span><a href="#40259340">prev</a><span>|</span><a href="#40259450">next</a><span>|</span><label class="collapse" for="c-40259707">[-]</label><label class="expand" for="c-40259707">[2 more]</label></div><br/><div class="children"><div class="content">Yeah you misread that. Read it again, it&#x27;s saying normal fuzzing is unlikely to find it but Kani finds it instantly.</div><br/><div id="40259732" class="c"><input type="checkbox" id="c-40259732" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#40258738">root</a><span>|</span><a href="#40259707">parent</a><span>|</span><a href="#40259450">next</a><span>|</span><label class="collapse" for="c-40259732">[-]</label><label class="expand" for="c-40259732">[1 more]</label></div><br/><div class="children"><div class="content">Oh this is embarrassing.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40259450" class="c"><input type="checkbox" id="c-40259450" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#40258738">prev</a><span>|</span><a href="#40259120">next</a><span>|</span><label class="collapse" for="c-40259450">[-]</label><label class="expand" for="c-40259450">[2 more]</label></div><br/><div class="children"><div class="content">How does this compare to scan-build, clazy etc.?</div><br/><div id="40259800" class="c"><input type="checkbox" id="c-40259800" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40259450">parent</a><span>|</span><a href="#40259120">next</a><span>|</span><label class="collapse" for="c-40259800">[-]</label><label class="expand" for="c-40259800">[1 more]</label></div><br/><div class="children"><div class="content">Those are different kinds of tools. Clazy is pretty much a linter. Scan-build is a traditional static analyser. It tries to find bugs or possible bugs but it&#x27;s not trying to disprove the presence of bugs.<p>CBMC is a formal verification tool which tries to <i>prove</i> that there aren&#x27;t any bugs (where &quot;bugs&quot; means things like UB).</div><br/></div></div></div></div><div id="40259120" class="c"><input type="checkbox" id="c-40259120" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#40259450">prev</a><span>|</span><label class="collapse" for="c-40259120">[-]</label><label class="expand" for="c-40259120">[2 more]</label></div><br/><div class="children"><div class="content">CBMC also powers Kani &lt;3</div><br/></div></div></div></div></div></div></div></body></html>