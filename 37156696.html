<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692262859981" as="style"/><link rel="stylesheet" href="styles.css?v=1692262859981"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jeremykun.com/2017/12/29/np-hard-does-not-mean-hard/">NP-hard does not mean hard (2017)</a>Â <span class="domain">(<a href="https://jeremykun.com">jeremykun.com</a>)</span></div><div class="subtext"><span>stefanpie</span> | <span>60 comments</span></div><br/><div><div id="37157112" class="c"><input type="checkbox" id="c-37157112" checked=""/><div class="controls bullet"><span class="by">lambda</span><span>|</span><a href="#37158228">next</a><span>|</span><label class="collapse" for="c-37157112">[-]</label><label class="expand" for="c-37157112">[20 more]</label></div><br/><div class="children"><div class="content">Corollary: P does not mean easy.<p>Most things that you do on the computer, you want to be O(n) or less; maybe O(n log n) or even O(n log^x n), but no slower than that. That means if you get a bigger problem, you can generally just get a proportionally bigger computer and be all set.<p>Now, sure, there are plenty of O(n^2) problems where the n stays small enough, or you don&#x27;t mind waiting or spending a ton of money on it. But just because something is in P doesn&#x27;t mean that you want to be solving it with a polynomial time algorithm on a regular basis.</div><br/><div id="37157709" class="c"><input type="checkbox" id="c-37157709" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#37157112">parent</a><span>|</span><a href="#37157351">next</a><span>|</span><label class="collapse" for="c-37157709">[-]</label><label class="expand" for="c-37157709">[5 more]</label></div><br/><div class="children"><div class="content">Our CS-Prof also had another interesting point: P = NP could be true without changing many things in reality.<p>This could occur if the reduction of an NP-complete problem onto a polynomial problem results in a runtime of such monstrous polynomial degree that the exponential algorithms are just faster for every tractable problem size. Something like this exists in some graph algorithms - theoretically faster algorithms exist, but in practice, they are a lot slower than the theoretically slower algorithm until completely silly graph sizes.<p>This could turn even more frustrating if the proof was nonconstructive.</div><br/><div id="37158699" class="c"><input type="checkbox" id="c-37158699" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157709">parent</a><span>|</span><a href="#37157781">next</a><span>|</span><label class="collapse" for="c-37158699">[-]</label><label class="expand" for="c-37158699">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This could occur if the reduction of an NP-complete problem onto a polynomial problem results in a runtime of such monstrous polynomial degree that the exponential algorithms are just faster for every tractable problem size.<p>You don&#x27;t even need to go that far.<p>n^8 is smaller than 2^n once you get past 44, still well in the tractable range, but encrypting something against n^8 brute force is a pretty reasonable task.</div><br/></div></div><div id="37157781" class="c"><input type="checkbox" id="c-37157781" checked=""/><div class="controls bullet"><span class="by">adalacelove</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157709">parent</a><span>|</span><a href="#37158699">prev</a><span>|</span><a href="#37158417">next</a><span>|</span><label class="collapse" for="c-37157781">[-]</label><label class="expand" for="c-37157781">[2 more]</label></div><br/><div class="children"><div class="content">Staying in the realm of polynomial complexity matrix multiplication comes to mind, where we are approaching more and more O(n^2), where O(n^3) is the naive, but more common implementation.</div><br/><div id="37158711" class="c"><input type="checkbox" id="c-37158711" checked=""/><div class="controls bullet"><span class="by">shenberg</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157781">parent</a><span>|</span><a href="#37158417">next</a><span>|</span><label class="collapse" for="c-37158711">[-]</label><label class="expand" for="c-37158711">[1 more]</label></div><br/><div class="children"><div class="content">In terms of practical algorithms, the Strassen algorithm (O(n^2.8)) is the only one that has runtime advantages for matrix sizes that aren&#x27;t enormous, and even then, it&#x27;s not always used because it has two non-trivial costs: reduced numerical stability and more memory space requirements for intermediate results.</div><br/></div></div></div></div><div id="37158417" class="c"><input type="checkbox" id="c-37158417" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157709">parent</a><span>|</span><a href="#37157781">prev</a><span>|</span><a href="#37157351">next</a><span>|</span><label class="collapse" for="c-37158417">[-]</label><label class="expand" for="c-37158417">[1 more]</label></div><br/><div class="children"><div class="content">This is similar to Knuth&#x27;s reasoning for P=NP. Essentially there might be algorithms for these problems that are simply so complex that we might never know them.</div><br/></div></div></div></div><div id="37157351" class="c"><input type="checkbox" id="c-37157351" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#37157112">parent</a><span>|</span><a href="#37157709">prev</a><span>|</span><a href="#37158909">next</a><span>|</span><label class="collapse" for="c-37157351">[-]</label><label class="expand" for="c-37157351">[3 more]</label></div><br/><div class="children"><div class="content">A terrific teardown of tracking down an unexpected O(n^2): <a href="https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2021&#x2F;02&#x2F;16&#x2F;arranging-invisible-icons-in-quadratic-time&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2021&#x2F;02&#x2F;16&#x2F;arranging-invis...</a></div><br/><div id="37158744" class="c"><input type="checkbox" id="c-37158744" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157351">parent</a><span>|</span><a href="#37158005">next</a><span>|</span><label class="collapse" for="c-37158744">[-]</label><label class="expand" for="c-37158744">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;accidentally quadratic&quot; blog collected such things. Not sure if it&#x27;s still being updated since Tumblr&#x27;s mass exodus (the posts don&#x27;t seem to show timestamps) <a href="https:&#x2F;&#x2F;accidentallyquadratic.tumblr.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;accidentallyquadratic.tumblr.com</a></div><br/></div></div><div id="37158005" class="c"><input type="checkbox" id="c-37158005" checked=""/><div class="controls bullet"><span class="by">gdprrrr</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157351">parent</a><span>|</span><a href="#37158744">prev</a><span>|</span><a href="#37158909">next</a><span>|</span><label class="collapse" for="c-37158005">[-]</label><label class="expand" for="c-37158005">[1 more]</label></div><br/><div class="children"><div class="content">Also reminds me of the GTA online case.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26296339">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26296339</a></div><br/></div></div></div></div><div id="37158909" class="c"><input type="checkbox" id="c-37158909" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#37157112">parent</a><span>|</span><a href="#37157351">prev</a><span>|</span><a href="#37157545">next</a><span>|</span><label class="collapse" for="c-37158909">[-]</label><label class="expand" for="c-37158909">[1 more]</label></div><br/><div class="children"><div class="content">Matrix multiplication is O(n^2.73) time and O(n^2) space. That&#x27;s what eats bigger and bigger chunk of electricity nowadays.</div><br/></div></div><div id="37157545" class="c"><input type="checkbox" id="c-37157545" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37157112">parent</a><span>|</span><a href="#37158909">prev</a><span>|</span><a href="#37158228">next</a><span>|</span><label class="collapse" for="c-37157545">[-]</label><label class="expand" for="c-37157545">[10 more]</label></div><br/><div class="children"><div class="content">Interestingly being P complete has another unexpected consequence: it means your problem is going to be difficult to parallelize.<p>This is why parallel SAT solvers are barely faster than the usual ones.<p>SAT is NP complete, but a crucial step in SAT solving (unit propagation) is P complete.</div><br/><div id="37157572" class="c"><input type="checkbox" id="c-37157572" checked=""/><div class="controls bullet"><span class="by">s1dev</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157545">parent</a><span>|</span><a href="#37158228">next</a><span>|</span><label class="collapse" for="c-37157572">[-]</label><label class="expand" for="c-37157572">[9 more]</label></div><br/><div class="children"><div class="content">Is there some good intuition why P-complete problems are difficult to parallelize? This is the first I&#x27;ve heard of it (but then again, I&#x27;m usually interested in more obscure complexity classes)</div><br/><div id="37157759" class="c"><input type="checkbox" id="c-37157759" checked=""/><div class="controls bullet"><span class="by">Cerium</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157572">parent</a><span>|</span><a href="#37157757">next</a><span>|</span><label class="collapse" for="c-37157759">[-]</label><label class="expand" for="c-37157759">[5 more]</label></div><br/><div class="children"><div class="content">This is the first I have heard of it as well (and I have properly studied NP complete in graph theory, so I don&#x27;t know why this missed my attention). It seems that P-complete are difficult to parallelize by definition as they are the set of tractable problems (as opposed to NP) which don&#x27;t parallelize well.<p>&quot;The class P, typically taken to consist of all the &quot;tractable&quot; problems for a sequential computer, contains the class NC, which consists of those problems which can be efficiently solved on a parallel computer. This is because parallel computers can be simulated on a sequential machine. It is not known whether NC = P. In other words, it is not known whether there are any tractable problems that are inherently sequential. &quot; From: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;P-complete" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;P-complete</a></div><br/><div id="37157787" class="c"><input type="checkbox" id="c-37157787" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157759">parent</a><span>|</span><a href="#37157757">next</a><span>|</span><label class="collapse" for="c-37157787">[-]</label><label class="expand" for="c-37157787">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not by definition, there&#x27;s a bit of math behind it! :)<p>The intuition is that the hardest problems in P have linear dependency chains.  
If you could have a good parallel algorithm for a P complete problem, you could take a problem with a dependency chain and solve parts of it in parallel without waiting for the results those parts are depending on.</div><br/><div id="37158351" class="c"><input type="checkbox" id="c-37158351" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157787">parent</a><span>|</span><a href="#37158118">next</a><span>|</span><label class="collapse" for="c-37158351">[-]</label><label class="expand" for="c-37158351">[1 more]</label></div><br/><div class="children"><div class="content">There is an easy daily example: the PBKDF function, the whole point of which is to be expensive to compute, and impossible to efficiently parallelize.</div><br/></div></div><div id="37158118" class="c"><input type="checkbox" id="c-37158118" checked=""/><div class="controls bullet"><span class="by">gnull</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157787">parent</a><span>|</span><a href="#37158351">prev</a><span>|</span><a href="#37157757">next</a><span>|</span><label class="collapse" for="c-37158118">[-]</label><label class="expand" for="c-37158118">[2 more]</label></div><br/><div class="children"><div class="content">Cerium is correct, we don&#x27;t know if P is efficiently parallelizable.<p>Is there a formal proof of what you&#x27;re talking about that we can read?</div><br/><div id="37158140" class="c"><input type="checkbox" id="c-37158140" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37158118">parent</a><span>|</span><a href="#37157757">next</a><span>|</span><label class="collapse" for="c-37158140">[-]</label><label class="expand" for="c-37158140">[1 more]</label></div><br/><div class="children"><div class="content">Are you perhaps confusing P with P complete?<p><a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;Walter-Ruzzo&#x2F;publication&#x2F;222089821_Limits_to_Parallel_Computation_P-Completeness_Theory&#x2F;links&#x2F;54fc88560cf20700c5e96c56&#x2F;Limits-to-Parallel-Computation-P-Completeness-Theory.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;Walter-Ruzzo&#x2F;publicatio...</a></div><br/></div></div></div></div></div></div></div></div><div id="37157757" class="c"><input type="checkbox" id="c-37157757" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157572">parent</a><span>|</span><a href="#37157759">prev</a><span>|</span><a href="#37158228">next</a><span>|</span><label class="collapse" for="c-37157757">[-]</label><label class="expand" for="c-37157757">[3 more]</label></div><br/><div class="children"><div class="content">Yes, linear(-ish) dependency chains so that your threads have to wait for one thread to provide a result (infinitely often).</div><br/><div id="37158148" class="c"><input type="checkbox" id="c-37158148" checked=""/><div class="controls bullet"><span class="by">gnull</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37157757">parent</a><span>|</span><a href="#37158228">next</a><span>|</span><label class="collapse" for="c-37158148">[-]</label><label class="expand" for="c-37158148">[2 more]</label></div><br/><div class="children"><div class="content">Are you stretching &quot;this specific strategy for parallelizing P that I came up with won&#x27;t work&quot; to &quot;there&#x27;s no way to parallelize P&quot;?</div><br/><div id="37158218" class="c"><input type="checkbox" id="c-37158218" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37157112">root</a><span>|</span><a href="#37158148">parent</a><span>|</span><a href="#37158228">next</a><span>|</span><label class="collapse" for="c-37158218">[-]</label><label class="expand" for="c-37158218">[1 more]</label></div><br/><div class="children"><div class="content">Itâs more like : you win a Turing award by finding a strategy to parallelize this problem as youâll be able to use that approach to parallelize all problems in P, proving NC = P.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37158228" class="c"><input type="checkbox" id="c-37158228" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#37157112">prev</a><span>|</span><a href="#37157002">next</a><span>|</span><label class="collapse" for="c-37158228">[-]</label><label class="expand" for="c-37158228">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, solving the NP-hard problem isn&#x27;t the part that is hard, it&#x27;s reducing the problem space and&#x2F;or solution space to make it into a P-problem (when n is sufficiently big enough to worry about it).<p>For example, changing how you&#x27;re storing the data in the first place, or talking to PM&#x2F;PO&#x27;s to learn if you really need an exact solution or if a very close approximation is ok.<p>Sometimes, you&#x27;re even trying to solve this problem while n has grown over months or years, and some customers are hitting the tipping point and the app is crashing. So there&#x27;s a lot of pressure to perform.<p>That&#x27;s what makes np-hard problems hard, imho; not the problem itself, but all the bullshit to get rid of it.</div><br/></div></div><div id="37157002" class="c"><input type="checkbox" id="c-37157002" checked=""/><div class="controls bullet"><span class="by">vsnf</span><span>|</span><a href="#37158228">prev</a><span>|</span><a href="#37157243">next</a><span>|</span><label class="collapse" for="c-37157002">[-]</label><label class="expand" for="c-37157002">[30 more]</label></div><br/><div class="children"><div class="content">Despite having done my undergrad in CS, I never understood what NP-hard really meant. I mean yeah, polynomial time, boolean logic, general-case not specific-case, transformable into other NP problems, I get it, but like, I don&#x27;t get it? Anyway, after reading this article I feel like I&#x27;ve gotten one small step closer to filling in this gap in my CS knowledge.</div><br/><div id="37158213" class="c"><input type="checkbox" id="c-37158213" checked=""/><div class="controls bullet"><span class="by">beefield</span><span>|</span><a href="#37157002">parent</a><span>|</span><a href="#37157036">next</a><span>|</span><label class="collapse" for="c-37158213">[-]</label><label class="expand" for="c-37158213">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Despite having done my undergrad in CS, I never understood what NP-hard really meant<p>Not having done CS undergrad, I have never really understood even P&#x2F;NP. The naive explanation of problems that are easy to solve and check vs problems that are difficult to solve but easy to check seems to leave something essential out.<p>I mean, with the naive explanation you are I think you are left with either of two options:<p>1. A philosophical issue of not being able to prove a negative, you really can&#x27;t prove that there is not a way to solve a problem fast.<p>2. That obviously P!=NP. You just for example lose information before giving the problem to the solver, say, I&#x27;m thinking a float with n decimals, then I round it to nearest integer and ask you to find the float given the integer. I can check the guess in linear time as n increases, but your difficulty increases exponentially as n increases.<p>I am pretty sure there is something in this problem that makes it a not legal P&#x2F;NP problem, but I have no idea what. I have a couple of times tried to look for more formal definitions of P&#x2F;NP, but the jargon goes immediately above my head.<p>(The &quot;guess&quot; is admittably there a bit informal, if you want a bit more formal problem, you take a process C that is mathematically proven to be sufficiently sensitive to initial conditions (e.g. chaotic), take integer x and calculate y = C(x), round y and ask what&#x27;s x.)</div><br/><div id="37158323" class="c"><input type="checkbox" id="c-37158323" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158213">parent</a><span>|</span><a href="#37157036">next</a><span>|</span><label class="collapse" for="c-37158323">[-]</label><label class="expand" for="c-37158323">[5 more]</label></div><br/><div class="children"><div class="content">Wait, how is it impossible to prove a negative?</div><br/><div id="37158355" class="c"><input type="checkbox" id="c-37158355" checked=""/><div class="controls bullet"><span class="by">beefield</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158323">parent</a><span>|</span><a href="#37157036">next</a><span>|</span><label class="collapse" for="c-37158355">[-]</label><label class="expand" for="c-37158355">[4 more]</label></div><br/><div class="children"><div class="content">Well, I guess you can prove that there are no odd numbers in set (2,4,6), so some negatives you can prove, but in general case, I do not know how to prove that something does not exist and will not exist ever.</div><br/><div id="37158514" class="c"><input type="checkbox" id="c-37158514" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158355">parent</a><span>|</span><a href="#37158575">next</a><span>|</span><label class="collapse" for="c-37158514">[-]</label><label class="expand" for="c-37158514">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the absence of proof.
It&#x27;s a bit different from the proof of a negative.<p>Don&#x27;t worry you&#x27;re not the first one mentioning it so that&#x27;s something that must be some kind of colloquialism somewhere but I was asking to understand what people may have meant.<p>To top it all, you proved a negative (by providing a counterexample) :o)</div><br/></div></div><div id="37158575" class="c"><input type="checkbox" id="c-37158575" checked=""/><div class="controls bullet"><span class="by">hnben</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158355">parent</a><span>|</span><a href="#37158514">prev</a><span>|</span><a href="#37157036">next</a><span>|</span><label class="collapse" for="c-37158575">[-]</label><label class="expand" for="c-37158575">[2 more]</label></div><br/><div class="children"><div class="content">when proving a negativ in math, you often do a proof by contradiction<p>precondition: Either A is true or it is false.<p>question: is A false?<p>solution:<p>1. assume that A is true<p>2. &lt;math stuff&gt;<p>3. find a contradiction<p>4. ==&gt; A can not be true<p>5. ==&gt; therefor A is false</div><br/><div id="37158962" class="c"><input type="checkbox" id="c-37158962" checked=""/><div class="controls bullet"><span class="by">beefield</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158575">parent</a><span>|</span><a href="#37157036">next</a><span>|</span><label class="collapse" for="c-37158962">[-]</label><label class="expand" for="c-37158962">[1 more]</label></div><br/><div class="children"><div class="content">In P&#x2F;NP case I would need to assume that I <i>can</i> solve a problem in polynomial time, and then find a contradiction.  To me it is really hard to see a useful path forward from there.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37158060" class="c"><input type="checkbox" id="c-37158060" checked=""/><div class="controls bullet"><span class="by">dandanua</span><span>|</span><a href="#37157002">parent</a><span>|</span><a href="#37157036">prev</a><span>|</span><a href="#37158445">next</a><span>|</span><label class="collapse" for="c-37158060">[-]</label><label class="expand" for="c-37158060">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably due to unfortunate naming of things.<p>First, NP doesn&#x27;t mean &quot;non polynomial&quot;, though people can imply that since there are no known polynomial solvers for NP-complete problems. It&#x27;s a shorthand for &quot;nondeterministic polynomial&quot;, but that naming is not intuitive either. It&#x27;s a class of problems that has polynomial verifiers of solutions.<p>Second, NP-hard means the problem is either NP-complete or not in NP at all. Which is another confusing naming, because problems not in NP are NP-hard.<p>As a saying goes, there are two main problems in programming - naming things and cache invalidation. And in this case the former fails badly.</div><br/><div id="37158256" class="c"><input type="checkbox" id="c-37158256" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158060">parent</a><span>|</span><a href="#37158387">next</a><span>|</span><label class="collapse" for="c-37158256">[-]</label><label class="expand" for="c-37158256">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Second, NP-hard means the problem is either NP-complete or not in NP at all. Which is another confusing naming, because problems not in NP are NP-hard.<p>But remember that P is in NP, so NP-hard implies not in P (assuming P â  NP).</div><br/><div id="37158753" class="c"><input type="checkbox" id="c-37158753" checked=""/><div class="controls bullet"><span class="by">dandanua</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158256">parent</a><span>|</span><a href="#37158729">next</a><span>|</span><label class="collapse" for="c-37158753">[-]</label><label class="expand" for="c-37158753">[1 more]</label></div><br/><div class="children"><div class="content">And if P = NP any problem will be NP-hard. Until P â  NP is proved we can&#x27;t heavily rely on the consequences.</div><br/></div></div></div></div><div id="37158387" class="c"><input type="checkbox" id="c-37158387" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158060">parent</a><span>|</span><a href="#37158256">prev</a><span>|</span><a href="#37158445">next</a><span>|</span><label class="collapse" for="c-37158387">[-]</label><label class="expand" for="c-37158387">[1 more]</label></div><br/><div class="children"><div class="content">So, NP-hard means that it&#x27;s either NP-complete (the hardest NP can get), or <i>even harder</i> than that. Pretty intuitive to me.</div><br/></div></div></div></div><div id="37158445" class="c"><input type="checkbox" id="c-37158445" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37157002">parent</a><span>|</span><a href="#37158060">prev</a><span>|</span><a href="#37157268">next</a><span>|</span><label class="collapse" for="c-37158445">[-]</label><label class="expand" for="c-37158445">[1 more]</label></div><br/><div class="children"><div class="content">You should grab a textbook about NP-completeness like Garey and Johnson. It&#x27;s actually quite easy to understand and you can follow along some proofs for NP-completeness even if you don&#x27;t have experience with that. NP-hard will follow.</div><br/></div></div><div id="37157268" class="c"><input type="checkbox" id="c-37157268" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#37157002">parent</a><span>|</span><a href="#37158445">prev</a><span>|</span><a href="#37157243">next</a><span>|</span><label class="collapse" for="c-37157268">[-]</label><label class="expand" for="c-37157268">[15 more]</label></div><br/><div class="children"><div class="content">From what I remember:<p>NP: Finding the solution takes more than polynomial time, but you can verify the answer is correct in polynomial time.<p>NP-Hard: Finding the solution takes more than polynomial time, and it also takes more than polynomial time to verify that the solution is correct.<p>NP-Complete: NP-Hard, but it can be transformed into any other NP-Complete problem in polynomial time.  This is special because it means if you find a solution for any NP-Complete problem, you have found a solution for all of them.  Finding an NP-Complete solution always seemed rather rather optimistic to me, but computer science professors obsessed over these problems.<p>Caveat:  It has been more than 20 years since I was quizzed on this stuff, so it might be wrong.</div><br/><div id="37157363" class="c"><input type="checkbox" id="c-37157363" checked=""/><div class="controls bullet"><span class="by">viknesh</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157268">parent</a><span>|</span><a href="#37157751">next</a><span>|</span><label class="collapse" for="c-37157363">[-]</label><label class="expand" for="c-37157363">[6 more]</label></div><br/><div class="children"><div class="content">NP: Checking a solution takes polynomial time.<p>NP-Hard: &quot;The problem is at least as hard as any problem in NP.&quot; Basically, if X is an NP hard problem and you are given an oracle to solve X, you can solve any problem in NP by first transforming it to an instance of X and then solving it.<p>NP Complete: The problem is NP Hard &amp; in NP.</div><br/><div id="37157768" class="c"><input type="checkbox" id="c-37157768" checked=""/><div class="controls bullet"><span class="by">zer8k</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157363">parent</a><span>|</span><a href="#37157751">next</a><span>|</span><label class="collapse" for="c-37157768">[-]</label><label class="expand" for="c-37157768">[5 more]</label></div><br/><div class="children"><div class="content">To add to this NP can also refer to the more formal idea of a non-deterministic turing machine being able to compute the problem in polynomial time. We learned NP as &quot;Non-deterministic Polynomial (time)&quot;. I think the more practical definition is &quot;not polynomial&quot;...lol.</div><br/><div id="37158241" class="c"><input type="checkbox" id="c-37158241" checked=""/><div class="controls bullet"><span class="by">jsolson</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157768">parent</a><span>|</span><a href="#37158142">next</a><span>|</span><label class="collapse" for="c-37158241">[-]</label><label class="expand" for="c-37158241">[2 more]</label></div><br/><div class="children"><div class="content">Following more or less directly from this:<p>- If you walk backwards from where the non-deterministic Turing machine halted, the list of taken state machine transitions is polynomial in length (naturally, as the machine stopped in polynomial time).<p>- Walking that polynomial length list of actually-taken edges forward through the Turing machine constitutes a polynomial time verification of the solution.<p>This is the essence of the equivalence between being able to solve problems in NP in polynomial time on a (hypothetical) non-deterministic Turing machine and being able to deterministically verify a solution to those problems in polynomial time.</div><br/><div id="37158328" class="c"><input type="checkbox" id="c-37158328" checked=""/><div class="controls bullet"><span class="by">zer8k</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37158241">parent</a><span>|</span><a href="#37158142">next</a><span>|</span><label class="collapse" for="c-37158328">[-]</label><label class="expand" for="c-37158328">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - If you walk backwards from where the non-deterministic Turing machine halted, the list of taken state machine transitions is polynomial in length (naturally, as the machine stopped in polynomial time).<p>&gt; - Walking that polynomial length list of actually-taken edges forward through the Turing machine constitutes a polynomial time verification of the solution.<p>These are really great explanations that would&#x27;ve saved me so much trouble in graduate school. Connecting the automata itself to the term &quot;nondeterministic turing machine&quot; is something that is sorely missed is most CS programs I think. It&#x27;s usually handwaved in automata theory in order to give you enough to head to compilers. Then you run into it again in graduate school algorithms where it is once again handwaved (because not even the professor fully understands it).</div><br/></div></div></div></div><div id="37158142" class="c"><input type="checkbox" id="c-37158142" checked=""/><div class="controls bullet"><span class="by">Skeime</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157768">parent</a><span>|</span><a href="#37158241">prev</a><span>|</span><a href="#37157897">next</a><span>|</span><label class="collapse" for="c-37158142">[-]</label><label class="expand" for="c-37158142">[1 more]</label></div><br/><div class="children"><div class="content">âNot polynomialâ is an easy trap to fall into (and one I have fallen into) but itâs really not correct. All polynomial-time problems are also NP problems (P=NP is about whether the converse is true, and <i>if</i> P=NP, all problems in NP are actually polynomial-time). So even if talking to a layman, saying that NP is non-polynomial is really missing the point of the question.</div><br/></div></div><div id="37157897" class="c"><input type="checkbox" id="c-37157897" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157768">parent</a><span>|</span><a href="#37158142">prev</a><span>|</span><a href="#37157751">next</a><span>|</span><label class="collapse" for="c-37157897">[-]</label><label class="expand" for="c-37157897">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To add to this NP can also refer to the more formal idea of a non-deterministic turing machine being able to compute the problem in polynomial time.<p>Yes. This definition is equivalent to the one about being verifiable in polynomial time, since your non-deterministic TM can just have a different branch for every possible verification &quot;oracle&quot;.<p>&gt; I think the more practical definition is &quot;not polynomial&quot;...lol.<p>Well, there are non-polynomial algorithms harder than NP. If a solution can&#x27;t even be verified efficiently, for example.</div><br/></div></div></div></div></div></div><div id="37157751" class="c"><input type="checkbox" id="c-37157751" checked=""/><div class="controls bullet"><span class="by">zer8k</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157268">parent</a><span>|</span><a href="#37157363">prev</a><span>|</span><a href="#37157558">next</a><span>|</span><label class="collapse" for="c-37157751">[-]</label><label class="expand" for="c-37157751">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the downvotes here are fair given the corrections this person has received. These misconceptions are <i>wildly</i> common. I&#x27;m sure 90% of the downvoters couldn&#x27;t even accurately identify this stuff.</div><br/></div></div><div id="37157558" class="c"><input type="checkbox" id="c-37157558" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157268">parent</a><span>|</span><a href="#37157751">prev</a><span>|</span><a href="#37157327">next</a><span>|</span><label class="collapse" for="c-37157558">[-]</label><label class="expand" for="c-37157558">[1 more]</label></div><br/><div class="children"><div class="content">^ The most common misconceptions about NP&#x2F;NP-Complete&#x2F;NP-Hard, packed in one comment!<p>But seriously for anyone reading this, please refer to the other sibling comments.</div><br/></div></div><div id="37157327" class="c"><input type="checkbox" id="c-37157327" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157268">parent</a><span>|</span><a href="#37157558">prev</a><span>|</span><a href="#37157652">next</a><span>|</span><label class="collapse" for="c-37157327">[-]</label><label class="expand" for="c-37157327">[4 more]</label></div><br/><div class="children"><div class="content">--Edit: this was wrong, see reply comment--<p>NP: you can verify the answer is correct in polynomial time. (and no other clauses)<p>Anything in P is in NP</div><br/><div id="37157684" class="c"><input type="checkbox" id="c-37157684" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157327">parent</a><span>|</span><a href="#37157567">next</a><span>|</span><label class="collapse" for="c-37157684">[-]</label><label class="expand" for="c-37157684">[1 more]</label></div><br/><div class="children"><div class="content">&gt; --Edit: this was wrong, see reply comment--<p>You&#x27;re not wrong tho. NP problems can be verified in polynomial time.<p>Nondetermisitic turnig machine is like a turing machine that has multiple &quot;next steps&quot; instead of one at a given time, and can migically choose the correct next step.<p>You can think it as &quot;taking all the possible paths at the same time (but at the end only the correct one matters)&quot;. But you can also think it as &quot;given all the &#x27;choices&#x27; it made, check if there is actually such a path&quot;, in other words, verifying a certification.</div><br/></div></div><div id="37157567" class="c"><input type="checkbox" id="c-37157567" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157327">parent</a><span>|</span><a href="#37157684">prev</a><span>|</span><a href="#37157639">next</a><span>|</span><label class="collapse" for="c-37157567">[-]</label><label class="expand" for="c-37157567">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s worth saying what NP stands for.<p>Nondeterministic Polynomial.  Where &quot;nondeterministic&quot; basically means you get to try every single polynomial solution in parallel.</div><br/></div></div><div id="37157639" class="c"><input type="checkbox" id="c-37157639" checked=""/><div class="controls bullet"><span class="by">minitech</span><span>|</span><a href="#37157002">root</a><span>|</span><a href="#37157327">parent</a><span>|</span><a href="#37157567">prev</a><span>|</span><a href="#37157652">next</a><span>|</span><label class="collapse" for="c-37157639">[-]</label><label class="expand" for="c-37157639">[1 more]</label></div><br/><div class="children"><div class="content">Not wrong, just a different criterion that describes the same complexity class.</div><br/></div></div></div></div></div></div></div></div><div id="37157243" class="c"><input type="checkbox" id="c-37157243" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#37157002">prev</a><span>|</span><a href="#37158458">next</a><span>|</span><label class="collapse" for="c-37157243">[-]</label><label class="expand" for="c-37157243">[2 more]</label></div><br/><div class="children"><div class="content">Look into the formal verification community, where PSPACE-complete is &quot;easy&quot; and undecidable is normal.</div><br/><div id="37157306" class="c"><input type="checkbox" id="c-37157306" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37157243">parent</a><span>|</span><a href="#37158458">next</a><span>|</span><label class="collapse" for="c-37157306">[-]</label><label class="expand" for="c-37157306">[1 more]</label></div><br/><div class="children"><div class="content">Hopefully they donât need to deal with âbig dataâ</div><br/></div></div></div></div><div id="37158458" class="c"><input type="checkbox" id="c-37158458" checked=""/><div class="controls bullet"><span class="by">ngruhn</span><span>|</span><a href="#37157243">prev</a><span>|</span><a href="#37158337">next</a><span>|</span><label class="collapse" for="c-37158458">[-]</label><label class="expand" for="c-37158458">[2 more]</label></div><br/><div class="children"><div class="content">Traveling salesmen is even solved to optimality (no heuristics) for pretty large instances with integer programming techniques.<p>Also SAT is pretty much a solved problem. With algorithms like CDCL.<p>This really surprised me. I also left my first complexity theory course believing that NP-hard = &quot;not solvable in practiceâ</div><br/><div id="37158526" class="c"><input type="checkbox" id="c-37158526" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37158458">parent</a><span>|</span><a href="#37158337">next</a><span>|</span><label class="collapse" for="c-37158526">[-]</label><label class="expand" for="c-37158526">[1 more]</label></div><br/><div class="children"><div class="content">&gt; SAT is pretty much a solved problem<p>We donât really understand what makes some SAT problems harder than others.<p>You can go from a problem solvable with CDCL in a few seconds to one that would outlast the solar system by changing a couple of input bits.</div><br/></div></div></div></div><div id="37156747" class="c"><input type="checkbox" id="c-37156747" checked=""/><div class="controls bullet"><span class="by">mutant_glofish</span><span>|</span><a href="#37156957">prev</a><span>|</span><label class="collapse" for="c-37156747">[-]</label><label class="expand" for="c-37156747">[2 more]</label></div><br/><div class="children"><div class="content">Hey, I vouched for your submission. Just wanted to let you know that there seems to be some issue with your account causing your submissions to be automatically flagged. You may want to contact HN moderators (hn@ycombinator.com) about that.</div><br/><div id="37156823" class="c"><input type="checkbox" id="c-37156823" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37156747">parent</a><span>|</span><label class="collapse" for="c-37156823">[-]</label><label class="expand" for="c-37156823">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve fixed it now. Thanks for watching out for a fellow user!</div><br/></div></div></div></div></div></div></div></div></div></body></html>