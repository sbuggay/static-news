<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714208455418" as="style"/><link rel="stylesheet" href="styles.css?v=1714208455418"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://loglog.games/blog/leaving-rust-gamedev/">Leaving Rust gamedev after 3 years</a> <span class="domain">(<a href="https://loglog.games">loglog.games</a>)</span></div><div class="subtext"><span>darthdeus</span> | <span>491 comments</span></div><br/><div><div id="40172952" class="c"><input type="checkbox" id="c-40172952" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40173475">next</a><span>|</span><label class="collapse" for="c-40172952">[-]</label><label class="expand" for="c-40172952">[136 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good article. He&#x27;s right about many things.<p>I&#x27;ve been writing a metaverse client in Rust for several years now. Works with Second Life and Open Simulator servers. Here&#x27;s some video.[1] It&#x27;s about 45,000 lines of safe Rust.<p>Notes:<p>* There are very few people doing serious 3D game work in Rust. There&#x27;s Veloren, and my stuff, and maybe a few others. No big, popular titles. I&#x27;d expected some AAA title to be written in Rust by now. That hasn&#x27;t happened, and it&#x27;s probably not going to happen, for the reasons the author gives.<p>* He&#x27;s right about the pain of refactoring and the difficulties of interconnecting different parts of the program. It&#x27;s quite common for some change to require extensive plumbing work. If the client that talks to the servers needs to talk to the 2D GUI, it has to queue an event.<p>* The rendering situation is almost adequate, but the stack isn&#x27;t finished and reliable yet. The 2D GUI systems are weak and require too much code per dialog box.<p>* I tend to agree about the &quot;async contamination&quot; problem. The &quot;async&quot; system is optimized for someone who needs to run a very large web server, with a huge number of clients sending in requests. I&#x27;ve been pushing back against it creeping into areas that don&#x27;t really need it.<p>* I have less trouble with compile times than he does, because the metaverse client has no built-in &quot;gameplay&quot;. A metaverse client is more like a 3D web browser than a game.
All the objects and their behaviors come from the server.
I can edit my part of the world from inside the live world.  If the color or behavior or model of something needs to be changed, that&#x27;s not something that requires a client recompile.<p>The people using C# and Unity on the same problem are making much faster progress.<p>[1] <a href="https:&#x2F;&#x2F;video.hardlimit.com&#x2F;w&#x2F;7usCE3v2RrWK6nuoSr4NHJ" rel="nofollow">https:&#x2F;&#x2F;video.hardlimit.com&#x2F;w&#x2F;7usCE3v2RrWK6nuoSr4NHJ</a></div><br/><div id="40173485" class="c"><input type="checkbox" id="c-40173485" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40173690">next</a><span>|</span><label class="collapse" for="c-40173485">[-]</label><label class="expand" for="c-40173485">[70 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I&#x27;d expected some AAA title to be written in Rust by now.</i><p>I&#x27;m disinclined to believe that any AAA game will be written in Rust (one is free to insert &quot;because Rust&#x27;s gamedev ecosystem is immature&quot; or &quot;because AAA game development is increasingly conservative and risk-averse&quot; at their discretion), yet I&#x27;m curious what led you to believe this. C++ became available in 1985, and didn&#x27;t become popular for gamedev until the turn of the millenium, in the wake of Quake 3 (buoyed by the new features of C++98).</div><br/><div id="40175564" class="c"><input type="checkbox" id="c-40175564" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173485">parent</a><span>|</span><a href="#40173883">next</a><span>|</span><label class="collapse" for="c-40175564">[-]</label><label class="expand" for="c-40175564">[3 more]</label></div><br/><div class="children"><div class="content">Lamothe&#x27;s Black Art book came out in &#x27;95.  Abrash&#x27;s black book came out in &#x27;97.<p>Borland C++ was pretty common and popular in 93 and we even had some not-so-great C++ compilers on Amiga in 92&#x2F;93 that had some use in gamedev.<p>SimCity 2000 was written in C++, way back in &#x27;93 (although they started with Cfront)<p>An absolute fuckton of shareware games I was playing in the 90s were built with Turbo C++.</div><br/><div id="40177710" class="c"><input type="checkbox" id="c-40177710" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175564">parent</a><span>|</span><a href="#40177939">next</a><span>|</span><label class="collapse" for="c-40177710">[-]</label><label class="expand" for="c-40177710">[1 more]</label></div><br/><div class="children"><div class="content">Kind of true, however they had endless amounts of inline Assembly, as shown on the Black Book as well.<p>I know of at least a MS-DOS game, published on Portuguese Spooler magazine, that was using Turbo C++ basically as a macro assembler.<p>One of the PlayStation selling points for developers was being the first home console with a C SDK, while SEGA and Nintendo were still doing Assembly, C++ support only came later to the PlayStation 2.<p>While I agree C++, BASIC, Turbo Pascal, AMOS were being used a lot, specially in the Demoscene, they were our Unity, from the point of view of successful game studios.</div><br/></div></div><div id="40177939" class="c"><input type="checkbox" id="c-40177939" checked=""/><div class="controls bullet"><span class="by">zonovar</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175564">parent</a><span>|</span><a href="#40177710">prev</a><span>|</span><a href="#40173883">next</a><span>|</span><label class="collapse" for="c-40177939">[-]</label><label class="expand" for="c-40177939">[1 more]</label></div><br/><div class="children"><div class="content">I also remember by videogame magazines I was reading back in early 90s that another C++ compiler that was a favourite among devs was Watcom C++ that was released in 88.</div><br/></div></div></div></div><div id="40173883" class="c"><input type="checkbox" id="c-40173883" checked=""/><div class="controls bullet"><span class="by">hamilyon2</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173485">parent</a><span>|</span><a href="#40175564">prev</a><span>|</span><a href="#40177050">next</a><span>|</span><label class="collapse" for="c-40173883">[-]</label><label class="expand" for="c-40173883">[1 more]</label></div><br/><div class="children"><div class="content">I really hope that C++ evolves with gamedev and they become more and more symbiotic.<p>Maybe adoption of rust by gamedev community isn&#x27;t the best thing to wish to happen to language. Maybe it is better to let other crowd to steer evolution of rust, letting system programming and gamedev drift apart</div><br/></div></div><div id="40177050" class="c"><input type="checkbox" id="c-40177050" checked=""/><div class="controls bullet"><span class="by">lumost</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173485">parent</a><span>|</span><a href="#40173883">prev</a><span>|</span><a href="#40173733">next</a><span>|</span><label class="collapse" for="c-40177050">[-]</label><label class="expand" for="c-40177050">[6 more]</label></div><br/><div class="children"><div class="content">I sometimes wonder if the problem with rust is that we have not yet had a major set of projects which drive solutions to common dev problems.<p>Go had google driving adoption, which in turn drove open source efforts. The language had to remain grounded to not interfere with the <i>doing</i> of building back-end services.<p>Rust had mozilla&#x2F;servo which was ultimately unsuccessful. While there are more than a few companies uinf rust for small projects with tough performance guarantees - I haven&#x27;t seen the “we manage 1-10 MM sloc of complex code using rust” type projects.</div><br/><div id="40177099" class="c"><input type="checkbox" id="c-40177099" checked=""/><div class="controls bullet"><span class="by">doublepg23</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177050">parent</a><span>|</span><a href="#40178153">next</a><span>|</span><label class="collapse" for="c-40177099">[-]</label><label class="expand" for="c-40177099">[2 more]</label></div><br/><div class="children"><div class="content">? I believe the Rust efforts in Firefox were largely successful. I think Servo was for experimental purposes and large parts were then added to Firefox with Quantum: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gecko_(software)#Quantum" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gecko_(software)#Quantum</a></div><br/><div id="40177159" class="c"><input type="checkbox" id="c-40177159" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177099">parent</a><span>|</span><a href="#40178153">next</a><span>|</span><label class="collapse" for="c-40177159">[-]</label><label class="expand" for="c-40177159">[1 more]</label></div><br/><div class="children"><div class="content">My recollection was that those were separate changes - servo didn’t get to the stage where it could be merged, but it was absolutely the plan to build a rendering engine that outperformed every other browser before budget cuts hit.</div><br/></div></div></div></div><div id="40178153" class="c"><input type="checkbox" id="c-40178153" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177050">parent</a><span>|</span><a href="#40177099">prev</a><span>|</span><a href="#40177902">next</a><span>|</span><label class="collapse" for="c-40178153">[-]</label><label class="expand" for="c-40178153">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Go had google driving adoption</i><p>This is commonly said but I think it&#x27;s only correct in the sense that Google is famous and Google engineers started it.<p>Google never <i>drove</i> adoption; it happened organically.</div><br/></div></div><div id="40177902" class="c"><input type="checkbox" id="c-40177902" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177050">parent</a><span>|</span><a href="#40178153">prev</a><span>|</span><a href="#40173733">next</a><span>|</span><label class="collapse" for="c-40177902">[-]</label><label class="expand" for="c-40177902">[2 more]</label></div><br/><div class="children"><div class="content">Servo is an ongoing project, it has not &quot;failed&quot; or been unsuccessful in any sense.</div><br/><div id="40177967" class="c"><input type="checkbox" id="c-40177967" checked=""/><div class="controls bullet"><span class="by">bjconlan</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177902">parent</a><span>|</span><a href="#40173733">next</a><span>|</span><label class="collapse" for="c-40177967">[-]</label><label class="expand" for="c-40177967">[1 more]</label></div><br/><div class="children"><div class="content">I think the original poster is perhaps speaking to previous articles (ie <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39269949">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39269949</a>) which from the outside looking in made me feel that perhaps this infact was the case (at least for a period).</div><br/></div></div></div></div></div></div><div id="40173733" class="c"><input type="checkbox" id="c-40173733" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173485">parent</a><span>|</span><a href="#40177050">prev</a><span>|</span><a href="#40175080">next</a><span>|</span><label class="collapse" for="c-40173733">[-]</label><label class="expand" for="c-40173733">[53 more]</label></div><br/><div class="children"><div class="content">Exactly, it&#x27;s all about the ecosystem and very little about the language features</div><br/><div id="40174737" class="c"><input type="checkbox" id="c-40174737" checked=""/><div class="controls bullet"><span class="by">jacobgorm</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173733">parent</a><span>|</span><a href="#40173779">next</a><span>|</span><label class="collapse" for="c-40174737">[-]</label><label class="expand" for="c-40174737">[11 more]</label></div><br/><div class="children"><div class="content">C++ classes with inheritance are a pretty good match for objects in a 3D (or 2D) world, which is why C++ became popular with 3D game programmers.</div><br/><div id="40178020" class="c"><input type="checkbox" id="c-40178020" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174737">parent</a><span>|</span><a href="#40177513">next</a><span>|</span><label class="collapse" for="c-40178020">[-]</label><label class="expand" for="c-40178020">[1 more]</label></div><br/><div class="children"><div class="content">This is not at all my experience.<p>What I have experienced is that C++ classes with inheritance are good at modeling objects in a game <i>at first</i>, when you are just starting and the hierarchy is super simple. Afterwards, it isn’t a good match. To can try to hack around this in several ways, but the short version of it is that if your game isn’t very simple you are better off starting with an Entity Component System setup. It will be more cumbersome to use than the language-provided features at first, but the lines cross very quickly.</div><br/></div></div><div id="40177513" class="c"><input type="checkbox" id="c-40177513" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174737">parent</a><span>|</span><a href="#40178020">prev</a><span>|</span><a href="#40174820">next</a><span>|</span><label class="collapse" for="c-40177513">[-]</label><label class="expand" for="c-40177513">[1 more]</label></div><br/><div class="children"><div class="content">This is how I feel about golang and systems programming. The strong concurrency primitives and language simplicity make it easier to write and reason about concurrent code. I have to maintain some low level systems in python and the language is such a worse fit for solving those problems.</div><br/></div></div><div id="40174820" class="c"><input type="checkbox" id="c-40174820" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174737">parent</a><span>|</span><a href="#40177513">prev</a><span>|</span><a href="#40173779">next</a><span>|</span><label class="collapse" for="c-40174820">[-]</label><label class="expand" for="c-40174820">[8 more]</label></div><br/><div class="children"><div class="content">Yeah, OOP makes sense for games. The language will matter a bit for which one takes off, but anything will work given enough support. Like, Python doesn&#x27;t inherently make a lot of sense for data processing or AI, but it&#x27;s good enough.</div><br/><div id="40178158" class="c"><input type="checkbox" id="c-40178158" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174820">parent</a><span>|</span><a href="#40175147">next</a><span>|</span><label class="collapse" for="c-40178158">[-]</label><label class="expand" for="c-40178158">[1 more]</label></div><br/><div class="children"><div class="content">To be clear, the reason why Python is so popular for data wrangling (including ML&#x2F;AI) is not due to the language itself.  It is due to the popular extensions (libraries) exclusively written in C &amp; C++!  Without these libraries, no one would bother with Python for these tasks.  They would use C++, Java, or .NET.  Hell, even Perl is much faster than Python for data processing using only the language and not native extensions.</div><br/></div></div><div id="40175147" class="c"><input type="checkbox" id="c-40175147" checked=""/><div class="controls bullet"><span class="by">kagakuninja</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174820">parent</a><span>|</span><a href="#40178158">prev</a><span>|</span><a href="#40176560">next</a><span>|</span><label class="collapse" for="c-40175147">[-]</label><label class="expand" for="c-40175147">[5 more]</label></div><br/><div class="children"><div class="content">OOP kind of goes out the window when people start using entity component systems. Of course, like the author, I&#x27;m not sure I&#x27;ll need ECS since I&#x27;m not building a AAA game.</div><br/><div id="40175602" class="c"><input type="checkbox" id="c-40175602" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175147">parent</a><span>|</span><a href="#40176560">next</a><span>|</span><label class="collapse" for="c-40175602">[-]</label><label class="expand" for="c-40175602">[4 more]</label></div><br/><div class="children"><div class="content">Had to look up ECS to be honest, and it&#x27;s pretty much what I already do in general dev. I don&#x27;t care to classify things, I care what I can do with something. Which is Rust&#x27;s model.</div><br/><div id="40176341" class="c"><input type="checkbox" id="c-40176341" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175602">parent</a><span>|</span><a href="#40176560">next</a><span>|</span><label class="collapse" for="c-40176341">[-]</label><label class="expand" for="c-40176341">[3 more]</label></div><br/><div class="children"><div class="content">Sorry I got lost in that sentence. What is Rust&#x27;s model?</div><br/><div id="40176605" class="c"><input type="checkbox" id="c-40176605" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40176341">parent</a><span>|</span><a href="#40176560">next</a><span>|</span><label class="collapse" for="c-40176605">[-]</label><label class="expand" for="c-40176605">[2 more]</label></div><br/><div class="children"><div class="content">Rust has traits on structs instead of using inheritance. Aka composition.</div><br/><div id="40177955" class="c"><input type="checkbox" id="c-40177955" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40176605">parent</a><span>|</span><a href="#40176560">next</a><span>|</span><label class="collapse" for="c-40177955">[-]</label><label class="expand" for="c-40177955">[1 more]</label></div><br/><div class="children"><div class="content">You can also have structs be generic over some &quot;tag&quot; type, which when combined with trait definitions gets you quite close to implementation inheritance as seen in C++ and elsewhere.  It&#x27;s just less common because usually composition is all that&#x27;s required.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40176560" class="c"><input type="checkbox" id="c-40176560" checked=""/><div class="controls bullet"><span class="by">juleiie</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174820">parent</a><span>|</span><a href="#40175147">prev</a><span>|</span><a href="#40173779">next</a><span>|</span><label class="collapse" for="c-40176560">[-]</label><label class="expand" for="c-40176560">[1 more]</label></div><br/><div class="children"><div class="content">Python makes sense because of accessibility and general comfort for relatively small code bases with big data sets.<p>Those data scientists at least from my experience are more into math&#x2F;business than interested in most efficient programming.<p>Or at least that was the situation at first and it sticked.</div><br/></div></div></div></div></div></div><div id="40173779" class="c"><input type="checkbox" id="c-40173779" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173733">parent</a><span>|</span><a href="#40174737">prev</a><span>|</span><a href="#40173852">next</a><span>|</span><label class="collapse" for="c-40173779">[-]</label><label class="expand" for="c-40173779">[32 more]</label></div><br/><div class="children"><div class="content">Disagree the adoption of C++ was more about Moore&#x27;s law than ecosystem, although having compilers that were beginning to not be completely rubbish also helped.</div><br/><div id="40173938" class="c"><input type="checkbox" id="c-40173938" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173779">parent</a><span>|</span><a href="#40174521">next</a><span>|</span><label class="collapse" for="c-40173938">[-]</label><label class="expand" for="c-40173938">[26 more]</label></div><br/><div class="children"><div class="content">Also C++ could be adopted incrementally by C developers. You could use it as “C with classes”, or just use operator overloading to make vector math more tolerable, or whatever subset that you happened to like.<p>So there’s really three forces at play in making C++ the standard:<p>1) The Microsoft ecosystem. They literally stopped supporting C by not adopting the C99 standard in their compiler. If you wanted any modern convenience, you had to compile in C++ mode. New APIs like Direct3D were theoretically accessible from C (via COM) but in practice designed for C++.<p>2) Better compilers and more CPU cycles to spare. You could actually count on the compiler to do the right thing often enough.<p>3) Seamless gradual adoption for C developers.<p>Rust has a good compiler, but it lacks that big ticket ecosystem push and is not entirely trivial for C++ developers to adopt.</div><br/><div id="40174029" class="c"><input type="checkbox" id="c-40174029" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173938">parent</a><span>|</span><a href="#40176104">next</a><span>|</span><label class="collapse" for="c-40174029">[-]</label><label class="expand" for="c-40174029">[21 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say Rust does have that big ticket ecosystem push. Microsoft has been embracing Rust lately, with things like official Windows bindings [1].<p>The bigger problem is just inertia: large game engines are enormous.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;windows-rs">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;windows-rs</a></div><br/><div id="40174715" class="c"><input type="checkbox" id="c-40174715" checked=""/><div class="controls bullet"><span class="by">withinrafael</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174029">parent</a><span>|</span><a href="#40174160">next</a><span>|</span><label class="collapse" for="c-40174715">[-]</label><label class="expand" for="c-40174715">[6 more]</label></div><br/><div class="children"><div class="content">Repo contributor here, just to curb some expectations a bit: it&#x27;s one very smart guy (Kenny), his unpaid volunteer sidekick (me), and a few unpaid external contributors. (I&#x27;m trying to draw a line between those with and without commit access, hence all the edits.)<p>There&#x27;s no other internal or external Microsoft &#x2F;support&#x2F; that I&#x27;m aware of. I wouldn&#x27;t necessarily use it as a signal of the company&#x27;s intentions at this time.<p>That said, there are Microsoft folks working on the Rust compiler, toolchain, etc. side of things too. Maybe those are better indicators!</div><br/><div id="40174776" class="c"><input type="checkbox" id="c-40174776" checked=""/><div class="controls bullet"><span class="by">heavyset_go</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174715">parent</a><span>|</span><a href="#40174160">next</a><span>|</span><label class="collapse" for="c-40174776">[-]</label><label class="expand" for="c-40174776">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s disappointing on Microsoft&#x27;s part, because their docs make it seem like windows-rs is the way of the future.<p>Thanks for your work, though!</div><br/><div id="40177737" class="c"><input type="checkbox" id="c-40177737" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174776">parent</a><span>|</span><a href="#40175460">next</a><span>|</span><label class="collapse" for="c-40177737">[-]</label><label class="expand" for="c-40177737">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t be, they also killed C++&#x2F;CX, even went to CppCon 2016 telling us how great future C++&#x2F;WinRT would bring to us.<p>Now almost a decade later, VS tooling is still not there, stuck in ATL&#x2F;VC++ 6.0 like experience (they blame it on the VS team), C++&#x2F;WinRT is in maintenance, only bug fixes, and all the fun is on Rust&#x2F;WinRT.<p>I would never trust this work for production development.</div><br/></div></div><div id="40175460" class="c"><input type="checkbox" id="c-40175460" checked=""/><div class="controls bullet"><span class="by">smileson2</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174776">parent</a><span>|</span><a href="#40177737">prev</a><span>|</span><a href="#40174160">next</a><span>|</span><label class="collapse" for="c-40175460">[-]</label><label class="expand" for="c-40175460">[3 more]</label></div><br/><div class="children"><div class="content">I wish Microsoft had any direction on the &#x27;way of the future&#x27; for native apps on Windows</div><br/><div id="40177528" class="c"><input type="checkbox" id="c-40177528" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175460">parent</a><span>|</span><a href="#40174160">next</a><span>|</span><label class="collapse" for="c-40177528">[-]</label><label class="expand" for="c-40177528">[2 more]</label></div><br/><div class="children"><div class="content">If they did publish a “way of the future” direction, would you believe them?<p>Fool me N times then shame on them, fool me N+1 times, then shame on me sort of thing.</div><br/><div id="40178116" class="c"><input type="checkbox" id="c-40178116" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177528">parent</a><span>|</span><a href="#40174160">next</a><span>|</span><label class="collapse" for="c-40178116">[-]</label><label class="expand" for="c-40178116">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d have bought into MAUI if there was Linux support in the box.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40174160" class="c"><input type="checkbox" id="c-40174160" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174029">parent</a><span>|</span><a href="#40174715">prev</a><span>|</span><a href="#40174762">next</a><span>|</span><label class="collapse" for="c-40174160">[-]</label><label class="expand" for="c-40174160">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say the inertia is far more social than codebase size related. Right now whilst there are pockets of interest there is no broader reason to switch. Bevy as the leading contender isn&#x27;t going to magic it&#x27;s way to being capable of shipping AAA titles unless a studio actually adopts it. I don&#x27;t think it&#x27;s actually shipped a commercially successful indie game yet.<p>Also game engines emphatically don&#x27;t have to be huge. Look at Balatro shipping on Love2d.</div><br/><div id="40174175" class="c"><input type="checkbox" id="c-40174175" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174160">parent</a><span>|</span><a href="#40175257">next</a><span>|</span><label class="collapse" for="c-40174175">[-]</label><label class="expand" for="c-40174175">[7 more]</label></div><br/><div class="children"><div class="content">There are a few successful games like Tunnet [1] written in Bevy.<p>[1]: <a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;2286390&#x2F;Tunnet&#x2F;" rel="nofollow">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;2286390&#x2F;Tunnet&#x2F;</a></div><br/><div id="40174256" class="c"><input type="checkbox" id="c-40174256" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174175">parent</a><span>|</span><a href="#40175257">next</a><span>|</span><label class="collapse" for="c-40174256">[-]</label><label class="expand" for="c-40174256">[6 more]</label></div><br/><div class="children"><div class="content">Looks cool and well received but at ~300ish reviews hardly a shining beacon if we extrapolate sales from that. But I&#x27;ll say that&#x27;s a good start.</div><br/><div id="40174948" class="c"><input type="checkbox" id="c-40174948" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174256">parent</a><span>|</span><a href="#40175257">next</a><span>|</span><label class="collapse" for="c-40174948">[-]</label><label class="expand" for="c-40174948">[5 more]</label></div><br/><div class="children"><div class="content">Speaking as a Godot supporter, I don&#x27;t think sales numbers of shipped games are relevant to anyone except the game&#x27;s developer.<p>When evaluating a newer technology, the key question is: are there any major non-obvious roadblocks? A finished game (with presumably decent performance) tells you that if there are problems, they&#x27;re solvable. That&#x27;s the data.</div><br/><div id="40175544" class="c"><input type="checkbox" id="c-40175544" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174948">parent</a><span>|</span><a href="#40177655">next</a><span>|</span><label class="collapse" for="c-40175544">[-]</label><label class="expand" for="c-40175544">[1 more]</label></div><br/><div class="children"><div class="content">Game engines are tools not fan clubs. It’s reasonable to judge them on their performance for which they are designed. As someone who cares about the commercial viability of their technology choices this is a small but positive signal.<p>What it tells me is someone shipped something and it wasn’t awful. Props to them!</div><br/></div></div><div id="40177655" class="c"><input type="checkbox" id="c-40177655" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174948">parent</a><span>|</span><a href="#40175544">prev</a><span>|</span><a href="#40175304">next</a><span>|</span><label class="collapse" for="c-40177655">[-]</label><label class="expand" for="c-40177655">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A finished game (with presumably decent performance) tells you that if there are problems, they&#x27;re solvable.<p>It doesn&#x27;t tell you <i>anything</i> about velocity, which is by far the most important metric for <i>indie</i> devs.<p>After all, the studio could have expended (maybe) twice as much effort to get a result.</div><br/><div id="40177808" class="c"><input type="checkbox" id="c-40177808" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177655">parent</a><span>|</span><a href="#40175304">next</a><span>|</span><label class="collapse" for="c-40177808">[-]</label><label class="expand" for="c-40177808">[1 more]</label></div><br/><div class="children"><div class="content">Or maybe Rust allowed them to develop twice as fast. Who knows? We&#x27;re going by data here, and this data point shows that games can be made in Bevy. No more and no less.</div><br/></div></div></div></div><div id="40175304" class="c"><input type="checkbox" id="c-40175304" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174948">parent</a><span>|</span><a href="#40177655">prev</a><span>|</span><a href="#40175257">next</a><span>|</span><label class="collapse" for="c-40175304">[-]</label><label class="expand" for="c-40175304">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. We&#x27;ve learned a lot from Godot, by the way. I consider all us open source engines to be in it together :)</div><br/></div></div></div></div></div></div></div></div><div id="40175257" class="c"><input type="checkbox" id="c-40175257" checked=""/><div class="controls bullet"><span class="by">cableshaft</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174160">parent</a><span>|</span><a href="#40174175">prev</a><span>|</span><a href="#40174762">next</a><span>|</span><label class="collapse" for="c-40175257">[-]</label><label class="expand" for="c-40175257">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Also game engines emphatically don&#x27;t have to be huge. Look at Balatro shipping on Love2d.<p>Balatro convinced me that Love2D might be a good contender for my next small 2D game release. I had no idea you could integrate Steamworks or 2D shaders that looked that good into Love2D. And it seems to be very cross-platform, since Balatro released on pretty much every platform on day 1 (with some porting help from a third party developer it seems like).<p>And since it&#x27;s Lua based, I should be able to port a slightly simpler version of the game over to the Playdate console.<p>I&#x27;m also considering Godot, though.</div><br/><div id="40175571" class="c"><input type="checkbox" id="c-40175571" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175257">parent</a><span>|</span><a href="#40174762">next</a><span>|</span><label class="collapse" for="c-40175571">[-]</label><label class="expand" for="c-40175571">[2 more]</label></div><br/><div class="children"><div class="content">There’s a pretty big difference between the Playdate and anything else in performance but also in requirements for assets. So much so I hope your idea is scoped accordingly. But yeah Love2d is great.</div><br/><div id="40176702" class="c"><input type="checkbox" id="c-40176702" checked=""/><div class="controls bullet"><span class="by">cableshaft</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175571">parent</a><span>|</span><a href="#40174762">next</a><span>|</span><label class="collapse" for="c-40176702">[-]</label><label class="expand" for="c-40176702">[1 more]</label></div><br/><div class="children"><div class="content">It is. I&#x27;ve already half ported one of my games to the Playdate (and own one), I&#x27;m pretty aware of its capabilities.<p>The assets are what I struggle with most. 1-bit graphics that look halfway decent are a challenge for me. In my half-ported game, I just draw the tiles programatically, like I did in the Pico-8 version (and they don&#x27;t look anywhere near as good as a lot of Playdate games, so I need to someday sit down and try to get some better art in it).</div><br/></div></div></div></div></div></div></div></div><div id="40174762" class="c"><input type="checkbox" id="c-40174762" checked=""/><div class="controls bullet"><span class="by">jacobgorm</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174029">parent</a><span>|</span><a href="#40174160">prev</a><span>|</span><a href="#40174132">next</a><span>|</span><label class="collapse" for="c-40174762">[-]</label><label class="expand" for="c-40174762">[1 more]</label></div><br/><div class="children"><div class="content">So far I am way less productive in rust than in any language I&#x27;ve ever used for actual work, so to rewrite an entire game engine would seem like commercial suicide.</div><br/></div></div><div id="40174132" class="c"><input type="checkbox" id="c-40174132" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174029">parent</a><span>|</span><a href="#40174762">prev</a><span>|</span><a href="#40176104">next</a><span>|</span><label class="collapse" for="c-40174132">[-]</label><label class="expand" for="c-40174132">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the Google folks are also funding efforts to improve Rust&#x2F;C++ interop, per <a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;02&#x2F;improving-interoperability-between-rust-and-c.html" rel="nofollow">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;02&#x2F;improving-interopera...</a></div><br/><div id="40178167" class="c"><input type="checkbox" id="c-40178167" checked=""/><div class="controls bullet"><span class="by">Sn0wCoder</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174132">parent</a><span>|</span><a href="#40176104">next</a><span>|</span><label class="collapse" for="c-40178167">[-]</label><label class="expand" for="c-40178167">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the link.  This one was also posted awhile back in a rust comment and when I first read it, I thought Google had used Rust in the V8 sandbox, but re-reading it seems that the article uses Rust as an ‘example’ of a memory safe language but does not explicitly say that it uses Rust.  Maybe someone with more knowledge can confirm that Rust was (or was not) used in the V8 Google Chrome sandbox example….<p><a href="https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;sandbox" rel="nofollow">https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;sandbox</a></div><br/></div></div></div></div></div></div><div id="40176104" class="c"><input type="checkbox" id="c-40176104" checked=""/><div class="controls bullet"><span class="by">SunlitCat</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173938">parent</a><span>|</span><a href="#40174029">prev</a><span>|</span><a href="#40174416">next</a><span>|</span><label class="collapse" for="c-40176104">[-]</label><label class="expand" for="c-40176104">[1 more]</label></div><br/><div class="children"><div class="content">Theoretically accessible describes the experience of trying to use D3D from C very well!<p>Was trying to use it with some kind of gcc for windows. The C++ part was still lacking some required features, so it was advised to use D3D from C instead C++. There were some helper macros, but overall I was glad when Microsoft started to release their Express (and later Community) Editions of Visual Studio.</div><br/></div></div><div id="40174416" class="c"><input type="checkbox" id="c-40174416" checked=""/><div class="controls bullet"><span class="by">IggleSniggle</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173938">parent</a><span>|</span><a href="#40176104">prev</a><span>|</span><a href="#40174129">next</a><span>|</span><label class="collapse" for="c-40174416">[-]</label><label class="expand" for="c-40174416">[1 more]</label></div><br/><div class="children"><div class="content">That description of problems bodes well for Zig</div><br/></div></div><div id="40174129" class="c"><input type="checkbox" id="c-40174129" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173938">parent</a><span>|</span><a href="#40174416">prev</a><span>|</span><a href="#40174521">next</a><span>|</span><label class="collapse" for="c-40174129">[-]</label><label class="expand" for="c-40174129">[2 more]</label></div><br/><div class="children"><div class="content">not true anymore, c11 and c17 are either supported or coming<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;cppblog&#x2F;c11-and-c17-standard-support-arriving-in-msvc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;cppblog&#x2F;c11-and-c17-standard-...</a></div><br/><div id="40174299" class="c"><input type="checkbox" id="c-40174299" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174129">parent</a><span>|</span><a href="#40174521">next</a><span>|</span><label class="collapse" for="c-40174299">[-]</label><label class="expand" for="c-40174299">[1 more]</label></div><br/><div class="children"><div class="content">Not really relevant to 30 years ago though.</div><br/></div></div></div></div></div></div><div id="40174521" class="c"><input type="checkbox" id="c-40174521" checked=""/><div class="controls bullet"><span class="by">georgeecollins</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173779">parent</a><span>|</span><a href="#40173938">prev</a><span>|</span><a href="#40174113">next</a><span>|</span><label class="collapse" for="c-40174521">[-]</label><label class="expand" for="c-40174521">[4 more]</label></div><br/><div class="children"><div class="content">I worked on many of Activision&#x27;s games 1995-2000 and C++ was the overwhelming choice of programming language for PC games.  C was more common for console.  In 1996 the quality of MSFT IDE&#x2F; Compiler, plus the CPUs available at the time was such that it could take an hour to compile a big game.  By 1998 it was a few minutes.  As I recall I think MSFT purchased another companies compiler and that really changed Visual Studio.</div><br/><div id="40175679" class="c"><input type="checkbox" id="c-40175679" checked=""/><div class="controls bullet"><span class="by">philiplu</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174521">parent</a><span>|</span><a href="#40175589">next</a><span>|</span><label class="collapse" for="c-40175679">[-]</label><label class="expand" for="c-40175679">[2 more]</label></div><br/><div class="children"><div class="content">I was a developer on the Microsoft C++ compiler team from 1991 to 2006.  We definitely didn&#x27;t purchase someone else&#x27;s compiler in that time.  We looked at the EDG front end at various times but never moved over to it while I was there.<p>Perhaps the speed-up you remember had something to do with the switch-over from 16 bits to 32, which would have been the early to mid 90s.  Or you&#x27;re thinking of Microsoft&#x27;s C compiler starting from Lattice C, back in the 80s before my time.  There was also a lot of work done on pre-compiled headers to speed compilation in the latter half of the 90s (including some that I was responsible for).</div><br/><div id="40178181" class="c"><input type="checkbox" id="c-40178181" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175679">parent</a><span>|</span><a href="#40175589">next</a><span>|</span><label class="collapse" for="c-40178181">[-]</label><label class="expand" for="c-40178181">[1 more]</label></div><br/><div class="children"><div class="content">I heard that early versions of C++ IntelliSense from Visual Studio used Edison Design Group&#x27;s (EDG) front end.  Is that true?  No trolling here -- honest question.  If yes, are they still using it now?</div><br/></div></div></div></div><div id="40175589" class="c"><input type="checkbox" id="c-40175589" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174521">parent</a><span>|</span><a href="#40175679">prev</a><span>|</span><a href="#40174113">next</a><span>|</span><label class="collapse" for="c-40175589">[-]</label><label class="expand" for="c-40175589">[1 more]</label></div><br/><div class="children"><div class="content">I was a teenager at that point. I learnt C in the early 90s and C++ after 96 IIRC. Didn’t start professionally in games until 2004 though!</div><br/></div></div></div></div></div></div><div id="40173852" class="c"><input type="checkbox" id="c-40173852" checked=""/><div class="controls bullet"><span class="by">delfinom</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173733">parent</a><span>|</span><a href="#40173779">prev</a><span>|</span><a href="#40175080">next</a><span>|</span><label class="collapse" for="c-40173852">[-]</label><label class="expand" for="c-40173852">[9 more]</label></div><br/><div class="children"><div class="content">Kind of both in my opinion. But rust is bringing nothing to the table that games need.<p>At best rust fixes crash bugs and not the usual  logic and rendering bugs that are far more involved and plague users more often.</div><br/><div id="40174063" class="c"><input type="checkbox" id="c-40174063" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173852">parent</a><span>|</span><a href="#40178277">next</a><span>|</span><label class="collapse" for="c-40174063">[-]</label><label class="expand" for="c-40174063">[7 more]</label></div><br/><div class="children"><div class="content">The ability of engines like Bevy to automatically schedule dependencies and multithread systems, which relies on Rust&#x27;s strictness around mutability, is a big advantage. Speaking as someone who&#x27;s spent a long time looking at Bevy profiles, the increased parallelism really helps.<p>Of course, you can do job queuing systems in C++ too. But Rust naturally pushes you toward the more parallel path with all your logic. In C++ the temptation is to start sequential to avoid data races; in systems like Bevy, you start parallel to begin with.</div><br/><div id="40174363" class="c"><input type="checkbox" id="c-40174363" checked=""/><div class="controls bullet"><span class="by">NBJack</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174063">parent</a><span>|</span><a href="#40178277">next</a><span>|</span><label class="collapse" for="c-40174363">[-]</label><label class="expand" for="c-40174363">[6 more]</label></div><br/><div class="children"><div class="content">Aside from a physics simulation, I&#x27;m curious as to what you think would be a positive cost benefit from that level of multithreading for the majority of game engines. Graphical pipelines take advantage of the concept but offload as much work as possible to the GPU.</div><br/><div id="40177219" class="c"><input type="checkbox" id="c-40177219" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174363">parent</a><span>|</span><a href="#40174456">next</a><span>|</span><label class="collapse" for="c-40177219">[-]</label><label class="expand" for="c-40177219">[3 more]</label></div><br/><div class="children"><div class="content">We were doing threading beyond that in 2010, you could easily have rendering, physics, animation, audio and other subsystems chugging along on different threads. As I was leaving the industry most engines were trending towards very parallel concurrent job execution systems.<p>The PS3 was also an interesting architecture(i.e. SPUs) from that perspective but it was so distant from the current time that it never really took off. Getting existing things ported to it was a beast.<p>Bevy <i>really</i> nails the concurrency right IMO(having worked on AA&#x2F;AAA engines in the past) it&#x27;s missing a ton in other dimensions but the actual ECS + scheduling APIs are a joy. Last &quot;proper&quot; engine I worked on was a rats-nest of concurrency in comparison.<p>That said as a few other people pointed out, the key is iteration, hot-reload and other things. Given the choice I&#x27;d probably do(and have done) a Rust based engine core where you need performance&#x2F;stability and some dynamic language on top(Lua, quickjs, etc) for actual game content.</div><br/><div id="40177467" class="c"><input type="checkbox" id="c-40177467" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177219">parent</a><span>|</span><a href="#40174456">next</a><span>|</span><label class="collapse" for="c-40177467">[-]</label><label class="expand" for="c-40177467">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That said as a few other people pointed out, the key is iteration, hot-reload and other things. Given the choice I&#x27;d probably do(and have done) a Rust based engine core where you need performance&#x2F;stability and some dynamic language on top(Lua, quickjs, etc) for actual game content.<p>I fully agree that this will likely be the solution a lot of people want to go with in Bevy: scripting for quick iteration, Rust for the stuff that has to be fast. (Also thank you for the kind words!)</div><br/><div id="40177569" class="c"><input type="checkbox" id="c-40177569" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177467">parent</a><span>|</span><a href="#40174456">next</a><span>|</span><label class="collapse" for="c-40177569">[-]</label><label class="expand" for="c-40177569">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s a fairly clean and natural divide. You see it in most of the major engines and it was present in all the proprietary engines I worked on(we mostly used Lua&#x2F;LuaJIT since this predated some great recent options like quickjs).<p>We even had things like designers writing scripts for AI in literate programming with Lua using coroutines. We fit in 400kb of space for code + runtime using Lua on the PSP(man that platform was a nightmare but the scripting worked out really well).<p>Rust excels when you know what you want to build, and core engine tech fits that category pretty cleanly. Once you get up in game logic&#x2F;behavior that iteration loop is so dynamic that you are prototyping more than developing.</div><br/></div></div></div></div></div></div><div id="40174456" class="c"><input type="checkbox" id="c-40174456" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174363">parent</a><span>|</span><a href="#40177219">prev</a><span>|</span><a href="#40174457">next</a><span>|</span><label class="collapse" for="c-40174456">[-]</label><label class="expand" for="c-40174456">[1 more]</label></div><br/><div class="children"><div class="content">In big-world high-detail games, the rendering operation wants so much time that the main thread has time for little else. There&#x27;s physics, there&#x27;s networking, there&#x27;s game movement, there&#x27;s NPC AI - those all need some time. If you can get that time from another CPU, rendering tends to go faster.<p>I tend to overdo parallelism. Load this file into a Tracy profile, version 0.10.0, and you can see what all the threads in my program are doing.[1] Currently I&#x27;m dealing with locking stalls at the WGPU level. If you have application&#x2F;Rend3&#x2F;WGPU&#x2F;Vulkan&#x2F;GPU parallism, every layer has to get it right.<p>Why? Because the C++ clients hit a framerate wall, with the main thread at 100% and no way to get faster.<p>[1] <a href="https:&#x2F;&#x2F;animats.com&#x2F;sl&#x2F;misc&#x2F;traces&#x2F;clockhavenspeed02.tracy" rel="nofollow">https:&#x2F;&#x2F;animats.com&#x2F;sl&#x2F;misc&#x2F;traces&#x2F;clockhavenspeed02.tracy</a></div><br/></div></div><div id="40174457" class="c"><input type="checkbox" id="c-40174457" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174363">parent</a><span>|</span><a href="#40174456">prev</a><span>|</span><a href="#40178277">next</a><span>|</span><label class="collapse" for="c-40174457">[-]</label><label class="expand" for="c-40174457">[1 more]</label></div><br/><div class="children"><div class="content">Animations are an example. I landed code in Bevy 0.13 to evaluate all AnimationTargets (in Unity speak, animators) for all objects in parallel. (This can&#x27;t be done on GPU because animations can affect the transforms of entities, which can cause collisions, etc. triggering arbitrary game logic.) For my test workload with 10,000 skinned meshes, it bumped up the FPS by quite a bit.</div><br/></div></div></div></div></div></div><div id="40178277" class="c"><input type="checkbox" id="c-40178277" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173852">parent</a><span>|</span><a href="#40174063">prev</a><span>|</span><a href="#40175080">next</a><span>|</span><label class="collapse" for="c-40178277">[-]</label><label class="expand" for="c-40178277">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Fearless concurrency&quot;</div><br/></div></div></div></div></div></div><div id="40175080" class="c"><input type="checkbox" id="c-40175080" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173485">parent</a><span>|</span><a href="#40173733">prev</a><span>|</span><a href="#40175944">next</a><span>|</span><label class="collapse" for="c-40175080">[-]</label><label class="expand" for="c-40175080">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, gaming industry has become mature enough to build up its own inertia so it will take some time for new technologies to take off. C# has become a mainstream gamedev language thanks to Unity, but this also took more than a decade.</div><br/></div></div><div id="40175944" class="c"><input type="checkbox" id="c-40175944" checked=""/><div class="controls bullet"><span class="by">augusto-moura</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173485">parent</a><span>|</span><a href="#40175080">prev</a><span>|</span><a href="#40176084">next</a><span>|</span><label class="collapse" for="c-40175944">[-]</label><label class="expand" for="c-40175944">[1 more]</label></div><br/><div class="children"><div class="content">The concept of AAA games didn&#x27;t even exist back in 1985, very few people were developing games at that era, and even fewer were writing &quot;complex&quot; games that would need C++.<p>The SNES came on 1990 and even then it had it&#x27;s own architecture and most games were written in pure assembly. The PlayStation had a MIPS CPU and was one of the first to popularize 3D graphics, the biggest complexity leap.<p>I believe your are seeing causation were only correlation should be given. C++ and more complex OOP languages just joined the scene when the games themselves became complex, because of hardware and market natural evolution</div><br/></div></div><div id="40176084" class="c"><input type="checkbox" id="c-40176084" checked=""/><div class="controls bullet"><span class="by">dimitrios1</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173485">parent</a><span>|</span><a href="#40175944">prev</a><span>|</span><a href="#40174218">next</a><span>|</span><label class="collapse" for="c-40176084">[-]</label><label class="expand" for="c-40176084">[1 more]</label></div><br/><div class="children"><div class="content">Comparing the time it takes for a prog language to spread from the 80s to today is a bad vantage point. Stuff took much longer to bake back then -- but even so the point is moot, as other commentors pointed out, it took off roughly the same amount of time between 2015 and today.</div><br/></div></div><div id="40174218" class="c"><input type="checkbox" id="c-40174218" checked=""/><div class="controls bullet"><span class="by">holoduke</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173485">parent</a><span>|</span><a href="#40176084">prev</a><span>|</span><a href="#40173690">next</a><span>|</span><label class="collapse" for="c-40174218">[-]</label><label class="expand" for="c-40174218">[3 more]</label></div><br/><div class="children"><div class="content">Many tried c++ in early 90s, but wasnt it too slow&#x2F;memory intensive? You had to implement lots of inline c&#x2F;assembly to have a bit of performance. Nowadays everything is heavily optimized, but back then not.</div><br/><div id="40174567" class="c"><input type="checkbox" id="c-40174567" checked=""/><div class="controls bullet"><span class="by">ovao</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174218">parent</a><span>|</span><a href="#40173690">next</a><span>|</span><label class="collapse" for="c-40174567">[-]</label><label class="expand" for="c-40174567">[2 more]</label></div><br/><div class="children"><div class="content">If you’re referring to game dev specifically, there have been (and continue to be) concerns around the weight of C++ exception handling, which is deeply-embedded in the STL. This proliferated in libraries like the EASTL. C++ itself however is intended to have as many zero-cost abstractions as possible&#x2F;reasonable.<p>The cost of exception handling is less of a concern these days though.</div><br/><div id="40176418" class="c"><input type="checkbox" id="c-40176418" checked=""/><div class="controls bullet"><span class="by">justinhj</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174567">parent</a><span>|</span><a href="#40173690">next</a><span>|</span><label class="collapse" for="c-40176418">[-]</label><label class="expand" for="c-40176418">[1 more]</label></div><br/><div class="children"><div class="content">Exception handling is easy enough to disable. Luckily, or C would probably still be the game developers go to.</div><br/></div></div></div></div></div></div></div></div><div id="40173690" class="c"><input type="checkbox" id="c-40173690" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40173485">prev</a><span>|</span><a href="#40173528">next</a><span>|</span><label class="collapse" for="c-40173690">[-]</label><label class="expand" for="c-40173690">[12 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d expected some AAA title to be written in Rust by now.<p>Why? Those kinds of game engines are enormous amounts of code, and there&#x27;s little incentive to rewrite.<p>I do strongly disagree that we aren&#x27;t ever going to see large-scale game development in Rust; it just takes time. Whether games adopt an engine is largely about that engine&#x27;s maturity rather than anything about the language. Bevy is quite young; 0.13 doesn&#x27;t even have support for animation blending yet (I landed that for 0.14).</div><br/><div id="40174123" class="c"><input type="checkbox" id="c-40174123" checked=""/><div class="controls bullet"><span class="by">VelesDude</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173690">parent</a><span>|</span><a href="#40173528">next</a><span>|</span><label class="collapse" for="c-40174123">[-]</label><label class="expand" for="c-40174123">[11 more]</label></div><br/><div class="children"><div class="content">It was a few years back that the question came up to the developers of a Call of Duty title. &quot;Is there still code from Quake 3 in COD?&quot;. They dodge around it by saying something like &quot;we cannot deny this but e use the most appropriate tech where needed&quot;.<p>While not confirmation, I wouldn&#x27;t be surprised if there is a few nuggets of Q3 in that code base still doing some of the basics. That would be really cool if it is true.<p>It seems like unless you are someone like John Carmack or most of Nintendo, game dev tools are about what can get the best results quickest rather than any sort of technical specifics. It is a business after all.</div><br/><div id="40174606" class="c"><input type="checkbox" id="c-40174606" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174123">parent</a><span>|</span><a href="#40174269">next</a><span>|</span><label class="collapse" for="c-40174606">[-]</label><label class="expand" for="c-40174606">[2 more]</label></div><br/><div class="children"><div class="content">A neat real-world example of ancient Quake code surviving to this day is visible in Valves games - the hardcoded patterns for flickering lights in Quake 1 survived into GoldSrc and then into Source and then into Source 2, most recently showing up in Half Life Alyx, 24 years on from their original appearance in Quake 1.<p><a href="https:&#x2F;&#x2F;www.alanzucconi.com&#x2F;2021&#x2F;06&#x2F;15&#x2F;valve-flickering-lights&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.alanzucconi.com&#x2F;2021&#x2F;06&#x2F;15&#x2F;valve-flickering-ligh...</a><p>Basically all of the bigger systems will have been Ship-of-Theseus&#x27;d several times over by now, but little things like that can slip through the cracks.</div><br/><div id="40178252" class="c"><input type="checkbox" id="c-40178252" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174606">parent</a><span>|</span><a href="#40174269">next</a><span>|</span><label class="collapse" for="c-40178252">[-]</label><label class="expand" for="c-40178252">[1 more]</label></div><br/><div class="children"><div class="content">That light flickering is quite cool, thanks for sharing. It reminds me of the Wilhelm scream, but on a much smaller scale of course.</div><br/></div></div></div></div><div id="40174269" class="c"><input type="checkbox" id="c-40174269" checked=""/><div class="controls bullet"><span class="by">scruple</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174123">parent</a><span>|</span><a href="#40174606">prev</a><span>|</span><a href="#40174361">next</a><span>|</span><label class="collapse" for="c-40174269">[-]</label><label class="expand" for="c-40174269">[2 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s the question... Let me assure you that there are decades-old pieces of code inside of, and used to assemble, many modern AAA games coming out of mature studios. The systems and tooling is typically carried forward. I don&#x27;t think this is some big secret and you&#x27;ve intuited exactly the reason why:<p>&gt; game dev tools are about what can get the best results quickest rather than any sort of technical specifics. It is a business after all.</div><br/><div id="40176045" class="c"><input type="checkbox" id="c-40176045" checked=""/><div class="controls bullet"><span class="by">VelesDude</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174269">parent</a><span>|</span><a href="#40174361">next</a><span>|</span><label class="collapse" for="c-40176045">[-]</label><label class="expand" for="c-40176045">[1 more]</label></div><br/><div class="children"><div class="content">Not surprised at all that this stuff sticks around. I find it very endearing actually. Ain&#x27;t broke, don&#x27;t fix it!</div><br/></div></div></div></div><div id="40174361" class="c"><input type="checkbox" id="c-40174361" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174123">parent</a><span>|</span><a href="#40174269">prev</a><span>|</span><a href="#40177641">next</a><span>|</span><label class="collapse" for="c-40174361">[-]</label><label class="expand" for="c-40174361">[4 more]</label></div><br/><div class="children"><div class="content">A lot of big projects have amazing longevity to their older architectural decisions. Unreal still has a lot of stuff in it people that used UE1 would recognize, I did most of my professional development on UE3 and a bunch of that is still pretty recognizable. Similarly Chrome is a product of the time it was first created. And looking into the Windows source is probably like staring into the stygian abyss.<p>There is a lot of legacy and tech debt out there!</div><br/><div id="40176072" class="c"><input type="checkbox" id="c-40176072" checked=""/><div class="controls bullet"><span class="by">VelesDude</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174361">parent</a><span>|</span><a href="#40177641">next</a><span>|</span><label class="collapse" for="c-40176072">[-]</label><label class="expand" for="c-40176072">[3 more]</label></div><br/><div class="children"><div class="content">I remember years back someone form Microsoft calling the windows code base &quot;The Abyss&quot; because of how much technical legacy there was in it.<p>I think it was Steve Gibson who said that the Windows code base had some very questionable things in it. For instance they had work experience high school students working on code that made it into the final build that was less than spectacular. Like how Windows used to stall when you put a CD in and wouldn&#x27;t proceed until the disc spun up and started reading data.<p>Windows 11 probably would still do that but I don&#x27;t know because I don&#x27;t have a disc drive any more.</div><br/><div id="40176622" class="c"><input type="checkbox" id="c-40176622" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40176072">parent</a><span>|</span><a href="#40177881">next</a><span>|</span><label class="collapse" for="c-40176622">[-]</label><label class="expand" for="c-40176622">[1 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t really windows lagging, it was explorer. There used to be more things in explorer that were blocked on something ultimately blocked by I&#x2F;O.<p>This tends to not be the case so much any more, so I doubt it would happen today.<p>Instead you get the dreaded &quot;Working on it....&quot;. It seem&#x27;s like hard drives can be just as slow to spin up these days as CDs were back in the day.</div><br/></div></div><div id="40177881" class="c"><input type="checkbox" id="c-40177881" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40176072">parent</a><span>|</span><a href="#40176622">prev</a><span>|</span><a href="#40177641">next</a><span>|</span><label class="collapse" for="c-40177881">[-]</label><label class="expand" for="c-40177881">[1 more]</label></div><br/><div class="children"><div class="content">Damn I forgot about explorer hanging when you put a CD in. That was especially terrible when you didn&#x27;t have DMA</div><br/></div></div></div></div></div></div><div id="40177641" class="c"><input type="checkbox" id="c-40177641" checked=""/><div class="controls bullet"><span class="by">johnnyanmac</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174123">parent</a><span>|</span><a href="#40174361">prev</a><span>|</span><a href="#40173528">next</a><span>|</span><label class="collapse" for="c-40177641">[-]</label><label class="expand" for="c-40177641">[2 more]</label></div><br/><div class="children"><div class="content">&gt; game dev tools are about what can get the best results quickest rather than any sort of technical specifics. It is a business after all.<p>Bingo. Rust&#x27;s biggest strength is correctness. But games aren&#x27;t mission critical, and gamers are very tolerant towards bugs (maybe not on social media, but very few buggy games have had their sales impacted). Your biggest sale to AAA game devs are to engine programmers to minimize tech debt. But as we are seeing with the current industry, that&#x27;s not exactly something companies care about until it&#x27;s too late.<p>Then on the indie level we get articles like this. Half the article ultimately came down to &quot;it&#x27;s faster to break things and iterate than to do it right once&quot;.  Again, similar lack of need for bug-free games. In addition, few indie games are scoped to a point where they need a highly disciplined ECS solution to scale with.<p>The author even criticizes the &quot;tech specs&quot; community part of rust gamedev. Different tools, diferent goals, different needs. IMO, I think Rust will help make for some very robust renderers one day, but ultimaely the scripting will be done on another language. Similar to how Unity uses C# scripting to a C++ engine, that they IL2CPP to bring back to a full C++ game.</div><br/><div id="40177870" class="c"><input type="checkbox" id="c-40177870" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177641">parent</a><span>|</span><a href="#40173528">next</a><span>|</span><label class="collapse" for="c-40177870">[-]</label><label class="expand" for="c-40177870">[1 more]</label></div><br/><div class="children"><div class="content">This, exactly. As an embedded turned Unreal developer the first impression I had while using Unreal is how little concern for correctness there is overall. UB is used liberally, and there&#x27;s clearly a larger focus on development speed and ease off use compared to safety and correctness. If a game has integer overflow or buffer overflows nobody cares. Viceversa, you need to keep the whole thing usable enough for the various 3D artists and such who have a hard time understanding advanced programming.</div><br/></div></div></div></div></div></div></div></div><div id="40173528" class="c"><input type="checkbox" id="c-40173528" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40173690">prev</a><span>|</span><a href="#40175020">next</a><span>|</span><label class="collapse" for="c-40173528">[-]</label><label class="expand" for="c-40173528">[20 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;async&quot; system is optimized for someone who needs to run a very large web server,<p>Even there it&#x27;s very problematic at scale unless you know what you&#x27;re doing. async&#x2F;await isn&#x27;t zero cost, regardless of what people will tell you.</div><br/><div id="40173737" class="c"><input type="checkbox" id="c-40173737" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173528">parent</a><span>|</span><a href="#40175020">next</a><span>|</span><label class="collapse" for="c-40173737">[-]</label><label class="expand" for="c-40173737">[19 more]</label></div><br/><div class="children"><div class="content">Absolutely. Async&#x2F;await typically improves headroom (scalability) at the cost of latency and throughput. It may also make code easier to reason about.</div><br/><div id="40174036" class="c"><input type="checkbox" id="c-40174036" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173737">parent</a><span>|</span><a href="#40175501">next</a><span>|</span><label class="collapse" for="c-40174036">[-]</label><label class="expand" for="c-40174036">[1 more]</label></div><br/><div class="children"><div class="content">I disagree with this, you&#x27;re probably not paying much (if at all) in latency or throughput for better scaling.<p>What you&#x27;re paying for with async&#x2F;await is a state machine that describes the concurrent task, but that state machine can be incredibly wasteful in size due to the design of futures and the desugaring pass that converts async&#x2F;await into the state machine.<p>That&#x27;s why I said it&#x27;s not &quot;zero cost&quot; in the loosest definition of the phrase - you can write a better implementation by hand.</div><br/></div></div><div id="40175501" class="c"><input type="checkbox" id="c-40175501" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173737">parent</a><span>|</span><a href="#40174036">prev</a><span>|</span><a href="#40173799">next</a><span>|</span><label class="collapse" for="c-40175501">[-]</label><label class="expand" for="c-40175501">[3 more]</label></div><br/><div class="children"><div class="content">Definitely makes code harder to reason about.</div><br/><div id="40176291" class="c"><input type="checkbox" id="c-40176291" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175501">parent</a><span>|</span><a href="#40173799">next</a><span>|</span><label class="collapse" for="c-40176291">[-]</label><label class="expand" for="c-40176291">[2 more]</label></div><br/><div class="children"><div class="content">If you were to write the same code without using async you&#x27;d be trudging through a mess of callbacks and combinators.  This is what writing futures code before 2018 was like.  It was doable if you needed the perf but it sucked.  Async is a huge improvement to readability and reasoning that we didn&#x27;t have before.</div><br/><div id="40177387" class="c"><input type="checkbox" id="c-40177387" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40176291">parent</a><span>|</span><a href="#40173799">next</a><span>|</span><label class="collapse" for="c-40177387">[-]</label><label class="expand" for="c-40177387">[1 more]</label></div><br/><div class="children"><div class="content">No, actually that was just javascript. Programming environments with threading models don&#x27;t have to live that way. Separate threads can communicate through channels and do quite well for themselves. See how it works is, you do something like let data = file.read(); and the it just sits there on that line until the read is done and then your data has the actual bytes in it and you just use them and go on with your life.</div><br/></div></div></div></div></div></div><div id="40173799" class="c"><input type="checkbox" id="c-40173799" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173737">parent</a><span>|</span><a href="#40175501">prev</a><span>|</span><a href="#40175020">next</a><span>|</span><label class="collapse" for="c-40173799">[-]</label><label class="expand" for="c-40173799">[14 more]</label></div><br/><div class="children"><div class="content">&gt; at the cost of latency and throughput.<p>Compared to what?<p>Doing epoll manually?</div><br/><div id="40174934" class="c"><input type="checkbox" id="c-40174934" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173799">parent</a><span>|</span><a href="#40174674">next</a><span>|</span><label class="collapse" for="c-40174934">[-]</label><label class="expand" for="c-40174934">[3 more]</label></div><br/><div class="children"><div class="content">A reactor has to move the pending task to some type of work queue. The task has to pulled off the work queue. The work queue is oblivious as to the priority of your tasks. Tasks aren&#x27;t as expensive as context switching, but they aren&#x27;t free either: e.g. likely to ruin CPU caches. Less code is fewer instructions is less time.<p>If you care enough, you generally should be able to outdo the reactor and state machines. Whether you should care enough is debatable.</div><br/><div id="40175839" class="c"><input type="checkbox" id="c-40175839" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174934">parent</a><span>|</span><a href="#40176962">next</a><span>|</span><label class="collapse" for="c-40175839">[-]</label><label class="expand" for="c-40175839">[1 more]</label></div><br/><div class="children"><div class="content">The cache thing is a thing I think a lot of people with a more... naive... understanding of machine architecture don&#x27;t clue into.<p>Even just synchronizing on an atomic can thrash branch prediction and L1 caches both, let alone working your way through a task queue and interrupting program flow to do so.</div><br/></div></div><div id="40176962" class="c"><input type="checkbox" id="c-40176962" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174934">parent</a><span>|</span><a href="#40175839">prev</a><span>|</span><a href="#40174674">next</a><span>|</span><label class="collapse" for="c-40176962">[-]</label><label class="expand" for="c-40176962">[1 more]</label></div><br/><div class="children"><div class="content">So yeah, you&#x27;re thinking about the comparison between async&#x2F;await and manual state machines management with epoll. But that&#x27;s not what most people have in mind when you&#x27;re saying async&#x2F;await have performance impact, most of them would immediately think you&#x27;re talking about the difference with threads.</div><br/></div></div></div></div><div id="40174674" class="c"><input type="checkbox" id="c-40174674" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173799">parent</a><span>|</span><a href="#40174934">prev</a><span>|</span><a href="#40173845">next</a><span>|</span><label class="collapse" for="c-40174674">[-]</label><label class="expand" for="c-40174674">[2 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m not doing slow blocking I&#x2F;O, I&#x27;m not doing epoll anyways.<p>But the moment somebody drops async into my codebase, yay, now I get to pay the cost.</div><br/><div id="40176967" class="c"><input type="checkbox" id="c-40176967" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174674">parent</a><span>|</span><a href="#40173845">next</a><span>|</span><label class="collapse" for="c-40176967">[-]</label><label class="expand" for="c-40176967">[1 more]</label></div><br/><div class="children"><div class="content">Either you are doing slow IO (in some of your dependency) or you don&#x27;t have anyone dropping async in your code though…</div><br/></div></div></div></div><div id="40173845" class="c"><input type="checkbox" id="c-40173845" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173799">parent</a><span>|</span><a href="#40174674">prev</a><span>|</span><a href="#40175020">next</a><span>|</span><label class="collapse" for="c-40173845">[-]</label><label class="expand" for="c-40173845">[8 more]</label></div><br/><div class="children"><div class="content">Threading, probably.</div><br/><div id="40174530" class="c"><input type="checkbox" id="c-40174530" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173845">parent</a><span>|</span><a href="#40174039">next</a><span>|</span><label class="collapse" for="c-40174530">[-]</label><label class="expand" for="c-40174530">[4 more]</label></div><br/><div class="children"><div class="content">Async&#x2F;await isn&#x27;t related to threading (although many users and implementations confuse them); it&#x27;s a way of transforming a function into a suspendable state machine.</div><br/><div id="40174829" class="c"><input type="checkbox" id="c-40174829" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174530">parent</a><span>|</span><a href="#40174039">next</a><span>|</span><label class="collapse" for="c-40174829">[-]</label><label class="expand" for="c-40174829">[3 more]</label></div><br/><div class="children"><div class="content">I know. But threading, and earlier processes, were less scalable but potentially faster ways of handling concurrent requests.</div><br/><div id="40175037" class="c"><input type="checkbox" id="c-40175037" checked=""/><div class="controls bullet"><span class="by">otterley</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174829">parent</a><span>|</span><a href="#40174039">next</a><span>|</span><label class="collapse" for="c-40175037">[-]</label><label class="expand" for="c-40175037">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also much easier to reason about, since scheduling is no longer your problem and you can just write sequential code.</div><br/><div id="40176950" class="c"><input type="checkbox" id="c-40176950" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175037">parent</a><span>|</span><a href="#40174039">next</a><span>|</span><label class="collapse" for="c-40176950">[-]</label><label class="expand" for="c-40176950">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one way to see it. But the symmetric view is equally valid: async await is easier to reason about because you see were the block points are instead of having to guess which function is blocking or not.<p>In any case you <i>aren&#x27;t</i> writing sequential code, it&#x27;s still concurrent code, and there&#x27;s a trade-off between the <i>writing</i> simplicity of writing it <i>as if it was</i> sequential code, and the <i>reading simplicity</i> of having things written down explicitly.<p>This “write-time vs read-time” trade of is everywhere in programming BTW, that&#x27;s also the difference between error-as-return-values and exception, or between dynamic typing and static one for instance.</div><br/></div></div></div></div></div></div></div></div><div id="40174039" class="c"><input type="checkbox" id="c-40174039" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173845">parent</a><span>|</span><a href="#40174530">prev</a><span>|</span><a href="#40174174">next</a><span>|</span><label class="collapse" for="c-40174039">[-]</label><label class="expand" for="c-40174039">[2 more]</label></div><br/><div class="children"><div class="content">Threading is compatible with async</div><br/><div id="40174845" class="c"><input type="checkbox" id="c-40174845" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174039">parent</a><span>|</span><a href="#40174174">next</a><span>|</span><label class="collapse" for="c-40174845">[-]</label><label class="expand" for="c-40174845">[1 more]</label></div><br/><div class="children"><div class="content">&quot;threading alone&quot; as in a thread per request.</div><br/></div></div></div></div><div id="40174174" class="c"><input type="checkbox" id="c-40174174" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173845">parent</a><span>|</span><a href="#40174039">prev</a><span>|</span><a href="#40175020">next</a><span>|</span><label class="collapse" for="c-40174174">[-]</label><label class="expand" for="c-40174174">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so, because there isn&#x27;t a performance drawback compared to threads when using async. In fact there&#x27;s literally nothing preventing you from using a thread per task as your future runtime and just blocking on `.await` (and implementing something like that is a common introduction to how async executors run under the hood so it&#x27;s not particularly convoluted).<p>Sure there&#x27;s no reason to do <i>that</i>, because non-blocking syscalls are just better, but you can…</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40175020" class="c"><input type="checkbox" id="c-40175020" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40173528">prev</a><span>|</span><a href="#40176747">next</a><span>|</span><label class="collapse" for="c-40175020">[-]</label><label class="expand" for="c-40175020">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d expected some AAA title to be written in Rust by now. That hasn&#x27;t happened, and it&#x27;s probably not going to happen, for the reasons the author gives.<p>The main reason is that you can&#x27;t ship that Rust code on PS5 in a sensible manner. People have tried, got useless toys to compile, but in the end even Embark gave up. I remember seeing something from them that they had moved Rust to server-only.</div><br/><div id="40175291" class="c"><input type="checkbox" id="c-40175291" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175020">parent</a><span>|</span><a href="#40176747">next</a><span>|</span><label class="collapse" for="c-40175291">[-]</label><label class="expand" for="c-40175291">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The main reason is that you can&#x27;t ship that Rust code on PS5 in a sensible manner.<p>Really - why’s that?</div><br/><div id="40175689" class="c"><input type="checkbox" id="c-40175689" checked=""/><div class="controls bullet"><span class="by">tormeh</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175291">parent</a><span>|</span><a href="#40176747">next</a><span>|</span><label class="collapse" for="c-40175689">[-]</label><label class="expand" for="c-40175689">[3 more]</label></div><br/><div class="children"><div class="content">Sony requires that you use their tooling, which you can only get under NDA.</div><br/><div id="40176507" class="c"><input type="checkbox" id="c-40176507" checked=""/><div class="controls bullet"><span class="by">justinhj</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175689">parent</a><span>|</span><a href="#40177970">next</a><span>|</span><label class="collapse" for="c-40176507">[-]</label><label class="expand" for="c-40176507">[1 more]</label></div><br/><div class="children"><div class="content">If there was significant pressure from developers Sony would allow Rust. I doubt there is any.</div><br/></div></div><div id="40177970" class="c"><input type="checkbox" id="c-40177970" checked=""/><div class="controls bullet"><span class="by">vintermann</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175689">parent</a><span>|</span><a href="#40176507">prev</a><span>|</span><a href="#40176747">next</a><span>|</span><label class="collapse" for="c-40177970">[-]</label><label class="expand" for="c-40177970">[1 more]</label></div><br/><div class="children"><div class="content">Really a shame that there&#x27;s that sort of thing going on in 2024 too.</div><br/></div></div></div></div></div></div></div></div><div id="40176747" class="c"><input type="checkbox" id="c-40176747" checked=""/><div class="controls bullet"><span class="by">rr808</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40175020">prev</a><span>|</span><a href="#40173035">next</a><span>|</span><label class="collapse" for="c-40176747">[-]</label><label class="expand" for="c-40176747">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I tend to agree about the &quot;async contamination&quot; problem.<p>Argh I have the same issue. Sure if you write JS or Python you probably need async. My current Java back end that has like 5 concurrent users does not need async everything making 10x the complexity.</div><br/></div></div><div id="40173035" class="c"><input type="checkbox" id="c-40173035" checked=""/><div class="controls bullet"><span class="by">int0x29</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40176747">prev</a><span>|</span><a href="#40174655">next</a><span>|</span><label class="collapse" for="c-40173035">[-]</label><label class="expand" for="c-40173035">[12 more]</label></div><br/><div class="children"><div class="content">&gt; * There are very few people doing serious 3D game work in Rust. There&#x27;s Veloren, and my stuff, and maybe a few others. No big, popular titles. I&#x27;d expected some AAA title to be written in Rust by now. That hasn&#x27;t happened, and it&#x27;s probably not going to happen, for the reasons the author gives.<p>At one point the studio behind the Finals was writing game server code in Rust with an Unreal engine client.  Not sure if that&#x27;s true still</div><br/><div id="40173534" class="c"><input type="checkbox" id="c-40173534" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173035">parent</a><span>|</span><a href="#40173144">next</a><span>|</span><label class="collapse" for="c-40173534">[-]</label><label class="expand" for="c-40173534">[2 more]</label></div><br/><div class="children"><div class="content">The studio you&#x27;re talking about is Embark studios, and is openly pretty big on Rust [1]
I think it was rumored that their next project will use a Rust game engine, but I am not sure how it&#x27;s going now.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;EmbarkStudios&#x2F;rust-ecosystem">https:&#x2F;&#x2F;github.com&#x2F;EmbarkStudios&#x2F;rust-ecosystem</a></div><br/><div id="40173808" class="c"><input type="checkbox" id="c-40173808" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173534">parent</a><span>|</span><a href="#40173144">next</a><span>|</span><label class="collapse" for="c-40173808">[-]</label><label class="expand" for="c-40173808">[1 more]</label></div><br/><div class="children"><div class="content">Their creative sandbox project is full Rust from client to server I believe. I haven&#x27;t kept up with it after trying the closed alpha a while ago but it looks like it&#x27;s still going, and has a name now: <a href="https:&#x2F;&#x2F;wim.live" rel="nofollow">https:&#x2F;&#x2F;wim.live</a><p>It&#x27;s still only listed as coming to PC, Mac, Linux and Android so I guess they haven&#x27;t broken through the barrier of shipping Rust on consoles.</div><br/></div></div></div></div><div id="40173144" class="c"><input type="checkbox" id="c-40173144" checked=""/><div class="controls bullet"><span class="by">droopyEyelids</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173035">parent</a><span>|</span><a href="#40173534">prev</a><span>|</span><a href="#40174655">next</a><span>|</span><label class="collapse" for="c-40173144">[-]</label><label class="expand" for="c-40173144">[9 more]</label></div><br/><div class="children"><div class="content">Backend 3d code?</div><br/><div id="40174442" class="c"><input type="checkbox" id="c-40174442" checked=""/><div class="controls bullet"><span class="by">xboxnolifes</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173144">parent</a><span>|</span><a href="#40173361">next</a><span>|</span><label class="collapse" for="c-40174442">[-]</label><label class="expand" for="c-40174442">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with the domain, but wouldn&#x27;t 3D collision checking be considered backend 3D code? Even if it&#x27;s not rendered, it still needs to be calculated.</div><br/></div></div><div id="40173361" class="c"><input type="checkbox" id="c-40173361" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173144">parent</a><span>|</span><a href="#40174442">prev</a><span>|</span><a href="#40174655">next</a><span>|</span><label class="collapse" for="c-40173361">[-]</label><label class="expand" for="c-40173361">[7 more]</label></div><br/><div class="children"><div class="content">Server side rendering for games.</div><br/><div id="40174229" class="c"><input type="checkbox" id="c-40174229" checked=""/><div class="controls bullet"><span class="by">internetter</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40173361">parent</a><span>|</span><a href="#40174655">next</a><span>|</span><label class="collapse" for="c-40174229">[-]</label><label class="expand" for="c-40174229">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a thing?</div><br/><div id="40177922" class="c"><input type="checkbox" id="c-40177922" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174229">parent</a><span>|</span><a href="#40174507">next</a><span>|</span><label class="collapse" for="c-40177922">[-]</label><label class="expand" for="c-40177922">[3 more]</label></div><br/><div class="children"><div class="content">Yep, Stadia might have failed, but GeForce Now and XBox Cloud Gaming have enough customers to keep them going.</div><br/><div id="40177985" class="c"><input type="checkbox" id="c-40177985" checked=""/><div class="controls bullet"><span class="by">spiderice</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177922">parent</a><span>|</span><a href="#40174507">next</a><span>|</span><label class="collapse" for="c-40177985">[-]</label><label class="expand" for="c-40177985">[2 more]</label></div><br/><div class="children"><div class="content">That’s complete different. They are rendering the client and streaming it to users. That doesn’t make the client side code “server side” any more than you streaming Fortnite on Twitch does.</div><br/><div id="40178355" class="c"><input type="checkbox" id="c-40178355" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177985">parent</a><span>|</span><a href="#40174507">next</a><span>|</span><label class="collapse" for="c-40178355">[-]</label><label class="expand" for="c-40178355">[1 more]</label></div><br/><div class="children"><div class="content">Nope, XBox XDK has facilities for code to be aware of rendering server side.</div><br/></div></div></div></div></div></div><div id="40174507" class="c"><input type="checkbox" id="c-40174507" checked=""/><div class="controls bullet"><span class="by">chris37879</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174229">parent</a><span>|</span><a href="#40177922">prev</a><span>|</span><a href="#40174655">next</a><span>|</span><label class="collapse" for="c-40174507">[-]</label><label class="expand" for="c-40174507">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely! Any sort of multiplayer game needs a source of authority if you want to prevent cheats like a hacked client lying about its position, and a really good way to do that is load the geometry of your level and run physics checks server side at a lower frequency than once per frame. Godot and Unity both support headless builds for exactly this reason, it&#x27;s basically the whole game engine, minus the renderer, audio, and UI systems, usually.</div><br/><div id="40175016" class="c"><input type="checkbox" id="c-40175016" checked=""/><div class="controls bullet"><span class="by">dj_mc_merlin</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174507">parent</a><span>|</span><a href="#40174655">next</a><span>|</span><label class="collapse" for="c-40175016">[-]</label><label class="expand" for="c-40175016">[1 more]</label></div><br/><div class="children"><div class="content">That is not server side rendering. Per your own comment:<p>&gt; minus the renderer<p>(Otherwise you are completely correct.)<p>Closest I can think of is server side ragdolls that are rendered the same on all screens and similar stuff.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40174655" class="c"><input type="checkbox" id="c-40174655" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40173035">prev</a><span>|</span><a href="#40176170">next</a><span>|</span><label class="collapse" for="c-40174655">[-]</label><label class="expand" for="c-40174655">[5 more]</label></div><br/><div class="children"><div class="content"><i>&quot;I tend to agree about the &quot;async contamination&quot; problem. The &quot;async&quot; system is optimized for someone who needs to run a very large web server, with a huge number of clients sending in requests. I&#x27;ve been pushing back against it creeping into areas that don&#x27;t really need it.&quot;</i><p>100% this. As I say elsewhere in these threads: Rust is the language that Tokio ate. It isn&#x27;t even just async viral-chain-effect, it&#x27;s that on the whole crates for one async runtime are not even compatible with those of another, and so it&#x27;s all really just about tokio.<p>Which sucks, if you&#x27;re doing, y&#x27;know, systems programming or embedded (or games). Because tokio has no business in those domains.</div><br/><div id="40177740" class="c"><input type="checkbox" id="c-40177740" checked=""/><div class="controls bullet"><span class="by">hgomersall</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174655">parent</a><span>|</span><a href="#40175537">next</a><span>|</span><label class="collapse" for="c-40177740">[-]</label><label class="expand" for="c-40177740">[1 more]</label></div><br/><div class="children"><div class="content">It does in my domain of systems programming with async data handling. Tokio works like a dream - slipping into the background and just working so I can concentrate on the business logic.</div><br/></div></div><div id="40175537" class="c"><input type="checkbox" id="c-40175537" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174655">parent</a><span>|</span><a href="#40177740">prev</a><span>|</span><a href="#40176170">next</a><span>|</span><label class="collapse" for="c-40175537">[-]</label><label class="expand" for="c-40175537">[3 more]</label></div><br/><div class="children"><div class="content">Disappointing to hear this after battling the same nonsense in JS for years.</div><br/><div id="40175725" class="c"><input type="checkbox" id="c-40175725" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175537">parent</a><span>|</span><a href="#40178239">next</a><span>|</span><label class="collapse" for="c-40175725">[-]</label><label class="expand" for="c-40175725">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just endemic to the industry. Framework-itis</div><br/></div></div><div id="40178239" class="c"><input type="checkbox" id="c-40178239" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40175537">parent</a><span>|</span><a href="#40175725">prev</a><span>|</span><a href="#40176170">next</a><span>|</span><label class="collapse" for="c-40178239">[-]</label><label class="expand" for="c-40178239">[1 more]</label></div><br/><div class="children"><div class="content">Rust is a language made and used by Dunning-Kruger people who violently react to having to learn the prior art.<p>What did you really expect?</div><br/></div></div></div></div></div></div><div id="40176170" class="c"><input type="checkbox" id="c-40176170" checked=""/><div class="controls bullet"><span class="by">retrocryptid</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40174655">prev</a><span>|</span><a href="#40174283">next</a><span>|</span><label class="collapse" for="c-40176170">[-]</label><label class="expand" for="c-40176170">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m happy to see <i>someone</i> still doing some work in second life.</div><br/><div id="40176764" class="c"><input type="checkbox" id="c-40176764" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40176170">parent</a><span>|</span><a href="#40174283">next</a><span>|</span><label class="collapse" for="c-40176764">[-]</label><label class="expand" for="c-40176764">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot going on. Someone is doing a new third party viewer, Crystal Frost, in Unity. Linden Lab has a mobile viewer in alpha test. Rendering is PBR now for new objects. There are mirrors! Content upload is moving to glTF, to be compatible with everybody else.
Voice is switching from Vivox to WebRTC. Game controller support is in test. New users get better avatars. The dev staff is larger.<p>None of this is yet increasing Second Life usership much, but it remains the best metaverse around.<p>I thought the metaverse thing was going to be bigger. Meta spent so much money to produce so little.</div><br/><div id="40177788" class="c"><input type="checkbox" id="c-40177788" checked=""/><div class="controls bullet"><span class="by">vaylian</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40176764">parent</a><span>|</span><a href="#40174283">next</a><span>|</span><label class="collapse" for="c-40177788">[-]</label><label class="expand" for="c-40177788">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a lot going on.<p>I&#x27;d like to use the opportunity to ask: What happened during the covid pandemic? I haven&#x27;t heard&#x2F;read anything about second life during the pandemic even though this was probably a once-in-a-lifetime opportunity?<p>Are there any news sources that you can recommend to keep an eye on second life, because it doesn&#x27;t seem that it gets that much press coverage?</div><br/><div id="40178012" class="c"><input type="checkbox" id="c-40178012" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40177788">parent</a><span>|</span><a href="#40174283">next</a><span>|</span><label class="collapse" for="c-40178012">[-]</label><label class="expand" for="c-40178012">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What happened during the COVID pandemic?<p>Usage went up about 10%, and then leveled off. Logged in right now, at 0020 PDT: 32084 users. Varies between 30,000 and 50,000 around the clock.<p>&gt; News sources<p>* <a href="https:&#x2F;&#x2F;modemworld.me&#x2F;" rel="nofollow">https:&#x2F;&#x2F;modemworld.me&#x2F;</a><p>* <a href="https:&#x2F;&#x2F;ryanschultz.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ryanschultz.com&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="40174283" class="c"><input type="checkbox" id="c-40174283" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#40172952">parent</a><span>|</span><a href="#40176170">prev</a><span>|</span><a href="#40173475">next</a><span>|</span><label class="collapse" for="c-40174283">[-]</label><label class="expand" for="c-40174283">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;async&quot; system is optimized for someone who needs to run a very large web server, with a huge number of clients sending in requests.<p>Can you please elaborate on this? I see a lot of similar concerns in other contexts too. Linux kernel&#x27;s scheduler for example. Is it a throughput&#x2F;latency tradeoff?</div><br/><div id="40174735" class="c"><input type="checkbox" id="c-40174735" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174283">parent</a><span>|</span><a href="#40173475">next</a><span>|</span><label class="collapse" for="c-40174735">[-]</label><label class="expand" for="c-40174735">[5 more]</label></div><br/><div class="children"><div class="content">The current popularity of the async stuff has its roots in the classic &quot;c10k&quot; problem.  (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;C10k_problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;C10k_problem</a>)<p>A perception among some that threads are expensive, especially when &quot;wasted&quot; on blocking I&#x2F;O. And that using them in that domain &quot;won&#x27;t scale.&quot;<p>Putting aside that not all of use are building web applications (heterodox here in HN, I know)...<p>Most people in the real world with real applications will not hit the limits of what is possible and efficient and totally fine with thread-based architectures.<p>Plus the kernel has gotten more efficient with threads over the years.<p>Plus hardware has gotten way better, and better at handling concurrent access.<p>Plus async involves other trade-offs -- running a state machine behind the scenes that&#x27;s doing the kinds of context switching the kernel &amp; hardware already potentially does for threads, but in user space. If you ever pull up a debugger and step through an async Rust&#x2F;tokio codebase, you&#x27;ll get a good sense for what the overhead here we&#x27;re talking about is.<p>That overhead is fine if you&#x27;re sitting there blocking on your database server, or some HTTP socket, or some filesystem.<p>It&#x27;s ... probably... not what you want if you&#x27;re building a game or an operating system or an embedded device of some kind.<p>An additional problem with async in Rust <i>right now</i> is that  it involves bringing in an async runtime, and giving it control over execution of async functions... but various things like thread spawning, channels, async locks, etc. are not standardized, and are specific per runtime. Which in the real world is always tokio.<p>So some piece of code you bring in in a crate, uses async, now you&#x27;re having to fire up a tokio runtime. Even though you were potentially not building something that has anything to do with the kinds of things that tokio is targeted for (&quot;scalable&quot; network services.)<p>So even if you find an async runtime that&#x27;s optimized in some other domain, etc (like glommio or smol or whatever) -- you&#x27;re unlikely to even be able to use it with whatever famous upstream crate you want, which will have explicit dependencies into tokio.</div><br/><div id="40178284" class="c"><input type="checkbox" id="c-40178284" checked=""/><div class="controls bullet"><span class="by">karmarepellent</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174735">parent</a><span>|</span><a href="#40176297">next</a><span>|</span><label class="collapse" for="c-40178284">[-]</label><label class="expand" for="c-40178284">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Putting aside that not all of use are building web applications<p>Perfect moment to mention &quot;rouille&quot; which is a very lightweight synchronous web server framework. So even when you decide to build some web application you do not necessarily have to go down the tokio&#x2F;async route. I have been using it for a while at work and for private projects and it turned out to be pretty eye-opening.</div><br/></div></div><div id="40176297" class="c"><input type="checkbox" id="c-40176297" checked=""/><div class="controls bullet"><span class="by">collinvandyck76</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40174735">parent</a><span>|</span><a href="#40178284">prev</a><span>|</span><a href="#40177583">next</a><span>|</span><label class="collapse" for="c-40176297">[-]</label><label class="expand" for="c-40176297">[2 more]</label></div><br/><div class="children"><div class="content">&gt;now you&#x27;re having to fire up a tokio runtime<p>I&#x27;ve been developing in (mostly async) Rust professionally for a about a year -- I haven&#x27;t written much sync rust other than my learning projects and a raytracer I&#x27;m working on, but what are the kind of common dependencies that pose this problem? Like wanting to use reqwest or things like that?</div><br/><div id="40178041" class="c"><input type="checkbox" id="c-40178041" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40172952">root</a><span>|</span><a href="#40176297">parent</a><span>|</span><a href="#40177583">next</a><span>|</span><label class="collapse" for="c-40178041">[-]</label><label class="expand" for="c-40178041">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Like wanting to use reqwest or things like that?<p>Yes. Reqwest cranks up Tokio. The amount of stuff it does for a single web request is rather large. It cranks up a thread pool, does the request, and if there&#x27;s nothing else going on, shuts down the thread pool after a while. That whole reqwest&#x2F;hyper&#x2F;tokio stack is intended to &quot;scale&quot;, and it&#x27;s massive overkill for something that&#x27;s not making large numbers of requests.<p>There&#x27;s &quot;ureq&quot;, if you don&#x27;t want Tokio client side. Does blocking HTTP&#x2F;HTTPS requests. Will set up a reusable connection pool if you want one.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40173475" class="c"><input type="checkbox" id="c-40173475" checked=""/><div class="controls bullet"><span class="by">stephc_int13</span><span>|</span><a href="#40172952">prev</a><span>|</span><a href="#40172593">next</a><span>|</span><label class="collapse" for="c-40173475">[-]</label><label class="expand" for="c-40173475">[69 more]</label></div><br/><div class="children"><div class="content">As a game developer for about two decades, I&#x27;ve never considered Rust to be a good programming language choice.<p>My priorities are reasonable performances and the fastest iteration time possible.<p>Gameplay code should be flexible, we have tons and tons of edge cases _by design_ because this is the best way to create interesting games.<p>Compilation time is very important, but also a flexible enough programming structure, moving things around and changing your mind about the most desirable approach several times a day is common during heavy development phases.<p>We almost never have specifications, almost nothing is set until the game is done.<p>It is a different story for game engines, renderers, physics, audio, asset loaders etc. those are much closer to system programming but this is also not where we usually spend the most time, as a professional you&#x27;re supposed to either use off-the-shelf engines or already made frameworks and libraries.<p>Also, ECS is, IMHO, a useful pattern for some systems, but it is a pain in the butt to use with gameplay or UI code.</div><br/><div id="40177574" class="c"><input type="checkbox" id="c-40177574" checked=""/><div class="controls bullet"><span class="by">fmbb</span><span>|</span><a href="#40173475">parent</a><span>|</span><a href="#40178306">next</a><span>|</span><label class="collapse" for="c-40177574">[-]</label><label class="expand" for="c-40177574">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is a different story for game engines, renderers, physics, audio, asset loaders etc. those are much closer to system programming but this is also not where we usually spend the most time, as a professional you&#x27;re supposed to either use off-the-shelf engines or already made frameworks and libraries.<p>But this is where industry interest (the little there is) lies for Rust, is it not? This is what the AAA studios that are researching and prototyping are working on.<p>C++ is not a popular language to implement the actual game in for all the reasons you list. It is too slow to compile and too rigid. The people who actually build the games, make them tick, are all working in visual scripting languages.</div><br/></div></div><div id="40178306" class="c"><input type="checkbox" id="c-40178306" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#40173475">parent</a><span>|</span><a href="#40177574">prev</a><span>|</span><a href="#40173652">next</a><span>|</span><label class="collapse" for="c-40178306">[-]</label><label class="expand" for="c-40178306">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, ECS is, IMHO, a useful pattern for some systems, but it is a pain in the butt to use with gameplay or UI code.<p>Not a game developer, but each time I tried to make one not using ECS(or something at least similar in spirit) I quickly found myself not being able to proceed due to the sheer mess in the codebase.<p>How does one normally avoid that?</div><br/></div></div><div id="40173652" class="c"><input type="checkbox" id="c-40173652" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">parent</a><span>|</span><a href="#40178306">prev</a><span>|</span><a href="#40175974">next</a><span>|</span><label class="collapse" for="c-40173652">[-]</label><label class="expand" for="c-40173652">[18 more]</label></div><br/><div class="children"><div class="content">As a non-game dev who uses Rust and Elixir, Rust wouldn&#x27;t be my first pick for a large gamedev studio for multiple reasons. As for alternatives worth evaluating: Crystal, Cython (compiled Python), or Nim could result in increased gamedev productivity over C++ or C#. Maybe even Go because the iteration and compile times are very fast, and the learning curve is very low.</div><br/><div id="40176199" class="c"><input type="checkbox" id="c-40176199" checked=""/><div class="controls bullet"><span class="by">ClimaxGravely</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173652">parent</a><span>|</span><a href="#40178307">next</a><span>|</span><label class="collapse" for="c-40176199">[-]</label><label class="expand" for="c-40176199">[1 more]</label></div><br/><div class="children"><div class="content">Often in the past Lua has been used and in my experience it&#x27;s been quite nice. It&#x27;s very easy to bind, there&#x27;s some nice editors out there and the performance is decent.<p>There&#x27;s some other game-specific scripting languages that have popped up (angelscript and wren come to mind but there&#x27;s more). I&#x27;ve not used them in full production products though. Mostly just kicked the tires.<p>Now that I think about it though, it&#x27;s been almost 6 years since I&#x27;ve worked on an engine with lua support. Mainly because in the last few years I&#x27;ve been working with unity or unreal.</div><br/></div></div><div id="40178307" class="c"><input type="checkbox" id="c-40178307" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173652">parent</a><span>|</span><a href="#40176199">prev</a><span>|</span><a href="#40174022">next</a><span>|</span><label class="collapse" for="c-40178307">[-]</label><label class="expand" for="c-40178307">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Cython (compiled Python), or Nim could result in increased gamedev productivity over C++ or C#<p>If you&#x27;re starting from scratch, then maybe. Having had to crash learn games dev (ex VFX systems person) Unity + c# is just so nice to use. most of the easiness of python, but with proper strict typing. (which you can turn off, if you want)<p>plus the wealth of documentation, its great. I imagine unreal is quite good in that regard too.</div><br/></div></div><div id="40174022" class="c"><input type="checkbox" id="c-40174022" checked=""/><div class="controls bullet"><span class="by">prisenco</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173652">parent</a><span>|</span><a href="#40178307">prev</a><span>|</span><a href="#40177759">next</a><span>|</span><label class="collapse" for="c-40174022">[-]</label><label class="expand" for="c-40174022">[2 more]</label></div><br/><div class="children"><div class="content">| <i>Go because the iteration and compile times are very fast</i><p>Safety is important and for certain applications, Rust is unrivaled.<p>But for games, like web apps, where time to market and innovation can be just as if not more important than being free of runtime errors, Go is more suited to rapid development than Rust on compile times alone.<p>Of course, the libraries and support for both aren&#x27;t quite there yet, so at this point neither is well suited to game dev.</div><br/><div id="40174501" class="c"><input type="checkbox" id="c-40174501" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174022">parent</a><span>|</span><a href="#40177759">next</a><span>|</span><label class="collapse" for="c-40174501">[-]</label><label class="expand" for="c-40174501">[1 more]</label></div><br/><div class="children"><div class="content">I agree. We almost have a paradox of choice nowadays because it&#x27;s easier than ever to create new language platforms. Rust is something different because its thesis is safety and performance by default, more or less optimized for systems development primarily, but at the bargain of making dangerous things more complicated to accomplish somewhat intentionally. Unconventional languages are sometimes used as a conspicuous challenge to attract developers or to attempt to move some parts of an industry into new territory.</div><br/></div></div></div></div><div id="40177759" class="c"><input type="checkbox" id="c-40177759" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173652">parent</a><span>|</span><a href="#40174022">prev</a><span>|</span><a href="#40173866">next</a><span>|</span><label class="collapse" for="c-40177759">[-]</label><label class="expand" for="c-40177759">[1 more]</label></div><br/><div class="children"><div class="content">&gt;As for alternatives worth evaluating: Crystal, Cython (compiled Python), or Nim could result in increased gamedev productivity over C++ or C#.<p>I read on a recent HN thread that Crystal compilation is slow due to its type inference, IIRC.</div><br/></div></div><div id="40173866" class="c"><input type="checkbox" id="c-40173866" checked=""/><div class="controls bullet"><span class="by">Nuzzerino</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173652">parent</a><span>|</span><a href="#40177759">prev</a><span>|</span><a href="#40176076">next</a><span>|</span><label class="collapse" for="c-40173866">[-]</label><label class="expand" for="c-40173866">[8 more]</label></div><br/><div class="children"><div class="content">Does Crystal support Hot Reloading? The slow compilation speed is a non-starter for me.</div><br/><div id="40175583" class="c"><input type="checkbox" id="c-40175583" checked=""/><div class="controls bullet"><span class="by">sam0x17</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173866">parent</a><span>|</span><a href="#40176171">next</a><span>|</span><label class="collapse" for="c-40175583">[-]</label><label class="expand" for="c-40175583">[1 more]</label></div><br/><div class="children"><div class="content">They have an interpreter mode now that is quite good and should be well-suited for these situations</div><br/></div></div><div id="40176171" class="c"><input type="checkbox" id="c-40176171" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173866">parent</a><span>|</span><a href="#40175583">prev</a><span>|</span><a href="#40174518">next</a><span>|</span><label class="collapse" for="c-40176171">[-]</label><label class="expand" for="c-40176171">[1 more]</label></div><br/><div class="children"><div class="content">Gamedev industry already settled on almost perfect language for this task (C#) so there is little profit in trying to reinvent the wheel.<p>And by perfect I mean not the way Unity uses it but the way pure C# engines use it.</div><br/></div></div><div id="40174518" class="c"><input type="checkbox" id="c-40174518" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173866">parent</a><span>|</span><a href="#40176171">prev</a><span>|</span><a href="#40176076">next</a><span>|</span><label class="collapse" for="c-40174518">[-]</label><label class="expand" for="c-40174518">[5 more]</label></div><br/><div class="children"><div class="content">Haha. Nope. Maybe Nim, V*, Go*, or Elixir would be a better choice for such a use-case.<p>* So fast, they really don&#x27;t need HCR.</div><br/><div id="40177298" class="c"><input type="checkbox" id="c-40177298" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174518">parent</a><span>|</span><a href="#40175653">next</a><span>|</span><label class="collapse" for="c-40177298">[-]</label><label class="expand" for="c-40177298">[1 more]</label></div><br/><div class="children"><div class="content">HCR provides changing things while th game is running in it&#x27;s current state. fast recompile does not.<p>Start game, wait for engine to initialize, select level, wait for it to load, move player or camera to desired location. Now iterate on something at that location via HCR. If you have to recompile and restart the game you&#x27;re not going to have fast iteration</div><br/></div></div><div id="40175653" class="c"><input type="checkbox" id="c-40175653" checked=""/><div class="controls bullet"><span class="by">misswaterfairy</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174518">parent</a><span>|</span><a href="#40177298">prev</a><span>|</span><a href="#40174992">next</a><span>|</span><label class="collapse" for="c-40175653">[-]</label><label class="expand" for="c-40175653">[1 more]</label></div><br/><div class="children"><div class="content">Nim does, when tied in with Unreal Engine 5.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jmgomez&#x2F;NimForUE">https:&#x2F;&#x2F;github.com&#x2F;jmgomez&#x2F;NimForUE</a><p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Cdr4-cOsAWA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Cdr4-cOsAWA</a></div><br/></div></div><div id="40174992" class="c"><input type="checkbox" id="c-40174992" checked=""/><div class="controls bullet"><span class="by">Nuzzerino</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174518">parent</a><span>|</span><a href="#40175653">prev</a><span>|</span><a href="#40176076">next</a><span>|</span><label class="collapse" for="c-40174992">[-]</label><label class="expand" for="c-40174992">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t tried it yet but I&#x27;ve wondered if Elixir might be a good choice for a game server with many concurrent players.</div><br/><div id="40175325" class="c"><input type="checkbox" id="c-40175325" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174992">parent</a><span>|</span><a href="#40176076">next</a><span>|</span><label class="collapse" for="c-40175325">[-]</label><label class="expand" for="c-40175325">[1 more]</label></div><br/><div class="children"><div class="content">Definitely and for chat.<p>BEAM&#x2F;HiPE VM allows native linking using NIFs so it&#x27;s possible to integrate Erlang or Elixir with C-compatible projects for critical code sections, library interfacing, and perhaps even the majority of a performance-critical game engine as native code. Rustler also exists to write NIFs in Rust. Recall how VMware ESXi core tech was implemented mostly as Linux kernel modules and heavily-modified Linux to turn it inside-out as a type-1 hypervisor.</div><br/></div></div></div></div></div></div></div></div><div id="40176076" class="c"><input type="checkbox" id="c-40176076" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173652">parent</a><span>|</span><a href="#40173866">prev</a><span>|</span><a href="#40175974">next</a><span>|</span><label class="collapse" for="c-40176076">[-]</label><label class="expand" for="c-40176076">[4 more]</label></div><br/><div class="children"><div class="content">Go is <i>infamous</i> for its gc latency spikes, which is the thing that games cannot tolerate.<p>Though 1.18 helped a lot, you&#x27;d have to do some major persuasion to game devs that Go&#x27;s gc is the kind of thing they&#x27;d want in their game.<p>---<p>EDIT: Not sure the downvote, Go is know for its (historically at least) unsuitability for RTC or game dev.</div><br/><div id="40176838" class="c"><input type="checkbox" id="c-40176838" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40176076">parent</a><span>|</span><a href="#40176928">next</a><span>|</span><label class="collapse" for="c-40176838">[-]</label><label class="expand" for="c-40176838">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true. Go ain&#x27;t C4 (JVM), ORCA (Pony), HiPE (Erlang&#x2F;OTP BEAM), or CLR (C#). The JVM and CLR runtimes have been beaten on for years at immense scale in server-side business settings. I wished Go supported embedded work (without a GC), had an alternative allocator a bit more like Erlang&#x27;s, and had alternative implementations that transpiled to other languages, but it doesn&#x27;t. Ultimately, I left when zillions of noobs poured in because it was seen as &quot;easy&quot; and started wasting my time rather than searching for answers themselves.<p>If performance were such a huge concern, I don&#x27;t see any valid resistance to Rust that completely lacks a GC and makes it easy to call C code other than &quot;it&#x27;s something different&quot;, &quot;there&#x27;s too much hype&quot;, or &quot;I don&#x27;t like it&quot;. Recent development tools like RustRover make is really damn easy to see whats a move value or a borrow, debug test cases, run clippy automatically, and check crates versions in Cargo.toml. Throw Copilot in there and let it generate mostly correct, repetitious code for you.</div><br/></div></div><div id="40176928" class="c"><input type="checkbox" id="c-40176928" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40176076">parent</a><span>|</span><a href="#40176838">prev</a><span>|</span><a href="#40175974">next</a><span>|</span><label class="collapse" for="c-40176928">[-]</label><label class="expand" for="c-40176928">[2 more]</label></div><br/><div class="children"><div class="content">I’ve heard that go has very low latency gc, i haven’t heard of it having spikes</div><br/><div id="40177207" class="c"><input type="checkbox" id="c-40177207" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40176928">parent</a><span>|</span><a href="#40175974">next</a><span>|</span><label class="collapse" for="c-40177207">[-]</label><label class="expand" for="c-40177207">[1 more]</label></div><br/><div class="children"><div class="content">The problem with Go is its inadequate FFI, which is important for gamedev which tends to be FFI and syscall-heavy due to embedding another gamescript language and&#x2F;or calling into underlying rendering back-end, sometimes interacting with input drivers directly, etc.<p>Which is why C# has been chosen so often (it has performance not much worse than C++ (you can manually optimize to match it), zero or almost zero-cost FFI, and can also be embedded, albeit with effort).<p>There are also ways to directly reduce GC frequency by writing less allocation-heavy code, without having to resort to writing your own drop-in GC implementation (which is supported but I haven&#x27;t seen anyone use that new API just yet aside from a few toy examples, I suppose built-in GC is good enough).</div><br/></div></div></div></div></div></div></div></div><div id="40175974" class="c"><input type="checkbox" id="c-40175974" checked=""/><div class="controls bullet"><span class="by">harpiaharpyja</span><span>|</span><a href="#40173475">parent</a><span>|</span><a href="#40173652">prev</a><span>|</span><a href="#40176236">next</a><span>|</span><label class="collapse" for="c-40175974">[-]</label><label class="expand" for="c-40175974">[1 more]</label></div><br/><div class="children"><div class="content">I had similar thoughts, about Rust being a good match for game engines but not games. Maybe it suggests Rust game engines might want to include an interpreter for some higher level language to actually do the gamedev in.<p>Rust is pretty good for writing PL interpreters (and similar tooling) too, actually.</div><br/></div></div><div id="40176236" class="c"><input type="checkbox" id="c-40176236" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40173475">parent</a><span>|</span><a href="#40175974">prev</a><span>|</span><a href="#40175601">next</a><span>|</span><label class="collapse" for="c-40176236">[-]</label><label class="expand" for="c-40176236">[1 more]</label></div><br/><div class="children"><div class="content">I know you&#x27;re not asking for recommendations, but Lisp, particularly SBCL, <i>really</i> seems to check all your boxes. I say this as someone who generally reaches for Scheme when it comes to Lisps too.<p>There are a few game engines[0] for CL, but most of them seem to be catered specifically to 2D games.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;CodyReichert&#x2F;awesome-cl?tab=readme-ov-file#game-development">https:&#x2F;&#x2F;github.com&#x2F;CodyReichert&#x2F;awesome-cl?tab=readme-ov-fil...</a></div><br/></div></div><div id="40175601" class="c"><input type="checkbox" id="c-40175601" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40173475">parent</a><span>|</span><a href="#40176236">prev</a><span>|</span><a href="#40173616">next</a><span>|</span><label class="collapse" for="c-40175601">[-]</label><label class="expand" for="c-40175601">[3 more]</label></div><br/><div class="children"><div class="content">&gt; a flexible enough programming structure, moving things around and changing your mind about the most desirable approach several times a day is common during heavy development phases.<p>That&#x27;s the kind of code for which Rust-like languages shine. Rich type systems make it easy to change your mind about things and make large changes to your code with confidence.<p>(Whether Rust tooling is actually at a level to take advantage of that is another question)</div><br/><div id="40177163" class="c"><input type="checkbox" id="c-40177163" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40175601">parent</a><span>|</span><a href="#40176814">next</a><span>|</span><label class="collapse" for="c-40177163">[-]</label><label class="expand" for="c-40177163">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s the kind of code for which Rust-like languages shine. Rich type systems make it easy to change your mind about things and make large changes to your code with confidence.<p>I don&#x27;t think this is true. Rust makes it easy to get the refactor right (generally speaking 100% right). But that&#x27;s not what they&#x27;re describing. They&#x27;re describing where the ability to make the refactor fast, even if it doesn&#x27;t work correctly (in the formal sense of correctly). That is to say, memory leaks and race conditions and all sorts of horrible nastiness may be tolerable during the dev process in exchange for trying out an idea more quickly.<p>This is, of course, significantly more work at the end to patch up all of the things you did, but if you don&#x27;t have to do the full work on 99&#x2F;100 iterations, or got to try out more iterations because of the quick turnaround time, that would be considered a win here.</div><br/></div></div><div id="40176814" class="c"><input type="checkbox" id="c-40176814" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40175601">parent</a><span>|</span><a href="#40177163">prev</a><span>|</span><a href="#40173616">next</a><span>|</span><label class="collapse" for="c-40176814">[-]</label><label class="expand" for="c-40176814">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Rich type systems make it easy to change your mind about things and make large changes to your code with confidence.<p>To be fair, they need to be able to make large changes with confidence because what would be small changes in other languages tend to end up being very large changes in rust like languages.</div><br/></div></div></div></div><div id="40173616" class="c"><input type="checkbox" id="c-40173616" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40173475">parent</a><span>|</span><a href="#40175601">prev</a><span>|</span><a href="#40172593">next</a><span>|</span><label class="collapse" for="c-40173616">[-]</label><label class="expand" for="c-40173616">[43 more]</label></div><br/><div class="children"><div class="content">&gt; My priorities are reasonable performances and the fastest iteration time possible.<p>I bought Mount &amp; Blade II Bannerlord in 2020-03-30.  I love it to death, but come on...<p><pre><code>  &#x2F;&#x2F; 2024-02-01
  $ curl https:&#x2F;&#x2F;www.taleworlds.com&#x2F;en&#x2F;News&#x2F;552 | grep &quot;Fixed a crash that&quot; | wc -l
  29

  &#x2F;&#x2F; 2023-12-21
  $ curl https:&#x2F;&#x2F;www.taleworlds.com&#x2F;en&#x2F;News&#x2F;549 | grep &quot;Fixed a crash that&quot; | wc -l
  6

  &#x2F;&#x2F; 2023-12-14
  $ curl https:&#x2F;&#x2F;www.taleworlds.com&#x2F;en&#x2F;News&#x2F;547 | grep &quot;Fixed a crash that&quot; | wc -l
  101
</code></pre>
Maybe feeling like you&#x27;re iterating fast isn&#x27;t the same as getting to the destination faster.<p>Edit:
Lol guys calm down with the down-vote party.  I was counting crashes, not bugs:<p><pre><code>  $ curl https:&#x2F;&#x2F;www.taleworlds.com&#x2F;en&#x2F;News&#x2F;547 | grep &quot;Fixed a bug that&quot; | wc -l
  308
</code></pre>
Does your C++ not crash, just theirs?</div><br/><div id="40174024" class="c"><input type="checkbox" id="c-40174024" checked=""/><div class="controls bullet"><span class="by">bogwog</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40176327">next</a><span>|</span><label class="collapse" for="c-40174024">[-]</label><label class="expand" for="c-40174024">[1 more]</label></div><br/><div class="children"><div class="content">That game (currently) has 88% positive reviews on steam and a 77 metacritic score with over 15.5k people playing the game right now (according to steamcharts.com)<p>Thats a lot of happy customers.</div><br/></div></div><div id="40176327" class="c"><input type="checkbox" id="c-40176327" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40174024">prev</a><span>|</span><a href="#40173854">next</a><span>|</span><label class="collapse" for="c-40176327">[-]</label><label class="expand" for="c-40176327">[3 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t really comment on the quality of the game or experience or how buggy it feels because I&#x27;ve never played it, but I will say that counting fixed crash situations is a somewhat arbitrary and useless metric.  If each of those crashes affected and was reported by a single person or even nobody because no regular person could really encounter it is a vastly different situation than if each of those crashes was experienced by even 1% of the users.<p>The criteria by which something is decided to mention in the patch notes is not always purely because the users care.  Sometimes it&#x27;s because the developers want to signal effort to user and&#x2F;or upper management.<p>Maybe Mount and Blade was super boggy in the past and is <i>still</i> super buggy now so all the crashes fixed are just an indicator of how large the problem is for them and how bad the code still is.  I dunno, you didn&#x27;t really give any information to help on that front.</div><br/><div id="40177054" class="c"><input type="checkbox" id="c-40177054" checked=""/><div class="controls bullet"><span class="by">Repulsion9513</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40176327">parent</a><span>|</span><a href="#40173854">next</a><span>|</span><label class="collapse" for="c-40177054">[-]</label><label class="expand" for="c-40177054">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If each of those crashes affected and was reported by a single person or even nobody<p>Then do you really think they&#x27;d be spending time fixing it?<p>(Actually, you know what, they probably would.)</div><br/><div id="40178025" class="c"><input type="checkbox" id="c-40178025" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177054">parent</a><span>|</span><a href="#40173854">next</a><span>|</span><label class="collapse" for="c-40178025">[-]</label><label class="expand" for="c-40178025">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why I had a paragraph mentioning different reasons things might be mentioned. I don&#x27;t think it&#x27;s uncommon to find a bug that could cause a crash while working something else, confirm it does crash, and then fix it. If the culture is to mention those things in patch notes even if you&#x27;re not sure it actually ever caused a user problem, then it will be listed.<p>That doesn&#x27;t mean all, or even any, of the listed crashes were like that, but it does illustrate that it&#x27;s hard to know what they actually mean without additional info.<p>(for what it&#x27;s worth, I&#x27;m a long time Tarkov player, so I&#x27;m definitely familiar wroth buggy games and apparent development problems with rushing, so this is more a devils advocate position on my part)</div><br/></div></div></div></div></div></div><div id="40173854" class="c"><input type="checkbox" id="c-40173854" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40176327">prev</a><span>|</span><a href="#40176835">next</a><span>|</span><label class="collapse" for="c-40173854">[-]</label><label class="expand" for="c-40173854">[3 more]</label></div><br/><div class="children"><div class="content">With Rust and the exact time iteration times, management and deadlines, you end up with the same amount, just theyre panic!() instead. Thats an improvement, sure, but its fighting a symptom.</div><br/><div id="40175606" class="c"><input type="checkbox" id="c-40175606" checked=""/><div class="controls bullet"><span class="by">sam0x17</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173854">parent</a><span>|</span><a href="#40174057">next</a><span>|</span><label class="collapse" for="c-40175606">[-]</label><label class="expand" for="c-40175606">[1 more]</label></div><br/><div class="children"><div class="content">There are a bunch of useful clippy lints to completely disable most forms of panicking in CI. We use this at my work since a single panic could cost millions of $ in our case.</div><br/></div></div><div id="40174057" class="c"><input type="checkbox" id="c-40174057" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173854">parent</a><span>|</span><a href="#40175606">prev</a><span>|</span><a href="#40176835">next</a><span>|</span><label class="collapse" for="c-40174057">[-]</label><label class="expand" for="c-40174057">[1 more]</label></div><br/><div class="children"><div class="content">With modern languages that take safety more seriously, it&#x27;s a <i>lot</i> easier to spot places where the code &#x27;goes wrong&#x27;.<p>In an older language, you have nothing to tell you whether you&#x27;re about to dereference null:<p><pre><code>   foo.bar.baz = ...;
</code></pre>
Even if you&#x27;ve coded it 100% correctly, that line of code still <i>looks the same</i> as code which will segfault.  You need to look elsewhere in codebase to make sure the right instructions populated those fields at the right time.  If I&#x27;m scrolling past, I&#x27;ll slow down everytime to think &quot;Hey, will that crash?&quot;<p>Compare that with more safety focused languages where you can see the null-dereferences on the page.  Unwrap() or whatever it is in Rust.  Since they&#x27;re visually present, you can code fast by using the unsafe variants, come back later, and know that they won&#x27;t be missed in a code review.  You can literally <i>grep</i> for unsafe code to refactor.</div><br/></div></div></div></div><div id="40176835" class="c"><input type="checkbox" id="c-40176835" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40173854">prev</a><span>|</span><a href="#40176787">next</a><span>|</span><label class="collapse" for="c-40176835">[-]</label><label class="expand" for="c-40176835">[14 more]</label></div><br/><div class="children"><div class="content">I love Rust, but a crashing released game is better than a half-finished &quot;perfect&quot; game, or a game where you couldn&#x27;t iterate quickly, and ended up with a perfectly tuned, unfun game.</div><br/><div id="40177067" class="c"><input type="checkbox" id="c-40177067" checked=""/><div class="controls bullet"><span class="by">Repulsion9513</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40176835">parent</a><span>|</span><a href="#40176787">next</a><span>|</span><label class="collapse" for="c-40177067">[-]</label><label class="expand" for="c-40177067">[13 more]</label></div><br/><div class="children"><div class="content">&gt; a crashing released game is better than a half-finished &quot;perfect&quot; game<p>For who? I, and I&#x27;m pretty sure most other gamers, would rather a fully-finished &quot;perfect&quot; game that took twice as long.</div><br/><div id="40177756" class="c"><input type="checkbox" id="c-40177756" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177067">parent</a><span>|</span><a href="#40178040">next</a><span>|</span><label class="collapse" for="c-40177756">[-]</label><label class="expand" for="c-40177756">[2 more]</label></div><br/><div class="children"><div class="content">&gt; For who? I, and I&#x27;m pretty sure most other gamers, would rather a fully-finished &quot;perfect&quot; game that took twice as long.<p>Evidence suggests otherwise. Of all demographics, gamers appear to be the most tolerant of buggy software.<p>I&#x27;m playing a 2020 game <i>right now</i> that has (in about 30 hours of gameplay):<p>1. Crashed twice
2. Froze once
3. Has at least <i>ONE</i> reproducible bug that a player would run into at least once every mission (including the first one).<p>Since this game is now so old it&#x27;s not getting any more patches, these bugs are there for all eternity, because they just do not move the needle on enjoyment by the gamer.<p>Searching forums for Far Cry 5 Bugs gives results like this: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;farcry&#x2F;comments&#x2F;1ai4jzx&#x2F;has_far_cry_5_always_been_extremely_buggy_or_am_i&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;farcry&#x2F;comments&#x2F;1ai4jzx&#x2F;has_far_cry...</a><p>Gamers just don&#x27;t care about bugs unless it stops them playing the game <i>at all!</i><p>In order for bugs to have an effect on gamer enjoyment, it literally needs to make the game unplayable, and not just make the player reload from the last savepoint.</div><br/><div id="40178344" class="c"><input type="checkbox" id="c-40178344" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177756">parent</a><span>|</span><a href="#40178040">next</a><span>|</span><label class="collapse" for="c-40178344">[-]</label><label class="expand" for="c-40178344">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 1. Crashed twice 2. Froze once 3. Has at least ONE reproducible bug that a player would run into at least once every mission (including the first one).<p>Sounds about on par even for enterprise software, in cases where shipping quickly is prioritized over overall quality, doubly so for gamedev which is notorious for long hours and scope creep.</div><br/></div></div></div></div><div id="40178040" class="c"><input type="checkbox" id="c-40178040" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177067">parent</a><span>|</span><a href="#40177756">prev</a><span>|</span><a href="#40177672">next</a><span>|</span><label class="collapse" for="c-40178040">[-]</label><label class="expand" for="c-40178040">[2 more]</label></div><br/><div class="children"><div class="content">Hell no.  Lots of these games take 5-7 years to make.  You want to turn that into 10-14?  I can live with the rare crash bugs.</div><br/><div id="40178402" class="c"><input type="checkbox" id="c-40178402" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40178040">parent</a><span>|</span><a href="#40177672">next</a><span>|</span><label class="collapse" for="c-40178402">[-]</label><label class="expand" for="c-40178402">[1 more]</label></div><br/><div class="children"><div class="content">What if it&#x27;s 5-7, but only after there is a deep enough dev pool and language tooling to address some of the productivity issues mentioned in the blog? Why make up arbitrary x2 factors?</div><br/></div></div></div></div><div id="40177672" class="c"><input type="checkbox" id="c-40177672" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177067">parent</a><span>|</span><a href="#40178040">prev</a><span>|</span><a href="#40177479">next</a><span>|</span><label class="collapse" for="c-40177672">[-]</label><label class="expand" for="c-40177672">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I, and I&#x27;m pretty sure most other gamers, would rather a fully-finished &quot;perfect&quot; game that took twice as long<p>I have recently completed Cyberpunk Phantom Liberty. The game crashed 4-5 times during 100-150 hours of gameplay. The crashes were pretty much painless because I quick save often.<p>The game was amazing.<p>The development of the game started in 2012, 12 years ago. I’m not sure you or most gamers would rather want a fully-finished &quot;perfect&quot; Cyberpunk 2077 game released in 2036.</div><br/></div></div><div id="40177479" class="c"><input type="checkbox" id="c-40177479" checked=""/><div class="controls bullet"><span class="by">StressedDev</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177067">parent</a><span>|</span><a href="#40177672">prev</a><span>|</span><a href="#40178313">next</a><span>|</span><label class="collapse" for="c-40177479">[-]</label><label class="expand" for="c-40177479">[5 more]</label></div><br/><div class="children"><div class="content">The problem is we would have a lot less games and the games we would get would not be as fun.  Rust appears to have the following problems:<p>1) As the article pointed out, game developers are less productive in Rust.  This is a huge problem.<p>2) Game budgets are not going to get bigger.  This means that if Rust reduces productivity, games are going to be less polished, less fun, etc. if they are written in Rust.<p>3) Game quality is already fine.  99% of the games I play have very few noticeable bugs (I play on an Xbox Series X).  Even the games with bugs are still fun.<p>Basically, gamers are looking for fun games which work well.  They are not looking for perfect software which has no bugs.</div><br/><div id="40177796" class="c"><input type="checkbox" id="c-40177796" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177479">parent</a><span>|</span><a href="#40178313">next</a><span>|</span><label class="collapse" for="c-40177796">[-]</label><label class="expand" for="c-40177796">[4 more]</label></div><br/><div class="children"><div class="content">&gt; As the article pointed out, game developers are less productive in Rust. This is a huge problem.<p>I don&#x27;t think it&#x27;s limited to <i>just</i> game developers though. Unless you are writing something in which any GC time other than 0ns is a dealbreaker, and <i>any</i> bug is also a dealbreaker, you&#x27;re going to be less productive in Rust than almost any other language.</div><br/><div id="40177815" class="c"><input type="checkbox" id="c-40177815" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177796">parent</a><span>|</span><a href="#40178313">next</a><span>|</span><label class="collapse" for="c-40177815">[-]</label><label class="expand" for="c-40177815">[3 more]</label></div><br/><div class="children"><div class="content">Oh, come on, we&#x27;re yet again extrapolating from &quot;Rust is bad at rapid iteration on an indie game&quot; to &quot;Rust is bad at everything&quot;. If Rust were really that astoundingly unproductive of a language, then so many developers at organizations big and small wouldn&#x27;t be using it. Our industry may be irrational at times, but it&#x27;s not <i>that</i> irrational.</div><br/><div id="40178069" class="c"><input type="checkbox" id="c-40178069" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177815">parent</a><span>|</span><a href="#40178313">next</a><span>|</span><label class="collapse" for="c-40178069">[-]</label><label class="expand" for="c-40178069">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Oh, come on, we&#x27;re yet again extrapolating from &quot;Rust is bad at rapid iteration on an indie game&quot; to &quot;Rust is bad at everything&quot;.<p>I am saying that Rust development has a lower velocity than mainstream GC&#x27;ed languages (Java, C#, Go, whatever).<p>I didn&#x27;t <i>think</i> that you are disputing this claim; if you <i>are</i> disputing this, I&#x27;d like to know why you think otherwise.</div><br/><div id="40178350" class="c"><input type="checkbox" id="c-40178350" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40178069">parent</a><span>|</span><a href="#40178313">next</a><span>|</span><label class="collapse" for="c-40178350">[-]</label><label class="expand" for="c-40178350">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am saying that Rust development has a lower velocity than mainstream GC&#x27;ed languages (Java, C#, Go, whatever).<p>That&#x27;s not what you said: you said you&#x27;re going to be less productive in Rust than nearly any other language, not &quot;mainstream GC&#x27;d languages&quot;.<p>&gt; I didn&#x27;t think that you are disputing this claim; if you are disputing this, I&#x27;d like to know why you think otherwise.<p>Depending on the domain, I am disputing that, because of things like the Cargo ecosystem, easy parallelism, ease of interop with native code, etc. There is no equivalent to wgpu in other languages, for example.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40178313" class="c"><input type="checkbox" id="c-40178313" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177067">parent</a><span>|</span><a href="#40177479">prev</a><span>|</span><a href="#40177847">next</a><span>|</span><label class="collapse" for="c-40178313">[-]</label><label class="expand" for="c-40178313">[1 more]</label></div><br/><div class="children"><div class="content">perfect is the enemy of good. You never release anything thats perfect.<p>Perfect is impossible.</div><br/></div></div><div id="40177847" class="c"><input type="checkbox" id="c-40177847" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40177067">parent</a><span>|</span><a href="#40178313">prev</a><span>|</span><a href="#40176787">next</a><span>|</span><label class="collapse" for="c-40177847">[-]</label><label class="expand" for="c-40177847">[1 more]</label></div><br/><div class="children"><div class="content">No, the game doesn’t take twice as long. It just gets abandoned half-finished.<p>The world is full of half-finished games, it takes time and money to push to a finish.</div><br/></div></div></div></div></div></div><div id="40176787" class="c"><input type="checkbox" id="c-40176787" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40176835">prev</a><span>|</span><a href="#40178186">next</a><span>|</span><label class="collapse" for="c-40176787">[-]</label><label class="expand" for="c-40176787">[1 more]</label></div><br/><div class="children"><div class="content">Photoshop does crash. Trust me if you do enough image editing you&#x27;ll know it&#x27;s not even a super rare event. They&#x27;re generally doing a poor job handling the situations where you have no enough storage or RAM.<p>It didn&#x27;t stop Adobe from being worth 200B.</div><br/></div></div><div id="40178186" class="c"><input type="checkbox" id="c-40178186" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40176787">prev</a><span>|</span><a href="#40173888">next</a><span>|</span><label class="collapse" for="c-40178186">[-]</label><label class="expand" for="c-40178186">[1 more]</label></div><br/><div class="children"><div class="content">And yet the fact that Bannerlord game logic is entirely in C# makes this possible:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;int19h&#x2F;Bannerlord.CSharp.Scripting">https:&#x2F;&#x2F;github.com&#x2F;int19h&#x2F;Bannerlord.CSharp.Scripting</a><p>which in turn makes it a lot easier and more convenient to mod. Try that with Rust...</div><br/></div></div><div id="40173888" class="c"><input type="checkbox" id="c-40173888" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40178186">prev</a><span>|</span><a href="#40173727">next</a><span>|</span><label class="collapse" for="c-40173888">[-]</label><label class="expand" for="c-40173888">[1 more]</label></div><br/><div class="children"><div class="content">Hard to know what TaleWorlds are actually optimising for because half the features of Bannerlord feel like they’ve never been played by a dev let alone iterated on.</div><br/></div></div><div id="40173727" class="c"><input type="checkbox" id="c-40173727" checked=""/><div class="controls bullet"><span class="by">stephc_int13</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40173888">prev</a><span>|</span><a href="#40173710">next</a><span>|</span><label class="collapse" for="c-40173727">[-]</label><label class="expand" for="c-40173727">[9 more]</label></div><br/><div class="children"><div class="content">Yeah this is a common problem in the industry, we rarely have enough time to refactor what should be considered prototype-level code into robust code.</div><br/><div id="40174594" class="c"><input type="checkbox" id="c-40174594" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173727">parent</a><span>|</span><a href="#40173710">next</a><span>|</span><label class="collapse" for="c-40174594">[-]</label><label class="expand" for="c-40174594">[8 more]</label></div><br/><div class="children"><div class="content">The game dev industry could form a consortium to launch its own dedicated general purpose language built from scratch to compile very fast like V or Go, run predictability, be much safer, be more reusable, and be extremely productive with the lessons learned from C, C++, C#, and more.<p>Also, I think LLMs will be able to run against code bases to suggest mass codemods to clean things up rather than having humans make a zillion changes or refactoring fragile areas of tech debt. LLMs are already being applied to generate test cases.</div><br/><div id="40175076" class="c"><input type="checkbox" id="c-40175076" checked=""/><div class="controls bullet"><span class="by">jibe</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174594">parent</a><span>|</span><a href="#40174748">next</a><span>|</span><label class="collapse" for="c-40175076">[-]</label><label class="expand" for="c-40175076">[2 more]</label></div><br/><div class="children"><div class="content">Jonathan Blow’s Jai is an attempt at something like this. It’s looking promising so far!</div><br/><div id="40175431" class="c"><input type="checkbox" id="c-40175431" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40175076">parent</a><span>|</span><a href="#40174748">next</a><span>|</span><label class="collapse" for="c-40175431">[-]</label><label class="expand" for="c-40175431">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. I went through the primer spec. Appears to be a different kind of D or Go with some key points. Any new language should begin with a specific thesis of specific competitive advantages and problems it solves over existing customary and alternative tools. Kai appears to fulfill this property, so that&#x27;s a good sign.</div><br/></div></div></div></div><div id="40174748" class="c"><input type="checkbox" id="c-40174748" checked=""/><div class="controls bullet"><span class="by">stephc_int13</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174594">parent</a><span>|</span><a href="#40175076">prev</a><span>|</span><a href="#40175861">next</a><span>|</span><label class="collapse" for="c-40174748">[-]</label><label class="expand" for="c-40174748">[1 more]</label></div><br/><div class="children"><div class="content">I believe that better tooling can help, yes. With refactoring, debugging, creating performance and style reports, updating documentation and a ton of other stuff.</div><br/></div></div><div id="40175861" class="c"><input type="checkbox" id="c-40175861" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174594">parent</a><span>|</span><a href="#40174748">prev</a><span>|</span><a href="#40173710">next</a><span>|</span><label class="collapse" for="c-40175861">[-]</label><label class="expand" for="c-40175861">[4 more]</label></div><br/><div class="children"><div class="content">C# is that language (see Godot, Stride, FNA, Monogame).</div><br/><div id="40176064" class="c"><input type="checkbox" id="c-40176064" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40175861">parent</a><span>|</span><a href="#40173710">next</a><span>|</span><label class="collapse" for="c-40176064">[-]</label><label class="expand" for="c-40176064">[3 more]</label></div><br/><div class="children"><div class="content">Not really, it was adopted. It originated from Microsoft as their post-J++ Java alternative for CLR for the purposes of making it easier to write banking server software and Windows apps.</div><br/><div id="40176111" class="c"><input type="checkbox" id="c-40176111" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40176064">parent</a><span>|</span><a href="#40173710">next</a><span>|</span><label class="collapse" for="c-40176111">[-]</label><label class="expand" for="c-40176111">[2 more]</label></div><br/><div class="children"><div class="content">Does it matter what it was 20 years ago? It is the go-to language for gamedev today and only keeps getting better at it.</div><br/><div id="40176749" class="c"><input type="checkbox" id="c-40176749" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40176111">parent</a><span>|</span><a href="#40173710">next</a><span>|</span><label class="collapse" for="c-40176749">[-]</label><label class="expand" for="c-40176749">[1 more]</label></div><br/><div class="children"><div class="content">Both things can be true. I&#x27;m saying it wasn&#x27;t designed to be as such. I don&#x27;t what you&#x27;re arguing about.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40173710" class="c"><input type="checkbox" id="c-40173710" checked=""/><div class="controls bullet"><span class="by">tedajax</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40173727">prev</a><span>|</span><a href="#40174098">next</a><span>|</span><label class="collapse" for="c-40173710">[-]</label><label class="expand" for="c-40173710">[1 more]</label></div><br/><div class="children"><div class="content">This comment is nonsense</div><br/></div></div><div id="40174098" class="c"><input type="checkbox" id="c-40174098" checked=""/><div class="controls bullet"><span class="by">meinersbur</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40173616">parent</a><span>|</span><a href="#40173710">prev</a><span>|</span><a href="#40172593">next</a><span>|</span><label class="collapse" for="c-40174098">[-]</label><label class="expand" for="c-40174098">[8 more]</label></div><br/><div class="children"><div class="content">My impression is that this is due to their non-robust programming style. They do not add fallback behavior when e.g. receiving a null object. It would still be a bug, but could be a log entry instead of crash.</div><br/><div id="40174227" class="c"><input type="checkbox" id="c-40174227" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174098">parent</a><span>|</span><a href="#40174561">next</a><span>|</span><label class="collapse" for="c-40174227">[-]</label><label class="expand" for="c-40174227">[3 more]</label></div><br/><div class="children"><div class="content">&gt; My impression is that this is due to their non-robust programming style.<p>It&#x27;s been 50+ years.  I don&#x27;t think that it&#x27;s worthwhile just telling the programmer to do a better job.<p>&gt; They do not add fallback behavior when e.g. receiving a null object. It would still be a bug, but could be a log entry instead of crash.<p>This is a pretty big feedback loop:<p><pre><code>  * The programmer puts the null into the code
  * The code is released
  * The right conditions occur and the player triggers it
  * IF DONE SKILLFULLY AND CORRECTLY the game is able to recover from the null-dereference, write it out to a log, and get that log back to the developers.
  * The programmer takes the null out of the code.
</code></pre>
If you don&#x27;t do the first step, you don&#x27;t get stuck doing the others either.</div><br/><div id="40175375" class="c"><input type="checkbox" id="c-40175375" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174227">parent</a><span>|</span><a href="#40174561">next</a><span>|</span><label class="collapse" for="c-40175375">[-]</label><label class="expand" for="c-40175375">[2 more]</label></div><br/><div class="children"><div class="content">50+ years and people still fail to grasp this.<p>You have to put something (an optional, or a default constructed object in a useless state) and all you did was to skip the null check. In case of optional, you introduced a stack rewind or a panic. Everything else stayed the same. Maybe that default even deleted the hard drive instead of crashing.<p>Coding is hard. &quot;just don&#x27;t code&quot; is not the answer. You can avoid something, that doesn&#x27;t mean it won&#x27;t show up in some other fashion.</div><br/><div id="40175619" class="c"><input type="checkbox" id="c-40175619" checked=""/><div class="controls bullet"><span class="by">sam0x17</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40175375">parent</a><span>|</span><a href="#40174561">next</a><span>|</span><label class="collapse" for="c-40175619">[-]</label><label class="expand" for="c-40175619">[1 more]</label></div><br/><div class="children"><div class="content">Again, if you disallow unwrapping and panicking at the CI level, you actually force your developers to properly handle these situations.</div><br/></div></div></div></div></div></div><div id="40174561" class="c"><input type="checkbox" id="c-40174561" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174098">parent</a><span>|</span><a href="#40174227">prev</a><span>|</span><a href="#40172593">next</a><span>|</span><label class="collapse" for="c-40174561">[-]</label><label class="expand" for="c-40174561">[4 more]</label></div><br/><div class="children"><div class="content">Arbitrary recovery to null pointers isn&#x27;t a good way to do robust programming. I recommend doing the exact opposite actually.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Crash-only_software" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Crash-only_software</a><p><a href="https:&#x2F;&#x2F;medium.com&#x2F;@vamsimokari&#x2F;erlang-let-it-crash-philosophy-53486d2a6da" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@vamsimokari&#x2F;erlang-let-it-crash-philosop...</a></div><br/><div id="40175208" class="c"><input type="checkbox" id="c-40175208" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40174561">parent</a><span>|</span><a href="#40172593">next</a><span>|</span><label class="collapse" for="c-40175208">[-]</label><label class="expand" for="c-40175208">[3 more]</label></div><br/><div class="children"><div class="content">A crash of an actor in BEAM is incomparable to a crash of a video game.</div><br/><div id="40176429" class="c"><input type="checkbox" id="c-40176429" checked=""/><div class="controls bullet"><span class="by">epr</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40175208">parent</a><span>|</span><a href="#40175963">next</a><span>|</span><label class="collapse" for="c-40176429">[-]</label><label class="expand" for="c-40176429">[1 more]</label></div><br/><div class="children"><div class="content">Is it? Is there no reasonable case where you have a subsystem in a game crash, then restart itself? Unless I&#x27;m mistaken, I&#x27;ve experienced this myself in video games more than once. Anything beats a full crash with a pointless error message.</div><br/></div></div><div id="40175963" class="c"><input type="checkbox" id="c-40175963" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40173475">root</a><span>|</span><a href="#40175208">parent</a><span>|</span><a href="#40176429">prev</a><span>|</span><a href="#40172593">next</a><span>|</span><label class="collapse" for="c-40175963">[-]</label><label class="expand" for="c-40175963">[1 more]</label></div><br/><div class="children"><div class="content">But if your video game uses a DSL for actors then you can do it in the DSL, which avoids special arbitrary bug-hiding behavior.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40172593" class="c"><input type="checkbox" id="c-40172593" checked=""/><div class="controls bullet"><span class="by">popcar2</span><span>|</span><a href="#40173475">prev</a><span>|</span><a href="#40172747">next</a><span>|</span><label class="collapse" for="c-40172593">[-]</label><label class="expand" for="c-40172593">[37 more]</label></div><br/><div class="children"><div class="content">&gt; Rust gamedev ecosystem lives on hype<p>I&#x27;ve been saying this for years. I&#x27;ve tried to get into Rust multiple times the past few years and one of the things I&#x27;ve tried was gamedev with Rust (specifically the library ggez when it was still being worked on, and a little bit of Bevy). I admittedly never got far, but I gave it a solid shot.<p>My experience was instantly terrible. Slow compile times and iterations, huge package downloads (my project folder was roughly 1gb for a simple 2D project), and of course Rust itself was difficult to get into with lifetimes and having to wrap and unwrap my variables constantly and getting into wrestling matches with the borrow checker.<p>I kept telling myself that everyone loves Rust and the community loves to rave about anything Rust-related and maybe I just don&#x27;t get it, but it took some time to realize that no... It&#x27;s just a terrible choice for it. I even tried to make UI with eGUI and was still miserable. Rust is a systems programming language but the community is trying to convince everyone should be used for general purpose stuff.<p>And my other biggest problem is that they keep painting other non-Rust things as being fundamentally flawed for not being Rust. &quot;It&#x27;s not memory safe&quot; is the biggest one thrown around, but when was the last time memory safety was actually a big problem in games? Unity uses C# which is garbage collected, Godot uses its own scripting language which makes it nigh impossible to leak memory, Unreal AFAIK has its own tools that makes memory management trivial. Rust game development feels like a solution looking for a problem to fix.<p>I am curious about Bevy when it becomes mature and has its own editor, but for now I&#x27;m just not convinced gamedev with Rust will ever take off.</div><br/><div id="40173842" class="c"><input type="checkbox" id="c-40173842" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40172746">next</a><span>|</span><label class="collapse" for="c-40173842">[-]</label><label class="expand" for="c-40173842">[13 more]</label></div><br/><div class="children"><div class="content">&gt; And my other biggest problem is that they keep painting other non-Rust things as being fundamentally flawed for not being Rust. &quot;It&#x27;s not memory safe&quot; is the biggest one thrown around, but when was the last time memory safety was actually a big problem in games? Unity uses C# which is garbage collected, Godot uses its own scripting language which makes it nigh impossible to leak memory, Unreal AFAIK has its own tools that makes memory management trivial. Rust game development feels like a solution looking for a problem to fix.<p>Memory safety may or may not be important in games, but the ability of engines like Bevy to analyze system dependencies and automatically scale to multiple CPUs is a big deal. Job queuing systems have been popular in gamedev for a very long time, and Rust&#x27;s insistence on explicit declaration of mutability is a big part of the reason that &quot;just works&quot; in Bevy.</div><br/><div id="40176343" class="c"><input type="checkbox" id="c-40176343" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40173842">parent</a><span>|</span><a href="#40178329">next</a><span>|</span><label class="collapse" for="c-40176343">[-]</label><label class="expand" for="c-40176343">[8 more]</label></div><br/><div class="children"><div class="content">&gt; but the ability of engines like Bevy to analyze system dependencies and automatically scale to multiple CPUs is a big deal<p>Is it?  The article addresses that, and basically calls it a pointless feature that is almost never used and when it is the benefits are mostly lost because of real world needs and constraints, and that the problems it solves are easier solved through other solutions and add-on systems that are well understood.<p>I think this might be a case where explaining the real-world benefit instead of the theoretical benefit is needed, if only to counter what are very pointed criticisms that are definitely deeper than at the theoretical level.</div><br/><div id="40176646" class="c"><input type="checkbox" id="c-40176646" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40176343">parent</a><span>|</span><a href="#40178329">next</a><span>|</span><label class="collapse" for="c-40176646">[-]</label><label class="expand" for="c-40176646">[7 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a trace of a Bevy demo: <a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;oXUxC2h.png" rel="nofollow">https:&#x2F;&#x2F;i.imgur.com&#x2F;oXUxC2h.png</a><p>You can see that all the CPUs are being maxed out. This actually does result in significant FPS increases. Does it matter for every game? No. But it does result in better performance!</div><br/><div id="40177814" class="c"><input type="checkbox" id="c-40177814" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40176646">parent</a><span>|</span><a href="#40176766">next</a><span>|</span><label class="collapse" for="c-40177814">[-]</label><label class="expand" for="c-40177814">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; but the ability of engines like Bevy to analyze system dependencies and automatically scale to multiple CPUs is a big deal<p>&gt;&gt; Is it? The article addresses that, and basically calls it a pointless feature<p>&gt; You can see that all the CPUs are being maxed out.<p>You&#x27;re missing the forest for the trees - the poster above basically said &quot;seeing all the CPUs being maxed out is a pointless feature&quot; and you reply with &quot;but see, all the CPUs are being maxed out&quot;.<p>You&#x27;re literally ignoring the complaint and replying with marketing.</div><br/><div id="40178366" class="c"><input type="checkbox" id="c-40178366" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40177814">parent</a><span>|</span><a href="#40176766">next</a><span>|</span><label class="collapse" for="c-40178366">[-]</label><label class="expand" for="c-40178366">[1 more]</label></div><br/><div class="children"><div class="content">No, the original article said that you <i>don&#x27;t get</i> parallelism from Bevy in practice:<p>&gt; Unfortunately, after all the work that one has to put into ordering their systems it&#x27;s not like there is going to be much left to parallelize. And in practice, what little one might gain from this will amount to parallelizing a purely data driven system that could&#x27;ve been done trivially with data parallelism using rayon.<p>It&#x27;s <i>not</i> saying &quot;yes, you get parallelism, but I don&#x27;t need the performance&quot;; it&#x27;s claiming that in practice you don&#x27;t get (system-level) parallelism at all. That&#x27;s at odds with my experience.</div><br/></div></div></div></div><div id="40176766" class="c"><input type="checkbox" id="c-40176766" checked=""/><div class="controls bullet"><span class="by">VS1999</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40176646">parent</a><span>|</span><a href="#40177814">prev</a><span>|</span><a href="#40178329">next</a><span>|</span><label class="collapse" for="c-40176766">[-]</label><label class="expand" for="c-40176766">[4 more]</label></div><br/><div class="children"><div class="content">The problem is that most of the gameplay code is linear, and people have already gotten good at splitting parallel work across threads. Serious physics engines (see jolt) are already designed to run on another thread and distribute the work across multiple cores. The main part of graphics drivers when using opengl or vulkan run on another thread and the UI you access just passes data to it. Rust&#x27;s parallelism hasn&#x27;t proven to be faster than C&#x2F;C++, let alone less annoying to achieve.</div><br/><div id="40176922" class="c"><input type="checkbox" id="c-40176922" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40176766">parent</a><span>|</span><a href="#40178329">next</a><span>|</span><label class="collapse" for="c-40176922">[-]</label><label class="expand" for="c-40176922">[3 more]</label></div><br/><div class="children"><div class="content">Among those who have tried both, I can confidently say that the idea that C&#x2F;C++ parallelism is as easy to achieve as parallelism in Rust is very much a minority view. There&#x27;s a reason why nobody tried to parallelize CSS styling in a production browser before Stylo came along.</div><br/><div id="40177002" class="c"><input type="checkbox" id="c-40177002" checked=""/><div class="controls bullet"><span class="by">VS1999</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40176922">parent</a><span>|</span><a href="#40178329">next</a><span>|</span><label class="collapse" for="c-40177002">[-]</label><label class="expand" for="c-40177002">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m talking about games specifically. I don&#x27;t know much about the needs of web browsers.</div><br/><div id="40177090" class="c"><input type="checkbox" id="c-40177090" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40177002">parent</a><span>|</span><a href="#40178329">next</a><span>|</span><label class="collapse" for="c-40177090">[-]</label><label class="expand" for="c-40177090">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve parallelized emulators in C++ and work on parallel parts of Bevy now, which is probably the closest you&#x27;re going to get to someone who has worked on parallelizing parts of large game engines in both C++ and Rust. It was far easier in Rust.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40178329" class="c"><input type="checkbox" id="c-40178329" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40173842">parent</a><span>|</span><a href="#40176343">prev</a><span>|</span><a href="#40176827">next</a><span>|</span><label class="collapse" for="c-40178329">[-]</label><label class="expand" for="c-40178329">[1 more]</label></div><br/><div class="children"><div class="content">&gt; automatically scale to multiple CPUs<p>We&#x27;ve been promised automatic CPU scaling in programming languages since at least 2001, and I&#x27;ve yet to see any practical version of it.</div><br/></div></div><div id="40176827" class="c"><input type="checkbox" id="c-40176827" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40173842">parent</a><span>|</span><a href="#40178329">prev</a><span>|</span><a href="#40172746">next</a><span>|</span><label class="collapse" for="c-40176827">[-]</label><label class="expand" for="c-40176827">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a good feature, but still a niche one. It&#x27;s a bit like choosing Unity <i>only</i> because of DOTS. For a few projects perhaps it make sense. But just a few ones.</div><br/><div id="40176938" class="c"><input type="checkbox" id="c-40176938" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40176827">parent</a><span>|</span><a href="#40172746">next</a><span>|</span><label class="collapse" for="c-40176938">[-]</label><label class="expand" for="c-40176938">[2 more]</label></div><br/><div class="children"><div class="content">Nobody said that every game needs that level of performance. But saying that it&#x27;s a solution looking for a problem is not true.<p>I&#x27;m fully in favor of having Bevy support dynamic languages, as implemented in for example bevy_mod_scripting [1], for projects that don&#x27;t need that parallel performance.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;makspll&#x2F;bevy_mod_scripting">https:&#x2F;&#x2F;github.com&#x2F;makspll&#x2F;bevy_mod_scripting</a></div><br/><div id="40178154" class="c"><input type="checkbox" id="c-40178154" checked=""/><div class="controls bullet"><span class="by">vaylian</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40176938">parent</a><span>|</span><a href="#40172746">next</a><span>|</span><label class="collapse" for="c-40178154">[-]</label><label class="expand" for="c-40178154">[1 more]</label></div><br/><div class="children"><div class="content">Good scripting support is probably the way to go for Rust game development anyway in order to achieve high iteration&#x2F;idea testing velocity. We could have a script engine that memory-manages various in-game objects and the scripts call into Rust functions to do the heavy lifting. Those Rust functions will typically take things by reference from the script engine so that memory-management is mostly a non-issue.</div><br/></div></div></div></div></div></div></div></div><div id="40172746" class="c"><input type="checkbox" id="c-40172746" checked=""/><div class="controls bullet"><span class="by">fleventynine</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40173842">prev</a><span>|</span><a href="#40173891">next</a><span>|</span><label class="collapse" for="c-40172746">[-]</label><label class="expand" for="c-40172746">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a Rust fan (mostly for embedded firmware with minimal deps), but even after 10 years of playing with the language it&#x27;s not clear to me that advanced GUI or gamedev fits well with the borrow checker. It requires a significant paradigm shift in architecture, and I&#x27;m not convinced it&#x27;s worth making that shift, especially if your application can tolerate a garbage collector (which many games and most UI apps can).</div><br/><div id="40173009" class="c"><input type="checkbox" id="c-40173009" checked=""/><div class="controls bullet"><span class="by">iknowstuff</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40172746">parent</a><span>|</span><a href="#40174114">next</a><span>|</span><label class="collapse" for="c-40173009">[-]</label><label class="expand" for="c-40173009">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;dioxuslabs.com&#x2F;blog&#x2F;release-050">https:&#x2F;&#x2F;dioxuslabs.com&#x2F;blog&#x2F;release-050</a><p>Seems promising, very React-esque with little boilerplate</div><br/><div id="40177288" class="c"><input type="checkbox" id="c-40177288" checked=""/><div class="controls bullet"><span class="by">alimnes</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40173009">parent</a><span>|</span><a href="#40173417">next</a><span>|</span><label class="collapse" for="c-40177288">[-]</label><label class="expand" for="c-40177288">[1 more]</label></div><br/><div class="children"><div class="content">Development speed is many times lower than with Typescript frameworks, while the result is not faster or significantly more stable.<p>Why should anyone choose Dioxus over Sveltekit, Next or Nuxt? I never had an issue with a frontend app that the borrow checker would have catched. Error handling was an issues some years ago but is solved by now when using one of those modern frameworks. (I don&#x27;t know if Dioxus has error boundaries, though.)<p>Those Rust fullstack frameworks make sense only for people wanting to use Rust, not for people looking for the right tool for the job.</div><br/></div></div><div id="40173417" class="c"><input type="checkbox" id="c-40173417" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40173009">parent</a><span>|</span><a href="#40177288">prev</a><span>|</span><a href="#40174114">next</a><span>|</span><label class="collapse" for="c-40173417">[-]</label><label class="expand" for="c-40173417">[2 more]</label></div><br/><div class="children"><div class="content">I hope Rust does gain mature options for its GUI ecosystem, but the author of the article makes a very good point that in other languages, there would be mature options in use already. &quot;Seems promising&quot; is too little, too late.</div><br/><div id="40173539" class="c"><input type="checkbox" id="c-40173539" checked=""/><div class="controls bullet"><span class="by">iknowstuff</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40173417">parent</a><span>|</span><a href="#40174114">next</a><span>|</span><label class="collapse" for="c-40173539">[-]</label><label class="expand" for="c-40173539">[1 more]</label></div><br/><div class="children"><div class="content">For sure! I would not write a game in Rust in 2024.</div><br/></div></div></div></div></div></div><div id="40174114" class="c"><input type="checkbox" id="c-40174114" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40172746">parent</a><span>|</span><a href="#40173009">prev</a><span>|</span><a href="#40173891">next</a><span>|</span><label class="collapse" for="c-40174114">[-]</label><label class="expand" for="c-40174114">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Multiple languages exist. They can be part of {your, your team&#x27;s} toolbox for different specific purposes. Some languages are set by other tools or by team members&#x27; backgrounds. Popularity also lends itself to greater availability of tools and Q&amp;A forums. In the end, it&#x27;s a better decision-making process to select what is most likely to be long-term productive for a specific project and team.</div><br/></div></div></div></div><div id="40173891" class="c"><input type="checkbox" id="c-40173891" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40172746">prev</a><span>|</span><a href="#40172796">next</a><span>|</span><label class="collapse" for="c-40173891">[-]</label><label class="expand" for="c-40173891">[1 more]</label></div><br/><div class="children"><div class="content">This might be controversial, but &quot;Safety&quot; and &quot;Speed&quot;, in the same ecosystem, are not free. The cost is heavy syntax and heavy cognitive climbs. Why Rust was ever sold as a language for the masses is beyond me. A safe, fast, hard language is something you use for operating systems, aircraft, etc.<p>I adore Rust because it does all the things I remember being told to do in C, but without me remembering to do them: Error codes from all functions, Ownership models, etc. But those are not good reasons for me to use it for anything I wouldn&#x27;t use C for.</div><br/></div></div><div id="40172796" class="c"><input type="checkbox" id="c-40172796" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40173891">prev</a><span>|</span><a href="#40173814">next</a><span>|</span><label class="collapse" for="c-40172796">[-]</label><label class="expand" for="c-40172796">[3 more]</label></div><br/><div class="children"><div class="content">Just a small addition: Godot also has great C# support. It is a real charm to work with.</div><br/><div id="40177343" class="c"><input type="checkbox" id="c-40177343" checked=""/><div class="controls bullet"><span class="by">leduyquang753</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40172796">parent</a><span>|</span><a href="#40176308">next</a><span>|</span><label class="collapse" for="c-40177343">[-]</label><label class="expand" for="c-40177343">[1 more]</label></div><br/><div class="children"><div class="content">Last time I tried Godot with C# in Visual studio, when I debugged I could not see the console output, and when I ran with the console output I could not debug (the breakpoints weren&#x27;t hit). A Google search later and turns out it wasn&#x27;t just me.</div><br/></div></div><div id="40176308" class="c"><input type="checkbox" id="c-40176308" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40172796">parent</a><span>|</span><a href="#40177343">prev</a><span>|</span><a href="#40173814">next</a><span>|</span><label class="collapse" for="c-40176308">[-]</label><label class="expand" for="c-40176308">[1 more]</label></div><br/><div class="children"><div class="content">The godot-rust project crates take a minor amount of adaptation to understand how it exposes the Godot object system in Rust but it&#x27;s also pretty well developed.</div><br/></div></div></div></div><div id="40173814" class="c"><input type="checkbox" id="c-40173814" checked=""/><div class="controls bullet"><span class="by">Quothling</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40172796">prev</a><span>|</span><a href="#40173831">next</a><span>|</span><label class="collapse" for="c-40173814">[-]</label><label class="expand" for="c-40173814">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re doing more and more of our back-end work with Rust. The main reason is the performance it provides. It&#x27;s not just great for our end-users it&#x27;s also so much cheaper in the modern world where we pay per mileage in the cloud. Part of what we really like about Rust, however, is actually exactly the variable ownership because it makes it very straight forward to enforce and control data-integrity and avoid race conditions. Even for programmers who would struggle to do so in C or C++.<p>I&#x27;m not sure whether or not that&#x27;s even useful in game development. I&#x27;ve never done any form of game development beyond some Chess game I programmed in my first year of CS 30 years ago. But I&#x27;m actually really curious as to why you&#x27;ve struggled with variable ownership, because I&#x27;d frankly like to improve our on-boarding processes even more for new hires.<p>&gt; my other biggest problem is that they keep painting other non-Rust things as being fundamentally flawed for not being Rust<p>Rust has a cult and it&#x27;s best not to pay too much attention to it. Don&#x27;t get me wrong, we&#x27;re seeing great benefit in not just using Rust over C&#x2F;C++ but also replacing more and more of our C# and Python services with it, but it&#x27;s a very immature language and like any other programming language it&#x27;s still just a tool. If it works for you, use it, if not... Well, use something that does.</div><br/></div></div><div id="40173831" class="c"><input type="checkbox" id="c-40173831" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40173814">prev</a><span>|</span><a href="#40173455">next</a><span>|</span><label class="collapse" for="c-40173831">[-]</label><label class="expand" for="c-40173831">[1 more]</label></div><br/><div class="children"><div class="content">Rust ain&#x27;t Go but anything Go has can be used as an argument that Rust should try to do better in certain areas. ;)<p>Perhaps learn another language like Haskell, Swift, or Kotlin before Rust.<p>Get cargo-bloat, cargo-cache, and cargo-outdated.<p>Setup a memcache server and use sccache to accelerate Rust, C, and C++ compilations. It&#x27;s not 100% but it&#x27;s pretty awesome for things compiled at a stable build location.<p>Just like any platform, avoid dependencies wherever possible and use minimal crate features. Some Rust crates have an npm-like problem of dragging in zillions of dependencies.</div><br/></div></div><div id="40173455" class="c"><input type="checkbox" id="c-40173455" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40173831">prev</a><span>|</span><a href="#40175367">next</a><span>|</span><label class="collapse" for="c-40173455">[-]</label><label class="expand" for="c-40173455">[2 more]</label></div><br/><div class="children"><div class="content">Now I&#x27;m wondering how far people could go a hypothetical Rustscript* that transpiles to Rust (or hooks into rustc?), introduces extra features such as reflection, removes lifetimes, and changes the defaults around things like monomorphization.<p>* name intentionally made to make people angry</div><br/><div id="40178396" class="c"><input type="checkbox" id="c-40178396" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40173455">parent</a><span>|</span><a href="#40175367">next</a><span>|</span><label class="collapse" for="c-40178396">[-]</label><label class="expand" for="c-40178396">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re removing lifetimes from the script, I&#x27;m not sure how you&#x27;re then transpiling to Rust, unless you wrap everything with reference counting, at which point you&#x27;re better off using a language with GC.</div><br/></div></div></div></div><div id="40175367" class="c"><input type="checkbox" id="c-40175367" checked=""/><div class="controls bullet"><span class="by">nialv7</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40173455">prev</a><span>|</span><a href="#40175617">next</a><span>|</span><label class="collapse" for="c-40175367">[-]</label><label class="expand" for="c-40175367">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but when was the last time memory safety was actually a big problem in games? Unity uses C# which is garbage collected, Godot uses its own scripting language which makes it nigh impossible to leak memory, Unreal AFAIK has its own tools that makes memory management trivial.<p>So.... Sounds like memory safety is indeed a problem? Otherwise why do so many solutions exist for it?<p>Yeah, Rust definitely is not the only solution, or perhaps not even a good solution to this problem in the context of game development. But let&#x27;s not pretend the problem itself doesn&#x27;t exist?</div><br/></div></div><div id="40175617" class="c"><input type="checkbox" id="c-40175617" checked=""/><div class="controls bullet"><span class="by">ciwolsey</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40175367">prev</a><span>|</span><a href="#40175562">next</a><span>|</span><label class="collapse" for="c-40175617">[-]</label><label class="expand" for="c-40175617">[1 more]</label></div><br/><div class="children"><div class="content">Garbage collection causes performance issues.</div><br/></div></div><div id="40175562" class="c"><input type="checkbox" id="c-40175562" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40175617">prev</a><span>|</span><a href="#40177251">next</a><span>|</span><label class="collapse" for="c-40175562">[-]</label><label class="expand" for="c-40175562">[2 more]</label></div><br/><div class="children"><div class="content">As I said in my own comment down thread, despite being a huge rust advocate, I sincerely agree with you here.<p>Rust is <i>not</i> a good language for actually writing games, and the fact that it is being sold as such is really detrimental to it in my opinion, because it is holding the ecosystem back. Rust is being pushed as a language for game logic, so  people try out and realize it isn&#x27;t very good at that, and so they just give up on Rust in the game development industry at all and leave, understandably! If Rust were more strategically positioned, it could get a lot farther. Where it should be focusing in the games industry is on game engines, where flexibility and quick iteration and easy prototyping and being able to just reach out and directly touch and control things isn&#x27;t as important, but where concerns like the clarity and maintainability of the code base, stability of the software, resource ownership and management, and eeking out every ounce of performance all become important, and so the type system and static analysis guarantees of Rust are actually useful.<p>This is where, I&#x27;m disappointed to say, I think things like Bevy and Amethyst have severely hurt the Rust game development ecosystem. They aren&#x27;t really game engines in the traditional sense, they are more like game <i>frameworks</i> like Love2D except written in Rust: they force you to statically link your game code to the engine code, and write your game logic in the same language your engine is written in. This means that game developers who just want to quickly prototype game mechanics and want to be able to iterate on them in order to refine them are forced to use a language that is far too focused on correctness, safety, static verifiability, and concerns like that to actually be usable as a programming language, and worse, it forces them to compile their game logic and the entire engine together and link them together in order to build their actual game and test it, massively increasing the weight of the process and basically ruling out hot reloading or making your game independent of any specific version of the engine, or its license. It puts them between a rock and a hard place, between using some other ecosystem, or using a language that simply unsuitable for a game development.<p>I think the far better solution (one which I plan to very slowly feel out with my embryo engine project, which is born out of my frustration of looking at the existing rust game engines and feeling like they are all kind of lying about what they are) would be to stop with the vaporware and the hype with Bevy and Amethyst and such, and actually build a proper game engine, like they are promising to be but are not, that is its own separate pre-compiled executable that game developers don&#x27;t even need to mess with at all, that picks up game assets and game code written in a more flexible, dynamic, language that&#x27;s better for prototyping, and runs them, something like what Unity or Godot or even Gamebryo do. Only then will the rust game development ecosystem take off, because it will no longer be forcing a language that just isn&#x27;t good for that on to people.</div><br/><div id="40178184" class="c"><input type="checkbox" id="c-40178184" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40175562">parent</a><span>|</span><a href="#40177251">next</a><span>|</span><label class="collapse" for="c-40178184">[-]</label><label class="expand" for="c-40178184">[1 more]</label></div><br/><div class="children"><div class="content">But people want to write Rust and a game seems like a fun way to do it. They can already use Godot or Unity with this approach.</div><br/></div></div></div></div><div id="40177251" class="c"><input type="checkbox" id="c-40177251" checked=""/><div class="controls bullet"><span class="by">alimnes</span><span>|</span><a href="#40172593">parent</a><span>|</span><a href="#40175562">prev</a><span>|</span><a href="#40172747">next</a><span>|</span><label class="collapse" for="c-40177251">[-]</label><label class="expand" for="c-40177251">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Rust game development feels like a solution looking for a problem to fix.<p>The same can be said for ordinary CRUD backends. Java, C#, Go and Typescript (Node, Deno or Bun) are all memory safe with good type systems and more than good enough performance. Evangelism around Rust is unfortunately still a thing. A good example is the latest hype in the community because some Google Manager said at a Rust conference that writing Rust is as fast as writing Go. Anyone having done more than a toy program in Rust and Go knows how wrong this statement is. The reasons are given in the article.</div><br/><div id="40177306" class="c"><input type="checkbox" id="c-40177306" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40177251">parent</a><span>|</span><a href="#40172747">next</a><span>|</span><label class="collapse" for="c-40177306">[-]</label><label class="expand" for="c-40177306">[4 more]</label></div><br/><div class="children"><div class="content">This is not necessarily a bad thing. Especially given that Rust is an immediate upgrade with no downsides when moving away from C or C++. It is easy to see with people never wanting to go back, which also involves getting companies and products to adopt it as you would otherwise be forced by the market to work with inferior tools.<p>As a counterexample, .NET suffers a lot from the lack of evangelism - big chunk of community that started out back in .net framework days still thinks of it as poorly as people outside the ecosystem because they never bothered to drop old and obsolete tools and targets and give new versions a proper try (as the code is often vastly simplified and performance is vastly better).<p>Other programming languages, not only Rust, also do better at self promotion - take for example Go that managed to convince everyone to put it in the same bucket as Rust (which, personally, I find absolutely insulting as C# is a much closer alternative to Rust both in performance, features and access to low-level bits).</div><br/><div id="40177969" class="c"><input type="checkbox" id="c-40177969" checked=""/><div class="controls bullet"><span class="by">obdev</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40177306">parent</a><span>|</span><a href="#40172747">next</a><span>|</span><label class="collapse" for="c-40177969">[-]</label><label class="expand" for="c-40177969">[3 more]</label></div><br/><div class="children"><div class="content">I mean, if we are allowed to lie in order to promote Rust, why don&#x27;t we just smear all the C&#x2F;C++ code bases in the world as security hazard needed to be sorted out ASAP?<p>Unless we already do...</div><br/><div id="40178092" class="c"><input type="checkbox" id="c-40178092" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40177969">parent</a><span>|</span><a href="#40172747">next</a><span>|</span><label class="collapse" for="c-40178092">[-]</label><label class="expand" for="c-40178092">[2 more]</label></div><br/><div class="children"><div class="content">I doubt security is the matter everyone is concerned with but rather the quality of tooling and developer experience.<p>It is, of course, difficult to convey to developers who only experienced C and C++ build systems, or Ruby tooling and brittleness, or Python way of managing dependencies, or setting up the packaging when using Java, that fast and easy to use solutions do not come from trade-offs but from <i>just</i> better ways of doing so - using cargo and Rust or dotnet and C# is night and day difference compared to options listed above.<p>I said it here in the past and will say it again: it&#x27;s not that Rust (or .NET for that matter) are <i>that</i> good, it&#x27;s a lot of other popular languages and platforms are <i>that</i> bad at one or another aspect (or many at the same time), that make it sufficiently painful to never tolerate a downgrade when you worked with a tool that offers better all-around experience.</div><br/><div id="40178393" class="c"><input type="checkbox" id="c-40178393" checked=""/><div class="controls bullet"><span class="by">obdev</span><span>|</span><a href="#40172593">root</a><span>|</span><a href="#40178092">parent</a><span>|</span><a href="#40172747">next</a><span>|</span><label class="collapse" for="c-40178393">[-]</label><label class="expand" for="c-40178393">[1 more]</label></div><br/><div class="children"><div class="content">I value good tooling as much as the next software engineer. We have good IDEs, build systems, package managers in Java and .NET lands; but we also have a decent environment of established, well-maintained libraries and frameworks.<p>Rust is deemed to have good tooling, but the third-party library ecosystem is following the NPM&#x2F;RubyGems <i>culture</i> with all the fragmented dependencies, plus the added complexity of compile times due to lack of ABI compatibility.<p>Meanwhile, monolithic projects like Tokio also keep strengthening their reign among the small peasant crates.<p>I&#x27;m learning Rust, after decades of various languages with garbage collector, and I believe in the language itself and its tooling. But everything else about Rust irks me.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40172747" class="c"><input type="checkbox" id="c-40172747" checked=""/><div class="controls bullet"><span class="by">LarsDu88</span><span>|</span><a href="#40172593">prev</a><span>|</span><a href="#40173393">next</a><span>|</span><label class="collapse" for="c-40172747">[-]</label><label class="expand" for="c-40172747">[12 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done hobby gamedev in Bevy&#x2F;Rust, Godot&#x2F;C#, and Unity C#.<p>It&#x27;s honestly somewhat baffling to me that folks will choose Rust for gamedev right now. The state of the open sourced tools are just not there yet, especially when compared to Godot, and at the same time these games are running on PC hardware which tends to get faster every year.<p>Also for ECS... one thing I tended to realize is that when developing a game, pigeonholing everything into an ECS can seriously tend to get in the way. A lot of (efficiently written) game code is best handled in an infrequent event-driven way.<p>An ECS backed game engine like Bevy can make big mobs more efficient, but few games will actually leverage this effectively for fun gameplay and at the same time modern PCs are fast as hell.<p>I think about Starcraft from 1998, created when virtually all PCs only had one core, and its 200 unit per faction cap. Blizzard hasn&#x27;t increased this cap because it doesn&#x27;t necessarily make the game more fun. Now should a gamedev today, 26 years later, making a 2d isometric game for the PC be worried about performant multithreading????</div><br/><div id="40173810" class="c"><input type="checkbox" id="c-40173810" checked=""/><div class="controls bullet"><span class="by">Nuzzerino</span><span>|</span><a href="#40172747">parent</a><span>|</span><a href="#40173449">next</a><span>|</span><label class="collapse" for="c-40173810">[-]</label><label class="expand" for="c-40173810">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I think about Starcraft from 1998, created when virtually all PCs only had one core, and its 200 unit per faction cap. Blizzard hasn&#x27;t increased this cap because it doesn&#x27;t necessarily make the game more fun.<p>Ah... Starcraft. It&#x27;s 200 supply per player (hero units take 0 supply, zerglings are 0.5, and the supply cost goes up to 8 for battlecruisers for example). The limit is enforced when building a unit from a building. Map triggers can grant units and you can exceed the 200 supply limit.<p>The technical unit limit for the map was 1700, and was later in fact extended to 3400 by Blizzard. The EUD emulator (part of the official SC Remastered) allows for online custom games to be played without any third party tools on the player&#x27;s part. Certain limits like sprites can be bypassed with this tool (for map makers) <a href="https:&#x2F;&#x2F;github.com&#x2F;phu54321&#x2F;euddraft&#x2F;blob&#x2F;master&#x2F;plugins&#x2F;unlimiter.py">https:&#x2F;&#x2F;github.com&#x2F;phu54321&#x2F;euddraft&#x2F;blob&#x2F;master&#x2F;plugins&#x2F;unl...</a><p>EUD started out as a buffer overflow exploit which allowed custom maps to patch the game client&#x27;s code. It was later fixed by blizzard but re-implemented as an emulator (with some restrictions).<p>These are definitely things that enhance gameplay for custom scenarios. 
<a href="https:&#x2F;&#x2F;youtu.be&#x2F;HEv_U9WV4PA?t=1541" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;HEv_U9WV4PA?t=1541</a> (yes, that is a battlecruiser shooting nukes)</div><br/><div id="40176184" class="c"><input type="checkbox" id="c-40176184" checked=""/><div class="controls bullet"><span class="by">davidalayachew</span><span>|</span><a href="#40172747">root</a><span>|</span><a href="#40173810">parent</a><span>|</span><a href="#40173449">next</a><span>|</span><label class="collapse" for="c-40176184">[-]</label><label class="expand" for="c-40176184">[2 more]</label></div><br/><div class="children"><div class="content">Complete distraction of a question -- for that video clip, what is the song playing at the time stamp you selected? Is that in-game music? I figure not.</div><br/><div id="40177162" class="c"><input type="checkbox" id="c-40177162" checked=""/><div class="controls bullet"><span class="by">Nuzzerino</span><span>|</span><a href="#40172747">root</a><span>|</span><a href="#40176184">parent</a><span>|</span><a href="#40173449">next</a><span>|</span><label class="collapse" for="c-40177162">[-]</label><label class="expand" for="c-40177162">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t know the song but that is the ingame music for that specific map, and gets triggered each time certain enemy buildings are destroyed. Different music for each type of building</div><br/></div></div></div></div></div></div><div id="40173449" class="c"><input type="checkbox" id="c-40173449" checked=""/><div class="controls bullet"><span class="by">pixelesque</span><span>|</span><a href="#40172747">parent</a><span>|</span><a href="#40173810">prev</a><span>|</span><a href="#40173426">next</a><span>|</span><label class="collapse" for="c-40173449">[-]</label><label class="expand" for="c-40173449">[1 more]</label></div><br/><div class="children"><div class="content">Likewise - I&#x27;ve been learning Rust for four years now (significant C&#x2F;C++&#x2F;Python&#x2F;Lua experience), and have written some reasonably complex apps in it, but I really just didn&#x27;t get the Bevy &#x2F; ECS &quot;hype&quot;...<p>I&#x27;ve tried to write several different types of games using it (with Bevy) in the past three years, and it just feels like shoe-horning something in.<p>But the biggest complaint I have with Bevy is that with all the refactoring that&#x27;s been needed with the Bevy version upgrades: getting the code to compile again after the version upgrades has normally been fairly easy - but it then often didn&#x27;t work correctly, and I&#x27;d have to spend time debugging the ECS system to work out what was wrong.<p>i.e. the &quot;if it compiles, it&#x27;ll almost certainly work&quot; bonus of generic Rust code totally seems to fall down within Bevy.<p>I obviously understand that it&#x27;s an in-development framework, in its early days, so some of that&#x27;s on me for choosing it, but still, it&#x27;s been a very painful experience, and I feel I&#x27;ve wasted a fairly significant amount of time over the past few years attempting it.</div><br/></div></div><div id="40173426" class="c"><input type="checkbox" id="c-40173426" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#40172747">parent</a><span>|</span><a href="#40173449">prev</a><span>|</span><a href="#40175627">next</a><span>|</span><label class="collapse" for="c-40173426">[-]</label><label class="expand" for="c-40173426">[2 more]</label></div><br/><div class="children"><div class="content">CPUs are way way faster, but RAM latency has barely improved in the past couple decades. That&#x27;s why cache-optimized systems like ECS can still be a dramatic improvement when you&#x27;re simulating a <i>lot</i> of stuff. Like, thousands of active objects.</div><br/><div id="40173497" class="c"><input type="checkbox" id="c-40173497" checked=""/><div class="controls bullet"><span class="by">pixelesque</span><span>|</span><a href="#40172747">root</a><span>|</span><a href="#40173426">parent</a><span>|</span><a href="#40175627">next</a><span>|</span><label class="collapse" for="c-40173497">[-]</label><label class="expand" for="c-40173497">[1 more]</label></div><br/><div class="children"><div class="content">They <i>can</i> be improvements, but you can do Data-Oriented Programming without ECS systems, i.e. Structure Of Arrays, which is what we often using in Rendering&#x2F;Simulation for VFX for SIMD&#x2F;GPU compute...<p>But similarly, ECSs <i>can</i> be slower, if they don&#x27;t have some optimisations, i.e. spatial data structure lookups: just using a generic ECS &quot;database&quot; system without any first-class spatial knowledge &#x2F; acceleration structure lookup ability, is likely going to be slower.</div><br/></div></div></div></div><div id="40175627" class="c"><input type="checkbox" id="c-40175627" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40172747">parent</a><span>|</span><a href="#40173426">prev</a><span>|</span><a href="#40177381">next</a><span>|</span><label class="collapse" for="c-40175627">[-]</label><label class="expand" for="c-40175627">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I think about Starcraft from 1998, created when virtually all PCs only had one core, and its 200 unit per faction cap. Blizzard hasn&#x27;t increased this cap because it doesn&#x27;t necessarily make the game more fun.<p>That small scale was exactly why the game ends up being so much about micro, and while that may make it more competitive or interesting for spectators it makes it a lot less fun to play IMO. Total Annihilation and successors were a lot more fun, and a big part of that was not having arbitrary unit caps in a way that affected gameplay; expanding the limit from 500 to 1500 did genuinely make the game more fun.</div><br/><div id="40175794" class="c"><input type="checkbox" id="c-40175794" checked=""/><div class="controls bullet"><span class="by">foolfoolz</span><span>|</span><a href="#40172747">root</a><span>|</span><a href="#40175627">parent</a><span>|</span><a href="#40176095">next</a><span>|</span><label class="collapse" for="c-40175794">[-]</label><label class="expand" for="c-40175794">[1 more]</label></div><br/><div class="children"><div class="content">supreme commanders very high unit cap leads to crazy end games. it allows your economy to grow exponentially for the entire game. which has a big impact on late game strategy</div><br/></div></div><div id="40176095" class="c"><input type="checkbox" id="c-40176095" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40172747">root</a><span>|</span><a href="#40175627">parent</a><span>|</span><a href="#40175794">prev</a><span>|</span><a href="#40177381">next</a><span>|</span><label class="collapse" for="c-40176095">[-]</label><label class="expand" for="c-40176095">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Truly exponential economy makes late-game Total Annihilation&#x2F;Supreme Commander&#x2F;Beyond All Reason far more fun than Starcraft.<p>Starcraft late-game is hoarding resources and running out your opponent&#x27;s patience while looking for a slip up.</div><br/></div></div></div></div><div id="40177381" class="c"><input type="checkbox" id="c-40177381" checked=""/><div class="controls bullet"><span class="by">alimnes</span><span>|</span><a href="#40172747">parent</a><span>|</span><a href="#40175627">prev</a><span>|</span><a href="#40175139">next</a><span>|</span><label class="collapse" for="c-40177381">[-]</label><label class="expand" for="c-40177381">[1 more]</label></div><br/><div class="children"><div class="content">Many people are choosing Rust because they want to use Rust. Rust has the reputation being &quot;the best&quot; programming language: Fast, safe, reliable, modern. I can rely on that very much. Who wouldn&#x27;t like the feeling of using the best tech for their project.<p>What many overlook is that using Rust has very high costs, but the edge over alternative languages is often only marginally - depending on the use case of course.<p>Those costs of Rust get in the way of developing the actual product. You loose speed, efficiency, but potentially gain no benefit to the users of your product.</div><br/></div></div><div id="40175139" class="c"><input type="checkbox" id="c-40175139" checked=""/><div class="controls bullet"><span class="by">Aerroon</span><span>|</span><a href="#40172747">parent</a><span>|</span><a href="#40177381">prev</a><span>|</span><a href="#40173393">next</a><span>|</span><label class="collapse" for="c-40175139">[-]</label><label class="expand" for="c-40175139">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>but few games will actually leverage this effectively for fun gameplay</i><p>In my opinion this is a result of big mobs having poor performance. When players get to choose they seem to like having more mobs thrown at them.<p>This can also be limiting for interactable objects.</div><br/></div></div></div></div><div id="40173393" class="c"><input type="checkbox" id="c-40173393" checked=""/><div class="controls bullet"><span class="by">modernerd</span><span>|</span><a href="#40172747">prev</a><span>|</span><a href="#40172473">next</a><span>|</span><label class="collapse" for="c-40173393">[-]</label><label class="expand" for="c-40173393">[3 more]</label></div><br/><div class="children"><div class="content">Allan Blomquist&#x27;s tooling demo they mention is incredible, go watch it:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=72y2EC5fkcE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=72y2EC5fkcE</a><p>Really sells the value of having a tight developer feedback loop: it shows hot reloading for code and graphics, a reversible debugger, live profiling with flame graphs, a data inspector with data breakpoints, time travel inspection with a scrub bar, session sharing and replay with the same scrub bar and direct links from the call stack to a breakpoint, and more.<p>Above the many niggles they had with Rust itself, this greatly helps me understand why Rust left them wanting more from their working environment. They say they&#x27;ve switched back to Unity with <a href="https:&#x2F;&#x2F;hotreload.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hotreload.net&#x2F;</a> to try to capture some of that, and now I see why. (It&#x27;s a shame that hot reloading tooling in Rust wasn&#x27;t ready for them yet, but I see why they&#x27;ve moved on instead of waiting&#x2F;contributing.)</div><br/><div id="40175487" class="c"><input type="checkbox" id="c-40175487" checked=""/><div class="controls bullet"><span class="by">darkteflon</span><span>|</span><a href="#40173393">parent</a><span>|</span><a href="#40172473">next</a><span>|</span><label class="collapse" for="c-40175487">[-]</label><label class="expand" for="c-40175487">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, this is the bit that stood out for me, too.<p>Does anyone knowledgeable here have a sense for whether there are any insurmountable roadblocks to bringing hot reload to Godot?</div><br/><div id="40176561" class="c"><input type="checkbox" id="c-40176561" checked=""/><div class="controls bullet"><span class="by">throwawee</span><span>|</span><a href="#40173393">root</a><span>|</span><a href="#40175487">parent</a><span>|</span><a href="#40172473">next</a><span>|</span><label class="collapse" for="c-40176561">[-]</label><label class="expand" for="c-40176561">[1 more]</label></div><br/><div class="children"><div class="content">Godot 4 already has hot reloading.</div><br/></div></div></div></div></div></div><div id="40172473" class="c"><input type="checkbox" id="c-40172473" checked=""/><div class="controls bullet"><span class="by">bdw5204</span><span>|</span><a href="#40173393">prev</a><span>|</span><a href="#40172704">next</a><span>|</span><label class="collapse" for="c-40172473">[-]</label><label class="expand" for="c-40172473">[28 more]</label></div><br/><div class="children"><div class="content">My impression of Rust is that it&#x27;s a very opinionated language that wants everybody to program in a specific way that emphasizes memory safety above everything. That&#x27;s a good idea, I think, for the systems programming use cases that it was intended for. I don&#x27;t see that as a particularly useful thing to value for game development. The part in the article about the Rust borrow checker constantly forcing refactors sounds extremely obnoxious to deal with.<p>I&#x27;d think that an ideal game dev language would be programmer time efficient, reasonably performant and designed for skilled programmers who can handle a language filled with footguns. Basically a better version of C such as a selective subset of C++ or a Golang without garbage collection. I just don&#x27;t think the kinds of security bugs you get from C&#x2F;C++ &quot;unsafe&quot; code are that big of a deal for games but they would be for a web site or an enterprise database.</div><br/><div id="40178372" class="c"><input type="checkbox" id="c-40178372" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#40172473">parent</a><span>|</span><a href="#40172934">next</a><span>|</span><label class="collapse" for="c-40178372">[-]</label><label class="expand" for="c-40178372">[1 more]</label></div><br/><div class="children"><div class="content">Most modern languages are memory safe and they don&#x27;t get called out for emphasizing that or being opinionated. I think with Rust that attention results from its choice of memory management model which gets in the way a lot in ways described in the article.</div><br/></div></div><div id="40172934" class="c"><input type="checkbox" id="c-40172934" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40172473">parent</a><span>|</span><a href="#40178372">prev</a><span>|</span><a href="#40172504">next</a><span>|</span><label class="collapse" for="c-40172934">[-]</label><label class="expand" for="c-40172934">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I just don&#x27;t think the kinds of security bugs you get from C&#x2F;C++ &quot;unsafe&quot; code are that big of a deal for games but they would be for a web site or an enterprise database.<p>Even for database engines specifically, modern C++ is essentially as safe as Rust and significantly more ergonomic. Rust&#x27;s safety features can&#x27;t reason about the case when all of your runtime objects live in explicitly paged memory with indefinite lifetimes and no fixed memory address, which is the norm in database kernels. You have to write the same code to make handling these objects safe and correct in Rust that you have to write in C++. You can&#x27;t use normal pointers and allocators for this even if you wanted to.<p>Rust&#x27;s safety is designed more for normal dynamic memory applications.</div><br/><div id="40174051" class="c"><input type="checkbox" id="c-40174051" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40172934">parent</a><span>|</span><a href="#40172504">next</a><span>|</span><label class="collapse" for="c-40174051">[-]</label><label class="expand" for="c-40174051">[5 more]</label></div><br/><div class="children"><div class="content">&gt; modern C++ is essentially as safe as Rust<p>This isn&#x27;t even close to being true. I think memory safety isn&#x27;t as important for games as it is for most software (though it is still quite important for multiplayer games!). But even if you write the most modern C++ possible I guarantee you are going to spend some of your time debugging segfaults, memory corruption and heisenbugs. Don&#x27;t try and claim &quot;I don&#x27;t write bugs&quot;. Everyone does.</div><br/><div id="40174822" class="c"><input type="checkbox" id="c-40174822" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40174051">parent</a><span>|</span><a href="#40175307">next</a><span>|</span><label class="collapse" for="c-40174822">[-]</label><label class="expand" for="c-40174822">[3 more]</label></div><br/><div class="children"><div class="content">That assertion was specifically qualified in the context of database engines, for which it is true. I definitely write bugs but I haven&#x27;t seen a segfault or memory corruption in years. That is more of a C thing than a C++ thing.<p>It is kind of difficult to have a segfault or memory corruption with explicitly paged object memory, since there can&#x27;t be any pointers and these complex objects are bound-checked at compile-time. If you care about performance and scalability, you don&#x27;t need to concern yourself with multi-threading as an issue either. The main way you&#x27;d expect to see memory corruption is if you try to read&#x2F;write a page in the middle of a DMA operation to the same memory, and Rust doesn&#x27;t help you with that either (though this would be just a normal logic bug in the scheduler).<p>It is pretty easy to avoid segfaults and memory corruption in modern C++ if the software architecture doesn&#x27;t allow you to create the conditions under which those are likely to occur.</div><br/><div id="40178050" class="c"><input type="checkbox" id="c-40178050" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40174822">parent</a><span>|</span><a href="#40175307">next</a><span>|</span><label class="collapse" for="c-40178050">[-]</label><label class="expand" for="c-40178050">[2 more]</label></div><br/><div class="children"><div class="content">So you&#x27;re saying if you write your database engine in C++ you&#x27;re not going to see any segfaults?<p><a href="https:&#x2F;&#x2F;jira.mariadb.org&#x2F;browse&#x2F;MDEV-14248?jql=text%20~%20%22segfault%22" rel="nofollow">https:&#x2F;&#x2F;jira.mariadb.org&#x2F;browse&#x2F;MDEV-14248?jql=text%20~%20%2...</a></div><br/><div id="40178212" class="c"><input type="checkbox" id="c-40178212" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40178050">parent</a><span>|</span><a href="#40175307">next</a><span>|</span><label class="collapse" for="c-40178212">[-]</label><label class="expand" for="c-40178212">[1 more]</label></div><br/><div class="children"><div class="content">No, they&#x27;re saying that you will still see segfaults if you write it in Rust, because Rust&#x27;s borrow checker is unusable in that environment.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40172504" class="c"><input type="checkbox" id="c-40172504" checked=""/><div class="controls bullet"><span class="by">baby</span><span>|</span><a href="#40172473">parent</a><span>|</span><a href="#40172934">prev</a><span>|</span><a href="#40172837">next</a><span>|</span><label class="collapse" for="c-40172504">[-]</label><label class="expand" for="c-40172504">[6 more]</label></div><br/><div class="children"><div class="content">IMO it’s not opinionated enough. Golang for example doesn’t let you customize go fmt, while Rust does. Rust also has many ways to do things in general (mod.rs vs name_of_folder.rs for example) and seems to not want to provide a useful baseline for most projects via its standard library (unlike Golang).<p>But to go back to our subject: Rust is a great language and that’s all you need. I wish I could use it with unity.</div><br/><div id="40173246" class="c"><input type="checkbox" id="c-40173246" checked=""/><div class="controls bullet"><span class="by">tick_tock_tick</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40172504">parent</a><span>|</span><a href="#40175430">next</a><span>|</span><label class="collapse" for="c-40173246">[-]</label><label class="expand" for="c-40173246">[4 more]</label></div><br/><div class="children"><div class="content">The mod vs folder rs stuff is just embarrassing for Rust. I have no idea why they support more then 1 method.</div><br/><div id="40176219" class="c"><input type="checkbox" id="c-40176219" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40173246">parent</a><span>|</span><a href="#40176411">next</a><span>|</span><label class="collapse" for="c-40176219">[-]</label><label class="expand" for="c-40176219">[2 more]</label></div><br/><div class="children"><div class="content">The do it because the first one sucked ass and the second is a huge improvement but you still have to support the old way.</div><br/><div id="40176889" class="c"><input type="checkbox" id="c-40176889" checked=""/><div class="controls bullet"><span class="by">sullyj3</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40176219">parent</a><span>|</span><a href="#40176411">next</a><span>|</span><label class="collapse" for="c-40176889">[-]</label><label class="expand" for="c-40176889">[1 more]</label></div><br/><div class="children"><div class="content">Which is which and why?</div><br/></div></div></div></div><div id="40176411" class="c"><input type="checkbox" id="c-40176411" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40173246">parent</a><span>|</span><a href="#40176219">prev</a><span>|</span><a href="#40175430">next</a><span>|</span><label class="collapse" for="c-40176411">[-]</label><label class="expand" for="c-40176411">[1 more]</label></div><br/><div class="children"><div class="content">I speculate that they wanted to support just `mod.rs`, but because VS Code became the editor for rust people hated seeing all tabs named `mod.rs`.</div><br/></div></div></div></div><div id="40175430" class="c"><input type="checkbox" id="c-40175430" checked=""/><div class="controls bullet"><span class="by">eYrKEC2</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40172504">parent</a><span>|</span><a href="#40173246">prev</a><span>|</span><a href="#40172837">next</a><span>|</span><label class="collapse" for="c-40175430">[-]</label><label class="expand" for="c-40175430">[1 more]</label></div><br/><div class="children"><div class="content">Golang is indeed much more opinionated.  To quote @bcantril, &quot;Go is like steampunk for programming.&quot;</div><br/></div></div></div></div><div id="40172837" class="c"><input type="checkbox" id="c-40172837" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40172473">parent</a><span>|</span><a href="#40172504">prev</a><span>|</span><a href="#40174335">next</a><span>|</span><label class="collapse" for="c-40172837">[-]</label><label class="expand" for="c-40172837">[5 more]</label></div><br/><div class="children"><div class="content">&gt; My impression of Rust is that it&#x27;s a very opinionated language<p>It&#x27;s not though. There&#x27;s only one thing Rust is opinionated about.<p>&gt; that wants everybody to program in a specific way that emphasizes memory safety above everything.<p>Well yes, that is literally the core proposition and purpose of the language. That&#x27;s like saying java is opinionated because it wants to manage the memory.<p>&gt; I just don&#x27;t think the kinds of security bugs you get from C&#x2F;C++ &quot;unsafe&quot; code are that big of a deal for games<p>As soon as games are networked it starts being a problem, and these days non-networked games are pretty rare.</div><br/><div id="40173672" class="c"><input type="checkbox" id="c-40173672" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40172837">parent</a><span>|</span><a href="#40175730">next</a><span>|</span><label class="collapse" for="c-40173672">[-]</label><label class="expand" for="c-40173672">[3 more]</label></div><br/><div class="children"><div class="content">Rust also is opinionated that you don&#x27;t want to write shared libraries or plugins.  You can do both, but only if you drop down to memory unsafe C interfaces. The default is statically compile all applications into one program. Rust also really wants you do to use their build system and package manager, you can avoid both but everything will fight you.</div><br/><div id="40174538" class="c"><input type="checkbox" id="c-40174538" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40173672">parent</a><span>|</span><a href="#40175730">next</a><span>|</span><label class="collapse" for="c-40174538">[-]</label><label class="expand" for="c-40174538">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rust also is opinionated that you don&#x27;t want to write shared libraries or plugins.<p>Not having a solution is not the same as having an opinion.<p>If you have years to spend on plugging at ABI stabilisation, generics and proc macros in dynamic linking, and redistributable std, I’m sure the core devs would be happy for you to.<p>&gt; Rust also really wants you do to use their build system and package manager, you can avoid both but everything will fight you.<p>What do you mean everything will fight you? It sounds like you’re confusing rust and its ecosystem.</div><br/><div id="40175434" class="c"><input type="checkbox" id="c-40175434" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40174538">parent</a><span>|</span><a href="#40175730">next</a><span>|</span><label class="collapse" for="c-40175434">[-]</label><label class="expand" for="c-40175434">[1 more]</label></div><br/><div class="children"><div class="content">A language is in large part the ecosystem. If I can&#x27;t use the expected ecosystem I can&#x27;t search for answers.</div><br/></div></div></div></div></div></div><div id="40175730" class="c"><input type="checkbox" id="c-40175730" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40172837">parent</a><span>|</span><a href="#40173672">prev</a><span>|</span><a href="#40174335">next</a><span>|</span><label class="collapse" for="c-40175730">[-]</label><label class="expand" for="c-40175730">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As soon as games are networked it starts being a problem, and these days non-networked games are pretty rare.<p>So have your network protocol parser in Rust and the entire rest of your game in whatever the hell you want.<p>All the practical safety you could desire without any language constraints for the other 99% of the code</div><br/></div></div></div></div><div id="40174335" class="c"><input type="checkbox" id="c-40174335" checked=""/><div class="controls bullet"><span class="by">alcover</span><span>|</span><a href="#40172473">parent</a><span>|</span><a href="#40172837">prev</a><span>|</span><a href="#40173602">next</a><span>|</span><label class="collapse" for="c-40174335">[-]</label><label class="expand" for="c-40174335">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; I&#x27;d think that an ideal game dev language would be programmer time efficient, reasonably performant and designed for skilled programmers who can handle a language filled with footguns. Basically a better version of C such as a selective subset of C++ or a Golang without garbage collection.
</code></pre>
I agree so much that I&#x27;ve been working on this for a whole year.<p>There is a sweet spot : non-GC, with pointers (but bounded), inference, basic OOP + tacking, and all the comforts of scripts. All in a <i>good</i> looking syntax without semi-colons.<p>So you can program fast and get a fast program.</div><br/><div id="40176301" class="c"><input type="checkbox" id="c-40176301" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40174335">parent</a><span>|</span><a href="#40175243">next</a><span>|</span><label class="collapse" for="c-40176301">[-]</label><label class="expand" for="c-40176301">[1 more]</label></div><br/><div class="children"><div class="content">Seeing presence&#x2F;absence of semicolons in the list of primary features makes me wary.<p>And it takes a lot of people to make good tooling.</div><br/></div></div><div id="40175243" class="c"><input type="checkbox" id="c-40175243" checked=""/><div class="controls bullet"><span class="by">jpardy</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40174335">parent</a><span>|</span><a href="#40176301">prev</a><span>|</span><a href="#40173602">next</a><span>|</span><label class="collapse" for="c-40175243">[-]</label><label class="expand" for="c-40175243">[1 more]</label></div><br/><div class="children"><div class="content">For me, this is Odin-Lang, it doesn&#x27;t meet all the requirements you have listed, but it&#x27;s ergonomic, fast, and comes with extensive core and vendor libraries. It&#x27;s all just fun and reasonable.<p><a href="https:&#x2F;&#x2F;odin-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;odin-lang.org&#x2F;</a></div><br/></div></div></div></div><div id="40173602" class="c"><input type="checkbox" id="c-40173602" checked=""/><div class="controls bullet"><span class="by">dario_od</span><span>|</span><a href="#40172473">parent</a><span>|</span><a href="#40174335">prev</a><span>|</span><a href="#40174027">next</a><span>|</span><label class="collapse" for="c-40173602">[-]</label><label class="expand" for="c-40173602">[5 more]</label></div><br/><div class="children"><div class="content">You more or less described Zig</div><br/><div id="40174014" class="c"><input type="checkbox" id="c-40174014" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40173602">parent</a><span>|</span><a href="#40174027">next</a><span>|</span><label class="collapse" for="c-40174014">[-]</label><label class="expand" for="c-40174014">[4 more]</label></div><br/><div class="children"><div class="content">Sort of, although Zig certainly pushes itself towards the embedded world.  I have tried Zig a bit and like it a lot, and I am sure it would be better for game dev than Rust, but I don&#x27;t want to pass allocators around all day to all the objects in my game.<p>Go without GC is more like a Go and Zig baby.</div><br/><div id="40174399" class="c"><input type="checkbox" id="c-40174399" checked=""/><div class="controls bullet"><span class="by">mholub</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40174014">parent</a><span>|</span><a href="#40177046">next</a><span>|</span><label class="collapse" for="c-40174399">[-]</label><label class="expand" for="c-40174399">[2 more]</label></div><br/><div class="children"><div class="content">nothing really prevents you from defining global allocator in Zig<p>and having explicit allocator in standard library is actually a good thing, cause it&#x27;s quite a common case in game development to use arena allocators which are being freed once per frame - so you don&#x27;t really need to reinvent your data structures in Zig<p>I do have some concerns about Zig because it also introduces some friction for correctness sake like requiring to always use all variables, explicit casts everywhere - I want some compiler toggle to disable all of that and focus on problem but unfortunately it&#x27;s not there<p>I am playing with Zig now and haven&#x27;t really formed my opinion about game development specifically but I like it a lot so far</div><br/><div id="40175094" class="c"><input type="checkbox" id="c-40175094" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40174399">parent</a><span>|</span><a href="#40177046">next</a><span>|</span><label class="collapse" for="c-40175094">[-]</label><label class="expand" for="c-40175094">[1 more]</label></div><br/><div class="children"><div class="content">To be fair though that sort of friction only affects things <i>in the small</i>.  They can be annoying but you&#x27;ll never have to refactor outside the scope of the friction itself.<p>In practice, it&#x27;s only really a problem if you&#x27;re doing codegen.</div><br/></div></div></div></div><div id="40177046" class="c"><input type="checkbox" id="c-40177046" checked=""/><div class="controls bullet"><span class="by">thegeekpirate</span><span>|</span><a href="#40172473">root</a><span>|</span><a href="#40174014">parent</a><span>|</span><a href="#40174399">prev</a><span>|</span><a href="#40174027">next</a><span>|</span><label class="collapse" for="c-40177046">[-]</label><label class="expand" for="c-40177046">[1 more]</label></div><br/><div class="children"><div class="content">Odin is almost precisely that, and has many useful gamedev features and bindings.</div><br/></div></div></div></div></div></div></div></div><div id="40172704" class="c"><input type="checkbox" id="c-40172704" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#40172473">prev</a><span>|</span><a href="#40172864">next</a><span>|</span><label class="collapse" for="c-40172704">[-]</label><label class="expand" for="c-40172704">[19 more]</label></div><br/><div class="children"><div class="content">Starting by saying I fundamentally agree wrt iteration speed. This is ultimately why [C&#x2F;C++]&#x2F;Lua was such a thing for a while, and it seems quite plausible that you could benefit from a core engine in rust bound to a scripting language.<p>But ultimately I sense the subtext here is much the same as with other Rust problems: the object oriented baby has been thrown out with the bathwater, often in the name of premature optimisation, but also with a sense of misplaced religious purity regarding the evils of state and the merits of functional programming. There never was any OOP law that your inheritance hierarchy had to be insane, or that you had to create classes for absolutely every last thing. Now we have people hitting the opposite extreme where everything has to go through the same function switched on a pattern matched enum. One of the core problems with Rust is it lacks the mechanisms to allow moving adequately out of this tarpit.<p>I still think Rust might have a place at the lowest level core where it is all about shuffling arrays of things through compute units, but for the higher level pieces it is clearly the wrong thing to be using.</div><br/><div id="40173282" class="c"><input type="checkbox" id="c-40173282" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40172704">parent</a><span>|</span><a href="#40173638">next</a><span>|</span><label class="collapse" for="c-40173282">[-]</label><label class="expand" for="c-40173282">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; but also with a sense of misplaced religious purity regarding the evils of state</i><p>To clarify, Rust isn&#x27;t against state at all. Rust bends over backwards to make mutation possible, when it would have been far easier (and slower, and less usable) to have a fully-immutable language. What Rust is against is global mutable state, and an aversion to global mutable state isn&#x27;t a religious position, it&#x27;s a pragmatic position, because global mutable state makes concurrency (and reasoning about your code in general) completely intractable.</div><br/><div id="40173420" class="c"><input type="checkbox" id="c-40173420" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40173282">parent</a><span>|</span><a href="#40173980">next</a><span>|</span><label class="collapse" for="c-40173420">[-]</label><label class="expand" for="c-40173420">[1 more]</label></div><br/><div class="children"><div class="content">1000%, and this is something gamedevs (and, for quite some time, webdevs) are guilty of in the name of speed for quite some time.  In both web and game dev, it&#x27;s come back to bite when it&#x27;s time to debug.<p>Concurrency is hard, and anything with a ton of user interaction or communication across multiple parties induces concurrency (never block the main thread and all).</div><br/></div></div></div></div><div id="40173638" class="c"><input type="checkbox" id="c-40173638" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#40172704">parent</a><span>|</span><a href="#40173282">prev</a><span>|</span><a href="#40173794">next</a><span>|</span><label class="collapse" for="c-40173638">[-]</label><label class="expand" for="c-40173638">[2 more]</label></div><br/><div class="children"><div class="content">YMMV, but I find C# and TypeScript to have a &quot;Goldilocks&quot; mix of OOP and FP that you can take advantage of the strengths of each where it makes sense.</div><br/><div id="40174532" class="c"><input type="checkbox" id="c-40174532" checked=""/><div class="controls bullet"><span class="by">d13</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40173638">parent</a><span>|</span><a href="#40173794">next</a><span>|</span><label class="collapse" for="c-40174532">[-]</label><label class="expand" for="c-40174532">[1 more]</label></div><br/><div class="children"><div class="content">You’re absolutely right, they are incredibly pragmatic.</div><br/></div></div></div></div><div id="40173794" class="c"><input type="checkbox" id="c-40173794" checked=""/><div class="controls bullet"><span class="by">MerrimanInd</span><span>|</span><a href="#40172704">parent</a><span>|</span><a href="#40173638">prev</a><span>|</span><a href="#40173821">next</a><span>|</span><label class="collapse" for="c-40173794">[-]</label><label class="expand" for="c-40173794">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been playing around with an idea about OOP for awhile, not sure if it&#x27;ll ring true or not but I&#x27;ll run it up the flagpole for feedback.<p>I think FP is a great way to program actions and agency but OOP is a great way to model the world. I like Rust&#x27;s trait system because the polymorphism is based on what you want an object to <i>do</i> not what it <i>is</i>. But when you&#x27;re creating models of the world it&#x27;s usually really convenient and even accurate to use nested inheritance models. Maybe the original system for this is the flora&#x2F;fauna taxonomy but it applies to a lot of things; like GUI elements or game models.<p>If this is correct, it might explain why the discourse is so polarized. Whether OOP is a blessing or a curse probably depends on whether you&#x27;re using a programming language as a modelling language or as a logic&#x2F;execution language.</div><br/><div id="40174137" class="c"><input type="checkbox" id="c-40174137" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40173794">parent</a><span>|</span><a href="#40175287">next</a><span>|</span><label class="collapse" for="c-40174137">[-]</label><label class="expand" for="c-40174137">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not hard&#x2F;fast but I would tend to agree with an approximation of this.<p>Back when I worked properly on big games the UI libs would often be trees of widgets with injectable functions for modifying the rendering, which is actually one of the points in this blog the writer would like. (The UI lib of classic Sims was exactly like that). These days the stuff I&#x27;ve done, although entirely in JS, at <a href="https:&#x2F;&#x2F;luduxia.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;luduxia.com&#x2F;</a> follows that pattern for the 3D components at least. The world is defined in an almost classic scene graph and then behaviour is added by attaching functions to pieces, which can be composed functionally.<p>Much of the anti-OOP noise is the result of people that have suffered from others creating hierarchies of the world too literally. Quite why it proves so difficult for developers to slow down and think about the right course of action is beyond me. They&#x27;re also staggeringly resistant to changing afterwards.</div><br/><div id="40177329" class="c"><input type="checkbox" id="c-40177329" checked=""/><div class="controls bullet"><span class="by">MerrimanInd</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40174137">parent</a><span>|</span><a href="#40175287">next</a><span>|</span><label class="collapse" for="c-40177329">[-]</label><label class="expand" for="c-40177329">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Much of the anti-OOP noise is the result of people that have suffered from others creating hierarchies of the world too literally.<p>I think one of the problems is that a heirarchy is inherently opinionated. You have to choose the criteria around how to group the objects&#x2F;nodes in your graph and that criteria is context-dependent. The example I&#x27;ve used with animal taxonomy is grouping your objects via things you can eat vs things you can pat. Thsoe are two very different graph structures of the same group of objects and if you started with one then realized you need to change, how you use your objects you&#x27;re gonna have a bad time. Multiple inheritance is the bandaid solution that usually comes with more hassle than it&#x27;s worth.<p>Building a UI is a good example of a heirarchical structure where you know <i>exactly</i> how you want to use your objects and how they&#x27;ll relate to each other, Not having access to that programming structure would be frustrating and just feel like a loss. But I&#x27;ve also done multiple large refactors of Python projects because I relied on OO inheritance models that turned out to not be quite the right implementation. In those situations, Rust traits are a breath of fresh air for offering the right kind of polymorphism.</div><br/></div></div></div></div><div id="40175287" class="c"><input type="checkbox" id="c-40175287" checked=""/><div class="controls bullet"><span class="by">beders</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40173794">parent</a><span>|</span><a href="#40174137">prev</a><span>|</span><a href="#40173821">next</a><span>|</span><label class="collapse" for="c-40175287">[-]</label><label class="expand" for="c-40175287">[4 more]</label></div><br/><div class="children"><div class="content">I shall recommend this talk for you 
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rX0ItVEVjHc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rX0ItVEVjHc</a></div><br/><div id="40177253" class="c"><input type="checkbox" id="c-40177253" checked=""/><div class="controls bullet"><span class="by">MerrimanInd</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40175287">parent</a><span>|</span><a href="#40177143">next</a><span>|</span><label class="collapse" for="c-40177253">[-]</label><label class="expand" for="c-40177253">[1 more]</label></div><br/><div class="children"><div class="content">I love a long, deep-dive, nerdy talk like this! I&#x27;ll check it out, thanks.</div><br/></div></div><div id="40177143" class="c"><input type="checkbox" id="c-40177143" checked=""/><div class="controls bullet"><span class="by">richrichie</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40175287">parent</a><span>|</span><a href="#40177253">prev</a><span>|</span><a href="#40173821">next</a><span>|</span><label class="collapse" for="c-40177143">[-]</label><label class="expand" for="c-40177143">[2 more]</label></div><br/><div class="children"><div class="content">Funny how at the end of the talk a senior looking guy asks him, “Why not just use C?” and the speaker basically admits that that would be his choice but for “cultural” reasons.</div><br/><div id="40178086" class="c"><input type="checkbox" id="c-40178086" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40177143">parent</a><span>|</span><a href="#40173821">next</a><span>|</span><label class="collapse" for="c-40178086">[-]</label><label class="expand" for="c-40178086">[1 more]</label></div><br/><div class="children"><div class="content">And then he went to work for Unity on HPC#, the C# Burst compiler toolchain.</div><br/></div></div></div></div></div></div></div></div><div id="40173821" class="c"><input type="checkbox" id="c-40173821" checked=""/><div class="controls bullet"><span class="by">tomtheelder</span><span>|</span><a href="#40172704">parent</a><span>|</span><a href="#40173794">prev</a><span>|</span><a href="#40173074">next</a><span>|</span><label class="collapse" for="c-40173821">[-]</label><label class="expand" for="c-40173821">[3 more]</label></div><br/><div class="children"><div class="content">Absolutely agree. I think people saw that a lot of games are written in C++ and got confused into thinking that the right thing to do is to build your entire game in a systems language. The fact that we have games written entirely in C++ is mostly just due to the enormous amount of inertia that game engines have, and the fact that many of them have origins that go back decades to a time when the programming language landscape and broader development ecosystem were completely different.<p>And now, the most popular generally available game engines right now are:
Unity - C++ in the engine, C# for game code
Godot - C++ in the engine code, GDScript or C# for game code
Unreal - C++ in the engine code, somewhat mangled C++ for game code BUT with also one of the most capable and widely used visual programming setups I have ever seen<p>I wouldn&#x27;t be surprised if the &quot;next great game engine&quot; had a Rust core and some other language- I mean why not C# at this point?- for game code.</div><br/><div id="40176480" class="c"><input type="checkbox" id="c-40176480" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40173821">parent</a><span>|</span><a href="#40173074">next</a><span>|</span><label class="collapse" for="c-40176480">[-]</label><label class="expand" for="c-40176480">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I wouldn&#x27;t be surprised if the &quot;next great game engine&quot; had a Rust core and some other language- I mean why not C# at this point?- for game code.<p>That&#x27;s why, the first time I saw Bevy and Amathyst, I had an immediate &quot;they&#x27;re doing it wront$ reaction. IMHO, to be a true game engine in the modern sense, instead of merely a game framework, your engine needs to be a precompiled, standalone executable in a systems language that picks up, loads, and executes game scripts, data files, and assets that are totally separate from the engine itself and written in higher level languages. You don&#x27;t want to be writing everything in a rigid systems language and <i>especially</i> don&#x27;t want to have to compile your game logic and your engine together and then link them as if the engine were a library. That&#x27;s why I&#x27;m (very slowly) feeling out what a proper game engine in Rust might be like with <a href="https:&#x2F;&#x2F;github.com&#x2F;alexispurslane&#x2F;embryo-engine">https:&#x2F;&#x2F;github.com&#x2F;alexispurslane&#x2F;embryo-engine</a>. It will take me some time, since I have to learn real time computer graphics and a lot about game engines, but I&#x27;ve got the books, I&#x27;ve made a lot of progress in learning them, and the engine design and architecture is coming together very well in my big black notebook, so if you&#x27;re interested, give the repo a watch ;)<p>I&#x27;m debating between embeddable common lisp (to satisfy my hacker impulses) or C# for the scripting language. I have figured out, I think, how I&#x27;ll embed C# in Rust down to some pretty detailed steps, involving a two stage process, but .NET is so heavy I&#x27;m worried if it&#x27;ll be worth it. I&#x27;d love input!</div><br/><div id="40177240" class="c"><input type="checkbox" id="c-40177240" checked=""/><div class="controls bullet"><span class="by">pshc</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40176480">parent</a><span>|</span><a href="#40173074">next</a><span>|</span><label class="collapse" for="c-40177240">[-]</label><label class="expand" for="c-40177240">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that bifurcation makes practical sense. Have you considered WebAssembly for the game script layer?</div><br/></div></div></div></div></div></div><div id="40173074" class="c"><input type="checkbox" id="c-40173074" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40172704">parent</a><span>|</span><a href="#40173821">prev</a><span>|</span><a href="#40173398">next</a><span>|</span><label class="collapse" for="c-40173074">[-]</label><label class="expand" for="c-40173074">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t the trait system exactly the way out of this tar pit?</div><br/><div id="40174338" class="c"><input type="checkbox" id="c-40174338" checked=""/><div class="controls bullet"><span class="by">fidotron</span><span>|</span><a href="#40172704">root</a><span>|</span><a href="#40173074">parent</a><span>|</span><a href="#40173398">next</a><span>|</span><label class="collapse" for="c-40174338">[-]</label><label class="expand" for="c-40174338">[1 more]</label></div><br/><div class="children"><div class="content">Obviously that is the intention, but the absence of libraries that manage to replicate what people manage fairly easily in other paradigms does show it&#x27;s not sufficient.<p>golang is similar in this regard - it has interfaces and you can compose type structs, but the results become an unwieldy mess unless the developers are staggeringly disciplined, in which case they&#x27;ll have a better time in something else anyway.</div><br/></div></div></div></div><div id="40173398" class="c"><input type="checkbox" id="c-40173398" checked=""/><div class="controls bullet"><span class="by">tormeh</span><span>|</span><a href="#40172704">parent</a><span>|</span><a href="#40173074">prev</a><span>|</span><a href="#40172864">next</a><span>|</span><label class="collapse" for="c-40173398">[-]</label><label class="expand" for="c-40173398">[1 more]</label></div><br/><div class="children"><div class="content">This makes a lot of sense. Wonder if Bevy will add support for GDScript or C# or something. I think it&#x27;s generally opposed in the interest of ensuring the Rust devex is as good as possible, but it&#x27;s coming eventually, I think.</div><br/></div></div></div></div><div id="40172864" class="c"><input type="checkbox" id="c-40172864" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#40172704">prev</a><span>|</span><a href="#40174550">next</a><span>|</span><label class="collapse" for="c-40172864">[-]</label><label class="expand" for="c-40172864">[3 more]</label></div><br/><div class="children"><div class="content">This is a sobering read. Thank you for sharing.<p>This sums it up for me:<p>&gt; Rust as both language and community is so preoccupied with avoiding problems at all cost that it completely loses sight of what matters, delivering an experience that is so good that whatever problems are there aren&#x27;t really important. This doesn&#x27;t mean &quot;ship crap games&quot;, it means focusing on the game being a good game, not on the code being good code.<p>I think this can be easily extrapolated to projects outside of game development as well.<p>User experience is ultimately all that matters. If you&#x27;re in prototyping stages of whatever it is you&#x27;re building, and games spend a lot of time in this phase, then your focus should always be on testing what the user experience will be like, rather than absolute code correctness, maintainability, and everything else that makes a long-term project successful.<p>The fact Rust seemingly can&#x27;t deliver this rapid prototyping workflow should be a large factor when deciding which language to use.<p>I&#x27;ve been using Go as my main language for the better part of a decade now, and I think it strikes the perfect balance of code quality and rapid prototyping. It&#x27;s far from the side of absolute freedom of a language like Python, which becomes a nightmare to work with after the prototyping phase is over (though this might have improved in the past few years), but it&#x27;s also far from languages like Rust, and allows me to be very productive, very quickly, while also being easy to pick up for newcomers. I probably wouldn&#x27;t pick it for GUI or game development either, though, but for things like CLI, network and web tooling, it&#x27;s perfect.</div><br/><div id="40173706" class="c"><input type="checkbox" id="c-40173706" checked=""/><div class="controls bullet"><span class="by">timeon</span><span>|</span><a href="#40172864">parent</a><span>|</span><a href="#40174550">next</a><span>|</span><label class="collapse" for="c-40173706">[-]</label><label class="expand" for="c-40173706">[2 more]</label></div><br/><div class="children"><div class="content">&gt; User experience is ultimately all that matters.<p>It should be but current state of web will show you that it is often not.</div><br/><div id="40177321" class="c"><input type="checkbox" id="c-40177321" checked=""/><div class="controls bullet"><span class="by">dimgl</span><span>|</span><a href="#40172864">root</a><span>|</span><a href="#40173706">parent</a><span>|</span><a href="#40174550">next</a><span>|</span><label class="collapse" for="c-40177321">[-]</label><label class="expand" for="c-40177321">[1 more]</label></div><br/><div class="children"><div class="content">Really? Why web?</div><br/></div></div></div></div></div></div><div id="40174550" class="c"><input type="checkbox" id="c-40174550" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#40172864">prev</a><span>|</span><a href="#40172577">next</a><span>|</span><label class="collapse" for="c-40174550">[-]</label><label class="expand" for="c-40174550">[3 more]</label></div><br/><div class="children"><div class="content">I only skimmed this article, but, despite it being very negative about Rust, I almost 100% <i>agree with it</i>: Rust is a HORRIBLE choice for game dev. I might quibble with how they outline the costs and benefits of some of the design patterns that rust forces you into, for instance I think command lists are actually incredibly useful and perfectly fine as a game development thing and not the huge problem they consider them to be, and generational arenas basically solve any pointer ownership problems in game development in my opinion, but they are right in the main.<p>I know, because I&#x27;ve tried it. Once. I would #never* recommend Rust to game developers, especially not indie ones. In fact I&#x27;d recommend against it strenuously!<p>And this is precisely because Rust is explicitly and knowingly focused on correctness, safety, perfectly clean code, etc at the cost of iteration speed and flexibility and dynamicism, and that&#x27;s bad for designing game mechanics and even just <i>getting a game done</i> — games have an inherently short life span and development cycle, so safety and correctness and code quality don&#x27;t matter a whole lot. It&#x27;s okay if they crash, etc, as long as they work enough to play. It&#x27;s okay if the code is ugly, you probably won&#x27;t be working on it for very long. This is even moreso the case, as the author says, because in writing a game you really want to be able to iterate quickly and just. Do shit as an experiment, even if it&#x27;s temporary, to see how it feels.<p>On the other hand, who I <i>would</i> recommend Rust to is the people writing game <i>engines</i>, where you really will probably be working on that code for years to come, where stability and correctness is pretty important, and so where Rust&#x27;s strengths will really shine — but crucially, even then, I&#x27;d tell them to make it a real engine, not a game framework like Bevy, by adding a highly flexible, dynamic scripting language like Lua or even C#, and a data format for specifying scenes and entities, and an editor. That way you don&#x27;t write your game in Rust at all!</div><br/><div id="40175660" class="c"><input type="checkbox" id="c-40175660" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#40174550">parent</a><span>|</span><a href="#40172577">next</a><span>|</span><label class="collapse" for="c-40175660">[-]</label><label class="expand" for="c-40175660">[2 more]</label></div><br/><div class="children"><div class="content">Quick note: I&#x27;m actually very slowly prototyping something like this here: <a href="https:&#x2F;&#x2F;github.com&#x2F;alexispurslane&#x2F;embryo-engine&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;alexispurslane&#x2F;embryo-engine&#x2F;</a><p>I&#x27;m disabled so I don&#x27;t have a lot of energy to work on it often, but, especially once I nail down the last few design issues, I&#x27;d really love help, or even just a few eyes on the project to encourage me ;)</div><br/><div id="40177732" class="c"><input type="checkbox" id="c-40177732" checked=""/><div class="controls bullet"><span class="by">potwinkle</span><span>|</span><a href="#40174550">root</a><span>|</span><a href="#40175660">parent</a><span>|</span><a href="#40172577">next</a><span>|</span><label class="collapse" for="c-40177732">[-]</label><label class="expand" for="c-40177732">[1 more]</label></div><br/><div class="children"><div class="content">I like it, I read the Design Document. Do you have any game concepts you are building with it? It seems like the kind of project that would be built with a game side-by-side.</div><br/></div></div></div></div></div></div><div id="40172577" class="c"><input type="checkbox" id="c-40172577" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40174550">prev</a><span>|</span><a href="#40176719">next</a><span>|</span><label class="collapse" for="c-40172577">[-]</label><label class="expand" for="c-40172577">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Making a fun &amp; interesting games is about rapid prototyping and iteration, Rust&#x27;s values are everything but that<p>I found this to be true of C after many, many years coding in C. I noticed that the first selection of data layout stayed throughout the life of the code (with a lot of tweaks, additions, etc.). But didn&#x27;t really think that much about it.<p>Until I started writing code in D. It was easy to change the data layout, and I did for experimenting. For example, changing a reference type to a value type, and vice versa. This was easy in D. It&#x27;s just too much work in C, so it didn&#x27;t happen.<p>The reason is simple:<p><pre><code>    p-&gt;b
    v.b
</code></pre>
To switch between a ref and a value type, you&#x27;ve got to search&#x2F;replace the -&gt; into ., and the . into -&gt;, and not disturb the dots and arrows of the other types. When dealing with 100,000 lines of code, this is a non-starter.<p>But with D, both reference and value types are used as:<p><pre><code>    p.b
    v.b
</code></pre>
making it easy to switch between the two, and also switching function parameters from values back and forth with references.</div><br/><div id="40174072" class="c"><input type="checkbox" id="c-40174072" checked=""/><div class="controls bullet"><span class="by">p0nce</span><span>|</span><a href="#40172577">parent</a><span>|</span><a href="#40175696">next</a><span>|</span><label class="collapse" for="c-40174072">[-]</label><label class="expand" for="c-40174072">[2 more]</label></div><br/><div class="children"><div class="content">I agree, and D with the GC lets me prototype quickly. Its type system gets progressively stricter with constraints, for code that survives. I wouldn&#x27;t want all the type system to apply to prototype code or a nascent program.</div><br/><div id="40174263" class="c"><input type="checkbox" id="c-40174263" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40172577">root</a><span>|</span><a href="#40174072">parent</a><span>|</span><a href="#40175696">next</a><span>|</span><label class="collapse" for="c-40174263">[-]</label><label class="expand" for="c-40174263">[1 more]</label></div><br/><div class="children"><div class="content">I tend to add in the constraints only after the code works. Two different parts of my brain.</div><br/></div></div></div></div><div id="40175696" class="c"><input type="checkbox" id="c-40175696" checked=""/><div class="controls bullet"><span class="by">gridspy</span><span>|</span><a href="#40172577">parent</a><span>|</span><a href="#40174072">prev</a><span>|</span><a href="#40172905">next</a><span>|</span><label class="collapse" for="c-40175696">[-]</label><label class="expand" for="c-40175696">[1 more]</label></div><br/><div class="children"><div class="content">The power of attributes and get&#x2F;set in languages like C# is similar. It&#x27;s easy to turn value types into functions. Or to move a value into a subclass and you don&#x27;t need to do a.b.c (moved c into b) because you can add c =&gt; b.c to the a class.</div><br/></div></div><div id="40172905" class="c"><input type="checkbox" id="c-40172905" checked=""/><div class="controls bullet"><span class="by">lylejantzi3rd</span><span>|</span><a href="#40172577">parent</a><span>|</span><a href="#40175696">prev</a><span>|</span><a href="#40174996">next</a><span>|</span><label class="collapse" for="c-40172905">[-]</label><label class="expand" for="c-40172905">[1 more]</label></div><br/><div class="children"><div class="content">You could hack the C compiler!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tsoding&#x2F;tic-tac-toe-auto-deref">https:&#x2F;&#x2F;github.com&#x2F;tsoding&#x2F;tic-tac-toe-auto-deref</a><p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yKI-VOBBFu8" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yKI-VOBBFu8</a></div><br/></div></div><div id="40174996" class="c"><input type="checkbox" id="c-40174996" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#40172577">parent</a><span>|</span><a href="#40172905">prev</a><span>|</span><a href="#40172938">next</a><span>|</span><label class="collapse" for="c-40174996">[-]</label><label class="expand" for="c-40174996">[1 more]</label></div><br/><div class="children"><div class="content">In the same idea in Eiffel in a.b, b can be either a member or a function to allow easy replacement.<p>On the opposite other languages want to have no hidden function call, no hidden pointer dereferencing..</div><br/></div></div><div id="40172938" class="c"><input type="checkbox" id="c-40172938" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#40172577">parent</a><span>|</span><a href="#40174996">prev</a><span>|</span><a href="#40172792">next</a><span>|</span><label class="collapse" for="c-40172938">[-]</label><label class="expand" for="c-40172938">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good example. I actually think dot syntax is really under-utilized sometimes. Although personally, I&#x27;d prefer that if v was a reference&#x2F;pointer to a struct, that v.b simply performs a pointer offset, instead of auto-dereferencing like -&gt;.</div><br/></div></div><div id="40172792" class="c"><input type="checkbox" id="c-40172792" checked=""/><div class="controls bullet"><span class="by">spintin</span><span>|</span><a href="#40172577">parent</a><span>|</span><a href="#40172938">prev</a><span>|</span><a href="#40176719">next</a><span>|</span><label class="collapse" for="c-40172792">[-]</label><label class="expand" for="c-40172792">[1 more]</label></div><br/><div class="children"><div class="content">When ever I watch someone coding C(++) all they do is compile and then add remove * and &amp; or change between -&gt; and . when the compiler complains.<p>Multiply that by all the C(++) coders on the planet and we have lost a billion man hours...</div><br/></div></div></div></div><div id="40176719" class="c"><input type="checkbox" id="c-40176719" checked=""/><div class="controls bullet"><span class="by">pc2g4d</span><span>|</span><a href="#40172577">prev</a><span>|</span><a href="#40173837">next</a><span>|</span><label class="collapse" for="c-40176719">[-]</label><label class="expand" for="c-40176719">[2 more]</label></div><br/><div class="children"><div class="content">When I set out to learn Rust about a decade ago, I chose to write a game - a clone of &quot;Empire&quot; that I call Umpire.<p>It&#x27;s a different task to re-implement an already-designed language rather than designing and implementing at the same time. Nevertheless I have run into a number of the difficulties mentioned in the article, and arrived at my own solutions - foremost passing around global UUIDs rather than actual `&amp;` references, and enforcing existence constraints at runtime.<p>I&#x27;ve experienced the protracted pain of major refactors when assumptions baked into my data model proved false.<p>In some regards these refactors wore some of the shine off of Rust for me as well. BUT I&#x27;m still glad the game is implemented in Rust, exactly because of Rust&#x27;s dual emphasis on safety and performance.<p>The AI I&#x27;m developing requires generation of massive quantities of self-play data. That the engine is as fast as it is helps greatly.<p>Rust&#x27;s strength in ML means my AI training and game code can share important types, ensuring consistency.<p>The effectiveness of Rust for writing CLI tools (mentioned in the article) has lent itself to a number of game-specific command-line interfaces that are of high quality.<p>Rust&#x27;s memory safety became critical once I decided to network the game. I don&#x27;t want `umpired` to be any more exploitable than it needs to be.<p>My constraints have been very different than the OP&#x27;s; obviously it makes sense for their studio given their experience to move away from Rust. But I think Rust still has a place in games.<p>* <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Empire:_Wargame_of_the_Century" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Empire:_Wargame_of_the_Century</a>
* <a href="https:&#x2F;&#x2F;github.com&#x2F;joshhansen&#x2F;Umpire">https:&#x2F;&#x2F;github.com&#x2F;joshhansen&#x2F;Umpire</a></div><br/><div id="40178151" class="c"><input type="checkbox" id="c-40178151" checked=""/><div class="controls bullet"><span class="by">eterevsky</span><span>|</span><a href="#40176719">parent</a><span>|</span><a href="#40173837">next</a><span>|</span><label class="collapse" for="c-40178151">[-]</label><label class="expand" for="c-40178151">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust&#x27;s strength in ML<p>Most of ML frameworks that I know are implemented in Python and C++. I tried looking at ML in Rust a few years ago and didn&#x27;t find anything useful. Has it changed?</div><br/></div></div></div></div><div id="40173837" class="c"><input type="checkbox" id="c-40173837" checked=""/><div class="controls bullet"><span class="by">chaosprint</span><span>|</span><a href="#40176719">prev</a><span>|</span><a href="#40172449">next</a><span>|</span><label class="collapse" for="c-40173837">[-]</label><label class="expand" for="c-40173837">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked on Ambient Engine and now on the Bevy engine. I totally agree with these points, very valuable.<p>I only make some comments from my professional (audio) perspective:<p>We need the highlight author&#x27;s affirmation of cli. Rust&#x27;s tui (ratatui) is great. I used it to make Glicol-cli [1]. If you are a Linux user, you are welcome to test the music production of the code.<p>Speaking of game audio, I actually think rust is perfect for audio. I have also continued to develop Glicol [2] recently, and my recent goal (starting tomorrow) is the bevy_glicol plug-in. I want to solve bevy&#x27;s audio problem on the browser.<p>All in all, even though I&#x27;ve had my share of pain with ecs, I still think rust is very valuable for game and app development, maybe not multiplayer AAA, maybe practical apps.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;glicol&#x2F;glicol-cli">https:&#x2F;&#x2F;github.com&#x2F;glicol&#x2F;glicol-cli</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;chaosprint&#x2F;glicol">https:&#x2F;&#x2F;github.com&#x2F;chaosprint&#x2F;glicol</a></div><br/><div id="40176753" class="c"><input type="checkbox" id="c-40176753" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#40173837">parent</a><span>|</span><a href="#40172449">next</a><span>|</span><label class="collapse" for="c-40176753">[-]</label><label class="expand" for="c-40176753">[1 more]</label></div><br/><div class="children"><div class="content">This looks <i>very</i> cool. Are there more videos of glicol being used live?</div><br/></div></div></div></div><div id="40172449" class="c"><input type="checkbox" id="c-40172449" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#40173837">prev</a><span>|</span><a href="#40173921">next</a><span>|</span><label class="collapse" for="c-40172449">[-]</label><label class="expand" for="c-40172449">[44 more]</label></div><br/><div class="children"><div class="content">As much as I love Rust I sometimes wonder if I&#x27;d be more productive in a simpler language. If I wrote it every day I&#x27;m not sure that would be true, but as a hobbyist coming back to Rust sometimes takes me a bit to get back in the zone. Also, still not a fan of async, as it is woefully incomplete and fairly complicated in some use cases. That said, I just can&#x27;t go back to Go with nil pointers and lack of decent enums&#x2F;ADTs&#x2F;pattern matching either. I long for the &quot;in between&quot; language, but with an amazing 3rd party ecosystem as both Rust&#x2F;Go have.<p>NOTE: I&#x27;m not a game dev</div><br/><div id="40172649" class="c"><input type="checkbox" id="c-40172649" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40172812">next</a><span>|</span><label class="collapse" for="c-40172649">[-]</label><label class="expand" for="c-40172649">[5 more]</label></div><br/><div class="children"><div class="content">Maybe people will make fun of me, but I&#x27;ve been very happy with Kotlin and Dart.
Null-safe, good ergonomics, very fast.<p>I&#x27;ve tried Rust, sometimes play with C, D, Deno&#x2F;TS, Nim, Java (actually I still write lots of it) and even some more cutting-edge stuff, like Unison. While they&#x27;re cool, what I want is a language with really good tooling that gets out of my way without letting me write patently dumb code (like Java lets me use any object without checking for null, when it can be null but the language just doesn&#x27;t give a shit to help me).<p>I use Dart when I want to compile to binary executable or use Flutter, and Kotlin for stuff I think the JVM has more to offer, like a server. The two languages are just a pleasure to use, pretty similar but having completely different ecosystems (which is great, you can use the best one for the job!).</div><br/><div id="40176627" class="c"><input type="checkbox" id="c-40176627" checked=""/><div class="controls bullet"><span class="by">nmfisher</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172649">parent</a><span>|</span><a href="#40172677">next</a><span>|</span><label class="collapse" for="c-40176627">[-]</label><label class="expand" for="c-40176627">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a Flutter package[0] that wraps the Filament 3D renderer, which I used to make a mini game for a Flutter game competition:<p><a href="https:&#x2F;&#x2F;devpost.com&#x2F;software&#x2F;escape-from-heat-island" rel="nofollow">https:&#x2F;&#x2F;devpost.com&#x2F;software&#x2F;escape-from-heat-island</a><p>(Judging is still ongoing and votes would really be appreciated! It would help me to get more resources to work on the underlying package).<p>This was my first ever “game” (tech demo, really), and I’m not a game dev, so take this with a grain of salt - but I do think there’s a lot of potential for Flutter&#x2F;Dart as a game framework. Hot reload makes iterating on game logic very fast, you obviously get the UI toolkit and cross-platform support straight out of the box, and the language itself is (relatively) concise, so it lends itself well to gameplay programming. When you need to get your hands dirty at a lower level, you just drop down to C++ (or whatever engine you can expose via FFI).<p>I think Google believe that Flutter can nab market share from Unity in casual 2D games (hence their official sponsored competition), but I think it has even more potential than that. In fact, I’ve seen at least two game companies (Supercell and another whose name I’ve forgotten) hiring for people to work on embedding the Flutter engine in various platform games.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;nmfisher&#x2F;flutter_filament.git">https:&#x2F;&#x2F;github.com&#x2F;nmfisher&#x2F;flutter_filament.git</a></div><br/></div></div><div id="40172677" class="c"><input type="checkbox" id="c-40172677" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172649">parent</a><span>|</span><a href="#40176627">prev</a><span>|</span><a href="#40173765">next</a><span>|</span><label class="collapse" for="c-40172677">[-]</label><label class="expand" for="c-40172677">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad you found tools&#x2F;languages that work for you. Kotlin felt a little too much like Java to me. If I stuck with a JVM lang. I&#x27;d probably go back to Scala 3, but I just don&#x27;t like the JVM as a user (just sucks too many resources).</div><br/></div></div><div id="40173765" class="c"><input type="checkbox" id="c-40173765" checked=""/><div class="controls bullet"><span class="by">YawningAngel</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172649">parent</a><span>|</span><a href="#40172677">prev</a><span>|</span><a href="#40173251">next</a><span>|</span><label class="collapse" for="c-40173765">[-]</label><label class="expand" for="c-40173765">[1 more]</label></div><br/><div class="children"><div class="content">I like Kotlin but I find the fact that it lacks a good way to detect and handle possible errors very frustrating. If some function can fail on sane-looking input I&#x27;d like to know about it</div><br/></div></div><div id="40173251" class="c"><input type="checkbox" id="c-40173251" checked=""/><div class="controls bullet"><span class="by">ImHereToVote</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172649">parent</a><span>|</span><a href="#40173765">prev</a><span>|</span><a href="#40172812">next</a><span>|</span><label class="collapse" for="c-40173251">[-]</label><label class="expand" for="c-40173251">[1 more]</label></div><br/><div class="children"><div class="content">Flutter sounds so awesome but really want something like OpenGL for it.</div><br/></div></div></div></div><div id="40172812" class="c"><input type="checkbox" id="c-40172812" checked=""/><div class="controls bullet"><span class="by">margorczynski</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40172649">prev</a><span>|</span><a href="#40173119">next</a><span>|</span><label class="collapse" for="c-40172812">[-]</label><label class="expand" for="c-40172812">[12 more]</label></div><br/><div class="children"><div class="content">&gt; I just can&#x27;t go back to Go with nil pointers and lack of decent enums&#x2F;ADTs&#x2F;pattern matching either.<p>Go is simply a badly designed language where the idea of &quot;simplicity&quot; has been maligned and proven bad ideas likes nil&#x2F;null, exceptions and such have been introduced in a seemingly modern language. One would think that decades of Java, Javascript, etc. code blowing up because of this issues would teach someone something but seems that is not always the case.</div><br/><div id="40173483" class="c"><input type="checkbox" id="c-40173483" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172812">parent</a><span>|</span><a href="#40173429">next</a><span>|</span><label class="collapse" for="c-40173483">[-]</label><label class="expand" for="c-40173483">[3 more]</label></div><br/><div class="children"><div class="content">Having worked with Go for about a decade now, I largely agree that nil is a pain in the ass to work with, and the language has largely done nothing to make it better. However, Go (mostly) doesn&#x27;t have exceptions. Ordinary problems are represented by non-nil errors, which are values. Panics exist but really are reserved for exceptional situations (with the number 1 cause being, of course, dereferencing nil).</div><br/><div id="40173661" class="c"><input type="checkbox" id="c-40173661" checked=""/><div class="controls bullet"><span class="by">sidkshatriya</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40173483">parent</a><span>|</span><a href="#40173429">next</a><span>|</span><label class="collapse" for="c-40173661">[-]</label><label class="expand" for="c-40173661">[2 more]</label></div><br/><div class="children"><div class="content">Nil in go is my biggest gripe with the language. Why keep repeating “the billion dollar mistake” in a relatively newly designed language??</div><br/><div id="40174058" class="c"><input type="checkbox" id="c-40174058" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40173661">parent</a><span>|</span><a href="#40173429">next</a><span>|</span><label class="collapse" for="c-40174058">[-]</label><label class="expand" for="c-40174058">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of ways in which Go handles nil better than C handles NULL. At the very least, a panic is better than a segfault. And carefully written code can avoid most kinds of nil panics entirely. So I guess the language&#x27;s authors thought this would be enough to overcome the mistake. But I don&#x27;t think they went far enough. The very limited type system and the lack of nil-safe operators make it not very ergonomic to write and read such &quot;carefully written&quot; code; design decisions in some key parts of the standard library completely undermine the language&#x27;s attempts to minimize nil; and then there&#x27;s the &quot;untyped nil&quot; default value for interfaces, which panics if you just look at it funny.</div><br/></div></div></div></div></div></div><div id="40173429" class="c"><input type="checkbox" id="c-40173429" checked=""/><div class="controls bullet"><span class="by">lagichikool</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172812">parent</a><span>|</span><a href="#40173483">prev</a><span>|</span><a href="#40173049">next</a><span>|</span><label class="collapse" for="c-40173429">[-]</label><label class="expand" for="c-40173429">[2 more]</label></div><br/><div class="children"><div class="content">&quot;code blowing up because of this issues&quot;<p>I ran into these issues all the time with Java, C++, and Python projects.<p>But it&#x27;s just not the experience of running Go in production, which I&#x27;ve been doing for over 10 years now, across many projects with many devs.<p>In practice, nil checks are just not very difficult to include everywhere. And experienced Go programmers don&#x27;t use exceptions (panic&#x2F;recover) almost ever.</div><br/><div id="40176131" class="c"><input type="checkbox" id="c-40176131" checked=""/><div class="controls bullet"><span class="by">margorczynski</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40173429">parent</a><span>|</span><a href="#40173049">next</a><span>|</span><label class="collapse" for="c-40176131">[-]</label><label class="expand" for="c-40176131">[1 more]</label></div><br/><div class="children"><div class="content">What you said is:<p>1) Anecdotal<p>2) Based on faith that someone will not forget to do something instead of a well documented mechanism in the language that could block that from the start<p>Having nil&#x2F;null to handle empty references is simply very bad design and there&#x27;s decades of examples why. The correct way is using a two-value type like Option, Maybe, etc. so that the (possibility) of the value missing is actually encoded in the type system</div><br/></div></div></div></div><div id="40173049" class="c"><input type="checkbox" id="c-40173049" checked=""/><div class="controls bullet"><span class="by">nahnahno</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172812">parent</a><span>|</span><a href="#40173429">prev</a><span>|</span><a href="#40173119">next</a><span>|</span><label class="collapse" for="c-40173049">[-]</label><label class="expand" for="c-40173049">[6 more]</label></div><br/><div class="children"><div class="content">And yet it is incredibly productive. The poster that contrasted engineers with artists got it right I think. Go is an engineer’s language.</div><br/><div id="40174777" class="c"><input type="checkbox" id="c-40174777" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40173049">parent</a><span>|</span><a href="#40173119">next</a><span>|</span><label class="collapse" for="c-40174777">[-]</label><label class="expand" for="c-40174777">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Go is an engineer’s language.<p>No, Ada&#x2F;Spark is an example of a good engineers language. Go is a mediocre effort at best. Rob Pikes defence is that it was designed for junior Googlers who &quot;aren&#x27;t capable of understanding a brilliant language&quot;. Yes that&#x27;s a real quote.</div><br/><div id="40176616" class="c"><input type="checkbox" id="c-40176616" checked=""/><div class="controls bullet"><span class="by">Exuma</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40174777">parent</a><span>|</span><a href="#40177913">next</a><span>|</span><label class="collapse" for="c-40176616">[-]</label><label class="expand" for="c-40176616">[3 more]</label></div><br/><div class="children"><div class="content">What’s a brilliant language in this context</div><br/><div id="40178011" class="c"><input type="checkbox" id="c-40178011" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40176616">parent</a><span>|</span><a href="#40178132">next</a><span>|</span><label class="collapse" for="c-40178011">[-]</label><label class="expand" for="c-40178011">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d have to ask Rob Pike. My own example of a brilliant language is Haskell, but it&#x27;s not without problems.</div><br/></div></div><div id="40178132" class="c"><input type="checkbox" id="c-40178132" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40176616">parent</a><span>|</span><a href="#40178011">prev</a><span>|</span><a href="#40177913">next</a><span>|</span><label class="collapse" for="c-40178132">[-]</label><label class="expand" for="c-40178132">[1 more]</label></div><br/><div class="children"><div class="content">Apparently anything that offers a type system beyond Go&#x27;s.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40173119" class="c"><input type="checkbox" id="c-40173119" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40172812">prev</a><span>|</span><a href="#40172606">next</a><span>|</span><label class="collapse" for="c-40173119">[-]</label><label class="expand" for="c-40173119">[1 more]</label></div><br/><div class="children"><div class="content">OCaml could be that language.<p>I’m not convinced that ecosystem is so important for game dev. Once you have a simple graphics library, bindings to BulletPhyiscs etc most of the code is custom simulation code with no integrations needed.</div><br/></div></div><div id="40172606" class="c"><input type="checkbox" id="c-40172606" checked=""/><div class="controls bullet"><span class="by">Scramblejams</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40173119">prev</a><span>|</span><a href="#40173141">next</a><span>|</span><label class="collapse" for="c-40172606">[-]</label><label class="expand" for="c-40172606">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been hoping to see more languages that compile to Go, it might be the most practical way to arrive at what you want. For example, see Borgo: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36847594">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36847594</a></div><br/><div id="40173283" class="c"><input type="checkbox" id="c-40173283" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172606">parent</a><span>|</span><a href="#40172617">next</a><span>|</span><label class="collapse" for="c-40173283">[-]</label><label class="expand" for="c-40173283">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been hoping to see more languages that compile to Go<p>One could also use Go-Assembler as a cross-platform assembly target: <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;asm" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;asm</a></div><br/></div></div><div id="40172617" class="c"><input type="checkbox" id="c-40172617" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172606">parent</a><span>|</span><a href="#40173283">prev</a><span>|</span><a href="#40173141">next</a><span>|</span><label class="collapse" for="c-40172617">[-]</label><label class="expand" for="c-40172617">[1 more]</label></div><br/><div class="children"><div class="content">I keep toying with the idea of creating one. :-)<p>Borgo looks neat - hadn&#x27;t seen it before.</div><br/></div></div></div></div><div id="40173141" class="c"><input type="checkbox" id="c-40173141" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40172606">prev</a><span>|</span><a href="#40174103">next</a><span>|</span><label class="collapse" for="c-40173141">[-]</label><label class="expand" for="c-40173141">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t occupy the same space, but the simplicity of Gleam has been very enjoyable to me. It&#x27;s still quite a young language though, but worth keeping an eye on.</div><br/></div></div><div id="40174103" class="c"><input type="checkbox" id="c-40174103" checked=""/><div class="controls bullet"><span class="by">notnullorvoid</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40173141">prev</a><span>|</span><a href="#40175710">next</a><span>|</span><label class="collapse" for="c-40174103">[-]</label><label class="expand" for="c-40174103">[1 more]</label></div><br/><div class="children"><div class="content">As much as I dislike many of the legacy issues with JavaScript I find TypeScript to be the best language to iterate with. If Rust had GC without need for wrappers like RC though I think that would be my preferred iteration language. 
 I mostly try to write my TS in a manner that would translate to Rust, but that&#x27;s hard to do sometimes when it comes to memory management.</div><br/></div></div><div id="40175710" class="c"><input type="checkbox" id="c-40175710" checked=""/><div class="controls bullet"><span class="by">110bpm</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40174103">prev</a><span>|</span><a href="#40172468">next</a><span>|</span><label class="collapse" for="c-40175710">[-]</label><label class="expand" for="c-40175710">[2 more]</label></div><br/><div class="children"><div class="content">For me, the closest language currently is F#.<p>The open-source ecosystem is not as massive as Go&#x27;s or the JVM&#x27;s, but it&#x27;s not niche either. F# runs on .NET and works with all .NET packages (C#, F#, ...). If the .NET ecosystem can work out for you, I recommend taking a closer look at F#.<p>F# allows for simple code, which is &quot;functional&quot; by default, but you&#x27;re still free to write imperative, &quot;side-effectful&quot; code, too.<p>I find this pragmatic approach works extremely well in practice. Most of my code ends up in a functional style. However, once projects grow more complex, I might need to place a mutable counter or a logging call in an otherwise pure function. Sometimes, I run into cases where the most straightforward and easy to reason about solution is imperative.<p>If I were confined to what is often described as a &quot;pure functional&quot; approach, I&#x27;d have to refactor, so that these side-effects would be fully represented in the function signature.<p>F# ticks the enums&#x2F;ADTs&#x2F;pattern box but also has its own interesting features like computation expressions [0].
I would describe them as a language extension mechanism that provides a common grammar (let!, do!, ...) that extension writers can target.<p>Because of this, the language doesn&#x27;t have await, async or any other operators for working with async (like C# or TS). There&#x27;s an async {} (and task {}) computation expression which is implemented using open library methods. But nothing is preventing you from rolling your own, or extending the language with other computation expressions.<p>In practice, async code looks like this:<p><pre><code>  let fetchAndDownload url =
    async {
        let! data = downloadData url &#x2F;&#x2F; similar to C#: var data = await downloadData(url);

        let processedData = processData data

        return processedData
    }
</code></pre>
I often use taskResult{}&#x2F;asyncResult{}[1] which combine the above with unwrapping Result&lt;&gt;(Ok or Error).<p>Metaprogramming is somewhat limited in comparison to Scala or Haskell; but still possible using various mechanisms. I find that this isn&#x27;t a big issue in my work.<p>IDE-wise, JetBrains Rider is a breeze to work with and it has native F# support. There is also Visual Studio and VS Code with Ionide, which are better in some areas.<p>You can run F# in Jypiter via .NET Interactive Notebooks (now called &quot;Polyglot Notebooks&quot; [2]). I haven&#x27;t seen this mentioned often, but this is very practical. I have a combination of Notebooks for one-off data tasks which I run from VS Code. These notebooks can even reuse code from my regular F# projects&#x27; code base.
Over the past years, this has almost eliminated my usage of Python notebooks except for ML work.<p>[0]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;language-reference&#x2F;computation-expressions" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;language-ref...</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;demystifyfp&#x2F;FsToolkit.ErrorHandling?tab=readme-ov-file#a-motivating-example">https:&#x2F;&#x2F;github.com&#x2F;demystifyfp&#x2F;FsToolkit.ErrorHandling?tab=r...</a><p>[2]: <a href="https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-dotnettools.dotnet-interactive-vscode" rel="nofollow">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-dotne...</a></div><br/><div id="40176136" class="c"><input type="checkbox" id="c-40176136" checked=""/><div class="controls bullet"><span class="by">belinder</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40175710">parent</a><span>|</span><a href="#40172468">next</a><span>|</span><label class="collapse" for="c-40176136">[-]</label><label class="expand" for="c-40176136">[1 more]</label></div><br/><div class="children"><div class="content">Do you know of or have any shareable (sample) projects implemented in your way of doing F#? It sounds very intriguing to me</div><br/></div></div></div></div><div id="40172468" class="c"><input type="checkbox" id="c-40172468" checked=""/><div class="controls bullet"><span class="by">BoorishBears</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40175710">prev</a><span>|</span><a href="#40172815">next</a><span>|</span><label class="collapse" for="c-40172468">[-]</label><label class="expand" for="c-40172468">[10 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that just Swift&#x2F;Kotlin?</div><br/><div id="40172611" class="c"><input type="checkbox" id="c-40172611" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172468">parent</a><span>|</span><a href="#40172699">next</a><span>|</span><label class="collapse" for="c-40172611">[-]</label><label class="expand" for="c-40172611">[4 more]</label></div><br/><div class="children"><div class="content">The problem with languages is they don&#x27;t compose. Iow, one missing feature needed automatically invalidates the language entirely. Swift is targeted at Apple platforms and cross platform is an after thought. Kotlin targets JVM and while it is cool in concept, I hate it as a user (and Kotlin native isn&#x27;t near as mature). If were considering something else at this stage I&#x27;d probably put my time into F#, but even it has its cons.<p>NOTE: By &quot;compose&quot; I mean that if I want feature A, B and C from lang X (has A and B), Y (has B and C) and Z (has A and C), but there is no way to get A, B and C in one language without creating a brand new one. I cannot mix and match features from different languages.</div><br/><div id="40172825" class="c"><input type="checkbox" id="c-40172825" checked=""/><div class="controls bullet"><span class="by">Scramblejams</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172611">parent</a><span>|</span><a href="#40173242">next</a><span>|</span><label class="collapse" for="c-40172825">[-]</label><label class="expand" for="c-40172825">[2 more]</label></div><br/><div class="children"><div class="content">And if we&#x27;re still talking about gamedev, F# would probably make the GC too sad.<p>(When are we getting a low latency collector in the CLR? But I digress...)</div><br/><div id="40172873" class="c"><input type="checkbox" id="c-40172873" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172825">parent</a><span>|</span><a href="#40173242">next</a><span>|</span><label class="collapse" for="c-40172873">[-]</label><label class="expand" for="c-40172873">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;m not a game dev and don&#x27;t write anything with low latency requirements. Almost all my code is in the &quot;thoughput&quot; camp.</div><br/></div></div></div></div><div id="40173242" class="c"><input type="checkbox" id="c-40173242" checked=""/><div class="controls bullet"><span class="by">BoorishBears</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172611">parent</a><span>|</span><a href="#40172825">prev</a><span>|</span><a href="#40172699">next</a><span>|</span><label class="collapse" for="c-40173242">[-]</label><label class="expand" for="c-40173242">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t compose what? Is this one of those &#x27;monad is an endofunctor&#x27; deals?<p>(me not knowing might be the ignorant bliss that allows me to just do productive things in them regardless)<p>Edit: I understand from the updated comment<p>I&#x27;ve long accepted that no one language can offer all of the  language features I&#x27;d want, but I also question if I&#x27;d even want that language if I got it</div><br/></div></div></div></div><div id="40172699" class="c"><input type="checkbox" id="c-40172699" checked=""/><div class="controls bullet"><span class="by">akavi</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172468">parent</a><span>|</span><a href="#40172611">prev</a><span>|</span><a href="#40172914">next</a><span>|</span><label class="collapse" for="c-40172699">[-]</label><label class="expand" for="c-40172699">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s any of:<p>Rust + (garbage collector)<p>Swift + (cross platform support)<p>Kotlin + (proper pattern matching)<p>Unfortunately, none quite hit that central sweet spot, IMO</div><br/><div id="40174043" class="c"><input type="checkbox" id="c-40174043" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172699">parent</a><span>|</span><a href="#40177211">next</a><span>|</span><label class="collapse" for="c-40174043">[-]</label><label class="expand" for="c-40174043">[1 more]</label></div><br/><div class="children"><div class="content">Roc is looking very promising IMO</div><br/></div></div><div id="40177211" class="c"><input type="checkbox" id="c-40177211" checked=""/><div class="controls bullet"><span class="by">valcron1000</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172699">parent</a><span>|</span><a href="#40174043">prev</a><span>|</span><a href="#40174358">next</a><span>|</span><label class="collapse" for="c-40177211">[-]</label><label class="expand" for="c-40177211">[1 more]</label></div><br/><div class="children"><div class="content">Well, Kotlin + (proper pattern matching) = Scala</div><br/></div></div><div id="40174358" class="c"><input type="checkbox" id="c-40174358" checked=""/><div class="controls bullet"><span class="by">melodyogonna</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172699">parent</a><span>|</span><a href="#40177211">prev</a><span>|</span><a href="#40172914">next</a><span>|</span><label class="collapse" for="c-40174358">[-]</label><label class="expand" for="c-40174358">[1 more]</label></div><br/><div class="children"><div class="content">Mojo soon</div><br/></div></div></div></div><div id="40172914" class="c"><input type="checkbox" id="c-40172914" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172468">parent</a><span>|</span><a href="#40172699">prev</a><span>|</span><a href="#40172815">next</a><span>|</span><label class="collapse" for="c-40172914">[-]</label><label class="expand" for="c-40172914">[1 more]</label></div><br/><div class="children"><div class="content">And Zig maybe?</div><br/></div></div></div></div><div id="40172815" class="c"><input type="checkbox" id="c-40172815" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40172468">prev</a><span>|</span><a href="#40172690">next</a><span>|</span><label class="collapse" for="c-40172815">[-]</label><label class="expand" for="c-40172815">[5 more]</label></div><br/><div class="children"><div class="content">I mean.. Java is there. Java 23 is really interesting.</div><br/><div id="40172888" class="c"><input type="checkbox" id="c-40172888" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172815">parent</a><span>|</span><a href="#40172690">next</a><span>|</span><label class="collapse" for="c-40172888">[-]</label><label class="expand" for="c-40172888">[4 more]</label></div><br/><div class="children"><div class="content">When is Java getting value types? It has been talked about forever now.</div><br/><div id="40178161" class="c"><input type="checkbox" id="c-40178161" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172888">parent</a><span>|</span><a href="#40173576">next</a><span>|</span><label class="collapse" for="c-40178161">[-]</label><label class="expand" for="c-40178161">[1 more]</label></div><br/><div class="children"><div class="content">And it will still take time to come, the whole engineering problem is how to introduce value types, make classes that are clearly value types like Optional, turn into value types, while at the same time not breaking the endless amount of JAR files in production, when upgrading to a JVM with value types support enabled.<p>They would get it sooner by breaking the ecosystem, and as Python 3, Java 9, .NET Core have shown, not everyone would be racing to adopt the new shiny thingy.</div><br/></div></div><div id="40173576" class="c"><input type="checkbox" id="c-40173576" checked=""/><div class="controls bullet"><span class="by">msgilligan</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172888">parent</a><span>|</span><a href="#40178161">prev</a><span>|</span><a href="#40173502">next</a><span>|</span><label class="collapse" for="c-40173576">[-]</label><label class="expand" for="c-40173576">[1 more]</label></div><br/><div class="children"><div class="content">Java 23 is not final and I&#x27;m hoping this JEP makes it into 23:<p><a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;401" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;401</a><p>I don&#x27;t follow the JEP process closely enough to know if it will be proposed for 23 or approved. But I think it&#x27;s coming soon.</div><br/></div></div><div id="40173502" class="c"><input type="checkbox" id="c-40173502" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172888">parent</a><span>|</span><a href="#40173576">prev</a><span>|</span><a href="#40172690">next</a><span>|</span><label class="collapse" for="c-40173502">[-]</label><label class="expand" for="c-40173502">[1 more]</label></div><br/><div class="children"><div class="content">Good question. I think it must be this one: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;401" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;401</a><p>I can&#x27;t see it in the feature list of JDK 22 or even 23. Maybe it&#x27;ll come in JDK 24?</div><br/></div></div></div></div></div></div><div id="40172690" class="c"><input type="checkbox" id="c-40172690" checked=""/><div class="controls bullet"><span class="by">andrepd</span><span>|</span><a href="#40172449">parent</a><span>|</span><a href="#40172815">prev</a><span>|</span><a href="#40173921">next</a><span>|</span><label class="collapse" for="c-40172690">[-]</label><label class="expand" for="c-40172690">[3 more]</label></div><br/><div class="children"><div class="content">Rust is in a separate class of go and swift and kotlin and etc. The class it competes on is pretty C, C++, and itself.<p>Yes it&#x27;s easier to write trivial code in python than Rust. Yes it&#x27;s harder to manage memory manually than it is to let a gc handle it. I don&#x27;t see the point.<p>Rust is a systems programming language. It&#x27;s hard to write a server in it than it is to hack something in node, but it will also be faster and more reliable. Conversely, it&#x27;s easier than writing it in C++ or C, while still being more reliable. That&#x27;s the whole value proposition.</div><br/><div id="40178173" class="c"><input type="checkbox" id="c-40178173" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172690">parent</a><span>|</span><a href="#40174621">next</a><span>|</span><label class="collapse" for="c-40178173">[-]</label><label class="expand" for="c-40178173">[1 more]</label></div><br/><div class="children"><div class="content">For Apple, Swift is their Rust, regardless of the world outside Apple&#x27;s ecosystem thinks about it.<p>It is clearly stated on Swift&#x27;s documentation, they already hold a couple of talks at C++ conferences about code migration, and is one of the reasons why nowadays they mostly focus on LLVM contributions instead of clang.</div><br/></div></div><div id="40174621" class="c"><input type="checkbox" id="c-40174621" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40172449">root</a><span>|</span><a href="#40172690">parent</a><span>|</span><a href="#40178173">prev</a><span>|</span><a href="#40173921">next</a><span>|</span><label class="collapse" for="c-40174621">[-]</label><label class="expand" for="c-40174621">[1 more]</label></div><br/><div class="children"><div class="content">Swift has a systems programming subset, and an even smaller embedded programming subset.<p>Of course &quot;smaller&quot; is significant here; it has less features and you might not like using it anymore.</div><br/></div></div></div></div></div></div><div id="40173921" class="c"><input type="checkbox" id="c-40173921" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#40172449">prev</a><span>|</span><a href="#40178180">next</a><span>|</span><label class="collapse" for="c-40173921">[-]</label><label class="expand" for="c-40173921">[4 more]</label></div><br/><div class="children"><div class="content">&gt; wait I can&#x27;t add this new thing because things will no longer compile, and there&#x27;s no workaround other than code restructuring<p>I definitely think that&#x27;s a great feature. I want to learn on day 2 that the design is a dead end, not on day 101 when I ship on day 100 and there was a race condition on day 2 I never noticed.<p>But the thing about gamedev (I guess - I&#x27;m not a game developer) is that the code being great and doing what you <i>hope</i> it will do isn&#x27;t 100% of the job as it is in other disciplines. In gamedev you may want to <i>run</i> the code, and the way it runs (fun, feel, whatever) might be bad even though it compiles, works according to a spec and so on. So while I&#x27;m usually happy to write code for a week and never run it - game development feels like it&#x27;s all about the iteration.<p>That said, game development is also game <i>engine</i> development. And Rust seems absolutely perfect for engine development (you need &quot;fearless&quot; concurrency and performance and there are zero mainstream languages that will do that other than rust). For people who feel it&#x27;s too rigid or hard to iterate with perhaps hybrid could work. Like Rust + Lua or something sounds like it could be worth trying.</div><br/><div id="40174463" class="c"><input type="checkbox" id="c-40174463" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40173921">parent</a><span>|</span><a href="#40178180">next</a><span>|</span><label class="collapse" for="c-40174463">[-]</label><label class="expand" for="c-40174463">[3 more]</label></div><br/><div class="children"><div class="content">I think the point is that there are few &quot;code related&quot; dead ends in game code with good game play that can&#x27;t be dealt with using enough effort.  There are plenty of &quot;game play related&quot; dead ends that no amount of clean code can help out.<p>To that end, whatever can help you explore the game play the fastest is what you want.</div><br/><div id="40174628" class="c"><input type="checkbox" id="c-40174628" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#40173921">root</a><span>|</span><a href="#40174463">parent</a><span>|</span><a href="#40178180">next</a><span>|</span><label class="collapse" for="c-40174628">[-]</label><label class="expand" for="c-40174628">[2 more]</label></div><br/><div class="children"><div class="content">Quick iteration perhaps isn&#x27;t the biggest strength of C++ either. Rust does have some friction when it comes to &quot;I&#x27;ll try this with a dirty impl and if it flies, then I cam make a clean one later&quot;. I guess if that friction is worth it will depend on how much faster you get on other things, e.g. refactoring without spending a lot of effort worrying about introducing hard-to-spot bugs like races, or - worse - having to spend valuable time <i>fixing</i> those bugs instead of adding fun to the game.</div><br/><div id="40174972" class="c"><input type="checkbox" id="c-40174972" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40173921">root</a><span>|</span><a href="#40174628">parent</a><span>|</span><a href="#40178180">next</a><span>|</span><label class="collapse" for="c-40174972">[-]</label><label class="expand" for="c-40174972">[1 more]</label></div><br/><div class="children"><div class="content">This is fair.  Always curious to see why so much effort is used to move a game&#x27;s codebase into a single language codebase.  Seems far more useful to move the core of a game&#x27;s engine to an interpreter loop and build on top of that, with all of the affordances one usually gets from that.</div><br/></div></div></div></div></div></div></div></div><div id="40178180" class="c"><input type="checkbox" id="c-40178180" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#40173921">prev</a><span>|</span><a href="#40173937">next</a><span>|</span><label class="collapse" for="c-40178180">[-]</label><label class="expand" for="c-40178180">[1 more]</label></div><br/><div class="children"><div class="content">I think the crux is this heading: <i>Making a fun &amp; interesting games is about rapid prototyping and iteration, Rust&#x27;s values are everything but that</i><p>Jon Blow said that in one of his talks:  Rust treats all code as production code. For most of the duration of a project, that&#x27;s counterproductive, because it introduces a significant amount of unnecessary friction.<p>For most of a game&#x27;s development, you&#x27;re trying to figure out what the game&#x27;s supposed to be. Only later does it crystallize. Rust doesn&#x27;t recognize the non-crystalline phase, or rather explicitly rejects it as invalid.</div><br/></div></div><div id="40173937" class="c"><input type="checkbox" id="c-40173937" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40178180">prev</a><span>|</span><a href="#40172794">next</a><span>|</span><label class="collapse" for="c-40173937">[-]</label><label class="expand" for="c-40173937">[2 more]</label></div><br/><div class="children"><div class="content">Oh my, this has to be my favorite quote in a blog in a long long time.<p>&quot;... many if not most of the problems don&#x27;t go away if one isn&#x27;t willing to constantly refactor their code and treat programming as a puzzle solving process, rather than just a tool to get things done.&quot;<p>I have thought it was just me for a long time, but many of the popular styles of programming that we push definitely seem to require constant refactors in the pursuit of a solution.  And I definitely see more tire spinning for the sake of the build than I do for whatever it was folks were building.<p>Great quote.</div><br/><div id="40174307" class="c"><input type="checkbox" id="c-40174307" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#40173937">parent</a><span>|</span><a href="#40172794">next</a><span>|</span><label class="collapse" for="c-40174307">[-]</label><label class="expand" for="c-40174307">[1 more]</label></div><br/><div class="children"><div class="content">It is a great quote!<p>I think multiple refactors in pursuit of a solution can be a good thing. As your thinking&#x2F;design evolves, so does the shape of the solution.<p>The main problem, I think, is that this goes against <i>specifically</i> gamedev. In gamedev whether the solution is the best or more resilient is secondary to extremely fast iteration and delivering <i>something</i>. Like the author says, sometimes &quot;clunky but good enough for now&quot; is what you need to get it over with (for the moment) an iterate rapidly over the gameplay elements you should spend most of your time on. Gameplay, not correctness or reliability or maintainability, is the most important thing in a game.</div><br/></div></div></div></div><div id="40172794" class="c"><input type="checkbox" id="c-40172794" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40173937">prev</a><span>|</span><a href="#40173279">next</a><span>|</span><label class="collapse" for="c-40172794">[-]</label><label class="expand" for="c-40172794">[5 more]</label></div><br/><div class="children"><div class="content">&gt; As far as a game is concerned, there is only one audio system, one input system, one physics world, one deltaTime, one renderer, one asset loader.<p>I thought this way when I was doing Java dev around 10 years ago.  I thought it excused the singleton pattern.  I was wrong!<p>You should always be able to construct an object by explicitly passing dependencies to it.  Especially for testing.<p>It really is no fun if your renderer starts talking to your asset loader and timer directly.</div><br/><div id="40174660" class="c"><input type="checkbox" id="c-40174660" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40172794">parent</a><span>|</span><a href="#40176242">prev</a><span>|</span><a href="#40173326">next</a><span>|</span><label class="collapse" for="c-40174660">[-]</label><label class="expand" for="c-40174660">[1 more]</label></div><br/><div class="children"><div class="content">People should get more into integration tests. If you start out thinking you need to separate everything for unit testability, you instantly get architecture astronaut-ism, where your architecture is entirely based on fake testability instead of the thing it&#x27;s actually meant to do in production.</div><br/></div></div><div id="40173326" class="c"><input type="checkbox" id="c-40173326" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#40172794">parent</a><span>|</span><a href="#40174660">prev</a><span>|</span><a href="#40173822">next</a><span>|</span><label class="collapse" for="c-40173326">[-]</label><label class="expand" for="c-40173326">[1 more]</label></div><br/><div class="children"><div class="content">All praise our almighty lord that is dependency injection</div><br/></div></div><div id="40173822" class="c"><input type="checkbox" id="c-40173822" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40172794">parent</a><span>|</span><a href="#40173326">prev</a><span>|</span><a href="#40173279">next</a><span>|</span><label class="collapse" for="c-40173822">[-]</label><label class="expand" for="c-40173822">[1 more]</label></div><br/><div class="children"><div class="content">No.
You don&#x27;t need ability to DI every single functionality.
And you can still do DI with global state, just with less granularity.</div><br/></div></div></div></div><div id="40173279" class="c"><input type="checkbox" id="c-40173279" checked=""/><div class="controls bullet"><span class="by">indigoabstract</span><span>|</span><a href="#40172794">prev</a><span>|</span><a href="#40172832">next</a><span>|</span><label class="collapse" for="c-40173279">[-]</label><label class="expand" for="c-40173279">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve become wary of commenting on articles that mention the pros and cons of various languages, but I still find it strange that so many people are so strongly focused on what their favourite language can do (usually better than others), instead of the project they&#x27;re working on. When it should be the other way around.<p>The joke he mentioned about having 50 engines written but only 5 games certainly rings true and I don&#x27;t think the language is the main problem preventing people from getting their projects done..</div><br/><div id="40173547" class="c"><input type="checkbox" id="c-40173547" checked=""/><div class="controls bullet"><span class="by">avery17</span><span>|</span><a href="#40173279">parent</a><span>|</span><a href="#40174040">next</a><span>|</span><label class="collapse" for="c-40173547">[-]</label><label class="expand" for="c-40173547">[5 more]</label></div><br/><div class="children"><div class="content">The hardest part of a project is finishing it. I think the main issue is the fun problems to solve happen very early in the project and once those are done it becomes incredibly tedius and boring and I usually lose focus until the project dies. Its difficult to maintain motivation.</div><br/><div id="40174672" class="c"><input type="checkbox" id="c-40174672" checked=""/><div class="controls bullet"><span class="by">TulliusCicero</span><span>|</span><a href="#40173279">root</a><span>|</span><a href="#40173547">parent</a><span>|</span><a href="#40173924">next</a><span>|</span><label class="collapse" for="c-40174672">[-]</label><label class="expand" for="c-40174672">[3 more]</label></div><br/><div class="children"><div class="content">Interesting, I almost find it the opposite right now. Learning the engine is a pain in the ass -- it&#x27;s not particularly hard, just tedious to learn all the APIs and quirks -- and then when you&#x27;re initially building the thing, &quot;it&#x27;s not fun yet&quot; for a quite a while. But then once you have the fundamentals down, you can add more abilities and characters and other features, that&#x27;s the fun shit.<p>I was working on the AI last night, and since I already had one functioning AI agent, it was pretty easy to spin up variations that behaved in moderately different ways, which was very fun!<p>I&#x27;ve only been dabbling though, and still sort of in the prototype stage, not quite a full game yet but getting there. Maybe I&#x27;ll feel more like you suggest deeper into development.</div><br/><div id="40175734" class="c"><input type="checkbox" id="c-40175734" checked=""/><div class="controls bullet"><span class="by">gridspy</span><span>|</span><a href="#40173279">root</a><span>|</span><a href="#40174672">parent</a><span>|</span><a href="#40173924">next</a><span>|</span><label class="collapse" for="c-40175734">[-]</label><label class="expand" for="c-40175734">[2 more]</label></div><br/><div class="children"><div class="content">I think the period between having a playable alpha and a polished release is the part people hate.<p>Or just grinding out content to make the game longer.<p>I hope you enjoy the process and succeed as a game dev.</div><br/><div id="40176259" class="c"><input type="checkbox" id="c-40176259" checked=""/><div class="controls bullet"><span class="by">TulliusCicero</span><span>|</span><a href="#40173279">root</a><span>|</span><a href="#40175734">parent</a><span>|</span><a href="#40173924">next</a><span>|</span><label class="collapse" for="c-40176259">[-]</label><label class="expand" for="c-40176259">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>Right now, the idea of creating new content being &quot;grinding&quot; baffles me, but that&#x27;s as a hobbyist developer of course. I&#x27;m sure I&#x27;d feel different if I was in a big company doing it.</div><br/></div></div></div></div></div></div><div id="40173924" class="c"><input type="checkbox" id="c-40173924" checked=""/><div class="controls bullet"><span class="by">indigoabstract</span><span>|</span><a href="#40173279">root</a><span>|</span><a href="#40173547">parent</a><span>|</span><a href="#40174672">prev</a><span>|</span><a href="#40174040">next</a><span>|</span><label class="collapse" for="c-40173924">[-]</label><label class="expand" for="c-40173924">[1 more]</label></div><br/><div class="children"><div class="content">Right. If someone could come up with a pill or something to maintain motivation and make all the bugs and hairy annoying details feel fresh again, just like the feeling of starting over, I would certainly part with my money. But there&#x27;s no such thing unfortunately.</div><br/></div></div></div></div><div id="40174040" class="c"><input type="checkbox" id="c-40174040" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#40173279">parent</a><span>|</span><a href="#40173547">prev</a><span>|</span><a href="#40175797">next</a><span>|</span><label class="collapse" for="c-40174040">[-]</label><label class="expand" for="c-40174040">[1 more]</label></div><br/><div class="children"><div class="content">IMO one language can sidetrack you more than another. It might not be the main problem but a language that gets in the way for your usecase causes you to focus on the wrong problem. Making a good game is really hard and really needs you to focus outside the tech.</div><br/></div></div><div id="40175797" class="c"><input type="checkbox" id="c-40175797" checked=""/><div class="controls bullet"><span class="by">ahfeah7373</span><span>|</span><a href="#40173279">parent</a><span>|</span><a href="#40174040">prev</a><span>|</span><a href="#40173856">next</a><span>|</span><label class="collapse" for="c-40175797">[-]</label><label class="expand" for="c-40175797">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree<p>My unpopular programming opinion: languages aren&#x27;t that interesting to me<p>I&#x27;m much more interested in the problem being solved and algorithms in the abstract sense</div><br/></div></div><div id="40173856" class="c"><input type="checkbox" id="c-40173856" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40173279">parent</a><span>|</span><a href="#40175797">prev</a><span>|</span><a href="#40172832">next</a><span>|</span><label class="collapse" for="c-40173856">[-]</label><label class="expand" for="c-40173856">[1 more]</label></div><br/><div class="children"><div class="content">Yep.<p>Bikeshedding, how many angels can dance on the head of a pin, and <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;</a> are some ways of loosely describing what you said.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;How_many_angels_can_dance_on_the_head_of_a_pin%3F" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;How_many_angels_can_dance_on...</a><p>&gt;but I still find it strange that so many people are so strongly focused on what their favourite language can do (usually better than others), instead of the project they&#x27;re working on.<p>Yes, if they are so convinced of that, why are they not back in the office or at home, working busy as a beaver on their project, using that great programming language, the benefits of which they extol?<p>Smells fishy to me.<p>Oops.<p>Do people see what I did there? ;)</div><br/></div></div></div></div><div id="40172832" class="c"><input type="checkbox" id="c-40172832" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#40173279">prev</a><span>|</span><a href="#40172604">next</a><span>|</span><label class="collapse" for="c-40172832">[-]</label><label class="expand" for="c-40172832">[1 more]</label></div><br/><div class="children"><div class="content">I agree with a lot here, but I think the author is overplaying &quot;get things done fast&quot; or underplaying &quot;stable, performant code&quot;.  I like indie games, but I&#x27;ve played enough games that crashed if I look at them wrong or chug despite being low poly early 2000s things that I now hesitate to buy indie games. Some of the examples seemed like maybe rust was preventing a weird unexpected feedback or clobbering iteration state or whatever.<p>I don&#x27;t think the author disagrees here and is mostly talking about awful runtime alternatives (refcell, etc) but I just wanted to say it for balance.</div><br/></div></div><div id="40172604" class="c"><input type="checkbox" id="c-40172604" checked=""/><div class="controls bullet"><span class="by">colund</span><span>|</span><a href="#40172832">prev</a><span>|</span><a href="#40172490">next</a><span>|</span><label class="collapse" for="c-40172604">[-]</label><label class="expand" for="c-40172604">[13 more]</label></div><br/><div class="children"><div class="content">I find that Jonathan Blow ranting about Rust game development here <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4t1K66dMhWk" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4t1K66dMhWk</a>. He adds interesting perspectives to the discussio, how the language makes the Rust game developer resort to arrays and their so called Rust point of views.</div><br/><div id="40176703" class="c"><input type="checkbox" id="c-40176703" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#40172604">parent</a><span>|</span><a href="#40173541">next</a><span>|</span><label class="collapse" for="c-40176703">[-]</label><label class="expand" for="c-40176703">[1 more]</label></div><br/><div class="children"><div class="content">There is a better, more recent clip of him where he explain &#x27;would we haven chosen rust, the witness would never been finished&#x27;.</div><br/></div></div><div id="40173541" class="c"><input type="checkbox" id="c-40173541" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#40172604">parent</a><span>|</span><a href="#40176703">prev</a><span>|</span><a href="#40172490">next</a><span>|</span><label class="collapse" for="c-40173541">[-]</label><label class="expand" for="c-40173541">[11 more]</label></div><br/><div class="children"><div class="content">Well the problem with Jonathan&#x27;s argument here is that he&#x27;s spent the past decade  mostly ranting about Rust and working to make a perfect game programming language, instead of making games.<p>So it turn out that even if he&#x27;s opinion on Rust is correct, he would still have been much more productive using it than trying to build his own language for a decade…<p>(But he already shipped his masterpiece and he&#x27;s a millionaire so he gets to chose his full time hobby as he wishes)</div><br/><div id="40173698" class="c"><input type="checkbox" id="c-40173698" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40173541">parent</a><span>|</span><a href="#40173943">next</a><span>|</span><label class="collapse" for="c-40173698">[-]</label><label class="expand" for="c-40173698">[7 more]</label></div><br/><div class="children"><div class="content">He is actively developing his new game in parallel to creating the language.<p>Not to mention  smaller projects like &#x27;Braid- anniversary edition&#x27;.</div><br/><div id="40174592" class="c"><input type="checkbox" id="c-40174592" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40173698">parent</a><span>|</span><a href="#40175472">next</a><span>|</span><label class="collapse" for="c-40174592">[-]</label><label class="expand" for="c-40174592">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the traditional advice that if you try to write both a game engine and a game that you&#x27;ll get neither?</div><br/><div id="40176278" class="c"><input type="checkbox" id="c-40176278" checked=""/><div class="controls bullet"><span class="by">QuadrupleA</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40174592">parent</a><span>|</span><a href="#40175045">next</a><span>|</span><label class="collapse" for="c-40176278">[-]</label><label class="expand" for="c-40176278">[1 more]</label></div><br/><div class="children"><div class="content">Braid and The Witness, his last two games, both used custom engines written in C++.</div><br/></div></div><div id="40175045" class="c"><input type="checkbox" id="c-40175045" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40174592">parent</a><span>|</span><a href="#40176278">prev</a><span>|</span><a href="#40174928">next</a><span>|</span><label class="collapse" for="c-40175045">[-]</label><label class="expand" for="c-40175045">[1 more]</label></div><br/><div class="children"><div class="content">Then it&#x27;s a good thing not everyone listens to traditional advice.</div><br/></div></div><div id="40174928" class="c"><input type="checkbox" id="c-40174928" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40174592">parent</a><span>|</span><a href="#40175045">prev</a><span>|</span><a href="#40175472">next</a><span>|</span><label class="collapse" for="c-40174928">[-]</label><label class="expand" for="c-40174928">[1 more]</label></div><br/><div class="children"><div class="content">I mean, it&#x27;s not like there are no games in existence that shipped with a custom engine.<p>Even in hindsight it&#x27;s hard to judge whether building your own engine was good or bad decision, and we are nowhere near &quot;the hindsight&quot; level of knowledge.</div><br/></div></div></div></div><div id="40175472" class="c"><input type="checkbox" id="c-40175472" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40173698">parent</a><span>|</span><a href="#40174592">prev</a><span>|</span><a href="#40173943">next</a><span>|</span><label class="collapse" for="c-40175472">[-]</label><label class="expand" for="c-40175472">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, and it&#x27;s taking him YEARS to implement a simple grid-walking Sokoban clone, and Braid anniversary edition had to be delayed.</div><br/><div id="40175952" class="c"><input type="checkbox" id="c-40175952" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40175472">parent</a><span>|</span><a href="#40173943">next</a><span>|</span><label class="collapse" for="c-40175952">[-]</label><label class="expand" for="c-40175952">[1 more]</label></div><br/><div class="children"><div class="content">Last I heard, the Sokoban game has a ridiculous number of puzzles on it. Can&#x27;t find a source but I seem to recall hearing that it would take 400+ hours to finish it all. So.. I don&#x27;t think it&#x27;s entirely unreasonable it&#x27;s been taking this long.</div><br/></div></div></div></div></div></div><div id="40173943" class="c"><input type="checkbox" id="c-40173943" checked=""/><div class="controls bullet"><span class="by">ekms</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40173541">parent</a><span>|</span><a href="#40173698">prev</a><span>|</span><a href="#40176150">next</a><span>|</span><label class="collapse" for="c-40173943">[-]</label><label class="expand" for="c-40173943">[1 more]</label></div><br/><div class="children"><div class="content">I mean, he does like a good rant lol. But this seems like a bad take. The witness came out ~8 years ago, and Braid came out ~8 years before that. Braid Anniversary is launching next week, he&#x27;s actively developing his language and next game (occasionally streams). 
 &quot;he&#x27;s just resting on his laurels now&quot; I think is clearly wrong</div><br/></div></div><div id="40176150" class="c"><input type="checkbox" id="c-40176150" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40173541">parent</a><span>|</span><a href="#40173943">prev</a><span>|</span><a href="#40175093">next</a><span>|</span><label class="collapse" for="c-40176150">[-]</label><label class="expand" for="c-40176150">[1 more]</label></div><br/><div class="children"><div class="content">Why should he be making more games, instead of building his vision of a perfect language?<p>A machinist who retires from running lathes and goes into the lathe-making business has reached the pinnacle of that profession.</div><br/></div></div><div id="40175093" class="c"><input type="checkbox" id="c-40175093" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#40172604">root</a><span>|</span><a href="#40173541">parent</a><span>|</span><a href="#40176150">prev</a><span>|</span><a href="#40172490">next</a><span>|</span><label class="collapse" for="c-40175093">[-]</label><label class="expand" for="c-40175093">[1 more]</label></div><br/><div class="children"><div class="content">Writing games in C++ feels horrible which is a large part of he wrote the language.</div><br/></div></div></div></div></div></div><div id="40172490" class="c"><input type="checkbox" id="c-40172490" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#40172604">prev</a><span>|</span><a href="#40173356">next</a><span>|</span><label class="collapse" for="c-40172490">[-]</label><label class="expand" for="c-40172490">[28 more]</label></div><br/><div class="children"><div class="content">This is a very brave post to write given how incendiary responses to rust criticism can be, but this matches my experience entirely.</div><br/><div id="40172666" class="c"><input type="checkbox" id="c-40172666" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#40172490">parent</a><span>|</span><a href="#40172563">next</a><span>|</span><label class="collapse" for="c-40172666">[-]</label><label class="expand" for="c-40172666">[7 more]</label></div><br/><div class="children"><div class="content">I think I just read about 10 versions of this comment on this page, and definitely not a single response to the criticism that could be described as incendiary. I don&#x27;t think I even saw a single comment just now that fundamentally pushed back on the premise of this article, let alone in an incendiary way. It&#x27;s early yet, and maybe this thread will look very different in a few hours though?</div><br/><div id="40172776" class="c"><input type="checkbox" id="c-40172776" checked=""/><div class="controls bullet"><span class="by">thegrim33</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172666">parent</a><span>|</span><a href="#40172882">next</a><span>|</span><label class="collapse" for="c-40172776">[-]</label><label class="expand" for="c-40172776">[2 more]</label></div><br/><div class="children"><div class="content">The author maybe somewhat hit on the reason for this in the article, where they mentioned that they&#x27;re already seeing some of the rabid, toxic, Rust proponents already moving onto the next &quot;hot&quot; thing and doing their thing there. So maybe after a few years of Rust we&#x27;ve arrived at the turning point now where enough of those types of people have finally moved on and the Rust community has significantly changed.</div><br/><div id="40176854" class="c"><input type="checkbox" id="c-40176854" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172776">parent</a><span>|</span><a href="#40172882">next</a><span>|</span><label class="collapse" for="c-40176854">[-]</label><label class="expand" for="c-40176854">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s the case. N=1, but I&#x27;m usually a quite staunch, and occasionally incendiary, proponent of Rust, because the arguments against it &#x2F; criticisms of it I usually see seem fundamentally misguided or even disingenuous to me — whereas in this thread, I&#x27;ve been only agreeing, because the criticisms are fair (I agree Rust isn&#x27;t built for, and is quite bad at, prototyping, fast iteration, flexible code, etc), if I think a bit overblown (I think many of the patterns the author complains about being forced to use like command lists and generational arenas are very good). That could be the difference you&#x27;re seeing, IMO.</div><br/></div></div></div></div><div id="40172882" class="c"><input type="checkbox" id="c-40172882" checked=""/><div class="controls bullet"><span class="by">ziddoap</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172666">parent</a><span>|</span><a href="#40172776">prev</a><span>|</span><a href="#40173062">next</a><span>|</span><label class="collapse" for="c-40172882">[-]</label><label class="expand" for="c-40172882">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps because the article is about how Rust isn&#x27;t the magic bullet to everything, and a few people have commented agreeing with the article, others feel more willing to comment their own Rust isn&#x27;t perfect opinion as well.<p>If you go into the comment section of a pro-Rust article, where the first few top-level comments are also pro-Rust, the responses to people expressing a negative attitude about Rust tend to (in my experience) be different.<p>This phenomenon certainly isn&#x27;t exclusive to Rust (or HN). It happens all the time, especially when a prolific commenter is among the first few comments. It can set the tone for the entire comment section.</div><br/><div id="40173788" class="c"><input type="checkbox" id="c-40173788" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172882">parent</a><span>|</span><a href="#40173062">next</a><span>|</span><label class="collapse" for="c-40173788">[-]</label><label class="expand" for="c-40173788">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a forum that scrambles comments could be interesting.</div><br/></div></div></div></div><div id="40173062" class="c"><input type="checkbox" id="c-40173062" checked=""/><div class="controls bullet"><span class="by">martin-t</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172666">parent</a><span>|</span><a href="#40172882">prev</a><span>|</span><a href="#40172563">next</a><span>|</span><label class="collapse" for="c-40173062">[-]</label><label class="expand" for="c-40173062">[2 more]</label></div><br/><div class="children"><div class="content">I assure you it happens, but the people targetted this way usually quickly learn what is ok and what isn&#x27;t to say, especially on rust&#x27;s reddit. If you wanna see examples, look at my reddit profile (same username). I dared to say bevy was full of hype and false promises and tat the money they get would be better spent elsewhere. And look at the hate i received.<p>One way i&#x27;ve seen to reduce this is prefixing any posts with &quot;I am not criticizing any engine in particular&quot; even if it&#x27;s blatantly obvious because the criticism only applies to one.</div><br/><div id="40174202" class="c"><input type="checkbox" id="c-40174202" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40173062">parent</a><span>|</span><a href="#40172563">next</a><span>|</span><label class="collapse" for="c-40174202">[-]</label><label class="expand" for="c-40174202">[1 more]</label></div><br/><div class="children"><div class="content">I guess I interpreted the comment as meaning that the incendiary responses were going to be seen <i>here</i>. I would expect incendiary responses to <i>anything</i> I post on reddit...</div><br/></div></div></div></div></div></div><div id="40172563" class="c"><input type="checkbox" id="c-40172563" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40172490">parent</a><span>|</span><a href="#40172666">prev</a><span>|</span><a href="#40172950">next</a><span>|</span><label class="collapse" for="c-40172563">[-]</label><label class="expand" for="c-40172563">[19 more]</label></div><br/><div class="children"><div class="content">&gt; incendiary responses to rust criticism can be<p>I&#x27;ve not experienced this.  Do you have examples of the rust community flaming someone for having negative opinions about the language?</div><br/><div id="40178383" class="c"><input type="checkbox" id="c-40178383" checked=""/><div class="controls bullet"><span class="by">gg2222</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172563">parent</a><span>|</span><a href="#40178110">next</a><span>|</span><label class="collapse" for="c-40178383">[-]</label><label class="expand" for="c-40178383">[1 more]</label></div><br/><div class="children"><div class="content">Check this response to the article within these HN comments:
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40177534">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40177534</a><p>Not actually flaming but quite condescending towards the article writer. Not even properly reading the article and coming to conclusions.<p>This is on HN which is generally more neutral towards Rust. I imagine in Rust circles these types of responses would come out a lot more.</div><br/></div></div><div id="40178110" class="c"><input type="checkbox" id="c-40178110" checked=""/><div class="controls bullet"><span class="by">googh</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172563">parent</a><span>|</span><a href="#40178383">prev</a><span>|</span><a href="#40175483">next</a><span>|</span><label class="collapse" for="c-40178110">[-]</label><label class="expand" for="c-40178110">[1 more]</label></div><br/><div class="children"><div class="content">Not parent, but take a look at these:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32117148">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32117148</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39641552">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39641552</a><p>These threads are absolutely painful to read. The Rust community&#x2F;leadership would not do anything about it because Rust thrives on such &quot;devotion&quot;.</div><br/></div></div><div id="40175483" class="c"><input type="checkbox" id="c-40175483" checked=""/><div class="controls bullet"><span class="by">VancouverMan</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172563">parent</a><span>|</span><a href="#40178110">prev</a><span>|</span><a href="#40172686">next</a><span>|</span><label class="collapse" for="c-40175483">[-]</label><label class="expand" for="c-40175483">[2 more]</label></div><br/><div class="children"><div class="content">Based on what I&#x27;ve seen, various forms of censorship and suppression are often employed in such cases, rather than outright &quot;flaming&quot; or other discussion-based approaches.<p>It really depends on where and how the discussion is taking place, and what censorship methods the website&#x2F;platform&#x2F;medium involved offers.<p>Sometimes users are just outright banned or shadow-banned, if those happen to be options.<p>Sometimes forum threads, bug reports, or comments are deleted.<p>Sometimes the discussion remains accessible, but is stifled in some way. This includes closing&#x2F;locking forum threads or bug reports, or otherwise severely limiting participation in such discussions to a very small and isolated group of people. If down-voting&#x2F;reporting systems are present, sometimes they&#x27;re used to limit the visibility or prominence of such discussion.</div><br/><div id="40175723" class="c"><input type="checkbox" id="c-40175723" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40175483">parent</a><span>|</span><a href="#40172686">next</a><span>|</span><label class="collapse" for="c-40175723">[-]</label><label class="expand" for="c-40175723">[1 more]</label></div><br/><div class="children"><div class="content">Ok, do you have a concrete example of this?</div><br/></div></div></div></div><div id="40172686" class="c"><input type="checkbox" id="c-40172686" checked=""/><div class="controls bullet"><span class="by">chimen</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172563">parent</a><span>|</span><a href="#40175483">prev</a><span>|</span><a href="#40173318">next</a><span>|</span><label class="collapse" for="c-40172686">[-]</label><label class="expand" for="c-40172686">[4 more]</label></div><br/><div class="children"><div class="content">yes, keep reading this section</div><br/><div id="40174616" class="c"><input type="checkbox" id="c-40174616" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172686">parent</a><span>|</span><a href="#40173318">next</a><span>|</span><label class="collapse" for="c-40174616">[-]</label><label class="expand" for="c-40174616">[3 more]</label></div><br/><div class="children"><div class="content">You were flagged for no such thing.<p>You were flagged for a pointless quip about &quot;woke&quot;ness. Other people repeated more civil and reasonably argued forms of your same point about the language and its community and received no such downvotes.<p>No need to play martyr.</div><br/></div></div></div></div><div id="40173318" class="c"><input type="checkbox" id="c-40173318" checked=""/><div class="controls bullet"><span class="by">tick_tock_tick</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40172563">parent</a><span>|</span><a href="#40172686">prev</a><span>|</span><a href="#40172950">next</a><span>|</span><label class="collapse" for="c-40173318">[-]</label><label class="expand" for="c-40173318">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;d go read their mailing list and Reddit forms; especially when people run into issues doing stuff that&#x27;s very simple in other languages. Never seen a more toxic programming community.<p>Hopefully they calm down, or really get drown out, once there are a real number of jobs for people using Rust. Right now the evangelists outnumber the rank and file who are just using a language to get work done.</div><br/><div id="40174849" class="c"><input type="checkbox" id="c-40174849" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40173318">parent</a><span>|</span><a href="#40174634">next</a><span>|</span><label class="collapse" for="c-40174849">[-]</label><label class="expand" for="c-40174849">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m active on both and have not seen this behavior.<p>In fact, my experience has been the polar opposite, the rust community has been very friendly and accepting of critique.<p>So again, I&#x27;m going to ask for an example of rust language fanatics frothing at a criticism.  If it&#x27;s such a community problem this should be easy to find correct?<p>Here&#x27;s the OPs article on &#x2F;r&#x2F;rust and it&#x27;s both got a fair number of up votes and the top comments are all really positive towards this article.  That&#x27;s what I&#x27;ve seen at typical in the rust community.<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1cdqdsi&#x2F;lessons_learned_after_3_years_of_fulltime_rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;1cdqdsi&#x2F;lessons_learn...</a></div><br/></div></div><div id="40174634" class="c"><input type="checkbox" id="c-40174634" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40173318">parent</a><span>|</span><a href="#40174849">prev</a><span>|</span><a href="#40173639">next</a><span>|</span><label class="collapse" for="c-40174634">[-]</label><label class="expand" for="c-40174634">[6 more]</label></div><br/><div class="children"><div class="content">If it helps, they can&#x27;t possibly be as toxic as Lisp programmers used to be, where more or less any online conversation would start with someone new asking a question and Erik Naggum replying that they were a moron who should die.</div><br/><div id="40176162" class="c"><input type="checkbox" id="c-40176162" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40174634">parent</a><span>|</span><a href="#40177327">next</a><span>|</span><label class="collapse" for="c-40176162">[-]</label><label class="expand" for="c-40176162">[3 more]</label></div><br/><div class="children"><div class="content">Why is it that, say, C programmers, as such, don&#x27;t get painted according to what has historically gone on in the comp.lang.c newsgroup?</div><br/><div id="40176263" class="c"><input type="checkbox" id="c-40176263" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40176162">parent</a><span>|</span><a href="#40177327">next</a><span>|</span><label class="collapse" for="c-40176263">[-]</label><label class="expand" for="c-40176263">[2 more]</label></div><br/><div class="children"><div class="content">Probably because there&#x27;s so many more of them. Maybe because being called not a real UNIX programmer feels different from being called a Blub programmer.</div><br/><div id="40176980" class="c"><input type="checkbox" id="c-40176980" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40176263">parent</a><span>|</span><a href="#40177327">next</a><span>|</span><label class="collapse" for="c-40176980">[-]</label><label class="expand" for="c-40176980">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I should ask: why should someone interested about Lisp today have to hear stories about some Erik Naggum who posted to a Usenet newsgroup, and died 15 years ago?<p>Let&#x27;s assume that the newsgroup is important. Legendary Lisp hacker Alan Bawden posted there just last week or so. Nobody ever mentions him.</div><br/></div></div></div></div></div></div><div id="40177327" class="c"><input type="checkbox" id="c-40177327" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40174634">parent</a><span>|</span><a href="#40176162">prev</a><span>|</span><a href="#40174867">next</a><span>|</span><label class="collapse" for="c-40177327">[-]</label><label class="expand" for="c-40177327">[1 more]</label></div><br/><div class="children"><div class="content">&quot;toxic&quot; is also to generalize from one person &#x2F; one forum, to an extremely diverse group, many which never used Usenet</div><br/></div></div><div id="40174867" class="c"><input type="checkbox" id="c-40174867" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40174634">parent</a><span>|</span><a href="#40177327">prev</a><span>|</span><a href="#40173639">next</a><span>|</span><label class="collapse" for="c-40174867">[-]</label><label class="expand" for="c-40174867">[1 more]</label></div><br/><div class="children"><div class="content">Lol, I had a similar example with perl as a young teen programmer.<p>They&#x27;ve gotten way nicer.</div><br/></div></div></div></div><div id="40173639" class="c"><input type="checkbox" id="c-40173639" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40173318">parent</a><span>|</span><a href="#40174634">prev</a><span>|</span><a href="#40174107">next</a><span>|</span><label class="collapse" for="c-40173639">[-]</label><label class="expand" for="c-40173639">[1 more]</label></div><br/><div class="children"><div class="content">That does not mirror my experience.</div><br/></div></div><div id="40174107" class="c"><input type="checkbox" id="c-40174107" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#40172490">root</a><span>|</span><a href="#40173318">parent</a><span>|</span><a href="#40173639">prev</a><span>|</span><a href="#40172950">next</a><span>|</span><label class="collapse" for="c-40174107">[-]</label><label class="expand" for="c-40174107">[1 more]</label></div><br/><div class="children"><div class="content">Rust hasn&#x27;t had a mailing list for roughly a decade now...</div><br/></div></div></div></div></div></div><div id="40172950" class="c"><input type="checkbox" id="c-40172950" checked=""/><div class="controls bullet"><span class="by">SantalBlush</span><span>|</span><a href="#40172490">parent</a><span>|</span><a href="#40172563">prev</a><span>|</span><a href="#40173356">next</a><span>|</span><label class="collapse" for="c-40172950">[-]</label><label class="expand" for="c-40172950">[1 more]</label></div><br/><div class="children"><div class="content">This is a textbook example of poisoning the well. [0]  We see it used in every discussion about pros and cons of a language on HN.<p>It&#x27;s some variation of &quot;People who like this language can&#x27;t handle criticism&#x2F;are part of a cult&#x2F;etc.&quot;  The idea being that this will preclude anyone from responding to a criticism, because that would confirm the comment.<p>[0] <a href="https:&#x2F;&#x2F;www.logicallyfallacious.com&#x2F;logicalfallacies&#x2F;Poisoning-the-Well" rel="nofollow">https:&#x2F;&#x2F;www.logicallyfallacious.com&#x2F;logicalfallacies&#x2F;Poisoni...</a></div><br/></div></div></div></div><div id="40173356" class="c"><input type="checkbox" id="c-40173356" checked=""/><div class="controls bullet"><span class="by">lastgeniusua</span><span>|</span><a href="#40172490">prev</a><span>|</span><a href="#40178081">next</a><span>|</span><label class="collapse" for="c-40173356">[-]</label><label class="expand" for="c-40173356">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The most fundamental issue is that the borrow checker forces a refactor at the most inconvenient times. Rust users consider this to be a positive, because it makes them &quot;write good code&quot;, but the more time I spend with the language the more I doubt how much of this is true. Good code is written by iterating on an idea and trying things out, and while the borrow checker can force more iterations, that does not mean that this is a desirable way to write code. I&#x27;ve often found that being unable to just move on for now and solve my problem and fix it later was what was truly hurting my ability to write good code.<p>The latter part of this is true for any strongly statically typed language (with Rust expanding this to lifetimes), which negates the beginning of this paragraph -- once you get things compiled, you won&#x27;t need to refactor, unless you are changing major parts of your interfaces. There are plenty of languages that do not have this problem because it is a design choice, hardly something Rust can &quot;fix&quot;, it&#x27;s what makes it Rust.</div><br/><div id="40176332" class="c"><input type="checkbox" id="c-40176332" checked=""/><div class="controls bullet"><span class="by">lugu</span><span>|</span><a href="#40173356">parent</a><span>|</span><a href="#40176189">next</a><span>|</span><label class="collapse" for="c-40176332">[-]</label><label class="expand" for="c-40176332">[2 more]</label></div><br/><div class="children"><div class="content">The author is asking for a &quot;give me a break&quot; feature. I would say that in a strongly typed functional language, this is akin to mutating objects. The author seems to wish for an unsafe option to locally turn off the borrower check. Is it something Rust could not offer?</div><br/><div id="40177280" class="c"><input type="checkbox" id="c-40177280" checked=""/><div class="controls bullet"><span class="by">aapoalas</span><span>|</span><a href="#40173356">root</a><span>|</span><a href="#40176332">parent</a><span>|</span><a href="#40176189">next</a><span>|</span><label class="collapse" for="c-40177280">[-]</label><label class="expand" for="c-40177280">[1 more]</label></div><br/><div class="children"><div class="content">You can always dip into raw pointers and come back up for a reference, or eg. do a transmute to a static lifetime. Absolutely not okay according to the language rules but it will compile and will probably also run without an issue if you&#x27;re not doing something wrong in your code (eg. Wanting to keep a reference to a string while you also mutate it.)<p>I&#x27;m actually surprised that the author didn&#x27;t seem to consider this much of an option.</div><br/></div></div></div></div><div id="40176189" class="c"><input type="checkbox" id="c-40176189" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40173356">parent</a><span>|</span><a href="#40176332">prev</a><span>|</span><a href="#40178081">next</a><span>|</span><label class="collapse" for="c-40176189">[-]</label><label class="expand" for="c-40176189">[1 more]</label></div><br/><div class="children"><div class="content">This is the opposite of my experience with other strongly typed languages. They&#x27;re easier to refactor, because when you change the types, say you delete a field, everywhere that field was used is a compile error. Clean them up and on your way.<p>The borrow checker is an entirely different beast. People forget that safe Rust allows a subset of programs. Finding the subset which does what you want can range from easy, to hair-pullingly gnarly, to provably impossible.</div><br/></div></div></div></div><div id="40178081" class="c"><input type="checkbox" id="c-40178081" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#40173356">prev</a><span>|</span><a href="#40173454">next</a><span>|</span><label class="collapse" for="c-40178081">[-]</label><label class="expand" for="c-40178081">[1 more]</label></div><br/><div class="children"><div class="content">There are vanishingly few reasons why anyone wouldn&#x27;t use a garbage collected language in modern software. I think a lot of the people using rust haven&#x27;t realised how much this limits its utility. As a result of this, the language has been presented as much more widely applicable than it actually is.</div><br/></div></div><div id="40173454" class="c"><input type="checkbox" id="c-40173454" checked=""/><div class="controls bullet"><span class="by">mikhmha</span><span>|</span><a href="#40178081">prev</a><span>|</span><a href="#40172711">next</a><span>|</span><label class="collapse" for="c-40173454">[-]</label><label class="expand" for="c-40173454">[3 more]</label></div><br/><div class="children"><div class="content">Interesting read! If I had not picked Elixir + Godot for the multiplayer game I&#x27;m making, then I would&#x27;ve gone with Rust for the whole thing. The old naive version of me would&#x27;ve tried doing it in C++ + Unreal but I knew better this time around.<p>I think multiplayer game devs are sleeping on Elixir! It has made the network side of things so much easier and intuitive with fast prototyping and built in monitoring - so many lifetime issues are easily found and addressed. I&#x27;m pairing Elixir with Godot, Godot is used for the frontend game client. And its crazy because I thought the game client part would be the &quot;hard&quot; part as it would be a new skillset to learn, but Godot makes the actual game part very easy. GDScript is easy to learn, and the way Godot uses &quot;signals&quot; is very similar to the backend code in Elixir with message passing so its not a huge cognitive shift to switch between server&#x2F;client code.<p>I get that BEAM doesn&#x27;t lend well to highly computational tasks, but I just don&#x27;t see how thats an issue for many types of multiplayer games? If you aren&#x27;t making some crazy simulation game, then most of the backend computation is more around managing client state and doing &quot;accounting&quot; every tick as inputs are processed. The most computational task I&#x27;ve had is server-side NPC Pathfinding, which I was able to quickly offload onto seperate processes that chug along at their own rhythm.</div><br/><div id="40175638" class="c"><input type="checkbox" id="c-40175638" checked=""/><div class="controls bullet"><span class="by">daelon</span><span>|</span><a href="#40173454">parent</a><span>|</span><a href="#40172711">next</a><span>|</span><label class="collapse" for="c-40175638">[-]</label><label class="expand" for="c-40175638">[2 more]</label></div><br/><div class="children"><div class="content">I would love to read more about these Godot&#x2F;Elixir adventures. Do you have a blog or a repo I could look through?</div><br/><div id="40176785" class="c"><input type="checkbox" id="c-40176785" checked=""/><div class="controls bullet"><span class="by">mikhmha</span><span>|</span><a href="#40173454">root</a><span>|</span><a href="#40175638">parent</a><span>|</span><a href="#40172711">next</a><span>|</span><label class="collapse" for="c-40176785">[-]</label><label class="expand" for="c-40176785">[1 more]</label></div><br/><div class="children"><div class="content">No blog unfortunately, the notes are all on paper. I have github page for the game where I ramble a bit: <a href="https:&#x2F;&#x2F;github.com&#x2F;mikhmha&#x2F;SWARMMO">https:&#x2F;&#x2F;github.com&#x2F;mikhmha&#x2F;SWARMMO</a><p>But I&#x27;m planning to release the game for testing next month! Its a browser &quot;MMO&quot; game too so its going to be easy to try out. And then I&#x27;ll have time to write some more detailed technical notes online.</div><br/></div></div></div></div></div></div><div id="40172711" class="c"><input type="checkbox" id="c-40172711" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#40173454">prev</a><span>|</span><a href="#40173917">next</a><span>|</span><label class="collapse" for="c-40172711">[-]</label><label class="expand" for="c-40172711">[29 more]</label></div><br/><div class="children"><div class="content">In my experience, fundamentally when you&#x27;re starting a software project, you need to make a strong up-front decision between two things:<p>1. I am using technology in order to build this thing.<p>2. I am building this thing in order to use this technology.<p>Developers often fall in the (2) camp but don&#x27;t admit it. There&#x27;s an allure to using the new, sexy tech that will solve all their problems, whether that&#x27;s Rust, Kubernetes, LLMs, etc.<p>If you&#x27;re in the (1) camp, you should stick with what you know; and if you know that what you know isn&#x27;t enough to build the thing, you should use whatever is most common and straightforward, not something off the beaten path.<p>Games seem to be the biggest trap, because solo devs often end up building a game <i>engine</i> when they set out to build a game. If you really want to build a game, just use Unity&#x2F;Unreal&#x2F;Godot, I promise it&#x27;ll go better for you.</div><br/><div id="40172854" class="c"><input type="checkbox" id="c-40172854" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#40172711">parent</a><span>|</span><a href="#40172863">next</a><span>|</span><label class="collapse" for="c-40172854">[-]</label><label class="expand" for="c-40172854">[16 more]</label></div><br/><div class="children"><div class="content">I know rust, I don&#x27;t know game development (I&#x27;ve dabbled slightly). If I choose to build a game I either need to make it work in rust* or I need to learn a new language (Unity -&gt; C#, Unreal -&gt; blueprints, Godot -&gt; gdscript).<p>So your advice to &quot;just use Unity&#x2F;Unreal&#x2F;Godot&quot; is the opposite of your advice &quot;you should stick with what you know&quot; in my case. I suspect the former is good advice, and the latter is therefore wrong.<p>* For the sake of argument, we can pretend I only know rust. In reality I know a fair number of other languages as well, but the list doesn&#x27;t happen to include C# or &quot;random game engine specific scripting language&quot;, which seems to be the options if we&#x27;re going with an established engine for big 3d games.</div><br/><div id="40173116" class="c"><input type="checkbox" id="c-40173116" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40172854">parent</a><span>|</span><a href="#40173211">next</a><span>|</span><label class="collapse" for="c-40173116">[-]</label><label class="expand" for="c-40173116">[2 more]</label></div><br/><div class="children"><div class="content">This falls in the &quot;you know that what you know isn&#x27;t enough to build the thing&quot; bucket, presumably. Even if you&#x27;re a Rust expert, do you know how to manage game asset content pipelines? Sound and music? Have you done graphics programming at all in Rust? How are you going to store levels in your game, and how are you going to make them? How are you doing multiplayer? etc...<p>You&#x27;re going to have to learn something new, and it&#x27;s a bit of a judgment call, but picking up C# or gdscript given that you already know programming should be straightforward compared to re-implementing all of those things yourself in Rust.<p>Unless, of course, you <i>do</i> know a bunch of great Rust game development libraries that solve all those problems--in which case yeah, building a game in Rust might be the best choice. It&#x27;s not impossible!</div><br/><div id="40173548" class="c"><input type="checkbox" id="c-40173548" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40173116">parent</a><span>|</span><a href="#40173211">next</a><span>|</span><label class="collapse" for="c-40173548">[-]</label><label class="expand" for="c-40173548">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but picking up C# or gdscript given that you already know programming should be straightforward compared to re-implementing all of those things yourself in Rust.<p>Right, this is practically my point. I suspect that the tools available from those languages mean that learning one of them would more than pay for itself in the course of developing a (single) game. Many many times over really.<p>Like, yes, I&#x27;ve dealt with both sound, basic graphics programming (though I&#x27;d need to learn a bit more to make a modern looking 3d game), networking, ... in rust. If I had to program my sound system and graphics engine from scratch myself I&#x27;d do it in rust (and I believe I&#x27;d be more productive in rust than I&#x27;d be in &lt;other language&gt; while doing so). But I don&#x27;t have to do everything from scratch, and the best not-from-scratch versions aren&#x27;t in rust, and the cost of switching <i>to something I don&#x27;t know</i> just isn&#x27;t that high.<p>Also OP is definitely right that rust has some anti-features that would be pain points for game development.</div><br/></div></div></div></div><div id="40173211" class="c"><input type="checkbox" id="c-40173211" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40172854">parent</a><span>|</span><a href="#40173116">prev</a><span>|</span><a href="#40176979">next</a><span>|</span><label class="collapse" for="c-40173211">[-]</label><label class="expand" for="c-40173211">[11 more]</label></div><br/><div class="children"><div class="content">Perhaps the more appropriate advice is : Use the right tool for the job.<p>Use C++ for writing a high performance library or a database engine.<p>Use Go or Java for writing a server.<p>Use C for writing a kernel module.<p>Use shell scripts for automation.<p>Use python for trying out ML ideas or heavier duty scripts.<p>Use Rust for ... I&#x27;m not quite sure what it&#x27;s the right tool for yet. I suspect it&#x27;s trying to become the right tool for all of the above and not succeeding much in practice.</div><br/><div id="40174666" class="c"><input type="checkbox" id="c-40174666" checked=""/><div class="controls bullet"><span class="by">Wazako</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40173211">parent</a><span>|</span><a href="#40174810">next</a><span>|</span><label class="collapse" for="c-40174666">[-]</label><label class="expand" for="c-40174666">[3 more]</label></div><br/><div class="children"><div class="content">Use Rust if crashes or memory bugs are not an option.
For everything wasm, Rust is much more pleasant with good libraries than the competition.</div><br/><div id="40175160" class="c"><input type="checkbox" id="c-40175160" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40174666">parent</a><span>|</span><a href="#40174810">next</a><span>|</span><label class="collapse" for="c-40175160">[-]</label><label class="expand" for="c-40175160">[2 more]</label></div><br/><div class="children"><div class="content">Wasm seems more convincing to me than the magical &#x27;no crashes or bugs&#x27; promise.<p>Here&#x27;s my wasm use case: tell me how I can use Rust.<p>I have a command line tool written in C that ..say.. takes strings and outputs strings.<p>How would I go about making a usable REPL out of this in Rust and wasm without rewriting the tool?</div><br/><div id="40175377" class="c"><input type="checkbox" id="c-40175377" checked=""/><div class="controls bullet"><span class="by">Wazako</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40175160">parent</a><span>|</span><a href="#40174810">next</a><span>|</span><label class="collapse" for="c-40175377">[-]</label><label class="expand" for="c-40175377">[1 more]</label></div><br/><div class="children"><div class="content">But when you look at the disaster that was c++ for cloudflare, and the switch to rust.<p>This is precisely the argument given against rust for video games: too much typing induced by memory safe, which is too restrictive.<p>Is there any use if your c code works, the advantage of rust over wasm is the easy-to-use packages (which is a pain in c++), and the ease with which you can make a wasm project with wasm-pack that generates the wasm, js and ts interface.<p>There really are a lot of libraries that support wasm, it&#x27;s even a problematic point raised in the article on bevy, with wasm support (so webgl) limiting the api.</div><br/></div></div></div></div></div></div><div id="40174810" class="c"><input type="checkbox" id="c-40174810" checked=""/><div class="controls bullet"><span class="by">tkubacki</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40173211">parent</a><span>|</span><a href="#40174666">prev</a><span>|</span><a href="#40176979">next</a><span>|</span><label class="collapse" for="c-40174810">[-]</label><label class="expand" for="c-40174810">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s C++ replacement just not yet there for game dev (maybe never for game dev)</div><br/><div id="40175124" class="c"><input type="checkbox" id="c-40175124" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40174810">parent</a><span>|</span><a href="#40176979">next</a><span>|</span><label class="collapse" for="c-40175124">[-]</label><label class="expand" for="c-40175124">[6 more]</label></div><br/><div class="children"><div class="content">A C++ replacement must have really strong and seamless C++ interop to be considered by anyone currently using C++. You can&#x27;t have a C++ replacement by ignoring existing C++ users and libraries, no matter how good the the language is.<p>Swift from Apple and Carbon from Google are stronger contenders at this point.</div><br/><div id="40175443" class="c"><input type="checkbox" id="c-40175443" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40175124">parent</a><span>|</span><a href="#40176979">next</a><span>|</span><label class="collapse" for="c-40175443">[-]</label><label class="expand" for="c-40175443">[5 more]</label></div><br/><div class="children"><div class="content">No language from Apple &#x2F; Google &#x2F; Microsoft &#x2F; whatever can ever be a serious replacement for C++. When the development of the language is dominated by a single entity, the risk that the interests of that entity override those of other users is simply too high.<p>Vendor-specific languages are fine, if you are developing something for that vendor&#x27;s ecosystem. But if you don&#x27;t want to lock your code to a specific ecosystem, an independent language such as C++ or Rust is a better choice.</div><br/><div id="40178201" class="c"><input type="checkbox" id="c-40178201" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40175443">parent</a><span>|</span><a href="#40175766">next</a><span>|</span><label class="collapse" for="c-40178201">[-]</label><label class="expand" for="c-40178201">[1 more]</label></div><br/><div class="children"><div class="content">C++ is only independent on the surface, as all the big players seat at WG21, and it goes where their votes say it goes, plus what actually gets implemented into compilers (none of them is 100% ISO compliant, each one has minor compliance issues).<p>Same applies to C, stuff like C23 is decided by who gets to join WG14.<p>In both cases, someone has to buy the final standard from ISO.</div><br/></div></div><div id="40175766" class="c"><input type="checkbox" id="c-40175766" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40175443">parent</a><span>|</span><a href="#40178201">prev</a><span>|</span><a href="#40176979">next</a><span>|</span><label class="collapse" for="c-40175766">[-]</label><label class="expand" for="c-40175766">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree.<p>Pragmatic considerations tend to win over ideological ones though.<p>Consider Java&#x27;s success.</div><br/><div id="40176285" class="c"><input type="checkbox" id="c-40176285" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40175766">parent</a><span>|</span><a href="#40176979">next</a><span>|</span><label class="collapse" for="c-40176285">[-]</label><label class="expand" for="c-40176285">[2 more]</label></div><br/><div class="children"><div class="content">I was thinking more about pragmatic issues, and Java is a good example of them. It&#x27;s a widely used language, but it&#x27;s also a huge failure.<p>25 years ago, Java was supposed to be the new general-purpose language you could use for everything. Universities rushed to teach it to everyone. There was a lot of initial success, but then Java started losing ground. The direction the language was going was not good for many applications. And then lawyers got involved, which didn&#x27;t help.<p>C++ is a general-purpose language. It&#x27;s widely used, because it&#x27;s widely used. The language is good enough for many tasks, and you can probably find the libraries you need and people familiar with the language. If you work in a niche with no specific reasons to use a particular language, C++ is often a good choice.<p>Rust is not there yet, because it&#x27;s a new language with limited library support. But it does have momentum. The biggest threat to Rust as a general-purpose language is probably async. When there are strong interests to develop the language and the ecosystem for specific applications, other niches often suffer.</div><br/><div id="40178216" class="c"><input type="checkbox" id="c-40178216" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40176285">parent</a><span>|</span><a href="#40176979">next</a><span>|</span><label class="collapse" for="c-40178216">[-]</label><label class="expand" for="c-40178216">[1 more]</label></div><br/><div class="children"><div class="content">Powering 80% of the mobile phone market, Amazon infrastructure, the IDEs everyone around here likes to rave about, is good enough success.<p>Additionally, everyone and their dog seems keen in replicating Java application servers with Kubernetes and WASM.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40176979" class="c"><input type="checkbox" id="c-40176979" checked=""/><div class="controls bullet"><span class="by">sullyj3</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40172854">parent</a><span>|</span><a href="#40173211">prev</a><span>|</span><a href="#40172863">next</a><span>|</span><label class="collapse" for="c-40176979">[-]</label><label class="expand" for="c-40176979">[2 more]</label></div><br/><div class="children"><div class="content">Learning a new language is basically trivial relative to the effort of bootstrapping everything yourself to compensate for a lacking ecosystem, or the effort of banging your head against the fundamental unsuitability of a tool for a job.<p>Anyone who&#x27;s learned one or two languages should be able to pick up the basics of any of the standard ones pretty much instantaneously.</div><br/><div id="40177216" class="c"><input type="checkbox" id="c-40177216" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40176979">parent</a><span>|</span><a href="#40172863">next</a><span>|</span><label class="collapse" for="c-40177216">[-]</label><label class="expand" for="c-40177216">[1 more]</label></div><br/><div class="children"><div class="content">Exactly</div><br/></div></div></div></div></div></div><div id="40172863" class="c"><input type="checkbox" id="c-40172863" checked=""/><div class="controls bullet"><span class="by">danbolt</span><span>|</span><a href="#40172711">parent</a><span>|</span><a href="#40172854">prev</a><span>|</span><a href="#40172971">next</a><span>|</span><label class="collapse" for="c-40172863">[-]</label><label class="expand" for="c-40172863">[3 more]</label></div><br/><div class="children"><div class="content">When all you have is a hammer, everything looks like a nail. When all you have is programming expertise, all your game production obstacles look like programming problems.<p>I think everyone in games has met an “engine person” who spends a lot of time iterating on tech, but never quite getting to the creative expression that got them in the game. I think part of it comes a bit from mythologizing breakthrough games like <i>DOOM</i>, where cool technology made something completely fresh. We begin to think that emulating id Software is how you make compelling art, ignoring the latter half of Kushner’s novel.</div><br/><div id="40173549" class="c"><input type="checkbox" id="c-40173549" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40172863">parent</a><span>|</span><a href="#40172971">next</a><span>|</span><label class="collapse" for="c-40173549">[-]</label><label class="expand" for="c-40173549">[2 more]</label></div><br/><div class="children"><div class="content">Well said, I am weary of all the &#x27;game&#x27; programmers that just fetishize working on the tech and particularly rendering.</div><br/><div id="40175144" class="c"><input type="checkbox" id="c-40175144" checked=""/><div class="controls bullet"><span class="by">georgeecollins</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40173549">parent</a><span>|</span><a href="#40172971">next</a><span>|</span><label class="collapse" for="c-40175144">[-]</label><label class="expand" for="c-40175144">[1 more]</label></div><br/><div class="children"><div class="content">People like to program on tasks that aren&#x27;t given to them, to practice their craft in a less restricted form than professional life usually allows.  So they make things for themselves and its natural that those things are what they are familiar with and enjoy.  So you often meet the programmer, almost never from the game industry, who wants to make his or her own game engine.  It&#x27;s about as likely to be a productive endeavor as making your own spreadsheet program.</div><br/></div></div></div></div></div></div><div id="40172971" class="c"><input type="checkbox" id="c-40172971" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#40172711">parent</a><span>|</span><a href="#40172863">prev</a><span>|</span><a href="#40173804">next</a><span>|</span><label class="collapse" for="c-40172971">[-]</label><label class="expand" for="c-40172971">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you need to make a strong up-front decision<p>Can one always realistically do so? I suspect the underlying unspoken assumption is that one must be ideally informed about all the possible potential pitfalls and gotchas they may face when using any given technology. Aka having a very good (ideally, perfect) knowledge of the technology and its surrounding ecosystem.<p>It wasn&#x27;t just once or twice when I&#x27;ve picked some very promising library or tool only to learn something isn&#x27;t exactly as I hoped (or as it was advertised - docs can lie, too) after I&#x27;ve already spent some non-negligible time implementing something with it. Save for some teenage keyboard mashing some decades ago I&#x27;m not a game developer, but I suspect this is universal experience no matter the niche.<p>&gt; Developers often fall in the (2) camp but don&#x27;t admit it.<p>There&#x27;s also a mixed approach, where people admit &quot;I want to build this thing and use this technology, and I suspect they&#x27;re a potential good match so I&#x27;m gonna try both at the same time&quot;. Any even slightly creative person must have an urge to learn and explore new things, even if they aren&#x27;t exactly <i>necessary</i> for a task at hand. Checking on the promise, if it holds true - sometimes it does and you get a new tech you love, quite frequently it doesn&#x27;t and you have a bad day.</div><br/><div id="40173763" class="c"><input type="checkbox" id="c-40173763" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40172971">parent</a><span>|</span><a href="#40173804">next</a><span>|</span><label class="collapse" for="c-40173763">[-]</label><label class="expand" for="c-40173763">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can one always realistically do so? I suspect the underlying unspoken assumption is that one must be ideally informed about all the possible potential pitfalls and gotchas they may face when using any given technology. Aka having a very good (ideally, perfect) knowledge of the technology and its surrounding ecosystem.<p>Exactly. You need to make some choices up front about program design despite rarely having enough information to make the correct decision, nor enough time to evaluate alternatives in detail.  If we had known 15 years ago what we know now our then green field project wouldn&#x27;t have been done this way - but we are still discovering things that the decisions we made 15 years ago are making hard to do today.  That is on top of all the existing things we know are wrong that we often cannot feasibly correct.<p>You have to make choices. Some of those choices will be impossible to undo without starting over after a while. Some of the negatives will take a decade to figure out. There is no way anyone sane will give you enough time to figure out what those negatives are for each choice - even if the did you will be dead before you finish.</div><br/></div></div></div></div><div id="40173804" class="c"><input type="checkbox" id="c-40173804" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40172711">parent</a><span>|</span><a href="#40172971">prev</a><span>|</span><a href="#40172918">next</a><span>|</span><label class="collapse" for="c-40173804">[-]</label><label class="expand" for="c-40173804">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m in the 1 camp.  After several decades of C++ I know it very well. Well enough to find some of the things that those Rust and Ada people are saying about their respective languages intriguing. I&#x27;m at the point where I need to spend some time with each to see how&#x2F;if they work with my problems in the real world.  Because eventually you have to admit that while you can drive a screw with a hammer there are other ways and maybe it is time to learn how to use a screwdriver.</div><br/></div></div><div id="40172918" class="c"><input type="checkbox" id="c-40172918" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#40172711">parent</a><span>|</span><a href="#40173804">prev</a><span>|</span><a href="#40173267">next</a><span>|</span><label class="collapse" for="c-40172918">[-]</label><label class="expand" for="c-40172918">[1 more]</label></div><br/><div class="children"><div class="content">This is what I like to call the artist vs engineer dilemma.<p>1. An engineer solves problems, learning and using tools.
2. And artist learns and uses tools, for the sake of it.<p>Neither is wrong, and some times they benefit each other. I believe much of academia and research is heavy on the artist side. You just have to be clear on which one you are at any given point.<p>I&#x27;m not gonna use assembly for my $JOB where we need some basic web backend. That&#x27;s not gonna stop me from trying on my free time tho.</div><br/></div></div><div id="40173267" class="c"><input type="checkbox" id="c-40173267" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#40172711">parent</a><span>|</span><a href="#40172918">prev</a><span>|</span><a href="#40173157">next</a><span>|</span><label class="collapse" for="c-40173267">[-]</label><label class="expand" for="c-40173267">[1 more]</label></div><br/><div class="children"><div class="content">How about &quot;I&#x27;m building this thing and I want it to enjoy the unique combination of performance and memory safety offered by this technology&quot;?<p>It&#x27;s certainly close to (1), but also a perfectly rational way to be a The Rust Way fundamentalist avoiding refcounting and unsafe who appears suspiciously (2).<p>The &quot;rewrite in Rust&quot; meme surely does not come from thin air and there is certainly some skill honing and challenge seeking involved. But perhaps a rewrite ever couple of decades isn&#x27;t all that bad? And if it isn&#x27;t, could there be a better time for it than &quot;in Rust&quot;?</div><br/></div></div><div id="40173157" class="c"><input type="checkbox" id="c-40173157" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#40172711">parent</a><span>|</span><a href="#40173267">prev</a><span>|</span><a href="#40173200">next</a><span>|</span><label class="collapse" for="c-40173157">[-]</label><label class="expand" for="c-40173157">[3 more]</label></div><br/><div class="children"><div class="content">Advice should be - you should do what you like and try to align it with your client (employer) - otherwise you&#x27;ll burnout rather quickly.</div><br/><div id="40173183" class="c"><input type="checkbox" id="c-40173183" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40173157">parent</a><span>|</span><a href="#40173200">next</a><span>|</span><label class="collapse" for="c-40173183">[-]</label><label class="expand" for="c-40173183">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not easy to find an employer that&#x27;ll agree with your preferences. I chose to find fun and value in the way I collaborate and reach end goals, not the tools. If the tooling in my dept sucks, I just treat it like a challenge and deal with it.</div><br/><div id="40174028" class="c"><input type="checkbox" id="c-40174028" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#40172711">root</a><span>|</span><a href="#40173183">parent</a><span>|</span><a href="#40173200">next</a><span>|</span><label class="collapse" for="c-40174028">[-]</label><label class="expand" for="c-40174028">[1 more]</label></div><br/><div class="children"><div class="content">Healthy.</div><br/></div></div></div></div></div></div></div></div><div id="40173917" class="c"><input type="checkbox" id="c-40173917" checked=""/><div class="controls bullet"><span class="by">cshenton</span><span>|</span><a href="#40172711">prev</a><span>|</span><a href="#40172901">next</a><span>|</span><label class="collapse" for="c-40173917">[-]</label><label class="expand" for="c-40173917">[2 more]</label></div><br/><div class="children"><div class="content">My experience is that the ecosystem is a mess, have hit winit, wgpu, and countless bevy bugs, iteration times are abysmal, documentation is nonexistent. In the time it would take me to make a game in popular Rust tooling I could build the game and engine from scratch in C and also have something that would crash less.</div><br/><div id="40176484" class="c"><input type="checkbox" id="c-40176484" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#40173917">parent</a><span>|</span><a href="#40172901">next</a><span>|</span><label class="collapse" for="c-40176484">[-]</label><label class="expand" for="c-40176484">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; documentation is nonexistent</i><p>You know, I think this point is important to get right: there <i>are</i> generally docs, Rust does a very good job of making it easy to write docs.<p>What <i>doesn&#x27;t</i> always exist are <i>guides</i> that explain how to piece things together. Sometimes you wind up needing to really know the inner platform to piece together things in Rust, and while I love the language, this is one area where the community could improve.</div><br/></div></div></div></div><div id="40172901" class="c"><input type="checkbox" id="c-40172901" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#40173917">prev</a><span>|</span><a href="#40173555">next</a><span>|</span><label class="collapse" for="c-40172901">[-]</label><label class="expand" for="c-40172901">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   By the time the Rust developer is finished with their refactoring, the C++&#x2F;C#&#x2F;Java&#x2F;JavaScript developer has implemented many different gameplay features, played the game a bunch and tried them all out, and has a better understanding of which direction should their game be taking.
</code></pre>
Man, slower than C++, that&#x27;s pretty damning.</div><br/></div></div><div id="40173555" class="c"><input type="checkbox" id="c-40173555" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#40172901">prev</a><span>|</span><a href="#40172590">next</a><span>|</span><label class="collapse" for="c-40173555">[-]</label><label class="expand" for="c-40173555">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve experienced a lot of these concerns while building <a href="https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;symbiants">https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;symbiants</a><p>I have a simple question that maybe someone smarter than me can answer confidently:<p>If I want to build something akin to Dwarf Fortress (in terms of simulation complexity) as a browser-first experience - what stack should I choose?<p>Originally, I prototyped something out using React, PixiJS, and ReactPixi (<a href="https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;antfarm">https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;antfarm</a>). The two main issues I ran into were the performance of React&#x27;s reconciler processing tens of thousands of entities when most weren&#x27;t changing (despite heavy memoization) and GC lurching due to excess object allocations. My takeaway was that if I wanted to continue writing in JS&#x2F;TS that I would need to write non-idiomatic code to avoid excess allocations and abandon React. This approach would result in me effectively creating my own engine to manage state.<p>I decided to not go that direction. I chose Rust because no GC is a language feature (especially good since GCs in WASM are heavy) and I chose Bevy because it seemed like a fairly structured way to mutate a large amount of code.<p>Progress has been slow for a lot of the reasons listed in this article. I&#x27;ve written a lot of this off to WASM being a new frontier for game dev, and I&#x27;m new to Rust&#x2F;Bevy&#x2F;ECS&#x2F;gamedev, and rationalized my effort by noting there&#x27;s not a lot of complex simulation games running in browser (that I&#x27;m aware of).<p>It&#x27;s not clear to me that I&#x27;ve made the right decision, and just need to take the good with the bad, in order to develop the type of game I want in the type of environment I want.</div><br/><div id="40177279" class="c"><input type="checkbox" id="c-40177279" checked=""/><div class="controls bullet"><span class="by">valcron1000</span><span>|</span><a href="#40173555">parent</a><span>|</span><a href="#40173909">next</a><span>|</span><label class="collapse" for="c-40177279">[-]</label><label class="expand" for="c-40177279">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re targeting the browser first why not use a browser first library like PhaserJS [0]?. I don&#x27;t see a reason to work around with WASM; HTML5 canvas might be everything that you need.<p>[0] <a href="https:&#x2F;&#x2F;phaser.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;phaser.io&#x2F;</a></div><br/><div id="40177384" class="c"><input type="checkbox" id="c-40177384" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#40173555">root</a><span>|</span><a href="#40177279">parent</a><span>|</span><a href="#40173909">next</a><span>|</span><label class="collapse" for="c-40177384">[-]</label><label class="expand" for="c-40177384">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m aware of Phaser and evaluated it, but didn&#x27;t try prototyping something out using it.<p>My primary concerns were: lack of <i>any</i> coherent plan towards supporting WebGPU, TS bindings being best effort rather than being written natively in TS, and, crucially, Phaser4 being stuck in development hell.<p>Phaser 4 was announced in 2019, <a href="https:&#x2F;&#x2F;www.patreon.com&#x2F;posts&#x2F;28467752" rel="nofollow">https:&#x2F;&#x2F;www.patreon.com&#x2F;posts&#x2F;28467752</a>, and hasn&#x27;t shipped. Current version on GitHub is v3.8. It made me deeply uncomfortable planning to build ontop of an engine that&#x27;s stalled out for 5 years. I would not reasonably expect to be given support for WebGPU ever and I strongly feel that WebGPU is going to be the defining way web games are written in the coming year(s).<p>I also wasn&#x27;t able to find any super compelling games written using Phaser. Since I evaluated it, it appears that Vampire Survivors was written using it, but then they abandoned Phaser and adopted Unity in v1.6.</div><br/></div></div></div></div><div id="40173909" class="c"><input type="checkbox" id="c-40173909" checked=""/><div class="controls bullet"><span class="by">unclad5968</span><span>|</span><a href="#40173555">parent</a><span>|</span><a href="#40177279">prev</a><span>|</span><a href="#40172590">next</a><span>|</span><label class="collapse" for="c-40173909">[-]</label><label class="expand" for="c-40173909">[1 more]</label></div><br/><div class="children"><div class="content">I personally would use C++ with SDL2, but I use c++ a lot already so I&#x27;m biased. Emscripten would allow you to target WASM.</div><br/></div></div></div></div><div id="40172590" class="c"><input type="checkbox" id="c-40172590" checked=""/><div class="controls bullet"><span class="by">tormeh</span><span>|</span><a href="#40173555">prev</a><span>|</span><a href="#40172316">next</a><span>|</span><label class="collapse" for="c-40172590">[-]</label><label class="expand" for="c-40172590">[12 more]</label></div><br/><div class="children"><div class="content">Gaming is C++ first and foremost. All other languages suck, except when used to script game engines (C# in Unity, etc.). There&#x27;s no practical reason to choose Rust or anything else. I don&#x27;t think Rust is particularly bad or good here. There&#x27;s decades of work to catch up on. I don&#x27;t see Rust becoming a truly great language for games unless it&#x27;s blessed by Epic or Unity.</div><br/><div id="40173421" class="c"><input type="checkbox" id="c-40173421" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40172590">parent</a><span>|</span><a href="#40173395">next</a><span>|</span><label class="collapse" for="c-40173421">[-]</label><label class="expand" for="c-40173421">[10 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s decades of work to catch up on<p>First you gotta get OpenGL going, with its horrible stateful API, give up on it and go to DirectX9.  Do a complete rewrite when DirectX10 comes out.  Get your real-time lighting happening with shadow volumes, run into patent issues and get strong-armed into putting Creative sound into your game.  Cycle between GLSL, HLSL, and Cg.  End up switching to shadow mapping anyway.  Drop Linux and Mac support.  Start over with Vulkan&#x2F;Metal.<p>I don&#x27;t think Rust needs to relive most of that.</div><br/><div id="40173787" class="c"><input type="checkbox" id="c-40173787" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40173421">parent</a><span>|</span><a href="#40173395">next</a><span>|</span><label class="collapse" for="c-40173787">[-]</label><label class="expand" for="c-40173787">[9 more]</label></div><br/><div class="children"><div class="content">Exactly. Bevy has the advantage of being built using the &quot;right way&quot; from the start. This makes an enormous difference in the ease of hacking on rendering code.<p>Ironically, the main thing holding Bevy back is the bickering at the W3C. WebGPU is <i>still</i> not widely supported, so we have to support WebGL 2 (with reduced functionality in some cases), and that adds a lot of complexity.</div><br/><div id="40175065" class="c"><input type="checkbox" id="c-40175065" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40173787">parent</a><span>|</span><a href="#40175329">next</a><span>|</span><label class="collapse" for="c-40175065">[-]</label><label class="expand" for="c-40175065">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Bevy has the advantage of being built using the &quot;right way&quot; from the start<p>I think the article is precisely criticizing this type of comment... You make people believe that Bevy is some kind of safe bet for the future, that it took inspiration from the greatest to build even better foundations for a game engine... And it seems common in the Rust community: make audacious unverifiable claims to enroll other &quot;believers&quot;. But it&#x27;s easy to claim when the tool itself has a fraction of the functionalities of Unreal, Unity or Even Godot. Heck, last time I used it (about 2 years ago) there wasn&#x27;t even any built-in physics stuff. You have to install plugins from every corner, some require old Bevy versions, some other require newer versions... It&#x27;s seriously unusable to just &quot;get things done&quot;</div><br/><div id="40176193" class="c"><input type="checkbox" id="c-40176193" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40175065">parent</a><span>|</span><a href="#40175164">next</a><span>|</span><label class="collapse" for="c-40176193">[-]</label><label class="expand" for="c-40176193">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anyone ever claimed that Bevy is finished.<p>As for audacious unverifiable claims: it&#x27;s quite verifiable that Bevy never used DirectX 9, DirectX 10, shadow volumes, HLSL, Cg, Vulkan, or Metal (I&#x27;m not sure about OpenGL or GLSL; those were before I got involved with the project). It chose the better path (wgpu) early on. That&#x27;s all I was saying.</div><br/><div id="40178444" class="c"><input type="checkbox" id="c-40178444" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40176193">parent</a><span>|</span><a href="#40177053">next</a><span>|</span><label class="collapse" for="c-40178444">[-]</label><label class="expand" for="c-40178444">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a pro engine dev, but from what I&#x27;ve heard, the graphics backend is a minor part of what makes a good and fully-fledged game engine. I see it more as a strength than other engine can ship on older and more legacy hardware. Moreover wgpu is still in its infancy but evolving rapidly. We&#x27;ll see in the future how bevy will develop, and I really hope it works out, because I liked some of the ergonomics of the ECS when I used it, but for now I am very doubtful</div><br/></div></div><div id="40177053" class="c"><input type="checkbox" id="c-40177053" checked=""/><div class="controls bullet"><span class="by">DangitBobby</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40176193">parent</a><span>|</span><a href="#40178444">prev</a><span>|</span><a href="#40175164">next</a><span>|</span><label class="collapse" for="c-40177053">[-]</label><label class="expand" for="c-40177053">[2 more]</label></div><br/><div class="children"><div class="content">It can&#x27;t be &quot;built the right way&quot; if it isn&#x27;t finished. We actually don&#x27;t know if it can be built the right way until it is finished.</div><br/><div id="40177103" class="c"><input type="checkbox" id="c-40177103" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40177053">parent</a><span>|</span><a href="#40175164">next</a><span>|</span><label class="collapse" for="c-40177103">[-]</label><label class="expand" for="c-40177103">[1 more]</label></div><br/><div class="children"><div class="content">I have about a half dozen PRs open, plus more on the way, that will get Bevy&#x27;s renderer up to rough feature parity with Godot (Godot will have some things Bevy doesn&#x27;t, like SDFGI, and Bevy will have some things Godot doesn&#x27;t, like deferred and GPU occlusion culling). I have no doubt in my mind that Bevy&#x27;s design is solid, but if you&#x27;re skeptical, we will find out very soon :)</div><br/></div></div></div></div></div></div><div id="40175164" class="c"><input type="checkbox" id="c-40175164" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40175065">parent</a><span>|</span><a href="#40176193">prev</a><span>|</span><a href="#40175329">next</a><span>|</span><label class="collapse" for="c-40175164">[-]</label><label class="expand" for="c-40175164">[2 more]</label></div><br/><div class="children"><div class="content">Well, there are two types of game engines from what I&#x27;ve seen:<p>- One where most things are done out of the box, and you can mostly GUI visual code to success - these are your Unreals, your Unitys and Godots.<p>- Second, where most things need to be built piecemeal, and many things are missing, and need to be built - Bevy falls into this category, along with stuff like PyGame and what not.<p>I mean, Bevy is a fine engine for small things, but I can&#x27;t admit I&#x27;ve seen any indie game of more renown succeed with it. OTOH, doesn&#x27;t mean you can&#x27;t make it, but it&#x27;s definitely more effort.</div><br/><div id="40175204" class="c"><input type="checkbox" id="c-40175204" checked=""/><div class="controls bullet"><span class="by">TheRoque</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40175164">parent</a><span>|</span><a href="#40175329">next</a><span>|</span><label class="collapse" for="c-40175204">[-]</label><label class="expand" for="c-40175204">[1 more]</label></div><br/><div class="children"><div class="content">Well, I don&#x27;t call the second ones &quot;game engines&quot;, I call them game libraries, or game frameworks. RayLib also is a nice one. But they don&#x27;t claim to be &quot;engines&quot; (or at least, they are mostly described with the aforementioned terms)</div><br/></div></div></div></div></div></div><div id="40175329" class="c"><input type="checkbox" id="c-40175329" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#40172590">root</a><span>|</span><a href="#40173787">parent</a><span>|</span><a href="#40175065">prev</a><span>|</span><a href="#40173395">next</a><span>|</span><label class="collapse" for="c-40175329">[-]</label><label class="expand" for="c-40175329">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and that adds a lot of complexity.<p>Well, the example code for a simple button referenced in the article has insane complexity that has nothing to do with WebGL though. It&#x27;s precisely &quot;the right way&quot; that adds a lot of complexity.</div><br/></div></div></div></div></div></div><div id="40173395" class="c"><input type="checkbox" id="c-40173395" checked=""/><div class="controls bullet"><span class="by">qiine</span><span>|</span><a href="#40172590">parent</a><span>|</span><a href="#40173421">prev</a><span>|</span><a href="#40172316">next</a><span>|</span><label class="collapse" for="c-40173395">[-]</label><label class="expand" for="c-40173395">[1 more]</label></div><br/><div class="children"><div class="content">&gt; * I don&#x27;t see Rust becoming a truly great language for games unless it&#x27;s blessed by Epic or Unity.<p>Which will never happen</div><br/></div></div></div></div><div id="40172316" class="c"><input type="checkbox" id="c-40172316" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40172590">prev</a><span>|</span><label class="collapse" for="c-40172316">[-]</label><label class="expand" for="c-40172316">[5 more]</label></div><br/><div class="children"><div class="content">Has there been any progress towards shipping Rust on consoles? I know the specifics are all under NDA, but to my knowledge nobody has even hinted that they&#x27;ve done it yet, even among the studios which are openly using Rust for backend or tooling stuff (e.g. Embark and Treyarch).<p>OP only appears to release their games on PC so it&#x27;s not a concern for them, but for the majority of developers not being able to fit into console toolchains would be an immediate dealbreaker. I have no first hand information but what I&#x27;ve <i>heard</i> from hanging around people who would know is that Sony insists that developers only use their official LLVM&#x2F;Clang fork which is customised for their weird ABI.</div><br/><div id="40173590" class="c"><input type="checkbox" id="c-40173590" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#40172316">parent</a><span>|</span><a href="#40173610">prev</a><span>|</span><label class="collapse" for="c-40173590">[-]</label><label class="expand" for="c-40173590">[3 more]</label></div><br/><div class="children"><div class="content">Rust has had tier 3 support for the Switch since 1.64, I believe. Someone had actually done it even before that but IIRC NDAs mucked up any movement on making that public.</div><br/><div id="40173667" class="c"><input type="checkbox" id="c-40173667" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40172316">root</a><span>|</span><a href="#40173590">parent</a><span>|</span><label class="collapse" for="c-40173667">[-]</label><label class="expand" for="c-40173667">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that Switch support was added by the homebrew side of the fence though so I don&#x27;t know if it&#x27;s something that developers would be able to use in an officially licensed game. Nintendo might not care so much as long as the game works, as mentioned it&#x27;s Sony in particular that I&#x27;ve heard is picky about which compilers their developers use.</div><br/><div id="40176899" class="c"><input type="checkbox" id="c-40176899" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#40172316">root</a><span>|</span><a href="#40173667">parent</a><span>|</span><label class="collapse" for="c-40176899">[-]</label><label class="expand" for="c-40176899">[1 more]</label></div><br/><div class="children"><div class="content">Ah, good point - was context I didn&#x27;t have.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>