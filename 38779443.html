<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703667654884" as="style"/><link rel="stylesheet" href="styles.css?v=1703667654884"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rednafi.com/go/reminiscing_cgi_scripts/">Reminiscing CGI Scripts</a>Â <span class="domain">(<a href="https://rednafi.com">rednafi.com</a>)</span></div><div class="subtext"><span>signa11</span> | <span>6 comments</span></div><br/><div><div id="38779956" class="c"><input type="checkbox" id="c-38779956" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#38780060">next</a><span>|</span><label class="collapse" for="c-38779956">[-]</label><label class="expand" for="c-38779956">[2 more]</label></div><br/><div class="children"><div class="content">I would like a super lightweight host process for interpreters that is similar to php-fpm and Erlang but can have shared state for database connections but the main interpreter is not a separate process but simply a function call.<p>Serverless and WASM runtimes are similar and Firecracker are in this space.<p>It would have to be multithreaded, it could communicate with nginx via domain socket as php-fpm does. I don&#x27;t know if there&#x27;s a way to multiplex data over a domain socket, maybe you could use multiple domain sockets and load balance between them? Or custom framing.<p>Does head of line blocking come into this too?</div><br/><div id="38780197" class="c"><input type="checkbox" id="c-38780197" checked=""/><div class="controls bullet"><span class="by">rav</span><span>|</span><a href="#38779956">parent</a><span>|</span><a href="#38780060">next</a><span>|</span><label class="collapse" for="c-38780197">[-]</label><label class="expand" for="c-38780197">[1 more]</label></div><br/><div class="children"><div class="content">&gt; can have shared state for database connections but the main interpreter is not a separate process but simply a function call.<p>&gt; It would have to be multithreaded, it could communicate with nginx via domain socket as php-fpm does.<p>If we define the communication with nginx over domain socket to be HTTP&#x2F;1.1, then you have basically reinvented Rails &#x2F; Flask &#x2F; Django &#x2F; Hyper &#x2F; ... - you can define each script as a Python&#x2F;Ruby&#x2F;Rust function and everything runs in shared processes so you can cache database connections and other things if you fancy.</div><br/></div></div></div></div><div id="38780060" class="c"><input type="checkbox" id="c-38780060" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#38779956">prev</a><span>|</span><a href="#38779937">next</a><span>|</span><label class="collapse" for="c-38780060">[-]</label><label class="expand" for="c-38780060">[2 more]</label></div><br/><div class="children"><div class="content">Very interesting read, like the author I too recently went on almost that exact same journey except with Dart.<p>In my mind I was looking to do a bit of a compare and contrast exercise with a very modern solution like Envoy.</div><br/><div id="38780186" class="c"><input type="checkbox" id="c-38780186" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38780060">parent</a><span>|</span><a href="#38779937">next</a><span>|</span><label class="collapse" for="c-38780186">[-]</label><label class="expand" for="c-38780186">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been funded (with later successful exit) on the basis of a quick&#x27;n&#x27;dirty demo that merely duct-taped CGI and sendmail.</div><br/></div></div></div></div><div id="38779937" class="c"><input type="checkbox" id="c-38779937" checked=""/><div class="controls bullet"><span class="by">contingencies</span><span>|</span><a href="#38780060">prev</a><span>|</span><label class="collapse" for="c-38779937">[-]</label><label class="expand" for="c-38779937">[1 more]</label></div><br/><div class="children"><div class="content">The elegance of CGI was in generically plumbing HTTP requests through to the standard unix environment whilst facilitating arbitrary server metadata. The reason it fell out of fashion was partly the objective limitations of speed, security, and no standard method of debugging, but probably also largely because of a generational shift toward interpreted languages written by new developers largely based on and used to non-unix style systems who quite pragmatically saw the server environment as a black box and were consequently motivated to use simpler and more standard environments such as that provided by php and its extensions in lieu of tediously manually configuring every server path in every script via <i>telnet</i> (and later <i>ssh</i>). Their ISPs and web hosts, aware of the security challenges of granting unix shells to inexperienced users, encouraged this and consequently embraced tooling such as cPanel to reduce the support load for their staff and spin up users faster.<p>Having cPanel-style user instantiation and management functions then became more and more critical as IP addresses ran out and virtual hosting took hold - the amount of manual config tweaking otherwise required (vhost, database, filesystem, (s)ftp access, etc.) exceeded a rational human workload for medium sized service providers, especially those with large numbers of users spread across an array of non-uniform infrastructure.<p>By the time the &#x27;cloud&#x27; arrived, this stuff at typical ISPs and web hosts had become a mish-mash of band-aids so advanced that in hindsight we might well wonder why it took so damn long for the paradigm to shift.</div><br/></div></div></div></div></div></div></div></body></html>