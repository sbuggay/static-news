<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731229252712" as="style"/><link rel="stylesheet" href="styles.css?v=1731229252712"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mergiraf.org/">Mergiraf: a syntax-aware merge driver for Git</a> <span class="domain">(<a href="https://mergiraf.org">mergiraf.org</a>)</span></div><div class="subtext"><span>p4bl0</span> | <span>78 comments</span></div><br/><div><div id="42094842" class="c"><input type="checkbox" id="c-42094842" checked=""/><div class="controls bullet"><span class="by">DarkPlayer</span><span>|</span><a href="#42094545">next</a><span>|</span><label class="collapse" for="c-42094842">[-]</label><label class="expand" for="c-42094842">[14 more]</label></div><br/><div class="children"><div class="content">Looking at the architecture, they will probably run into some issues. We are doing something similar with SemanticDiff [1] and also started out using tree-sitter grammars for parsing and GumTree for matching. Both choices turned out to be problematic.<p>Tree sitter grammars are primarily written to support syntax highlighting and often use a best effort approach to parsing. This is perfectly fine for syntax highlighting, since the worst that can happen is that a few characters are highlighted incorrectly. However, when diffing or modifying code you really want the code to be parsed according to the upstream grammar, not something that mostly resembles it. We are currently in the process of moving away from tree-sitter and instead using the parsers provided by the languages themselves where possible.<p>GumTree is good at returning a result quickly, but there are quite a few cases where it always returned bad matches for us, no matter how many follow-up papers with improvements we tried to implement. In the end we switched over to a dijkstra based approach that tries to minimize the cost of the mapping, which is more computationally expensive but gives much better results. Difftastic uses a similar approach as well.<p>[1]: <a href="https:&#x2F;&#x2F;semanticdiff.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;semanticdiff.com&#x2F;</a></div><br/><div id="42094979" class="c"><input type="checkbox" id="c-42094979" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42094842">parent</a><span>|</span><a href="#42098708">next</a><span>|</span><label class="collapse" for="c-42094979">[-]</label><label class="expand" for="c-42094979">[4 more]</label></div><br/><div class="children"><div class="content">Thanks for the insightful comments! You surely have a lot more experience than me there, but my impression was that producing visual diffs and merging files are tasks that put different requirements on the tree matching algorithms, and Dijkstra-style approaches felt more fitting for diffs than for merging, so that&#x27;s why I went for GumTree as it seemed to be the state of the art for merging. Does SemanticDiff offer a merge driver? I could only find documentation about diffing on the website.<p>As to mismatches: yes, they are bound to happen in some cases. Even for line-based diffing, Git uses rather convoluted heuristics to avoid them (with the &quot;histogram&quot; diff algorithm), but they can&#x27;t be completely ruled out there either. I hope that with enough safeguards (helper to review merges, downstream consistency checks with local fall-back to line-based diffing) they can be lived with. I&#x27;m happy to try other matching algorithms if they are more promising though (there isn&#x27;t much coupling with the rest of the pipeline).<p>Concerning tree-sitter, I have noticed some small issues, but nothing that was a show-stopper so far. I actually like it that it&#x27;s designed for syntax highlighting, because it&#x27;s really helpful that the representations it gives stay faithful to the original source, to avoid introducing reformatting noise in the merging process. Parsers written for a specific language can sometimes be too zealous (stripping comments out, doing some normalizations behind your back). That&#x27;s a problem in Spork (which uses Spoon, a pretty advanced Java parser). And the uniform API tree-sitter offers over all those parsers is just too good to give up, in my opinion.</div><br/><div id="42095381" class="c"><input type="checkbox" id="c-42095381" checked=""/><div class="controls bullet"><span class="by">DarkPlayer</span><span>|</span><a href="#42094842">root</a><span>|</span><a href="#42094979">parent</a><span>|</span><a href="#42098708">next</a><span>|</span><label class="collapse" for="c-42095381">[-]</label><label class="expand" for="c-42095381">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that different algorithms are better for merging or diffing. In both cases, the first step is to match identical nodes, and the quality of the final result depends heavily on this step. The main problem with GumTree is that it is a greedy algorithm. One incorrectly matched node can completely screw up the rest of the matches. A typical example we encountered was adding a decorator to a function in Python. When other functions with the same decorator followed, the algorithm would often map the newly added decorator to an existing decorator, causing all other decorator mappings to be &quot;off-by-one&quot;. GumTree has a tendency to come up with more changes than there actually are.<p>We try to really get the diff quality nailed down before going after merges. We don&#x27;t have merge functionallity in SemanticDiff yet.<p>The main issue we have with tree-sitter is that the grammars are often written from scratch and not based on the upstream grammar definition. Sometimes they only cover the most likely cases which can lead to parsing errors or incorrectly parsed code. When you encounter parsing errors it can be difficult to fix them, because the upstream grammar is structured completely different. To give you an example, try to compare the tree-sitter Go grammar for types [1] with the upstream grammar [2]. It is similar but the way the rules are structured is somewhat inverted.<p>We use separate executables for the parsers (this also helps to secure them using seccomp on Linux), and they all use the same JSON schema for their output. This allows us to write the parser executable in the most appropriate language for the target language. Building all them statically and cross-platform for our VS Code extension isn&#x27;t easy though ;)<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;tree-sitter&#x2F;tree-sitter-go&#x2F;blob&#x2F;master&#x2F;grammar.js#L289">https:&#x2F;&#x2F;github.com&#x2F;tree-sitter&#x2F;tree-sitter-go&#x2F;blob&#x2F;master&#x2F;gr...</a>
[2]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#Types" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#Types</a></div><br/><div id="42095514" class="c"><input type="checkbox" id="c-42095514" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42094842">root</a><span>|</span><a href="#42095381">parent</a><span>|</span><a href="#42098708">next</a><span>|</span><label class="collapse" for="c-42095514">[-]</label><label class="expand" for="c-42095514">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the details.
Concerning matching for diffing vs for merging, the differences I can think of are:<p>- for diffing, the matching of the leaves is what matters the most, for merging the internal nodes are more important,<p>- for diffing, it feels more acceptable to restrict the matching to be monotonous on the leaves since it&#x27;s difficult to visually represent moves if you can detect them. For merging, supporting moves is more interesting as it lets you replay changes on the moved element,<p>- diffing needs to be faster than merging, so the accuracy&#x2F;speed tradeoffs can be different.<p>Packaging parsers into separate executables seems like hard work indeed! I assume you also considered fixing the tree-sitter grammars (vendoring them as needed, if the fixes can&#x27;t be upstreamed)? Tree-sitter parsers are being used for a lot more than syntax highlighting these days (for instance GitHub&#x27;s &quot;Symbols&quot; panel) so I would imagine maintainers should be open to making grammars more faithful to the official specs. I&#x27;m not particularly looking forward to maintaining dozens of forked grammars but it still feels a lot easier than writing parsers in different languages. I guess you have different distribution constraints also.</div><br/><div id="42096237" class="c"><input type="checkbox" id="c-42096237" checked=""/><div class="controls bullet"><span class="by">DarkPlayer</span><span>|</span><a href="#42094842">root</a><span>|</span><a href="#42095514">parent</a><span>|</span><a href="#42098708">next</a><span>|</span><label class="collapse" for="c-42096237">[-]</label><label class="expand" for="c-42096237">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - for diffing, the matching of the leaves is what matters the most, for merging the internal nodes are more important,<p>The leaves are the ones that end up being highlighted in the diff, but the inner nodes play an important role as well. We try to preserve as much of the code structure as possible when mapping the nodes. A developer is unlikely to change the structure of the code just for fun. A mapping with a larger number of structural changes is therefore more likely to be incorrect.<p>&gt; - for diffing, it feels more acceptable to restrict the matching to be monotonous on the leaves since it&#x27;s difficult to visually represent moves if you can detect them. For merging, supporting moves is more interesting as it lets you replay changes on the moved element,<p>We use a pipeline based approach and visualizing the changes is the last step. For some types of changes we don&#x27;t have a way to visualize them yet (e.g. moves within the same line) and ignore that part of the mapping. We are still trying to get the mapping right though :)<p>We upstreamed a few bug fixes for tree-sitter itself. The grammars were a bit more complicated because we were just using them as a starting point. We patched tree-sitter, added our own annotations to the grammars and restructured them to help our matching algorithm achieve better results and improve performance. In the end there was not much to upstream any more.<p>Using a well tested parsing library, such as Roslyn for C#, and writing some code to integrate it into our existing system aligned more with our goals than tinkering with grammars. Context-sensitive keywords in particular were a constant source of annoyance. The grammar looks correct, but it will fail to parse because of the way the lexer works. You don&#x27;t want your tool to abort just because someone named their parameter &quot;async&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="42098708" class="c"><input type="checkbox" id="c-42098708" checked=""/><div class="controls bullet"><span class="by">herrington_d</span><span>|</span><a href="#42094842">parent</a><span>|</span><a href="#42094979">prev</a><span>|</span><a href="#42096308">next</a><span>|</span><label class="collapse" for="c-42098708">[-]</label><label class="expand" for="c-42098708">[1 more]</label></div><br/><div class="children"><div class="content">Hi! ast-grep[1] author here. It is a tree-sitter based syntax tool to search tool.<p>I wonder how you transition from tree-sitter to other builtin parsers? Tree-sitter gave a unified interface to all languages. Using language native parsers will require significant work for various FFI if I am not wrong.<p>[1]: <a href="https:&#x2F;&#x2F;ast-grep.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ast-grep.github.io&#x2F;</a></div><br/></div></div><div id="42096308" class="c"><input type="checkbox" id="c-42096308" checked=""/><div class="controls bullet"><span class="by">abathur</span><span>|</span><a href="#42094842">parent</a><span>|</span><a href="#42098708">prev</a><span>|</span><a href="#42096029">next</a><span>|</span><label class="collapse" for="c-42096308">[-]</label><label class="expand" for="c-42096308">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We are currently in the process of moving away from tree-sitter and instead using the parsers provided by the languages themselves where possible.<p>I imagine this means you&#x27;re trying to abstract over those parsers somehow? How well is that going, and have you written about your approach?<p>(I wrote `resholve` to identify and rewrite references to external dependencies in bash&#x2F;posixy Shell scripts to absolute paths. This is helpful in the Nix ecosystem to confirm the dependencies are known, specified, present, don&#x27;t shift when run from a service with a different PATH, etc.<p>It builds on the mostly-bash-compatible OSH parser from the oilshell&#x2F;oils-for-unix project for the same reasons you&#x27;re citing.<p>It would be ~nice to eventually generalize out something that can handle scripts for other shell languages like fish, zsh, nushell, elvish, the ysh part of the oils-for-unix project, etc., but I suspect that&#x27;ll be a diminishing-return sort of slog and haven&#x27;t had any lightbulb-moments to make it feel tractable yet.<p>We also have some ~related needs here around identifying hardcoded or user-controlled exec...)</div><br/><div id="42096528" class="c"><input type="checkbox" id="c-42096528" checked=""/><div class="controls bullet"><span class="by">DarkPlayer</span><span>|</span><a href="#42094842">root</a><span>|</span><a href="#42096308">parent</a><span>|</span><a href="#42096029">next</a><span>|</span><label class="collapse" for="c-42096528">[-]</label><label class="expand" for="c-42096528">[1 more]</label></div><br/><div class="children"><div class="content">Our parsers simply return the concrete syntax trees in a JSON format. We do not unify all the different syntax constructs into a common AST if that is what you are looking for. The languages and file formats we support are too diverse for that.<p>The language specific logic does not end with the parsers though. The core of SemanticDiff also contains language specific rules that are picked up by the matching and visualization steps. For example, the HTML module might add a rule that the order of attributes within a tag is irrelevant. So it all comes down to writing a generic rule system that makes it easy to add new languages.</div><br/></div></div></div></div><div id="42096029" class="c"><input type="checkbox" id="c-42096029" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#42094842">parent</a><span>|</span><a href="#42096308">prev</a><span>|</span><a href="#42096318">next</a><span>|</span><label class="collapse" for="c-42096029">[-]</label><label class="expand" for="c-42096029">[1 more]</label></div><br/><div class="children"><div class="content">An important point here is that for certain languages, using the original grammar is pretty much impossible. In particular, for C, you want to do diffing and merging on the un-preprocessed source, but the language&#x27;s grammar very much assumes the source has gone through the preprocessor.<p>Of course, the existence of the preprocessor means there are situations where it&#x27;s completely impossible to know what the correct parse is; it will necessarily be heuristic in some cases.</div><br/></div></div><div id="42096318" class="c"><input type="checkbox" id="c-42096318" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#42094842">parent</a><span>|</span><a href="#42096029">prev</a><span>|</span><a href="#42098650">next</a><span>|</span><label class="collapse" for="c-42096318">[-]</label><label class="expand" for="c-42096318">[2 more]</label></div><br/><div class="children"><div class="content">&gt; best effort approach to parsing. This is perfectly fine for syntax highlighting, since the worst that can happen is that a few characters are highlighted incorrectly. However, when diffing or modifying code you really want the code to be parsed according to the upstream grammar, not something that mostly resembles it.<p>But surely you need to support code that doesn&#x27;t parse correctly by the actual language&#x27;s grammar anyway? &#x27;Merge branch fix-syntax-error&#x27;</div><br/><div id="42096527" class="c"><input type="checkbox" id="c-42096527" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42094842">root</a><span>|</span><a href="#42096318">parent</a><span>|</span><a href="#42098650">next</a><span>|</span><label class="collapse" for="c-42096527">[-]</label><label class="expand" for="c-42096527">[1 more]</label></div><br/><div class="children"><div class="content">In Mergiraf, as soon as there is a parsing error in any of the revisions, it falls back on line-based merging, even though tree-sitter is generally good at isolating the error. It felt like the safest thing to do (maybe we detected the language wrong), but I&#x27;m definitely open to reconsidering…</div><br/></div></div></div></div><div id="42098650" class="c"><input type="checkbox" id="c-42098650" checked=""/><div class="controls bullet"><span class="by">Sparkyte</span><span>|</span><a href="#42094842">parent</a><span>|</span><a href="#42096318">prev</a><span>|</span><a href="#42098735">next</a><span>|</span><label class="collapse" for="c-42098650">[-]</label><label class="expand" for="c-42098650">[1 more]</label></div><br/><div class="children"><div class="content">Good example of when adding abstraction is more problematic than the processes themselves which is like an extra minute or two in flow.</div><br/></div></div><div id="42098735" class="c"><input type="checkbox" id="c-42098735" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#42094842">parent</a><span>|</span><a href="#42098650">prev</a><span>|</span><a href="#42096023">next</a><span>|</span><label class="collapse" for="c-42098735">[-]</label><label class="expand" for="c-42098735">[1 more]</label></div><br/><div class="children"><div class="content">Small brained primate comment.<p>I&#x27;ve wondered if you could add annotation keywords to languages to convert them into something that could be parsed reliably with a tree sitter grammar.<p>I say this as someone that feels like you really want diffs that say, changed &#x27;struct x name from y to z&#x27; instead of here&#x27;s a huge list of files with ten changes each.</div><br/></div></div><div id="42096023" class="c"><input type="checkbox" id="c-42096023" checked=""/><div class="controls bullet"><span class="by">drawnwren</span><span>|</span><a href="#42094842">parent</a><span>|</span><a href="#42098735">prev</a><span>|</span><a href="#42094545">next</a><span>|</span><label class="collapse" for="c-42096023">[-]</label><label class="expand" for="c-42096023">[1 more]</label></div><br/><div class="children"><div class="content">This may or may not be on your radar, but crypto is desperate for a product like this. Smart contracts are often forks or rewrites (obfuscated or otherwise) of others and an easy interface for end users to be able to see changes between two forks would probably provide a lot of value.</div><br/></div></div></div></div><div id="42094545" class="c"><input type="checkbox" id="c-42094545" checked=""/><div class="controls bullet"><span class="by">Game_Ender</span><span>|</span><a href="#42094842">prev</a><span>|</span><a href="#42093937">next</a><span>|</span><label class="collapse" for="c-42094545">[-]</label><label class="expand" for="c-42094545">[2 more]</label></div><br/><div class="children"><div class="content">The tool has an excellent architecture section [0] that goes into how it works under the hood.  It stands out to me that a complex tool has an overview to this depth that allows you to grasp conceptually how it works.<p>0 - <a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;architecture.html" rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;architecture.html</a></div><br/><div id="42094664" class="c"><input type="checkbox" id="c-42094664" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42094545">parent</a><span>|</span><a href="#42093937">next</a><span>|</span><label class="collapse" for="c-42094664">[-]</label><label class="expand" for="c-42094664">[1 more]</label></div><br/><div class="children"><div class="content">That <i>is</i> nicely done, often hard to find, and usually it&#x27;s what I&#x27;m looking for when deciding whether to use a piece of software: Show me the complexity you&#x27;ve encapsulated so that I can be the judge of whether the juice is worth the squeeze.<p>Armed with that, I can tolerate some rough edges. Without it, I&#x27;ll get stuck in weird ways that your docs can&#x27;t anticipate.</div><br/></div></div></div></div><div id="42093937" class="c"><input type="checkbox" id="c-42093937" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#42094545">prev</a><span>|</span><a href="#42094036">next</a><span>|</span><label class="collapse" for="c-42093937">[-]</label><label class="expand" for="c-42093937">[19 more]</label></div><br/><div class="children"><div class="content">Going through the sorts of conflicts it solves, and limitations in that, I find it claiming that in some insertions, order doesn’t matter &lt;<a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;conflicts.html#neighbouring-insertions-and-deletions-of-elements-whose-order-does-not-matter" rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;conflicts.html#neighbouring-insertions-...</a>&gt;.<p>I <i>really</i> don’t like that. At the <i>language</i> level, order may not matter, but quite frequently in such cases the order <i>does</i> matter, insofar as almost every human would put the two things in a particular order; or where there is a particular convention active. If you automatically merge the two sides in a <i>different</i> order from that, doing it automatically has become <i>harmful</i>.<p>My clearest example: take Base `struct Foo; struct Bar;`, then between these two items, Left inserts `impl Foo { }`, Right inserts `struct Baz;`. To the computer, the difference doesn’t matter, but merging it as `struct Foo; struct Baz; impl Foo { } struct Bar;` is <i>obviously</i> bad to a human. This is the problem: it’s handling language <i>syntax</i> semantics, but can’t be aware of <i>logical</i> semantics. (Hope you can grasp what I’m trying to convey, not sure of the best words.) Left was not inserting something between Foo and Bar, it was attaching something to the end of Foo. Whereas Right was probably inserting something between Foo and Bar—but maybe even it was inserting something before Bar. You perceive that these are all different things, <i>logically</i>.<p>Another example where this will quickly go wrong: in CSS rulesets, some will sort the declarations by property name lexicographically, some by property name length (seriously, it’s frequently <i>so pretty</i>), some will group by different types of property… you can’t know.</div><br/><div id="42094758" class="c"><input type="checkbox" id="c-42094758" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#42093937">parent</a><span>|</span><a href="#42094000">next</a><span>|</span><label class="collapse" for="c-42094758">[-]</label><label class="expand" for="c-42094758">[3 more]</label></div><br/><div class="children"><div class="content">Not only that, the order of fields in a Java class <i>does</i> matter despite what that link claims. It&#x27;s common to use Lombok to automatically generate constructors, and &quot;the order of the parameters match the order in which the fields appear in your class.&quot;<p><a href="https:&#x2F;&#x2F;projectlombok.org&#x2F;features&#x2F;constructor" rel="nofollow">https:&#x2F;&#x2F;projectlombok.org&#x2F;features&#x2F;constructor</a><p>The first two kinds of conflicts that Mergiraf handles looks somewhat dangerous to me when handled by a computer.<p><a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;conflicts.html" rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;conflicts.html</a></div><br/><div id="42095090" class="c"><input type="checkbox" id="c-42095090" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42094758">parent</a><span>|</span><a href="#42095826">next</a><span>|</span><label class="collapse" for="c-42095090">[-]</label><label class="expand" for="c-42095090">[1 more]</label></div><br/><div class="children"><div class="content">Lombok is an interesting example, but yes, just with reflection you can already get order-dependent behaviors as the docs note. I&#x27;ve been thinking about giving users more control over this commutativity, but it&#x27;s not clear to me what it should look like. A strict mode where commutativity is disabled entirely? The ability to disable certain commutative parents?</div><br/></div></div><div id="42095826" class="c"><input type="checkbox" id="c-42095826" checked=""/><div class="controls bullet"><span class="by">andrewaylett</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42094758">parent</a><span>|</span><a href="#42095090">prev</a><span>|</span><a href="#42094000">next</a><span>|</span><label class="collapse" for="c-42095826">[-]</label><label class="expand" for="c-42095826">[1 more]</label></div><br/><div class="children"><div class="content">Code that uses Lombok features which <i>change</i> classes (rather than subclassing them) might have a high degree of similarity to Java, but it&#x27;s not Java.</div><br/></div></div></div></div><div id="42094000" class="c"><input type="checkbox" id="c-42094000" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#42093937">parent</a><span>|</span><a href="#42094758">prev</a><span>|</span><a href="#42094483">next</a><span>|</span><label class="collapse" for="c-42094000">[-]</label><label class="expand" for="c-42094000">[4 more]</label></div><br/><div class="children"><div class="content">I sort my CSS by property type (display, size, position, etc). Takes a while to get used to it but it definitely speeds up my ability to do CSS surgery.</div><br/><div id="42094222" class="c"><input type="checkbox" id="c-42094222" checked=""/><div class="controls bullet"><span class="by">wonger_</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42094000">parent</a><span>|</span><a href="#42094483">next</a><span>|</span><label class="collapse" for="c-42094222">[-]</label><label class="expand" for="c-42094222">[3 more]</label></div><br/><div class="children"><div class="content">Similarly, I&#x27;ve been wanting to make an autoformatter that reorders CSS properties into these categories: <a href="https:&#x2F;&#x2F;9elements.com&#x2F;css-rule-order&#x2F;" rel="nofollow">https:&#x2F;&#x2F;9elements.com&#x2F;css-rule-order&#x2F;</a> (box model, positioning, typography, etc)<p>I think it&#x27;s the most useful CSS organization method I&#x27;ve found yet.</div><br/><div id="42095095" class="c"><input type="checkbox" id="c-42095095" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42094222">parent</a><span>|</span><a href="#42094323">next</a><span>|</span><label class="collapse" for="c-42095095">[-]</label><label class="expand" for="c-42095095">[1 more]</label></div><br/><div class="children"><div class="content">This is what I&#x27;ve always done naturally for the 20+ years I&#x27;ve been writing CSS. The only difference is that I put animation at the end, probably because it came much later than the rest.</div><br/></div></div><div id="42094323" class="c"><input type="checkbox" id="c-42094323" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42094222">parent</a><span>|</span><a href="#42095095">prev</a><span>|</span><a href="#42094483">next</a><span>|</span><label class="collapse" for="c-42094323">[-]</label><label class="expand" for="c-42094323">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in <a href="https:&#x2F;&#x2F;github.com&#x2F;hudochenkov&#x2F;stylelint-order">https:&#x2F;&#x2F;github.com&#x2F;hudochenkov&#x2F;stylelint-order</a></div><br/></div></div></div></div></div></div><div id="42094483" class="c"><input type="checkbox" id="c-42094483" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#42093937">parent</a><span>|</span><a href="#42094000">prev</a><span>|</span><a href="#42094052">next</a><span>|</span><label class="collapse" for="c-42094483">[-]</label><label class="expand" for="c-42094483">[2 more]</label></div><br/><div class="children"><div class="content">I want to add another problem here. &lt;<a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;adding-a-language.html#add-commutative-parents:~:text=To%20let%20Mergiraf%20reorder,in%20the%20syntax%20tree)." rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;adding-a-language.html#add-commutative-...</a>&gt;:<p>&gt; <i>To let Mergiraf reorder using statements to fix conflicts, we actually need to specify that they can be reordered with any of their siblings (any other child of their parent in the syntax tree).</i><p>That’s too coarse-grained. No idea about C♯, but languages could impose a rule that imports must come before anything else—long ago Rust had such a rule, for example. So it might be that within your compilation_unit node, only its using_directive children are commutative, and only among themselves.<p>Otherwise (lapsing into Rust syntax for convenience), with Base `use A; struct X…`, Left `use A; use B; struct X…` and Right `use A; struct Y; struct X…`, you could end up with the invalid `use A; struct Y; use B; struct X…`.</div><br/><div id="42094644" class="c"><input type="checkbox" id="c-42094644" checked=""/><div class="controls bullet"><span class="by">tokinonagare</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42094483">parent</a><span>|</span><a href="#42094052">next</a><span>|</span><label class="collapse" for="c-42094644">[-]</label><label class="expand" for="c-42094644">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No idea about C♯<p>C#&#x27;s <i>using</i> aren&#x27;t imports, and order indeed doesn&#x27;t matter.</div><br/></div></div></div></div><div id="42094052" class="c"><input type="checkbox" id="c-42094052" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42093937">parent</a><span>|</span><a href="#42094483">prev</a><span>|</span><a href="#42096856">next</a><span>|</span><label class="collapse" for="c-42094052">[-]</label><label class="expand" for="c-42094052">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s definitely something that could be refined, for instance by specifying that only children of specific types can be reordered together: <a href="https:&#x2F;&#x2F;codeberg.org&#x2F;mergiraf&#x2F;mergiraf&#x2F;issues&#x2F;6" rel="nofollow">https:&#x2F;&#x2F;codeberg.org&#x2F;mergiraf&#x2F;mergiraf&#x2F;issues&#x2F;6</a></div><br/></div></div><div id="42096856" class="c"><input type="checkbox" id="c-42096856" checked=""/><div class="controls bullet"><span class="by">bjackman</span><span>|</span><a href="#42093937">parent</a><span>|</span><a href="#42094052">prev</a><span>|</span><a href="#42093971">next</a><span>|</span><label class="collapse" for="c-42096856">[-]</label><label class="expand" for="c-42096856">[1 more]</label></div><br/><div class="children"><div class="content">I am very excited about this tool despite agreeing with what you wrote here.<p>The reason for that is that most of the time when I&#x27;m resolving huge numbers merge conflicts... I don&#x27;t give a shit about details like field order. I just want to get some code that&#x27;s functionally correct at p&lt;0.05 so I can figure out what performance characteristics my old feature branch would have if I resurrected it. Or I want to kick off the slow integration tests ASAP. 9&#x2F;10 times it&#x27;s that kind of thing.<p>The 1&#x2F;10 times where I&#x27;m like &quot;OK now I actually wanna merge this code, I have to look over the resolutions, I will upload them to Gerrit&#x2F;GitHub and do a self-review&quot; I am more than happy to spend 20 minutes correcting order etc. Or I&#x27;ll happily just switch this tool off and do a totally manual merge.<p>So yeah I think it just comes down to usecase.</div><br/></div></div><div id="42093971" class="c"><input type="checkbox" id="c-42093971" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#42093937">parent</a><span>|</span><a href="#42096856">prev</a><span>|</span><a href="#42093988">next</a><span>|</span><label class="collapse" for="c-42093971">[-]</label><label class="expand" for="c-42093971">[3 more]</label></div><br/><div class="children"><div class="content">Could some of this be mitigated by running a prettifier post-merge?</div><br/><div id="42094083" class="c"><input type="checkbox" id="c-42094083" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42093971">parent</a><span>|</span><a href="#42093988">next</a><span>|</span><label class="collapse" for="c-42094083">[-]</label><label class="expand" for="c-42094083">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely something I would recommend in general, but I&#x27;m not sure if it would solve this particular problem (reordering blocks is perhaps a bit bold for a prettifier).</div><br/><div id="42097487" class="c"><input type="checkbox" id="c-42097487" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42094083">parent</a><span>|</span><a href="#42093988">next</a><span>|</span><label class="collapse" for="c-42097487">[-]</label><label class="expand" for="c-42097487">[1 more]</label></div><br/><div class="children"><div class="content">Maybe prettifier was the wrong word. I&#x27;ve definitely used code formatting tools that offer sorting of certain syntax elements as a feature. (Python imports in PyCharm springs to mind)</div><br/></div></div></div></div></div></div><div id="42093988" class="c"><input type="checkbox" id="c-42093988" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42093937">parent</a><span>|</span><a href="#42093971">prev</a><span>|</span><a href="#42096262">next</a><span>|</span><label class="collapse" for="c-42093988">[-]</label><label class="expand" for="c-42093988">[3 more]</label></div><br/><div class="children"><div class="content">But surely Mergiraf has some opinion about the order when it doesn’t matter, right? Like structs before impls, in your example.</div><br/><div id="42094071" class="c"><input type="checkbox" id="c-42094071" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42093988">parent</a><span>|</span><a href="#42096262">next</a><span>|</span><label class="collapse" for="c-42094071">[-]</label><label class="expand" for="c-42094071">[2 more]</label></div><br/><div class="children"><div class="content">For now, you let it reorder every child within a given node type, which felt expressive enough to me in most cases, but I agree it would be good to refine that: <a href="https:&#x2F;&#x2F;codeberg.org&#x2F;mergiraf&#x2F;mergiraf&#x2F;issues&#x2F;6" rel="nofollow">https:&#x2F;&#x2F;codeberg.org&#x2F;mergiraf&#x2F;mergiraf&#x2F;issues&#x2F;6</a></div><br/><div id="42096455" class="c"><input type="checkbox" id="c-42096455" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#42093937">root</a><span>|</span><a href="#42094071">parent</a><span>|</span><a href="#42096262">next</a><span>|</span><label class="collapse" for="c-42096455">[-]</label><label class="expand" for="c-42096455">[1 more]</label></div><br/><div class="children"><div class="content">Looking at the nice demo, I think just defaulting to asking for confirmation if there is ambiguity, instead of dazzling the user with `mergiraf solve` magic would help; there is already a `merigraf review`. Then, a confirm prompt, an option to undo the resolution completely, or just do it on a file-by-file basis (with help what command to run next).</div><br/></div></div></div></div></div></div><div id="42096262" class="c"><input type="checkbox" id="c-42096262" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42093937">parent</a><span>|</span><a href="#42093988">prev</a><span>|</span><a href="#42094036">next</a><span>|</span><label class="collapse" for="c-42096262">[-]</label><label class="expand" for="c-42096262">[1 more]</label></div><br/><div class="children"><div class="content">Yes maybe, but these issues are true for Git&#x27;s native merge algorithms too. It isn&#x27;t perfect either.<p>As soon as you do any merge you&#x27;re accepting that there might be edits you don&#x27;t agree with.</div><br/></div></div></div></div><div id="42094036" class="c"><input type="checkbox" id="c-42094036" checked=""/><div class="controls bullet"><span class="by">nathell</span><span>|</span><a href="#42093937">prev</a><span>|</span><a href="#42098786">next</a><span>|</span><label class="collapse" for="c-42094036">[-]</label><label class="expand" for="c-42094036">[5 more]</label></div><br/><div class="children"><div class="content">‘Why the giraffe? Two reasons. First, it can see farther due to its height; second, it has one of the biggest hearts of all land mammals. Besides, its ossicones make you believe it listens to you when you look at it.’ – My NVC teacher<p>Kudos for the nonviolence. :)</div><br/><div id="42094447" class="c"><input type="checkbox" id="c-42094447" checked=""/><div class="controls bullet"><span class="by">aeonik</span><span>|</span><a href="#42094036">parent</a><span>|</span><a href="#42094454">next</a><span>|</span><label class="collapse" for="c-42094447">[-]</label><label class="expand" for="c-42094447">[2 more]</label></div><br/><div class="children"><div class="content">Fyi, giraffes are wild animals, and can be very violent and territorial.</div><br/><div id="42098875" class="c"><input type="checkbox" id="c-42098875" checked=""/><div class="controls bullet"><span class="by">mnsc</span><span>|</span><a href="#42094036">root</a><span>|</span><a href="#42094447">parent</a><span>|</span><a href="#42094454">next</a><span>|</span><label class="collapse" for="c-42098875">[-]</label><label class="expand" for="c-42098875">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very literal minded and many metaphors irk me because they require a unspoken shared agreement of only considering the positive aspects that match and ignore the inconvenient ones. Like all sports metaphors used in work related activities. But still, don&#x27;t skip nvc just because you can&#x27;t accept a violent animal as a symbol for non violent communication. It has to much value for us literal minded people.</div><br/></div></div></div></div><div id="42094454" class="c"><input type="checkbox" id="c-42094454" checked=""/><div class="controls bullet"><span class="by">postepowanieadm</span><span>|</span><a href="#42094036">parent</a><span>|</span><a href="#42094447">prev</a><span>|</span><a href="#42098786">next</a><span>|</span><label class="collapse" for="c-42094454">[-]</label><label class="expand" for="c-42094454">[2 more]</label></div><br/><div class="children"><div class="content">Boa constrictor could be a less friendly mascot.</div><br/><div id="42095132" class="c"><input type="checkbox" id="c-42095132" checked=""/><div class="controls bullet"><span class="by">arunix</span><span>|</span><a href="#42094036">root</a><span>|</span><a href="#42094454">parent</a><span>|</span><a href="#42098786">next</a><span>|</span><label class="collapse" for="c-42095132">[-]</label><label class="expand" for="c-42095132">[1 more]</label></div><br/><div class="children"><div class="content">There was such a project long time ago.<p><a href="https:&#x2F;&#x2F;boa-constructor.sourceforge.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;boa-constructor.sourceforge.net&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42098786" class="c"><input type="checkbox" id="c-42098786" checked=""/><div class="controls bullet"><span class="by">manx</span><span>|</span><a href="#42094036">prev</a><span>|</span><a href="#42094143">next</a><span>|</span><label class="collapse" for="c-42098786">[-]</label><label class="expand" for="c-42098786">[1 more]</label></div><br/><div class="children"><div class="content">Great to see more work in automatic git conflict resolution! I&#x27;ll definitely give this a try. My own attempt at such a tool involved character based diffing and patching. It is able to solve most trivial conflicts that git cannot: <a href="https:&#x2F;&#x2F;fdietze.github.io&#x2F;blend&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fdietze.github.io&#x2F;blend&#x2F;</a><p>I never found the time to make a cli out of this.</div><br/></div></div><div id="42094143" class="c"><input type="checkbox" id="c-42094143" checked=""/><div class="controls bullet"><span class="by">lucasoshiro</span><span>|</span><a href="#42098786">prev</a><span>|</span><a href="#42095961">next</a><span>|</span><label class="collapse" for="c-42094143">[-]</label><label class="expand" for="c-42094143">[5 more]</label></div><br/><div class="children"><div class="content">Happy to see something being developed for merge drivers, they are a underrated Git feature that could save a lot since the standard three-way merge of file contents is not aware of the language and can create some problems. For example, if you have this valid Python code:<p>x = input()<p>if x == &#x27;x&#x27;:
    print(&#x27;foo&#x27;)<p><pre><code>    print(&#x27;bar&#x27;)
</code></pre>
If you delete the first print in a branch, delete the other print in another branch, then merge the two branches, you&#x27;ll have this:<p>x = input()<p>if x == &#x27;x&#x27;:<p>Both branches delete a portion of the code inside the if block, leaving it only with a whitespace. In Python it is not a valid code, as they empty scopes need to be declared with pass.<p>I installed Mergiraf to see if it can solve this situation, but sadly, it doesn&#x27;t support Python...</div><br/><div id="42094317" class="c"><input type="checkbox" id="c-42094317" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42094143">parent</a><span>|</span><a href="#42094209">next</a><span>|</span><label class="collapse" for="c-42094317">[-]</label><label class="expand" for="c-42094317">[3 more]</label></div><br/><div class="children"><div class="content">FWIW your examples are very unclear as they use text formatting, you need to indent lines by 4 spaces (with an empty line before and after) for a code block e.g.<p>if a == b:
    print(&quot;x&quot;)<p>versus<p><pre><code>    if a == b:
        print(&quot;x&quot;)</code></pre></div><br/><div id="42094423" class="c"><input type="checkbox" id="c-42094423" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#42094143">root</a><span>|</span><a href="#42094317">parent</a><span>|</span><a href="#42094209">next</a><span>|</span><label class="collapse" for="c-42094423">[-]</label><label class="expand" for="c-42094423">[2 more]</label></div><br/><div class="children"><div class="content">The minimum required is actually only two spaces.</div><br/></div></div></div></div><div id="42094209" class="c"><input type="checkbox" id="c-42094209" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42094143">parent</a><span>|</span><a href="#42094317">prev</a><span>|</span><a href="#42095961">next</a><span>|</span><label class="collapse" for="c-42094209">[-]</label><label class="expand" for="c-42094209">[1 more]</label></div><br/><div class="children"><div class="content">I tried your example but git does create a conflict in my case - but maybe I misunderstood the scenario.
Python support can likely be done (I would be thrilled if someone made a PR for it), but I don&#x27;t know if there is a lot of potential for solving conflicts there: imports can have side effects, function arguments are complicated with the mixture of positional and keyword arguments, decorators are effectful… it seems to me that there is a lot of sensitivity to order in many places.</div><br/></div></div></div></div><div id="42095961" class="c"><input type="checkbox" id="c-42095961" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#42094143">prev</a><span>|</span><a href="#42094375">next</a><span>|</span><label class="collapse" for="c-42095961">[-]</label><label class="expand" for="c-42095961">[3 more]</label></div><br/><div class="children"><div class="content">Syntax-aware tools always have issues when a team extends the base language to fit their problem. Rust has macros. People started using &quot;go generate&quot; for stuff like early generics. Does Mergiraf take EBNF or plugins or does a team fork it to explain their syntax?</div><br/><div id="42096193" class="c"><input type="checkbox" id="c-42096193" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42095961">parent</a><span>|</span><a href="#42094375">next</a><span>|</span><label class="collapse" for="c-42096193">[-]</label><label class="expand" for="c-42096193">[2 more]</label></div><br/><div class="children"><div class="content">Yeah at the moment it just supports whatever the tree-sitter parser accepts, period. A bring-your-own-grammar version could be interesting, I don&#x27;t see why it couldn&#x27;t work. Do you have any Rust crates to recommend, to do parsing according to a grammar supplied by the user at run time? It&#x27;s likely to be slower, but maybe not prohibitively so…<p>Another approach would be for the tool to accept doing structured merging even if there are error nodes in the parsed tree. If those error span the parts of the file where the extended language is used, then the tool could still help with merging the other parts, treating the errors as atomic blocks. I&#x27;d be a bit reluctant to do that, because there could be errors for all sorts of other reasons.</div><br/><div id="42097716" class="c"><input type="checkbox" id="c-42097716" checked=""/><div class="controls bullet"><span class="by">papashell</span><span>|</span><a href="#42095961">root</a><span>|</span><a href="#42096193">parent</a><span>|</span><a href="#42094375">next</a><span>|</span><label class="collapse" for="c-42097716">[-]</label><label class="expand" for="c-42097716">[1 more]</label></div><br/><div class="children"><div class="content">Since tree sitter parsers output a c library, you could dynamically load it.<p>The rust bindings themselves are a thin ffi wrapper.<p>If you wanted to make it a little smoother than needing to compile the tree sitter syntax you could compile&#x2F;bundle grammars up with wasm so its sandboxed and cross platform<p>Edit: found this vscode extension that dynamically loads syntaxes compiled to wasm. You should be able to do the same thing in rust: <a href="https:&#x2F;&#x2F;github.com&#x2F;selfint&#x2F;vscode-tree-sitter">https:&#x2F;&#x2F;github.com&#x2F;selfint&#x2F;vscode-tree-sitter</a></div><br/></div></div></div></div></div></div><div id="42094375" class="c"><input type="checkbox" id="c-42094375" checked=""/><div class="controls bullet"><span class="by">jappgar</span><span>|</span><a href="#42095961">prev</a><span>|</span><a href="#42094327">next</a><span>|</span><label class="collapse" for="c-42094375">[-]</label><label class="expand" for="c-42094375">[2 more]</label></div><br/><div class="children"><div class="content">This seems like a really cool idea that would help with a scenario I encounter a lot with conflicts related to auto-formatting. Sometimes a small change can lead to a lot of whitespace changes below (in functional chains in js, for example).<p>Can this also detect some scenarios where semantic conflicts (but not line conflicts) arise, usually due to moved code?<p>I don&#x27;t know the exact circumstances when this happens, but occasionally you can have e.g a function defined twice after two branches both move the same function elsewhere.</div><br/><div id="42094394" class="c"><input type="checkbox" id="c-42094394" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42094375">parent</a><span>|</span><a href="#42094327">next</a><span>|</span><label class="collapse" for="c-42094394">[-]</label><label class="expand" for="c-42094394">[1 more]</label></div><br/><div class="children"><div class="content">Yes, see this example: <a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;conflicts.html#line-based-merges" rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;conflicts.html#line-based-merges</a></div><br/></div></div></div></div><div id="42094327" class="c"><input type="checkbox" id="c-42094327" checked=""/><div class="controls bullet"><span class="by">leonheld</span><span>|</span><a href="#42094375">prev</a><span>|</span><a href="#42094565">next</a><span>|</span><label class="collapse" for="c-42094327">[-]</label><label class="expand" for="c-42094327">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll certainly give it a try. Another tool I&#x27;ve been using (with varied degree of success) to enhance my git life is <a href="https:&#x2F;&#x2F;github.com&#x2F;tummychow&#x2F;git-absorb">https:&#x2F;&#x2F;github.com&#x2F;tummychow&#x2F;git-absorb</a>. If both of these worked flawlessly or maybe even officially incorporated in git, I&#x27;d be very happy.</div><br/><div id="42094456" class="c"><input type="checkbox" id="c-42094456" checked=""/><div class="controls bullet"><span class="by">ksynwa</span><span>|</span><a href="#42094327">parent</a><span>|</span><a href="#42094668">next</a><span>|</span><label class="collapse" for="c-42094456">[-]</label><label class="expand" for="c-42094456">[4 more]</label></div><br/><div class="children"><div class="content">This sounds like what jujutsu&#x27;s workflow is like by default</div><br/><div id="42094634" class="c"><input type="checkbox" id="c-42094634" checked=""/><div class="controls bullet"><span class="by">leonheld</span><span>|</span><a href="#42094327">root</a><span>|</span><a href="#42094456">parent</a><span>|</span><a href="#42094791">prev</a><span>|</span><a href="#42094668">next</a><span>|</span><label class="collapse" for="c-42094634">[-]</label><label class="expand" for="c-42094634">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard of jujutsu, but I&#x27;m kinda over learning new tooling, specially experimental one. If it&#x27;s not a drop-in replacement that makes my life better (like these easy &quot;git plugins&quot;), I&#x27;m basically not using.</div><br/><div id="42094745" class="c"><input type="checkbox" id="c-42094745" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#42094327">root</a><span>|</span><a href="#42094634">parent</a><span>|</span><a href="#42094668">next</a><span>|</span><label class="collapse" for="c-42094745">[-]</label><label class="expand" for="c-42094745">[1 more]</label></div><br/><div class="children"><div class="content">fwiw you can mix git and jj commands on the same repo and everything will work fine. If you want to stick with 99% git commands, and use jj only as a replacement for git-absorb, you can. For this particular use case, jj will handle merges&#x2F;tags descended from the fixed commit gracefully, and I don&#x27;t think git-absorb handles that.</div><br/></div></div></div></div></div></div><div id="42094668" class="c"><input type="checkbox" id="c-42094668" checked=""/><div class="controls bullet"><span class="by">dochtman</span><span>|</span><a href="#42094327">parent</a><span>|</span><a href="#42094456">prev</a><span>|</span><a href="#42094565">next</a><span>|</span><label class="collapse" for="c-42094668">[-]</label><label class="expand" for="c-42094668">[1 more]</label></div><br/><div class="children"><div class="content">git absorb is great, use it all the time.</div><br/></div></div></div></div><div id="42094565" class="c"><input type="checkbox" id="c-42094565" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#42094327">prev</a><span>|</span><a href="#42094430">next</a><span>|</span><label class="collapse" for="c-42094565">[-]</label><label class="expand" for="c-42094565">[1 more]</label></div><br/><div class="children"><div class="content">Python support would certainly be seem useful for this, in particular as its intentation-based AST should play nicely with this.</div><br/></div></div><div id="42094430" class="c"><input type="checkbox" id="c-42094430" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#42094565">prev</a><span>|</span><a href="#42094838">next</a><span>|</span><label class="collapse" for="c-42094430">[-]</label><label class="expand" for="c-42094430">[4 more]</label></div><br/><div class="children"><div class="content">Neat idea for sure. Language support is pretty limited right now, hopefully there&#x27;s support for more in the works.</div><br/><div id="42094604" class="c"><input type="checkbox" id="c-42094604" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42094430">parent</a><span>|</span><a href="#42094838">next</a><span>|</span><label class="collapse" for="c-42094604">[-]</label><label class="expand" for="c-42094604">[3 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, which languages would you be interested in?</div><br/><div id="42094888" class="c"><input type="checkbox" id="c-42094888" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#42094430">root</a><span>|</span><a href="#42094604">parent</a><span>|</span><a href="#42094666">next</a><span>|</span><label class="collapse" for="c-42094888">[-]</label><label class="expand" for="c-42094888">[1 more]</label></div><br/><div class="children"><div class="content">Off the top of my head, PHP, TypeScript and INI. JavaScript might cover TypeScript, I don&#x27;t know.</div><br/></div></div><div id="42094666" class="c"><input type="checkbox" id="c-42094666" checked=""/><div class="controls bullet"><span class="by">wlll</span><span>|</span><a href="#42094430">root</a><span>|</span><a href="#42094604">parent</a><span>|</span><a href="#42094888">prev</a><span>|</span><a href="#42094838">next</a><span>|</span><label class="collapse" for="c-42094666">[-]</label><label class="expand" for="c-42094666">[1 more]</label></div><br/><div class="children"><div class="content">For me, Ruby.</div><br/></div></div></div></div></div></div><div id="42094838" class="c"><input type="checkbox" id="c-42094838" checked=""/><div class="controls bullet"><span class="by">DrBenCarson</span><span>|</span><a href="#42094430">prev</a><span>|</span><a href="#42094620">next</a><span>|</span><label class="collapse" for="c-42094838">[-]</label><label class="expand" for="c-42094838">[2 more]</label></div><br/><div class="children"><div class="content">How is this better than Difftastic? <a href="https:&#x2F;&#x2F;github.com&#x2F;Wilfred&#x2F;difftastic">https:&#x2F;&#x2F;github.com&#x2F;Wilfred&#x2F;difftastic</a></div><br/><div id="42094879" class="c"><input type="checkbox" id="c-42094879" checked=""/><div class="controls bullet"><span class="by">jFriedensreich</span><span>|</span><a href="#42094838">parent</a><span>|</span><a href="#42094620">next</a><span>|</span><label class="collapse" for="c-42094879">[-]</label><label class="expand" for="c-42094879">[1 more]</label></div><br/><div class="children"><div class="content">difftastic does only diffing not merging.</div><br/></div></div></div></div><div id="42094620" class="c"><input type="checkbox" id="c-42094620" checked=""/><div class="controls bullet"><span class="by">fuzzy2</span><span>|</span><a href="#42094838">prev</a><span>|</span><a href="#42094648">next</a><span>|</span><label class="collapse" for="c-42094620">[-]</label><label class="expand" for="c-42094620">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m eager to try this. Seems like it could revive the genre after Semantic Merge died.</div><br/></div></div><div id="42094648" class="c"><input type="checkbox" id="c-42094648" checked=""/><div class="controls bullet"><span class="by">ctenb</span><span>|</span><a href="#42094620">prev</a><span>|</span><a href="#42095740">next</a><span>|</span><label class="collapse" for="c-42094648">[-]</label><label class="expand" for="c-42094648">[4 more]</label></div><br/><div class="children"><div class="content">Would it be possible to make this work with a treesitter grammar?</div><br/><div id="42094653" class="c"><input type="checkbox" id="c-42094653" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42094648">parent</a><span>|</span><a href="#42094661">next</a><span>|</span><label class="collapse" for="c-42094653">[-]</label><label class="expand" for="c-42094653">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s based on tree-sitter indeed: <a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;adding-a-language.html" rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;adding-a-language.html</a></div><br/></div></div><div id="42094661" class="c"><input type="checkbox" id="c-42094661" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#42094648">parent</a><span>|</span><a href="#42094653">prev</a><span>|</span><a href="#42095740">next</a><span>|</span><label class="collapse" for="c-42094661">[-]</label><label class="expand" for="c-42094661">[2 more]</label></div><br/><div class="children"><div class="content">what do you mean?<p>its treesitter based already:<p><a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;architecture.html" rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;architecture.html</a></div><br/><div id="42094973" class="c"><input type="checkbox" id="c-42094973" checked=""/><div class="controls bullet"><span class="by">ctenb</span><span>|</span><a href="#42094648">root</a><span>|</span><a href="#42094661">parent</a><span>|</span><a href="#42095740">next</a><span>|</span><label class="collapse" for="c-42094973">[-]</label><label class="expand" for="c-42094973">[1 more]</label></div><br/><div class="children"><div class="content">Hm, I failed to notice that, since it is not mentioned in their introduction, and the list of supported languages is fairly small :)</div><br/></div></div></div></div></div></div><div id="42095740" class="c"><input type="checkbox" id="c-42095740" checked=""/><div class="controls bullet"><span class="by">cool-RR</span><span>|</span><a href="#42094648">prev</a><span>|</span><a href="#42095474">next</a><span>|</span><label class="collapse" for="c-42095740">[-]</label><label class="expand" for="c-42095740">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m flummoxed at the lack of Python support.</div><br/><div id="42096055" class="c"><input type="checkbox" id="c-42096055" checked=""/><div class="controls bullet"><span class="by">77pt77</span><span>|</span><a href="#42095740">parent</a><span>|</span><a href="#42095474">next</a><span>|</span><label class="collapse" for="c-42096055">[-]</label><label class="expand" for="c-42096055">[1 more]</label></div><br/><div class="children"><div class="content">No typescript either, but it does support JS.</div><br/></div></div></div></div><div id="42095474" class="c"><input type="checkbox" id="c-42095474" checked=""/><div class="controls bullet"><span class="by">jay-anderson</span><span>|</span><a href="#42095740">prev</a><span>|</span><a href="#42094684">next</a><span>|</span><label class="collapse" for="c-42095474">[-]</label><label class="expand" for="c-42095474">[1 more]</label></div><br/><div class="children"><div class="content">Nice to see lilypond in the example.</div><br/></div></div><div id="42094684" class="c"><input type="checkbox" id="c-42094684" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42095474">prev</a><span>|</span><a href="#42094275">next</a><span>|</span><label class="collapse" for="c-42094684">[-]</label><label class="expand" for="c-42094684">[3 more]</label></div><br/><div class="children"><div class="content">This sounds great. To be honest though none of the merge tools really give me enough information to resolve all conflicts easily.<p>The best I&#x27;ve got to is zdiff3 in VSCode (not using their fancy merge view which I don&#x27;t understand at all). But it&#x27;s missing:<p>1. Blame for the merge base.<p>2. Detection of the commit that introduced the first conflict.<p>3. Most annoyingly, no way to show diffs between the &quot;current&quot; and &quot;incoming&quot;. IIRC it has buttons to compare both of those to the merge base, but not to each other. That often leaves me visually scanning the text to manually find differences like a neanderthal. Sometimes it&#x27;s annoying enough that I copy &amp; paste current&#x2F;incoming into files and then diff those but that&#x27;s a right pain.</div><br/><div id="42096809" class="c"><input type="checkbox" id="c-42096809" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#42094684">parent</a><span>|</span><a href="#42094275">next</a><span>|</span><label class="collapse" for="c-42096809">[-]</label><label class="expand" for="c-42096809">[2 more]</label></div><br/><div class="children"><div class="content">Have you tried p4merge? It&#x27;s usually one of the first tools I install.</div><br/><div id="42098960" class="c"><input type="checkbox" id="c-42098960" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42094684">root</a><span>|</span><a href="#42096809">parent</a><span>|</span><a href="#42094275">next</a><span>|</span><label class="collapse" for="c-42098960">[-]</label><label class="expand" for="c-42098960">[1 more]</label></div><br/><div class="children"><div class="content">No. Does it do any of the things I want?</div><br/></div></div></div></div></div></div><div id="42094275" class="c"><input type="checkbox" id="c-42094275" checked=""/><div class="controls bullet"><span class="by">pknopf</span><span>|</span><a href="#42094684">prev</a><span>|</span><label class="collapse" for="c-42094275">[-]</label><label class="expand" for="c-42094275">[2 more]</label></div><br/><div class="children"><div class="content">Can LLMs help here?</div><br/><div id="42094354" class="c"><input type="checkbox" id="c-42094354" checked=""/><div class="controls bullet"><span class="by">wetneb</span><span>|</span><a href="#42094275">parent</a><span>|</span><label class="collapse" for="c-42094354">[-]</label><label class="expand" for="c-42094354">[1 more]</label></div><br/><div class="children"><div class="content">There are attempts to do that, such as <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2111.11904" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2111.11904</a> or <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2109.00084" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2109.00084</a>. I couldn&#x27;t find any open source implementation though. I&#x27;m personally not so keen to use LLMs for merging: I want it to be quick and predictable.</div><br/></div></div></div></div></div></div></div></div></div></body></html>