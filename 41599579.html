<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727254868408" as="style"/><link rel="stylesheet" href="styles.css?v=1727254868408"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/vshymanskyy/wasm2mpy">Wasm2Mpy: Compiling WASM to MicroPython so it can run on Raspberrys</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>syrusakbary</span> | <span>25 comments</span></div><br/><div><div id="41640257" class="c"><input type="checkbox" id="c-41640257" checked=""/><div class="controls bullet"><span class="by">bragr</span><span>|</span><a href="#41643802">next</a><span>|</span><label class="collapse" for="c-41640257">[-]</label><label class="expand" for="c-41640257">[14 more]</label></div><br/><div class="children"><div class="content">I feel like this project is a classic example of the README missing a &quot;Why?&quot; section. Not to justify the project, it just makes it hard to evaluate without understanding why they choose implementing a transpiler rather than an embedded WASM VM. Or why not transpile to native assembly? I&#x27;m sure they have good reasons but they aren&#x27;t listed here.</div><br/><div id="41644129" class="c"><input type="checkbox" id="c-41644129" checked=""/><div class="controls bullet"><span class="by">vshymanskyy</span><span>|</span><a href="#41640257">parent</a><span>|</span><a href="#41641077">next</a><span>|</span><label class="collapse" for="c-41644129">[-]</label><label class="expand" for="c-41644129">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the feedback.
I&#x27;ll improve the README based on your inputs. I was focused on the actual research.
Overall, this allows writing code in statically compiled languages and running it (fast) on embedded systems with MicroPython.
MicroPython itself is comparatively slow, and this provides tools to deliver more demanding software (AI, signal processing, etc).</div><br/><div id="41645075" class="c"><input type="checkbox" id="c-41645075" checked=""/><div class="controls bullet"><span class="by">0points</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41644129">parent</a><span>|</span><a href="#41641077">next</a><span>|</span><label class="collapse" for="c-41645075">[-]</label><label class="expand" for="c-41645075">[1 more]</label></div><br/><div class="children"><div class="content">There exists tooling already to compile for wasm from static languages (rust, C++, and so on) and there exists tooling to run this WASM on a raspberry pi (wasmer, etc).<p>That makes me feel the end goal here is not what&#x27;s described (&quot;make wasm so it can run on a raspberry&quot;), but rather &quot;make wasm run in micropython&quot;.<p>Am I missing something?</div><br/></div></div></div></div><div id="41641077" class="c"><input type="checkbox" id="c-41641077" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41640257">parent</a><span>|</span><a href="#41644129">prev</a><span>|</span><a href="#41640470">next</a><span>|</span><label class="collapse" for="c-41641077">[-]</label><label class="expand" for="c-41641077">[10 more]</label></div><br/><div class="children"><div class="content">i think your questions are implicitly answered in the top page of the readme, but by showing rather than telling<p>esp32 and stm32 run three different native assembly instruction sets (though this only supports two of them, the others listed in the first line of the readme are all arm)<p>the coremark results seem like an adequate answer to why you&#x27;d use a compiler rather than an interpreter<p>i do think it would be clearer, though, to explain up front that the module being built is not made of python code, but rather callable from python code</div><br/><div id="41643561" class="c"><input type="checkbox" id="c-41643561" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41641077">parent</a><span>|</span><a href="#41641330">next</a><span>|</span><label class="collapse" for="c-41643561">[-]</label><label class="expand" for="c-41643561">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no scenario where a bespoke WASM interpreter is slower than MicroPython - though this isn&#x27;t really Python.<p>WASM is an almost &quot;ideal&quot; bytecode target for embedded AOT native compilation as well, though yeah, you&#x27;d have to implement all of the backend targets.</div><br/></div></div><div id="41641330" class="c"><input type="checkbox" id="c-41641330" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41641077">parent</a><span>|</span><a href="#41643561">prev</a><span>|</span><a href="#41640470">next</a><span>|</span><label class="collapse" for="c-41641330">[-]</label><label class="expand" for="c-41641330">[8 more]</label></div><br/><div class="children"><div class="content">&gt; i do think it would be clearer, though, to explain up front that the module being built is not made of python code, but rather callable from python code<p>I know nothing about micropython. Do the modules contain bytecode?</div><br/><div id="41641434" class="c"><input type="checkbox" id="c-41641434" checked=""/><div class="controls bullet"><span class="by">HALtheWise</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41641330">parent</a><span>|</span><a href="#41641462">next</a><span>|</span><label class="collapse" for="c-41641434">[-]</label><label class="expand" for="c-41641434">[3 more]</label></div><br/><div class="children"><div class="content">In this case, the modules contain native code compiled for the target architecture. Micropython has something approximating a dynamic linker to load them.<p><a href="https:&#x2F;&#x2F;docs.micropython.org&#x2F;en&#x2F;latest&#x2F;develop&#x2F;natmod.html" rel="nofollow">https:&#x2F;&#x2F;docs.micropython.org&#x2F;en&#x2F;latest&#x2F;develop&#x2F;natmod.html</a></div><br/><div id="41642816" class="c"><input type="checkbox" id="c-41642816" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41641434">parent</a><span>|</span><a href="#41641462">next</a><span>|</span><label class="collapse" for="c-41642816">[-]</label><label class="expand" for="c-41642816">[2 more]</label></div><br/><div class="children"><div class="content">tools&#x2F;mpy_ld.py: <a href="https:&#x2F;&#x2F;github.com&#x2F;micropython&#x2F;micropython&#x2F;blob&#x2F;master&#x2F;tools&#x2F;mpy_ld.py">https:&#x2F;&#x2F;github.com&#x2F;micropython&#x2F;micropython&#x2F;blob&#x2F;master&#x2F;tools...</a><p>tools&#x2F;mpy-tool.py lists opcodes: <a href="https:&#x2F;&#x2F;github.com&#x2F;micropython&#x2F;micropython&#x2F;blob&#x2F;master&#x2F;tools&#x2F;mpy-tool.py">https:&#x2F;&#x2F;github.com&#x2F;micropython&#x2F;micropython&#x2F;blob&#x2F;master&#x2F;tools...</a><p>Can the same be done with .pyc files; what are the advantages of MicroPython native modules?<p>Why does it need wasm2c?</div><br/><div id="41644152" class="c"><input type="checkbox" id="c-41644152" checked=""/><div class="controls bullet"><span class="by">vshymanskyy</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41642816">parent</a><span>|</span><a href="#41641462">next</a><span>|</span><label class="collapse" for="c-41644152">[-]</label><label class="expand" for="c-41644152">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think .pyc files can contain native code, but .mpy can! And that&#x27;s exactly what I&#x27;m using here:<p>- compile any language to wasm<p>- translate wasm to C99<p>- use the native target toolchain to compile C99 to .mpy<p>- run that on the device</div><br/></div></div></div></div></div></div><div id="41641462" class="c"><input type="checkbox" id="c-41641462" checked=""/><div class="controls bullet"><span class="by">jononor</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41641330">parent</a><span>|</span><a href="#41641434">prev</a><span>|</span><a href="#41640470">next</a><span>|</span><label class="collapse" for="c-41641462">[-]</label><label class="expand" for="c-41641462">[4 more]</label></div><br/><div class="children"><div class="content">.mpy modules can contain MicroPython bytecode and&#x2F;or native machine code. In this case, WASM is compiled (via C) to native code. So the performance is very good, much better than interpreting either MicroPython bytecode or WASM bytecode.<p>The conventional way of creating native modules for MicroPython is to write them in C. This work allows to use any language that supports WASM output target.</div><br/><div id="41643994" class="c"><input type="checkbox" id="c-41643994" checked=""/><div class="controls bullet"><span class="by">zorgmonkey</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41641462">parent</a><span>|</span><a href="#41641794">next</a><span>|</span><label class="collapse" for="c-41643994">[-]</label><label class="expand" for="c-41643994">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the explanation this project makes so much more sense now. If people want a little more detail, they have a brief how it works section in readme <a href="https:&#x2F;&#x2F;github.com&#x2F;vshymanskyy&#x2F;wasm2mpy?tab=readme-ov-file#how-it-works">https:&#x2F;&#x2F;github.com&#x2F;vshymanskyy&#x2F;wasm2mpy?tab=readme-ov-file#h...</a></div><br/></div></div><div id="41641794" class="c"><input type="checkbox" id="c-41641794" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41641462">parent</a><span>|</span><a href="#41643994">prev</a><span>|</span><a href="#41640470">next</a><span>|</span><label class="collapse" for="c-41641794">[-]</label><label class="expand" for="c-41641794">[2 more]</label></div><br/><div class="children"><div class="content">Oh, I didn&#x27;t know MicroPython was fully AOT. I&#x27;m surprised, since vanilla Python is typically interpreted with maybe a bytecode cache, right?</div><br/><div id="41642442" class="c"><input type="checkbox" id="c-41642442" checked=""/><div class="controls bullet"><span class="by">dbcurtis</span><span>|</span><a href="#41640257">root</a><span>|</span><a href="#41641794">parent</a><span>|</span><a href="#41640470">next</a><span>|</span><label class="collapse" for="c-41642442">[-]</label><label class="expand" for="c-41642442">[1 more]</label></div><br/><div class="children"><div class="content">It isn’t fully AOT, but support for AOT modules is excellent.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41640470" class="c"><input type="checkbox" id="c-41640470" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#41640257">parent</a><span>|</span><a href="#41641077">prev</a><span>|</span><a href="#41643802">next</a><span>|</span><label class="collapse" for="c-41640470">[-]</label><label class="expand" for="c-41640470">[1 more]</label></div><br/><div class="children"><div class="content">Probably at least one of &quot;it&#x27;s cool&quot; or &quot;I&#x27;m already using MicroPython&quot;</div><br/></div></div></div></div><div id="41643802" class="c"><input type="checkbox" id="c-41643802" checked=""/><div class="controls bullet"><span class="by">vshymanskyy</span><span>|</span><a href="#41640257">prev</a><span>|</span><a href="#41641787">next</a><span>|</span><label class="collapse" for="c-41643802">[-]</label><label class="expand" for="c-41643802">[1 more]</label></div><br/><div class="children"><div class="content">Author here, ready to answer any questions.</div><br/></div></div><div id="41641787" class="c"><input type="checkbox" id="c-41641787" checked=""/><div class="controls bullet"><span class="by">oulipo</span><span>|</span><a href="#41643802">prev</a><span>|</span><a href="#41640863">next</a><span>|</span><label class="collapse" for="c-41641787">[-]</label><label class="expand" for="c-41641787">[4 more]</label></div><br/><div class="children"><div class="content">What would be the recommendation to run on ESP32?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;wasm3&#x2F;wasm3">https:&#x2F;&#x2F;github.com&#x2F;wasm3&#x2F;wasm3</a>? <a href="https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-wasmachine">https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-wasmachine</a> ? <a href="https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasm-micro-runtime&#x2F;tree&#x2F;main">https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasm-micro-runtime&#x2F;tree&#x2F;...</a> ? <a href="https:&#x2F;&#x2F;github.com&#x2F;TOPLLab&#x2F;WARDuino">https:&#x2F;&#x2F;github.com&#x2F;TOPLLab&#x2F;WARDuino</a> ?</div><br/><div id="41644161" class="c"><input type="checkbox" id="c-41644161" checked=""/><div class="controls bullet"><span class="by">vshymanskyy</span><span>|</span><a href="#41641787">parent</a><span>|</span><a href="#41640863">next</a><span>|</span><label class="collapse" for="c-41644161">[-]</label><label class="expand" for="c-41644161">[3 more]</label></div><br/><div class="children"><div class="content">For esp32 I&#x27;d recommend <a href="https:&#x2F;&#x2F;github.com&#x2F;wasm3&#x2F;embedded-wasm-apps">https:&#x2F;&#x2F;github.com&#x2F;wasm3&#x2F;embedded-wasm-apps</a><p>It obviously depends on your needs&#x2F;goals.<p>P.S. I&#x27;m also the author of wasm3</div><br/><div id="41645252" class="c"><input type="checkbox" id="c-41645252" checked=""/><div class="controls bullet"><span class="by">oulipo</span><span>|</span><a href="#41641787">root</a><span>|</span><a href="#41644161">parent</a><span>|</span><a href="#41645154">next</a><span>|</span><label class="collapse" for="c-41645252">[-]</label><label class="expand" for="c-41645252">[1 more]</label></div><br/><div class="children"><div class="content">Actually in my case I need a VM, because I want users to be able to upload &quot;extension plugins&quot; in real-time, without reuploading firmware<p>In that case which approach &#x2F; library would you recommend to embedd a WASM VM?</div><br/></div></div><div id="41645154" class="c"><input type="checkbox" id="c-41645154" checked=""/><div class="controls bullet"><span class="by">oulipo</span><span>|</span><a href="#41641787">root</a><span>|</span><a href="#41644161">parent</a><span>|</span><a href="#41645252">prev</a><span>|</span><a href="#41640863">next</a><span>|</span><label class="collapse" for="c-41645154">[-]</label><label class="expand" for="c-41645154">[1 more]</label></div><br/><div class="children"><div class="content">thanks for your answer!! Can you tell me a bit more about why this suggestion might be more appropriate than the others?<p>Is it in terms of maturity? Speed? Memory footprint? Safety?</div><br/></div></div></div></div></div></div><div id="41640863" class="c"><input type="checkbox" id="c-41640863" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#41641787">prev</a><span>|</span><a href="#41642073">next</a><span>|</span><label class="collapse" for="c-41640863">[-]</label><label class="expand" for="c-41640863">[3 more]</label></div><br/><div class="children"><div class="content">Can we have python compiled to wasm compiled to python compiled to wasm compiled to python - just for obfuscation reasons?</div><br/><div id="41644106" class="c"><input type="checkbox" id="c-41644106" checked=""/><div class="controls bullet"><span class="by">vshymanskyy</span><span>|</span><a href="#41640863">parent</a><span>|</span><a href="#41640905">next</a><span>|</span><label class="collapse" for="c-41644106">[-]</label><label class="expand" for="c-41644106">[1 more]</label></div><br/><div class="children"><div class="content">With this approach, wasm is compiled to native code. Translating that to Python is in theory possible, but very impractical.</div><br/></div></div><div id="41640905" class="c"><input type="checkbox" id="c-41640905" checked=""/><div class="controls bullet"><span class="by">cyanydeez</span><span>|</span><a href="#41640863">parent</a><span>|</span><a href="#41644106">prev</a><span>|</span><a href="#41642073">next</a><span>|</span><label class="collapse" for="c-41640905">[-]</label><label class="expand" for="c-41640905">[1 more]</label></div><br/><div class="children"><div class="content">Best add a LLM into the loop for real speed.</div><br/></div></div></div></div><div id="41642073" class="c"><input type="checkbox" id="c-41642073" checked=""/><div class="controls bullet"><span class="by">tony-allan</span><span>|</span><a href="#41640863">prev</a><span>|</span><a href="#41640781">next</a><span>|</span><label class="collapse" for="c-41642073">[-]</label><label class="expand" for="c-41642073">[1 more]</label></div><br/><div class="children"><div class="content">A great way to allow code created in another language to be compiled to a MicroPython module and then run in a MicroPython environment.<p>These .mpy files are dynamically loaded into MicroPython using a regular python import.</div><br/></div></div></div></div></div></div></div></body></html>