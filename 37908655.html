<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697533267604" as="style"/><link rel="stylesheet" href="styles.css?v=1697533267604"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rachelbythebay.com/w/2023/10/16/env/">Getaddrinfo() on glibc calls getenv(), oh boy</a> <span class="domain">(<a href="https://rachelbythebay.com">rachelbythebay.com</a>)</span></div><div class="subtext"><span>defrost</span> | <span>189 comments</span></div><br/><div><div id="37909023" class="c"><input type="checkbox" id="c-37909023" checked=""/><div class="controls bullet"><span class="by">jrmg</span><span>|</span><a href="#37908976">next</a><span>|</span><label class="collapse" for="c-37909023">[-]</label><label class="expand" for="c-37909023">[47 more]</label></div><br/><div class="children"><div class="content">I think I must be missing something here, but I’ll ask anyway:<p>Why don’t the OS libraries have some sort of lock around setenv&#x2F;getenv, so that only one thread can be inside them at a time? I can’t see how it could deadlock. And surely no-one is so dependent on the performance of these calls that the time to lock&#x2F;unlock would be problematic?</div><br/><div id="37909699" class="c"><input type="checkbox" id="c-37909699" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909111">next</a><span>|</span><label class="collapse" for="c-37909699">[-]</label><label class="expand" for="c-37909699">[4 more]</label></div><br/><div class="children"><div class="content">getenv returns a pointer which could be invalidated after releasing the lock, unless the lock also guards uses of that pointer and all application code uses that lock, which they most certainly do not. Likewise, this scheme does not solve direct use of environ by application code.<p>NetBSD has getenv_r, which copies into a buffer, but few applications use getenv_r, and certainly not <i>all</i> of them. And it doesn&#x27;t resolve environ.<p>Solaris never free&#x27;s env strings or environ arrays, only creating new copies and atomically swapping them. It uses a special allocator for those objects which doubles the backing buffer each time it deep copies the environ array, then argues this strategy is technically asymptotically memory bounded.<p>EDIT: Glancing at the code I think glibc is similar to Solaris in that it never free&#x27;s env strings, but it has a heuristic to conditionally free environ arrays which means directly using environ isn&#x27;t thread-safe.</div><br/><div id="37910195" class="c"><input type="checkbox" id="c-37910195" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909699">parent</a><span>|</span><a href="#37911279">next</a><span>|</span><label class="collapse" for="c-37910195">[-]</label><label class="expand" for="c-37910195">[2 more]</label></div><br/><div class="children"><div class="content">Having a lock would still be better than the current situation. Especially if the lock was exposed so that programs that did mess with environ directly, or the pointer returned by getenv could hold the lock while doing so.</div><br/><div id="37910692" class="c"><input type="checkbox" id="c-37910692" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910195">parent</a><span>|</span><a href="#37911279">next</a><span>|</span><label class="collapse" for="c-37910692">[-]</label><label class="expand" for="c-37910692">[1 more]</label></div><br/><div class="children"><div class="content">Deadlock disaster that one.</div><br/></div></div></div></div><div id="37911279" class="c"><input type="checkbox" id="c-37911279" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909699">parent</a><span>|</span><a href="#37910195">prev</a><span>|</span><a href="#37909111">next</a><span>|</span><label class="collapse" for="c-37911279">[-]</label><label class="expand" for="c-37911279">[1 more]</label></div><br/><div class="children"><div class="content">`getenv()` never returns pointers that can be invalidated.  If you `putenv()` something, you commit to never freeing it or overwriting it.</div><br/></div></div></div></div><div id="37909111" class="c"><input type="checkbox" id="c-37909111" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909699">prev</a><span>|</span><a href="#37909080">next</a><span>|</span><label class="collapse" for="c-37909111">[-]</label><label class="expand" for="c-37909111">[15 more]</label></div><br/><div class="children"><div class="content">I <i>think</i> the missing piece here is how POSIX specifiers the environment: `getenv(3)` and `setenv(3)` are accessors for `environ`[1], which is just a pointer to some memory (over which walking is also specified[2]). That level of granularity means that it&#x27;s pretty hard to add any locking here.<p>[1]: <a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;basedefs&#x2F;V1_chap08.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;basedefs&#x2F;V1...</a><p>[2]: <a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;functions&#x2F;setenv.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;functions&#x2F;s...</a></div><br/><div id="37909228" class="c"><input type="checkbox" id="c-37909228" checked=""/><div class="controls bullet"><span class="by">YetAnotherNick</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909111">parent</a><span>|</span><a href="#37909189">next</a><span>|</span><label class="collapse" for="c-37909228">[-]</label><label class="expand" for="c-37909228">[11 more]</label></div><br/><div class="children"><div class="content">But getenv&#x2F;setenv syscall could still be under lock, which I think most of the people would use. Walking over memory could be without lock and the program could see inconsistent values as is the current behaviour.</div><br/><div id="37909239" class="c"><input type="checkbox" id="c-37909239" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909228">parent</a><span>|</span><a href="#37911290">next</a><span>|</span><label class="collapse" for="c-37909239">[-]</label><label class="expand" for="c-37909239">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a library call, not a system call. You&#x27;re right though, they could implement locking.</div><br/><div id="37909272" class="c"><input type="checkbox" id="c-37909272" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909239">parent</a><span>|</span><a href="#37911290">next</a><span>|</span><label class="collapse" for="c-37909272">[-]</label><label class="expand" for="c-37909272">[1 more]</label></div><br/><div class="children"><div class="content">I think in libc, there&#x27;s a lot of stuff where an interface is kind of broken from a thread perspective, and it <i>could</i> be implemented better without changing the interface, but often people generally do not.<p>I can&#x27;t think of any examples offhand, but I often think it about thread-local storage.  Eg. lots of interfaces have an _r() equivalent where you provide the buffer, but many people still call the unsafe one which is broken when there are threads...  In my mind, the best way to do this would be to use static thread-local storage in the non-_r() one, and have it call the _r() one ...  Sure that has overhead and isn&#x27;t a perfect solution, but it&#x27;s better than &quot;bad&quot;.  But a lot of these old functions don&#x27;t necessarily get love.</div><br/></div></div></div></div><div id="37911290" class="c"><input type="checkbox" id="c-37911290" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909228">parent</a><span>|</span><a href="#37909239">prev</a><span>|</span><a href="#37909799">next</a><span>|</span><label class="collapse" for="c-37911290">[-]</label><label class="expand" for="c-37911290">[1 more]</label></div><br/><div class="children"><div class="content">It should never use locks.  Solaris&#x2F;Illumos&#x27; getenv() is lock-less.  Every C library should copy that pattern.</div><br/></div></div><div id="37909799" class="c"><input type="checkbox" id="c-37909799" checked=""/><div class="controls bullet"><span class="by">lokar</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909228">parent</a><span>|</span><a href="#37911290">prev</a><span>|</span><a href="#37909189">next</a><span>|</span><label class="collapse" for="c-37909799">[-]</label><label class="expand" for="c-37909799">[7 more]</label></div><br/><div class="children"><div class="content">That won’t help.  The APi is broken.  It returns a pointer.</div><br/><div id="37910271" class="c"><input type="checkbox" id="c-37910271" checked=""/><div class="controls bullet"><span class="by">Sprocklem</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909799">parent</a><span>|</span><a href="#37909189">next</a><span>|</span><label class="collapse" for="c-37910271">[-]</label><label class="expand" for="c-37910271">[6 more]</label></div><br/><div class="children"><div class="content">The pointer isn&#x27;t guaranteed to point into `environ` directly. `getenv()` could copy the value to a thread-local, (dynamically-allocated?) buffer while holding the lock.<p>Edit: In hindsight, a dynamic buffer would require returning ENOMEM errors (which might lead to some unexpected failures), while a static buffer would limit the value length. I think you might be right about the API being broken.</div><br/><div id="37910377" class="c"><input type="checkbox" id="c-37910377" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910271">parent</a><span>|</span><a href="#37909189">next</a><span>|</span><label class="collapse" for="c-37910377">[-]</label><label class="expand" for="c-37910377">[5 more]</label></div><br/><div class="children"><div class="content">Call getenv() in a loop and you run out of memory.</div><br/><div id="37910607" class="c"><input type="checkbox" id="c-37910607" checked=""/><div class="controls bullet"><span class="by">harerazer</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910377">parent</a><span>|</span><a href="#37910599">next</a><span>|</span><label class="collapse" for="c-37910607">[-]</label><label class="expand" for="c-37910607">[3 more]</label></div><br/><div class="children"><div class="content">Then don&#x27;t do that. Of all the footguns in POSIX&#x2F;C programming, having to remember to free this is really not as bad as you seem to imply.</div><br/><div id="37912275" class="c"><input type="checkbox" id="c-37912275" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910607">parent</a><span>|</span><a href="#37910878">next</a><span>|</span><label class="collapse" for="c-37912275">[-]</label><label class="expand" for="c-37912275">[1 more]</label></div><br/><div class="children"><div class="content">You miss the point. If you have full control over when and how getenv is called, there&#x27;s no issue to begin with. The problem is that you don&#x27;t, as OP demonstrates. It&#x27;s perfectly natural to call getaddrinfo in a loop.<p>We need a new API which is not broken like in NetBSD, and a multi-year migration of all core libraries to it. Well a pity it wasn&#x27;t started years ago though, could&#x27;ve been 95% done by now.</div><br/></div></div><div id="37910878" class="c"><input type="checkbox" id="c-37910878" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910607">parent</a><span>|</span><a href="#37912275">prev</a><span>|</span><a href="#37910599">next</a><span>|</span><label class="collapse" for="c-37910878">[-]</label><label class="expand" for="c-37910878">[1 more]</label></div><br/><div class="children"><div class="content">And how would you free it? The current posix API doesn&#x27;t have any way to reliably free the result returned by `getenv`.</div><br/></div></div></div></div><div id="37910599" class="c"><input type="checkbox" id="c-37910599" checked=""/><div class="controls bullet"><span class="by">Sprocklem</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910377">parent</a><span>|</span><a href="#37910607">prev</a><span>|</span><a href="#37909189">next</a><span>|</span><label class="collapse" for="c-37910599">[-]</label><label class="expand" for="c-37910599">[1 more]</label></div><br/><div class="children"><div class="content">I was suggesting that the buffer be invalidated by each subsequent call – like some other libc functions&#x27; internal buffers – although, as I noted in the edit this would need `getenv()` to be able to indicate errors (specifically ENOMEM). It currently cannot do this as currently described, because NULL is used to indicate an absent variable.<p>You could also require callers free the returned memory when they&#x27;re done, but that would be another change of API.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37909189" class="c"><input type="checkbox" id="c-37909189" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909111">parent</a><span>|</span><a href="#37909228">prev</a><span>|</span><a href="#37909184">next</a><span>|</span><label class="collapse" for="c-37909189">[-]</label><label class="expand" for="c-37909189">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if you could get around this by giving each thread its own environment context, and synchronizing them, asynchronously.</div><br/></div></div><div id="37909184" class="c"><input type="checkbox" id="c-37909184" checked=""/><div class="controls bullet"><span class="by">jrmg</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909111">parent</a><span>|</span><a href="#37909189">prev</a><span>|</span><a href="#37909080">next</a><span>|</span><label class="collapse" for="c-37909184">[-]</label><label class="expand" for="c-37909184">[1 more]</label></div><br/><div class="children"><div class="content">That makes a lot of sense. You’d need to snapshot environ when the lock was taken (when another thread could be accessing it!), which I imagine would be complicated. Although surely possible.</div><br/></div></div></div></div><div id="37909080" class="c"><input type="checkbox" id="c-37909080" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909111">prev</a><span>|</span><a href="#37909866">next</a><span>|</span><label class="collapse" for="c-37909080">[-]</label><label class="expand" for="c-37909080">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I&#x27;m shocked this isn&#x27;t there in 2023. Or even better, a rwlock allowing concurrent reads while serializing writes. Or some lock free algorithm for writes.<p>I&#x27;m pretty sure the Windows version of the environment calls has locking.<p>Historically you can access the environment via a global variable too, which would side-step locking schemes. But probably hardly anybody does that anymore.</div><br/></div></div><div id="37909866" class="c"><input type="checkbox" id="c-37909866" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909080">prev</a><span>|</span><a href="#37911902">next</a><span>|</span><label class="collapse" for="c-37909866">[-]</label><label class="expand" for="c-37909866">[3 more]</label></div><br/><div class="children"><div class="content">On at least some other operating systems, getenv(3C) and setenv(3C) are indeed thread-safe; e.g., on illumos: <a href="https:&#x2F;&#x2F;illumos.org&#x2F;man&#x2F;3C&#x2F;getenv" rel="nofollow noreferrer">https:&#x2F;&#x2F;illumos.org&#x2F;man&#x2F;3C&#x2F;getenv</a><p>We inherited our implementation from OpenSolaris, as did Oracle when they created their Solaris 11 fork.  I expect at least some of the BSDs have probably fixed this as well.</div><br/><div id="37910616" class="c"><input type="checkbox" id="c-37910616" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909866">parent</a><span>|</span><a href="#37911902">next</a><span>|</span><label class="collapse" for="c-37910616">[-]</label><label class="expand" for="c-37910616">[2 more]</label></div><br/><div class="children"><div class="content">Just because it is <i>documented</i> as thread safe doesn&#x27;t mean it actually is. They might have just not understood the problem (see e.g. the various indirect links to &quot;please mandate a thread-local `getenv`&quot;).<p>`setenv` is a nasty beast, especially since the raw `environ` variable is also exposed (and is in fact the only way to enumerate the environment).</div><br/><div id="37910731" class="c"><input type="checkbox" id="c-37910731" checked=""/><div class="controls bullet"><span class="by">tjfontaine</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910616">parent</a><span>|</span><a href="#37911902">next</a><span>|</span><label class="collapse" for="c-37910731">[-]</label><label class="expand" for="c-37910731">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, because it is documented that’s the behavior I would expect.<p>That being said, I went to look[0] and it turns out it wasn’t a lie.
 [0]<a href="https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;lib&#x2F;libc&#x2F;port&#x2F;gen&#x2F;getenv.c">https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;...</a></div><br/></div></div></div></div></div></div><div id="37911902" class="c"><input type="checkbox" id="c-37911902" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909866">prev</a><span>|</span><a href="#37909278">next</a><span>|</span><label class="collapse" for="c-37911902">[-]</label><label class="expand" for="c-37911902">[1 more]</label></div><br/><div class="children"><div class="content">Even if the api was perfect and used locks and returned memory to be managed by the caller, it would still be hard to use safely in a multithreading environment as long as the env is a process global property.</div><br/></div></div><div id="37909278" class="c"><input type="checkbox" id="c-37909278" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37911902">prev</a><span>|</span><a href="#37909128">next</a><span>|</span><label class="collapse" for="c-37909278">[-]</label><label class="expand" for="c-37909278">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a proposal for that: <a href="https:&#x2F;&#x2F;www.owlfolio.org&#x2F;development&#x2F;thread-safe-environment-variable-mutation-working-draft-2022-15&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.owlfolio.org&#x2F;development&#x2F;thread-safe-environment...</a></div><br/><div id="37910248" class="c"><input type="checkbox" id="c-37910248" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909278">parent</a><span>|</span><a href="#37909128">next</a><span>|</span><label class="collapse" for="c-37910248">[-]</label><label class="expand" for="c-37910248">[1 more]</label></div><br/><div class="children"><div class="content">That would be nice. What is the likelihood this will actually make it into libc implementations and&#x2F;or become part of the posix standard?</div><br/></div></div></div></div><div id="37909128" class="c"><input type="checkbox" id="c-37909128" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909278">prev</a><span>|</span><a href="#37909113">next</a><span>|</span><label class="collapse" for="c-37909128">[-]</label><label class="expand" for="c-37909128">[3 more]</label></div><br/><div class="children"><div class="content">there are lots of programs that access `*environ` directly, so while this might be good, it wouldn’t solve all classes of the problem. There are also uses out there which are performance sensitive (and often just as if not more unsafe, such as holding pointers into the structure over long periods).<p>threaded programs should probably seriously consider retiring libc, but we don’t currently have a common ground replacement.<p>name related activities are one of the worst areas, contributing significantly to the glibc linkage and abi challenges, but also lacking sufficient standards for alternatives or even consensus to be built quickly.</div><br/><div id="37909767" class="c"><input type="checkbox" id="c-37909767" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909128">parent</a><span>|</span><a href="#37909113">next</a><span>|</span><label class="collapse" for="c-37909767">[-]</label><label class="expand" for="c-37909767">[2 more]</label></div><br/><div class="children"><div class="content">Yes, on Linux you can even write `int main(int argc, char* argv[], char* envp[])`.</div><br/><div id="37910638" class="c"><input type="checkbox" id="c-37910638" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909767">parent</a><span>|</span><a href="#37909113">next</a><span>|</span><label class="collapse" for="c-37910638">[-]</label><label class="expand" for="c-37910638">[1 more]</label></div><br/><div class="children"><div class="content">`envp` is unsafe after `setenv` even in single-threaded programs though. So you really should use `environ`.</div><br/></div></div></div></div></div></div><div id="37909113" class="c"><input type="checkbox" id="c-37909113" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909128">prev</a><span>|</span><a href="#37911285">next</a><span>|</span><label class="collapse" for="c-37909113">[-]</label><label class="expand" for="c-37909113">[8 more]</label></div><br/><div class="children"><div class="content">The sarcastic answer to that would be something along the lines of “users should be aware of what they’re doing, and you should be more careful about calling those concurrently anyway&#x2F;good-luck-have-fun”.</div><br/><div id="37909133" class="c"><input type="checkbox" id="c-37909133" checked=""/><div class="controls bullet"><span class="by">jrmg</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909113">parent</a><span>|</span><a href="#37909334">next</a><span>|</span><label class="collapse" for="c-37909133">[-]</label><label class="expand" for="c-37909133">[6 more]</label></div><br/><div class="children"><div class="content">I’ve been searching around, and you can find a bunch of discussions about this online. Your ’sarcastic’ argument is basically the one I’ve seen in most places.<p>They could easily be made thread safe, but, paraphrasing, most arguments seem to come down to something like:<p>“setenv and getenv are POSIX functions, and not defined to lock. Just like many POSIX functions, they’ve _never_ been thread safe, and it’s an error to assume they are. Should we really start papering over client errors in use of a supposedly portable API, even though it’s working as specified? And if we make that choice pragmatically for this instance, should we be trying to do it for _all_ of POSIX? That’s impossible for some things, and would add complexity even where it’s not. For all these reasons, it’s better if these just stay dangerous like they’ve always been.”</div><br/><div id="37910480" class="c"><input type="checkbox" id="c-37910480" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909133">parent</a><span>|</span><a href="#37910023">next</a><span>|</span><label class="collapse" for="c-37910480">[-]</label><label class="expand" for="c-37910480">[1 more]</label></div><br/><div class="children"><div class="content">This is fine for a 1980s monolithic program but if you use any library that reads environment variables (like, ahem, libc!) you have to treat the whole library as non-thread-safe? Or keep track of the &quot;color&quot; of each library function?</div><br/></div></div><div id="37910023" class="c"><input type="checkbox" id="c-37910023" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909133">parent</a><span>|</span><a href="#37910480">prev</a><span>|</span><a href="#37910215">next</a><span>|</span><label class="collapse" for="c-37910023">[-]</label><label class="expand" for="c-37910023">[2 more]</label></div><br/><div class="children"><div class="content">This kind of historical baggage is one of the main reasons I now completely avoid C&#x2F;C++ programming and won&#x27;t touch it ever again. It&#x27;s Rust or C# only for me from here on...</div><br/><div id="37910971" class="c"><input type="checkbox" id="c-37910971" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910023">parent</a><span>|</span><a href="#37910215">next</a><span>|</span><label class="collapse" for="c-37910971">[-]</label><label class="expand" for="c-37910971">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that this effects higher languages too, because they often build on libc. And on some OSes, they don&#x27;t have a choice, because the system call interface is unstable and&#x2F;or undocumented).<p>For example in rust, multiple time libraries were found to be unsound if `std::env::set_env` was ever called from a multi-threaded program. See:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;time-rs&#x2F;time&#x2F;issues&#x2F;293">https:&#x2F;&#x2F;github.com&#x2F;time-rs&#x2F;time&#x2F;issues&#x2F;293</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;chronotope&#x2F;chrono&#x2F;issues&#x2F;499">https:&#x2F;&#x2F;github.com&#x2F;chronotope&#x2F;chrono&#x2F;issues&#x2F;499</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;27970">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;27970</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;90308">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;90308</a></div><br/></div></div></div></div><div id="37910215" class="c"><input type="checkbox" id="c-37910215" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909133">parent</a><span>|</span><a href="#37910023">prev</a><span>|</span><a href="#37909334">next</a><span>|</span><label class="collapse" for="c-37910215">[-]</label><label class="expand" for="c-37910215">[2 more]</label></div><br/><div class="children"><div class="content">Yes it&#x27;s worth remembering that the POSIX base came before threads became commonly available (or even had a standardised API)</div><br/><div id="37910976" class="c"><input type="checkbox" id="c-37910976" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37910215">parent</a><span>|</span><a href="#37909334">next</a><span>|</span><label class="collapse" for="c-37910976">[-]</label><label class="expand" for="c-37910976">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it is time to replace the POSIX base with something that is better suited to a multi-threaded environemnt.</div><br/></div></div></div></div></div></div><div id="37909334" class="c"><input type="checkbox" id="c-37909334" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909113">parent</a><span>|</span><a href="#37909133">prev</a><span>|</span><a href="#37911285">next</a><span>|</span><label class="collapse" for="c-37909334">[-]</label><label class="expand" for="c-37909334">[1 more]</label></div><br/><div class="children"><div class="content">For libc-developer, they could do better.<p>For the rest of us, I guess this is the best option. We can do wrappers, but, yak!</div><br/></div></div></div></div><div id="37911285" class="c"><input type="checkbox" id="c-37911285" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909113">prev</a><span>|</span><a href="#37909204">next</a><span>|</span><label class="collapse" for="c-37911285">[-]</label><label class="expand" for="c-37911285">[2 more]</label></div><br/><div class="children"><div class="content">On Solaris&#x2F;Illumos `putenv()` and `getenv()` are lock-less and <i>really</i> fast.<p>Basically, if you `putenv()`, you commit to never freeing that memory.</div><br/><div id="37911918" class="c"><input type="checkbox" id="c-37911918" checked=""/><div class="controls bullet"><span class="by">xy2_</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37911285">parent</a><span>|</span><a href="#37909204">next</a><span>|</span><label class="collapse" for="c-37911918">[-]</label><label class="expand" for="c-37911918">[1 more]</label></div><br/><div class="children"><div class="content">putenv is not lock free: <a href="https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;lib&#x2F;libc&#x2F;port&#x2F;gen&#x2F;getenv.c#L222C2-L222C13">https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;...</a></div><br/></div></div></div></div><div id="37909204" class="c"><input type="checkbox" id="c-37909204" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37911285">prev</a><span>|</span><a href="#37909885">next</a><span>|</span><label class="collapse" for="c-37909204">[-]</label><label class="expand" for="c-37909204">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why getenv_s et al were added.</div><br/></div></div><div id="37909885" class="c"><input type="checkbox" id="c-37909885" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37909023">parent</a><span>|</span><a href="#37909204">prev</a><span>|</span><a href="#37908976">next</a><span>|</span><label class="collapse" for="c-37909885">[-]</label><label class="expand" for="c-37909885">[6 more]</label></div><br/><div class="children"><div class="content">If I were King I would ban environment variables from the OS entirely. Global mutable state is the root of all evil! Globals are evil evil evil and the modern reliance on bullshit environment variables is a plague upon reliability.<p>Kill it all with fire.</div><br/><div id="37911716" class="c"><input type="checkbox" id="c-37911716" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909885">parent</a><span>|</span><a href="#37911388">next</a><span>|</span><label class="collapse" for="c-37911716">[-]</label><label class="expand" for="c-37911716">[2 more]</label></div><br/><div class="children"><div class="content">Well, environment variables are not &quot;global&quot; globals. They are just my globals, or my post-it notes for some variables. Because they are not per-user even. They are per user session.<p>10 processes can have completely different set of values for the same environment variables, because they are in their own environments, and apparently, that&#x27;s useful.<p>There are foot guns, and there are unintentional consequences of implementation and design details. This is why we patch, improve and rewrite our software over time. To iron out these kinks.<p>Fire is also have a tendency to cause collateral damage. So use both fire and environment variables responsibly, and world will be a better place.</div><br/><div id="37911923" class="c"><input type="checkbox" id="c-37911923" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37911716">parent</a><span>|</span><a href="#37911388">next</a><span>|</span><label class="collapse" for="c-37911923">[-]</label><label class="expand" for="c-37911923">[1 more]</label></div><br/><div class="children"><div class="content">They are dynamically scoped variables. Very powerful, but only a slight step above globals.</div><br/></div></div></div></div><div id="37911388" class="c"><input type="checkbox" id="c-37911388" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37909885">parent</a><span>|</span><a href="#37911716">prev</a><span>|</span><a href="#37908976">next</a><span>|</span><label class="collapse" for="c-37911388">[-]</label><label class="expand" for="c-37911388">[3 more]</label></div><br/><div class="children"><div class="content">Should we also get rid of filesystems? Databases? All form of RPC?</div><br/><div id="37911719" class="c"><input type="checkbox" id="c-37911719" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37911388">parent</a><span>|</span><a href="#37911433">next</a><span>|</span><label class="collapse" for="c-37911719">[-]</label><label class="expand" for="c-37911719">[1 more]</label></div><br/><div class="children"><div class="content">I definitely think a lot of filesystem access is a code smell and probably not the right thing. That one causes me a lot of pain. But that’s largely because I work in games and you really need to use the Unity&#x2F;Unreal&#x2F;whatever asset management system instead of direct file system access.<p>I’ve got a small build system and the first thing it does is nuke PATH to empty. It’s glorious. No more grabbing random shit from a big blob with untracked dependencies that varies wildly by system!<p>I could easily live my entire life without environment variables. They’re just a fundamentally bad idea. Every program that foolishly uses environment variables can be replaced by a better program that takes a config file or arglist.</div><br/></div></div><div id="37911433" class="c"><input type="checkbox" id="c-37911433" checked=""/><div class="controls bullet"><span class="by">nikanj</span><span>|</span><a href="#37909023">root</a><span>|</span><a href="#37911388">parent</a><span>|</span><a href="#37911719">prev</a><span>|</span><a href="#37908976">next</a><span>|</span><label class="collapse" for="c-37911433">[-]</label><label class="expand" for="c-37911433">[1 more]</label></div><br/><div class="children"><div class="content">Honestly sometimes I think the answer is yes. Imagine how happy we could be, and how many fewer problems we would have. Add printers to that list and you&#x27;re describing a paradise.</div><br/></div></div></div></div></div></div></div></div><div id="37908976" class="c"><input type="checkbox" id="c-37908976" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#37909023">prev</a><span>|</span><a href="#37910156">next</a><span>|</span><label class="collapse" for="c-37908976">[-]</label><label class="expand" for="c-37908976">[12 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t almost every C library function potentially call getenv()? printf()ing a number requires checking the locale which can be configured via the environment, after all.<p>I&#x27;d say you shouldn&#x27;t be calling setenv() at all once you&#x27;ve spawned threads.</div><br/><div id="37911557" class="c"><input type="checkbox" id="c-37911557" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#37908976">parent</a><span>|</span><a href="#37909056">next</a><span>|</span><label class="collapse" for="c-37911557">[-]</label><label class="expand" for="c-37911557">[1 more]</label></div><br/><div class="children"><div class="content">The environment variables don&#x27;t affect locale immediately; only when you call setlocale().</div><br/></div></div><div id="37909056" class="c"><input type="checkbox" id="c-37909056" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37908976">parent</a><span>|</span><a href="#37911557">prev</a><span>|</span><a href="#37911341">next</a><span>|</span><label class="collapse" for="c-37909056">[-]</label><label class="expand" for="c-37909056">[3 more]</label></div><br/><div class="children"><div class="content">Correct. libc is largely thread unsafe.</div><br/><div id="37910632" class="c"><input type="checkbox" id="c-37910632" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37908976">root</a><span>|</span><a href="#37909056">parent</a><span>|</span><a href="#37911345">next</a><span>|</span><label class="collapse" for="c-37910632">[-]</label><label class="expand" for="c-37910632">[1 more]</label></div><br/><div class="children"><div class="content">Thread unsafe is too kind a qualifier, libc is largely thread-broken.</div><br/></div></div><div id="37911345" class="c"><input type="checkbox" id="c-37911345" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37908976">root</a><span>|</span><a href="#37909056">parent</a><span>|</span><a href="#37910632">prev</a><span>|</span><a href="#37911341">next</a><span>|</span><label class="collapse" for="c-37911345">[-]</label><label class="expand" for="c-37911345">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t have to be.  Even `strtok()`, `getpwnam()`, etc. can be thread-safe (just not reentrant).</div><br/></div></div></div></div><div id="37911341" class="c"><input type="checkbox" id="c-37911341" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37908976">parent</a><span>|</span><a href="#37909056">prev</a><span>|</span><a href="#37909381">next</a><span>|</span><label class="collapse" for="c-37911341">[-]</label><label class="expand" for="c-37911341">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say you shouldn&#x27;t be calling setenv() at all once you&#x27;ve spawned threads.<p>Or, you know, get a better C library.  <a href="https:&#x2F;&#x2F;src.illumos.org&#x2F;source&#x2F;xref&#x2F;illumos-gate&#x2F;usr&#x2F;src&#x2F;lib&#x2F;libc&#x2F;port&#x2F;gen&#x2F;getenv.c?r=60b81b86#48" rel="nofollow noreferrer">https:&#x2F;&#x2F;src.illumos.org&#x2F;source&#x2F;xref&#x2F;illumos-gate&#x2F;usr&#x2F;src&#x2F;lib...</a></div><br/></div></div><div id="37909381" class="c"><input type="checkbox" id="c-37909381" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37908976">parent</a><span>|</span><a href="#37911341">prev</a><span>|</span><a href="#37909009">next</a><span>|</span><label class="collapse" for="c-37909381">[-]</label><label class="expand" for="c-37909381">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say you shouldn&#x27;t be calling setenv() at all once you&#x27;ve spawned threads.<p>That&#x27;s why I hate ZeroMQ. They spawn threads and do magics behind your back.</div><br/></div></div><div id="37909009" class="c"><input type="checkbox" id="c-37909009" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#37908976">parent</a><span>|</span><a href="#37909381">prev</a><span>|</span><a href="#37909014">next</a><span>|</span><label class="collapse" for="c-37909009">[-]</label><label class="expand" for="c-37909009">[1 more]</label></div><br/><div class="children"><div class="content">But the question is:  Who knows what and what not to do with libc?<p>&quot;But Go compiled it just fine...&quot;</div><br/></div></div><div id="37909014" class="c"><input type="checkbox" id="c-37909014" checked=""/><div class="controls bullet"><span class="by">thewakalix</span><span>|</span><a href="#37908976">parent</a><span>|</span><a href="#37909009">prev</a><span>|</span><a href="#37910156">next</a><span>|</span><label class="collapse" for="c-37909014">[-]</label><label class="expand" for="c-37909014">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the entire point of the post and the earlier posts it links to.</div><br/><div id="37909060" class="c"><input type="checkbox" id="c-37909060" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#37908976">root</a><span>|</span><a href="#37909014">parent</a><span>|</span><a href="#37910156">next</a><span>|</span><label class="collapse" for="c-37909060">[-]</label><label class="expand" for="c-37909060">[3 more]</label></div><br/><div class="children"><div class="content">The post is about getaddrinfo() specifically. It just struck me as odd to call that one out when there are far more common C library calls that use getenv().</div><br/><div id="37909427" class="c"><input type="checkbox" id="c-37909427" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#37908976">root</a><span>|</span><a href="#37909060">parent</a><span>|</span><a href="#37909401">next</a><span>|</span><label class="collapse" for="c-37909427">[-]</label><label class="expand" for="c-37909427">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a strong tendency to think of network calls as entirely universal and not tied in any way to to locale settings in the environment.<p>Time, date, physical spellings, ... many things are locale dependant, but socket stuff?.<p>It comes as a <i>Surprise!!</i>, and not the good kind, to many a network programmer with just a few years under their belt to discover threaded networking can segfault because of this.<p>Once you know, you know and don&#x27;t forget (until next time), but I suspect this was the motivation behind the blog posting, the principal of <i>potentially</i> most surprise.</div><br/></div></div><div id="37909401" class="c"><input type="checkbox" id="c-37909401" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37908976">root</a><span>|</span><a href="#37909060">parent</a><span>|</span><a href="#37909427">prev</a><span>|</span><a href="#37910156">next</a><span>|</span><label class="collapse" for="c-37909401">[-]</label><label class="expand" for="c-37909401">[1 more]</label></div><br/><div class="children"><div class="content">They did a post on mktime()<p>But, yes, in general for libc, if the manpage didn&#x27;t say it&#x27;s thread-safe, it is unsafe.</div><br/></div></div></div></div></div></div></div></div><div id="37910156" class="c"><input type="checkbox" id="c-37910156" checked=""/><div class="controls bullet"><span class="by">X-Istence</span><span>|</span><a href="#37908976">prev</a><span>|</span><a href="#37909054">next</a><span>|</span><label class="collapse" for="c-37910156">[-]</label><label class="expand" for="c-37910156">[1 more]</label></div><br/><div class="children"><div class="content">This is something that has bit Rust as well: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;90308">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;90308</a></div><br/></div></div><div id="37909054" class="c"><input type="checkbox" id="c-37909054" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#37910156">prev</a><span>|</span><a href="#37909716">next</a><span>|</span><label class="collapse" for="c-37909054">[-]</label><label class="expand" for="c-37909054">[7 more]</label></div><br/><div class="children"><div class="content">The value of `setenv(3)` has always been pretty murky to me -- the only time I&#x27;ve ever really needed it is when performing a fork-exec, and even then it&#x27;s been the wrong tool for the job (the dedicated exec*e variants are the right way).<p>Would there be any significant downsides (besides breakage) to mapping `environ(7)` as read-only? That seems like the kind of thing that a Linux distribution (or more realistically OpenBSD) could do as a way to kill off a persistent family of bugs.</div><br/><div id="37912055" class="c"><input type="checkbox" id="c-37912055" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37909054">parent</a><span>|</span><a href="#37909098">next</a><span>|</span><label class="collapse" for="c-37912055">[-]</label><label class="expand" for="c-37912055">[1 more]</label></div><br/><div class="children"><div class="content">The best part is that you can&#x27;t use setenv after fork and before execve as it is not async signal safe. As you mention, the envp-taking variant of execve is the only sane option.</div><br/></div></div><div id="37909098" class="c"><input type="checkbox" id="c-37909098" checked=""/><div class="controls bullet"><span class="by">fsociety</span><span>|</span><a href="#37909054">parent</a><span>|</span><a href="#37912055">prev</a><span>|</span><a href="#37909536">next</a><span>|</span><label class="collapse" for="c-37909098">[-]</label><label class="expand" for="c-37909098">[2 more]</label></div><br/><div class="children"><div class="content">If they did it, it would break userspace for a probably surprising amount of processes.</div><br/><div id="37909604" class="c"><input type="checkbox" id="c-37909604" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#37909054">root</a><span>|</span><a href="#37909098">parent</a><span>|</span><a href="#37909536">next</a><span>|</span><label class="collapse" for="c-37909604">[-]</label><label class="expand" for="c-37909604">[1 more]</label></div><br/><div class="children"><div class="content">Why not find those? Especially in a dedicated arena whose stated goals are things just like that like openbsd.</div><br/></div></div></div></div><div id="37909536" class="c"><input type="checkbox" id="c-37909536" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37909054">parent</a><span>|</span><a href="#37909098">prev</a><span>|</span><a href="#37909716">next</a><span>|</span><label class="collapse" for="c-37909536">[-]</label><label class="expand" for="c-37909536">[3 more]</label></div><br/><div class="children"><div class="content">It is quite common a pattern setting the timezones with setenv(&quot;TZ&quot;,...)<p>There are alternatives, but rewriting every program is not always an option.<p>These kind of rewriting sounds exactly like what OpenBSD would do ..</div><br/><div id="37909960" class="c"><input type="checkbox" id="c-37909960" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#37909054">root</a><span>|</span><a href="#37909536">parent</a><span>|</span><a href="#37909716">next</a><span>|</span><label class="collapse" for="c-37909960">[-]</label><label class="expand" for="c-37909960">[2 more]</label></div><br/><div class="children"><div class="content">This is perhaps just my ignorance, but when do you find yourself needing to set the timezone like that? Not in 10+ years of C programming have I ever had to do that.</div><br/><div id="37910645" class="c"><input type="checkbox" id="c-37910645" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37909054">root</a><span>|</span><a href="#37909960">parent</a><span>|</span><a href="#37909716">next</a><span>|</span><label class="collapse" for="c-37910645">[-]</label><label class="expand" for="c-37910645">[1 more]</label></div><br/><div class="children"><div class="content">I assume doing something on behalf of a remote user and still convinced locales can do a thing other than hurt you.</div><br/></div></div></div></div></div></div></div></div><div id="37909716" class="c"><input type="checkbox" id="c-37909716" checked=""/><div class="controls bullet"><span class="by">r2vcap</span><span>|</span><a href="#37909054">prev</a><span>|</span><a href="#37910811">next</a><span>|</span><label class="collapse" for="c-37909716">[-]</label><label class="expand" for="c-37909716">[4 more]</label></div><br/><div class="children"><div class="content">I think the problem is in setenv(3), not getenv(3). Reading shared global state is okay as long as it is not mutable. If someone relies on modifying environment variables, one should use execve(3), not setenv.</div><br/><div id="37910579" class="c"><input type="checkbox" id="c-37910579" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#37909716">parent</a><span>|</span><a href="#37911352">next</a><span>|</span><label class="collapse" for="c-37910579">[-]</label><label class="expand" for="c-37910579">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Setting environment variables while a program is running is a terrible idea. Thread safe or not.<p>A lot of code, for good reasons, assume envvars are constants set before the program started and caches computations based on them, read config files and so on.<p>The fact that they are essentially global variables should be enough to deter usage of them.</div><br/></div></div><div id="37911352" class="c"><input type="checkbox" id="c-37911352" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37909716">parent</a><span>|</span><a href="#37910579">prev</a><span>|</span><a href="#37909726">next</a><span>|</span><label class="collapse" for="c-37911352">[-]</label><label class="expand" for="c-37911352">[1 more]</label></div><br/><div class="children"><div class="content">It can be made safe: <a href="https:&#x2F;&#x2F;src.illumos.org&#x2F;source&#x2F;xref&#x2F;illumos-gate&#x2F;usr&#x2F;src&#x2F;lib&#x2F;libc&#x2F;port&#x2F;gen&#x2F;getenv.c?r=60b81b86#48" rel="nofollow noreferrer">https:&#x2F;&#x2F;src.illumos.org&#x2F;source&#x2F;xref&#x2F;illumos-gate&#x2F;usr&#x2F;src&#x2F;lib...</a></div><br/></div></div><div id="37909726" class="c"><input type="checkbox" id="c-37909726" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#37909716">parent</a><span>|</span><a href="#37911352">prev</a><span>|</span><a href="#37910811">next</a><span>|</span><label class="collapse" for="c-37909726">[-]</label><label class="expand" for="c-37909726">[1 more]</label></div><br/><div class="children"><div class="content">For those who, like me, are a bit rusty on the man memorization:<p>execve(3): <a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;execve" rel="nofollow noreferrer">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;execve</a></div><br/></div></div></div></div><div id="37910811" class="c"><input type="checkbox" id="c-37910811" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#37909716">prev</a><span>|</span><a href="#37909386">next</a><span>|</span><label class="collapse" for="c-37910811">[-]</label><label class="expand" for="c-37910811">[3 more]</label></div><br/><div class="children"><div class="content">Many posix (and c standard library for that matter) functions were not designed with multithreaded programs in mind and don&#x27;t work well in multithreaded programs.<p>I really think it would be worth creating a new standard API that <i>is</i> built with threading in mind, where functions like mktime, getaddrinfo, localtime, etc. take arguments instead of reading from the environment, that avoid global state as much as possible, and are thread safe if there is global state.</div><br/><div id="37910896" class="c"><input type="checkbox" id="c-37910896" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#37910811">parent</a><span>|</span><a href="#37909386">next</a><span>|</span><label class="collapse" for="c-37910896">[-]</label><label class="expand" for="c-37910896">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;musl.libc.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;musl.libc.org&#x2F;</a></div><br/><div id="37911358" class="c"><input type="checkbox" id="c-37911358" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37910811">root</a><span>|</span><a href="#37910896">parent</a><span>|</span><a href="#37909386">next</a><span>|</span><label class="collapse" for="c-37911358">[-]</label><label class="expand" for="c-37911358">[1 more]</label></div><br/><div class="children"><div class="content">Solaris&#x2F;Illumos also has a very nice C library with lots more thread-safety than others, including `getenv()` being thread-safe.</div><br/></div></div></div></div></div></div><div id="37909386" class="c"><input type="checkbox" id="c-37909386" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#37910811">prev</a><span>|</span><a href="#37911310">next</a><span>|</span><label class="collapse" for="c-37909386">[-]</label><label class="expand" for="c-37909386">[6 more]</label></div><br/><div class="children"><div class="content">GAI just needs to go. It needs to be moved to its own daemon with a simple RPC.<p>libc is kinda schizophrenic in this regard. It has mostly obviously low-level functions like string manipulation and memory management, and then unexpectedly a DNS client implementation and a support for arbitrary runtime plugins (for PAM).</div><br/><div id="37910251" class="c"><input type="checkbox" id="c-37910251" checked=""/><div class="controls bullet"><span class="by">xerxes901</span><span>|</span><a href="#37909386">parent</a><span>|</span><a href="#37910598">next</a><span>|</span><label class="collapse" for="c-37910251">[-]</label><label class="expand" for="c-37910251">[3 more]</label></div><br/><div class="children"><div class="content">This is essentially what systemd-resolved with the nss-resolve NSS module is right? It’s possible to use &#x2F;etc&#x2F;nsswitch.conf to entirely disable the built-in DNS resolution in glibc if you want.</div><br/><div id="37910652" class="c"><input type="checkbox" id="c-37910652" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#37909386">root</a><span>|</span><a href="#37910251">parent</a><span>|</span><a href="#37910503">next</a><span>|</span><label class="collapse" for="c-37910652">[-]</label><label class="expand" for="c-37910652">[1 more]</label></div><br/><div class="children"><div class="content">Yep, it&#x27;s close. But you still depend on the unholy mess that is nsswitch.conf<p>It&#x27;s still a bit worrying, with manual JSON parsing: <a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;blob&#x2F;79f487038444646f5bce1f5a18d51cda5f20b268&#x2F;src&#x2F;nss-resolve&#x2F;nss-resolve.c#L598">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;blob&#x2F;79f487038444646f5bce...</a> But at least it&#x27;s just ~600 lines of fairly straightforward code.<p>You also can get most of it with nscd.<p>(Sigh, I wish BUS1 guys pushed their project to completion)</div><br/></div></div><div id="37910503" class="c"><input type="checkbox" id="c-37910503" checked=""/><div class="controls bullet"><span class="by">alexgartrell</span><span>|</span><a href="#37909386">root</a><span>|</span><a href="#37910251">parent</a><span>|</span><a href="#37910652">prev</a><span>|</span><a href="#37910598">next</a><span>|</span><label class="collapse" for="c-37910503">[-]</label><label class="expand" for="c-37910503">[1 more]</label></div><br/><div class="children"><div class="content">IME, familiarity with &#x2F;etc&#x2F;nsswitch.conf and the rest of the nss stuff is very highly correlated with people who have <i>seen some shit.</i></div><br/></div></div></div></div><div id="37910598" class="c"><input type="checkbox" id="c-37910598" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#37909386">parent</a><span>|</span><a href="#37910251">prev</a><span>|</span><a href="#37911628">next</a><span>|</span><label class="collapse" for="c-37910598">[-]</label><label class="expand" for="c-37910598">[1 more]</label></div><br/><div class="children"><div class="content">This, along with the general inability to handle per-interface DNS resolution, is the primary reason systemd-resolved exists.</div><br/></div></div></div></div><div id="37911310" class="c"><input type="checkbox" id="c-37911310" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37909386">prev</a><span>|</span><a href="#37908883">next</a><span>|</span><label class="collapse" for="c-37911310">[-]</label><label class="expand" for="c-37911310">[3 more]</label></div><br/><div class="children"><div class="content">There is no reason that `getenv()` should ever lock -- it should always be lock-free.  `putenv()`&#x2F;`setenv()`&#x2F;`unsetenv()` <i>can</i> lock, of course, since there&#x27;s no point allowing more than one writer at a time.<p>Don&#x27;t believe me?  Look at this work of art (the entire file!): <a href="https:&#x2F;&#x2F;src.illumos.org&#x2F;source&#x2F;xref&#x2F;illumos-gate&#x2F;usr&#x2F;src&#x2F;lib&#x2F;libc&#x2F;port&#x2F;gen&#x2F;getenv.c?r=60b81b86#48" rel="nofollow noreferrer">https:&#x2F;&#x2F;src.illumos.org&#x2F;source&#x2F;xref&#x2F;illumos-gate&#x2F;usr&#x2F;src&#x2F;lib...</a></div><br/><div id="37911367" class="c"><input type="checkbox" id="c-37911367" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#37911310">parent</a><span>|</span><a href="#37908883">next</a><span>|</span><label class="collapse" for="c-37911367">[-]</label><label class="expand" for="c-37911367">[2 more]</label></div><br/><div class="children"><div class="content">What are you trying to say using that example? The getenv() function shown calls initenv(), which can (clearly) take a lock?</div><br/><div id="37911429" class="c"><input type="checkbox" id="c-37911429" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37911310">root</a><span>|</span><a href="#37911367">parent</a><span>|</span><a href="#37908883">next</a><span>|</span><label class="collapse" for="c-37911429">[-]</label><label class="expand" for="c-37911429">[1 more]</label></div><br/><div class="children"><div class="content">One time.  Also, I think that could be removed with some care.</div><br/></div></div></div></div></div></div><div id="37908883" class="c"><input type="checkbox" id="c-37908883" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#37911310">prev</a><span>|</span><a href="#37909120">next</a><span>|</span><label class="collapse" for="c-37908883">[-]</label><label class="expand" for="c-37908883">[8 more]</label></div><br/><div class="children"><div class="content">Why would you ever call setenv after spawning threads though?<p>Or are there other sneaky calls which will do that behind you back?</div><br/><div id="37909044" class="c"><input type="checkbox" id="c-37909044" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#37908883">parent</a><span>|</span><a href="#37908921">next</a><span>|</span><label class="collapse" for="c-37909044">[-]</label><label class="expand" for="c-37909044">[2 more]</label></div><br/><div class="children"><div class="content">Well, that&#x27;s the gotcha isn&#x27;t it?<p>It&#x27;s easy to think about some complex interactive software where the need to call setenv appears only after you have worker threads doing some other thing. Without a warning, you won&#x27;t know it&#x27;s a bad thing to do, and the manpage only says that it and unsetenv are not thread safe, as if this was remotely enough information.<p>What nobody is telling is that the environment is so big that you need it to compress data or open an IPv6 connection. It&#x27;s not obvious at all that you can&#x27;t do those things while editing a variable.</div><br/><div id="37912030" class="c"><input type="checkbox" id="c-37912030" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37908883">root</a><span>|</span><a href="#37909044">parent</a><span>|</span><a href="#37908921">next</a><span>|</span><label class="collapse" for="c-37912030">[-]</label><label class="expand" for="c-37912030">[1 more]</label></div><br/><div class="children"><div class="content">There’s always a lot of weird emergent behavior in bootstrapping an app, and on an app of any serious size, I can’t entirely control if someone decides to spool up a thread pool on startup so that everything is hot before listen() happens.<p>I may think I have control, I may believe that a handful of us are <i>entitled</i> to have that say, but all it takes is someone adding a cross dependency that forces an existing piece of code to jump from 20th position in the load order to 6th and all hell can break loose. Or just as often, set a ticking time bomb that nobody notices until there’s a scaling or peak traffic event or someone adds one more small mistake to the code and foomp! up it goes.</div><br/></div></div></div></div><div id="37908921" class="c"><input type="checkbox" id="c-37908921" checked=""/><div class="controls bullet"><span class="by">numbsafari</span><span>|</span><a href="#37908883">parent</a><span>|</span><a href="#37909044">prev</a><span>|</span><a href="#37909120">next</a><span>|</span><label class="collapse" for="c-37908921">[-]</label><label class="expand" for="c-37908921">[5 more]</label></div><br/><div class="children"><div class="content">That’s literally explained in the article. It’s worth reading more than the headline.<p>Ed: actually, that’s even spelled out in the headline.</div><br/><div id="37909018" class="c"><input type="checkbox" id="c-37909018" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37908883">root</a><span>|</span><a href="#37908921">parent</a><span>|</span><a href="#37908980">next</a><span>|</span><label class="collapse" for="c-37909018">[-]</label><label class="expand" for="c-37909018">[1 more]</label></div><br/><div class="children"><div class="content">It’s neither in the headline or in the article. The question was about setenv, not getenv.<p>It is best to avoid calling setenv in a threaded program. Some programs do it to make space for rewriting argv with large strings (freeing space from *environ which tends to be right after the tail of argv). Some programs or libraries use *environ directly to stage variables for exec before forking. Some want to pass variable changes to forks. There are alternatives possible, but in the context of something like go calling libc setenv, it’s to make interop easier- sadly it may make other interop harder, such as this case.</div><br/></div></div><div id="37908980" class="c"><input type="checkbox" id="c-37908980" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#37908883">root</a><span>|</span><a href="#37908921">parent</a><span>|</span><a href="#37909018">prev</a><span>|</span><a href="#37908953">next</a><span>|</span><label class="collapse" for="c-37908980">[-]</label><label class="expand" for="c-37908980">[2 more]</label></div><br/><div class="children"><div class="content">? setenv not getenv.  You&#x27;d rarely use setenv, and even then you&#x27;d do it at startup.</div><br/><div id="37911848" class="c"><input type="checkbox" id="c-37911848" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#37908883">root</a><span>|</span><a href="#37908980">parent</a><span>|</span><a href="#37908953">next</a><span>|</span><label class="collapse" for="c-37911848">[-]</label><label class="expand" for="c-37911848">[1 more]</label></div><br/><div class="children"><div class="content">Right. That&#x27;s been my experience so far, hence my question.</div><br/></div></div></div></div><div id="37908953" class="c"><input type="checkbox" id="c-37908953" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#37908883">root</a><span>|</span><a href="#37908921">parent</a><span>|</span><a href="#37908980">prev</a><span>|</span><a href="#37909120">next</a><span>|</span><label class="collapse" for="c-37908953">[-]</label><label class="expand" for="c-37908953">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not.  OP was asking about setenv, not getenv...</div><br/></div></div></div></div></div></div><div id="37909120" class="c"><input type="checkbox" id="c-37909120" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#37908883">prev</a><span>|</span><a href="#37910992">next</a><span>|</span><label class="collapse" for="c-37909120">[-]</label><label class="expand" for="c-37909120">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if this only applies to the dns resolver, or also other NSS modules, like the systemd resolver. And don&#x27;t forget about nscd: if nscd is running, then all of the nsswitch stuff will be done out of process.<p>That might mean a viable workaround is enabling nscd, oddly enough.<p>And frankly, maybe libpthread should just overlay thread-safe getenv&#x2F;setenv like I believe it does for a couple of other libc symbols.</div><br/></div></div><div id="37910992" class="c"><input type="checkbox" id="c-37910992" checked=""/><div class="controls bullet"><span class="by">habibur</span><span>|</span><a href="#37909120">prev</a><span>|</span><a href="#37909038">next</a><span>|</span><label class="collapse" for="c-37910992">[-]</label><label class="expand" for="c-37910992">[6 more]</label></div><br/><div class="children"><div class="content">Which is why I have gotten rid of getaddrinfo() calls in my server code, and rather resolve DNS directly reading the DNS server setting from the system.<p>Other issues I faced :<p>- Not epoll() friendly. Always forks a process while resolving domain name.<p>- Valgrind complains of uninitialized memory touches when the function is called and I can&#x27;t get rid of it.</div><br/><div id="37911185" class="c"><input type="checkbox" id="c-37911185" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#37910992">parent</a><span>|</span><a href="#37909038">next</a><span>|</span><label class="collapse" for="c-37911185">[-]</label><label class="expand" for="c-37911185">[5 more]</label></div><br/><div class="children"><div class="content">how confident are you that the DNS settings you are honoring are the ones the user intended?<p>For example, in a split-VPN situation?</div><br/><div id="37911311" class="c"><input type="checkbox" id="c-37911311" checked=""/><div class="controls bullet"><span class="by">habibur</span><span>|</span><a href="#37910992">root</a><span>|</span><a href="#37911185">parent</a><span>|</span><a href="#37909038">next</a><span>|</span><label class="collapse" for="c-37911311">[-]</label><label class="expand" for="c-37911311">[4 more]</label></div><br/><div class="children"><div class="content">Those redirections happen further in the stack. You are ok reading settings from &#x2F;etc&#x2F;resolve.conf, which frequently points to a localhost daemon that redirects your calls to whatever DNS setting you have in your connection.<p>But parsing &#x2F;etc&#x2F;resolve.conf and using it is all that you need in your code.</div><br/><div id="37911748" class="c"><input type="checkbox" id="c-37911748" checked=""/><div class="controls bullet"><span class="by">uxp8u61q</span><span>|</span><a href="#37910992">root</a><span>|</span><a href="#37911311">parent</a><span>|</span><a href="#37911642">next</a><span>|</span><label class="collapse" for="c-37911748">[-]</label><label class="expand" for="c-37911748">[1 more]</label></div><br/><div class="children"><div class="content">Your complete lack of mention of nsswitch.conf makes me believe that you&#x27;re not implenting anything correctly in this instance.</div><br/></div></div><div id="37911642" class="c"><input type="checkbox" id="c-37911642" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#37910992">root</a><span>|</span><a href="#37911311">parent</a><span>|</span><a href="#37911748">prev</a><span>|</span><a href="#37909038">next</a><span>|</span><label class="collapse" for="c-37911642">[-]</label><label class="expand" for="c-37911642">[2 more]</label></div><br/><div class="children"><div class="content">And your code correctly parses all the options that can be in that file?</div><br/><div id="37912068" class="c"><input type="checkbox" id="c-37912068" checked=""/><div class="controls bullet"><span class="by">habibur</span><span>|</span><a href="#37910992">root</a><span>|</span><a href="#37911642">parent</a><span>|</span><a href="#37909038">next</a><span>|</span><label class="collapse" for="c-37912068">[-]</label><label class="expand" for="c-37912068">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need all the options. Search google. Parsing resolve.conf is an old technique and the file was written assuming individual apps will be parsing it. You will find instructions on how to do it in say 4 lines. Explicitly for this file. Not any random conf file from the system.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37909038" class="c"><input type="checkbox" id="c-37909038" checked=""/><div class="controls bullet"><span class="by">jxy</span><span>|</span><a href="#37910992">prev</a><span>|</span><a href="#37910689">next</a><span>|</span><label class="collapse" for="c-37909038">[-]</label><label class="expand" for="c-37909038">[6 more]</label></div><br/><div class="children"><div class="content">Either Linux&#x27;s fault or Glibc&#x27;s fault.<p>POSIX mandates getaddrinfo to be thread safe.</div><br/><div id="37910523" class="c"><input type="checkbox" id="c-37910523" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37909038">parent</a><span>|</span><a href="#37911097">next</a><span>|</span><label class="collapse" for="c-37910523">[-]</label><label class="expand" for="c-37910523">[3 more]</label></div><br/><div class="children"><div class="content">Yes, but `setenv` is documented as not thread-safe.<p>Once you do unsafe things, the nasal demons can spread to safe code elsewhere.<p>Glibc&#x27;s documentation is more explicit about the propogation of the nasal demons:<p><pre><code>       ┌─────────────────────┬───────────────┬─────────────────────┐
       │Interface            │ Attribute     │ Value               │
       ├─────────────────────┼───────────────┼─────────────────────┤
       │setenv(), unsetenv() │ Thread safety │ MT-Unsafe const:env │
       └─────────────────────┴───────────────┴─────────────────────┘
       ┌────────────────┬───────────────┬────────────────────┐
       │Interface       │ Attribute     │ Value              │
       ├────────────────┼───────────────┼────────────────────┤
       │getaddrinfo()   │ Thread safety │ MT-Safe env locale │
       ├────────────────┼───────────────┼────────────────────┤
       │freeaddrinfo(), │ Thread safety │ MT-Safe            │
       │gai_strerror()  │               │                    │
       └────────────────┴───────────────┴────────────────────┘</code></pre></div><br/><div id="37911906" class="c"><input type="checkbox" id="c-37911906" checked=""/><div class="controls bullet"><span class="by">anttihaapala</span><span>|</span><a href="#37909038">root</a><span>|</span><a href="#37910523">parent</a><span>|</span><a href="#37911753">next</a><span>|</span><label class="collapse" for="c-37911906">[-]</label><label class="expand" for="c-37911906">[1 more]</label></div><br/><div class="children"><div class="content">This! And the attributes page explains these even better:<p><pre><code>       const  Functions marked with const as an MT-Safety issue non-
              atomically modify internal objects that are better
              regarded as constant, because a substantial portion of the
              GNU C Library accesses them without synchronization.
              Unlike race, which causes both readers and writers of
              internal objects to be regarded as MT-Unsafe, this mark is
              applied to writers only.  Writers remain MT-Unsafe to
              call, but the then-mandatory constness of objects they
              modify enables readers to be regarded as MT-Safe (as long
              as no other reasons for them to be unsafe remain), since
              the lack of synchronization is not a problem when the
              objects are effectively constant.

              The identifier that follows the const mark will appear by
              itself as a safety note in readers.  Programs that wish to
              work around this safety issue, so as to call writers, may
              use a non-recursive read-write lock associated with the
              identifier, and guard all calls to functions marked with
              const followed by the identifier with a write lock, and
              all calls to functions marked with the identifier by
              itself with a read lock.
</code></pre>
and<p><pre><code>       env    Functions marked with env as an MT-Safety issue access the
              environment with getenv(3) or similar, without any guards
              to ensure safety in the presence of concurrent
              modifications.

              We do not mark these functions as MT-Unsafe, however,
              because functions that modify the environment are all
              marked with const:env and regarded as unsafe.  Being
              unsafe, the latter are not to be called when multiple
              threads are running or asynchronous signals are enabled,
              and so the environment can be considered effectively
              constant in these contexts, which makes the former safe.</code></pre></div><br/></div></div><div id="37911753" class="c"><input type="checkbox" id="c-37911753" checked=""/><div class="controls bullet"><span class="by">uxp8u61q</span><span>|</span><a href="#37909038">root</a><span>|</span><a href="#37910523">parent</a><span>|</span><a href="#37911906">prev</a><span>|</span><a href="#37911097">next</a><span>|</span><label class="collapse" for="c-37911753">[-]</label><label class="expand" for="c-37911753">[1 more]</label></div><br/><div class="children"><div class="content">This table is unreadable on a narrow screen.</div><br/></div></div></div></div><div id="37911097" class="c"><input type="checkbox" id="c-37911097" checked=""/><div class="controls bullet"><span class="by">mmis1000</span><span>|</span><a href="#37909038">parent</a><span>|</span><a href="#37910523">prev</a><span>|</span><a href="#37909169">next</a><span>|</span><label class="collapse" for="c-37911097">[-]</label><label class="expand" for="c-37911097">[1 more]</label></div><br/><div class="children"><div class="content">The general rule of unsafe api(usage) is &quot;once you done it, nothing is expected to safe even if it was stated to be&quot;.<p>Error can spread in your program in funny way, which also break the program in funny way (think about stack overflow or double free).<p>Unless the manual&#x2F;document explicitly stated what error can it cause, there is no way to know without actually trigger it.</div><br/></div></div><div id="37909169" class="c"><input type="checkbox" id="c-37909169" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37909038">parent</a><span>|</span><a href="#37911097">prev</a><span>|</span><a href="#37910689">next</a><span>|</span><label class="collapse" for="c-37909169">[-]</label><label class="expand" for="c-37909169">[1 more]</label></div><br/><div class="children"><div class="content">glibc, I’m too lazy to lookup if it removes the getenv lookup with posix build flags.</div><br/></div></div></div></div><div id="37910689" class="c"><input type="checkbox" id="c-37910689" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#37909038">prev</a><span>|</span><a href="#37909441">next</a><span>|</span><label class="collapse" for="c-37910689">[-]</label><label class="expand" for="c-37910689">[2 more]</label></div><br/><div class="children"><div class="content">It’s easy to sterilize your code in this regard (although as this article points out you need to know to do it).<p>POSIX implements a three-argument `main` function (just look at `exec()`) where the third argument is `char* envp[]`.  You can call `setenv` to manipulate it.<p>But easiest is to just null out the POSIX extern `char* environ` (save a copy if you want to consult it yourself later).  Just `man 7 environ`</div><br/><div id="37910855" class="c"><input type="checkbox" id="c-37910855" checked=""/><div class="controls bullet"><span class="by">naruhodo</span><span>|</span><a href="#37910689">parent</a><span>|</span><a href="#37909441">next</a><span>|</span><label class="collapse" for="c-37910855">[-]</label><label class="expand" for="c-37910855">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not clear from the man pages, but `setenv()` mutates `environ`.<p>In particular, setting a previously-undefined variable causes `environ` to be reallocated. Whereas `setenv()` of an extant variable changes just that value in the current `environ` pointer array.</div><br/></div></div></div></div><div id="37909441" class="c"><input type="checkbox" id="c-37909441" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37910689">prev</a><span>|</span><a href="#37909028">next</a><span>|</span><label class="collapse" for="c-37909441">[-]</label><label class="expand" for="c-37909441">[4 more]</label></div><br/><div class="children"><div class="content">Keep in mind: Don&#x27;t use multiple threads unless you really, <i>really</i> need to, and have thought long and hard about concurrency issues.<p>In a way, I think the fact that many library functions are not thread-safe should be viewed as an encouragement to not use threads, or use them only for the bare minimum necessary.<p>I say this from a few decades of experience fighting with race conditions and the like, and whereupon several times I rewrote an existing multithreaded process into a single-threaded one and greatly improved performance and reduced memory usage. The architecture astronauts may have moved on to stuff like microservices now, but in the 90s&#x2F;2000s threads were overused just as much.</div><br/><div id="37910001" class="c"><input type="checkbox" id="c-37910001" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#37909441">parent</a><span>|</span><a href="#37911570">next</a><span>|</span><label class="collapse" for="c-37910001">[-]</label><label class="expand" for="c-37910001">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s basically impossible in many modern programming environments - even if you never spawn a thread, something else in your executable probably has.  By the time your iOS or macOS app has finished launching, it has multiple threads.  The Windows loader uses threads to load DLLs.</div><br/></div></div><div id="37911570" class="c"><input type="checkbox" id="c-37911570" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37909441">parent</a><span>|</span><a href="#37910001">prev</a><span>|</span><a href="#37909947">next</a><span>|</span><label class="collapse" for="c-37911570">[-]</label><label class="expand" for="c-37911570">[1 more]</label></div><br/><div class="children"><div class="content">For one, if you are using getaddrinfo you are often forced to use threads as gai is a slow blocking call.</div><br/></div></div><div id="37909947" class="c"><input type="checkbox" id="c-37909947" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#37909441">parent</a><span>|</span><a href="#37911570">prev</a><span>|</span><a href="#37909028">next</a><span>|</span><label class="collapse" for="c-37909947">[-]</label><label class="expand" for="c-37909947">[1 more]</label></div><br/><div class="children"><div class="content">There are many ways to do multiple threads wrong.  Seems that the &quot;right way&quot; is to wake up a sleeping but already-created thread, and take elements out of a work queue in a threadsafe way.  Your main thread can even be processing elements during the 10000 clock cycles it takes to wake up a thread.</div><br/></div></div></div></div><div id="37909028" class="c"><input type="checkbox" id="c-37909028" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#37909441">prev</a><span>|</span><a href="#37911219">next</a><span>|</span><label class="collapse" for="c-37909028">[-]</label><label class="expand" for="c-37909028">[8 more]</label></div><br/><div class="children"><div class="content">getaddrinfo is terrible. Did you know it also opens and then connects to a socket? Any process that uses getaddrinfo needs a blanket exception in my firewall in order to work properly, because otherwise it will fail to connect to some randomly-generated port that it just made up.</div><br/><div id="37909440" class="c"><input type="checkbox" id="c-37909440" checked=""/><div class="controls bullet"><span class="by">Sprocklem</span><span>|</span><a href="#37909028">parent</a><span>|</span><a href="#37909155">next</a><span>|</span><label class="collapse" for="c-37909440">[-]</label><label class="expand" for="c-37909440">[5 more]</label></div><br/><div class="children"><div class="content">How do you propose that DNS resolution precede without opening a socket?</div><br/><div id="37910392" class="c"><input type="checkbox" id="c-37910392" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#37909028">root</a><span>|</span><a href="#37909440">parent</a><span>|</span><a href="#37909929">next</a><span>|</span><label class="collapse" for="c-37910392">[-]</label><label class="expand" for="c-37910392">[1 more]</label></div><br/><div class="children"><div class="content">It opens a socket <i>to the same process that called getaddrinfo</i>. That is, it&#x27;s just communicating with itself, using a brand-new randomly-generated port for each call. This should be completely unnecessary.</div><br/></div></div><div id="37909929" class="c"><input type="checkbox" id="c-37909929" checked=""/><div class="controls bullet"><span class="by">nomadluap</span><span>|</span><a href="#37909028">root</a><span>|</span><a href="#37909440">parent</a><span>|</span><a href="#37910392">prev</a><span>|</span><a href="#37909155">next</a><span>|</span><label class="collapse" for="c-37909929">[-]</label><label class="expand" for="c-37909929">[3 more]</label></div><br/><div class="children"><div class="content">For one thing, it could delegate to a local service. Granted, the communication to this service is probably still be over a socket interface, but at least as a purely-local connection you would hopefully have some better worst-case performance characteristics.<p>This is basically what dnsmasq does when you use it as a local DNS cache.</div><br/><div id="37910161" class="c"><input type="checkbox" id="c-37910161" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#37909028">root</a><span>|</span><a href="#37909929">parent</a><span>|</span><a href="#37909155">next</a><span>|</span><label class="collapse" for="c-37910161">[-]</label><label class="expand" for="c-37910161">[2 more]</label></div><br/><div class="children"><div class="content">Completely agree. Just use systemd-resolved which is the recommended way of doing DNS anyway.</div><br/><div id="37911659" class="c"><input type="checkbox" id="c-37911659" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#37909028">root</a><span>|</span><a href="#37910161">parent</a><span>|</span><a href="#37909155">next</a><span>|</span><label class="collapse" for="c-37911659">[-]</label><label class="expand" for="c-37911659">[1 more]</label></div><br/><div class="children"><div class="content">And how do you communicate with systemd-resolved?</div><br/></div></div></div></div></div></div></div></div><div id="37909155" class="c"><input type="checkbox" id="c-37909155" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37909028">parent</a><span>|</span><a href="#37909440">prev</a><span>|</span><a href="#37909256">next</a><span>|</span><label class="collapse" for="c-37909155">[-]</label><label class="expand" for="c-37909155">[1 more]</label></div><br/><div class="children"><div class="content">What should I use instead that doesn&#x27;t open a socket?</div><br/></div></div><div id="37909256" class="c"><input type="checkbox" id="c-37909256" checked=""/><div class="controls bullet"><span class="by">hknapp</span><span>|</span><a href="#37909028">parent</a><span>|</span><a href="#37909155">prev</a><span>|</span><a href="#37911219">next</a><span>|</span><label class="collapse" for="c-37909256">[-]</label><label class="expand" for="c-37909256">[1 more]</label></div><br/><div class="children"><div class="content">They probably could have given a more apt name</div><br/></div></div></div></div><div id="37911219" class="c"><input type="checkbox" id="c-37911219" checked=""/><div class="controls bullet"><span class="by">dur-randir</span><span>|</span><a href="#37909028">prev</a><span>|</span><a href="#37909832">next</a><span>|</span><label class="collapse" for="c-37911219">[-]</label><label class="expand" for="c-37911219">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve once spent 3 months debugging crash caused by this.</div><br/></div></div><div id="37911022" class="c"><input type="checkbox" id="c-37911022" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37909832">prev</a><span>|</span><a href="#37909674">next</a><span>|</span><label class="collapse" for="c-37911022">[-]</label><label class="expand" for="c-37911022">[1 more]</label></div><br/><div class="children"><div class="content">getenv() could be made thread-safe by leaking the memory returned.</div><br/></div></div><div id="37909674" class="c"><input type="checkbox" id="c-37909674" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37911022">prev</a><span>|</span><a href="#37910004">next</a><span>|</span><label class="collapse" for="c-37909674">[-]</label><label class="expand" for="c-37909674">[16 more]</label></div><br/><div class="children"><div class="content">this is not a unix beartrap, this is a bug in Go if that&#x27;s where it was found. If your code is multithreaded, it&#x27;s up to you to make it threadsafe. You can&#x27;t declare you&#x27;re creating the most threadsafe memorysafe newbie safe system, and then go home. You have to write the code.<p>Your program gets its own copy of the environment when the program was launched. Nobody is changing it on you, any contention for that resource is you contending with yourself.<p>You don&#x27;t expect an operating system to change things out from under you. Unix doesn&#x27;t. If there is contention for this resource, it&#x27;s all you (or whoever wrote the library you are using)<p>The environment is name-value pairs, as strings. That&#x27;s it. That&#x27;s what makes it accessible and useful. You can swallow it up, the whole thing, into whatever data structure you prefer in your language in a few lines of code, and a millisecond (if that much) of runtime. Just learn how things work and you won&#x27;t feel helpless.</div><br/><div id="37909719" class="c"><input type="checkbox" id="c-37909719" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#37909674">parent</a><span>|</span><a href="#37910876">next</a><span>|</span><label class="collapse" for="c-37909719">[-]</label><label class="expand" for="c-37909719">[6 more]</label></div><br/><div class="children"><div class="content">Most people would expect getaddrinfo to be re-entrant, and in the Linux man 3 page it is: <a href="https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;getaddrinfo.3.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;getaddrinfo.3.html</a><p>There is no <i>clear&#x2F;obvious</i> mention of the fact that setenv could interfere with it. It is a glibc footgun&#x2F;beartrap that this re-entrancy <i>doesn&#x27;t</i> actually mean calling it with non-shared memory in the arguments ensures no data races.</div><br/><div id="37909757" class="c"><input type="checkbox" id="c-37909757" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909719">parent</a><span>|</span><a href="#37911595">next</a><span>|</span><label class="collapse" for="c-37909757">[-]</label><label class="expand" for="c-37909757">[3 more]</label></div><br/><div class="children"><div class="content">there could very well be a bug. if there&#x27;s a bug, fix it.<p>But from what I read, it&#x27;s documented as not threadsafe and this problem is happening in a threaded environment. That still could be called a bug. You find bugs, you fix them;<p>That&#x27;s better than hyperventilating about how there is some massive problem with an operating system that you are using because all the people who came before you who knew more than you decided it was the best thing to use. The other OSes sucked more. This OS is simple enough that you can actually learn how it works, it&#x27;s all laid out in front of you.<p>Should it do some additional things? sure. Help write the code.</div><br/><div id="37909849" class="c"><input type="checkbox" id="c-37909849" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909757">parent</a><span>|</span><a href="#37911595">next</a><span>|</span><label class="collapse" for="c-37909849">[-]</label><label class="expand" for="c-37909849">[2 more]</label></div><br/><div class="children"><div class="content">A beartrap&#x2F;footgun means &quot;a bit too easy to harm yourself for comfort&quot;, not &quot;there is a bug&quot;. I am relatively old and have been programming to this interface for a few decades, so I&#x27;m not hyperventilating about it.<p>My point (which made reference to the actual OS documentation) was that it takes being bit by such issues before you learn what this &quot;Attributes&quot; section means:<p>&gt; │Interface                  │ Attribute     │ Value              │<p>&gt; │getaddrinfo()              │ Thread safety │ MT-Safe env locale │<p>For the 1st decade of my career, I just searched for &quot;re-entrant&quot;, &quot;reentrant&quot;, or &quot;MT&quot; and went on my merry way, without realizing the importance of the other possible values of attributes table: in this case &quot;env&quot;.<p>It&#x27;s worth highlighting!</div><br/><div id="37911242" class="c"><input type="checkbox" id="c-37911242" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909849">parent</a><span>|</span><a href="#37911595">next</a><span>|</span><label class="collapse" for="c-37911242">[-]</label><label class="expand" for="c-37911242">[1 more]</label></div><br/><div class="children"><div class="content">when you read the doc and realized you missed something, don&#x27;t say &quot;footgun&quot;, say &quot;aha! I misunderstood&quot; Then if you want, set about to make things better.<p>Instead of jumping to &quot;It shouldn&#x27;t work this way&quot; consider &quot;Hmmm, why does it work this way? Is it possible that Thompson, Kernighan and Ritchie knew more about how to make a coherent straightforward system that would last 50 years in 1970 than I know how to now?&quot;</div><br/></div></div></div></div></div></div><div id="37911595" class="c"><input type="checkbox" id="c-37911595" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909719">parent</a><span>|</span><a href="#37909757">prev</a><span>|</span><a href="#37911366">next</a><span>|</span><label class="collapse" for="c-37911595">[-]</label><label class="expand" for="c-37911595">[1 more]</label></div><br/><div class="children"><div class="content">In the attribute  table, thread safety is clearly marked as &quot;Thread-Safe, env&quot;, with a link just below explaining the meaning of the attributes.<p>As many things, the behaviour is surprising and can be overlooked. But undocumented is not.</div><br/></div></div><div id="37911366" class="c"><input type="checkbox" id="c-37911366" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909719">parent</a><span>|</span><a href="#37911595">prev</a><span>|</span><a href="#37910876">next</a><span>|</span><label class="collapse" for="c-37911366">[-]</label><label class="expand" for="c-37911366">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>       ┌───────────────────────────┬───────────────┬────────────────────┐
       │Interface                  │ Attribute     │ Value              │
       ├───────────────────────────┼───────────────┼────────────────────┤
       │getaddrinfo()              │ Thread safety │ MT-Safe env locale │
       ├───────────────────────────┼───────────────┼────────────────────┤
       │freeaddrinfo(),            │ Thread safety │ MT-Safe            │
       │gai_strerror()             │               │                    │
       └───────────────────────────┴───────────────┴────────────────────┘


       MT-Safe
              MT-Safe or Thread-Safe functions are safe to call in the
              presence of other threads.  MT, in MT-Safe, stands for
              Multi Thread.

              Being MT-Safe does not imply a function is atomic, nor
              that it uses any of the memory synchronization mechanisms
              POSIX exposes to users.  It is even possible that calling
              MT-Safe functions in sequence does not yield an MT-Safe
              combination.  For example, having a thread call two MT-
              Safe functions one right after the other does not
              guarantee behavior equivalent to atomic execution of a
              combination of both functions, since concurrent calls in
              other threads may interfere in a destructive way.

              Whole-program optimizations that could inline functions
              across library interfaces may expose unsafe reordering,
              and so performing inlining across the GNU C Library
              interface is not recommended.  The documented MT-Safety
              status is not guaranteed under whole-program optimization.
              However, functions defined in user-visible headers are
              designed to be safe for inlining.


   Other safety remarks
       Additional keywords may be attached to functions, indicating
       features that do not make a function unsafe to call, but that may
       need to be taken into account in certain classes of programs:

       locale Functions annotated with locale as an MT-Safety issue read
              from the locale object without any form of
              synchronization.  Functions annotated with locale called
              concurrently with locale changes may behave in ways that
              do not correspond to any of the locales active during
              their execution, but an unpredictable mix thereof.

              We do not mark these functions as MT-Unsafe, however,
              because functions that modify the locale object are marked
              with const:locale and regarded as unsafe.  Being unsafe,
              the latter are not to be called when multiple threads are
              running or asynchronous signals are enabled, and so the
              locale can be considered effectively constant in these
              contexts, which makes the former safe.

       env    Functions marked with env as an MT-Safety issue access the
              environment with getenv(3) or similar, without any guards
              to ensure safety in the presence of concurrent
              modifications.

              We do not mark these functions as MT-Unsafe, however,
              because functions that modify the environment are all
              marked with const:env and regarded as unsafe.  Being
              unsafe, the latter are not to be called when multiple
              threads are running or asynchronous signals are enabled,
              and so the environment can be considered effectively
              constant in these contexts, which makes the former safe.</code></pre></div><br/></div></div></div></div><div id="37910876" class="c"><input type="checkbox" id="c-37910876" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37909674">parent</a><span>|</span><a href="#37909719">prev</a><span>|</span><a href="#37909695">next</a><span>|</span><label class="collapse" for="c-37910876">[-]</label><label class="expand" for="c-37910876">[3 more]</label></div><br/><div class="children"><div class="content">This is the viewpoint of someone who works alone or on small teams, where all the code in the process is their own. In a complex program there is plenty that can do surprising things that you didn’t expect.</div><br/><div id="37911087" class="c"><input type="checkbox" id="c-37911087" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37910876">parent</a><span>|</span><a href="#37909695">next</a><span>|</span><label class="collapse" for="c-37911087">[-]</label><label class="expand" for="c-37911087">[2 more]</label></div><br/><div class="children"><div class="content">no, this is a person who understands what is there. People who imagine something else is there, are disappointed when it&#x27;s not.<p>People who try to invent the new <i>new</i>, and don&#x27;t complete the task, blame unix, when unix just does what unix said it would do. It was the people who made bigger claims but did not deliver who should step up and say &quot;I didn&#x27;t turn the unix environment into what I thought I did.&quot;<p>but people trying to invent the new <i>new</i> are trying to invent it on unix because unix delivers what it promises. It doesn&#x27;t deliver what <i>you</i> promise. But have some humility, and accept your failure and don&#x27;t try to pin it on unix. Go implement on Windows.<p>Unix does allow you to deliver what you promise, that&#x27;s why you&#x27;ll still be complaining about unix 10 years from now, but it&#x27;s up to you to deliver what you promise.<p>people who say &quot;footgun&quot; are people who try to shed responsibility; &quot;it wasn&#x27;t my fault, waaaaaah&quot;. I&#x27;m not saying we should not make computers easier to program, I&#x27;m saying that when we fail to: &quot;it&#x27;s a poor worker who blames his tools.&quot;<p>Why is it so important to you to blame this on unix, when you could blame it on a mistaken implementation of a library that could be fixed?</div><br/><div id="37911860" class="c"><input type="checkbox" id="c-37911860" checked=""/><div class="controls bullet"><span class="by">moring</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37911087">parent</a><span>|</span><a href="#37909695">next</a><span>|</span><label class="collapse" for="c-37911860">[-]</label><label class="expand" for="c-37911860">[1 more]</label></div><br/><div class="children"><div class="content">The words &quot;blame&quot; and &quot;guilt&quot; do not even appear in the article, and &quot;fault&quot; only as part of &quot;segfaulting&quot;. Rachel merely points out an easy-to-make mistake before others make them, to save them time. She isn&#x27;t talking about who is to blame. No need to get defensive.</div><br/></div></div></div></div></div></div><div id="37909695" class="c"><input type="checkbox" id="c-37909695" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#37909674">parent</a><span>|</span><a href="#37910876">prev</a><span>|</span><a href="#37910004">next</a><span>|</span><label class="collapse" for="c-37909695">[-]</label><label class="expand" for="c-37909695">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused, aren&#x27;t we talking about the getaddrinfo() syscall?<p>It definitely seems like that syscall is a (multithreaded) footgun that Go just happened to hit.</div><br/><div id="37909743" class="c"><input type="checkbox" id="c-37909743" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909695">parent</a><span>|</span><a href="#37909730">next</a><span>|</span><label class="collapse" for="c-37909743">[-]</label><label class="expand" for="c-37909743">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a syscall, it&#x27;s a C standard library function that may read files, talk to dbus, read env vars, etc. The problem is people quite understandably expect its re-entrancy to mean more than it really means.</div><br/><div id="37909749" class="c"><input type="checkbox" id="c-37909749" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909743">parent</a><span>|</span><a href="#37909730">next</a><span>|</span><label class="collapse" for="c-37909749">[-]</label><label class="expand" for="c-37909749">[2 more]</label></div><br/><div class="children"><div class="content">Oh, that&#x27;s my error.  Shows you how much code I write that calls into libc, i.e. almost none.</div><br/><div id="37912082" class="c"><input type="checkbox" id="c-37912082" checked=""/><div class="controls bullet"><span class="by">Macha</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909749">parent</a><span>|</span><a href="#37909730">next</a><span>|</span><label class="collapse" for="c-37912082">[-]</label><label class="expand" for="c-37912082">[1 more]</label></div><br/><div class="children"><div class="content">If you write anything other than Go or Zig on Linux, you&#x27;re probably calling libc without realising.</div><br/></div></div></div></div></div></div><div id="37909730" class="c"><input type="checkbox" id="c-37909730" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909695">parent</a><span>|</span><a href="#37909743">prev</a><span>|</span><a href="#37910004">next</a><span>|</span><label class="collapse" for="c-37909730">[-]</label><label class="expand" for="c-37909730">[2 more]</label></div><br/><div class="children"><div class="content">a &quot;syscall&quot; is not going to call back into your code to get the environment. If a &quot;syscall&quot; is using your environment, it&#x27;s part of your code, probably better described as a library call.</div><br/><div id="37910871" class="c"><input type="checkbox" id="c-37910871" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37909674">root</a><span>|</span><a href="#37909730">parent</a><span>|</span><a href="#37910004">next</a><span>|</span><label class="collapse" for="c-37910871">[-]</label><label class="expand" for="c-37910871">[1 more]</label></div><br/><div class="children"><div class="content">Few people make raw syscalls.</div><br/></div></div></div></div></div></div></div></div><div id="37910004" class="c"><input type="checkbox" id="c-37910004" checked=""/><div class="controls bullet"><span class="by">jakeogh</span><span>|</span><a href="#37909674">prev</a><span>|</span><a href="#37908896">next</a><span>|</span><label class="collapse" for="c-37910004">[-]</label><label class="expand" for="c-37910004">[2 more]</label></div><br/><div class="children"><div class="content">musl: <a href="https:&#x2F;&#x2F;git.musl-libc.org&#x2F;cgit&#x2F;musl&#x2F;tree&#x2F;src&#x2F;network&#x2F;getaddrinfo.c" rel="nofollow noreferrer">https:&#x2F;&#x2F;git.musl-libc.org&#x2F;cgit&#x2F;musl&#x2F;tree&#x2F;src&#x2F;network&#x2F;getaddr...</a></div><br/><div id="37910863" class="c"><input type="checkbox" id="c-37910863" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37910004">parent</a><span>|</span><a href="#37908896">next</a><span>|</span><label class="collapse" for="c-37910863">[-]</label><label class="expand" for="c-37910863">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that’s why nobody likes musl’s DNS.</div><br/></div></div></div></div><div id="37908896" class="c"><input type="checkbox" id="c-37908896" checked=""/><div class="controls bullet"><span class="by">ForkMeOnTinder</span><span>|</span><a href="#37910004">prev</a><span>|</span><a href="#37908886">next</a><span>|</span><label class="collapse" for="c-37908896">[-]</label><label class="expand" for="c-37908896">[45 more]</label></div><br/><div class="children"><div class="content">Stuff like this is why I&#x27;m supportive of newer languages like Go and Zig that sidestep libc entirely (when not using cgo as in TFA of course). libc is a great achievement and has served us well but, boy, it sure is a product of its time.<p>`errno` is another relic that needs to die yesterday.</div><br/><div id="37908950" class="c"><input type="checkbox" id="c-37908950" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#37908896">parent</a><span>|</span><a href="#37909057">next</a><span>|</span><label class="collapse" for="c-37908950">[-]</label><label class="expand" for="c-37908950">[8 more]</label></div><br/><div class="children"><div class="content">Depending on the operating system, you can&#x27;t skip libc even in Go. I think it&#x27;s required on openbsd and illumos&#x2F;solaris for example.<p><a href="https:&#x2F;&#x2F;utcc.utoronto.ca&#x2F;~cks&#x2F;space&#x2F;blog&#x2F;programming&#x2F;Go116OpenBSDUsesLibc" rel="nofollow noreferrer">https:&#x2F;&#x2F;utcc.utoronto.ca&#x2F;~cks&#x2F;space&#x2F;blog&#x2F;programming&#x2F;Go116Op...</a></div><br/><div id="37911436" class="c"><input type="checkbox" id="c-37911436" checked=""/><div class="controls bullet"><span class="by">beebmam</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37908950">parent</a><span>|</span><a href="#37908999">next</a><span>|</span><label class="collapse" for="c-37911436">[-]</label><label class="expand" for="c-37911436">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s the same in Windows, right? Can&#x27;t use the syscalls underneath the hood, everything through the standard libraries. Maybe I&#x27;m wrong (I know very little about Windows other than how to use it to play games, and WSL)</div><br/><div id="37911540" class="c"><input type="checkbox" id="c-37911540" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37911436">parent</a><span>|</span><a href="#37911587">next</a><span>|</span><label class="collapse" for="c-37911540">[-]</label><label class="expand" for="c-37911540">[1 more]</label></div><br/><div class="children"><div class="content">The standard libraries on Windows don&#x27;t involve libc.
The Windows APIs look rather different, and in general are much more friendly to multi-threading. POSIX on the other hand tends to assume that the program is in control of everything happening inside of it, which is an incorrect assumption due to libraries.<p>In this particular case, the Windows APIs have neither getaddrinfo() nor getenv(); and the closest equivalent GetEnvironmentVariableW is perfectly thread-safe.
Microsoft additionally has a C runtime (msvcrt) providing functions like getenv(), but this is much less fundamental than it is on other system. Every program is supposed to ship its own copy of the C runtime, it&#x27;s not officially part of Windows! And it&#x27;s perfectly possible for multiple different copies of the C runtime to be loaded into the same Windows process. And since *environ is a variable defined by the C runtime, there&#x27;s a different copy for each C runtime...</div><br/></div></div><div id="37911587" class="c"><input type="checkbox" id="c-37911587" checked=""/><div class="controls bullet"><span class="by">roblabla</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37911436">parent</a><span>|</span><a href="#37911540">prev</a><span>|</span><a href="#37908999">next</a><span>|</span><label class="collapse" for="c-37911587">[-]</label><label class="expand" for="c-37911587">[1 more]</label></div><br/><div class="children"><div class="content">On windows it’s somewhat possible to avoid most of it by linking to ntdll, which only provides symbols for raw syscall wrappers. But a lot of it is unstable and may change from a windows release to the next.<p>Doing raw syscalls without ntdll is also possible, but windows syscall numbers change on essentially every release, so you’d end up with something that only works on your windows version.</div><br/></div></div></div></div><div id="37908999" class="c"><input type="checkbox" id="c-37908999" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37908950">parent</a><span>|</span><a href="#37911436">prev</a><span>|</span><a href="#37909057">next</a><span>|</span><label class="collapse" for="c-37908999">[-]</label><label class="expand" for="c-37908999">[4 more]</label></div><br/><div class="children"><div class="content">golang used to break all the time on macOS, because it was using the syscall ABI, which isn&#x27;t stable, instead of libSystem, which is.</div><br/><div id="37911058" class="c"><input type="checkbox" id="c-37911058" checked=""/><div class="controls bullet"><span class="by">dottedmag</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37908999">parent</a><span>|</span><a href="#37909057">next</a><span>|</span><label class="collapse" for="c-37911058">[-]</label><label class="expand" for="c-37911058">[3 more]</label></div><br/><div class="children"><div class="content">It has been fixed recently-ish.</div><br/><div id="37911522" class="c"><input type="checkbox" id="c-37911522" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37911058">parent</a><span>|</span><a href="#37911441">next</a><span>|</span><label class="collapse" for="c-37911522">[-]</label><label class="expand" for="c-37911522">[1 more]</label></div><br/><div class="children"><div class="content">it was fixed by using-the-system-libs</div><br/></div></div><div id="37911441" class="c"><input type="checkbox" id="c-37911441" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37911058">parent</a><span>|</span><a href="#37911522">prev</a><span>|</span><a href="#37909057">next</a><span>|</span><label class="collapse" for="c-37911441">[-]</label><label class="expand" for="c-37911441">[1 more]</label></div><br/><div class="children"><div class="content">A long time ago, but AFAIK the fix was “use the system&#x27;s libc”.</div><br/></div></div></div></div></div></div></div></div><div id="37909057" class="c"><input type="checkbox" id="c-37909057" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#37908896">parent</a><span>|</span><a href="#37908950">prev</a><span>|</span><a href="#37909152">next</a><span>|</span><label class="collapse" for="c-37909057">[-]</label><label class="expand" for="c-37909057">[3 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been building everything with CGO_ENABLED=0 for years now, with no nasty side effects.  It gets to be a pain using the default, when something as innocuous as a point version of a Docker image breaks compatibility because of a glibc version change[1].<p>[1] golang official image 1.20.4 to 1.20.5 went from Debian 11 to 12 base.  Always use the -(debian version) tags.</div><br/><div id="37910766" class="c"><input type="checkbox" id="c-37910766" checked=""/><div class="controls bullet"><span class="by">X-Istence</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909057">parent</a><span>|</span><a href="#37909152">next</a><span>|</span><label class="collapse" for="c-37910766">[-]</label><label class="expand" for="c-37910766">[2 more]</label></div><br/><div class="children"><div class="content">Split DNS is broken on macOS when doing that, and for users with VPN that does split DNS it is not just an annoyance it leads to software not actually functioning.<p>Re-implementing system capabilities is fine and all as long as you support common use cases properly, which Golang does not.</div><br/><div id="37911292" class="c"><input type="checkbox" id="c-37911292" checked=""/><div class="controls bullet"><span class="by">DominoTree</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910766">parent</a><span>|</span><a href="#37909152">next</a><span>|</span><label class="collapse" for="c-37911292">[-]</label><label class="expand" for="c-37911292">[1 more]</label></div><br/><div class="children"><div class="content">And on the flip side, there have been a number of instances where, in cases where the behavior differs, the Golang documentation describes a function only as it behaves with the Golang-native implementation, rather than the system implementation which ends up being the default - without calling any of this out</div><br/></div></div></div></div></div></div><div id="37909152" class="c"><input type="checkbox" id="c-37909152" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#37908896">parent</a><span>|</span><a href="#37909057">prev</a><span>|</span><a href="#37909637">next</a><span>|</span><label class="collapse" for="c-37909152">[-]</label><label class="expand" for="c-37909152">[21 more]</label></div><br/><div class="children"><div class="content">&gt; `errno` is another relic that needs to die yesterday.<p>ok, i will bite: what is the problem with it ?</div><br/><div id="37909284" class="c"><input type="checkbox" id="c-37909284" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909152">parent</a><span>|</span><a href="#37909270">next</a><span>|</span><label class="collapse" for="c-37909284">[-]</label><label class="expand" for="c-37909284">[16 more]</label></div><br/><div class="children"><div class="content">Shared global (well, thread local) mutable state.<p>As for why shared global mutable state is (generally) bad, see: <a href="https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;148108&#x2F;why-is-global-state-so-evil" rel="nofollow noreferrer">https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;1481...</a><p>`man 3 errno` on my Linux system even has a note calling out a common failure pattern. Can you spot the problem?<p><pre><code>           if (somecall() == -1) {
               printf(&quot;somecall() failed\n&quot;);
               if (errno == ...) { ... }
           }</code></pre></div><br/><div id="37910852" class="c"><input type="checkbox" id="c-37910852" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909284">parent</a><span>|</span><a href="#37909826">next</a><span>|</span><label class="collapse" for="c-37910852">[-]</label><label class="expand" for="c-37910852">[3 more]</label></div><br/><div class="children"><div class="content">regarding your snippet:<p><pre><code>           if (somecall() == -1) {
               printf(&quot;somecall() failed\n&quot;);
               if (errno == ...) { ... }
           }
</code></pre>
sure, the issue is that `somecall(...)` might have altered `errno` through &#x27;acts-of-omission-or-comission&#x27; :o)<p>fwiw, posix has updated its definition to pretty much say that &#x27;value of errno in one thread is not affected by assignments to it by another&#x27;. this has been the case since at least a decade-and-a-half (iirc), which in internet years would positively be in the pleistocenic era :o)<p>so, i am not sure i really appreciate &#x27;the shared-global-mutable-state&#x27; argument above. thanks !</div><br/><div id="37911096" class="c"><input type="checkbox" id="c-37911096" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910852">parent</a><span>|</span><a href="#37909826">next</a><span>|</span><label class="collapse" for="c-37911096">[-]</label><label class="expand" for="c-37911096">[2 more]</label></div><br/><div class="children"><div class="content">The problem in that snippet is that `printf` could have altered the `errno` set by `somecall`, and that&#x27;s only thanks to it being shared-global-mutable-state. You not realizing that was possible makes for a great example of why shared-mutable-global-state is hard to reason about.</div><br/><div id="37911431" class="c"><input type="checkbox" id="c-37911431" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37911096">parent</a><span>|</span><a href="#37909826">next</a><span>|</span><label class="collapse" for="c-37911431">[-]</label><label class="expand" for="c-37911431">[1 more]</label></div><br/><div class="children"><div class="content">crap, i <i>definitely</i> meant to write `printf(...)` there !<p>my typical usage for such scenarios i.e. when i know that callee might alter errno etc. is to<p><pre><code>        int save_errno = errno;

        do_foo(...);

        if (errno == ...) {
          ...
        }
</code></pre>
wrapping libc into something that (maybe) does better seems like such a sisyphean task to me.</div><br/></div></div></div></div></div></div><div id="37909826" class="c"><input type="checkbox" id="c-37909826" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909284">parent</a><span>|</span><a href="#37910852">prev</a><span>|</span><a href="#37909455">next</a><span>|</span><label class="collapse" for="c-37909826">[-]</label><label class="expand" for="c-37909826">[1 more]</label></div><br/><div class="children"><div class="content">There are 2 errno mistakes in that snippet since there is no way to know who set errno.</div><br/></div></div><div id="37909455" class="c"><input type="checkbox" id="c-37909455" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909284">parent</a><span>|</span><a href="#37909826">prev</a><span>|</span><a href="#37909270">next</a><span>|</span><label class="collapse" for="c-37909455">[-]</label><label class="expand" for="c-37909455">[11 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the alternative?<p>Returning a&quot;Result&quot; struct doubles the size. This is one less register to use.<p>Exception handling is even more invasive.<p>They are great for high(-er) level language, but less prefect on lower level where performance is critical.<p>EDIT: Linux kernel use negative return value for error. It&#x27;s good and efficient when it work. But it is not always an option when you need the full register width</div><br/><div id="37911357" class="c"><input type="checkbox" id="c-37911357" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909455">parent</a><span>|</span><a href="#37910781">next</a><span>|</span><label class="collapse" for="c-37911357">[-]</label><label class="expand" for="c-37911357">[1 more]</label></div><br/><div class="children"><div class="content">You are saving one register at the cost of having a thread local variable that is visible to signal handlers, so none of its uses can be optimized away. Which results in things like gcc having to decorate every math instruction with code to set errno on the off chance that someone somewhere might read it (no one ever does).</div><br/></div></div><div id="37910781" class="c"><input type="checkbox" id="c-37910781" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909455">parent</a><span>|</span><a href="#37911357">prev</a><span>|</span><a href="#37909688">next</a><span>|</span><label class="collapse" for="c-37910781">[-]</label><label class="expand" for="c-37910781">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Returning a&quot;Result&quot; struct doubles the size. This is one less register to use.<p>One less register right before and after returns doesn&#x27;t sound like a big problem, especially with 16+ registers.</div><br/></div></div><div id="37909688" class="c"><input type="checkbox" id="c-37909688" checked=""/><div class="controls bullet"><span class="by">bdd8f1df777b</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909455">parent</a><span>|</span><a href="#37910781">prev</a><span>|</span><a href="#37910040">next</a><span>|</span><label class="collapse" for="c-37909688">[-]</label><label class="expand" for="c-37909688">[7 more]</label></div><br/><div class="children"><div class="content">Most of the POSIX functions that use errno for error signaling simply return 0 for success and -1 for error. They could have returned errno directly.</div><br/><div id="37909923" class="c"><input type="checkbox" id="c-37909923" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909688">parent</a><span>|</span><a href="#37910014">next</a><span>|</span><label class="collapse" for="c-37909923">[-]</label><label class="expand" for="c-37909923">[1 more]</label></div><br/><div class="children"><div class="content">Last I checked, the Linux kernel ABI <i>does</i> return -errno for errors. Then libc mangles that all up.</div><br/></div></div><div id="37910014" class="c"><input type="checkbox" id="c-37910014" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909688">parent</a><span>|</span><a href="#37909923">prev</a><span>|</span><a href="#37909828">next</a><span>|</span><label class="collapse" for="c-37910014">[-]</label><label class="expand" for="c-37910014">[2 more]</label></div><br/><div class="children"><div class="content">Some newer POSIX APIs, such as pthreads, do return the error this way. But many legacy APIs, such as dup or read, use the positive integer space, thus the negation pattern you often see in syscalls. Notably, POSIX guarantees &lt;errno.h&gt; values to be positive integers.</div><br/><div id="37911265" class="c"><input type="checkbox" id="c-37911265" checked=""/><div class="controls bullet"><span class="by">bdd8f1df777b</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910014">parent</a><span>|</span><a href="#37909828">next</a><span>|</span><label class="collapse" for="c-37911265">[-]</label><label class="expand" for="c-37911265">[1 more]</label></div><br/><div class="children"><div class="content">`dup` and `read` returns -1 on error and set the `errno` variable. If they were redesigned, they should just return `-errno` on failure.</div><br/></div></div></div></div><div id="37909828" class="c"><input type="checkbox" id="c-37909828" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909688">parent</a><span>|</span><a href="#37910014">prev</a><span>|</span><a href="#37910040">next</a><span>|</span><label class="collapse" for="c-37909828">[-]</label><label class="expand" for="c-37909828">[3 more]</label></div><br/><div class="children"><div class="content">What about the rest?</div><br/><div id="37911257" class="c"><input type="checkbox" id="c-37911257" checked=""/><div class="controls bullet"><span class="by">bdd8f1df777b</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909828">parent</a><span>|</span><a href="#37910797">prev</a><span>|</span><a href="#37910040">next</a><span>|</span><label class="collapse" for="c-37911257">[-]</label><label class="expand" for="c-37911257">[1 more]</label></div><br/><div class="children"><div class="content">Put the original return value in a pointer argument, and return errno (or -errno).</div><br/></div></div></div></div></div></div><div id="37910040" class="c"><input type="checkbox" id="c-37910040" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909455">parent</a><span>|</span><a href="#37909688">prev</a><span>|</span><a href="#37909270">next</a><span>|</span><label class="collapse" for="c-37910040">[-]</label><label class="expand" for="c-37910040">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of alternatives, and it&#x27;s not clear why the ones you&#x27;ve suggested are inappropriate. You&#x27;ve listed some perceived costs, but I don&#x27;t see why those costs are greater than the ones paid by the status quo.<p>Linux even shows you a path, yet you reject it for reasons that don&#x27;t seem compelling to me.</div><br/></div></div></div></div></div></div><div id="37909270" class="c"><input type="checkbox" id="c-37909270" checked=""/><div class="controls bullet"><span class="by">ForkMeOnTinder</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909152">parent</a><span>|</span><a href="#37909284">prev</a><span>|</span><a href="#37911264">next</a><span>|</span><label class="collapse" for="c-37909270">[-]</label><label class="expand" for="c-37909270">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s global state for a local condition.<p>Linus Torvalds on errno: <a href="https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;errno.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;errno.html</a></div><br/><div id="37910861" class="c"><input type="checkbox" id="c-37910861" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909270">parent</a><span>|</span><a href="#37911264">next</a><span>|</span><label class="collapse" for="c-37910861">[-]</label><label class="expand" for="c-37910861">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ... Linus Torvalds on errno: <a href="https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;errno.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;yarchive.net&#x2F;comp&#x2F;linux&#x2F;errno.html</a><p>yes, he argues against its usage in the KERNEL.</div><br/><div id="37911158" class="c"><input type="checkbox" id="c-37911158" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910861">parent</a><span>|</span><a href="#37911264">next</a><span>|</span><label class="collapse" for="c-37911158">[-]</label><label class="expand" for="c-37911158">[1 more]</label></div><br/><div class="children"><div class="content">But his argument stands even outside the kernel. Errno is awful, similar to locale APIs.</div><br/></div></div></div></div></div></div><div id="37911264" class="c"><input type="checkbox" id="c-37911264" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909152">parent</a><span>|</span><a href="#37909270">prev</a><span>|</span><a href="#37909637">next</a><span>|</span><label class="collapse" for="c-37911264">[-]</label><label class="expand" for="c-37911264">[1 more]</label></div><br/><div class="children"><div class="content">The most obvious way it is wrong is that it is archaic. There is simply no reason to ever pass return values in hidden state. Just use return values damnit.</div><br/></div></div></div></div><div id="37910849" class="c"><input type="checkbox" id="c-37910849" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#37908896">parent</a><span>|</span><a href="#37909637">prev</a><span>|</span><a href="#37909162">next</a><span>|</span><label class="collapse" for="c-37910849">[-]</label><label class="expand" for="c-37910849">[7 more]</label></div><br/><div class="children"><div class="content">Most of the still working privilege escalation exploits from 2006 are only still there because it is intended behaviour of glibc.<p>Environment variables like LD_PRELOAD should never ever be available in production.<p>I totally understand why the muslc developers kinda freaked out and started their own standard library.</div><br/><div id="37910885" class="c"><input type="checkbox" id="c-37910885" checked=""/><div class="controls bullet"><span class="by">avereveard</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910849">parent</a><span>|</span><a href="#37909162">next</a><span>|</span><label class="collapse" for="c-37910885">[-]</label><label class="expand" for="c-37910885">[6 more]</label></div><br/><div class="children"><div class="content">Err no thank you. Ld preload and similar mechanism are great to inject code into apps legitimately, i.e. to patch long unsupported systems or to tame current ones.<p>For example I have vision issue and without reshade filter I would be unable to play a great deal of games.<p>Now that is also an attack vector, that&#x27;s for sure, but you cannot go ax features willy nilly just because you don&#x27;t see value in them.</div><br/><div id="37910990" class="c"><input type="checkbox" id="c-37910990" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910885">parent</a><span>|</span><a href="#37911419">next</a><span>|</span><label class="collapse" for="c-37910990">[-]</label><label class="expand" for="c-37910990">[1 more]</label></div><br/><div class="children"><div class="content">Chestersons Fence<p><a href="https:&#x2F;&#x2F;en.m.wiktionary.org&#x2F;wiki&#x2F;Chesterton%27s_fence" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wiktionary.org&#x2F;wiki&#x2F;Chesterton%27s_fence</a></div><br/></div></div><div id="37911419" class="c"><input type="checkbox" id="c-37911419" checked=""/><div class="controls bullet"><span class="by">GoblinSlayer</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910885">parent</a><span>|</span><a href="#37910990">prev</a><span>|</span><a href="#37911131">next</a><span>|</span><label class="collapse" for="c-37911419">[-]</label><label class="expand" for="c-37911419">[1 more]</label></div><br/><div class="children"><div class="content">At least it could be additionally guarded by a system setting or something like that.</div><br/></div></div><div id="37911131" class="c"><input type="checkbox" id="c-37911131" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910885">parent</a><span>|</span><a href="#37911419">prev</a><span>|</span><a href="#37911553">next</a><span>|</span><label class="collapse" for="c-37911131">[-]</label><label class="expand" for="c-37911131">[2 more]</label></div><br/><div class="children"><div class="content">LD_PRELOAD won&#x27;t be needed if the OS were built around containers &#x2F; jails, instead of the weakly isolated processes and process groups.<p>The Unix kernel (both Linux, BSD, and Solaris) already had much of what&#x27;s needed, say, 30 years ago, but nobody saw it as such a burning necessity (likely except Solaris which eventually developed Zones).</div><br/><div id="37911180" class="c"><input type="checkbox" id="c-37911180" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37911131">parent</a><span>|</span><a href="#37911553">next</a><span>|</span><label class="collapse" for="c-37911180">[-]</label><label class="expand" for="c-37911180">[1 more]</label></div><br/><div class="children"><div class="content">On a  &quot;normal&quot; desktop system, you don&#x27;t need containers or jails. Your programs must communicate with each other (copy paste, print screen, etc.).<p>But today every god damn UI program needs an internet connection to phone home and execute remote code. This is the actual problem which must be fixed.</div><br/></div></div></div></div><div id="37911553" class="c"><input type="checkbox" id="c-37911553" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37910885">parent</a><span>|</span><a href="#37911131">prev</a><span>|</span><a href="#37909162">next</a><span>|</span><label class="collapse" for="c-37911553">[-]</label><label class="expand" for="c-37911553">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Err no thank you.<p>&gt; Err no<p>Not sure if you are trolling</div><br/></div></div></div></div></div></div><div id="37909162" class="c"><input type="checkbox" id="c-37909162" checked=""/><div class="controls bullet"><span class="by">throwaway894345</span><span>|</span><a href="#37908896">parent</a><span>|</span><a href="#37910849">prev</a><span>|</span><a href="#37911624">next</a><span>|</span><label class="collapse" for="c-37909162">[-]</label><label class="expand" for="c-37909162">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, there&#x27;s so much misery in the C ecosystem that it&#x27;s better to eschew it altogether. Even merely packaging anything that depends on C ends up being a hugely painful undertaking since every C library has its own bespoke build system and its own implicit set of dependencies (and implicit versions of those dependencies, and expectations about where on the system those dependencies live).<p>I mostly like C <i>as a language</i>, but between the security concerns and the tooling concerns (and the community&#x27;s zealous devotion to ignoring these very real problems) I&#x27;m really excited for its increasing marginalization. Unfortunately, it&#x27;s not being marginalized in favor of &quot;a better C&quot;, but rather every ecosystem is rewriting the same stuff from scratch which seems like a bit of a bummer (but still better than depending on C).</div><br/><div id="37911203" class="c"><input type="checkbox" id="c-37911203" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37909162">parent</a><span>|</span><a href="#37911624">next</a><span>|</span><label class="collapse" for="c-37911203">[-]</label><label class="expand" for="c-37911203">[2 more]</label></div><br/><div class="children"><div class="content">&gt; since every C library has its own bespoke build system and its own implicit set of dependencies (and<p>You should see other libraries. At least glibc does not require meson, cmake and ninja.</div><br/><div id="37911392" class="c"><input type="checkbox" id="c-37911392" checked=""/><div class="controls bullet"><span class="by">techbrovanguard</span><span>|</span><a href="#37908896">root</a><span>|</span><a href="#37911203">parent</a><span>|</span><a href="#37911624">next</a><span>|</span><label class="collapse" for="c-37911392">[-]</label><label class="expand" for="c-37911392">[1 more]</label></div><br/><div class="children"><div class="content">yes, it only requires autotools. a build system so friendly that it spawned cmake and meson to replace it.</div><br/></div></div></div></div></div></div></div></div><div id="37908886" class="c"><input type="checkbox" id="c-37908886" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#37908896">prev</a><span>|</span><a href="#37909694">next</a><span>|</span><label class="collapse" for="c-37908886">[-]</label><label class="expand" for="c-37908886">[2 more]</label></div><br/><div class="children"><div class="content">I always thought getenv() was code smell, and this confirms it. I guess a better option would be to add a parameter to Getaddrinfo(), and deal with it further up the stack?</div><br/><div id="37909041" class="c"><input type="checkbox" id="c-37909041" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37908886">parent</a><span>|</span><a href="#37909694">next</a><span>|</span><label class="collapse" for="c-37909041">[-]</label><label class="expand" for="c-37909041">[1 more]</label></div><br/><div class="children"><div class="content">getaddrinfo is far too ossified to be changed</div><br/></div></div></div></div><div id="37909694" class="c"><input type="checkbox" id="c-37909694" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#37908886">prev</a><span>|</span><label class="collapse" for="c-37909694">[-]</label><label class="expand" for="c-37909694">[2 more]</label></div><br/><div class="children"><div class="content">You know the source code and manual pages are open source. You can look for these things.</div><br/><div id="37910866" class="c"><input type="checkbox" id="c-37910866" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37909694">parent</a><span>|</span><label class="collapse" for="c-37910866">[-]</label><label class="expand" for="c-37910866">[1 more]</label></div><br/><div class="children"><div class="content">She does in fact know these things, which is why she’s writing about it. For the people who may not have thought to do that yet.</div><br/></div></div></div></div></div></div></div></div></div></body></html>