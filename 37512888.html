<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694768464907" as="style"/><link rel="stylesheet" href="styles.css?v=1694768464907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jvns.ca/blog/2023/09/14/in-a-git-repository--where-do-your-files-live-/">In a Git repository, where do your files live?</a> <span class="domain">(<a href="https://jvns.ca">jvns.ca</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>87 comments</span></div><br/><div><div id="37514029" class="c"><input type="checkbox" id="c-37514029" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#37514301">next</a><span>|</span><label class="collapse" for="c-37514029">[-]</label><label class="expand" for="c-37514029">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing this very interesting link (I actually knew it would be good before clicking simply because of the domain name)!<p>If this sort of internal view of git interests you, I strongly suggest reading the &quot;DIY Git in Python&quot; series from here: <a href="https:&#x2F;&#x2F;www.leshenko.net&#x2F;p&#x2F;ugit&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.leshenko.net&#x2F;p&#x2F;ugit&#x2F;</a></div><br/></div></div><div id="37514301" class="c"><input type="checkbox" id="c-37514301" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#37514029">prev</a><span>|</span><a href="#37514431">next</a><span>|</span><label class="collapse" for="c-37514301">[-]</label><label class="expand" for="c-37514301">[10 more]</label></div><br/><div class="children"><div class="content">I realize the Python script is likely provided for didactic purposes, but you can use `git hash-object` to get the object ID:<p><a href="https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-hash-object" rel="nofollow noreferrer">https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-hash-object</a><p>With a bit of sed, the python script in the blog post becomes:<p><pre><code>  git hash-object &lt;path&gt; | sed -E &#x27;s|(..)(.*)|.git&#x2F;objects&#x2F;\1&#x2F;\2|&#x27;
</code></pre>
The inverse of `git hash-object` is `git cat-file`:<p><pre><code>  git cat-file -p $(git hash-object &lt;path&gt;)
</code></pre>
<a href="https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-cat-file" rel="nofollow noreferrer">https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-cat-file</a><p>Aside, when I learn a new subject, I like to go to the index such that it is to get an idea of what I don&#x27;t know (first stage of learning: you don&#x27;t know what you don&#x27;t know). Then I can try to prioritize the order of learning about the topic. With git, I&#x27;d start with this page:<p><a href="https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git" rel="nofollow noreferrer">https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git</a></div><br/><div id="37514727" class="c"><input type="checkbox" id="c-37514727" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#37514301">parent</a><span>|</span><a href="#37514431">next</a><span>|</span><label class="collapse" for="c-37514727">[-]</label><label class="expand" for="c-37514727">[9 more]</label></div><br/><div class="children"><div class="content">I have a local clone of a git repo with many local branches.  I lost an object file (and I&#x27;m not certain how).  Now git gc always fails, complaining about the object:<p><i>Counting objects: 100% (11785289&#x2F;11785289), done.<p>Delta compression using up to 64 threads<p>Compressing objects: 100% (4116944&#x2F;4116944), done.<p>fatal: unable to read 
1cae71a9d5b24991c0d632b45186ca8a250e5d52<p>fatal: failed to run repack</i><p>I&#x27;ve cloned the repo again, and that object does not appear in the new clone, so I assume it must be from a commit to a local branch.<p>The odd thing is that I <i>think</i> I locally cloned this repo, and saw no complaints about the missing object.<p>Is there any way to tell what branch and&#x2F;or file(s) were referred to by the object?  And, assuming its from a stale branch, just delete the branch and thereby fix my repo?</div><br/><div id="37519705" class="c"><input type="checkbox" id="c-37519705" checked=""/><div class="controls bullet"><span class="by">Borg3</span><span>|</span><a href="#37514301">root</a><span>|</span><a href="#37514727">parent</a><span>|</span><a href="#37514777">next</a><span>|</span><label class="collapse" for="c-37519705">[-]</label><label class="expand" for="c-37519705">[1 more]</label></div><br/><div class="children"><div class="content">Thats interesting.. Did you had any system crash recently?
Or maybe disk full? The only moment I think this is the only way to loose object like this.<p>Anyway, If this is your only repo containing those branches then its gone.
The only way you can try is to clone fresh repo from trusted source and then
reconstruct every branch manually, basically squashing commits. And I bet, one of those branches will be broken.</div><br/></div></div><div id="37514777" class="c"><input type="checkbox" id="c-37514777" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37514301">root</a><span>|</span><a href="#37514727">parent</a><span>|</span><a href="#37519705">prev</a><span>|</span><a href="#37514431">next</a><span>|</span><label class="collapse" for="c-37514777">[-]</label><label class="expand" for="c-37514777">[7 more]</label></div><br/><div class="children"><div class="content">You can try to git fsck in case that identifies the missing object. But I’m not sure there’s any ready made command to identify through which path a missing object is reached.<p>It could actually be the reflog. Pruning the reflog then running “git gc —prune=now” might do the trick.</div><br/><div id="37514992" class="c"><input type="checkbox" id="c-37514992" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#37514301">root</a><span>|</span><a href="#37514777">parent</a><span>|</span><a href="#37514431">next</a><span>|</span><label class="collapse" for="c-37514992">[-]</label><label class="expand" for="c-37514992">[6 more]</label></div><br/><div class="children"><div class="content">Thank you.  I&#x27;ve tried git fsck in the past, and it complains about the missing object as well.<p>And I just tried &quot;git gc —prune=now&quot;, and sadly it still fails the same way.<p>I&#x27;m afraid I&#x27;m going to have to bite the bullet and clean up my 30 or so worktrees and re-clone the repo, and re-create the worktrees.</div><br/><div id="37515192" class="c"><input type="checkbox" id="c-37515192" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#37514301">root</a><span>|</span><a href="#37514992">parent</a><span>|</span><a href="#37515186">next</a><span>|</span><label class="collapse" for="c-37515192">[-]</label><label class="expand" for="c-37515192">[1 more]</label></div><br/><div class="children"><div class="content">You might be able to recreate the git history without that object (or commit). Look into commands like filter-branch. I&#x27;d be surprised if there&#x27;s not a way to recover from this situation</div><br/></div></div><div id="37515186" class="c"><input type="checkbox" id="c-37515186" checked=""/><div class="controls bullet"><span class="by">williamcotton</span><span>|</span><a href="#37514301">root</a><span>|</span><a href="#37514992">parent</a><span>|</span><a href="#37515192">prev</a><span>|</span><a href="#37514431">next</a><span>|</span><label class="collapse" for="c-37515186">[-]</label><label class="expand" for="c-37515186">[4 more]</label></div><br/><div class="children"><div class="content">Try a grep for that missing hash in the fatal message you posted and point it at a commit&#x2F;object that does exist or just delete that line&#x2F;file and see if that fixes it!</div><br/><div id="37515274" class="c"><input type="checkbox" id="c-37515274" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#37514301">root</a><span>|</span><a href="#37515186">parent</a><span>|</span><a href="#37514431">next</a><span>|</span><label class="collapse" for="c-37515274">[-]</label><label class="expand" for="c-37515274">[3 more]</label></div><br/><div class="children"><div class="content">This is more or less what I&#x27;ve been trying to do for quite a while.  How do I grep for it?  And once I do that, how can I &quot;point it at a commit&#x2F;object that does exist ?&quot;</div><br/><div id="37515987" class="c"><input type="checkbox" id="c-37515987" checked=""/><div class="controls bullet"><span class="by">williamcotton</span><span>|</span><a href="#37514301">root</a><span>|</span><a href="#37515274">parent</a><span>|</span><a href="#37514431">next</a><span>|</span><label class="collapse" for="c-37515987">[-]</label><label class="expand" for="c-37515987">[2 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s a ref somewhere then it&#x27;ll just be a string of the hash deadbeef style. Just open the file up and change it to another commit hash or just delete the ref completely.<p>Try something like:<p><pre><code>  grep -r &quot;1cae71a9&quot; .&#x2F;.git&#x2F;
</code></pre>
And see if it comes up somewhere. My guess is that it&#x27;s a ref for some old branch pointing at a commit that isn&#x27;t around.</div><br/><div id="37520144" class="c"><input type="checkbox" id="c-37520144" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#37514301">root</a><span>|</span><a href="#37515987">parent</a><span>|</span><a href="#37514431">next</a><span>|</span><label class="collapse" for="c-37520144">[-]</label><label class="expand" for="c-37520144">[1 more]</label></div><br/><div class="children"><div class="content">That won&#x27;t work, as loose objects are stored zlib-compressed in .git, and packed objects can be stored in a delta format. You&#x27;d need something like this:<p><pre><code>   git cat-file --unordered --batch-check=&#x27;%(objectname)&#x27; --batch-all-objects | xargs -n1 -- git cat-file -p | grep 1cae71a9d5b24991c0d632b45186ca8a250e5d52</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37514431" class="c"><input type="checkbox" id="c-37514431" checked=""/><div class="controls bullet"><span class="by">smartmic</span><span>|</span><a href="#37514301">prev</a><span>|</span><a href="#37515672">next</a><span>|</span><label class="collapse" for="c-37514431">[-]</label><label class="expand" for="c-37514431">[7 more]</label></div><br/><div class="children"><div class="content">Oh yeah, the Git internals...
I tried to find my way through them using visualization but did not progress much: <a href="https:&#x2F;&#x2F;github.com&#x2F;smartmic&#x2F;git2pic">https:&#x2F;&#x2F;github.com&#x2F;smartmic&#x2F;git2pic</a></div><br/><div id="37515159" class="c"><input type="checkbox" id="c-37515159" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#37514431">parent</a><span>|</span><a href="#37514559">next</a><span>|</span><label class="collapse" for="c-37515159">[-]</label><label class="expand" for="c-37515159">[2 more]</label></div><br/><div class="children"><div class="content">I encourage everyone to read A Plumber&#x27;s Guide to Git: <a href="https:&#x2F;&#x2F;alexwlchan.net&#x2F;a-plumbers-guide-to-git&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;alexwlchan.net&#x2F;a-plumbers-guide-to-git&#x2F;</a><p>It&#x27;s not a book, just a series of five short blog posts. Part 1 explains precisely where files live: <a href="https:&#x2F;&#x2F;alexwlchan.net&#x2F;a-plumbers-guide-to-git&#x2F;1-the-git-object-store&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;alexwlchan.net&#x2F;a-plumbers-guide-to-git&#x2F;1-the-git-obj...</a><p><pre><code>  $ mkdir animals

  $ cd animals

  $ git init

  $ echo &quot;Big blue basilisks bawl in the basement&quot; &gt; animals.txt
  
  $ git hash-object -w animals.txt
  b13311e04762c322493e8562e6ce145a899ce570
  
  $ find .git&#x2F;objects -type f
  .git&#x2F;objects&#x2F;b1&#x2F;3311e04762c322493e8562e6ce145a899ce570

  $ rm animals.txt

  $ git cat-file -p b13311e04762c322493e8562e6ce145a899ce570 &gt; animals.txt
</code></pre>
Congratulations, you just did a `git restore animals.txt` manually.<p>Parts 2 through 5 are equally illuminating.</div><br/><div id="37516093" class="c"><input type="checkbox" id="c-37516093" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#37514431">root</a><span>|</span><a href="#37515159">parent</a><span>|</span><a href="#37514559">next</a><span>|</span><label class="collapse" for="c-37516093">[-]</label><label class="expand" for="c-37516093">[1 more]</label></div><br/><div class="children"><div class="content">Thank you a thousand times for sharing that. I just ran through the examples and they were very enlightening.</div><br/></div></div></div></div><div id="37514559" class="c"><input type="checkbox" id="c-37514559" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#37514431">parent</a><span>|</span><a href="#37515159">prev</a><span>|</span><a href="#37515580">next</a><span>|</span><label class="collapse" for="c-37514559">[-]</label><label class="expand" for="c-37514559">[1 more]</label></div><br/><div class="children"><div class="content">This was my aha! Momment
<a href="https:&#x2F;&#x2F;youtu.be&#x2F;P6jD966jzlk?si=YNKrNf872IQqr1vj" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;P6jD966jzlk?si=YNKrNf872IQqr1vj</a></div><br/></div></div><div id="37515580" class="c"><input type="checkbox" id="c-37515580" checked=""/><div class="controls bullet"><span class="by">srathi</span><span>|</span><a href="#37514431">parent</a><span>|</span><a href="#37514559">prev</a><span>|</span><a href="#37517526">next</a><span>|</span><label class="collapse" for="c-37515580">[-]</label><label class="expand" for="c-37515580">[1 more]</label></div><br/><div class="children"><div class="content">It is fun to explore the Git internals! Some time back, I used it to learn Golang [1]. Two birds with one stone!<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ssrathi&#x2F;gogit">https:&#x2F;&#x2F;github.com&#x2F;ssrathi&#x2F;gogit</a></div><br/></div></div><div id="37517526" class="c"><input type="checkbox" id="c-37517526" checked=""/><div class="controls bullet"><span class="by">totetsu</span><span>|</span><a href="#37514431">parent</a><span>|</span><a href="#37515580">prev</a><span>|</span><a href="#37514621">next</a><span>|</span><label class="collapse" for="c-37517526">[-]</label><label class="expand" for="c-37517526">[1 more]</label></div><br/><div class="children"><div class="content">I found this page had very easy to understand visuals<p><a href="https:&#x2F;&#x2F;www.devopsschool.com&#x2F;blog&#x2F;git-tutorial-objects-references-the-index&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.devopsschool.com&#x2F;blog&#x2F;git-tutorial-objects-refer...</a></div><br/></div></div><div id="37514621" class="c"><input type="checkbox" id="c-37514621" checked=""/><div class="controls bullet"><span class="by">gjf</span><span>|</span><a href="#37514431">parent</a><span>|</span><a href="#37517526">prev</a><span>|</span><a href="#37515672">next</a><span>|</span><label class="collapse" for="c-37514621">[-]</label><label class="expand" for="c-37514621">[1 more]</label></div><br/><div class="children"><div class="content">I tried to do something similar: <a href="https:&#x2F;&#x2F;articles.foletta.org&#x2F;post&#x2F;git-under-the-hood&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;articles.foletta.org&#x2F;post&#x2F;git-under-the-hood&#x2F;</a></div><br/></div></div></div></div><div id="37515672" class="c"><input type="checkbox" id="c-37515672" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#37514431">prev</a><span>|</span><a href="#37514676">next</a><span>|</span><label class="collapse" for="c-37515672">[-]</label><label class="expand" for="c-37515672">[5 more]</label></div><br/><div class="children"><div class="content">Very apropos, I&#x27;m trying to write a guide for my team called &quot;git beyond pull&#x2F;push and checkout&quot;.<p>I&#x27;m trying to write something that will demystify git for the developers in this team. So I want to show them the files in .git, and connect them to the concepts they know like branches, etc. I&#x27;m always on the lookout for new stuff to include.<p>The more I can read, the better information I can put in this guide.</div><br/><div id="37515709" class="c"><input type="checkbox" id="c-37515709" checked=""/><div class="controls bullet"><span class="by">grahamplace</span><span>|</span><a href="#37515672">parent</a><span>|</span><a href="#37514676">next</a><span>|</span><label class="collapse" for="c-37515709">[-]</label><label class="expand" for="c-37515709">[4 more]</label></div><br/><div class="children"><div class="content">I’d definitely read this if you’re able to share it publicly</div><br/><div id="37520071" class="c"><input type="checkbox" id="c-37520071" checked=""/><div class="controls bullet"><span class="by">Vinnl</span><span>|</span><a href="#37515672">root</a><span>|</span><a href="#37515709">parent</a><span>|</span><a href="#37515860">next</a><span>|</span><label class="collapse" for="c-37520071">[-]</label><label class="expand" for="c-37520071">[1 more]</label></div><br/><div class="children"><div class="content">Heh, &quot;git beyond pull&#x2F;push and checkout&quot; was also the idea behind my tutorial, though I figured visualising the commit graph would be more helpful than showing the hidden files. And also that a ~10 min guide would be more likely to be used than a very detailed book.<p>Anyway, in case you&#x27;re interested: <a href="https:&#x2F;&#x2F;agripongit.vincenttunru.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;agripongit.vincenttunru.com</a></div><br/></div></div><div id="37515860" class="c"><input type="checkbox" id="c-37515860" checked=""/><div class="controls bullet"><span class="by">tcoff91</span><span>|</span><a href="#37515672">root</a><span>|</span><a href="#37515709">parent</a><span>|</span><a href="#37520071">prev</a><span>|</span><a href="#37515792">next</a><span>|</span><label class="collapse" for="c-37515860">[-]</label><label class="expand" for="c-37515860">[1 more]</label></div><br/><div class="children"><div class="content">You should read this: <a href="https:&#x2F;&#x2F;jwiegley.github.io&#x2F;git-from-the-bottom-up&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jwiegley.github.io&#x2F;git-from-the-bottom-up&#x2F;</a></div><br/></div></div><div id="37515792" class="c"><input type="checkbox" id="c-37515792" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#37515672">root</a><span>|</span><a href="#37515709">parent</a><span>|</span><a href="#37515860">prev</a><span>|</span><a href="#37514676">next</a><span>|</span><label class="collapse" for="c-37515792">[-]</label><label class="expand" for="c-37515792">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll probably announce it on HN when it&#x27;s finished :)</div><br/></div></div></div></div></div></div><div id="37514676" class="c"><input type="checkbox" id="c-37514676" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37515672">prev</a><span>|</span><a href="#37515760">next</a><span>|</span><label class="collapse" for="c-37514676">[-]</label><label class="expand" for="c-37514676">[14 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to know this, by the way. You can totally just think of git as simply storing a copy of your entire repo every time you make a commit. This is one part of git that actually is a good abstraction.<p>Of course it is fun to know this but it won&#x27;t help you understand git really, and please don&#x27;t tell people who are just learning git. Just say git makes a copy of the whole project every time you commit.</div><br/><div id="37519963" class="c"><input type="checkbox" id="c-37519963" checked=""/><div class="controls bullet"><span class="by">solarkraft</span><span>|</span><a href="#37514676">parent</a><span>|</span><a href="#37515508">next</a><span>|</span><label class="collapse" for="c-37519963">[-]</label><label class="expand" for="c-37519963">[2 more]</label></div><br/><div class="children"><div class="content">Yeah.<p>I want to understand git. But by that I mean <i>using it</i>. I don&#x27;t need to know about the internals for that; I need to know common approaches to typical merge problems (where all of a sudden git loses a lot of its elegance).</div><br/><div id="37520033" class="c"><input type="checkbox" id="c-37520033" checked=""/><div class="controls bullet"><span class="by">visarga</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37519963">parent</a><span>|</span><a href="#37515508">next</a><span>|</span><label class="collapse" for="c-37520033">[-]</label><label class="expand" for="c-37520033">[1 more]</label></div><br/><div class="children"><div class="content">I found out that GPT-4 is pretty good at helping me find&#x2F;format git commands and solve git issues. These are usually short responses, repeated in many places on the web, and easy to memorise for the LLM. GPT is really a game changer related to git anxiety.</div><br/></div></div></div></div><div id="37515508" class="c"><input type="checkbox" id="c-37515508" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#37514676">parent</a><span>|</span><a href="#37519963">prev</a><span>|</span><a href="#37515787">next</a><span>|</span><label class="collapse" for="c-37515508">[-]</label><label class="expand" for="c-37515508">[4 more]</label></div><br/><div class="children"><div class="content">&quot;I don&#x27;t commit that often because I don&#x27;t have that much hard drive space.&quot;</div><br/><div id="37515784" class="c"><input type="checkbox" id="c-37515784" checked=""/><div class="controls bullet"><span class="by">mostlylurks</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37515508">parent</a><span>|</span><a href="#37515683">next</a><span>|</span><label class="collapse" for="c-37515784">[-]</label><label class="expand" for="c-37515784">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if anyone has built a system with the philosophy of the opposite extreme.<p>&quot;Oh yeah, space is cheap, so I just let my automated system make 10,000 commits per second. It&#x27;ll be fine.&quot;</div><br/><div id="37515960" class="c"><input type="checkbox" id="c-37515960" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37515784">parent</a><span>|</span><a href="#37515683">next</a><span>|</span><label class="collapse" for="c-37515960">[-]</label><label class="expand" for="c-37515960">[1 more]</label></div><br/><div class="children"><div class="content">I have been thinking about this. Why no record all keystrokes. Then checkpoint where you are whenever you desire. These days AI could describe any arbitrary span of code changes.</div><br/></div></div></div></div><div id="37515683" class="c"><input type="checkbox" id="c-37515683" checked=""/><div class="controls bullet"><span class="by">jxy</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37515508">parent</a><span>|</span><a href="#37515784">prev</a><span>|</span><a href="#37515787">next</a><span>|</span><label class="collapse" for="c-37515683">[-]</label><label class="expand" for="c-37515683">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of true with git-lfs.</div><br/></div></div></div></div><div id="37515787" class="c"><input type="checkbox" id="c-37515787" checked=""/><div class="controls bullet"><span class="by">glhaynes</span><span>|</span><a href="#37514676">parent</a><span>|</span><a href="#37515508">prev</a><span>|</span><a href="#37515760">next</a><span>|</span><label class="collapse" for="c-37515787">[-]</label><label class="expand" for="c-37515787">[7 more]</label></div><br/><div class="children"><div class="content">I feel like git culture is one of the worst about these sorts of things. I&#x27;ve run into people that think you&#x27;re a loser if you don&#x27;t use it from the command line, but my commits using a GUI client are much cleaner and I seem to have much less trouble than they do.</div><br/><div id="37515939" class="c"><input type="checkbox" id="c-37515939" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37515787">parent</a><span>|</span><a href="#37519772">next</a><span>|</span><label class="collapse" for="c-37515939">[-]</label><label class="expand" for="c-37515939">[1 more]</label></div><br/><div class="children"><div class="content">I use command line for pull&#x2F;push&#x2F;new branch, VSCode for commits and Tortoise for archeology and merges. I just use whatever seems easiest for the task.</div><br/></div></div><div id="37519772" class="c"><input type="checkbox" id="c-37519772" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37515787">parent</a><span>|</span><a href="#37515939">prev</a><span>|</span><a href="#37518033">next</a><span>|</span><label class="collapse" for="c-37519772">[-]</label><label class="expand" for="c-37519772">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m the &quot;git guy&quot; in every job I&#x27;ve had. I never use the CLI! I use magit which is probably the very best git UI there is. A GUI is simply the best thing when you are in the process of building state. CLI is great for functional type stuff (ie. I type a command providing both input and output but is completely stateless). Building commits is one such example of working with state. Most CLI users I know just add everything every time.</div><br/></div></div><div id="37518033" class="c"><input type="checkbox" id="c-37518033" checked=""/><div class="controls bullet"><span class="by">poorlyknit</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37515787">parent</a><span>|</span><a href="#37519772">prev</a><span>|</span><a href="#37515760">next</a><span>|</span><label class="collapse" for="c-37518033">[-]</label><label class="expand" for="c-37518033">[4 more]</label></div><br/><div class="children"><div class="content">What GUI are you using and how do I make my commits cleaner?</div><br/><div id="37519834" class="c"><input type="checkbox" id="c-37519834" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37518033">parent</a><span>|</span><a href="#37515760">next</a><span>|</span><label class="collapse" for="c-37519834">[-]</label><label class="expand" for="c-37519834">[3 more]</label></div><br/><div class="children"><div class="content">I use magit. You want a UI that allows you to easily see the changes in your worktree and add those line by line to the index, if necessary. Of course, you also want it to be easy to add whole files or hunks too, as always going line by line would be insane.<p>A good commit means a good <i>version</i>. That&#x27;s what we&#x27;re doing after all: version control. Every commit you produce should be a valid standalone version of the software. Commits can build on each other, e.g. you can add feature a then subsequently add feature b that depends on feature a, but a maintainer should always be able to only take feature a, there shouldn&#x27;t be bits of feature b in there, and there shouldn&#x27;t be fixes for feature a in feature b&#x27;s commit.<p>With practice you can learn to make rough commits first then clean them up into proper commits later. For example, there are &quot;end of day&quot; commits and there are fixup commits. Those are both valid uses of git, but you shouldn&#x27;t be exposing those to your team. You need to rebase them before sending them. A good git user will sow the seeds for a smooth rebase early.</div><br/><div id="37520096" class="c"><input type="checkbox" id="c-37520096" checked=""/><div class="controls bullet"><span class="by">Vinnl</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37519834">parent</a><span>|</span><a href="#37515760">next</a><span>|</span><label class="collapse" for="c-37520096">[-]</label><label class="expand" for="c-37520096">[2 more]</label></div><br/><div class="children"><div class="content">For those who <i>do</i> prefer the command line (you do you), what you want is<p><pre><code>    git add --patch</code></pre></div><br/><div id="37520162" class="c"><input type="checkbox" id="c-37520162" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37514676">root</a><span>|</span><a href="#37520096">parent</a><span>|</span><a href="#37515760">next</a><span>|</span><label class="collapse" for="c-37520162">[-]</label><label class="expand" for="c-37520162">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not really a CLI, though, it&#x27;s a really basic rudimentary text UI. Might as well spend the effort to learn it learning enough Emacs to use Magit. Can it even do line by line effectively? What about unstaging stuff you added accidentally? It&#x27;s not a patch on Magit or even any semi-decent GUI.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37515760" class="c"><input type="checkbox" id="c-37515760" checked=""/><div class="controls bullet"><span class="by">deepspace</span><span>|</span><a href="#37514676">prev</a><span>|</span><a href="#37517042">next</a><span>|</span><label class="collapse" for="c-37515760">[-]</label><label class="expand" for="c-37515760">[45 more]</label></div><br/><div class="children"><div class="content">That was very informative, but I wondered if there is an easy-to-read reference somewhere about WHY git works the way it does?<p>I am old enough to have used SCCS, RCS and CVS extensively.  Each had their faults, but Git is the only VCS I have used where dealing with merge conflicts is unintuitive enough that I sometimes end up with the repository in an unusable state.  I am sure I am doing something wrong, but I would like to understand why.<p>The VCS that maps closes to the way my brain works is ClearCase.  You essentially have a versioned file system, and you can set up a view to present any previous state of that file system.  Of course, administration is a nightmare, it is not distributed, it is expensive, yada, yada. But when using it I always felt I knew exactly what was going on under the covers, which is not the case with Git at all.</div><br/><div id="37516176" class="c"><input type="checkbox" id="c-37516176" checked=""/><div class="controls bullet"><span class="by">mabbo</span><span>|</span><a href="#37515760">parent</a><span>|</span><a href="#37516572">next</a><span>|</span><label class="collapse" for="c-37516176">[-]</label><label class="expand" for="c-37516176">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely not a super intuitive model, but it is a <i>powerful</i> one.<p>As I see it, git is a distributed database of snapshots of a directory of files. Every commit is a new snapshot. It&#x27;s designed the way it is to achieve that goal while minimizing the space used, yet keeping an entire history of the project. It also has tools like git-diff to better compare those snapshots.<p>But distributed matters most because it was literally designed for managing the Linux kernel development- a large open source project with thousands of contributors working concurrently.<p>Merge conflicts are hard in this model because you&#x27;re trying to put two snapshots together, not just two diffs.</div><br/><div id="37517108" class="c"><input type="checkbox" id="c-37517108" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516176">parent</a><span>|</span><a href="#37516572">next</a><span>|</span><label class="collapse" for="c-37517108">[-]</label><label class="expand" for="c-37517108">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s designed the way it is to achieve that goal while minimizing the space used, yet keeping an entire history of the project<p>Most of git&#x27;s design was done before they thought of &#x27;minimizing the space used&#x27;.  Originally, they didn&#x27;t even do deltas and just stored complete snapshots for every object.<p>&gt; Merge conflicts are hard in this model because you&#x27;re trying to put two snapshots together, not just two diffs.<p>I don&#x27;t think that&#x27;s the case at all.  Thanks to three-way-merges git has just as much access to the diffs as any other version control system when merging.  It&#x27;s just that in git diffs are a derived data structure, not a source of truth, but that doesn&#x27;t make a difference.</div><br/><div id="37519178" class="c"><input type="checkbox" id="c-37519178" checked=""/><div class="controls bullet"><span class="by">hooper</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37517108">parent</a><span>|</span><a href="#37516572">next</a><span>|</span><label class="collapse" for="c-37519178">[-]</label><label class="expand" for="c-37519178">[1 more]</label></div><br/><div class="children"><div class="content">One of the ideas behind Pijul is that implicit vs explicit diffs does make an important difference sometimes: <a href="https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;why_pijul.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;pijul.org&#x2F;manual&#x2F;why_pijul.html</a></div><br/></div></div></div></div></div></div><div id="37516572" class="c"><input type="checkbox" id="c-37516572" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#37515760">parent</a><span>|</span><a href="#37516176">prev</a><span>|</span><a href="#37516960">next</a><span>|</span><label class="collapse" for="c-37516572">[-]</label><label class="expand" for="c-37516572">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ClearCase [...] it is not distributed [...]<p>That&#x27;s the key reason Git can&#x27;t work the same way, and what makes it so powerful, and sometimes hard to grok.<p>Git is based on a Directed Acyclic Graph (DAG) of committed changes.  The DAG is shared by everyone.  Each commit is immutable, and only extends the DAG with a new node. You do not alter any of the DAG that other people already possess, you are creating a NEW chain of nodes connected to the DAG.<p>And that&#x27;s it, that&#x27;s how it allows anyone to make changes, at any time, on any number of systems.  Because all operations are strictly additive to the DAG.  Every time you commit changes, you add another immutable node onto the DAG.  And at the very same moment, on another unrelated server, someone else is adding unrelated immutable nodes as well.<p>Later, you may obtain some of those remote changes, they can be fetched into your local repository.  You can fetch them without merging them.  You will just have a copy of how someone else extended the DAG.  But there will be no connection between the changes you made locally, and the changes the other person made in their repository.<p>When you merge, you&#x27;re simply updating the DAG with a new node, it will point at two, previously disconnected chains of commits.  Both sides of the merge represent immutable changes that extended the DAG starting from a single commit, the branching point.<p>And that&#x27;s what you see in merge conflicts.  The first block shows what a section of code looks like in the local branch.  And the second block (after the equal signs) shows what that same section of code looks like in the remote branch you&#x27;re merging.<p><pre><code>    &lt;&lt;&lt;&lt;&lt;&lt;&lt;  local
    a
    X
    c
    ========
    a
    Z
    c
    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; remote
</code></pre>
That&#x27;s it.</div><br/></div></div><div id="37516960" class="c"><input type="checkbox" id="c-37516960" checked=""/><div class="controls bullet"><span class="by">jamie_ca</span><span>|</span><a href="#37515760">parent</a><span>|</span><a href="#37516572">prev</a><span>|</span><a href="#37517014">next</a><span>|</span><label class="collapse" for="c-37516960">[-]</label><label class="expand" for="c-37516960">[1 more]</label></div><br/><div class="children"><div class="content">A lot of its design decisions are based around the data storage model, and tooling built to operate on those data structures. I recall a good write-up from a decade gone now, but no dice googling for it. The short version is probably:<p>- Everything is a blob, a text file named after the SHA1 of its content.<p>- Files are just themselves.<p>- Directories list &lt;entry sha1&gt; &lt;name&gt; for their entries (file or subdirectory).<p>- Commits list a Directory (the project root), and some metadata about the commit like the author, commit message, and the parent(s) of the commit.<p>- A branch then is just an end-user-named reference to a commit&#x27;s hash.<p>Everything flows from that - SHAs are reused, if you&#x27;re doing a diff and two directory entries have the same sha referencing a file, there&#x27;s no change. Switching a branch is modifying the special HEAD branch content, and recursively walking it to rehydrate the filesystem (and comparing to the previous checkout to optimize, skipping whole directories that don&#x27;t change).</div><br/></div></div><div id="37517014" class="c"><input type="checkbox" id="c-37517014" checked=""/><div class="controls bullet"><span class="by">wayfinder</span><span>|</span><a href="#37515760">parent</a><span>|</span><a href="#37516960">prev</a><span>|</span><a href="#37515820">next</a><span>|</span><label class="collapse" for="c-37517014">[-]</label><label class="expand" for="c-37517014">[4 more]</label></div><br/><div class="children"><div class="content">I think Git is conceptually simple... each commit is just conceptually a diff from a previous commit -- possibly from two commits. Branches and tags are just pointers to a commit.<p>A merge is when you join two commits and thus may result in <i>one</i> merge conflict, while a rebase is resetting your branch to some other target commit and then &#x2F;re-applying&#x2F; <i>_each_</i> of <i>your</i> commits on top, which may generate more than 1 merge conflict (due to <i>each _one_</i> of your commits effectively being re-committed all over again) but hides the fact that you applying <i>old</i> changes to a <i>newer</i> base.<p>But the tooling around Git is not great. I think showing merge conflicts properly so you don&#x27;t mess them up is also tooling issue more than anything.<p>I&#x27;m going to plug this app called SmartGit which I have no relationship with that I don&#x27;t think a lot of people have tried but it&#x27;s awesome. Doesn&#x27;t obscure anything about Git and shows merge conflicts well IMO. Costs $ though.</div><br/><div id="37517134" class="c"><input type="checkbox" id="c-37517134" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37517014">parent</a><span>|</span><a href="#37515820">next</a><span>|</span><label class="collapse" for="c-37517134">[-]</label><label class="expand" for="c-37517134">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I think Git is conceptually simple... each commit is just conceptually a diff from a previous commit -- possibly from two commits. Branches and tags are just pointers to a commit.<p>That&#x27;s backwards.  Git commits are complete snapshots of the state of your repository at the time.  You can compute diffs between arbitrary commits, be that between child and parent commits, or completely unrelated commits.<p>Have a look at <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;4129049&#x2F;why-is-a-3-way-merge-advantageous-over-a-2-way-merge" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;4129049&#x2F;why-is-a-3-way-m...</a></div><br/><div id="37518543" class="c"><input type="checkbox" id="c-37518543" checked=""/><div class="controls bullet"><span class="by">wayfinder</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37517134">parent</a><span>|</span><a href="#37515820">next</a><span>|</span><label class="collapse" for="c-37518543">[-]</label><label class="expand" for="c-37518543">[2 more]</label></div><br/><div class="children"><div class="content">Oh I know. I do that all that time. (And in SmartFGit, you can select any two commits.)<p>But I said conceptually and that’s how I see them and it works for me.</div><br/><div id="37520289" class="c"><input type="checkbox" id="c-37520289" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37518543">parent</a><span>|</span><a href="#37515820">next</a><span>|</span><label class="collapse" for="c-37520289">[-]</label><label class="expand" for="c-37520289">[1 more]</label></div><br/><div class="children"><div class="content">Conceptually, though, that&#x27;s the wrong model. Pijul works like that, but git does not: commits are not diffs, they are full snapshots of the repository, including history. If you cherry-pick a commit from one branch to another, that&#x27;s an entire new commit, it&#x27;s not just &quot;this patch moved from one branch to another&quot;. If your idea of a commit is &quot;it&#x27;s a diff to the previous commit&quot;, you&#x27;ll get into trouble.</div><br/></div></div></div></div></div></div></div></div><div id="37515820" class="c"><input type="checkbox" id="c-37515820" checked=""/><div class="controls bullet"><span class="by">zadokshi</span><span>|</span><a href="#37515760">parent</a><span>|</span><a href="#37517014">prev</a><span>|</span><a href="#37516912">next</a><span>|</span><label class="collapse" for="c-37515820">[-]</label><label class="expand" for="c-37515820">[32 more]</label></div><br/><div class="children"><div class="content">I used git for years now. I’m comfortable with all of the basic functions. It is my experience that I have had several times where merging&#x2F;branching has caused a repo to “break”   It doesn’t happen often, but when it does it’s super frustrating and this I avoid the merging workflows where possible. I’m sure if I educate myself a bit more about git and pay more careful attention to the details, I wouldn’t occasionally have this problem, but Git really shouldn’t be like this.</div><br/><div id="37516332" class="c"><input type="checkbox" id="c-37516332" checked=""/><div class="controls bullet"><span class="by">Yodel0914</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37515820">parent</a><span>|</span><a href="#37515904">next</a><span>|</span><label class="collapse" for="c-37516332">[-]</label><label class="expand" for="c-37516332">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using git for I guess 15 years, on a variety of server platforms (github, atlassian, MS devops, plain ssh) and branching models, with teams of various sizes, and I&#x27;ve never had a repo &quot;break&quot;. Branching and merging is what git is amazing at.<p>The worse thing I&#x27;ve had happen is that someone was lazy when merging and just did a &quot;take mine&quot; on 100s of files, thinking that they&#x27;d do a &quot;proper&quot; merge later. Of course git doesn&#x27;t work like that and their lazy merge had to unwound very carefully.</div><br/></div></div><div id="37515904" class="c"><input type="checkbox" id="c-37515904" checked=""/><div class="controls bullet"><span class="by">jayshua</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37515820">parent</a><span>|</span><a href="#37516332">prev</a><span>|</span><a href="#37516842">next</a><span>|</span><label class="collapse" for="c-37515904">[-]</label><label class="expand" for="c-37515904">[1 more]</label></div><br/><div class="children"><div class="content">What does a broken repo look like? What does broken mean here?</div><br/></div></div><div id="37516842" class="c"><input type="checkbox" id="c-37516842" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37515820">parent</a><span>|</span><a href="#37515904">prev</a><span>|</span><a href="#37516007">next</a><span>|</span><label class="collapse" for="c-37516842">[-]</label><label class="expand" for="c-37516842">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It is my experience that I have had several times where merging&#x2F;branching has caused a repo to “break”<p>What do you mean? Like you resolve the conflict correctly and git stops working? Stops working how? That sounds very strange, and anything else just seems like PEBKAC.</div><br/><div id="37517185" class="c"><input type="checkbox" id="c-37517185" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516842">parent</a><span>|</span><a href="#37516007">next</a><span>|</span><label class="collapse" for="c-37517185">[-]</label><label class="expand" for="c-37517185">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t go so far as the term PEBKAC.<p>It&#x27;s true that git does not &#x27;break&#x27; from a merge; but merge conflicts (and rebase conflicts) can still be frustrating to resolve for ordinary users.  And after things get too frustrating, they often do really random stuff that then might accidentally break the repo for real, or at least get it into a state where they don&#x27;t have enough knowledge to recover.<p>Git&#x27;s underlying data model is fine, but the user interface can be quite lacking.  For example, &#x27;git checkout&#x27; is a mess of almost unrelated functionality thrown together under one command.<p>I think the idea behind &#x27;git switch&#x27; is a good one, and git could benefit from a complete overhaul of its user interface.  Well, at least if you ignore the switching costs.  Old farts like you and me have gotten used to the quirks of the bad old interface, and learned all the barely coherent options to &#x27;git reset&#x27;.</div><br/></div></div></div></div><div id="37516007" class="c"><input type="checkbox" id="c-37516007" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37515820">parent</a><span>|</span><a href="#37516842">prev</a><span>|</span><a href="#37516912">next</a><span>|</span><label class="collapse" for="c-37516007">[-]</label><label class="expand" for="c-37516007">[27 more]</label></div><br/><div class="children"><div class="content">Git could be a lot better in a lot of ways, particularly from a developer experience perspective. I’m a little surprised we haven’t seen a meaningful successor.<p>One example is how git will deceive you and tell you you’re up to date with your remote (e.g. origin&#x2F;main). What it means is that your local branch is up to date with its local concept of remote, and makes no statement guarantees about the actual state of the remote. Which is really a nonsense concept that does not need to exist.<p>Similarly the whole concept of needing to specify “origin” at all is a bit bonkers and does no favors. Why is it that I can pull from a remote branch, commit some changes, run ‘git push’ and git has no idea what branch I want to push to. Another example: if main is a protected branch, don’t let me accidentally commit to it locally. I could keep going with the examples but I won’t.<p>And yeah you can forgive all this by quibbling that git was written in a time when internet access was not ubiquitous, and of course all these decisions make sense because x, y, or z <i>advanced edge case</i> for <i>advanced users only</i>, and I’m a shitty engineer because all of this complexity secretly makes my life better and I’m just too simpleminded to appreciate it.<p>Really though, if you rewrote git from a principles first approach (with developer experience being one of those principles), it certainly would not look like how it looks today. There is too much complexity, too many ways to do things, and too many bad decisions around defaults. Treat it like a proper distributed system, perhaps even backed by a real database. It’s not special because the data is code. The fact that it’s treated as such is the reason it feels so weird.</div><br/><div id="37516258" class="c"><input type="checkbox" id="c-37516258" checked=""/><div class="controls bullet"><span class="by">OkayPhysicist</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516007">parent</a><span>|</span><a href="#37516786">next</a><span>|</span><label class="collapse" for="c-37516258">[-]</label><label class="expand" for="c-37516258">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re confused because you&#x27;re treating the repo server as special.<p>Git doesn&#x27;t do special. All branches, on all machines, are just branches. &quot;main&quot; on your device and &quot;origin&#x2F;main&quot; (main on the machine you called &quot;origin&quot;), are two different branches. They don&#x27;t need to share a name, you can just as easily set your local &quot;main&quot; to have &quot;origin&#x2F;Release&quot; as its upstream. The name &quot;main&quot; isn&#x27;t special. You can name your branches anything you desire. If you want to lock yourself out from controlling your own code, that&#x27;s a customization for you to make. To git, there&#x27;s no difference between committing to &quot;main&quot;,&quot;feature111&quot;, or anything else. &quot;origin&quot; isn&#x27;t special, either: you can have many different repo servers hosting different branches. Or maybe you don&#x27;t have a repo server at all, and you just have all your fellow devs machines and you coordinate via email.<p>While being perhaps a bit un-opinionated, it also makes Git conceptually extremely consistent, and thus simple.</div><br/><div id="37516507" class="c"><input type="checkbox" id="c-37516507" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516258">parent</a><span>|</span><a href="#37516786">next</a><span>|</span><label class="collapse" for="c-37516507">[-]</label><label class="expand" for="c-37516507">[3 more]</label></div><br/><div class="children"><div class="content">I certainly understand the abstraction and how to use git in this sense. The foundation of my above opinion is that I don’t think this is a great idea that’s well applied to modern development.<p>Is it elegant that the same version control system can be used whether you have a remote server or you just coordinate over email? It certainly is! Is it necessary to have this level of generality and lack of opinions when 95% of users just want to do the same basic flow (and it <i>does</i> involve a server of some kind)? I don’t really think so, which is why I think there is so much confusion around really basic git functionality.<p>We live in a world where git is philosophically more like Perl than python, and I think that it’s not unreasonable to think that it’s possible that if we flipped that, then that might actually be a good thing.</div><br/><div id="37516963" class="c"><input type="checkbox" id="c-37516963" checked=""/><div class="controls bullet"><span class="by">ylyn</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516507">parent</a><span>|</span><a href="#37516786">next</a><span>|</span><label class="collapse" for="c-37516963">[-]</label><label class="expand" for="c-37516963">[2 more]</label></div><br/><div class="children"><div class="content">Then write your own wrapper on top of Git.</div><br/><div id="37517471" class="c"><input type="checkbox" id="c-37517471" checked=""/><div class="controls bullet"><span class="by">TeeMassive</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516963">parent</a><span>|</span><a href="#37516786">next</a><span>|</span><label class="collapse" for="c-37517471">[-]</label><label class="expand" for="c-37517471">[1 more]</label></div><br/><div class="children"><div class="content">Lazy Git ftw</div><br/></div></div></div></div></div></div></div></div><div id="37516786" class="c"><input type="checkbox" id="c-37516786" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516007">parent</a><span>|</span><a href="#37516258">prev</a><span>|</span><a href="#37516229">next</a><span>|</span><label class="collapse" for="c-37516786">[-]</label><label class="expand" for="c-37516786">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Why is it that I can pull from a remote branch, commit some changes, run ‘git push’ and git has no idea what branch I want to push to<p>Git has automatically tracked remote branches for years now. &quot;git switch foo&quot; will do exactly what you expect if &quot;origin&#x2F;foo&quot; exists.<p>&gt; if main is a protected branch, don’t let me accidentally commit to it locally<p>&quot;Protected branches&quot; don&#x27;t exist in Git. They&#x27;re a GitHub concept. How would you be able to fork a repository if the permissions on a remote copy of the repository prevent you from making changes to your own copy?</div><br/><div id="37517300" class="c"><input type="checkbox" id="c-37517300" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516786">parent</a><span>|</span><a href="#37516229">next</a><span>|</span><label class="collapse" for="c-37517300">[-]</label><label class="expand" for="c-37517300">[3 more]</label></div><br/><div class="children"><div class="content">I can see the case for a local UI option (perhaps even on by default) that warns you when you make changes to a local branch that&#x27;s tracking a remote branch that&#x27;s marked as &#x27;protected&#x27; there.  The option could also have a setting where it outright stops you from making that change.<p>Of course, you could always opt out of that setting.<p>Git doesn&#x27;t know what &#x27;protected&#x27; means, but you could teach it with a relatively small change to its code.  Similarly, it might be useful to teach git about &#x27;volatile&#x27; branches (in the same sense as C&#x27;s volatile variables); a volatile branch is one where git would always checks for upstream changes first before any operation.  Eg origin&#x2F;main would typically be marked as both protected and volatile.<p>Again, volatile would be something you can override locally, but it might be useful as a default.</div><br/><div id="37517635" class="c"><input type="checkbox" id="c-37517635" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37517300">parent</a><span>|</span><a href="#37516229">next</a><span>|</span><label class="collapse" for="c-37517635">[-]</label><label class="expand" for="c-37517635">[2 more]</label></div><br/><div class="children"><div class="content">The logic you&#x27;re suggesting can easily be implemented with a Git hook:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40462111&#x2F;prevent-commits-in-master-branch" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40462111&#x2F;prevent-commits...</a><p>Alternately, you can simply not check out that branch locally at all, and then you&#x27;ll never have to worry about accidentally committing to it.</div><br/><div id="37518764" class="c"><input type="checkbox" id="c-37518764" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37517635">parent</a><span>|</span><a href="#37516229">next</a><span>|</span><label class="collapse" for="c-37518764">[-]</label><label class="expand" for="c-37518764">[1 more]</label></div><br/><div class="children"><div class="content">Also, many repo hosts have branch protection tools, and VS Code has a setting git.branchProtection to list branches which you want VS Code to remind you not to commit to, which can be handy.</div><br/></div></div></div></div></div></div></div></div><div id="37516229" class="c"><input type="checkbox" id="c-37516229" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516007">parent</a><span>|</span><a href="#37516786">prev</a><span>|</span><a href="#37517259">next</a><span>|</span><label class="collapse" for="c-37516229">[-]</label><label class="expand" for="c-37516229">[3 more]</label></div><br/><div class="children"><div class="content">Git separates its plumbing from its porcelain very well. That makes all the different front ends possible. Maybe there&#x27;s one that will help you to work with git?<p>I differ from your opinion that the user experience is poor. I think it&#x27;s great, and I prefer using the command line interface.</div><br/><div id="37516556" class="c"><input type="checkbox" id="c-37516556" checked=""/><div class="controls bullet"><span class="by">tmacam</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516229">parent</a><span>|</span><a href="#37517259">next</a><span>|</span><label class="collapse" for="c-37516556">[-]</label><label class="expand" for="c-37516556">[2 more]</label></div><br/><div class="children"><div class="content">As an example of a different frontend, have you tried &quot;jujutso&quot; [1]? Every time I ended seeing a comment about git vs Hg usability I am reminded of it. It uses git in the backend but its workflow&#x2F;frontend seems streamlined.<p><pre><code>  Jujutsu is a Git-compatible DVCS. It combines features from Git (data model, speed), Mercurial (anonymous branching, simple CLI free from &quot;the index&quot;, revsets, powerful history-rewriting), and Pijul&#x2F;Darcs (first-class conflicts), with features not found in most of them (working-copy-as-a-commit, undo functionality, automatic rebase, safe replication via rsync, Dropbox, or distributed file system).
</code></pre>
[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj">https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj</a></div><br/><div id="37518505" class="c"><input type="checkbox" id="c-37518505" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516556">parent</a><span>|</span><a href="#37517259">next</a><span>|</span><label class="collapse" for="c-37518505">[-]</label><label class="expand" for="c-37518505">[1 more]</label></div><br/><div class="children"><div class="content">This is pretty interesting. Maybe a missed opportunity to call it jugitsu</div><br/></div></div></div></div></div></div><div id="37517259" class="c"><input type="checkbox" id="c-37517259" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516007">parent</a><span>|</span><a href="#37516229">prev</a><span>|</span><a href="#37516560">next</a><span>|</span><label class="collapse" for="c-37517259">[-]</label><label class="expand" for="c-37517259">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Similarly the whole concept of needing to specify “origin” at all is a bit bonkers and does no favors. Why is it that I can pull from a remote branch, commit some changes, run ‘git push’ and git has no idea what branch I want to push to.<p>Git actually works like that.  (Though you might have to set push.autoSetupRemote to true in the config?)<p>However, when you have multiple remotes, it&#x27;s only natural that you will sometimes need to specify which one you want.<p>&gt; And yeah you can forgive all this by quibbling that git was written in a time when internet access was not ubiquitous, and of course all these decisions make sense because x, y, or z advanced edge case for advanced users only, and I’m a shitty engineer because all of this complexity secretly makes my life better and I’m just too simpleminded to appreciate it.<p>Git was explicitly written for Linux kernel development.<p>You are right that almost all other projects are simpler.<p>&gt; Really though, if you rewrote git from a principles first approach (with developer experience being one of those principles), it certainly would not look like how it looks today.<p>I agree that git&#x27;s UI is lacking.  You don&#x27;t need a from-scratch rewrite of whole system.  You can just rewrite the UI only and think carefully about the defaults in the config.<p>Eg &#x27;git checkout&#x27; is an incoherent mess of barely related features.  &#x27;git switch&#x27; is a later addition, and goes in the right direction.<p>&gt; Treat it like a proper distributed system, perhaps even backed by a real database.<p>Git is very much backed by a real database.  That&#x27;s actually one of the stronger points of its design.  You can see that the guy who started git, Linus Torvalds, has a lot of experience writing filesystems (which are also a kind of database).<p>Git is also very much a distributed system with no trust between the nodes necessary, including no central trusted authority.  How would you &#x27;treat&#x27; it even more &#x27;like a proper distributed system&#x27;?<p>&gt; It’s not special because the data is code. The fact that it’s treated as such is the reason it feels so weird.<p>Where do you get that impression from?<p>The main influence of being designed for code first comes in the form of the default merge driver being line oriented.  But you can plug in your own merge drivers for your own data formats.<p>But most everything else works the same, whether you stick C source code or funny cat pictures into your repository.</div><br/></div></div><div id="37516560" class="c"><input type="checkbox" id="c-37516560" checked=""/><div class="controls bullet"><span class="by">zaphirplane</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516007">parent</a><span>|</span><a href="#37517259">prev</a><span>|</span><a href="#37516141">next</a><span>|</span><label class="collapse" for="c-37516560">[-]</label><label class="expand" for="c-37516560">[2 more]</label></div><br/><div class="children"><div class="content">How would that work when someone is working on a feature&#x2F;bug and has to pause switch to a another bug, then return to the 1st feature&#x2F;bug<p>Sometimes you want to keep 2 different copies of Main with different names and state</div><br/><div id="37517332" class="c"><input type="checkbox" id="c-37517332" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516560">parent</a><span>|</span><a href="#37516141">next</a><span>|</span><label class="collapse" for="c-37517332">[-]</label><label class="expand" for="c-37517332">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sometimes you want to keep 2 different copies of Main with different names and state<p>Wouldn&#x27;t that just be two different branches?  What does it have to do with &#x27;main&#x27;?</div><br/></div></div></div></div><div id="37516141" class="c"><input type="checkbox" id="c-37516141" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516007">parent</a><span>|</span><a href="#37516560">prev</a><span>|</span><a href="#37518961">next</a><span>|</span><label class="collapse" for="c-37516141">[-]</label><label class="expand" for="c-37516141">[10 more]</label></div><br/><div class="children"><div class="content">Blame the Linus Torvalds personality cult. Only way that terrible UX got traction in the first place. If anyone OTHER than Linus had written it, it would have been mocked, and deservedly so.</div><br/><div id="37516373" class="c"><input type="checkbox" id="c-37516373" checked=""/><div class="controls bullet"><span class="by">Yodel0914</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516141">parent</a><span>|</span><a href="#37516655">next</a><span>|</span><label class="collapse" for="c-37516373">[-]</label><label class="expand" for="c-37516373">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a pretty big claim. Git solved real problems at the time in a novel and extremely useful way. Coming from SVN (or god forbid VSS), the power and flexibility of git more than made up for its difficulty to grasp.<p>Why it &quot;won&quot; over alternatives with cleaner UX (eg Hg) is a different question, and I think has a lot to do with github.</div><br/><div id="37517348" class="c"><input type="checkbox" id="c-37517348" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516373">parent</a><span>|</span><a href="#37516497">next</a><span>|</span><label class="collapse" for="c-37517348">[-]</label><label class="expand" for="c-37517348">[2 more]</label></div><br/><div class="children"><div class="content">Mercurial came out essentially simultaneously, solved the same problems, with a much more coherent UX.</div><br/><div id="37517517" class="c"><input type="checkbox" id="c-37517517" checked=""/><div class="controls bullet"><span class="by">Yodel0914</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37517348">parent</a><span>|</span><a href="#37516497">next</a><span>|</span><label class="collapse" for="c-37517517">[-]</label><label class="expand" for="c-37517517">[1 more]</label></div><br/><div class="children"><div class="content">Early on, I was definitely a proponent for hg over git. I assumed it would at the very least remain a peer, given how much more sane the UX is. I was wrong though, and I don&#x27;t think it&#x27;s <i>just</i> because of github.<p>Named branches being baked in turned out to actually be a real pain in mercurial. Sure, you can use bookmarks (and we did) but starts to quickly feel like you&#x27;re swimming against the current.</div><br/></div></div></div></div><div id="37516497" class="c"><input type="checkbox" id="c-37516497" checked=""/><div class="controls bullet"><span class="by">spaniard89277</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516373">parent</a><span>|</span><a href="#37517348">prev</a><span>|</span><a href="#37516655">next</a><span>|</span><label class="collapse" for="c-37516497">[-]</label><label class="expand" for="c-37516497">[1 more]</label></div><br/><div class="children"><div class="content">Git may solve real problems but honestly, it&#x27;s a PITA to use. Just for basic tasks needs quite a lot time sink to understand what&#x27;s going on and what do you need to do.<p>It gets in the way of the workflow IMO.</div><br/></div></div></div></div><div id="37516655" class="c"><input type="checkbox" id="c-37516655" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516141">parent</a><span>|</span><a href="#37516373">prev</a><span>|</span><a href="#37516259">next</a><span>|</span><label class="collapse" for="c-37516655">[-]</label><label class="expand" for="c-37516655">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s bigger than him. GitHub built their SaaS on top of it. Had they chosen subversion or fossil, history would be very different.<p>People use git because everybody else uses git and it started because GitHub provides easy code sharing and a better UI than the alternative — SourceForge and mailing lists.</div><br/><div id="37517098" class="c"><input type="checkbox" id="c-37517098" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516655">parent</a><span>|</span><a href="#37516259">next</a><span>|</span><label class="collapse" for="c-37517098">[-]</label><label class="expand" for="c-37517098">[3 more]</label></div><br/><div class="children"><div class="content">People could have kept using SVN or whatever else.  They jumped ship in droves, way before GitHub.<p>At the time it was the only distributed and open source VCS.  Fossil may have come quickly on its heels, but it was already too late.</div><br/><div id="37517145" class="c"><input type="checkbox" id="c-37517145" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37517098">parent</a><span>|</span><a href="#37516259">next</a><span>|</span><label class="collapse" for="c-37517145">[-]</label><label class="expand" for="c-37517145">[2 more]</label></div><br/><div class="children"><div class="content">Mercurial (hg) was released mere weeks after git saw the light of day, so it&#x27;s not that.</div><br/><div id="37517323" class="c"><input type="checkbox" id="c-37517323" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37517145">parent</a><span>|</span><a href="#37516259">next</a><span>|</span><label class="collapse" for="c-37517323">[-]</label><label class="expand" for="c-37517323">[1 more]</label></div><br/><div class="children"><div class="content">And others were released before git:<p>&gt; The first open-source DVCS systems included Arch, Monotone, and Darcs. However, open source DVCSs were never very popular until the release of Git and Mercurial.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Distributed_version_control#History" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Distributed_version_control#Hi...</a></div><br/></div></div></div></div></div></div></div></div><div id="37516259" class="c"><input type="checkbox" id="c-37516259" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516141">parent</a><span>|</span><a href="#37516655">prev</a><span>|</span><a href="#37518961">next</a><span>|</span><label class="collapse" for="c-37516259">[-]</label><label class="expand" for="c-37516259">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I originally had some Linus snark in there but deleted it. My above comment is being rapidly downvoted though, which is in some sense validating.</div><br/></div></div></div></div><div id="37518961" class="c"><input type="checkbox" id="c-37518961" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516007">parent</a><span>|</span><a href="#37516141">prev</a><span>|</span><a href="#37517466">next</a><span>|</span><label class="collapse" for="c-37518961">[-]</label><label class="expand" for="c-37518961">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And yeah you can forgive all this by quibbling that git was written in a time when internet access was not ubiquitous<p>I don&#x27;t think that&#x27;s right. Git&#x27;s remote concepts were built heavily on even more ubiquitous internet access than you are assuming, to some extent. Git was built where some upstreams were patches on email mailing lists. Git was built in environments where every contributor could relatively easily stand up a small server of their own (even as just a temporary server on a personal device with specified time windows) and you might have branch remotes tied to different colleagues&#x27; servers in a <i>distributed</i> fashion, the D in DVCS.<p>At the time those weren&#x27;t advanced features for advanced users, those were simple features for flexible source control. There&#x27;s a sort of simplicity to pull requests in email flows. There&#x27;s a sort of simplicity in &quot;hey, can you check out my branch and make notes on it, I&#x27;ll serve it on my lab machine for a couple of hours so you can grab it, here&#x27;s the URL.&quot; In some of those cases you don&#x27;t even care to remember that remote URL after you&#x27;ve grabbed the branch because it will be a different IP address and port the next time they bring up that lab machine. (Git was a built in a world where there was no &quot;origin&quot; and multiple repos were valid representations of progress, some of them transient and as-needed, and &quot;origin&quot; was a name and concept that came later.)<p>Some of that only exists in a world that assumes internet connectivity is ubiquitous, not just access, but service hosting and upload capabilities. The internet has some strange centralizing forces making access easier but anything other than raw consumption harder.<p>There are certainly a lot of good reasons for some of that centralization. Whether or not is &quot;simpler&quot;, there&#x27;s a <i>convenience</i> on everyone sharing big centralized hosts. There&#x27;s a lot of convenience of &quot;there is mostly only one remote that everyone shares and it has a high uptime SLA and a ton of extra collaboration features in one place&quot;. There were certainly a lot of centralized version control systems before the DVCS was invented, and beyond convenience also a lot of <i>familiarity</i> that such centralizing operations benefited from.<p>It&#x27;s interesting to me that in your last paragraph you think the solution is to make git a more &quot;proper&quot; distributed system, but one of the features you find too complex and don&#x27;t like exists so much <i>because</i> it was defined and built as a distributed system and just isn&#x27;t as convenient when working with centralized providers. git repos support multiple remotes because it was built to be distributed, git repos require to fetch remotes explicitly because it was built to be fault-tolerant in a distributed system and remotes may have very different SLAs from each other; losing access to one remote host shouldn&#x27;t stop you from fetching updates from a different one. The DX there was built for a distributed system. It is mostly where we see everything revolving around some super special &quot;origin&quot; remote that the DX feels overly-complicated and maybe missing better &quot;defaults&quot;. It is mostly on the internet where running a simple CLI command to spin up a quick code server on a random port on a random machine with an accessible IP address is increasingly hard that it also becomes harder to imagine why people ever needed remotes beyond that special sauce &quot;origin&quot; idea.</div><br/></div></div><div id="37517466" class="c"><input type="checkbox" id="c-37517466" checked=""/><div class="controls bullet"><span class="by">TeeMassive</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516007">parent</a><span>|</span><a href="#37518961">prev</a><span>|</span><a href="#37516912">next</a><span>|</span><label class="collapse" for="c-37517466">[-]</label><label class="expand" for="c-37517466">[1 more]</label></div><br/><div class="children"><div class="content">Git is much more data focused than all the other VCS.
Sure, exposes details that complicates its usage for novices users, but it makes everything more maintainable and extensible in the long run.</div><br/></div></div></div></div></div></div><div id="37516912" class="c"><input type="checkbox" id="c-37516912" checked=""/><div class="controls bullet"><span class="by">seesaw</span><span>|</span><a href="#37515760">parent</a><span>|</span><a href="#37515820">prev</a><span>|</span><a href="#37516926">next</a><span>|</span><label class="collapse" for="c-37516912">[-]</label><label class="expand" for="c-37516912">[2 more]</label></div><br/><div class="children"><div class="content">+1 for clearcase. I enjoyed the time I used clearcase, and never found another one that was as pleasant to use as an end user.</div><br/><div id="37519754" class="c"><input type="checkbox" id="c-37519754" checked=""/><div class="controls bullet"><span class="by">Borg3</span><span>|</span><a href="#37515760">root</a><span>|</span><a href="#37516912">parent</a><span>|</span><a href="#37516926">next</a><span>|</span><label class="collapse" for="c-37519754">[-]</label><label class="expand" for="c-37519754">[1 more]</label></div><br/><div class="children"><div class="content">Ugh. Ive been both using ClearCase and also were Admin of it.
While as user it was pretty fine to use, as Admin I saw how complicated and fragile the whole thing was. They distributed model is absolutly terrible.
You need powerfull box as a VOB server and probably be equal or even more powerfull box if you want to use dynamic views. We ended up using snapshot views.<p>I would choose GIT every single time over ClearCase.</div><br/></div></div></div></div></div></div><div id="37516848" class="c"><input type="checkbox" id="c-37516848" checked=""/><div class="controls bullet"><span class="by">temeya</span><span>|</span><a href="#37517042">prev</a><span>|</span><label class="collapse" for="c-37516848">[-]</label><label class="expand" for="c-37516848">[2 more]</label></div><br/><div class="children"><div class="content">While I&#x27;ve used Git a bit, and appreciate for what it is, I will admit that it&#x27;s syntax is what makes it a bit difficult. If the Git commands had kept to a single metaphor, then I think that would have helped tremendously. Even now, I&#x27;m still trying to figure out the best metaphor for using Git and it&#x27;s commands. So far the closest I have is a tree metaphor as follows:<p>Git init = tree planted<p>Git add and Git merge = trunk grows<p>Git branch = branch grows<p>Git merge = branch intersects<p>And so on. But even this falls apart once I get to Git diff and Git checkout.</div><br/><div id="37516970" class="c"><input type="checkbox" id="c-37516970" checked=""/><div class="controls bullet"><span class="by">brainbag</span><span>|</span><a href="#37516848">parent</a><span>|</span><label class="collapse" for="c-37516970">[-]</label><label class="expand" for="c-37516970">[1 more]</label></div><br/><div class="children"><div class="content">If you haven&#x27;t watched the brilliant Git For Ages 4 and Up I can&#x27;t recommend it more highly. I make everyone watch it on my teams and my students. <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=3m7BgIvC-uQ">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=3m7BgIvC-uQ</a> Git is quite simple under the hood, it&#x27;s the convoluted user interface that makes it seem so difficult. Once you understand technically what the commands are doing, it&#x27;s a lot easier to know which one to reach for.</div><br/></div></div></div></div></div></div></div></div></div></body></html>