<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688029269275" as="style"/><link rel="stylesheet" href="styles.css?v=1688029269275"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://oatzy.github.io/2020/05/10/writing-python-like-rust.html">Writing Python like Rust (2020)</a> <span class="domain">(<a href="https://oatzy.github.io">oatzy.github.io</a>)</span></div><div class="subtext"><span>behnamoh</span> | <span>87 comments</span></div><br/><div><div id="36515792" class="c"><input type="checkbox" id="c-36515792" checked=""/><div class="controls bullet"><span class="by">ddejohn</span><span>|</span><a href="#36516661">next</a><span>|</span><label class="collapse" for="c-36515792">[-]</label><label class="expand" for="c-36515792">[26 more]</label></div><br/><div class="children"><div class="content">My current role is at a company with a few hundred <i>thousand</i> lines of un-typed, undocumented, mostly un-tested Python. I get a small allowance of &quot;tech debt busting&quot; time, and it&#x27;s absurd how many bugs I find just by trying to suss out the types on a given code path. It&#x27;s maddening work.</div><br/><div id="36515959" class="c"><input type="checkbox" id="c-36515959" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#36515792">parent</a><span>|</span><a href="#36516087">next</a><span>|</span><label class="collapse" for="c-36515959">[-]</label><label class="expand" for="c-36515959">[7 more]</label></div><br/><div class="children"><div class="content">My experience of porting Javascript code to Typescript (or calling into Javascript from Typescript and figuring out the correct types to pass) is very similar.<p>Thousands of files all become filled with very obvious bugs once you enable a basic type checker, which then helps brand Typescript as &quot;too much effort&quot; by those who normally write Javascript because now they need to deal with their buggy code. Luckily you can just explicitly cast all of your types without checking and hope that nobody notices!<p>When you ask people to get their typing right, someone will use buzzwords like &quot;rapid prototyping&quot; and remind you that features are more important than fixing the existing product as long as nobody complains about the bugs, and that&#x27;s that. Also, Typescript is hard, apparently.<p>Untyped legacy code sucks. It&#x27;s one of the reasons I detest working with languages like Javascript, Python, and PHP. At least Python and PHP have types these days, making Javascript objectively inferior.</div><br/><div id="36516582" class="c"><input type="checkbox" id="c-36516582" checked=""/><div class="controls bullet"><span class="by">wirrbel</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36515959">parent</a><span>|</span><a href="#36517303">next</a><span>|</span><label class="collapse" for="c-36516582">[-]</label><label class="expand" for="c-36516582">[4 more]</label></div><br/><div class="children"><div class="content">The other way around you have the &quot;it compiles, so I don&#x27;t need tests&quot; crowd in statically-typed languages.</div><br/><div id="36517983" class="c"><input type="checkbox" id="c-36517983" checked=""/><div class="controls bullet"><span class="by">cjfd</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516582">parent</a><span>|</span><a href="#36516901">next</a><span>|</span><label class="collapse" for="c-36517983">[-]</label><label class="expand" for="c-36517983">[1 more]</label></div><br/><div class="children"><div class="content">Are there many people like that?<p>In actuality, writing software that is some quality is so hard that one needs all help one can get. One absolutely needs type checking and is just not professional without. One absolutely needs automated tests and is just not professional without. One absolutely needs manual&#x2F;exploratory testing and is just not professional without.</div><br/></div></div><div id="36516901" class="c"><input type="checkbox" id="c-36516901" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516582">parent</a><span>|</span><a href="#36517983">prev</a><span>|</span><a href="#36516755">next</a><span>|</span><label class="collapse" for="c-36516901">[-]</label><label class="expand" for="c-36516901">[1 more]</label></div><br/><div class="children"><div class="content">I am currently firefighting for a customer who has a medium Sized application in c#. Started around 2019 so not ancient, but every programming, architecture and technology choice was wrong.<p>Sure it compiles. But often it crashes without rhyme or reason and for some reason, customers hate it.<p>First thing I did was to get it from .net 4.8 to .net 7 and enable all available errors checkers and style linters.<p>The other howled, but their builds stopped because they could no longer check-in crap. That helped. But fixing this is more work than what this would have needed if they had done it right the first time.<p>Funny examples: reinvanted rabbitmw badly using raw TCP and XML. Better hope your network is good, If the messages arrive at the same time, they are merged and the app crashes. So there are lots of time.sleep(50) calls to avoid that. Why is that app slow?<p>The iot devices can only address 254 states. The UI for that allows ulong devices. It&#x27;s never checked, but if the vast fails, the app just crashes.</div><br/></div></div><div id="36516755" class="c"><input type="checkbox" id="c-36516755" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516582">parent</a><span>|</span><a href="#36516901">prev</a><span>|</span><a href="#36517303">next</a><span>|</span><label class="collapse" for="c-36516755">[-]</label><label class="expand" for="c-36516755">[1 more]</label></div><br/><div class="children"><div class="content">This might sort of work if everything from the domain gets a disjoint type, but stringly-typed code is a lot more common and the type system doesn’t know what would make sense.</div><br/></div></div></div></div><div id="36517303" class="c"><input type="checkbox" id="c-36517303" checked=""/><div class="controls bullet"><span class="by">MereInterest</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36515959">parent</a><span>|</span><a href="#36516582">prev</a><span>|</span><a href="#36516425">next</a><span>|</span><label class="collapse" for="c-36517303">[-]</label><label class="expand" for="c-36517303">[1 more]</label></div><br/><div class="children"><div class="content">This might be dependent on the size of your codebase, but it can be useful to start by running checks locally, using the static analysis to find bugs, then submitting the fixes independent of the static analysis.  That way, by the time you propose enabling static analysis on all commits, it doesn’t scare people away.<p>Granted, this has the potential of the opposite problem, convincing detractors that static analysis didn’t find much, but that can be avoided by keeping a list of the bugs that were resolved ahead of time.</div><br/></div></div><div id="36516425" class="c"><input type="checkbox" id="c-36516425" checked=""/><div class="controls bullet"><span class="by">valzam</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36515959">parent</a><span>|</span><a href="#36517303">prev</a><span>|</span><a href="#36516087">next</a><span>|</span><label class="collapse" for="c-36516425">[-]</label><label class="expand" for="c-36516425">[1 more]</label></div><br/><div class="children"><div class="content">&quot;having type annotations&quot; and &quot;having types&quot; are two very different things. The people who say TS is too hard&#x2F;not worth are most definitely not adding type annotations to Python&#x2F;PHP code.</div><br/></div></div></div></div><div id="36516087" class="c"><input type="checkbox" id="c-36516087" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#36515792">parent</a><span>|</span><a href="#36515959">prev</a><span>|</span><a href="#36517820">next</a><span>|</span><label class="collapse" for="c-36516087">[-]</label><label class="expand" for="c-36516087">[9 more]</label></div><br/><div class="children"><div class="content">This is why I can&#x27;t help but mentally roll my eyes when people say that static typing makes programming slower.<p>It makes writing the happy path slower, but is writing the happy path _programming?_<p>By the time you have a program which is complete and (at least mostly) bug free, the static typing has saved you hundreds of hours.</div><br/><div id="36516463" class="c"><input type="checkbox" id="c-36516463" checked=""/><div class="controls bullet"><span class="by">lixtra</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516087">parent</a><span>|</span><a href="#36516203">next</a><span>|</span><label class="collapse" for="c-36516463">[-]</label><label class="expand" for="c-36516463">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It makes writing the happy path slower, but is writing the happy path _programming?_<p>The happy path is just fine for many cases.<p>Your home isn’t built to withstand a determined attacker with a tank. But we live in a happy world and a lot of stuff exists because people can cut corners.<p>Good managers&#x2F;programmers know where they can be sloppy and where they have to be super careful.<p>The beauty of technical debt is that it only has to be repaid in case of success.</div><br/><div id="36516561" class="c"><input type="checkbox" id="c-36516561" checked=""/><div class="controls bullet"><span class="by">beoberha</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516463">parent</a><span>|</span><a href="#36516833">next</a><span>|</span><label class="collapse" for="c-36516561">[-]</label><label class="expand" for="c-36516561">[1 more]</label></div><br/><div class="children"><div class="content">This is an interesting example. There are plenty of rules that must be followed when building a home. Equating type checking to a home being able to withstand a tank is a poor example IMO due to the potential of the scenario actually occurring. You’re going to have type checking errors. You’re never going to have someone coming at your home with a tank. A much better example is a significant amount of rain or wind. You might have that storm once every few years but you’ll be glad you built it to withstand it when it comes.<p>I’m being generous tbh. In my experience, though I work on pretty critical software, the unhappy path is a fairly critical path and must have some intentional barriers built before being shipped to customers.</div><br/></div></div><div id="36516833" class="c"><input type="checkbox" id="c-36516833" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516463">parent</a><span>|</span><a href="#36516561">prev</a><span>|</span><a href="#36516203">next</a><span>|</span><label class="collapse" for="c-36516833">[-]</label><label class="expand" for="c-36516833">[1 more]</label></div><br/><div class="children"><div class="content">The dynamic type checking analogy of house building is eyeballing support dimensions and then rebuilding walls when they fall down. Fine for a shed, but if it&#x27;s a building I&#x27;m living in I would like a structural engineer to do some calculations to check it&#x27;s ok <i>before</i> I use it.<p>Maybe that&#x27;s the difference between programming and software engineering! Engineers care if their stuff breaks.</div><br/></div></div></div></div><div id="36516203" class="c"><input type="checkbox" id="c-36516203" checked=""/><div class="controls bullet"><span class="by">l0b0</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516087">parent</a><span>|</span><a href="#36516463">prev</a><span>|</span><a href="#36516528">next</a><span>|</span><label class="collapse" for="c-36516203">[-]</label><label class="expand" for="c-36516203">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; It makes writing the happy path slower, but is writing the happy path _programming?_
</code></pre>
Most managers and even some programmers seem to think so. Build the thing with no quality control, ship it, deal with the fallout, repeat. Bad programmers think this is normal, good programmers ensure that any fallout is rare.</div><br/><div id="36516408" class="c"><input type="checkbox" id="c-36516408" checked=""/><div class="controls bullet"><span class="by">smif</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516203">parent</a><span>|</span><a href="#36516528">next</a><span>|</span><label class="collapse" for="c-36516408">[-]</label><label class="expand" for="c-36516408">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if it&#x27;s necessarily bad programmers. Think about this analogy, there&#x27;s a blacksmith that can make swords but if you want it done well, it&#x27;s gonna take more time&#x2F;money. That same blacksmith can choose to take on customers that insist that he make the sword quicker and cheaper (and probably shittier).<p>He&#x27;s not gonna be the one using the sword and he can make it clear up front about the tradeoffs. If it shatters in use and the customer gets maimed, oh well, they were warned. Sometimes the market is flooded with people who just want cheap swords made fast and the blacksmith needs to pay the bills too right?</div><br/><div id="36517585" class="c"><input type="checkbox" id="c-36517585" checked=""/><div class="controls bullet"><span class="by">MereInterest</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516408">parent</a><span>|</span><a href="#36516528">next</a><span>|</span><label class="collapse" for="c-36517585">[-]</label><label class="expand" for="c-36517585">[1 more]</label></div><br/><div class="children"><div class="content">One problem with this mentality is that customers need to search more and more to find blacksmiths that provide anything other than cheap swords.  They may reasonably conclude that this is just the nature of swords, and that there’s no such thing as a sword that withstands more than one or two blows.  Eventually, even people who want good swords accept that they won’t be able to find a blacksmith who makes them, and settle for cheap swords instead.<p>In effect, <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Market_for_Lemons" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Market_for_Lemons</a></div><br/></div></div></div></div></div></div><div id="36516528" class="c"><input type="checkbox" id="c-36516528" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516087">parent</a><span>|</span><a href="#36516203">prev</a><span>|</span><a href="#36516445">next</a><span>|</span><label class="collapse" for="c-36516528">[-]</label><label class="expand" for="c-36516528">[1 more]</label></div><br/><div class="children"><div class="content">plus modern statically typed languages have type inference so I don&#x27;t buy the argument that the happy path is faster in dynamically typed languages.</div><br/></div></div><div id="36516445" class="c"><input type="checkbox" id="c-36516445" checked=""/><div class="controls bullet"><span class="by">jim-jim-jim</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516087">parent</a><span>|</span><a href="#36516528">prev</a><span>|</span><a href="#36517820">next</a><span>|</span><label class="collapse" for="c-36516445">[-]</label><label class="expand" for="c-36516445">[1 more]</label></div><br/><div class="children"><div class="content">Funnily enough, languages with sufficiently advanced type systems can focus almost exclusively on the happy path thanks to functor&#x2F;applicative&#x2F;monad.<p>--<p>It seems that this comment is controversial and I&#x27;m not sure why. I&#x27;m referring to the ability to do something like<p><pre><code>    h &lt;=&lt; g &lt;=&lt; f
</code></pre>
in Haskell, compared to a much longer explicit error checking equivalent in Go etc.</div><br/></div></div></div></div><div id="36517820" class="c"><input type="checkbox" id="c-36517820" checked=""/><div class="controls bullet"><span class="by">holri</span><span>|</span><a href="#36515792">parent</a><span>|</span><a href="#36516087">prev</a><span>|</span><a href="#36517520">next</a><span>|</span><label class="collapse" for="c-36517820">[-]</label><label class="expand" for="c-36517820">[1 more]</label></div><br/><div class="children"><div class="content">It is no problem to write buggy unmaintainable code in a strongly typed language. It is also perfectly possible to write clean and maintainable code in a duck type language.</div><br/></div></div><div id="36517520" class="c"><input type="checkbox" id="c-36517520" checked=""/><div class="controls bullet"><span class="by">s6ro</span><span>|</span><a href="#36515792">parent</a><span>|</span><a href="#36517820">prev</a><span>|</span><a href="#36517867">next</a><span>|</span><label class="collapse" for="c-36517520">[-]</label><label class="expand" for="c-36517520">[1 more]</label></div><br/><div class="children"><div class="content">Ah memories... I once had 100K Python 2.x codebase to maintain. No docs, no tests and then being required to add features. Had to use the debugger[1] to make sense of the codebase and types, formats etc. Sheer madness and 
such a waste of time...<p>To this day, I&#x27;m baffled by the dynamic language folks who cannot get their head around how strictness&#x2F;rigor (via a good expressive type system) actually makes maintenance easier and more importantly: cheaper.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;inducer&#x2F;pudb">https:&#x2F;&#x2F;github.com&#x2F;inducer&#x2F;pudb</a></div><br/></div></div><div id="36517867" class="c"><input type="checkbox" id="c-36517867" checked=""/><div class="controls bullet"><span class="by">bronxpockfabz</span><span>|</span><a href="#36515792">parent</a><span>|</span><a href="#36517520">prev</a><span>|</span><a href="#36515840">next</a><span>|</span><label class="collapse" for="c-36517867">[-]</label><label class="expand" for="c-36517867">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;beartype&#x2F;beartype">https:&#x2F;&#x2F;github.com&#x2F;beartype&#x2F;beartype</a><p>I wish more people started using Beartype, it makes Python bearable</div><br/></div></div><div id="36515840" class="c"><input type="checkbox" id="c-36515840" checked=""/><div class="controls bullet"><span class="by">l0b0</span><span>|</span><a href="#36515792">parent</a><span>|</span><a href="#36517867">prev</a><span>|</span><a href="#36515940">next</a><span>|</span><label class="collapse" for="c-36515840">[-]</label><label class="expand" for="c-36515840">[1 more]</label></div><br/><div class="children"><div class="content">Bringing a non-trivial code base up to even half-decent standards can be a monumental task, and because such code bases are inherently overly complex and risky to change there&#x27;s only so much you can do without breaking production constantly. It&#x27;s a lose-lose proposition, which is why I&#x27;d never want to be &quot;the programmer&quot; at some place like that, no matter the pay.</div><br/></div></div><div id="36515940" class="c"><input type="checkbox" id="c-36515940" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#36515792">parent</a><span>|</span><a href="#36515840">prev</a><span>|</span><a href="#36516661">next</a><span>|</span><label class="collapse" for="c-36515940">[-]</label><label class="expand" for="c-36515940">[5 more]</label></div><br/><div class="children"><div class="content">django has 500K lines of python and it&#x27;s considered well written and stable, so it&#x27;s possible to do python with large code base I think. oddly, django does not seem to be even using type hints, new features such as dataclasses was not found from the source base either, still it just works well somehow.</div><br/><div id="36516163" class="c"><input type="checkbox" id="c-36516163" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36515940">parent</a><span>|</span><a href="#36516146">next</a><span>|</span><label class="collapse" for="c-36516163">[-]</label><label class="expand" for="c-36516163">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because a great deal of Django was written before type hints or even dataclasses existed.</div><br/><div id="36517817" class="c"><input type="checkbox" id="c-36517817" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516163">parent</a><span>|</span><a href="#36516146">next</a><span>|</span><label class="collapse" for="c-36517817">[-]</label><label class="expand" for="c-36517817">[1 more]</label></div><br/><div class="children"><div class="content">And type hints aren&#x27;t really that mature yet. If you look at the `typing` module&#x27;s documentation in Python 3.11, there&#x27;s 23 occurrences of the string &quot;Changed in version&quot;. And the Python 3.12 version of the same document adds 9 more. Type hinting in Python is constantly evolving.</div><br/></div></div></div></div><div id="36516146" class="c"><input type="checkbox" id="c-36516146" checked=""/><div class="controls bullet"><span class="by">dsissitka</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36515940">parent</a><span>|</span><a href="#36516163">prev</a><span>|</span><a href="#36516661">next</a><span>|</span><label class="collapse" for="c-36516146">[-]</label><label class="expand" for="c-36516146">[2 more]</label></div><br/><div class="children"><div class="content">I was curious:<p><pre><code>  SLOC    Directory       SLOC-by-Language (Sorted)
  232099  tests           python=232099
  102470  django          python=102470
  424     docs            python=424
  158     scripts         python=142,sh=16
  21      top_dir         python=21
  0       extras          (none)
  0       js_tests        (none)
  
  Totals grouped by language (dominant language first):
  python:      335156 (100.00%)
  sh:              16 (0.00%)
  
  Please credit this data as &quot;generated using David A. Wheeler&#x27;s &#x27;SLOCCount&#x27;.&quot;</code></pre></div><br/><div id="36517297" class="c"><input type="checkbox" id="c-36517297" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#36515792">root</a><span>|</span><a href="#36516146">parent</a><span>|</span><a href="#36516661">next</a><span>|</span><label class="collapse" for="c-36517297">[-]</label><label class="expand" for="c-36517297">[1 more]</label></div><br/><div class="children"><div class="content">Wow, 2.3x for tests&#x2F;src ratio. I remember some recommendation for Java to have around 0.9x ratio, otherwise too much tests maintenance.<p>Depends on the project of course, e.g. SQLite has an insane ratio.</div><br/></div></div></div></div></div></div></div></div><div id="36516661" class="c"><input type="checkbox" id="c-36516661" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#36515792">prev</a><span>|</span><a href="#36516356">next</a><span>|</span><label class="collapse" for="c-36516661">[-]</label><label class="expand" for="c-36516661">[19 more]</label></div><br/><div class="children"><div class="content">&gt; What I like about the Rust (and to a lesser extent, Go) approach to error handling is, you know up front if and what errors a function might return. And additionally, the compiler forces you to at least consider how you’re going to deal with it.<p>&gt; By comparison, the python approach to dealing with exceptions is quite chunky<p>&gt; try:
&gt;     function()
&gt; except SomeException:
&gt;     # etc<p>&gt; I think this, in fact, encourages just letting exceptions bubble up, rather than fussing about with handling them.<p>Letting exceptions bubble up is usually the right thing to do. Handle them centrally, e.g. in middleware for a web application.</div><br/><div id="36516703" class="c"><input type="checkbox" id="c-36516703" checked=""/><div class="controls bullet"><span class="by">mindwok</span><span>|</span><a href="#36516661">parent</a><span>|</span><a href="#36517228">next</a><span>|</span><label class="collapse" for="c-36516703">[-]</label><label class="expand" for="c-36516703">[7 more]</label></div><br/><div class="children"><div class="content">Agree. I spent quite a lot of effort at a previous role trying to convince junior developers to stop using except pretty much everywhere and just let the program explode, because that&#x27;s really what you want most of the time. The problem is that sometimes in Python exceptions can be used for control flow, or for things that are reasonably common. In that case, it&#x27;s very useful to know ahead of time what errors might be returned.</div><br/><div id="36516923" class="c"><input type="checkbox" id="c-36516923" checked=""/><div class="controls bullet"><span class="by">dotancohen</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516703">parent</a><span>|</span><a href="#36517228">next</a><span>|</span><label class="collapse" for="c-36516923">[-]</label><label class="expand" for="c-36516923">[6 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; The problem is that sometimes in Python exceptions can be used for control flow, or for things that are reasonably common.
</code></pre>
Almost every time I&#x27;ve heard this argument, I&#x27;ve disagreed with it. I think that the only time using Exceptions for flow control was valid was some string-validation technique (like ensuring that a string was JSON or an email address) that could only throw an exception on error. I&#x27;d love to see _your_ use case, though.</div><br/><div id="36517959" class="c"><input type="checkbox" id="c-36517959" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516923">parent</a><span>|</span><a href="#36517834">next</a><span>|</span><label class="collapse" for="c-36517959">[-]</label><label class="expand" for="c-36517959">[1 more]</label></div><br/><div class="children"><div class="content">The way that an iterator signals that it is done iterating is by raising StopIteration ( <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;exceptions.html#StopIteration" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;exceptions.html#StopIterat...</a> ).<p>I don&#x27;t know if it&#x27;s still the case in Python 3, but in 2 that exception was core to how for loops and list comprehensions worked.</div><br/></div></div><div id="36517834" class="c"><input type="checkbox" id="c-36517834" checked=""/><div class="controls bullet"><span class="by">Skeime</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516923">parent</a><span>|</span><a href="#36517959">prev</a><span>|</span><a href="#36517287">next</a><span>|</span><label class="collapse" for="c-36517834">[-]</label><label class="expand" for="c-36517834">[1 more]</label></div><br/><div class="children"><div class="content">I think any type of parsing benefits from some happy-path&#x2F;unhappy-path support in the language, because parsing essentially is about figuring out whether your input conforms to some format and then translating it into a more useful representation. And it often works in a nested way, where you parse sub-parts of your input and then combine those parts later. If you don’t use some form of exceptions&#x2F;result types&#x2F;CPS, you end up with lots of code like<p><pre><code>    if first part of input_data has format a:
        extract first part of output from input_data
</code></pre>
You need the checks because otherwise your program will blow up in the extract step, which in parsing is often not what you want, as you might need to try a different way of parsing the same thing first. Internally, the check and the extraction often do pretty similar things, so you’re duplicating your work.<p>Here, exceptions for control flow can help, because instead of the check, you just try to extract, and if it doesn’t work, you try the next version. (However, result types usually work better for this, in programming languages that support them.)<p>And as the last point, in my experience, many programming problems are handled cleanest when treating them as the problem of parsing some form of input (not necessarily a string) into some form of output. So this comes up more often than one might first think.<p>[Also, Python uses exceptions for some types of control flow internally. For example, StopIteration is thrown by Iterators for the (rather unexceptional) case that the Iterator is finished producing output. Admittedly, you can almost always just use a for loop, except when you want access to the StopIteration’s value at the end.]</div><br/></div></div><div id="36517287" class="c"><input type="checkbox" id="c-36517287" checked=""/><div class="controls bullet"><span class="by">stevesimmons</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516923">parent</a><span>|</span><a href="#36517834">prev</a><span>|</span><a href="#36517756">next</a><span>|</span><label class="collapse" for="c-36517287">[-]</label><label class="expand" for="c-36517287">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; The problem is that sometimes in Python exceptions can be used for control flow, or for things that are reasonably common.
</code></pre>
Using exceptions for control flow is, imo, fine within a single function (e.g. for x in y: try: blah except KeyError: continue).<p>Using exceptions for control flow across function boundaries seems a recipe for confusion, unless very clearly documented.</div><br/></div></div><div id="36517756" class="c"><input type="checkbox" id="c-36517756" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516923">parent</a><span>|</span><a href="#36517287">prev</a><span>|</span><a href="#36517514">next</a><span>|</span><label class="collapse" for="c-36517756">[-]</label><label class="expand" for="c-36517756">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused — how would one use exceptions if not for control flow?</div><br/></div></div><div id="36517514" class="c"><input type="checkbox" id="c-36517514" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516923">parent</a><span>|</span><a href="#36517756">prev</a><span>|</span><a href="#36517228">next</a><span>|</span><label class="collapse" for="c-36517514">[-]</label><label class="expand" for="c-36517514">[1 more]</label></div><br/><div class="children"><div class="content">The async library e.g. uses exceptions for queues.</div><br/></div></div></div></div></div></div><div id="36517228" class="c"><input type="checkbox" id="c-36517228" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#36516661">parent</a><span>|</span><a href="#36516703">prev</a><span>|</span><a href="#36517541">next</a><span>|</span><label class="collapse" for="c-36517228">[-]</label><label class="expand" for="c-36517228">[1 more]</label></div><br/><div class="children"><div class="content">A good fraction of bugs and exceptions I’ve seen in real python code bases is because the code itself didn’t handle the None edge cases at the exact moment they get created, and hence fail in a different place and let the debugging engineer scratching their head.<p>If you write typed python code that lets you avoid this while writing the bad code at the beginning itself, that’s a win. Actual runtime errors caused due to invalid user input should of course throw appropriate exceptions deep in the code and bubble up and be handled in middleware.</div><br/></div></div><div id="36517541" class="c"><input type="checkbox" id="c-36517541" checked=""/><div class="controls bullet"><span class="by">duckmysick</span><span>|</span><a href="#36516661">parent</a><span>|</span><a href="#36517228">prev</a><span>|</span><a href="#36517300">next</a><span>|</span><label class="collapse" for="c-36517541">[-]</label><label class="expand" for="c-36517541">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Handle them centrally, e.g. in middleware for a web application.<p>So, for a Django app is it better to use their built-in middleware framework or something third-party that sits outside of Django?<p><a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;4.2&#x2F;topics&#x2F;http&#x2F;middleware&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;4.2&#x2F;topics&#x2F;http&#x2F;middleware...</a></div><br/></div></div><div id="36517300" class="c"><input type="checkbox" id="c-36517300" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#36516661">parent</a><span>|</span><a href="#36517541">prev</a><span>|</span><a href="#36516812">next</a><span>|</span><label class="collapse" for="c-36517300">[-]</label><label class="expand" for="c-36517300">[1 more]</label></div><br/><div class="children"><div class="content">Usually? Yea there is a lot of stuff that you handle &quot;centrally&quot;, but there is also a lot of stuff that you should handle locally. E.g. &quot;try this then that&quot;. Or stuff that you try, just log or save the error, and continue.<p>Exceptions are obviously great for bubbling up, but just awful for handling locally. I don&#x27;t know what it is: maybe it&#x27;s the horrible try&#x2F;catch control flow that breaks everything up, or the fact that all functions can &quot;return&quot; exceptions apart from the ones in the signature (if any), so you&#x27;re never quite sure what happens or what to do.</div><br/></div></div><div id="36516812" class="c"><input type="checkbox" id="c-36516812" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#36516661">parent</a><span>|</span><a href="#36517300">prev</a><span>|</span><a href="#36516793">next</a><span>|</span><label class="collapse" for="c-36516812">[-]</label><label class="expand" for="c-36516812">[5 more]</label></div><br/><div class="children"><div class="content">Handle errors as soon as you can is my stance. If a low-level function raises, but its immediate caller knows how to handle that specific exception, handle it (for example, turn a zero division error into None, if it makes sense for the domain).<p>Only bubble up if your handling consists of reraising anyway and no business logic can be applied (which might be the majority of cases).</div><br/><div id="36516835" class="c"><input type="checkbox" id="c-36516835" checked=""/><div class="controls bullet"><span class="by">jdeaton</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516812">parent</a><span>|</span><a href="#36516793">next</a><span>|</span><label class="collapse" for="c-36516835">[-]</label><label class="expand" for="c-36516835">[4 more]</label></div><br/><div class="children"><div class="content">This is interestingly divergent from the advice given in “Philosophy of Software Design” by John O. which is “exceptions are most useful when they&#x27;re thrown the furthest”</div><br/><div id="36517316" class="c"><input type="checkbox" id="c-36517316" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516835">parent</a><span>|</span><a href="#36517621">next</a><span>|</span><label class="collapse" for="c-36517316">[-]</label><label class="expand" for="c-36517316">[1 more]</label></div><br/><div class="children"><div class="content">Funny you’re mentioning that exact book. I almost put it as the source in my original comment, but maybe I remember wrong.<p>What I remember is the “deep interfaces” advice, which is great. It encourages small surfaces but deep implementations. Hiding the potentially large list of raisable exceptions helps in keeping an interface or API small. Errors are handled transparently and the user only needs to deal with those they know how to handle. What good is it to raise a deep error that by the time it reaches the top levels (like a web servers middleware loop), it can no longer be handled reasonably and has to be thrown? That’s why, if you can handle it, do so ASAP.<p>That’s what I remember from that book. Again, perhaps I’m misremembering.</div><br/></div></div><div id="36517621" class="c"><input type="checkbox" id="c-36517621" checked=""/><div class="controls bullet"><span class="by">MereInterest</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516835">parent</a><span>|</span><a href="#36517316">prev</a><span>|</span><a href="#36517299">next</a><span>|</span><label class="collapse" for="c-36517621">[-]</label><label class="expand" for="c-36517621">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think the pieces of advice contradict each other.  If exceptions are handled at the lowest scope possible, and exceptions are most useful when the rise above many scopes, then exceptions are most useful when the scope that encounters the error is very deep compared to the scope that can handle the error.<p>This agrees with my intuition, that error codes are most fragile when they must be checked and re-raised across many scopes.</div><br/></div></div><div id="36517299" class="c"><input type="checkbox" id="c-36517299" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516835">parent</a><span>|</span><a href="#36517621">prev</a><span>|</span><a href="#36516793">next</a><span>|</span><label class="collapse" for="c-36517299">[-]</label><label class="expand" for="c-36517299">[1 more]</label></div><br/><div class="children"><div class="content">Note the comment you reply adds &quot;this might be the majority of cases&quot;.<p>There <i>are</i> exceptions that are a normal result of some function call, and they can be handled by the caller.<p>But most exceptions are of the kind that you want to pass to some general error reporting thing far away.</div><br/></div></div></div></div></div></div><div id="36516793" class="c"><input type="checkbox" id="c-36516793" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36516661">parent</a><span>|</span><a href="#36516812">prev</a><span>|</span><a href="#36516356">next</a><span>|</span><label class="collapse" for="c-36516793">[-]</label><label class="expand" for="c-36516793">[3 more]</label></div><br/><div class="children"><div class="content">With Rust &amp; Go style error handling you generally still do bubble up errors and handle them centrally. But you don&#x27;t <i>always</i> want to do that. Sometimes you want to handle errors locally and e.g. retry things, or try something else in case of an error or ignore some errors etc. You also should add context (`raise ConfigParseError() from int_parse_error`) which approximately 0% of people do with exceptions.<p>Handling errors locally is difficult to do with exception handling because it&#x27;s impossible to tell what errors a function might produce (if any!). It&#x27;s also more verbose (especially compared to Rust) which just makes it annoying.<p>Checked exceptions are the usual answer to this but they&#x27;re so tedious most people don&#x27;t bother with them. C++ even dropped support for them from the language.<p>Rust&#x27;s error handling is much better than exceptions in almost every way.</div><br/><div id="36516876" class="c"><input type="checkbox" id="c-36516876" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516793">parent</a><span>|</span><a href="#36516356">next</a><span>|</span><label class="collapse" for="c-36516876">[-]</label><label class="expand" for="c-36516876">[2 more]</label></div><br/><div class="children"><div class="content">Why do you think nobody wraps exceptions? Everyone did in every project in every language I&#x27;ve worked on.<p>Every rest API client library will wrap the http library errors which will wrap network errors.<p>Languages even directly support the notion of keeping a reference to the original exception.<p>If anything, people do it too much.</div><br/><div id="36517021" class="c"><input type="checkbox" id="c-36517021" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#36516661">root</a><span>|</span><a href="#36516876">parent</a><span>|</span><a href="#36516356">next</a><span>|</span><label class="collapse" for="c-36517021">[-]</label><label class="expand" for="c-36517021">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s always that edge case, say &quot;FileReadTimedOut&quot; presented as a UncaughtServerError that no developer ever knew the existence of, let alone thought to wrap it (in, say, the LogoStorage).<p>With Rust this situation is impossible. Unexpected errors are made impossible by the type checker, a dev <i>must</i> handle it. Sure, a dev may say &quot;meh, I&#x27;ll just .into() (or wrap, if you want) any error that file-io gives into NotFound&quot; but she does so knowingly and actively.</div><br/></div></div></div></div></div></div></div></div><div id="36516356" class="c"><input type="checkbox" id="c-36516356" checked=""/><div class="controls bullet"><span class="by">dataking</span><span>|</span><a href="#36516661">prev</a><span>|</span><a href="#36516333">next</a><span>|</span><label class="collapse" for="c-36516356">[-]</label><label class="expand" for="c-36516356">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Unlike in a strongly typed language, the python type annotations aren’t enforced.<p>Python is a strongly typed language but type checks happen at runtime rather than ahead of time [0]. The author is correct that the type annotations aren&#x27;t enforced.<p>[0] <a href="https:&#x2F;&#x2F;wiki.python.org&#x2F;moin&#x2F;Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.python.org&#x2F;moin&#x2F;Why%20is%20Python%20a%20dynamic...</a></div><br/></div></div><div id="36516333" class="c"><input type="checkbox" id="c-36516333" checked=""/><div class="controls bullet"><span class="by">jgilias</span><span>|</span><a href="#36516356">prev</a><span>|</span><a href="#36517554">next</a><span>|</span><label class="collapse" for="c-36516333">[-]</label><label class="expand" for="c-36516333">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Of course, if you’re the sort of person who deals with errors in rust by just slapping ? on anything that might fail, then you’re more or less just doing exceptions<p>Well, no, not really. You typically still explicitly enumerate how your code may fail to use that notation (unless it’s a small utility where you just anyhow it), you also have the fallible values clearly denoted as such, and not everything is fallible. And last, but not least, every time I slap a ‘?’ I tend to quickly evaluate what the failure case is, and if it’s something I can’t do anything about at the moment and should just bubble up, or is it something I can actually handle.<p>So, no, not the same thing as exceptions at all!</div><br/><div id="36516480" class="c"><input type="checkbox" id="c-36516480" checked=""/><div class="controls bullet"><span class="by">Zamiel_Snawley</span><span>|</span><a href="#36516333">parent</a><span>|</span><a href="#36517554">next</a><span>|</span><label class="collapse" for="c-36516480">[-]</label><label class="expand" for="c-36516480">[2 more]</label></div><br/><div class="children"><div class="content">And also, returning errors by value does not introduce hidden control flow!
In python, you have no way of knowing what(if any) exceptions that a function may throw, so unless you catch everything you have no way of knowing where execution will end up after calling a function.<p>Not to mention the intentionally(!) thrown exceptions for iterators. In my book, exceptions are goto by another name.</div><br/><div id="36516856" class="c"><input type="checkbox" id="c-36516856" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#36516333">root</a><span>|</span><a href="#36516480">parent</a><span>|</span><a href="#36517554">next</a><span>|</span><label class="collapse" for="c-36516856">[-]</label><label class="expand" for="c-36516856">[1 more]</label></div><br/><div class="children"><div class="content">Exceptions are goto in disguise to some extent, as it’s forward-jumping only. An important limitation to retain structured programming in this case.</div><br/></div></div></div></div></div></div><div id="36517554" class="c"><input type="checkbox" id="c-36517554" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36516333">prev</a><span>|</span><a href="#36515869">next</a><span>|</span><label class="collapse" for="c-36517554">[-]</label><label class="expand" for="c-36517554">[1 more]</label></div><br/><div class="children"><div class="content">Type hints are an absolute must for me in modern Python, starting with one really simple reason: All the tooling can use them.<p>That means:<p><pre><code>    - The static checker &#x2F; linter
    - My LSP server
    - Documentation Generators
    - Testing frameworks
</code></pre>
All of them can use type hints to work better, or to put this in to words that interest me: <i>make my life easier</i>. Laziness is a programmers virtue. I am lazy. I don&#x27;t want to guess or lookup what type a param has. I want my LSP to yell it at me loudly when calling something. Taking the 1.5 extra seconds to write that type hint, is a minute saved later when using the code.<p>Oh, and to everyone using LLM in their editing environment: They understand type hints as well, and can make good use of them.<p>And for when I am feeling especially lazy: I have a keybind that sends the current code block to the LLM asking it to add type hints and a docstring ;-)</div><br/></div></div><div id="36515869" class="c"><input type="checkbox" id="c-36515869" checked=""/><div class="controls bullet"><span class="by">voz_</span><span>|</span><a href="#36517554">prev</a><span>|</span><a href="#36515970">next</a><span>|</span><label class="collapse" for="c-36515869">[-]</label><label class="expand" for="c-36515869">[5 more]</label></div><br/><div class="children"><div class="content">Type annotations do not rust make. And lack of types does not Python make.<p>As someone who has learned to love both languages as tools for the job, I want to write Python like Python and rust like rust.</div><br/><div id="36515917" class="c"><input type="checkbox" id="c-36515917" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#36515869">parent</a><span>|</span><a href="#36516285">next</a><span>|</span><label class="collapse" for="c-36515917">[-]</label><label class="expand" for="c-36515917">[3 more]</label></div><br/><div class="children"><div class="content">I want to write correct and maintainable code, and techniques like these make that easier for me. I&#x27;ve found that if it&#x27;s hard to type hint my code, there&#x27;s probably a better way to design it.</div><br/><div id="36516147" class="c"><input type="checkbox" id="c-36516147" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#36515869">root</a><span>|</span><a href="#36515917">parent</a><span>|</span><a href="#36515931">next</a><span>|</span><label class="collapse" for="c-36516147">[-]</label><label class="expand" for="c-36516147">[1 more]</label></div><br/><div class="children"><div class="content">Similar to why I like unit-testing. Writing code in a testable way usually straightens out what would have been a thornier first-pass interface. Even if the test never fails, it made me be explicit about my assumptions.</div><br/></div></div><div id="36515931" class="c"><input type="checkbox" id="c-36515931" checked=""/><div class="controls bullet"><span class="by">ddejohn</span><span>|</span><a href="#36515869">root</a><span>|</span><a href="#36515917">parent</a><span>|</span><a href="#36516147">prev</a><span>|</span><a href="#36516285">next</a><span>|</span><label class="collapse" for="c-36515931">[-]</label><label class="expand" for="c-36515931">[1 more]</label></div><br/><div class="children"><div class="content">I find that approaching tasks from the type-first perspective can really help illuminate the problem. I can&#x27;t imagine trying to code without having both types at the forefront of my mind and all of the IDE&#x27;s helpful type-related features.</div><br/></div></div></div></div><div id="36516285" class="c"><input type="checkbox" id="c-36516285" checked=""/><div class="controls bullet"><span class="by">ghnws</span><span>|</span><a href="#36515869">parent</a><span>|</span><a href="#36515917">prev</a><span>|</span><a href="#36515970">next</a><span>|</span><label class="collapse" for="c-36516285">[-]</label><label class="expand" for="c-36516285">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Type annotations do not rust make. And lack of types does not Python make.<p>That is never implied. See the first example in the article.</div><br/></div></div></div></div><div id="36515970" class="c"><input type="checkbox" id="c-36515970" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#36515869">prev</a><span>|</span><a href="#36515775">next</a><span>|</span><label class="collapse" for="c-36515970">[-]</label><label class="expand" for="c-36515970">[3 more]</label></div><br/><div class="children"><div class="content">(2020).<p>Things have arguably become even nicer (although slightly more divergent between the two) since then: Python&#x27;s `Optional[T]` can now be written as `T | None`, and the core container types can now be annotated directly (e.g. `List[T]` becomes `list[T]`).<p>Combined via pyO3[1], Python and Rust are a real joy to write together.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;pyo3">https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;pyo3</a></div><br/><div id="36516845" class="c"><input type="checkbox" id="c-36516845" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#36515970">parent</a><span>|</span><a href="#36516379">next</a><span>|</span><label class="collapse" for="c-36516845">[-]</label><label class="expand" for="c-36516845">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think the new way to write None is an improvement in this case. I use the pipe as a replacement for Union (of which Optional is a special case, but oddly, there is prefer to use Optional; it reads nicely).</div><br/></div></div><div id="36516379" class="c"><input type="checkbox" id="c-36516379" checked=""/><div class="controls bullet"><span class="by">tayo42</span><span>|</span><a href="#36515970">parent</a><span>|</span><a href="#36516845">prev</a><span>|</span><a href="#36515775">next</a><span>|</span><label class="collapse" for="c-36516379">[-]</label><label class="expand" for="c-36516379">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t notice the date, I was confused about the comment about pattern matching</div><br/></div></div></div></div><div id="36515775" class="c"><input type="checkbox" id="c-36515775" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#36515970">prev</a><span>|</span><a href="#36516118">next</a><span>|</span><label class="collapse" for="c-36515775">[-]</label><label class="expand" for="c-36515775">[18 more]</label></div><br/><div class="children"><div class="content">While I respect people that prefer programming without explicit types, I can’t understand it.</div><br/><div id="36516148" class="c"><input type="checkbox" id="c-36516148" checked=""/><div class="controls bullet"><span class="by">impulser_</span><span>|</span><a href="#36515775">parent</a><span>|</span><a href="#36516954">next</a><span>|</span><label class="collapse" for="c-36516148">[-]</label><label class="expand" for="c-36516148">[2 more]</label></div><br/><div class="children"><div class="content">I use to think the same, then I tried Elixir. It made me realize the language ecosystem can outweigh cons as big as not having types.<p>The Elixir ecosystem is top notch. Phoenix, Ecto, Livebook, Mix, Hex, Nx, Axon, Scholar, Explorer, Broadway, and Rustler are libraries and tools that make it hard to use anything else even when the language doesn&#x27;t have types. I never enjoyed programming in a language more than Elixir.<p>Tho, they are currently are in the process of researching a type system for Elixir.</div><br/><div id="36517699" class="c"><input type="checkbox" id="c-36517699" checked=""/><div class="controls bullet"><span class="by">s6ro</span><span>|</span><a href="#36515775">root</a><span>|</span><a href="#36516148">parent</a><span>|</span><a href="#36516954">next</a><span>|</span><label class="collapse" for="c-36517699">[-]</label><label class="expand" for="c-36517699">[1 more]</label></div><br/><div class="children"><div class="content">Elixir is functional and immutable first, (and structs) - that alleviates somewhat the pain of not having a strong type system. I really like the architecture of OTP, but I still find myself using Elixir in anger.<p>Especially, if I&#x27;m trying to bring and old(er) codebase (Elixir 1.9) up to the newest release... and upgrading packages, checking if things are likely to brake etc.<p>I constantly find myself realising that I cannot trust the compiler, which means more defensive coding, more tests, more time spent...<p>As an example, upgraded postgrex. The return tuple of one its functions had changed from 2 elements to 3 elements. Did the compiler caught it? No.
Had I had dialyzer type spec-s on my private function, I would at least gotten a warning. Thus, morale of the story: always type spec even your private functions , especially if they use 3rd party code.</div><br/></div></div></div></div><div id="36516954" class="c"><input type="checkbox" id="c-36516954" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#36515775">parent</a><span>|</span><a href="#36516148">prev</a><span>|</span><a href="#36516351">next</a><span>|</span><label class="collapse" for="c-36516954">[-]</label><label class="expand" for="c-36516954">[1 more]</label></div><br/><div class="children"><div class="content">Types replace some tests and introduce a lot of ceremony.
If this a worthwhile tradeoff depends.<p>E.g. I wrote c# and Python for a living. Especially in the mid 2010s python was much better for the Microservices I wrote because they are so small that you could unit test them exhaustively. The lack of ceremony and small domain model made development super easy. C# just felt clunky and limiting. You spend lots of time wrangling types which could have been figured out by the compiler.<p>Nowadays c# has gotten a lot of features that reduce type ceremony and extend their usefulness (nuallibility checks, better tuples etc)  so it feels much more ergonomic (unlike java where the culture still goes off on needless verbosity) . Python also got types which I use a lot, it helps to document it for other developers, ides and spot bugs.</div><br/></div></div><div id="36516351" class="c"><input type="checkbox" id="c-36516351" checked=""/><div class="controls bullet"><span class="by">neilwilson</span><span>|</span><a href="#36515775">parent</a><span>|</span><a href="#36516954">prev</a><span>|</span><a href="#36516044">next</a><span>|</span><label class="collapse" for="c-36516351">[-]</label><label class="expand" for="c-36516351">[2 more]</label></div><br/><div class="children"><div class="content">Types are really just a way of applying certain tests to part of your code.<p>In dynamic languages the typing is just moved to the test suite. We can see that with the way type hints are enforced in Python and Ruby - by running a program that takes those hints and essentially runs a bunch of tests.<p>If you look at the code of Terraform, for example, you&#x27;ll see that it spends a lot of time trying to get around the limitations of Go typing.<p>The rise of dynamic languages in the early 2000s was a direct result of the perceived limitations of the type systems of Java, C++, etc. and the ability to use a different way of constraining code (Test driven development, behaviour driven development).<p>Now it is swinging back the other way with the implementation of more flexible type systems.<p>Before too long the limitations of those type systems will start to grate and the pendulum will swing back to dynamic languages again - based upon some new innovations there.<p>Get used to the back and forth in IT. The static&#x2F;dynamic cycle is but one of many. (Centralisation&#x2F;decentralisation is the other main one). You&#x27;ll find lots of work in IT is reimplementing existing stuff in the current fashionable paradigm.</div><br/><div id="36516928" class="c"><input type="checkbox" id="c-36516928" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#36515775">root</a><span>|</span><a href="#36516351">parent</a><span>|</span><a href="#36516044">next</a><span>|</span><label class="collapse" for="c-36516928">[-]</label><label class="expand" for="c-36516928">[1 more]</label></div><br/><div class="children"><div class="content">No modern type systems are powerful and flexible enough that I don&#x27;t believe the pendulum will swing back toward dynamic languages, at least to the same degree. Especially with dependent typing becoming more of a thing.<p>Then again perhaps LLM programming will become the new thing. ;)</div><br/></div></div></div></div><div id="36516044" class="c"><input type="checkbox" id="c-36516044" checked=""/><div class="controls bullet"><span class="by">winstonewert</span><span>|</span><a href="#36515775">parent</a><span>|</span><a href="#36516351">prev</a><span>|</span><a href="#36516188">next</a><span>|</span><label class="collapse" for="c-36516044">[-]</label><label class="expand" for="c-36516044">[1 more]</label></div><br/><div class="children"><div class="content">I can make two observations that explain some of it.<p>Other aspects of a language can matter more than the types. Python, for example, was a well constructed language in many ways that make up for much of its disadvantage on the typing side.<p>Many commonly used statically typed languages have poor type systems. They will both fail to detect some important errors (like null pointers) and get in the way when writing more generic code.</div><br/></div></div><div id="36516188" class="c"><input type="checkbox" id="c-36516188" checked=""/><div class="controls bullet"><span class="by">dbrueck</span><span>|</span><a href="#36515775">parent</a><span>|</span><a href="#36516044">prev</a><span>|</span><a href="#36515819">next</a><span>|</span><label class="collapse" for="c-36516188">[-]</label><label class="expand" for="c-36516188">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m one of those people. :) Well, it&#x27;s not so much that I <i>prefer</i> no explicit types, I just dislike how most languages require you to specify them, and to do so at the least opportune time, so I end up preferring languages that don&#x27;t require them at all. (Ideally, the language would let you start with none and then layer them in as the design gels.)<p>FWIW, there are definitely ways to do it &quot;right&quot; in languages like Python, but it&#x27;s a slightly different approach to dev than in other languages, so people create a mess if they don&#x27;t shift, or if they are just untrained&#x2F;sloppy&#x2F;lazy&#x2F;whatever. But when you have a team of people doing it right, it&#x27;s really quite nice, even as the codebase grows large.<p>But if even just <i>one</i> person on the team can&#x27;t be trusted to do it that way, you&#x27;re probably better off in some other language.</div><br/></div></div><div id="36515819" class="c"><input type="checkbox" id="c-36515819" checked=""/><div class="controls bullet"><span class="by">tnecniv</span><span>|</span><a href="#36515775">parent</a><span>|</span><a href="#36516188">prev</a><span>|</span><a href="#36515906">next</a><span>|</span><label class="collapse" for="c-36515819">[-]</label><label class="expand" for="c-36515819">[6 more]</label></div><br/><div class="children"><div class="content">This was something that was in vogue in the mid &#x2F; late 2000s, then Haskell became the cool kid language and types are back.<p>The thing that drives me crazy about Python typing is that I need to import stuff to make full use of the type system. Like I get that the typing is option because that would be a huge language overhaul, but it feels weird that so many tools get hidden inside libraries (standing or otherwise).</div><br/><div id="36516151" class="c"><input type="checkbox" id="c-36516151" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#36515775">root</a><span>|</span><a href="#36515819">parent</a><span>|</span><a href="#36515995">prev</a><span>|</span><a href="#36515906">next</a><span>|</span><label class="collapse" for="c-36516151">[-]</label><label class="expand" for="c-36516151">[4 more]</label></div><br/><div class="children"><div class="content">AFAIK, you only need to import the actual types that you&#x27;re using (`from typing import List, Iterable, Optional, ...`). What else is there?</div><br/><div id="36516248" class="c"><input type="checkbox" id="c-36516248" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#36515775">root</a><span>|</span><a href="#36516151">parent</a><span>|</span><a href="#36516419">next</a><span>|</span><label class="collapse" for="c-36516248">[-]</label><label class="expand" for="c-36516248">[1 more]</label></div><br/><div class="children"><div class="content">In newer Python versions, you don&#x27;t need most of those imports  either:<p><pre><code>  foo: list[str] = [&quot;a&quot;]
  bar: int | None = 1</code></pre></div><br/></div></div><div id="36516419" class="c"><input type="checkbox" id="c-36516419" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#36515775">root</a><span>|</span><a href="#36516151">parent</a><span>|</span><a href="#36516248">prev</a><span>|</span><a href="#36516398">next</a><span>|</span><label class="collapse" for="c-36516419">[-]</label><label class="expand" for="c-36516419">[1 more]</label></div><br/><div class="children"><div class="content">But why do we have to import any? They should be part of the core language by now. The lack of boldness of Python core developers is sometimes very annoying.</div><br/></div></div><div id="36516398" class="c"><input type="checkbox" id="c-36516398" checked=""/><div class="controls bullet"><span class="by">saulpw</span><span>|</span><a href="#36515775">root</a><span>|</span><a href="#36516151">parent</a><span>|</span><a href="#36516419">prev</a><span>|</span><a href="#36515906">next</a><span>|</span><label class="collapse" for="c-36516398">[-]</label><label class="expand" for="c-36516398">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but that&#x27;s completely unnecessary friction.</div><br/></div></div></div></div></div></div><div id="36515906" class="c"><input type="checkbox" id="c-36515906" checked=""/><div class="controls bullet"><span class="by">ShamelessC</span><span>|</span><a href="#36515775">parent</a><span>|</span><a href="#36515819">prev</a><span>|</span><a href="#36516257">next</a><span>|</span><label class="collapse" for="c-36515906">[-]</label><label class="expand" for="c-36515906">[1 more]</label></div><br/><div class="children"><div class="content">Many programmers don&#x27;t get a choice in the language they have to use. Or they don&#x27;t get a choice in the language they learn first. In either case, it is best to steel-man the case for the language you&#x27;re using at any given time. Ideally, you should do this once for a language with explicit types (e.g. C++&#x2F;Rust), once for a language with dynamic&#x2F;implicit types (e.g. JS, Python3) and maybe once for a gradual typing system like TypeScript.<p>Then you can appreciate which tool to use and when, rather than getting distracted by strange religious notions about how &quot;this language is better than that one&quot;. It also prevents you from forcing conventions the language doesn&#x27;t align well with, and that if you&#x27;re going to _try_ to do so - you should do so gradually and very carefully.</div><br/></div></div><div id="36516257" class="c"><input type="checkbox" id="c-36516257" checked=""/><div class="controls bullet"><span class="by">irrational</span><span>|</span><a href="#36515775">parent</a><span>|</span><a href="#36515906">prev</a><span>|</span><a href="#36516118">next</a><span>|</span><label class="collapse" for="c-36516257">[-]</label><label class="expand" for="c-36516257">[3 more]</label></div><br/><div class="children"><div class="content">For me it is that I learned to program in dynamically typed languages and have used them for decades. I am interested in using types, but it is not enforced at my work, I am not given time to learn how to use them at work, and I’m too busy at home to learn it on my own.</div><br/><div id="36516443" class="c"><input type="checkbox" id="c-36516443" checked=""/><div class="controls bullet"><span class="by">dsQTbR7Y5mRHnZv</span><span>|</span><a href="#36515775">root</a><span>|</span><a href="#36516257">parent</a><span>|</span><a href="#36516118">next</a><span>|</span><label class="collapse" for="c-36516443">[-]</label><label class="expand" for="c-36516443">[2 more]</label></div><br/><div class="children"><div class="content">I find it helps to think about it like this:<p>Whether you specify them or not, the data moving around your application _has_ types.<p>Strings, ints, booleans - they&#x27;re all there. You&#x27;re just keeping that information in your head while you work.<p>By writing them in the code, you&#x27;re simply offloading all of that and saying &quot;I trust the computer to validate this better than I can.&quot; Which is exactly the kind of thing we should be trusting computers to do. They won&#x27;t forget what type something is 5 function calls deep and they won&#x27;t get tired from lack of sleep.<p>I know I prefer having the computer tell me I made a mistake while I&#x27;m developing something rather than a user emailing me after I&#x27;ve shipped it.</div><br/><div id="36516789" class="c"><input type="checkbox" id="c-36516789" checked=""/><div class="controls bullet"><span class="by">irrational</span><span>|</span><a href="#36515775">root</a><span>|</span><a href="#36516443">parent</a><span>|</span><a href="#36516118">next</a><span>|</span><label class="collapse" for="c-36516789">[-]</label><label class="expand" for="c-36516789">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I just have no idea how to write them, what the syntax is, where to write them, etc. Since my work doesn’t care to give me time to find out, and I don’t have time to do it on my own, it isn’t going to happen until it becomes a priority at work.</div><br/></div></div></div></div></div></div></div></div><div id="36516118" class="c"><input type="checkbox" id="c-36516118" checked=""/><div class="controls bullet"><span class="by">oldelpaso66</span><span>|</span><a href="#36515775">prev</a><span>|</span><a href="#36516009">next</a><span>|</span><label class="collapse" for="c-36516118">[-]</label><label class="expand" for="c-36516118">[1 more]</label></div><br/><div class="children"><div class="content">There was another one of these posts floating around recently <a href="https:&#x2F;&#x2F;kobzol.github.io&#x2F;rust&#x2F;python&#x2F;2023&#x2F;05&#x2F;20&#x2F;writing-python-like-its-rust.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;kobzol.github.io&#x2F;rust&#x2F;python&#x2F;2023&#x2F;05&#x2F;20&#x2F;writing-pyth...</a><p>My personal experience is that while this would be a really good way of getting people to write quality Python code, a lot of python users (data scientists) are not software engineers and don&#x27;t have the discipline to do this without very strict PR reviews</div><br/></div></div><div id="36516009" class="c"><input type="checkbox" id="c-36516009" checked=""/><div class="controls bullet"><span class="by">andrewqu</span><span>|</span><a href="#36516118">prev</a><span>|</span><a href="#36516215">next</a><span>|</span><label class="collapse" for="c-36516009">[-]</label><label class="expand" for="c-36516009">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d rather write rust like python</div><br/><div id="36516221" class="c"><input type="checkbox" id="c-36516221" checked=""/><div class="controls bullet"><span class="by">jasfi</span><span>|</span><a href="#36516009">parent</a><span>|</span><a href="#36516197">next</a><span>|</span><label class="collapse" for="c-36516221">[-]</label><label class="expand" for="c-36516221">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like Nim.</div><br/></div></div><div id="36516197" class="c"><input type="checkbox" id="c-36516197" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#36516009">parent</a><span>|</span><a href="#36516221">prev</a><span>|</span><a href="#36516215">next</a><span>|</span><label class="collapse" for="c-36516197">[-]</label><label class="expand" for="c-36516197">[1 more]</label></div><br/><div class="children"><div class="content">Im hoping Mojo supports essentially that.</div><br/></div></div></div></div><div id="36516215" class="c"><input type="checkbox" id="c-36516215" checked=""/><div class="controls bullet"><span class="by">guggle</span><span>|</span><a href="#36516009">prev</a><span>|</span><a href="#36517132">next</a><span>|</span><label class="collapse" for="c-36516215">[-]</label><label class="expand" for="c-36516215">[1 more]</label></div><br/><div class="children"><div class="content">Convincing my colleagues to use type hints in Python has been very easy. The benefits are obvious and immediate. To the point where I wonder why there was even a time when it was acceptable not to have them.</div><br/></div></div><div id="36517132" class="c"><input type="checkbox" id="c-36517132" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#36516215">prev</a><span>|</span><a href="#36516295">next</a><span>|</span><label class="collapse" for="c-36517132">[-]</label><label class="expand" for="c-36517132">[1 more]</label></div><br/><div class="children"><div class="content">Very similar article a month ago: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36018621">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36018621</a></div><br/></div></div><div id="36516295" class="c"><input type="checkbox" id="c-36516295" checked=""/><div class="controls bullet"><span class="by">d--b</span><span>|</span><a href="#36517132">prev</a><span>|</span><label class="collapse" for="c-36516295">[-]</label><label class="expand" for="c-36516295">[3 more]</label></div><br/><div class="children"><div class="content">&gt; At this point, you’re maybe wondering why we didn’t just write the project in Rust?<p>Err, aren’t Python and Rust designed to write completely different kinds of programs?<p>Python =&gt; scripting, data stuff, unsafe and slow,  quick’n’dirty PoCs<p>Rust =&gt; compiled, system stuff, robust and fast, production work.<p>If the author is balancing the 2, they probably should have used C# !</div><br/><div id="36516502" class="c"><input type="checkbox" id="c-36516502" checked=""/><div class="controls bullet"><span class="by">jug6ernaut</span><span>|</span><a href="#36516295">parent</a><span>|</span><label class="collapse" for="c-36516502">[-]</label><label class="expand" for="c-36516502">[2 more]</label></div><br/><div class="children"><div class="content">Designed with different goals absolutely, they have very different use cases that they individually accel at.<p>This however does not stop people from trying to use their one preferred language fer beyond it&#x27;s focus area.<p>IMO one of the major turning points in a developers career is when they learn that finding the right tool for the problem is always the game you are playing. But this almost always takes learning this lesson the hard way by pushing a language one know very well past its breakpoint.</div><br/><div id="36517104" class="c"><input type="checkbox" id="c-36517104" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#36516295">root</a><span>|</span><a href="#36516502">parent</a><span>|</span><label class="collapse" for="c-36517104">[-]</label><label class="expand" for="c-36517104">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m there. I write Ruby, JavaScript, Python, Java, Bash, and Rust for work.<p>Rust is surprisingly good at many tasks I would otherwise pick &quot;the proper&quot; tool for. A web service, a quick frontend in wasm (leptos), a hackish commandline tool, or, indeed, that low-level&#x2F;embedded thing that Rust was &quot;meant&quot; for.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>