<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694768464907" as="style"/><link rel="stylesheet" href="styles.css?v=1694768464907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.separateconcerns.com/2023-09-11-linear-code.html">Linear code is more readable</a> <span class="domain">(<a href="https://blog.separateconcerns.com">blog.separateconcerns.com</a>)</span></div><div class="subtext"><span>dmarto</span> | <span>135 comments</span></div><br/><div><div id="37520297" class="c"><input type="checkbox" id="c-37520297" checked=""/><div class="controls bullet"><span class="by">bcoughlan</span><span>|</span><a href="#37518965">next</a><span>|</span><label class="collapse" for="c-37520297">[-]</label><label class="expand" for="c-37520297">[1 more]</label></div><br/><div class="children"><div class="content">This was always my interpretation of &quot;Flat is better than nested.&quot; from &quot;The Zen of Python&quot;.<p>I often run into conflict with developers who believe in the single return statement. This is flatter but irks a lot of devs:<p>```
if (!condition) {
  return
}<p>more code<p>return
```</div><br/></div></div><div id="37518965" class="c"><input type="checkbox" id="c-37518965" checked=""/><div class="controls bullet"><span class="by">theptip</span><span>|</span><a href="#37520297">prev</a><span>|</span><a href="#37517831">next</a><span>|</span><label class="collapse" for="c-37518965">[-]</label><label class="expand" for="c-37518965">[20 more]</label></div><br/><div class="children"><div class="content">It’s a matter of style, and like cooking, either too much or too little salt will ruin a dish.<p>In this case I hope nobody is proposing a single 1000-line god function. Nor is a maximum of 5 lines per function going to read well. So where do we split things?<p>This requires judgment, and yes, good taste. Also iteration. Just because the first place you tried to carve an abstraction didn’t work well, doesn’t mean you give up on abstractions; after refactoring a few times you’ll get an API that makes sense, hopefully with classes that match the business domain clearly.<p>But at the same time, don’t be over-eager to abstract, or mortally offended by a few lines of duplication. Premature abstraction often ends up coupling code that should not have to evolve together.<p>As a stylistic device, extracting a function which will only be called in one place to abstract away a unit of work can really clean up an algorithm; especially if you can hide boilerplate or prevent mixing of infra and domain concerns like business logic and DB connection handling. But again I’d recommend using this judiciously, and avoiding breaking up steps that should really be at the same level of abstraction.</div><br/><div id="37519286" class="c"><input type="checkbox" id="c-37519286" checked=""/><div class="controls bullet"><span class="by">ncann</span><span>|</span><a href="#37518965">parent</a><span>|</span><a href="#37519762">next</a><span>|</span><label class="collapse" for="c-37519286">[-]</label><label class="expand" for="c-37519286">[5 more]</label></div><br/><div class="children"><div class="content">&gt; In this case I hope nobody is proposing a single 1000-line god function. Nor is a maximum of 5 lines per function going to read well.<p>This is the key. Novice devs tend to write giant functions. Zealot devs who read books like Clean Code for the first time tend to split things to a million functions, each one a few lines long (pretty sure the book itself says no more than 5 lines for each function). I worked with a guy who extracted each and every boolean condition to a function because &quot;it&#x27;s easier to read&quot;, while never writing any comments because &quot;comments are bad&quot; (according to the book). I hate that book, it creates these zealots that mindlessly follow its bad advices.</div><br/><div id="37519455" class="c"><input type="checkbox" id="c-37519455" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519286">parent</a><span>|</span><a href="#37519804">next</a><span>|</span><label class="collapse" for="c-37519455">[-]</label><label class="expand" for="c-37519455">[1 more]</label></div><br/><div class="children"><div class="content">The problem with any good idea: As soon as it becomes dogma, it doesn&#x27;t matter how good the original idea was, it will turn itself bad.</div><br/></div></div><div id="37519804" class="c"><input type="checkbox" id="c-37519804" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519286">parent</a><span>|</span><a href="#37519455">prev</a><span>|</span><a href="#37519434">next</a><span>|</span><label class="collapse" for="c-37519804">[-]</label><label class="expand" for="c-37519804">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I worked with a guy who extracted each and every boolean condition to a function because &quot;it&#x27;s easier to read&quot;<p>Obviously, readability is important, but I&#x27;ve also seen things like this so often in my career where it&#x27;s used as an excuse for anything. Most recently, trying to stop a teammate turning nearly every class into a singleton for the sake of &quot;simplicity&quot; and &quot;readability&quot;, which I thought was a real stretch.</div><br/></div></div><div id="37519434" class="c"><input type="checkbox" id="c-37519434" checked=""/><div class="controls bullet"><span class="by">livrem</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519286">parent</a><span>|</span><a href="#37519804">prev</a><span>|</span><a href="#37519762">next</a><span>|</span><label class="collapse" for="c-37519434">[-]</label><label class="expand" for="c-37519434">[2 more]</label></div><br/><div class="children"><div class="content">Clean Code says &quot;Functions should not be 100 lines long. Functions should hardly ever be 20 lines long&quot;.<p>I think both 100 and 20 are a bit low, but much better than 5. As I mentioned in a comment a few days ago when I also corrected someone that misremembered a detail from the book, I am not a huge fan. But I also think it is mostly correct about most things, and not as terribly bad as some say. Listening to fans of the book is more annoying than to actually read the book.<p>(And that other comment when I corrected someone was about bad comments. Clean Code definitely does not say that you shall never comment anything.)</div><br/><div id="37519865" class="c"><input type="checkbox" id="c-37519865" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519434">parent</a><span>|</span><a href="#37519762">next</a><span>|</span><label class="collapse" for="c-37519865">[-]</label><label class="expand" for="c-37519865">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not from Clean Code, but Refactoring.</div><br/></div></div></div></div></div></div><div id="37519762" class="c"><input type="checkbox" id="c-37519762" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37518965">parent</a><span>|</span><a href="#37519286">prev</a><span>|</span><a href="#37519377">next</a><span>|</span><label class="collapse" for="c-37519762">[-]</label><label class="expand" for="c-37519762">[2 more]</label></div><br/><div class="children"><div class="content">&gt;<i>In this case I hope nobody is proposing a single 1000-line god function.</i><p>Why not? Who said it&#x27;s worse? What study settles the issue?<p>Some times a &quot;1000-line god function&quot; is just what the domain needs, and can be way more readable, with the logic and operations consolidated, than 20 50 line functions, that you still have to read to understand the whole thing (and which then someone will be tempted to reuse a few, adjust them for 2-3 different needs not had by your original operation, and tie parts of the functions implementing your specific logic to irrelevant to it use cases).<p>And if it&#x27;s a pure 1000-line function, it could even be 10,000 lines for all I care, and it would still be fine.</div><br/><div id="37520103" class="c"><input type="checkbox" id="c-37520103" checked=""/><div class="controls bullet"><span class="by">visarga</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519762">parent</a><span>|</span><a href="#37519377">next</a><span>|</span><label class="collapse" for="c-37520103">[-]</label><label class="expand" for="c-37520103">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, when code gets spread out across too many classes and functions, it&#x27;s like you&#x27;re trying to navigate a maze without a map. You hit a breakpoint, and you&#x27;re left scratching your head, trying to figure out what the heck each class is supposed to do. Names can be deceptive, and before you know it, the whole architecture feels like a jigsaw puzzle. It&#x27;s a cognitive load, having to keep track of all these quirks. Maybe it was easier for the author to do it that way when they started from scratch, but after they finished, it&#x27;s another deal.</div><br/></div></div></div></div><div id="37519377" class="c"><input type="checkbox" id="c-37519377" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#37518965">parent</a><span>|</span><a href="#37519762">prev</a><span>|</span><a href="#37519282">next</a><span>|</span><label class="collapse" for="c-37519377">[-]</label><label class="expand" for="c-37519377">[9 more]</label></div><br/><div class="children"><div class="content">&gt; In this case I hope nobody is proposing a single 1000-line god function.<p>I’ll take well-structured 1000-lines function over bad spaghetti of hundreds small functions any day.</div><br/><div id="37519850" class="c"><input type="checkbox" id="c-37519850" checked=""/><div class="controls bullet"><span class="by">npteljes</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519377">parent</a><span>|</span><a href="#37519582">next</a><span>|</span><label class="collapse" for="c-37519850">[-]</label><label class="expand" for="c-37519850">[2 more]</label></div><br/><div class="children"><div class="content">Going further, I&#x27;ll take a 1000-line shitty code, over split-to-small-functions shitty code. In the long code, all I have to think about is the code. With the functions, I have to pay attention to what calls what, also also because the code is shitty, surely the function names also are, adding two things at the same time to the confusion mix.</div><br/><div id="37520276" class="c"><input type="checkbox" id="c-37520276" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519850">parent</a><span>|</span><a href="#37519582">next</a><span>|</span><label class="collapse" for="c-37520276">[-]</label><label class="expand" for="c-37520276">[1 more]</label></div><br/><div class="children"><div class="content">Even better instead of a interrupt driven state machine implemented as a switch statement that linearly progresses. Do it using 20-25 small chained callbacks spread over a couple of files.<p>Bonus: Uncle Bob teaches us not to use comments.</div><br/></div></div></div></div><div id="37519582" class="c"><input type="checkbox" id="c-37519582" checked=""/><div class="controls bullet"><span class="by">leoedin</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519377">parent</a><span>|</span><a href="#37519850">prev</a><span>|</span><a href="#37519282">next</a><span>|</span><label class="collapse" for="c-37519582">[-]</label><label class="expand" for="c-37519582">[6 more]</label></div><br/><div class="children"><div class="content">Have you ever seen a well structured 1000 line function?<p>I&#x27;m sure they exist - maybe some sort of exceedingly complicated data transform or something. But in almost every situation I&#x27;ve seen, a 1000 line function has countless side effects, probably sets a few globals, takes loads of poorly named arguments, each of which is a nested data structure which it reaches deeply into and often has the same for loop copied and pasted 10 times with one character changed.<p>Often a 1000 line function is actually 5 or 6 20 line functions. I&#x27;m sure there are legitimate exceptions, but I&#x27;ve never seen them.</div><br/><div id="37519717" class="c"><input type="checkbox" id="c-37519717" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519582">parent</a><span>|</span><a href="#37519646">next</a><span>|</span><label class="collapse" for="c-37519717">[-]</label><label class="expand" for="c-37519717">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;putty&#x2F;blob&#x2F;master&#x2F;terminal.c#L3281">https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;putty&#x2F;blob&#x2F;master&#x2F;terminal.c#L3281</a><p>This function is 1830 lines long. It&#x27;s reasonably well structured I think. Although the #if 0 are maybe not so good.</div><br/><div id="37520238" class="c"><input type="checkbox" id="c-37520238" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519717">parent</a><span>|</span><a href="#37519822">next</a><span>|</span><label class="collapse" for="c-37520238">[-]</label><label class="expand" for="c-37520238">[1 more]</label></div><br/><div class="children"><div class="content">Oh my God. The sneaky `else` at line 3400.<p>edit: another one at 3826 with a preprocessor define interleaved.</div><br/></div></div><div id="37519822" class="c"><input type="checkbox" id="c-37519822" checked=""/><div class="controls bullet"><span class="by">mattlondon</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519717">parent</a><span>|</span><a href="#37520238">prev</a><span>|</span><a href="#37520094">next</a><span>|</span><label class="collapse" for="c-37519822">[-]</label><label class="expand" for="c-37519822">[1 more]</label></div><br/><div class="children"><div class="content">A lot of those if-&#x2F;case-blocks are precisely where I&#x27;d put functions :)<p>If you changed a bunch of those to separate, pure (i.e. side-effect-free) functions it would if nothing else make unit testing a breeze, and then you&#x27;d be free to fix bugs in the logic without fear.  As it is, if I had a bug in that huge function I&#x27;d be really worried about breaking some edge-condition or implied-state 500 lines up etc.</div><br/></div></div><div id="37520094" class="c"><input type="checkbox" id="c-37520094" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519717">parent</a><span>|</span><a href="#37519822">prev</a><span>|</span><a href="#37519646">next</a><span>|</span><label class="collapse" for="c-37520094">[-]</label><label class="expand" for="c-37520094">[1 more]</label></div><br/><div class="children"><div class="content">Well that&#x27;s horrendous. Sorry, Simon. Each of those big &quot;switch&quot; statements should be broken out.</div><br/></div></div></div></div><div id="37519646" class="c"><input type="checkbox" id="c-37519646" checked=""/><div class="controls bullet"><span class="by">deelly</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519582">parent</a><span>|</span><a href="#37519717">prev</a><span>|</span><a href="#37519282">next</a><span>|</span><label class="collapse" for="c-37519646">[-]</label><label class="expand" for="c-37519646">[1 more]</label></div><br/><div class="children"><div class="content">I`m not OP, but yes, I saw.<p>Thats my personal opinion, and nothing more:<p>Something like complex one time financial&#x2F;workflow&#x2F;maintenance operation that includes calling dozens of different smaller functions, but very well structured.<p>It does not make sense to separate it more into different functions, because execution is generally linear and having to deal with tree of calls where some calls is depends on state of the previous is become cumbersome and makes reading and making changes more complex.<p>Again, thats my personal feeling, and nothing more.</div><br/></div></div></div></div></div></div><div id="37519282" class="c"><input type="checkbox" id="c-37519282" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#37518965">parent</a><span>|</span><a href="#37519377">prev</a><span>|</span><a href="#37519493">next</a><span>|</span><label class="collapse" for="c-37519282">[-]</label><label class="expand" for="c-37519282">[1 more]</label></div><br/><div class="children"><div class="content">If we go with the cooking analogy, if you have to describe to someone how to cook a meal, and at one part of the meal you have to put the fond in, it is reasonable to explain how to make the fond in a seperate section. The fond is it&#x27;s own thing and it has one touching point with the food,therefore it is okay (or even benefitial) to move it out.<p>Also: cooking recipes are also very abstracted. When they say you need to lightly fry onions they assume you know a way to cut onions and a lightly frying algorithm already. If they would inline everything it would become unreadable.<p>Code is very similar. If you want it strictly without abstractions it will be as low level as your language allows you, and that is definitely not readable code.<p>If you e.g. instead of using pythons &quot;decode&quot; method tries to do unicode decoding yourself it would become very hard to understand what your program is actually about. Now there are probably zero people who would do that, because the language provides a simple and well tested abstraction — but what makes that different from you creating your own  simple and well tested abstraction and using that throughout the actual business logic of your code?<p>The hard part is creating abstractions that are so well chosen that nobody will have to ever touch them again.</div><br/></div></div><div id="37519493" class="c"><input type="checkbox" id="c-37519493" checked=""/><div class="controls bullet"><span class="by">dsego</span><span>|</span><a href="#37518965">parent</a><span>|</span><a href="#37519282">prev</a><span>|</span><a href="#37517831">next</a><span>|</span><label class="collapse" for="c-37519493">[-]</label><label class="expand" for="c-37519493">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Also iteration. Just because the first place you tried to carve an abstraction didn’t work well, doesn’t mean you give up on abstractions;<p>C. Muratori calls this method &quot;semantic compression&quot; .
<a href="https:&#x2F;&#x2F;caseymuratori.com&#x2F;blog_0015" rel="nofollow noreferrer">https:&#x2F;&#x2F;caseymuratori.com&#x2F;blog_0015</a></div><br/><div id="37519700" class="c"><input type="checkbox" id="c-37519700" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#37518965">root</a><span>|</span><a href="#37519493">parent</a><span>|</span><a href="#37517831">next</a><span>|</span><label class="collapse" for="c-37519700">[-]</label><label class="expand" for="c-37519700">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s described there is what I understand DRY (&quot;don&#x27;t repeat yourself&quot;) and the associated &quot;rule of three&quot; to mean.</div><br/></div></div></div></div></div></div><div id="37517831" class="c"><input type="checkbox" id="c-37517831" checked=""/><div class="controls bullet"><span class="by">bsuvc</span><span>|</span><a href="#37518965">prev</a><span>|</span><a href="#37518330">next</a><span>|</span><label class="collapse" for="c-37517831">[-]</label><label class="expand" for="c-37517831">[53 more]</label></div><br/><div class="children"><div class="content">The example code is vey simplistic, so of course <i>that</i> linear code is more readable, but the idea doesn’t scale.<p>I think you have to consider things like reusability and unit-test-ability as well, and having all your code in a single function can make reasoning about it more difficult due to all the local variables in scope that you need to consider as possibly (maybe or maybe not) relevant to the block of code you’re reading.<p>That being said, when I look back on my younger, less experienced days, I often fell into the trap of over-refactoring perfectly fine linear code into something more modular, yet less maintainable due to all the jumping around.  There is something to be said for leaving the code as you initially wrote it, because it is closer to how your mind was thinking at the time, and how a readers mind will also probably be interpreting the code as well.  When you over-refactor, that can be lost.<p>So I guess in summary, this is one of those “programming is a craft” things, where experience helps you determine what is right in a situation.</div><br/><div id="37518036" class="c"><input type="checkbox" id="c-37518036" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#37517831">parent</a><span>|</span><a href="#37517959">next</a><span>|</span><label class="collapse" for="c-37518036">[-]</label><label class="expand" for="c-37518036">[36 more]</label></div><br/><div class="children"><div class="content">&gt; The example code is vey simplistic, so of course that linear code is more readable, but the idea doesn’t scale.<p>One of the best reviewed functions I wrote at work is a 2000 line monster with 9 separate variable scopes (stages) written in a linear style. It had one purpose and one purpose only. It was supposed to convert from some individual html pages used in one corner of our app on one platform into a carousell that faked the native feel of another platform. We only needed that in one place and the whole process was incredibly specific to that platform and that corner of the app.<p>You could argue that every one of those 9 scopes could be a separate function, but then devs would be tempted to reuse them. Yet, each step had subtle assumptions about what happened before. The moment we would have spent effort to make them distinct functions we would have had to recheck our assumptions, generalize, verify that methods work on their own... For code that&#x27;s barely ever needed elsewhere. We even had some code that was similar to some of the middle parta of the process... But just slightly didn&#x27;t fit here. Changing that code caused other aspects of our software to fail.<p>The method was not any less debuggable, it still had end to end tests, none of the intermediate steps leaked state outside of the function. In fact 2 other devs contributed fixes over time. It worked really well. Not to mention that it was fast to write.<p>Linear code scales well and solves problems. You don&#x27;t always want that but it sure as hell makes life easier in more contexts than you&#x27;d expect.<p>Note. Initial reactions to the 2000 line monster were not positive. But, spend 5 minutes with the function, and yeah... You couldn&#x27;t really find practical flaws, just fears that didn&#x27;t really manifest once you had a couple tests for it.</div><br/><div id="37518291" class="c"><input type="checkbox" id="c-37518291" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37519057">next</a><span>|</span><label class="collapse" for="c-37518291">[-]</label><label class="expand" for="c-37518291">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if it is still like this, but the code for dpkg used to be like this, and it was <i>amazing</i>: if you ever needed to know in exactly what order various side effects of installing a package happened in, you could just scroll through the one function and it was obvious.<p>To this end, I&#x27;d say it is important to be working in a language that avoids messing up the logic with boiler plate, or building some kind of mechanism (as dpkg did) to ease error handling and shove it out of the main flow; this is where the happy path shines: when it reads like a specification.</div><br/></div></div><div id="37519057" class="c"><input type="checkbox" id="c-37519057" checked=""/><div class="controls bullet"><span class="by">koonsolo</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37518291">prev</a><span>|</span><a href="#37518199">next</a><span>|</span><label class="collapse" for="c-37519057">[-]</label><label class="expand" for="c-37519057">[3 more]</label></div><br/><div class="children"><div class="content">At first I thought how horrible, but basically you have sort of 9 functions within the same scope, each having a docstring. So I guess not too different from splitting them up.<p>I read you have &quot;end to end&quot; tests.<p>One question though: Wouldn&#x27;t each part benefit for having their own unit tests?</div><br/><div id="37519154" class="c"><input type="checkbox" id="c-37519154" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519057">parent</a><span>|</span><a href="#37519796">next</a><span>|</span><label class="collapse" for="c-37519154">[-]</label><label class="expand" for="c-37519154">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, maybe not. For our particular case it would have been mostly wasted effort.<p>I found that I like to write tests at the level of abstraction I want to keep an implementation stable. I&#x27;d be totally fine if someone went in and changed the implementation details of that long process if needed. We cared that stuff got cleaned up at the end of the process, that the output matched certain criteria, that certain user interaction was triggered and so on... In that case it made more sense to test all our expectations for a larger scope of code, rather than &quot;fix&quot; the implementation details.<p>Tests usually &quot;fix&quot; expectations so they don&#x27;t change from build to build. Tests don&#x27;t ensure correctness, they ensure stuff doesn&#x27;t alter unexpectedly.</div><br/></div></div><div id="37519796" class="c"><input type="checkbox" id="c-37519796" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519057">parent</a><span>|</span><a href="#37519154">prev</a><span>|</span><a href="#37518199">next</a><span>|</span><label class="collapse" for="c-37519796">[-]</label><label class="expand" for="c-37519796">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>One question though: Wouldn&#x27;t each part benefit for having their own unit tests?</i><p>Not necessarily, especially since this allows for the case where individual unit tests pass fine, but the combined logic fails.</div><br/></div></div></div></div><div id="37518199" class="c"><input type="checkbox" id="c-37518199" checked=""/><div class="controls bullet"><span class="by">realrains</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37519057">prev</a><span>|</span><a href="#37518485">next</a><span>|</span><label class="collapse" for="c-37518199">[-]</label><label class="expand" for="c-37518199">[9 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the fact that a function works well is a good enough reason to write a 2000 line function. Sometimes there are long pieces of code that implement complex algorithms that are difficult to break into smaller pieces of code, but those cases are limited to the few you mentioned.</div><br/><div id="37519008" class="c"><input type="checkbox" id="c-37519008" checked=""/><div class="controls bullet"><span class="by">BigJono</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518199">parent</a><span>|</span><a href="#37519248">next</a><span>|</span><label class="collapse" for="c-37519008">[-]</label><label class="expand" for="c-37519008">[3 more]</label></div><br/><div class="children"><div class="content">Computers execute code in a linear fashion, why on earth would you &quot;need a reason&quot; to NOT abstract something? Just because abstraction is often the right thing to do doesn&#x27;t make it the base case.<p>It&#x27;s like saying you need a reason not to add 4000 random jumps in your assembly code just to make it more difficult to read...</div><br/><div id="37519115" class="c"><input type="checkbox" id="c-37519115" checked=""/><div class="controls bullet"><span class="by">ahtihn</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519008">parent</a><span>|</span><a href="#37519248">next</a><span>|</span><label class="collapse" for="c-37519115">[-]</label><label class="expand" for="c-37519115">[2 more]</label></div><br/><div class="children"><div class="content">Source code isn&#x27;t written to be executed by computers, it&#x27;s written to be read by other humans.<p>Source code tends to be very far removed from how computers execute anything, so I wouldn&#x27;t use that as a justification for any sort of code style.</div><br/><div id="37519563" class="c"><input type="checkbox" id="c-37519563" checked=""/><div class="controls bullet"><span class="by">amoss</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519115">parent</a><span>|</span><a href="#37519248">next</a><span>|</span><label class="collapse" for="c-37519563">[-]</label><label class="expand" for="c-37519563">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Source code isn&#x27;t written to be executed by computers, it&#x27;s written to be read by other humans.<p>It is pronounced &quot;documentation&quot;.</div><br/></div></div></div></div></div></div><div id="37519248" class="c"><input type="checkbox" id="c-37519248" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518199">parent</a><span>|</span><a href="#37519008">prev</a><span>|</span><a href="#37519354">next</a><span>|</span><label class="collapse" for="c-37519248">[-]</label><label class="expand" for="c-37519248">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that implement complex algorithms that are difficult to break into smaller pieces of code<p>My longest code is always image processing. It&#x27;s usually too hard to break up for the sake of breaking up. There&#x27;s nothing to reuse between the calls to filters&#x2F;whatever.</div><br/></div></div><div id="37519354" class="c"><input type="checkbox" id="c-37519354" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518199">parent</a><span>|</span><a href="#37519248">prev</a><span>|</span><a href="#37519784">next</a><span>|</span><label class="collapse" for="c-37519354">[-]</label><label class="expand" for="c-37519354">[1 more]</label></div><br/><div class="children"><div class="content">The default should be reversed, don&#x27;t break into smaller pieces unless there&#x27;s a really good reason.</div><br/></div></div><div id="37519784" class="c"><input type="checkbox" id="c-37519784" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518199">parent</a><span>|</span><a href="#37519354">prev</a><span>|</span><a href="#37519034">next</a><span>|</span><label class="collapse" for="c-37519784">[-]</label><label class="expand" for="c-37519784">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>I don&#x27;t think the fact that a function works well is a good enough reason to write a 2000 line function.</i><p>The fact that it works well and reads well (when it does, as in the parent&#x27;s case), is.<p>Aside from those factors what else would be against it? Dogma?</div><br/></div></div><div id="37519034" class="c"><input type="checkbox" id="c-37519034" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518199">parent</a><span>|</span><a href="#37519784">prev</a><span>|</span><a href="#37518485">next</a><span>|</span><label class="collapse" for="c-37519034">[-]</label><label class="expand" for="c-37519034">[2 more]</label></div><br/><div class="children"><div class="content">I guess all we know is there were 2K lines of code and the commenter thinks that was the right way to do it. It would be necessary to see the code to appropriately critique it.</div><br/><div id="37519296" class="c"><input type="checkbox" id="c-37519296" checked=""/><div class="controls bullet"><span class="by">goatlover</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519034">parent</a><span>|</span><a href="#37518485">next</a><span>|</span><label class="collapse" for="c-37519296">[-]</label><label class="expand" for="c-37519296">[1 more]</label></div><br/><div class="children"><div class="content">Not just the commenter, but his team as well. It passed code review with flying colors, apparently. The moral of the story is that there always exceptions and developers should not be ideologically committed to one approach above all else.</div><br/></div></div></div></div></div></div><div id="37518485" class="c"><input type="checkbox" id="c-37518485" checked=""/><div class="controls bullet"><span class="by">RHSeeger</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37518199">prev</a><span>|</span><a href="#37519009">next</a><span>|</span><label class="collapse" for="c-37518485">[-]</label><label class="expand" for="c-37518485">[8 more]</label></div><br/><div class="children"><div class="content">&gt;The moment we would have spent effort to make them distinct functions we would have had to recheck our assumptions, generalize, verify that methods work on their own<p>Why? Why can&#x27;t the functions say &quot;to be used by &lt;this other function&gt;, makes assumptions based on that function, do not use externally&quot;? Breaking out code into a function so that the place it came from is easier to maintain... does not mandate that the code broken out needs to be &quot;general purpose&quot;.</div><br/><div id="37518670" class="c"><input type="checkbox" id="c-37518670" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518485">parent</a><span>|</span><a href="#37519009">next</a><span>|</span><label class="collapse" for="c-37518670">[-]</label><label class="expand" for="c-37518670">[7 more]</label></div><br/><div class="children"><div class="content">Specifically, in that place, there was no need. And prematurely splitting it would have caused us to overthink and over generalize. Having a long, linear and tested function was a better choice.</div><br/><div id="37519004" class="c"><input type="checkbox" id="c-37519004" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518670">parent</a><span>|</span><a href="#37519009">next</a><span>|</span><label class="collapse" for="c-37519004">[-]</label><label class="expand" for="c-37519004">[6 more]</label></div><br/><div class="children"><div class="content">I understand your point, but perhaps that would have simply been an opportunity to refine your approach to code design. If such a situation leads to excessive deliberation and overgeneralisation, your code base must be riddled with unnecessary overthinking and overgeneralisation.</div><br/><div id="37519312" class="c"><input type="checkbox" id="c-37519312" checked=""/><div class="controls bullet"><span class="by">goatlover</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519004">parent</a><span>|</span><a href="#37519393">next</a><span>|</span><label class="collapse" for="c-37519312">[-]</label><label class="expand" for="c-37519312">[3 more]</label></div><br/><div class="children"><div class="content">Or maybe it was just a long, sequential algorithm where breaking it up wouldn&#x27;t have been an improvement.</div><br/><div id="37519908" class="c"><input type="checkbox" id="c-37519908" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519312">parent</a><span>|</span><a href="#37519393">next</a><span>|</span><label class="collapse" for="c-37519908">[-]</label><label class="expand" for="c-37519908">[2 more]</label></div><br/><div class="children"><div class="content">I have been programming for more than 30 years. Except for code generated explicitly to be only consumed by machine, I&#x27;ve never come across a function consisting of 2000 lines of code that should not have been broken up. Something is wrong there, and if you show me the code, I&#x27;ll tell you what&#x27;s wrong with it.</div><br/><div id="37520098" class="c"><input type="checkbox" id="c-37520098" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519908">parent</a><span>|</span><a href="#37519393">next</a><span>|</span><label class="collapse" for="c-37520098">[-]</label><label class="expand" for="c-37520098">[1 more]</label></div><br/><div class="children"><div class="content">I can imagine a new control statement with this type of syntax:<p><pre><code>  code
  code
  uses (a, b, c, d) {
    code
    code
  }
  more code
  more code
</code></pre>
It&#x27;s a block that defines the variables it uses, with no other access to the outer scope. It would help break up a linear function into blocks with clearer dependencies.</div><br/></div></div></div></div></div></div><div id="37519393" class="c"><input type="checkbox" id="c-37519393" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519004">parent</a><span>|</span><a href="#37519312">prev</a><span>|</span><a href="#37519009">next</a><span>|</span><label class="collapse" for="c-37519393">[-]</label><label class="expand" for="c-37519393">[2 more]</label></div><br/><div class="children"><div class="content">Glad you can see that without even looking at the code.</div><br/><div id="37519917" class="c"><input type="checkbox" id="c-37519917" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519393">parent</a><span>|</span><a href="#37519009">next</a><span>|</span><label class="collapse" for="c-37519917">[-]</label><label class="expand" for="c-37519917">[1 more]</label></div><br/><div class="children"><div class="content">Some things you don&#x27;t have to see to know whats going on. Function with 2000 lines of code? Have fun rationalising this.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37519009" class="c"><input type="checkbox" id="c-37519009" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37518485">prev</a><span>|</span><a href="#37519061">next</a><span>|</span><label class="collapse" for="c-37519009">[-]</label><label class="expand" for="c-37519009">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have to write tests to prove that private methods work on their own. Just test the public behaviour.</div><br/></div></div><div id="37519061" class="c"><input type="checkbox" id="c-37519061" checked=""/><div class="controls bullet"><span class="by">patrulek</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37519009">prev</a><span>|</span><a href="#37518091">next</a><span>|</span><label class="collapse" for="c-37519061">[-]</label><label class="expand" for="c-37519061">[1 more]</label></div><br/><div class="children"><div class="content">2000 lines is like a small project. I cant imagine putting that all in one function.</div><br/></div></div><div id="37518091" class="c"><input type="checkbox" id="c-37518091" checked=""/><div class="controls bullet"><span class="by">waynesonfire</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37519061">prev</a><span>|</span><a href="#37518964">next</a><span>|</span><label class="collapse" for="c-37518091">[-]</label><label class="expand" for="c-37518091">[4 more]</label></div><br/><div class="children"><div class="content">I worked with an engineer that wrote the most clear and elegant linear code. It was remarkable, never seen anything like it since. I can&#x27;t reproduce it but I do have an idea of what a well designed linear function looks like.. a story.</div><br/><div id="37519285" class="c"><input type="checkbox" id="c-37519285" checked=""/><div class="controls bullet"><span class="by">eep_social</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518091">parent</a><span>|</span><a href="#37518772">next</a><span>|</span><label class="collapse" for="c-37519285">[-]</label><label class="expand" for="c-37519285">[1 more]</label></div><br/><div class="children"><div class="content">I was just thinking that if I _needed_ to refactor this I might structure the stages as chapters in a book. One might be able to write an inner class or some such that had a “table of contents” function that called each stage in sequence as a void function with data managed out of line, maybe via cleverly designed singleton structs. Then the code itself can be written in order with minimal boilerplate between stage boundaries.<p>I think I’ve worked with some Python that looked and worked this way. I can’t place the details but probably in a processor pipeline running over a particularly hairy data format. Consider ancient specifications written by engineers talking on the phone encapsulated in relatively “modern” but still vintage specifications, sometimes involving screen-scraping a green screen mainframe terminal, wrapped in XML and sent over the internet. Anyway, point is I couldn’t agree more about stories.</div><br/></div></div><div id="37518772" class="c"><input type="checkbox" id="c-37518772" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518091">parent</a><span>|</span><a href="#37519285">prev</a><span>|</span><a href="#37518794">next</a><span>|</span><label class="collapse" for="c-37518772">[-]</label><label class="expand" for="c-37518772">[1 more]</label></div><br/><div class="children"><div class="content">That is true of well designed nonlinear code as well.The code needs to tell a story or it will be a mess.</div><br/></div></div><div id="37518794" class="c"><input type="checkbox" id="c-37518794" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518091">parent</a><span>|</span><a href="#37518772">prev</a><span>|</span><a href="#37518964">next</a><span>|</span><label class="collapse" for="c-37518794">[-]</label><label class="expand" for="c-37518794">[1 more]</label></div><br/><div class="children"><div class="content">I will agree that it takes some skill, not that I am great at it. It&#x27;s a different kind of skill than abstraction. Reading error handling in c code offered good insights for me to learn linearity better (c code that uses goto to jump to the end of a function for cleanup when an error occurs, for example).<p>However, if you screw up linear code, you screw up locally. If you write poor small functions, the rest of the team screws up because they barely ever read the contents of your functions that call other functions that call other functions. I&#x27;ve had way more problems with stuff being called slightly out of order, than with large functions.</div><br/></div></div></div></div><div id="37518964" class="c"><input type="checkbox" id="c-37518964" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37518091">prev</a><span>|</span><a href="#37518299">next</a><span>|</span><label class="collapse" for="c-37518964">[-]</label><label class="expand" for="c-37518964">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You could argue that every one of those 9 scopes could be a separate function, but then devs would be tempted to reuse them.<p>Good thinking. Now they’ll just add 50 flags and ten levels of nested ifs instead which is much simpler.</div><br/></div></div><div id="37518299" class="c"><input type="checkbox" id="c-37518299" checked=""/><div class="controls bullet"><span class="by">gabereiser</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518036">parent</a><span>|</span><a href="#37518964">prev</a><span>|</span><a href="#37517959">next</a><span>|</span><label class="collapse" for="c-37518299">[-]</label><label class="expand" for="c-37518299">[7 more]</label></div><br/><div class="children"><div class="content">&gt;”but then devs would be tempted to reuse them”<p>Isn’t that the fucking point? Having a 2000 line function is a code smell so bad, I don’t care how well the function works. It’s an automatic review fail in my book. Abstractions, closures, scope, and most importantly - docs to make sure others use your functions the way you intended them. Jesus.</div><br/><div id="37518713" class="c"><input type="checkbox" id="c-37518713" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518299">parent</a><span>|</span><a href="#37519092">next</a><span>|</span><label class="collapse" for="c-37518713">[-]</label><label class="expand" for="c-37518713">[1 more]</label></div><br/><div class="children"><div class="content">Some devs did find it a code smell... But each scope had a clear short high level comment describing what it did, there were end to end tests for the method, and very little state flowed from scope to scope  (some did) - because that&#x27;s what scoprs do... Prevent variables from leaking.<p>My point is the code smell isn&#x27;t always accurate, and there are times and even for 2000 line monsters other devs agreed that it was the best way to hide complexity away from the rest of the codebase in that case. If we ever needed to factor things out (we never did), we could spend some effort and do it.</div><br/></div></div><div id="37519092" class="c"><input type="checkbox" id="c-37519092" checked=""/><div class="controls bullet"><span class="by">okaleniuk</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518299">parent</a><span>|</span><a href="#37518713">prev</a><span>|</span><a href="#37519036">next</a><span>|</span><label class="collapse" for="c-37519092">[-]</label><label class="expand" for="c-37519092">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried reading code instead of smelling it?</div><br/></div></div><div id="37519036" class="c"><input type="checkbox" id="c-37519036" checked=""/><div class="controls bullet"><span class="by">MrPatan</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518299">parent</a><span>|</span><a href="#37519092">prev</a><span>|</span><a href="#37518429">next</a><span>|</span><label class="collapse" for="c-37519036">[-]</label><label class="expand" for="c-37519036">[2 more]</label></div><br/><div class="children"><div class="content">A code smell means you should look into it, not that it&#x27;s wrong.<p>Some things are genuinely 2kloc-complex.  Maybe not that many. Do check! But some are.</div><br/><div id="37519233" class="c"><input type="checkbox" id="c-37519233" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37519036">parent</a><span>|</span><a href="#37518429">next</a><span>|</span><label class="collapse" for="c-37519233">[-]</label><label class="expand" for="c-37519233">[1 more]</label></div><br/><div class="children"><div class="content">Definitely not that many. Even for me this was an outlier, but it made me more comfortable with functions most people would consider long.<p>I&#x27;d like to clarify this was not necessarily 2kloc-complex, this was just 2kloc-long-and-not-really-meant-to-be-reused. It was a fairly long but linear process that was out of the ordinary for the rest of the codebase. It could easily have been split (hell, I had 9 fairly separate stages), but calling any of the intermediate stages out of order or without the context of the rest of the execution flow... would have been a foot gun for someone else. And, as time showed, we never needed those stages for anything else.</div><br/></div></div></div></div><div id="37518429" class="c"><input type="checkbox" id="c-37518429" checked=""/><div class="controls bullet"><span class="by">turdprincess</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518299">parent</a><span>|</span><a href="#37519036">prev</a><span>|</span><a href="#37517959">next</a><span>|</span><label class="collapse" for="c-37518429">[-]</label><label class="expand" for="c-37518429">[2 more]</label></div><br/><div class="children"><div class="content">Agreed.  I’ve written plenty of software of all kinds and have never had to write a 2000 line long methods (although I have had the joy of refactoring such messeses a time or two).<p>Just don’t do that.  Your code doesn’t have to have abstractions out the wazzo, but if your class (or method) is getting bigger than 1000 lines that’s a great sign that it’s doing too much and abstractions can be teased out.  Your future self will thank you, as well as your team.</div><br/><div id="37518979" class="c"><input type="checkbox" id="c-37518979" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518429">parent</a><span>|</span><a href="#37517959">next</a><span>|</span><label class="collapse" for="c-37518979">[-]</label><label class="expand" for="c-37518979">[1 more]</label></div><br/><div class="children"><div class="content">I like this from Sandi Metz:<p>&gt; You can&#x27;t create the right abstraction until you fully understand the code, but the existence of the wrong abstraction may prevent you from ever doing so. This suggests that you should not reach for abstractions, but instead, you should resist them until they absolutely insist upon being created.</div><br/></div></div></div></div></div></div></div></div><div id="37517959" class="c"><input type="checkbox" id="c-37517959" checked=""/><div class="controls bullet"><span class="by">whywhywouldyou</span><span>|</span><a href="#37517831">parent</a><span>|</span><a href="#37518036">prev</a><span>|</span><a href="#37518275">next</a><span>|</span><label class="collapse" for="c-37517959">[-]</label><label class="expand" for="c-37517959">[10 more]</label></div><br/><div class="children"><div class="content">So where&#x27;s the proof that the function&#x27;d code scales? As the complexity of the overall code grows, so would something that gets chopped into dozens of functions to the point of being unreadable.<p>Suddenly, you realize that the dozens of functions __need to be called in specific orders__, and they are each only ever used once. So really what you&#x27;re doing is forcing someone to know the magic order these functions are composed in order for them to be of any use.</div><br/><div id="37518087" class="c"><input type="checkbox" id="c-37518087" checked=""/><div class="controls bullet"><span class="by">harpiaharpyja</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37517959">parent</a><span>|</span><a href="#37518458">next</a><span>|</span><label class="collapse" for="c-37518087">[-]</label><label class="expand" for="c-37518087">[4 more]</label></div><br/><div class="children"><div class="content">The truth is that either one can be done wrong.<p>Unfortunately organizing your code along the right lines of abstraction is something that just takes skill and can&#x27;t easily be summarized in the form of &quot;just always do this and your code will be better&quot;<p>If you organize your code into units that are easy to recompose and remix, well you get huge benefits when you want recompose and remix things.<p>If you organize your code into units that can&#x27;t be easily recomposed, then yes you&#x27;ve added complexity for no benefit. But why make units that can&#x27;t be treated individually?<p>&quot;As the complexity of the overall code grows, so would something that gets chopped into dozens of functions to the point of being unreadable.&quot;<p>So the answer to this is, &quot;don&#x27;t chop it into functions in a way that leaves it unreadable, instead chop it into functions in a way that leaves it more readable.&quot;<p>That may be unsatisfying, but it gets to the point that blindly applying rules is not always going to lead to better code. But it doesn&#x27;t mean that an approach has no value.</div><br/><div id="37518493" class="c"><input type="checkbox" id="c-37518493" checked=""/><div class="controls bullet"><span class="by">erhaetherth</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518087">parent</a><span>|</span><a href="#37518458">next</a><span>|</span><label class="collapse" for="c-37518493">[-]</label><label class="expand" for="c-37518493">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an easier approach that will also aid you in telling you how to precisely chop up your function.<p>Simply don&#x27;t chop up your function until you need a slice of it somewhere else. Then refactor out the bit you need. You&#x27;ll find out exactly which bits need to be replaced with variables and exactly where the slice needs to happen.</div><br/><div id="37518756" class="c"><input type="checkbox" id="c-37518756" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518493">parent</a><span>|</span><a href="#37519148">next</a><span>|</span><label class="collapse" for="c-37518756">[-]</label><label class="expand" for="c-37518756">[1 more]</label></div><br/><div class="children"><div class="content">This is the correct answer right here if you have a good enough team. It is still the way I want to work. Unfortunately, I find that there are too many developers who haven&#x27;t learned that you should always be considering to &quot;refactor as you go&quot;. I&#x27;m trying to teach by example, but it&#x27;s an uphill battle.</div><br/></div></div><div id="37519148" class="c"><input type="checkbox" id="c-37519148" checked=""/><div class="controls bullet"><span class="by">pstuart</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518493">parent</a><span>|</span><a href="#37518756">prev</a><span>|</span><a href="#37518458">next</a><span>|</span><label class="collapse" for="c-37519148">[-]</label><label class="expand" for="c-37519148">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Start with the straight-ahead linear approach and factor out once it&#x27;s unwieldy.<p>Same thing for copy pasta funcs -- the first copy is fine, the second one may be too, but after that consider extracting to a parameterized func (a permutation of the Go Proverb &quot;A little copying is better than a little dependency.&quot;)</div><br/></div></div></div></div></div></div><div id="37518458" class="c"><input type="checkbox" id="c-37518458" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37517959">parent</a><span>|</span><a href="#37518087">prev</a><span>|</span><a href="#37518119">next</a><span>|</span><label class="collapse" for="c-37518458">[-]</label><label class="expand" for="c-37518458">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Suddenly, you realize that the dozens of functions __need to be called in specific orders__, and they are each only ever used once. So really what you&#x27;re doing is forcing someone to know the magic order these functions are composed in order for them to be of any use.<p>That&#x27;s where nested functions show their true utility. You get short linear logic because everything is in functions, but the functions are all local scope so you get to modify local scope with them, and because the functions are all named, it is easy to determine what is going on.</div><br/></div></div><div id="37518119" class="c"><input type="checkbox" id="c-37518119" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37517959">parent</a><span>|</span><a href="#37518458">prev</a><span>|</span><a href="#37519603">next</a><span>|</span><label class="collapse" for="c-37518119">[-]</label><label class="expand" for="c-37518119">[1 more]</label></div><br/><div class="children"><div class="content">The API shouldn&#x27;t be that. Expose something easy to use. That is the point of abstractions. It doesn&#x27;t matter if there are a dozen methods called in order if those dozen methods are called by a helper method, beyond maybe some implementation details.<p>Really the question should always come up when there are more than say two ways to do things. If I can make a pizza from scratch, reheat a chilled pizza, create a pizza and chill it, reheat a half dozen pizzas, or make three pizzas of the same kind and chill them suddenly the useful abstractions are probably something you can figure out between those helper methods.<p>Honestly that is the real fear of the left way of thinking. If you add a quantity, whether to cook and whether to chill parameters you end up with a hard API where certain combinations of parameters don&#x27;t make sense.<p>Have a clean API and make the implementation as simple as is feasible. Reuse via functions when it makes sense but don&#x27;t add them willy nilly.<p>Aka &quot;it is a craft and you figure things out&quot; as someone said in the comments here</div><br/></div></div><div id="37519603" class="c"><input type="checkbox" id="c-37519603" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37517959">parent</a><span>|</span><a href="#37518119">prev</a><span>|</span><a href="#37517996">next</a><span>|</span><label class="collapse" for="c-37519603">[-]</label><label class="expand" for="c-37519603">[1 more]</label></div><br/><div class="children"><div class="content">If you have dozens of functions that need to be called in specific orders, design and use a state machine and then use a dispatch function that orchestrates the state machine.</div><br/></div></div><div id="37517996" class="c"><input type="checkbox" id="c-37517996" checked=""/><div class="controls bullet"><span class="by">professoretc</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37517959">parent</a><span>|</span><a href="#37519603">prev</a><span>|</span><a href="#37517978">next</a><span>|</span><label class="collapse" for="c-37517996">[-]</label><label class="expand" for="c-37517996">[1 more]</label></div><br/><div class="children"><div class="content">In a decent programming language you can nest functions, so all the little functions that make up some larger unit of the program are contained within (and can only be <i>called</i> within) that outer function. They serve less as functions to be called and more just as names attached to bits of code. And since they can&#x27;t be called anywhere else, other people don&#x27;t need to worry about them unless they&#x27;re working on that specific part of the program.</div><br/></div></div><div id="37517978" class="c"><input type="checkbox" id="c-37517978" checked=""/><div class="controls bullet"><span class="by">dfee</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37517959">parent</a><span>|</span><a href="#37517996">prev</a><span>|</span><a href="#37518275">next</a><span>|</span><label class="collapse" for="c-37517978">[-]</label><label class="expand" for="c-37517978">[1 more]</label></div><br/><div class="children"><div class="content">Dozens of functions need to be called in a specific order?<p>Oh my God.</div><br/></div></div></div></div><div id="37518275" class="c"><input type="checkbox" id="c-37518275" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#37517831">parent</a><span>|</span><a href="#37517959">prev</a><span>|</span><a href="#37519019">next</a><span>|</span><label class="collapse" for="c-37518275">[-]</label><label class="expand" for="c-37518275">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but the idea doesn’t scale.<p>You are wrong here.<p>&gt; this is one of those “programming is a craft” things, where experience helps you determine what is right in a situation.<p>You are right here.<p>The key insight on why giant linear functions are often more readable (and desirable) is because they allow you to keep more concepts&#x2F;relationships simultaneously together as a single chunk without context switching which seems to aid our comprehension. An extreme proponent is Arthur Whitney (inventor of the K language) who writes very terse (almost incomprehensible to others) code so as to accommodate as much as possible in a single screen.<p>Two examples from my own experience;<p>1) I found reading&#x2F;understanding&#x2F;debugging a very large Windows message handler function (i.e. a WndProc with a giant switch statement containing all the business logic) far easier than the same application rewritten in Visual C++ where the message handlers were broken out into separate functions.<p>2) The sample code for a microcontroller showed an ADC usage example in two different ways; One with everything in the same file and another where the code was distributed across files eg. main.c&#x2F;config.c&#x2F;interrupts.c&#x2F;timer.c&#x2F;etc. Even though the LOC was &lt;200 i found the second example hard to understand simply because of the context switch involved.</div><br/><div id="37519161" class="c"><input type="checkbox" id="c-37519161" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518275">parent</a><span>|</span><a href="#37518508">next</a><span>|</span><label class="collapse" for="c-37519161">[-]</label><label class="expand" for="c-37519161">[1 more]</label></div><br/><div class="children"><div class="content">&gt; an extreme proponent is Arthur Whitney (inventor of the K language) who writes very terse (almost incomprehensible to others) code<p>But k has a small set of built-in commands and a built-in database; it was made for fast analysis of stock information, so with that you have everything you need and you use the same semantics. The only thing you need to know is the data structure and you can build whatever you need.<p>So in this way, it&#x27;s very likely that, given two tables A + B and &#x27;bunch of operations&#x27; X on A and &#x27;bunch of operations Y&#x27; on B where Y depends on the result of X, and given the tasks to;<p>- create X&#x27; = X<p>- create XY&#x27; = X + Y<p>to implement XY without knowing X already exists rather than figure out X exists and reuse it.<p>The problem with not k (or programs written in similar style; it doesn&#x27;t really matter what the programming language is), that we have learned to use the second style from the article, and, more extreme, to separate everything out in layers. You cannot even <i>reach</i> the data model without going through a layer (or more) of abstractions which makes it necessary not only to know the datamodel in detail but also find the matching findXinAandApplyWithYToB(). Where X &amp; Y &amp; A &amp; B are often some kind of ambiguous and badly named entities. And then there is of course badly designed databases which is also quite the norm as far as we see, so there is a much lower data integrity which means that if you create something without checking all the code that touches it, that you might change something and the data becomes inconsistent.<p>I notice the same when working on systems built with stored procedures on MSSQL&#x2F;Postgres; it is far quicker to oversee and (at least basically) understand the datamodel (even with 1000+ tables, which is rather normal for systems we work with) than it is to understand even a fraction of a, let&#x27;s say Go, codebase. So when asked to do do a task XY&#x27;, you are usually just not searching for X&#x27;; you are simply reading the data used in X &amp; Y and whop up a procedure&#x2F;query&#x2F;whatever yourself. It&#x27;s simply much faster as you have a restricted work surface; the model and sql (I know, you can use almost any language in postgres, but let&#x27;s not here) and you can reason about them and the tasks at hand when you shut off internet and <i>just</i> use your sql workbench.</div><br/></div></div><div id="37518508" class="c"><input type="checkbox" id="c-37518508" checked=""/><div class="controls bullet"><span class="by">RHSeeger</span><span>|</span><a href="#37517831">root</a><span>|</span><a href="#37518275">parent</a><span>|</span><a href="#37519161">prev</a><span>|</span><a href="#37519019">next</a><span>|</span><label class="collapse" for="c-37518508">[-]</label><label class="expand" for="c-37518508">[1 more]</label></div><br/><div class="children"><div class="content">YEAH, but the moral that should be taken from that is not &quot;it&#x27;s always better to write huge, linear functions&quot;. Rather, &quot;there are cases where huge, linear functions make sense because of the way the code needs to interact with things&quot;. Along the same lines, there are cases where breaking the code up into smaller functions, and calling them from the main function, makes more sense&quot;.<p>&gt; Linear code is more readable<p>^ Wrong<p>&gt; Linear code is sometimes more readable<p>^ Better</div><br/></div></div></div></div><div id="37519019" class="c"><input type="checkbox" id="c-37519019" checked=""/><div class="controls bullet"><span class="by">starbugs</span><span>|</span><a href="#37517831">parent</a><span>|</span><a href="#37518275">prev</a><span>|</span><a href="#37519338">next</a><span>|</span><label class="collapse" for="c-37519019">[-]</label><label class="expand" for="c-37519019">[1 more]</label></div><br/><div class="children"><div class="content">I have seen many instances where people just out of habbit factor out a lot of linear code that will never be reused into separate functions.<p>These pieces of code then often end up being private functions of a class. With state. Since they are private functions now, they are not really testable.<p>So now we got a lot of private functions that are only called once and typically modify side effect state. When these functions are grouped together with the caller, it is actually still a bit readable in simple cases.<p>But then after a while someone adds other functions in between the calling function and the factored out ones.<p>Now we have bits and pieces modifying different side effect state that no one knows if they are called from different places without getting a call graph or doing a search in the class file.<p>If you insist on making the code non-linear, I&#x27;d beg you to at least consider making these factored out private funcs inner funcs of the calling function if your language supports that. This makes it clear that these functions won&#x27;t be called from anywhere else.<p>As with so many things in life, in a real codebase this is not an either&#x2F;or, but an art of combining the two into something that stays readable and maintainable.</div><br/></div></div><div id="37519338" class="c"><input type="checkbox" id="c-37519338" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#37517831">parent</a><span>|</span><a href="#37519019">prev</a><span>|</span><a href="#37519091">next</a><span>|</span><label class="collapse" for="c-37519338">[-]</label><label class="expand" for="c-37519338">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The example code is vey simplistic, so of course that linear code is more readable, but the idea doesn’t scale.<p>...that&#x27;s basically why common sense and taste in programming is still required, it&#x27;s not a purely mechanical task. That&#x27;s also why I&#x27;m not entirely a fan of automatic code formatting tools, they don&#x27;t understand the concept of nuance.</div><br/></div></div><div id="37519091" class="c"><input type="checkbox" id="c-37519091" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37517831">parent</a><span>|</span><a href="#37519338">prev</a><span>|</span><a href="#37518330">next</a><span>|</span><label class="collapse" for="c-37519091">[-]</label><label class="expand" for="c-37519091">[1 more]</label></div><br/><div class="children"><div class="content">If the function was truly linear having a long function wouldn&#x27;t be so bad. But it actually isn&#x27;t, the example contains multiple branches!<p>Will people bother testing all of them? Or will they write a single test, pass in a pizza and just glance at it actually working? My guess is the latter, as testing multiple branches from outside is often tedious, vs testing smaller specialized functions.</div><br/></div></div></div></div><div id="37518330" class="c"><input type="checkbox" id="c-37518330" checked=""/><div class="controls bullet"><span class="by">s17n</span><span>|</span><a href="#37517831">prev</a><span>|</span><a href="#37520110">next</a><span>|</span><label class="collapse" for="c-37518330">[-]</label><label class="expand" for="c-37518330">[7 more]</label></div><br/><div class="children"><div class="content">Everyone saying &quot;linear code doesn&#x27;t scale&quot; actually has it backwards - it&#x27;s concise functions with a deeply nested call stack that really becomes a nightmare in large codebases.  It&#x27;s never obvious where new code should be added, the difficulty of understanding what the effects of your changes will be increases exponentially since you have to trace all the possible ways code can get called, you end up with duplicated subroutines, etc etc.<p>99% of the time, you haven&#x27;t actually come up with a good abstraction, so just write some linear code.  Prefer copy&#x2F;pasting to dubious function semantics.</div><br/><div id="37518417" class="c"><input type="checkbox" id="c-37518417" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37518330">parent</a><span>|</span><a href="#37518416">next</a><span>|</span><label class="collapse" for="c-37518417">[-]</label><label class="expand" for="c-37518417">[4 more]</label></div><br/><div class="children"><div class="content">Another risk is if you add print_table() then someone else is going to find it and use it in their code, but also add a little flag to adjust the output for their use case.<p>12 months later you have:<p><pre><code>  print_table(
    rows,
    headers = None,
    is_unicode = False,
    left_align = False,
    align = [],
    remove_emoji = None,
    max_width = 80,
    potato_mode = 7,
    _debug_frontend = not FLAGS.dont_debug,
    ellipsis_for = 0,
    no_print = False,
  )</code></pre></div><br/><div id="37519381" class="c"><input type="checkbox" id="c-37519381" checked=""/><div class="controls bullet"><span class="by">ncann</span><span>|</span><a href="#37518330">root</a><span>|</span><a href="#37518417">parent</a><span>|</span><a href="#37520114">next</a><span>|</span><label class="collapse" for="c-37519381">[-]</label><label class="expand" for="c-37519381">[1 more]</label></div><br/><div class="children"><div class="content">I think we all know at least some functions like this in a code base. All it takes is for a newcomer to come across a complex function that they need to update some logics for but also don&#x27;t understand it enough to refactor, so they just added some parameters with default values and call it a day.<p>&gt; no_print = False<p>love this</div><br/></div></div><div id="37520114" class="c"><input type="checkbox" id="c-37520114" checked=""/><div class="controls bullet"><span class="by">krembo</span><span>|</span><a href="#37518330">root</a><span>|</span><a href="#37518417">parent</a><span>|</span><a href="#37519381">prev</a><span>|</span><a href="#37519949">next</a><span>|</span><label class="collapse" for="c-37520114">[-]</label><label class="expand" for="c-37520114">[1 more]</label></div><br/><div class="children"><div class="content">This example looks totally legit to me as long as it preserves backward compatibility and doesnt add unnecessary junk flags</div><br/></div></div><div id="37519949" class="c"><input type="checkbox" id="c-37519949" checked=""/><div class="controls bullet"><span class="by">reedf1</span><span>|</span><a href="#37518330">root</a><span>|</span><a href="#37518417">parent</a><span>|</span><a href="#37520114">prev</a><span>|</span><a href="#37518416">next</a><span>|</span><label class="collapse" for="c-37519949">[-]</label><label class="expand" for="c-37519949">[1 more]</label></div><br/><div class="children"><div class="content">To play devil&#x27;s advocate - what&#x27;s the issue with this?<p>Is print_table() + print_table_without_emoji() better than print_table(remove_emoji= False)?</div><br/></div></div></div></div><div id="37518416" class="c"><input type="checkbox" id="c-37518416" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37518330">parent</a><span>|</span><a href="#37518417">prev</a><span>|</span><a href="#37520110">next</a><span>|</span><label class="collapse" for="c-37518416">[-]</label><label class="expand" for="c-37518416">[2 more]</label></div><br/><div class="children"><div class="content">Well you&#x27;re describing a readability problem. And you&#x27;re essentially saying readability is what causes it not to scale.<p>If we consider the concepts orthogonally meaning we don&#x27;t consider the fact that readability can influence scalability then &quot;everyone&quot; is fully correct. Linear code doesn&#x27;t scale as well as modular code. The dichotomy is worth knowing and worth considering depending on the situation.<p>That being said I STILL disagree with you. Small functions do not cause readability issues if those functions are PURE. Meaning they don&#x27;t touch state. That and you don&#x27;t inject logic into your code, so explicitly minimize all dependency injection and passing functions to other functions.<p>Form a pipeline of pure functions passing only data to other functions then it all becomes readable and scalable. You&#x27;ll much more rarely hit an issue where you have to rewrite your logic because of a design flaw. More often then not by composing pure functions your code becomes like legos. Every refactoring becomes more like re-configuring and recomposing existing primitives.</div><br/><div id="37519634" class="c"><input type="checkbox" id="c-37519634" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#37518330">root</a><span>|</span><a href="#37518416">parent</a><span>|</span><a href="#37520110">next</a><span>|</span><label class="collapse" for="c-37519634">[-]</label><label class="expand" for="c-37519634">[1 more]</label></div><br/><div class="children"><div class="content">I disagree.  It&#x27;s not the purity of the functions, its having to know the details of them.  The details, which could have existed here, are now in two other places.  If you need to figure out how a value is calculated, and you use a half dozen functions to come to that value, you now have a half dozen places you need to jump to within the codebase.<p>Small functions increase the chances of you having to do this.  Larger ones decrease it, but can cause other issues.<p>Also, many small functions doesn&#x27;t make code modular.  Having well defined, focused interfaces (I don&#x27;t mean in the OO sense) for people to use makes it modular.  Small functions don&#x27;t necessarily harm it, but if you&#x27;re not really good at organizing things they definitely can obscure it.</div><br/></div></div></div></div></div></div><div id="37520110" class="c"><input type="checkbox" id="c-37520110" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#37518330">prev</a><span>|</span><a href="#37518635">next</a><span>|</span><label class="collapse" for="c-37520110">[-]</label><label class="expand" for="c-37520110">[1 more]</label></div><br/><div class="children"><div class="content">John carmack said much the same and I have been following it ever since. Of course linear code is easier to read, if follows the order of execution. It minimizes eye saccades.<p>Some code needs to be non-linear for reuse. Then execution is a graph. If you code does not exploit code reuse from a graph structure, do not bother introducing vertexes where a single edge suffices.<p><a href="http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;blog&#x2F;programming&#x2F;2014&#x2F;09&#x2F;26&#x2F;carmack-on-inlined-code.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;blog&#x2F;programming&#x2F;2014&#x2F;09&#x2F;26&#x2F;carm...</a></div><br/></div></div><div id="37518635" class="c"><input type="checkbox" id="c-37518635" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#37520110">prev</a><span>|</span><a href="#37520161">next</a><span>|</span><label class="collapse" for="c-37518635">[-]</label><label class="expand" for="c-37518635">[2 more]</label></div><br/><div class="children"><div class="content">I actually sort of agree that linear code is more readable, but that’s not what makes good code practices alone. So while good linear code is more readable, at least in my opinion, it’s also a lot less maintainable and testable. I have a few decades of experience now, I even work a side gig as an external examiner for CS students, and the only real world good practices I’ve seen over the years is keeping functions small. I know, I know, I grade students on a lot of things I don’t believe in. I’m not particularly fond of abstraction, or even avoiding code-duplication at all costs and so on, but “as close to single purpose” functions as you can get, do that, and the future will thank you for it.<p>Because what is going to happen when the code in those examples run in production over a decade is that each segment is going to change. If you’re lucky the comments will be updated as that happens, but they more than likely won’t. The unit test will also get more and more clunky as changes happen because it’s big and unwieldy, and maybe someone is going to forget to alter the part of it that wasn’t obviously tied to a change. The code will probably also become a lot less readable as time goes by, not by intend or even incompetence but mostly due to time pressure or other human things. So yes, it’s more readable, and in the perfect world you probably wouldn’t need to separate your concerns, but we live in a very imperfect world and the smaller and less responsibility you give your functions the easier it’ll be to deal with that imperfection as time goes on.</div><br/><div id="37518688" class="c"><input type="checkbox" id="c-37518688" checked=""/><div class="controls bullet"><span class="by">mtreis86</span><span>|</span><a href="#37518635">parent</a><span>|</span><a href="#37520161">next</a><span>|</span><label class="collapse" for="c-37518688">[-]</label><label class="expand" for="c-37518688">[1 more]</label></div><br/><div class="children"><div class="content">I recently started reading Sussman&#x27;s Software Design for Flexibility and what you write is directly in line with that book
 <a href="https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262045490&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262045490&#x2F;</a></div><br/></div></div></div></div><div id="37520161" class="c"><input type="checkbox" id="c-37520161" checked=""/><div class="controls bullet"><span class="by">faizshah</span><span>|</span><a href="#37518635">prev</a><span>|</span><a href="#37518017">next</a><span>|</span><label class="collapse" for="c-37520161">[-]</label><label class="expand" for="c-37520161">[1 more]</label></div><br/><div class="children"><div class="content">Whats not shown is the 10 other functions calling createPizza and bakePizza that can be tested by mocking that routine centrally.<p>In the basic case, the linear version is better until the code is duplicated. Adding constants and function aliases before the code has duplicated is generally a bad idea.</div><br/></div></div><div id="37518017" class="c"><input type="checkbox" id="c-37518017" checked=""/><div class="controls bullet"><span class="by">Shoop</span><span>|</span><a href="#37520161">prev</a><span>|</span><a href="#37519182">next</a><span>|</span><label class="collapse" for="c-37518017">[-]</label><label class="expand" for="c-37518017">[1 more]</label></div><br/><div class="children"><div class="content">Related email by John Carmack: <a href="http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;blog&#x2F;programming&#x2F;2014&#x2F;09&#x2F;26&#x2F;carmack-on-inlined-code.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;blog&#x2F;programming&#x2F;2014&#x2F;09&#x2F;26&#x2F;carm...</a><p>Discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12120752">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12120752</a></div><br/></div></div><div id="37519182" class="c"><input type="checkbox" id="c-37519182" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#37518017">prev</a><span>|</span><a href="#37519125">next</a><span>|</span><label class="collapse" for="c-37519182">[-]</label><label class="expand" for="c-37519182">[3 more]</label></div><br/><div class="children"><div class="content">I think the fundamental problem is that, despite our wishes, there are programs which are inherently complex, and cannot be refactored into a simple, by-pieces testable, form. And if we try to do that anyway, all we end up with is just more fluff (mocking, I am mocking you) that hides the complexity.<p>The internal complexity doesn&#x27;t necessarily come from complex abstractions. Take for example some implementation of a tax code, i.e. code calculating taxes. There is probably gonna be a lot of interdependencies, dealing with special cases. That&#x27;s your typical &quot;business logic&quot;. This code is not inherently complex because the primitives are complex, but because there is a lot of dependencies in the calculation. That fact in itself makes it difficult to unit test.<p>On the other end of the spectrum, we have something like a library of functions, for example, mathematical functions. The inner workings of how to calculate, say, a gamma function, can be very complex to understand, but the surface (API) of each of the function is very small, and that makes the library itself simple and easy to unit test.<p>We can make an analogy with books instead of programs. On one end, you have a novel, which despite being written in a plain language, has many interdependencies of the characters interacting. You cannot &quot;unit test&quot; a novel by reading a single chapter, you have to read it all. You can have a summary of the novel (like the top function in exhibit B in the OP&#x27;s example), but the summary of the novel is not exactly the novel, you&#x27;re not really testing the novel if you read just the summary.<p>On the other end, there are reference works like dictionary or encyclopedia. We can unit test these easily, since each entry should stand on its own (if you want to evaluate quality of a reference work, you can pick a few entries and test that, and it&#x27;s gonna be pretty representative). They are not emergently complex like a novel is, despite the fact that entries might use specialized jargon and be harder to read.</div><br/><div id="37519443" class="c"><input type="checkbox" id="c-37519443" checked=""/><div class="controls bullet"><span class="by">andrewjl</span><span>|</span><a href="#37519182">parent</a><span>|</span><a href="#37519125">next</a><span>|</span><label class="collapse" for="c-37519443">[-]</label><label class="expand" for="c-37519443">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That fact in itself makes it difficult to unit test.<p>Verifying a tax code implementation is a good place to make use of property based testing.</div><br/><div id="37519571" class="c"><input type="checkbox" id="c-37519571" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#37519182">root</a><span>|</span><a href="#37519443">parent</a><span>|</span><a href="#37519125">next</a><span>|</span><label class="collapse" for="c-37519571">[-]</label><label class="expand" for="c-37519571">[1 more]</label></div><br/><div class="children"><div class="content">I agree, and that&#x27;s why I favor it to unit testing (although to be fair, they are pretty complementary, because each addresses different end of the spectrum). To properly unit test, you need to have a different implementation, which you can compare with, you cannot IMHO unit test under the same assumptions that the code makes.</div><br/></div></div></div></div></div></div><div id="37519125" class="c"><input type="checkbox" id="c-37519125" checked=""/><div class="controls bullet"><span class="by">dgunay</span><span>|</span><a href="#37519182">prev</a><span>|</span><a href="#37520141">next</a><span>|</span><label class="collapse" for="c-37519125">[-]</label><label class="expand" for="c-37519125">[1 more]</label></div><br/><div class="children"><div class="content">The example code would be less distracting if it at least attempted to stick to the pizza metaphor in a meaningful way and weren&#x27;t subpar Go code.<p>`prepare` is a horrible name for a function. I would expect a seasoned Gopher to call it something like `NewPizzaFromOrder`.<p>I don&#x27;t see any reason for putting `addToppings` in its own function. If you have to have it, I personally would have made it a method on Pizza something like `func (p *Pizza) WithToppings(topping ...Topping) *Pizza { &#x2F;* ... *&#x2F; }`. Real pizza is mutable, so the method mutates the receiver.<p>Why is a new oven instantiated every time you want to bake a pizza? You should start with an oven you already have, then do `oven.Preheat()`, and then call call `oven.Bake(pizza)`. You can take this further by having `oven.Preheat()` return a newtype of Oven which exposes `.Bake()` so that you can&#x27;t accidentally bake something without preheating the oven first. Maybe elsewhere `Baker` is an interface, and you have a `ToasterOven` implementation that does not require you to preheat before baking because it&#x27;s just not as important.<p>Without changing the code, I&#x27;d also reorder the declarations to be more what you&#x27;d expect (so you don&#x27;t have to jump up and down the page as you scan through functions that call each other).<p>IDK I have to leave now but there are just so, so many ways in which the code is already a deeply horrible example to even start picking apart the &quot;which is more readable&quot; debate.</div><br/></div></div><div id="37520141" class="c"><input type="checkbox" id="c-37520141" checked=""/><div class="controls bullet"><span class="by">olav</span><span>|</span><a href="#37519125">prev</a><span>|</span><a href="#37517969">next</a><span>|</span><label class="collapse" for="c-37520141">[-]</label><label class="expand" for="c-37520141">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if there is some programming language that supports combining both styles:<p>- A linear control flow
- Named Blocks with explicit, named, typed parameters and return values<p>I understand that one can use anonymous functions, immediately called to simulate 
this style.</div><br/></div></div><div id="37517969" class="c"><input type="checkbox" id="c-37517969" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#37520141">prev</a><span>|</span><a href="#37518730">next</a><span>|</span><label class="collapse" for="c-37517969">[-]</label><label class="expand" for="c-37517969">[8 more]</label></div><br/><div class="children"><div class="content">Hard agree.  And I used to belong to the other camp.<p>The basic tension here is between locality [0], on the one hand, and the desire to clearly show the high-level &quot;table of contents&quot; view on the other.  Locality is more important for readable code.  As the article notes, the TOC view can be made clear enough with section comments.<p>There is another, even more important, reason to prefer the linear code: It is much easier to navigate a codebase writ large when the &quot;chunks&quot; (functions &#x2F; classes &#x2F; whatever your language mandates) roughly correspond to business use-cases.  Otherwise your search space gets too big, and you have to &quot;reconstruct&quot; the whole from the pieces yourself.  The code&#x27;s structure should do that for you.<p>If a bunch of &quot;stuff&quot; is all related to one thing (signup, or purchase, or whatever), let it be one thing in the code.  It will be much easier to find and change things.  Only break it down into sub-functions when <i>re-use</i> requires it.  Don&#x27;t do it <i>solely</i> for the sake of organization.<p>[0] <a href="https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;locality-of-behaviour&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;locality-of-behaviour&#x2F;</a></div><br/><div id="37519072" class="c"><input type="checkbox" id="c-37519072" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#37517969">parent</a><span>|</span><a href="#37517998">next</a><span>|</span><label class="collapse" for="c-37519072">[-]</label><label class="expand" for="c-37519072">[4 more]</label></div><br/><div class="children"><div class="content">I went the opposite direction: I used to be in the linear code camp, and now I&#x27;m in the &quot;more functions&quot; camp.<p>For me the biggest reason is state.  The longer the function, the wider the scope of the local variables.  Any code anywhere in the function can mutate any of the variables, and it&#x27;s not immediately clear what the data flow is.  More functions help scopes stay small, and data flow is more explicit.<p>A side benefit is that &quot;more functions&quot; helps keep indentation down.<p>At the same time, I don&#x27;t like functions that are <i>too</i> small, otherwise it&#x27;s hard to find out where any actual work gets done.</div><br/><div id="37519522" class="c"><input type="checkbox" id="c-37519522" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#37517969">root</a><span>|</span><a href="#37519072">parent</a><span>|</span><a href="#37519426">next</a><span>|</span><label class="collapse" for="c-37519522">[-]</label><label class="expand" for="c-37519522">[1 more]</label></div><br/><div class="children"><div class="content">Some important context re: my style...<p>&gt; Any code anywhere in the function can mutate any of the variables<p>Regardless of the language I&#x27;m using, I never mutate values.  Counters in loops or some other hyper-local variables (for performance) might be the inconsequential exceptions to this rule.<p>&gt; More functions help scopes stay small, and data flow is more explicit.<p>Just write your big function with local scope sections, if needed (another local exception to the rule above).  Eg, in JS:<p><pre><code>   let sectionReturnVal
   {
     &#x2F;&#x2F; stuff that sets sectionReturnVal
   }
</code></pre>
or even use IIFE to return the value and then you can use a const.  &quot;A function, you&#x27;re cheating!&quot; you might say, but my goal is not to avoid a particular language construct, but to maintain locality, and avoid unnecessary names and jumping around.<p>&gt; A side benefit is that &quot;more functions&quot; helps keep indentation down.<p>This is important and I maintain it.<p>See &quot;Align the happy path to the left&quot; (<a href="https:&#x2F;&#x2F;medium.com&#x2F;@matryer&#x2F;line-of-sight-in-code-186dd7cdea88" rel="nofollow noreferrer">https:&#x2F;&#x2F;medium.com&#x2F;@matryer&#x2F;line-of-sight-in-code-186dd7cdea...</a>)<p>It is also worth noting that solving this problem with function extraction can often be a merely aesthetic improvement.  That is, you will still need to keep hold the surrounding context (if not the state) in your head when reading the function to understand the whole picture, and the extraction makes that harder.<p>Using early returns correctly, by contrast, can actually alleviate working memory issues, since you can dismiss everything above as &quot;handling validation and errors&quot;.  That is, even though technically, no matter what you do, you are spidering down the branches of control flow, and therefore in some very specific context, the code organization can affect how much attention you need to pay to that context.<p>&gt; I don&#x27;t like functions that are too small, otherwise it&#x27;s hard to find out where any actual work gets done.<p>Precisely, just take this thinking to its logical conclusion.  You can (mostly) have your cake and eat it too.</div><br/></div></div><div id="37519426" class="c"><input type="checkbox" id="c-37519426" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#37517969">root</a><span>|</span><a href="#37519072">parent</a><span>|</span><a href="#37519522">prev</a><span>|</span><a href="#37517998">next</a><span>|</span><label class="collapse" for="c-37519426">[-]</label><label class="expand" for="c-37519426">[2 more]</label></div><br/><div class="children"><div class="content">The better solution to this is to use nested functions that are immediately called, rather than top level functions. That lets you cordon off chunks of state while still keeping a linear order of definition and execution. And you don&#x27;t have to worry about inadvertently increasing your API maintenance burden because people started to depend on those top level functions later.</div><br/><div id="37519546" class="c"><input type="checkbox" id="c-37519546" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#37517969">root</a><span>|</span><a href="#37519426">parent</a><span>|</span><a href="#37517998">next</a><span>|</span><label class="collapse" for="c-37519546">[-]</label><label class="expand" for="c-37519546">[1 more]</label></div><br/><div class="children"><div class="content">Ha, I started writing my reply before seeing yours, and suggested almost the same thing.</div><br/></div></div></div></div></div></div><div id="37517998" class="c"><input type="checkbox" id="c-37517998" checked=""/><div class="controls bullet"><span class="by">ryanjshaw</span><span>|</span><a href="#37517969">parent</a><span>|</span><a href="#37519072">prev</a><span>|</span><a href="#37518730">next</a><span>|</span><label class="collapse" for="c-37517998">[-]</label><label class="expand" for="c-37517998">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Only break it down into sub-functions when re-use requires it. Don&#x27;t do it solely for the sake of organization<p>What about for testing? What about for reducing state you need to keep in mind? What about releasing resources? What about understanding the impact of a change? Etc.<p>Consider an end of day process with 10 non-reusable steps that must run in order and each step is 100 lines. Each step uses similar data to the step before it so variables are similar but not the same. You would really choose a 1000 line single function?</div><br/><div id="37518103" class="c"><input type="checkbox" id="c-37518103" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#37517969">root</a><span>|</span><a href="#37517998">parent</a><span>|</span><a href="#37518222">next</a><span>|</span><label class="collapse" for="c-37518103">[-]</label><label class="expand" for="c-37518103">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What about for testing?<p>For &quot;use-case&quot; code like this with many steps, you are typically testing how things wire together, and so will either be injecting mocks to unit test, in which case it is not a problem, or wanting to integration or e2e test, in which case it is also not a problem.<p>If complex, purely logical computation is part of the larger function, and you can pull that part out into a pure function which can be easily unit tested without mocks, that is indeed a valid factoring which I support, and an exception to the general rule.<p>&gt; What about for reducing state you need to keep in mind?<p>Typically not a problem because if the function corresponds to a business use-case, you and everybody else is already thinking about it as &quot;one thing&quot;.<p>&gt; What about releasing resources?<p>Not a problem I have <i>ever once</i> run into with backend programming in garbage collected languages.  Obviously if you are in a different situation, YMMV.<p>&gt; Consider an end of day process with 30 non-reusable steps that must run in order and each step is 100 lines.<p>I would use my judgement and might break it down.  Again, I have never encountered such a situation in many years of programming.<p>You seem to be trying to find the (ime) rare exceptions as if those disprove the general rule.  But in practice the &quot;explode your holistic function unnecessarily into 10 parts&quot; is a much more common error than taking &quot;don&#x27;t break it down&quot; too far.</div><br/></div></div><div id="37518222" class="c"><input type="checkbox" id="c-37518222" checked=""/><div class="controls bullet"><span class="by">syntheweave</span><span>|</span><a href="#37517969">root</a><span>|</span><a href="#37517998">parent</a><span>|</span><a href="#37518103">prev</a><span>|</span><a href="#37518730">next</a><span>|</span><label class="collapse" for="c-37518222">[-]</label><label class="expand" for="c-37518222">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  let DebugFlags = {StepOne=false, StepTwo=false, StepThree=true};
  
  if (DebugFlags.StepOne) { ... }
  if (DebugFlags.StepTwo) { ... }
  if (DebugFlags.StepThree) { ... }
</code></pre>
Your training in structured, DRY and OOP will recoil at this: More branches! Impossible. But your spec says &quot;must run in order&quot;. It does this by design. Every resource can be tracked by reading it top to bottom, and the only way in which you can miss it is through a loop, which you can also aim to minimize usage of. The spec also says &quot;uses similar data to the step before it&quot;. If variables are similar-not-same, enclose them in curly braces so that you get some scope guarding. The debug flags contain the information needed to generate whatever test data is necessary. They can alternately be organized as enumerated state instead of booleans: {All, TestOne, TestTwo, TestThree}.<p>Long, bespoke linear sequences can be hairy, but the tools to deal with them are present in current production languages without atomizing the code into tiny functions. Occasionally you can find a useful pattern that does call for a new function, and do a &quot;harvest&quot; on the code and get its size down. But you have to be patient with it before you have a good sense of where a new parameterized function gets the right effect, and where inlining and flagging an existing one will do better.</div><br/></div></div></div></div></div></div><div id="37518730" class="c"><input type="checkbox" id="c-37518730" checked=""/><div class="controls bullet"><span class="by">jvans</span><span>|</span><a href="#37517969">prev</a><span>|</span><a href="#37518062">next</a><span>|</span><label class="collapse" for="c-37518730">[-]</label><label class="expand" for="c-37518730">[2 more]</label></div><br/><div class="children"><div class="content">In my experience the more familiar that someone is with the code, the more they think pushing code into smaller functions is the correct path. They have already built up a mental model of the code at hand, so the cleanest implementation to <i>them</i> is one with very few lines.<p>But the next person to come along has to bounce back and forth, performing mental stack push&#x2F;pop operations to create the same mental model which is much harder to do when you don&#x27;t have any of the original context</div><br/><div id="37519869" class="c"><input type="checkbox" id="c-37519869" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#37518730">parent</a><span>|</span><a href="#37518062">next</a><span>|</span><label class="collapse" for="c-37519869">[-]</label><label class="expand" for="c-37519869">[1 more]</label></div><br/><div class="children"><div class="content">Not if the code makes sense. If the code is well written with elegant abstractions, slim interfaces and decent documentation, you often don&#x27;t need to bounce around that much. For example how often do you read source code of your language&#x27;s standard library? I almost never do, I mostly just look at method signatures and maybe read some docs if it&#x27;s a bit complex or new.<p>The whole point of interfaces is that you&#x27;re not supposed to care how a method is implemented, only what it does which is explained by a combination of context, naming and documentation. But a lot of devs don&#x27;t understand(or care about) this, so they write code that doesn&#x27;t make sense and then it doesn&#x27;t matter whether they made it linear or modular. They do things like make a service class where you have to call one method to get some data and then you have to call another to get some other data and then you have to call a third method to get some data that needs to be consolidated with the other two and now what the hell is the point of your service? It exposes all the internal complexity to the outside.<p>You aren&#x27;t supposed to <i>force</i> small methods, there&#x27;s no point having 20 ~5-line functions that are all only called once and do super specific stuff and have to be called in the right order etc. That&#x27;s not clean code, that&#x27;s more like cargo cult programming. You are supposed to abstract things appropriately so that they make sense both to new and seasoned team members, are easy to reason about and hide complexity in places where the complexity makes sense.<p>This is not easy to do but it is possible.</div><br/></div></div></div></div><div id="37518062" class="c"><input type="checkbox" id="c-37518062" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37518730">prev</a><span>|</span><a href="#37518230">next</a><span>|</span><label class="collapse" for="c-37518062">[-]</label><label class="expand" for="c-37518062">[1 more]</label></div><br/><div class="children"><div class="content">They both read linearly. In the version with smaller functions taken out, there&#x27;s a table of contents at the top of the page and it summarizes the dataflow between the steps. It seems like an appealing read order, assuming you&#x27;re going to read the whole thing.<p>For it to stay this readable, though, you&#x27;d need to move the functions around if you change the order of the steps. And that&#x27;s fine if they&#x27;re private functions, called only from the table of contents. Only, nothing forces you to keep them in order, or even to think about how it reads overall.<p>It often happens that functions start being reused in a way that can&#x27;t be linearized anymore. Sometimes people give up and sort them alphabetically, or it&#x27;s just random.</div><br/></div></div><div id="37518230" class="c"><input type="checkbox" id="c-37518230" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#37518062">prev</a><span>|</span><a href="#37519062">next</a><span>|</span><label class="collapse" for="c-37518230">[-]</label><label class="expand" for="c-37518230">[4 more]</label></div><br/><div class="children"><div class="content">The code that is more easily unit testable, is the code I care about.<p>Neither example is easily tested.<p>Neither support injecting the dependencies, which make mocking really difficult.<p>On the left, you&#x27;re testing one big method with a whole bunch of conditionals, which leaves you with a whole ton of tests for that one big method.<p>On the right, there is a bake() method and it does oven.New(), but where does oven come from? Is it some global somewhere?</div><br/><div id="37518315" class="c"><input type="checkbox" id="c-37518315" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#37518230">parent</a><span>|</span><a href="#37518596">next</a><span>|</span><label class="collapse" for="c-37518315">[-]</label><label class="expand" for="c-37518315">[2 more]</label></div><br/><div class="children"><div class="content">Here is an idea for a unit test for this code.<p>Pass in an order, assert the pizza that comes out is correct.<p>The entire function is a unit which can fit on my phone screen and has no external dependencies other than possibly oven, which was discussed in the article, it should probably have been passed in, aka dependency injection.</div><br/><div id="37518367" class="c"><input type="checkbox" id="c-37518367" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#37518230">root</a><span>|</span><a href="#37518315">parent</a><span>|</span><a href="#37518596">next</a><span>|</span><label class="collapse" for="c-37518367">[-]</label><label class="expand" for="c-37518367">[1 more]</label></div><br/><div class="children"><div class="content">Since the example was golang, I personally love uberFX to define modules and dependencies between modules.  When you do it that way, unit tests become really easy.<p>It isn&#x27;t necessary with golang to do this at all, but it really helps build consistent structure throughout the entire app, so I do it.<p>Speaking from personal experience. I built a small golang process that ran on around 25k worker machines. It had to be bug free cause if it crashed and stopped running, it meant updating a whole lot of computers across multiple data centers, by hand.<p>We unit tested everything and the project worked out really well because of that.</div><br/></div></div></div></div><div id="37518596" class="c"><input type="checkbox" id="c-37518596" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#37518230">parent</a><span>|</span><a href="#37518315">prev</a><span>|</span><a href="#37519062">next</a><span>|</span><label class="collapse" for="c-37518596">[-]</label><label class="expand" for="c-37518596">[1 more]</label></div><br/><div class="children"><div class="content">unit test is overrated because most of the problems can be solved via correct by construction methods. Like, do you really need to check if this &quot;kind&quot; variable is equal to &quot;Veg&quot;? This could have easily been solved by using Enum. Similarly, global or not can be solved by using classes&#x2F;structs that don&#x27;t have any constructors or something like that.<p>Functions should exist at the level of concepts:<p>1. arr | flat | map | collect as HashMap makes sense.<p>2. CreateFlattenMappedHashMapFromArr does not.</div><br/></div></div></div></div><div id="37519062" class="c"><input type="checkbox" id="c-37519062" checked=""/><div class="controls bullet"><span class="by">okaleniuk</span><span>|</span><a href="#37518230">prev</a><span>|</span><a href="#37520102">next</a><span>|</span><label class="collapse" for="c-37519062">[-]</label><label class="expand" for="c-37519062">[2 more]</label></div><br/><div class="children"><div class="content">This &quot;level of abstraction&quot; euphemism actually means &quot;the level at which I&#x27;m not reading code anymore even and especially if I should&quot;. Of course, linear code is more readable! Linear everything is more readable. Have you ever seen a novel with &quot;levels of abstraction&quot; in it?<p>But nobody reads the code anymore. Why bother? You&#x27;re not going to stay on a single project for long enough for the attention investment to pay off. So the common best practice at the moment is to pretend that you read the code without actually reading it. For this purpose, the green code is much much better.</div><br/><div id="37519225" class="c"><input type="checkbox" id="c-37519225" checked=""/><div class="controls bullet"><span class="by">japanuspus</span><span>|</span><a href="#37519062">parent</a><span>|</span><a href="#37520102">next</a><span>|</span><label class="collapse" for="c-37519225">[-]</label><label class="expand" for="c-37519225">[1 more]</label></div><br/><div class="children"><div class="content">I realize this is tongue in cheek, but really: Read code!<p>If you ever start plateauing in your code skills, start digging into the code of your favorite open source project. Accept that things have been done in another way than you would for a reason and try to understand that reason.<p>Try joining advent of code[0], and make sure to spend half you time block on reading and understanding alternative solutions.<p>[0]: <a href="https:&#x2F;&#x2F;adventofcode.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;adventofcode.com&#x2F;</a></div><br/></div></div></div></div><div id="37520102" class="c"><input type="checkbox" id="c-37520102" checked=""/><div class="controls bullet"><span class="by">al_be_back</span><span>|</span><a href="#37519062">prev</a><span>|</span><a href="#37520106">next</a><span>|</span><label class="collapse" for="c-37520102">[-]</label><label class="expand" for="c-37520102">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; this code makes no sense: why would you create a whole new oven to make a pizza? in real life...<p>one can rationalize all sorts, but certain real-life metaphors don&#x27;t have to map closely to the digital realm.<p>if my CreatePizza function relies on remote&#x2F;dynamic code&#x2F;features (realtime functionality), then it&#x27;s simpler and possibly safer to re-create than re-use. Depends on the use-case.</div><br/></div></div><div id="37520106" class="c"><input type="checkbox" id="c-37520106" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#37520102">prev</a><span>|</span><a href="#37517950">next</a><span>|</span><label class="collapse" for="c-37520106">[-]</label><label class="expand" for="c-37520106">[1 more]</label></div><br/><div class="children"><div class="content">I can imagine a new control statement with this type of syntax:<p><pre><code>  code
  code
  uses (a, b, c, d) { &#x2F;&#x2F; Step 5: Foo the bar
    code
    code
  }
  more code
  more code
</code></pre>
It&#x27;s a block that defines the variables it uses, with no other access to the outer scope. It would help break up a linear function into blocks with clearer dependencies.</div><br/></div></div><div id="37517950" class="c"><input type="checkbox" id="c-37517950" checked=""/><div class="controls bullet"><span class="by">realrains</span><span>|</span><a href="#37520106">prev</a><span>|</span><a href="#37519107">next</a><span>|</span><label class="collapse" for="c-37517950">[-]</label><label class="expand" for="c-37517950">[1 more]</label></div><br/><div class="children"><div class="content">Mixing different levels of abstraction makes the code harder to understand. Linear code is probably good because the examples in the body are simple. It&#x27;s one thing to separate code into separate files, but it&#x27;s another to break up code snippets in one file.</div><br/></div></div><div id="37519107" class="c"><input type="checkbox" id="c-37519107" checked=""/><div class="controls bullet"><span class="by">kristjank</span><span>|</span><a href="#37517950">prev</a><span>|</span><a href="#37519680">next</a><span>|</span><label class="collapse" for="c-37519107">[-]</label><label class="expand" for="c-37519107">[1 more]</label></div><br/><div class="children"><div class="content">I have been working on a system for programming some specialty hardware on customer premises for a while, and most of it was written in a pseudo-language implemented by another backend programmer. Think BASIC-like implements in a YAML file, with arbitrary python inserts here and there.<p>Despite the code being not very visually attractive (long corridors of imperative statements reading and writing from SMBus addresses), I was always surprised how easy it was to maintain the code, and how quickly I could get back &quot;in the zone&quot; after not working on it for months.<p>There is something painfully trivial about old clunky languages that makes them somewhat easier to get back into. The cost in abstraction capabilities is obvious though. The only reason I can afford to write concise, linear, imperative code for this project is its narrow, specialized scope that most of modern programs cannot afford to limit themselves to anymore.</div><br/></div></div><div id="37519680" class="c"><input type="checkbox" id="c-37519680" checked=""/><div class="controls bullet"><span class="by">agigao</span><span>|</span><a href="#37519107">prev</a><span>|</span><a href="#37519823">next</a><span>|</span><label class="collapse" for="c-37519680">[-]</label><label class="expand" for="c-37519680">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps we can try to do it in a proper functional language?<p><pre><code>  (ns restaurant.pizza
    (:require [restaurant.oven :as oven]
              [restaurant.package :as pack]))

  (defn make-order [size sauce cheese kind]
    {:size size
     :sauce sauce
     :cheese cheese
     :kind kind})

  (def toppings-map
    {&quot;Veg&quot; &quot;Veg toppings&quot;
     &quot;Meat&quot; &quot;Meat toppings&quot;})

  (defn prepare [order]
    (assoc order :toppings (:kind order)))

  (defn bake [prepared-order]
    (oven&#x2F;bake prepared-order :pizza))

  (defn box [baked-pizza]
    (pack&#x2F;box baked-pizza :pizza))

  (defn pizza [order]
    (-&gt; order
        prepare
        bake
        box))

  (comment 
    (def order (make-order 26 &quot;Tomato&quot; &quot;Mozzarella&quot; &quot;Meat&quot;))
    (pizza order))


</code></pre>
It&#x27;s short and overwhelmingly granular, but for the sake of illustration. Large and complex codebases sliced up this way has not alternative in terms of ease of testing and reasoning about the code.</div><br/></div></div><div id="37519823" class="c"><input type="checkbox" id="c-37519823" checked=""/><div class="controls bullet"><span class="by">al05</span><span>|</span><a href="#37519680">prev</a><span>|</span><a href="#37517502">next</a><span>|</span><label class="collapse" for="c-37519823">[-]</label><label class="expand" for="c-37519823">[1 more]</label></div><br/><div class="children"><div class="content">I still prefer the one the right. I&#x27;m able to skip entire sections of code, and assume what the function does. Only if I require details do I go deeper.<p>The comments are metadata, and where function names are tied into the code. One is going to stay up to date. The other isn&#x27;t.</div><br/></div></div><div id="37517502" class="c"><input type="checkbox" id="c-37517502" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#37519823">prev</a><span>|</span><a href="#37519153">next</a><span>|</span><label class="collapse" for="c-37517502">[-]</label><label class="expand" for="c-37517502">[6 more]</label></div><br/><div class="children"><div class="content">I agree. I really hate having to jump all over a file (or multiple files!) for something that could fit into a single page of linear code.</div><br/><div id="37517727" class="c"><input type="checkbox" id="c-37517727" checked=""/><div class="controls bullet"><span class="by">Jeff_Brown</span><span>|</span><a href="#37517502">parent</a><span>|</span><a href="#37517720">next</a><span>|</span><label class="collapse" for="c-37517727">[-]</label><label class="expand" for="c-37517727">[3 more]</label></div><br/><div class="children"><div class="content">Someone smart said, &quot;When you&#x27;ve lost something, and finally find it, don&#x27;t put it there again. Instead put it the first place you looked.&quot;<p>I think that applies to code. When I read something I wrote, if I&#x27;m annoyed at how it reads, I try to refactor it to be what I wanted to read, and remember to do it that way in the future.<p>But sometimes what the reader wants is too much work for the writer, so I don&#x27;t push that effort beyond what it&#x27;s worth.</div><br/><div id="37518326" class="c"><input type="checkbox" id="c-37518326" checked=""/><div class="controls bullet"><span class="by">gabereiser</span><span>|</span><a href="#37517502">root</a><span>|</span><a href="#37517727">parent</a><span>|</span><a href="#37517720">next</a><span>|</span><label class="collapse" for="c-37518326">[-]</label><label class="expand" for="c-37518326">[2 more]</label></div><br/><div class="children"><div class="content">There’s a whole style of coding dedicated to that very notion. It’s called test driven development.</div><br/><div id="37519096" class="c"><input type="checkbox" id="c-37519096" checked=""/><div class="controls bullet"><span class="by">BigJ1211</span><span>|</span><a href="#37517502">root</a><span>|</span><a href="#37518326">parent</a><span>|</span><a href="#37517720">next</a><span>|</span><label class="collapse" for="c-37519096">[-]</label><label class="expand" for="c-37519096">[1 more]</label></div><br/><div class="children"><div class="content">I don’t agree that’s what TDD does. You spent inordinate amounts thinking about how you should want it to be, when you could just write it, find where and what about it you dislike, write it again and have actual good code. Also called WET. You spend less time with better results that way and you gain what OP was talking about in the process.</div><br/></div></div></div></div></div></div><div id="37517720" class="c"><input type="checkbox" id="c-37517720" checked=""/><div class="controls bullet"><span class="by">meitham</span><span>|</span><a href="#37517502">parent</a><span>|</span><a href="#37517727">prev</a><span>|</span><a href="#37518460">next</a><span>|</span><label class="collapse" for="c-37517720">[-]</label><label class="expand" for="c-37517720">[1 more]</label></div><br/><div class="children"><div class="content">I agree too.  Another example: I find early returns in functions easier to read than “else” with one “return” at the end.  Basically vertically linear code as opposed to unnecessary branches and too much indentation, keeping the code slimmer is healthier!</div><br/></div></div><div id="37518460" class="c"><input type="checkbox" id="c-37518460" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#37517502">parent</a><span>|</span><a href="#37517720">prev</a><span>|</span><a href="#37519153">next</a><span>|</span><label class="collapse" for="c-37518460">[-]</label><label class="expand" for="c-37518460">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also a naming issue. A good name means I don&#x27;t have to jump.</div><br/></div></div></div></div><div id="37519153" class="c"><input type="checkbox" id="c-37519153" checked=""/><div class="controls bullet"><span class="by">siddharthgoel88</span><span>|</span><a href="#37517502">prev</a><span>|</span><a href="#37519914">next</a><span>|</span><label class="collapse" for="c-37519153">[-]</label><label class="expand" for="c-37519153">[1 more]</label></div><br/><div class="children"><div class="content">I noticed that people have already contributed great insights on readability and testability aspects which were my first thoughts as well on reading this blog.<p>However, I do believe that there is no one right answer to this argument. And the right answer is with that team who in the end have to read, write and maintain that code. The metrics that I collect with my co-workers who work on same code base as me are<p><pre><code>  * What is the cognitive load to grasp the code for members in the team?  
  * How easy is it to onboard a new member to this team?
  * Are we able to move fast and have confidence in the code changes we make?
</code></pre>
In my opinion, metrics like these are usually the ones most of us care about in the end.</div><br/></div></div><div id="37519914" class="c"><input type="checkbox" id="c-37519914" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#37519153">prev</a><span>|</span><a href="#37518152">next</a><span>|</span><label class="collapse" for="c-37519914">[-]</label><label class="expand" for="c-37519914">[1 more]</label></div><br/><div class="children"><div class="content">The problem with code styles is that most developers can only reason about information systems, where the only thing your code has to do is dispatch the right data to the right place.<p>As soon as you try and write a function that actually uses the data, you find out that every book has been written for CRUD application programmers.</div><br/></div></div><div id="37518152" class="c"><input type="checkbox" id="c-37518152" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#37519914">prev</a><span>|</span><a href="#37518424">next</a><span>|</span><label class="collapse" for="c-37518152">[-]</label><label class="expand" for="c-37518152">[2 more]</label></div><br/><div class="children"><div class="content">I find Linear B more readable than Linear A, but I agree with the OP, if there were additional explanatory comments in Linear A code, then it would be probably more readable than Linear B.</div><br/><div id="37518202" class="c"><input type="checkbox" id="c-37518202" checked=""/><div class="controls bullet"><span class="by">vulcan01</span><span>|</span><a href="#37518152">parent</a><span>|</span><a href="#37518424">next</a><span>|</span><label class="collapse" for="c-37518202">[-]</label><label class="expand" for="c-37518202">[1 more]</label></div><br/><div class="children"><div class="content">This is not a constructive comment. I just want to say that I appreciate this joke, it&#x27;s pretty funny.</div><br/></div></div></div></div><div id="37518424" class="c"><input type="checkbox" id="c-37518424" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#37518152">prev</a><span>|</span><a href="#37519226">next</a><span>|</span><label class="collapse" for="c-37518424">[-]</label><label class="expand" for="c-37518424">[3 more]</label></div><br/><div class="children"><div class="content">I feel like there a happy medium between the two, the left can easily be made more simple by factoring out one or two functions however the right went too far.<p>The prepare and addtoppings functions should be one function, prepare effectively just fills in a struct and calls add toppings, its pointless to seperare them.<p>The Bake function simply prepares the over for cooking, which the author mentioned should be a dependency with a method and then factors 4 lines of code into a new function for no reason. The bake and bake pizza function should be one function.<p>You can then keep the box function as is.<p>That would be both easier to maintain and easier to read.</div><br/><div id="37518555" class="c"><input type="checkbox" id="c-37518555" checked=""/><div class="controls bullet"><span class="by">erhaetherth</span><span>|</span><a href="#37518424">parent</a><span>|</span><a href="#37519226">next</a><span>|</span><label class="collapse" for="c-37518555">[-]</label><label class="expand" for="c-37518555">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You can then keep the box function as is.<p>The box function is broken too. You box the pizza and then return the pizza...but the box is logically a wrapper for the pizza. `box(pizza)` should return a boxed pizza. A box with contents=[pizza]. Maybe some sauce and pepperoncini in there too.<p>Plus all these functions are impure. Which isn&#x27;t always bad but if you can prevent things like boxing it before baking it, you should.<p>And what even... this entire example is just horrendous. You box the pizza and <i>then</i> slice the pizza? Ready = box.Close()? Can the Close() operation fail? And then the pizza is not ready? Why not throw an error, now the caller has to check if the pizza that got returned to them is even ready...? And that fact is even more hidden on the right side. Same for Sliced and Boxed.</div><br/><div id="37518781" class="c"><input type="checkbox" id="c-37518781" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#37518424">root</a><span>|</span><a href="#37518555">parent</a><span>|</span><a href="#37519226">next</a><span>|</span><label class="collapse" for="c-37518781">[-]</label><label class="expand" for="c-37518781">[1 more]</label></div><br/><div class="children"><div class="content">This entire function is clearly a factory for a boxed pizza with toppings which is baked.<p>I&#x27;d argue the entire box.Close() method is slideware and wouldn&#x27;t exist since it likely is just a return true. You can just as easily just say pizza.Ready = true. Reading this code afterwards I would think there was some stupid requirement somewhere for a pizza.Ready property so someone added it and would check a commit log to see if it can just be removed.<p>Decent catch there though, the box can also be a dependency that get&#x27;s passed in.</div><br/></div></div></div></div></div></div><div id="37519226" class="c"><input type="checkbox" id="c-37519226" checked=""/><div class="controls bullet"><span class="by">justanotherjoe</span><span>|</span><a href="#37518424">prev</a><span>|</span><a href="#37517878">next</a><span>|</span><label class="collapse" for="c-37519226">[-]</label><label class="expand" for="c-37519226">[1 more]</label></div><br/><div class="children"><div class="content">Sure, you can put A, B, C, D side by side.  But next time if you need to find D, you have to navigate A &gt; B &gt; C &gt; D, with no other recourse.  Often, you don&#x27;t care about A, B, or C.  Only D.  And the benefit of A, B, C, and D being close together becomes immaterial.<p>In real systems where things are spread, A, B, C, and D can be very far apart indeed.  And it&#x27;s totally fine!  What matters is that from the starting position,let&#x27;s say X, I can &#x27;navigate&#x27; to A, B, C, or D, in an equal and speedy manner.<p>Plus human brains love to navigate things in a &#x27;spatial&#x27; way like this.  It&#x27;s natural.  Really when you think about it, the perceived loss here is not that big compared to the benefits.</div><br/></div></div><div id="37517878" class="c"><input type="checkbox" id="c-37517878" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37519226">prev</a><span>|</span><a href="#37518943">next</a><span>|</span><label class="collapse" for="c-37517878">[-]</label><label class="expand" for="c-37517878">[5 more]</label></div><br/><div class="children"><div class="content">If you never have to write any tests, perhaps this is ok.</div><br/><div id="37518001" class="c"><input type="checkbox" id="c-37518001" checked=""/><div class="controls bullet"><span class="by">yCombLinks</span><span>|</span><a href="#37517878">parent</a><span>|</span><a href="#37518943">next</a><span>|</span><label class="collapse" for="c-37518001">[-]</label><label class="expand" for="c-37518001">[4 more]</label></div><br/><div class="children"><div class="content">What do you mean never write any tests? The api should be the same. Order goes in, pizza comes out. The rest is implementation details that should not be exposed to a test.</div><br/><div id="37518102" class="c"><input type="checkbox" id="c-37518102" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#37517878">root</a><span>|</span><a href="#37518001">parent</a><span>|</span><a href="#37518943">next</a><span>|</span><label class="collapse" for="c-37518102">[-]</label><label class="expand" for="c-37518102">[3 more]</label></div><br/><div class="children"><div class="content">you&#x27;re right, the api for ordering a pizza will probably stay the same.<p>the cooking process won&#x27;t though. stuffed crust? add some stuff in the middle. square? add some stuff in the middle. deep dish? add some stuff in the middle.<p>iterate a while and your &quot;one golden test&quot; is what falls down.</div><br/><div id="37518617" class="c"><input type="checkbox" id="c-37518617" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#37517878">root</a><span>|</span><a href="#37518102">parent</a><span>|</span><a href="#37518469">next</a><span>|</span><label class="collapse" for="c-37518617">[-]</label><label class="expand" for="c-37518617">[1 more]</label></div><br/><div class="children"><div class="content">YAGNI<p>Refactor when those things are needed, right now the cooking process is stick it in a warm over for x minutes.<p>What are you testing there?<p>The oven was preheated? Put in an assert, that doesn&#x27;t need a test.<p>That it stayed in for x minutes? You assuming the builtin sleep function is broken? Don&#x27;t test library code, that&#x27;s not your job.<p>That the oven actually preheated correctly, that was discussed in the article, the oven and it&#x27;s preheat method should be a dependency that gets passed in, again not needed to be tested here.<p>Also in your example you are testing whether an if condition was evaluated as true.<p>Give me an example of a stuffed crust pizza cooking process that has a unit test which cannot be checked by looking at the resulting pizza.</div><br/></div></div><div id="37518469" class="c"><input type="checkbox" id="c-37518469" checked=""/><div class="controls bullet"><span class="by">yCombLinks</span><span>|</span><a href="#37517878">root</a><span>|</span><a href="#37518102">parent</a><span>|</span><a href="#37518617">prev</a><span>|</span><a href="#37518943">next</a><span>|</span><label class="collapse" for="c-37518469">[-]</label><label class="expand" for="c-37518469">[1 more]</label></div><br/><div class="children"><div class="content">Those items are all testable through the createPizza method. There should be lots of tests! You&#x27;ve made up the one golden test scenario as a strawman. Every scenario you listed changes the expected output(the pizza). If you are testing internal methods, your tests are going to tell you you have broken, even if the pizzas created are 100% correct. So people won&#x27;t clean the code, because the tests break, and they don&#x27;t know if they are actually broken.</div><br/></div></div></div></div></div></div></div></div><div id="37518943" class="c"><input type="checkbox" id="c-37518943" checked=""/><div class="controls bullet"><span class="by">Roark66</span><span>|</span><a href="#37517878">prev</a><span>|</span><label class="collapse" for="c-37518943">[-]</label><label class="expand" for="c-37518943">[1 more]</label></div><br/><div class="children"><div class="content">I too find the code on the left&#x2F;red (linear) more readable. However the version with all the functions is quite extreme. When I&#x27;m splitting my code into functions I decide if something should be it&#x27;s own function on the basis of: is this chunk of functionality required to be reusable? Am I repeating code, only slightly changed?<p>If the answer is yes, a function gets created. I never do what I assume authors did here, find the smallest logical units code can split into and generate a bajillion functions. I&#x27;m not paid by the line of code after all.<p>The same reason makes me like object programming (especially inheritance, abstract functions, operator overloading). IMO with a good IDE such code is much more succinct(within the constraints of the language) and more readable, but taking it to extreme is a mistake.</div><br/></div></div></div></div></div></div></div></body></html>