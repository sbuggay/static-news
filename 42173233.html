<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732006876076" as="style"/><link rel="stylesheet" href="styles.css?v=1732006876076"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.joshtumath.uk/posts/2024-11-08-how-a-bbc-navigation-bar-component-broke-depending-on-which-external-monitor-it-was-on/">A BBC navigation bar component broke depending on the external monitor</a> <span class="domain">(<a href="https://www.joshtumath.uk">www.joshtumath.uk</a>)</span></div><div class="subtext"><span>ulrischa</span> | <span>109 comments</span></div><br/><div><div id="42174177" class="c"><input type="checkbox" id="c-42174177" checked=""/><div class="controls bullet"><span class="by">nozzlegear</span><span>|</span><a href="#42174016">next</a><span>|</span><label class="collapse" for="c-42174177">[-]</label><label class="expand" for="c-42174177">[40 more]</label></div><br/><div class="children"><div class="content">For anyone who didn&#x27;t click through to the WebKit bug report the author submitted, a WebKit dev asked him to clarify why the BBC finds it beneficial to be able to detect that the event was sent from a keyboard. This is the author&#x27;s response:<p>&gt; <i>Ironically, I want interoperability on this to help with use cases relating to accessibility.</i><p>&gt; <i>I work at the BBC and, on our UK website, our navigation bar menu button behaves slightly differently depending on if it is opened with a pointer or keyboard. The click event will always open the menu, but:</i><p>&gt; - <i>when opening with a pointer, the focus moves to the menu container.</i><p>&gt; - <i>when opening with a keyboard, there is no animation to open the menu and the focus moves to the first link in the menu.</i><p>&gt; <i>Often when opening a menu, we don&#x27;t want a slightly different behaviour around focus and animations depending on if the user &#x27;clicks&#x27; with a pointer or keyboard.</i><p>&gt; <i>The &#x27;click&#x27; event is great when creating user experiences for keyboard users because it is device independent. On keyboards, it is only invoked by Space or Enter key presses. If we were to use the keydown event, we would have to check whether only the the Space or Enter keys were pressed.</i><p>Source: <a href="https:&#x2F;&#x2F;bugs.webkit.org&#x2F;show_bug.cgi?id=281430" rel="nofollow">https:&#x2F;&#x2F;bugs.webkit.org&#x2F;show_bug.cgi?id=281430</a></div><br/><div id="42175176" class="c"><input type="checkbox" id="c-42175176" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#42174177">parent</a><span>|</span><a href="#42174511">next</a><span>|</span><label class="collapse" for="c-42175176">[-]</label><label class="expand" for="c-42175176">[12 more]</label></div><br/><div class="children"><div class="content">This is fascinating, because the naive English interpretation of the code and the comment on that WebKit bug don&#x27;t match the actual structure of the code.  Here&#x27;s the relevant code:<p><pre><code>    const isInvokedByMouse = event =&gt; event.screenX &gt; 0 || event.screenY &gt; 0;
    const isInvokedByKeyboard = event =&gt; isEnterKey(event) || isSpaceKey(event);
</code></pre>
Ignoring the actual conditions entirely, this code seems to be trying to categorize the event into one of two categories: mouse or keyboard.  But what it actually does is to categorize into one of four categories:  (mouse and not keyboard), (keyboard and not mouse), (keyboard and mouse), and (neither keyboard nor mouse).  And, as the original bug shows, (neither keyboard nor mouse) is handled inappropriately.  One might wonder whether (keyboard and mouse) works well.<p>Either the code should be deliberate about the fact that (is it a keyboard) and (is it a mouse) are separate booleans, or the code should be structured so that the actual categories are mutually exclusive.  For example:<p><pre><code>    const isInvokedByMouse = ...
</code></pre>
and use !isInvokedByMouse to check for keyboardiness, or:<p><pre><code>    const eventSource = ... (returns &quot;keyboard&quot; or &quot;mouse&quot;)
</code></pre>
or, perhaps even better:<p><pre><code>    const eventSource = ... (returns &quot;keyboard&quot;, &quot;mouse&quot;, or &quot;not sure&quot;)</code></pre></div><br/><div id="42176623" class="c"><input type="checkbox" id="c-42176623" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42175176">parent</a><span>|</span><a href="#42177520">next</a><span>|</span><label class="collapse" for="c-42176623">[-]</label><label class="expand" for="c-42176623">[8 more]</label></div><br/><div class="children"><div class="content">This is a great comment ^ whenever you use two booleans like this, you&#x27;re opening yourself up to &quot;unrepresentable state&quot; logic errors. Finding and noticing this in code can be tricky, but it&#x27;s a great example of something that should be caught during code review.</div><br/><div id="42177164" class="c"><input type="checkbox" id="c-42177164" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42176623">parent</a><span>|</span><a href="#42177520">next</a><span>|</span><label class="collapse" for="c-42177164">[-]</label><label class="expand" for="c-42177164">[7 more]</label></div><br/><div class="children"><div class="content">Not sure if exactly the same thing but reminds me of &quot;Booleans are a trap&quot;<p><a href="https:&#x2F;&#x2F;katafrakt.me&#x2F;2024&#x2F;11&#x2F;09&#x2F;booleans-are-a-trap&#x2F;" rel="nofollow">https:&#x2F;&#x2F;katafrakt.me&#x2F;2024&#x2F;11&#x2F;09&#x2F;booleans-are-a-trap&#x2F;</a></div><br/><div id="42179492" class="c"><input type="checkbox" id="c-42179492" checked=""/><div class="controls bullet"><span class="by">lvturner</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42177164">parent</a><span>|</span><a href="#42178236">next</a><span>|</span><label class="collapse" for="c-42179492">[-]</label><label class="expand" for="c-42179492">[1 more]</label></div><br/><div class="children"><div class="content"><i>Wait—that last state doesn&#x27;t make sense. With a real door, you can technically turn the key while it&#x27;s open, but does that meaningfully change its state? Yet our model allows this impossible combination.</i><p>Funnily enough, I have a physical door &amp; lock that OFTEN gets in to this state - it&#x27;s exactly as irritating as it sounds, and it has very meaningful impact on it&#x27;s state (it then can&#x27;t be closed without first unlocking the lock!)</div><br/></div></div><div id="42178236" class="c"><input type="checkbox" id="c-42178236" checked=""/><div class="controls bullet"><span class="by">iwontberude</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42177164">parent</a><span>|</span><a href="#42179492">prev</a><span>|</span><a href="#42177520">next</a><span>|</span><label class="collapse" for="c-42178236">[-]</label><label class="expand" for="c-42178236">[5 more]</label></div><br/><div class="children"><div class="content">Yet another article prematurely optimizing. It’s like these people have nothing better to do. I’ll wait for my code to get into stupid edge cases first and then fix it. Even if you spend your time avoiding booleans you will still find yourself with some new contradictory state and have to fix it differently anyways.</div><br/><div id="42178795" class="c"><input type="checkbox" id="c-42178795" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42178236">parent</a><span>|</span><a href="#42179765">next</a><span>|</span><label class="collapse" for="c-42178795">[-]</label><label class="expand" for="c-42178795">[1 more]</label></div><br/><div class="children"><div class="content">Coming up with proper representation for your state is almost always worth it. If anything it&#x27;s the opposite of premature optimisation - normalise first, only denormalise after you&#x27;ve proven that it&#x27;s needed.</div><br/></div></div><div id="42179765" class="c"><input type="checkbox" id="c-42179765" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42178236">parent</a><span>|</span><a href="#42178795">prev</a><span>|</span><a href="#42178418">next</a><span>|</span><label class="collapse" for="c-42179765">[-]</label><label class="expand" for="c-42179765">[2 more]</label></div><br/><div class="children"><div class="content">The issue isn’t booleans the issue is that the code doesn’t handle all the states described by the two booleans, when all are possible.</div><br/><div id="42180130" class="c"><input type="checkbox" id="c-42180130" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42179765">parent</a><span>|</span><a href="#42178418">next</a><span>|</span><label class="collapse" for="c-42180130">[-]</label><label class="expand" for="c-42180130">[1 more]</label></div><br/><div class="children"><div class="content">Make the impossible states unrepresentable using an enum of only the possible boolean combinations.</div><br/></div></div></div></div><div id="42178418" class="c"><input type="checkbox" id="c-42178418" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42178236">parent</a><span>|</span><a href="#42179765">prev</a><span>|</span><a href="#42177520">next</a><span>|</span><label class="collapse" for="c-42178418">[-]</label><label class="expand" for="c-42178418">[1 more]</label></div><br/><div class="children"><div class="content">Huh?  This isn’t premature optimization unless you consider trying to write correct code “optimizing”.</div><br/></div></div></div></div></div></div></div></div><div id="42177520" class="c"><input type="checkbox" id="c-42177520" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42175176">parent</a><span>|</span><a href="#42176623">prev</a><span>|</span><a href="#42179647">next</a><span>|</span><label class="collapse" for="c-42177520">[-]</label><label class="expand" for="c-42177520">[1 more]</label></div><br/><div class="children"><div class="content">And just to add an extra corner case, Mobile Safari changes the click behavior if an onclick handler is registered - even if the click handler is an empty function that does nothing. The onclick handler itself acts as another Boolean that affects the browser&#x27;s behavior. I don&#x27;t remember the exact details because it was a corner case (I think to do with scrolling or popovers or touchcancel - I know it was surprisingly nasty). This page mentions something else <a href="http:&#x2F;&#x2F;www.quirksmode.org&#x2F;blog&#x2F;archives&#x2F;2010&#x2F;09&#x2F;click_event_del.html" rel="nofollow">http:&#x2F;&#x2F;www.quirksmode.org&#x2F;blog&#x2F;archives&#x2F;2010&#x2F;09&#x2F;click_event_...</a> &quot;Fortunately it’s pretty easy to solve: you have to make the element clickable by giving it an onclick event handler of its very own. That handler can be empty; as long as it’s present it will make any element clickable.&quot;.</div><br/></div></div><div id="42179647" class="c"><input type="checkbox" id="c-42179647" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42175176">parent</a><span>|</span><a href="#42177520">prev</a><span>|</span><a href="#42174511">next</a><span>|</span><label class="collapse" for="c-42179647">[-]</label><label class="expand" for="c-42179647">[2 more]</label></div><br/><div class="children"><div class="content">Well said. I usually go through several phases when dealing with this kind of thing, I start with &quot;flags for different conditions&quot; type logic, then when things get too complex I refine this into &quot;set of explicitly defined states&quot;, and then as the state code evolves from &#x27;ideal happy path&#x27; to &#x27;production-tested code&#x27; I gradually realise that most of the original combinations represented by the original flags actually CAN happen in weird edge-cases.</div><br/><div id="42180092" class="c"><input type="checkbox" id="c-42180092" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42179647">parent</a><span>|</span><a href="#42174511">next</a><span>|</span><label class="collapse" for="c-42180092">[-]</label><label class="expand" for="c-42180092">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;set of explicitly defined states&quot;<p>this is called algebraic data type (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Algebraic_data_type" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Algebraic_data_type</a>), and it is the best way, imho, to reduce bugs in code.<p>By making it easy to pattern match, it reduces the possiblity of producing an invalid state, because at the time of definition, you have to figure out how to get that type (and checked by compiler).</div><br/></div></div></div></div></div></div><div id="42174511" class="c"><input type="checkbox" id="c-42174511" checked=""/><div class="controls bullet"><span class="by">O-stevns</span><span>|</span><a href="#42174177">parent</a><span>|</span><a href="#42175176">prev</a><span>|</span><a href="#42174432">next</a><span>|</span><label class="collapse" for="c-42174511">[-]</label><label class="expand" for="c-42174511">[21 more]</label></div><br/><div class="children"><div class="content">Seems like a non bug to me.<p>The first mistake the developer made, was that he wanted to create a different user experience between keyboard and mouse. Stick to what you get by default and design your components so they work for both usecases. Don&#x27;t try to be smart when it comes to accessibility.<p>What he ended up doing is what I would have considered a hack. A solution that inevitably breaks or has side effects.<p>The reason there rarely are good handles to do things differently in accessibility context, is because it&#x27;s not something that&#x27;s meant to be handled differently.</div><br/><div id="42174993" class="c"><input type="checkbox" id="c-42174993" checked=""/><div class="controls bullet"><span class="by">willwade</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174511">parent</a><span>|</span><a href="#42175139">next</a><span>|</span><label class="collapse" for="c-42174993">[-]</label><label class="expand" for="c-42174993">[4 more]</label></div><br/><div class="children"><div class="content">See I work in accessibility. Like I provide and create solutions direct to end users with complex needs. Not regular web accessibility. I get the view of this. It’s the same idea of universal access. But actually I don’t fully agree. Yes. If you can stick to this principle - and do try &#x2F;  but I promise you edge cases - which in itself is what accessibility users are all about - cause headaches. At some level you have to do custom stuff. It’s the best way. Take for example switch users. Yes. If your ui is tab able - great. But what if you need your items scannable in frequency order. Your tab index needs to change to meet the end users needs. Or eye gaze users. The accuracy level changes. Add in cognitive issues. You can’t just make a one size fits all interface. At some stage you need to significantly customize it. You can’t rely on a user just learning a complex system level interaction technique- if they can’t do that you have to customise on an individual level.</div><br/><div id="42175449" class="c"><input type="checkbox" id="c-42175449" checked=""/><div class="controls bullet"><span class="by">O-stevns</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174993">parent</a><span>|</span><a href="#42175182">next</a><span>|</span><label class="collapse" for="c-42175449">[-]</label><label class="expand" for="c-42175449">[1 more]</label></div><br/><div class="children"><div class="content">Of course there are edge cases, I work with accessibility too, for an app in the public sector where WCAG rules are no joke, so I know this as well but even so, we don&#x27;t build custom accessibility UI for our users. We (try to) build the UI with accessibility in mind so it&#x27;s scalable, can be used and navigate properly by voice over and keyboard.<p>On mobile it&#x27;s not perfect either but in general you do have features to change stuff like. focus, grouping of elements, how the keyboard navigate the view stack, how to access a button through custom actions and like you mention, change the tab index programmatically.<p>Even so, not everything can be fixed or handled through standard accessibility means and as such hacks will inevitably make it into the products.<p>I get what you&#x27;re saying but I still think that making things accessible and designing with common accessibility in mind should be default and as such it has to be thought about when designing and developing from the get go. Having to create custom interfaces to fulfill a specific need might be a good fit for some things but not when developing apps and websites unless you&#x27;re targeting that user-group specifically.</div><br/></div></div><div id="42175182" class="c"><input type="checkbox" id="c-42175182" checked=""/><div class="controls bullet"><span class="by">joshtumath</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174993">parent</a><span>|</span><a href="#42175449">prev</a><span>|</span><a href="#42175209">next</a><span>|</span><label class="collapse" for="c-42175182">[-]</label><label class="expand" for="c-42175182">[1 more]</label></div><br/><div class="children"><div class="content">Well said! It certainly applies to web development as well. Sadly, sometimes more complex solutions are needed - especially when based on user research.</div><br/></div></div><div id="42175209" class="c"><input type="checkbox" id="c-42175209" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174993">parent</a><span>|</span><a href="#42175182">prev</a><span>|</span><a href="#42175139">next</a><span>|</span><label class="collapse" for="c-42175209">[-]</label><label class="expand" for="c-42175209">[1 more]</label></div><br/><div class="children"><div class="content">Also note, it’s been about 10-15 years since the rules changed and if you want to work on a government contract, accessibility is mandatory.</div><br/></div></div></div></div><div id="42175139" class="c"><input type="checkbox" id="c-42175139" checked=""/><div class="controls bullet"><span class="by">joshtumath</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174511">parent</a><span>|</span><a href="#42174993">prev</a><span>|</span><a href="#42174804">next</a><span>|</span><label class="collapse" for="c-42175139">[-]</label><label class="expand" for="c-42175139">[6 more]</label></div><br/><div class="children"><div class="content">I am the author.<p>&gt; The first mistake the developer made, was that he wanted to create a different user experience between keyboard and mouse. Stick to what you get by default and design your components so they work for both usecases.<p>We have.  The behaviour is mostly the same whether you&#x27;re using the keyboard or a pointer (mouse&#x2F;touch&#x2F;pen). The only difference is that, for keyboard users, we want to turn off the animation and move the focus to the first link in the menu instead of focussing on the menu&#x27;s parent &lt;ul&gt;.<p>The problem was that, as various devs have iterated on the menu over the years, it&#x27;s broken the fallback behaviour. For my colleague on the funny multi-monitor set up, it should have fallen back to the keyboard no-animation behaviour with no real major difference to the UX, but instead it fell back to the no-JS experience.<p>So yes, generally don&#x27;t try to be smart with accessibility, avoid ARIA attributes except where necessary, etc, but click events are the universal input event and work on any kind of input device and have perfect browser support. It&#x27;s far better for accessibility using them instead of a mix of keydown and mousedown or pointerdown, and potentially missing other kinds of input events.<p>As I stated in another comment, if it was a scenario where there needs to be a major difference in behaviour between keyboard and pointers, then I would rather use separate keydown and pointerdown events.</div><br/><div id="42175748" class="c"><input type="checkbox" id="c-42175748" checked=""/><div class="controls bullet"><span class="by">O-stevns</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42175139">parent</a><span>|</span><a href="#42179411">next</a><span>|</span><label class="collapse" for="c-42175748">[-]</label><label class="expand" for="c-42175748">[1 more]</label></div><br/><div class="children"><div class="content">The _mostly_ same behavior is what caused the problem though :P I&#x27;m curious, did these solutions come to pass because you had to make adjustments based on actual user feedback or was it just a developer trying to think ahead? I&#x27;m questioning whether forcing the user to tab to get to the menu item is a hindrance at all or whether the animation was a problem.<p>Maybe the former could have been solved using ARIA tags or maybe it would require bigger changes to the component itself. Accessibility is a roller-coaster for all these reasons alone.</div><br/></div></div><div id="42179411" class="c"><input type="checkbox" id="c-42179411" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42175139">parent</a><span>|</span><a href="#42175748">prev</a><span>|</span><a href="#42174804">next</a><span>|</span><label class="collapse" for="c-42179411">[-]</label><label class="expand" for="c-42179411">[4 more]</label></div><br/><div class="children"><div class="content">&gt; we want to turn off the animation and move the focus to the first link in the menu instead of focussing on the menu&#x27;s parent<p>Why not just always turn off the animations? Why not just always move the focus to the link?<p>What is the benefit of the animation <i>to the user</i>? What is the benefit of focusing on the menu’s parent <i>to the user</i>?<p>One rule of thumb with accessibility is that accessible products are usually better for <i>everyone</i>.</div><br/><div id="42179604" class="c"><input type="checkbox" id="c-42179604" checked=""/><div class="controls bullet"><span class="by">yreg</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42179411">parent</a><span>|</span><a href="#42174804">next</a><span>|</span><label class="collapse" for="c-42179604">[-]</label><label class="expand" for="c-42179604">[3 more]</label></div><br/><div class="children"><div class="content">&gt; What is the benefit of the animation to the user?<p>Animations enhance experience by drawing attention to state changes and providing intuitive feedback to user actions.<p>If you don&#x27;t find them engaging or useful, that&#x27;s fine - and you can set prefers-reduced-motion to true on your client - , but many people do.<p>&gt; What is the benefit of focusing on the menu’s parent to the user?<p>The first item was not interacted with nor navigated to, therefore it shouldn&#x27;t be focused under normal circumstances. It would be unexpected behavior.<p>Focusing the first item in keyboard interactions is an accessibility hack recommended by W3C:<p><a href="https:&#x2F;&#x2F;www.w3.org&#x2F;WAI&#x2F;ARIA&#x2F;apg&#x2F;patterns&#x2F;menubar&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.w3.org&#x2F;WAI&#x2F;ARIA&#x2F;apg&#x2F;patterns&#x2F;menubar&#x2F;</a></div><br/><div id="42180530" class="c"><input type="checkbox" id="c-42180530" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42179604">parent</a><span>|</span><a href="#42174804">next</a><span>|</span><label class="collapse" for="c-42180530">[-]</label><label class="expand" for="c-42180530">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Animations enhance experience by drawing attention to state changes and providing intuitive feedback to user actions.</i><p>&gt; <i>If you don&#x27;t find them engaging or useful, that&#x27;s fine - and you can set prefers-reduced-motion to true on your client - , but many people do.</i><p>The question here is not &quot;does an animation have worth&quot;, but how is that worth tied to whether an onclick event originated from the mouse or the keyboard? Your reasoning applies equally to both, and thus leaves us still confused: why are we varying the animation by input device?</div><br/><div id="42180669" class="c"><input type="checkbox" id="c-42180669" checked=""/><div class="controls bullet"><span class="by">yreg</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42180530">parent</a><span>|</span><a href="#42174804">next</a><span>|</span><label class="collapse" for="c-42180669">[-]</label><label class="expand" for="c-42180669">[1 more]</label></div><br/><div class="children"><div class="content">The question was &quot;Why not just always turn off the animations?&quot;<p>---<p>&gt; why are we varying the animation by input device?<p>Another user explains it here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42176540">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42176540</a><p>I don&#x27;t actually agree, I think you can keep the animation and still make the content available immediately for screen readers. (And of course, keyboard navigation is not just for screen reader users!) Maybe someone else knows of some issue I don&#x27;t.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42174804" class="c"><input type="checkbox" id="c-42174804" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174511">parent</a><span>|</span><a href="#42175139">prev</a><span>|</span><a href="#42176540">next</a><span>|</span><label class="collapse" for="c-42174804">[-]</label><label class="expand" for="c-42174804">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Don&#x27;t try to be smart when it comes to accessibility.<p>“Don&#x27;t try to be smart” alone is good advice in general and everywhere. Also in UI “don’t try to be original”</div><br/><div id="42177518" class="c"><input type="checkbox" id="c-42177518" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174804">parent</a><span>|</span><a href="#42174895">next</a><span>|</span><label class="collapse" for="c-42177518">[-]</label><label class="expand" for="c-42177518">[1 more]</label></div><br/><div class="children"><div class="content">I prefer the line: “make it as simple as possible, but no simpler”<p>Sometimes complexity is simply the right tool for the job. Complexity is essential and valuable in all sorts of places - like fuzzers, LLMs, compilers, rendering engines, kernel schedulers and so on. But projects only have so much complexity budget to spend. I think I&#x27;ve spent my whole career trying to figure out how to spend complexity wisely. And I could spend decades more on it.</div><br/></div></div><div id="42174895" class="c"><input type="checkbox" id="c-42174895" checked=""/><div class="controls bullet"><span class="by">afandian</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174804">parent</a><span>|</span><a href="#42177518">prev</a><span>|</span><a href="#42176540">next</a><span>|</span><label class="collapse" for="c-42174895">[-]</label><label class="expand" for="c-42174895">[2 more]</label></div><br/><div class="children"><div class="content">The BBC site has a &quot;search box&quot; that&#x27;s actually a button that brings up the real search box. Always feels confusing. At least it&#x27;s consistent across News &#x2F; Sounds &#x2F; iPlayer.</div><br/><div id="42180379" class="c"><input type="checkbox" id="c-42180379" checked=""/><div class="controls bullet"><span class="by">eCa</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174895">parent</a><span>|</span><a href="#42176540">next</a><span>|</span><label class="collapse" for="c-42180379">[-]</label><label class="expand" for="c-42180379">[1 more]</label></div><br/><div class="children"><div class="content">This is becoming more and more common. Can’t say I’m a fan either.</div><br/></div></div></div></div></div></div><div id="42176540" class="c"><input type="checkbox" id="c-42176540" checked=""/><div class="controls bullet"><span class="by">that_guy_iain</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174511">parent</a><span>|</span><a href="#42174804">prev</a><span>|</span><a href="#42174432">next</a><span>|</span><label class="collapse" for="c-42176540">[-]</label><label class="expand" for="c-42176540">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The first mistake the developer made, was that he wanted to create a different user experience between keyboard and mouse.<p>No, they wanted to make them the same. It&#x27;s just to give a blind person the same experience as a seeing person requires different things because they operate differently for obvious reasons. For example, a blind person can&#x27;t see when an animation has finished. They expect that menu to be available once they&#x27;ve triggered it. However, seeing people see the dropdown appearing and then go to use it once it&#x27;s ready.<p>&gt; Don&#x27;t try to be smart when it comes to accessibility.<p>In all seriousness, considering the state of accessibility as is, I think going outside the box isn&#x27;t trying to be smart. It&#x27;s actually being smart. The BBC frontend team is probably at the forefront of making high-traffic websites extremely usable.</div><br/><div id="42180852" class="c"><input type="checkbox" id="c-42180852" checked=""/><div class="controls bullet"><span class="by">O-stevns</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42176540">parent</a><span>|</span><a href="#42177333">next</a><span>|</span><label class="collapse" for="c-42180852">[-]</label><label class="expand" for="c-42180852">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a blind person can&#x27;t see when an animation has finished. They expect that menu to be available once they&#x27;ve triggered it. However, seeing people see the dropdown appearing and then go to use it once it&#x27;s ready.<p>A blind person can and should get cues from their assistive technologies that an item is is being loaded and is shown, either using announcements or aria tags that provide this information to the user.<p>While its fine to expect that something is available immediately, that&#x27;s rarely a realistic expectation, whether you&#x27;re blind or not.</div><br/><div id="42181109" class="c"><input type="checkbox" id="c-42181109" checked=""/><div class="controls bullet"><span class="by">that_guy_iain</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42180852">parent</a><span>|</span><a href="#42177333">next</a><span>|</span><label class="collapse" for="c-42181109">[-]</label><label class="expand" for="c-42181109">[1 more]</label></div><br/><div class="children"><div class="content">If you remove the can, I would agree.</div><br/></div></div></div></div><div id="42177333" class="c"><input type="checkbox" id="c-42177333" checked=""/><div class="controls bullet"><span class="by">pwg</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42176540">parent</a><span>|</span><a href="#42180852">prev</a><span>|</span><a href="#42174432">next</a><span>|</span><label class="collapse" for="c-42177333">[-]</label><label class="expand" for="c-42177333">[3 more]</label></div><br/><div class="children"><div class="content">&gt; For example, a blind person can&#x27;t see when an animation has finished. They expect that menu to be available once they&#x27;ve triggered it. However, seeing people see the dropdown appearing and then go to use it once it&#x27;s ready.<p>For my two-cents, the BBC was simply trying too much to be &quot;cutesy&quot;.  Don&#x27;t animate anything, because the silly animation on mouse click simply makes the website feel slower overall.  Just open the menu as fast as the user&#x27;s browser will open it.</div><br/><div id="42177751" class="c"><input type="checkbox" id="c-42177751" checked=""/><div class="controls bullet"><span class="by">unclad5968</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42177333">parent</a><span>|</span><a href="#42179471">next</a><span>|</span><label class="collapse" for="c-42177751">[-]</label><label class="expand" for="c-42177751">[1 more]</label></div><br/><div class="children"><div class="content">That wouldn&#x27;t change anything. They want the first element of the menu to be focused when &quot;clicked&quot; from a keyboard but not from a mouse. The animation doesn&#x27;t affect that.</div><br/></div></div><div id="42179471" class="c"><input type="checkbox" id="c-42179471" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42177333">parent</a><span>|</span><a href="#42177751">prev</a><span>|</span><a href="#42174432">next</a><span>|</span><label class="collapse" for="c-42179471">[-]</label><label class="expand" for="c-42179471">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Don&#x27;t animate anything<p>Animation helps to correlate screen elements. Without animation it actually takes longer to establish the mental relationship between the action and the result.</div><br/></div></div></div></div></div></div></div></div><div id="42174432" class="c"><input type="checkbox" id="c-42174432" checked=""/><div class="controls bullet"><span class="by">Sayrus</span><span>|</span><a href="#42174177">parent</a><span>|</span><a href="#42174511">prev</a><span>|</span><a href="#42174692">next</a><span>|</span><label class="collapse" for="c-42174432">[-]</label><label class="expand" for="c-42174432">[1 more]</label></div><br/><div class="children"><div class="content">While I can understand the author&#x27;s need for screenX and screenY, the question remains. Why would screenX return the real screenX position instead of the position within the renderer (I don&#x27;t think that exists?) or the rendered page (layerX and layerY)? The author&#x27;s need would be met the same with the renderer position and window positions wouldn&#x27;t be leaked to all visited websites.</div><br/></div></div><div id="42174692" class="c"><input type="checkbox" id="c-42174692" checked=""/><div class="controls bullet"><span class="by">kypro</span><span>|</span><a href="#42174177">parent</a><span>|</span><a href="#42174432">prev</a><span>|</span><a href="#42174435">next</a><span>|</span><label class="collapse" for="c-42174692">[-]</label><label class="expand" for="c-42174692">[3 more]</label></div><br/><div class="children"><div class="content">Does anyone else find this write up confusing?<p>My understanding from this is that BBC want slightly different behaviour depending on whether it&#x27;s a mouse or keyboard &quot;click&quot; (keyboard shouldn&#x27;t show the animation and should focus the first link in the menu).<p>However, they also want the ease of binding to a single event and while binding to &quot;click&quot; can do this, they have no way to tell whether it was a mouse click or keyboard press which triggered the event.<p>To solve this they&#x27;re using an unreliable heuristic after realising in Chrome if the mouse position is screenX=0, screenY=0 it means the event was either triggered by a mouse click at screenX=0, screenY=0 or a keyboard.<p>As someone whose worked on accessibility projects in the past, this is a really stupid idea imo, and had I reviewed a PR with something like this I would have asked it to be reworked. While I agree browsers should ideally do the same thing, the real issue here seems to me that screenX and screenY make little sense on &quot;click&quot; triggered by a keyboard.<p>The solution ideally would be a new event (&quot;trigger&quot; or something) which doesn&#x27;t emit a &quot;MouseEvent&quot;, but something more generic which could apply to both a keyboard and mouse event and provide information about the &quot;trigger&quot; source. Imo keyboard &quot;clicks&quot; are weird to begin with and would ideally be fixed with a more appropriate event.<p>That said, I understand this doesn&#x27;t currently exist in the spec and a solution is needed now. Therefore I don&#x27;t see why they couldn&#x27;t also bind to a &quot;keydown&quot; event then if the click is triggered alongside the &quot;keydown&quot; on the same element, assume it was a keyboard press. That would be far more reliable and far less hacky than what they&#x27;re doing, and would allow them to trigger from the single event with a bit of extra code to detect if it was a keyboard or mouse.</div><br/><div id="42174988" class="c"><input type="checkbox" id="c-42174988" checked=""/><div class="controls bullet"><span class="by">joshtumath</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174692">parent</a><span>|</span><a href="#42174435">next</a><span>|</span><label class="collapse" for="c-42174988">[-]</label><label class="expand" for="c-42174988">[2 more]</label></div><br/><div class="children"><div class="content">Hello I am the author and, yes, I totally agree some generic &#x27;trigger&#x27; event would be far better.<p>To use the keydown event means we have to assume that the &#x27;Enter&#x27; and &#x27;Space&#x27; are the only keys we need to check for. Using &#x27;click&#x27; is far safer from an accessibility point of view because it will always respect what your device considers to be some kind of input trigger.<p>As stated in the UI Events spec:<p>&gt; For maximum accessibility, content authors are encouraged to use the click event type when defining activation behavior for custom controls, rather than other pointing-device event types such as mousedown or mouseup, which are more device-specific. Though the click event type has its origins in pointer devices (e.g., a mouse), subsequent implementation enhancements have extended it beyond that association, and it can be considered a device-independent event type for element activation.<p>And to be clear, I would not want to do it this way if it was for some really critical difference in behaviour between pointer or keyboard interactions. I&#x27;m OK with this strange mechanism here because the fallback behaviour is not that different. If you&#x27;re on Safari, for example, which can&#x27;t check for `screenX === 0`, then all that happens is that there will be an animation when you open the menu.<p>However, sadly, because of the ways various developers have added to this code over the years, it&#x27;s broken that fallback behaviour and stopped it working entirely. So I&#x27;ve just finished a refactor to sort that out and it will hopefully be going live soon.</div><br/><div id="42179554" class="c"><input type="checkbox" id="c-42179554" checked=""/><div class="controls bullet"><span class="by">yreg</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174988">parent</a><span>|</span><a href="#42174435">next</a><span>|</span><label class="collapse" for="c-42179554">[-]</label><label class="expand" for="c-42179554">[1 more]</label></div><br/><div class="children"><div class="content">I suspect you are checking for the coordinates because you can&#x27;t fully trust the event type.<p>I currently have an open semi-related bug, also in a menu dropdown component (where we also want to focus the first item when triggered via keyboard). My issue is that when Windows Narrator is used, the space&#x2F;enter triggers a mocked click event instead of the keydown. We could check for the position like you do.<p>Unfortunately, accessibility is often hacky both on the content side, but also on on the browser&#x2F;screen reader side.</div><br/></div></div></div></div></div></div><div id="42174435" class="c"><input type="checkbox" id="c-42174435" checked=""/><div class="controls bullet"><span class="by">tshaddox</span><span>|</span><a href="#42174177">parent</a><span>|</span><a href="#42174692">prev</a><span>|</span><a href="#42174016">next</a><span>|</span><label class="collapse" for="c-42174435">[-]</label><label class="expand" for="c-42174435">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Often when opening a menu, we don&#x27;t want a slightly different behaviour around focus and animations depending on if the user &#x27;clicks&#x27; with a pointer or keyboard.<p>Is the word “don’t” a mistake which gives the sentence the opposite of the intended meaning?</div><br/><div id="42174812" class="c"><input type="checkbox" id="c-42174812" checked=""/><div class="controls bullet"><span class="by">joshtumath</span><span>|</span><a href="#42174177">root</a><span>|</span><a href="#42174435">parent</a><span>|</span><a href="#42174016">next</a><span>|</span><label class="collapse" for="c-42174812">[-]</label><label class="expand" for="c-42174812">[1 more]</label></div><br/><div class="children"><div class="content">Hello I am the author and that was indeed a mistake. Whoops!</div><br/></div></div></div></div></div></div><div id="42174016" class="c"><input type="checkbox" id="c-42174016" checked=""/><div class="controls bullet"><span class="by">marcellus23</span><span>|</span><a href="#42174177">prev</a><span>|</span><a href="#42175935">next</a><span>|</span><label class="collapse" for="c-42174016">[-]</label><label class="expand" for="c-42174016">[9 more]</label></div><br/><div class="children"><div class="content">&gt; All we had to do was change the isInvokedByMouse to check that screenX and screenY don&#x27;t equal 0, rather than checking if they are greater than 0.<p>It&#x27;s obviously extremely unlikely but what if the mouse is actually at 0,0 when the user clicks? I&#x27;m not very familiar with JS, is checking for != 0 really the best&#x2F;only way to do this?<p>EDIT: actually upon going back, I realized I didn&#x27;t fully process this sentence originally but it seems to address this:<p>&gt; We should probably do further refactoring of the event handler function, since it&#x27;s complicated by the fact that it also handles keydown events. For now, though, this fix will do just fine.</div><br/><div id="42174225" class="c"><input type="checkbox" id="c-42174225" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#42174016">parent</a><span>|</span><a href="#42174129">next</a><span>|</span><label class="collapse" for="c-42174225">[-]</label><label class="expand" for="c-42174225">[2 more]</label></div><br/><div class="children"><div class="content">It seems that querying the screen position is just a heuristic they came up with to determine the nature of the event. Instinctively I would use <i>instance of MouseEvent</i> for this, but even this feels risky&#x2F;hacky to me.<p>My question is why they&#x27;re relying on those heuristics. My guess is that <i>toggleMenu</i> is being used by multiple event handlers. Or maybe there&#x27;s something else going on that is specific to their codebase.<p>It&#x27;s hard to judge without knowing the full picture.<p>EDIT: Aha, there&#x27;s an answer here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42174177">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42174177</a></div><br/><div id="42180007" class="c"><input type="checkbox" id="c-42180007" checked=""/><div class="controls bullet"><span class="by">alain94040</span><span>|</span><a href="#42174016">root</a><span>|</span><a href="#42174225">parent</a><span>|</span><a href="#42174129">next</a><span>|</span><label class="collapse" for="c-42180007">[-]</label><label class="expand" for="c-42180007">[1 more]</label></div><br/><div class="children"><div class="content">You can do a search on GitHub and there is quite a bit of code that is using event.screenX &gt; 0. Maybe someone should file some bug reports.<p>Also, stack overflow suggests that exact code to &quot;differentiate between mouse and keyboard triggering onclick&quot;: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7465006&#x2F;differentiate-between-mouse-and-keyboard-triggering-onclick" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7465006&#x2F;differentiate-be...</a></div><br/></div></div></div></div><div id="42174129" class="c"><input type="checkbox" id="c-42174129" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#42174016">parent</a><span>|</span><a href="#42174225">prev</a><span>|</span><a href="#42174311">next</a><span>|</span><label class="collapse" for="c-42174129">[-]</label><label class="expand" for="c-42174129">[5 more]</label></div><br/><div class="children"><div class="content">But they&#x27;re already checking for event.name == &#x27;click&#x27; in the revised code. So why would you want to filter <i>out</i> some legitimate click events?</div><br/><div id="42174182" class="c"><input type="checkbox" id="c-42174182" checked=""/><div class="controls bullet"><span class="by">marcellus23</span><span>|</span><a href="#42174016">root</a><span>|</span><a href="#42174129">parent</a><span>|</span><a href="#42174203">next</a><span>|</span><label class="collapse" for="c-42174182">[-]</label><label class="expand" for="c-42174182">[3 more]</label></div><br/><div class="children"><div class="content">Maybe browsers will report `click` events that aren&#x27;t actually created by a pointer device (maybe a screen reader or something?). But that still raises the question of why you would care. It seems to me like if the platform wants to report it as a `click`, your app should treat it as one and not try to get &quot;clever&quot; about it.</div><br/><div id="42174558" class="c"><input type="checkbox" id="c-42174558" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#42174016">root</a><span>|</span><a href="#42174182">parent</a><span>|</span><a href="#42174203">next</a><span>|</span><label class="collapse" for="c-42174558">[-]</label><label class="expand" for="c-42174558">[2 more]</label></div><br/><div class="children"><div class="content">For compatibility with the Web content, the `click` event has become a device-independent activation event. Sites can&#x27;t be expected to listen for events from every kind of device, so instead all devices send `click`s.<p>They care, because focus for keyboard-controlled screen readers sending &quot;click&quot; should behave differently: an element inside the menu should receive focus, even though it&#x27;s not the element that has been clicked. Otherwise if focus stayed on top-level menu bar, screen reader users would be lost, and had to navigate to menu&#x27;s content themselves.</div><br/><div id="42175535" class="c"><input type="checkbox" id="c-42175535" checked=""/><div class="controls bullet"><span class="by">marcellus23</span><span>|</span><a href="#42174016">root</a><span>|</span><a href="#42174558">parent</a><span>|</span><a href="#42174203">next</a><span>|</span><label class="collapse" for="c-42175535">[-]</label><label class="expand" for="c-42175535">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. Seems like something that should be exposed more explicitly.</div><br/></div></div></div></div></div></div><div id="42174203" class="c"><input type="checkbox" id="c-42174203" checked=""/><div class="controls bullet"><span class="by">kulor</span><span>|</span><a href="#42174016">root</a><span>|</span><a href="#42174129">parent</a><span>|</span><a href="#42174182">prev</a><span>|</span><a href="#42174311">next</a><span>|</span><label class="collapse" for="c-42174203">[-]</label><label class="expand" for="c-42174203">[1 more]</label></div><br/><div class="children"><div class="content">Apply Chesterton&#x27;s Fence principle and assume there are (hopefully) comments in the real code around why this has been put in place</div><br/></div></div></div></div><div id="42174311" class="c"><input type="checkbox" id="c-42174311" checked=""/><div class="controls bullet"><span class="by">tomjen3</span><span>|</span><a href="#42174016">parent</a><span>|</span><a href="#42174129">prev</a><span>|</span><a href="#42175935">next</a><span>|</span><label class="collapse" for="c-42174311">[-]</label><label class="expand" for="c-42174311">[1 more]</label></div><br/><div class="children"><div class="content">No its not. You can do media select on if the primary input device is a pointer device (and, further, if it has high accuracy) and then filter on that.<p>I used it to select which layout to show in the past.<p>If you want to listen to input on touch only then you can do that and call preventDefault on the event so that the browser does not then cause a click event. Or you can just save yourself the trouble and write a click handler.</div><br/></div></div></div></div><div id="42175935" class="c"><input type="checkbox" id="c-42175935" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#42174016">prev</a><span>|</span><a href="#42180883">next</a><span>|</span><label class="collapse" for="c-42175935">[-]</label><label class="expand" for="c-42175935">[3 more]</label></div><br/><div class="children"><div class="content">Kudos to BBC for investing in accessibility, and unfortunately discovering a nasty bug.<p>As an industry, why haven&#x27;t we figured out how to make drop downs that consistently open for all users? Is accessibility just that hard? Are there web frameworks&#x2F;web components BBC should be using that already handle this?<p>I&#x27;ve been wary (as a backend-focused full-stack developer) about tweaking the browsers components. There&#x27;s so much nuance to how they work and the implementations are battle tested. The idea of creating a custom text box (for example) without doing extensive research of text box behavior across platforms seems ripe for failure. I notice broken copy&#x2F;paste and dropped characters often enough (on major corporate sites too). Why are text boxes broken in 2024? React feels arrogant to me now.<p>Personally, I&#x27;ve tried to handle this with server-side templates, CSS frameworks like Bulma, minimal JS. It&#x27;s not viable for sites demanding slick custom branding (vanity?) but my text boxes work and my site doesn&#x27;t cost a fortune to develop. Is it accessible to BBC standards? I&#x27;m not sure.</div><br/><div id="42176307" class="c"><input type="checkbox" id="c-42176307" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#42175935">parent</a><span>|</span><a href="#42180952">next</a><span>|</span><label class="collapse" for="c-42176307">[-]</label><label class="expand" for="c-42176307">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. But ultimately many issues arise when user agents customize these elements in very dubious ways. It&#x27;s ok for the most part, but there&#x27;s a reason behind reset.css files, and I wager a more nuclear approach was used here to circumvent these issues completely.<p>I&#x27;m just trying to reason on their decision here.</div><br/></div></div></div></div><div id="42180883" class="c"><input type="checkbox" id="c-42180883" checked=""/><div class="controls bullet"><span class="by">256_</span><span>|</span><a href="#42175935">prev</a><span>|</span><a href="#42174968">next</a><span>|</span><label class="collapse" for="c-42180883">[-]</label><label class="expand" for="c-42180883">[1 more]</label></div><br/><div class="children"><div class="content">Some people are pretty negative about the code presented here (which the author criticised in a second post[0]), which makes me wonder, as someone who thankfully hasn&#x27;t programmed anything non-trivial in Javascript in years: Is checking for (0,0) actually bad code, or is it simply making the most of a bad API?<p>Bear in mind the following:<p>&gt; Also, thank you to Patrick H. Lauke from TetraLogical (editor of the Pointer Events Level 2 spec) for his comment on Mastodon that suggested improving the offending code by checking for pointerType in the PointerEvent interface instead of screenX and screenY.<p>The code provided in the second post[0] uses pointerType if available, else falls back to checking for (0,0). Also:<p>&gt; At the time this code was originally written four years ago, not all browsers treated click events as PointerEvents. They used the MouseEvent interface, so pointerId or pointerType wasn&#x27;t an option.<p>[0]: <a href="https:&#x2F;&#x2F;www.joshtumath.uk&#x2F;posts&#x2F;2024-11-18-how-i-refactored-the-bbc-navigation-bar-and-a-follow-up-faq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joshtumath.uk&#x2F;posts&#x2F;2024-11-18-how-i-refactored-...</a></div><br/></div></div><div id="42174968" class="c"><input type="checkbox" id="c-42174968" checked=""/><div class="controls bullet"><span class="by">watusername</span><span>|</span><a href="#42180883">prev</a><span>|</span><a href="#42174070">next</a><span>|</span><label class="collapse" for="c-42174968">[-]</label><label class="expand" for="c-42174968">[2 more]</label></div><br/><div class="children"><div class="content">This seems like a self-inflicted bug resulted from incorrect heuristics (assumption that positive screenX&#x2F;Y values represent mouse event), and the investigation was complicated by inadequate tracing&#x2F;logging.<p>Instead of checking the more appropriate property that other commenters have suggested (pointerType), I&#x27;m a bit surprised that the solution given by the author is to patch up the shaky heuristics even more:<p>&gt; We could deduce from our final two clues the solution: we need to check for negative numbers as well as positive numbers when checking the screenX and screenY coordinates.</div><br/><div id="42175259" class="c"><input type="checkbox" id="c-42175259" checked=""/><div class="controls bullet"><span class="by">joshtumath</span><span>|</span><a href="#42174968">parent</a><span>|</span><a href="#42174070">next</a><span>|</span><label class="collapse" for="c-42175259">[-]</label><label class="expand" for="c-42175259">[1 more]</label></div><br/><div class="children"><div class="content">Actually that is what we&#x27;re going to do. I&#x27;m hoping to merging in code, soon, that will change it to use pointerId === -1 and then fall back to screenX === 0.<p>At the time this code was originally written four years ago or whenever it was, not all browsers used PointerEvent for click.</div><br/></div></div></div></div><div id="42174070" class="c"><input type="checkbox" id="c-42174070" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#42174968">prev</a><span>|</span><a href="#42174146">next</a><span>|</span><label class="collapse" for="c-42174070">[-]</label><label class="expand" for="c-42174070">[17 more]</label></div><br/><div class="children"><div class="content">Why are websites getting mouse position in screen coordinates in the first place?</div><br/><div id="42174236" class="c"><input type="checkbox" id="c-42174236" checked=""/><div class="controls bullet"><span class="by">Sayrus</span><span>|</span><a href="#42174070">parent</a><span>|</span><a href="#42174483">next</a><span>|</span><label class="collapse" for="c-42174236">[-]</label><label class="expand" for="c-42174236">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve searched for reasons and couldn&#x27;t find much. The fact that a website can know where a browser window is located (window.screenX&#x2F;window.screenY) and that clicks position can be reported in that coordinate system sounds insane for a desktop. TOR Browser seems to spoof screenX and screenY to avoid fingerprinting.<p>Has anyone seen good use-cases for that feature? I&#x27;m thinking about dual window applications that interacts with each other (I think I saw a demo of something like this a while ago on HN but I wasn&#x27;t able to find it again), or sites where behavior depends on their location on the virtual screen.</div><br/><div id="42175446" class="c"><input type="checkbox" id="c-42175446" checked=""/><div class="controls bullet"><span class="by">willwade</span><span>|</span><a href="#42174070">root</a><span>|</span><a href="#42174236">parent</a><span>|</span><a href="#42178604">next</a><span>|</span><label class="collapse" for="c-42175446">[-]</label><label class="expand" for="c-42175446">[1 more]</label></div><br/><div class="children"><div class="content">Back in html 4 days we did this shenanigans all the time. I worked on very over the top sites that played with multiple windows talking to each other and moving in synchrony. I’ve tried looking for examples on archive.org (eg I know we did this a ton on flash heavy sites like design museum in London ) but alas the ones I was looking for a broken in that archive.</div><br/></div></div><div id="42178604" class="c"><input type="checkbox" id="c-42178604" checked=""/><div class="controls bullet"><span class="by">thundermuffin</span><span>|</span><a href="#42174070">root</a><span>|</span><a href="#42174236">parent</a><span>|</span><a href="#42175446">prev</a><span>|</span><a href="#42174288">next</a><span>|</span><label class="collapse" for="c-42178604">[-]</label><label class="expand" for="c-42178604">[2 more]</label></div><br/><div class="children"><div class="content">Maybe this[1] is the demo you were thinking of? It&#x27;s what came to mind when reading this chain at least.<p>[1] <a href="https:&#x2F;&#x2F;x.com&#x2F;wesbos&#x2F;status&#x2F;1727730566143803522" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;wesbos&#x2F;status&#x2F;1727730566143803522</a></div><br/><div id="42179224" class="c"><input type="checkbox" id="c-42179224" checked=""/><div class="controls bullet"><span class="by">Sayrus</span><span>|</span><a href="#42174070">root</a><span>|</span><a href="#42178604">parent</a><span>|</span><a href="#42174288">next</a><span>|</span><label class="collapse" for="c-42179224">[-]</label><label class="expand" for="c-42179224">[1 more]</label></div><br/><div class="children"><div class="content">Not the one I was thinking one but definitely the vibe, thanks for sharing.</div><br/></div></div></div></div><div id="42174288" class="c"><input type="checkbox" id="c-42174288" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#42174070">root</a><span>|</span><a href="#42174236">parent</a><span>|</span><a href="#42178604">prev</a><span>|</span><a href="#42174483">next</a><span>|</span><label class="collapse" for="c-42174288">[-]</label><label class="expand" for="c-42174288">[1 more]</label></div><br/><div class="children"><div class="content">The webkit report talks about it (<a href="https:&#x2F;&#x2F;bugs.webkit.org&#x2F;show_bug.cgi?id=281430" rel="nofollow">https:&#x2F;&#x2F;bugs.webkit.org&#x2F;show_bug.cgi?id=281430</a>), while the article doesn&#x27;t seem to, for some reason. Another HN comment with summary: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42174177">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42174177</a></div><br/></div></div></div></div><div id="42174483" class="c"><input type="checkbox" id="c-42174483" checked=""/><div class="controls bullet"><span class="by">tshaddox</span><span>|</span><a href="#42174070">parent</a><span>|</span><a href="#42174236">prev</a><span>|</span><a href="#42174581">next</a><span>|</span><label class="collapse" for="c-42174483">[-]</label><label class="expand" for="c-42174483">[2 more]</label></div><br/><div class="children"><div class="content">It’s useful for creating games where the graphics are composed of many small browser windows which interact with one another.<p>For example:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;3al8prbfK5o?si=loNtyqIfMFkppm5V" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;3al8prbfK5o?si=loNtyqIfMFkppm5V</a></div><br/><div id="42180990" class="c"><input type="checkbox" id="c-42180990" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#42174070">root</a><span>|</span><a href="#42174483">parent</a><span>|</span><a href="#42174581">next</a><span>|</span><label class="collapse" for="c-42180990">[-]</label><label class="expand" for="c-42180990">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s nowhere near useful enough to justify such a significant security flaw.</div><br/></div></div></div></div><div id="42174581" class="c"><input type="checkbox" id="c-42174581" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42174070">parent</a><span>|</span><a href="#42174483">prev</a><span>|</span><a href="#42174192">next</a><span>|</span><label class="collapse" for="c-42174581">[-]</label><label class="expand" for="c-42174581">[1 more]</label></div><br/><div class="children"><div class="content">Because this was easy to do during the 10 days allocated to develop JavaScript in 1995, and then backwards compatibility kicked in :(</div><br/></div></div><div id="42174192" class="c"><input type="checkbox" id="c-42174192" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#42174070">parent</a><span>|</span><a href="#42174581">prev</a><span>|</span><a href="#42174549">next</a><span>|</span><label class="collapse" for="c-42174192">[-]</label><label class="expand" for="c-42174192">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re reacting to click events, you might want to know the coordinates of where you&#x27;re clicking. I mostly use this for click and drag stuff since you can get the delta between events and update position of the thing being dragged.<p>As for why they&#x27;re checking for coordinates instead of checking for event.type is beyond me. Still I appreciate the write up, it is a good puzzle and relatable to come across code you didn&#x27;t write and ask, why is it important that the click coordinate is nonzero? Why can&#x27;t we just check that event.target is the button we want to activate? Why are we using JavaScript at all when a details&#x2F;summary tag would do the same job?</div><br/><div id="42175606" class="c"><input type="checkbox" id="c-42175606" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#42174070">root</a><span>|</span><a href="#42174192">parent</a><span>|</span><a href="#42174549">next</a><span>|</span><label class="collapse" for="c-42175606">[-]</label><label class="expand" for="c-42175606">[1 more]</label></div><br/><div class="children"><div class="content">Relative coordinates sure, but why would you need the absolute position?<p>I&#x27;m with you on the second point - as unlikely as it is for the click to occur at the origin, it&#x27;s still a legitimate value being abused as an indicator of something that might not actually be true - quite frankly the code was bad to begin with, and it was still bad after the fix.</div><br/></div></div></div></div><div id="42174549" class="c"><input type="checkbox" id="c-42174549" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42174070">parent</a><span>|</span><a href="#42174192">prev</a><span>|</span><a href="#42174200">next</a><span>|</span><label class="collapse" for="c-42174549">[-]</label><label class="expand" for="c-42174549">[1 more]</label></div><br/><div class="children"><div class="content">I use it for a JavaScript-free CAPTCHA, works well, but it only sends the x and y of mouse click upon clicking on it.</div><br/></div></div><div id="42174200" class="c"><input type="checkbox" id="c-42174200" checked=""/><div class="controls bullet"><span class="by">DCH3416</span><span>|</span><a href="#42174070">parent</a><span>|</span><a href="#42174549">prev</a><span>|</span><a href="#42177418">next</a><span>|</span><label class="collapse" for="c-42174200">[-]</label><label class="expand" for="c-42174200">[3 more]</label></div><br/><div class="children"><div class="content">Uh. So they can keep track of what the user is doing?<p>Why would you just send a document when you can generate a heat map of where the user is on your website. And then complain about the performance and wonder why it costs so much to run a modern website.</div><br/><div id="42174308" class="c"><input type="checkbox" id="c-42174308" checked=""/><div class="controls bullet"><span class="by">Sayrus</span><span>|</span><a href="#42174070">root</a><span>|</span><a href="#42174200">parent</a><span>|</span><a href="#42174285">next</a><span>|</span><label class="collapse" for="c-42174308">[-]</label><label class="expand" for="c-42174308">[1 more]</label></div><br/><div class="children"><div class="content">The issue isn&#x27;t so much the coordinate of the mouse within a page, but that the coordinates are relative to the virtual screen layout. It describes where your window is located on the screen(s) and the click is expressed in screen coordinates. Mapping those coordinates to your website&#x27;s renderer coordinates requires additional calculation.<p>layerX[1] while non-standard is supported and returns a position relative to the top of the page or the top of the parent element. This makes coordinates positive only and 50,50 is the same for all users. For screenX, 3000,1567 is the same coordinate as 15,37 depending on where the window is located.<p>[1] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;MouseEvent&#x2F;layerX" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;MouseEvent&#x2F;...</a></div><br/></div></div></div></div><div id="42177418" class="c"><input type="checkbox" id="c-42177418" checked=""/><div class="controls bullet"><span class="by">grumple</span><span>|</span><a href="#42174070">parent</a><span>|</span><a href="#42174200">prev</a><span>|</span><a href="#42174247">next</a><span>|</span><label class="collapse" for="c-42177418">[-]</label><label class="expand" for="c-42177418">[1 more]</label></div><br/><div class="children"><div class="content">Well, I used it for bounding box and reading order annotations, but that’s a pretty specialized use case.</div><br/></div></div><div id="42174247" class="c"><input type="checkbox" id="c-42174247" checked=""/><div class="controls bullet"><span class="by">Taylor_OD</span><span>|</span><a href="#42174070">parent</a><span>|</span><a href="#42177418">prev</a><span>|</span><a href="#42174146">next</a><span>|</span><label class="collapse" for="c-42174247">[-]</label><label class="expand" for="c-42174247">[1 more]</label></div><br/><div class="children"><div class="content">Haha. Welcome to the world of analytics. Lots of sites are recording exactly what you are doing on their site including mouse movement at all times.</div><br/></div></div></div></div><div id="42174146" class="c"><input type="checkbox" id="c-42174146" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#42174070">prev</a><span>|</span><a href="#42175325">next</a><span>|</span><label class="collapse" for="c-42174146">[-]</label><label class="expand" for="c-42174146">[6 more]</label></div><br/><div class="children"><div class="content">Why are you filtering for screen coordinates in the first place? What if the user is using e.g. an alternative input device that doesn&#x27;t have a screen? The `click` event should be enough indication that the user has tried to activate the menu. Why reinvent the wheel?</div><br/><div id="42174263" class="c"><input type="checkbox" id="c-42174263" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#42174146">parent</a><span>|</span><a href="#42175325">next</a><span>|</span><label class="collapse" for="c-42174263">[-]</label><label class="expand" for="c-42174263">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Why are you filtering for screen coordinates in the first place?<p>FTA:<p>&gt; The isInvokedByMouse was checking whether the click event was invoked by a mouse or touch pointer – rather than a keyboard – by checking if the screenX or screenY coordinates were a positive number.<p>They were trying to detect whether it was keyboard or mouse activation, and whoever wrote it assumed that screen coordinates of mouse events would always be positive.</div><br/><div id="42177879" class="c"><input type="checkbox" id="c-42177879" checked=""/><div class="controls bullet"><span class="by">Aaargh20318</span><span>|</span><a href="#42174146">root</a><span>|</span><a href="#42174263">parent</a><span>|</span><a href="#42174460">next</a><span>|</span><label class="collapse" for="c-42177879">[-]</label><label class="expand" for="c-42177879">[1 more]</label></div><br/><div class="children"><div class="content">They are breaking Curly’s Law here (<a href="https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;curlys-law-do-one-thing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;curlys-law-do-one-thing&#x2F;</a>), the screenX&#x2F;Y location mean one thing: the location of the mouse event on screen. Using it for anything else is a huge red flag.</div><br/></div></div><div id="42174460" class="c"><input type="checkbox" id="c-42174460" checked=""/><div class="controls bullet"><span class="by">echoangle</span><span>|</span><a href="#42174146">root</a><span>|</span><a href="#42174263">parent</a><span>|</span><a href="#42177879">prev</a><span>|</span><a href="#42174434">next</a><span>|</span><label class="collapse" for="c-42174460">[-]</label><label class="expand" for="c-42174460">[2 more]</label></div><br/><div class="children"><div class="content">&gt; They were trying to detect whether it was keyboard or mouse activation<p>But the code shown doesn&#x27;t do different stuff for Keyboard vs Mouse, it just checks if it is either one of them. Why would you do that? Which other click event types are there that you want to filter?</div><br/><div id="42175205" class="c"><input type="checkbox" id="c-42175205" checked=""/><div class="controls bullet"><span class="by">joshtumath</span><span>|</span><a href="#42174146">root</a><span>|</span><a href="#42174460">parent</a><span>|</span><a href="#42174434">next</a><span>|</span><label class="collapse" for="c-42175205">[-]</label><label class="expand" for="c-42175205">[1 more]</label></div><br/><div class="children"><div class="content">I omitted that code to keep the article simpler. We want to turn off the animation on keyboard, and move the focus to different things depending on if it&#x27;s a keyboard or pointer user.</div><br/></div></div></div></div><div id="42174434" class="c"><input type="checkbox" id="c-42174434" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#42174146">root</a><span>|</span><a href="#42174263">parent</a><span>|</span><a href="#42174460">prev</a><span>|</span><a href="#42175325">next</a><span>|</span><label class="collapse" for="c-42174434">[-]</label><label class="expand" for="c-42174434">[1 more]</label></div><br/><div class="children"><div class="content">Right, but the article doesn&#x27;t explain <i>why</i> they cared whether it was keyboard or mouse activation. The linked WebKit bug goes into more detail, but it&#x27;s still lacking an explanation of why alternative, more common and widely deployed strategies (like having a capturing keyup event that triggers earlier in the render loop) wouldn&#x27;t be a better idea instead.<p>Also, if you <i>really</i> want to determine whether a MouseEvent is &quot;real&quot; or &quot;synthetic&quot;, and you don&#x27;t want to worry about when mouse events are triggered relative to keyboard events in the event loop (although it doesn&#x27;t seem very hard to keep track of), it seems like you can use the current click count (i.e., event.detail). This works on both Chrome and Safari—it&#x27;s 1 for mouse clicks, and 0 for keyboard &quot;clicks&quot;, but the spec text is also a little contradictory and under-specified: the &quot;click&quot; event handler says that &quot;the attribute value MUST be 1 when the user begins this action and increments by 1 for each click&quot; (<a href="https:&#x2F;&#x2F;w3c.github.io&#x2F;uievents&#x2F;#event-type-click" rel="nofollow">https:&#x2F;&#x2F;w3c.github.io&#x2F;uievents&#x2F;#event-type-click</a>) but it also says &quot;This MUST be a non-negative integer indicating the number of consecutive clicks of a pointing device button within a specific time&quot; (<a href="https:&#x2F;&#x2F;w3c.github.io&#x2F;uievents&#x2F;#current-click-count" rel="nofollow">https:&#x2F;&#x2F;w3c.github.io&#x2F;uievents&#x2F;#current-click-count</a>), and the definition of &quot;pointing device button&quot; seems to exclude synthetic keyboard events (since those are handled separately)</div><br/></div></div></div></div></div></div><div id="42175325" class="c"><input type="checkbox" id="c-42175325" checked=""/><div class="controls bullet"><span class="by">andy_ppp</span><span>|</span><a href="#42174146">prev</a><span>|</span><a href="#42180768">next</a><span>|</span><label class="collapse" for="c-42175325">[-]</label><label class="expand" for="c-42175325">[3 more]</label></div><br/><div class="children"><div class="content">What is the correct way to check if you have a mouse click rather than a keyboard click? I would be tempted to set a module level flag based on what most recently happened - if there was a &quot;mousedown&quot; event more recently we&#x27;ll set isKeyboard to false and isMouse to true and vice-versa if &quot;keydown&quot; is pressed.<p>Then we wouldn&#x27;t need the isInvokedByMouse and isInvokedByKeyboard functions.<p>Is there a better way? Relying on screen coordinates for this is highly dubious and I would argue a hack.</div><br/><div id="42177759" class="c"><input type="checkbox" id="c-42177759" checked=""/><div class="controls bullet"><span class="by">matijs</span><span>|</span><a href="#42175325">parent</a><span>|</span><a href="#42180768">next</a><span>|</span><label class="collapse" for="c-42177759">[-]</label><label class="expand" for="c-42177759">[2 more]</label></div><br/><div class="children"><div class="content">`event.detail` [1] is 0 for keyboard “clicks” and 1 for pointer clicks.<p>1: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;UIEvent&#x2F;detail" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;UIEvent&#x2F;det...</a></div><br/><div id="42180562" class="c"><input type="checkbox" id="c-42180562" checked=""/><div class="controls bullet"><span class="by">andy_ppp</span><span>|</span><a href="#42175325">root</a><span>|</span><a href="#42177759">parent</a><span>|</span><a href="#42180768">next</a><span>|</span><label class="collapse" for="c-42180562">[-]</label><label class="expand" for="c-42180562">[1 more]</label></div><br/><div class="children"><div class="content">The whole point of the learning from this article is don’t use hacks and make assumptions about what is happening. This is not for that, this is about how many clicks happened. You might get away with it but it’s not good code.</div><br/></div></div></div></div></div></div><div id="42180768" class="c"><input type="checkbox" id="c-42180768" checked=""/><div class="controls bullet"><span class="by">hansottowirtz</span><span>|</span><a href="#42175325">prev</a><span>|</span><a href="#42177947">next</a><span>|</span><label class="collapse" for="c-42180768">[-]</label><label class="expand" for="c-42180768">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of a bug on our website where a bright green image turned to yellow on an external monitor. Turns out it is a color space issue on wide gamut screens [1].<p>[1] <a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;41483538" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;41483538</a></div><br/></div></div><div id="42177947" class="c"><input type="checkbox" id="c-42177947" checked=""/><div class="controls bullet"><span class="by">owaislone</span><span>|</span><a href="#42180768">prev</a><span>|</span><a href="#42180046">next</a><span>|</span><label class="collapse" for="c-42177947">[-]</label><label class="expand" for="c-42177947">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting but why would a browser report different coordinates depending on the monitor? I&#x27;d assume browser would treat the webpage as if it was the entire screen irrespective of which display it was on. Is there a reason for web APIs to have this information at all? Seems like a potential security&#x2F;information&#x2F;tracking risk.</div><br/></div></div><div id="42180046" class="c"><input type="checkbox" id="c-42180046" checked=""/><div class="controls bullet"><span class="by">joshtumath</span><span>|</span><a href="#42177947">prev</a><span>|</span><a href="#42174114">next</a><span>|</span><label class="collapse" for="c-42180046">[-]</label><label class="expand" for="c-42180046">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve just posted another blog post to provide context and answer some questions people had. Like why are we checking screenX === 0 in the first place? Why do we want different behaviour depending on keyboard or mouse inputs? And I&#x27;ve explain how I&#x27;ve refactored it to prevent more mishaps. I hope it&#x27;s helpful.<p><a href="https:&#x2F;&#x2F;www.joshtumath.uk&#x2F;posts&#x2F;2024-11-18-how-i-refactored-the-bbc-navigation-bar-and-a-follow-up-faq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joshtumath.uk&#x2F;posts&#x2F;2024-11-18-how-i-refactored-...</a></div><br/></div></div><div id="42174114" class="c"><input type="checkbox" id="c-42174114" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#42180046">prev</a><span>|</span><a href="#42179424">next</a><span>|</span><label class="collapse" for="c-42174114">[-]</label><label class="expand" for="c-42174114">[1 more]</label></div><br/><div class="children"><div class="content">I’m impressed he wrote a blog without having to get authorisation from a dozen layers of bbc management and lawyers.</div><br/></div></div><div id="42179424" class="c"><input type="checkbox" id="c-42179424" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#42174114">prev</a><span>|</span><a href="#42179691">next</a><span>|</span><label class="collapse" for="c-42179424">[-]</label><label class="expand" for="c-42179424">[1 more]</label></div><br/><div class="children"><div class="content">Skill issue? Should&#x27;ve used viewport, not screen coordinates (read with .clientX and .clientY). I don&#x27;t see why negative values in screen space is a bug.<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;CSSOM_view&#x2F;Coordinate_systems#viewport" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;CSSOM_view&#x2F;...</a></div><br/></div></div><div id="42179691" class="c"><input type="checkbox" id="c-42179691" checked=""/><div class="controls bullet"><span class="by">jccalhoun</span><span>|</span><a href="#42179424">prev</a><span>|</span><a href="#42176476">next</a><span>|</span><label class="collapse" for="c-42179691">[-]</label><label class="expand" for="c-42179691">[1 more]</label></div><br/><div class="children"><div class="content">Am I missing something? Why are things highlighted in blue? And why is &quot; on Chrome and Firefox, the screenX and screenY properties were negative numbers&quot; repeated so often? I had to go back to reread to make sure I didn&#x27;t somehow skip back a few lines without noticing it.</div><br/></div></div><div id="42176476" class="c"><input type="checkbox" id="c-42176476" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#42179691">prev</a><span>|</span><a href="#42176362">next</a><span>|</span><label class="collapse" for="c-42176476">[-]</label><label class="expand" for="c-42176476">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I checked the (DOM UI Events) spec to see if that was correct, but there didn&#x27;t seem to be any specific information about it<p>Story of my life is finding out the details that apparently matter when I am debugging stuff has not been actually written in the spec (any)</div><br/></div></div><div id="42176362" class="c"><input type="checkbox" id="c-42176362" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#42176476">prev</a><span>|</span><a href="#42174685">next</a><span>|</span><label class="collapse" for="c-42176362">[-]</label><label class="expand" for="c-42176362">[1 more]</label></div><br/><div class="children"><div class="content">Checking for position != 0 still does not fix it. On Windows and Linux, it is possible for a window to span multiple displays. Someone could set things up so that a valid click target for the button ends up in the (0, 0) position.</div><br/></div></div><div id="42174685" class="c"><input type="checkbox" id="c-42174685" checked=""/><div class="controls bullet"><span class="by">G1N</span><span>|</span><a href="#42176362">prev</a><span>|</span><a href="#42174148">next</a><span>|</span><label class="collapse" for="c-42174685">[-]</label><label class="expand" for="c-42174685">[4 more]</label></div><br/><div class="children"><div class="content">RE this line of code at the bottom of the article:<p><pre><code>  const isInvokedByMouse = event =&gt;
  event.type === &#x27;click&#x27; &amp;&amp; (event.screenX !== 0 || event.screenY !== 0);
</code></pre>
Why do you even have to check if screenX and screenY are non-zero (as opposed to just checking typeof event.screenX == &quot;number&quot;)? Wouldn&#x27;t that mean (and this is a wild edge-case) that if someone positioned their browser window so that the menu was in the top left corner (at position 0,0) the event handler would break again? Is this to block synthetic click events like (&lt;div &#x2F;&gt;).click()? Keyboard events don&#x27;t have a screenX or screenY from what I remember as well.</div><br/><div id="42180262" class="c"><input type="checkbox" id="c-42180262" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#42174685">parent</a><span>|</span><a href="#42175051">next</a><span>|</span><label class="collapse" for="c-42180262">[-]</label><label class="expand" for="c-42180262">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Keyboard events don&#x27;t have a screenX or screenY from what I remember as well.</i><p>Remember that this is on &#x27;click&#x27; events. The &#x27;click&#x27; event type is a bit of a misnomer: it’s arguably more “activate” than “click”, because (depending a little on platform conventions) it also triggers on Space&#x2F;Enter if the element is focused. But importantly <i>it’s still a &#x27;click&#x27; event</i>: so it’s still a PointerEvent, not a KeyboardEvent. Since various of the fields aren’t appropriate, they get zeroed. So, screenX == 0 &amp;&amp; screenY == 0 means either that the pointer is at the top left of the screen, or that the event was not generated by a pointer (that is, by a keyboard).<p>Try it out yourself, if you like, by loading a URL like this and activating by keyboard and by mouse and comparing the events.<p><pre><code>  data:text&#x2F;html,&lt;button onclick=console.log(event)&gt;
</code></pre>
In reality, if you used such a check more generally, you’d find it wasn’t <i>such</i> a rare edge case: if the page is fullscreen, corner clicking is actually pretty common, and if you have buttons that are supposed to be in the corner, they should certainly activate on exact-corner clicks. (See also Fitt’s law &lt;<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fitts&#x27;s_law#Implications_for_UI_design:~:text=This%20effect%20can%20be%20exaggerated%20at%20the%20four%20corners%20of%20a%20screen.,theoretically%20infinitely%20big%20button." rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fitts&#x27;s_law#Implications_for_U...</a>&gt;.)<p>Fortunately, there’s a proper fix: `event.pointerId === -1` indicates non-pointer (<i>viz.</i> keyboard) activation.</div><br/></div></div><div id="42175051" class="c"><input type="checkbox" id="c-42175051" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#42174685">parent</a><span>|</span><a href="#42180262">prev</a><span>|</span><a href="#42179466">next</a><span>|</span><label class="collapse" for="c-42175051">[-]</label><label class="expand" for="c-42175051">[1 more]</label></div><br/><div class="children"><div class="content">This is just a heuristic to determine if the event is keydown or click.<p>In the article the author says that the issue is that the same function is handling both events, and they will work on refactoring it to something better.<p>The normal approach is just have different functions answering to different events. Or using more precise information about the event [1], instead of a heuristic.<p>[1] A suggestion was made by this poster: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42174436">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42174436</a></div><br/></div></div><div id="42179466" class="c"><input type="checkbox" id="c-42179466" checked=""/><div class="controls bullet"><span class="by">aetherspawn</span><span>|</span><a href="#42174685">parent</a><span>|</span><a href="#42175051">prev</a><span>|</span><a href="#42174148">next</a><span>|</span><label class="collapse" for="c-42179466">[-]</label><label class="expand" for="c-42179466">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, comparing to zero is still the wrong thing to do, was dissatisfied after reading the article because the problem still isn&#x27;t really solved.. just swapping one spooky edge case with another.<p>Who knows, they probably broke the menu for keyboard navigation, voice navigation, eye tracking or something like that. This is one of those cases where you could really &quot;make it make sense&quot; by just using something CSS based.</div><br/></div></div></div></div><div id="42174148" class="c"><input type="checkbox" id="c-42174148" checked=""/><div class="controls bullet"><span class="by">duxup</span><span>|</span><a href="#42174685">prev</a><span>|</span><a href="#42175215">next</a><span>|</span><label class="collapse" for="c-42174148">[-]</label><label class="expand" for="c-42174148">[10 more]</label></div><br/><div class="children"><div class="content">Why are screenX and screenY relevant here as far as their code goes?<p>Where they using those values in their code?<p>Very interesting article but I&#x27;m missing the step where it would impact their code ...</div><br/><div id="42174292" class="c"><input type="checkbox" id="c-42174292" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#42174148">parent</a><span>|</span><a href="#42175215">next</a><span>|</span><label class="collapse" for="c-42174292">[-]</label><label class="expand" for="c-42174292">[9 more]</label></div><br/><div class="children"><div class="content">...because when they are 0 one can infer that the event came from a keypress rather than a mouse.  They want to know this.</div><br/><div id="42174436" class="c"><input type="checkbox" id="c-42174436" checked=""/><div class="controls bullet"><span class="by">shdon</span><span>|</span><a href="#42174148">root</a><span>|</span><a href="#42174292">parent</a><span>|</span><a href="#42174868">next</a><span>|</span><label class="collapse" for="c-42174436">[-]</label><label class="expand" for="c-42174436">[3 more]</label></div><br/><div class="children"><div class="content">Then it would make a lot more sense to check event.pointerType == &#x27;mouse&#x27; vs event.pointerType == &#x27;&#x27; (for keyboard)</div><br/><div id="42175287" class="c"><input type="checkbox" id="c-42175287" checked=""/><div class="controls bullet"><span class="by">jorams</span><span>|</span><a href="#42174148">root</a><span>|</span><a href="#42174436">parent</a><span>|</span><a href="#42175068">next</a><span>|</span><label class="collapse" for="c-42175287">[-]</label><label class="expand" for="c-42175287">[1 more]</label></div><br/><div class="children"><div class="content">That does seem quite obviously better. Even when insisting on checking coordinates why use the coordinate system carried by the event that you have the <i>least</i> control over. Why not .pageX&#x2F;.pageY, which can&#x27;t trigger the failure case as long as you make sure the element isn&#x27;t in the far top left.</div><br/></div></div></div></div><div id="42174868" class="c"><input type="checkbox" id="c-42174868" checked=""/><div class="controls bullet"><span class="by">G1N</span><span>|</span><a href="#42174148">root</a><span>|</span><a href="#42174292">parent</a><span>|</span><a href="#42174436">prev</a><span>|</span><a href="#42175013">next</a><span>|</span><label class="collapse" for="c-42174868">[-]</label><label class="expand" for="c-42174868">[1 more]</label></div><br/><div class="children"><div class="content">Based on the other replies here it seems like it&#x27;s to differentiate taps vs mouse clicks, keyboard events in js don&#x27;t have a screenX or screenY property (you can run this in your browser console on this HN post to confirm):<p><pre><code>  (() =&gt; {
    const logEvent = event =&gt; console.log({
      coords: [event.screenX, event.screenY],
      type: event.type
    });
    const input = document.querySelector(&quot;textarea&quot;);
    &#x2F;&#x2F; use &quot;keydown&quot; instead of &quot;keypress&quot; to detect all keyboard input instead of just character producing input 
    input.addEventListener(&quot;keydown&quot;, logEvent);
    input.addEventListener(&quot;click&quot;, logEvent);
  })();
</code></pre>
Type in or click on the reply text input and you&#x27;ll see that the coords array is undefined for all keyboard events. I haven&#x27;t tried this equivalent on a touch device however, so not sure how it&#x27;s handled there.</div><br/></div></div><div id="42175013" class="c"><input type="checkbox" id="c-42175013" checked=""/><div class="controls bullet"><span class="by">hyperhopper</span><span>|</span><a href="#42174148">root</a><span>|</span><a href="#42174292">parent</a><span>|</span><a href="#42174868">prev</a><span>|</span><a href="#42175215">next</a><span>|</span><label class="collapse" for="c-42175013">[-]</label><label class="expand" for="c-42175013">[4 more]</label></div><br/><div class="children"><div class="content">This does not work when the mouse is actually at 0,0</div><br/><div id="42175496" class="c"><input type="checkbox" id="c-42175496" checked=""/><div class="controls bullet"><span class="by">xboxnolifes</span><span>|</span><a href="#42174148">root</a><span>|</span><a href="#42175013">parent</a><span>|</span><a href="#42175215">next</a><span>|</span><label class="collapse" for="c-42175496">[-]</label><label class="expand" for="c-42175496">[3 more]</label></div><br/><div class="children"><div class="content">An imperfect solution for a situation that will practically never happen and have no noticeable downside.</div><br/><div id="42179370" class="c"><input type="checkbox" id="c-42179370" checked=""/><div class="controls bullet"><span class="by">noworriesnate</span><span>|</span><a href="#42174148">root</a><span>|</span><a href="#42175496">parent</a><span>|</span><a href="#42175215">next</a><span>|</span><label class="collapse" for="c-42179370">[-]</label><label class="expand" for="c-42179370">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;ll screw up UI tests</div><br/><div id="42179861" class="c"><input type="checkbox" id="c-42179861" checked=""/><div class="controls bullet"><span class="by">xboxnolifes</span><span>|</span><a href="#42174148">root</a><span>|</span><a href="#42179370">parent</a><span>|</span><a href="#42175215">next</a><span>|</span><label class="collapse" for="c-42179861">[-]</label><label class="expand" for="c-42179861">[1 more]</label></div><br/><div class="children"><div class="content">Clearly not, otherwise this bug would have been found much sooner.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42175215" class="c"><input type="checkbox" id="c-42175215" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42174148">prev</a><span>|</span><a href="#42180076">next</a><span>|</span><label class="collapse" for="c-42175215">[-]</label><label class="expand" for="c-42175215">[1 more]</label></div><br/><div class="children"><div class="content">I would not write a blog post advertizing how I filed a bug with WebKit for my own coding 101 error: unsafe assumptions and relying on side effects and heuristics.<p>Actually not just 101, it&#x27;s basically with all of us at all levels and for life. So they&#x27;re in good company having made a mistake everyone makes all the time, but it was a mistake on their part not a bug in WebKit, nore even a &quot;interoperability issue&quot; in WebKit or any browser.<p>They say they weren&#x27;t aware that negative values were possible and that different browsers produce different values.<p>Ok, but neither of those matters.<p>If the function is even allowed to contain or express a negative value (IE right at the lowest basic level, is the returned data type actually a uint, or is it <i>anything else</i>? a regular int? a string?) then negetive values were always a possibility even if you personally never saw one before. Saying &quot;I didn&#x27;t expect a number below 0&quot; is barely any different from saying &quot;I didn&#x27;t expect a number above 10000&quot;.<p>The discrepency between browsers doesn&#x27;t matter and isn&#x27;t the browsers fault that it tripped you up. You just made a standard boring unsafe assumption like every other programmer ever.<p>The entire problem is that you cared about something you don&#x27;t actually care about.<p>You assumed that there was meaning in the absolute position of the window or the mouse pointer, when there never was, and you don&#x27;t actually care about those anyway. The absolute position is like the actual internal-only row number in a db. Every row has a unique one, but it&#x27;s none of your business what it is. There is only meaning in it&#x27;s position relative to something else like a button, or relative to it&#x27;s previous position to track movement.<p>Similarly checking for 0,0 and assuming that means keyboard is just another false heuristic that doesn&#x27;t actually prove any such thing. The specs may or may not promise that the value will be 0,0 in the event of a keyboard initiated click, but no way it says that it can&#x27;t be 0,0 any other way.<p>Don&#x27;t de ashamed of this error because it&#x27;s common, but don&#x27;t be proud of calling these WebKit or browser interoperability bugs.<p>Do write up and publish the experience though as a warning and lesson to new developers about assumptions and heuristics and relying on side effects that just happen to work on the developers laptop when they tried it once and shipped it.<p>Also &quot;it&#x27;s for accessibility&quot; doesn&#x27;t change anything. Trying to be too smart just makes it worse. Actually that&#x27;s true just generally for everything.</div><br/></div></div><div id="42180076" class="c"><input type="checkbox" id="c-42180076" checked=""/><div class="controls bullet"><span class="by">tonymet</span><span>|</span><a href="#42175215">prev</a><span>|</span><a href="#42176168">next</a><span>|</span><label class="collapse" for="c-42180076">[-]</label><label class="expand" for="c-42180076">[1 more]</label></div><br/><div class="children"><div class="content">Most people applaud the tech skills needed to reproduce this bug (I do too).  Some people shiver at the Mount Everest of clumsy JavaScript code needed to provide a usable web experience.<p>Can you believe that every app has a team of people who just maintain the app&#x27;s code?</div><br/></div></div><div id="42176168" class="c"><input type="checkbox" id="c-42176168" checked=""/><div class="controls bullet"><span class="by">kernal</span><span>|</span><a href="#42180076">prev</a><span>|</span><a href="#42176980">next</a><span>|</span><label class="collapse" for="c-42176168">[-]</label><label class="expand" for="c-42176168">[1 more]</label></div><br/><div class="children"><div class="content">That flickering Ace Attorney GIF was extremely annoying.</div><br/></div></div></div></div></div></div></div></body></html>