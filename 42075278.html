<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731661284293" as="style"/><link rel="stylesheet" href="styles.css?v=1731661284293"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.jeremyong.com/winapi/io/2024/11/03/windows-memory-mapped-file-io/">Windows Memory Mapped File IO</a> <span class="domain">(<a href="https://www.jeremyong.com">www.jeremyong.com</a>)</span></div><div class="subtext"><span>ibobev</span> | <span>8 comments</span></div><br/><div><div id="42144637" class="c"><input type="checkbox" id="c-42144637" checked=""/><div class="controls bullet"><span class="by">fjfaase</span><span>|</span><a href="#42144571">next</a><span>|</span><label class="collapse" for="c-42144637">[-]</label><label class="expand" for="c-42144637">[4 more]</label></div><br/><div class="children"><div class="content">A memory mapped file can be used to store complex object oriented structures if you make use of &#x27;relative&#x27; pointers, where you have to add the address of the pointer to the pointer to get to the object you are pointing to. I once used this method, to persist a complex data structure without having to write serialization code.<p>A long time ago, I implemented some C++ classes that would hide most of the additional work and also took care of allocating new objects inside the memory mapped file. See: <a href="https:&#x2F;&#x2F;www.iwriteiam.nl&#x2F;D0205.html#13MMF" rel="nofollow">https:&#x2F;&#x2F;www.iwriteiam.nl&#x2F;D0205.html#13MMF</a> (Note that this implementation actually makes use of a slightly different approach where pointers are relative with respect to the first position of the file. This implementation has the limitation that you can only open one such store as a memory mapped file. It was only later I realized that it was possible to do without the offset. I never came to rewriting all the code.)</div><br/><div id="42144680" class="c"><input type="checkbox" id="c-42144680" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#42144637">parent</a><span>|</span><a href="#42144651">next</a><span>|</span><label class="collapse" for="c-42144680">[-]</label><label class="expand" for="c-42144680">[1 more]</label></div><br/><div class="children"><div class="content">Boost.Container [1] has reimplementations of the STL containers that use offsets to be compatible with memory-mapped files. Boost.Interprocess [2] has some other useful types, such as smart pointers that are compatible with memory-mapped files, along with platform-independent APIs for handling them.<p>[1] <a href="https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_86_0&#x2F;doc&#x2F;html&#x2F;container.html#container.intro.introduction_building_container" rel="nofollow">https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_86_0&#x2F;doc&#x2F;html&#x2F;container.htm...</a><p>[2] <a href="https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_86_0&#x2F;doc&#x2F;html&#x2F;interprocess.html" rel="nofollow">https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_86_0&#x2F;doc&#x2F;html&#x2F;interprocess....</a></div><br/></div></div><div id="42144651" class="c"><input type="checkbox" id="c-42144651" checked=""/><div class="controls bullet"><span class="by">anon291</span><span>|</span><a href="#42144637">parent</a><span>|</span><a href="#42144680">prev</a><span>|</span><a href="#42144650">next</a><span>|</span><label class="collapse" for="c-42144651">[-]</label><label class="expand" for="c-42144651">[1 more]</label></div><br/><div class="children"><div class="content">Most stl classes will work just fine with smart pointers. For example, std::vector takes a custom allocator. You can have the allocators pointer type be a custom pointer class. The pointer class is a wrapper over an offset that is the same size as the native word.<p>Then the operator-&gt; is just (this + offset).<p>I&#x27;ve used this approach successfully in many projects. If you&#x27;re worried about differing stls(probably a reasonable worry here), then use any of the boost containers.</div><br/></div></div><div id="42144650" class="c"><input type="checkbox" id="c-42144650" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#42144637">parent</a><span>|</span><a href="#42144651">prev</a><span>|</span><a href="#42144571">next</a><span>|</span><label class="collapse" for="c-42144650">[-]</label><label class="expand" for="c-42144650">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; complex object oriented structures if you make use of &#x27;relative&#x27; pointers
</code></pre>
You just described the original MsOffice file formats (and given many people who ever tried to parse them a PTSD shock)</div><br/></div></div></div></div><div id="42144571" class="c"><input type="checkbox" id="c-42144571" checked=""/><div class="controls bullet"><span class="by">majke</span><span>|</span><a href="#42144637">prev</a><span>|</span><a href="#42144815">next</a><span>|</span><label class="collapse" for="c-42144571">[-]</label><label class="expand" for="c-42144571">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A legitimate problem here is the case where you need to read from or write to many locations at once. With the memory-mapped scheme as described, you can only issue as many concurrent page faults as you have threads in the program.<p>&gt; Unfortunately, I don’t have great answers here, and view this as a legitimate use case that warrants a dedicated code path using other mechanisms at your disposal.<p>Right. I think it’s similar on linux. Mmap makes sense until  the data size is too large and tlb misses start to add up.</div><br/><div id="42144758" class="c"><input type="checkbox" id="c-42144758" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42144571">parent</a><span>|</span><a href="#42144815">next</a><span>|</span><label class="collapse" for="c-42144758">[-]</label><label class="expand" for="c-42144758">[1 more]</label></div><br/><div class="children"><div class="content">Why would the TLB misses be any different than if you read the file into memory?<p>The article is describing a separate problem where you can’t issue concurrent reads although that doesn’t feel true if you make use of madvise.</div><br/></div></div></div></div><div id="42144815" class="c"><input type="checkbox" id="c-42144815" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42144571">prev</a><span>|</span><label class="collapse" for="c-42144815">[-]</label><label class="expand" for="c-42144815">[1 more]</label></div><br/><div class="children"><div class="content">Article assumes that reads&#x2F;writes can only ever fail if working with remote files.</div><br/></div></div></div></div></div></div></div></body></html>