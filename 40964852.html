<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721034065349" as="style"/><link rel="stylesheet" href="styles.css?v=1721034065349"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zeromq.org/">ZeroMQ: High-Performance Concurrency Framework</a> <span class="domain">(<a href="https://zeromq.org">zeromq.org</a>)</span></div><div class="subtext"><span>klaussilveira</span> | <span>28 comments</span></div><br/><div><div id="40964974" class="c"><input type="checkbox" id="c-40964974" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#40965364">next</a><span>|</span><label class="collapse" for="c-40964974">[-]</label><label class="expand" for="c-40964974">[10 more]</label></div><br/><div class="children"><div class="content">ZeroMQ was followed by nanomsg (<a href="https:&#x2F;&#x2F;nanomsg.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nanomsg.org&#x2F;</a>) and nng (<a href="https:&#x2F;&#x2F;nng.nanomsg.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nng.nanomsg.org&#x2F;</a>)<p>Some of Martin&#x27;s rationale here:<p><a href="https:&#x2F;&#x2F;250bpm.com&#x2F;blog:23&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;250bpm.com&#x2F;blog:23&#x2F;index.html</a><p>ZeroMQ is still widely used and popular, but I am not sure if it is still actively developed.</div><br/><div id="40965019" class="c"><input type="checkbox" id="c-40965019" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40964974">parent</a><span>|</span><a href="#40965823">next</a><span>|</span><label class="collapse" for="c-40965019">[-]</label><label class="expand" for="c-40965019">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used zeromq, nanomsg, and nng. The differences are subtle and focused on native library support, background threading model, and other systems level things.<p>All of them are based on specs that are widely published. I&#x27;ve had zero problems implementing real robotic systems in nng, zmq, etc.<p>And it is so damn easy to use it&#x27;s amazing to me the whole world doesn&#x27;t use it.</div><br/><div id="40966265" class="c"><input type="checkbox" id="c-40966265" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40964974">root</a><span>|</span><a href="#40965019">parent</a><span>|</span><a href="#40965417">next</a><span>|</span><label class="collapse" for="c-40966265">[-]</label><label class="expand" for="c-40966265">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had some bad experiences with zeromq in robotic systems contexts: it&#x27;s very assert-happy, and therefore tends to bring down the whole process in corner cases, and it&#x27;s quite difficult to debug. It caused me quite a lot of headache and I&#x27;m no longer particularly enamored of the approach (the internal architecture is one which makes error propagation very difficult, so even if the individual bugs were fixed there&#x27;s not a good overall handling strategy).</div><br/></div></div><div id="40965417" class="c"><input type="checkbox" id="c-40965417" checked=""/><div class="controls bullet"><span class="by">AnonHP</span><span>|</span><a href="#40964974">root</a><span>|</span><a href="#40965019">parent</a><span>|</span><a href="#40966265">prev</a><span>|</span><a href="#40965200">next</a><span>|</span><label class="collapse" for="c-40965417">[-]</label><label class="expand" for="c-40965417">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And it is so damn easy to use it&#x27;s amazing to me the whole world doesn&#x27;t use it.<p>Perhaps many of them are locked into “the cloud” and “serverless”, by default choosing the proprietary solutions offered by these providers on their platforms?</div><br/></div></div><div id="40965200" class="c"><input type="checkbox" id="c-40965200" checked=""/><div class="controls bullet"><span class="by">throwaway984393</span><span>|</span><a href="#40964974">root</a><span>|</span><a href="#40965019">parent</a><span>|</span><a href="#40965417">prev</a><span>|</span><a href="#40965823">next</a><span>|</span><label class="collapse" for="c-40965200">[-]</label><label class="expand" for="c-40965200">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure the world doesn&#x27;t use it more because it doesn&#x27;t have a flashy marketing campaign and trendy developer tools&#x2F;libraries don&#x27;t have a plugin for it. If a whole bunch of developers aren&#x27;t writing blog posts about it, does it even exist? Plus, it&#x27;s <i>old</i>, so it&#x27;s bad.</div><br/></div></div></div></div><div id="40965823" class="c"><input type="checkbox" id="c-40965823" checked=""/><div class="controls bullet"><span class="by">nlnn</span><span>|</span><a href="#40964974">parent</a><span>|</span><a href="#40965019">prev</a><span>|</span><a href="#40965270">next</a><span>|</span><label class="collapse" for="c-40965823">[-]</label><label class="expand" for="c-40965823">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been looking at these recently for a project.<p>nng looks promising, but the guide from zmq seemed like a killer feature. It describes all sorts of high level patterns, gotchas, etc.<p>For nng I mostly found API documentation, which made me a bit more cautious (though to be fair, I&#x27;ve not tried it yet).</div><br/><div id="40965906" class="c"><input type="checkbox" id="c-40965906" checked=""/><div class="controls bullet"><span class="by">masfoobar</span><span>|</span><a href="#40964974">root</a><span>|</span><a href="#40965823">parent</a><span>|</span><a href="#40965270">next</a><span>|</span><label class="collapse" for="c-40965906">[-]</label><label class="expand" for="c-40965906">[1 more]</label></div><br/><div class="children"><div class="content">I have used ZeroMQ with C, Dlang, and Python -- mostly for learning.<p>However, I have used NetMQ.. a C# implementation of ZeroMQ in live software and the results are very positive!<p>I used a Pub-Sub pattern for one program to keep users informed on progress of a task, which could have taken hours to complete. They had a GUI program which spits out updates. It worked really well.<p>I was also tasked updating a Till software, which the integration of orders to the central system was extremely slow. I used NetMQ which was looking extremely successful but was put on hold due to IT manager not understanding Software Developers -- if something starts taking more than a week to do (which I stated I needed a month) they get itchy and move onto to something else. Sadly, that never got completed.<p>Now, I have played with NNG and there are some interested articles (or hidden pages from memory) about companring NNG to ZeroMQ - it seems the &quot;patterns&quot; are simplified.<p>I am currently in the progress of creating bindings for NNG. Seems to be pretty good, so far. I plan to move away from NetMQ (C#) in favour of this language moving forward.<p>Whether you use ZeroMQ or NNG - I dont think you can go wrong. It is all about the process more than anything, ensuring you do not lose data.</div><br/></div></div></div></div><div id="40965270" class="c"><input type="checkbox" id="c-40965270" checked=""/><div class="controls bullet"><span class="by">mindslight</span><span>|</span><a href="#40964974">parent</a><span>|</span><a href="#40965823">prev</a><span>|</span><a href="#40965364">next</a><span>|</span><label class="collapse" for="c-40965270">[-]</label><label class="expand" for="c-40965270">[3 more]</label></div><br/><div class="children"><div class="content">I looked at 0mq et al, and what I couldn&#x27;t understand is why sockets have a single exclusive type. Like say I want a process that generally sends out streaming broadcast updates, but is also controlled through request-reply. It would need two separate sockets. Then I&#x27;d have to reinvent some sort of ordering protocol across the two (as well as program logic to handle the partially-connected state), which would defeat much of the point of using 0mq?</div><br/><div id="40965953" class="c"><input type="checkbox" id="c-40965953" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#40964974">root</a><span>|</span><a href="#40965270">parent</a><span>|</span><a href="#40966083">next</a><span>|</span><label class="collapse" for="c-40965953">[-]</label><label class="expand" for="c-40965953">[1 more]</label></div><br/><div class="children"><div class="content">Without knowing any details, it sounds like a hard problem whether you use 0mq or not.</div><br/></div></div><div id="40966083" class="c"><input type="checkbox" id="c-40966083" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#40964974">root</a><span>|</span><a href="#40965270">parent</a><span>|</span><a href="#40965953">prev</a><span>|</span><a href="#40965364">next</a><span>|</span><label class="collapse" for="c-40966083">[-]</label><label class="expand" for="c-40966083">[1 more]</label></div><br/><div class="children"><div class="content">news = -setup broadcast socket-<p>orders = -setup req rep socket-<p>while 1:<p>----order = orders.read (with timeout)<p>----orders.send(ack)<p>----if order:<p>--------do stuff differently<p>----news.send(status)</div><br/></div></div></div></div></div></div><div id="40965364" class="c"><input type="checkbox" id="c-40965364" checked=""/><div class="controls bullet"><span class="by">sigmonsays</span><span>|</span><a href="#40964974">prev</a><span>|</span><a href="#40965600">next</a><span>|</span><label class="collapse" for="c-40965364">[-]</label><label class="expand" for="c-40965364">[3 more]</label></div><br/><div class="children"><div class="content">I would rather use sockets. 
Not getting errors when a client times out is a bad api design to me.
I&#x27;ve used zeromq an only kept it around for IPC.<p>I may have been doing it wrong, but i personally want to know when clients disconnect&#x2F;reconnect&#x2F;etc. the API seems to hide all that from you and your send or recv just block.</div><br/><div id="40966258" class="c"><input type="checkbox" id="c-40966258" checked=""/><div class="controls bullet"><span class="by">ohnoesjmr</span><span>|</span><a href="#40965364">parent</a><span>|</span><a href="#40965477">next</a><span>|</span><label class="collapse" for="c-40966258">[-]</label><label class="expand" for="c-40966258">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much this.<p>I always found it crazy how zmq gained any traction at all.<p>&quot;Oh, I have a req&#x2F;resp workload&quot; - one of the sides restarts, goes out of rhythm with the state of the connection (whether its req or resp), unrecoverable errors.<p>Every system I&#x27;ve seen use zmq usually use it without these fancy patterns (use yeet messages in any order), and usually have some sort of &quot;Is anybody there on the other side?&quot; message to combat the fact there is no way to introspect connection state (otherwise your writes just block at the high water mark), at which point it would have been easier to just use tcp.<p>The whole thing to me reeks of mongo. It&#x27;s great if you are completely incapable&#x2F;incompetent of solving the problem properly.</div><br/></div></div><div id="40965477" class="c"><input type="checkbox" id="c-40965477" checked=""/><div class="controls bullet"><span class="by">haneul</span><span>|</span><a href="#40965364">parent</a><span>|</span><a href="#40966258">prev</a><span>|</span><a href="#40965600">next</a><span>|</span><label class="collapse" for="c-40965477">[-]</label><label class="expand" for="c-40965477">[1 more]</label></div><br/><div class="children"><div class="content">Imo, ZMQ is more of an abstraction with which to design protocols, rather than a message queue ready to use, Kafka-style. I found unexpectedly that I needed to really read the entire manual and work through the worked examples and some of my own to start getting it, rather than the usual incremental read.<p>So, you can set up a protocol using ZMQ such that you become aware when a client times out, and you can set behavior regarding the high water mark, and other things, but you have to actually do it explicitly - it&#x27;s not required that you do it, because you can choose to maximize throughput or minimize latency instead.<p>But, whatever protocol behavior &#x2F; performance you want, you can pretty much build it with ZMQ. In Python, ZMQ was the only &quot;feasible for my not-a-network-engineer-self&quot; to get a system with 100μs latency with sufficient throughput and guarantees (when used for IPC, although not using the IPC transport type). gRPC was a lot less performant for me, granted it would&#x27;ve been more convenient, but the low latency was a hard need.<p>Although, networks are one of my noobier areas, so I might be blind in many ways here.</div><br/></div></div></div></div><div id="40965600" class="c"><input type="checkbox" id="c-40965600" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#40965364">prev</a><span>|</span><a href="#40965148">next</a><span>|</span><label class="collapse" for="c-40965600">[-]</label><label class="expand" for="c-40965600">[3 more]</label></div><br/><div class="children"><div class="content">As a new dev in 2011, I was unsuccessfully making a http worker thing in Python with Zeromq and I was distracted by their docs were encouraging replacing callback architecture with message passing with inproc queues.</div><br/><div id="40966049" class="c"><input type="checkbox" id="c-40966049" checked=""/><div class="controls bullet"><span class="by">notachatbot1234</span><span>|</span><a href="#40965600">parent</a><span>|</span><a href="#40965148">next</a><span>|</span><label class="collapse" for="c-40966049">[-]</label><label class="expand" for="c-40966049">[2 more]</label></div><br/><div class="children"><div class="content">Is this criticism still relevant? 2011 is 13 years (as in: a teenager&#x27;s life) ago.</div><br/><div id="40966121" class="c"><input type="checkbox" id="c-40966121" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#40965600">root</a><span>|</span><a href="#40966049">parent</a><span>|</span><a href="#40965148">next</a><span>|</span><label class="collapse" for="c-40966121">[-]</label><label class="expand" for="c-40966121">[1 more]</label></div><br/><div class="children"><div class="content">FWIW most discussion about inproc is around 2010, per $SEARCHENGINE. Guess that architecture didnt catch on.</div><br/></div></div></div></div></div></div><div id="40965148" class="c"><input type="checkbox" id="c-40965148" checked=""/><div class="controls bullet"><span class="by">sidcool</span><span>|</span><a href="#40965600">prev</a><span>|</span><a href="#40965311">next</a><span>|</span><label class="collapse" for="c-40965148">[-]</label><label class="expand" for="c-40965148">[7 more]</label></div><br/><div class="children"><div class="content">Anything new with ZeroMQ?  It&#x27;s been around for a long time.</div><br/><div id="40965207" class="c"><input type="checkbox" id="c-40965207" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#40965148">parent</a><span>|</span><a href="#40965311">next</a><span>|</span><label class="collapse" for="c-40965207">[-]</label><label class="expand" for="c-40965207">[6 more]</label></div><br/><div class="children"><div class="content">The licensing was changed about nine months ago. LGPL-3.0+ is out and MPL 2.0 is in. Very thankful for that.</div><br/><div id="40965305" class="c"><input type="checkbox" id="c-40965305" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#40965148">root</a><span>|</span><a href="#40965207">parent</a><span>|</span><a href="#40965922">next</a><span>|</span><label class="collapse" for="c-40965305">[-]</label><label class="expand" for="c-40965305">[3 more]</label></div><br/><div class="children"><div class="content">Why are you thankful for the MPL instead of the LGPL? Is there any advantage to the MPL other than being easier to incorporate MPL code into proprietary software?</div><br/><div id="40965526" class="c"><input type="checkbox" id="c-40965526" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#40965148">root</a><span>|</span><a href="#40965305">parent</a><span>|</span><a href="#40966077">next</a><span>|</span><label class="collapse" for="c-40965526">[-]</label><label class="expand" for="c-40965526">[1 more]</label></div><br/><div class="children"><div class="content">Making the software easier to use from a legal point of view was indeed the reason. 
They explained why they did this here: <a href="https:&#x2F;&#x2F;github.com&#x2F;zeromq&#x2F;libzmq&#x2F;issues&#x2F;2376">https:&#x2F;&#x2F;github.com&#x2F;zeromq&#x2F;libzmq&#x2F;issues&#x2F;2376</a><p>Bottom line is that their licensing with a static linking exception was kind of weird and creating a lot of issues combining zeromq code even with other open source licenses (like Apache 2.0).<p>Interesting to see how they gathered permission to do this from the developer community. License changes like this are usually hard to realize unless you insist on copyright transfers. But in this case they managed to do it without that. So it was a collective decision. Hard to argue with that.</div><br/></div></div><div id="40966077" class="c"><input type="checkbox" id="c-40966077" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40965148">root</a><span>|</span><a href="#40965305">parent</a><span>|</span><a href="#40965526">prev</a><span>|</span><a href="#40965922">next</a><span>|</span><label class="collapse" for="c-40966077">[-]</label><label class="expand" for="c-40966077">[1 more]</label></div><br/><div class="children"><div class="content">Yes, GPL compatibility -- in particular GPL v2 isn&#x27;t compatible with LGPL v3, but it is compatible with MPL.<p>Several projects, including some I work on, only found out how much a mess (L)GPL v2 vs v3 is once important developers had passed away, meaning it&#x27;s very hard to get out of the resulting mess.</div><br/></div></div></div></div><div id="40965922" class="c"><input type="checkbox" id="c-40965922" checked=""/><div class="controls bullet"><span class="by">masfoobar</span><span>|</span><a href="#40965148">root</a><span>|</span><a href="#40965207">parent</a><span>|</span><a href="#40965305">prev</a><span>|</span><a href="#40965272">next</a><span>|</span><label class="collapse" for="c-40965922">[-]</label><label class="expand" for="c-40965922">[1 more]</label></div><br/><div class="children"><div class="content">I always get confused when I see MPL... part of me panics thinking ZeroMQ went with the &quot;Microsoft Public License&quot;<p>:-)</div><br/></div></div><div id="40965272" class="c"><input type="checkbox" id="c-40965272" checked=""/><div class="controls bullet"><span class="by">sidcool</span><span>|</span><a href="#40965148">root</a><span>|</span><a href="#40965207">parent</a><span>|</span><a href="#40965922">prev</a><span>|</span><a href="#40965311">next</a><span>|</span><label class="collapse" for="c-40965272">[-]</label><label class="expand" for="c-40965272">[1 more]</label></div><br/><div class="children"><div class="content">Ah ok.  Was wondering why this was on HN front page today. :)</div><br/></div></div></div></div></div></div><div id="40965311" class="c"><input type="checkbox" id="c-40965311" checked=""/><div class="controls bullet"><span class="by">jobulanus</span><span>|</span><a href="#40965148">prev</a><span>|</span><a href="#40964971">next</a><span>|</span><label class="collapse" for="c-40965311">[-]</label><label class="expand" for="c-40965311">[3 more]</label></div><br/><div class="children"><div class="content">NATS is the ZeroMQ of today.</div><br/><div id="40965322" class="c"><input type="checkbox" id="c-40965322" checked=""/><div class="controls bullet"><span class="by">lgas</span><span>|</span><a href="#40965311">parent</a><span>|</span><a href="#40964971">next</a><span>|</span><label class="collapse" for="c-40965322">[-]</label><label class="expand" for="c-40965322">[2 more]</label></div><br/><div class="children"><div class="content">They aren&#x27;t really the same thing.  NATS is a message queue&#x2F;MOM, ZeroMQ is a smarter abstraction over sockets.</div><br/></div></div></div></div></div></div></div></div></div></body></html>