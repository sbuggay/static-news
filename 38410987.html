<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700902853467" as="style"/><link rel="stylesheet" href="styles.css?v=1700902853467"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.scattered-thoughts.net/writing/there-are-no-strings-on-me/">There are no strings on me</a>Â <span class="domain">(<a href="https://www.scattered-thoughts.net">www.scattered-thoughts.net</a>)</span></div><div class="subtext"><span>luu</span> | <span>7 comments</span></div><br/><div><div id="38412245" class="c"><input type="checkbox" id="c-38412245" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#38411619">next</a><span>|</span><label class="collapse" for="c-38412245">[-]</label><label class="expand" for="c-38412245">[1 more]</label></div><br/><div class="children"><div class="content">Captured objects in closures are another problem in JavaScript.<p>A long time ago I was using a JavaScript framework where  the memory usage went up steadily as you navigated the single page app. One cause was captured variables (referencing large object trees) in event handlers. The only viable way to fix the issue was to write my own custom framework taking extreme care with closures and sometimes nulling variables (the code for the existing framework was just too complex to fix - and memory references are hard to debug in browsers). I saw the same issue with memory usage growth in a different framework.</div><br/></div></div><div id="38411619" class="c"><input type="checkbox" id="c-38411619" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38412245">prev</a><span>|</span><a href="#38412086">next</a><span>|</span><label class="collapse" for="c-38411619">[-]</label><label class="expand" for="c-38411619">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always written Lisp with an editor, into a file, and used the REPL only for exploratory and debugging tasks.<p>Some of my early Lisp programs used a Makefile.<p>Lisp is great even without the scatter-brained approaches that some Lisp programmers advocate in order to roll people&#x27;s eyes and turn them away from Lisp.</div><br/></div></div><div id="38412086" class="c"><input type="checkbox" id="c-38412086" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#38411619">prev</a><span>|</span><a href="#38411803">next</a><span>|</span><label class="collapse" for="c-38412086">[-]</label><label class="expand" for="c-38412086">[1 more]</label></div><br/><div class="children"><div class="content">And what about async promises? Those really make it hard to reason about what the system is doing.</div><br/></div></div><div id="38411803" class="c"><input type="checkbox" id="c-38411803" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#38412086">prev</a><span>|</span><a href="#38411611">next</a><span>|</span><label class="collapse" for="c-38411803">[-]</label><label class="expand" for="c-38411803">[1 more]</label></div><br/><div class="children"><div class="content">Being able to skip the stop-edit-compile-(re)start cycle is <i>nice</i>.<p>I don&#x27;t know that the evidence is overwhelming that it is <i>better</i>.</div><br/></div></div><div id="38411611" class="c"><input type="checkbox" id="c-38411611" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38411803">prev</a><span>|</span><a href="#38411466">next</a><span>|</span><label class="collapse" for="c-38411611">[-]</label><label class="expand" for="c-38411611">[1 more]</label></div><br/><div class="children"><div class="content">Late binding is programming for moties.[1]<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Mote_in_God%27s_Eye" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Mote_in_God%27s_Eye</a></div><br/></div></div><div id="38411466" class="c"><input type="checkbox" id="c-38411466" checked=""/><div class="controls bullet"><span class="by">smitty1e</span><span>|</span><a href="#38411611">prev</a><span>|</span><label class="collapse" for="c-38411466">[-]</label><label class="expand" for="c-38411466">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Methods overridden at runtime, traces that end with a call to a closure that no longer exists, event handlers whose execution order depends on side-effects during module loading, stack-traces which contain multiple different versions of the same function.<p>My experience is that the more orthogonal the data, logic, and presentation in the system, the more methodical the naming, the less important the system is and the more the creativity can be focused on the task, not dealing with the &quot;personality&quot; of the system.</div><br/></div></div></div></div></div></div></div></body></html>