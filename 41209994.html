<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723366868474" as="style"/><link rel="stylesheet" href="styles.css?v=1723366868474"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/supabase/pg_replicate">Show HN: Pg_replicate – Build Postgres replication applications in Rust</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>imor80</span> | <span>22 comments</span></div><br/><div><div id="41214849" class="c"><input type="checkbox" id="c-41214849" checked=""/><div class="controls bullet"><span class="by">steinroe</span><span>|</span><a href="#41209995">next</a><span>|</span><label class="collapse" for="c-41214849">[-]</label><label class="expand" for="c-41214849">[1 more]</label></div><br/><div class="children"><div class="content">This is great! We&#x27;ve been using PostgREST along with a PostgreSQL-based queue to handle side-effects like sending webhooks after database operations (inserts&#x2F;updates&#x2F;deletes). The queue feeds into a node server that processes these tasks. However, this setup is becoming a performance bottleneck as we scale.<p>I&#x27;m exploring an alternative way to run logic asynchronously after db operations without the overhead, and I think using cdc to export jobs into an external queue is the way to go here. Essentially a lightweight alternative to Debezium with a better developer experience that is easier to manage. This crate could serve as the core of such a service.</div><br/></div></div><div id="41209995" class="c"><input type="checkbox" id="c-41209995" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41214849">prev</a><span>|</span><a href="#41211598">next</a><span>|</span><label class="collapse" for="c-41209995">[-]</label><label class="expand" for="c-41209995">[6 more]</label></div><br/><div class="children"><div class="content">Hey HN,<p>For the past few months, as part of my job at Supabase, I have been working on pg_replicate. pg_replicate lets you very easily build applications which can copy data (full table copies and cdc) from Postgres to any other data system. Around six months back I was figuring out what can be built by tailing Postgres&#x27; WAL. pg_replicate grew organically out of that effort. Many similar tools, like Debezium, exist already which do a great job, but pg_replicate is much simpler and focussed only on Postgres. Rust was used in the project because I am most comfortable with it. pg_replicate abstracts over the Postgres logical replication protocol[0] and lets you work with higher level concepts. There are three main concepts to understand pg_replicate: source, sink and pipeline.<p>1&#x2F; A source is a Postgres db from which data is to be copied.
2&#x2F; A sink is a data system into which data will be copied.
3&#x2F; A pipeline connects a source to a sink.<p>Currently pg_replicate supports BigQuery, DuckDb local file and, MotherDuck as sinks. More sinks will be added in future. To support a new data system, you just need to implement the BatchSink trait (older Sink trait will be deprecated soon).<p>pg_replicate is still under heavy development and is a little thin on documentation. Performance is another area which hasn&#x27;t received much attention. We are releasing this to get feedback from the community and are still evaluating how (or if) we can integrate it with the Supabase platform. Comments and feedback are welcome.<p>[0] Postgres logical replication protocol: [<a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;protocol-logical-replication.html](https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;protocol-logical-replication.html)" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;protocol-logical-rep...</a>)</div><br/><div id="41212231" class="c"><input type="checkbox" id="c-41212231" checked=""/><div class="controls bullet"><span class="by">necubi</span><span>|</span><a href="#41209995">parent</a><span>|</span><a href="#41211479">next</a><span>|</span><label class="collapse" for="c-41212231">[-]</label><label class="expand" for="c-41212231">[1 more]</label></div><br/><div class="children"><div class="content">This is so cool! I appreciate Debezium for its wide DB support (no part of me wants to know the inner workings of MSSQL&#x27;s replication protocol) but it&#x27;s finnicky to run. Great to have an alternative, at least for postgres.</div><br/></div></div><div id="41211479" class="c"><input type="checkbox" id="c-41211479" checked=""/><div class="controls bullet"><span class="by">chucky_z</span><span>|</span><a href="#41209995">parent</a><span>|</span><a href="#41212231">prev</a><span>|</span><a href="#41210988">next</a><span>|</span><label class="collapse" for="c-41211479">[-]</label><label class="expand" for="c-41211479">[2 more]</label></div><br/><div class="children"><div class="content">I’m curious in your experience how many clients can run pg_replicate at once?<p>With MySQL I saw the interesting use-case of the black hole storage engine to scale out replication logs but ultimately the only usage I’m aware of was for scaling other mysql read replicas.<p>The idea of scaling an application by tailing logs from a database sounds very interesting to me, and I’m curious if you’ve explored this at all.  There’s of course things like Kafka (and then things like Debezium), but it’s hard to beat direct!</div><br/><div id="41213731" class="c"><input type="checkbox" id="c-41213731" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41209995">root</a><span>|</span><a href="#41211479">parent</a><span>|</span><a href="#41210988">next</a><span>|</span><label class="collapse" for="c-41213731">[-]</label><label class="expand" for="c-41213731">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’m curious in your experience how many clients can run pg_replicate at once?<p>I&#x27;d expect more clients to put more pressure on the resource usage on the db. But it&#x27;s not clear whether the relationship between number of clients and resource usage is linear, quadratic or something else since I haven&#x27;t done benchmarking yet.<p>&gt; The idea of scaling an application by tailing logs from a database sounds very interesting to me, and I’m curious if you’ve explored this at all. There’s of course things like Kafka (and then things like Debezium), but it’s hard to beat direct!<p>It doesn&#x27;t exist yet, but I was thinking of creating a sink which exposes Postgres WAL via websockets. This way the number of clients might scale much better.</div><br/></div></div></div></div><div id="41210988" class="c"><input type="checkbox" id="c-41210988" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#41209995">parent</a><span>|</span><a href="#41211479">prev</a><span>|</span><a href="#41211598">next</a><span>|</span><label class="collapse" for="c-41210988">[-]</label><label class="expand" for="c-41210988">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve recently been playing with the logical replication protocol, and it enables all kinds of interesting usages. one really cool thing is that you see the transactional boundaries, so not only can you write a cache, you can do so in a way thats internally consistent.<p>its also inherently much nicer than listen&#x2F;notify, since you don&#x27;t have to go back and figure out what data was associated with the event</div><br/><div id="41213741" class="c"><input type="checkbox" id="c-41213741" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41209995">root</a><span>|</span><a href="#41210988">parent</a><span>|</span><a href="#41211598">next</a><span>|</span><label class="collapse" for="c-41213741">[-]</label><label class="expand" for="c-41213741">[1 more]</label></div><br/><div class="children"><div class="content">Yes, logical replication complements very nicely the normal way of interacting with the database via queries. This inverted flow makes those apps possible which were hard&#x2F;impossible to build with just queries.</div><br/></div></div></div></div></div></div><div id="41211598" class="c"><input type="checkbox" id="c-41211598" checked=""/><div class="controls bullet"><span class="by">rubenfiszel</span><span>|</span><a href="#41209995">prev</a><span>|</span><a href="#41211365">next</a><span>|</span><label class="collapse" for="c-41211598">[-]</label><label class="expand" for="c-41211598">[3 more]</label></div><br/><div class="children"><div class="content">This is super timely.<p>Windmill (<a href="https:&#x2F;&#x2F;windmill.dev">https:&#x2F;&#x2F;windmill.dev</a>) used to only support webhooks to trigger code and flow jobs. We have just added email support building our own MX server, and wanted to add CDC change. We were gonna do it on Debezium but this will allow us to remove the need for a third-party service and just add this as a crate. Thank you supabase for open-sourcing this.</div><br/><div id="41213794" class="c"><input type="checkbox" id="c-41213794" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41211598">parent</a><span>|</span><a href="#41213577">next</a><span>|</span><label class="collapse" for="c-41213794">[-]</label><label class="expand" for="c-41213794">[1 more]</label></div><br/><div class="children"><div class="content">Please do share your experience using pg_replicate as feedback once you integrate with windmill.</div><br/></div></div><div id="41213577" class="c"><input type="checkbox" id="c-41213577" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#41211598">parent</a><span>|</span><a href="#41213794">prev</a><span>|</span><a href="#41211365">next</a><span>|</span><label class="collapse" for="c-41213577">[-]</label><label class="expand" for="c-41213577">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m super excited to see a feature based on this in Windmill.</div><br/></div></div></div></div><div id="41211365" class="c"><input type="checkbox" id="c-41211365" checked=""/><div class="controls bullet"><span class="by">phamilton</span><span>|</span><a href="#41211598">prev</a><span>|</span><a href="#41212743">next</a><span>|</span><label class="collapse" for="c-41211365">[-]</label><label class="expand" for="c-41211365">[2 more]</label></div><br/><div class="children"><div class="content">Postgres + Rust is one of the most exciting intersections of tech I&#x27;ve seen in a while.<p>There&#x27;s external tooling like his project, but postgres extensions in Rust are exciting.<p>Full extensions via pgrx have been cool to see, but plrust + pg_tle is also starting to show up.<p>If you aren&#x27;t familiar with TLE (Trusted Language Extensions), it is a postgres extension from AWS that created some privileged interfaces for procedural languages (used for user-defined functions) to do some extra stuff. Right now it&#x27;s mostly auth-related hooks but my hope is that it expands in the future.<p>Plrust is a procedural language extension for Rust, allowing user defined functions written in Rust.<p>The combination of those two could open up a world of rich extensions usable in managed hosted environments like RDS.</div><br/><div id="41213759" class="c"><input type="checkbox" id="c-41213759" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41211365">parent</a><span>|</span><a href="#41212743">next</a><span>|</span><label class="collapse" for="c-41213759">[-]</label><label class="expand" for="c-41213759">[1 more]</label></div><br/><div class="children"><div class="content">Agree, Rust and Postgres and a perfect match. It feels so much more productive to write Postgres tooling in Rust. E.g. we already have extensions like pg_graphql[0], pg_jsonschema[1] and wrappers[2] which use pgrx. We don&#x27;t have plrust on the platform yet though.<p>Full disclosure: I&#x27;m a Rust Engieer at Supabase.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;pg_graphql">https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;pg_graphql</a>
[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;pg_jsonschema">https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;pg_jsonschema</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;wrappers">https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;wrappers</a></div><br/></div></div></div></div><div id="41212743" class="c"><input type="checkbox" id="c-41212743" checked=""/><div class="controls bullet"><span class="by">stlava</span><span>|</span><a href="#41211365">prev</a><span>|</span><a href="#41211603">next</a><span>|</span><label class="collapse" for="c-41212743">[-]</label><label class="expand" for="c-41212743">[2 more]</label></div><br/><div class="children"><div class="content">Nice! I&#x27;m one of the authors of pg-bifrost which is in the same space. Have you thought about &#x2F; have solved sharding consumption across multiple slots &#x2F; multi consumers to increase throughput? This is on my radar but not something I&#x27;ve investigated yet.<p>The issue we&#x27;ve ran into is some team at work decides to re-write an entire table and things get backed up until they stop updating rows.</div><br/><div id="41213788" class="c"><input type="checkbox" id="c-41213788" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41212743">parent</a><span>|</span><a href="#41211603">next</a><span>|</span><label class="collapse" for="c-41213788">[-]</label><label class="expand" for="c-41213788">[1 more]</label></div><br/><div class="children"><div class="content">pg-bifrost looks solid.<p>&gt; Have you thought about &#x2F; have solved sharding consumption across multiple slots &#x2F; multi consumers to increase throughput?<p>Not yet, there has been not performance yet, as the project is still quite young.</div><br/></div></div></div></div><div id="41211603" class="c"><input type="checkbox" id="c-41211603" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#41212743">prev</a><span>|</span><a href="#41213894">next</a><span>|</span><label class="collapse" for="c-41211603">[-]</label><label class="expand" for="c-41211603">[3 more]</label></div><br/><div class="children"><div class="content">I was trying out the stdout example. Could not get it to log anything. DuckDB example worked so I went digging into the source. Apparently the stdout sink is using tracing and I did not have a `RUST_LOG` env var set.<p>Might be a good idea to have it documented or have the default level set to info for the stdout example.<p>Maybe this is common Rust knowledge and I just don&#x27;t know what I&#x27;m doing though.</div><br/><div id="41213274" class="c"><input type="checkbox" id="c-41213274" checked=""/><div class="controls bullet"><span class="by">hermanradtke</span><span>|</span><a href="#41211603">parent</a><span>|</span><a href="#41213894">next</a><span>|</span><label class="collapse" for="c-41213274">[-]</label><label class="expand" for="c-41213274">[2 more]</label></div><br/><div class="children"><div class="content">I too consider this a footgun.<p>Most applications will have something like<p><pre><code>   tracing_subscriber::registry()
           .with(
               tracing_subscriber::EnvFilter::try_from_default_env()
                   .unwrap_or_else(|_| &quot;my_app=info&quot;.into()),
           )
           .with(tracing_subscriber::fmt::layer())
           .init();

</code></pre>
in the `main.rs` which will default the tracing if RUST_LOG env var is not set.</div><br/><div id="41213765" class="c"><input type="checkbox" id="c-41213765" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41211603">root</a><span>|</span><a href="#41213274">parent</a><span>|</span><a href="#41213894">next</a><span>|</span><label class="collapse" for="c-41213765">[-]</label><label class="expand" for="c-41213765">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for trying out, I&#x27;ll update the code and&#x2F;or the README to fix this.</div><br/></div></div></div></div></div></div><div id="41213894" class="c"><input type="checkbox" id="c-41213894" checked=""/><div class="controls bullet"><span class="by">pgnone</span><span>|</span><a href="#41211603">prev</a><span>|</span><a href="#41212883">next</a><span>|</span><label class="collapse" for="c-41213894">[-]</label><label class="expand" for="c-41213894">[2 more]</label></div><br/><div class="children"><div class="content">Do you do anything special with toast not changed values, this always seemed problematic to me with doing cdc as either you have to maintain the latest value in your own state or hit the read connection to pull the value</div><br/><div id="41213926" class="c"><input type="checkbox" id="c-41213926" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41213894">parent</a><span>|</span><a href="#41212883">next</a><span>|</span><label class="collapse" for="c-41213926">[-]</label><label class="expand" for="c-41213926">[1 more]</label></div><br/><div class="children"><div class="content">Not yet, but it is planned for the future. We&#x27;d need to pick one of the two options you suggested.</div><br/></div></div></div></div><div id="41212883" class="c"><input type="checkbox" id="c-41212883" checked=""/><div class="controls bullet"><span class="by">alexnewman</span><span>|</span><a href="#41213894">prev</a><span>|</span><label class="collapse" for="c-41212883">[-]</label><label class="expand" for="c-41212883">[2 more]</label></div><br/><div class="children"><div class="content">Wow I think i build one of the first pg-rust-cdc replication module for postgresql and now it seems mainstream. It was a part of my <a href="https:&#x2F;&#x2F;github.com&#x2F;posix4e&#x2F;rpgffi">https:&#x2F;&#x2F;github.com&#x2F;posix4e&#x2F;rpgffi</a> project, which is garbage code I&#x27;m now embarrassed about. Rust programming has come a long way and we didn&#x27;t have the best practices. Now it seems actual grownup engineering teams are living the dream. We truly live in the best of all universes.</div><br/><div id="41213810" class="c"><input type="checkbox" id="c-41213810" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41212883">parent</a><span>|</span><label class="collapse" for="c-41213810">[-]</label><label class="expand" for="c-41213810">[1 more]</label></div><br/><div class="children"><div class="content">These days, for writing extensions&#x2F;FFI pgrx[0] is the best crate.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;pgcentralfoundation&#x2F;pgrx">https:&#x2F;&#x2F;github.com&#x2F;pgcentralfoundation&#x2F;pgrx</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>