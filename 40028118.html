<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713089488691" as="style"/><link rel="stylesheet" href="styles.css?v=1713089488691"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/Flow-IPC">Show HN: Comprehensive inter-process communication (IPC) toolkit in modern C++</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>ygoldfeld</span> | <span>31 comments</span></div><br/><div><div id="40024280" class="c"><input type="checkbox" id="c-40024280" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#40005504">next</a><span>|</span><label class="collapse" for="c-40024280">[-]</label><label class="expand" for="c-40024280">[2 more]</label></div><br/><div class="children"><div class="content">Does the schema help a lot? For C++ you can get very fast without, for example with IceOryx <a href="https:&#x2F;&#x2F;github.com&#x2F;eclipse-iceoryx&#x2F;iceoryx">https:&#x2F;&#x2F;github.com&#x2F;eclipse-iceoryx&#x2F;iceoryx</a><p>In contrast to Cap&#x27;n&#x27;Proto you get compiler optimized struct layout as benefit from using raw structs. Benchmarks are here <a href="https:&#x2F;&#x2F;iceoryx.io&#x2F;v2.0.2&#x2F;examples&#x2F;iceperf&#x2F;" rel="nofollow">https:&#x2F;&#x2F;iceoryx.io&#x2F;v2.0.2&#x2F;examples&#x2F;iceperf&#x2F;</a></div><br/><div id="40029070" class="c"><input type="checkbox" id="c-40029070" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#40024280">parent</a><span>|</span><a href="#40005504">next</a><span>|</span><label class="collapse" for="c-40029070">[-]</label><label class="expand" for="c-40029070">[1 more]</label></div><br/><div class="children"><div class="content">I think that (whether a native-struct versus a capnp schema-based struct = helps&#x2F;how much) is a general question of what kind of serialization is best for a particular use-case. I wouldn&#x27;t want to litigate that here fully. Personally though I&#x27;ve found capnp-based IPC protocols to be neat and helpful, across versions and protocol changes (where e.g. there are well-defined rules of forward-compatibility; and Flow-IPC gives you niceties including request-response and message-type demultiplexing to a particular handler). [footnote 1 below]<p>BUT!!! Some algorithms don&#x27;t require an &quot;IPC protocol&quot; per se, necessarily, but more like = 2+ applications collaborating on a data structure. In that case native structures are for sure superior, or at times even essentially required. (E.g., if you have some custom optimized hash-table -- you&#x27;re not going to want to express it as a capnp structure probably.)<p>So, more to the point:<p>- Flow-IPC 100% supports transmitting&#x2F;sharing (and constructing, and auto-destroyting) native C++ structures. Compared to iceoryx, on this point, it appears to have some extra capabilities, namely full support for structures with pointers&#x2F;references and&#x2F;or STL-compliant containers. (This example <a href="https:&#x2F;&#x2F;iceoryx.io&#x2F;latest&#x2F;examples&#x2F;complexdata&#x2F;" rel="nofollow">https:&#x2F;&#x2F;iceoryx.io&#x2F;latest&#x2F;examples&#x2F;complexdata&#x2F;</a> and other pages say things like, &quot;To implement zero-copy data transfer we use a shared memory approach. <i>This requires that every data structure needs to be entirely contained in the shared memory and must not internally use pointers or references.</i> The complete list of restrictions can be found...&quot;.) Flow-IPC, in this context, means no need to write custom containers sans heap-use, or eliminate pointers in an existing structure. [footnote 2 below]<p>- Indeed, the capnp framing (only if you choose to use the Flow-IPC capnp-protocol feature in question!) adds processing and thus <i>some</i> computational and RAM-use overhead. For many applications, the 10s of microseconds added there don&#x27;t matter much -- as long as they are constant regardless of structure size, and as long as they <i>are</i> 10s of microseconds. So a 100usec (modulo processor model of course!) RTT (size-independent) is pretty good still. Of course I would never claim this overhead doesn&#x27;t matter to <i>anyone</i>, and iceoryx&#x27;s results here are straight-up admirable.<p>[footnote 1] The request&#x2F;response&#x2F;demultiplexing&#x2F;etc. niceties added by Flow-IPC&#x27;s capnp-protocol feature-in-question work well IMO, but one might prefer the sweet RPC-semantics + promise pipelining of capnp-RPC. Kenton V (capnp inventor&#x2F;owner) and I have spoken recently about using Flow-IPC to zero-copy-ify capnp-RPC. I&#x27;m looking into it! (He suspects it is pretty simple&#x2F;natural, given that we handle the capnp-serialization layer already, and capnp-RPC is built on that.) This wouldn&#x27;t <i>change</i> Flow-IPC&#x27;s existing features but rather exercise another way of using them. In a way Flow-IPC provides a simple-but-effective-out-of-the-box schema-based conversation protocol via capnp-serialization, and capnp-RPC would provide an alternate (to that out-of-the-box guy) conversation protocol option. I tried pretty hard to design Flow-IPC in a grounded and layered way, so such work would be natural as opposed to daunting.<p>[footnote 2] In fact the Flow-IPC capnp-based structured-channel feature (internally) itself uses Flow-IPC&#x27;s own native-structure-transmission feature in its implementation (eat our own dog-food). Since a capnp serialization = sequence of buffers (a.k.a. segments), for us it is (internally) represented as essentially an STL list&lt;vector&lt;uint8_t&gt;&gt;. So we construct&#x2F;build one of those in SHM (internally); then only a small SHM-handle is (internally) transmitted over the IPC-transport [footnote 3]; and the receiver then obtains the in-place list&lt;vector&lt;uint8_t&gt;&gt; (essentially) which is then treated as the capnp-encoding it really is. This would all happen (internally) when executing the quite-short example in the blog (<a href="https:&#x2F;&#x2F;www.linode.com&#x2F;blog&#x2F;open-source&#x2F;flow-ipc-introduction-low-latency-cpp-toolkit&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.linode.com&#x2F;blog&#x2F;open-source&#x2F;flow-ipc-introductio...</a>). As you can see there, to the Flow-IPC-using developer, it&#x27;s just -- like -- &quot;create a message with this schema here, call some mutators, send&quot;; and conversely &quot;receive a message expected to have that (same) schema, OK -- got it; call some accessors.&quot;<p>[footnote 3] IPC-transport = Unix domain socket or one 2 MQ types -- you can choose via template arg (or add your own IPC-transport by implementing a certain pair of simple concepts).</div><br/></div></div></div></div><div id="40005504" class="c"><input type="checkbox" id="c-40005504" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#40024280">prev</a><span>|</span><a href="#40029054">next</a><span>|</span><label class="collapse" for="c-40005504">[-]</label><label class="expand" for="c-40005504">[4 more]</label></div><br/><div class="children"><div class="content">Whoa. I’m the lead developer on this - I got to this post totally by accident: was googling for my own Show HN post about this from a couple days ago - and it took me here without my noticing.<p>There’s some discussion on it in Show HN, and of course I can answer anything here that people might be interested in too. I’m very proud of it and very grateful Akamai gave the resources to open-source it.<p>I’d like to have a flashier friendlier site with a slick intro video - haven’t had the time to do that stuff - but the substance and API documentation + Manual are very serious and complete, I hope.<p>All linked off the blog-post!</div><br/><div id="40029795" class="c"><input type="checkbox" id="c-40029795" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#40005504">parent</a><span>|</span><a href="#40028109">next</a><span>|</span><label class="collapse" for="c-40029795">[-]</label><label class="expand" for="c-40029795">[1 more]</label></div><br/><div class="children"><div class="content">Your submission is [dead], dunno why. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39987732">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39987732</a></div><br/></div></div><div id="40028109" class="c"><input type="checkbox" id="c-40028109" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40005504">parent</a><span>|</span><a href="#40029795">prev</a><span>|</span><a href="#40029054">next</a><span>|</span><label class="collapse" for="c-40028109">[-]</label><label class="expand" for="c-40028109">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s great! Show HNs are preferred so I&#x27;ve re-upped your original post and have merged the other thread (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40000104">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40000104</a>) hither.<p>But readers will probably want to look at the other article as well: <a href="https:&#x2F;&#x2F;www.linode.com&#x2F;blog&#x2F;open-source&#x2F;flow-ipc-introduction-low-latency-cpp-toolkit&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.linode.com&#x2F;blog&#x2F;open-source&#x2F;flow-ipc-introductio...</a>.</div><br/><div id="40028899" class="c"><input type="checkbox" id="c-40028899" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#40005504">root</a><span>|</span><a href="#40028109">parent</a><span>|</span><a href="#40029054">next</a><span>|</span><label class="collapse" for="c-40028899">[-]</label><label class="expand" for="c-40028899">[1 more]</label></div><br/><div class="children"><div class="content">Whoa (again), super-cool, appreciate that.</div><br/></div></div></div></div></div></div><div id="40029054" class="c"><input type="checkbox" id="c-40029054" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40005504">prev</a><span>|</span><a href="#40010197">next</a><span>|</span><label class="collapse" for="c-40029054">[-]</label><label class="expand" for="c-40029054">[2 more]</label></div><br/><div class="children"><div class="content">I also went this route and came to the very same conclusions. Cap&#x27;n proto for fast reading, SHM for shared data, simple short messaging, just everything in C.<p>My only problem is MacOS with its too small default SHM buffers, you need to enhance them. Most solutions need a reboot, but a simple setter is enough. Like sudo sysctl -w kern.sysv.shmmax=16777216</div><br/><div id="40029152" class="c"><input type="checkbox" id="c-40029152" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#40029054">parent</a><span>|</span><a href="#40010197">next</a><span>|</span><label class="collapse" for="c-40029152">[-]</label><label class="expand" for="c-40029152">[1 more]</label></div><br/><div class="children"><div class="content">Interesting! I&#x27;d best write this down. Current notes on macOS and Windows port work:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Flow-IPC&#x2F;ipc&#x2F;issues&#x2F;101">https:&#x2F;&#x2F;github.com&#x2F;Flow-IPC&#x2F;ipc&#x2F;issues&#x2F;101</a> (&lt;= <a href="https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;Flow-IPC&#x2F;discussions&#x2F;98">https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;Flow-IPC&#x2F;discussions&#x2F;98</a>)<p>For macOS&#x2F;ARM64, currently it looks to me like the apparent lack of &#x2F;dev&#x2F;shm equivalent (unless I messed up in searching for it) means the most significant amount of new work necessary to port it ... but you just mentioned a thing I did not know about. (SHM size&#x2F;count limits definitely were a thing in Linux, though, indeed.) TY</div><br/></div></div></div></div><div id="40010197" class="c"><input type="checkbox" id="c-40010197" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#40029054">prev</a><span>|</span><a href="#39987737">next</a><span>|</span><label class="collapse" for="c-40010197">[-]</label><label class="expand" for="c-40010197">[4 more]</label></div><br/><div class="children"><div class="content">i have done something exactly identical at my current place of employment, and am always inquisitive to see how others have &#x27;stacked-da-cat&#x27;.<p>we _unfortunately_ gravitated towards protobuf&#x27;s despite my fervent appeal to go with capn-proto. that has caused a cascade of troubles &#x2F; missed opportunities for optimizations etc. etc.</div><br/><div id="40024655" class="c"><input type="checkbox" id="c-40024655" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#40010197">parent</a><span>|</span><a href="#40026720">next</a><span>|</span><label class="collapse" for="c-40024655">[-]</label><label class="expand" for="c-40024655">[2 more]</label></div><br/><div class="children"><div class="content">I tried to migrate to capn-proto but it just doesn&#x27;t build on MinGW so I have no choice but to wait. Like you say, it gets worse the more I wait. But, if the APIs are somewhat sane, they should hopefully also be somewhat similar: Able to switch case on oneofs, movable data structures etc.<p>I don&#x27;t like that protobuf has recently started linking with abseil, which despite being a good framework, I can&#x27;t use it if it doesn&#x27;t build absolutely everywhere I need it to. So, maybe I&#x27;ll be forced over to CapnProto one of these days?</div><br/><div id="40027198" class="c"><input type="checkbox" id="c-40027198" checked=""/><div class="controls bullet"><span class="by">Arelius</span><span>|</span><a href="#40010197">root</a><span>|</span><a href="#40024655">parent</a><span>|</span><a href="#40026720">next</a><span>|</span><label class="collapse" for="c-40027198">[-]</label><label class="expand" for="c-40027198">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I like capn-proto. But it&#x27;s community is a bit light. Even Windows which is &quot;supported&quot; has been a bit fix-it-yourself.<p>If MinGW isn&#x27;t already supported, if probably expect to have to take that over yourself.</div><br/></div></div></div></div><div id="40026720" class="c"><input type="checkbox" id="c-40026720" checked=""/><div class="controls bullet"><span class="by">sgtnoodle</span><span>|</span><a href="#40010197">parent</a><span>|</span><a href="#40024655">prev</a><span>|</span><a href="#39987737">next</a><span>|</span><label class="collapse" for="c-40026720">[-]</label><label class="expand" for="c-40026720">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also developed a strikingly similar low latency real-time IPC message bus for work. It also uses sockets with transparent shared memory optimization. In my case, it&#x27;s the backbone for an autonomous aircraft&#x27;s avionics. I made everything agnostic to the message scheme, though, and most of the tooling supports an in-house schema, protobuf, JSON, YAML, etc. There&#x27;s also clients implemented in C++, Rust, Python and Julia.<p>What troubles has protobuf caused you?</div><br/></div></div></div></div><div id="39987737" class="c"><input type="checkbox" id="c-39987737" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#40010197">prev</a><span>|</span><a href="#40024248">next</a><span>|</span><label class="collapse" for="c-39987737">[-]</label><label class="expand" for="c-39987737">[14 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so hard to communicate this stuff in writing! There are several angles of potential interest; I wish I could simply chat in-person with anyone curious, you know? Of course that is impossible. (I&#x27;ll do my best here at HN and the Flow-IPC Discussions board at GitHub.)<p>I hope the above 2 links get the job done in communicating the key points. There is certainly no shortage of documentation! Still:<p>If you&#x27;ll indulge me, I do want to share how this project got started and became open-source. I actually do suspect this might help one get a feeling of what this thing is, and is not.<p>My name is Yuri Goldfeld. I have worked at Akamai since 2005 (with a break for startup shenanigans, and VMware, in the middle). I designed or co-designed Flow-IPC and wrote about 75% of it (by lines of code ignoring comments); my colleague Eddy Chan wrote the rest, including the bulk of the SHM-jemalloc component (which is really cool IMO).<p>Akamai in certain core parts is a C++&#x2F;Linux shop, with dogged scrutiny to latency. Every millisecond along the request path is scrutinized. A few years ago I was asked to do a couple things:
  - Determine the best serializer to use, in general, but especially for IPC protocols. The answer there was easy IMO: Cap&#x27;n Proto.
  - Split-up a certain important C++ service into several parts, for various reasons, without adding latency to the request path.<p>The latter task meant, among other things, communicating large amounts of user data from server application to server application. capnp-encoded structures (sometimes big - but not necessarily) would also need to be transmitted; as would FDs.<p>The technical answers to these challenges are not necessarily rocket science. FDs can be transmitted via Unix domain socket as &quot;ancillary data&quot;; the POSIX `sendmsg()` API is hairy but usable. Small messages can be transmitted via Unix domain socket, or pipe, or POSIX MQ (etc.). Large blobs of data it would <i>not</i> be okay to transmit via those transports, as too much copying into and out of kernel buffers is involved and would add major latency, so we&#x27;d have to use shared memory (SHM). Certainly a hairy technology... but again, doable. And as for capnp - well - you &quot;just&quot; code a `MessageBuilder` implementation that allocates segments in SHM instead of regular heap like `capnp::MallocMessageBuilder` does.<p>Thing is, I noticed that various parts of the company had similar needs. I&#x27;ve observed some variation of each of the aforementioned tasks custom-implemented - again, and again, and again. None of these implementations could really be reused anywhere else. Most of them ran into the same problems - none of which is that big a deal on its own, but together (and across projects) it more than adds up. To coders it&#x27;s annoying. And to the business, it&#x27;s expensive!<p>Plus, at least one thing actually proved to be technically quite hard. Sharing (via SHM) a native C++ structure involving STL containers and&#x2F;or raw pointers: downright tough to achieve in a general way. At least with Boost.interprocess (<a href="https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_84_0&#x2F;doc&#x2F;html&#x2F;interprocess.html" rel="nofollow">https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_84_0&#x2F;doc&#x2F;html&#x2F;interprocess....</a>) - which is really quite thoughtful - one can accomplish a lot... but even then, there are key limitations, in terms of safety and ease of use&#x2F;reusability. (I&#x27;m being a bit vague here... trying to keep the length under control.)<p>So, I decided to <i>not</i> just design&#x2F;code an &quot;IPC thing&quot; for that original key C++ service I was being asked to split... but rather one that could be used as a general toolkit, for any C++ applications. Originally we named it Akamai-IPC, then renamed it Flow-IPC.<p>As a result of that origin story, Flow-IPC is... hmmm... meat-and-potatoes, pragmatic. It is not a &quot;framework.&quot; It does <i>not</i> replace or compete with gRPC. (It can, instead, speed RPC frameworks up by providing the zero-copy transmission substrate.) I hope that it is neither niche nor high-maintenance.<p>To wit: If you merely want to send some binary-blob messages and&#x2F;or FDs, it&#x27;ll do that - and make it easier by letting you set-up a single <i>session</i> between the 2 processes, instead of making you worry about socket names and cleanup. (But, that&#x27;s optional! If you simply want to set up a Unix domain socket yourself, you can.) If you want to add structured messaging, it supports Cap&#x27;n Proto - as noted - <i>and</i> right out of the box it&#x27;ll be zero-copy end-to-end. That is, it&#x27;ll do all the SHM stuff without a single `shm_open()` or `mmap()` or `ftruncate()` on your part. And if you want to customize how that all works, those layers and concepts are formally available to you. (No need to modify Flow-IPC yourself: just implement certain concepts and plug them in, at compile-time.)<p>Lastly, for those who want to work with native C++ data directly in SHM, it&#x27;ll simplify setup&#x2F;cleanup considerably compared to what&#x27;s typical. For the original Akamai service in question, we needed to use SHM as intensively as one typically uses the regular heap. So in particular Boost.interprocess&#x27;s built-in 2 SHM-allocation algorithms were not sufficient. We <i>needed</i> something more industrial-strength. So we adapted jemalloc (<a href="https:&#x2F;&#x2F;jemalloc.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jemalloc.net&#x2F;</a>) to work in SHM, and worked that into Flow-IPC as a standard available feature. (jemalloc powers FreeBSD and big parts of Meta.) So jemalloc&#x27;s anti-fragmentation algorithms, thread caching - all that stuff - will work for our SHM allocations.<p>Having accepted this basic plan - develop a reusable IPC library that handled the above oft-repeated needs - Eddy Chan joined and especially heavily contributed on the jemalloc aspects. A couple years later we had it ready for internal Akamai use. All throughout we kept it general - not Akamai-specific (and certainly not specific to that original C++ service that started it all off) - and personally I felt it was a very natural candidate for open-source.<p>To my delight, once I announced it internally, the immediate reaction from higher-up was, &quot;you should open-source it.&quot; Not only that, we were given the resources and goodwill to actually <i>do</i> it. I have learned that it&#x27;s not easy to make something like this presentable publicly, even having developed it with that in mind. (BTW it is about 69k lines of code, 92k lines of comments, excluding the Manual.)<p>So, that&#x27;s what happened. We wrote a thing useful for various teams internally at Akamai - and then Akamai decided we should share it with the world. That&#x27;s how open-source thrives, we figured.<p>On a personal level, of course it would be gratifying if others found it useful and&#x2F;or themselves contributed. What a cool feeling that would be! After working with exemplary open-source stuff like capnp, it&#x27;d be amazing to offer even a fraction of that usefulness. But, we don&#x27;t gain from &quot;market share.&quot; It really is just there to be useful. So we hope it is!</div><br/><div id="39995666" class="c"><input type="checkbox" id="c-39995666" checked=""/><div class="controls bullet"><span class="by">robobully</span><span>|</span><a href="#39987737">parent</a><span>|</span><a href="#39993210">next</a><span>|</span><label class="collapse" for="c-39995666">[-]</label><label class="expand" for="c-39995666">[9 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an impressive read, thank you and congrats on the release! I think that nowadays the development and adoption of performant IPC mechanisms is unfairly low, it&#x27;s good to have such tech opensourced.<p>My question is, how does Flow-IPC compare to projects like Mojo IPC (from Chromium) and Eclipse iceoryx? At first glance they all pursue similar goals and pay much less attention to complex allocation management, yet managing to perform well enough.</div><br/><div id="39996692" class="c"><input type="checkbox" id="c-39996692" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#39995666">parent</a><span>|</span><a href="#39996715">next</a><span>|</span><label class="collapse" for="c-39996692">[-]</label><label class="expand" for="c-39996692">[7 more]</label></div><br/><div class="children"><div class="content">Appreciate your time! And, naturally, this was the question I expected to pop up once I was able to work through everything required internally here at Akamai to actually put this guy out in public. Wouldn&#x27;t it be sad :-( if the same thing already existed, and we just hadn&#x27;t noticed it?<p>In tactical terms, back when this all started, of course we looked around for something to use; after all why write a whole thing, if we could use something? We didn&#x27;t write a serializer, for example, since a kick-butt one (capnp - and FlatBuffers also seems fine) already existed. Back then, though, nothing really jumped out. So looking back, it may have simply been a race; a few people&#x2F;groups out there saw this niche and started developing things. I see iceoryx in particular has one identical plank, which is workable&#x2F;general end-to-end zero-copy via SHM; and it was released a couple years before, hence has a super nice presentation I hugely appreciate: many well-documented examples in particular. Whereas for us, providing that will take some more effort. (That said, we did not skimp on documentation: everything is documented meticulously, and there is a hopefully-reader-friendly Manual as well.)<p>When it came down to the core abilities we needed, it was like this:
1. We wanted to be able to share arbitrary combinations of C++ native structures, and not just PoDs (plain-old-datatypes). Meaning, things with pointers needed to work; and things with STL-compliant containers needed to work. Boost.interprocess initially looked like it got that job done... but not enough for our use-case at least. When it came down to it, with Boost.ipc:<p>- Allocation from a SHM-segment had to be done using a built-in Boost-written heap-allocation algorithm (they provided two of them, and you can plug in your own... as long as all the control structures lived inside SHM).<p>- The shared data structure had to live entirely within one SHM-segment (mmap()ed area).<p>But, we needed some heavy-duty allocation - the Boost ones are not that. Plugging in a commercial-grade one - like jemalloc - was an option, but that was itself quite a project, especially since the control structures have to live in SHM for it to work. jemalloc is the most advanced thing available, but it kept control structures as globals, so plopping those into SHM meant changing jemalloc (a lot... Eddy actually did pursue this during the design phase). Plus, having both sides of the conversation reading <i>and</i> writing in one shared SHM-segment was not great due to safety concerns.<p>And, whatever allocation would be used - with Boost.interprocess&#x27;s straightforward assumptions - had to be constrained to one mmap()ed area (SHM-segment). jemalloc (for example; substitute tcmalloc or any other heap-provider as desired) would want to mmap() new segments at will. Boost.ipc doesn&#x27;t work in that advanced way.<p>2. We wanted to to send capnp-encoded messages (and, more generally, just &quot;stuff&quot; - linear buffers) with end-to-end zero-copy, meaning capnp-segments would need to be allocated in SHM. I spoke with Kenton Varda (Cap&#x27;n Proto overlord) very recently; he too felt this straightforward desire of not piping-over copies of capnp-encoded items. Various Akamai teams implemented and reimplemented this by hand, for specific use cases, but as I said earlier, it wasn&#x27;t reusable in a general way (not for our specific use-case for that original big C++ service that I was tasked with splitting-up).<p>Other niceties were desirable too - not worrying about names IPC-resource names&#x2F;conflicts&#x2F;..., ensuring SHM cleanup straightforwardly on exit or crash - but they were more tangential (albeit extremely useful) things that came about once we decided to handle the core (1) and (2) in reusable fashion.<p>At that point, nothing seemed to be around that would just give us those fairly intuitive things. I am <i>not</i> saying these are necessary for <i>every</i> IPC use-case... but they never hurt at the very least, and having those readily available give one a feeling of power and freedom.<p>Now, as to the actual question: How does it compare to those? I am not going to lie (because lying is bad): It&#x27;ll take me a few days to understand the ins and outs of Mojo IPC and iceoryx, so any impression I give here is going to be preliminary and surface-level. To that point, I expect the correct&#x2F;true answer to your question will be a matter of diving into each API and simply seeing which one seems best to the particular potential user. For Flow-IPC, this Manual page here should be a pretty decent overview of what&#x27;s available with code snippets: <a href="https:&#x2F;&#x2F;flow-ipc.github.io&#x2F;doc&#x2F;flow-ipc&#x2F;versions&#x2F;main&#x2F;generated&#x2F;html_public&#x2F;api_overview.html" rel="nofollow">https:&#x2F;&#x2F;flow-ipc.github.io&#x2F;doc&#x2F;flow-ipc&#x2F;versions&#x2F;main&#x2F;genera...</a><p>That said, my <i>preliminary</i> initial impression is:<p>(cont.)</div><br/><div id="39996723" class="c"><input type="checkbox" id="c-39996723" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#39996692">parent</a><span>|</span><a href="#39996715">next</a><span>|</span><label class="collapse" for="c-39996723">[-]</label><label class="expand" for="c-39996723">[6 more]</label></div><br/><div class="children"><div class="content">Versus iceoryx (the C++ version, not the Rust-oriented iceoryx2):<p>TL;DR: So far, it looks super-sweet (as well as mature, already supporting macOS for example). However more of an investment to use than is Flow-IPC, with a central daemon and a special event-loop model. It also doesn&#x27;t want to do #1 above described (no pointers, no using existing STL-compliant container types).<p>This guy seems really cool, and it directly addresses at least the major part of need #2 above. You can transmit buffers with near-zero latency, and it&#x27;ll do the SHM stuff for you. (For capnp specifically one would then implement the required SHM-allocating capnp::MessageBuilder, and off we go. Flow-IPC does give you this part out-of-the-box, granted.) Looking over the examples and overview, it seems like integrating it into an event loop might involve some pretty serious learning of iceoryx&#x27;s event-loop model + subscribe&#x2F;publish. There is also a central daemon that needs to run.<p>Flow-IPC, to me, seems to have a lower-learning&#x2F;lower-maintenance curve approach to this. There&#x27;s no central daemon or any equivalent of it. For each asynchronous thing (a transport::Channel, for example, which has receive-oriented methods), you can use one of 2 supplied APIs. The sync_io-style API will let you plug into anything select()&#x2F;poll()&#x2F;epoll()-oriented (and has a syntactic-sugar hook for boost.asio loops). If you&#x27;ve got an event loop, it&#x27;ll be easy to plug Flow-IPC ops right into it - no background threads added thereby. Or, use the async-I&#x2F;O-style API; then it&#x27;ll create background threads as needed and call your callback (e.g., on message receipt) from there, leaving it to you to handle it there or by posting the &quot;true&quot; handling onto one of your own threads.<p>Point being, my impression so far is, using Flow-IPC in this sense is a lower-effort enterprise. It&#x27;s pretty much just there to plug-in. (I really hope that isn&#x27;t slander. That&#x27;s my take so far - as I said, it&#x27;ll take me a few days to understand these products in-depth.)<p>Now, in terms of need #1. (I acknowledge, this need is not for every C++ IPC use-case ever. 2 processes collaborating on one native C++ data structure full of SHM-compliant containers and&#x2F;or pointers =&#x2F;= done every day. Still, though, if 2 threads in one process can do it easily, why shouldn&#x27;t they as-easily be able to do it across a process boundary? Right?) If I understand iceoryx&#x27;s example on this topic (<a href="https:&#x2F;&#x2F;iceoryx.io&#x2F;latest&#x2F;examples&#x2F;complexdata&#x2F;" rel="nofollow">https:&#x2F;&#x2F;iceoryx.io&#x2F;latest&#x2F;examples&#x2F;complexdata&#x2F;</a>)... I quote: &quot;To implement zero-copy data transfer we use a shared memory approach. This requires that every data structure needs to be entirely contained in the shared memory and must not internally use pointers or references. ... Therefore, most of the STL types cannot be used, but we reimplemented some constructs. This example shows how to send&#x2F;receive a iox::cxx::vector and how to send&#x2F;receive a complex data structure containing some of our STL container surrogates.&quot;<p>With Flow-IPC, this does not apply. You can share existing STL-compliant containers, and (if you want) can have raw pointers too. We have tests nesting boost::container string&#x2F;vector&#x2F;map guys and our own flow::util::Basic_blob STL-compliant guy and sharing them, no problem. We&#x27;ve provided the necessary allocator and fancy-pointer types. Moreover, with a single line you can do this in jemalloc-allocated SHM; or instead choose a Boost.ipc-backed single-segment SHM. (Depends on what you desire for safety versus simplicity, internally. I am being a bit vague on that here, but it&#x27;s in the docs, I promise.) I <i>believe</i> this is a pretty good illustration of Flow-IPC&#x27;s &quot;thing&quot;:<p>- Meat-and-potatoes, do what you want to do in your daily C++, without a major learning curve...
- ...but without sacrificing essential power...
- ...and extensibly, meaning you can modify its behavior in core ways without requiring a massive amount of learning of how Flow-IPC is built.<p>Versus Mojo IPC:<p>I really need to understand it better, before I can really comment. So far, it seems like its equivalent of Flow-IPC&#x27;s sessions = super cool, building up a network of processes that can all talk to each other once in the network. Flow-IPC&#x27;s sessions are basic: you want process A and B to speak, you establish a session (during this step, one is designated as the session-server and can therefore accept more sessions from that app or other apps)... then from there, you can make channels (and access SHM arenas, if you are using SHM directly as opposed to letting the zero-copy channels do it invisibly). It also has various-language bindings; Flow-IPC is C++... straight up.<p>That established, I need to understand it better. It looks like it provides super-fast low-level IPC transports (similar to Flow-IPC&#x27;s unstructured-layer <i>channels</i>) in platform-agnostic fashion - but does not seem to specifically facilitate end-to-end zero-copy transmission of data structures via SHM. I could be completely wrong here, but it actually looks like one could feasibly plug-in Mojo IPC pipes as Flow-IPC Blob_sender&#x2F;receiver (and&#x2F;or Native_handle_sender&#x2F;receiver) concept impl, into Flow-IPC, and get the end-to-end zero-copy goodness.<p>At least superficially, so far, Flow-IPC again looks like perhaps a more down-to-earth&#x2F;readily-pluggable effort. (But, still documented out-the-wazoo!)</div><br/><div id="40001166" class="c"><input type="checkbox" id="c-40001166" checked=""/><div class="controls bullet"><span class="by">robobully</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#39996723">parent</a><span>|</span><a href="#39996715">next</a><span>|</span><label class="collapse" for="c-40001166">[-]</label><label class="expand" for="c-40001166">[5 more]</label></div><br/><div class="children"><div class="content">Thanks for the detailed answer! I really appreciate that.</div><br/><div id="40003571" class="c"><input type="checkbox" id="c-40003571" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#40001166">parent</a><span>|</span><a href="#39996715">next</a><span>|</span><label class="collapse" for="c-40003571">[-]</label><label class="expand" for="c-40003571">[4 more]</label></div><br/><div class="children"><div class="content">You’re welcome. But I must tell you, at work I asked how my answers are, keep me honest. So a coworker looked at this thread and was just like, “dude just get to the point, no one wants to read all that.” And then explained that in huge detail.<p>That’s just how I talk. With all the writing I’ve had to do lately - documentation, blog, announcements - it’s been a constant struggle forcing myself to say fewer words, keep it short, keep the eyeballs, come onnnnnnn, edit edit edit!!! And that’s good… it’s how it should be. It’s just totally unnatural to me personally… hehe.<p>FINALLY there’s a chance to simply talk about it to some humans, so I uh… maybe went a little wild with the verbosity.</div><br/><div id="40008726" class="c"><input type="checkbox" id="c-40008726" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#40003571">parent</a><span>|</span><a href="#39996715">next</a><span>|</span><label class="collapse" for="c-40008726">[-]</label><label class="expand" for="c-40008726">[3 more]</label></div><br/><div class="children"><div class="content">Actually, I&#x27;m happy you spent all those words, and I read them all.<p>I&#x27;ve been looking for an SHM IPC for a <i>very</i> long time and not finding one.  It&#x27;s nice to know that I&#x27;m not the only idiot thinking along these lines.<p>In addition, it&#x27;s also nice to know that <i>this was hard</i>.  I have taken several stabs at doing this, and I always bounced off thinking &quot;It can&#x27;t be this difficult.  I&#x27;m screwing up.&quot;  Seeing that smart people working for a real company had to do major surgery on something like jemalloc is a bit of a validation.<p>Can&#x27;t say I&#x27;m happy to see this in C++, but I&#x27;ll take what I can get.  :)<p>Thanks to all the folks who wrote it.  And thank you for the long winded explanations otherwise I probably would have ignored it.</div><br/><div id="40009120" class="c"><input type="checkbox" id="c-40009120" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#40008726">parent</a><span>|</span><a href="#39996715">next</a><span>|</span><label class="collapse" for="c-40009120">[-]</label><label class="expand" for="c-40009120">[2 more]</label></div><br/><div class="children"><div class="content">1. You’re welcome!<p>2. I too would like to explore other developments - not that I think C++ sucks or anything (not that I don’t think it doesn’t suck sometimes!) - Rust and all. Here’s hoping<p>3. At points during development of this, the ol’ impostor syndrome would kick in. “Surely someone would’ve done this already.” Or more often, “Meh, people will just roll their own version of this, it’s not that hard.” But then I’d actually go through the exercise of implementing whatever it was - and think to myself, “that WAS NOT obvious.” It dawned on me that by doing it, I proved (to myself at least) that it’s not easy to do it, and thus perhaps worth having started.</div><br/><div id="40029062" class="c"><input type="checkbox" id="c-40029062" checked=""/><div class="controls bullet"><span class="by">geostupid</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#40009120">parent</a><span>|</span><a href="#39996715">next</a><span>|</span><label class="collapse" for="c-40029062">[-]</label><label class="expand" for="c-40029062">[1 more]</label></div><br/><div class="children"><div class="content">Thank you so much for posting everything that you did. Long-form details are hard to find.  In my truest contribution, I suggest you&#x27;re a pleasure to work with. Rarely have I seen anyone willing to give the deep-digest of their determination and problems with a function.  Consider writing more!<p>EDIT<p>I didn&#x27;t see the other posts about brevity. Fuck that. Details matter and so does the human experience. Who hasn&#x27;t on this site been the unfortunate recipient of trying to get some brilliant but shitty function to work?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39993210" class="c"><input type="checkbox" id="c-39993210" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#39987737">parent</a><span>|</span><a href="#39995666">prev</a><span>|</span><a href="#40024248">next</a><span>|</span><label class="collapse" for="c-39993210">[-]</label><label class="expand" for="c-39993210">[4 more]</label></div><br/><div class="children"><div class="content">I’ve spent a lot of time with boost asio and serialisation of objects into a boost variant to send that across the wire. The server vists the variant to process the message. Including boost shared memory for file data.<p>Both for unix domain sockets and TCP.<p>There’re plenty of boost examples around so, I’d suggest, you take their examples and work them for your framework.<p>As I’m sure you’re aware, a clean and easy to read example will make a difference.<p>It’s great that you’re open source and I hope you get some traction.</div><br/><div id="39993390" class="c"><input type="checkbox" id="c-39993390" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#39993210">parent</a><span>|</span><a href="#40024248">next</a><span>|</span><label class="collapse" for="c-39993390">[-]</label><label class="expand" for="c-39993390">[3 more]</label></div><br/><div class="children"><div class="content">Indeed, examples from every angle are probably the one deficit of the existing documentation. There are a couple, such as the perf_demo described in the blog post. I’d like to add ones showing integration with<p>- epoll based event loop<p>- boost.asio based event loop<p>(Boost.interprocess and boost.asio are huge inspirations and are both used inside!)<p>As for traction: it’s tough! Have to get eyeballs; and then have to convey a sense of being worth one’s trust.<p>Thank you for your time.</div><br/><div id="39995972" class="c"><input type="checkbox" id="c-39995972" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#39993390">parent</a><span>|</span><a href="#40024248">next</a><span>|</span><label class="collapse" for="c-39995972">[-]</label><label class="expand" for="c-39995972">[2 more]</label></div><br/><div class="children"><div class="content">Integration with boost asio would be of interest to many - myself included. It is the defacto for anyone who’s got past Stephen’s Unix Network Programming.<p>It would gain a level of trust with developers.</div><br/><div id="39996753" class="c"><input type="checkbox" id="c-39996753" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#39987737">root</a><span>|</span><a href="#39995972">parent</a><span>|</span><a href="#40024248">next</a><span>|</span><label class="collapse" for="c-39996753">[-]</label><label class="expand" for="c-39996753">[1 more]</label></div><br/><div class="children"><div class="content">Roger dodger.<p>For what it is worth at this time - obviously acting on the following statement will require some level of trust -<p>It is very much ready to use with boost.asio. (I know that, because I myself use boost.asio religiously. If it were not compatible with it, I&#x27;d pretty much have to not use Flow-IPC myself.) Though, it could (fairly easily) gain a number of wrapper classes that would turn our stuff into actual boost.asio I&#x2F;O objects; then it&#x27;d be even more straightforward.<p>Topic is covered here:<p><a href="https:&#x2F;&#x2F;flow-ipc.github.io&#x2F;doc&#x2F;flow-ipc&#x2F;versions&#x2F;main&#x2F;generated&#x2F;html_public&#x2F;async_loop.html" rel="nofollow">https:&#x2F;&#x2F;flow-ipc.github.io&#x2F;doc&#x2F;flow-ipc&#x2F;versions&#x2F;main&#x2F;genera...</a><p>There&#x27;s even the little section entitled, &quot;I&#x27;m a boost.asio user. Can&#x27;t I just give your constructor my io_context, and then you&#x27;ll place the completion handler directly onto it?&quot;<p>To summarize, though...<p>-1- You can have Flow-IPC create background threads as-needed and ping your completion handler (e.g., &quot;message received&quot;) from such threads.<p>-2- You can have it <i>not</i> create any background threads, instead asking you to .async_wait() (via boost.asio, most easily; but also manually with poll() or whatever you want) whenever it needs internally to async-await something. Your own completion handler (e.g., handle just-received message M) shall execute synchronously at only predictable points, in non-blocking fashion.<p>-3- Direct integration with boost.asio - meaning ipc::transport::Channel (e.g.) would take an io_context&#x2F;executor&#x2F;whatever in its ctor, and .async_X(F) would indeed post F onto that io_context&#x2F;executor&#x2F;whatever = essentially syntactic sugar = a TODO. (I&#x27;d best file an Issue, I just remembered.)<p>The perf_demo (partially recreated in the blog-post) integrates into a single-threaded boost.asio io_context, using technique #2 above. In the source code snippets in the blog, we avoided anything asynchronous just to keep it focused for the max # of readers (hopefully).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40024248" class="c"><input type="checkbox" id="c-40024248" checked=""/><div class="controls bullet"><span class="by">nonane</span><span>|</span><a href="#39987737">prev</a><span>|</span><a href="#40005544">next</a><span>|</span><label class="collapse" for="c-40024248">[-]</label><label class="expand" for="c-40024248">[3 more]</label></div><br/><div class="children"><div class="content">Cool stuff!<p>Does Flow-IPC protect against malformed messages? For example a client sending malformed messages to a server process</div><br/><div id="40026778" class="c"><input type="checkbox" id="c-40026778" checked=""/><div class="controls bullet"><span class="by">sgtnoodle</span><span>|</span><a href="#40024248">parent</a><span>|</span><a href="#40005544">next</a><span>|</span><label class="collapse" for="c-40026778">[-]</label><label class="expand" for="c-40026778">[2 more]</label></div><br/><div class="children"><div class="content">Given that it&#x27;s shared memory based, it seems like there has to be some degree of trust that the participants are well behaved. What do you mean by a malformed message, though? If you&#x27;re talking about the payload of the message, that seems like a matter of the message scheme you&#x27;re using. If you&#x27;re talking about correctness of the IPC protocol itself, integrity checking is unfortunately at odds with latency.</div><br/><div id="40029098" class="c"><input type="checkbox" id="c-40029098" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#40024248">root</a><span>|</span><a href="#40026778">parent</a><span>|</span><a href="#40005544">next</a><span>|</span><label class="collapse" for="c-40029098">[-]</label><label class="expand" for="c-40029098">[1 more]</label></div><br/><div class="children"><div class="content">Reply co-signed!<p>That said, I&#x27;ll add that my Manual (<a href="https:&#x2F;&#x2F;flow-ipc.github.io&#x2F;doc&#x2F;flow-ipc&#x2F;versions&#x2F;main&#x2F;generated&#x2F;html_public&#x2F;pages.html" rel="nofollow">https:&#x2F;&#x2F;flow-ipc.github.io&#x2F;doc&#x2F;flow-ipc&#x2F;versions&#x2F;main&#x2F;genera...</a>) gets into the topic of <i>safety</i> (with a few words on how this differs from <i>security</i>; this indeed involves <i>trust</i>). So indeed Flow-IPC does not attempt to provide security for malicious&#x2F;untrusted conversation-partner -- but it <i>does</i> provide a few enabled-by-default <i>safety</i> mechanisms. The Manual page in question: <a href="https:&#x2F;&#x2F;flow-ipc.github.io&#x2F;doc&#x2F;flow-ipc&#x2F;versions&#x2F;main&#x2F;generated&#x2F;html_public&#x2F;safety_perms.html" rel="nofollow">https:&#x2F;&#x2F;flow-ipc.github.io&#x2F;doc&#x2F;flow-ipc&#x2F;versions&#x2F;main&#x2F;genera...</a><p>Among other things, the capnp-layer (which, as I noted in a recent reply earlier, is optional to use -- you can and sometimes certainly should &quot;just&quot; go native, and&#x2F;or combine the two approaches) uses an internally-generated token to ensure some kind of terrible bug&#x2F;thing&#x2F;problem&#x2F;act-of-god isn&#x27;t mis-routing messages. It&#x27;s a <i>safety</i> mechanism.<p>But in terms of, say, incompatible schemas or mis-matching native `struct`s -- what if you used different compilers with slightly different STLs on the 2 sides?! -- it is indeed on the developer to not make that error&#x2F;not converse with untrusted code. Flow-IPC will guard against misuses to the extent it&#x27;s reasonable though, IMO.<p>P.S. [Internal impl note] Oh! And, although at the moment it is the protocol version v1 (for all internally-involved protocols at all layers), I did build-in a protocol-version-checking system from the start, so as to avoid shooting ourselves in the foot, in case Flow-IPC needs to expand some of its internal protocol(s) in later versions. At the very worst, Flow-IPC would refuse to establish a channel&#x2F;session upon encountering a partner with Flow-IPC version such that their protocols are incompatible. (Again -- academic at the moment, since there is only v1 -- but might be different in the future. At that point a new protocol might be developed to be backward-compatible with earlier-Flow-IPCs and just still work; or worst case throw the aforementioned error if not.)</div><br/></div></div></div></div></div></div><div id="40005544" class="c"><input type="checkbox" id="c-40005544" checked=""/><div class="controls bullet"><span class="by">ygoldfeld</span><span>|</span><a href="#40024248">prev</a><span>|</span><label class="collapse" for="c-40005544">[-]</label><label class="expand" for="c-40005544">[1 more]</label></div><br/><div class="children"><div class="content">(Akamai owns Linode and uses the blog on Linode.com as a developer-oriented blog. So that’s why the link is to there.)</div><br/></div></div></div></div></div></div></div></body></html>