<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702285263628" as="style"/><link rel="stylesheet" href="styles.css?v=1702285263628"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/littlefs-project/littlefs">Littlefs – a little fail-safe filesystem designed for microcontrollers</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>pabs3</span> | <span>11 comments</span></div><br/><div><div id="38597684" class="c"><input type="checkbox" id="c-38597684" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#38597595">next</a><span>|</span><label class="collapse" for="c-38597684">[-]</label><label class="expand" for="c-38597684">[9 more]</label></div><br/><div class="children"><div class="content">A caveat for anyone wanting to use this - while the library does work and the test suite seems thorough, the implementation does some _very_ sketchy things like forcibly casting pointers to unrelated types so they can be shoved through some multiply-recursive functions and then cast back to the correct type later.<p>A team I was on a while back ended up abandoning LittleFS as we couldn&#x27;t fully trust the C implementation and my two separate attempts to port it to Rust both proved futile (_everything_ had to be unsafe).</div><br/><div id="38598788" class="c"><input type="checkbox" id="c-38598788" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38597684">parent</a><span>|</span><a href="#38598133">next</a><span>|</span><label class="collapse" for="c-38598788">[-]</label><label class="expand" for="c-38598788">[1 more]</label></div><br/><div class="children"><div class="content">What prevents you from taking the underlying data structures and reimplementing the API?</div><br/></div></div><div id="38598133" class="c"><input type="checkbox" id="c-38598133" checked=""/><div class="controls bullet"><span class="by">SV_BubbleTime</span><span>|</span><a href="#38597684">parent</a><span>|</span><a href="#38598788">prev</a><span>|</span><a href="#38597702">next</a><span>|</span><label class="collapse" for="c-38598133">[-]</label><label class="expand" for="c-38598133">[1 more]</label></div><br/><div class="children"><div class="content">I can tell you take offense to the questionable casting… but did you discover anywhere it made mistakes and failed - or you just didn’t like it?</div><br/></div></div><div id="38597702" class="c"><input type="checkbox" id="c-38597702" checked=""/><div class="controls bullet"><span class="by">thenewwazoo</span><span>|</span><a href="#38597684">parent</a><span>|</span><a href="#38598133">prev</a><span>|</span><a href="#38597595">next</a><span>|</span><label class="collapse" for="c-38597702">[-]</label><label class="expand" for="c-38597702">[6 more]</label></div><br/><div class="children"><div class="content">What do you recommend instead?</div><br/><div id="38597736" class="c"><input type="checkbox" id="c-38597736" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#38597684">root</a><span>|</span><a href="#38597702">parent</a><span>|</span><a href="#38597595">next</a><span>|</span><label class="collapse" for="c-38597736">[-]</label><label class="expand" for="c-38597736">[5 more]</label></div><br/><div class="children"><div class="content">We ended up going with a very trivial system based on tar files and bitfield allocators and delegated the more filesystem-y like functionality to a higher level of the stack.</div><br/><div id="38597898" class="c"><input type="checkbox" id="c-38597898" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38597684">root</a><span>|</span><a href="#38597736">parent</a><span>|</span><a href="#38597595">next</a><span>|</span><label class="collapse" for="c-38597898">[-]</label><label class="expand" for="c-38597898">[4 more]</label></div><br/><div class="children"><div class="content">I happen to be in the middle of writing a simple tar implementation, and had in fact just started playing with the idea of just using it as an on-disk filesystem format. The caveats I can see are that 1. it&#x27;s approximately append-only[0], and 2. you have to replay the whole thing in order to make sure you have the latest version of a file (I&#x27;m leaning towards doing so on mount because then I can also build an in-memory filename-to-block-address cache). Have you hit any issues, or is this as surprisingly reasonable as it sounds?<p>[0] I mean, if the new version of a file fits in the same number of 512-byte blocks as the old version you <i>could</i> update in place, but that&#x27;s an unreliable condition at best and also guarantees data corruption if you lose power halfway; really going append-only makes the implementation simple and also makes it easy to be really resilient.</div><br/><div id="38598508" class="c"><input type="checkbox" id="c-38598508" checked=""/><div class="controls bullet"><span class="by">e63f67dd-065b</span><span>|</span><a href="#38597684">root</a><span>|</span><a href="#38597898">parent</a><span>|</span><a href="#38597935">next</a><span>|</span><label class="collapse" for="c-38598508">[-]</label><label class="expand" for="c-38598508">[2 more]</label></div><br/><div class="children"><div class="content">Not so sure about the tar part, but the append-only nature is actually really well-known: look up log-structured filesystems, where all operations append to the log and GC comes to clean up stale data later.
 I’m in the middle of writing a log-structured disk, and it’s really nice to work with. You get many things like clones, snapshots, etc for free.<p>The replay problem is usually solved with periodic checkpoints of your map, and a checkpoint on shutdown. This way you only ever replay on failure, at which point performance doesn’t matter as much.</div><br/><div id="38598555" class="c"><input type="checkbox" id="c-38598555" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38597684">root</a><span>|</span><a href="#38598508">parent</a><span>|</span><a href="#38597935">next</a><span>|</span><label class="collapse" for="c-38598555">[-]</label><label class="expand" for="c-38598555">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, knowing there were filesystems designed like that on purpose made me feel better about it:) And once you get over the initial weirdness, the ability to get any version of any file is pretty nice. Though my favorite angle is that if you can live with just burning space[0], it makes the thing <i>so</i> easy to implement:)<p>[0] To be fair, a huge caveat.</div><br/></div></div></div></div><div id="38597935" class="c"><input type="checkbox" id="c-38597935" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#38597684">root</a><span>|</span><a href="#38597898">parent</a><span>|</span><a href="#38598508">prev</a><span>|</span><a href="#38597595">next</a><span>|</span><label class="collapse" for="c-38597935">[-]</label><label class="expand" for="c-38597935">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not on the team anymore so I don&#x27;t know if they kept the tar stuff around, but it was straightforward to scan the flash for valid tar header blocks to build the allocation bitmap and then flag header blocks as invalid when files were deleted. The total number of files we needed to keep in the flash was small, so simple brute-force stuff worked fine.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38597595" class="c"><input type="checkbox" id="c-38597595" checked=""/><div class="controls bullet"><span class="by">jpcfl</span><span>|</span><a href="#38597684">prev</a><span>|</span><label class="collapse" for="c-38597595">[-]</label><label class="expand" for="c-38597595">[1 more]</label></div><br/><div class="children"><div class="content">Very cool. FYI, I had to remove some compiler flags and change the &#x27;section&#x27; attributes to get the tests building with Clang, but it seems to be working on my Mac.<p>I was looking for a benchmark that would give me an idea of the RAM&#x2F;ROM footprint for the library, but I don&#x27;t see one.</div><br/></div></div></div></div></div></div></div></body></html>