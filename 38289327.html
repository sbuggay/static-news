<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700211657985" as="style"/><link rel="stylesheet" href="styles.css?v=1700211657985"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zknill.io/posts/collaboration-no-crdts/">You don&#x27;t need a CRDT to build a collaborative experience</a> <span class="domain">(<a href="https://zknill.io">zknill.io</a>)</span></div><div class="subtext"><span>zknill</span> | <span>55 comments</span></div><br/><div><div id="38292180" class="c"><input type="checkbox" id="c-38292180" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#38292306">next</a><span>|</span><label class="collapse" for="c-38292180">[-]</label><label class="expand" for="c-38292180">[13 more]</label></div><br/><div class="children"><div class="content">I agree broadly with the article’s position but I think locks are more harmful than helpful. When I was a Quip user (2018) it was super frustrating to get locked out of a paragraph because someone’s cursor idled there. Instead just allow LWW overwrites. If users have contention and your sync &amp; presence is fast, they’ll figure it out pretty quick, and at most lose 1-2 keystrokes, or one drag gesture, or one color pick.<p>Notion is “collaborative” and we don’t use a CRDT for text, it’s all last-write-wins decided by the server. However our LWW texts are individually small - one block&#x2F;paragraph in size - and adding&#x2F;moving&#x2F;removing blocks is intention-preserving if not perfectly convergent.<p>As the article says, the downside for LWW is that “offline” &#x2F; async collaboration isn’t so great. That’s why we’re working on switching to CRDT for our texts. If you’re interested in bringing CRDTs to a product with a lot of users, consider joining Notion’s Docs team - <a href="https:&#x2F;&#x2F;boards.greenhouse.io&#x2F;notion&#x2F;jobs&#x2F;5602426003" rel="nofollow noreferrer">https:&#x2F;&#x2F;boards.greenhouse.io&#x2F;notion&#x2F;jobs&#x2F;5602426003</a> &#x2F; @jitl on Twitter &#x2F; jake@makenotion.com</div><br/><div id="38299534" class="c"><input type="checkbox" id="c-38299534" checked=""/><div class="controls bullet"><span class="by">ccorcos</span><span>|</span><a href="#38292180">parent</a><span>|</span><a href="#38292682">next</a><span>|</span><label class="collapse" for="c-38299534">[-]</label><label class="expand" for="c-38299534">[1 more]</label></div><br/><div class="children"><div class="content">I agree!<p>If people clobber each others updates by typing at the same time in the same input, at least they can understand what happened.<p>That’s much better than not being able to do something because someone left their cursor on something and walked away…</div><br/></div></div><div id="38292682" class="c"><input type="checkbox" id="c-38292682" checked=""/><div class="controls bullet"><span class="by">zknill</span><span>|</span><a href="#38292180">parent</a><span>|</span><a href="#38299534">prev</a><span>|</span><a href="#38298360">next</a><span>|</span><label class="collapse" for="c-38292682">[-]</label><label class="expand" for="c-38292682">[5 more]</label></div><br/><div class="children"><div class="content">So Last-Write-Wins (LWW) basically _is_ a CRDT, but not in the sense that anyone really expects, because they aren&#x27;t that useful or intention preserving. Especially if the two writes happen in very quick succession &#x2F; concurrently.<p>LWW becomes useful if you can:<p>a) help humans to see who is doing what on a doc<p>b) reduce the size of the change that is LWW<p>As you&#x27;ve said:<p>&gt; However our LWW texts are individually small - one block&#x2F;paragraph in size<p>This is really important, because by reducing the size of the individual element that any single user is updating you can also reduce the chance of conflicts. With a small amount of contextual feedback (like the notion icon next to the block) a lot of the problem cases are just avoided.<p>Clearly locking and updating the entire document would be terrible, but if you can do it on a small enough scope that others can change other elements, it can work really well.<p>(If you&#x27;ve worked on the notion things you&#x27;re describing then I&#x27;m sure you know this better than I do, but just spelling it out really clearly.)</div><br/><div id="38293078" class="c"><input type="checkbox" id="c-38293078" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#38292180">root</a><span>|</span><a href="#38292682">parent</a><span>|</span><a href="#38298360">next</a><span>|</span><label class="collapse" for="c-38293078">[-]</label><label class="expand" for="c-38293078">[4 more]</label></div><br/><div class="children"><div class="content">You can have a LWW CRDT, but not every LWW is a CRDT. LWW CRDTs generally pick a winner based on causal order which is <i>convergent</i>, the C in CRDT, because every peer receiving the same ops in any order would pick the same winner.<p>Picking a winner based on wall clock time order (as suggested in the article, and implemented by Notion) is not convergent; if peers used that algorithm to apply ops I they would not converge to the same state. Instead you need an authority (your server) to essentially pick an arbitrary order of ops and clients just have to deal with it.<p>A practical example is to consider three users (A, B, C) working on a document.<p>1. A, B, C start online working together.<p>2. C goes offline<p>3. A, B stay online, and make 100s of changes.<p>4. C makes a few changes while offline (not sent to other peers yet)<p>5. C comes back online and sends their changes to (the server &#x2F; other peers).<p>In wall-clock LWW, C&#x27;s changes will overwrite A &amp; B&#x27;s changes, even though A &amp; B have done a lot more work.<p>In a causal ordering CRDT implementing LWW, C&#x27;s changes will &quot;lose&quot; to A &amp; B&#x27;s changes, since they were actually made &quot;earlier&quot; in causal ordering.<p>&gt; Clearly locking and updating the entire document would be terrible, but if you can do it on a small enough scope that others can change other elements, it can work really well.<p>I&#x27;m sure good UX is possible with locks, but I haven&#x27;t used one yet for document editing. I&#x27;m still traumatized from Quip which did per-paragraph (per block?) locking and was really annoying. Eventually they added an unlock button next to the block so anyone could &quot;steal&quot; the lock at will due to all the user complaints, but at that point, why put it in at all?</div><br/><div id="38294560" class="c"><input type="checkbox" id="c-38294560" checked=""/><div class="controls bullet"><span class="by">maclockard</span><span>|</span><a href="#38292180">root</a><span>|</span><a href="#38293078">parent</a><span>|</span><a href="#38296490">next</a><span>|</span><label class="collapse" for="c-38294560">[-]</label><label class="expand" for="c-38294560">[1 more]</label></div><br/><div class="children"><div class="content">I understand what you are saying here in terms of the difference between using wall-clock or causal ordering to determine who &#x27;wins&#x27; for LWW. However, both of these strategies seem convergent to me? In any case, all clients will agree on whose changes win.<p>1. With wall-clock decided by clients, A + B changes will win since C&#x27;s wall-time is earlier (yes, C could lie, but still would converge).<p>2. With wall-clock decided by server C will win and everyone will agree.<p>3. With causal ordering, everyone will agree that A + B won.<p>2 is not a CRDT since it requires a central server, but I think 1 would still count? Or stated another way: I&#x27;m not sure the _convergence_ is what determines if these strategies are CRDTs or not, but rather whether or not this decision making is _distributed_ or not.</div><br/></div></div><div id="38296490" class="c"><input type="checkbox" id="c-38296490" checked=""/><div class="controls bullet"><span class="by">asib</span><span>|</span><a href="#38292180">root</a><span>|</span><a href="#38293078">parent</a><span>|</span><a href="#38294560">prev</a><span>|</span><a href="#38295206">next</a><span>|</span><label class="collapse" for="c-38296490">[-]</label><label class="expand" for="c-38296490">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ...based on causal order which is convergent, the C in CRDT...<p>Doesn&#x27;t the C stand for conflict-free? I suppose both are kind of getting at the same idea though.</div><br/></div></div></div></div></div></div><div id="38298360" class="c"><input type="checkbox" id="c-38298360" checked=""/><div class="controls bullet"><span class="by">Summerbud</span><span>|</span><a href="#38292180">parent</a><span>|</span><a href="#38292682">prev</a><span>|</span><a href="#38295717">next</a><span>|</span><label class="collapse" for="c-38298360">[-]</label><label class="expand" for="c-38298360">[1 more]</label></div><br/><div class="children"><div class="content">I feel the same in the paragraph. But in some situation it seems rational<p>Figma still limits you from editing the component if someone is on it. And Figjam did that too. In my mind, this is a good practice in the realm of collaborative design. Because it will be very messy if a single component obeys the last-write-win rule</div><br/></div></div><div id="38292299" class="c"><input type="checkbox" id="c-38292299" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#38292180">parent</a><span>|</span><a href="#38295797">prev</a><span>|</span><a href="#38292306">next</a><span>|</span><label class="collapse" for="c-38292299">[-]</label><label class="expand" for="c-38292299">[3 more]</label></div><br/><div class="children"><div class="content">Are you considering having a CRDT for each text block individually, or moving to a CRDT for the entire data model for a document? Really curious about the design approach here, especially insofar as there&#x27;s now an external API that the data models need to service!</div><br/><div id="38292439" class="c"><input type="checkbox" id="c-38292439" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#38292180">root</a><span>|</span><a href="#38292299">parent</a><span>|</span><a href="#38292306">next</a><span>|</span><label class="collapse" for="c-38292439">[-]</label><label class="expand" for="c-38292439">[2 more]</label></div><br/><div class="children"><div class="content">It’s Complicated (tm), a hybrid of the two. Text content across multiple CRDT enabled blocks may be connected in a single logical CRDT, but the segment visible in any given block is stored in that block object, which maintains our permission system invariants. We’ll still support moving blocks to different pages, so one page may have a few different CRDTs visually interleaved.<p>All the edge cases are very interesting, like what happens if I use backspace to join a block of CRDT B into block of CRDT A.<p>API consumers are unaffected. Likely we’ll support API updates of text as best-effort diff-match-patch of the text on our side applied as CRDT ops.</div><br/><div id="38293685" class="c"><input type="checkbox" id="c-38293685" checked=""/><div class="controls bullet"><span class="by">npunt</span><span>|</span><a href="#38292180">root</a><span>|</span><a href="#38292439">parent</a><span>|</span><a href="#38292306">next</a><span>|</span><label class="collapse" for="c-38293685">[-]</label><label class="expand" for="c-38293685">[1 more]</label></div><br/><div class="children"><div class="content">always great hearing your perspective on the notion text engine jake, thanks for taking the time to explain everything!</div><br/></div></div></div></div></div></div></div></div><div id="38292306" class="c"><input type="checkbox" id="c-38292306" checked=""/><div class="controls bullet"><span class="by">lewisjoe</span><span>|</span><a href="#38292180">prev</a><span>|</span><a href="#38291507">next</a><span>|</span><label class="collapse" for="c-38292306">[-]</label><label class="expand" for="c-38292306">[5 more]</label></div><br/><div class="children"><div class="content">&gt; everyone’s gonna say “but hey, google docs uses operational transform not CRDTs”.. OK yes, but you are not google.<p>Well, google docs works not because they somehow figured out how to converge OT edits with as much precision as CRDTs do, but simply because they have a central server which orders edits anyway and don&#x27;t need true leader-less convergence.<p>In fact, I agree not many things don&#x27;t need a CRDT. CRDTs help with mathematical rigidity of convergence when you want true peer-2-peer collaboration which works without any central authority.<p>However, most apps anyway work on top of a central authority (example SaaS apps) so there is no real reason to accomodate all the compexity that comes with CRDT. They might get far with a simpler OT based model + central server based ordering.<p>For example even Figma doesn&#x27;t call its model a 100% pure CRDT. It&#x27;s a partial, simpler CRDT implemented with an assumption that there&#x27;s going to be a server that understands ordering.<p>It&#x27;s the same with Google Docs. They don&#x27;t need a CRDT because it&#x27;s a cloud app after all, which means OT is more convenient with major heavylifting (ordering and conflict handlings) outsourced to the server.</div><br/><div id="38295067" class="c"><input type="checkbox" id="c-38295067" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#38292306">parent</a><span>|</span><a href="#38291507">next</a><span>|</span><label class="collapse" for="c-38295067">[-]</label><label class="expand" for="c-38295067">[4 more]</label></div><br/><div class="children"><div class="content">Yeah. Text based OT is pretty simple to implement, too. It’s about 200 lines of code, plus a simple network protocol. It’s fast and relatively straightforward to code up, and unlike text CRDTs it’s pretty fast by default.<p>I use it as my standard test when trying out a new programming language. It was unexpectedly ugly in go because of go’s lack of enums &amp; unions, and that’s one of the big reasons I never got in to programming Go.</div><br/><div id="38296162" class="c"><input type="checkbox" id="c-38296162" checked=""/><div class="controls bullet"><span class="by">jay-aye-see-key</span><span>|</span><a href="#38292306">root</a><span>|</span><a href="#38295067">parent</a><span>|</span><a href="#38291507">next</a><span>|</span><label class="collapse" for="c-38296162">[-]</label><label class="expand" for="c-38296162">[3 more]</label></div><br/><div class="children"><div class="content">Operational transforms are one of those interesting technologies I’ve wanted to learn by implementing but haven’t made the time yet. I also didn’t realise it could be implemented in that little code.<p>Can you recommend any learning resources for implementing an OT? (Ideally typescript, python, or rust)</div><br/><div id="38296686" class="c"><input type="checkbox" id="c-38296686" checked=""/><div class="controls bullet"><span class="by">dugmartin</span><span>|</span><a href="#38292306">root</a><span>|</span><a href="#38296162">parent</a><span>|</span><a href="#38296435">next</a><span>|</span><label class="collapse" for="c-38296686">[-]</label><label class="expand" for="c-38296686">[1 more]</label></div><br/><div class="children"><div class="content">This single file shows the entire set of OT transformations (retain, insert, delete):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Operational-Transformation&#x2F;ot.js&#x2F;blob&#x2F;master&#x2F;lib&#x2F;text-operation.js">https:&#x2F;&#x2F;github.com&#x2F;Operational-Transformation&#x2F;ot.js&#x2F;blob&#x2F;mas...</a><p>and this is a good post outlining the basics of OT, from the creator of CodeMirror:<p><a href="https:&#x2F;&#x2F;marijnhaverbeke.nl&#x2F;blog&#x2F;collaborative-editing-cm.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;marijnhaverbeke.nl&#x2F;blog&#x2F;collaborative-editing-cm.htm...</a></div><br/></div></div><div id="38296435" class="c"><input type="checkbox" id="c-38296435" checked=""/><div class="controls bullet"><span class="by">jahfer</span><span>|</span><a href="#38292306">root</a><span>|</span><a href="#38296162">parent</a><span>|</span><a href="#38296686">prev</a><span>|</span><a href="#38291507">next</a><span>|</span><label class="collapse" for="c-38296435">[-]</label><label class="expand" for="c-38296435">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t explored this space in a while, but I have a couple of examples that could be helpful. A Clojure library of mine [0] has a decent README with some background reading on how to use operational transform.<p>I also reimplemented it in a surprisingly tiny amount of OCaml [1] which was a fun way to learn that language :)<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;jahfer&#x2F;othello">https:&#x2F;&#x2F;github.com&#x2F;jahfer&#x2F;othello</a>
[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;jahfer&#x2F;othello-ocaml">https:&#x2F;&#x2F;github.com&#x2F;jahfer&#x2F;othello-ocaml</a></div><br/></div></div></div></div></div></div></div></div><div id="38291507" class="c"><input type="checkbox" id="c-38291507" checked=""/><div class="controls bullet"><span class="by">MontagFTB</span><span>|</span><a href="#38292306">prev</a><span>|</span><a href="#38291630">next</a><span>|</span><label class="collapse" for="c-38291507">[-]</label><label class="expand" for="c-38291507">[8 more]</label></div><br/><div class="children"><div class="content">One of the main points of this article is to &quot;just use locks&quot;, which glosses over a lot of technical complications about locking elements within a document. How long is the lock held? Can it be stolen from a user who has gone offline, or is still online but off to lunch, and we _really_ need to make this change before the presentation in an hour? What if the user comes back online and they have changes, but the lock was stolen - how are those changes reconciled to the document?<p>I am generally in favor of simpler is better, and if there is a way to build a collaborative experience without using CRDTs, then go for it. However, sometimes the cure can be worse than the disease, and solutions like locking may introduce more technical complexity than originally thought.</div><br/><div id="38292470" class="c"><input type="checkbox" id="c-38292470" checked=""/><div class="controls bullet"><span class="by">zknill</span><span>|</span><a href="#38291507">parent</a><span>|</span><a href="#38291571">next</a><span>|</span><label class="collapse" for="c-38292470">[-]</label><label class="expand" for="c-38292470">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re absolutely right, locking is a hard problem. Especially when you get into the edge cases of clients not disconnecting cleanly.<p>If you&#x27;ve ever used one of those awful early-2000s Microsoft word collaboration systems where you have to check-out the doc, and remember to check it back in, and no one can use it until you&#x27;ve checked it back in... it&#x27;s awful!<p>I&#x27;m not directly in this team, but one of the teams at my company have been working on this problem. They call it &quot;Spaces&quot;, and one of the features solves this component locking problem.<p><a href="https:&#x2F;&#x2F;ably.com&#x2F;examples&#x2F;component-locking" rel="nofollow noreferrer">https:&#x2F;&#x2F;ably.com&#x2F;examples&#x2F;component-locking</a></div><br/></div></div><div id="38291571" class="c"><input type="checkbox" id="c-38291571" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38291507">parent</a><span>|</span><a href="#38292470">prev</a><span>|</span><a href="#38292323">next</a><span>|</span><label class="collapse" for="c-38291571">[-]</label><label class="expand" for="c-38291571">[1 more]</label></div><br/><div class="children"><div class="content">By exploring that locking and unlocking mechanism, you will find that the logical conclusion in the end, when enough complexity and edge cases get covered&#x2F;fixed as bugs, that it turns into a crude form of &quot;CRDT&quot; (where it&#x27;s not actually consistent, but merges within reason for 99% of use cases).<p>It might as well have been CRDT from the get go.</div><br/></div></div><div id="38291570" class="c"><input type="checkbox" id="c-38291570" checked=""/><div class="controls bullet"><span class="by">dsmmcken</span><span>|</span><a href="#38291507">parent</a><span>|</span><a href="#38292323">prev</a><span>|</span><a href="#38291630">next</a><span>|</span><label class="collapse" for="c-38291570">[-]</label><label class="expand" for="c-38291570">[4 more]</label></div><br/><div class="children"><div class="content">&gt; How long is the lock held?<p>For however long the user has a browser focus state on the element seems like a reasonable answer, and submit changes as they are made. However, I don&#x27;t know how you resolve conflicts of two users simultaneously attempting to acquire a lock.</div><br/><div id="38291986" class="c"><input type="checkbox" id="c-38291986" checked=""/><div class="controls bullet"><span class="by">filleokus</span><span>|</span><a href="#38291507">root</a><span>|</span><a href="#38291570">parent</a><span>|</span><a href="#38292314">next</a><span>|</span><label class="collapse" for="c-38291986">[-]</label><label class="expand" for="c-38291986">[1 more]</label></div><br/><div class="children"><div class="content">The server must keep track of the locks, and it can only know about the lock being released if the client tells it. E.g by sending a message that the field is not focused any more. The tricky thing is in the &quot;edge&quot; cases, or really the non-perfect cases, which there are plenty of (as I think GP described).<p>The server can decide that the client is offline if the server misses expected heartbeat messages from the client. But how often will those be sent and how long grace period will we allow? If it&#x27;s too short then it will be unreliable on shaky 4G connections, if it&#x27;s too long then it will be annoying in the other direction.<p>And that&#x27;s not considering the &quot;social&quot; problems with locks. I&#x27;ve worked on replacing a system that was lock-based with CRDTs where the lunch scenario from MontagFTB actually was a common occurrence.<p>In an &quot;ideal&quot; scenario your lock acquisition problem is not hard. Client&#x27;s just show the UI optimistically and whoever the server decide was first gets the lock. The loosing client throws any state the user created in the short time-frame. Over reliable and fast connections for granular locks, this works fine. But in the real world that&#x27;s just one of the issues with a lock based approach…</div><br/></div></div><div id="38292314" class="c"><input type="checkbox" id="c-38292314" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#38291507">root</a><span>|</span><a href="#38291570">parent</a><span>|</span><a href="#38291986">prev</a><span>|</span><a href="#38291910">next</a><span>|</span><label class="collapse" for="c-38292314">[-]</label><label class="expand" for="c-38292314">[1 more]</label></div><br/><div class="children"><div class="content">Having used an app with locks like this (Quip) I can tell you it really sucks to have a lock lease &gt;10s after the last edit. The “lock” should be a UI level concept anyways - clients should broadcast “hey I’m taking field X”; if you have two users submit a write+lock request concurrently you’ll need to pick a winner anyways.</div><br/></div></div><div id="38291910" class="c"><input type="checkbox" id="c-38291910" checked=""/><div class="controls bullet"><span class="by">Arelius</span><span>|</span><a href="#38291507">root</a><span>|</span><a href="#38291570">parent</a><span>|</span><a href="#38292314">prev</a><span>|</span><a href="#38291630">next</a><span>|</span><label class="collapse" for="c-38291910">[-]</label><label class="expand" for="c-38291910">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However, I don&#x27;t know how you resolve conflicts of two users simultaneously attempting to acquire a lock.<p>It turns out you just have to pick one... This all depends on a source of truth, and when you are there it&#x27;s easy to pick one, say based on whichever arrived at the network interface first.</div><br/></div></div></div></div></div></div><div id="38291630" class="c"><input type="checkbox" id="c-38291630" checked=""/><div class="controls bullet"><span class="by">charles_f</span><span>|</span><a href="#38291507">prev</a><span>|</span><a href="#38292653">next</a><span>|</span><label class="collapse" for="c-38291630">[-]</label><label class="expand" for="c-38291630">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true for collaborative experience. Crdts are a mechanism to handle eventual consistency (that&#x27;s even the preface of the paper). If you assume that said collaborative experience is always online, you don&#x27;t need them, and &quot;using locks&quot; as you described is probably enough.<p>If you want a mechanism to handle that eventual consistency, it&#x27;s probably better to reuse their principles rather than reinventing something that will eventually ressemble Crdts.<p>You mentioned &quot;offline first&quot;, I think it&#x27;s probably a good place to pluck that ib <a href="https:&#x2F;&#x2F;www.inkandswitch.com&#x2F;local-first&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.inkandswitch.com&#x2F;local-first&#x2F;</a></div><br/></div></div><div id="38292653" class="c"><input type="checkbox" id="c-38292653" checked=""/><div class="controls bullet"><span class="by">antidnan</span><span>|</span><a href="#38291630">prev</a><span>|</span><a href="#38292108">next</a><span>|</span><label class="collapse" for="c-38292653">[-]</label><label class="expand" for="c-38292653">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you need a pure CRDT either but I think locking and presence is a bit of an oversimplification.<p>LWW is a good place to start, and updating the smallest piece of information possible is the right idea in general but there is a lot more nuance to handling complex applications like a spreadsheet (I&#x27;m working on one) and whiteboard apps.<p>Things like reparenting or grouping shapes [1], or updating elements that aren&#x27;t at the lowest scale like deleting a row or column in a spreadsheet make locking challenging to implement. Do you lock the entire row while I&#x27;m moving it? Do you lock the entire group of shapes?<p>With the exception of text editing, the popular libraries like Yjs don&#x27;t just give you a perfect CRDT out of the box. You still have to construct your data model in a way that enables small scale updates [2], and CRDT libraries and literature are the best source of thinking for these problems that I&#x27;ve found.<p>[1] <a href="https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology-works&#x2F;#syncing-trees-of-objects" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology...</a><p>[2] <a href="https:&#x2F;&#x2F;mattweidner.com&#x2F;2022&#x2F;02&#x2F;10&#x2F;collaborative-data-design.html#case-study-a-collaborative-spreadsheet" rel="nofollow noreferrer">https:&#x2F;&#x2F;mattweidner.com&#x2F;2022&#x2F;02&#x2F;10&#x2F;collaborative-data-design...</a></div><br/></div></div><div id="38292108" class="c"><input type="checkbox" id="c-38292108" checked=""/><div class="controls bullet"><span class="by">saqadri</span><span>|</span><a href="#38292653">prev</a><span>|</span><a href="#38294099">next</a><span>|</span><label class="collapse" for="c-38292108">[-]</label><label class="expand" for="c-38292108">[1 more]</label></div><br/><div class="children"><div class="content">You may not need CRDT per-se, but building a collaborative experience is so difficult. I worked on collaborative systems for a bit, and also have read a bit about how Figma and Notion do it (this is a good read: <a href="https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology-works&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology...</a>) -- it&#x27;s still super hard to get right.<p>This talk by Karri about Linear&#x27;s &quot;sync engine&quot; is also a good watch: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Wo2m3jaJixU">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Wo2m3jaJixU</a>.</div><br/></div></div><div id="38294099" class="c"><input type="checkbox" id="c-38294099" checked=""/><div class="controls bullet"><span class="by">iamwil</span><span>|</span><a href="#38292108">prev</a><span>|</span><a href="#38294718">next</a><span>|</span><label class="collapse" for="c-38294099">[-]</label><label class="expand" for="c-38294099">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ever-growing state: for CRDTs to work well they need to keep a record of both what exists, and what has been deleted (so that the deletes aren’t accidentally added back in later). This means that CRDT state will continually expand.<p>I guess a couple things:<p>It depends on the CRDT. Some CRDTs grow with the number of replicas and others with the number of events.<p>State-based CRDTs don&#x27;t need to keep history and don&#x27;t need causal ordering of messages, but internal bookkeeping grows with the number of replicas. And for large states (like sets and maps), it can be prohibitive to send the state all over the wire for an idempotent merge.<p>That&#x27;s why in practice, people implement Op-based CRDTs, which makes the trade: in order to send small ops over the wire, we now need causal ordering of messages. To make sure we can sync with replicas long offline, we keep as much history so that they can catch up.<p>There are other variations, such as delta-state based CRDTs that send diffs, and merkle CRDTs, which use merkle data structures to calculate diffs and detect concurrency, which have different growth characteristics.<p>---<p>As for a growing state: Is this actually a concern for devs that aren&#x27;t using CRDTs for collaborative text? I can see that being an issue with the amount of changes that can happen.<p>But outside of that, lots of data don&#x27;t grow that fast. We all regularly use Git and it keeps a history of everything. Our disks are huge, and having an immutable record is great for lots of things (providing you can access it).<p>&gt; Opaque state: ...you’re generally left with an opaque blob of binary encoded data.<p>Most CRDT libraries take a document-orientated angle. It assumes that you can contain the entire &quot;unit of work&quot;, like a document, inside of a CRDT. However, if your data is more relational, it doesn&#x27;t quite fit. And while there&#x27;s immutable data in a CRDT, I do wish it was more accessible and queryable. In addition, being a binary blob, it&#x27;s not exactly composable. I think CRDT libraries should be composable with each other.</div><br/></div></div><div id="38294718" class="c"><input type="checkbox" id="c-38294718" checked=""/><div class="controls bullet"><span class="by">chromatin</span><span>|</span><a href="#38294099">prev</a><span>|</span><a href="#38293371">next</a><span>|</span><label class="collapse" for="c-38294718">[-]</label><label class="expand" for="c-38294718">[3 more]</label></div><br/><div class="children"><div class="content">We took a super simple (IMO) approach to collaborative editing in my current project:<p>Each block of text has a version number which must be incremented by one by the client at the time of submission. The database provides conflict prevention by uniqueness constraint which bubbles up to the API code. The frontend is informed of conflict, so that the user can be notified and let the human being perform conflict resolution.<p>Because most concurrent users are working on different blocks, this works great.</div><br/><div id="38295057" class="c"><input type="checkbox" id="c-38295057" checked=""/><div class="controls bullet"><span class="by">zknill</span><span>|</span><a href="#38294718">parent</a><span>|</span><a href="#38293371">next</a><span>|</span><label class="collapse" for="c-38295057">[-]</label><label class="expand" for="c-38295057">[2 more]</label></div><br/><div class="children"><div class="content">How do you handle getting the changes that one client makes onto the other clients? Are you pushing it from the server to the clients with websockets, or waiting for the clients to ask for new info, or waiting for the conflict to happen when someone else tries to make a change, or something else?<p>I&#x27;m thinking a lot about keeping server and client data in sync while working on our hopefully-soon-to-be-released LiveSync product[1]<p>[1] <a href="https:&#x2F;&#x2F;ably.com&#x2F;livesync" rel="nofollow noreferrer">https:&#x2F;&#x2F;ably.com&#x2F;livesync</a></div><br/><div id="38296603" class="c"><input type="checkbox" id="c-38296603" checked=""/><div class="controls bullet"><span class="by">chromatin</span><span>|</span><a href="#38294718">root</a><span>|</span><a href="#38295057">parent</a><span>|</span><a href="#38293371">next</a><span>|</span><label class="collapse" for="c-38296603">[-]</label><label class="expand" for="c-38296603">[1 more]</label></div><br/><div class="children"><div class="content">When the client gets HTTP 409 Conflict, it asks for the current version and presents to the user for manual resolution</div><br/></div></div></div></div></div></div><div id="38293371" class="c"><input type="checkbox" id="c-38293371" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#38294718">prev</a><span>|</span><a href="#38294041">next</a><span>|</span><label class="collapse" for="c-38293371">[-]</label><label class="expand" for="c-38293371">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen locks used at the CMSes of large news organizations. It&#x27;s fine, but they all need a mechanism to kick out an editor who has an idle tab left open. For my own small scale CMS, I just wrapped Google Docs and let them handle all the syncing headaches.</div><br/></div></div><div id="38294041" class="c"><input type="checkbox" id="c-38294041" checked=""/><div class="controls bullet"><span class="by">namelosw</span><span>|</span><a href="#38293371">prev</a><span>|</span><a href="#38298044">next</a><span>|</span><label class="collapse" for="c-38294041">[-]</label><label class="expand" for="c-38294041">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not gonna work for real-world projects. Real-world apps often have larger edits than locking individual cells&#x2F;cards e.g. Move columns or replace large chunks of spreadsheets in Google Sheets, or Ctrl-A to select all and then drag to move.<p>Also, if you consider latency, locking does not work well because client B might do operations before he&#x2F;she even acknowledges the lock from client A because of latency.</div><br/></div></div><div id="38298044" class="c"><input type="checkbox" id="c-38298044" checked=""/><div class="controls bullet"><span class="by">socketcluster</span><span>|</span><a href="#38294041">prev</a><span>|</span><a href="#38295732">next</a><span>|</span><label class="collapse" for="c-38298044">[-]</label><label class="expand" for="c-38298044">[1 more]</label></div><br/><div class="children"><div class="content">The no-code serverless platform I built achieves this behind the scenes via a real-time CRUD API: <a href="https:&#x2F;&#x2F;saasufy.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;saasufy.com&#x2F;</a><p>The key is to perform updates on fields individually. Normally this would not be viable using HTTP due to headers&#x2F;overheads (too many fields per resource to dedicate an entire HTTP request per-field) but it is viable over WebSockets as each frame is very lightweight and can even be batched. Also, being able to tie together the life of the connection to the subscription is handy to ensure that no real-time updates can be missed.<p>I built a chat app with authentication + access control with it (you can log in with GitHub at the bottom):<p><a href="https:&#x2F;&#x2F;saasufy.github.io&#x2F;chat-app&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;saasufy.github.io&#x2F;chat-app&#x2F;</a><p>Only 120 lines of HTML markup (web components), no custom JS.
See GitHub repo here for the &#x27;source&#x27;: <a href="https:&#x2F;&#x2F;github.com&#x2F;Saasufy&#x2F;chat-app">https:&#x2F;&#x2F;github.com&#x2F;Saasufy&#x2F;chat-app</a></div><br/></div></div><div id="38295732" class="c"><input type="checkbox" id="c-38295732" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38298044">prev</a><span>|</span><a href="#38297069">next</a><span>|</span><label class="collapse" for="c-38295732">[-]</label><label class="expand" for="c-38295732">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  You can’t inspect your model represented by the CRDT without using the CRDT library to decode the blob, and you can’t just store the underlying model state because the CRDT needs its change history also. You’re left with an opaque blob of data in your database. You can’t join on it, you can’t search it, you can’t do much without building extra features around that state blob.<p>So use the CRDT library when building your indices? Or better yet use a CRDT-aware datastore. This doesn&#x27;t seem like a real problem.<p>&gt; Locking for safety<p>Please don&#x27;t. You&#x27;re inevitably going to have lost locks, lost updates, or most likely both.</div><br/><div id="38296115" class="c"><input type="checkbox" id="c-38296115" checked=""/><div class="controls bullet"><span class="by">zknill</span><span>|</span><a href="#38295732">parent</a><span>|</span><a href="#38297069">next</a><span>|</span><label class="collapse" for="c-38296115">[-]</label><label class="expand" for="c-38296115">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So use the CRDT library when building your indices?<p>Yeah, sure, you can build a secondary index over the data. But you&#x27;re still having to decode the blob and index it. There&#x27;s no version where you can index the data without using the library to expose the underlying model state (like you could if you weren&#x27;t using a CRDT).<p>On locking, yes, it&#x27;s hard. But it&#x27;s not the same kind of locking that you&#x27;d expect in other parts of a system. You&#x27;re locking the UI, not the actual data, so it&#x27;s a tiny bit more forgiving. In general the locks aren&#x27;t trying to force consistency, instead they are trying to prompt the humans to reduce the chance of conflict happening in the first place. Ofc, you still have to care about the locking, unlocking, disconnection problems, etc.<p>Here&#x27;s a decent example&#x2F;demo you can play around with in multiple windows:<p><a href="https:&#x2F;&#x2F;examples.ably.dev&#x2F;component-locking?space=W0V-t5oY6AwbuukcJRl6Y" rel="nofollow noreferrer">https:&#x2F;&#x2F;examples.ably.dev&#x2F;component-locking?space=W0V-t5oY6A...</a><p><a href="https:&#x2F;&#x2F;ably.com&#x2F;spaces" rel="nofollow noreferrer">https:&#x2F;&#x2F;ably.com&#x2F;spaces</a></div><br/><div id="38297371" class="c"><input type="checkbox" id="c-38297371" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38295732">root</a><span>|</span><a href="#38296115">parent</a><span>|</span><a href="#38297069">next</a><span>|</span><label class="collapse" for="c-38297371">[-]</label><label class="expand" for="c-38297371">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yeah, sure, you can build a secondary index over the data. But you&#x27;re still having to decode the blob and index it. There&#x27;s no version where you can index the data without using the library to expose the underlying model state (like you could if you weren&#x27;t using a CRDT).<p>How&#x27;s that different from any other datastructure? You&#x27;re never indexing the raw underlying bytes and you wouldn&#x27;t want to. Like, sure, if you&#x27;re using a datastore where indexing is built in then you need to make sure that your datastore understands the datastructures you&#x27;re using, but that&#x27;s always a problem that you have. Most of the CRDT infrastructure I&#x27;ve seen has been designed around having a datastore that understands the CRDT and building on top of that.<p>&gt; On locking, yes, it&#x27;s hard. But it&#x27;s not the same kind of locking that you&#x27;d expect in other parts of a system. You&#x27;re locking the UI, not the actual data, so it&#x27;s a tiny bit more forgiving. In general the locks aren&#x27;t trying to force consistency, instead they are trying to prompt the humans to reduce the chance of conflict happening in the first place.<p>I don&#x27;t think that actually improves matters, it just means more edge cases? Either you have a locking system that&#x27;s 100% consistent and people can lock each other out and deadlock, or you don&#x27;t and you end up with lost updates that will be even more infuriating because the user checked whether anyone else was editing and it looked like they weren&#x27;t.</div><br/></div></div></div></div></div></div><div id="38297069" class="c"><input type="checkbox" id="c-38297069" checked=""/><div class="controls bullet"><span class="by">matlin</span><span>|</span><a href="#38295732">prev</a><span>|</span><a href="#38293952">next</a><span>|</span><label class="collapse" for="c-38297069">[-]</label><label class="expand" for="c-38297069">[1 more]</label></div><br/><div class="children"><div class="content">I think the most important part of designing collaborative software, which this touches on a bit, is having a the right granularity and scope of a given change.<p>Last-writer-wins is only bad when the granularity of what you&#x27;re editing is too big. E.g. if you&#x27;re an editor like Figma and each element is a row in a database, a single row is too big. Instead you want attribute level granularity so two users can change the independent properties (like one color and the other size) without bulldozing each other.<p>The other key thing (that&#x27;s also a common mistake) is to only consider <i>realtime</i> collaboration. In practice, there&#x27;s always some delay (maybe just milliseconds but could be be hours or days) in how events propagate so solutions like locking don&#x27;t work.<p>The reality is that any client-server system that needs to be highly interactive and robust to unreliable network conditions is undeniably a distributed system and therefore warrants using distributed system solutions like vector clocks, Lamport timestamps, CRDTs, etc.<p>Last thing is that I think many people only think of operation-based CRDTs when they think about CRDTs. You can (and we have at my company) created a fairly traditional feeling database that relies on a state-based CRDT solution that doesn&#x27;t need to maintain a log of every operation that has every happened.<p>So yes, you might not need to reach for a fancy library like Yjs or Automerge, but it&#x27;s worth understanding how these things thinks basically work because many of them are extremely simple and easy to grok - the complicated parts of Yjs and Automerge are the sophisticated data-structures and algorithms  that are pretty much only needed for large document text editing.</div><br/></div></div><div id="38293952" class="c"><input type="checkbox" id="c-38293952" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#38297069">prev</a><span>|</span><a href="#38296024">next</a><span>|</span><label class="collapse" for="c-38293952">[-]</label><label class="expand" for="c-38293952">[1 more]</label></div><br/><div class="children"><div class="content">For offline first apps, or for applications where very high degree of control for the content is needed (e.g. legal docs) and realtime collaboration isn&#x27;t that valuable, there is also the option to use 3-way merge instead.<p>The benefit is that you can even allow the user to resolve conflicts in a satisfactory way.<p>Another benefit is that the document doesn&#x27;t even have to be derived from the original, it could go through exports and re-imports and it will still be possible to run a 3-way merge as long as a common base version is declared. This can be especially covnenient for systems that involve e.g. MS Word.</div><br/></div></div><div id="38296024" class="c"><input type="checkbox" id="c-38296024" checked=""/><div class="controls bullet"><span class="by">aboodman</span><span>|</span><a href="#38293952">prev</a><span>|</span><a href="#38294763">next</a><span>|</span><label class="collapse" for="c-38296024">[-]</label><label class="expand" for="c-38296024">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s true that a CRDT is often not the right thing for a classic client&#x2F;server application. But this doesn&#x27;t mean we should just give up on ux and use locking.<p>There are approaches to multiplayer that are client&#x2F;server native. By leveraging the authoritative server they can offer features that CRDTs can&#x27;t, while preserving the great ux.<p>I&#x27;m partial to server reconciliation:<p><a href="https:&#x2F;&#x2F;www.gabrielgambetta.com&#x2F;client-side-prediction-server-reconciliation.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.gabrielgambetta.com&#x2F;client-side-prediction-serve...</a><p>My product, Reflect, implements server reconciliation as a service. You can learn more about how it works here:<p><a href="https:&#x2F;&#x2F;rocicorp.dev&#x2F;blog&#x2F;ready-player-two" rel="nofollow noreferrer">https:&#x2F;&#x2F;rocicorp.dev&#x2F;blog&#x2F;ready-player-two</a></div><br/><div id="38296354" class="c"><input type="checkbox" id="c-38296354" checked=""/><div class="controls bullet"><span class="by">zknill</span><span>|</span><a href="#38296024">parent</a><span>|</span><a href="#38294763">next</a><span>|</span><label class="collapse" for="c-38296354">[-]</label><label class="expand" for="c-38296354">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But this doesn&#x27;t mean we should just give up on ux<p>It&#x27;s a little unfair to describe locking as &quot;[giving] up on UX&quot;, especially given some well known collaboration products use it quite successfully; Google Sheets cell locking, Miro element&#x2F;Text locking, etc.<p>Ofc, it&#x27;s going to depend on the scope of what&#x27;s being locked. These two examples are quite finely scoped element locks.</div><br/></div></div></div></div><div id="38294763" class="c"><input type="checkbox" id="c-38294763" checked=""/><div class="controls bullet"><span class="by">maclockard</span><span>|</span><a href="#38296024">prev</a><span>|</span><a href="#38295909">next</a><span>|</span><label class="collapse" for="c-38294763">[-]</label><label class="expand" for="c-38294763">[1 more]</label></div><br/><div class="children"><div class="content">Wrote about something similar a while ago <a href="https:&#x2F;&#x2F;hex.tech&#x2F;blog&#x2F;a-pragmatic-approach-to-live-collaboration&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hex.tech&#x2F;blog&#x2F;a-pragmatic-approach-to-live-collabora...</a><p>Using a server to tie break and locking has worked pretty well for us</div><br/></div></div><div id="38295909" class="c"><input type="checkbox" id="c-38295909" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#38294763">prev</a><span>|</span><a href="#38295086">next</a><span>|</span><label class="collapse" for="c-38295909">[-]</label><label class="expand" for="c-38295909">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’ll run through a bunch of broad categories of applications, and describe how to make use of these features.<p>i love these kinds of taxonomies of apps, because then you can get specific about tech stack choices. just offering a couple more that i&#x27;ve come across in my years:<p>- more prototypical: 7GUIs <a href="https:&#x2F;&#x2F;eugenkiss.github.io&#x2F;7guis&#x2F;tasks" rel="nofollow noreferrer">https:&#x2F;&#x2F;eugenkiss.github.io&#x2F;7guis&#x2F;tasks</a><p>- Application holotypes: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;arthurwuhoo&#x2F;status&#x2F;1470489178186170374" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;arthurwuhoo&#x2F;status&#x2F;1470489178186170374</a></div><br/></div></div><div id="38295086" class="c"><input type="checkbox" id="c-38295086" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#38295909">prev</a><span>|</span><a href="#38296240">next</a><span>|</span><label class="collapse" for="c-38295086">[-]</label><label class="expand" for="c-38295086">[1 more]</label></div><br/><div class="children"><div class="content">At this point, given the maturity of libraries (I was exploring this recently), I think you&#x27;d have to make the case that CRDTs are bad not just &quot;too much&quot;.<p>Interfacing with the &#x27;blob&#x27; is a real thing (y-js is solving some of this with a rust implementation that has cross language binding) but generally the things they noted (e.g. a Figma canvas) aren&#x27;t things you commonly do joins across and if you did you&#x27;d have an independent indexing store for that functionality.<p>With tools like SyncedStore [1] and HocusPocus [2] you end up with a pretty good, we&#x27;ll tested, easy to implement base for good collaboration.<p>[1] syncedstore.org<p>[2] github.com&#x2F;ueberdosis&#x2F;hocuspocus</div><br/></div></div><div id="38296240" class="c"><input type="checkbox" id="c-38296240" checked=""/><div class="controls bullet"><span class="by">speps</span><span>|</span><a href="#38295086">prev</a><span>|</span><a href="#38291795">next</a><span>|</span><label class="collapse" for="c-38296240">[-]</label><label class="expand" for="c-38296240">[1 more]</label></div><br/><div class="children"><div class="content">The Wikipedia page for Operational Transformation [1] mentions Differential Synchronization [2] as an alternative, does anyone have any experience with DS?<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Operational_transformation" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Operational_transformation</a>
[2] <a href="https:&#x2F;&#x2F;neil.fraser.name&#x2F;writing&#x2F;sync&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;neil.fraser.name&#x2F;writing&#x2F;sync&#x2F;</a></div><br/></div></div><div id="38291795" class="c"><input type="checkbox" id="c-38291795" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38296240">prev</a><span>|</span><a href="#38293832">next</a><span>|</span><label class="collapse" for="c-38291795">[-]</label><label class="expand" for="c-38291795">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ever-growing state: for CRDTs to work well they need to keep a record of both what exists, and what has been deleted (so that the deletes aren’t accidentally added back in later). This means that CRDT state will continually expand. There’s a bunch of magic that CRDT library authors are doing with clever compression techniques to make this problem less-bad, but it’s basically in-escapable. The size of your CRDT state is not purely a function of the size of the state the CRDT represents, but also of the number of updates that state has gone through.<p>A) This is only the case for certain CRDTs, such as sets that support deletion - so, if you want Set semantics with deletion support, you need two sets, one to that tracks all deletions and one that tracks all insertions.<p>B) You can garbage collection your sets. They don&#x27;t have to grow forever.<p>&gt; Complex implementations: CRDTs are easy to implement wrong, so probably don’t roll your own.<p>Personally, I&#x27;ve never done this. I&#x27;ve just added a `merge(&amp;mut self, other: &amp;Self)` method to structs in Rust. Guaranteeing CRDT properties is often trivial, or at least it was in my case.<p>&gt; Opaque state: Because the CRDT has to represent both the underlying state and the updates that led to that state<p>Again, this is only if you need specific operations on your CRDTs <i>and</i> if your CRDTs are encoded in specific ways.<p>I&#x27;ve said it before, but a trivial crdt looks like this<p><pre><code>    struct Grows(u64);

    impl Grows {
        fn merge(&amp;mut self, other: &amp;Self) {
            self.0 = max(self.0, other.0);
        }
    }
</code></pre>
et voila? Obviously you lose all intermediary states, but since that is specified to be a negative thing, I just want to be clear that it&#x27;s often optional.<p>&gt; So maybe you are convinced that CRDTs are not the be-all-and-end-all of collaboration, and that you aren’t in one of the two categories where you probably should use a CRDT, and you’ve made it this far in the post.<p>I am convinced that CRDTs are not the be-all-and-end-all, because Strong Eventual Consistency does not provide strong enough guarantees for all use cases.<p>Once again we have a CRDT article that&#x27;s about user collaboration, which I find somewhat frustrating because CRDTs can be used in far more places than that, and user collaboration is like <i>the</i> most complicated thing you could ever write since it&#x27;s all of the problems of a distributed system <i>and then we add humans into the mix</i>. There is no &quot;good&quot; solution to this problem - CRDTs aren&#x27;t going to solve it, and neither is any other algorithm, because it&#x27;s not possible to encode every possible state update in a way that never conflicts and is also what a human expects (especially since humans have varying expectations).<p>The algorithm&#x2F; approach, as described, seems perfectly fine - it will have edge cases just like CRDTs will. In reality, for such an impossibly complex problem, you&#x27;re probably going to end up with something really complex to solve it. You&#x27;re almost certainly going to start adding CRDT-like operations, like &quot;ok technically this user held a lock on X, but the other user performed an operation on X that technically commutes, so we can allow both&quot; to alleviate some of the inherent complexities (and UX issues) with locking.</div><br/></div></div><div id="38293832" class="c"><input type="checkbox" id="c-38293832" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#38291795">prev</a><span>|</span><a href="#38293566">next</a><span>|</span><label class="collapse" for="c-38293832">[-]</label><label class="expand" for="c-38293832">[3 more]</label></div><br/><div class="children"><div class="content">CRDT is a different paradigm. Ideally we&#x27;d use it to <i>replace</i> client-server</div><br/><div id="38295703" class="c"><input type="checkbox" id="c-38295703" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#38293832">parent</a><span>|</span><a href="#38294133">next</a><span>|</span><label class="collapse" for="c-38295703">[-]</label><label class="expand" for="c-38295703">[1 more]</label></div><br/><div class="children"><div class="content">And wrangling CRDTs into a client-server architecture is actually extra work. The basic design assumes you can trust every peer -- making sure that jes5199 actually was the peer who added a comment that is marked as author: &quot;jes5199&quot; is not trivial.</div><br/></div></div><div id="38294133" class="c"><input type="checkbox" id="c-38294133" checked=""/><div class="controls bullet"><span class="by">iamwil</span><span>|</span><a href="#38293832">parent</a><span>|</span><a href="#38295703">prev</a><span>|</span><a href="#38293566">next</a><span>|</span><label class="collapse" for="c-38294133">[-]</label><label class="expand" for="c-38294133">[1 more]</label></div><br/><div class="children"><div class="content">I think we can. Following all the implications down the rabbit hole, you end up with a system architecture where there&#x27;s no front-end, and there&#x27;s no back-end.<p>Since CRDTs are still kinda new for most people, the discussion hasn&#x27;t really gotten there yet.</div><br/></div></div></div></div><div id="38293566" class="c"><input type="checkbox" id="c-38293566" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#38293832">prev</a><span>|</span><a href="#38298071">next</a><span>|</span><label class="collapse" for="c-38293566">[-]</label><label class="expand" for="c-38293566">[2 more]</label></div><br/><div class="children"><div class="content">Conflict-Free Replicated Data Type (CRDT) is a type of data structure that enables concurrent updates across multiple replicas without the need for coordination between them.</div><br/><div id="38299474" class="c"><input type="checkbox" id="c-38299474" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#38293566">parent</a><span>|</span><a href="#38298071">next</a><span>|</span><label class="collapse" for="c-38299474">[-]</label><label class="expand" for="c-38299474">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I was scanning the replies looking for this since the author of TFA didn&#x27;t. Note for writers: spell out acronyms on first use.</div><br/></div></div></div></div><div id="38298071" class="c"><input type="checkbox" id="c-38298071" checked=""/><div class="controls bullet"><span class="by">shove</span><span>|</span><a href="#38293566">prev</a><span>|</span><label class="collapse" for="c-38298071">[-]</label><label class="expand" for="c-38298071">[1 more]</label></div><br/><div class="children"><div class="content">As someone on the UX team for a product that just uses locks: LOL. Ok, but the suck index is pretty high.</div><br/></div></div></div></div></div></div></div></body></html>