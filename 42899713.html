<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738486854908" as="style"/><link rel="stylesheet" href="styles.css?v=1738486854908"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/kspalaiologos/bzip3">Bzip3: A spiritual successor to BZip2</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>tosh</span> | <span>145 comments</span></div><br/><div><div id="42907286" class="c"><input type="checkbox" id="c-42907286" checked=""/><div class="controls bullet"><span class="by">thomasmg</span><span>|</span><a href="#42900094">next</a><span>|</span><label class="collapse" for="c-42907286">[-]</label><label class="expand" for="c-42907286">[1 more]</label></div><br/><div class="children"><div class="content">Improving BWT is great!<p>In my view, improving &quot;long range&quot; compression has the biggest potential. There are many, many algorithms and implementations for very short range (huffman, arithmetic, ANS) and short range (LZ, BWT), but not that much research has gone into &quot;long range&quot; yet. There&#x27;s deduplication, and large-window LZ &#x2F; BWT.. but not much more yet. What is missing is efficietly (and with little memory) finding similarities on multi-GB data sets. I think sorting by similarity would help there. Or did I miss research in this area?</div><br/></div></div><div id="42900094" class="c"><input type="checkbox" id="c-42900094" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#42907286">prev</a><span>|</span><a href="#42900071">next</a><span>|</span><label class="collapse" for="c-42900094">[-]</label><label class="expand" for="c-42900094">[30 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve studied the Burrows-Wheeler Transform, I understand the transformation, I&#x27;ve re-implemented it countless times for kicks, I see how it improves compressability, but for the life of me the intuition of _why_ it works has never really clicked.<p>It&#x27;s a fantastic bit of algorithmic magic that will always impress me to see it.</div><br/><div id="42901081" class="c"><input type="checkbox" id="c-42901081" checked=""/><div class="controls bullet"><span class="by">unnah</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42901386">next</a><span>|</span><label class="collapse" for="c-42901081">[-]</label><label class="expand" for="c-42901081">[8 more]</label></div><br/><div class="children"><div class="content">The Burroughs-Wheeler transform has been described as a unique algorithm idea in that there are no non-trivial variations or related algorithms, unlike more conventional compression algorithms, which can be tweaked and improved in so many ways. There is no general compression theory in which BWT could be described as a special case.<p>It looks to me that the above still holds: Bzip2 and Bzip3 are simply combining more conventional compression algorithms with the BWT, which itself is still the same old transform. Bzip2 does Huffman coding after BWT, and Bzip3 does arithmetic coding.</div><br/><div id="42906326" class="c"><input type="checkbox" id="c-42906326" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901081">parent</a><span>|</span><a href="#42905919">next</a><span>|</span><label class="collapse" for="c-42906326">[-]</label><label class="expand" for="c-42906326">[1 more]</label></div><br/><div class="children"><div class="content">It definitely is related to prediction by partial match (PPM).<p>BWT sorts rotated data and what is achieved is that same suffixes group together:<p><pre><code>  ...
  &quot;Bzip2 and Bzip3 are simply combining more&quot;
  &quot;Bzip3 are simply combining moreBzip2 and &quot;
</code></pre>
The preceding (to suffix) character goes to end and then gets outputted. This is much like PPM going backward. There is a PPM* algorithm (unbounded context length) where authors considered reconstruction of contexts from data, utilizing something like LZSS seach. Same idea is in BWT - context is reconstructed from data.<p>BWT also breaks near dependencies in data, this is why move-to-front with Huffman or arithmetic encoding works well there.</div><br/></div></div><div id="42905919" class="c"><input type="checkbox" id="c-42905919" checked=""/><div class="controls bullet"><span class="by">derf_</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901081">parent</a><span>|</span><a href="#42906326">prev</a><span>|</span><a href="#42901376">next</a><span>|</span><label class="collapse" for="c-42905919">[-]</label><label class="expand" for="c-42905919">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; There is no general compression theory in which BWT could be described as a special case.</i><p>I would not really say this is true. BWT is spiritually similar to the various Prediction by Partial Matching (PPM) algorithms, except that instead of needing to decide how much context (i.e., preceding symbols) to use to model the next symbol, and carefully learning the probabilities for each unique context, it naturally sorts symbols with the same context (of _any_ length) so they appear next to each other, and relies on adaptation to update your learned statistics as you move from one context to the next, without ever explicitly tracking context boundaries [0].<p>[0] N.J. Larsson, &quot;The Context Trees of Block Sorting Compression,&quot; 1998. <a href="https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;abstract&#x2F;document&#x2F;672147" rel="nofollow">https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;abstract&#x2F;document&#x2F;672147</a></div><br/></div></div><div id="42901376" class="c"><input type="checkbox" id="c-42901376" checked=""/><div class="controls bullet"><span class="by">altairprime</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901081">parent</a><span>|</span><a href="#42905919">prev</a><span>|</span><a href="#42901386">next</a><span>|</span><label class="collapse" for="c-42901376">[-]</label><label class="expand" for="c-42901376">[5 more]</label></div><br/><div class="children"><div class="content">Can BWT be combined with zstd, which uses asymmetric numeral systems?</div><br/><div id="42902126" class="c"><input type="checkbox" id="c-42902126" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901376">parent</a><span>|</span><a href="#42904634">next</a><span>|</span><label class="collapse" for="c-42902126">[-]</label><label class="expand" for="c-42902126">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it would actually be interesting to just have a bwt pass which does no compression, so we can then try lots of post compression options.</div><br/><div id="42905987" class="c"><input type="checkbox" id="c-42905987" checked=""/><div class="controls bullet"><span class="by">rkeene2</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42902126">parent</a><span>|</span><a href="#42904634">next</a><span>|</span><label class="collapse" for="c-42905987">[-]</label><label class="expand" for="c-42905987">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been thinking about adding support for this kind of stacking to DACT [0].<p>[0] <a href="http:&#x2F;&#x2F;dact.rkeene.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;dact.rkeene.org&#x2F;</a></div><br/></div></div></div></div><div id="42904634" class="c"><input type="checkbox" id="c-42904634" checked=""/><div class="controls bullet"><span class="by">gopalv</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901376">parent</a><span>|</span><a href="#42902126">prev</a><span>|</span><a href="#42905567">next</a><span>|</span><label class="collapse" for="c-42904634">[-]</label><label class="expand" for="c-42904634">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  BWT be combined with zstd<p>BWT can be combined with anything which does RLE and get a benefit.<p>What does it does is give RLE more to work with.</div><br/></div></div><div id="42905567" class="c"><input type="checkbox" id="c-42905567" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901376">parent</a><span>|</span><a href="#42904634">prev</a><span>|</span><a href="#42901386">next</a><span>|</span><label class="collapse" for="c-42905567">[-]</label><label class="expand" for="c-42905567">[1 more]</label></div><br/><div class="children"><div class="content">I think you would just need ANS, not the rest of zstd.</div><br/></div></div></div></div></div></div><div id="42901386" class="c"><input type="checkbox" id="c-42901386" checked=""/><div class="controls bullet"><span class="by">thrtythreeforty</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42901081">prev</a><span>|</span><a href="#42901725">next</a><span>|</span><label class="collapse" for="c-42901386">[-]</label><label class="expand" for="c-42901386">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the reference. I learned something new today. That algorithm is wild. If you had shown me the transform and asked if it had an inverse, I would have said of course it doesn&#x27;t, it&#x27;s too weird.</div><br/></div></div><div id="42901725" class="c"><input type="checkbox" id="c-42901725" checked=""/><div class="controls bullet"><span class="by">loxias</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42901386">prev</a><span>|</span><a href="#42900711">next</a><span>|</span><label class="collapse" for="c-42901725">[-]</label><label class="expand" for="c-42901725">[9 more]</label></div><br/><div class="children"><div class="content">I always understood it as working because of the predictability of a symbol&#x2F;letter&#x2F;token given the previous one.<p>Sorting all the shifts of a string puts all the characters in order, then looking at the last column shows you all the _preceding_ characters.  If there&#x27;s any predictability there (which there often is), it&#x27;s now easier to compress.  It&#x27;s sorta like an entropy coder in that way.<p>I&#x27;ve never thought of it as being that deep, and understood them since I was a kid -- building an intuition for &quot;why&quot; the FFT works is much harder -- but that being said, I clicked quickly to reply thinking &quot;that&#x27;s easy! I can explain this!&quot; then struggled for a while trying to get the picture in my mind into text. :)</div><br/><div id="42901782" class="c"><input type="checkbox" id="c-42901782" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901725">parent</a><span>|</span><a href="#42903370">next</a><span>|</span><label class="collapse" for="c-42901782">[-]</label><label class="expand" for="c-42901782">[5 more]</label></div><br/><div class="children"><div class="content">But shouldn&#x27;t Huffman coding already detect that same predictability and compress it the same?<p>What I don&#x27;t get isn&#x27;t the benefits of BWT on its own. It&#x27;s why BWT should add any additional benefit if you&#x27;re already doing Huffman.</div><br/><div id="42901935" class="c"><input type="checkbox" id="c-42901935" checked=""/><div class="controls bullet"><span class="by">loxias</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901782">parent</a><span>|</span><a href="#42902437">next</a><span>|</span><label class="collapse" for="c-42901935">[-]</label><label class="expand" for="c-42901935">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What I don&#x27;t get isn&#x27;t the benefits of BWT on its own. It&#x27;s why BWT should add any additional benefit if you&#x27;re already doing Huffman.<p>Ahhhh.  Now we&#x27;re on the same page. :) Seeing how it helps when combined is somewhat subtle&#x2F;non-obvious.  I believe it relates to BWT and Huffman both being approximations of something more optimal.  The two transforms could also have different window sizes -- one rarely does BWT on a whole 1GB file -- which introduce inefficiencies.  Huffman coding is also only optimal in the very large alphabet and very long data limits.  As your data length and alphabet size decrease, it gets less optimal.<p>Put differently, &quot;I think that&#x27;s a wonderfully phrased question, this _is_ my specialization&#x2F;subfield, and I&#x27;m gonna need to chew on it for a while.&quot;</div><br/><div id="42902066" class="c"><input type="checkbox" id="c-42902066" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901935">parent</a><span>|</span><a href="#42902437">next</a><span>|</span><label class="collapse" for="c-42902066">[-]</label><label class="expand" for="c-42902066">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. Yeah, I can see how that would make more sense if BWT was redundant under a theoretically perfect Huffman compression, but it happens to pick up some things that real-world Huffman encoders don&#x27;t, with their practical limits on CPU and memory.</div><br/></div></div></div></div><div id="42902437" class="c"><input type="checkbox" id="c-42902437" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901782">parent</a><span>|</span><a href="#42901935">prev</a><span>|</span><a href="#42902407">next</a><span>|</span><label class="collapse" for="c-42902437">[-]</label><label class="expand" for="c-42902437">[1 more]</label></div><br/><div class="children"><div class="content">One way to look at data compression is splitting it into a model and an encoder. The model describes the data, while the encoder encodes (or equivalently predicts) the data according to the model. The compressed output consists of the serialized model and the encoded data. BWT is a model, while Huffman is an encoder.<p>Huffman takes a probability distribution and a symbol and encodes the symbol according to the distribution. If you encode all symbols independently according to the same distribution, you probably don&#x27;t get very good compression.<p>You get a bit better results with a model that has a separate distribution for each context. If the previous symbols were X, Y, and Z, you encode the next symbol according to the distribution for context XYZ. This approach doesn&#x27;t really scale, because the size of the model grows rapidly (exponentially in a naive implementation) with context length. You get better compression with an adaptive model. You start with a uniform distribution and update the available contexts and distributions after encoding each symbol. On the one hand, you don&#x27;t have to store the model explicitly. But on the other hand, updating the model is very slow.<p>Burrows-Wheeler transform is an implicit model. It sorts the symbols according to the context that follows them, and it does that simultaneously for each context length. Because you don&#x27;t have to store the model explicitly, you can effectively use longer context lengths than with a fixed explicit model. And because you don&#x27;t have to update an explicit model after encoding each symbol, using the BWT is much faster than using an adaptive model.</div><br/></div></div><div id="42902407" class="c"><input type="checkbox" id="c-42902407" checked=""/><div class="controls bullet"><span class="by">palaiologos</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901782">parent</a><span>|</span><a href="#42902437">prev</a><span>|</span><a href="#42903370">next</a><span>|</span><label class="collapse" for="c-42902407">[-]</label><label class="expand" for="c-42902407">[1 more]</label></div><br/><div class="children"><div class="content">Hi, tool author here.<p>Huffman coding is a static minimum-redundancy code. What this means is that it finds an optimal assignment of bit sequences to letters in the input alphabet (commonly US-ASCII or extensions). This however means that Huffman coding can not exploit redundancies that stem from the concrete sequence of characters. For example, you could easily predict that an `e` comes after `Th`, but Huffman coding can not know that.<p>Hence after applying the Burrows-Wheeler transform you need to have some sort of a higher-order transform (i.e. a transform that considers more than just individual bytes) which somehow reaps from the changed distribution of the result of the algorithm. But we will get to that in a second.<p>The joke here is that the Burrows-Wheeler transform is closely related to suffix trees and suffix arrays, which are often used in bioinformatics and HPC for full-text search. If you wanted to find a pattern of length `p` in a text of length `n`, if you already have a suffix tree of the original text, the search is linear in the length &#x2F;of the pattern&#x2F; - i.e. O(p). The suffix tree stores all suffixes of a string in a compressed manner (i.e. it has a linear space overhead, approximately O(20n) as given by Gusfield, D. (1997). Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology. Cambridge University Press), so you can search for a word in it by simply traversing from the root node to an internal or leaf node by following a sequence of bytes that comprise the word.<p>As such, a suffix tree (and equivalently suffix array and the BWT, which is trivially computed from a suffix array) form something which can be thought of as a static PPM model. Notably real world implementations of PPM use suffix trees as a part of their main storage data structure (e.g. PPMd). What this all means is that given a suffix tree, we can very cheaply give the probability distribution for the next byte that follows a given fixed-order sequence of bytes. This is nice, because then e.g. an order-2 predictor would be able to tell that `Th` is followed by `e` once enough data has been gathered.<p>As you can probably guess, the more preceding bytes you know, the better will be your estimate for what is the most likely next byte. But the larger your context, the more expensive the searches and computations become due to pointer chasing in the suffix tree.<p>So how do we remedy this? We notice that the Burrows-Wheeler transform essentially clusters similar contexts together, meaning that a low order predictor (= faster, simpler) on BWT compresses as well as a high order predictor (= slow, complicated) on the original data, at the cost of an extra transformation. This is viable, because the Burrows-Wheeler transform can be quickly computed and there have been recent advancements in running it on the GPU. So what this means is that bzip3 uses BWT + a low order predictor with an arithmetic coder to encode the bytes, meaning that it can make use of high order statistics for compression and performs comparably at a faster speed.</div><br/></div></div></div></div><div id="42903370" class="c"><input type="checkbox" id="c-42903370" checked=""/><div class="controls bullet"><span class="by">vanviegen</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901725">parent</a><span>|</span><a href="#42901782">prev</a><span>|</span><a href="#42900711">next</a><span>|</span><label class="collapse" for="c-42903370">[-]</label><label class="expand" for="c-42903370">[3 more]</label></div><br/><div class="children"><div class="content">Understanding why increasing predictability helps with compression is not the hard part though. What&#x27;s hard to grasp is why the transform is reversible.</div><br/><div id="42903905" class="c"><input type="checkbox" id="c-42903905" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42903370">parent</a><span>|</span><a href="#42900711">next</a><span>|</span><label class="collapse" for="c-42903905">[-]</label><label class="expand" for="c-42903905">[2 more]</label></div><br/><div class="children"><div class="content">a word can be factored into the set and frequency of letters + the specific permutation. compressable patterns in either channel seem likely when the underlying words are language like.</div><br/><div id="42904025" class="c"><input type="checkbox" id="c-42904025" checked=""/><div class="controls bullet"><span class="by">SideQuark</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42903905">parent</a><span>|</span><a href="#42900711">next</a><span>|</span><label class="collapse" for="c-42904025">[-]</label><label class="expand" for="c-42904025">[1 more]</label></div><br/><div class="children"><div class="content">And in general that set of descriptors provides no compressibility. BWT is much richer that that set in that the way it works performs well for data we care about.<p>Describing a multiset takes as much information as the multiset contained to begin with, on average. BWT somehow works better on things of use.</div><br/></div></div></div></div></div></div></div></div><div id="42900711" class="c"><input type="checkbox" id="c-42900711" checked=""/><div class="controls bullet"><span class="by">mnw21cam</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42901725">prev</a><span>|</span><a href="#42904688">next</a><span>|</span><label class="collapse" for="c-42900711">[-]</label><label class="expand" for="c-42900711">[2 more]</label></div><br/><div class="children"><div class="content">I remember the lecturer commenting on what sort of sick and twisted mind could come up with such a ridiculous convoluted notion when I was taught it at university.</div><br/><div id="42906800" class="c"><input type="checkbox" id="c-42906800" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42900711">parent</a><span>|</span><a href="#42904688">next</a><span>|</span><label class="collapse" for="c-42906800">[-]</label><label class="expand" for="c-42906800">[1 more]</label></div><br/><div class="children"><div class="content">Wheeler was also one of the inventors of the &quot;closed subroutine&quot; AKA function, which had to be implemented via a hack as machines of the time did not include ISA support for &quot;return&quot;:<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Wheeler_Jump" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Wheeler_Jump</a></div><br/></div></div></div></div><div id="42904688" class="c"><input type="checkbox" id="c-42904688" checked=""/><div class="controls bullet"><span class="by">abetusk</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42900711">prev</a><span>|</span><a href="#42903579">next</a><span>|</span><label class="collapse" for="c-42904688">[-]</label><label class="expand" for="c-42904688">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it basically run length encoding but on patterns? Sorting lexicographical on all rotations means blocks of patterns get grouped together, which means you can do compression more easily, right?</div><br/></div></div><div id="42903579" class="c"><input type="checkbox" id="c-42903579" checked=""/><div class="controls bullet"><span class="by">BlackLotus89</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42904688">prev</a><span>|</span><a href="#42903926">next</a><span>|</span><label class="collapse" for="c-42903579">[-]</label><label class="expand" for="c-42903579">[1 more]</label></div><br/><div class="children"><div class="content">I really liked the computerphile video about it <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=GYbCttCF25A" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=GYbCttCF25A</a></div><br/></div></div><div id="42903926" class="c"><input type="checkbox" id="c-42903926" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42903579">prev</a><span>|</span><a href="#42901513">next</a><span>|</span><label class="collapse" for="c-42903926">[-]</label><label class="expand" for="c-42903926">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the intuition of _why_ it works has never really clicked.<p>In terms of why it aids compression, or why it&#x27;s reversible?<p>As far as the first goes: it transforms n-grams into repeated characters.</div><br/></div></div><div id="42901513" class="c"><input type="checkbox" id="c-42901513" checked=""/><div class="controls bullet"><span class="by">forty</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42903926">prev</a><span>|</span><a href="#42900687">next</a><span>|</span><label class="collapse" for="c-42901513">[-]</label><label class="expand" for="c-42901513">[1 more]</label></div><br/><div class="children"><div class="content">Haha I also studied as part of a student project and I remember my computer science teacher saying &quot;it&#x27;s dark magic&quot; ^^</div><br/></div></div><div id="42901775" class="c"><input type="checkbox" id="c-42901775" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42900094">parent</a><span>|</span><a href="#42900687">prev</a><span>|</span><a href="#42900071">next</a><span>|</span><label class="collapse" for="c-42901775">[-]</label><label class="expand" for="c-42901775">[4 more]</label></div><br/><div class="children"><div class="content">Yeah. BWT and zero knowledge proofs are my goto examples of CS things that seem like pure magic.</div><br/><div id="42903688" class="c"><input type="checkbox" id="c-42903688" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42901775">parent</a><span>|</span><a href="#42900071">next</a><span>|</span><label class="collapse" for="c-42903688">[-]</label><label class="expand" for="c-42903688">[3 more]</label></div><br/><div class="children"><div class="content">Public-key cryptography is magic. Zero-knowledge proofs are a consequence that&#x27;s difficult to find on your own but easy to understand once you&#x27;ve seen it.<p>I remember seeing someone (probably Avi Wigderson) demonstrating a zero-knowledge proof for graph coloring on an overhead projector when I was starting my second year studying CS. He had a slide with a graph, multiple slides with different permutations of the same valid coloring of the vertices, and a piece of paper with &quot;doors&quot; over the vertices to cover everything. The audience could ask him to open the doors over the vertices connected by any edge, and he would show that the coloring is valid, as far as those two vertices are concerned. And then he would replace the coloring with another permutation for the next iteration. The idea felt clever but kind of obvious in retrospect.</div><br/><div id="42904529" class="c"><input type="checkbox" id="c-42904529" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42903688">parent</a><span>|</span><a href="#42900071">next</a><span>|</span><label class="collapse" for="c-42904529">[-]</label><label class="expand" for="c-42904529">[2 more]</label></div><br/><div class="children"><div class="content">Magical things are usually built up from the trivial examples.<p>Graph colouring is usually used as a teaching example for zkp, because of how easy it is to understand. Its still amazing how you can go from that example to &quot;Here is a file that anyone can verify (non-interactively) which shows i have a passport and that passport is not from a country sanctioned by the usa but otherwise does not reveal anything about me&quot; or &quot;I will not reveal my ip or any other identifying&#x2F;unique info but i will prove i have not been previously blocked from this website including during the other times i anonoymously accessed this website&quot;</div><br/><div id="42904996" class="c"><input type="checkbox" id="c-42904996" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#42900094">root</a><span>|</span><a href="#42904529">parent</a><span>|</span><a href="#42900071">next</a><span>|</span><label class="collapse" for="c-42904996">[-]</label><label class="expand" for="c-42904996">[1 more]</label></div><br/><div class="children"><div class="content">Things that look magical often stop being magical when you have the right perspective and the right abstractions. The step from a toy example to proving any verifiable statement is just NP-completeness. Which is simple enough that undergraduates are often expected to understand it.<p>Interactive zero-knowledge proofs are also technically non-interactive. They are defined in terms of the verifier evaluating a transcript of the protocol. If the verifier accepts some causal assumptions about the provenance of the transcript, they will accept the proof. If they disagree with the assumptions, the proof is indistinguishable from random noise they could generate themself. An interactive commitment – challenge – response protocol is one possible causal assumption. A source of randomness could replace the challenges, making the protocol non-interactive. Or there could be a pre-committed secret, making a single-round protocol effectively non-interactive.<p>These are things a sufficiently interested CS undergraduate can prove and understand. Public-key cryptography, on the other hand, remains magical. There are many things people assume to be true. Which need to be true for public-key cryptography to function. Empirically these things seem to be true, but nobody has been able to prove them. And I don&#x27;t think anyone really understands them.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42900071" class="c"><input type="checkbox" id="c-42900071" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#42900094">prev</a><span>|</span><a href="#42900442">next</a><span>|</span><label class="collapse" for="c-42900071">[-]</label><label class="expand" for="c-42900071">[30 more]</label></div><br/><div class="children"><div class="content">Highlight (benchmark of Perl source code):<p><pre><code>    The results follow:
    xz -T16 -9 -k - 2&#x27;056&#x27;645&#x27;240 bytes (c=12m09s, d=4m40s)
    bzip2 -9 -k   - 3&#x27;441&#x27;163&#x27;911 bytes (c=17m16s, d=9m22s)
    bzip3 -b 256  - 1&#x27;001&#x27;957&#x27;587 bytes (c=7m10s,  d=4m6s? Unclear on source page)
    bzip3 -b 511  -   546&#x27;456&#x27;978 bytes (c=7m08s,  d=4m6s? Unclear)
    zstd -T12 -16 - 3&#x27;076&#x27;143&#x27;660 bytes (c=6m32s,  d=3m51s)
</code></pre>
edit: Adding times and compression levels</div><br/><div id="42900458" class="c"><input type="checkbox" id="c-42900458" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42901476">next</a><span>|</span><label class="collapse" for="c-42900458">[-]</label><label class="expand" for="c-42900458">[8 more]</label></div><br/><div class="children"><div class="content">My standard test is compressing a &quot;dd&quot; disc image of a Linux install (I use these for work), with unused blocks being zeroed.  Results:<p><pre><code>    Uncompressed:      7,516,192,768
    zstd:              1,100,323,366
    bzip3 -b 511 -j 4: 1,115,125,019</code></pre></div><br/><div id="42902241" class="c"><input type="checkbox" id="c-42902241" checked=""/><div class="controls bullet"><span class="by">palaiologos</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900458">parent</a><span>|</span><a href="#42902876">next</a><span>|</span><label class="collapse" for="c-42902241">[-]</label><label class="expand" for="c-42902241">[5 more]</label></div><br/><div class="children"><div class="content">Hi, tool author here!<p>Thank you for your benchmark!<p>As you may be aware, different compression tools fill in different data type niches. In particular, less specialised statistical methods (bzip2, bzip3, PPMd) generally perform poorly on vaguely defined binary data due to unnatural distribution of the underlying data that at least in bzip3&#x27;s case does not lend well to suffix sorting.<p>Conversely, Lempel-Ziv methods usually perform suboptimally on vaguely defined &quot;textual data&quot; due to the fact that the future stages of compression that involve entropy coding can not make good use of the information encoded by match offsets while maintaining fast decompression performance - it&#x27;s a long story that I could definitely go into detail about if you&#x27;d like, but I want to keep this reply short.<p>All things considered, data compression is more of an art than science, trying to fit in an acceptable spot on the time to compression ratio curve. I created bzip2 as an improvement to the original algorithm, hoping that we can replace some uses of it with a more modern and worthwhile technology as of 2022. I have included benchmarks against LZMA, zstandard, etc. mostly as a formality; in reality if you were to choose a compression method it&#x27;d be very dependent on what exactly you&#x27;re trying to compress, but my personal stance is that bzip3 would likely be strictly better than bzip2 in all of them.<p>bzip3 usually operates on bigger block sizes, up to 16 times bigger than bzip2. additionally, bzip3 supports parallel compression&#x2F;decompression out of the box. for fairness, the benchmarks have been performed using single thread mode, but they aren&#x27;t quite as fair towards bzip3 itself, as it uses a way bigger block size. what bzip3 aims to be is a replacement for bzip2 on modern hardware. what used to not be viable decades ago (arithmetic coding, context mixing, SAIS algorithms for BWT construction) became viable nowadays, as CPU Frequencies don&#x27;t tend to change, while cache and RAM keep getting bigger and faster.</div><br/><div id="42902919" class="c"><input type="checkbox" id="c-42902919" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42902241">parent</a><span>|</span><a href="#42902861">next</a><span>|</span><label class="collapse" for="c-42902919">[-]</label><label class="expand" for="c-42902919">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the reply.  I just figured I&#x27;d try it and see, and the bzip3 results are extremely good.  I figured it was worth trying because a fair bit of the data in that image is non-binary (man pages, config files, shell&#x2F;python code), but probably the bulk of it is binary (kernel images, executables).</div><br/></div></div><div id="42902861" class="c"><input type="checkbox" id="c-42902861" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42902241">parent</a><span>|</span><a href="#42902919">prev</a><span>|</span><a href="#42902876">next</a><span>|</span><label class="collapse" for="c-42902861">[-]</label><label class="expand" for="c-42902861">[3 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t a modern compression tool, targeting a high compression rate, try to switch its compression method on the fly depending on the input data?<p>I have no idea about compression, just a naive thought.</div><br/><div id="42904442" class="c"><input type="checkbox" id="c-42904442" checked=""/><div class="controls bullet"><span class="by">supertrope</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42902861">parent</a><span>|</span><a href="#42906048">next</a><span>|</span><label class="collapse" for="c-42904442">[-]</label><label class="expand" for="c-42904442">[1 more]</label></div><br/><div class="children"><div class="content">7-Zip can apply a BCJ filter before LZMA to more effectively compress x86 binaries. <a href="https:&#x2F;&#x2F;www.7-zip.org&#x2F;7z.html" rel="nofollow">https:&#x2F;&#x2F;www.7-zip.org&#x2F;7z.html</a>. Btrfs’ transparent compression feature checks if the first block compressed well; if not it gives up for the rest of the file.</div><br/></div></div><div id="42906048" class="c"><input type="checkbox" id="c-42906048" checked=""/><div class="controls bullet"><span class="by">kristofferR</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42902861">parent</a><span>|</span><a href="#42904442">prev</a><span>|</span><a href="#42902876">next</a><span>|</span><label class="collapse" for="c-42906048">[-]</label><label class="expand" for="c-42906048">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PAQ" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PAQ</a></div><br/></div></div></div></div></div></div><div id="42902876" class="c"><input type="checkbox" id="c-42902876" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900458">parent</a><span>|</span><a href="#42902241">prev</a><span>|</span><a href="#42900832">next</a><span>|</span><label class="collapse" for="c-42902876">[-]</label><label class="expand" for="c-42902876">[1 more]</label></div><br/><div class="children"><div class="content">A couple other data points:<p><pre><code>    zstd --long --ultra -2:                                1,062,475,298
    zstd --long=windowLog --zstd=windowLog=31 --ultra -22: 1,041,203,362
</code></pre>
So for my use case the additional settings don&#x27;t seem to make sense.</div><br/></div></div></div></div><div id="42901476" class="c"><input type="checkbox" id="c-42901476" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42900458">prev</a><span>|</span><a href="#42900965">next</a><span>|</span><label class="collapse" for="c-42901476">[-]</label><label class="expand" for="c-42901476">[1 more]</label></div><br/><div class="children"><div class="content">Additional benchmarks on the same dataset:<p><pre><code>    uncompressed               - 19&#x27;291&#x27;709&#x27;440
    bzip2 -9                   -  3&#x27;491&#x27;493&#x27;993 (sanity check)
    zstd -16 --long            -    593&#x27;915&#x27;849
    zstd -16 --long=31         -    122&#x27;909&#x27;756 (requires equivalent argument in decompressor due to needing ~4GB RAM)
    zstd -19 --long            -    505&#x27;728&#x27;419
    zstd -19 --long=31         -    106&#x27;601&#x27;594 (requires equivalent argument in decompressor)
    zstd --ultra -22           -    240&#x27;330&#x27;522
    zstd --ultra -22 --long=31 -     64&#x27;899&#x27;008 (requires equivalent argument in decompressor)
    rar a -m5 -md4g -s -mt8    -     64&#x27;837&#x27;044
    
</code></pre>
As you notice my sanity check actually has a slightly different size. Not sure why. The benchmark is a bit underspecified because new perl versions were released in the interim. I used all releases up to perl-5.37.1 to get to the correct number of files. Just treat all numbers to have about 2% uncertainty to account for this difference.<p>I can&#x27;t provide compression&#x2F;decompression times, but the --long or --long=31 arguments should not have major impact on speed, they mostly impact used memory. --long=31 requires setting the same in the decompressor, making that option mostly useful for internal use, not archives meant for public consumption.<p>As you can see, the benchmark chosen by the author mostly comes down to finding similar data that&#x27;s far away. I wonder if bzip3 can do this better than other algorithms (especially in less memory) or simply chose default parameters that use more memory.<p>Edit: added more benchmarks</div><br/></div></div><div id="42900965" class="c"><input type="checkbox" id="c-42900965" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42901476">prev</a><span>|</span><a href="#42900124">next</a><span>|</span><label class="collapse" for="c-42900965">[-]</label><label class="expand" for="c-42900965">[2 more]</label></div><br/><div class="children"><div class="content">Did a test on a 1.3G text file (output of `find -f -printf ...`); Macbook Pro M3 Max 64GB.  All timings are &quot;real&quot; seconds from bash&#x27;s builtin `time`.<p><pre><code>    files.txt         1439563776
    bzip2 -9 -k       1026805779 71.3% c=67 d=53
    zstd --long -19   1002759868 69.7% c=357 d=9
    xz -T16 -9 -k      993376236 69.0% c=93 d=9
    zstd -T12 -16      989246823 68.7% c=14 d=9
    bzip3 -b 256       975153650 67.7% c=174 d=187
    bzip3 -b 256 -j12  975153650 67.7% c=46 d=189
    bzip3 -b 511       974113769 67.6% c=172 d=187
    bzip3 -b 511 -j12  974113769 67.6% c=77s d=186
</code></pre>
I&#x27;ll stick with zstd for now (unless I need to compress the Perl source, I guess.)<p>(edited to add 12 thread runs of bzip3 and remove superfluous filenames)</div><br/><div id="42902564" class="c"><input type="checkbox" id="c-42902564" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900965">parent</a><span>|</span><a href="#42900124">next</a><span>|</span><label class="collapse" for="c-42902564">[-]</label><label class="expand" for="c-42902564">[1 more]</label></div><br/><div class="children"><div class="content">Since I only have 12 perf cores on this Mac, I tried the xz test again with 12 threads.<p><pre><code>    xz -T12 -9 -k      993376236 69.0% c=83 d=9
</code></pre>
~10% faster for compression with the same size output.</div><br/></div></div></div></div><div id="42900124" class="c"><input type="checkbox" id="c-42900124" checked=""/><div class="controls bullet"><span class="by">sevg</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42900965">prev</a><span>|</span><a href="#42900300">next</a><span>|</span><label class="collapse" for="c-42900124">[-]</label><label class="expand" for="c-42900124">[6 more]</label></div><br/><div class="children"><div class="content">To make your comment more useful you’ll want to include compression and decompression time.<p>Using the results from the readme, seems like bzip3 performs competitively with zstd on both counts.</div><br/><div id="42900761" class="c"><input type="checkbox" id="c-42900761" checked=""/><div class="controls bullet"><span class="by">idoubtit</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900124">parent</a><span>|</span><a href="#42900159">next</a><span>|</span><label class="collapse" for="c-42900761">[-]</label><label class="expand" for="c-42900761">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve experimented a bit with bzip3, and I think the results in the readme are not representative. I think it&#x27;s a handmade pick, with an uncommon input and unfair choices of parameters. And it&#x27;s made with a HDD, which skews the results even more.<p>For instance, with a 800 MB SQL file, for the same compression time and optimal parameters (within my capacity), bzip3 produced a smaller file (5.7 % compression ration) than zstd (6.1 % with `--long -15`). But the decompression was about 20× slower (with all cores or just one).<p>I&#x27;m not claim my stupid benchmark is better or even right. It&#x27;s just that my results were very different from bzip3&#x27;s readme. So I&#x27;m suspicious.</div><br/></div></div><div id="42900159" class="c"><input type="checkbox" id="c-42900159" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900124">parent</a><span>|</span><a href="#42900761">prev</a><span>|</span><a href="#42900300">next</a><span>|</span><label class="collapse" for="c-42900159">[-]</label><label class="expand" for="c-42900159">[4 more]</label></div><br/><div class="children"><div class="content">Also the compression levels..</div><br/><div id="42900245" class="c"><input type="checkbox" id="c-42900245" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900159">parent</a><span>|</span><a href="#42900300">next</a><span>|</span><label class="collapse" for="c-42900245">[-]</label><label class="expand" for="c-42900245">[3 more]</label></div><br/><div class="children"><div class="content">I believe the compression levels are included in the list above.</div><br/><div id="42900293" class="c"><input type="checkbox" id="c-42900293" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900245">parent</a><span>|</span><a href="#42900300">next</a><span>|</span><label class="collapse" for="c-42900293">[-]</label><label class="expand" for="c-42900293">[2 more]</label></div><br/><div class="children"><div class="content">Not for zstd or lzma</div><br/><div id="42900432" class="c"><input type="checkbox" id="c-42900432" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900293">parent</a><span>|</span><a href="#42900300">next</a><span>|</span><label class="collapse" for="c-42900432">[-]</label><label class="expand" for="c-42900432">[1 more]</label></div><br/><div class="children"><div class="content">Added, thanks.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42900300" class="c"><input type="checkbox" id="c-42900300" checked=""/><div class="controls bullet"><span class="by">jl6</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42900124">prev</a><span>|</span><a href="#42901612">next</a><span>|</span><label class="collapse" for="c-42900300">[-]</label><label class="expand" for="c-42900300">[2 more]</label></div><br/><div class="children"><div class="content">A 4x improvement over lzma is an extraordinary claim. I see the author has also given a result after applying lrzip (which removes long-range redundancies in large files), and the difference isn’t so great (but bzip3 still wins). Does the amazing result without lrzip mean bzip3 is somehow managing to exploit some of that long-range redundancy natively?<p>I’d be astonished if such a 4x result generalized to tarballs that aren’t mostly duplicated files.</div><br/><div id="42900505" class="c"><input type="checkbox" id="c-42900505" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900300">parent</a><span>|</span><a href="#42901612">next</a><span>|</span><label class="collapse" for="c-42900505">[-]</label><label class="expand" for="c-42900505">[1 more]</label></div><br/><div class="children"><div class="content">Currently running my own benchmarks, my preliminary results are that zstd becomes competitive again once you add the --long option (so `zstd --long -16 all.tar` instead of `zstd -16 all.tar`). Which is an option that not everyone might be aware of, but whose usefulness should be intuitive for this benchmark of &gt;200 very similar files.</div><br/></div></div></div></div><div id="42901612" class="c"><input type="checkbox" id="c-42901612" checked=""/><div class="controls bullet"><span class="by">SeptiumMMX</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42900300">prev</a><span>|</span><a href="#42903508">next</a><span>|</span><label class="collapse" for="c-42901612">[-]</label><label class="expand" for="c-42901612">[2 more]</label></div><br/><div class="children"><div class="content">Given that it&#x27;s BWT, the difference should be the most prominent on codebases with huge amounts of mostly equivalent files. Most compression algorithms won&#x27;t help if you get an exact duplicate of some block when it&#x27;s past the compression window (and will be less efficient if near the end of the window).<p>But here&#x27;s a practical trick: sort files by extension and then by name before putting them into an archive, and then use any conventional compression. It will very likely put the similar-looking files together, and save you space. Done that in practice, works like a charm.</div><br/><div id="42904305" class="c"><input type="checkbox" id="c-42904305" checked=""/><div class="controls bullet"><span class="by">hcs</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42901612">parent</a><span>|</span><a href="#42903508">next</a><span>|</span><label class="collapse" for="c-42904305">[-]</label><label class="expand" for="c-42904305">[1 more]</label></div><br/><div class="children"><div class="content">Handy tip for 7-Zip, the `-mqs` command line switch (just `qs` in the Parameters field of the GUI) does this for you. <a href="https:&#x2F;&#x2F;7-zip.opensource.jp&#x2F;chm&#x2F;cmdline&#x2F;switches&#x2F;method.htm#qs" rel="nofollow">https:&#x2F;&#x2F;7-zip.opensource.jp&#x2F;chm&#x2F;cmdline&#x2F;switches&#x2F;method.htm#...</a></div><br/></div></div></div></div><div id="42903508" class="c"><input type="checkbox" id="c-42903508" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42901612">prev</a><span>|</span><a href="#42900102">next</a><span>|</span><label class="collapse" for="c-42903508">[-]</label><label class="expand" for="c-42903508">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue that&#x27;s actually the lowlight of the README since that is a very poor choice of benchmark. Combining a multitude of versions of the same software massively favors an algorithm good at dealing with this kind of repetitiveness in a way that will not be seen in typical applications.<p>The &quot;Corpus benchmarks&quot; further down in the README are IMHO much more practically relevant. The compression ratio of bzip3 is not significantly better, but the runtime seems quite a bit lower than lzma at least.</div><br/></div></div><div id="42900102" class="c"><input type="checkbox" id="c-42900102" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42903508">prev</a><span>|</span><a href="#42900525">next</a><span>|</span><label class="collapse" for="c-42900102">[-]</label><label class="expand" for="c-42900102">[4 more]</label></div><br/><div class="children"><div class="content">In Linux source benchmark results are interestingly more equal, LZMA still holding up well.<p>What makes Perl source benchmark special? Deduplication?</div><br/><div id="42900121" class="c"><input type="checkbox" id="c-42900121" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900102">parent</a><span>|</span><a href="#42900525">next</a><span>|</span><label class="collapse" for="c-42900121">[-]</label><label class="expand" for="c-42900121">[3 more]</label></div><br/><div class="children"><div class="content">An old friend use to say that Perl is line noise that was given sentience.</div><br/><div id="42900263" class="c"><input type="checkbox" id="c-42900263" checked=""/><div class="controls bullet"><span class="by">ape4</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900121">parent</a><span>|</span><a href="#42900525">next</a><span>|</span><label class="collapse" for="c-42900263">[-]</label><label class="expand" for="c-42900263">[2 more]</label></div><br/><div class="children"><div class="content">This is the source - which is probably C.</div><br/><div id="42900584" class="c"><input type="checkbox" id="c-42900584" checked=""/><div class="controls bullet"><span class="by">bhaney</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900263">parent</a><span>|</span><a href="#42900525">next</a><span>|</span><label class="collapse" for="c-42900584">[-]</label><label class="expand" for="c-42900584">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s 246 C files and 3163 perl files</div><br/></div></div></div></div></div></div></div></div><div id="42900525" class="c"><input type="checkbox" id="c-42900525" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42900102">prev</a><span>|</span><a href="#42900302">next</a><span>|</span><label class="collapse" for="c-42900525">[-]</label><label class="expand" for="c-42900525">[2 more]</label></div><br/><div class="children"><div class="content">Why -T12 for zstd and T16 for xz?  How many threads is bzip3 using?</div><br/><div id="42901161" class="c"><input type="checkbox" id="c-42901161" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#42900071">root</a><span>|</span><a href="#42900525">parent</a><span>|</span><a href="#42900302">next</a><span>|</span><label class="collapse" for="c-42901161">[-]</label><label class="expand" for="c-42901161">[1 more]</label></div><br/><div class="children"><div class="content">From the source, it looks like bzip3 defaults to 1 thread if not explicitly set by arguments.</div><br/></div></div></div></div><div id="42900302" class="c"><input type="checkbox" id="c-42900302" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#42900071">parent</a><span>|</span><a href="#42900525">prev</a><span>|</span><a href="#42900442">next</a><span>|</span><label class="collapse" for="c-42900302">[-]</label><label class="expand" for="c-42900302">[1 more]</label></div><br/><div class="children"><div class="content">...using zstd level 16, when zstd goes up to 22. And without turning on zstd&#x27;s long-range mode.</div><br/></div></div></div></div><div id="42900442" class="c"><input type="checkbox" id="c-42900442" checked=""/><div class="controls bullet"><span class="by">pxeger1</span><span>|</span><a href="#42900071">prev</a><span>|</span><a href="#42904837">next</a><span>|</span><label class="collapse" for="c-42900442">[-]</label><label class="expand" for="c-42900442">[1 more]</label></div><br/><div class="children"><div class="content">The author is super cool. They are one of very few people to write any substantial programs in Malbolge, a programming language designed to be cryptographically hard to use (or something like that)</div><br/></div></div><div id="42904837" class="c"><input type="checkbox" id="c-42904837" checked=""/><div class="controls bullet"><span class="by">jwr</span><span>|</span><a href="#42900442">prev</a><span>|</span><a href="#42903882">next</a><span>|</span><label class="collapse" for="c-42904837">[-]</label><label class="expand" for="c-42904837">[1 more]</label></div><br/><div class="children"><div class="content">I still remember going crazy about bzip (the first one) and re-compressing all my data with it.<p>And then I remember discovering, several years later, that bzip (the first one) is an obsolete format that is now difficult to even decompress.<p>I learned my lesson and now use horribly sub-optimal formats that I&#x27;m sure will stick around for a long time, if not forever.</div><br/></div></div><div id="42903882" class="c"><input type="checkbox" id="c-42903882" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42904837">prev</a><span>|</span><a href="#42905010">next</a><span>|</span><label class="collapse" for="c-42903882">[-]</label><label class="expand" for="c-42903882">[4 more]</label></div><br/><div class="children"><div class="content">Small request: write a header or tail block which records the compression efficiency. Bzip2 doesn&#x27;t. Gzip does. Knowing the uncompressed size can be vital. Yes, there is a risk of lying and making zip bombs.</div><br/><div id="42904770" class="c"><input type="checkbox" id="c-42904770" checked=""/><div class="controls bullet"><span class="by">Zamiel_Snawley</span><span>|</span><a href="#42903882">parent</a><span>|</span><a href="#42905010">next</a><span>|</span><label class="collapse" for="c-42904770">[-]</label><label class="expand" for="c-42904770">[3 more]</label></div><br/><div class="children"><div class="content">Shouldn’t knowing how big it’s supposed to be make it easier to stop a zip bomb? Just stop decompressing once you hit the size from the header.</div><br/><div id="42905028" class="c"><input type="checkbox" id="c-42905028" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42903882">root</a><span>|</span><a href="#42904770">parent</a><span>|</span><a href="#42905010">next</a><span>|</span><label class="collapse" for="c-42905028">[-]</label><label class="expand" for="c-42905028">[2 more]</label></div><br/><div class="children"><div class="content">That only works if the standard actually describes what you&#x27;re supposed to do with extra data at the end, and everyone agrees.<p>In practice, there have been antivirus bypasses that made use of AV scanners treating the additional data differently from common extraction software (I believe it was winrar?).<p>One could argue that a text document with a corrupt file size byte should still be decodeable. One could also argue that the file is completely corrupt and should be treated as such. Knowing that there will be tools that will take the first approach regardless, I&#x27;d stick to just decoding the extra data and marking the file as potentially damaged rather than send the user down a data recovery rabbit hole for a file that&#x27;ll decompress just fine.</div><br/><div id="42906297" class="c"><input type="checkbox" id="c-42906297" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42903882">root</a><span>|</span><a href="#42905028">parent</a><span>|</span><a href="#42905010">next</a><span>|</span><label class="collapse" for="c-42906297">[-]</label><label class="expand" for="c-42906297">[1 more]</label></div><br/><div class="children"><div class="content">IIRC to decode raw zlib or deflate using only command-line tools, you have to prepend the gzip header and stream while ignoring errors at EOF.</div><br/></div></div></div></div></div></div></div></div><div id="42905010" class="c"><input type="checkbox" id="c-42905010" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#42903882">prev</a><span>|</span><a href="#42904833">next</a><span>|</span><label class="collapse" for="c-42905010">[-]</label><label class="expand" for="c-42905010">[1 more]</label></div><br/><div class="children"><div class="content">How does this compare to existing BWT-based compressors on things like the Large Text Compression Benchmark?</div><br/></div></div><div id="42904833" class="c"><input type="checkbox" id="c-42904833" checked=""/><div class="controls bullet"><span class="by">twotwotwo</span><span>|</span><a href="#42905010">prev</a><span>|</span><a href="#42901649">next</a><span>|</span><label class="collapse" for="c-42904833">[-]</label><label class="expand" for="c-42904833">[1 more]</label></div><br/><div class="children"><div class="content">A random thought that Might Work, Who Knows(tm): first compress long-ish repetitions in the input and store the copies separately from the literals (like zstd). Then run just blocks of literals through the BWT before entropy coding.<p>The idea is that the BWT can help take advantage of however much context remains after the copies are snipped out, whether that&#x27;s one byte or a few, and shrinking the input with the LZ-ish step may make it faster. It might be strictly worse than using PPM or basic context modeling like Brotli&#x27;s; either of those can be &quot;aware&quot; of the preceding bytes even when they come from copies rather than literals.<p>It&#x27;s implied in &quot;successor to bzip2&quot; and a lot of the comments, but it&#x27;s worth highlighting that high-compression algorithms, especially those that are also slow to decompress, are a pretty specialized niche now. Using zstd or brotli at low to medium settings sometimes <i>speeds things up</i> by reducing network or storage transfers more than their CPU use slows you down. (Especially when your storage transfers <i>are</i> network transfers.) Even when compressing isn&#x27;t a net speedup, you pay fairly little time for the saved space. Even lowish levels of zstd and brotli often eke out decent compression ratios for big inputs since, with modern quantities of RAM, their MBs-long history windows let them take advantage of long-range matches.</div><br/></div></div><div id="42901649" class="c"><input type="checkbox" id="c-42901649" checked=""/><div class="controls bullet"><span class="by">wood_spirit</span><span>|</span><a href="#42904833">prev</a><span>|</span><a href="#42900455">next</a><span>|</span><label class="collapse" for="c-42901649">[-]</label><label class="expand" for="c-42901649">[2 more]</label></div><br/><div class="children"><div class="content">strange that bzip3 is not yet listed on the large text compression benchmark <a href="http:&#x2F;&#x2F;mattmahoney.net&#x2F;dc&#x2F;text.html" rel="nofollow">http:&#x2F;&#x2F;mattmahoney.net&#x2F;dc&#x2F;text.html</a></div><br/><div id="42905768" class="c"><input type="checkbox" id="c-42905768" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42901649">parent</a><span>|</span><a href="#42900455">next</a><span>|</span><label class="collapse" for="c-42905768">[-]</label><label class="expand" for="c-42905768">[1 more]</label></div><br/><div class="children"><div class="content">But it does have many, many BWT based implementations.  Might be interesting to benchmark it against e.g. bsc[1]<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;IlyaGrebnov&#x2F;libbsc">https:&#x2F;&#x2F;github.com&#x2F;IlyaGrebnov&#x2F;libbsc</a></div><br/></div></div></div></div><div id="42900455" class="c"><input type="checkbox" id="c-42900455" checked=""/><div class="controls bullet"><span class="by">jgalt212</span><span>|</span><a href="#42901649">prev</a><span>|</span><a href="#42905775">next</a><span>|</span><label class="collapse" for="c-42900455">[-]</label><label class="expand" for="c-42900455">[39 more]</label></div><br/><div class="children"><div class="content">I poke around in this space periodically, but I&#x27;ve never found a compelling reason to move away from gzip.</div><br/><div id="42901552" class="c"><input type="checkbox" id="c-42901552" checked=""/><div class="controls bullet"><span class="by">alkh</span><span>|</span><a href="#42900455">parent</a><span>|</span><a href="#42900540">next</a><span>|</span><label class="collapse" for="c-42901552">[-]</label><label class="expand" for="c-42901552">[3 more]</label></div><br/><div class="children"><div class="content">I am a huge proponent of zstd after I learned about it on HN.
I&#x27;ve recently had to compress a 12 Gb csv file. zstd took ~3 sec for compression and ~11 sec for decompression and got the file to ~1.1 Gb. Xz took ~3.5 min for compression(!) and the resulting file was ~740 Mb(I didn&#x27;t measure the decompression time). I just realized that in most cases it&#x27;s more efficient to use zstd, especially for file transfer.<p>The majority of OS that people use either have it installed or can be trivially downloaded to, so I see no point in using gzip nowadays, unless it is mandated by API</div><br/><div id="42903721" class="c"><input type="checkbox" id="c-42903721" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901552">parent</a><span>|</span><a href="#42900540">next</a><span>|</span><label class="collapse" for="c-42903721">[-]</label><label class="expand" for="c-42903721">[2 more]</label></div><br/><div class="children"><div class="content">Did you confuse gzip and xz?  You mention numbers from xz and then suddenly talk about gzip?  These two are not related…</div><br/><div id="42904090" class="c"><input type="checkbox" id="c-42904090" checked=""/><div class="controls bullet"><span class="by">alkh</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903721">parent</a><span>|</span><a href="#42900540">next</a><span>|</span><label class="collapse" for="c-42904090">[-]</label><label class="expand" for="c-42904090">[1 more]</label></div><br/><div class="children"><div class="content">Hey, I didn&#x27;t confuse them but I guess I should have been more specific. I&#x27;ve addressed 2 main points in my text. 1) In my opinion, for the vast majority of cases you don&#x27;t need to be worried about comparability, as you can easily install better alternatives to gzip for platforms a lot of people use. 2) I think zstd can become a primary replacement for gzip due to its high speed of compression and good compression ratio, even when compared to such great algorithms like xz&#x2F;lzma. Sacrificing some compression ratio for (de)compression speed is worth it, for me at least</div><br/></div></div></div></div></div></div><div id="42900540" class="c"><input type="checkbox" id="c-42900540" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900455">parent</a><span>|</span><a href="#42901552">prev</a><span>|</span><a href="#42900975">next</a><span>|</span><label class="collapse" for="c-42900540">[-]</label><label class="expand" for="c-42900540">[33 more]</label></div><br/><div class="children"><div class="content">zstd is faster and provides better compression than gzip at every point on the curve.  There is no reason to use gzip these days other than backwards compatibility.</div><br/><div id="42900623" class="c"><input type="checkbox" id="c-42900623" checked=""/><div class="controls bullet"><span class="by">idoubtit</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900540">parent</a><span>|</span><a href="#42901388">next</a><span>|</span><label class="collapse" for="c-42900623">[-]</label><label class="expand" for="c-42900623">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve reached the same conclusion, and I&#x27;ve been using zstd unless I want extremely fast (de)compression with lz4.<p>And even when I still have to use gzip (the format), the executables of libdeflate are fully compatible and noticeably faster than gzip&#x2F;gunzip (the tool).</div><br/><div id="42901363" class="c"><input type="checkbox" id="c-42901363" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900623">parent</a><span>|</span><a href="#42901388">next</a><span>|</span><label class="collapse" for="c-42901363">[-]</label><label class="expand" for="c-42901363">[1 more]</label></div><br/><div class="children"><div class="content">This was on HN a while ago <a href="https:&#x2F;&#x2F;jolynch.github.io&#x2F;posts&#x2F;use_fast_data_algorithms&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jolynch.github.io&#x2F;posts&#x2F;use_fast_data_algorithms&#x2F;</a> and reaches the same conclusion.  I am inclined to use Zstd even in cases where people would use lz4.  Zstd is very fast.</div><br/></div></div></div></div><div id="42901388" class="c"><input type="checkbox" id="c-42901388" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900540">parent</a><span>|</span><a href="#42900623">prev</a><span>|</span><a href="#42900732">next</a><span>|</span><label class="collapse" for="c-42901388">[-]</label><label class="expand" for="c-42901388">[19 more]</label></div><br/><div class="children"><div class="content">Do zless, zcat and zgrep support zstd everywhere? And I mean <i>everywhere</i>? VMs? Alpine? FreeBSD? OSX? Openwrt?<p>Nothing is shittier than sshing into a box that doesn’t understand half of your command line tricks. Or the clever shell script you just tested six ways to Sunday. It’s like fighting with your hands tied behind your back.</div><br/><div id="42901520" class="c"><input type="checkbox" id="c-42901520" checked=""/><div class="controls bullet"><span class="by">sophiebits</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901388">parent</a><span>|</span><a href="#42901639">next</a><span>|</span><label class="collapse" for="c-42901520">[-]</label><label class="expand" for="c-42901520">[2 more]</label></div><br/><div class="children"><div class="content">&gt; other than backwards compatibility</div><br/><div id="42901802" class="c"><input type="checkbox" id="c-42901802" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901520">parent</a><span>|</span><a href="#42901639">next</a><span>|</span><label class="collapse" for="c-42901802">[-]</label><label class="expand" for="c-42901802">[1 more]</label></div><br/><div class="children"><div class="content">Other than that, Mrs Lincoln, how was the play?</div><br/></div></div></div></div><div id="42901639" class="c"><input type="checkbox" id="c-42901639" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901388">parent</a><span>|</span><a href="#42901520">prev</a><span>|</span><a href="#42901712">next</a><span>|</span><label class="collapse" for="c-42901639">[-]</label><label class="expand" for="c-42901639">[15 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s supported on all those platforms.</div><br/><div id="42901810" class="c"><input type="checkbox" id="c-42901810" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901639">parent</a><span>|</span><a href="#42901712">next</a><span>|</span><label class="collapse" for="c-42901810">[-]</label><label class="expand" for="c-42901810">[14 more]</label></div><br/><div class="children"><div class="content">How far back?</div><br/><div id="42901857" class="c"><input type="checkbox" id="c-42901857" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901810">parent</a><span>|</span><a href="#42901712">next</a><span>|</span><label class="collapse" for="c-42901857">[-]</label><label class="expand" for="c-42901857">[13 more]</label></div><br/><div class="children"><div class="content">How much does that matter? All currently supported releases at least.</div><br/><div id="42903177" class="c"><input type="checkbox" id="c-42903177" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901857">parent</a><span>|</span><a href="#42902151">next</a><span>|</span><label class="collapse" for="c-42903177">[-]</label><label class="expand" for="c-42903177">[9 more]</label></div><br/><div class="children"><div class="content">bash4 was released Feb 2009. 16 years ago.
The very latest version of osx ships with bash3, from 20 years ago.<p>It&#x27;s a fair question, and &quot;currently supported&quot; is essentially meaningless.<p>(Yes we all know about macports and the other more popular but less correct systems, and yes most bash scripts should be written to specifically avoid relying on any special features exactly to avoid being broken so easily. These are both true and both beside the point. Fact is still, this is not only a &quot;currently supported&quot; system by some technicality like the final months of a 5 year lts release or something, this is the up to this very minute version of a massive install base, with a 20 year old version of something as basic and all-touching as the very shell itself.<p>I know about this so intimately because I actually have scripts that don&#x27;t work because they were intentional stunts to see just what could be done without forking any external exes or even child shells, but allow using every possible feature and trick in bash itself.)</div><br/><div id="42903389" class="c"><input type="checkbox" id="c-42903389" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903177">parent</a><span>|</span><a href="#42903279">next</a><span>|</span><label class="collapse" for="c-42903389">[-]</label><label class="expand" for="c-42903389">[4 more]</label></div><br/><div class="children"><div class="content">The bash 4 thing is due to the GPL 3, not some inherent slowness in updating software.  It has nothing to do with zstd, which is permissively licensed.</div><br/><div id="42903477" class="c"><input type="checkbox" id="c-42903477" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903389">parent</a><span>|</span><a href="#42903279">next</a><span>|</span><label class="collapse" for="c-42903477">[-]</label><label class="expand" for="c-42903477">[3 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter why. All that matters is that &quot;current&quot; is not a valid word. Old things exist in &quot;current&quot; systems. And current systems may also be old systems.</div><br/><div id="42903592" class="c"><input type="checkbox" id="c-42903592" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903477">parent</a><span>|</span><a href="#42906319">next</a><span>|</span><label class="collapse" for="c-42903592">[-]</label><label class="expand" for="c-42903592">[1 more]</label></div><br/><div class="children"><div class="content">Ok.  I think engineers are well capable of evaluating what systems they need to support and if zstd is a usable option for them.  In many situations, the answer will be &quot;yes.&quot;</div><br/></div></div><div id="42906319" class="c"><input type="checkbox" id="c-42906319" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903477">parent</a><span>|</span><a href="#42903592">prev</a><span>|</span><a href="#42903279">next</a><span>|</span><label class="collapse" for="c-42906319">[-]</label><label class="expand" for="c-42906319">[1 more]</label></div><br/><div class="children"><div class="content">You can download a supported zstd release through homebrew for every version of macOS that is supported by Apple (as those are the releases homebrew supports), and it compiles from source for older ones.<p>I don&#x27;t even know why we&#x27;re talking about bash here. But for the record, this is a unique circumstance that affects only software which made the transition from GPLv2 -&gt; GPLv3. Changing your license can cause you to fork away from some users. News at 11.</div><br/></div></div></div></div></div></div><div id="42903279" class="c"><input type="checkbox" id="c-42903279" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903177">parent</a><span>|</span><a href="#42903389">prev</a><span>|</span><a href="#42903353">next</a><span>|</span><label class="collapse" for="c-42903279">[-]</label><label class="expand" for="c-42903279">[1 more]</label></div><br/><div class="children"><div class="content">I really don’t want to switch to zsh, but these are facts.<p>The number of devs working on OSX producing non-OSX applications is staggering.</div><br/></div></div><div id="42903353" class="c"><input type="checkbox" id="c-42903353" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903177">parent</a><span>|</span><a href="#42903279">prev</a><span>|</span><a href="#42902151">next</a><span>|</span><label class="collapse" for="c-42903353">[-]</label><label class="expand" for="c-42903353">[3 more]</label></div><br/><div class="children"><div class="content">What does that have to do with zstd?</div><br/><div id="42903506" class="c"><input type="checkbox" id="c-42903506" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903353">parent</a><span>|</span><a href="#42902151">next</a><span>|</span><label class="collapse" for="c-42903506">[-]</label><label class="expand" for="c-42903506">[2 more]</label></div><br/><div class="children"><div class="content">It directly addresses &quot;How much does that matter? All currently supported releases at least.&quot;</div><br/><div id="42904541" class="c"><input type="checkbox" id="c-42904541" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903506">parent</a><span>|</span><a href="#42902151">next</a><span>|</span><label class="collapse" for="c-42904541">[-]</label><label class="expand" for="c-42904541">[1 more]</label></div><br/><div class="children"><div class="content">No it doesn’t? You can get zstd on macOS just fine. We’re talking about zstd, not bash, and supported releases not what ships with the distribution.</div><br/></div></div></div></div></div></div></div></div><div id="42902151" class="c"><input type="checkbox" id="c-42902151" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901857">parent</a><span>|</span><a href="#42903177">prev</a><span>|</span><a href="#42901712">next</a><span>|</span><label class="collapse" for="c-42902151">[-]</label><label class="expand" for="c-42902151">[3 more]</label></div><br/><div class="children"><div class="content">Seriously?<p>There are places still migrating off of Java 8.<p>And pet servers still exist in the wild.</div><br/><div id="42905073" class="c"><input type="checkbox" id="c-42905073" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42902151">parent</a><span>|</span><a href="#42902580">next</a><span>|</span><label class="collapse" for="c-42905073">[-]</label><label class="expand" for="c-42905073">[1 more]</label></div><br/><div class="children"><div class="content">Java 8 will be supported until 2032 if you pick the right distro, and that distro comes with zstd in the repos (if not pre-installed).<p>And if your system is so old that you don&#x27;t have access to eight-year-old software, I don&#x27;t see why the rest of the world needs to accommodate you. Sticking with weird and old software is fine, but that comes with the risk of having to deal with everyone else moving on.</div><br/></div></div><div id="42902580" class="c"><input type="checkbox" id="c-42902580" checked=""/><div class="controls bullet"><span class="by">mobutu</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42902151">parent</a><span>|</span><a href="#42905073">prev</a><span>|</span><a href="#42901712">next</a><span>|</span><label class="collapse" for="c-42902580">[-]</label><label class="expand" for="c-42902580">[1 more]</label></div><br/><div class="children"><div class="content">Seriously who cares about those who are living in the past? It is on them for not keeping up with the times.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42901712" class="c"><input type="checkbox" id="c-42901712" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901388">parent</a><span>|</span><a href="#42901639">prev</a><span>|</span><a href="#42900732">next</a><span>|</span><label class="collapse" for="c-42901712">[-]</label><label class="expand" for="c-42901712">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s been integrated in lots of places, mostly as long ago as the late 2010s.</div><br/></div></div></div></div><div id="42900732" class="c"><input type="checkbox" id="c-42900732" checked=""/><div class="controls bullet"><span class="by">ThatGuyRaion</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900540">parent</a><span>|</span><a href="#42901388">prev</a><span>|</span><a href="#42900975">next</a><span>|</span><label class="collapse" for="c-42900732">[-]</label><label class="expand" for="c-42900732">[11 more]</label></div><br/><div class="children"><div class="content">zstd is a great setup, for sure, but the build system they use is patently awful. Can someone make an autoconf or hell, even CMake build system for them pleasee???</div><br/><div id="42900848" class="c"><input type="checkbox" id="c-42900848" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900732">parent</a><span>|</span><a href="#42903611">next</a><span>|</span><label class="collapse" for="c-42900848">[-]</label><label class="expand" for="c-42900848">[8 more]</label></div><br/><div class="children"><div class="content">Just install the binary package from whatever distro you use?  Why do you need to build it?<p>But if it matters, FreeBSD has a pretty trivial BSDmake build of it:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;freebsd&#x2F;freebsd-src&#x2F;blob&#x2F;main&#x2F;lib&#x2F;libzstd&#x2F;Makefile">https:&#x2F;&#x2F;github.com&#x2F;freebsd&#x2F;freebsd-src&#x2F;blob&#x2F;main&#x2F;lib&#x2F;libzstd...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;freebsd&#x2F;freebsd-src&#x2F;blob&#x2F;main&#x2F;usr.bin&#x2F;zstd&#x2F;Makefile">https:&#x2F;&#x2F;github.com&#x2F;freebsd&#x2F;freebsd-src&#x2F;blob&#x2F;main&#x2F;usr.bin&#x2F;zst...</a><p>You could easily do something similar in GNU make or whatever without the dependencies on the FBSD build system.  It&#x27;s basically just the classic &quot;cc -c a bunch of C files, then link them.&quot;</div><br/><div id="42905967" class="c"><input type="checkbox" id="c-42905967" checked=""/><div class="controls bullet"><span class="by">ThatGuyRaion</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900848">parent</a><span>|</span><a href="#42901342">next</a><span>|</span><label class="collapse" for="c-42905967">[-]</label><label class="expand" for="c-42905967">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just install the binary package from whatever distro you use? Why do you need to build it?<p>Cuz I&#x27;m actually a packaging maintainer for a couple different old operating systems. Regardless I thank you for being thankful even though I feel like you were being backhanded and demeaning on a number of levels.</div><br/></div></div><div id="42901342" class="c"><input type="checkbox" id="c-42901342" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900848">parent</a><span>|</span><a href="#42905967">prev</a><span>|</span><a href="#42903611">next</a><span>|</span><label class="collapse" for="c-42901342">[-]</label><label class="expand" for="c-42901342">[6 more]</label></div><br/><div class="children"><div class="content">I suppose the point of open source software is to edit the source code and make your own version.  If you can&#x27;t build it, you can&#x27;t do that.</div><br/><div id="42901737" class="c"><input type="checkbox" id="c-42901737" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901342">parent</a><span>|</span><a href="#42903611">next</a><span>|</span><label class="collapse" for="c-42901737">[-]</label><label class="expand" for="c-42901737">[5 more]</label></div><br/><div class="children"><div class="content">Zstd has lots of contributors who have all figured out how to edit and build it.</div><br/><div id="42906286" class="c"><input type="checkbox" id="c-42906286" checked=""/><div class="controls bullet"><span class="by">ThatGuyRaion</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901737">parent</a><span>|</span><a href="#42902069">next</a><span>|</span><label class="collapse" for="c-42906286">[-]</label><label class="expand" for="c-42906286">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s basically a giant GCCism. Don&#x27;t be condescending.</div><br/><div id="42906772" class="c"><input type="checkbox" id="c-42906772" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42906286">parent</a><span>|</span><a href="#42902069">next</a><span>|</span><label class="collapse" for="c-42906772">[-]</label><label class="expand" for="c-42906772">[1 more]</label></div><br/><div class="children"><div class="content">I have no idea what you&#x27;re talking about at this point.</div><br/></div></div></div></div><div id="42902069" class="c"><input type="checkbox" id="c-42902069" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42901737">parent</a><span>|</span><a href="#42906286">prev</a><span>|</span><a href="#42903611">next</a><span>|</span><label class="collapse" for="c-42902069">[-]</label><label class="expand" for="c-42902069">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, not sure what the original commenter is complaining about.  I did &quot;git clone <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;zstd">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;zstd</a>&quot;, &quot;cd zstd&quot;, &quot;make&quot; and have a working binary.  Doesn&#x27;t get easier than that.</div><br/><div id="42906288" class="c"><input type="checkbox" id="c-42906288" checked=""/><div class="controls bullet"><span class="by">ThatGuyRaion</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42902069">parent</a><span>|</span><a href="#42903611">next</a><span>|</span><label class="collapse" for="c-42906288">[-]</label><label class="expand" for="c-42906288">[1 more]</label></div><br/><div class="children"><div class="content">Not everyone is using a standard tool chain or anything like that and oftentimes when I find projects with atypical build systems that give me trouble I tend to just move on to something else</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42903611" class="c"><input type="checkbox" id="c-42903611" checked=""/><div class="controls bullet"><span class="by">MawKKe</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900732">parent</a><span>|</span><a href="#42900848">prev</a><span>|</span><a href="#42900975">next</a><span>|</span><label class="collapse" for="c-42903611">[-]</label><label class="expand" for="c-42903611">[2 more]</label></div><br/><div class="children"><div class="content">Quick glance of zstd github repo shows they do provide CMake build scripts?</div><br/><div id="42905970" class="c"><input type="checkbox" id="c-42905970" checked=""/><div class="controls bullet"><span class="by">ThatGuyRaion</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42903611">parent</a><span>|</span><a href="#42900975">next</a><span>|</span><label class="collapse" for="c-42905970">[-]</label><label class="expand" for="c-42905970">[1 more]</label></div><br/><div class="children"><div class="content">Last I touched it they only had glitchy make files and I don&#x27;t like cmake particularly, I was just like &quot;bespoke make files are fine if they&#x27;re posix compliant, but these aren&#x27;t&quot;</div><br/></div></div></div></div></div></div></div></div><div id="42900975" class="c"><input type="checkbox" id="c-42900975" checked=""/><div class="controls bullet"><span class="by">Borg3</span><span>|</span><a href="#42900455">parent</a><span>|</span><a href="#42900540">prev</a><span>|</span><a href="#42905775">next</a><span>|</span><label class="collapse" for="c-42900975">[-]</label><label class="expand" for="c-42900975">[2 more]</label></div><br/><div class="children"><div class="content">Same here. Storage is not that expensive so I do NOT care to squize every byte out of archive. Also, im more into retro, so portability and memory usage is more importand for me :)</div><br/><div id="42902144" class="c"><input type="checkbox" id="c-42902144" checked=""/><div class="controls bullet"><span class="by">palaiologos</span><span>|</span><a href="#42900455">root</a><span>|</span><a href="#42900975">parent</a><span>|</span><a href="#42905775">next</a><span>|</span><label class="collapse" for="c-42902144">[-]</label><label class="expand" for="c-42902144">[1 more]</label></div><br/><div class="children"><div class="content">Hi, tool author here!<p>Regarding your first remark: high ratio data compression has its time and place, and I personally understand that to many people it is not very desirable. In a lot of scenarios something as plain and simple as LZ4 generally suffices.<p>On the other hand, there is an unofficial (= unsupported) port of bzip3 to older (386+) machines that run MS-DOS6.22. I have prepared it for a retrocomputing meeting in Ontario that I attended a while back. Let me know what you think :).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kspalaiologos&#x2F;dev-urandom&#x2F;blob&#x2F;main&#x2F;dos&#x2F;BZIP3.EXE">https:&#x2F;&#x2F;github.com&#x2F;kspalaiologos&#x2F;dev-urandom&#x2F;blob&#x2F;main&#x2F;dos&#x2F;B...</a></div><br/></div></div></div></div></div></div><div id="42905775" class="c"><input type="checkbox" id="c-42905775" checked=""/><div class="controls bullet"><span class="by">biglost</span><span>|</span><a href="#42900455">prev</a><span>|</span><a href="#42900229">next</a><span>|</span><label class="collapse" for="c-42905775">[-]</label><label class="expand" for="c-42905775">[1 more]</label></div><br/><div class="children"><div class="content">Everytime someone says I&#x27;m too smart, i remember this kind of black magic and inmediately answer: no, im not</div><br/></div></div><div id="42900229" class="c"><input type="checkbox" id="c-42900229" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#42905775">prev</a><span>|</span><a href="#42900088">next</a><span>|</span><label class="collapse" for="c-42900229">[-]</label><label class="expand" for="c-42900229">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Bzip3: A better and stronger spiritual successor to BZip2<p>Please, no. What&#x27;s next ? BZip4 and BZip5, each one incompatible with each other ?</div><br/><div id="42906400" class="c"><input type="checkbox" id="c-42906400" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#42900229">parent</a><span>|</span><a href="#42900287">next</a><span>|</span><label class="collapse" for="c-42906400">[-]</label><label class="expand" for="c-42906400">[1 more]</label></div><br/><div class="children"><div class="content">While the name bzip3 itself would be okay for reasons others stated, I still don&#x27;t like it because it is so easy to confuse with bzip2 and may indicate a false relationship with bzip2 regardless of intents. A spiritual successor doesn&#x27;t have to be named confusingly similar, after all.</div><br/></div></div><div id="42900287" class="c"><input type="checkbox" id="c-42900287" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#42900229">parent</a><span>|</span><a href="#42906400">prev</a><span>|</span><a href="#42900599">next</a><span>|</span><label class="collapse" for="c-42900287">[-]</label><label class="expand" for="c-42900287">[1 more]</label></div><br/><div class="children"><div class="content">this is the way.</div><br/></div></div><div id="42900599" class="c"><input type="checkbox" id="c-42900599" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#42900229">parent</a><span>|</span><a href="#42900287">prev</a><span>|</span><a href="#42900831">next</a><span>|</span><label class="collapse" for="c-42900599">[-]</label><label class="expand" for="c-42900599">[1 more]</label></div><br/><div class="children"><div class="content">The format gets a new major version precisely because it is incompatible.</div><br/></div></div><div id="42900831" class="c"><input type="checkbox" id="c-42900831" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#42900229">parent</a><span>|</span><a href="#42900599">prev</a><span>|</span><a href="#42900948">next</a><span>|</span><label class="collapse" for="c-42900831">[-]</label><label class="expand" for="c-42900831">[3 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;m sick of this. Did you know you can&#x27;t even use ext2&#x2F;3&#x2F;4 together on the same partition? What a mess.</div><br/><div id="42900875" class="c"><input type="checkbox" id="c-42900875" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42900229">root</a><span>|</span><a href="#42900831">parent</a><span>|</span><a href="#42900948">next</a><span>|</span><label class="collapse" for="c-42900875">[-]</label><label class="expand" for="c-42900875">[2 more]</label></div><br/><div class="children"><div class="content">The ext4&#x2F;3 filesystems, notably, can read&#x2F;write ext2 (and for ext4: ext3) filesystems in a compatible way.</div><br/><div id="42901383" class="c"><input type="checkbox" id="c-42901383" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#42900229">root</a><span>|</span><a href="#42900875">parent</a><span>|</span><a href="#42900948">next</a><span>|</span><label class="collapse" for="c-42901383">[-]</label><label class="expand" for="c-42901383">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah true</div><br/></div></div></div></div></div></div><div id="42900948" class="c"><input type="checkbox" id="c-42900948" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#42900229">parent</a><span>|</span><a href="#42900831">prev</a><span>|</span><a href="#42900088">next</a><span>|</span><label class="collapse" for="c-42900948">[-]</label><label class="expand" for="c-42900948">[1 more]</label></div><br/><div class="children"><div class="content">If they have to be incompatible then it&#x27;s better to not conceal that. Generalized file formats require you to implement more stuff to support them, and we can&#x27;t tell the format by looking at the file name.</div><br/></div></div></div></div><div id="42900088" class="c"><input type="checkbox" id="c-42900088" checked=""/><div class="controls bullet"><span class="by">otterley</span><span>|</span><a href="#42900229">prev</a><span>|</span><a href="#42901256">next</a><span>|</span><label class="collapse" for="c-42900088">[-]</label><label class="expand" for="c-42900088">[4 more]</label></div><br/><div class="children"><div class="content">(2022)</div><br/><div id="42901301" class="c"><input type="checkbox" id="c-42901301" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#42900088">parent</a><span>|</span><a href="#42901256">next</a><span>|</span><label class="collapse" for="c-42901301">[-]</label><label class="expand" for="c-42901301">[3 more]</label></div><br/><div class="children"><div class="content">what do you mean??<p>usually this signifies the year some article was finalized and published.<p>and this is a GitHub repo with recent commits so this is not correct here.</div><br/><div id="42906380" class="c"><input type="checkbox" id="c-42906380" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#42900088">root</a><span>|</span><a href="#42901301">parent</a><span>|</span><a href="#42903153">next</a><span>|</span><label class="collapse" for="c-42906380">[-]</label><label class="expand" for="c-42906380">[1 more]</label></div><br/><div class="children"><div class="content">But there seem to have been no major updates since the original submission (every release up to 1.5.1 is for minor maintenances), so the year would be indeed useful for the vast majority who do remember that.</div><br/></div></div><div id="42903153" class="c"><input type="checkbox" id="c-42903153" checked=""/><div class="controls bullet"><span class="by">otterley</span><span>|</span><a href="#42900088">root</a><span>|</span><a href="#42901301">parent</a><span>|</span><a href="#42906380">prev</a><span>|</span><a href="#42901256">next</a><span>|</span><label class="collapse" for="c-42903153">[-]</label><label class="expand" for="c-42903153">[1 more]</label></div><br/><div class="children"><div class="content">The date signifies that this tool is not new; and this is ostensibly a &quot;news&quot; site.</div><br/></div></div></div></div></div></div><div id="42901256" class="c"><input type="checkbox" id="c-42901256" checked=""/><div class="controls bullet"><span class="by">lexicality</span><span>|</span><a href="#42900088">prev</a><span>|</span><label class="collapse" for="c-42901256">[-]</label><label class="expand" for="c-42901256">[21 more]</label></div><br/><div class="children"><div class="content">&gt; DO NOT COMPRESS ANY DATA WITH THIS PROGRAM UNLESS YOU ARE PREPARED TO ACCEPT THE POSSIBILITY, HOWEVER SMALL, THAT THE DATA WILL NOT BE RECOVERABLE.<p>I know every open source project (and quite a lot of expensive proprietary ones!) come with a &quot;btw this software might wipe your computer, if it does that&#x27;s your fault lol&quot; clause in their license but I can&#x27;t imagine trying to convince anyone else that using this for anything remotely serious is a good idea with that line in the readme.</div><br/><div id="42902059" class="c"><input type="checkbox" id="c-42902059" checked=""/><div class="controls bullet"><span class="by">palaiologos</span><span>|</span><a href="#42901256">parent</a><span>|</span><a href="#42901313">next</a><span>|</span><label class="collapse" for="c-42902059">[-]</label><label class="expand" for="c-42902059">[2 more]</label></div><br/><div class="children"><div class="content">Hi! Tool author here.<p>Almost every single open source compression tool contains a clause like this. For example, the one in the README that you see has been directly lifted from the bzip2 README. Almost all open source projects come with such a no-warranty scheme. 7-Zip, zstandard, xz-utils, etc; as exemplified by a quote from the license text of the MIT license:<p>&gt; THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.<p>If you were willing to sign a commercial support contract with me on terms that we negotiated, I would be willing to provide you warranty.<p>If you were not aware, this is essentially the business model of WinRAR. The reason why tools like 7-Zip are not used by the public sector or companies (at least here) is that they provide no warranty in case of data loss. However, if you actually buy WinRAR, then you can hold them liable for damage to your archives. The &quot;infinite 40 day trial&quot; of WinRAR does not entitle you to compensation for damages and thus corporate entities and public entities have to buy WinRAR licenses. WinRAR has never cared about personal customers.<p>In general, having to cope with mild reliability of software is what you have to live with - you already get more than you paid for. Not to say that my tool is unreliable - I put a lot of effort into it, but it would put you in bad light to complain about something that you generously received for free :).</div><br/></div></div><div id="42901313" class="c"><input type="checkbox" id="c-42901313" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#42901256">parent</a><span>|</span><a href="#42902059">prev</a><span>|</span><a href="#42901540">next</a><span>|</span><label class="collapse" for="c-42901313">[-]</label><label class="expand" for="c-42901313">[8 more]</label></div><br/><div class="children"><div class="content">Simple enough to be safe, at the cost of performance: uncompress and compare to the original.</div><br/><div id="42901333" class="c"><input type="checkbox" id="c-42901333" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42901313">parent</a><span>|</span><a href="#42901328">next</a><span>|</span><label class="collapse" for="c-42901333">[-]</label><label class="expand" for="c-42901333">[2 more]</label></div><br/><div class="children"><div class="content">You could have bugs that show up on different hardware or compiler versions. So the round trip is table stakes but not a guarantee.<p>Edit: someone deleted a response that said that if you can read it back then the data is there. I think in a data recovery sense that’s definitely true, if it’s consistent across inputs. But building something that simulates the undefined behavior or race condition - if it’s symmetrical between read and write could be pretty tricky. And you’d have to decode based on file version number to know if you need the emulation. So possible but terrible to maintain, and the interim versions from creating and discovering the bug would still be broken.</div><br/></div></div><div id="42901328" class="c"><input type="checkbox" id="c-42901328" checked=""/><div class="controls bullet"><span class="by">lexicality</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42901313">parent</a><span>|</span><a href="#42901333">prev</a><span>|</span><a href="#42901540">next</a><span>|</span><label class="collapse" for="c-42901328">[-]</label><label class="expand" for="c-42901328">[5 more]</label></div><br/><div class="children"><div class="content">And what do you do if it doesn&#x27;t match?</div><br/><div id="42901399" class="c"><input type="checkbox" id="c-42901399" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42901328">parent</a><span>|</span><a href="#42901540">next</a><span>|</span><label class="collapse" for="c-42901399">[-]</label><label class="expand" for="c-42901399">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it obvious? Warn the user, who can now use something else instead.</div><br/><div id="42901428" class="c"><input type="checkbox" id="c-42901428" checked=""/><div class="controls bullet"><span class="by">lexicality</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42901399">parent</a><span>|</span><a href="#42901540">next</a><span>|</span><label class="collapse" for="c-42901428">[-]</label><label class="expand" for="c-42901428">[3 more]</label></div><br/><div class="children"><div class="content">That only works if the &quot;user&quot; is an interactive TTY with a human on the other end of it though. What if I tried using this for compressing automatic backups? Do I need an error handling routine that uses something else?</div><br/><div id="42901548" class="c"><input type="checkbox" id="c-42901548" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42901428">parent</a><span>|</span><a href="#42905112">next</a><span>|</span><label class="collapse" for="c-42901548">[-]</label><label class="expand" for="c-42901548">[1 more]</label></div><br/><div class="children"><div class="content">A backup system should be reliable and be able to report errors. No matter what they may be.</div><br/></div></div><div id="42905112" class="c"><input type="checkbox" id="c-42905112" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42901428">parent</a><span>|</span><a href="#42901548">prev</a><span>|</span><a href="#42901540">next</a><span>|</span><label class="collapse" for="c-42905112">[-]</label><label class="expand" for="c-42905112">[1 more]</label></div><br/><div class="children"><div class="content">Your automatic backups may actually be corrupted by random bit flips. Happens quite a lot with ZFS NAS systems where the admin forgot to set up a scrub job and still uses incremental backups.<p>Any read or write could fail for a multitude of reasons. The chance of an entire file being lost is rather small, but it&#x27;s still an edge case that can happen in the real world if the FS flips to read only at just the wrong time. Hell, on platforms like macOS, you can&#x27;t even assume fsync returning success will actually write floating data to storage!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42901540" class="c"><input type="checkbox" id="c-42901540" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#42901256">parent</a><span>|</span><a href="#42901313">prev</a><span>|</span><a href="#42902894">next</a><span>|</span><label class="collapse" for="c-42901540">[-]</label><label class="expand" for="c-42901540">[4 more]</label></div><br/><div class="children"><div class="content">The author of lzip goes into some degree of excitement on the reliability and recoverability of the lzip format compared to xz.<p><a href="https:&#x2F;&#x2F;www.nongnu.org&#x2F;lzip&#x2F;xz_inadequate.html" rel="nofollow">https:&#x2F;&#x2F;www.nongnu.org&#x2F;lzip&#x2F;xz_inadequate.html</a><p>I personally back up about a terabyte each week, and I use 7-zip because it has built-in encryption, which is required because of the HR data in the backup. Thank heavens for xargs -P.<p>I could use &quot;openssl enc&quot; combined with any pure compression utility, but I don&#x27;t want to make decompression impossible if I get hit by a bus.</div><br/><div id="42902769" class="c"><input type="checkbox" id="c-42902769" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42901540">parent</a><span>|</span><a href="#42902894">next</a><span>|</span><label class="collapse" for="c-42902769">[-]</label><label class="expand" for="c-42902769">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <a href="https:&#x2F;&#x2F;www.nongnu.org&#x2F;lzip&#x2F;xz_inadequate.html" rel="nofollow">https:&#x2F;&#x2F;www.nongnu.org&#x2F;lzip&#x2F;xz_inadequate.html</a><p>I have replaced all my previous uses of xz with lzip ever since I read that page (via <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32210438">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32210438</a>), but for some reason lzip never seem to rise to the same level of fame as xz.  bzip3 also wasn&#x27;t benchmarked against lzip.</div><br/><div id="42906436" class="c"><input type="checkbox" id="c-42906436" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42902769">parent</a><span>|</span><a href="#42902894">next</a><span>|</span><label class="collapse" for="c-42906436">[-]</label><label class="expand" for="c-42906436">[2 more]</label></div><br/><div class="children"><div class="content">I think you should just skip both xz and lzip, because that essay is in my opinion technically correct but also only deals with a very much minor concern [1]. If you want the recovery out of archives, you should use dedicated formats like PArchive and not ordinary archives with half-baked recovery attempts.<p>[1] Previously: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39873122">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39873122</a></div><br/><div id="42906724" class="c"><input type="checkbox" id="c-42906724" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42906436">parent</a><span>|</span><a href="#42902894">next</a><span>|</span><label class="collapse" for="c-42906724">[-]</label><label class="expand" for="c-42906724">[1 more]</label></div><br/><div class="children"><div class="content">For my personal backup use, I actually use RAR with recovery records, optionally with encryption if it&#x27;s sensitive.  I was only using xz in places where I couldn&#x27;t use RAR (e.g. for work), and those places tend to also have lzip available.</div><br/></div></div></div></div></div></div></div></div><div id="42902894" class="c"><input type="checkbox" id="c-42902894" checked=""/><div class="controls bullet"><span class="by">andix</span><span>|</span><a href="#42901256">parent</a><span>|</span><a href="#42901540">prev</a><span>|</span><a href="#42901340">next</a><span>|</span><label class="collapse" for="c-42902894">[-]</label><label class="expand" for="c-42902894">[1 more]</label></div><br/><div class="children"><div class="content">It reads to me more like: DONT USE EXPERIMENTAL COMPRESSION TOOLS FOR BACKING UP YOUR IMPORTANT DATA. USE IT FOR TRANSFERRING DATA AND CHECK HASHES.</div><br/></div></div><div id="42901340" class="c"><input type="checkbox" id="c-42901340" checked=""/><div class="controls bullet"><span class="by">PaulKeeble</span><span>|</span><a href="#42901256">parent</a><span>|</span><a href="#42902894">prev</a><span>|</span><a href="#42901327">next</a><span>|</span><label class="collapse" for="c-42901340">[-]</label><label class="expand" for="c-42901340">[1 more]</label></div><br/><div class="children"><div class="content">I had bzip2 eat some files some years back and ended up loosing them. I don&#x27;t trust bzip2 for backup files and I wouldn&#x27;t trust bzip3 either as a result.</div><br/></div></div><div id="42901327" class="c"><input type="checkbox" id="c-42901327" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42901256">parent</a><span>|</span><a href="#42901340">prev</a><span>|</span><a href="#42901341">next</a><span>|</span><label class="collapse" for="c-42901327">[-]</label><label class="expand" for="c-42901327">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I think this may be part of why compression in flight has been a growth area in compression lately. If your transport encoding becomes garbled people notice immediately. If you manage to serve a few billion compressed requests without any incident reports then maybe you can trust it for data at rest.</div><br/></div></div><div id="42901341" class="c"><input type="checkbox" id="c-42901341" checked=""/><div class="controls bullet"><span class="by">supertrope</span><span>|</span><a href="#42901256">parent</a><span>|</span><a href="#42901327">prev</a><span>|</span><a href="#42901319">next</a><span>|</span><label class="collapse" for="c-42901341">[-]</label><label class="expand" for="c-42901341">[2 more]</label></div><br/><div class="children"><div class="content">A shell script to run a checksum on the original file, compress, uncompress, and verify output integrity should be trivial.</div><br/><div id="42901370" class="c"><input type="checkbox" id="c-42901370" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#42901256">root</a><span>|</span><a href="#42901341">parent</a><span>|</span><a href="#42901319">next</a><span>|</span><label class="collapse" for="c-42901370">[-]</label><label class="expand" for="c-42901370">[1 more]</label></div><br/><div class="children"><div class="content">I wonder why this isn&#x27;t inbuilt into the program..</div><br/></div></div></div></div><div id="42901319" class="c"><input type="checkbox" id="c-42901319" checked=""/><div class="controls bullet"><span class="by">cowsandmilk</span><span>|</span><a href="#42901256">parent</a><span>|</span><a href="#42901341">prev</a><span>|</span><label class="collapse" for="c-42901319">[-]</label><label class="expand" for="c-42901319">[1 more]</label></div><br/><div class="children"><div class="content">I mean, hosting downloads that have been compressed with this seems fine. I have the original, I just want a smaller version for those downloading.</div><br/></div></div></div></div></div></div></div></div></div></body></html>