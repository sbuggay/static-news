<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723626078522" as="style"/><link rel="stylesheet" href="styles.css?v=1723626078522"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://marabos.nl/atomics/">Rust Atomics and Locks (2023)</a> <span class="domain">(<a href="https://marabos.nl">marabos.nl</a>)</span></div><div class="subtext"><span>0xedb</span> | <span>42 comments</span></div><br/><div><div id="41241186" class="c"><input type="checkbox" id="c-41241186" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41240358">next</a><span>|</span><label class="collapse" for="c-41241186">[-]</label><label class="expand" for="c-41241186">[8 more]</label></div><br/><div class="children"><div class="content">Because this book was written more than a year ago, it spends some time on Windows Slim Reader Writer Locks, SRWLocks which at that time of its writing were how Rust&#x27;s Mutex and RwLock were implemented on Windows (by the author in fact IIRC).<p>Since then, two important things happened.<p>1. On Windows 8 and beyond Rust moved to WaitOnAddress with an API similar to the futex on several other systems.<p>2. We found out SRWLocks have a significant (arguably fatal, but depending on your use case it may seem irrelevant) difference between how they actually work and what Microsoft&#x27;s API said about them. This bug is fixed... in Microsoft&#x27;s own version control, not in released Windows versions.<p>Specifically SRWLocks may silently give you a Write Lock, even if you asked only for a Read Lock, in the case where the lock was just released at the moment you asked. If you were expecting other threads to <i>also</i> get a read lock, which would ordinarily be possible - too bad, you&#x27;ve secretly been given the exclusive write lock so read locks are unavailable until you release it.<p>The actual reason seems to be this: SRWLocks are small (a single pointer, with some low bits stolen to hide metadata) and the authors forgot that they actually know (because it&#x27;s a different function call) whether you asked for a <i>read</i> or a <i>write</i> lock. Since they didn&#x27;t have anywhere to store this single bit (read or write) they just assumed they don&#x27;t know in this edge case where the lock happens to be available immediately, and since they &quot;don&#x27;t know&quot; they always give you a write lock anyway. Oops.<p>[Edited to make minor clarifications]</div><br/><div id="41241324" class="c"><input type="checkbox" id="c-41241324" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41241186">parent</a><span>|</span><a href="#41241446">next</a><span>|</span><label class="collapse" for="c-41241324">[-]</label><label class="expand" for="c-41241324">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Specifically SRWLocks may silently give you a Write Lock, even if you asked only for a Read Lock, in the case where the lock was just released at the moment you asked.<p>Oh hey, I reported that bug and behavior! One of my proudest reports. Not too often you find a legit bug, or at least documentation oversight, in such a core API.</div><br/><div id="41242468" class="c"><input type="checkbox" id="c-41242468" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41241186">root</a><span>|</span><a href="#41241324">parent</a><span>|</span><a href="#41241700">next</a><span>|</span><label class="collapse" for="c-41242468">[-]</label><label class="expand" for="c-41242468">[1 more]</label></div><br/><div class="children"><div class="content">Definitely sounds like a legit bug to me! I&#x27;d only call this a &quot;documentation oversight&quot; in the sense that they could have the docs-equivalent of the fast-talking disclaimers at the end of commercials saying something like &quot;notactuallyareadwritelockmayormaynotallowconcurrentreadsdonotusewhenpregnantorbreastfeeedinguseatyourownrisk&quot;</div><br/></div></div><div id="41241700" class="c"><input type="checkbox" id="c-41241700" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41241186">root</a><span>|</span><a href="#41241324">parent</a><span>|</span><a href="#41242468">prev</a><span>|</span><a href="#41241446">next</a><span>|</span><label class="collapse" for="c-41241700">[-]</label><label class="expand" for="c-41241700">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve also only very rarely seen real bugs in core system features (deadlock inside glibc&#x27;s allocator a decade or more ago in my case IIRC) and I must say you got a much healthier reaction.<p>It&#x27;s definitely an actual bug not a doc bug. I&#x27;ve explained this a few times to people and it does seem like the natural inclination is to assume SRWLock must be supposed to do that, but I was glad to see internally Microsoft did fix this, because it&#x27;s clearly the Wrong Thing™.<p>I see two common defences for this bug. One is &quot;Actually, it&#x27;s <i>supposed</i> to be unfair, you don&#x27;t understand why that&#x27;s a good idea&quot;. Which assumes I&#x27;m expecting a fair lock and I&#x27;m unhappy not to get it. Giving a reader the <i>reader</i> lock when there&#x27;s a writer waiting would be unfair - and probably a bad idea but I&#x27;m open to it if somebody presents benchmarks - but giving them the <i>writer</i> lock is just a bug.<p>Another is &quot;Actually, there is a writer waiting, and this way that writer gets the lock faster&quot;. As you wrote the example code you know that&#x27;s false, there is no writer waiting, there are only readers and (in the buggy scenario) they&#x27;re blocked forever for no reason.</div><br/><div id="41241872" class="c"><input type="checkbox" id="c-41241872" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41241186">root</a><span>|</span><a href="#41241700">parent</a><span>|</span><a href="#41241446">next</a><span>|</span><label class="collapse" for="c-41241872">[-]</label><label class="expand" for="c-41241872">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I must say you got a much healthier reaction.<p>I definitely spent a lot of time carefully crafting the message and iterating on a minimal repro.<p>Writing on the internet requires a LOT of defensive effort. It’s very annoying but is what it is. I write blog posts and my secret goal is “high views, low comments”. Because most comments are “well ackchyually“.<p>For the Reddit thread it helped that I tagged u&#x2F;STL and he responded quickly in agreement. That was very intentional on my part! I’m still a little sad I didn’t get a Raymond Chen comment though!</div><br/><div id="41243581" class="c"><input type="checkbox" id="c-41243581" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41241186">root</a><span>|</span><a href="#41241872">parent</a><span>|</span><a href="#41241446">next</a><span>|</span><label class="collapse" for="c-41243581">[-]</label><label class="expand" for="c-41243581">[1 more]</label></div><br/><div class="children"><div class="content">Does Raymond comment on Reddit? That would feel like a personal achievement indeed.<p>One of the smallest pieces of work I&#x27;m proud of is a tool that automates the labor of Raymond&#x27;s &quot;The poor man&#x27;s way of identifying memory leaks&quot;. The part where you need to be familiar with how your data types look in memory isn&#x27;t automated, that&#x27;s on you, but my tool (leakdice because it replaces the hexadecimal dice I previously used for this in real life) picks a random page of heap in a chosen (Linux) process and shows you what&#x27;s in it, the rest is up to you as Raymond explains.</div><br/></div></div></div></div></div></div></div></div><div id="41241446" class="c"><input type="checkbox" id="c-41241446" checked=""/><div class="controls bullet"><span class="by">OptionOfT</span><span>|</span><a href="#41241186">parent</a><span>|</span><a href="#41241324">prev</a><span>|</span><a href="#41240358">next</a><span>|</span><label class="collapse" for="c-41241446">[-]</label><label class="expand" for="c-41241446">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve looked in the Rust issue tracker for SRWLocks but could only find older posts. Can you share some links?</div><br/><div id="41241614" class="c"><input type="checkbox" id="c-41241614" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41241186">root</a><span>|</span><a href="#41241446">parent</a><span>|</span><a href="#41240358">next</a><span>|</span><label class="collapse" for="c-41241614">[-]</label><label class="expand" for="c-41241614">[1 more]</label></div><br/><div class="children"><div class="content">SRWLocks are a Windows feature, not a Rust feature, so you&#x27;re looking in the wrong place.<p>Here&#x27;s STL&#x27;s (nominative determinism at work) GitHub issue for Microsoft&#x27;s C++ stdlib implementation about this <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;STL&#x2F;issues&#x2F;4448">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;STL&#x2F;issues&#x2F;4448</a><p>Here&#x27;s the C++ Reddit thread where the bug was shown: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;1b55686&#x2F;maybe_possible_bug_in_stdshared_mutex_on_windows&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;1b55686&#x2F;maybe_possible...</a><p>Here&#x27;s the Rust change which was merged for 1.78: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;121956&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;121956&#x2F;</a></div><br/></div></div></div></div></div></div><div id="41240358" class="c"><input type="checkbox" id="c-41240358" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#41241186">prev</a><span>|</span><a href="#41241024">next</a><span>|</span><label class="collapse" for="c-41240358">[-]</label><label class="expand" for="c-41240358">[3 more]</label></div><br/><div class="children"><div class="content">Even if you are not into Rust, I&#x27;d recommend this book if you want to get into low-level and&#x2F;or embedded programming. It&#x27;s an exceptionally well written introduction into the most important topics there and ~80% of the book are not specific to Rust (or can be transferred just as well to other languages).</div><br/><div id="41243049" class="c"><input type="checkbox" id="c-41243049" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#41240358">parent</a><span>|</span><a href="#41243949">next</a><span>|</span><label class="collapse" for="c-41243049">[-]</label><label class="expand" for="c-41243049">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this comment. I’ve had this book sitting on my To Be Read stack for about 10 months but kept bumping it down because I don’t use Rust, but the title and ToC was compelling enough for me to buy it and hope for non-Rust specific content. Even if your 80% estimate is 20% to large a guess, I’m definitely going to pull it up to the top of the stack and read it instead of passing it over.</div><br/></div></div><div id="41243949" class="c"><input type="checkbox" id="c-41243949" checked=""/><div class="controls bullet"><span class="by">self_awareness</span><span>|</span><a href="#41240358">parent</a><span>|</span><a href="#41243049">prev</a><span>|</span><a href="#41241024">next</a><span>|</span><label class="collapse" for="c-41243949">[-]</label><label class="expand" for="c-41243949">[1 more]</label></div><br/><div class="children"><div class="content">They can be transferred, but other languages have also other concepts
and other mechanisms of synchronization. This Rust book seems solid, but
I would not assume other languages to have the same mechanisms as in
Rust the same way I wouldn&#x27;t recomment using programming patterns from
other languages in Rust.</div><br/></div></div></div></div><div id="41241024" class="c"><input type="checkbox" id="c-41241024" checked=""/><div class="controls bullet"><span class="by">nutate</span><span>|</span><a href="#41240358">prev</a><span>|</span><a href="#41241047">next</a><span>|</span><label class="collapse" for="c-41241024">[-]</label><label class="expand" for="c-41241024">[1 more]</label></div><br/><div class="children"><div class="content">I wrote this in a review I believe, but this is one of the most comprehensive introductions to a good 80% of what could be considered a high performance computing education. It&#x27;s extremely well written, in the weeds, but not lost in them. If you&#x27;ve done heavy atomics and or locks in C or C++ or with Fortran libraries, this will help show you how rust prevents so many footguns at compile time.</div><br/></div></div><div id="41241047" class="c"><input type="checkbox" id="c-41241047" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#41241024">prev</a><span>|</span><a href="#41240323">next</a><span>|</span><label class="collapse" for="c-41241047">[-]</label><label class="expand" for="c-41241047">[7 more]</label></div><br/><div class="children"><div class="content">Any thoughts on the best way to express global locks in Rust?<p>A classic example is a set of bank accounts, atomically transacting with each other. Fine-grained per-account locking is possible, but risks deadlock due to lock ordering inversion. A simple solution is to replace per-account locks with a singleton global lock, covering all accounts. Any transaction must first acquire this lock, and now deadlock is impossible.<p>But this is an awkward fit for Rust, whose locks want to own the data they protect. What&#x27;s the best way to express a global lock, enforcing that certain data may only be accessed while the global lock is held?</div><br/><div id="41241263" class="c"><input type="checkbox" id="c-41241263" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41241047">parent</a><span>|</span><a href="#41241847">next</a><span>|</span><label class="collapse" for="c-41241263">[-]</label><label class="expand" for="c-41241263">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this <i>is</i> an awkward fit. There&#x27;s no reason it should be Mutex&lt;CustomerBankAccount&gt; it can be Mutex&lt;MyTransferToken&gt; or indeed Mutex&lt;()&gt; if you&#x27;re <i>really</i> sure you don&#x27;t actually want to lock any data.<p>One piece of advice I&#x27;d suggest is, write APIs which take that MyTransferToken to signify that you must take the lock before calling them, it can be a unit type (a Zero Size type, a struct with no members) at the start if you like, but I suspect you&#x27;ll find that across several functions which take that MyTransferToken you realise <i>actually</i> the data I was going to put in a separate parameter is really always accompanying that token, and so it might as well go inside the the MyTransferToken and before you know it your unit type that was just to ensure correct locking is in fact an object with important data protected by the lock.</div><br/></div></div><div id="41241847" class="c"><input type="checkbox" id="c-41241847" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41241047">parent</a><span>|</span><a href="#41241263">prev</a><span>|</span><a href="#41241099">next</a><span>|</span><label class="collapse" for="c-41241847">[-]</label><label class="expand" for="c-41241847">[1 more]</label></div><br/><div class="children"><div class="content">You would write<p><pre><code>    Mutex&lt;HashMap&lt;CustomerID, Account&gt;&gt;
</code></pre>
Instead of<p><pre><code>    HashMap&lt;CustomerID, Mutex&lt;Account&gt;&gt;
</code></pre>
Using a singleton is kind of overkill.<p>But in the real world you&#x27;d probably use a transactional database for this (there are a few in memory options) with retries.</div><br/></div></div><div id="41241099" class="c"><input type="checkbox" id="c-41241099" checked=""/><div class="controls bullet"><span class="by">returningfory2</span><span>|</span><a href="#41241047">parent</a><span>|</span><a href="#41241847">prev</a><span>|</span><a href="#41242563">next</a><span>|</span><label class="collapse" for="c-41241099">[-]</label><label class="expand" for="c-41241099">[1 more]</label></div><br/><div class="children"><div class="content">Maybe define a new type in a such way that only 1 value of that type can be instantiated, and then put that unique value in a mutex. Any function that needs to hold the global lock accepts a value of the new type. Calling the function involves providing the value, which is proof that you are holding the mutex.</div><br/></div></div><div id="41242563" class="c"><input type="checkbox" id="c-41242563" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41241047">parent</a><span>|</span><a href="#41241099">prev</a><span>|</span><a href="#41241163">next</a><span>|</span><label class="collapse" for="c-41242563">[-]</label><label class="expand" for="c-41242563">[1 more]</label></div><br/><div class="children"><div class="content">My first instinct would be to use a static instance of `LazyLock`[1] wrapping the data (or `OnceLock`[2] if needed). `LazyLock` only just got stabilized, and `OnceLock` only a bit less recently,  but both have equivalents available via the `once_cell`[3] package for a while.<p>[1]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;sync&#x2F;struct.LazyLock.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;sync&#x2F;struct.LazyLock.html</a>
[2]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;sync&#x2F;struct.OnceLock.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;sync&#x2F;struct.OnceLock.html</a>
[3]: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;once_cell" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;once_cell</a></div><br/></div></div><div id="41241163" class="c"><input type="checkbox" id="c-41241163" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#41241047">parent</a><span>|</span><a href="#41242563">prev</a><span>|</span><a href="#41241064">next</a><span>|</span><label class="collapse" for="c-41241163">[-]</label><label class="expand" for="c-41241163">[1 more]</label></div><br/><div class="children"><div class="content">Use ghost_cell&#x2F;qcell, and put the QCellOwner in a mutex. Acquiring the cell owner grants the ability to access the data, but doesn&#x27;t tie ownership.</div><br/></div></div><div id="41241064" class="c"><input type="checkbox" id="c-41241064" checked=""/><div class="controls bullet"><span class="by">lucasyvas</span><span>|</span><a href="#41241047">parent</a><span>|</span><a href="#41241163">prev</a><span>|</span><a href="#41240323">next</a><span>|</span><label class="collapse" for="c-41241064">[-]</label><label class="expand" for="c-41241064">[1 more]</label></div><br/><div class="children"><div class="content">If I’m understanding correctly can’t you lock on some other account criteria, like IDs? A Mutex does have to own the data but you can still decide what it owns.<p>When you lock, the returned MutexGuard is owned, so you can pass it around or return it and it’s only dropped when it ultimately goes out of scope.</div><br/></div></div></div></div><div id="41240323" class="c"><input type="checkbox" id="c-41240323" checked=""/><div class="controls bullet"><span class="by">ra0x3</span><span>|</span><a href="#41241047">prev</a><span>|</span><a href="#41240675">next</a><span>|</span><label class="collapse" for="c-41240323">[-]</label><label class="expand" for="c-41240323">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re into Rust and need a solid, no-fluff intro to atomics and locks, Mara Bos has you covered. It’s straight to the point, helping you nail down concurrency without the usual headache. Worth checking out if you&#x27;re serious about leveling up your Rust game.</div><br/></div></div><div id="41240675" class="c"><input type="checkbox" id="c-41240675" checked=""/><div class="controls bullet"><span class="by">raphar</span><span>|</span><a href="#41240323">prev</a><span>|</span><a href="#41240876">next</a><span>|</span><label class="collapse" for="c-41240675">[-]</label><label class="expand" for="c-41240675">[14 more]</label></div><br/><div class="children"><div class="content">Can you recommend any other book about the same subject but different programming language? Thanks!!!</div><br/><div id="41241187" class="c"><input type="checkbox" id="c-41241187" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#41240675">parent</a><span>|</span><a href="#41240936">next</a><span>|</span><label class="collapse" for="c-41241187">[-]</label><label class="expand" for="c-41241187">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Is Parallel Programming Hard, And, If So, What Can You Do About It?&quot; is one of the best books about atomics and concurrency, and my #2 recommendation. <a href="https:&#x2F;&#x2F;mirrors.edge.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;people&#x2F;paulmck&#x2F;perfbook&#x2F;perfbook.html" rel="nofollow">https:&#x2F;&#x2F;mirrors.edge.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;people&#x2F;paul...</a><p>My #1 actually isn&#x27;t a book at all, but the two &quot;atomic Weapons&quot; talks by Herb Sutter, which are extremely good. <a href="https:&#x2F;&#x2F;youtu.be&#x2F;A8eCGOqgvH4" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;A8eCGOqgvH4</a> <a href="https:&#x2F;&#x2F;youtu.be&#x2F;KeLBd2EJLOU" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;KeLBd2EJLOU</a></div><br/></div></div><div id="41240936" class="c"><input type="checkbox" id="c-41240936" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41240675">parent</a><span>|</span><a href="#41241187">prev</a><span>|</span><a href="#41240938">next</a><span>|</span><label class="collapse" for="c-41240936">[-]</label><label class="expand" for="c-41240936">[1 more]</label></div><br/><div class="children"><div class="content">I have used Rust a little, but this book was most useful to me when I was working on a concurrent data structure for an old C program. It’s a very good book for anyone writing low-level multi-threaded code in C or C++ as well as Rust, because they have basically the same primitives.<p>The only places I know where it isn’t applicable are the Linux kernel and Java, because their memory models and concurrency primitives predate and significantly differ from the Rust&#x2F;C++&#x2F;C models.<p>For the Linux memory model, there is Paul McKenney’s free book, “is parallel programming hard, and if so, what can you do about it?” <a href="https:&#x2F;&#x2F;cdn.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;people&#x2F;paulmck&#x2F;perfbook&#x2F;perfbook.html" rel="nofollow">https:&#x2F;&#x2F;cdn.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;people&#x2F;paulmck&#x2F;perfb...</a></div><br/></div></div><div id="41240938" class="c"><input type="checkbox" id="c-41240938" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41240675">parent</a><span>|</span><a href="#41240936">prev</a><span>|</span><a href="#41240821">next</a><span>|</span><label class="collapse" for="c-41240938">[-]</label><label class="expand" for="c-41240938">[5 more]</label></div><br/><div class="children"><div class="content">I guess there must be at least one book about the Java Memory Model, which is very different but fascinating? I don&#x27;t know of any specific books to recommend.<p>For many languages there is nothing resembling this, they tend to not get into the details Mara covers, if you get a mutex and maybe atomic arithmetic then they&#x27;re done.<p>If you wondered about C or C++, this book is the same content as for those languages but with Rust&#x27;s syntax. The discrepancy between Rust&#x27;s memory model and the memory model adopted in C++ 11 and subsequently C is mostly about a feature that&#x27;s not available in your C or C++ compiler and (which is why Rust doesn&#x27;t have it) probably won&#x27;t ever be.<p>C++   x.store(r1, std::memory_order_relaxed);<p>is literally the same thing as<p>Rust  x.store(r1, std::sync::atomic::Ordering::Relaxed);<p>The biggest syntax difference is that C++  x.store(r1) compiles, and in Rust it doesn&#x27;t. But, chances are after reading Mara&#x27;s book you will think it&#x27;s weird not to specify the Ordering needed and never use this uh, convenience.</div><br/><div id="41240974" class="c"><input type="checkbox" id="c-41240974" checked=""/><div class="controls bullet"><span class="by">freddierest</span><span>|</span><a href="#41240675">root</a><span>|</span><a href="#41240938">parent</a><span>|</span><a href="#41240821">next</a><span>|</span><label class="collapse" for="c-41240974">[-]</label><label class="expand" for="c-41240974">[4 more]</label></div><br/><div class="children"><div class="content">The classic for Java is &quot;Java Concurrency in Practice&quot;, a great book for more than just Java.<p>Java&#x27;s happens-before memory model is similar to C++&#x27;s.<p>I&#x27;ll prob get this book, if only for the memory model chapter.</div><br/><div id="41241012" class="c"><input type="checkbox" id="c-41241012" checked=""/><div class="controls bullet"><span class="by">ibraheemdev</span><span>|</span><a href="#41240675">root</a><span>|</span><a href="#41240974">parent</a><span>|</span><a href="#41240821">next</a><span>|</span><label class="collapse" for="c-41241012">[-]</label><label class="expand" for="c-41241012">[3 more]</label></div><br/><div class="children"><div class="content">Java atomics are actually sequentially consistent. C# relaxes this to acquire&#x2F;release. Though the general concept of happens-before is still immensely useful for learning atomics as sequential consistency is a superset of acquire&#x2F;release.</div><br/><div id="41241747" class="c"><input type="checkbox" id="c-41241747" checked=""/><div class="controls bullet"><span class="by">freddierest</span><span>|</span><a href="#41240675">root</a><span>|</span><a href="#41241012">parent</a><span>|</span><a href="#41240821">next</a><span>|</span><label class="collapse" for="c-41241747">[-]</label><label class="expand" for="c-41241747">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for correction&#x2F;clarification. Much as C# has a weaker memory model than Java, my mental model for memory models is weaker than I thought.<p>Where do Rust and C++ lie wrt C# and Java?</div><br/><div id="41242407" class="c"><input type="checkbox" id="c-41242407" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41240675">root</a><span>|</span><a href="#41241747">parent</a><span>|</span><a href="#41240821">next</a><span>|</span><label class="collapse" for="c-41242407">[-]</label><label class="expand" for="c-41242407">[1 more]</label></div><br/><div class="children"><div class="content">All of the memory models in question are based on data-race-free, which says (in essence) that as long as all cross-thread interactions follow happens-before, then you can act as if everybody is sequentially-consistent.<p>The original Java 5 memory model only offered sequentially-consistent atomics to establish cross-thread happens-before in a primitive way. The C++11 memory model added three more kinds of atomics: acquire&#x2F;release, consume&#x2F;release (which was essentially a mistake [1]), and relaxed atomics (which, to oversimplify, establish atomicity without happens-before). Pretty much every memory model since C++11--which includes the Rust memory model--has based its definition on that memory model, with most systems defaulting an otherwise unadorned atomic operation to sequentially-consistent. Even Java has retrofitted ways to get weaker atomic semantics [2].<p>As a practical matter, most atomics could probably safely default to acquire&#x2F;release over fully sequentially-consistent. The main difference between the two is that sequentially-consistent is safer if you&#x27;ve got multiple atomic variables in play (e.g., you&#x27;re going with some fancy lockless algorithm), whereas acquire&#x2F;release tends to largely be safe if there&#x27;s only one atomic variable of concern (e.g., you&#x27;re implementing locks of some kind).<p>[1] A consume operation is an acquire, but only for loads data-dependent on the load operation. This is supposed to represent a situation that requires no fences on any system not named Alpha, but it turns out for reasons™ that compilers cannot reliably preserve source-level data dependencies, so no compiler really implemented consume&#x2F;release.<p>[2] Even Java 5 may have had it in sun.misc.Unsafe; I was never familiar with that API, so I don&#x27;t know for certain.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41240821" class="c"><input type="checkbox" id="c-41240821" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#41240675">parent</a><span>|</span><a href="#41240938">prev</a><span>|</span><a href="#41243970">next</a><span>|</span><label class="collapse" for="c-41240821">[-]</label><label class="expand" for="c-41240821">[1 more]</label></div><br/><div class="children"><div class="content">&quot;C++ Concurrency in Action&quot; by Anthony Williams is solid.<p>Make sure you get the second edition, it is updated for C++17.<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;C-Concurrency-Action-Anthony-Williams-dp-1617294691&#x2F;dp&#x2F;1617294691&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;C-Concurrency-Action-Anthony-Williams...</a></div><br/></div></div><div id="41243970" class="c"><input type="checkbox" id="c-41243970" checked=""/><div class="controls bullet"><span class="by">self_awareness</span><span>|</span><a href="#41240675">parent</a><span>|</span><a href="#41240821">prev</a><span>|</span><a href="#41241851">next</a><span>|</span><label class="collapse" for="c-41243970">[-]</label><label class="expand" for="c-41243970">[1 more]</label></div><br/><div class="children"><div class="content">The book was already mentioned elswhere in this thread, but also a good,
skimmable source of information is simply in javadoc:<p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase%2F8%2Fdocs%2Fapi%2F%2F&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;package-summary.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase%2F8%2Fdocs%2Fapi%2F%2F&#x2F;java&#x2F;u...</a></div><br/></div></div><div id="41241851" class="c"><input type="checkbox" id="c-41241851" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#41240675">parent</a><span>|</span><a href="#41243970">prev</a><span>|</span><a href="#41240792">next</a><span>|</span><label class="collapse" for="c-41241851">[-]</label><label class="expand" for="c-41241851">[1 more]</label></div><br/><div class="children"><div class="content">Parallel and Concurrent Programming in Haskell<p><a href="https:&#x2F;&#x2F;simonmar.github.io&#x2F;pages&#x2F;pcph.html" rel="nofollow">https:&#x2F;&#x2F;simonmar.github.io&#x2F;pages&#x2F;pcph.html</a></div><br/></div></div><div id="41240792" class="c"><input type="checkbox" id="c-41240792" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#41240675">parent</a><span>|</span><a href="#41241851">prev</a><span>|</span><a href="#41240829">next</a><span>|</span><label class="collapse" for="c-41240792">[-]</label><label class="expand" for="c-41240792">[2 more]</label></div><br/><div class="children"><div class="content">This book!  There’s Rust specific parts but the knowledge you gain will transfer across languages.</div><br/><div id="41240843" class="c"><input type="checkbox" id="c-41240843" checked=""/><div class="controls bullet"><span class="by">raphar</span><span>|</span><a href="#41240675">root</a><span>|</span><a href="#41240792">parent</a><span>|</span><a href="#41240829">next</a><span>|</span><label class="collapse" for="c-41240843">[-]</label><label class="expand" for="c-41240843">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m reading this at the moment! but I also want to compare how well each language helps you develop concurrency solutions.</div><br/></div></div></div></div></div></div><div id="41240876" class="c"><input type="checkbox" id="c-41240876" checked=""/><div class="controls bullet"><span class="by">mbsai29</span><span>|</span><a href="#41240675">prev</a><span>|</span><a href="#41241277">next</a><span>|</span><label class="collapse" for="c-41240876">[-]</label><label class="expand" for="c-41240876">[2 more]</label></div><br/><div class="children"><div class="content">If you are working with async rust, this book is a must-read. Clearly explains most of the primitives that are used in rust like Arc, Mutex, etc. The examples in the github repo are quite helpful and fairly intuitive if you follow along.</div><br/><div id="41240944" class="c"><input type="checkbox" id="c-41240944" checked=""/><div class="controls bullet"><span class="by">freddierest</span><span>|</span><a href="#41240876">parent</a><span>|</span><a href="#41241277">next</a><span>|</span><label class="collapse" for="c-41240944">[-]</label><label class="expand" for="c-41240944">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s quite an escalation of topics for Rust.<p>If you want to write a HTTP server, people are guided towards Axum&#x2F;Tokio, and thus async rust.<p>If you want to use async Rust, read this book?<p>This books covers assembly level atomics, and creating your own channels, in beginner chapters.<p>Is that necessary for writing a HTTP server in Rust?<p>From the topics in the TOC, this book is useful of you want you write concurrency primitives. I wouldn&#x27;t recommend it if you just want to _use_ Arc&#x2F;Mutex&#x2F;crossbeam-channel.</div><br/></div></div></div></div><div id="41241277" class="c"><input type="checkbox" id="c-41241277" checked=""/><div class="controls bullet"><span class="by">skoocda</span><span>|</span><a href="#41240876">prev</a><span>|</span><a href="#41243442">next</a><span>|</span><label class="collapse" for="c-41241277">[-]</label><label class="expand" for="c-41241277">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done a precursory skim of this and plan to start reading it in earnest next week. Looks comprehensive and accessible. Very excited.</div><br/></div></div><div id="41243442" class="c"><input type="checkbox" id="c-41243442" checked=""/><div class="controls bullet"><span class="by">pythops</span><span>|</span><a href="#41241277">prev</a><span>|</span><a href="#41241936">next</a><span>|</span><label class="collapse" for="c-41243442">[-]</label><label class="expand" for="c-41243442">[1 more]</label></div><br/><div class="children"><div class="content">Amazing book !</div><br/></div></div><div id="41241936" class="c"><input type="checkbox" id="c-41241936" checked=""/><div class="controls bullet"><span class="by">quohort</span><span>|</span><a href="#41243442">prev</a><span>|</span><label class="collapse" for="c-41241936">[-]</label><label class="expand" for="c-41241936">[3 more]</label></div><br/><div class="children"><div class="content">Why do programming books always have some random unrelated illustration on the front?<p>Usually when you have a textbook, they will have some nice illustration that is tangentially related to the content of the book (like fibonacci spiral for a math book or some chemical reaction for a chemistry book for example). But I suppose that there isn&#x27;t really such an equivalent unless it&#x27;s a computer graphics book.<p>I guess it&#x27;s also like how every project has to have its own &quot;cutesey&quot; mascot.</div><br/><div id="41243997" class="c"><input type="checkbox" id="c-41243997" checked=""/><div class="controls bullet"><span class="by">self_awareness</span><span>|</span><a href="#41241936">parent</a><span>|</span><a href="#41241951">next</a><span>|</span><label class="collapse" for="c-41243997">[-]</label><label class="expand" for="c-41243997">[1 more]</label></div><br/><div class="children"><div class="content">This is mostly an O&#x27;Reilly thing.<p><a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;content&#x2F;a-short-history-of-the-oreilly-animals&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oreilly.com&#x2F;content&#x2F;a-short-history-of-the-oreil...</a><p>TL;DR:<p>&gt; Some of the people at O’Reilly were taken aback: they thought the animals were weird, ugly, and a bit scary. But Tim [O&#x27;Reilly] got it immediately—he liked the quirkiness of the animals, thought it would help to make the books stand out from other publishers’ offerings—and it just felt right.<p>They even have a browser which helps you identify the animal:<p><a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;animals.csp" rel="nofollow">https:&#x2F;&#x2F;www.oreilly.com&#x2F;animals.csp</a></div><br/></div></div><div id="41241951" class="c"><input type="checkbox" id="c-41241951" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#41241936">parent</a><span>|</span><a href="#41243997">prev</a><span>|</span><label class="collapse" for="c-41241951">[-]</label><label class="expand" for="c-41241951">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, especially that persnickety, &quot;The Programming Language&quot; book. Talk about obscure covers!<p>&#x2F;s<p>I think it&#x27;s just an O&#x27;Reilly thing. It keeps the people guessing.<p>Actually, the covers also make the books easily recognizable. Animals, statues, etc., are all good memory association drivers.</div><br/></div></div></div></div></div></div></div></div></div></body></html>