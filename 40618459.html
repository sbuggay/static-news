<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717923671388" as="style"/><link rel="stylesheet" href="styles.css?v=1717923671388"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fobes.dev/ps2/detecting-emu-vu-floats">Detecting a PS2 Emulator: When 1*X does not equal X</a> <span class="domain">(<a href="https://fobes.dev">fobes.dev</a>)</span></div><div class="subtext"><span>fobes</span> | <span>68 comments</span></div><br/><div><div id="40620274" class="c"><input type="checkbox" id="c-40620274" checked=""/><div class="controls bullet"><span class="by">mattbee</span><span>|</span><a href="#40619063">next</a><span>|</span><label class="collapse" for="c-40620274">[-]</label><label class="expand" for="c-40620274">[8 more]</label></div><br/><div class="children"><div class="content">The simplest trick for detecting old ARM emulation - ISTR was used on some Gameboy Advance copy protection: store a booby-trap instruction at PC+4 (i.e. the very next one).  A real ARM has a pipeline that reads PC+8, while decoding PC+4 and while executing at PC. So the newly-stored instruction should have no effect. An emulator (which didn&#x27;t emulate the hardware pipeline) would execute it.<p>edit: described in more detail here, among other emulation-busting measures from 2004 <a href="https:&#x2F;&#x2F;mgba.io&#x2F;&#x2F;2014&#x2F;12&#x2F;28&#x2F;classic-nes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mgba.io&#x2F;&#x2F;2014&#x2F;12&#x2F;28&#x2F;classic-nes&#x2F;</a></div><br/><div id="40620715" class="c"><input type="checkbox" id="c-40620715" checked=""/><div class="controls bullet"><span class="by">ekidd</span><span>|</span><a href="#40620274">parent</a><span>|</span><a href="#40621768">next</a><span>|</span><label class="collapse" for="c-40620715">[-]</label><label class="expand" for="c-40620715">[2 more]</label></div><br/><div class="children"><div class="content">The Texas Instrument TI320C40 digital signal processor had even weirder pipeline issues:<p>- Branch delay slots (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Delay_slot" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Delay_slot</a>), where one or more instruction(s) <i>after</i> a branch would be executed before the branch actually occurred.<p>- Load delay slots, where values stored into registers weren&#x27;t guaranteed to appear until some later instruction. I believe the the value in the register was undefined for several cycles?<p>Writing tightly-optimized assembly code for these chips was pretty horrible, sort of like playing an unusually tasteless Zachtronics clone.</div><br/><div id="40620797" class="c"><input type="checkbox" id="c-40620797" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40620274">root</a><span>|</span><a href="#40620715">parent</a><span>|</span><a href="#40621768">next</a><span>|</span><label class="collapse" for="c-40620797">[-]</label><label class="expand" for="c-40620797">[1 more]</label></div><br/><div class="children"><div class="content">It was also kinda awesome because, as long as you were willing to spend days to optimize one page of code, you could get <i>so much</i> performance out of it.<p>Things like deliberately using the fact that multiplies only write the results into a register ~6 cycles later, means you can use that register for a bunch of other stuff in the meantime, and then on the 6th cycle the results would magically appear.<p>Basically, for those 6 cycles, you had no registers in-use for either the source operands or destination of the multiplication.<p>Obviously this is also pipelinable - you can start more multiplies while the first is running, using the same source and destination registers, but meanwhile you&#x27;ve used other instructions to load more data into the inputs and do something else with the outputs.</div><br/></div></div></div></div><div id="40621768" class="c"><input type="checkbox" id="c-40621768" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40620274">parent</a><span>|</span><a href="#40620715">prev</a><span>|</span><a href="#40620455">next</a><span>|</span><label class="collapse" for="c-40621768">[-]</label><label class="expand" for="c-40621768">[1 more]</label></div><br/><div class="children"><div class="content">Another sibling comment here references it obliquely but on x86 the prefetch queue produces similar behaviour, until Intel decided to detect SMC on the Pentium and newer CPUs so that modifying the instruction about to be executed will always have an effect.<p>However, someone much later found another undetected edge-case: a self-overwriting repeated string instruction.<p><a href="https:&#x2F;&#x2F;silviocesare.wordpress.com&#x2F;2009&#x2F;02&#x2F;02&#x2F;anti-debugging-prefetch-tricks-and-single-stepping-through-a-rep-stosmovs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;silviocesare.wordpress.com&#x2F;2009&#x2F;02&#x2F;02&#x2F;anti-debugging...</a></div><br/></div></div><div id="40620455" class="c"><input type="checkbox" id="c-40620455" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#40620274">parent</a><span>|</span><a href="#40621768">prev</a><span>|</span><a href="#40620768">next</a><span>|</span><label class="collapse" for="c-40620455">[-]</label><label class="expand" for="c-40620455">[2 more]</label></div><br/><div class="children"><div class="content">Some pipelined CPUs have retained compatibility with self-modifying code and detect when you overwrite an instruction that is on the pipeline and flush it.<p>X86 has that machinery although I&#x27;m not sure if they dropped it eventually on the 64-bit variant.</div><br/><div id="40620927" class="c"><input type="checkbox" id="c-40620927" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#40620274">root</a><span>|</span><a href="#40620455">parent</a><span>|</span><a href="#40620768">next</a><span>|</span><label class="collapse" for="c-40620927">[-]</label><label class="expand" for="c-40620927">[1 more]</label></div><br/><div class="children"><div class="content">The rules and mechanisms for SMC detection are essentially the same in both modes as far as I am aware.<p>Both Intel and AMD implement SMC detection that is a bit stronger than required by the specification as well.</div><br/></div></div></div></div><div id="40620768" class="c"><input type="checkbox" id="c-40620768" checked=""/><div class="controls bullet"><span class="by">sergiotapia</span><span>|</span><a href="#40620274">parent</a><span>|</span><a href="#40620455">prev</a><span>|</span><a href="#40619063">next</a><span>|</span><label class="collapse" for="c-40620768">[-]</label><label class="expand" for="c-40620768">[2 more]</label></div><br/><div class="children"><div class="content">Is this why my ROM for Dragon Ball Z: The Legacy of Goku II didn&#x27;t work sometimes with visualboy advance?</div><br/><div id="40622136" class="c"><input type="checkbox" id="c-40622136" checked=""/><div class="controls bullet"><span class="by">IntelMiner</span><span>|</span><a href="#40620274">root</a><span>|</span><a href="#40620768">parent</a><span>|</span><a href="#40619063">next</a><span>|</span><label class="collapse" for="c-40622136">[-]</label><label class="expand" for="c-40622136">[1 more]</label></div><br/><div class="children"><div class="content">VisualBoyAdvance was (and is) absolute garbage in terms of accuracy and is loaded with delicious code execution exploits from boobytrapped roms<p>Use mGBA instead if you want to play Gameboy games in 2024</div><br/></div></div></div></div></div></div><div id="40619063" class="c"><input type="checkbox" id="c-40619063" checked=""/><div class="controls bullet"><span class="by">qbane</span><span>|</span><a href="#40620274">prev</a><span>|</span><a href="#40622633">next</a><span>|</span><label class="collapse" for="c-40619063">[-]</label><label class="expand" for="c-40619063">[20 more]</label></div><br/><div class="children"><div class="content">That is why emulating, when targeting 100% accuracy, is a craftsmanship in our industry. Not only do you need to know each and every quirk the original hardware&#x2F;software has, but you also need to replicate it, however peculiar it is. Consider the potential performance impact if itself is not challenging enough.</div><br/><div id="40619173" class="c"><input type="checkbox" id="c-40619173" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40619063">parent</a><span>|</span><a href="#40622633">next</a><span>|</span><label class="collapse" for="c-40619173">[-]</label><label class="expand" for="c-40619173">[19 more]</label></div><br/><div class="children"><div class="content">Emulators have to be pragmatic about accuracy, when emulating more modern systems it&#x27;s generally not feasible to target 100% hardware accuracy <i>and</i> usable performance, so they tend to accept compromises which are technically deviations from the real hardware but usually don&#x27;t make any observable difference in practice. Anything that uses a JIT recompiler is never going to be perfectly cycle-accurate to the original hardware but it usually doesn&#x27;t matter unless the game code is deliberately constructed to break emulators.<p>Dolphin had to reckon with that balance when a few commercial Wii games included such anti-emulator code, which abused details of the real Wii CPUs cache behavior. Technically they <i>could</i> have emulated the real CPU cache to make those games work seamlessly, but the performance overhead (likely a 10x slowdown) would make them unplayable, so they hacked around it instead.<p><a href="https:&#x2F;&#x2F;dolphin-emu.org&#x2F;blog&#x2F;2017&#x2F;02&#x2F;01&#x2F;dolphin-progress-report-january-2017&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dolphin-emu.org&#x2F;blog&#x2F;2017&#x2F;02&#x2F;01&#x2F;dolphin-progress-rep...</a></div><br/><div id="40619224" class="c"><input type="checkbox" id="c-40619224" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619173">parent</a><span>|</span><a href="#40619315">next</a><span>|</span><label class="collapse" for="c-40619224">[-]</label><label class="expand" for="c-40619224">[9 more]</label></div><br/><div class="children"><div class="content">I once wrote something that would hard lock cortex-A8 but not the cortex-A9 we shipped on. To my knowledge, nobody tracked down why our app, once exfiltrated from our device, would crash slightly older phones.</div><br/><div id="40619283" class="c"><input type="checkbox" id="c-40619283" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619224">parent</a><span>|</span><a href="#40619609">next</a><span>|</span><label class="collapse" for="c-40619283">[-]</label><label class="expand" for="c-40619283">[3 more]</label></div><br/><div class="children"><div class="content">Were you exploiting an A8 erratum, or detecting &quot;this is an A8&quot; somehow and then making it barf in a less processor specific way?</div><br/><div id="40622155" class="c"><input type="checkbox" id="c-40622155" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619283">parent</a><span>|</span><a href="#40619609">next</a><span>|</span><label class="collapse" for="c-40622155">[-]</label><label class="expand" for="c-40622155">[2 more]</label></div><br/><div class="children"><div class="content">A8 erratum. This was ages ago, but if I recall you could place a thumb2 instruction straddling two pages, only one of which was loaded in the TLBs. If you got everything right, the A8 would hang without trapping.<p>Edit: it was errata #657417, long since scrubbed from arm.com</div><br/><div id="40622774" class="c"><input type="checkbox" id="c-40622774" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40622155">parent</a><span>|</span><a href="#40619609">next</a><span>|</span><label class="collapse" for="c-40622774">[-]</label><label class="expand" for="c-40622774">[1 more]</label></div><br/><div class="children"><div class="content">The A8 errata doc is at <a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;prdc008070&#x2F;latest&#x2F;" rel="nofollow">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;prdc008070&#x2F;latest&#x2F;</a> these days and does have a description of 657417 with enough detail to make writing a reproducer possible. Instructions crossing page boundaries are tricky beasts :-)</div><br/></div></div></div></div></div></div><div id="40619609" class="c"><input type="checkbox" id="c-40619609" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619224">parent</a><span>|</span><a href="#40619283">prev</a><span>|</span><a href="#40619315">next</a><span>|</span><label class="collapse" for="c-40619609">[-]</label><label class="expand" for="c-40619609">[5 more]</label></div><br/><div class="children"><div class="content">So they&#x27;ll patch around it.<p>You&#x27;re just making your software worthless in the long run for some value probably less than 5 years, or creating a fun problem for an emu hacker.<p>Most of the significant losses to piracy monetarily isn&#x27;t emulation, it&#x27;s the chippers&#x2F;mods that bypass cloned media copy protection.<p>Which emulator authors have a lot more control over in bypassing</div><br/><div id="40620328" class="c"><input type="checkbox" id="c-40620328" checked=""/><div class="controls bullet"><span class="by">mikestew</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619609">parent</a><span>|</span><a href="#40619769">next</a><span>|</span><label class="collapse" for="c-40620328">[-]</label><label class="expand" for="c-40620328">[2 more]</label></div><br/><div class="children"><div class="content">You assume an anti-piracy attempt when GP, from my reading, made no such statement. More of a mystery, but who cares because the problem hardware wasn’t what they shipped on.</div><br/><div id="40620598" class="c"><input type="checkbox" id="c-40620598" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40620328">parent</a><span>|</span><a href="#40619769">next</a><span>|</span><label class="collapse" for="c-40620598">[-]</label><label class="expand" for="c-40620598">[1 more]</label></div><br/><div class="children"><div class="content">They used the word exfiltrate, it&#x27;s not a stretch.</div><br/></div></div></div></div><div id="40619769" class="c"><input type="checkbox" id="c-40619769" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619609">parent</a><span>|</span><a href="#40620328">prev</a><span>|</span><a href="#40619315">next</a><span>|</span><label class="collapse" for="c-40619769">[-]</label><label class="expand" for="c-40619769">[2 more]</label></div><br/><div class="children"><div class="content">If it hardlocked an A8 but not an A9, chances are very high that an emulator would run it with no problem, because nobody deliberately tries to emulate the kind of CPU bug that lets an app hardlock the CPU. GP appears to have been interested in deterring people from running their code on non-authorised real hardware at the time, not targeting emulator users.</div><br/><div id="40622207" class="c"><input type="checkbox" id="c-40622207" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619769">parent</a><span>|</span><a href="#40619315">next</a><span>|</span><label class="collapse" for="c-40622207">[-]</label><label class="expand" for="c-40622207">[1 more]</label></div><br/><div class="children"><div class="content">Bingo! Didn&#x27;t want someone running new product&#x27;s app on old product&#x27;s hardware. Company was new to building non-RTOS devices which were tightly hardware bound, wanted similar type restrictions.</div><br/></div></div></div></div></div></div></div></div><div id="40619315" class="c"><input type="checkbox" id="c-40619315" checked=""/><div class="controls bullet"><span class="by">FMecha</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619173">parent</a><span>|</span><a href="#40619224">prev</a><span>|</span><a href="#40620450">next</a><span>|</span><label class="collapse" for="c-40619315">[-]</label><label class="expand" for="c-40619315">[3 more]</label></div><br/><div class="children"><div class="content">&gt;but it usually doesn&#x27;t matter<p>When it comes to speedrunning: Some speedrunners do, though, to ensure their speedrun tech are reproducible on both emulators and real hardware.</div><br/><div id="40619341" class="c"><input type="checkbox" id="c-40619341" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619315">parent</a><span>|</span><a href="#40620450">next</a><span>|</span><label class="collapse" for="c-40619341">[-]</label><label class="expand" for="c-40619341">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, the small differences between a pragmatic &quot;accurate enough&quot; emulator and real hardware can matter for speedrunners. The difference between real hardware running at 60fps and a principled cycle-accurate emulator running at &lt;0.1fps would matter more, though.<p>For the SNES and earlier it&#x27;s feasible to have exceptional accuracy and still usable performance, but for anything modern it&#x27;s just not happening. Imagine trying to write a cycle-accurate emulator core for a modern CPU with instruction re-ordering, branch prediction, prefetching, asynchronous memory, etc, nevermind making it go fast.</div><br/><div id="40619968" class="c"><input type="checkbox" id="c-40619968" checked=""/><div class="controls bullet"><span class="by">FMecha</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619341">parent</a><span>|</span><a href="#40620450">next</a><span>|</span><label class="collapse" for="c-40619968">[-]</label><label class="expand" for="c-40619968">[1 more]</label></div><br/><div class="children"><div class="content">&gt;For the SNES and earlier<p>I think the cutline can be moved to the original PlayStation now.<p>&gt;but for anything modern it&#x27;s just not happening.<p>Which arguably explains a cultural rift in arcade emulation circles. MAME&#x27;s philosophy is about cycle-accuracy, which might work for bespoke arcade hardware up to early 3D systems, whether they&#x27;re bespoke (such as Namco&#x27;s System 22) or console-derived (Namco&#x27;s System 1x series, which all derive from the original PlayStation hardware) hardware.  For newer arcade titles, which are just beefed period PCs, such kind of emulation (philosophy) would not be suffice for gameplay.</div><br/></div></div></div></div></div></div><div id="40620450" class="c"><input type="checkbox" id="c-40620450" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619173">parent</a><span>|</span><a href="#40619315">prev</a><span>|</span><a href="#40620468">next</a><span>|</span><label class="collapse" for="c-40620450">[-]</label><label class="expand" for="c-40620450">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Anything that uses a JIT recompiler is never going to be perfectly cycle-accurate to the original hardware<p>beebjit [1] is a cycle-accurate JIT-based emulator for the BBC Micro.  It can be done.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;scarybeasts&#x2F;beebjit">https:&#x2F;&#x2F;github.com&#x2F;scarybeasts&#x2F;beebjit</a></div><br/><div id="40621896" class="c"><input type="checkbox" id="c-40621896" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40620450">parent</a><span>|</span><a href="#40620468">next</a><span>|</span><label class="collapse" for="c-40621896">[-]</label><label class="expand" for="c-40621896">[1 more]</label></div><br/><div class="children"><div class="content">That is not perfectly cycle-accurate, but it is accurate enough to run almost anything without issues.</div><br/></div></div></div></div><div id="40620468" class="c"><input type="checkbox" id="c-40620468" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40619173">parent</a><span>|</span><a href="#40620450">prev</a><span>|</span><a href="#40619194">next</a><span>|</span><label class="collapse" for="c-40620468">[-]</label><label class="expand" for="c-40620468">[3 more]</label></div><br/><div class="children"><div class="content">I wonder how mainframe emulators (that sometimes are used to run legacy, very critical software on modern hardware) manage to do it. Do they go for full complete emulation? As in, implementing the entire hardware in software?</div><br/><div id="40622736" class="c"><input type="checkbox" id="c-40622736" checked=""/><div class="controls bullet"><span class="by">Locutus_</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40620468">parent</a><span>|</span><a href="#40622484">next</a><span>|</span><label class="collapse" for="c-40622736">[-]</label><label class="expand" for="c-40622736">[1 more]</label></div><br/><div class="children"><div class="content">Most of those a JIT recompilers, Mainframe code doesn&#x27;t usually depend on instruction cycle timing to the level that say beam-racing game code does.</div><br/></div></div><div id="40622484" class="c"><input type="checkbox" id="c-40622484" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#40619063">root</a><span>|</span><a href="#40620468">parent</a><span>|</span><a href="#40622736">prev</a><span>|</span><a href="#40619194">next</a><span>|</span><label class="collapse" for="c-40622484">[-]</label><label class="expand" for="c-40622484">[1 more]</label></div><br/><div class="children"><div class="content">Mainframes typically execute batch processes on a CPU. Much simpler than a game console with a GPU. Cycle-accurate emulation is less relevant for mainframes.</div><br/></div></div></div></div></div></div></div></div><div id="40622633" class="c"><input type="checkbox" id="c-40622633" checked=""/><div class="controls bullet"><span class="by">claudex</span><span>|</span><a href="#40619063">prev</a><span>|</span><a href="#40619000">next</a><span>|</span><label class="collapse" for="c-40622633">[-]</label><label class="expand" for="c-40622633">[2 more]</label></div><br/><div class="children"><div class="content">Anyone else was lost with the title asking why a mouse or a keyboard should do math ? I spent to much time to find this about Playstation 2, not about Personal System&#x2F;2 ports used to connect mouse and keyboard.</div><br/><div id="40622972" class="c"><input type="checkbox" id="c-40622972" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40622633">parent</a><span>|</span><a href="#40619000">next</a><span>|</span><label class="collapse" for="c-40622972">[-]</label><label class="expand" for="c-40622972">[1 more]</label></div><br/><div class="children"><div class="content">No, one is PS2, the other is PS&#x2F;2.</div><br/></div></div></div></div><div id="40619000" class="c"><input type="checkbox" id="c-40619000" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#40622633">prev</a><span>|</span><a href="#40621329">next</a><span>|</span><label class="collapse" for="c-40619000">[-]</label><label class="expand" for="c-40619000">[16 more]</label></div><br/><div class="children"><div class="content">Interesting example of the kind of thing it&#x27;s probably not worth caring about in software emulation. Emulating the bug would be considerably slower.<p>Some day replicating the PS2 on an FPGA will be feasible, and then figuring out how this worked will be a fun project for someone.</div><br/><div id="40619626" class="c"><input type="checkbox" id="c-40619626" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#40619000">parent</a><span>|</span><a href="#40619022">next</a><span>|</span><label class="collapse" for="c-40619626">[-]</label><label class="expand" for="c-40619626">[6 more]</label></div><br/><div class="children"><div class="content">FPGA implementations are often implemented based on code or documentation from software emulation projects. An FPGA version of a PS2 has no guarantee of not implementing the same or similar bug.</div><br/><div id="40620227" class="c"><input type="checkbox" id="c-40620227" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40619626">parent</a><span>|</span><a href="#40619022">next</a><span>|</span><label class="collapse" for="c-40620227">[-]</label><label class="expand" for="c-40620227">[5 more]</label></div><br/><div class="children"><div class="content">The point here is that it is actually <i>viable</i> to reimplement such bugs without incurring significant performance penalties.<p>A software emulator has to be able to execute a single PS2 instruction in the same amount of wall time as it&#x27;d take on the original hardware. With a regular multiplication that&#x27;s fairly easy: x86 also has multiplication, so you can do a 1:1 translation and be fairly certain it&#x27;s within your time budget. With a <i>bugged</i> multiplication you need to do a regular x86 multiplication, and wrap that in a few dozen other instructions to add the buggy behaviour to it. There&#x27;s a pretty decent chance it&#x27;s simply too expensive!<p>When you&#x27;re writing an FPGA emulator you are able to recreate the buggy multiplication directly in hardware. There&#x27;s no additional wrapping needed, so (beyond figuring out intended behaviour) it&#x27;s not any more costly than emulating a non-buggy multiplication. It&#x27;s far easier to do a cycle-accurate emulation because you have direct control over the transistors!</div><br/><div id="40620452" class="c"><input type="checkbox" id="c-40620452" checked=""/><div class="controls bullet"><span class="by">gamepsys</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40620227">parent</a><span>|</span><a href="#40619022">next</a><span>|</span><label class="collapse" for="c-40620452">[-]</label><label class="expand" for="c-40620452">[4 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a pretty decent chance it&#x27;s simply too expensive!<p>I doubt the 24 year old, 300Mhz RISC, 32MB Ram, PS2 instruction set is too expensive to do a cycle perfect replication.</div><br/><div id="40620501" class="c"><input type="checkbox" id="c-40620501" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40620452">parent</a><span>|</span><a href="#40621033">next</a><span>|</span><label class="collapse" for="c-40620501">[-]</label><label class="expand" for="c-40620501">[1 more]</label></div><br/><div class="children"><div class="content">Higan is a cycle-perfect SNES emulator, and it&#x27;s very single-core CPU-intensive. This is what the FAQ [0] says:<p><i>Full-speed emulation for the Super Famicom base unit requires an Intel Core 2 Duo (or AMD equivalent), full-speed for games with the SuperFX chip requires an Intel Ivy Bridge (or equivalent), full-speed for the wireframe animations in Mega Man X2 requires an even faster computer. Low-power CPUs like ARM chips, or Intel Atom and Celeron CPUS generally aren’t fast enough to emulate the Super Famicom with higan, although other emulated consoles may work.</i><p>Work can&#x27;t be split across cores (according to the FAQ) because that would compromise the accuracy of the timing.<p>It may be that the PS2 has similar problems while being more powerful than the SNES.<p>[0]: <a href="https:&#x2F;&#x2F;higan.readthedocs.io&#x2F;en&#x2F;v104b&#x2F;faq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;higan.readthedocs.io&#x2F;en&#x2F;v104b&#x2F;faq&#x2F;</a></div><br/></div></div><div id="40621033" class="c"><input type="checkbox" id="c-40621033" checked=""/><div class="controls bullet"><span class="by">redox99</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40620452">parent</a><span>|</span><a href="#40620501">prev</a><span>|</span><a href="#40621979">next</a><span>|</span><label class="collapse" for="c-40621033">[-]</label><label class="expand" for="c-40621033">[1 more]</label></div><br/><div class="children"><div class="content">Idk about PS2, but N64 (a generation older, much slower) still doesn&#x27;t have a cycle perfect emulator that runs in real time.<p>Remember that you can&#x27;t just perfectly emulate the CPU, you must also perfectly emulate the GPU, since they share the memory bus so one can slow the other.</div><br/></div></div><div id="40621979" class="c"><input type="checkbox" id="c-40621979" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40620452">parent</a><span>|</span><a href="#40621033">prev</a><span>|</span><a href="#40619022">next</a><span>|</span><label class="collapse" for="c-40621979">[-]</label><label class="expand" for="c-40621979">[1 more]</label></div><br/><div class="children"><div class="content">You would probably need a terahertz CPU for cycle-accurate PS2 emulation.<p>Cycle-accurate PS2 emulation means emulating the state of the CPU, GPU, other interacting processors, and their various interconnecting busses at clock cycle granularity and possibly at sub-cycle granularity if the processors are running asynchronously.</div><br/></div></div></div></div></div></div></div></div><div id="40619022" class="c"><input type="checkbox" id="c-40619022" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40619000">parent</a><span>|</span><a href="#40619626">prev</a><span>|</span><a href="#40619782">next</a><span>|</span><label class="collapse" for="c-40619022">[-]</label><label class="expand" for="c-40619022">[1 more]</label></div><br/><div class="children"><div class="content">Depends on whether the bug breaks games or not.</div><br/></div></div><div id="40619782" class="c"><input type="checkbox" id="c-40619782" checked=""/><div class="controls bullet"><span class="by">fobes</span><span>|</span><a href="#40619000">parent</a><span>|</span><a href="#40619022">prev</a><span>|</span><a href="#40619876">next</a><span>|</span><label class="collapse" for="c-40619782">[-]</label><label class="expand" for="c-40619782">[1 more]</label></div><br/><div class="children"><div class="content">Fixing this bug would be part of fixing a bunch of other floating point bugs, more specifically rounding and clamping.<p>Yes, software floating point would be slower, but the general solution would probably follow the PS4s PS2 emulator. Where each game can have whitelisted sections of code for the software floating point path.</div><br/></div></div><div id="40619876" class="c"><input type="checkbox" id="c-40619876" checked=""/><div class="controls bullet"><span class="by">b3orn</span><span>|</span><a href="#40619000">parent</a><span>|</span><a href="#40619782">prev</a><span>|</span><a href="#40621329">next</a><span>|</span><label class="collapse" for="c-40619876">[-]</label><label class="expand" for="c-40619876">[7 more]</label></div><br/><div class="children"><div class="content">Why would you want to emulate an old crappy MIPS CPU using a relatively expensive FPGA? The whole idea of emulating old consoles is to be independent of the hardware so you can play your old games on your computer or phone.</div><br/><div id="40620079" class="c"><input type="checkbox" id="c-40620079" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40619876">parent</a><span>|</span><a href="#40620253">next</a><span>|</span><label class="collapse" for="c-40620079">[-]</label><label class="expand" for="c-40620079">[4 more]</label></div><br/><div class="children"><div class="content">For you, maybe. For others, having thing that does what this other thing did, with no regard to cost, is a fun adventure, in and of itself.</div><br/><div id="40620295" class="c"><input type="checkbox" id="c-40620295" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40620079">parent</a><span>|</span><a href="#40620244">next</a><span>|</span><label class="collapse" for="c-40620295">[-]</label><label class="expand" for="c-40620295">[1 more]</label></div><br/><div class="children"><div class="content">I second that. I wrote a nes emulator twenty years ago because it was fun, and not for any practical purpose. I had no idea what I was doing, but I remember being in awe of the nes after reading the detailed hw spec ( found on zophars domain, doc by yoshi if memory serves me well ). I promptly decided to write an emulator in whatever language I was learning at that time.<p>The result was terrible, but I had tremendous fun!</div><br/></div></div><div id="40620244" class="c"><input type="checkbox" id="c-40620244" checked=""/><div class="controls bullet"><span class="by">b3orn</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40620079">parent</a><span>|</span><a href="#40620295">prev</a><span>|</span><a href="#40620253">next</a><span>|</span><label class="collapse" for="c-40620244">[-]</label><label class="expand" for="c-40620244">[2 more]</label></div><br/><div class="children"><div class="content">In that case I&#x27;m sure current FPGAs are already capable of emulating the MIPS CPU of a PS2.</div><br/><div id="40620366" class="c"><input type="checkbox" id="c-40620366" checked=""/><div class="controls bullet"><span class="by">aeyes</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40620244">parent</a><span>|</span><a href="#40620253">next</a><span>|</span><label class="collapse" for="c-40620366">[-]</label><label class="expand" for="c-40620366">[1 more]</label></div><br/><div class="children"><div class="content">The CPU yes but you want to emulate every piece of hardware in the console. The audio chips, the GPU, they way video memory works and so on.</div><br/></div></div></div></div></div></div><div id="40620253" class="c"><input type="checkbox" id="c-40620253" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40619876">parent</a><span>|</span><a href="#40620079">prev</a><span>|</span><a href="#40620352">next</a><span>|</span><label class="collapse" for="c-40620253">[-]</label><label class="expand" for="c-40620253">[1 more]</label></div><br/><div class="children"><div class="content">Because the implementation on your computer or phone behaves <i>slightly</i> differently from actual hardware, sometimes to the point of being unplayable. If you can&#x27;t get your hands on a genuine working console, cycle-accurate FPGA implementation is the next best thing.</div><br/></div></div><div id="40620352" class="c"><input type="checkbox" id="c-40620352" checked=""/><div class="controls bullet"><span class="by">7thpower</span><span>|</span><a href="#40619000">root</a><span>|</span><a href="#40619876">parent</a><span>|</span><a href="#40620253">prev</a><span>|</span><a href="#40621329">next</a><span>|</span><label class="collapse" for="c-40620352">[-]</label><label class="expand" for="c-40620352">[1 more]</label></div><br/><div class="children"><div class="content">Often the games I’m excited to play run like shit and have timing issues that are difficult to measure but feel wrong and diminish the nostalgia.<p>Free time is scarce, so I’ll gladly pay a couple hundred to not have to spend time fiddling with settings only to ultimately capitulate.</div><br/></div></div></div></div></div></div><div id="40621329" class="c"><input type="checkbox" id="c-40621329" checked=""/><div class="controls bullet"><span class="by">dudeinjapan</span><span>|</span><a href="#40619000">prev</a><span>|</span><a href="#40618460">next</a><span>|</span><label class="collapse" for="c-40621329">[-]</label><label class="expand" for="c-40621329">[6 more]</label></div><br/><div class="children"><div class="content">Terrence Howard was right!</div><br/><div id="40621341" class="c"><input type="checkbox" id="c-40621341" checked=""/><div class="controls bullet"><span class="by">wsintra2022</span><span>|</span><a href="#40621329">parent</a><span>|</span><a href="#40621526">next</a><span>|</span><label class="collapse" for="c-40621341">[-]</label><label class="expand" for="c-40621341">[4 more]</label></div><br/><div class="children"><div class="content">I came for this comment and there you are! Bravo</div><br/><div id="40621706" class="c"><input type="checkbox" id="c-40621706" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#40621329">root</a><span>|</span><a href="#40621341">parent</a><span>|</span><a href="#40621526">next</a><span>|</span><label class="collapse" for="c-40621706">[-]</label><label class="expand" for="c-40621706">[3 more]</label></div><br/><div class="children"><div class="content">what&#x27;s the reference?</div><br/><div id="40621900" class="c"><input type="checkbox" id="c-40621900" checked=""/><div class="controls bullet"><span class="by">blharr</span><span>|</span><a href="#40621329">root</a><span>|</span><a href="#40621706">parent</a><span>|</span><a href="#40621526">next</a><span>|</span><label class="collapse" for="c-40621900">[-]</label><label class="expand" for="c-40621900">[2 more]</label></div><br/><div class="children"><div class="content">Terrence Howard (actor in Ironman, Empire TV show, etc) believes he has discovered &quot;a new math&quot; where 1x1=2. I believe he has gained recent notoriety because he was on the Joe Rogan podcast, where he got a platform to say his beliefs to many people, but he has had these beliefs for many years.<p>As far as I can tell, his reasoning is literally that 2x2=4, so if you divide both sides by 2, you get 1x1=2.</div><br/><div id="40622453" class="c"><input type="checkbox" id="c-40622453" checked=""/><div class="controls bullet"><span class="by">huygens6363</span><span>|</span><a href="#40621329">root</a><span>|</span><a href="#40621900">parent</a><span>|</span><a href="#40621526">next</a><span>|</span><label class="collapse" for="c-40622453">[-]</label><label class="expand" for="c-40622453">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, there went my morning. That was quite the rabbit hole. I’m now confused and sad.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40620935" class="c"><input type="checkbox" id="c-40620935" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#40618460">prev</a><span>|</span><a href="#40618898">next</a><span>|</span><label class="collapse" for="c-40620935">[-]</label><label class="expand" for="c-40620935">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t tell Terrence Howard...</div><br/></div></div></div></div></div></div></div></body></html>