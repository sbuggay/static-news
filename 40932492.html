<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720688470030" as="style"/><link rel="stylesheet" href="styles.css?v=1720688470030"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://codeberg.org/201984/dut">Show HN: Dut, a fast Linux disk usage calculator</a> <span class="domain">(<a href="https://codeberg.org">codeberg.org</a>)</span></div><div class="subtext"><span>201984</span> | <span>80 comments</span></div><br/><div><div id="40934720" class="c"><input type="checkbox" id="c-40934720" checked=""/><div class="controls bullet"><span class="by">Neil44</span><span>|</span><a href="#40934590">next</a><span>|</span><label class="collapse" for="c-40934720">[-]</label><label class="expand" for="c-40934720">[1 more]</label></div><br/><div class="children"><div class="content">On Windows I always used to use Windirstat but it was slow, then I found Wiztree which is many orders of magnitude faster. I understand it works by directly reading the NTFS tables rather than spidering through the directories laboriously. I wonder if this approach would work for ext4 or whatever.</div><br/></div></div><div id="40934590" class="c"><input type="checkbox" id="c-40934590" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#40934720">prev</a><span>|</span><a href="#40934256">next</a><span>|</span><label class="collapse" for="c-40934590">[-]</label><label class="expand" for="c-40934590">[5 more]</label></div><br/><div class="children"><div class="content">&gt; but I don&#x27;t like how unintuitive the readout is<p>The best disk usage UI I ever saw was this one: <a href="https:&#x2F;&#x2F;www.trishtech.com&#x2F;2013&#x2F;10&#x2F;scanner-display-hard-disk-usage-in-chart-form&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.trishtech.com&#x2F;2013&#x2F;10&#x2F;scanner-display-hard-disk-...</a> The inner circle is the top level directories, and each ring outwards is one level deeper in the directory heirarchy. You would mouse over large subdirectories to see what they were, or double click to drilldown into a subdirectory. Download it and try it - it is quite spectacularly useful on Windows (although I&#x27;m not sure how well it handles Terabyte size drives - I haven&#x27;t used Windows for a long time).<p>Hard to do a circular graph in a terminal...<p>It is very similar to a flame graph? Perhaps look at how flame graphs are drawn by other terminal performance tools.</div><br/><div id="40934617" class="c"><input type="checkbox" id="c-40934617" checked=""/><div class="controls bullet"><span class="by">pricechild</span><span>|</span><a href="#40934590">parent</a><span>|</span><a href="#40934697">next</a><span>|</span><label class="collapse" for="c-40934617">[-]</label><label class="expand" for="c-40934617">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Disk Usage Analyser&quot; &#x2F; &quot;Baobab&quot; on Linux is awesome with the same UI: <a href="https:&#x2F;&#x2F;apps.gnome.org&#x2F;en-GB&#x2F;Baobab&#x2F;" rel="nofollow">https:&#x2F;&#x2F;apps.gnome.org&#x2F;en-GB&#x2F;Baobab&#x2F;</a></div><br/></div></div><div id="40934697" class="c"><input type="checkbox" id="c-40934697" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#40934590">parent</a><span>|</span><a href="#40934617">prev</a><span>|</span><a href="#40934652">next</a><span>|</span><label class="collapse" for="c-40934697">[-]</label><label class="expand" for="c-40934697">[2 more]</label></div><br/><div class="children"><div class="content">DaisyDisk on mac does that. Also it&#x27;s blazing fast, it seems to even beat &quot;du&quot; so I don&#x27;t know what tricks they&#x27;re pulling.</div><br/><div id="40934746" class="c"><input type="checkbox" id="c-40934746" checked=""/><div class="controls bullet"><span class="by">supernes</span><span>|</span><a href="#40934590">root</a><span>|</span><a href="#40934697">parent</a><span>|</span><a href="#40934652">next</a><span>|</span><label class="collapse" for="c-40934746">[-]</label><label class="expand" for="c-40934746">[1 more]</label></div><br/><div class="children"><div class="content">I think they&#x27;re reading some of the info from Spotlight metadata already collected by the OS for indexing, but I could be wrong.</div><br/></div></div></div></div><div id="40934652" class="c"><input type="checkbox" id="c-40934652" checked=""/><div class="controls bullet"><span class="by">rlue</span><span>|</span><a href="#40934590">parent</a><span>|</span><a href="#40934697">prev</a><span>|</span><a href="#40934256">next</a><span>|</span><label class="collapse" for="c-40934652">[-]</label><label class="expand" for="c-40934652">[1 more]</label></div><br/><div class="children"><div class="content">That’s called a ring chart or a sunburst chart.</div><br/></div></div></div></div><div id="40934256" class="c"><input type="checkbox" id="c-40934256" checked=""/><div class="controls bullet"><span class="by">INTPenis</span><span>|</span><a href="#40934590">prev</a><span>|</span><a href="#40934778">next</a><span>|</span><label class="collapse" for="c-40934256">[-]</label><label class="expand" for="c-40934256">[6 more]</label></div><br/><div class="children"><div class="content">Reminds me of someone&#x27;s script I have been using for over a decade.<p><pre><code>    #&#x2F;bin&#x2F;sh
    du -k --max-depth=1 &quot;$@&quot; | sort -nr | awk &#x27;
         BEGIN {
            split(&quot;KB,MB,GB,TB&quot;, Units, &quot;,&quot;);
         }
         {
            u = 1;
            while ($1 &gt;= 1024) {
               $1 = $1 &#x2F; 1024;
               u += 1
            }
            $1 = sprintf(&quot;%.1f %s&quot;, $1, Units[u]);
            print $0;
         }
        &#x27;</code></pre></div><br/><div id="40934465" class="c"><input type="checkbox" id="c-40934465" checked=""/><div class="controls bullet"><span class="by">mshook</span><span>|</span><a href="#40934256">parent</a><span>|</span><a href="#40934740">next</a><span>|</span><label class="collapse" for="c-40934465">[-]</label><label class="expand" for="c-40934465">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand the point of the script, it&#x27;s nothing more than:<p><pre><code>  du -h --max-depth=1 &quot;$@&quot; | sort -hr</code></pre></div><br/><div id="40934499" class="c"><input type="checkbox" id="c-40934499" checked=""/><div class="controls bullet"><span class="by">out-of-ideas</span><span>|</span><a href="#40934256">root</a><span>|</span><a href="#40934465">parent</a><span>|</span><a href="#40934630">next</a><span>|</span><label class="collapse" for="c-40934499">[-]</label><label class="expand" for="c-40934499">[1 more]</label></div><br/><div class="children"><div class="content">`-h` is not available in all `sort` implementations</div><br/></div></div><div id="40934630" class="c"><input type="checkbox" id="c-40934630" checked=""/><div class="controls bullet"><span class="by">dotancohen</span><span>|</span><a href="#40934256">root</a><span>|</span><a href="#40934465">parent</a><span>|</span><a href="#40934499">prev</a><span>|</span><a href="#40934740">next</a><span>|</span><label class="collapse" for="c-40934630">[-]</label><label class="expand" for="c-40934630">[1 more]</label></div><br/><div class="children"><div class="content">The point is that it is faster.</div><br/></div></div></div></div><div id="40934740" class="c"><input type="checkbox" id="c-40934740" checked=""/><div class="controls bullet"><span class="by">kelahcim</span><span>|</span><a href="#40934256">parent</a><span>|</span><a href="#40934465">prev</a><span>|</span><a href="#40934469">next</a><span>|</span><label class="collapse" for="c-40934740">[-]</label><label class="expand" for="c-40934740">[1 more]</label></div><br/><div class="children"><div class="content">I will definitely try this one and compare with my daily stuff<p>`du -s -k * | sort -r -n -k1,1 -t&quot; &quot;`</div><br/></div></div><div id="40934469" class="c"><input type="checkbox" id="c-40934469" checked=""/><div class="controls bullet"><span class="by">matzf</span><span>|</span><a href="#40934256">parent</a><span>|</span><a href="#40934740">prev</a><span>|</span><a href="#40934778">next</a><span>|</span><label class="collapse" for="c-40934469">[-]</label><label class="expand" for="c-40934469">[1 more]</label></div><br/><div class="children"><div class="content">Any particular reason for doing the human readable units &quot;manually&quot;? `du -h | sort -h` works just fine.</div><br/></div></div></div></div><div id="40934778" class="c"><input type="checkbox" id="c-40934778" checked=""/><div class="controls bullet"><span class="by">tiku</span><span>|</span><a href="#40934256">prev</a><span>|</span><a href="#40933207">next</a><span>|</span><label class="collapse" for="c-40934778">[-]</label><label class="expand" for="c-40934778">[1 more]</label></div><br/><div class="children"><div class="content">Ncdu is easy to remember and use, clicking through etc. would be cool to find a faster replacement, same usage instead of a new tool with parameters to remember..</div><br/></div></div><div id="40933207" class="c"><input type="checkbox" id="c-40933207" checked=""/><div class="controls bullet"><span class="by">montroser</span><span>|</span><a href="#40934778">prev</a><span>|</span><a href="#40934005">next</a><span>|</span><label class="collapse" for="c-40933207">[-]</label><label class="expand" for="c-40933207">[14 more]</label></div><br/><div class="children"><div class="content">Nice work.  Some times I wonder if there&#x27;s any way to trade away accuracy for speed?  Like, often I don&#x27;t care _exactly_ how many bytes is the biggest user of space, but I just want to see some orders of magnitude.<p>Maybe there could be an iterative breadth-first approach, where first you quickly identify and discard the small unimportant items, passing over anything that can&#x27;t be counted quickly.  Then with what&#x27;s left you identify the smallest of those and discard, and then with what&#x27;s left the smallest of those, and repeat and repeat.  Each pass through, you get a higher resolution picture of which directories and files are using the most space, and you just wait until you have the level of detail you need, but you get to see the tally as it happens across the board.  Does this exist?</div><br/><div id="40933613" class="c"><input type="checkbox" id="c-40933613" checked=""/><div class="controls bullet"><span class="by">mos_basik</span><span>|</span><a href="#40933207">parent</a><span>|</span><a href="#40933235">next</a><span>|</span><label class="collapse" for="c-40933613">[-]</label><label class="expand" for="c-40933613">[3 more]</label></div><br/><div class="children"><div class="content">Something like that exists for btrfs; it&#x27;s called bdtu. It has the accuracy&#x2F;time trade-off you&#x27;re interested in, but the implementation is quite different. It samples random points on the disk and finds out what file path they belong to. The longer it runs the more accurate it gets. The readme is good at explaining why this approach makes sense for btrfs and what its limitations are.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;CyberShadow&#x2F;btdu">https:&#x2F;&#x2F;github.com&#x2F;CyberShadow&#x2F;btdu</a></div><br/><div id="40933789" class="c"><input type="checkbox" id="c-40933789" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933613">parent</a><span>|</span><a href="#40933659">next</a><span>|</span><label class="collapse" for="c-40933789">[-]</label><label class="expand" for="c-40933789">[1 more]</label></div><br/><div class="children"><div class="content">Damn, `ext4` is organized differently entirely. You can&#x27;t get anything useful from:<p><pre><code>    sudo debugfs -R &quot;icheck $RANDOM&quot; &#x2F;dev&#x2F;nvme1
    sudo debugfs -R &quot;ncheck $res&quot; &#x2F;dev&#x2F;nvme1
</code></pre>
and recursing. That&#x27;s a clever technique given btrfs structs.</div><br/></div></div><div id="40933659" class="c"><input type="checkbox" id="c-40933659" checked=""/><div class="controls bullet"><span class="by">jszymborski</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933613">parent</a><span>|</span><a href="#40933789">prev</a><span>|</span><a href="#40933235">next</a><span>|</span><label class="collapse" for="c-40933659">[-]</label><label class="expand" for="c-40933659">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s so cool.</div><br/></div></div></div></div><div id="40933235" class="c"><input type="checkbox" id="c-40933235" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933207">parent</a><span>|</span><a href="#40933613">prev</a><span>|</span><a href="#40933238">next</a><span>|</span><label class="collapse" for="c-40933235">[-]</label><label class="expand" for="c-40933235">[3 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>What you described is a neat idea, but it&#x27;s not possible with any degree of accuracy AFAIK. To give you a picture of the problem, calculating the disk usage of a directory requires calling statx(2) on every file in that directory, summing up the reported sizes, and then recursing into every subdirectory and starting over. The problem with doing a partial search is that all the data is at the leaves of the tree, so you&#x27;ll miss some potentially very large files.<p>Picture if your program only traversed the first, say, three levels of subdirectories to get a rough estimate. If there was a 1TB file down another level, your program would miss it completely and get a <i>very</i> innaccurate estimate of the disk usage, so it wouldn&#x27;t be useful at all for finding the biggest culprits. You have the same problem if you decide to stop counting after seeing N files, since file N+1 could be gigantic and you&#x27;d never know.</div><br/><div id="40933449" class="c"><input type="checkbox" id="c-40933449" checked=""/><div class="controls bullet"><span class="by">montroser</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933235">parent</a><span>|</span><a href="#40933238">next</a><span>|</span><label class="collapse" for="c-40933449">[-]</label><label class="expand" for="c-40933449">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, maybe approximation is not really possible.  But it still seems like if you could do say, up to 1000 stats per directory per pass, then running totals could be accumulated incrementally and reported along the way.<p>So after just a second or two, you might be able to know with certainty that a bunch of small directories are small, and then that a handful of others are at least however big has been counted so far.  And that could be all you need, or else you could wait longer to see how the bigger directories play out.</div><br/><div id="40933548" class="c"><input type="checkbox" id="c-40933548" checked=""/><div class="controls bullet"><span class="by">geertj</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933449">parent</a><span>|</span><a href="#40933238">next</a><span>|</span><label class="collapse" for="c-40933548">[-]</label><label class="expand" for="c-40933548">[1 more]</label></div><br/><div class="children"><div class="content">You would still have to getdents() everything but this way you may indeed save on stat() operations, which access information that is stored separately on disk and eliminating these would likely help uncached runs.<p>You could sample files in a directory or across directories to get an average file size and use the total number of files from getdents to estimate a total size. This does require you to know if a directory entry is a file or directory, which the d_type field gives you depending on the OS, file system and other factors. An average file size could also be obtained from statvfs().<p>Another trick is based on the fact that the link count of a directory is 2 + the number of subdirectories. Once you have seen the corresponding number of subdirectories, you know that there are no more subdirectories you need to descend into. This could allow you to abort a getdents for a very large directory, using eg the directory size to estimate the total entries.</div><br/></div></div></div></div></div></div><div id="40933238" class="c"><input type="checkbox" id="c-40933238" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#40933207">parent</a><span>|</span><a href="#40933235">prev</a><span>|</span><a href="#40933668">next</a><span>|</span><label class="collapse" for="c-40933238">[-]</label><label class="expand" for="c-40933238">[3 more]</label></div><br/><div class="children"><div class="content">This seems difficult since I&#x27;m not aware of any way to get approximate file sizes, at least with the usual FS-agnostic system calls: to get any size info you are pretty much calling something in the `stat` family and at that point you have the exact size.</div><br/><div id="40933280" class="c"><input type="checkbox" id="c-40933280" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933238">parent</a><span>|</span><a href="#40933668">next</a><span>|</span><label class="collapse" for="c-40933280">[-]</label><label class="expand" for="c-40933280">[2 more]</label></div><br/><div class="children"><div class="content">i thought files can be sparse and have holes in the middle where nothing is allocated, so the file size is not what is used to calculate usage, it&#x27;s the sum of the extents or some such.</div><br/><div id="40933296" class="c"><input type="checkbox" id="c-40933296" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933280">parent</a><span>|</span><a href="#40933668">next</a><span>|</span><label class="collapse" for="c-40933296">[-]</label><label class="expand" for="c-40933296">[1 more]</label></div><br/><div class="children"><div class="content">Yes, files can be sparse but the actual disk usage information is also returned by these stat-family calls, so there is no special cost to handling sparse files.</div><br/></div></div></div></div></div></div><div id="40933668" class="c"><input type="checkbox" id="c-40933668" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#40933207">parent</a><span>|</span><a href="#40933238">prev</a><span>|</span><a href="#40934005">next</a><span>|</span><label class="collapse" for="c-40933668">[-]</label><label class="expand" for="c-40933668">[4 more]</label></div><br/><div class="children"><div class="content">Wish modern filesystems maintained usage per dir as a directory file attribute instead of mandating tools to do this basic job.</div><br/><div id="40933925" class="c"><input type="checkbox" id="c-40933925" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933668">parent</a><span>|</span><a href="#40933785">next</a><span>|</span><label class="collapse" for="c-40933925">[-]</label><label class="expand" for="c-40933925">[1 more]</label></div><br/><div class="children"><div class="content">CephFS does that.<p>You can use getfattr to ask it for the recursive number of entries or bytes in a given directory.<p>Querying it is constant time, updates update it with a few seconds delay.<p>Extremely useful when you have billions of files on spinning disks, where running du&#x2F;ncdu would take a month just for the stat()s.</div><br/></div></div><div id="40933785" class="c"><input type="checkbox" id="c-40933785" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933668">parent</a><span>|</span><a href="#40933925">prev</a><span>|</span><a href="#40934005">next</a><span>|</span><label class="collapse" for="c-40933785">[-]</label><label class="expand" for="c-40933785">[2 more]</label></div><br/><div class="children"><div class="content">This is an excellent point and I wholeheartedly agree!</div><br/><div id="40933820" class="c"><input type="checkbox" id="c-40933820" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40933207">root</a><span>|</span><a href="#40933785">parent</a><span>|</span><a href="#40934005">next</a><span>|</span><label class="collapse" for="c-40933820">[-]</label><label class="expand" for="c-40933820">[1 more]</label></div><br/><div class="children"><div class="content">Is it? That would require any update to any file to cascade into a bunch of directory updates amplifying the write and for what? Do you “du” in your shell prompt?<p>Not to mention it would likely be unable to handle the hardlink problem so it would consistently be wrong.</div><br/></div></div></div></div></div></div></div></div><div id="40934005" class="c"><input type="checkbox" id="c-40934005" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#40933207">prev</a><span>|</span><a href="#40934434">next</a><span>|</span><label class="collapse" for="c-40934005">[-]</label><label class="expand" for="c-40934005">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t know why one ordering is better than the other, but the difference is pretty drastic.<p>I have the suspicion that some file systems store stat info next to the getdents entries.<p>Thus cache locality would kick in if you stat a file after receiving it via getdents (and counterintuitively, smaller getdents buffers make it faster then). Also in such cases it would be important to not sort combined getdents outputs before starting (which would destroy the locality again).<p>I found such a situation with CephFS but don&#x27;t know what the layout is for common local file systems.</div><br/></div></div><div id="40934434" class="c"><input type="checkbox" id="c-40934434" checked=""/><div class="controls bullet"><span class="by">laixintao</span><span>|</span><a href="#40934005">prev</a><span>|</span><a href="#40933388">next</a><span>|</span><label class="collapse" for="c-40934434">[-]</label><label class="expand" for="c-40934434">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Anyone have ideas for a better format?<p>Hi, how about flamegraph? I always want to display the file hierarchy in flamegraph like format.<p>- previous discussion: <a href="https:&#x2F;&#x2F;x.com&#x2F;laixintao&#x2F;status&#x2F;1744012609983295816" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;laixintao&#x2F;status&#x2F;1744012609983295816</a><p>- my work display flamegraph in terminal: <a href="https:&#x2F;&#x2F;github.com&#x2F;laixintao&#x2F;flameshow">https:&#x2F;&#x2F;github.com&#x2F;laixintao&#x2F;flameshow</a></div><br/></div></div><div id="40933388" class="c"><input type="checkbox" id="c-40933388" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#40934434">prev</a><span>|</span><a href="#40933908">next</a><span>|</span><label class="collapse" for="c-40933388">[-]</label><label class="expand" for="c-40933388">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised statx was that much faster than fstatat. fstatat looks like a very thin wrapper around statx, it just calls vfs_statx and copies out the result to user space.</div><br/><div id="40933482" class="c"><input type="checkbox" id="c-40933482" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933388">parent</a><span>|</span><a href="#40933908">next</a><span>|</span><label class="collapse" for="c-40933482">[-]</label><label class="expand" for="c-40933482">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, I switched it back to fstatat and compared, and found no significant difference. Must&#x27;ve been some other change I made at the time, although I could&#x27;ve sworn this was true. Could be a system update changed something in the three months since I did that. I can&#x27;t edit my post now though, so that wrong info is stuck there.</div><br/></div></div></div></div><div id="40933908" class="c"><input type="checkbox" id="c-40933908" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#40933388">prev</a><span>|</span><a href="#40933847">next</a><span>|</span><label class="collapse" for="c-40933908">[-]</label><label class="expand" for="c-40933908">[1 more]</label></div><br/><div class="children"><div class="content">I have this in my bashrc:<p><pre><code>    alias duwim=&#x27;du --apparent-size -c -s -B1048576 * | sort -g&#x27;
</code></pre>
It produces a similar output, showing a list of directories and their sizes under the current dir.<p>The name &quot;duwim&quot; stands for &quot;du what I mean&quot;. It came naturally after I dabbled for quite a while to figure out how to make du do what I mean.</div><br/></div></div><div id="40933847" class="c"><input type="checkbox" id="c-40933847" checked=""/><div class="controls bullet"><span class="by">shellfishgene</span><span>|</span><a href="#40933908">prev</a><span>|</span><a href="#40932959">next</a><span>|</span><label class="collapse" for="c-40933847">[-]</label><label class="expand" for="c-40933847">[8 more]</label></div><br/><div class="children"><div class="content">What I need is a du that caches the results somewhere and then does not rescan the 90% of dirs that have not changed when I run it again a month later...</div><br/><div id="40933919" class="c"><input type="checkbox" id="c-40933919" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40933847">parent</a><span>|</span><a href="#40932959">next</a><span>|</span><label class="collapse" for="c-40933919">[-]</label><label class="expand" for="c-40933919">[7 more]</label></div><br/><div class="children"><div class="content">And it would know they did not change without scanning them because how?</div><br/><div id="40933967" class="c"><input type="checkbox" id="c-40933967" checked=""/><div class="controls bullet"><span class="by">svpg</span><span>|</span><a href="#40933847">root</a><span>|</span><a href="#40933919">parent</a><span>|</span><a href="#40934688">prev</a><span>|</span><a href="#40932959">next</a><span>|</span><label class="collapse" for="c-40933967">[-]</label><label class="expand" for="c-40933967">[5 more]</label></div><br/><div class="children"><div class="content">It could hash the contents of a dir. Along the lines of git</div><br/><div id="40934012" class="c"><input type="checkbox" id="c-40934012" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#40933847">root</a><span>|</span><a href="#40933967">parent</a><span>|</span><a href="#40934013">next</a><span>|</span><label class="collapse" for="c-40934012">[-]</label><label class="expand" for="c-40934012">[2 more]</label></div><br/><div class="children"><div class="content">Except hashing requires... reading.<p>There is not much to be done here. Directories entries are just names, no guarantees that the files were not modified or replaced.<p>The best you could do is something similar to the strategies of rsync, rely on metadata (modified date, etc) and cross fingers nobody did `cp -a`.</div><br/><div id="40934101" class="c"><input type="checkbox" id="c-40934101" checked=""/><div class="controls bullet"><span class="by">shellfishgene</span><span>|</span><a href="#40933847">root</a><span>|</span><a href="#40934012">parent</a><span>|</span><a href="#40934013">next</a><span>|</span><label class="collapse" for="c-40934101">[-]</label><label class="expand" for="c-40934101">[1 more]</label></div><br/><div class="children"><div class="content">I would be fine with the latter, the program could display a warning like &quot;Results may be inaccurate, full scan required&quot; or something.<p>I guess I&#x27;m just annoyed that for Windows&#x2F;NTFS really fast programs are available but not for Linux filesystems.</div><br/></div></div></div></div><div id="40934013" class="c"><input type="checkbox" id="c-40934013" checked=""/><div class="controls bullet"><span class="by">legends2k</span><span>|</span><a href="#40933847">root</a><span>|</span><a href="#40933967">parent</a><span>|</span><a href="#40934012">prev</a><span>|</span><a href="#40932959">next</a><span>|</span><label class="collapse" for="c-40934013">[-]</label><label class="expand" for="c-40934013">[2 more]</label></div><br/><div class="children"><div class="content">And to hash something needs reading all of its data.  I think deducing the file size would actually be faster in some file systems and never slower with any.</div><br/><div id="40934378" class="c"><input type="checkbox" id="c-40934378" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#40933847">root</a><span>|</span><a href="#40934013">parent</a><span>|</span><a href="#40932959">next</a><span>|</span><label class="collapse" for="c-40934378">[-]</label><label class="expand" for="c-40934378">[1 more]</label></div><br/><div class="children"><div class="content">Faster in all file systems I&#x27;d guess, stat is fast, opening the file and reading its contents and updating a checksum is slow, and gets slower the larger the file is.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40932959" class="c"><input type="checkbox" id="c-40932959" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40933847">prev</a><span>|</span><a href="#40933010">next</a><span>|</span><label class="collapse" for="c-40932959">[-]</label><label class="expand" for="c-40932959">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m away from my Linux machine now but I&#x27;m curious whether&#x2F;how you handle reflinks. On a supported file system such as Btrfs which I use, how does `cp --reflink` gets counted? Similar to hard links? I&#x27;m curious because I use this feature extensively.</div><br/><div id="40933078" class="c"><input type="checkbox" id="c-40933078" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40932959">parent</a><span>|</span><a href="#40933010">next</a><span>|</span><label class="collapse" for="c-40933078">[-]</label><label class="expand" for="c-40933078">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve actually never heard of --reflink, so I had to look it up. `cp` from coreutils uses the FICLONE ioctl to clone the file on btrfs instead of a regular syscall.<p>I don&#x27;t handle them specifically in dut, so it will total up whatever statx(2) reports for any reflink files.</div><br/><div id="40933503" class="c"><input type="checkbox" id="c-40933503" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40932959">root</a><span>|</span><a href="#40933078">parent</a><span>|</span><a href="#40933010">next</a><span>|</span><label class="collapse" for="c-40933503">[-]</label><label class="expand" for="c-40933503">[1 more]</label></div><br/><div class="children"><div class="content">You’ll probably end up with dupes (and removing these files won’t have the effect you intend) but I don’t know that there’s a good way to handle and report such soft links anyway.</div><br/></div></div></div></div></div></div><div id="40933010" class="c"><input type="checkbox" id="c-40933010" checked=""/><div class="controls bullet"><span class="by">timrichard</span><span>|</span><a href="#40932959">prev</a><span>|</span><a href="#40933888">next</a><span>|</span><label class="collapse" for="c-40933010">[-]</label><label class="expand" for="c-40933010">[2 more]</label></div><br/><div class="children"><div class="content">Looks nice, although a feature I like in ncdu is the &#x27;d&#x27; key to delete the currently highlighted file or directory.</div><br/><div id="40933114" class="c"><input type="checkbox" id="c-40933114" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933010">parent</a><span>|</span><a href="#40933888">next</a><span>|</span><label class="collapse" for="c-40933114">[-]</label><label class="expand" for="c-40933114">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t an interactive program, so ncdu would be better for interactively going around and freeing up space. If you just want an overview, though, then dut runs much quicker than ncdu and will show large files deep down in subdirectories without having to go down manually.</div><br/></div></div></div></div><div id="40933888" class="c"><input type="checkbox" id="c-40933888" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#40933010">prev</a><span>|</span><a href="#40933758">next</a><span>|</span><label class="collapse" for="c-40933888">[-]</label><label class="expand" for="c-40933888">[1 more]</label></div><br/><div class="children"><div class="content">I have been using diskonaut, its fast enough given that it also produces a nice visual output.</div><br/></div></div><div id="40933758" class="c"><input type="checkbox" id="c-40933758" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#40933888">prev</a><span>|</span><a href="#40933344">next</a><span>|</span><label class="collapse" for="c-40933758">[-]</label><label class="expand" for="c-40933758">[2 more]</label></div><br/><div class="children"><div class="content">Did you consider the fts[0] family of functions for traversal? I use that along with a work queue for filtered entries to get pretty good performance with dedup[1]. For my use case I could avoid any separate stat call altogether, the FTSENT already provided everything I needed.<p>0 - <a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;fts_read" rel="nofollow">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;fts_read</a><p>1 - <a href="https:&#x2F;&#x2F;github.com&#x2F;ttkb-oss&#x2F;dedup&#x2F;blob&#x2F;6a906db5a940df71deb4fdcdc7fc8bb4fcd0eb29&#x2F;dedup.c#L621">https:&#x2F;&#x2F;github.com&#x2F;ttkb-oss&#x2F;dedup&#x2F;blob&#x2F;6a906db5a940df71deb4f...</a></div><br/><div id="40933900" class="c"><input type="checkbox" id="c-40933900" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#40933758">parent</a><span>|</span><a href="#40933344">next</a><span>|</span><label class="collapse" for="c-40933900">[-]</label><label class="expand" for="c-40933900">[1 more]</label></div><br/><div class="children"><div class="content">fts is just wrapper functions.<p>You cannot around getdents and stat family syscalls on Linux if you need file sizes.</div><br/></div></div></div></div><div id="40933344" class="c"><input type="checkbox" id="c-40933344" checked=""/><div class="controls bullet"><span class="by">teamspirit</span><span>|</span><a href="#40933758">prev</a><span>|</span><a href="#40934092">next</a><span>|</span><label class="collapse" for="c-40933344">[-]</label><label class="expand" for="c-40933344">[2 more]</label></div><br/><div class="children"><div class="content">Nice job. I&#x27;ve been using dua[0] and have found it to be quite fast on my MacBook Pro. I&#x27;m interested to see how this compares.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Byron&#x2F;dua-cli">https:&#x2F;&#x2F;github.com&#x2F;Byron&#x2F;dua-cli</a></div><br/><div id="40933376" class="c"><input type="checkbox" id="c-40933376" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933344">parent</a><span>|</span><a href="#40934092">next</a><span>|</span><label class="collapse" for="c-40933376">[-]</label><label class="expand" for="c-40933376">[1 more]</label></div><br/><div class="children"><div class="content">I benchmarked against dua while developing, and the results are in the README. Note that dut uses Linux-specific syscalls, so it won&#x27;t run on MacOS.<p>TL;DR: dut is 3x faster with warm caches, slightly faster on SSD, slightly slower on HDD.</div><br/></div></div></div></div><div id="40934092" class="c"><input type="checkbox" id="c-40934092" checked=""/><div class="controls bullet"><span class="by">trustno2</span><span>|</span><a href="#40933344">prev</a><span>|</span><a href="#40934004">next</a><span>|</span><label class="collapse" for="c-40934092">[-]</label><label class="expand" for="c-40934092">[2 more]</label></div><br/><div class="children"><div class="content">Does it depend on linux functionality or can I use it on macos?<p>Well I can just try :)</div><br/><div id="40934620" class="c"><input type="checkbox" id="c-40934620" checked=""/><div class="controls bullet"><span class="by">Ringz</span><span>|</span><a href="#40934092">parent</a><span>|</span><a href="#40934004">next</a><span>|</span><label class="collapse" for="c-40934620">[-]</label><label class="expand" for="c-40934620">[1 more]</label></div><br/><div class="children"><div class="content">From the author:<p>„Note that dut uses Linux-specific syscalls, so it won&#x27;t run on MacOS.“</div><br/></div></div></div></div><div id="40934004" class="c"><input type="checkbox" id="c-40934004" checked=""/><div class="controls bullet"><span class="by">sandreas</span><span>|</span><a href="#40934092">prev</a><span>|</span><a href="#40933937">next</a><span>|</span><label class="collapse" for="c-40934004">[-]</label><label class="expand" for="c-40934004">[1 more]</label></div><br/><div class="children"><div class="content">Nice work! There is also gdu[1], where the UI is heavily inspired by ncdu and somehow feels way faster...<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;dundee&#x2F;gdu">https:&#x2F;&#x2F;github.com&#x2F;dundee&#x2F;gdu</a></div><br/></div></div><div id="40933937" class="c"><input type="checkbox" id="c-40933937" checked=""/><div class="controls bullet"><span class="by">tamimio</span><span>|</span><a href="#40934004">prev</a><span>|</span><a href="#40932968">next</a><span>|</span><label class="collapse" for="c-40933937">[-]</label><label class="expand" for="c-40933937">[1 more]</label></div><br/><div class="children"><div class="content">Someone, please create a Gdut, a fork that will produce graphs for a quick and easy way to read, it’s almost impossible to read in small vertical screens.</div><br/></div></div><div id="40932968" class="c"><input type="checkbox" id="c-40932968" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#40933937">prev</a><span>|</span><a href="#40933755">next</a><span>|</span><label class="collapse" for="c-40932968">[-]</label><label class="expand" for="c-40932968">[2 more]</label></div><br/><div class="children"><div class="content">This looks handy. Do you have any tips for stuff like queued ‘mv’ or similar? If I’m moving data around on 3-4 drives, it’s common where I’ll stack commands where the 3rd command may free up space for the 4th to run successfully - I use &amp;&amp; a to ensure a halt on failure, but I need to mentally calculate the space free when I’m writing the commands as the free space after the third mv will be different to the output of ‘df’ before any of the commands have run.</div><br/><div id="40933125" class="c"><input type="checkbox" id="c-40933125" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40932968">parent</a><span>|</span><a href="#40933755">next</a><span>|</span><label class="collapse" for="c-40933125">[-]</label><label class="expand" for="c-40933125">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t run into a situation like that, but if I did, I&#x27;d be doing mental math like you. `dut` would only be useful as a (quicker) replacement for `du` for telling you how large the source of a `cp -r` is.</div><br/></div></div></div></div><div id="40933755" class="c"><input type="checkbox" id="c-40933755" checked=""/><div class="controls bullet"><span class="by">jmakov</span><span>|</span><a href="#40932968">prev</a><span>|</span><a href="#40933331">next</a><span>|</span><label class="collapse" for="c-40933755">[-]</label><label class="expand" for="c-40933755">[1 more]</label></div><br/><div class="children"><div class="content">Would be great to have a TUI interface for browsing like ncdu.</div><br/></div></div><div id="40933331" class="c"><input type="checkbox" id="c-40933331" checked=""/><div class="controls bullet"><span class="by">jftuga</span><span>|</span><a href="#40933755">prev</a><span>|</span><a href="#40933300">next</a><span>|</span><label class="collapse" for="c-40933331">[-]</label><label class="expand" for="c-40933331">[2 more]</label></div><br/><div class="children"><div class="content">You should include the &quot;How to build&quot; instructions near the beginning of the main.c file.</div><br/><div id="40933359" class="c"><input type="checkbox" id="c-40933359" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933331">parent</a><span>|</span><a href="#40933300">next</a><span>|</span><label class="collapse" for="c-40933359">[-]</label><label class="expand" for="c-40933359">[1 more]</label></div><br/><div class="children"><div class="content">Done</div><br/></div></div></div></div><div id="40933300" class="c"><input type="checkbox" id="c-40933300" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#40933331">prev</a><span>|</span><a href="#40933265">next</a><span>|</span><label class="collapse" for="c-40933300">[-]</label><label class="expand" for="c-40933300">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <a href="https:&#x2F;&#x2F;dev.yorhel.nl&#x2F;doc&#x2F;ncdu2" rel="nofollow">https:&#x2F;&#x2F;dev.yorhel.nl&#x2F;doc&#x2F;ncdu2</a><p>I wasn&#x27;t aware that there was a rewrite of ncdu in Zig. That link is a nice read.</div><br/></div></div><div id="40933265" class="c"><input type="checkbox" id="c-40933265" checked=""/><div class="controls bullet"><span class="by">chomp</span><span>|</span><a href="#40933300">prev</a><span>|</span><a href="#40933037">next</a><span>|</span><label class="collapse" for="c-40933265">[-]</label><label class="expand" for="c-40933265">[1 more]</label></div><br/><div class="children"><div class="content">GPLv3, you love to see it. Great work.</div><br/></div></div><div id="40933037" class="c"><input type="checkbox" id="c-40933037" checked=""/><div class="controls bullet"><span class="by">notarealllama</span><span>|</span><a href="#40933265">prev</a><span>|</span><a href="#40933298">next</a><span>|</span><label class="collapse" for="c-40933037">[-]</label><label class="expand" for="c-40933037">[3 more]</label></div><br/><div class="children"><div class="content">If this accurately shows hidden stuff, such as docker build cache and old kernels, then it will become my go-to!</div><br/><div id="40933084" class="c"><input type="checkbox" id="c-40933084" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933037">parent</a><span>|</span><a href="#40934260">next</a><span>|</span><label class="collapse" for="c-40933084">[-]</label><label class="expand" for="c-40933084">[1 more]</label></div><br/><div class="children"><div class="content">As long as it has permissions, it totals up everything under the directory you give it including names that start with a &#x27;.&#x27;. It won&#x27;t follow symlinks though.</div><br/></div></div><div id="40934260" class="c"><input type="checkbox" id="c-40934260" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#40933037">parent</a><span>|</span><a href="#40933084">prev</a><span>|</span><a href="#40933298">next</a><span>|</span><label class="collapse" for="c-40934260">[-]</label><label class="expand" for="c-40934260">[1 more]</label></div><br/><div class="children"><div class="content">Uh, even basic du &quot;shows hidden stuff&quot; accurately doesn&#x27;t it?<p>dot files are just a convention on unix.</div><br/></div></div></div></div><div id="40933298" class="c"><input type="checkbox" id="c-40933298" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#40933037">prev</a><span>|</span><a href="#40933889">next</a><span>|</span><label class="collapse" for="c-40933298">[-]</label><label class="expand" for="c-40933298">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also interesting that the perf report for running dut on my homedir shows that it spends virtually all of the time looking for, not finding, and inserting entries in dentry cache slabs, where the entries are never found again, only inserted :-&#x2F; Great cache management by the kernel there.<p>ETA: Apparently the value in &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;vfs_cache_pressure makes a <i>huge</i> difference. With the default of 100, my dentry and inode caches never grow large enough to contain the ~15M entries in my homedir. Dentry slabs get reclaimed to stay &lt; 1% of system RAM, while the xfs_inode slab cache grows to the correct size. The threads in dut are pointless in this case because the access to the xfs inodes serializes.<p>If I set this kernel param to 15, then the caches grow to accommodate the tens of millions of inodes in my homedir. Ultimately the slab caches occupy 20GB of RAM! When the caches are working the threading in dut is moderately effective, job finishes in 5s with 200% CPU time.</div><br/><div id="40933340" class="c"><input type="checkbox" id="c-40933340" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933298">parent</a><span>|</span><a href="#40933889">next</a><span>|</span><label class="collapse" for="c-40933340">[-]</label><label class="expand" for="c-40933340">[3 more]</label></div><br/><div class="children"><div class="content">Are you referring to the kmem_cache_alloc calls in the profile? If so, that&#x27;s all in kernel space and there&#x27;s nothing I can do about it.<p><a href="https:&#x2F;&#x2F;share.firefox.dev&#x2F;3XT9L7P" rel="nofollow">https:&#x2F;&#x2F;share.firefox.dev&#x2F;3XT9L7P</a></div><br/><div id="40933348" class="c"><input type="checkbox" id="c-40933348" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#40933298">root</a><span>|</span><a href="#40933340">parent</a><span>|</span><a href="#40933889">next</a><span>|</span><label class="collapse" for="c-40933348">[-]</label><label class="expand" for="c-40933348">[2 more]</label></div><br/><div class="children"><div class="content">No, see how your profiles have `lookup_fast` at the leaves? Mine has `__lookup_slow` and it is slow indeed.</div><br/><div id="40933425" class="c"><input type="checkbox" id="c-40933425" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933298">root</a><span>|</span><a href="#40933348">parent</a><span>|</span><a href="#40933889">next</a><span>|</span><label class="collapse" for="c-40933425">[-]</label><label class="expand" for="c-40933425">[1 more]</label></div><br/><div class="children"><div class="content">I just saw your edit. You have WAY more stuff under your home directory than I do. I only have ~2.5M inodes on both my laptop drives combined. The difference in the buff&#x2F;cache output of `free` before and after running `dut` is only 1 GB for me.<p>Also, TIL about that kernel parameter, thanks!</div><br/></div></div></div></div></div></div></div></div><div id="40933889" class="c"><input type="checkbox" id="c-40933889" checked=""/><div class="controls bullet"><span class="by">rafaelgoncalves</span><span>|</span><a href="#40933298">prev</a><span>|</span><a href="#40933136">next</a><span>|</span><label class="collapse" for="c-40933889">[-]</label><label class="expand" for="c-40933889">[1 more]</label></div><br/><div class="children"><div class="content">neat tool, congrats on the release and thank you for this and the analysis&#x2F;comparison.</div><br/></div></div><div id="40933136" class="c"><input type="checkbox" id="c-40933136" checked=""/><div class="controls bullet"><span class="by">jepler</span><span>|</span><a href="#40933889">prev</a><span>|</span><a href="#40933770">next</a><span>|</span><label class="collapse" for="c-40933136">[-]</label><label class="expand" for="c-40933136">[4 more]</label></div><br/><div class="children"><div class="content">did you consider using io_uring? if not, was there a reason other than portability?</div><br/><div id="40933162" class="c"><input type="checkbox" id="c-40933162" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40933136">parent</a><span>|</span><a href="#40933770">next</a><span>|</span><label class="collapse" for="c-40933162">[-]</label><label class="expand" for="c-40933162">[3 more]</label></div><br/><div class="children"><div class="content">io_uring doesn&#x27;t support the getdents syscall, so there&#x27;s no way to traverse the filesystem with it. I considered using it for statx(2) to get the disk usage of each file, but decided not to because (a) it would be complicated to mix normal syscalls and io_uring and (b) perf showed the kernel spending most of its time doing actual work and not syscall boilerplate.</div><br/><div id="40933959" class="c"><input type="checkbox" id="c-40933959" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#40933136">root</a><span>|</span><a href="#40933162">parent</a><span>|</span><a href="#40933272">next</a><span>|</span><label class="collapse" for="c-40933959">[-]</label><label class="expand" for="c-40933959">[1 more]</label></div><br/><div class="children"><div class="content">Are you sure the perf may not be misleading?<p>E.g. memory accesses might show up as slower die to CPU caches being flushed when switching between user and kernel space.<p>I would be extremely interested in a quick (standalone?) benchmark of e.g. 1M stats with vs without uring.<p>Also <a href="https:&#x2F;&#x2F;github.com&#x2F;tdanecker&#x2F;iouring-getdents">https:&#x2F;&#x2F;github.com&#x2F;tdanecker&#x2F;iouring-getdents</a> reports big uring speedups for getdents, which makes it surprising to get no speedups for stat.<p>If uring turns out fast, you might ignore (a), just doing the getdents first and then all stats afterwards. Since getdents is a &quot;batch&quot; syscalls covering many files anyway, but stat isn&#x27;t.</div><br/></div></div><div id="40933272" class="c"><input type="checkbox" id="c-40933272" checked=""/><div class="controls bullet"><span class="by">jepler</span><span>|</span><a href="#40933136">root</a><span>|</span><a href="#40933162">parent</a><span>|</span><a href="#40933959">prev</a><span>|</span><a href="#40933770">next</a><span>|</span><label class="collapse" for="c-40933272">[-]</label><label class="expand" for="c-40933272">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate the explanation!</div><br/></div></div></div></div></div></div><div id="40933770" class="c"><input type="checkbox" id="c-40933770" checked=""/><div class="controls bullet"><span class="by">dima55</span><span>|</span><a href="#40933136">prev</a><span>|</span><a href="#40933933">next</a><span>|</span><label class="collapse" for="c-40933770">[-]</label><label class="expand" for="c-40933770">[2 more]</label></div><br/><div class="children"><div class="content">Ideas for a better format: do what xdiskusage does.</div><br/><div id="40934024" class="c"><input type="checkbox" id="c-40934024" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40933770">parent</a><span>|</span><a href="#40933933">next</a><span>|</span><label class="collapse" for="c-40934024">[-]</label><label class="expand" for="c-40934024">[1 more]</label></div><br/><div class="children"><div class="content">What specifically do you feel xdiskusage does well?</div><br/></div></div></div></div><div id="40933933" class="c"><input type="checkbox" id="c-40933933" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40933770">prev</a><span>|</span><a href="#40934064">next</a><span>|</span><label class="collapse" for="c-40933933">[-]</label><label class="expand" for="c-40933933">[1 more]</label></div><br/><div class="children"><div class="content">Not as featureful, but what I&#x27;ve been using.  If you can&#x27;t install this tool for some reason, it&#x27;s still useful.  I call it usage:<p><pre><code>    #!&#x2F;bin&#x2F;bash

    du -hs * .??* 2&gt; &#x2F;dev&#x2F;null | sort -h | tail -22</code></pre></div><br/></div></div><div id="40934064" class="c"><input type="checkbox" id="c-40934064" checked=""/><div class="controls bullet"><span class="by">miew</span><span>|</span><a href="#40933933">prev</a><span>|</span><label class="collapse" for="c-40934064">[-]</label><label class="expand" for="c-40934064">[3 more]</label></div><br/><div class="children"><div class="content">Why C and not Rust or even Zig?</div><br/><div id="40934067" class="c"><input type="checkbox" id="c-40934067" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#40934064">parent</a><span>|</span><label class="collapse" for="c-40934067">[-]</label><label class="expand" for="c-40934067">[2 more]</label></div><br/><div class="children"><div class="content">Why Rust or Zig and not C?</div><br/><div id="40934275" class="c"><input type="checkbox" id="c-40934275" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#40934064">root</a><span>|</span><a href="#40934067">parent</a><span>|</span><label class="collapse" for="c-40934275">[-]</label><label class="expand" for="c-40934275">[1 more]</label></div><br/><div class="children"><div class="content">Better for the author&#x27;s resume, if they want to make it hype driven.<p>Also some nebulous &quot;being more secure&quot;. Never mind that this tool does not have elevated privileges. You gotta watch out for those remote root exploits even for a local only app, man.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>