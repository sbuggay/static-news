<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730797255075" as="style"/><link rel="stylesheet" href="styles.css?v=1730797255075"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.gitpod.io/blog/we-are-leaving-kubernetes">We&#x27;re Leaving Kubernetes</a> <span class="domain">(<a href="https://www.gitpod.io">www.gitpod.io</a>)</span></div><div class="subtext"><span>filiptronicek</span> | <span>172 comments</span></div><br/><div><div id="42042999" class="c"><input type="checkbox" id="c-42042999" checked=""/><div class="controls bullet"><span class="by">horsawlarway</span><span>|</span><a href="#42049856">next</a><span>|</span><label class="collapse" for="c-42042999">[-]</label><label class="expand" for="c-42042999">[99 more]</label></div><br/><div class="children"><div class="content">Personally - just let the developer own the machine they use for development.<p>If you <i>really</i> need consistency for the environment - Let them own the machine, and then give them a stable base VM image, and pay for decent virtualization tooling that they run... on their own machine.<p>I have seen several attempts to move dev environments to a remote host.  They <i>invariably</i> suck.<p>Yes - that means you need to pay for decent hardware for your devs, it&#x27;s usually cheaper than remote resources (for a lot of reasons).<p>Yes - that means you need to support running your stack locally.  This is a good constraint (and a place where containers are your friend for consistency).<p>Yes - that means you need data generation tooling to populate a local env.  This can be automated relatively well, and it&#x27;s something you need with a remote env anyways.<p>---<p>The only real downside is data control (ie - the company has less control over how a developer manages assets like source code).  I&#x27;m my experience, the vast majority of companies should worry less about this - your value as a company isn&#x27;t your source code in 99.5% of cases, it&#x27;s the team that executes that source code in production.<p>If you&#x27;re in the 0.5% of other cases... you know it and you should be in an air-gapped closed room anyways (and I&#x27;ve worked in those too...)</div><br/><div id="42043130" class="c"><input type="checkbox" id="c-42043130" checked=""/><div class="controls bullet"><span class="by">shriek</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42048206">next</a><span>|</span><label class="collapse" for="c-42043130">[-]</label><label class="expand" for="c-42043130">[2 more]</label></div><br/><div class="children"><div class="content">And the reason they suck is the feedback loop is just too high as compared to running it locally. You have to jump through hoops to debug&#x2F;troubleshoot your code or any issues that you come across between your code and output of your code. And it&#x27;s almost impossible to work on things when you have spotty internet. 
I haven&#x27;t worked on extremely sensitive data but for PII data from prod to dev, scrubbing is a good practice to follow. This will vary based on the project&#x2F;team you&#x27;re on of course.</div><br/><div id="42043214" class="c"><input type="checkbox" id="c-42043214" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043130">parent</a><span>|</span><a href="#42048206">next</a><span>|</span><label class="collapse" for="c-42043214">[-]</label><label class="expand" for="c-42043214">[1 more]</label></div><br/><div class="children"><div class="content">Aka &#x27;if a developer knew beforehand everything they needed, it wouldn&#x27;t be development&#x27;</div><br/></div></div></div></div><div id="42048206" class="c"><input type="checkbox" id="c-42048206" checked=""/><div class="controls bullet"><span class="by">czhu12</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42043130">prev</a><span>|</span><a href="#42043651">next</a><span>|</span><label class="collapse" for="c-42048206">[-]</label><label class="expand" for="c-42048206">[16 more]</label></div><br/><div class="children"><div class="content">We tried this approach at a former company with ~600 engineers at the time.<p>Trying to boot the full service on a single machine required every single developer in the company installing ~50ish microservices on their machine, for things to work correctly. Became totally intractable.<p>I guess one can grumble about bad architecture all day but this had to be solved. we had to move to remote development environments which restored everyone’s sanity.<p>Both FAANG companies I’ve worked at had remote dev environments that were built in house.</div><br/><div id="42049142" class="c"><input type="checkbox" id="c-42049142" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048206">parent</a><span>|</span><a href="#42048459">next</a><span>|</span><label class="collapse" for="c-42049142">[-]</label><label class="expand" for="c-42049142">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Trying to boot the full service on a single machine required every single developer in the company installing ~50ish microservices on their machine, for things to work correctly. Became totally intractable.<p>This is certainly one of the critical mistakes you did.<p>No developer needs to launch half of the company&#x27;s services to work on a local deployment. That&#x27;s crazy, and awfully short-sighted.<p>The only services a developer ever needs to launch locally are the ones that are being changed. Anything else they can consume straight out of a non-prod development environment. That&#x27;s what non-prod environments are for. You launch your local service locally, you consume whatever you need to consume straight from a cloud environment, you test the contract with a local test set, and you deploy the service. That&#x27;s it.<p>&gt; I guess one can grumble about bad architecture all day but this had to be solved.<p>Yes, it needs to be solved. You need to launch your service locally while consuming dependencies deployed to any cloud environment. That&#x27;s not a company problem. That&#x27;s a problem plaguing that particular service, and one which is trivial to solve.<p>&gt; Both FAANG companies I’ve worked at had remote dev environments that were built in house.<p>All FANG companies I personally know had indeed remote dev environments. They also had their own custom tool sets to deploy services locally, either in isolation or consuming dependencies deployed to the cloud.<p>This is not a FANG cargo cult problem. This is a problem you created for yourself out of short-sightedness and for thinking you&#x27;re too smart for your own good. Newbies know very well they need to launch one service instance alone because that&#x27;s what they are changing. Veterans know that too well. Why on earth would anyone believe it&#x27;s reasonable to launch 50 services to do anything at all? Just launch the one service you&#x27;re working on. That&#x27;s it. If you believe something prevents you from doing that, that&#x27;s the problem you need to fix. Simple. Crazy.</div><br/></div></div><div id="42048459" class="c"><input type="checkbox" id="c-42048459" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048206">parent</a><span>|</span><a href="#42049142">prev</a><span>|</span><a href="#42048908">next</a><span>|</span><label class="collapse" for="c-42048459">[-]</label><label class="expand" for="c-42048459">[7 more]</label></div><br/><div class="children"><div class="content">I may be misunderstanding, but wouldn&#x27;t you want the particular microservice you are working on independent enough to develop locally, then deploy into the remote environment to test the integration?
(I don&#x27;t work at this scale)</div><br/><div id="42048595" class="c"><input type="checkbox" id="c-42048595" checked=""/><div class="controls bullet"><span class="by">animal_spirits</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048459">parent</a><span>|</span><a href="#42048908">next</a><span>|</span><label class="collapse" for="c-42048595">[-]</label><label class="expand" for="c-42048595">[6 more]</label></div><br/><div class="children"><div class="content">Invariably this is an ideal and does not match up in reality. I work at ~50 ish employee company and we have layers of dependencies between at least 6 or 7 various microservices. I can see this adding up in complexity as the product scales</div><br/><div id="42049224" class="c"><input type="checkbox" id="c-42049224" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048595">parent</a><span>|</span><a href="#42048862">next</a><span>|</span><label class="collapse" for="c-42049224">[-]</label><label class="expand" for="c-42049224">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Invariably this is an ideal and does not match up in reality.<p>No, this does indeed match reality. At least for those who work with microservices. This is microservices 101. It&#x27;s baffling how this is even being argued.<p>We have industry behemoths building their whole development experience around this fact. Look at Microsoft. They even went to the extents of supporting Connected Services in Visual Studio 2022. Why on earth do you believe one of the most basic traits of backend development is unreal?<p>&gt; I work at ~50 ish employee company and we have layers of dependencies between at least 6 or 7 various microservices.<p>Irrelevant. Each service has dependencies and consumers. When you need to run an instance of one of those services locally, you point it to it&#x27;s dependencies and you unplug it from it&#x27;s consumers. Done. This is not rocket science.</div><br/></div></div><div id="42048862" class="c"><input type="checkbox" id="c-42048862" checked=""/><div class="controls bullet"><span class="by">nightski</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048595">parent</a><span>|</span><a href="#42049224">prev</a><span>|</span><a href="#42048760">next</a><span>|</span><label class="collapse" for="c-42048862">[-]</label><label class="expand" for="c-42048862">[1 more]</label></div><br/><div class="children"><div class="content">So basically a distributed monolith :P</div><br/></div></div><div id="42048760" class="c"><input type="checkbox" id="c-42048760" checked=""/><div class="controls bullet"><span class="by">flimsypremise</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048595">parent</a><span>|</span><a href="#42048862">prev</a><span>|</span><a href="#42048603">next</a><span>|</span><label class="collapse" for="c-42048760">[-]</label><label class="expand" for="c-42048760">[2 more]</label></div><br/><div class="children"><div class="content">If the microservice has dependencies on other services it is not a microservice.</div><br/><div id="42049860" class="c"><input type="checkbox" id="c-42049860" checked=""/><div class="controls bullet"><span class="by">blitzar</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048760">parent</a><span>|</span><a href="#42048603">next</a><span>|</span><label class="collapse" for="c-42049860">[-]</label><label class="expand" for="c-42049860">[1 more]</label></div><br/><div class="children"><div class="content">Connecting to a messaging queue or database count as a dependency?</div><br/></div></div></div></div><div id="42048603" class="c"><input type="checkbox" id="c-42048603" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048595">parent</a><span>|</span><a href="#42048760">prev</a><span>|</span><a href="#42048908">next</a><span>|</span><label class="collapse" for="c-42048603">[-]</label><label class="expand" for="c-42048603">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the real world trumps theory, hence my question.</div><br/></div></div></div></div></div></div><div id="42048550" class="c"><input type="checkbox" id="c-42048550" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048206">parent</a><span>|</span><a href="#42048908">prev</a><span>|</span><a href="#42043651">next</a><span>|</span><label class="collapse" for="c-42048550">[-]</label><label class="expand" for="c-42048550">[6 more]</label></div><br/><div class="children"><div class="content">&gt; installing ~50ish microservices on their machine<p>Ouch.  Where they using macOS at the time with laptops having not-enough-ram?<p>I&#x27;ve seen that go poorly on macOS with java based microservices.  Largely due to java VMs wanting ram pre-assigned for each, which really chews though ram that mostly sits around unused.<p>This was a few years ago though, at the tail end of Intel based mac&#x27;s where 32GB ram in a mac laptop wasn&#x27;t really an option.</div><br/><div id="42048631" class="c"><input type="checkbox" id="c-42048631" checked=""/><div class="controls bullet"><span class="by">themanmaran</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048550">parent</a><span>|</span><a href="#42043651">next</a><span>|</span><label class="collapse" for="c-42048631">[-]</label><label class="expand" for="c-42048631">[5 more]</label></div><br/><div class="children"><div class="content">I bet it&#x27;s less of a RAM issue, and more of an orchestration problem. Making sure you have the latest version of every microservice and it&#x27;s configuration.<p>&quot;Oh it&#x27;s not running locally, you need to also run service_18_v2.js, and include the right env variables&quot;</div><br/><div id="42048887" class="c"><input type="checkbox" id="c-42048887" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048631">parent</a><span>|</span><a href="#42048804">next</a><span>|</span><label class="collapse" for="c-42048887">[-]</label><label class="expand" for="c-42048887">[3 more]</label></div><br/><div class="children"><div class="content">No, it was <i>definitely</i> a ram issue in this case.  The laptops had 16GB of ram, the maximum available at the time.  With the java VM overhead that ran things straight into swap and then some.<p>Running the dev environments remotely (or rewriting in Go) were the options being considered before the whole project was canned and people redistributed to other things.</div><br/><div id="42049531" class="c"><input type="checkbox" id="c-42049531" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048887">parent</a><span>|</span><a href="#42049168">next</a><span>|</span><label class="collapse" for="c-42049531">[-]</label><label class="expand" for="c-42049531">[1 more]</label></div><br/><div class="children"><div class="content">Given some Kubernetes workloads, even writing everything in Assembly might not help.</div><br/></div></div><div id="42049168" class="c"><input type="checkbox" id="c-42049168" checked=""/><div class="controls bullet"><span class="by">sdenton4</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048887">parent</a><span>|</span><a href="#42049531">prev</a><span>|</span><a href="#42048804">next</a><span>|</span><label class="collapse" for="c-42049168">[-]</label><label class="expand" for="c-42049168">[1 more]</label></div><br/><div class="children"><div class="content">I do the great majority of my work on a beefy desktop with a phat GPU, which I mostly run via ssh and a browser.</div><br/></div></div></div></div><div id="42048804" class="c"><input type="checkbox" id="c-42048804" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048631">parent</a><span>|</span><a href="#42048887">prev</a><span>|</span><a href="#42043651">next</a><span>|</span><label class="collapse" for="c-42048804">[-]</label><label class="expand" for="c-42048804">[1 more]</label></div><br/><div class="children"><div class="content">This + k8s magic that seem to make thing coupled tighter.</div><br/></div></div></div></div></div></div></div></div><div id="42043651" class="c"><input type="checkbox" id="c-42043651" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42048206">prev</a><span>|</span><a href="#42043304">next</a><span>|</span><label class="collapse" for="c-42043651">[-]</label><label class="expand" for="c-42043651">[20 more]</label></div><br/><div class="children"><div class="content">Most teams&#x2F;products I have been involved in, the stack always grows to the point that a dev can no longer test it on their own machine, regardless of how big the machine is. And having a different development machine than production leads to completely predictable and unavoidable problems. Devs need to create the software tooling to make remote dev less painful. I mean, they&#x27;re devs... making software is kind of their whole thing.</div><br/><div id="42044533" class="c"><input type="checkbox" id="c-42044533" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043651">parent</a><span>|</span><a href="#42044649">next</a><span>|</span><label class="collapse" for="c-42044533">[-]</label><label class="expand" for="c-42044533">[6 more]</label></div><br/><div class="children"><div class="content">I have used remote dev machines just fine, but my workflow vastly differs from many of my coworkers: terminal-only spacemacs + tmux + mosh. I have a lot of CLI and TUI tools, and I do not use VScode at all. The main GUI app I run is a browser, and that runs locally.<p>I have worked on developing VMs for other developers that rely on a local IDE such. The main sticking point is syncing and schlepping source code (something my setup avoids because the source code and editor is on the remote machine). I have tried a number of approaches, and I sympathize with the article author. So, in response to &quot;Devs need to create the software tooling to make remote dev less painful. I mean, they&#x27;re devs... making software is kind of their whole thing.&quot; &lt;-- syncing and schlepping source code is by no means a solved problem.<p>I can also say that, my spacemacs config is very vanilla. Like my phone, I don&#x27;t want to be messing with it when I want to code. Writing tooling for my editor environment is a sideshow for the work I am trying to finish.</div><br/><div id="42047668" class="c"><input type="checkbox" id="c-42047668" checked=""/><div class="controls bullet"><span class="by">xcrunner529</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42044533">parent</a><span>|</span><a href="#42046930">next</a><span>|</span><label class="collapse" for="c-42047668">[-]</label><label class="expand" for="c-42047668">[4 more]</label></div><br/><div class="children"><div class="content">I am hardly a dev but occasionally have had to do some or some scripting or web stuff and have really loved VSCode and using the remote SSH support to basically feel like I’m coding locally. Does that not work for your devs?</div><br/><div id="42049550" class="c"><input type="checkbox" id="c-42049550" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047668">parent</a><span>|</span><a href="#42048642">next</a><span>|</span><label class="collapse" for="c-42049550">[-]</label><label class="expand" for="c-42049550">[2 more]</label></div><br/><div class="children"><div class="content">UNIX, and other competing timesharing systems of the time, have always been remote first, with Windows catching up with Citrix, followed by RDP, and nowadays finally headless as well.<p>Nowadays Web frontends and SSH&#x2F;cloud shell, have replaced what used to be X Windows &#x2F; telnet &#x2F; rsh, but the underlying workflows aren&#x27;t much different than running an IDE &#x2F; emacs &#x2F;vi &#x2F; joe &#x2F;... from a UNIX development server in a 1990&#x27;s office.</div><br/><div id="42049713" class="c"><input type="checkbox" id="c-42049713" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42049550">parent</a><span>|</span><a href="#42048642">next</a><span>|</span><label class="collapse" for="c-42049713">[-]</label><label class="expand" for="c-42049713">[1 more]</label></div><br/><div class="children"><div class="content">The funniest (?) thing to me about all this: we&#x27;re still hoping, if we do things right, to replicate the technology (terminals) from <i>50 years ago</i>.<p>I honestly don&#x27;t understand why nobody has simply invented some software to solve this problem, after 50 years.</div><br/></div></div></div></div><div id="42048642" class="c"><input type="checkbox" id="c-42048642" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047668">parent</a><span>|</span><a href="#42049550">prev</a><span>|</span><a href="#42046930">next</a><span>|</span><label class="collapse" for="c-42048642">[-]</label><label class="expand" for="c-42048642">[1 more]</label></div><br/><div class="children"><div class="content">That puts a &quot;scary&quot; VSCode blob on the remote-server.  Some orgs do not like that, even if it&#x27;s a &quot;work&quot; class box.</div><br/></div></div></div></div><div id="42046930" class="c"><input type="checkbox" id="c-42046930" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42044533">parent</a><span>|</span><a href="#42047668">prev</a><span>|</span><a href="#42044649">next</a><span>|</span><label class="collapse" for="c-42046930">[-]</label><label class="expand" for="c-42046930">[1 more]</label></div><br/><div class="children"><div class="content">Me as well, specially in the days that there was only a UNIX dev server for everyone.<p>It was never an issue to use X Windows on them, with hummingbird on my Windows thin client.<p>I guess a new generation has to learn the ways of timesharing development.</div><br/></div></div></div></div><div id="42044649" class="c"><input type="checkbox" id="c-42044649" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043651">parent</a><span>|</span><a href="#42044533">prev</a><span>|</span><a href="#42047097">next</a><span>|</span><label class="collapse" for="c-42044649">[-]</label><label class="expand" for="c-42044649">[1 more]</label></div><br/><div class="children"><div class="content">We have a project which spawns around 80 Docker containers and runs pretty OK on a 5 year old Dell laptop with 16GB RAM. The fans run crazy and the laptop is always very hot but I haven&#x27;t noticed considerable lags, even with IntelliJ running. Most services are written in Go though and are pretty lightweight.</div><br/></div></div><div id="42047097" class="c"><input type="checkbox" id="c-42047097" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043651">parent</a><span>|</span><a href="#42044649">prev</a><span>|</span><a href="#42047801">next</a><span>|</span><label class="collapse" for="c-42047097">[-]</label><label class="expand" for="c-42047097">[6 more]</label></div><br/><div class="children"><div class="content">&gt; the stack always grows to the point that a dev can no longer test it on their own machine<p>So the solution here is to not have that kind of &quot;stack&quot;.<p>I mean, if it&#x27;s all so big and complex that it can&#x27;t be run on a laptop then you almost certainly got a lot of problems regardless. What typically happens is tons of interconnected services without clear abstractions or interfaces, and no one really understands this spaghetti mess, and people just keep piling crap on top of it.<p>This leads to all sorts of problems. Everywhere I&#x27;ve seen this happen they had real problems running stuff in production too, because it was a complex spaghetti mess. The abstracted &quot;easy&quot; dev-env (in whatever form that came) is then also incredibly complex, finicky, and brittle. Never mind running tests, which is typically even worse. It&#x27;s not uncommon for it all to be broken for every other new person who joins because changes somewhere broke the setup steps which are only run for new people. Everyone else is afraid to do anything with their machine &quot;because it now works&#x27;.<p>There are some exceptions where you really need a big beefy machine for a dev env and tests, maybe, but they&#x27;re few and far between.</div><br/><div id="42048576" class="c"><input type="checkbox" id="c-42048576" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047097">parent</a><span>|</span><a href="#42048075">next</a><span>|</span><label class="collapse" for="c-42048576">[-]</label><label class="expand" for="c-42048576">[1 more]</label></div><br/><div class="children"><div class="content">That kind of mess sounds super dangerous from a production perspective too.<p>With things that messy it&#x27;s fairly likely there would be dependency loops or problems (thundering herd, etc) trying to get things going from a cold start.<p>ie after a complete outage or similar for whatever reason</div><br/></div></div><div id="42048075" class="c"><input type="checkbox" id="c-42048075" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047097">parent</a><span>|</span><a href="#42048576">prev</a><span>|</span><a href="#42047801">next</a><span>|</span><label class="collapse" for="c-42048075">[-]</label><label class="expand" for="c-42048075">[4 more]</label></div><br/><div class="children"><div class="content">&gt; So the solution here is to not have that kind of &quot;stack&quot;.<p>Reminds me of my favorites debugging technique. It&#x27;s super fast: Don&#x27;t write any bugs!</div><br/><div id="42049590" class="c"><input type="checkbox" id="c-42049590" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048075">parent</a><span>|</span><a href="#42048429">next</a><span>|</span><label class="collapse" for="c-42049590">[-]</label><label class="expand" for="c-42049590">[1 more]</label></div><br/><div class="children"><div class="content">What a boring trite reply. All of this is analogous to badly written spaghetti code. And yes, you can absolutely avoid all of this if you know what you&#x27;re doing.</div><br/></div></div><div id="42048429" class="c"><input type="checkbox" id="c-42048429" checked=""/><div class="controls bullet"><span class="by">vinnymac</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048075">parent</a><span>|</span><a href="#42049590">prev</a><span>|</span><a href="#42048636">next</a><span>|</span><label class="collapse" for="c-42048429">[-]</label><label class="expand" for="c-42048429">[1 more]</label></div><br/><div class="children"><div class="content">Code is a liability. Not writing code is one of the best things a developer can do on any particular day, aside of course from deleting it ;)</div><br/></div></div><div id="42048636" class="c"><input type="checkbox" id="c-42048636" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048075">parent</a><span>|</span><a href="#42048429">prev</a><span>|</span><a href="#42047801">next</a><span>|</span><label class="collapse" for="c-42048636">[-]</label><label class="expand" for="c-42048636">[1 more]</label></div><br/><div class="children"><div class="content">Quite an effective approach:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kelseyhightower&#x2F;nocode">https:&#x2F;&#x2F;github.com&#x2F;kelseyhightower&#x2F;nocode</a></div><br/></div></div></div></div></div></div><div id="42047801" class="c"><input type="checkbox" id="c-42047801" checked=""/><div class="controls bullet"><span class="by">pylua</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043651">parent</a><span>|</span><a href="#42047097">prev</a><span>|</span><a href="#42047458">next</a><span>|</span><label class="collapse" for="c-42047801">[-]</label><label class="expand" for="c-42047801">[1 more]</label></div><br/><div class="children"><div class="content">Really? I can&#x27;t imagine not running the code locally. Honestly, my company has a micro services architecture, and I will just comment out the docker-compose pieces that I am not using. If I am developing&#x2F;testing a particular component then I will enable it.<p>How tightly coupled are these systems?</div><br/></div></div><div id="42047458" class="c"><input type="checkbox" id="c-42047458" checked=""/><div class="controls bullet"><span class="by">maxrecursion</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043651">parent</a><span>|</span><a href="#42047801">prev</a><span>|</span><a href="#42048573">next</a><span>|</span><label class="collapse" for="c-42047458">[-]</label><label class="expand" for="c-42047458">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Most teams&#x2F;products I have been involved in, the stack always grows to the point that a dev can no longer test it on their own machine&quot;<p>Isn&#x27;t this problem solved by CICD? When the developer is ready to test, they make a commit, and the pipeline deploys the code to a dev&#x2F;test environment. That&#x27;s how my teams have been doing it.</div><br/><div id="42047652" class="c"><input type="checkbox" id="c-42047652" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047458">parent</a><span>|</span><a href="#42048573">next</a><span>|</span><label class="collapse" for="c-42047652">[-]</label><label class="expand" for="c-42047652">[3 more]</label></div><br/><div class="children"><div class="content">This turns a 1 hour task into a 1 day task.  Fast feedback cycles are critical to software development.<p>I don&#x27;t quite understand how people get into the situation where their work can&#x27;t fit on their workstation.  I&#x27;ve worked on huge projects at huge tech companies, and I could run everything on my workstation.  I&#x27;ve worked at startups where the CI situation was passing 5% of the time and required 3 hours to run, that you can now run on your workstation in seconds.  What you do is fix the stuff that doesn&#x27;t fit.<p>The most insidious source of slowness I&#x27;ve encountered is tests that use test databases set to fsync = on.  This severely limits parallelism and speed in a way that&#x27;s difficult to diagnose; you have plenty of CPU and memory available, but the tests just aren&#x27;t going very fast.  (I don&#x27;t remember how I stumbled upon this insight.  I think I must have straced Postgres and been like &quot;ohhhhhhhhh, of course&quot;.)</div><br/><div id="42048050" class="c"><input type="checkbox" id="c-42048050" checked=""/><div class="controls bullet"><span class="by">d_sem</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047652">parent</a><span>|</span><a href="#42048563">next</a><span>|</span><label class="collapse" for="c-42048050">[-]</label><label class="expand" for="c-42048050">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s likely you haven&#x27;t come across these use cases in your professional career, but I assure you its very common. My entire career has only seen projects where you need dozen to hundreds of CPU&#x27;s in order to have a short feedback loop to verify the system works. I saw this in simple algorithms in automotive, to Advanced Driver Assistance Systems and machine learning applications.<p>When you are working on a software project that has 1,000 active developers checking in code daily and require a stable system build you need lots of compute.</div><br/></div></div><div id="42048563" class="c"><input type="checkbox" id="c-42048563" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047652">parent</a><span>|</span><a href="#42048050">prev</a><span>|</span><a href="#42048573">next</a><span>|</span><label class="collapse" for="c-42048563">[-]</label><label class="expand" for="c-42048563">[1 more]</label></div><br/><div class="children"><div class="content">You just need faster tests. ;)<p>Also, if you&#x27;re booting kernel or device drivers you need the hardware.  Some of this is not desktop hardware.</div><br/></div></div></div></div></div></div><div id="42048573" class="c"><input type="checkbox" id="c-42048573" checked=""/><div class="controls bullet"><span class="by">rossjudson</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043651">parent</a><span>|</span><a href="#42047458">prev</a><span>|</span><a href="#42043304">next</a><span>|</span><label class="collapse" for="c-42048573">[-]</label><label class="expand" for="c-42048573">[1 more]</label></div><br/><div class="children"><div class="content">The stack(factory) must grow.</div><br/></div></div></div></div><div id="42043304" class="c"><input type="checkbox" id="c-42043304" checked=""/><div class="controls bullet"><span class="by">csweichel</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42043651">prev</a><span>|</span><a href="#42045620">next</a><span>|</span><label class="collapse" for="c-42043304">[-]</label><label class="expand" for="c-42043304">[6 more]</label></div><br/><div class="children"><div class="content">OP here. There definitely is a place for running things on your local machine. Exactly as you say: one can get a great deal of consistency using VMs.<p>One of the benefits of moving away from Kubernetes, to a runner-based architecture , is that we can now seamlessly support cloud-based and local environments (<a href="https:&#x2F;&#x2F;www.gitpod.io&#x2F;blog&#x2F;introducing-gitpod-desktop" rel="nofollow">https:&#x2F;&#x2F;www.gitpod.io&#x2F;blog&#x2F;introducing-gitpod-desktop</a>).<p>What&#x27;s really nice about this is that with this kind of integration there&#x27;s very little difference in setting up a dev env in the cloud or locally. The behaviour and qualities of those  environments can differ vastly though (network bandwidth, latency, GPU, RAM, CPUs, ARM&#x2F;x86).</div><br/><div id="42048591" class="c"><input type="checkbox" id="c-42048591" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043304">parent</a><span>|</span><a href="#42044832">next</a><span>|</span><label class="collapse" for="c-42048591">[-]</label><label class="expand" for="c-42048591">[1 more]</label></div><br/><div class="children"><div class="content">Something that&#x27;s not clear from the post is whether you&#x27;re running these environments on your own hardware, or layering things on top of something from a cloud provider (AWS, etc)?</div><br/></div></div><div id="42044832" class="c"><input type="checkbox" id="c-42044832" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043304">parent</a><span>|</span><a href="#42048591">prev</a><span>|</span><a href="#42044541">next</a><span>|</span><label class="collapse" for="c-42044832">[-]</label><label class="expand" for="c-42044832">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; The behaviour and qualities of those environments can differ vastly though (network bandwidth, latency, GPU, RAM, CPUs, ARM&#x2F;x86).</i><p>For example, when you&#x27;re running on your local machine you&#x27;ve actually got the amount of RAM and CPU advertised :)</div><br/><div id="42045802" class="c"><input type="checkbox" id="c-42045802" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42044832">parent</a><span>|</span><a href="#42044541">next</a><span>|</span><label class="collapse" for="c-42045802">[-]</label><label class="expand" for="c-42045802">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Hm, why does my Go service on a pod with 2.2 cpu&#x27;s think it has 6k? Oh, it thinks it has the whole cluster. Nice; that is why scheduling has been an issue&quot;</div><br/></div></div></div></div><div id="42044541" class="c"><input type="checkbox" id="c-42044541" checked=""/><div class="controls bullet"><span class="by">master_crab</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043304">parent</a><span>|</span><a href="#42044832">prev</a><span>|</span><a href="#42043512">next</a><span>|</span><label class="collapse" for="c-42044541">[-]</label><label class="expand" for="c-42044541">[1 more]</label></div><br/><div class="children"><div class="content">Hi Christian. We just deployed Gitpod EKS at our company in NY. Can we get some details on the replacement architecture? I’m sure it’s great but the devil is always in the details.</div><br/></div></div></div></div><div id="42045620" class="c"><input type="checkbox" id="c-42045620" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42043304">prev</a><span>|</span><a href="#42048516">next</a><span>|</span><label class="collapse" for="c-42045620">[-]</label><label class="expand" for="c-42045620">[32 more]</label></div><br/><div class="children"><div class="content">In my last role as a director of engineering at a startup, I found that a project `flake.nix` file (coupled with simply asking people to use <a href="https:&#x2F;&#x2F;determinate.systems&#x2F;posts&#x2F;determinate-nix-installer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;determinate.systems&#x2F;posts&#x2F;determinate-nix-installer&#x2F;</a> to install Nix) led to the fastest &quot;new-hire-to-able-to-contribute&quot; time of anything I&#x27;ve seen.<p>Unfortunately, after a few hires (hand-picked by me), this is what happened:<p>1) People didn&#x27;t want to learn Nix, neither did they want to ask me how to make something work with Nix, neither did they tell me they didn&#x27;t want to learn Nix. In essence, I told them to set the project up with it, which they&#x27;d do (and which would be successful, at least initially), but <i>forgot that I also had to sell them on it.</i> In one case, a developer spent all weekend (of HIS time) uninstalling Nix and making things work using the &quot;usual crap&quot; (as I would call it), all because of an issue I could have fixed in probably 5 minutes if he had just reached out to me (which he did not, to my chagrin). The first time I heard them comment their true feelings on it was when I pushed back regarding this because I would have gladly helped... I&#x27;ve mentioned this on various Slacks to get feedback and people have basically said &quot;you either insist on it and say it&#x27;s the only supported developer-environment-defining framework, or you will lose control over it&quot; &#x2F;shrug<p>2) Developers really like to have control over their own machines (but I failed to assume they&#x27;d also want this control over the project dependencies, since, after all, I was the one who decided to control mine with the flake.nix in the first place!)<p>3) At a startup, execution is everything and time is possibly too short (especially if you have kids) to learn new things that aren&#x27;t simple, even if better... that unfortunately may include Nix.<p>4) Nix would also be perfect for deployments... except that there is no (to my knowledge) general-purpose, broadly-accepted way to deploy via Nix, except to convert it to a Docker image and deploy that, which (almost) defeats most of the purpose of Nix.<p>I still believe in Nix but actually trying to use it to &quot;perfectly control&quot; a team&#x27;s project dependencies (which I will insist <i>it does do, pretty much, better than anything else</i>) has been a mixed bag. And I will still insist that for every 5 minutes spent wrestling with Nix trying to get it to do what you need it to do, you are saving <i>at least</i> an order of magnitude more time spent debugging non-deterministic dependency issues that (as it turns out) were only &quot;accidentally&quot; working in the first place.</div><br/><div id="42048582" class="c"><input type="checkbox" id="c-42048582" checked=""/><div class="controls bullet"><span class="by">lemme_tell_ya</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42046700">next</a><span>|</span><label class="collapse" for="c-42048582">[-]</label><label class="expand" for="c-42048582">[2 more]</label></div><br/><div class="children"><div class="content">&gt; time is possibly too short (especially if you have kids) to learn new things that aren&#x27;t simple, even if better<p>Having a kid has drastically altered my ability to learn new things outside of work, simply due to lack of time. I never could have imagined how big of an impact having a kid would be, its crazy!<p>The worst thing is when you actually manage to carve out some time to do some learning or experimentation with a new tool, library, etc only to find out that it sucks or you just don&#x27;t have the time to pick up or whatever.</div><br/><div id="42049141" class="c"><input type="checkbox" id="c-42049141" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048582">parent</a><span>|</span><a href="#42046700">next</a><span>|</span><label class="collapse" for="c-42049141">[-]</label><label class="expand" for="c-42049141">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Having a kid has drastically altered my ability to learn new things outside of work, simply due to lack of time. I never could have imagined how big of an impact having a kid would be, its crazy!<p>yeah, I could have written this verbatim. Either I was not warned enough, or I did not pay enough attention&#x2F;heed whatever I was warned of. I don&#x27;t have a large family, so I&#x27;ve basically had ZERO kid experience since I was a kid... yikes... almost 50 years ago LOL. What worries me though is that it&#x27;s kind of been an assumption at this job that you DO spend some off-duty time learning&#x2F;tinkering. And I enjoyed it!<p>&gt; The worst thing is when you actually manage to carve out some time to do some learning or experimentation with a new tool, library, etc only to find out that it sucks<p>I got briefly excited about the V language to maybe use for little utility scripts and maybe even as a first teaching language for my kid, then realized that when you scratch the surface of it it&#x27;s basically kind of ugly underneath. (Example- The &quot;this should never happen&quot; error was literally most of the errors, lol.) It looks like something with a lot of great ideas but slipshod not-deeply-thought-out implementation. And the final nail in the coffin was all the evidence that the language creator simply bans anyone with valid criticism- I&#x27;m a free-speech near-absolutist so that one was the killer for me.<p>One of a few examples of what you&#x27;re referring to. The thing is, before kids, we could afford to waste that time. Now we cannot. :&#x2F;</div><br/></div></div></div></div><div id="42046700" class="c"><input type="checkbox" id="c-42046700" checked=""/><div class="controls bullet"><span class="by">kalaksi</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42048582">prev</a><span>|</span><a href="#42047526">next</a><span>|</span><label class="collapse" for="c-42046700">[-]</label><label class="expand" for="c-42046700">[10 more]</label></div><br/><div class="children"><div class="content">From my perspective, installing Nix seems pretty invasive. I can understand if someone doesn&#x27;t want to mess with their system &quot;unnecessarily&quot; especially if the tool and it&#x27;s workings are foreign. And I can&#x27;t really remember the last time I had issues with non-deterministic dependencies either. Dependency versions are locked. Maybe I&#x27;m missing something?</div><br/><div id="42049189" class="c"><input type="checkbox" id="c-42049189" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42046700">parent</a><span>|</span><a href="#42049025">next</a><span>|</span><label class="collapse" for="c-42049189">[-]</label><label class="expand" for="c-42049189">[3 more]</label></div><br/><div class="children"><div class="content">&gt; installing Nix seems pretty invasive<p>I&#x27;m writing a test to check whether a tool I&#x27;m writing can work without Nix (it works with it perfectly, but I want it to also work without it because there are a lot of folks like you, and like me about 3 years ago, who still think they&#x27;d rather struggle with manually installing the right glibc that goes with the right python dependency installed with the right pip and venv versions, to the right location, that goes with the right python version that makes Whisper models work (literally the thing I&#x27;m currently working on), instead of just running `nix develop` and getting a coffee and then done.<p>And all I have to do to simulate &quot;no Nix&quot; is to remove all the nix paths from PATH (I suppose I could purge it from the linker paths as well, now that I think about it). But that&#x27;s it.<p>What Nix does is put its entire repo into a separate part of your hard drive owned by root, and create a few build users for security reasons. That&#x27;s (to me) not particularly &quot;invasive,&quot; but YMMV (and if you use the Determinate Nix installer, it&#x27;s even more trivial to uninstall than the official way). Also, when you run `nix develop`, the environment changes it does to make everything &quot;just work&quot; (like PATH changes etc) <i>are only valid for that terminal session</i>. Again, this is the least intrusive thing possible while also providing the guarantees it does, and is also (more or less) guaranteed to work.<p>The Nix whitepaper is pretty readable and not that long. I recommend it to understand why it&#x27;s important and useful: <a href="https:&#x2F;&#x2F;edolstra.github.io&#x2F;pubs&#x2F;nspfssd-lisa2004-final.pdf" rel="nofollow">https:&#x2F;&#x2F;edolstra.github.io&#x2F;pubs&#x2F;nspfssd-lisa2004-final.pdf</a><p>There is also Guix, which is like Nix but uses Guile (a Scheme dialect) as its scripting language <i>all the way down to the bare metal</i> (literally, the boot loader is written in it, I believe, as soon as the interpreter is loaded somehow). Their strategy seems to be to let Nix take the lead and make all the mistakes and then implement the way that seems to work the best, in its own ecosystem&#x2F;tooling: <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;</a> But they have a lot fewer packages than Nix does.<p>Both of these let you define an entire machine with a single configuration file that is far more guaranteed to work than running a Dockerfile.</div><br/><div id="42049576" class="c"><input type="checkbox" id="c-42049576" checked=""/><div class="controls bullet"><span class="by">kalaksi</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42049189">parent</a><span>|</span><a href="#42049410">next</a><span>|</span><label class="collapse" for="c-42049576">[-]</label><label class="expand" for="c-42049576">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for providing some concrete examples and explaining how it works. Sounds like a reasonable setup to automate. I&#x27;m actually running NixOS at home on a few hosts (but not on my desktop), so Nix isn&#x27;t entirely foreign to me, but I haven&#x27;t (yet?) used it with other distros or for developing as my needs have been simpler. In your case, I probably would have chosen the recommended path.<p>In my current work project, we use Windows and .NET with some libs and tools. Nothing too complicated, but automating it would be nice. I could probably push for it a bit, but I&#x27;m not familiar with automating Windows environments, since I mainly use Linux at home.</div><br/></div></div><div id="42049410" class="c"><input type="checkbox" id="c-42049410" checked=""/><div class="controls bullet"><span class="by">herewulf</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42049189">parent</a><span>|</span><a href="#42049576">prev</a><span>|</span><a href="#42049025">next</a><span>|</span><label class="collapse" for="c-42049410">[-]</label><label class="expand" for="c-42049410">[1 more]</label></div><br/><div class="children"><div class="content">Guix uses GRUB like most distros (but is scripted a bit to allow booting earlier generations of the system). The init system is Guile (Shepherd).<p>Fewer packages, yes, but the packages are by far the most common ones. It&#x27;s easy to add packages for yourself, if needed. Nonguix channel and others for stuff upstream won&#x27;t accept.<p>I believe Guix is innovating on a number of things in relation to Nix these days. So I&#x27;ve heard. I don&#x27;t know much about Nix, honestly.<p>I heartily agree with your last paragraph in the case of Guix.</div><br/></div></div></div></div><div id="42049025" class="c"><input type="checkbox" id="c-42049025" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42046700">parent</a><span>|</span><a href="#42049189">prev</a><span>|</span><a href="#42048092">next</a><span>|</span><label class="collapse" for="c-42049025">[-]</label><label class="expand" for="c-42049025">[4 more]</label></div><br/><div class="children"><div class="content">&gt; From my perspective, installing Nix seems pretty invasive.<p>How so? With what other software does Nix interfere?</div><br/><div id="42049100" class="c"><input type="checkbox" id="c-42049100" checked=""/><div class="controls bullet"><span class="by">kalaksi</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42049025">parent</a><span>|</span><a href="#42048092">next</a><span>|</span><label class="collapse" for="c-42049100">[-]</label><label class="expand" for="c-42049100">[3 more]</label></div><br/><div class="children"><div class="content">From the provided link:<p>&gt; Nix requires a broad set of changes to your system, from creating new users to installing and running a daemon to creating a root volume and beyond</div><br/><div id="42049238" class="c"><input type="checkbox" id="c-42049238" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42049100">parent</a><span>|</span><a href="#42049622">next</a><span>|</span><label class="collapse" for="c-42049238">[-]</label><label class="expand" for="c-42049238">[1 more]</label></div><br/><div class="children"><div class="content">The daemon and the users are only to run a build when that is necessary. It might seem invasive but it works out pretty well.</div><br/></div></div><div id="42049622" class="c"><input type="checkbox" id="c-42049622" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42049100">parent</a><span>|</span><a href="#42049238">prev</a><span>|</span><a href="#42048092">next</a><span>|</span><label class="collapse" for="c-42049622">[-]</label><label class="expand" for="c-42049622">[1 more]</label></div><br/><div class="children"><div class="content">Ok, I see what you mean now.<p>What the post is trying to do there is motivate the creation of a new installer, including to the existing Nix community. The snippet you&#x27;ve highlighted is essentially correct, but I still wouldn&#x27;t characterize Nix as particularly invasive.<p>The only that Nix <i>strictly</i> needs is to be plugged into your shell. That&#x27;s it. It doesn&#x27;t need deep or special hooks into a system just to function.<p>But including the daemon enables sandboxing for builds that Nix performs, which improves both the security and isolation of those builds, and it also lets Nix be shared nicely between unprivileged users on multiuser systems. For those reasons, daemonful installs are the default and with them come the system users.<p>(Adding system users is pretty much bog standard stuff for Unix system software, since the main kind of security boundary designed into that system is boundaries between users. Indeed, that&#x27;s exactly what that&#x27;s used for with Nix, too.)<p>The two things I described above comprise the totality of what is required to enable all of Nix&#x27;s functionality. <i>Everything</i> else that the Determinate Nix installer does as of now is to work around or avoid macOS quirks, and is totally unnecessary for using Nix on any other OS.<p>The &#x27;root volume&#x27; stuff is the result of a collision between the historical and conventional location of the Nix store at `&#x2F;nix` and Apple&#x27;s later imposition of a read-only root partition. So Nix installers do a little Apple-specific dance that creates a kind of filesystem volume that doesn&#x27;t take up any real space or involve any physical partitioning of the disk when they run on macOS.<p>The other thing this installer does is build in an attempt to self-repair the damage that Apple inflicts upon Nix&#x27;s sole real requirement by having macOS unconditionally clobber the shell config files under &#x2F;etc during major macOS updates.<p>That&#x27;s it. That&#x27;s an exhaustive list of all the things a Nix installer does and why. It&#x27;s not particularly tricky, or hard to remember or figure out. It&#x27;s not even hard to undo manually— before the Determinate Nix installer existed, I sometimes uninstalled Nix by hand while manually testing the macOS bootstrap scripts for my dotfiles. It was <i>annoying</i> to do, and the uninstallation functionality of the Determinate Nix installer is extremely reliable and convenient and nice. But anyone who knows what `$PATH` is and has ever run `man` before could completely uninstall Nix even if some joker walked over to their machine and deleted the uninstaller.<p>At the same time, none of the changes Nix installers make on your system affect the behavior of outside programs at all, except by exposing what you choose to install via Nix through standard Unix environment variables like PATH.<p>Lacking things like kernel components, automatic self-updates, or the requirement for privileged APIs (e.g., on macOS, the endpoint security APIs and accessibility APIs), Nix is not only far less invasive than <i>any</i> endpoint security software, monitoring software, or MDM software you are likely to run on a work machine, but I&#x27;d argue tons of common desktop software like Zoom, Discord, DisplayLink and tons of popular macOS powertools like Amphetamine, SteerMouse, SoundSource, etc.<p>Plus the uninstall procedure with the DetSys installer and its forks is totally conventional and leaves nothing behind: run uninstaller, thing gone.<p>Nix on macOS is admittedly not an installer-free, drag-and-drop app bundle like some lovely applications get to be. But at most workplaces it&#x27;s not likely to crack the top 10 most invasive applications installed on the average developer machine, either. Nix installers are just very up front about the things they <i>do</i> set up.<p>All that said, there are reasonable people who find having a daemon at all offensive. People who are deeply committed to minimalism or simplicity might prefer a single-user install or to use some other tool. But I think for most people, Nix is imo more than fine in terms of invasiveness.</div><br/></div></div></div></div></div></div><div id="42048092" class="c"><input type="checkbox" id="c-42048092" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42046700">parent</a><span>|</span><a href="#42049025">prev</a><span>|</span><a href="#42047526">next</a><span>|</span><label class="collapse" for="c-42048092">[-]</label><label class="expand" for="c-42048092">[2 more]</label></div><br/><div class="children"><div class="content">Typically when you start a new dev job the company will provide you with a pre-provisioned laptop that has their security stuff setup and maybe dev tools already installed, eg source code, compilers, VMs, Nix, and a supported editor, so it&#x27;s not exactly a personal machine that they&#x27;re messing with.</div><br/><div id="42049151" class="c"><input type="checkbox" id="c-42049151" checked=""/><div class="controls bullet"><span class="by">kalaksi</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048092">parent</a><span>|</span><a href="#42047526">next</a><span>|</span><label class="collapse" for="c-42049151">[-]</label><label class="expand" for="c-42049151">[1 more]</label></div><br/><div class="children"><div class="content">Sure, and personally, I have no issue installing and using recommended tools since it&#x27;s indeed just a work laptop, but I&#x27;ve seen more tuned setups too (see parent&#x27;s point 2: &quot;Developers really like to have control over their own machines&quot;)</div><br/></div></div></div></div></div></div><div id="42047526" class="c"><input type="checkbox" id="c-42047526" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42046700">prev</a><span>|</span><a href="#42047716">next</a><span>|</span><label class="collapse" for="c-42047526">[-]</label><label class="expand" for="c-42047526">[4 more]</label></div><br/><div class="children"><div class="content">People just straight-up don’t want to learn. There are always exceptions, of course, but IME the majority of people in tech are incurious. They want to do their job, and get paid. Reading man pages is sadly not in that list.</div><br/><div id="42048284" class="c"><input type="checkbox" id="c-42048284" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047526">parent</a><span>|</span><a href="#42049372">next</a><span>|</span><label class="collapse" for="c-42048284">[-]</label><label class="expand" for="c-42048284">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They want to do their job, and get paid<p>Where &quot;job&quot; is defined in a narrowest way possible to assume minimum responsibility. Still want to get 200k+ salaries though...<p>This may sound extreme (it really isn&#x27;t) but as Dr of Eng TP&#x27;s job was to sus those folks out as early as possible and part ways (the kind where they go work for someone else). Some folks are completely irrational about their setups and no amount of appeasement in the form of &quot;whys&quot; and training is usually sufficient.</div><br/></div></div><div id="42049372" class="c"><input type="checkbox" id="c-42049372" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047526">parent</a><span>|</span><a href="#42048284">prev</a><span>|</span><a href="#42047751">next</a><span>|</span><label class="collapse" for="c-42049372">[-]</label><label class="expand" for="c-42049372">[1 more]</label></div><br/><div class="children"><div class="content">&gt; People just straight-up don’t want to learn. (...) but IME the majority of people in tech are incurious. They want to do their job, and get paid. Reading man pages is sadly not in that list.<p>I don&#x27;t think you know what you&#x27;re talking about. Just because you know people who do not want to waste their time on a set of unproductive chores you arbitrarily singled out, that does not mean they are against learning.<p>Your take is particularly absurd considering the topic: engineers working on distributed services.<p>Do you actually believe that you build up enough knowledge on this topic to become a professional in the field if you &quot;straight-up don&#x27;t want to learn&quot;? There is not a single developer in the field who, at least to some degree, is not self-taught.<p>&gt; They want to do their job, and get paid.<p>Everyone wants to get paid. Do you know anyone who works non-profit?<p>What you&#x27;re failing to understand is the &quot;do their job&quot; part. Software developers are trained to solve the problems they face, and not waste time with the problems they do not have. Time is precious, and they invest it where it has the largest return on investment.<p>&gt; Reading man pages is sadly not in that list.<p>Man pages are notoriously a colossal waste of time. In general they are poorly thought out, they are incomplete, they were written with complete disregard for user experience, and more often than not they are way out of date.<p>Why do you think sites like Stack overflow is so popular? Because all those &quot;incurious&quot; people in tech feels the need to ask questions and dig through answers on how to solve problems?<p>I think you&#x27;re just picking a very personal definition of competence which conveniently boils down to &quot;do the things I do, and do not do the things I don&#x27;t&quot;. Except the bulk of the people in the field is smart, and some have already solved problems that you aren&#x27;t aware exist, such as wasting precious time deciphering unreadable documents that are systematically out of date.</div><br/></div></div><div id="42047751" class="c"><input type="checkbox" id="c-42047751" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047526">parent</a><span>|</span><a href="#42049372">prev</a><span>|</span><a href="#42047716">next</a><span>|</span><label class="collapse" for="c-42047751">[-]</label><label class="expand" for="c-42047751">[1 more]</label></div><br/><div class="children"><div class="content">This has always made me sad, but I think you&#x27;re right in a lot of cases.  What I&#x27;ve always tried to do is to focus on basic productivity; make sure everyone has everything they need to do their work, and that most people do it in the same way, so you can make progress on the learning journey together.  Whenever people ask me for help and want to set up a meeting (not just &quot;please answer this on Slack and I&#x27;ll leave you alone&quot;), I record the meeting, try to touch on all the related areas of their problem, and then review the recording for things that would be interesting to write about it.  If any of the digressions are interesting, I go into Notion, create a new page, and write up a couple paragraphs.  Then I give my team &quot;ever wonder what dynamic linking is and how to debug it?&quot; and they can read it and know as much as I know.<p>I really, really struggle to deal with the fact that people don&#x27;t know as much as I do (I wrote my first program when I was 4 and I&#x27;m 39 now), but I have accepted that it&#x27;s not a weakness on their part, it&#x27;s a weakness on my part.  I wouldn&#x27;t lower my standards (as a manager once suggested), but I do feel like it&#x27;s my obligation to lead them on a journey of learning.  That is to say, people don&#x27;t learn without teaching, so be a teacher.</div><br/></div></div></div></div><div id="42047716" class="c"><input type="checkbox" id="c-42047716" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42047526">prev</a><span>|</span><a href="#42048331">next</a><span>|</span><label class="collapse" for="c-42047716">[-]</label><label class="expand" for="c-42047716">[2 more]</label></div><br/><div class="children"><div class="content">I think this, or something of equal complexity, is probably the right choice.  I have spent a lot of time helping people with their dev environments, and the same problems keep coming up; &quot;no, you need this version of kubectl&quot;, &quot;no, you need this version of jq&quot;, &quot;no, the Makefile expects THIS version of The Silver Searcher&quot;.  A mass of shell scripts and random utilities was a consistent drag on the entire team and everyone that interacted with the team.<p>I ended up going with Bazel, not because of this particular problem alone (though it was part of it; people we hired spent WEEKS trying to get a happy edit&#x2F;test&#x2F;debug cycle going), but because proper dependency-based test caching was sorely needed.  Using Bazel and Buildbuddy brought CI down from about 17 minutes per run to 3-4 minutes for a typical change, which meant that even if people didn&#x27;t want to get a local setup going, they could at least be slightly productive.  I also made sure that every dependency &#x2F; tool useful for developing the product was versioned in the repository, so if something needs `psql` you can `bazel run &#x2F;&#x2F;tools&#x2F;postgres&#x2F;psql` and have it just work.  (Hate that Postgres can&#x27;t be statically linked, though.)<p>It was a lot of work for me, and people do gripe about some things (&quot;I liked `go test .&#x2F;...`, I can&#x27;t adjust to `bazel test ...`&quot;), but all in all, it does work well.  I would do it again.  Day 1 at the company; git clone our thing, install bazelisk, and your environment setup is done.  All the tests pass.  You can run the app locally with a simple `bazel run`.  I&#x27;m pretty happy with the outcome.<p>Nix is something I looked into for our container images, but they just end up being too big.  I never figured out why; I think a lot of things are dynamically linked and they include their own &#x2F;usr&#x2F;lib tree with the entire transitive dependency chain for that particular app, even if other things you have installed have some overlap with that dependency chain.  I prefer the approach of statically linking everything and only including what you need.  I compromised by basing things on Debian and rules_distroless, which at least lets you build a container image with the exact same sha256 on two different machines.  (We previously just did &quot;FROM scratch; COPY &lt;statically linked binary&gt; &#x2F;app; ENTRYPOINT &#x2F;app&quot;, but then started needing things like pg_dump in our image.  If you can just have a single statically-linked binary be your entire app, great.  Sometimes you can&#x27;t, and then you need some sort of reasonable solution.  Also everything ends up growing a dependency on ca-certificates...)</div><br/><div id="42049091" class="c"><input type="checkbox" id="c-42049091" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42047716">parent</a><span>|</span><a href="#42048331">next</a><span>|</span><label class="collapse" for="c-42049091">[-]</label><label class="expand" for="c-42049091">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think a lot of things are dynamically linked and they include their own &#x2F;usr&#x2F;lib tree with the entire transitive dependency chain for that particular app, even if other things you have installed have some overlap with that dependency chain. I prefer the approach of statically linking everything and only including what you need.<p>Wherever there&#x27;s such overlap, those dependencies are already shared. Static linking in such a situation means <i>more</i> disk usage, not less.<p>Packages in Nixpkgs have large closure sizes for entirely other reasons, like not splitting packages as aggressively as they could be split, or enabling&#x2F;including most optional dependencies by default. Distros like Alpine typically lean the other way for their defaults.<p>It&#x27;s true that if you&#x27;re willing to manually mangle them, static binaries are nice because you can very easily strip all docs and examples or even executables that you don&#x27;t need, and still know your executable will have the libs it&#x27;s linked against. In one place at work I actually do this with Nixpkgs— there&#x27;s a pkgsStatic that includes only statically compiled packages. I pull just the tiny parts of some package I need out and copy them onto a blank OCI image because it was the path of least resistance.<p>But Nix also has some really nice tools for inspecting dependency graphs to figure out why large packages are getting pulled in. nix-tree is my favorite, but there&#x27;s also the older nix-du that gives the same info via graphviz instead of the terminal, and the built-in `nix why-depends`.<p>-----<p>Edited to add: wait, are you saying you used some other base distro to create Docker images where some things were supplied by Nix and others came from the base distro? If so, yeah, Nix is going to bring all the dependencies along, all the way down to libc or whatever. That&#x27;s required for the kind of hermeticity that is its goal.<p>Mixed images like that are always going to be larger. But you also don&#x27;t need a base distro at all with Nix. You can use one of the existing Nix libraries for Docker&#x2F;OCI stuff to generate a complete image from scratch, or just copy your Nix packages&#x27; dependency closure onto an empty image with a FROM SCRATCH Dockerfile.<p>If you can&#x27;t do that, you can do various things to try to slim things down but it&#x27;s best to just Nixify whatever other packages you&#x27;re using so you don&#x27;t need a base distro. (And if you&#x27;re trying to save space, Nix itself doesn&#x27;t need to be in your Docker images either, which can also cut out some deps.)</div><br/></div></div></div></div><div id="42048331" class="c"><input type="checkbox" id="c-42048331" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42047716">prev</a><span>|</span><a href="#42046147">next</a><span>|</span><label class="collapse" for="c-42048331">[-]</label><label class="expand" for="c-42048331">[5 more]</label></div><br/><div class="children"><div class="content">After my personal 2-year experiment with NixOS, I&#x27;d avoid anything Nix like the plague, and would be looking for a new job if anyone instituted a Nix-only policy.<p>It&#x27;s not the learning new things that&#x27;s a problem, but rather the fact that every little issue turns into a 2-day marathon that&#x27;s eventually solved with a  1-line fix. And that&#x27;s because the feedback loop and general UX is just awful - I really started to feel like I needed a sacrificial chicken.<p>Docker may be a dumpster fire, but at least it&#x27;s generally easy to see what you did wrong and fix it.</div><br/><div id="42049340" class="c"><input type="checkbox" id="c-42049340" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048331">parent</a><span>|</span><a href="#42048948">next</a><span>|</span><label class="collapse" for="c-42049340">[-]</label><label class="expand" for="c-42049340">[2 more]</label></div><br/><div class="children"><div class="content">Literally every Docker image you&#x27;ve ever downloaded comes from a build that only worked (essentially) &quot;by accident.&quot;<p>If Docker builds were as deterministic as Nix, then all that would need to be distributed would be Dockerfiles and perhaps a cache of base images somewhere.<p>Looking at a build as a pure function where each dependency (including any compiler(s), plus the environment), are &quot;input arguments&quot; to it, was a revelation (since I already realized the advantages of pure functions while working in functional languages).<p>Running a Dockerfile and hoping to get a working image out of it is like running a function which checks the time when it runs and errors when the seconds end in 0 due to a bug.<p>&gt; every little issue turns into a 2-day marathon that&#x27;s eventually solved with a 1-line fix<p>There is spotty education in the space. Did you ever take this (very cool) Nix tutorial? Not actually understanding Nix is going to make any troubleshooting of Nix much harder. <a href="https:&#x2F;&#x2F;nixcloud.io&#x2F;tour&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nixcloud.io&#x2F;tour&#x2F;</a><p>&gt; I really started to feel like I needed a sacrificial chicken.<p>Have you looked at Guix? A lot of people think it&#x27;s &quot;Nix without the warts.&quot; Plus it uses a Lisp, which some people prefer, or can at least grok better than the Nix language. <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;</a></div><br/><div id="42049857" class="c"><input type="checkbox" id="c-42049857" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42049340">parent</a><span>|</span><a href="#42048948">next</a><span>|</span><label class="collapse" for="c-42049857">[-]</label><label class="expand" for="c-42049857">[1 more]</label></div><br/><div class="children"><div class="content">I watched all the videos, read all the tutorials (including the &quot;super easy&quot; ones). I understand the Nix language, but the actual infrastructure is just so damn convoluted and fragile, the error feedback mechanisms are worse than useless, and the documentation assumes that you already know everything inside and out. It reminds me of the bad old days of the neckbeard gatekeepers.<p>I&#x27;ll take a look at guix, though...</div><br/></div></div></div></div><div id="42048948" class="c"><input type="checkbox" id="c-42048948" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048331">parent</a><span>|</span><a href="#42049340">prev</a><span>|</span><a href="#42046147">next</a><span>|</span><label class="collapse" for="c-42048948">[-]</label><label class="expand" for="c-42048948">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ...but at least it&#x27;s generally easy to see what you did wrong and fix it.<p>You&#x27;re not actually &quot;fixing&quot; anything, you&#x27;re just passing the ball of shit down the responsibility chain to the ops&#x2F;infra team.<p>Which is fine if you work in a large corporation where this is a valid strategy.<p>Unfortunately though the software supply chain problem is a) very difficult and b) unavoidable.<p>Nix is the best (or maybe only) attempt to solve this problem with programmatic (vs organizational) tooling.</div><br/><div id="42049831" class="c"><input type="checkbox" id="c-42049831" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42048948">parent</a><span>|</span><a href="#42046147">next</a><span>|</span><label class="collapse" for="c-42049831">[-]</label><label class="expand" for="c-42049831">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got nothing against the fundamental concepts that Nix strives for. In fact, that&#x27;s what triggered my 2 year journey with it. I just hate the implementation with a passion. The overall result is worse than before.</div><br/></div></div></div></div></div></div><div id="42046147" class="c"><input type="checkbox" id="c-42046147" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42048331">prev</a><span>|</span><a href="#42048935">next</a><span>|</span><label class="collapse" for="c-42046147">[-]</label><label class="expand" for="c-42046147">[2 more]</label></div><br/><div class="children"><div class="content">In a worse world, worse is better.</div><br/><div id="42049368" class="c"><input type="checkbox" id="c-42049368" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42046147">parent</a><span>|</span><a href="#42048935">next</a><span>|</span><label class="collapse" for="c-42049368">[-]</label><label class="expand" for="c-42049368">[1 more]</label></div><br/><div class="children"><div class="content">this is such an awful truth to even say aloud lol but... yeah.<p>which is why you gotta find your peeps that believe in the better world and are thus believing it into existence. (OT: reminds me of this song title: <a href="https:&#x2F;&#x2F;soundcloud.com&#x2F;anjunabeats&#x2F;mat-zo-see-it-when-i-believe-it" rel="nofollow">https:&#x2F;&#x2F;soundcloud.com&#x2F;anjunabeats&#x2F;mat-zo-see-it-when-i-beli...</a>)</div><br/></div></div></div></div><div id="42048935" class="c"><input type="checkbox" id="c-42048935" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42046147">prev</a><span>|</span><a href="#42047504">next</a><span>|</span><label class="collapse" for="c-42048935">[-]</label><label class="expand" for="c-42048935">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there is no (to my knowledge) general-purpose, broadly-accepted way to deploy via Nix<p>`nix copy .#my-crap --to ssh:&#x2F;&#x2F;remote`<p>What you do with it then on the remote depends on your environment. At the minimum do a `nix-store --add-root` to make a symlink to whatever you just copied.<p>(The most painless path is if you&#x27;re deploying an entire NixOS system, but that requires converting the remote host to NixOS first.)</div><br/></div></div><div id="42047504" class="c"><input type="checkbox" id="c-42047504" checked=""/><div class="controls bullet"><span class="by">nixdev</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42048935">prev</a><span>|</span><a href="#42045825">next</a><span>|</span><label class="collapse" for="c-42047504">[-]</label><label class="expand" for="c-42047504">[1 more]</label></div><br/><div class="children"><div class="content">Heh, yeah. You gotta put in writing that only userlands defined in Nix will be eligible to enter any environment beyond &quot;dev&quot;. And (also put in writing) that their performance in the role will be partly evaluated on their ability to reach out for help with Nix when they need it.</div><br/></div></div><div id="42045825" class="c"><input type="checkbox" id="c-42045825" checked=""/><div class="controls bullet"><span class="by">oblio</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42047504">prev</a><span>|</span><a href="#42046800">next</a><span>|</span><label class="collapse" for="c-42045825">[-]</label><label class="expand" for="c-42045825">[2 more]</label></div><br/><div class="children"><div class="content">I think if you take about 80% of your comment and replace &quot;Nix&quot; with &quot;Haskell&#x2F;Lisp&quot; and a few other techs, you&#x27;d basically have the same thing. Especially point #1.</div><br/><div id="42047357" class="c"><input type="checkbox" id="c-42047357" checked=""/><div class="controls bullet"><span class="by">strawhatguy</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045825">parent</a><span>|</span><a href="#42046800">next</a><span>|</span><label class="collapse" for="c-42047357">[-]</label><label class="expand" for="c-42047357">[1 more]</label></div><br/><div class="children"><div class="content">Too true. I think there&#x27;s a lot of people who <i>don&#x27;t</i> want control; freedom is responsibility, as the saying goes, and responsibility can be stressful, even if it&#x27;s liberating also.<p>Worse is better, sadly.</div><br/></div></div></div></div><div id="42046800" class="c"><input type="checkbox" id="c-42046800" checked=""/><div class="controls bullet"><span class="by">bamboozled</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045620">parent</a><span>|</span><a href="#42045825">prev</a><span>|</span><a href="#42048516">next</a><span>|</span><label class="collapse" for="c-42046800">[-]</label><label class="expand" for="c-42046800">[2 more]</label></div><br/><div class="children"><div class="content">Try Devbox, you can basically ignore nix entirely and reap all the benefits.</div><br/><div id="42049377" class="c"><input type="checkbox" id="c-42049377" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42046800">parent</a><span>|</span><a href="#42048516">next</a><span>|</span><label class="collapse" for="c-42049377">[-]</label><label class="expand" for="c-42049377">[1 more]</label></div><br/><div class="children"><div class="content">When I looked at it, I encountered some problem that unfortunately slips my mind now.</div><br/></div></div></div></div></div></div><div id="42048516" class="c"><input type="checkbox" id="c-42048516" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42045620">prev</a><span>|</span><a href="#42043162">next</a><span>|</span><label class="collapse" for="c-42048516">[-]</label><label class="expand" for="c-42048516">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve no problem with remote dev envs for most things.  But they have to be VMs in many cases, not containers.</div><br/></div></div><div id="42043162" class="c"><input type="checkbox" id="c-42043162" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42048516">prev</a><span>|</span><a href="#42045264">next</a><span>|</span><label class="collapse" for="c-42043162">[-]</label><label class="expand" for="c-42043162">[1 more]</label></div><br/><div class="children"><div class="content">Hello.  Currently debugging my kubernetes-based dev pod and not getting anything else done.  What fun!</div><br/></div></div><div id="42045264" class="c"><input type="checkbox" id="c-42045264" checked=""/><div class="controls bullet"><span class="by">nixdev</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42043162">prev</a><span>|</span><a href="#42044814">next</a><span>|</span><label class="collapse" for="c-42045264">[-]</label><label class="expand" for="c-42045264">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Personally - just let the developer own the machine they use for development.<p>Overall I agree with you that this is how it should be, but as DevOps working with so many development teams, I can tell you that too many developers know a language or two but beyond that barely know how to use a computer. Most developers (yes even most of the ones in Silicon Valley or the larger Bay Area) with Macbooks will smile and nod at when you tell them that Docker Desktop runs a virtual machine to run a copy of Linux to run oci images, and then not too much later reveal themselves to have been clueless.<p>Commenters on this site are generally expected to be in a different category. Just wanted to share that, as a seasoned DevOps pro, I can tell you it&#x27;s pretty rough out there.</div><br/><div id="42047579" class="c"><input type="checkbox" id="c-42047579" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045264">parent</a><span>|</span><a href="#42044814">next</a><span>|</span><label class="collapse" for="c-42047579">[-]</label><label class="expand" for="c-42047579">[1 more]</label></div><br/><div class="children"><div class="content">This is an unpopular take, but entirely true. Skilled at a programming language, other than maybe C, does not in any way translate to general skill with system administration, or even knowing how to correctly operate a computer. I once had to explain to a dev that their Mac was out of disk space because a. They had never removed dangling containers or old image versions b. They had never emptied the Trash.</div><br/></div></div></div></div><div id="42044814" class="c"><input type="checkbox" id="c-42044814" checked=""/><div class="controls bullet"><span class="by">jt2190</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42045264">prev</a><span>|</span><a href="#42044055">next</a><span>|</span><label class="collapse" for="c-42044814">[-]</label><label class="expand" for="c-42044814">[4 more]</label></div><br/><div class="children"><div class="content">I’m not sure we should leap from:<p>&gt; I have seen several attempts to move dev environments to a remote host. They invariably suck.<p>To “therefore they will <i>always</i> suck and have no benefits and nobody should ever use them ever”. Apologies for the hyperbole but I’m making a point that comments like these tend to shut down interesting explorations of the state of the art of remote computing and what the pros&#x2F;cons are.<p>Edit: In a world where users demand that companies implement excellent security then we must allow those same companies to limit physical access to their machines as much as possible.</div><br/><div id="42045206" class="c"><input type="checkbox" id="c-42045206" checked=""/><div class="controls bullet"><span class="by">horsawlarway</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42044814">parent</a><span>|</span><a href="#42044055">next</a><span>|</span><label class="collapse" for="c-42045206">[-]</label><label class="expand" for="c-42045206">[3 more]</label></div><br/><div class="children"><div class="content">But they don&#x27;t suck because of lack of effort - they suck because there are real physical constraints.<p>Ex - even on a <i>VERY</i> good connection, RTT on the network is going to exceed your frame latency for a computer sitting in front of you (before we even get into the latency of the actual frame rendering of that remote computer).  There&#x27;s just not a solution for &quot;make the light go faster&quot;.<p>Then we get into the issues the author actually laid out quite compellingly - Shared resources are unpredictable.  Is my code running slowly right now because I just introduced an issue, or is it because I&#x27;m sharing an env and my neighbor just ate 99% of the CPU&#x2F;IO, or my network provider has picked a different route and my latency just went up 500ms?<p>And that&#x27;s before we even touch the &quot;My machine is down&#x2F;unreachable, I don&#x27;t know why and I have no visibility into resolving the issue, when was my last commit again?&quot; style problems...<p>&gt; Edit: In a world where users demand that companies implement excellent security then we must allow those same companies to limit physical access to their machines as much as possible.<p>And this... is just bogus.  We&#x27;re not talking about machines running production data.  We&#x27;re talking about a developer environment.  Sure - limit access to prod machines all you like, while you&#x27;re at it, don&#x27;t give me any production user data either - I sure as hell don&#x27;t want it for local dev.  What I do want is a fast system that I control so that I can actually tweak it as needed to develop and debug the system - it is almost impossible to give a developer &quot;the least access needed&quot; to do development locally because if you know what that access was you wouldn&#x27;t be developing still.</div><br/><div id="42046548" class="c"><input type="checkbox" id="c-42046548" checked=""/><div class="controls bullet"><span class="by">sangnoir</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42045206">parent</a><span>|</span><a href="#42044055">next</a><span>|</span><label class="collapse" for="c-42046548">[-]</label><label class="expand" for="c-42046548">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But they don&#x27;t suck because of lack of effort - they suck because there are real physical constraints.<p>They <i>do</i> suck due to lack of effort or investment. FANG companies have remote dev experiences that are decent - or even great - because they invest obscene amounts into dev tooling.<p>There physical constraints on the flipside: especially for gigantic codebases or datasets that don&#x27;t fit on dev laptops or have need lower latencies to other services in the DC.<p>Added bonus: smaller attack surface area for adversaries who want to gain access to your code.</div><br/><div id="42047535" class="c"><input type="checkbox" id="c-42047535" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42046548">parent</a><span>|</span><a href="#42044055">next</a><span>|</span><label class="collapse" for="c-42047535">[-]</label><label class="expand" for="c-42047535">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t just the tooling though.<p>At least with Google, they also have a data center near where most developers work, so that they have much lower latency.<p>They can&#x27;t make the light go faster, but they can make it so it doesn&#x27;t go as far. Smaller companies usually don&#x27;t have a lot of flexibility with that though.</div><br/></div></div></div></div></div></div></div></div><div id="42044055" class="c"><input type="checkbox" id="c-42044055" checked=""/><div class="controls bullet"><span class="by">2075</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42044814">prev</a><span>|</span><a href="#42043311">next</a><span>|</span><label class="collapse" for="c-42044055">[-]</label><label class="expand" for="c-42044055">[1 more]</label></div><br/><div class="children"><div class="content">I think nowadays the value of source code is rarely a more valuable asset than the data being processed. Also I would prefer to give my devs just a second machine to run workloads and eventually pull in data or mock the data so they get moving more easily.</div><br/></div></div><div id="42043311" class="c"><input type="checkbox" id="c-42043311" checked=""/><div class="controls bullet"><span class="by">idunnoman1222</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42044055">prev</a><span>|</span><a href="#42044610">next</a><span>|</span><label class="collapse" for="c-42043311">[-]</label><label class="expand" for="c-42043311">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you are not using a lot of hardware - Rfid, POS, top-spec video cards, etc</div><br/></div></div><div id="42044610" class="c"><input type="checkbox" id="c-42044610" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42043311">prev</a><span>|</span><a href="#42047495">next</a><span>|</span><label class="collapse" for="c-42044610">[-]</label><label class="expand" for="c-42044610">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The only real downside is data control (ie - the company has less control over how a developer manages assets like source code). ). I&#x27;m my experience, the vast majority of companies should worry less about this [...]</i><p>I once had to burn a ton of political capital (including some on credit), because someone who didn&#x27;t understand software thought that cutting-edge tech startup software developers, even including systems programmers working close to metal, could work effectively using only virtual remote desktops... with a terrible VM configuration... from servers literally halfway around the world... through a very dodgy firewall and VPN... of 10Mb&#x2F;s total bandwidth... for the entire office of dozens of developers.<p>(And no other Internet access from the VMs.  Administrators would copy whatever files from the Internet that are needed for work.  And there was a bureaucratic form for a human process, if you wanted to request any code&#x2F;data to go in or out.  And the laptops&#x2F;workstations used only as thin-clients for the remote VMs would have to be Windows and run this ridiculous obscure &#x27;endpoint security&#x27; software that had changed hands from its ancient developer, and hadn&#x27;t even updated the marketing materials (e.g., a top bulletpoint was keeping your employees from wasting time on a Web site that famously was wiped out over a decade earlier), and presumably was littered with introduced vulnerabilities and instabilities.)<p>Note that this was <i>not</i> something like DoD, nor HIPAA, nor finance.  Just cutting-edge tech on which (ironically) we wanted first-mover advantage.<p>This escalated to the other top-titled software engineer and I together doing a presentation to C-suite, on why not only would this kill working productivity (especially in a startup that needed to do creative work fast!), but the bad actors someone was paranoid about could easily circumvent it anyway to exfiltrate data (using methods obvious to the skilled software people like they hired, some undetectable by any security product or even human monitoring they imagined), and all the good rule-following people would quit in incredulous frustration.<p>Unfortunately, it might not have been even the CEO&#x27;s call, but a crazy investor.</div><br/></div></div><div id="42047495" class="c"><input type="checkbox" id="c-42047495" checked=""/><div class="controls bullet"><span class="by">reissbaker</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42044610">prev</a><span>|</span><a href="#42043298">next</a><span>|</span><label class="collapse" for="c-42047495">[-]</label><label class="expand" for="c-42047495">[1 more]</label></div><br/><div class="children"><div class="content">If your app fits on one machine, I agree with you: you <i>absolutely</i> should not use cloud dev environments in my opinion (and I&#x27;ve worked on large dev infra teams, that shipped cloud dev environments). The performance and latency of a Macbook Pro (or Framework 13, or whatever) is going to destroy cloud perf for development purposes.<p>If it doesn&#x27;t fit on one machine, though, you don&#x27;t have another option: Meta, for example, will never have a local dev env for Instagram or Blue. Then you need to make some hard choices.<p>Personally, my ideal cloud dev env is:<p>1. Local checkout of the code you&#x27;re working on. You can use whatever IDE or text editor you prefer. For large monorepos, you&#x27;ll need some special tooling to make sure it&#x27;s easy to only check out slices of the repo.<p>2. Sync the code to the remote execution environment automatically, with hot-reloading.<p>3. Auto-port-forward from your local machine to the remote.<p>4. Optionally be able to run dependent services on your personal remote to debug&#x2F;test their interactions with each other, and optionally be able to connect to a well-maintained shared environment for dependencies you aren&#x27;t working on. If you have a shared environment, it can&#x27;t be viewed as less-important than production: if it&#x27;s broken, it&#x27;s a SEV and the team that broke it needs to drop everything and fix it immediately. (Otherwise the shared env will be broken all the time, and your shipping speed will either drop, or you&#x27;ll constantly be shipping bugs to prod due to lack of dev care.)<p>At Meta we didn&#x27;t have (1): everyone had to use VSCode, with special in-house plugins that synced to the remote environment. It was okay but honestly a little soul-sucking; I think customizing your tooling is part of a lot of people&#x27;s craft and helps maintain their flow state. Thankfully we had the rest, so it was tolerable if not enjoyable. At Airbnb we didn&#x27;t have the political will to enforce (4), so the dev env was always broken. I think (4) is actually the most critical part: it doesn&#x27;t matter how good the rest of it is, if the org doesn&#x27;t care about it working.<p>But yeah — if you don&#x27;t <i>need</i> it, that&#x27;s a lot of work and politics. Use local environments as long as you possibly can.</div><br/></div></div><div id="42044825" class="c"><input type="checkbox" id="c-42044825" checked=""/><div class="controls bullet"><span class="by">hintymad</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42043298">prev</a><span>|</span><a href="#42043305">next</a><span>|</span><label class="collapse" for="c-42044825">[-]</label><label class="expand" for="c-42044825">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Personally - just let the developer own the machine they use for development.<p>It&#x27;ll work if the company can offer something similar to EC2. Unfortunately most of the companies are not capable of doing so if they are not on cloud.</div><br/></div></div><div id="42043305" class="c"><input type="checkbox" id="c-42043305" checked=""/><div class="controls bullet"><span class="by">lotharcable</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42044825">prev</a><span>|</span><a href="#42046349">next</a><span>|</span><label class="collapse" for="c-42043305">[-]</label><label class="expand" for="c-42043305">[3 more]</label></div><br/><div class="children"><div class="content">I strongly recommend just switching the Dev environment over to Linux and taking advantage of tools like &quot;distrobox&quot; and &quot;toolbx&quot;.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;89luca89&#x2F;distrobox">https:&#x2F;&#x2F;github.com&#x2F;89luca89&#x2F;distrobox</a><p><a href="https:&#x2F;&#x2F;containertoolbx.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;containertoolbx.org&#x2F;</a><p>It is sorta like Vagrant, but instead of using virtualbox virtual machines you use podman containers.  This way you get to use OCI images for your &quot;dev environment&quot; that integrates directly into your desktop.<p><a href="https:&#x2F;&#x2F;podman.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;podman.io&#x2F;</a><p>There is some challenges related to usermode networking for non-root-managed controllers and desktop integration has some additional complications. But besides that it has almost no overhead and you can have unfettered access to things like GPUs.<p>Also it is usually pretty easy to convert your normal docker or kubernetes containers over to something you can run on your desktop.<p>Also it is possible to use things like Kubernetes pods definitions to deploy sets of containers with podman and manage it with systemd and such things.  So you can have &quot;clouds of containers&quot; that your dev container needs access to locally.<p>If there is a corporate need for window-specific applications then running Windows VMs or doing remote applications over RDP is a possible work around.<p>If everything you are targeting as a deployment is going to be Linux-everything then it doesn&#x27;t make a lot of sense to jump through a bunch of hoops and cause a bunch of headaches just to avoid having it as workstation OS.</div><br/><div id="42046839" class="c"><input type="checkbox" id="c-42046839" checked=""/><div class="controls bullet"><span class="by">trog</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043305">parent</a><span>|</span><a href="#42047600">next</a><span>|</span><label class="collapse" for="c-42046839">[-]</label><label class="expand" for="c-42046839">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re doing this, there are many cases where you might as well just spin up a decent Linux server and give your developers accounts on that? With some pretty basic setup everyone can just run their own stuff within their own user account.<p>You&#x27;ll run into occasional issues (e.g. if everyone is trying to run default node.js on default port) but with some basic guardrails it feels like it should be OK?<p>I&#x27;m remembering back to when my old company ran a lot of PHP projects. Each user just had their own development environment and their own Apache vhost. They wrote their code and tested it in their own vhost. Then we&#x27;d merge to a single separate vhost for further testing.<p>I am trying to remember anything about what was painful about it but it all basically Just Worked. Everyone had remote access via VPN; the worst case scenario for them was they&#x27;d have to work from home with a bit of extra latency.</div><br/></div></div><div id="42047600" class="c"><input type="checkbox" id="c-42047600" checked=""/><div class="controls bullet"><span class="by">h4ck_th3_pl4n3t</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42043305">parent</a><span>|</span><a href="#42046839">prev</a><span>|</span><a href="#42046349">next</a><span>|</span><label class="collapse" for="c-42047600">[-]</label><label class="expand" for="c-42047600">[1 more]</label></div><br/><div class="children"><div class="content">This.<p>Distrobox and podman are such a charm to use, and so easily integrated into dev environments and production environments.<p>The intentional daemon free concept is so much easier to setup in practice, as there&#x27;s no fiddly group management necessary anymore.<p>Just a 5 line systemd service file and that&#x27;s it. Easy as pie.</div><br/></div></div></div></div><div id="42046349" class="c"><input type="checkbox" id="c-42046349" checked=""/><div class="controls bullet"><span class="by">brunoborges</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42043305">prev</a><span>|</span><a href="#42043791">next</a><span>|</span><label class="collapse" for="c-42046349">[-]</label><label class="expand" for="c-42046349">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Personally - just let the developer own the machine they use for development.<p>I wonder if Microsoft&#x27;s approach for Dev Box is the right one.</div><br/><div id="42047160" class="c"><input type="checkbox" id="c-42047160" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#42042999">root</a><span>|</span><a href="#42046349">parent</a><span>|</span><a href="#42043791">next</a><span>|</span><label class="collapse" for="c-42047160">[-]</label><label class="expand" for="c-42047160">[1 more]</label></div><br/><div class="children"><div class="content">Could you elaborate on what that approach is?</div><br/></div></div></div></div><div id="42043791" class="c"><input type="checkbox" id="c-42043791" checked=""/><div class="controls bullet"><span class="by">speedisavirus</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42046349">prev</a><span>|</span><a href="#42046416">next</a><span>|</span><label class="collapse" for="c-42043791">[-]</label><label class="expand" for="c-42043791">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fine for some. However it&#x27;s not always that. I wrote an entire site on my ipad in spare time with GitPods. Maybe you are at a small company with a small team so if things get critical you are likely to get a call. Do you say F&#x27;it, do you carry your laptop, or do you carry your ipad like you already are knowing you can still at least do triage if needed because you have a perfectly configured gitpod to use.</div><br/></div></div><div id="42046416" class="c"><input type="checkbox" id="c-42046416" checked=""/><div class="controls bullet"><span class="by">to11mtm</span><span>|</span><a href="#42042999">parent</a><span>|</span><a href="#42043791">prev</a><span>|</span><a href="#42043111">next</a><span>|</span><label class="collapse" for="c-42046416">[-]</label><label class="expand" for="c-42046416">[1 more]</label></div><br/><div class="children"><div class="content"><i>laughs in &quot;Here&#x27;s a VDI with 2vCPUs and 32GB of RAM but the cluster is overloaded, also you get to budget which IDEs you have installed because you have only a couple hundred GB of storage for everything including what we install on the base image that you will never use&quot;</i></div><br/></div></div></div></div><div id="42049856" class="c"><input type="checkbox" id="c-42049856" checked=""/><div class="controls bullet"><span class="by">gloosx</span><span>|</span><a href="#42042999">prev</a><span>|</span><a href="#42042163">next</a><span>|</span><label class="collapse" for="c-42049856">[-]</label><label class="expand" for="c-42049856">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt;Kubernetes seems like the obvious choice for building out remote, standardized and automated development environments
</code></pre>
- Is it Obvious Choice™ though Fred?<p>- Hmm, let&#x27;s consult the graphs.<p><pre><code>  &gt;Kubernetes is a container orchestration system for automating software deployment.
</code></pre>
- It&#x27;s about automating <i>deployment</i> Carl, not development!<p><pre><code>  &gt;we’ve found that Kubernetes is not the right choice for building development environments.</code></pre></div><br/></div></div><div id="42042163" class="c"><input type="checkbox" id="c-42042163" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42049856">prev</a><span>|</span><a href="#42049785">next</a><span>|</span><label class="collapse" for="c-42042163">[-]</label><label class="expand" for="c-42042163">[7 more]</label></div><br/><div class="children"><div class="content">&gt; This is not a story of whether or not to use Kubernetes for production workloads that’s a whole separate conversation. As is the topic of how to build a comprehensive soup-to-nuts developer experience for shipping applications on Kubernetes.<p>&gt; This is the story of how (not) to build development environments in the cloud.<p>I&#x27;d like to request that the comment thread not turn into a bunch of generic k8s complaints. This is a legitimately interesting article about complicated engineering trade-offs faced by an organization with a very unique workload. Let&#x27;s talk about that instead of talking about the title!</div><br/><div id="42042312" class="c"><input type="checkbox" id="c-42042312" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#42042163">parent</a><span>|</span><a href="#42046408">next</a><span>|</span><label class="collapse" for="c-42042312">[-]</label><label class="expand" for="c-42042312">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. It&#x27;s actually a very interesting use case and I can easily see that K8s wouldn&#x27;t be the answer. My dev env is very definitely my &quot;pet&quot;, thank you very much!</div><br/><div id="42043196" class="c"><input type="checkbox" id="c-42043196" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#42042163">root</a><span>|</span><a href="#42042312">parent</a><span>|</span><a href="#42046408">next</a><span>|</span><label class="collapse" for="c-42043196">[-]</label><label class="expand" for="c-42043196">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;d be nice to editorialize the title a bit with &quot;... (for dev envs)&quot; for clarity.<p>Super useful negative example, and the lengths they pursued to make it fit! And no knock on the initial choice or impressive engineering, as many of the k8s problems they hit likely weren&#x27;t understood gaps at the time they chose k8s.<p>Which makes sense, given k8s roots in (a) not being a security isolation tool &amp; (b) targeting up-front configurability over runtime flexibility.<p>Neither of which mesh well with the co-hosted dev environment use case.</div><br/></div></div></div></div><div id="42046408" class="c"><input type="checkbox" id="c-42046408" checked=""/><div class="controls bullet"><span class="by">preommr</span><span>|</span><a href="#42042163">parent</a><span>|</span><a href="#42042312">prev</a><span>|</span><a href="#42049785">next</a><span>|</span><label class="collapse" for="c-42046408">[-]</label><label class="expand" for="c-42046408">[4 more]</label></div><br/><div class="children"><div class="content">Can someone clarify if they mean development environments, or if they&#x27;re talking about a service that they sell that&#x27;s related to development environments.<p>Because I don&#x27;t understand most of the article if it&#x27;s the former. How are things like performance are a concern for internal development environments? And why are so many things stateful - ideally there should be some kind of configuration&#x2F;secret management solution so that deployments are consistent.<p>If it&#x27;s the latter, then this is incredibly niche and maybe interesting, but unlikely to be applicable to anyone else.</div><br/><div id="42049619" class="c"><input type="checkbox" id="c-42049619" checked=""/><div class="controls bullet"><span class="by">bittermandel</span><span>|</span><a href="#42042163">root</a><span>|</span><a href="#42046408">parent</a><span>|</span><a href="#42047978">next</a><span>|</span><label class="collapse" for="c-42049619">[-]</label><label class="expand" for="c-42049619">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s for running their commercial products, which are stateful and long-lived developer environments.</div><br/></div></div><div id="42047978" class="c"><input type="checkbox" id="c-42047978" checked=""/><div class="controls bullet"><span class="by">wutwutwat</span><span>|</span><a href="#42042163">root</a><span>|</span><a href="#42046408">parent</a><span>|</span><a href="#42049619">prev</a><span>|</span><a href="#42049785">next</a><span>|</span><label class="collapse" for="c-42047978">[-]</label><label class="expand" for="c-42047978">[2 more]</label></div><br/><div class="children"><div class="content">4th paragraph in if you read the article…<p>&gt; This is not a story of whether or not to use Kubernetes for production workloads that’s a whole separate conversation. As is the topic of how to build a comprehensive soup-to-nuts developer experience for shipping applications on Kubernetes.<p>&gt; This is the story of how (not) to build development environments in the cloud.</div><br/><div id="42048098" class="c"><input type="checkbox" id="c-42048098" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42042163">root</a><span>|</span><a href="#42047978">parent</a><span>|</span><a href="#42049785">next</a><span>|</span><label class="collapse" for="c-42048098">[-]</label><label class="expand" for="c-42048098">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that this really answers their question.</div><br/></div></div></div></div></div></div></div></div><div id="42049785" class="c"><input type="checkbox" id="c-42049785" checked=""/><div class="controls bullet"><span class="by">bluelightning2k</span><span>|</span><a href="#42042163">prev</a><span>|</span><a href="#42042383">next</a><span>|</span><label class="collapse" for="c-42049785">[-]</label><label class="expand" for="c-42049785">[1 more]</label></div><br/><div class="children"><div class="content">The debate in the comments about whether you should run locally is fascinating.<p>To the people saying ultra modern hardware could handle it: worth remembering the companies on question started on this path X years ago with Y set of technologies and Z set of experiences.<p>Because it made sense for Google in 2012 or whatever doesn&#x27;t necessarily mean they would choose it again --or not-- given a do over (but there&#x27;s basically no way back).</div><br/></div></div><div id="42042383" class="c"><input type="checkbox" id="c-42042383" checked=""/><div class="controls bullet"><span class="by">ensignavenger</span><span>|</span><a href="#42049785">prev</a><span>|</span><a href="#42046276">next</a><span>|</span><label class="collapse" for="c-42042383">[-]</label><label class="expand" for="c-42042383">[7 more]</label></div><br/><div class="children"><div class="content">The article does a great job of explaining the challenges they ran into with Kubernetes, and some of the things they tried... but I feel like it drops the ball at the end by not telling us at least a little what they chose instead.  The article mentions they  call their new solution &quot;Gitpod Flex&quot; but there is nothing about what Gitpod Flex is.  They said they tried microVMs and decided against them, and of course Kubernetes, the focus of the article.  So is GitpodFlex based on full VM&#x27;s?  Docker?  Some other container runtime??<p>Perhaps a followup article will go into detail about their replacement.</div><br/><div id="42042638" class="c"><input type="checkbox" id="c-42042638" checked=""/><div class="controls bullet"><span class="by">loujaybee</span><span>|</span><a href="#42042383">parent</a><span>|</span><a href="#42046276">next</a><span>|</span><label class="collapse" for="c-42042638">[-]</label><label class="expand" for="c-42042638">[6 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s fair. The blog was getting quite long, so we need to do some deeper dives in follow-ups.<p>Gitpod Flex is runner-based. The runner interface is intentionally generic so that we can support different clouds, on-prem or just Linux in future.<p>The first implemented runner is built around AWS primitives like EC2, EBS and ECS. But because of the more generic interface Gitpod now supports local &#x2F; desktop environments on MacOS. And again, future OS support will come.<p>There’s a bit more information in the docs, but we will do some follow ups!<p>- <a href="https:&#x2F;&#x2F;www.gitpod.io&#x2F;docs&#x2F;flex&#x2F;runners&#x2F;aws&#x2F;setup-aws-runners" rel="nofollow">https:&#x2F;&#x2F;www.gitpod.io&#x2F;docs&#x2F;flex&#x2F;runners&#x2F;aws&#x2F;setup-aws-runner...</a>
- <a href="https:&#x2F;&#x2F;www.gitpod.io&#x2F;docs&#x2F;flex&#x2F;gitpod-desktop" rel="nofollow">https:&#x2F;&#x2F;www.gitpod.io&#x2F;docs&#x2F;flex&#x2F;gitpod-desktop</a><p>(I work at Gitpod)</div><br/><div id="42042784" class="c"><input type="checkbox" id="c-42042784" checked=""/><div class="controls bullet"><span class="by">nickstinemates</span><span>|</span><a href="#42042383">root</a><span>|</span><a href="#42042638">parent</a><span>|</span><a href="#42049460">next</a><span>|</span><label class="collapse" for="c-42042784">[-]</label><label class="expand" for="c-42042784">[2 more]</label></div><br/><div class="children"><div class="content">Echoing the parent you&#x27;re replying to. You built up all of the context and missed they payoff.</div><br/><div id="42043255" class="c"><input type="checkbox" id="c-42043255" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#42042383">root</a><span>|</span><a href="#42042784">parent</a><span>|</span><a href="#42049460">next</a><span>|</span><label class="collapse" for="c-42043255">[-]</label><label class="expand" for="c-42043255">[1 more]</label></div><br/><div class="children"><div class="content">I thought it was fair.<p>&gt;&gt; <i>We’ll be posting a lot more about Gitpod Flex architecture in the coming weeks or months.</i><p>Cramming more detail into this post would have exceeded the average user read time ceiling.</div><br/></div></div></div></div><div id="42049460" class="c"><input type="checkbox" id="c-42049460" checked=""/><div class="controls bullet"><span class="by">weikju</span><span>|</span><a href="#42042383">root</a><span>|</span><a href="#42042638">parent</a><span>|</span><a href="#42042784">prev</a><span>|</span><a href="#42045951">next</a><span>|</span><label class="collapse" for="c-42049460">[-]</label><label class="expand" for="c-42049460">[1 more]</label></div><br/><div class="children"><div class="content">What’s a “runner”?</div><br/></div></div><div id="42045951" class="c"><input type="checkbox" id="c-42045951" checked=""/><div class="controls bullet"><span class="by">ensignavenger</span><span>|</span><a href="#42042383">root</a><span>|</span><a href="#42042638">parent</a><span>|</span><a href="#42049460">prev</a><span>|</span><a href="#42044294">next</a><span>|</span><label class="collapse" for="c-42045951">[-]</label><label class="expand" for="c-42045951">[1 more]</label></div><br/><div class="children"><div class="content">Awesome, looking forward to hearing more.  I only recently began testing out Theia and OpenVSCodeServer, I really appreciate Gitpod&#x27;s contributions to open source!</div><br/></div></div><div id="42044294" class="c"><input type="checkbox" id="c-42044294" checked=""/><div class="controls bullet"><span class="by">Bombthecat</span><span>|</span><a href="#42042383">root</a><span>|</span><a href="#42042638">parent</a><span>|</span><a href="#42045951">prev</a><span>|</span><a href="#42046276">next</a><span>|</span><label class="collapse" for="c-42044294">[-]</label><label class="expand" for="c-42044294">[1 more]</label></div><br/><div class="children"><div class="content">Still No idea what you did technically... Maybe a second post?<p>Did you use consul?</div><br/></div></div></div></div></div></div><div id="42046276" class="c"><input type="checkbox" id="c-42046276" checked=""/><div class="controls bullet"><span class="by">rahen</span><span>|</span><a href="#42042383">prev</a><span>|</span><a href="#42044841">next</a><span>|</span><label class="collapse" for="c-42046276">[-]</label><label class="expand" for="c-42046276">[3 more]</label></div><br/><div class="children"><div class="content">Kubernetes works great for stateless workloads.<p>For anything stateful, monolithic, or that doesn&#x27;t require autoscaling, I find LXC more appropriate:<p>- it can be clusterized (LXD&#x2F;Incus), like K8S but unlike Compose<p>- it exposes some tooling to the data plane, especially a load balancer, like K8S<p>- it offers system instances with a complete distribution and a init system, like a VM but unlike a Docker container<p>- it can orchestrate both VMs (including Windows VMs) and LXC containers at the same time in the same cluster<p>- LXC containers have the same performance as Docker containers unlike a VM<p>- it uses a declarative syntax<p>- it can be used as a foundation layer for anything stateful or stateless, including the Kubernetes cluster<p>LXD&#x2F;Incus sits somewhere between Docker Swarm and a vCenter cluster, which makes it one of the most versatile platform. Nomad is also a nice contender, it cannot orchestrate LXC containers but can autoscale a variety of workloads, including Java apps and qemu VMs.</div><br/><div id="42049350" class="c"><input type="checkbox" id="c-42049350" checked=""/><div class="controls bullet"><span class="by">OneCricketeer</span><span>|</span><a href="#42046276">parent</a><span>|</span><a href="#42047129">next</a><span>|</span><label class="collapse" for="c-42049350">[-]</label><label class="expand" for="c-42049350">[1 more]</label></div><br/><div class="children"><div class="content">Nomad cannot orchestrate what, exactly? <a href="https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;nomad&#x2F;tutorials&#x2F;plugins&#x2F;plugin-lxc" rel="nofollow">https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;nomad&#x2F;tutorials&#x2F;plugins&#x2F;plug...</a></div><br/></div></div><div id="42047129" class="c"><input type="checkbox" id="c-42047129" checked=""/><div class="controls bullet"><span class="by">belthesar</span><span>|</span><a href="#42046276">parent</a><span>|</span><a href="#42049350">prev</a><span>|</span><a href="#42044841">next</a><span>|</span><label class="collapse" for="c-42047129">[-]</label><label class="expand" for="c-42047129">[1 more]</label></div><br/><div class="children"><div class="content">I too am rallying quickly to the Incus way of doing things. Also of note, there&#x27;s an effort to build a utility to write Compose manifests for Incus workloads that I&#x27;m following very closely. <a href="https:&#x2F;&#x2F;github.com&#x2F;bketelsen&#x2F;incus-compose">https:&#x2F;&#x2F;github.com&#x2F;bketelsen&#x2F;incus-compose</a></div><br/></div></div></div></div><div id="42044841" class="c"><input type="checkbox" id="c-42044841" checked=""/><div class="controls bullet"><span class="by">concerndc1tizen</span><span>|</span><a href="#42046276">prev</a><span>|</span><a href="#42042522">next</a><span>|</span><label class="collapse" for="c-42044841">[-]</label><label class="expand" for="c-42044841">[9 more]</label></div><br/><div class="children"><div class="content">Sounds more to me like they need a new CTO.<p>And that they&#x27;re desperate to tell customers that they&#x27;ve fixed their problems.<p>Kubernetes is absolutely the wrong tool for this use case, and I argue that this should be obvious to someone in a CTO-level position, or their immediate advisors.<p>Kubernetes excels as a microservices platform, running reasonably trustworthy workloads. The key features of Kubernetes are rollout (highly available upgrades), elasticity (horizontal scaleout), bin packing (resource limits), CSI (dynamically mounted block storage), and so on. All this relates to a highly dynamic environment.<p>This is not at all what Gitpod needs. They need high performance disks, ballooning memory, live migrations, and isolated workloads.<p>Kubernetes does not provide you sufficient security boundaries for untrusted workloads. You need virtualization for that, and ideally physically separate machines.<p>Another major mistake they made was trying to build this on public cloud infrastructure. Of course the performance will be ridiculous.<p>However, one major reason for using Kubernetes is sharing the GPU. That is, to my knowledge, not possible with virtualization. But again, do you want to risk sharing your data, on a shared GPU?</div><br/><div id="42049699" class="c"><input type="checkbox" id="c-42049699" checked=""/><div class="controls bullet"><span class="by">bittermandel</span><span>|</span><a href="#42044841">parent</a><span>|</span><a href="#42049056">next</a><span>|</span><label class="collapse" for="c-42049699">[-]</label><label class="expand" for="c-42049699">[1 more]</label></div><br/><div class="children"><div class="content">I consider Kubernetes to be an excellent framework to build these kinds of applications. The difference here is Gitpod being stateful, which is notoriously hard on Kubernetes, though easier now than ever before!<p>To clarify on one of your points, Kubernetes itself has nothing to do with actually <i>setting</i> the security boundaries. It only providers a schema to describe resources and policies, and then an underlying system (perhaps Cilium for networking, or Kata Containers for micro VMs) can ensure that the resources created actually follow those schemas and policies.<p>For example, Neon have built <a href="https:&#x2F;&#x2F;github.com&#x2F;neondatabase&#x2F;autoscaling">https:&#x2F;&#x2F;github.com&#x2F;neondatabase&#x2F;autoscaling</a> which manages Neon Instances with Kubernetes by running them with QEMU instead. This allows them to do live migrations and resource (de)allocation while the service is running, without having to replace Kubernetes. These workloads are, as far as I understand it, stateless.</div><br/></div></div><div id="42046216" class="c"><input type="checkbox" id="c-42046216" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#42044841">parent</a><span>|</span><a href="#42049056">prev</a><span>|</span><a href="#42046750">next</a><span>|</span><label class="collapse" for="c-42046216">[-]</label><label class="expand" for="c-42046216">[3 more]</label></div><br/><div class="children"><div class="content">I agree on the cloud thing. Don&#x27;t agree that &quot;high performance disks, ballooning memory, live migrations, and isolated workloads&quot; preclude from using k8s - you can still run it as base layer. You get some central configuration storage, machine management and some other niceties for free and you can push your VM-specific features into your application pod. In fact, that&#x27;s how Google Cloud is designed (except they use Borg not k8s but same idea).</div><br/><div id="42047182" class="c"><input type="checkbox" id="c-42047182" checked=""/><div class="controls bullet"><span class="by">concerndc1tizen</span><span>|</span><a href="#42044841">root</a><span>|</span><a href="#42046216">parent</a><span>|</span><a href="#42046750">next</a><span>|</span><label class="collapse" for="c-42047182">[-]</label><label class="expand" for="c-42047182">[2 more]</label></div><br/><div class="children"><div class="content">True! I love the idea of using K8s to orchestrate the running of VMs. With graceful shutdown and distributed storage, it makes it even more trivial to semi-live migrate VMs.<p>Are you aware of the limits? It must run as root and privileged?</div><br/><div id="42047399" class="c"><input type="checkbox" id="c-42047399" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#42044841">root</a><span>|</span><a href="#42047182">parent</a><span>|</span><a href="#42046750">next</a><span>|</span><label class="collapse" for="c-42047399">[-]</label><label class="expand" for="c-42047399">[1 more]</label></div><br/><div class="children"><div class="content">In this scenario k8s is orchestrating the hypervisor,
not VMs themselves. Hypervisor then orchestrates VMs + network (eg OVS) + other supporting functions (logs shipping, etc) on each individual “worker” node. VM scheduling&#x2F;migration component needs to be completely decoupled from k8s apiserver (but itself can still run as normal k8s deployment) bc scaling kube api with unbound users is challenging. And yes, hypervisor will need to run privileged but you can limit it to worker nodes only</div><br/></div></div></div></div></div></div><div id="42046750" class="c"><input type="checkbox" id="c-42046750" checked=""/><div class="controls bullet"><span class="by">ed_mercer</span><span>|</span><a href="#42044841">parent</a><span>|</span><a href="#42046216">prev</a><span>|</span><a href="#42042522">next</a><span>|</span><label class="collapse" for="c-42046750">[-]</label><label class="expand" for="c-42046750">[3 more]</label></div><br/><div class="children"><div class="content">Why would you say that performance is bad on public cloud infrastructure?</div><br/><div id="42047247" class="c"><input type="checkbox" id="c-42047247" checked=""/><div class="controls bullet"><span class="by">concerndc1tizen</span><span>|</span><a href="#42044841">root</a><span>|</span><a href="#42046750">parent</a><span>|</span><a href="#42042522">next</a><span>|</span><label class="collapse" for="c-42047247">[-]</label><label class="expand" for="c-42047247">[2 more]</label></div><br/><div class="children"><div class="content">There are things that public cloud is great for.
Cost efficiency at high performance is not it.
For Gitpod, performance is critical to their product offering, because any latency in a dev environment is terrible UX.<p>Example: What performance do you get out of your NVMe disks?
Because these days you can build storage that delivers 100-200 GB&#x2F;s.<p><a href="https:&#x2F;&#x2F;www.graidtech.com&#x2F;wp-content&#x2F;uploads&#x2F;2023&#x2F;04&#x2F;Results-Summary-Tables_Sequential-1024x566.jpg" rel="nofollow">https:&#x2F;&#x2F;www.graidtech.com&#x2F;wp-content&#x2F;uploads&#x2F;2023&#x2F;04&#x2F;Results...</a><p>I bet few public cloud customers are seeing that kind of performance.</div><br/><div id="42049115" class="c"><input type="checkbox" id="c-42049115" checked=""/><div class="controls bullet"><span class="by">ed_mercer</span><span>|</span><a href="#42044841">root</a><span>|</span><a href="#42047247">parent</a><span>|</span><a href="#42042522">next</a><span>|</span><label class="collapse" for="c-42049115">[-]</label><label class="expand" for="c-42049115">[1 more]</label></div><br/><div class="children"><div class="content">This is also my personal experience. I am finding that building out our own high-performance cluster of (second-hand) servers is orders of magnitude cheaper than having the same on GCP, even though we have to maintain&#x2F;configure everything ourselves.</div><br/></div></div></div></div></div></div></div></div><div id="42042522" class="c"><input type="checkbox" id="c-42042522" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#42044841">prev</a><span>|</span><a href="#42048931">next</a><span>|</span><label class="collapse" for="c-42042522">[-]</label><label class="expand" for="c-42042522">[5 more]</label></div><br/><div class="children"><div class="content">I do agree with the points in article that k8s is not a good fit for development environments.<p>In my opinion, k8s is great for stable and consistent deployment&#x2F;orchestration of applications. Dev environments by default are in a constant state of flux.<p>I don’t understand the need for “cloud development environments” though. Isn’t the point of containerized apps is to avoid the need for synchronizing dev envs amongst teams?<p>Or maybe this product is supposed to decrease onboarding friction?</div><br/><div id="42042602" class="c"><input type="checkbox" id="c-42042602" checked=""/><div class="controls bullet"><span class="by">sofixa</span><span>|</span><a href="#42042522">parent</a><span>|</span><a href="#42042965">next</a><span>|</span><label class="collapse" for="c-42042602">[-]</label><label class="expand" for="c-42042602">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s to ensure a consistent environment for all developers, with the resources required. E.g. they mention GPUs, for developers working with GPU-intensive workloads. You can ship all developers gaming laptops with 64GB RAM and proper GPUs, and have them fight the environment to get the correct libraries as you have in prod (even with containers that&#x27;s not trivial), or you can ship them Macbook Airs and similar, and have them run consistent (the same) dev environments remotely (you can self-host gitpod, it&#x27;s not only a cloud service, it&#x27;s more the API&#x2F;environment to get consistent remote dev enviornments).</div><br/><div id="42042963" class="c"><input type="checkbox" id="c-42042963" checked=""/><div class="controls bullet"><span class="by">loujaybee</span><span>|</span><a href="#42042522">root</a><span>|</span><a href="#42042602">parent</a><span>|</span><a href="#42042965">next</a><span>|</span><label class="collapse" for="c-42042963">[-]</label><label class="expand" for="c-42042963">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, exactly. Containers locally are a basic foundation. But usually those containers or services need to talk to one another, they need some form of auth and credentials, they need some networking setup. There&#x27;s a lot of configuration in all of that. The more devs swap projects or the more complex the thing you&#x27;re working on the more the challenge grows. Automating depedencies, secret access, ensuring projects have the right memory, cpu, gpu etc. Also security - moving source code off your laptop and devices and standardizing your setups helps if you need to do a lot of audit and compliance as you can automate it.</div><br/></div></div></div></div><div id="42042965" class="c"><input type="checkbox" id="c-42042965" checked=""/><div class="controls bullet"><span class="by">roshbhatia</span><span>|</span><a href="#42042522">parent</a><span>|</span><a href="#42042602">prev</a><span>|</span><a href="#42042948">next</a><span>|</span><label class="collapse" for="c-42042965">[-]</label><label class="expand" for="c-42042965">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, the case where this becomes really valuable is if your team needs access to either different kinds of hardware or really expensive hardware that changes relatively quickly (i.e. GPUs). At a previous small startup I setup <a href="https:&#x2F;&#x2F;devpod.sh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devpod.sh&#x2F;</a> (similar to gitpod) for our MLE&#x2F;Data team. It was a big pro to leverage our existing k8s setup w&#x2F; little configuration needed to get these developer envs up and running as-needed, and we could piggyback off of our existing cost tracking tooling to measure usage, but I do feel like we already had infra conducive to running dev envs on k8s before making this decision -- we had cost tracking tooling, we had a dedicated k8s cluster for tooling, we had already been supporting GPU based workloads in k8s, and our platform team that managed all the k8s infra also were the SMEs for anything devenv releated. In a world where we started fresh and absolutely needed ephemeral devenvs, I think the native devcontainer functionality in vscode or something like github codespaces would have been our go to, but even then I&#x27;d push for a docker-compose based workflow prior to touching any of these other tools.<p>The rest of our eng team just did dev on their laptops though. I do think there was a level of batteries-included-ness that came with the ephemeral dev envs which our less technical data scientists appreciated, but the rest of our developers did not. Just my 2c</div><br/></div></div><div id="42042948" class="c"><input type="checkbox" id="c-42042948" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#42042522">parent</a><span>|</span><a href="#42042965">prev</a><span>|</span><a href="#42048931">next</a><span>|</span><label class="collapse" for="c-42042948">[-]</label><label class="expand" for="c-42042948">[1 more]</label></div><br/><div class="children"><div class="content">Sarcastically, CDE is one way to move cost from CAPEX (get your developer a Mac Book Pro) to OPEX (a monthly subscription that you only need to pay as long as the dev has not been lay off)<p>It&#x27;s also much cheaper to hire contractors and give them the CDE that can be terminated on a moment notice.</div><br/></div></div></div></div><div id="42048931" class="c"><input type="checkbox" id="c-42048931" checked=""/><div class="controls bullet"><span class="by">eichi</span><span>|</span><a href="#42042522">prev</a><span>|</span><a href="#42046463">next</a><span>|</span><label class="collapse" for="c-42048931">[-]</label><label class="expand" for="c-42048931">[1 more]</label></div><br/><div class="children"><div class="content">Kubernetes is just combined infra admin practices. Whether we use it or not, we need to do the same things by local oriented way or vendor specific way .<p>1. Some operations on remote in local oriented way are time consuming and unmanageable.<p>2. With vendor specific way, our skill would be deprecated, having dependency to the vendors.<p>3. Kubernetes is not the best tools but it it popular.<p>As always, custom solution is the most powerful but should be replaced with more unified way for the stability of the development.</div><br/></div></div><div id="42046463" class="c"><input type="checkbox" id="c-42046463" checked=""/><div class="controls bullet"><span class="by">abofh</span><span>|</span><a href="#42048931">prev</a><span>|</span><a href="#42042478">next</a><span>|</span><label class="collapse" for="c-42046463">[-]</label><label class="expand" for="c-42046463">[5 more]</label></div><br/><div class="children"><div class="content">I feel like anyone who was building a CI solution to sell to others and chose kubernetes didn&#x27;t really understand the problem.<p>You&#x27;re running hot pods for crypto miners and against people who really want to see the rest of the code that box has ever seen.  You should be isolating with something purpose built like firecracker, and do your own dispatch &amp; shred for security.</div><br/><div id="42049072" class="c"><input type="checkbox" id="c-42049072" checked=""/><div class="controls bullet"><span class="by">merb</span><span>|</span><a href="#42046463">parent</a><span>|</span><a href="#42046589">next</a><span>|</span><label class="collapse" for="c-42049072">[-]</label><label class="expand" for="c-42049072">[1 more]</label></div><br/><div class="children"><div class="content">you can run your pods in vms, with something like kata containers.
Kubernetes is more a scheduler than a isolation layer. Of course it uses the cri-o runtime for containers by default and relies heavily on groups, but that is just the default</div><br/></div></div><div id="42046589" class="c"><input type="checkbox" id="c-42046589" checked=""/><div class="controls bullet"><span class="by">geoctl</span><span>|</span><a href="#42046463">parent</a><span>|</span><a href="#42049072">prev</a><span>|</span><a href="#42042478">next</a><span>|</span><label class="collapse" for="c-42046589">[-]</label><label class="expand" for="c-42046589">[3 more]</label></div><br/><div class="children"><div class="content">Firecracker is more comparable to container runtimes than to orchestrators such as K8s. You still need an orchestrator to schedule, manage and garbage-collect all your uVMs on top of your infrastructure exactly like you would do with containers via k8s. In other words, you will probably have to either use k8s or build your own k8s to run &quot;supervisor&quot; containers&#x2F;processes that launch uVMs which in turn launch the customer dev containers.</div><br/><div id="42046663" class="c"><input type="checkbox" id="c-42046663" checked=""/><div class="controls bullet"><span class="by">abofh</span><span>|</span><a href="#42046463">root</a><span>|</span><a href="#42046589">parent</a><span>|</span><a href="#42042478">next</a><span>|</span><label class="collapse" for="c-42046663">[-]</label><label class="expand" for="c-42046663">[2 more]</label></div><br/><div class="children"><div class="content">For sure, but that&#x27;s the point - containers aren&#x27;t really good for an adversarial CI solution.  You can run that shit in house on kubernetes on a VM in a simulated VR if you want. But if you have adversarial builds, you have a) builds that may well need close to root, and b) customers who may well want to break your shit.  Containers are not the right solution for that, VM&#x27;s get you mostly there, and the right answer is burning bare metal instances with fire after every change-of-tenant - but nobody does that (anymore), because VM&#x27;s are close enough and it&#x27;s faster to zero out a virtual disk than a real one.<p>So if you started with kubernetes and fought the whole process of why it&#x27;s not a great solution to the problem, I have to assume you didn&#x27;t understand the problem.  I :heart: kubernetes, its complexity pays my bills - but it&#x27;s barely a good CI solution when you trust everyone involved, it&#x27;s definitely not a good one where you&#x27;re trying to be general-purpose to everyone with a makefile.</div><br/><div id="42046974" class="c"><input type="checkbox" id="c-42046974" checked=""/><div class="controls bullet"><span class="by">geoctl</span><span>|</span><a href="#42046463">root</a><span>|</span><a href="#42046663">parent</a><span>|</span><a href="#42042478">next</a><span>|</span><label class="collapse" for="c-42046974">[-]</label><label class="expand" for="c-42046974">[1 more]</label></div><br/><div class="children"><div class="content">I would argue that dev containers are more complicated than CI even though they share many of the challenges (e.g. devcontainers might need to load 10s or 100s of GBs to start and are write heavy). I would also argue that userns&#x2F;rootless containers provide &quot;enough&quot; isolation when it comes to isolating CPU&#x2F;memory&#x2F;networking as well as access to the host&#x27;s syscalls if you&#x27;re careful enough; however when it comes to storage (e.g. max disk size that a container can use and write to, max opened files, completely hiding the host&#x27;s fs from the container&#x27;s, etc...), it&#x27;s unfortunately still extremely limited,fs-dependent for some features, even though modern solutions (e.g. vDPA and ublk) can be used to fix that and virtualize the storage for containers.</div><br/></div></div></div></div></div></div></div></div><div id="42042478" class="c"><input type="checkbox" id="c-42042478" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#42046463">prev</a><span>|</span><a href="#42043492">next</a><span>|</span><label class="collapse" for="c-42042478">[-]</label><label class="expand" for="c-42042478">[3 more]</label></div><br/><div class="children"><div class="content">The original k8s paper mentioned that the only use case was a low latency and a high latency workflow combination and the resource allocation is based on that. The generic idea is that you can easily move low latency work between nodes and there are no serios repercussions when a high latency job fails.<p>Based on this information, it is hard to justify to even consider k8s for the problem that gitpod has.</div><br/><div id="42048657" class="c"><input type="checkbox" id="c-42048657" checked=""/><div class="controls bullet"><span class="by">junkaccount</span><span>|</span><a href="#42042478">parent</a><span>|</span><a href="#42043492">next</a><span>|</span><label class="collapse" for="c-42048657">[-]</label><label class="expand" for="c-42048657">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for reading the paper!</div><br/><div id="42049601" class="c"><input type="checkbox" id="c-42049601" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#42042478">root</a><span>|</span><a href="#42048657">parent</a><span>|</span><a href="#42043492">next</a><span>|</span><label class="collapse" for="c-42049601">[-]</label><label class="expand" for="c-42049601">[1 more]</label></div><br/><div class="children"><div class="content">For those who are interested:<p><a href="https:&#x2F;&#x2F;static.googleusercontent.com&#x2F;media&#x2F;research.google.com&#x2F;en&#x2F;&#x2F;pubs&#x2F;archive&#x2F;43438.pdf" rel="nofollow">https:&#x2F;&#x2F;static.googleusercontent.com&#x2F;media&#x2F;research.google.c...</a><p>I am not sure what differences k8s has compare to Borg. At the concept level these are pretty comparable.</div><br/></div></div></div></div></div></div><div id="42043492" class="c"><input type="checkbox" id="c-42043492" checked=""/><div class="controls bullet"><span class="by">geoctl</span><span>|</span><a href="#42042478">prev</a><span>|</span><a href="#42042766">next</a><span>|</span><label class="collapse" for="c-42043492">[-]</label><label class="expand" for="c-42043492">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked on something similar to gitpod in a slightly different context that&#x27;s part of a much bigger personal project related to secure remote access that I&#x27;ve actually spent a few years building now and hope to open source in a few months from now. While I agree on many of the points in the article, I just don&#x27;t understand how using micro VMs by itself replaces K8s unless they actually start building their own K8s that orchestrates their micro VMs (as opposed to containers in the case of k8s) ending up with the same thing basically when k8s itself can be used to orchestrate the outer containers that run the micro VMs used to run the dev containers. Yes, k8s has many challenges when it comes to nesting containers, cgroups, creating rootless containers inside the outer k8s containers and other stuff such as multi-region scaling, but actually the biggest challenge that I&#x27;ve faced so far isn&#x27;t related to networkPolicies or cgroups but is actually by far related to storage, both when it comes to (lazily) pulling big OCI images which are extremely unready to be used for dev containers whose sizes are typically in the GBs or 10s of GBs as well as also when it comes to storage virtualization over the underlying k8s node storage. There are serious attempts to accelerate image pulling (e.g. Nydus) but such solutions would still probably be needed whether you use micro VMs or rootless&#x2F;userns containers in order to load and run your dev containers.</div><br/></div></div><div id="42042766" class="c"><input type="checkbox" id="c-42042766" checked=""/><div class="controls bullet"><span class="by">debarshri</span><span>|</span><a href="#42043492">prev</a><span>|</span><a href="#42049501">next</a><span>|</span><label class="collapse" for="c-42042766">[-]</label><label class="expand" for="c-42042766">[1 more]</label></div><br/><div class="children"><div class="content">Phew, it is absolutely true. Building dev environments on k8s become wasteful. To add to this complexity, if you are building a product that is self hosted on customer&#x27;s infrastructure. Debugging and support also become non homogeneous and difficult.<p>What we have seen works especially when you are building developer centric product is expose these native issues around network, memory, compute and storage to engineers and they are more willing to work around it. Abstracting those issues leads to shift in responsibility on the product.<p>Having said that, I still think k8s is an upgrade when you have a large team.</div><br/></div></div><div id="42049501" class="c"><input type="checkbox" id="c-42049501" checked=""/><div class="controls bullet"><span class="by">vrnvu</span><span>|</span><a href="#42042766">prev</a><span>|</span><a href="#42044040">next</a><span>|</span><label class="collapse" for="c-42049501">[-]</label><label class="expand" for="c-42049501">[1 more]</label></div><br/><div class="children"><div class="content">For development, I made the switch to nix&#x2F;flox and it’s been a game-changer.</div><br/></div></div><div id="42044040" class="c"><input type="checkbox" id="c-42044040" checked=""/><div class="controls bullet"><span class="by">alecfong</span><span>|</span><a href="#42049501">prev</a><span>|</span><a href="#42042333">next</a><span>|</span><label class="collapse" for="c-42044040">[-]</label><label class="expand" for="c-42044040">[1 more]</label></div><br/><div class="children"><div class="content">Our first implementation of brev.dev was built on top of kubernetes. We were also building a remote dev environment tool at the time. Treating dev environments like cattle seemed to be the wrong assumption. Turning kubernetes into a pet manager was a huge endeavor with long tail of issues. We rewrote our platform against vms and were immediately able to provide a better experience. Lots of tradeoffs but makes sense for dev envs.</div><br/></div></div><div id="42042333" class="c"><input type="checkbox" id="c-42042333" checked=""/><div class="controls bullet"><span class="by">clvx</span><span>|</span><a href="#42044040">prev</a><span>|</span><a href="#42048994">next</a><span>|</span><label class="collapse" for="c-42042333">[-]</label><label class="expand" for="c-42042333">[3 more]</label></div><br/><div class="children"><div class="content">I tried doing a dev environment on Kubernetes but the fact you have to be dealing with a set of containers that could change if the base layer changed meant instability in certain cases which threw me off.<p>I ended up with a mix of nix and it&#x27;s vm build system which is based on qemu. The issue is too tied to NixOS and all services run in the same place which forces you to manage ports and other things.<p>How I wish it could work is having a flake that defines certain services, these services could or could not run in different µVMs sharing an isolated linux network layer. Your flake could define your versions, your commands to interact and manage the lifecyle of those µVM&#x27;s. As the nix store can be cached&#x2F;shared, it can be provide fast and reproducible builds after the first build.</div><br/><div id="42042487" class="c"><input type="checkbox" id="c-42042487" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#42042333">parent</a><span>|</span><a href="#42046214">next</a><span>|</span><label class="collapse" for="c-42042487">[-]</label><label class="expand" for="c-42042487">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the fact you have to be dealing with a set of containers that could change if the base layer changed meant instability<p>Can you expand on this?  Are you talking about containers you create?</div><br/></div></div><div id="42046214" class="c"><input type="checkbox" id="c-42046214" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#42042333">parent</a><span>|</span><a href="#42042487">prev</a><span>|</span><a href="#42048994">next</a><span>|</span><label class="collapse" for="c-42046214">[-]</label><label class="expand" for="c-42046214">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried <a href="https:&#x2F;&#x2F;github.com&#x2F;astro&#x2F;microvm.nix">https:&#x2F;&#x2F;github.com&#x2F;astro&#x2F;microvm.nix</a> ?
You can use the same NixOS module for both declarative VMs and imperatively configured and spawned VMs.</div><br/></div></div></div></div><div id="42048991" class="c"><input type="checkbox" id="c-42048991" checked=""/><div class="controls bullet"><span class="by">Jack008</span><span>|</span><a href="#42048994">prev</a><span>|</span><a href="#42043432">next</a><span>|</span><label class="collapse" for="c-42048991">[-]</label><label class="expand" for="c-42048991">[1 more]</label></div><br/><div class="children"><div class="content">Make sure you need microservices-based architecture because it comes with its own complexity - a load balancer, container networking, distributed tracing, etc. If you application does not need to scale its sub-components independently, you are better off using a VM-based application. It&#x27;s 10X cheaper to maintain&#x2F;troubleshoot and is high performance&#x2F;resources.</div><br/></div></div><div id="42043432" class="c"><input type="checkbox" id="c-42043432" checked=""/><div class="controls bullet"><span class="by">rekoros</span><span>|</span><a href="#42048991">prev</a><span>|</span><a href="#42044196">next</a><span>|</span><label class="collapse" for="c-42043432">[-]</label><label class="expand" for="c-42043432">[4 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been using Nix flakes and direnv (<a href="https:&#x2F;&#x2F;direnv.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;direnv.net&#x2F;</a>) for developer environments and NixOS with <a href="https:&#x2F;&#x2F;github.com&#x2F;serokell&#x2F;deploy-rs">https:&#x2F;&#x2F;github.com&#x2F;serokell&#x2F;deploy-rs</a> for prod&#x2F;deploys - takes serious digging and time to set up, but excellent experience with it so far.</div><br/><div id="42043734" class="c"><input type="checkbox" id="c-42043734" checked=""/><div class="controls bullet"><span class="by">andreweggleston</span><span>|</span><a href="#42043432">parent</a><span>|</span><a href="#42045176">next</a><span>|</span><label class="collapse" for="c-42043734">[-]</label><label class="expand" for="c-42043734">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been using Nix for the past year and it really feels like the holy grail for stable development environments. Like you said—it takes serious time to set up, but it seems like that’s an unavoidable reality of easily sharable dev envs.</div><br/></div></div><div id="42045176" class="c"><input type="checkbox" id="c-42045176" checked=""/><div class="controls bullet"><span class="by">aliasxneo</span><span>|</span><a href="#42043432">parent</a><span>|</span><a href="#42043734">prev</a><span>|</span><a href="#42044196">next</a><span>|</span><label class="collapse" for="c-42045176">[-]</label><label class="expand" for="c-42045176">[2 more]</label></div><br/><div class="children"><div class="content">Serious time to set up _and_ maintain as the project changes. At least, that was my experience. I really _want_ to have Nix-powered development environments, but I do _not_ want to spend the rest of my career maintaining them because developers refuse to &quot;seriously dig&quot; to understand how it works and why it decided to randomly break when they added a new dependency.<p>I think this approach works best in small teams where everyone agrees to drink the Nix juice. Otherwise, it&#x27;s caused nothing but strife in my company.</div><br/><div id="42045343" class="c"><input type="checkbox" id="c-42045343" checked=""/><div class="controls bullet"><span class="by">rekoros</span><span>|</span><a href="#42043432">root</a><span>|</span><a href="#42045176">parent</a><span>|</span><a href="#42044196">next</a><span>|</span><label class="collapse" for="c-42045343">[-]</label><label class="expand" for="c-42045343">[1 more]</label></div><br/><div class="children"><div class="content">This may be the one area where some form of autocracy has merit :-)</div><br/></div></div></div></div></div></div><div id="42044196" class="c"><input type="checkbox" id="c-42044196" checked=""/><div class="controls bullet"><span class="by">junkaccount</span><span>|</span><a href="#42043432">prev</a><span>|</span><a href="#42042754">next</a><span>|</span><label class="collapse" for="c-42044196">[-]</label><label class="expand" for="c-42044196">[3 more]</label></div><br/><div class="children"><div class="content">The real reason for this shift is that kubernetes moved to containerd which they cannot handle. Docker was much easier. Differential workloads is not correct to blame.<p>Also, there is a long tail of issues to be fixed if you do it with Kubernetes.<p>Kubernetes does not just give you scaling, it gives you many things: run on any architecture, be close to your deployment etc.</div><br/><div id="42044381" class="c"><input type="checkbox" id="c-42044381" checked=""/><div class="controls bullet"><span class="by">moondev</span><span>|</span><a href="#42044196">parent</a><span>|</span><a href="#42042754">next</a><span>|</span><label class="collapse" for="c-42044381">[-]</label><label class="expand" for="c-42044381">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;Mirantis&#x2F;cri-dockerd">https:&#x2F;&#x2F;github.com&#x2F;Mirantis&#x2F;cri-dockerd</a></div><br/><div id="42044885" class="c"><input type="checkbox" id="c-42044885" checked=""/><div class="controls bullet"><span class="by">junkaccount</span><span>|</span><a href="#42044196">root</a><span>|</span><a href="#42044381">parent</a><span>|</span><a href="#42042754">next</a><span>|</span><label class="collapse" for="c-42044885">[-]</label><label class="expand" for="c-42044885">[1 more]</label></div><br/><div class="children"><div class="content">Most of the kubernetes providers (GKE, EKS) do not support this new shim. Even on baremetal it is possibly hard to run.</div><br/></div></div></div></div></div></div><div id="42042754" class="c"><input type="checkbox" id="c-42042754" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#42044196">prev</a><span>|</span><a href="#42048249">next</a><span>|</span><label class="collapse" for="c-42042754">[-]</label><label class="expand" for="c-42042754">[4 more]</label></div><br/><div class="children"><div class="content">I was intrigued because the development environment problem is similar to the data scientist one - data gravity, GPU sharing, etc - but I&#x27;m confused on the solution?<p>Oddly, I left with a funny alternate takeaway: One by one, their clever inhouse tweaks &amp; scheduling preferences were recognized by the community and turned into standard k8s knobs<p>So I&#x27;m back to the original question... What is fundamentally left? It sounds like one part is maintaining a clean container path to simplify a local deploy, which a lot of k8s teams do (ex: most of our enterprise customers prefer our docker compose &amp; AMIs over k8s). But more importantly, something fundamental architecturally about how envs run that k8s cannot do, but they do not identify?</div><br/><div id="42043209" class="c"><input type="checkbox" id="c-42043209" checked=""/><div class="controls bullet"><span class="by">csweichel</span><span>|</span><a href="#42042754">parent</a><span>|</span><a href="#42042832">next</a><span>|</span><label class="collapse" for="c-42043209">[-]</label><label class="expand" for="c-42043209">[2 more]</label></div><br/><div class="children"><div class="content">OP here. The Kubernetes community has been fantastic at evolving the platform, and we&#x27;ve greatly enjoyed being in the middle of it. Indeed, many of the things we had to build next to Kubernetes have now become part of k8s itself.<p>Still, some of the core challenges remain:
- the flexibility Kubernetes affords makes it hard to build and distribute a product with such specific requirements across the broad swath of differently set up Kubernetes installations. Managed Kubernetes services help, but come with their own restrictions (e.g. Kernel versions on GKE).
- state handling and storage remains unsolved. PVCs are not reliable enough, subject to a lot of variance (see point above), and depending on the backing storage have vastly different behaviour. Local disks (which we use to this day), make workspace startup and backup expensive from a resource perspective and hard to predict timing wise.
- user namespaces have come a long way in Kubernetes, but by themselves are not enough. &#x2F;proc is still masked, FUSE is still not usable.
- startup times, specifically container pulls and backup restoration, are hard to optimize because they depend on a lot of factors outside of our control (image homogeneity, cluster configuration)<p>Fundamentally, Kubernetes simply isn&#x27;t the right choice here. It&#x27;s possible to make it work, but at some point the ROI of running on Kubernetes simply isn&#x27;t there.</div><br/><div id="42043402" class="c"><input type="checkbox" id="c-42043402" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#42042754">root</a><span>|</span><a href="#42043209">parent</a><span>|</span><a href="#42042832">next</a><span>|</span><label class="collapse" for="c-42043402">[-]</label><label class="expand" for="c-42043402">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>AFAICT, a lot of that comes down to storage abstractions, which I&#x27;ll be curious to see the answer on! Pinned localstorage &lt;&gt; cloud native is frustrating.<p>I sense another big chunk is the fast secure start problems that firecracker (noted in the blogpost) solve but k8s is not currently equipped for. Our team has been puzzling that one for awhile, and part of our guess is incentives. It&#x27;s been 5+ years since firecracker came out, so likewise been frustrating to see.</div><br/></div></div></div></div><div id="42042832" class="c"><input type="checkbox" id="c-42042832" checked=""/><div class="controls bullet"><span class="by">thenaturalist</span><span>|</span><a href="#42042754">parent</a><span>|</span><a href="#42043209">prev</a><span>|</span><a href="#42048249">next</a><span>|</span><label class="collapse" for="c-42042832">[-]</label><label class="expand" for="c-42042832">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We’ll be posting a lot more about Gitpod Flex architecture in the coming weeks or months. I’d love to invite you on November the 6th to a virtual event where I’ll be giving a demo of Gitpod Flex and I’ll deep-dive into the architecture and security model at length.<p>Bottom of the post.</div><br/></div></div></div></div><div id="42048249" class="c"><input type="checkbox" id="c-42048249" checked=""/><div class="controls bullet"><span class="by">ncrmro</span><span>|</span><a href="#42042754">prev</a><span>|</span><a href="#42043013">next</a><span>|</span><label class="collapse" for="c-42048249">[-]</label><label class="expand" for="c-42048249">[1 more]</label></div><br/><div class="children"><div class="content">We started having a few developers have constant VSCode timeouts. We switched to GitHub devcontainers which have been great.</div><br/></div></div><div id="42043013" class="c"><input type="checkbox" id="c-42043013" checked=""/><div class="controls bullet"><span class="by">javier_e06</span><span>|</span><a href="#42048249">prev</a><span>|</span><a href="#42045126">next</a><span>|</span><label class="collapse" for="c-42043013">[-]</label><label class="expand" for="c-42043013">[1 more]</label></div><br/><div class="children"><div class="content">The article is an excellent cautionary tale. Debugging an app in a container is one thing. Debugging and app running inside a Kubernetes node is a rabbit hole that demands more hours and expertise.</div><br/></div></div><div id="42045126" class="c"><input type="checkbox" id="c-42045126" checked=""/><div class="controls bullet"><span class="by">hintymad</span><span>|</span><a href="#42043013">prev</a><span>|</span><a href="#42046835">next</a><span>|</span><label class="collapse" for="c-42045126">[-]</label><label class="expand" for="c-42045126">[1 more]</label></div><br/><div class="children"><div class="content">I was wondering if there&#x27;s productivity angle too. Take Ceph vs Rook for example. If a Ceph cluster needs all the resources on its machines and the cluster manages its resources too, then moving to Rook does not give any additional features. All the 50K additional lines of code in Rook is to set up CSIs and statefulsets and whatnot just to get Ceph working on Kubernetes.</div><br/></div></div><div id="42046835" class="c"><input type="checkbox" id="c-42046835" checked=""/><div class="controls bullet"><span class="by">riiii</span><span>|</span><a href="#42045126">prev</a><span>|</span><a href="#42046356">next</a><span>|</span><label class="collapse" for="c-42046835">[-]</label><label class="expand" for="c-42046835">[1 more]</label></div><br/><div class="children"><div class="content">&gt; development environments<p>Kubernetes has never ever struck me as a good idea for a development environment. I&#x27;m surprised it took the author this long to figure out.<p>K8s can be a lifesaver for production, staging, testing, ... depending on your requirements and infrastructure.</div><br/></div></div><div id="42046356" class="c"><input type="checkbox" id="c-42046356" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#42046835">prev</a><span>|</span><a href="#42046012">next</a><span>|</span><label class="collapse" for="c-42046356">[-]</label><label class="expand" for="c-42046356">[2 more]</label></div><br/><div class="children"><div class="content">&gt; SSD RAID 0<p>&gt; A simpler version of this setup is to use a single SSD attached to the node. This approach provides lower IOPS and bandwidth, and still binds the data to individual nodes.<p>Are you sure SSD is that slow? NVMe devices are so fast that I hardly believe there&#x27;s any need for RAID 0.</div><br/><div id="42047338" class="c"><input type="checkbox" id="c-42047338" checked=""/><div class="controls bullet"><span class="by">mikeshi42</span><span>|</span><a href="#42046356">parent</a><span>|</span><a href="#42046012">next</a><span>|</span><label class="collapse" for="c-42047338">[-]</label><label class="expand" for="c-42047338">[1 more]</label></div><br/><div class="children"><div class="content">In AWS iirc NVMe max out at 2GB&#x2F;s - I&#x27;m not sure why that&#x27;s the case. I know there were issues with the PCIe controller in the past being the bottleneck, but I suspect there&#x27;s something more to it than that.</div><br/></div></div></div></div><div id="42046012" class="c"><input type="checkbox" id="c-42046012" checked=""/><div class="controls bullet"><span class="by">dwroberts</span><span>|</span><a href="#42046356">prev</a><span>|</span><a href="#42046728">next</a><span>|</span><label class="collapse" for="c-42046012">[-]</label><label class="expand" for="c-42046012">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Autoscaler plugins: In June 2022, we switched to using cluster-autoscaler plugins when they were introduced.<p>Does anyone have any links for cluster-autoscaler plugins? Searching drawing a blank, even in the cluster-autoscaler repo itself. Did this concept get ditched&#x2F;removed?</div><br/></div></div><div id="42046728" class="c"><input type="checkbox" id="c-42046728" checked=""/><div class="controls bullet"><span class="by">eYrKEC2</span><span>|</span><a href="#42046012">prev</a><span>|</span><a href="#42044652">next</a><span>|</span><label class="collapse" for="c-42046728">[-]</label><label class="expand" for="c-42046728">[1 more]</label></div><br/><div class="children"><div class="content">Have folks seen success with <a href="https:&#x2F;&#x2F;earthly.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;earthly.dev&#x2F;</a> as a tool in their dev cycle?</div><br/></div></div><div id="42044652" class="c"><input type="checkbox" id="c-42044652" checked=""/><div class="controls bullet"><span class="by">tacone</span><span>|</span><a href="#42046728">prev</a><span>|</span><a href="#42045933">next</a><span>|</span><label class="collapse" for="c-42044652">[-]</label><label class="expand" for="c-42044652">[1 more]</label></div><br/><div class="children"><div class="content">On a side note: has anybody experience with MicroK8s? I&#x27;d love to learn stories about it. I&#x27;m interested in both dev and production experiences.</div><br/></div></div><div id="42045933" class="c"><input type="checkbox" id="c-42045933" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42044652">prev</a><span>|</span><label class="collapse" for="c-42045933">[-]</label><label class="expand" for="c-42045933">[1 more]</label></div><br/><div class="children"><div class="content">I read this article and I still don&#x27;t understand what&#x27;s wrong with Kubernetes for this task. Everything you would do with virtual machines could be done with Kubernetes with very similar results.<p>I guess team just wants to rewrite everything, it happens. Manager should prevent that.</div><br/></div></div></div></div></div></div></div></body></html>