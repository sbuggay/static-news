<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694163660314" as="style"/><link rel="stylesheet" href="styles.css?v=1694163660314"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gal.hagever.com/posts/my-node-js-is-a-bit-rusty">My Node.js is a bit Rusty</a> <span class="domain">(<a href="https://gal.hagever.com">gal.hagever.com</a>)</span></div><div class="subtext"><span>qsantos</span> | <span>65 comments</span></div><br/><div><div id="37430410" class="c"><input type="checkbox" id="c-37430410" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#37431180">next</a><span>|</span><label class="collapse" for="c-37430410">[-]</label><label class="expand" for="c-37430410">[24 more]</label></div><br/><div class="children"><div class="content">&gt; having 25 Node.js instances running for three hours to parse 200GB of data seems like an indication that something isn&#x27;t quite right.<p>That’s about 700kb&#x2F;s.<p>I’m all for playing with rust, but this post strikes me as engineers being distracted by shiny new things because <i>they are only able to parse a TSV at 700kb&#x2F;s</i>?<p>You should be able to understand why your current system performs so absolutely terribly before you decide to rewrite it in any language.<p>Hand-waving at the garbage collector whilst seemingly doing very little to understand what’s happening doesn’t convince me that there isn’t another, possibly pretty obvious issue going on.</div><br/><div id="37430473" class="c"><input type="checkbox" id="c-37430473" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37430410">parent</a><span>|</span><a href="#37431114">next</a><span>|</span><label class="collapse" for="c-37430473">[-]</label><label class="expand" for="c-37430473">[17 more]</label></div><br/><div class="children"><div class="content">They debugged the problem to be excessive allocations in the tight loop of the TSV parser. If you allocate a separate object per each field, I can imagine how it can result in throughput counted in kB&#x2F;s instead of GB&#x2F;s.<p>We have had very similar issues with Java - excessive heap allocations can bring the system to a crawl and there is often no easy way out.</div><br/><div id="37430598" class="c"><input type="checkbox" id="c-37430598" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430473">parent</a><span>|</span><a href="#37430498">next</a><span>|</span><label class="collapse" for="c-37430598">[-]</label><label class="expand" for="c-37430598">[11 more]</label></div><br/><div class="children"><div class="content">They didn&#x27;t debug anything. They just stuck a job queue on it and then rewrote part of it in Rust. That&#x27;s the point of my comment. Using their code in the post (gist here[1]):<p><pre><code>   $ pv lol.tsv | node lol.js
   1.71GiB 0:00:07 [ 225MiB&#x2F;s] [================================&gt;] 100%
   Finished reading the file.
</code></pre>
Do we live in a world where engineers using a mature language like NodeJS with a pretty simple line-by-line file reading process and a string split think they hit a hard wall at 700kb&#x2F;s, and the problem is <i>not</i> their bad code?<p>1. <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;orf&#x2F;92bc26381e3dc00c8e96af262768591b" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;orf&#x2F;92bc26381e3dc00c8e96af262768591b</a></div><br/><div id="37430919" class="c"><input type="checkbox" id="c-37430919" checked=""/><div class="controls bullet"><span class="by">bhaak</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430598">parent</a><span>|</span><a href="#37431085">next</a><span>|</span><label class="collapse" for="c-37430919">[-]</label><label class="expand" for="c-37430919">[2 more]</label></div><br/><div class="children"><div class="content">Try it with something a little bigger than what you used. Then you would have seen that the GC kicks in and performance goes down after about 2GB of processed data.<p>With my first try with bigger data it blew up with an out of heap memory error. The article mentions them having memory problems as well. They probably operated at the upper levels of available memory and even got into swapping and then 700kb&#x2F;s is not surprising.<p>So yes, this absolutely looks like a memory allocation issue.</div><br/><div id="37431230" class="c"><input type="checkbox" id="c-37431230" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430919">parent</a><span>|</span><a href="#37431085">next</a><span>|</span><label class="collapse" for="c-37431230">[-]</label><label class="expand" for="c-37431230">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div></div></div><div id="37431085" class="c"><input type="checkbox" id="c-37431085" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430598">parent</a><span>|</span><a href="#37430919">prev</a><span>|</span><a href="#37430727">next</a><span>|</span><label class="collapse" for="c-37431085">[-]</label><label class="expand" for="c-37431085">[2 more]</label></div><br/><div class="children"><div class="content">&gt; They just stuck a job queue on it and then rewrote part of it in Rust<p>IMO that&#x27;s not an inappropriate response here. You <i>can</i> make this code in Node, but it&#x27;s super-awkward trying to reduce string allocations in JavaScript. Much easier to rewrite in Rust where such things will be fast even with the naive code. For code such as this you can likely do a 1:1 port of the Node code and it will be 10x faster. Which is much better than getting yourself in twists trying to make Node fast at tasks it&#x27;s not good at.</div><br/><div id="37431173" class="c"><input type="checkbox" id="c-37431173" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37431085">parent</a><span>|</span><a href="#37430727">next</a><span>|</span><label class="collapse" for="c-37431173">[-]</label><label class="expand" for="c-37431173">[1 more]</label></div><br/><div class="children"><div class="content">I took the code from their post, the one they highlighted as the issue, string allocations and all, and ran it. It was 1000x as fast as their self-reported runtime.<p>Does this really, really not scream “there is another issue” to you?<p>Do you really think, even with string allocations in a hot loop, NodeJS with its very optimised runtime would struggle to hit 1mb&#x2F;s?</div><br/></div></div></div></div><div id="37430727" class="c"><input type="checkbox" id="c-37430727" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430598">parent</a><span>|</span><a href="#37431085">prev</a><span>|</span><a href="#37430498">next</a><span>|</span><label class="collapse" for="c-37430727">[-]</label><label class="expand" for="c-37430727">[6 more]</label></div><br/><div class="children"><div class="content">But is the code shitty? It looks like boring normal code to me. I&#x27;m not sure what point you&#x27;re making here.<p>The point of the article is that you can write really boring normal code in NodeJS and it&#x27;s really slow, or you can write really boring normal code in Rust and it&#x27;s a lot faster, and it&#x27;s not that hard to use the latter to replace hot paths in the former.</div><br/><div id="37430855" class="c"><input type="checkbox" id="c-37430855" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430727">parent</a><span>|</span><a href="#37431107">next</a><span>|</span><label class="collapse" for="c-37430855">[-]</label><label class="expand" for="c-37430855">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But is the code shitty? It looks like boring normal code to me. I&#x27;m not sure what point you&#x27;re making here.<p>1. It should never be that <i>stupidly</i> slow<p>2. That should be obvious to anyone with a napkin and some math<p>3. Excessive allocations are highly unlikely to be the root cause of the slowness<p>4. Instead of debugging, they seemingly spent a lot of time putting it on Kubernetes, scaling it out to 25 instances and then finally rewriting a portion of it in Rust.<p>The whole thing smells of confusion and multiple issues being conflated together, with the rewrite in rust fixing these by virtue of deletion.<p>And if the root is <i>was</i> the GC, then some `--trace-gc` output in the post would be nice at the absolute minimum. Showing a for loop with a string split doesn&#x27;t cut it.</div><br/><div id="37430967" class="c"><input type="checkbox" id="c-37430967" checked=""/><div class="controls bullet"><span class="by">maurice2k</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430855">parent</a><span>|</span><a href="#37431107">next</a><span>|</span><label class="collapse" for="c-37430967">[-]</label><label class="expand" for="c-37430967">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. I&#x27;m not a super-expert in Node.js but worked a lot with it and also know a lot of internals.<p>And I can definitely say: IO speed is pretty good. To be honest, I&#x27;ve never come across a language with bad IO speed and I&#x27;ve seen quite a lot of languages.<p>I also did some benchmarks (like orf did) and speed is pretty good. Maybe Rust is a little bit better because it&#x27;s nearer to syscalls than Node.js is but we&#x27;re not talking about 760kb&#x2F;s vs. 250mb&#x2F;s.<p>200GB of logs and 25 instances means 8GB per instance.
Not sure what they&#x27;re doing, but processing of 8GB taking 3h is like doing it with my 80286 processor ;-) Even with inserting stuff in MongoDB this seems <i>way to slow</i>. And they only replaced the file IO part with Rust...<p>I guess the records array is getting pretty huge which <i>might</i> result in swapping to disk. But then: don&#x27;t let it happen, just flush it to the database or whatever. I believe the problem could have been solved with Node.js without issues.</div><br/></div></div></div></div><div id="37431107" class="c"><input type="checkbox" id="c-37431107" checked=""/><div class="controls bullet"><span class="by">mrighele</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430727">parent</a><span>|</span><a href="#37430855">prev</a><span>|</span><a href="#37430841">next</a><span>|</span><label class="collapse" for="c-37431107">[-]</label><label class="expand" for="c-37431107">[1 more]</label></div><br/><div class="children"><div class="content">The point the parent is making is that the boring normal code in NodeJS is not slow, at least not as presented in the article. The bottleneck is probably somewhere else. Allocation is usually not slow in a garbage collected language. Deallocation can be, but that is usually easy to check (for example with the --trace-gc flag, or running with profiling enabled and checking the results with chrome devtools). It would have been nice if they shared such analysis.<p>With the limited information provided in the article, there are other points that I would check before going as far as writing a module in another language. For example<p>&gt;   records.push({<p>They are collecting all the parsed rows in a single array. This is going to consume memory proportional to the size of the file, potentially in the same order of magnitude (depends on how much information is being collected and how much discarded).</div><br/></div></div><div id="37430841" class="c"><input type="checkbox" id="c-37430841" checked=""/><div class="controls bullet"><span class="by">disgruntledphd2</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430727">parent</a><span>|</span><a href="#37431107">prev</a><span>|</span><a href="#37430498">next</a><span>|</span><label class="collapse" for="c-37430841">[-]</label><label class="expand" for="c-37430841">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably all the memory allocations. I know that when I do work like this, creating a huge array up front and assigning to that typically results in massive speedups.<p>I know basically nothing about Node though, so I could be completely wrong here.</div><br/><div id="37431009" class="c"><input type="checkbox" id="c-37431009" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430841">parent</a><span>|</span><a href="#37430498">next</a><span>|</span><label class="collapse" for="c-37431009">[-]</label><label class="expand" for="c-37431009">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s one way to do it. Another is to reuse structures where possible to not force reallocation. There&#x27;s a bunch of ways.</div><br/></div></div></div></div></div></div></div></div><div id="37430498" class="c"><input type="checkbox" id="c-37430498" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430473">parent</a><span>|</span><a href="#37430598">prev</a><span>|</span><a href="#37431114">next</a><span>|</span><label class="collapse" for="c-37430498">[-]</label><label class="expand" for="c-37430498">[5 more]</label></div><br/><div class="children"><div class="content">A common technique (at least in Java, never seen it in nodejs) is to have a pool of pre-allocated objects and just reuse them as they are discarded. Essentially manual GC</div><br/><div id="37431013" class="c"><input type="checkbox" id="c-37431013" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430498">parent</a><span>|</span><a href="#37430675">next</a><span>|</span><label class="collapse" for="c-37431013">[-]</label><label class="expand" for="c-37431013">[2 more]</label></div><br/><div class="children"><div class="content">That reminds me of how iOS could achieve fast scrolling of lists, which Facebook and Twitter struggled with for years because they tried to stick with HTML. Basically if you scroll down, a list element from above is moved to the bottom and has its contents replaced.<p>Anyway, I&#x27;m not sure if this is in Java already or is upcoming, but Java will finally add value objects, that is, stack variables instead of just making everything a heap object. For tight loops that will be much more efficient, since it can just reuse the same memory, stay within the cpu registers, etc. (I&#x27;m talking out of my ass btw from a superficial knowledge of Go and Java and half-remembered theory from college).</div><br/><div id="37431111" class="c"><input type="checkbox" id="c-37431111" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37431013">parent</a><span>|</span><a href="#37430675">next</a><span>|</span><label class="collapse" for="c-37431111">[-]</label><label class="expand" for="c-37431111">[1 more]</label></div><br/><div class="children"><div class="content">Virtual scrolling is a very common technique for rendering large tables or lists in HTML (and pretty much any other environment), and is by no means unique to iOS...</div><br/></div></div></div></div><div id="37430675" class="c"><input type="checkbox" id="c-37430675" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430498">parent</a><span>|</span><a href="#37431013">prev</a><span>|</span><a href="#37430647">next</a><span>|</span><label class="collapse" for="c-37430675">[-]</label><label class="expand" for="c-37430675">[1 more]</label></div><br/><div class="children"><div class="content">It is easier said than done, when the whole ecosystem is based on libraries and frameworks that allocate like crazy. Preallocating and reusing introduces complexity and increases likelihood of bugs. And at least in Java you can run into surprising GC troubles with pooling as well. Object pools tend to be promoted to a tenured generation and if you do it too much, you essentially break the generational hypothesis many GCs are optimized for. Generational GCs don&#x27;t like dealing with objects with long lifetimes.</div><br/></div></div><div id="37430647" class="c"><input type="checkbox" id="c-37430647" checked=""/><div class="controls bullet"><span class="by">DrDroop</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430498">parent</a><span>|</span><a href="#37430675">prev</a><span>|</span><a href="#37431114">next</a><span>|</span><label class="collapse" for="c-37430647">[-]</label><label class="expand" for="c-37430647">[1 more]</label></div><br/><div class="children"><div class="content">Happens JS world aswel SimonDev did a video about it, this one I think:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=easvMCCBFkQ">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=easvMCCBFkQ</a><p>This channel is a real gem, show what talent really is:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=a1L7k35EHIc">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=a1L7k35EHIc</a></div><br/></div></div></div></div></div></div><div id="37431114" class="c"><input type="checkbox" id="c-37431114" checked=""/><div class="controls bullet"><span class="by">z3t4</span><span>|</span><a href="#37430410">parent</a><span>|</span><a href="#37430473">prev</a><span>|</span><a href="#37431033">next</a><span>|</span><label class="collapse" for="c-37431114">[-]</label><label class="expand" for="c-37431114">[1 more]</label></div><br/><div class="children"><div class="content">Async programming is not easy. For example the following line<p><pre><code>    for await ...
</code></pre>
will will process the whole file, then give you all lines at once.<p>So the problem is probably that all lines in all files are parsed at the time creating a bottleneck somewhere and ballooning memory usage. The solution is to use streams, pause the stream in order to parse the line, then continue the stream. And pipe the parsed result to stdout or a tcp stream. That will use minimal memory, and if the GC doesn&#x27;t do it&#x27;s job Node.js now supports manual GC. So you could probably parse the whole thing using only a few kilobytes of memory.</div><br/></div></div><div id="37431033" class="c"><input type="checkbox" id="c-37431033" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#37430410">parent</a><span>|</span><a href="#37431114">prev</a><span>|</span><a href="#37430585">next</a><span>|</span><label class="collapse" for="c-37431033">[-]</label><label class="expand" for="c-37431033">[1 more]</label></div><br/><div class="children"><div class="content">I agree, 700kb&#x2F;s is just impossibly slow; I mean personally I wouldn&#x27;t use node to do it, but with node you still should be orders faster. Something is not right.</div><br/></div></div><div id="37430585" class="c"><input type="checkbox" id="c-37430585" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#37430410">parent</a><span>|</span><a href="#37431033">prev</a><span>|</span><a href="#37430586">next</a><span>|</span><label class="collapse" for="c-37430585">[-]</label><label class="expand" for="c-37430585">[2 more]</label></div><br/><div class="children"><div class="content">Realizing that Memory &amp; Memory allocation is almost always where the performance goes wrong in practice takes some wisdom.</div><br/><div id="37430966" class="c"><input type="checkbox" id="c-37430966" checked=""/><div class="controls bullet"><span class="by">discreteevent</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430585">parent</a><span>|</span><a href="#37430586">next</a><span>|</span><label class="collapse" for="c-37430966">[-]</label><label class="expand" for="c-37430966">[1 more]</label></div><br/><div class="children"><div class="content">&quot;almost always [...] wisdom&quot; - Is this sarcasm? Maybe you work in a domain where that is the case but in my experience it&#x27;s almost always not memory allocation or GC. &quot;Wisdom&quot; if there is any comes from measuring things properly and finding out the hard way that it&#x27;s not what you think it is.</div><br/></div></div></div></div><div id="37430586" class="c"><input type="checkbox" id="c-37430586" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#37430410">parent</a><span>|</span><a href="#37430585">prev</a><span>|</span><a href="#37431180">next</a><span>|</span><label class="collapse" for="c-37430586">[-]</label><label class="expand" for="c-37430586">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I’m all for playing with rust, but this post strikes me as engineers being distracted by shiny new things because they are only able to parse a TSV at 700kb&#x2F;s?<p>They definitely just wanted to A.) Play with Rust, B.) Write a post about it.<p>This is the key line:<p>&gt; As an intermediate Rustacean (I do have a fairly successful open-source project written in Rust, called fnm),<p>It&#x27;s fine to say &quot;I rewrote this code in Rust because I like Rust&quot;. We don&#x27;t have to do a whole song and dance about why X needed a rewrite in Rust because X wasn&#x27;t doing a good enough job. People do exactly this work in Node every day successfully. They just wanted to write Rust instead of optimizing some Javascript. _Which is fine_, just totally not newsworthy.</div><br/><div id="37431019" class="c"><input type="checkbox" id="c-37431019" checked=""/><div class="controls bullet"><span class="by">_nhh</span><span>|</span><a href="#37430410">root</a><span>|</span><a href="#37430586">parent</a><span>|</span><a href="#37431180">next</a><span>|</span><label class="collapse" for="c-37431019">[-]</label><label class="expand" for="c-37431019">[1 more]</label></div><br/><div class="children"><div class="content">Couldnt agree more.</div><br/></div></div></div></div></div></div><div id="37431180" class="c"><input type="checkbox" id="c-37431180" checked=""/><div class="controls bullet"><span class="by">ifdefdebug</span><span>|</span><a href="#37430410">prev</a><span>|</span><a href="#37429647">next</a><span>|</span><label class="collapse" for="c-37431180">[-]</label><label class="expand" for="c-37431180">[1 more]</label></div><br/><div class="children"><div class="content">I just skimmed through the article but it seems that they refactored from allocating and copying substring to pointing at the substrings within the original string (inside a hot path). So 25x performance boost should be expected just from that and has nothing to do with GC or the language used.</div><br/></div></div><div id="37429647" class="c"><input type="checkbox" id="c-37429647" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37431180">prev</a><span>|</span><a href="#37430944">next</a><span>|</span><label class="collapse" for="c-37429647">[-]</label><label class="expand" for="c-37429647">[4 more]</label></div><br/><div class="children"><div class="content">Blink and you missed the interesting bit, which is how they hooked them together. Looks like it&#x27;s with this project: <a href="https:&#x2F;&#x2F;napi.rs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;napi.rs&#x2F;</a><p>That project seems to be creating platform-specific DLL&#x27;s, which I guess doesn&#x27;t matter too much if it&#x27;s wrapped up nicely in an npm package and you&#x27;re deploying Docker files on Linux anyway? But conceptually, it seems like it would be more portable to generate a single WebAssembly binary instead of a bunch of DLL&#x27;s.<p>Alternatively, writing very C-like code using a Uint8Array and not allocating in the loop might have fixed it too? But if you don&#x27;t use JavaScript string libraries, it&#x27;s not much like writing JavaScript anymore.</div><br/><div id="37430380" class="c"><input type="checkbox" id="c-37430380" checked=""/><div class="controls bullet"><span class="by">pimeys</span><span>|</span><a href="#37429647">parent</a><span>|</span><a href="#37429971">next</a><span>|</span><label class="collapse" for="c-37430380">[-]</label><label class="expand" for="c-37430380">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But conceptually, it seems like it would be more portable to generate a single WebAssembly binary instead of a bunch of DLL&#x27;s.<p>If the database IO happens in Rust, the option with WebAssembly is fetch, meaning HTTP and the Atlas-only Data API. If the IO is done in JS, you pay some extra CPU time transferring UTF-16 strings over the border and copy them as UTF-8 in Rust.</div><br/></div></div><div id="37429971" class="c"><input type="checkbox" id="c-37429971" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#37429647">parent</a><span>|</span><a href="#37430380">prev</a><span>|</span><a href="#37430104">next</a><span>|</span><label class="collapse" for="c-37429971">[-]</label><label class="expand" for="c-37429971">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I think Uint8Array might&#x27;ve been a strong solution. But I&#x27;ve got the feeling this isn&#x27;t the whole story. Unless the TSV is extremely wide, this alone feels a bit insignificant. I don&#x27;t know the details so this is pure speculation, but using a transform stream on each row to split it up might&#x27;ve been enough to reduce memory pressure.<p>I&#x27;ve done a bit of data manipulation in node and while imo js is not the ideal language for the job, it can be very fast. Strings are hard though, I&#x27;ll admit that</div><br/></div></div><div id="37430104" class="c"><input type="checkbox" id="c-37430104" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#37429647">parent</a><span>|</span><a href="#37429971">prev</a><span>|</span><a href="#37430944">next</a><span>|</span><label class="collapse" for="c-37430104">[-]</label><label class="expand" for="c-37430104">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But conceptually, it seems like it would be more portable to generate a single WebAssembly binary instead of a bunch of DLL&#x27;s.<p>This is true, but N-API will generally perform better (sometimes significantly, usually in exactly the same CPU-bound scenarios where WASM will perform better than V8). And NAPI-RS is quite good at paving the happy path for multi-target packages.</div><br/></div></div></div></div><div id="37430944" class="c"><input type="checkbox" id="c-37430944" checked=""/><div class="controls bullet"><span class="by">brownfox</span><span>|</span><a href="#37429647">prev</a><span>|</span><a href="#37429924">next</a><span>|</span><label class="collapse" for="c-37430944">[-]</label><label class="expand" for="c-37430944">[1 more]</label></div><br/><div class="children"><div class="content">I believe that the memory management aspect alone doesn&#x27;t provide sufficient justification for rewriting the code in Rust. While it is possible to achieve reduced memory consumption through techniques like reusing a backing buffer and using allocUnsafe(), which require developers to take on memory management responsibilities, it might result in slightly more verbose code compared to a straightforward line-by-line split() approach.<p>I am eager to explore the possibility of enhancing the line parsing process using Node.js. If you could provide a runnable example on a GitHub repository, it would enable me to compare its memory efficiency with the Rust rewrite version.</div><br/></div></div><div id="37429924" class="c"><input type="checkbox" id="c-37429924" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#37430944">prev</a><span>|</span><a href="#37430534">next</a><span>|</span><label class="collapse" for="c-37429924">[-]</label><label class="expand" for="c-37429924">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Promise.all, isn&#x27;t that delightful?). However, to our surprise, we soon ran into out-of-memory issues,<p>I think I must be misunderstanding something, but isn’t that exactly what you should expect?<p>We use node.js to process solar plant data. Which is massive amounts of data as each individual solar panel will log information about its power generation and status every few seconds. We can then use this to figure out which solar panels have a birds nest on them, and so on. Node performs this task well enough, but it obviously can’t be aggregated. Even if you were to spread it out on 25 node instances “concurrently” with control shift you’d run into out-of-memory issues extremely fast. I guess you could up the upper limit on when node.js stops being cool with its own memory usage, but honestly we tend to simply avoid the use promise aggregation exactly because it tends to ”break” node.<p>I think moving to Rust was probably a good idea for this. Go might’ve been a better option if you were going for a “modern” concurrent language, but whatever works! We tend to use C ourselves when node needs a little boost. But often Node can handle these things on its own. With the solar data we use worker threads to collect and process the data in real time, which is really parallel-execution and not concurrency, but it works well and it doesn’t get you into performance issues.</div><br/><div id="37430313" class="c"><input type="checkbox" id="c-37430313" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37429924">parent</a><span>|</span><a href="#37430839">next</a><span>|</span><label class="collapse" for="c-37430313">[-]</label><label class="expand" for="c-37430313">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go might’ve been a better option if you were going for a “modern” concurrent language, but whatever works!<p>Go doesn&#x27;t embed in other runtimes as nicely as Rust, nor it cannot call foreign code (including even  C) as efficiently as Rust does. Rust strength is that it needs virtually no runtime and there is no magic needed to cross the ffi boundary.</div><br/></div></div><div id="37430839" class="c"><input type="checkbox" id="c-37430839" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#37429924">parent</a><span>|</span><a href="#37430313">prev</a><span>|</span><a href="#37430085">next</a><span>|</span><label class="collapse" for="c-37430839">[-]</label><label class="expand" for="c-37430839">[1 more]</label></div><br/><div class="children"><div class="content">The issue isn&#x27;t Node. The issue is a poor understanding of memory requirements of each task and trying to do too many at once. You need to throttle your concurrency.</div><br/></div></div><div id="37430085" class="c"><input type="checkbox" id="c-37430085" checked=""/><div class="controls bullet"><span class="by">go_prodev</span><span>|</span><a href="#37429924">parent</a><span>|</span><a href="#37430839">prev</a><span>|</span><a href="#37430110">next</a><span>|</span><label class="collapse" for="c-37430085">[-]</label><label class="expand" for="c-37430085">[2 more]</label></div><br/><div class="children"><div class="content">That sounds really interesting.<p>Out of curiosity, how do you use Node for this purpose?  Is it building a real time dashboard?<p>My company has possibly similar challenges.  We have lots of sensors on equipment that streams information every few ms through a time series database from the vendor. It&#x27;s used to build monitoring dashboards, trigger alarms and help engineers to prioritize and optimize equipment settings, and look for trends over time.<p>It&#x27;s such high volumes that capturing it and analyzing can be difficult, so we use a combination of vendor systems, Azure Synapse and Power BI. 
 There are still lots of opportunities to improve, and I&#x27;d be interested to hear how you landed on your setup and what you do with the data.</div><br/><div id="37431138" class="c"><input type="checkbox" id="c-37431138" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#37429924">root</a><span>|</span><a href="#37430085">parent</a><span>|</span><a href="#37430110">next</a><span>|</span><label class="collapse" for="c-37431138">[-]</label><label class="expand" for="c-37431138">[1 more]</label></div><br/><div class="children"><div class="content">It’s mainly for data transformation and transport. Solar inverters don’t deliver data in the same formats, there are no protocols and apparently most engineers in the solar panel business still think FTP (not SFTP) is fine but some will deliver a file per reading while others will aggregate and so on.<p>We use node to gather the data and transform it into consumptive formats that our 3rd party AI vendor can work with, as well as store it in a range of SQL databases for our own PowerBI consumption. We do no frontend work.<p>We don’t use node because it’s a good idea to use node for this. We use node because we try to use TypeScript as much as possible because we’re a small team and having a single language covering as much of our stack as possible makes it easier to work together.</div><br/></div></div></div></div><div id="37430110" class="c"><input type="checkbox" id="c-37430110" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#37429924">parent</a><span>|</span><a href="#37430085">prev</a><span>|</span><a href="#37430534">next</a><span>|</span><label class="collapse" for="c-37430110">[-]</label><label class="expand" for="c-37430110">[2 more]</label></div><br/><div class="children"><div class="content">Modern concurrent language, suitable for processing massive amounts of data, is Elixir.</div><br/><div id="37431240" class="c"><input type="checkbox" id="c-37431240" checked=""/><div class="controls bullet"><span class="by">synthc</span><span>|</span><a href="#37429924">root</a><span>|</span><a href="#37430110">parent</a><span>|</span><a href="#37430534">next</a><span>|</span><label class="collapse" for="c-37431240">[-]</label><label class="expand" for="c-37431240">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the BEAM VM on which it runs rather slow?</div><br/></div></div></div></div></div></div><div id="37430534" class="c"><input type="checkbox" id="c-37430534" checked=""/><div class="controls bullet"><span class="by">mrighele</span><span>|</span><a href="#37429924">prev</a><span>|</span><a href="#37430034">next</a><span>|</span><label class="collapse" for="c-37430534">[-]</label><label class="expand" for="c-37430534">[1 more]</label></div><br/><div class="children"><div class="content">I guess there is something I am missing here.<p>The original code should consume not much more memory than the optimized one. Yes you&#x27;re going to allocate a lot of more memory, but whatever doesn&#x27;t finish in the record becomes garbage after every single line, so I can expect worse performance, but not using two order of magnitude more memory.<p>I would see more problematic the fact that you&#x27;re collecting all the records in a single array. Depending on how you use them it can be beneficial to use a generator and consume them incrementally.</div><br/></div></div><div id="37430034" class="c"><input type="checkbox" id="c-37430034" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#37430534">prev</a><span>|</span><a href="#37429886">next</a><span>|</span><label class="collapse" for="c-37430034">[-]</label><label class="expand" for="c-37430034">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However, to our surprise, we soon ran into out-of-memory issues, even when using utilities like p-limit to limit ourselves to just two jobs in parallel.<p>If only two async jobs already run OOM, your issue is <i>probably</i> bad code, not node.js. From the code snippet posted, it looks like they do a `records.push(...)`, whereas it probably would&#x27;ve been more efficient to just continue using streams downstream as well. Additionally, using a transform stream to split the string rather than doing it in a loop might&#x27;ve yielded better results because the previous row could be cleaned up. Obviously, this is just poking in the dark, but such stark difference in numbers in the Rust implementation leads me to believe that they changed some other fundamental part of the design (e.g. streaming the results to the database rather than inserting everything in one big batch at the end).</div><br/></div></div><div id="37429886" class="c"><input type="checkbox" id="c-37429886" checked=""/><div class="controls bullet"><span class="by">Klaster_1</span><span>|</span><a href="#37430034">prev</a><span>|</span><a href="#37430567">next</a><span>|</span><label class="collapse" for="c-37429886">[-]</label><label class="expand" for="c-37429886">[11 more]</label></div><br/><div class="children"><div class="content">Leveraging Rust to speed Node.js is cool and all, but why the author didn&#x27;t attempt to optimize the JS code first? If too much intermediate objects negatively impact memory consumption, surely re-using the same structure or variables to hold the parsed result would have improved the performance? The benchmark tests not only the speedup brought up by Rust, but an optimization too, so it&#x27;s unclear which impacts the performance the most.</div><br/><div id="37430020" class="c"><input type="checkbox" id="c-37430020" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37429886">parent</a><span>|</span><a href="#37430480">next</a><span>|</span><label class="collapse" for="c-37430020">[-]</label><label class="expand" for="c-37430020">[4 more]</label></div><br/><div class="children"><div class="content">That approach may work in short term but in long term you&#x27;d likely end up with unreadable and brittle code that is often still not as fast as it would be after the rewrite. You&#x27;d introduce additional complexity into your product to overcome limitations of the platform. And tricks like reusing objects can turn into really nasty bugs, especially in languages that don&#x27;t come with any tools to control aliasing.</div><br/><div id="37431058" class="c"><input type="checkbox" id="c-37431058" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37429886">root</a><span>|</span><a href="#37430020">parent</a><span>|</span><a href="#37430225">next</a><span>|</span><label class="collapse" for="c-37431058">[-]</label><label class="expand" for="c-37431058">[1 more]</label></div><br/><div class="children"><div class="content">I mean I hear what you mean, but counterpoints; The hot path of code is allowed to be more involved than a naive implementation. You mention &quot;unreadable&quot;, &quot;brittle&quot; and &quot;complex&quot; as if those are inevitable; I don&#x27;t believe it, and again, it&#x27;s worth the tradeoff, like dropping down to ASM in the hot path of C applications.<p>Another counterpoint: By switching to Rust, another language was added to the company&#x27;s technology stack. This means that they now need to hire for Rust as well, if the author decides to leave. The simple graphics on <a href="https:&#x2F;&#x2F;boringtechnology.club&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;boringtechnology.club&#x2F;</a> are pretty interesting in that regard.<p>I don&#x27;t know anything about this company, but the general advice I&#x27;d give is: be careful with adding languages, it adds an exponent to the complexity of your organization and hiring.</div><br/></div></div><div id="37430225" class="c"><input type="checkbox" id="c-37430225" checked=""/><div class="controls bullet"><span class="by">beezlewax</span><span>|</span><a href="#37429886">root</a><span>|</span><a href="#37430020">parent</a><span>|</span><a href="#37431058">prev</a><span>|</span><a href="#37430480">next</a><span>|</span><label class="collapse" for="c-37430225">[-]</label><label class="expand" for="c-37430225">[2 more]</label></div><br/><div class="children"><div class="content">What does aliasing mean in this context?</div><br/><div id="37430352" class="c"><input type="checkbox" id="c-37430352" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37429886">root</a><span>|</span><a href="#37430225">parent</a><span>|</span><a href="#37430480">next</a><span>|</span><label class="collapse" for="c-37430352">[-]</label><label class="expand" for="c-37430352">[1 more]</label></div><br/><div class="children"><div class="content">If you want to reuse an object to avoid allocation, you better not have a reference to that object from somewhere else. In JS AFAIK there is no way to detect such situation automatically.</div><br/></div></div></div></div></div></div><div id="37430480" class="c"><input type="checkbox" id="c-37430480" checked=""/><div class="controls bullet"><span class="by">TheFragenTaken</span><span>|</span><a href="#37429886">parent</a><span>|</span><a href="#37430020">prev</a><span>|</span><a href="#37430026">next</a><span>|</span><label class="collapse" for="c-37430480">[-]</label><label class="expand" for="c-37430480">[1 more]</label></div><br/><div class="children"><div class="content">You couldn&#x27;t write a blog post that hit the top of HN if you did that :)</div><br/></div></div><div id="37430026" class="c"><input type="checkbox" id="c-37430026" checked=""/><div class="controls bullet"><span class="by">tacone</span><span>|</span><a href="#37429886">parent</a><span>|</span><a href="#37430480">prev</a><span>|</span><a href="#37430737">next</a><span>|</span><label class="collapse" for="c-37430026">[-]</label><label class="expand" for="c-37430026">[4 more]</label></div><br/><div class="children"><div class="content">Not 100% sure but just defining those variables outside the loop might have solved.</div><br/><div id="37430286" class="c"><input type="checkbox" id="c-37430286" checked=""/><div class="controls bullet"><span class="by">r-spaghetti</span><span>|</span><a href="#37429886">root</a><span>|</span><a href="#37430026">parent</a><span>|</span><a href="#37430737">next</a><span>|</span><label class="collapse" for="c-37430286">[-]</label><label class="expand" for="c-37430286">[3 more]</label></div><br/><div class="children"><div class="content">Or delete them or set to null inside the loop?</div><br/><div id="37430418" class="c"><input type="checkbox" id="c-37430418" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37429886">root</a><span>|</span><a href="#37430286">parent</a><span>|</span><a href="#37430737">next</a><span>|</span><label class="collapse" for="c-37430418">[-]</label><label class="expand" for="c-37430418">[2 more]</label></div><br/><div class="children"><div class="content">Setting to null doesn&#x27;t release the memory. It only erases the reference. You still need to wait for the GC to complete.</div><br/><div id="37430516" class="c"><input type="checkbox" id="c-37430516" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37429886">root</a><span>|</span><a href="#37430418">parent</a><span>|</span><a href="#37430737">next</a><span>|</span><label class="collapse" for="c-37430516">[-]</label><label class="expand" for="c-37430516">[1 more]</label></div><br/><div class="children"><div class="content">Side note: it might work in a refcount GC like CPython. That isn’t node though. (It only might because it doesn’t guarantee that memory is actually reused.)</div><br/></div></div></div></div></div></div></div></div><div id="37430737" class="c"><input type="checkbox" id="c-37430737" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#37429886">parent</a><span>|</span><a href="#37430026">prev</a><span>|</span><a href="#37430567">next</a><span>|</span><label class="collapse" for="c-37430737">[-]</label><label class="expand" for="c-37430737">[1 more]</label></div><br/><div class="children"><div class="content">In this case, it&#x27;s probably easier to just write the Rust version.</div><br/></div></div></div></div><div id="37430567" class="c"><input type="checkbox" id="c-37430567" checked=""/><div class="controls bullet"><span class="by">getcrunk</span><span>|</span><a href="#37429886">prev</a><span>|</span><a href="#37430555">next</a><span>|</span><label class="collapse" for="c-37430567">[-]</label><label class="expand" for="c-37430567">[1 more]</label></div><br/><div class="children"><div class="content">The author gives no info about how much memory these node instances had. I think that context is very important to know.<p>Also as others have mentioned the js code could have been optimized.<p>Id be very interested in a part two testing out some of the suggestions and sharing the benchmarks!</div><br/></div></div><div id="37430555" class="c"><input type="checkbox" id="c-37430555" checked=""/><div class="controls bullet"><span class="by">kohlerm</span><span>|</span><a href="#37430567">prev</a><span>|</span><a href="#37430367">next</a><span>|</span><label class="collapse" for="c-37430555">[-]</label><label class="expand" for="c-37430555">[1 more]</label></div><br/><div class="children"><div class="content">This is probably fixable in Node.js, just preallocate objects and do not excessively create new ones. But yeah using Node.js is probably not the best choice for this. As others have mentioned a JVM could easily handle this with some pre-allocation strategy.</div><br/></div></div><div id="37430367" class="c"><input type="checkbox" id="c-37430367" checked=""/><div class="controls bullet"><span class="by">franciscop</span><span>|</span><a href="#37430555">prev</a><span>|</span><a href="#37430902">next</a><span>|</span><label class="collapse" for="c-37430367">[-]</label><label class="expand" for="c-37430367">[5 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;The intriguing part here is that line and fields won&#x27;t be cleared from memory until the garbage collector determines it&#x27;s time to do so. We find ourselves with RAM filled with redundant strings and arrays that need cleaning. It&#x27;s hardly surprising that our computer wasn&#x27;t thrilled with this situation.&quot;<p>I don&#x27;t have enough experience with super-optimizing Javascript, but wouldn&#x27;t this be an easy solution? Instead of creating new variables in each loop and let the engine clear them, reuse the variables to avoid using more memory:<p><pre><code>    let line, fields, httpStatus;
    for await (line of readlineStream) {
      fields = line.split(&#x27;\t&#x27;);
      httpStatus = Number(fields[5]);
      if (httpStatus &lt; 200 || httpStatus &gt; 299) continue;
      await dbWrite({
        pathname: fields[7],
        referrer: fields[8],
        &#x2F;&#x2F; ...
      });
    }
</code></pre>
Edit: and as others suggest, keep streaming those records, instead of just pushing them into an array</div><br/><div id="37430390" class="c"><input type="checkbox" id="c-37430390" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37430367">parent</a><span>|</span><a href="#37430902">next</a><span>|</span><label class="collapse" for="c-37430390">[-]</label><label class="expand" for="c-37430390">[4 more]</label></div><br/><div class="children"><div class="content">No, this still allocates a new string array per each line.split call. It&#x27;s not really a problem with variables. The variables are likely on the stack anyways, but they only store pointers to data on the heap. If you call any function that allocates data on the heap you cannot get away with that by moving the variable declarations.</div><br/><div id="37430580" class="c"><input type="checkbox" id="c-37430580" checked=""/><div class="controls bullet"><span class="by">getcrunk</span><span>|</span><a href="#37430367">root</a><span>|</span><a href="#37430390">parent</a><span>|</span><a href="#37430902">next</a><span>|</span><label class="collapse" for="c-37430580">[-]</label><label class="expand" for="c-37430580">[3 more]</label></div><br/><div class="children"><div class="content">Okay, but it still gets rid of two other allocations (line and http)</div><br/><div id="37430657" class="c"><input type="checkbox" id="c-37430657" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37430367">root</a><span>|</span><a href="#37430580">parent</a><span>|</span><a href="#37430902">next</a><span>|</span><label class="collapse" for="c-37430657">[-]</label><label class="expand" for="c-37430657">[2 more]</label></div><br/><div class="children"><div class="content">Line is a string. It allocates a fresh one on each line even if the variable is reused.</div><br/><div id="37430843" class="c"><input type="checkbox" id="c-37430843" checked=""/><div class="controls bullet"><span class="by">getcrunk</span><span>|</span><a href="#37430367">root</a><span>|</span><a href="#37430657">parent</a><span>|</span><a href="#37430902">next</a><span>|</span><label class="collapse" for="c-37430843">[-]</label><label class="expand" for="c-37430843">[1 more]</label></div><br/><div class="children"><div class="content">Lol shows how much I know!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37430902" class="c"><input type="checkbox" id="c-37430902" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#37430367">prev</a><span>|</span><a href="#37429768">next</a><span>|</span><label class="collapse" for="c-37430902">[-]</label><label class="expand" for="c-37430902">[1 more]</label></div><br/><div class="children"><div class="content">Let me know if you want some help optimizing that aggregation query :) looks like a fun challenge.</div><br/></div></div><div id="37429768" class="c"><input type="checkbox" id="c-37429768" checked=""/><div class="controls bullet"><span class="by">warkanlock</span><span>|</span><a href="#37430902">prev</a><span>|</span><a href="#37429624">next</a><span>|</span><label class="collapse" for="c-37429768">[-]</label><label class="expand" for="c-37429768">[2 more]</label></div><br/><div class="children"><div class="content">In my experience, Node.js generally performs very well for most use cases although when it comes to data manipulation (or similar use cases), performance often goes down the hill, becoming the primary bottleneck nearly every time. It&#x27;s simply not the right tool for the job.<p>The beauty of this is that it allows teams to isolate and optimize just the problematic portion of the code, preventing them from going down a rabbit hole of extensive changes that can be more harmful than beneficial.<p>NAPI is such a good tool for this; that I&#x27;ve been advocating the use of it to my team since forever.</div><br/><div id="37431225" class="c"><input type="checkbox" id="c-37431225" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37429768">parent</a><span>|</span><a href="#37429624">next</a><span>|</span><label class="collapse" for="c-37431225">[-]</label><label class="expand" for="c-37431225">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience, Node.js generally performs very well<p>Hard disagree here. Node is extremely fast to get up and running with, has as close to 0 barrier to entry as possible, and doesn&#x27;t suffer from slow startup times that plague JVM languages. It can also be fast for tight loops.<p>But in the experience I&#x27;ve had with it&quot;generally&quot;, it&#x27;s orders of magnitude slower than other languages. A hello world with express.js and gin in go are a full order of magnitude apart, and the express app with default settings dies under a load test that I would describe as &quot;very light&quot;.<p>Stories like this thread are common in the JS world where technically it can be rewritten to be faster, but like with Bun, esbuild, and many other examples we&#x27;ve seen here on HN, a better language choice makes an enormous difference. And to me, the only time node is the right tool for the job is if you have a team of JavaScript developers who can&#x27;t learn another language</div><br/></div></div></div></div><div id="37429624" class="c"><input type="checkbox" id="c-37429624" checked=""/><div class="controls bullet"><span class="by">jasfi</span><span>|</span><a href="#37429768">prev</a><span>|</span><a href="#37429767">next</a><span>|</span><label class="collapse" for="c-37429624">[-]</label><label class="expand" for="c-37429624">[1 more]</label></div><br/><div class="children"><div class="content">Related: you can write a Node.js module in Nim with Denim: <a href="https:&#x2F;&#x2F;github.com&#x2F;openpeeps&#x2F;denim">https:&#x2F;&#x2F;github.com&#x2F;openpeeps&#x2F;denim</a></div><br/></div></div><div id="37429767" class="c"><input type="checkbox" id="c-37429767" checked=""/><div class="controls bullet"><span class="by">bubblydoops</span><span>|</span><a href="#37429624">prev</a><span>|</span><a href="#37430330">next</a><span>|</span><label class="collapse" for="c-37429767">[-]</label><label class="expand" for="c-37429767">[2 more]</label></div><br/><div class="children"><div class="content">Batch maintenance is a drag.  However even just from the snippet of the purported memory&#x2F;slow issue, I think theres a smell that was not revealed.<p>If your constantly running out of memory you have a bad design.<p>This seems like a native code agenda type post which I have a problem with.
I will not code in native code ever again.  Its not worth it anymore, its a horrible practice and it just enables bad code to pretend its good.</div><br/><div id="37430169" class="c"><input type="checkbox" id="c-37430169" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#37429767">parent</a><span>|</span><a href="#37430330">next</a><span>|</span><label class="collapse" for="c-37430169">[-]</label><label class="expand" for="c-37430169">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean &quot;native code&quot; and why will you not program in such code?</div><br/></div></div></div></div><div id="37430330" class="c"><input type="checkbox" id="c-37430330" checked=""/><div class="controls bullet"><span class="by">lemper</span><span>|</span><a href="#37429767">prev</a><span>|</span><label class="collapse" for="c-37430330">[-]</label><label class="expand" for="c-37430330">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s as if using fitting tool for solving problem&#x27;s domain is a magic.
good for you for saving that much of resource, though.</div><br/></div></div></div></div></div></div></div></body></html>