<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694250058644" as="style"/><link rel="stylesheet" href="styles.css?v=1694250058644"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://quuxplusone.github.io/blog/2023/09/08/constexpr-string-firewall/">Just how constexpr is C++20’s std:string?</a> <span class="domain">(<a href="https://quuxplusone.github.io">quuxplusone.github.io</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>88 comments</span></div><br/><div><div id="37440379" class="c"><input type="checkbox" id="c-37440379" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#37443367">next</a><span>|</span><label class="collapse" for="c-37440379">[-]</label><label class="expand" for="c-37440379">[12 more]</label></div><br/><div class="children"><div class="content">&gt; libstdc++ rejects the following code (Godbolt [1]). (Microsoft accepts, but I think that might be an MSVC bug.)<p>This is not a bug in MSVC, rather it is due to MSVC implementing std::string SSO differently than gcc or clang. Instead of initializing `data` as pointing to the internal buffer for small strings, MSVC uses the string&#x27;s capacity to determine whether to access `data` or the internal storage [2].<p>Hence this code compiles, as it&#x27;s not initializing the string using a stack address. [3]<p>[1]: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;1ErrKjdbq" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;1ErrKjdbq</a><p>[2]: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20230803-00&#x2F;?p=108532" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20230803-00&#x2F;?p=10...</a><p>[3]: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;1MaxdGfvj" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;1MaxdGfvj</a></div><br/><div id="37443246" class="c"><input type="checkbox" id="c-37443246" checked=""/><div class="controls bullet"><span class="by">filmor</span><span>|</span><a href="#37440379">parent</a><span>|</span><a href="#37440553">next</a><span>|</span><label class="collapse" for="c-37443246">[-]</label><label class="expand" for="c-37443246">[1 more]</label></div><br/><div class="children"><div class="content">SSO is &quot;small string optimization&quot;, in case anyone was wondering.</div><br/></div></div><div id="37440553" class="c"><input type="checkbox" id="c-37440553" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#37440379">parent</a><span>|</span><a href="#37443246">prev</a><span>|</span><a href="#37443367">next</a><span>|</span><label class="collapse" for="c-37440553">[-]</label><label class="expand" for="c-37440553">[10 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fine that it is not a bug, but it seems like a compatibility nightmare.</div><br/><div id="37441148" class="c"><input type="checkbox" id="c-37441148" checked=""/><div class="controls bullet"><span class="by">fake-name</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37440553">parent</a><span>|</span><a href="#37443367">next</a><span>|</span><label class="collapse" for="c-37441148">[-]</label><label class="expand" for="c-37441148">[9 more]</label></div><br/><div class="children"><div class="content">It can lead to &quot;fun&quot; optimizations.<p>I spent a while porting a codebase that was written by someone far more clever then smart. They had discovered that you could clear a string under MSVC by `memset()`ing over it.<p>Obviously, this exploded in linux. That was a fun bug to track down.</div><br/><div id="37443154" class="c"><input type="checkbox" id="c-37443154" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37441148">parent</a><span>|</span><a href="#37441180">next</a><span>|</span><label class="collapse" for="c-37443154">[-]</label><label class="expand" for="c-37443154">[2 more]</label></div><br/><div class="children"><div class="content">&gt; They had discovered that you could clear a string under MSVC by `memset()`ing over it.<p>Why was that? Was it too problematic to just call std::string::clear ?</div><br/><div id="37443176" class="c"><input type="checkbox" id="c-37443176" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37443154">parent</a><span>|</span><a href="#37441180">next</a><span>|</span><label class="collapse" for="c-37443176">[-]</label><label class="expand" for="c-37443176">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing the string was part of a larger struct, and they wanted to clear the entire struct with a single memset.<p>It&#x27;s a somewhat common pattern in C, but requires care.</div><br/></div></div></div></div><div id="37441180" class="c"><input type="checkbox" id="c-37441180" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37441148">parent</a><span>|</span><a href="#37443154">prev</a><span>|</span><a href="#37443367">next</a><span>|</span><label class="collapse" for="c-37441180">[-]</label><label class="expand" for="c-37441180">[6 more]</label></div><br/><div class="children"><div class="content">How does that even work on MSVC? Wouldn&#x27;t it leak memory?</div><br/><div id="37441338" class="c"><input type="checkbox" id="c-37441338" checked=""/><div class="controls bullet"><span class="by">gavinsyancey</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37441180">parent</a><span>|</span><a href="#37443171">next</a><span>|</span><label class="collapse" for="c-37441338">[-]</label><label class="expand" for="c-37441338">[4 more]</label></div><br/><div class="children"><div class="content">&gt; How does that even work on MSVC?<p>It sets the capacity to zero. MSVC then interprets it as a short string with length 0, which doesn&#x27;t have an external allocation.<p>&gt; Wouldn&#x27;t it leak memory?<p>Yes, but I assume the &quot;far more clever then smart&quot; programmer didn&#x27;t notice.</div><br/><div id="37441354" class="c"><input type="checkbox" id="c-37441354" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37441338">parent</a><span>|</span><a href="#37443171">next</a><span>|</span><label class="collapse" for="c-37441354">[-]</label><label class="expand" for="c-37441354">[3 more]</label></div><br/><div class="children"><div class="content">Yeah I wouldn&#x27;t call that working on MSVC either haha.</div><br/><div id="37441467" class="c"><input type="checkbox" id="c-37441467" checked=""/><div class="controls bullet"><span class="by">gavinsyancey</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37441354">parent</a><span>|</span><a href="#37443171">next</a><span>|</span><label class="collapse" for="c-37441467">[-]</label><label class="expand" for="c-37441467">[2 more]</label></div><br/><div class="children"><div class="content">Definitely not &quot;working&quot;, yeah, but<p>On MSVC, an all-zero string object is the correct representation for a std::string containing &quot;&quot; (and the memory leak is easy to miss if you don&#x27;t do it too much).<p>On both Clang and gcc, an all-zero string object is <i>not using the short-string optimization</i> -- it is a string with size zero, capacity zero, and an external buffer of nullptr. (On clang this happens because capacity is even, and on gcc because &amp;str-&gt;buf != &amp;str). Any code that attempts to access its null terminator will dereference the null pointer and crash immediately.</div><br/><div id="37441479" class="c"><input type="checkbox" id="c-37441479" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37441467">parent</a><span>|</span><a href="#37443171">next</a><span>|</span><label class="collapse" for="c-37441479">[-]</label><label class="expand" for="c-37441479">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I get that.</div><br/></div></div></div></div></div></div></div></div><div id="37443171" class="c"><input type="checkbox" id="c-37443171" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37440379">root</a><span>|</span><a href="#37441180">parent</a><span>|</span><a href="#37441338">prev</a><span>|</span><a href="#37443367">next</a><span>|</span><label class="collapse" for="c-37443171">[-]</label><label class="expand" for="c-37443171">[1 more]</label></div><br/><div class="children"><div class="content">If your string hadn&#x27;t allocated yet then nope, probably not.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37443367" class="c"><input type="checkbox" id="c-37443367" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#37440379">prev</a><span>|</span><a href="#37442852">next</a><span>|</span><label class="collapse" for="c-37443367">[-]</label><label class="expand" for="c-37443367">[1 more]</label></div><br/><div class="children"><div class="content">Is accepting 11-char strings but not accepting 19-char strings for constexpr, specified in the C++ specification, or is this just behavior that different compiler vendors are implementing differently?<p>If the latter, then it is pretty annoying that non-standard behavior is happening now related to standard libraries implementations and constexpr.</div><br/></div></div><div id="37442852" class="c"><input type="checkbox" id="c-37442852" checked=""/><div class="controls bullet"><span class="by">elteto</span><span>|</span><a href="#37443367">prev</a><span>|</span><a href="#37438463">next</a><span>|</span><label class="collapse" for="c-37442852">[-]</label><label class="expand" for="c-37442852">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In real life, there’s basically no reason ever to use constexpr on a stack variable; you’ll use it only on globals or as part of the set phrase static constexpr.<p>Hmm… this is just unnecessarily dogmatic. I use constexpr all the time, for example, for local numerical constants that don’t need to be a global.</div><br/><div id="37442975" class="c"><input type="checkbox" id="c-37442975" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#37442852">parent</a><span>|</span><a href="#37438463">next</a><span>|</span><label class="collapse" for="c-37442975">[-]</label><label class="expand" for="c-37442975">[1 more]</label></div><br/><div class="children"><div class="content">Why not use a static local constexpr? That seems like it would be faster to me due to not needing to allocate stack space and copy the value to the stack. You still get the benefit of not needing a global.</div><br/></div></div></div></div><div id="37438463" class="c"><input type="checkbox" id="c-37438463" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#37442852">prev</a><span>|</span><a href="#37439875">next</a><span>|</span><label class="collapse" for="c-37438463">[-]</label><label class="expand" for="c-37438463">[30 more]</label></div><br/><div class="children"><div class="content">I find that there&#x27;s no use case for a constexpr std::string. Maybe I&#x27;m just not imaginative enough. If I want a string literal constant, I use string_view which can be constexpr. If somehow I need an actual std::string object, I use a regular const not constexpr. What would be a use case that prompts the author to explore using constexpr with std::string?</div><br/><div id="37438642" class="c"><input type="checkbox" id="c-37438642" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37438463">parent</a><span>|</span><a href="#37438679">next</a><span>|</span><label class="collapse" for="c-37438642">[-]</label><label class="expand" for="c-37438642">[5 more]</label></div><br/><div class="children"><div class="content">Generate a large number of strings and maps programmatically in compile time.<p>You are pretty much limited to macros and macro-like languages (llvm-tablegen) if you want to do this today.</div><br/><div id="37438883" class="c"><input type="checkbox" id="c-37438883" checked=""/><div class="controls bullet"><span class="by">mostlylurks</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438642">parent</a><span>|</span><a href="#37441247">next</a><span>|</span><label class="collapse" for="c-37438883">[-]</label><label class="expand" for="c-37438883">[3 more]</label></div><br/><div class="children"><div class="content">You can also do the same with templates quite easily, but the resulting compile times are going to be absolutely atrocious.</div><br/><div id="37439654" class="c"><input type="checkbox" id="c-37439654" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438883">parent</a><span>|</span><a href="#37440155">next</a><span>|</span><label class="collapse" for="c-37439654">[-]</label><label class="expand" for="c-37439654">[1 more]</label></div><br/><div class="children"><div class="content">A bunch of constexpr stuff since C++14 onwards have been added just to make meta-programming more usable.<p>Users, library writers, and compiler writers all benefit from this in some way.</div><br/></div></div></div></div><div id="37441247" class="c"><input type="checkbox" id="c-37441247" checked=""/><div class="controls bullet"><span class="by">ghotli</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438642">parent</a><span>|</span><a href="#37438883">prev</a><span>|</span><a href="#37438679">next</a><span>|</span><label class="collapse" for="c-37441247">[-]</label><label class="expand" for="c-37441247">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m just not imaginative enough but what sort of use-case is this sort of thing for?</div><br/></div></div></div></div><div id="37438679" class="c"><input type="checkbox" id="c-37438679" checked=""/><div class="controls bullet"><span class="by">hudsonwillis</span><span>|</span><a href="#37438463">parent</a><span>|</span><a href="#37438642">prev</a><span>|</span><a href="#37438609">next</a><span>|</span><label class="collapse" for="c-37438679">[-]</label><label class="expand" for="c-37438679">[4 more]</label></div><br/><div class="children"><div class="content">It enables users to process string at compile time. You can implement a constexpr getRFC3339DateString(int year, int month, int day) -&gt; string and then construct a constexpr string list.</div><br/><div id="37439159" class="c"><input type="checkbox" id="c-37439159" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438679">parent</a><span>|</span><a href="#37438609">next</a><span>|</span><label class="collapse" for="c-37439159">[-]</label><label class="expand" for="c-37439159">[3 more]</label></div><br/><div class="children"><div class="content">But what can you do with that string list afterwards? You can&#x27;t store it anywhere to be accessed at run time, can you?</div><br/><div id="37439417" class="c"><input type="checkbox" id="c-37439417" checked=""/><div class="controls bullet"><span class="by">Chabsff</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439159">parent</a><span>|</span><a href="#37439774">next</a><span>|</span><label class="collapse" for="c-37439417">[-]</label><label class="expand" for="c-37439417">[1 more]</label></div><br/><div class="children"><div class="content">The important part is that all the intermediate strings used during the computation are constexpr, to guarantee that the work happens during compilation.<p>Also, constexpr symbols can be demoted to regular const as needed by the compiler if necessary, such as when getting a pointer to one. constexpr doesn&#x27;t mean &quot;compile-time only&quot;, it means &quot;compile-time compatible&quot;</div><br/></div></div><div id="37439774" class="c"><input type="checkbox" id="c-37439774" checked=""/><div class="controls bullet"><span class="by">lldb</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439159">parent</a><span>|</span><a href="#37439417">prev</a><span>|</span><a href="#37438609">next</a><span>|</span><label class="collapse" for="c-37439774">[-]</label><label class="expand" for="c-37439774">[1 more]</label></div><br/><div class="children"><div class="content">Right - you can use the std::string at compile time but since it allocates dynamically you need to copy to a fixed size char[]&#x2F;std::array to use at runtime.</div><br/></div></div></div></div></div></div><div id="37438609" class="c"><input type="checkbox" id="c-37438609" checked=""/><div class="controls bullet"><span class="by">dtho</span><span>|</span><a href="#37438463">parent</a><span>|</span><a href="#37438679">prev</a><span>|</span><a href="#37438733">next</a><span>|</span><label class="collapse" for="c-37438609">[-]</label><label class="expand" for="c-37438609">[2 more]</label></div><br/><div class="children"><div class="content">The <i>constructor</i> of std::string is constexpr in C++20. A runtime call to &#x27;strlen&#x27; (or equivalent) can be optimized out by computing the string&#x27;s length at compile time and initializing the object accordingly.</div><br/><div id="37443187" class="c"><input type="checkbox" id="c-37443187" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438609">parent</a><span>|</span><a href="#37438733">next</a><span>|</span><label class="collapse" for="c-37443187">[-]</label><label class="expand" for="c-37443187">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The constructor of std::string is constexpr in C++20.<p>If I recall correctly, from C++20 onward all member functions of std::string are constexpr.</div><br/></div></div></div></div><div id="37438733" class="c"><input type="checkbox" id="c-37438733" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37438463">parent</a><span>|</span><a href="#37438609">prev</a><span>|</span><a href="#37439278">next</a><span>|</span><label class="collapse" for="c-37438733">[-]</label><label class="expand" for="c-37438733">[8 more]</label></div><br/><div class="children"><div class="content">&gt;  If I want a string literal constant, I use string_view which can be constexp<p>That assumes your API accepts string views. How do you pass a string_view (safely) to fopen, or CreateFile (on windows)?</div><br/><div id="37439458" class="c"><input type="checkbox" id="c-37439458" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438733">parent</a><span>|</span><a href="#37438767">next</a><span>|</span><label class="collapse" for="c-37439458">[-]</label><label class="expand" for="c-37439458">[1 more]</label></div><br/><div class="children"><div class="content">Old Windows APIs are a bit of a mess when it comes to const. So many that use LPWSTR strings rather than an LPCWSTR.</div><br/></div></div><div id="37438767" class="c"><input type="checkbox" id="c-37438767" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438733">parent</a><span>|</span><a href="#37439458">prev</a><span>|</span><a href="#37439278">next</a><span>|</span><label class="collapse" for="c-37438767">[-]</label><label class="expand" for="c-37438767">[6 more]</label></div><br/><div class="children"><div class="content">While (I think) I understand your broader point, when would you pass a string created by a constexp to fopen() or CreateFile?</div><br/><div id="37440022" class="c"><input type="checkbox" id="c-37440022" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438767">parent</a><span>|</span><a href="#37439328">next</a><span>|</span><label class="collapse" for="c-37440022">[-]</label><label class="expand" for="c-37440022">[3 more]</label></div><br/><div class="children"><div class="content">They were examples, they&#x27;re widely used C apis. Anything that passes through to glibc, windows or posix will have this problem.</div><br/><div id="37442284" class="c"><input type="checkbox" id="c-37442284" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37440022">parent</a><span>|</span><a href="#37439328">next</a><span>|</span><label class="collapse" for="c-37442284">[-]</label><label class="expand" for="c-37442284">[2 more]</label></div><br/><div class="children"><div class="content">I lack the intuition to understand why is it useful to constexpr path names. Could you elaborate?</div><br/><div id="37443215" class="c"><input type="checkbox" id="c-37443215" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37442284">parent</a><span>|</span><a href="#37439328">next</a><span>|</span><label class="collapse" for="c-37443215">[-]</label><label class="expand" for="c-37443215">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about path names. It&#x27;s about passing constexpr strings to c functions that expect a null terminated string.  You&#x27;re totally missing the point.<p>That said, here&#x27;s an example:<p><pre><code>    &#x2F;&#x2F; imagine this with string_view
    FILE* openFileInPath(const std::string&amp; path) {
        
        if (path.starts_with(&quot;some_dir&quot;))
        {
            return fopen(path.c_str());
        }
    return nullptr;
    }
</code></pre>
That function works just fine to only open a path that has a prefix (logic bug on relative paths aside for brevity while posting)<p>I should be able to pass a constexpr string to that function the same way I can pass a runtime created string.</div><br/></div></div></div></div></div></div><div id="37439328" class="c"><input type="checkbox" id="c-37439328" checked=""/><div class="controls bullet"><span class="by">cshokie</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37438767">parent</a><span>|</span><a href="#37440022">prev</a><span>|</span><a href="#37439278">next</a><span>|</span><label class="collapse" for="c-37439328">[-]</label><label class="expand" for="c-37439328">[2 more]</label></div><br/><div class="children"><div class="content">Hard-coding a relative file path seems like an obvious example. For example a config file with settings. The file will always have the same name so heap allocations and mutability are not needed.</div><br/><div id="37442308" class="c"><input type="checkbox" id="c-37442308" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439328">parent</a><span>|</span><a href="#37439278">next</a><span>|</span><label class="collapse" for="c-37442308">[-]</label><label class="expand" for="c-37442308">[1 more]</label></div><br/><div class="children"><div class="content">My config file paths have either been constant (&quot;.dotfile&quot;) or required run-time information that could not be constexpr&#x27;ed. I don&#x27;t see how constexpr would be useful.<p>Then again, I am primarily a Python and C programmer, so there is likely some underlying reasoning I&#x27;m missing.</div><br/></div></div></div></div></div></div></div></div><div id="37439278" class="c"><input type="checkbox" id="c-37439278" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37438463">parent</a><span>|</span><a href="#37438733">prev</a><span>|</span><a href="#37439258">next</a><span>|</span><label class="collapse" for="c-37439278">[-]</label><label class="expand" for="c-37439278">[6 more]</label></div><br/><div class="children"><div class="content">I use constexpr char[] for string literal constants just because it&#x27;s a little more compatible. Some things can&#x27;t take string_view.</div><br/><div id="37439413" class="c"><input type="checkbox" id="c-37439413" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439278">parent</a><span>|</span><a href="#37439258">next</a><span>|</span><label class="collapse" for="c-37439413">[-]</label><label class="expand" for="c-37439413">[5 more]</label></div><br/><div class="children"><div class="content">Why not use a std::array? Otherwise won&#x27;t you a second variable for the string length?</div><br/><div id="37439610" class="c"><input type="checkbox" id="c-37439610" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439413">parent</a><span>|</span><a href="#37439258">next</a><span>|</span><label class="collapse" for="c-37439610">[-]</label><label class="expand" for="c-37439610">[4 more]</label></div><br/><div class="children"><div class="content">`constexpr char kFoo[] = &quot;bar&quot;`, then kFoo can be used like an std::string and passed into things that take const std::string&amp; or string_view. The length is part of that. Or is that actually doing a copy?</div><br/><div id="37439776" class="c"><input type="checkbox" id="c-37439776" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439610">parent</a><span>|</span><a href="#37439799">next</a><span>|</span><label class="collapse" for="c-37439776">[-]</label><label class="expand" for="c-37439776">[2 more]</label></div><br/><div class="children"><div class="content">For both const std::string&amp; and std::string_view, you&#x27;re (potentially) incurring a runtime invocation of strlen.<p>For const std::string&amp;, you&#x27;re further incurring a copy in order to create a temporary std::string.</div><br/><div id="37442724" class="c"><input type="checkbox" id="c-37442724" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439776">parent</a><span>|</span><a href="#37439799">next</a><span>|</span><label class="collapse" for="c-37442724">[-]</label><label class="expand" for="c-37442724">[1 more]</label></div><br/><div class="children"><div class="content">Whoops. As you can maybe tell, the stuff I use C++ for isn&#x27;t so much about performance.</div><br/></div></div></div></div><div id="37439799" class="c"><input type="checkbox" id="c-37439799" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439610">parent</a><span>|</span><a href="#37439776">prev</a><span>|</span><a href="#37439258">next</a><span>|</span><label class="collapse" for="c-37439799">[-]</label><label class="expand" for="c-37439799">[1 more]</label></div><br/><div class="children"><div class="content">I think you still need the length though unless you can guarantee the string will never have any nulls in it. In Windows, there are API calls that take strings with embedded nulls (and that are typically terminated with a two nulls in a row).<p>So you might need to deal with a string that looks like &quot;foo\0bar\0\0&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="37439258" class="c"><input type="checkbox" id="c-37439258" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37438463">parent</a><span>|</span><a href="#37439278">prev</a><span>|</span><a href="#37443182">next</a><span>|</span><label class="collapse" for="c-37439258">[-]</label><label class="expand" for="c-37439258">[1 more]</label></div><br/><div class="children"><div class="content">If it was <i>real</i> constexpr it would be useful, e.g. concatenation is commonly desired and requires awkward workarounds currently.</div><br/></div></div><div id="37443182" class="c"><input type="checkbox" id="c-37443182" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37438463">parent</a><span>|</span><a href="#37439258">prev</a><span>|</span><a href="#37439513">next</a><span>|</span><label class="collapse" for="c-37443182">[-]</label><label class="expand" for="c-37443182">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find that there&#x27;s no use case for a constexpr std::string. Maybe I&#x27;m just not imaginative enough.<p>Putting together strings through string interpolation involving somewhat expensive operations is a common usecase. Given the choice, it&#x27;s preferable to not have to compute them each and every single time a function is invoked.</div><br/></div></div><div id="37439513" class="c"><input type="checkbox" id="c-37439513" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#37438463">parent</a><span>|</span><a href="#37443182">prev</a><span>|</span><a href="#37439875">next</a><span>|</span><label class="collapse" for="c-37439513">[-]</label><label class="expand" for="c-37439513">[2 more]</label></div><br/><div class="children"><div class="content">Would definitely be more useful if you could actually materialize the eventual result into something that&#x27;s visible at runtime.<p>If there was reflection, it would be useful to talk about class names, function names, etc, at compile time.</div><br/><div id="37441173" class="c"><input type="checkbox" id="c-37441173" checked=""/><div class="controls bullet"><span class="by">scatters</span><span>|</span><a href="#37438463">root</a><span>|</span><a href="#37439513">parent</a><span>|</span><a href="#37439875">next</a><span>|</span><label class="collapse" for="c-37441173">[-]</label><label class="expand" for="c-37441173">[1 more]</label></div><br/><div class="children"><div class="content">You can use `std::array&lt;char&gt;` (which, as it happens, is a literal type) as an intermediary when performing materialization. A nice toy example is to build a comma-separated string listing enumerators:<p><pre><code>    template&lt;class E&gt; requires std::is_enum_v&lt;E&gt; constexpr std::string_view joinedEnum() {
        constexpr auto generate = [] -&gt; std::string {
            return []&lt;template&lt;class...&gt; class L, class... D&gt;(L&lt;D...&gt;) {
                std::string str;
                (((str += (str.empty() ? &quot;&quot; : &quot;, &quot;)) += D::name), ...);
                return str;
            }(boost::describe::describe_enumerators&lt;E&gt;());
        };
        static constexpr auto arr = [&amp;] {
            constexpr std::size_t N = generate().size();
            std::array&lt;char, N&gt; arr;
            std::char_traits&lt;char&gt;::copy(arr.data(), generate().data(), N);
            return arr;
        }();
        return std::string_view(arr);
    }
</code></pre>
Note that you have to generate the constexpr std::string twice; once for its size, once for its contents. But you assume that the compiler can memoize the result.</div><br/></div></div></div></div></div></div><div id="37439875" class="c"><input type="checkbox" id="c-37439875" checked=""/><div class="controls bullet"><span class="by">seeknotfind</span><span>|</span><a href="#37438463">prev</a><span>|</span><a href="#37442516">next</a><span>|</span><label class="collapse" for="c-37439875">[-]</label><label class="expand" for="c-37439875">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really unfortunate the heap allocation can&#x27;t be in .ro.data for constexpr std::string. It might be an invasive change, but it would beat the hell out of const char* there for the reason of avoiding a copy onto the heap.</div><br/><div id="37440467" class="c"><input type="checkbox" id="c-37440467" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#37439875">parent</a><span>|</span><a href="#37442516">next</a><span>|</span><label class="collapse" for="c-37440467">[-]</label><label class="expand" for="c-37440467">[9 more]</label></div><br/><div class="children"><div class="content">I hate const char*. This notation sucks. Is it<p><pre><code>    (const char)*
</code></pre>
or<p><pre><code>    const (char*)?
</code></pre>
i.e. is it a pointer to a char but the memory address it points to is const, or is it a variable pointer that points to a const char.</div><br/><div id="37441847" class="c"><input type="checkbox" id="c-37441847" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#37439875">root</a><span>|</span><a href="#37440467">parent</a><span>|</span><a href="#37440497">next</a><span>|</span><label class="collapse" for="c-37441847">[-]</label><label class="expand" for="c-37441847">[1 more]</label></div><br/><div class="children"><div class="content">This explanation from isocpp is the one that has always guided me:<p><pre><code>   Read the pointer declarations right-to-left.

       * const X* p means “p points to an X that is const”: the X object can’t be changed via p.

       * X* const p means “p is a const pointer to an X that is non-const”: you can’t change the pointer p itself, but you can change the X object via p.

       * const X* const p means “p is a const pointer to an X that is const”: you can’t change the pointer p itself, nor can you change the X object via p.

    And, oh yea, did I mention to read your pointer declarations right-to-left?
</code></pre>
<a href="https:&#x2F;&#x2F;isocpp.org&#x2F;wiki&#x2F;faq&#x2F;const-correctness#const-ptr-vs-ptr-const" rel="nofollow noreferrer">https:&#x2F;&#x2F;isocpp.org&#x2F;wiki&#x2F;faq&#x2F;const-correctness#const-ptr-vs-p...</a></div><br/></div></div><div id="37440497" class="c"><input type="checkbox" id="c-37440497" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#37439875">root</a><span>|</span><a href="#37440467">parent</a><span>|</span><a href="#37441847">prev</a><span>|</span><a href="#37440797">next</a><span>|</span><label class="collapse" for="c-37440497">[-]</label><label class="expand" for="c-37440497">[2 more]</label></div><br/><div class="children"><div class="content">It is the former, a pointer to a const char. A const pointer to char would be qualified as:<p>char* const</div><br/><div id="37440561" class="c"><input type="checkbox" id="c-37440561" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#37439875">root</a><span>|</span><a href="#37440497">parent</a><span>|</span><a href="#37440797">next</a><span>|</span><label class="collapse" for="c-37440561">[-]</label><label class="expand" for="c-37440561">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  const char* const f() const
</code></pre>
is the best!</div><br/></div></div></div></div><div id="37440797" class="c"><input type="checkbox" id="c-37440797" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#37439875">root</a><span>|</span><a href="#37440467">parent</a><span>|</span><a href="#37440497">prev</a><span>|</span><a href="#37442516">next</a><span>|</span><label class="collapse" for="c-37440797">[-]</label><label class="expand" for="c-37440797">[5 more]</label></div><br/><div class="children"><div class="content">I think<p><pre><code>    const char *</code></pre>
and<p><pre><code>    char * const
</code></pre>
are obvious (whichever the const keyword is closest to).<p>That rule of thumb doesn&#x27;t work though for<p><pre><code>    char const *</code></pre>
or<p><pre><code>    char * const *
</code></pre>
though.</div><br/><div id="37441036" class="c"><input type="checkbox" id="c-37441036" checked=""/><div class="controls bullet"><span class="by">eMSF</span><span>|</span><a href="#37439875">root</a><span>|</span><a href="#37440797">parent</a><span>|</span><a href="#37440932">next</a><span>|</span><label class="collapse" for="c-37441036">[-]</label><label class="expand" for="c-37441036">[1 more]</label></div><br/><div class="children"><div class="content">A lot of folks write char const * (and T const&amp; in C++), and the &quot;rule of thumb&quot; is to read the declaration right to left. In this case, pointer (to) const char. Works also with multiple consts or levels of indirection.</div><br/></div></div><div id="37440932" class="c"><input type="checkbox" id="c-37440932" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#37439875">root</a><span>|</span><a href="#37440797">parent</a><span>|</span><a href="#37441036">prev</a><span>|</span><a href="#37442516">next</a><span>|</span><label class="collapse" for="c-37440932">[-]</label><label class="expand" for="c-37440932">[3 more]</label></div><br/><div class="children"><div class="content">&gt; char * const<p>Oof no I HATE this.<p>I also hate it when people write<p><pre><code>    char *a;
</code></pre>
because the type is char* (i.e. pointer to a char) and the name of the variable is a.</div><br/><div id="37442348" class="c"><input type="checkbox" id="c-37442348" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37439875">root</a><span>|</span><a href="#37440932">parent</a><span>|</span><a href="#37441132">next</a><span>|</span><label class="collapse" for="c-37442348">[-]</label><label class="expand" for="c-37442348">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  because the type is char* (i.e. pointer to a char) and the name of the variable is a.<p>But it&#x27;s not.<p><pre><code>  char *a, b;
</code></pre>
The type you are assigning is just char.  The * only affects a.</div><br/></div></div><div id="37441132" class="c"><input type="checkbox" id="c-37441132" checked=""/><div class="controls bullet"><span class="by">moregrist</span><span>|</span><a href="#37439875">root</a><span>|</span><a href="#37440932">parent</a><span>|</span><a href="#37442348">prev</a><span>|</span><a href="#37442516">next</a><span>|</span><label class="collapse" for="c-37441132">[-]</label><label class="expand" for="c-37441132">[1 more]</label></div><br/><div class="children"><div class="content">`char * const a` is a different type from `const char *a`.<p>In the first, the variable `a` is const, but `*a` is not const. That is, you cannot change the value of `a` but you can change what it points to.<p>In the second `a` is not const, but `*a` is. That is, you can change `a` but you cannot change the value it points to.<p>I feel that your confusion is tied up in not understanding how C and C++ type declarations work, as is your insistence on `char* a`.<p>Dennis Ritchie (the C language designer) intended it to be written as `char *a` and talked about this at length over the years as an important design decision:  variable declaration follows _usage_, so it’s `char *a` because the type of `*a` is `char`.<p>For better or worse, Stroustrup took this design decision into C++.<p>Sure both will parse in this simple case, but keeping this in mind is also the way that more complex declarations make sense.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37442516" class="c"><input type="checkbox" id="c-37442516" checked=""/><div class="controls bullet"><span class="by">beyondCritics</span><span>|</span><a href="#37439875">prev</a><span>|</span><a href="#37440448">next</a><span>|</span><label class="collapse" for="c-37442516">[-]</label><label class="expand" for="c-37442516">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In real life, there’s basically no reason ever to use constexpr on a stack variable<p>Wait what? This is what i was doing right now. It defines a local compile time constant and hence is an important mean to express an abstract concept.
You could use a macro, but we are told to get rid of them. And a local const variable is an entirely different thing.</div><br/></div></div><div id="37440448" class="c"><input type="checkbox" id="c-37440448" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#37442516">prev</a><span>|</span><a href="#37440216">next</a><span>|</span><label class="collapse" for="c-37440448">[-]</label><label class="expand" for="c-37440448">[1 more]</label></div><br/><div class="children"><div class="content">constexpr is often difficult to get right.<p>For example, we use a wide_integer type for 128 and 256-bit integers: <a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;blob&#x2F;master&#x2F;base&#x2F;base&#x2F;wide_integer_impl.h">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;blob&#x2F;master&#x2F;base&#x2F;ba...</a><p>It was developed by a C++ expert to fit into the C++ standard, so it has constexpr everywhere. But for this reason, we cannot use memcpy inside its methods and have to wait for a new standard with constexpr memcpy. Note: memcpy is to satisfy strict aliasing - we can use std::bit_cast instead, but there was some trouble.</div><br/></div></div><div id="37440216" class="c"><input type="checkbox" id="c-37440216" checked=""/><div class="controls bullet"><span class="by">ljosifov</span><span>|</span><a href="#37440448">prev</a><span>|</span><a href="#37440336">next</a><span>|</span><label class="collapse" for="c-37440216">[-]</label><label class="expand" for="c-37440216">[1 more]</label></div><br/><div class="children"><div class="content">For many years the best language(s) experts have been trying to have compile time and run time strings live together happily ever. They come tantalizingly close but don&#x27;t quite succeeded. Maybe it is time to entertain the idea that even if compile and run time strings look so similar as to be almost the same - maybe they are not? Maybe they are actually more dissimilar than they appear? Compile time strings to me look more like symbols table: strings unique and ideally sorted. The offset can be a handle - then uniqueness means we can == or != compare handles rather than strings. If the table is sorted, then &lt; &gt; &lt;= &gt;= compares of symbols via their offsets just works too.</div><br/></div></div><div id="37442291" class="c"><input type="checkbox" id="c-37442291" checked=""/><div class="controls bullet"><span class="by">1024core</span><span>|</span><a href="#37440336">prev</a><span>|</span><a href="#37439080">next</a><span>|</span><label class="collapse" for="c-37442291">[-]</label><label class="expand" for="c-37442291">[2 more]</label></div><br/><div class="children"><div class="content">My C++ knowledge is from the old days. What book would one recommend to learn
_and understand_ these new fangled concepts like &quot;constexpr&quot;, &quot;constinit&quot;, std::move, std::unique_ptr, closures, etc.</div><br/><div id="37442396" class="c"><input type="checkbox" id="c-37442396" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37442291">parent</a><span>|</span><a href="#37439080">next</a><span>|</span><label class="collapse" for="c-37442396">[-]</label><label class="expand" for="c-37442396">[1 more]</label></div><br/><div class="children"><div class="content">Tour of C++, written by Bjarne Stroustrouop, exactly for those with prior knowledge 
.</div><br/></div></div></div></div><div id="37439080" class="c"><input type="checkbox" id="c-37439080" checked=""/><div class="controls bullet"><span class="by">frozenport</span><span>|</span><a href="#37442291">prev</a><span>|</span><a href="#37438657">next</a><span>|</span><label class="collapse" for="c-37439080">[-]</label><label class="expand" for="c-37439080">[2 more]</label></div><br/><div class="children"><div class="content">easy fix: just make a std::constexpr_string</div><br/><div id="37439398" class="c"><input type="checkbox" id="c-37439398" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37439080">parent</a><span>|</span><a href="#37438657">next</a><span>|</span><label class="collapse" for="c-37439398">[-]</label><label class="expand" for="c-37439398">[1 more]</label></div><br/><div class="children"><div class="content">it has to be something ridiculous like std::basic_string&lt;char, ..., std::argh::boink::constexpr_trait{}()&lt;!?&gt;&gt;</div><br/></div></div></div></div><div id="37438657" class="c"><input type="checkbox" id="c-37438657" checked=""/><div class="controls bullet"><span class="by">alphanullmeric</span><span>|</span><a href="#37439080">prev</a><span>|</span><a href="#37439472">next</a><span>|</span><label class="collapse" for="c-37438657">[-]</label><label class="expand" for="c-37438657">[7 more]</label></div><br/><div class="children"><div class="content">Much more than rust, that’s for sure, where you are forced to stick everything in a macro or pray the compiler is smart for compile time programming.</div><br/><div id="37438858" class="c"><input type="checkbox" id="c-37438858" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#37438657">parent</a><span>|</span><a href="#37439472">next</a><span>|</span><label class="collapse" for="c-37438858">[-]</label><label class="expand" for="c-37438858">[6 more]</label></div><br/><div class="children"><div class="content">Not to derail, because frankly I think it&#x27;s very weird to even bring Rust up here, but `const fn` is a thing in Rust and is guaranteed to execute at compile time.<p>It is more limited, no question. But you don&#x27;t have to hope that the compiler will do things, it is guaranteed to do them.</div><br/><div id="37439460" class="c"><input type="checkbox" id="c-37439460" checked=""/><div class="controls bullet"><span class="by">alphanullmeric</span><span>|</span><a href="#37438657">root</a><span>|</span><a href="#37438858">parent</a><span>|</span><a href="#37439472">next</a><span>|</span><label class="collapse" for="c-37439460">[-]</label><label class="expand" for="c-37439460">[5 more]</label></div><br/><div class="children"><div class="content">It’s not any weirder than promoting rust under discussions about c++, unless you think any mention of rust must be positive.<p>There is pretty much nothing useful, this post included, that can be done with const fn in rust.</div><br/><div id="37440562" class="c"><input type="checkbox" id="c-37440562" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#37438657">root</a><span>|</span><a href="#37439460">parent</a><span>|</span><a href="#37439472">next</a><span>|</span><label class="collapse" for="c-37440562">[-]</label><label class="expand" for="c-37440562">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It’s not any weirder than promoting rust under discussions about c++<p>Feels like a straw man? I never promoted Rust, certainly I didn&#x27;t bring it up unprompted. I corrected someone who brought it up.<p>&gt; unless you think any mention of rust must be positive.<p>Again, feels like a straw man. I said nothing of the sort.<p>&gt; There is pretty much nothing useful, this post included, that can be done with const fn in rust.<p>I feel like you&#x27;re simultaneously upset that I corrected your post... but also you&#x27;re challenging my point, in an attempt to pursue discussion? It&#x27;s confusing because you&#x27;re wrong but there&#x27;s also an interesting discussion to be had - although I think this post covers the general issue of &quot;what is a pointer at compile time&quot; quite well.</div><br/><div id="37440881" class="c"><input type="checkbox" id="c-37440881" checked=""/><div class="controls bullet"><span class="by">alphanullmeric</span><span>|</span><a href="#37438657">root</a><span>|</span><a href="#37440562">parent</a><span>|</span><a href="#37439472">next</a><span>|</span><label class="collapse" for="c-37440881">[-]</label><label class="expand" for="c-37440881">[3 more]</label></div><br/><div class="children"><div class="content">I didn’t accuse you of doing it, I said you only find other people bringing up rust weird if it’s not positive. Unless you want to agree that it’s always weird to bring up rust in a discussion about c++?<p>I’m not upset about anything. You said I’m wrong, so show me how you use const fn to make a heap allocated string at compile time as done in this post.</div><br/><div id="37441067" class="c"><input type="checkbox" id="c-37441067" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#37438657">root</a><span>|</span><a href="#37440881">parent</a><span>|</span><a href="#37439472">next</a><span>|</span><label class="collapse" for="c-37441067">[-]</label><label class="expand" for="c-37441067">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t understand your first point about bringing Rust up, I&#x27;m going to go out on a limb and assume that English may not be your first language.<p>&gt; You said I’m wrong, so show me how you use const fn to make a heap allocated string at compile time as done in this post.<p>You:<p>&gt; where you are forced to stick everything in a macro or pray the compiler is smart for compile time programming.<p>`const fn` exists. You do not need to &quot;pray the compiler is smart&quot; - you can run code at compile time. No need for macros either.<p>As I also said, it is not as powerful as C++. You can not do heap allocations with const fn.</div><br/><div id="37442273" class="c"><input type="checkbox" id="c-37442273" checked=""/><div class="controls bullet"><span class="by">pharrington</span><span>|</span><a href="#37438657">root</a><span>|</span><a href="#37441067">parent</a><span>|</span><a href="#37439472">next</a><span>|</span><label class="collapse" for="c-37442273">[-]</label><label class="expand" for="c-37442273">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I can&#x27;t understand your first point about bringing Rust up, I&#x27;m going to go out on a limb and assume that English may not be your first language.<p>The sentiment you&#x27;re looking for is &quot;talking past each other&quot;<p>(i&#x27;m assuming mods can detach my comment from the thread?)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37439472" class="c"><input type="checkbox" id="c-37439472" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37438657">prev</a><span>|</span><a href="#37438900">next</a><span>|</span><label class="collapse" for="c-37439472">[-]</label><label class="expand" for="c-37439472">[11 more]</label></div><br/><div class="children"><div class="content">Reading this is really making me sigh. What is C++? A language used to make applications or a language for the sake of the language?<p>It often feels like math professors discussing math for the fun of it, not for solving practical problems.</div><br/><div id="37440089" class="c"><input type="checkbox" id="c-37440089" checked=""/><div class="controls bullet"><span class="by">galkk</span><span>|</span><a href="#37439472">parent</a><span>|</span><a href="#37439821">next</a><span>|</span><label class="collapse" for="c-37440089">[-]</label><label class="expand" for="c-37440089">[1 more]</label></div><br/><div class="children"><div class="content">C++ is a language that was expressive enough to have inside the mechanic that is useful for _implementing_ another language for template metaprogramming, but that another language is built from weird building blocks and they do not look natural at all.<p>Old presentation
<a href="https:&#x2F;&#x2F;youtu.be&#x2F;a0FliKwcwXE?t=31" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;a0FliKwcwXE?t=31</a><p>that when I did watch for the first time did remind me A LOT the memes about different levels of haskell engineers writing factorial function, with people somewhere in the middle implementing their own numerics based on basic number theory things. This presentation is literally exact scenario - you take one thing and start building poor man&#x27;s programming language using it. And it&#x27;s horrific.<p>Problem with C++, that it is extremely slowly addressing is that it doesn&#x27;t have many facilities to improve that nested informal templated language built on top of templating constructs. C++ is getting them, but it at glacier pace. And when I see that presentation after having exposure to other languages, I just feel that this is so much waste here, it could&#x27;ve been much better if language had better thought put into metaprogramming part, instead of letting random crazy geniuses to build hacks on top of hacks to get something useful.<p>Unfortunately for C++, it gives significant problem for starting. Because to learn something, it is very useful to look into how standard things, like stdlib is implemented. But what you see, often, is not C++, it is that another _thing_ that is using c++ constructs to have its own thing. That has its own patterns and quirks (and there are many of them, so many).<p>C++ went into local maxima by letting to do many things by various template tricks, but in the end I think that this is dead end. C++ need real metaprogramming, type level programming, you name it - that can be done in (constrained) C++, not in some fungus that has grown on top of template language.</div><br/></div></div><div id="37439821" class="c"><input type="checkbox" id="c-37439821" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#37439472">parent</a><span>|</span><a href="#37440089">prev</a><span>|</span><a href="#37442363">next</a><span>|</span><label class="collapse" for="c-37439821">[-]</label><label class="expand" for="c-37439821">[1 more]</label></div><br/><div class="children"><div class="content">This seems kinda backwards? C++ has gotten as complex as it has mostly <i>because</i> it’s been the pragmatic default for big, performance sensitive applications consistently for like 30 years and the clear up-and-comer for ~10 more.<p>Java can be really fast and handle big codebases too, and it’s also been huge for long enough it can buy a beer, and it’s also getting a little hairy.<p>Uh, other languages in the niche seem to be <i>starting</i> their runs at comparable levels of complexity, if they’re as successful as it looks like, writing them will be quantum chromodynamics in another 30.</div><br/></div></div><div id="37442363" class="c"><input type="checkbox" id="c-37442363" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#37439472">parent</a><span>|</span><a href="#37439821">prev</a><span>|</span><a href="#37439685">next</a><span>|</span><label class="collapse" for="c-37442363">[-]</label><label class="expand" for="c-37442363">[1 more]</label></div><br/><div class="children"><div class="content">C++ was accidentally highly expressive. Since it was accidental, much of this expressiveness was only available via convoluted and inscrutable metaprogramming. Nonetheless, this expressiveness turned out to be highly useful in practical scenarios, which established the value of that expressiveness.<p>If you fast-forward to C++20, metaprogramming is mostly, though not always, concise and easy to follow. The language was redesigned to make template hacks that people found highly useful into first-class features of the language. For reasons of backward compatibility, you can still express these things the old ways. But it isn’t required anymore, there are concise and direct ways of expressing most metaprogramming things you might want to do.<p>The extreme expressiveness of modern C++ in application domains with unusual requirements remains its greatest strength. For pure systems languages, nothing else can express as much in a type-safe way in so few lines of code, almost entirely due to its metaprogramming facilities.</div><br/></div></div><div id="37439685" class="c"><input type="checkbox" id="c-37439685" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#37439472">parent</a><span>|</span><a href="#37442363">prev</a><span>|</span><a href="#37439795">next</a><span>|</span><label class="collapse" for="c-37439685">[-]</label><label class="expand" for="c-37439685">[5 more]</label></div><br/><div class="children"><div class="content">Luckily, one can just ignore all the modern C++ shenanigans and use it as not much more than C with classes and some basic templates for generic containers. Those are too useful to give up.</div><br/><div id="37441313" class="c"><input type="checkbox" id="c-37441313" checked=""/><div class="controls bullet"><span class="by">gemstones</span><span>|</span><a href="#37439472">root</a><span>|</span><a href="#37439685">parent</a><span>|</span><a href="#37440514">next</a><span>|</span><label class="collapse" for="c-37441313">[-]</label><label class="expand" for="c-37441313">[3 more]</label></div><br/><div class="children"><div class="content">Is everyone on a team of one in C++ land?  I kind of want to learn a bit of C++ but to be honest, I’m a bit scared off by the fact that it’s only workable if you stick to a specific style.  If I learn C++, will I be completely lost the moment I change teams?  Presumably they’ll have their own set of practices they like to follow that I’ll be expected to be productive with.</div><br/><div id="37442966" class="c"><input type="checkbox" id="c-37442966" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#37439472">root</a><span>|</span><a href="#37441313">parent</a><span>|</span><a href="#37441577">next</a><span>|</span><label class="collapse" for="c-37442966">[-]</label><label class="expand" for="c-37442966">[1 more]</label></div><br/><div class="children"><div class="content">Most large teams totally ignore whatever the standard library is doing, because it&#x27;s largely just bad, over engineered and slow, both to compile and at runtime. They then have their own developed from scratch. It would be funny if it wasn&#x27;t so sad.<p>For example, even though both Chromium and Unreal Engine are using C++, good luck finding basically anything high level in common. All of the naming schemes are different, the formatting is different, the high level libraries are unrecognizable. It almost feels like these projects are written in different languages.<p>Beneath all of that, they do make use of the same low level mechanics. A pointer is still a pointer, no matter what libraries you build on it. A stack allocation is still a stack allocation, passing something by a const reference is still the same, passing universal references to container templates is still the same. Includes work the same everywhere. And so on.<p>Basically, unlike most other languages, you want to have a solid understanding of these underlying mechanics so you can then quickly understand whatever high level libraries the project decided to build on top and hit the ground running using those. There&#x27;s gonna be some kind of resizable array thing in every project.<p>But yes, you&#x27;re basically starting over re-familiarizing yourself with the language on every large project or framework you explore. I&#x27;ve been using C++ for many years and never once used a std::string, since each framework has its own clearly superior string...</div><br/></div></div><div id="37441577" class="c"><input type="checkbox" id="c-37441577" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37439472">root</a><span>|</span><a href="#37441313">parent</a><span>|</span><a href="#37442966">prev</a><span>|</span><a href="#37440514">next</a><span>|</span><label class="collapse" for="c-37441577">[-]</label><label class="expand" for="c-37441577">[1 more]</label></div><br/><div class="children"><div class="content">You want to be on a team that contains a C++ expert or two, and they should conscientiously and continuously evolve your code base to incorporate more static time correctness checks and to be more in line with where the standard library is heading.</div><br/></div></div></div></div><div id="37440514" class="c"><input type="checkbox" id="c-37440514" checked=""/><div class="controls bullet"><span class="by">jcul</span><span>|</span><a href="#37439472">root</a><span>|</span><a href="#37439685">parent</a><span>|</span><a href="#37441313">prev</a><span>|</span><a href="#37439795">next</a><span>|</span><label class="collapse" for="c-37440514">[-]</label><label class="expand" for="c-37440514">[1 more]</label></div><br/><div class="children"><div class="content">You can, but the modern stuff (in the last decade or so) have made it so much nicer and more fun to work with.</div><br/></div></div></div></div><div id="37439795" class="c"><input type="checkbox" id="c-37439795" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#37439472">parent</a><span>|</span><a href="#37439685">prev</a><span>|</span><a href="#37439526">next</a><span>|</span><label class="collapse" for="c-37439795">[-]</label><label class="expand" for="c-37439795">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t like it, don&#x27;t use it. For a lot of us writing stuff in c++, the enhancements are always quite useful.</div><br/></div></div></div></div><div id="37438900" class="c"><input type="checkbox" id="c-37438900" checked=""/><div class="controls bullet"><span class="by">eclectic29</span><span>|</span><a href="#37439472">prev</a><span>|</span><a href="#37440511">next</a><span>|</span><label class="collapse" for="c-37438900">[-]</label><label class="expand" for="c-37438900">[5 more]</label></div><br/><div class="children"><div class="content">[deleted]</div><br/><div id="37439012" class="c"><input type="checkbox" id="c-37439012" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#37438900">parent</a><span>|</span><a href="#37438964">next</a><span>|</span><label class="collapse" for="c-37439012">[-]</label><label class="expand" for="c-37439012">[1 more]</label></div><br/><div class="children"><div class="content">Er, I&#x27;m way out of touch with modern c++, what implementation do you buy? Borland used to have tons of little helpers and utils to smooth over some rough edges.<p>I&#x27;d imagine ms vc++ has tons of stuff to support this?<p>Again, I haven&#x27;t used a commercial compiler in a while. But that seems like really standard stuff you get with them, yeah?</div><br/></div></div><div id="37438964" class="c"><input type="checkbox" id="c-37438964" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37438900">parent</a><span>|</span><a href="#37439012">prev</a><span>|</span><a href="#37439139">next</a><span>|</span><label class="collapse" for="c-37438964">[-]</label><label class="expand" for="c-37438964">[1 more]</label></div><br/><div class="children"><div class="content">This is extremely off topic — what does any of this have to do with constexpr strings?</div><br/></div></div><div id="37439092" class="c"><input type="checkbox" id="c-37439092" checked=""/><div class="controls bullet"><span class="by">frozenport</span><span>|</span><a href="#37438900">parent</a><span>|</span><a href="#37439139">prev</a><span>|</span><a href="#37440511">next</a><span>|</span><label class="collapse" for="c-37439092">[-]</label><label class="expand" for="c-37439092">[1 more]</label></div><br/><div class="children"><div class="content">3rd party libraries provide that functionality, and do it with higher performance than in any other another language</div><br/></div></div></div></div><div id="37440511" class="c"><input type="checkbox" id="c-37440511" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#37438900">prev</a><span>|</span><label class="collapse" for="c-37440511">[-]</label><label class="expand" for="c-37440511">[1 more]</label></div><br/><div class="children"><div class="content">&gt; :<p>Meant to be ‘::’, of course. (This abomination can only compete with the ML’s double semicolon.)</div><br/></div></div></div></div></div></div></div></body></html>