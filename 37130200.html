<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692176461062" as="style"/><link rel="stylesheet" href="styles.css?v=1692176461062"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rtheunissen.github.io/bst/">Exploring the design space of binary search trees</a>Â <span class="domain">(<a href="https://rtheunissen.github.io">rtheunissen.github.io</a>)</span></div><div class="subtext"><span>rtheunissen</span> | <span>12 comments</span></div><br/><div><div id="37130607" class="c"><input type="checkbox" id="c-37130607" checked=""/><div class="controls bullet"><span class="by">gniv</span><span>|</span><a href="#37143044">next</a><span>|</span><label class="collapse" for="c-37130607">[-]</label><label class="expand" for="c-37130607">[5 more]</label></div><br/><div class="children"><div class="content">This looks like a thorough treatment of the subject. But my intuition is that B-trees are better than BSTs in almost every context. A good B-tree implementation is more cache-friendly, so faster to insert, delete, traverse. In my previous job I used to replace STL map uses with a btree implementation. It was always faster.</div><br/><div id="37130697" class="c"><input type="checkbox" id="c-37130697" checked=""/><div class="controls bullet"><span class="by">rtheunissen</span><span>|</span><a href="#37130607">parent</a><span>|</span><a href="#37141492">next</a><span>|</span><label class="collapse" for="c-37130697">[-]</label><label class="expand" for="c-37130697">[1 more]</label></div><br/><div class="children"><div class="content">That is true, but in a persistent setting they likely also copy more data, and iterator invalidation might be a concern in some cases when moving values around within a B-tree node. The motivation was not really to come up with the best tree structure or to even consider memory hierarchy at all.<p>Instead, within just the scope of binary search trees specifically, what cool things might we uncover by taking a closer look? In a hypothetical future, our hardware might be so different and caches so large and advanced that the best practices of today might not apply all the same.<p>Binary search trees today are probably only viable for absolutely massive collections, and at that scale there is almost definitely a better, bespoke solution available. Exploring without necessarily thinking about the hardware, in the abstract, has been a fun sandbox to play in. The fact that we still teach them suggests that they provide value beyond practical application.<p>Thank you for your feedback, you are absolutely right. In most practical use-cases today, a B-tree would likely achieve better results.</div><br/></div></div><div id="37141492" class="c"><input type="checkbox" id="c-37141492" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37130607">parent</a><span>|</span><a href="#37130697">prev</a><span>|</span><a href="#37143044">next</a><span>|</span><label class="collapse" for="c-37141492">[-]</label><label class="expand" for="c-37141492">[3 more]</label></div><br/><div class="children"><div class="content">A lot of cache oblivious structures start with a BST laid out in a flat array, which is actually more cache friendly than a naive B tree. But not many people do that in practice, and also require keeping it balanced, so B trees are fine.<p>BSTs are also useful as an analytical tool because they&#x27;re just B trees with B = 2, so a lot of the insight into their structure and algorithms can be extrapolated to N-ary search trees aka B trees</div><br/><div id="37141724" class="c"><input type="checkbox" id="c-37141724" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37130607">root</a><span>|</span><a href="#37141492">parent</a><span>|</span><a href="#37143044">next</a><span>|</span><label class="collapse" for="c-37141724">[-]</label><label class="expand" for="c-37141724">[2 more]</label></div><br/><div class="children"><div class="content">by &#x27;bst laid out in a flat array&#x27; i am guessing you mean a layout like a traditional binheap, so, for the keys 1 2 3 4 5 6 7<p><pre><code>    4 2 6 1 3 5 7
</code></pre>
is that right, and do you mean to make this arbitrarily large<p>i feel like this is less cache friendly than a naive b-tree, even without rebalancing; if your cache line size is 128 bytes, your keys are 4 bytes, and your b-tree nodes are 15 keys and 16 (4-byte!) pointers, you can reach any of 1048576 keys in 5 cache-line fills, of which probably 2 were already in your cache so it&#x27;s really 3.  by contrast, the flat-array binary search tree above is 20 levels deep.  the first 5 levels are in one cache line (because you don&#x27;t waste any space on pointers) but every key in the following 15 levels of the tree is in its own cache line so you have probably 14 cache-line fills<p>14 is like a lot more than 3 in my mind maybe<p>conceivably you have done this in practice and can tell me what i&#x27;m overlooking</div><br/><div id="37142687" class="c"><input type="checkbox" id="c-37142687" checked=""/><div class="controls bullet"><span class="by">rtheunissen</span><span>|</span><a href="#37130607">root</a><span>|</span><a href="#37141724">parent</a><span>|</span><a href="#37143044">next</a><span>|</span><label class="collapse" for="c-37142687">[-]</label><label class="expand" for="c-37142687">[1 more]</label></div><br/><div class="children"><div class="content">I believe yes, as illustrated in [1]. This idea only works in a static sense, because to insert a value suffers from the same linear movement of memory as dynamic arrays. B-trees are somewhere in-between because they support logarithmic insert&#x2F;split&#x2F;join and make better use of cache than BSTs, a well known fact.<p>I tried to focus specifically on BSTs in the context of online persistence and concurrency, where they are particularly effective at very large sizes. There is a section on the paper that mentions B-trees but I did not want to include a direct comparison as part of the scope. Take the best candidate from this set, and compare against a good B-tree implementation in whatever situation you might require them.<p>[1] <a href="https:&#x2F;&#x2F;algorithmica.org&#x2F;en&#x2F;eytzinger" rel="nofollow noreferrer">https:&#x2F;&#x2F;algorithmica.org&#x2F;en&#x2F;eytzinger</a></div><br/></div></div></div></div></div></div></div></div><div id="37143044" class="c"><input type="checkbox" id="c-37143044" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#37130607">prev</a><span>|</span><a href="#37143523">next</a><span>|</span><label class="collapse" for="c-37143044">[-]</label><label class="expand" for="c-37143044">[2 more]</label></div><br/><div class="children"><div class="content">Empty page with noscript. And with Javascript enabled just text!</div><br/><div id="37143545" class="c"><input type="checkbox" id="c-37143545" checked=""/><div class="controls bullet"><span class="by">rtheunissen</span><span>|</span><a href="#37143044">parent</a><span>|</span><a href="#37143523">next</a><span>|</span><label class="collapse" for="c-37143545">[-]</label><label class="expand" for="c-37143545">[1 more]</label></div><br/><div class="children"><div class="content">This is tragic! Supporting noscript was a primary design goal but I forgot to only enable the knuth&#x2F;plass justification in print media. The math expressions I&#x27;m moving to build time now. So sorry.</div><br/></div></div></div></div><div id="37143523" class="c"><input type="checkbox" id="c-37143523" checked=""/><div class="controls bullet"><span class="by">mattnewport</span><span>|</span><a href="#37143044">prev</a><span>|</span><a href="#37131012">next</a><span>|</span><label class="collapse" for="c-37143523">[-]</label><label class="expand" for="c-37143523">[1 more]</label></div><br/><div class="children"><div class="content">Skimming through, I didn&#x27;t see any discussion of AA trees which I have seen discussed as similar to red black trees but simpler to implement and have been interested in exploring for learning purposes. Any reason you didn&#x27;t look specifically at AA trees, or were they covered somewhere that I missed?</div><br/></div></div><div id="37131012" class="c"><input type="checkbox" id="c-37131012" checked=""/><div class="controls bullet"><span class="by">davmsmith</span><span>|</span><a href="#37143523">prev</a><span>|</span><a href="#37141193">next</a><span>|</span><label class="collapse" for="c-37131012">[-]</label><label class="expand" for="c-37131012">[1 more]</label></div><br/><div class="children"><div class="content">A brilliant resource thank you! Will definitely be referencing this in our ds&#x2F;algorithms courses.</div><br/></div></div></div></div></div></div></div></body></html>