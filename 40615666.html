<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717923671388" as="style"/><link rel="stylesheet" href="styles.css?v=1717923671388"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://msinilo.pl/blog2/post/compilers-are-too-smart/">Compilers Are (Too) Smart</a> <span class="domain">(<a href="http://msinilo.pl">msinilo.pl</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>30 comments</span></div><br/><div><div id="40622614" class="c"><input type="checkbox" id="c-40622614" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#40617235">next</a><span>|</span><label class="collapse" for="c-40622614">[-]</label><label class="expand" for="c-40622614">[2 more]</label></div><br/><div class="children"><div class="content">I have come across a related compiler issue with popcnt before. I was trying to prototype a &quot;population count&quot; routine in C before rewriting it in 64-bit ARM assembly.
ARMv8.0 64-bit doesn&#x27;t have a &quot;popcnt&quot; instruction in its scalar set.<p>I was curious to how well Clang would map my C statements into the ARM assembly I had been thinking of using, so I tested it on Compiler Explorer.
I noticed that in the output my routine was oh so slightly different, using an inverted constant. I then rewrote my routine with another algorithm ... but got the same compiler output.<p>Apparently Clang can recognise that &quot;Oh, this is a population count routine&quot; and replace it with a `llvm.ctpop.i32` intrinsic.
I have found no way to use compiler flags to suppress specifically this optimisation without turning off optimisations completely.</div><br/><div id="40622995" class="c"><input type="checkbox" id="c-40622995" checked=""/><div class="controls bullet"><span class="by">matthews2</span><span>|</span><a href="#40622614">parent</a><span>|</span><a href="#40617235">next</a><span>|</span><label class="collapse" for="c-40622995">[-]</label><label class="expand" for="c-40622995">[1 more]</label></div><br/><div class="children"><div class="content">You can use -mno-popcnt for this.<p>Godbolt: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;raszoEedr" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;raszoEedr</a><p>Reference: <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ClangCommandLineReference.html#cmdoption-clang-mpopcnt" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ClangCommandLineReference.html#c...</a></div><br/></div></div></div></div><div id="40617235" class="c"><input type="checkbox" id="c-40617235" checked=""/><div class="controls bullet"><span class="by">FrankWilhoit</span><span>|</span><a href="#40622614">prev</a><span>|</span><a href="#40618441">next</a><span>|</span><label class="collapse" for="c-40617235">[-]</label><label class="expand" for="c-40617235">[3 more]</label></div><br/><div class="children"><div class="content">So you need to do a binary search but you don&#x27;t want to use division instructions.  The funny thing is that DEC&#x27;s assembler for the PDP-10 did a very similar thing to set up the binary search of its symbol table, which was its critical path.  The JFFO instruction (Jump on Find First One) was added to the PDP-10 instruction set for this purpose.</div><br/><div id="40617311" class="c"><input type="checkbox" id="c-40617311" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40617235">parent</a><span>|</span><a href="#40618441">next</a><span>|</span><label class="collapse" for="c-40617311">[-]</label><label class="expand" for="c-40617311">[2 more]</label></div><br/><div class="children"><div class="content">Binary search is easy because division by two is just a shift. It doesn’t need any division or even multiplication instructions. I can guess why they might have used JFFO but it seems needlessly complicated.<p>I wonder why libcxx doesn’t use multiplication for modular reduction. <a href="https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2016&#x2F;06&#x2F;27&#x2F;a-fast-alternative-to-the-modulo-reduction&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2016&#x2F;06&#x2F;27&#x2F;a-fast-alternative-to-the-...</a></div><br/><div id="40617553" class="c"><input type="checkbox" id="c-40617553" checked=""/><div class="controls bullet"><span class="by">FrankWilhoit</span><span>|</span><a href="#40617235">root</a><span>|</span><a href="#40617311">parent</a><span>|</span><a href="#40618441">next</a><span>|</span><label class="collapse" for="c-40617553">[-]</label><label class="expand" for="c-40617553">[1 more]</label></div><br/><div class="children"><div class="content">The trick is quickly finding the largest power of two that is less than the size of the table.  It was done with two instructions: the second was the JFFO, the first was an FADD with a purposely denormalized operand.  The symbol table was kept sorted on every insert.</div><br/></div></div></div></div></div></div><div id="40618441" class="c"><input type="checkbox" id="c-40618441" checked=""/><div class="controls bullet"><span class="by">petermcneeley</span><span>|</span><a href="#40617235">prev</a><span>|</span><a href="#40622252">next</a><span>|</span><label class="collapse" for="c-40618441">[-]</label><label class="expand" for="c-40618441">[2 more]</label></div><br/><div class="children"><div class="content">Looks like this is the week we talk about the performance of hash function binning.
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40553541">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40553541</a><p>Most of the issue here comes from the mistaken belief that computers do mathematical (and more specifically arithmatic) operations as first class citizens.</div><br/></div></div><div id="40622252" class="c"><input type="checkbox" id="c-40622252" checked=""/><div class="controls bullet"><span class="by">mrcode007</span><span>|</span><a href="#40618441">prev</a><span>|</span><a href="#40622243">next</a><span>|</span><label class="collapse" for="c-40622252">[-]</label><label class="expand" for="c-40622252">[6 more]</label></div><br/><div class="children"><div class="content">It uses SWAR technique for counting bits because target platform wasn’t specified in compiler flags properly. popcnt and family are specific family extensions and without specifying the target flags the compiler generates lowest common denominator among available instructions<p>Edit: add -msse4 and you will see popcnt appear because popcnt is the SSE4 extension</div><br/><div id="40622419" class="c"><input type="checkbox" id="c-40622419" checked=""/><div class="controls bullet"><span class="by">upon_drumhead</span><span>|</span><a href="#40622252">parent</a><span>|</span><a href="#40622691">next</a><span>|</span><label class="collapse" for="c-40622419">[-]</label><label class="expand" for="c-40622419">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It was a Clang compiler, ARM-based platform<p>&gt; I do think it is a bug in this case, native popcnt could maybe be defended, but should not be used if compiling for architecture that does not support it.</div><br/><div id="40622607" class="c"><input type="checkbox" id="c-40622607" checked=""/><div class="controls bullet"><span class="by">mrcode007</span><span>|</span><a href="#40622252">root</a><span>|</span><a href="#40622419">parent</a><span>|</span><a href="#40622691">next</a><span>|</span><label class="collapse" for="c-40622607">[-]</label><label class="expand" for="c-40622607">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you would like to experiment yourself, Compiler Explorer snippet can be found here<p><a href="https:&#x2F;&#x2F;gcc.godbolt.org&#x2F;z&#x2F;qGzWo39b6" rel="nofollow">https:&#x2F;&#x2F;gcc.godbolt.org&#x2F;z&#x2F;qGzWo39b6</a><p>Which is an x86-64 sample</div><br/></div></div></div></div><div id="40622691" class="c"><input type="checkbox" id="c-40622691" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40622252">parent</a><span>|</span><a href="#40622419">prev</a><span>|</span><a href="#40622392">next</a><span>|</span><label class="collapse" for="c-40622691">[-]</label><label class="expand" for="c-40622691">[1 more]</label></div><br/><div class="children"><div class="content">I think the issue that the article is not explaining very well, is that what it&#x27;s <i>actually</i> trying to do is check if a number is a power of two, and one part of the compiler says &quot;use popcnt!&quot; and then later another part says &quot;oh sorry, we&#x27;ll have to emulate that with a ton of instructions&quot;. Whereas it could have just used a shift and and.</div><br/></div></div><div id="40622392" class="c"><input type="checkbox" id="c-40622392" checked=""/><div class="controls bullet"><span class="by">fyrn_</span><span>|</span><a href="#40622252">parent</a><span>|</span><a href="#40622691">prev</a><span>|</span><a href="#40622259">next</a><span>|</span><label class="collapse" for="c-40622392">[-]</label><label class="expand" for="c-40622392">[1 more]</label></div><br/><div class="children"><div class="content">The article says all of this?</div><br/></div></div></div></div><div id="40622243" class="c"><input type="checkbox" id="c-40622243" checked=""/><div class="controls bullet"><span class="by">shikaan</span><span>|</span><a href="#40622252">prev</a><span>|</span><label class="collapse" for="c-40622243">[-]</label><label class="expand" for="c-40622243">[16 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s probably hyperbole, but why<p>&gt; yes, I know, friends don’t let friends use STL, but that is a topic for another discussion<p>?<p>Are there known shortcomings with the standard library in C++?</div><br/><div id="40622406" class="c"><input type="checkbox" id="c-40622406" checked=""/><div class="controls bullet"><span class="by">fyrn_</span><span>|</span><a href="#40622243">parent</a><span>|</span><a href="#40622657">next</a><span>|</span><label class="collapse" for="c-40622406">[-]</label><label class="expand" for="c-40622406">[3 more]</label></div><br/><div class="children"><div class="content">It has some pretty bad containers, specifically unordered_map and map, and set.
There are some good talks on why from ccp con and other varius developer cons.
They are still usable mind you, just it&#x27;s also true that unordered_map is slower then JS or Python hashmaps in some situations
because of some really questionable design choices (exposing bucket nodes, overly restrictive iterator invalidation  requirements, etc..)</div><br/><div id="40622433" class="c"><input type="checkbox" id="c-40622433" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#40622243">root</a><span>|</span><a href="#40622406">parent</a><span>|</span><a href="#40622657">next</a><span>|</span><label class="collapse" for="c-40622433">[-]</label><label class="expand" for="c-40622433">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the recommended drop-in replacement? absl::flat_map?</div><br/><div id="40622649" class="c"><input type="checkbox" id="c-40622649" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40622243">root</a><span>|</span><a href="#40622433">parent</a><span>|</span><a href="#40622657">next</a><span>|</span><label class="collapse" for="c-40622649">[-]</label><label class="expand" for="c-40622649">[1 more]</label></div><br/><div class="children"><div class="content">One of the Abseil containers if you really need an associative container to begin with, but honestly often you can play quite a few tricks with just plain arrays if you get a little creative, with better performance profiles...</div><br/></div></div></div></div></div></div><div id="40622657" class="c"><input type="checkbox" id="c-40622657" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40622243">parent</a><span>|</span><a href="#40622406">prev</a><span>|</span><a href="#40622571">next</a><span>|</span><label class="collapse" for="c-40622657">[-]</label><label class="expand" for="c-40622657">[2 more]</label></div><br/><div class="children"><div class="content">People exaggerate this a lot, but mainly it&#x27;s just the discontiguous containers (and regexes) that often have better alternatives. They&#x27;re not bad for what they&#x27;re trying to accomplish -- they just provide guarantees you often don&#x27;t need, which results in you paying costs you shouldn&#x27;t need to.</div><br/><div id="40622833" class="c"><input type="checkbox" id="c-40622833" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40622243">root</a><span>|</span><a href="#40622657">parent</a><span>|</span><a href="#40622571">next</a><span>|</span><label class="collapse" for="c-40622833">[-]</label><label class="expand" for="c-40622833">[1 more]</label></div><br/><div class="children"><div class="content">Worth noting that this issue is not unique to the C++ standard library either. Java is saddled with an overly-general HashMap implementation with awful worst-case performance characteristics as well, and older versions of Rust&#x27;s HashMap had performance problems as well (though these have mostly been addressed).</div><br/></div></div></div></div><div id="40622571" class="c"><input type="checkbox" id="c-40622571" checked=""/><div class="controls bullet"><span class="by">snovv_crash</span><span>|</span><a href="#40622243">parent</a><span>|</span><a href="#40622657">prev</a><span>|</span><a href="#40622269">next</a><span>|</span><label class="collapse" for="c-40622571">[-]</label><label class="expand" for="c-40622571">[1 more]</label></div><br/><div class="children"><div class="content">The algorithms are generally fine, it&#x27;s the containers which are very heavy on heap allocations, particularly the maps and trees.</div><br/></div></div><div id="40622269" class="c"><input type="checkbox" id="c-40622269" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#40622243">parent</a><span>|</span><a href="#40622571">prev</a><span>|</span><a href="#40622566">next</a><span>|</span><label class="collapse" for="c-40622269">[-]</label><label class="expand" for="c-40622269">[1 more]</label></div><br/><div class="children"><div class="content">I noticed the post was tagged with &#x27;gamedev&#x27; which might be relevant, STL used to be hard to optimize due to it doing lots of heap allocations.<p>It has been a while since I was in gamedev so perhaps not true anymore but sometimes these things change slowly with people&#x2F;culture.</div><br/></div></div><div id="40622566" class="c"><input type="checkbox" id="c-40622566" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#40622243">parent</a><span>|</span><a href="#40622269">prev</a><span>|</span><a href="#40622426">next</a><span>|</span><label class="collapse" for="c-40622566">[-]</label><label class="expand" for="c-40622566">[1 more]</label></div><br/><div class="children"><div class="content">On top of what sibling comments mention, another common problem is that the STL has many different implementations with different&#x2F;inconsistent performance profiles. If you want containers with guaranteed performance characteristics, you&#x27;re better off using your own or a third party.</div><br/></div></div><div id="40622267" class="c"><input type="checkbox" id="c-40622267" checked=""/><div class="controls bullet"><span class="by">mrcode007</span><span>|</span><a href="#40622243">parent</a><span>|</span><a href="#40622426">prev</a><span>|</span><a href="#40622495">next</a><span>|</span><label class="collapse" for="c-40622267">[-]</label><label class="expand" for="c-40622267">[1 more]</label></div><br/><div class="children"><div class="content">No. It’s a trope. Most people can’t tell the difference. It’s highly context and application specific.</div><br/></div></div><div id="40622495" class="c"><input type="checkbox" id="c-40622495" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#40622243">parent</a><span>|</span><a href="#40622267">prev</a><span>|</span><a href="#40622248">next</a><span>|</span><label class="collapse" for="c-40622495">[-]</label><label class="expand" for="c-40622495">[4 more]</label></div><br/><div class="children"><div class="content">STL has been both historically and recently slow in many ways. Many game devs are making their own engine, especially historically, so they just implement their own version of STL in the way they want. Or they use another engine which has made its own replacement. Even Andreas of SerenityOS made his own entire STL (and also his own Objective-C like class system).<p>The C++ STL is probably one of the most commonly avoided standard libraries of any language. I can’t think of another that is so often replaced by bespoke code</div><br/><div id="40622572" class="c"><input type="checkbox" id="c-40622572" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40622243">root</a><span>|</span><a href="#40622495">parent</a><span>|</span><a href="#40622248">next</a><span>|</span><label class="collapse" for="c-40622572">[-]</label><label class="expand" for="c-40622572">[3 more]</label></div><br/><div class="children"><div class="content">When I was learning C++ in 2008, I remember people telling me STL was one of the greatest accomplishments in computer science.</div><br/><div id="40622672" class="c"><input type="checkbox" id="c-40622672" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40622243">root</a><span>|</span><a href="#40622572">parent</a><span>|</span><a href="#40622725">next</a><span>|</span><label class="collapse" for="c-40622672">[-]</label><label class="expand" for="c-40622672">[1 more]</label></div><br/><div class="children"><div class="content">It always depended on the specific C++ bubble you&#x27;re in. The stdlib was also controversial back then (even in the late 90&#x27;s when I started to use C++).</div><br/></div></div><div id="40622725" class="c"><input type="checkbox" id="c-40622725" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#40622243">root</a><span>|</span><a href="#40622572">parent</a><span>|</span><a href="#40622672">prev</a><span>|</span><a href="#40622248">next</a><span>|</span><label class="collapse" for="c-40622725">[-]</label><label class="expand" for="c-40622725">[1 more]</label></div><br/><div class="children"><div class="content">Well, 2008 was a long time ago, but back then it was even worse.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>