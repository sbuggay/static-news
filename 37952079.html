<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697792455735" as="style"/><link rel="stylesheet" href="styles.css?v=1697792455735"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://journal.stuffwithstuff.com/2023/10/19/does-go-have-subtyping/">Does Go Have Subtyping?</a> <span class="domain">(<a href="https://journal.stuffwithstuff.com">journal.stuffwithstuff.com</a>)</span></div><div class="subtext"><span>grep_it</span> | <span>53 comments</span></div><br/><div><div id="37953574" class="c"><input type="checkbox" id="c-37953574" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37953032">next</a><span>|</span><label class="collapse" for="c-37953574">[-]</label><label class="expand" for="c-37953574">[1 more]</label></div><br/><div class="children"><div class="content">The conclusion is pretty weird to me.<p>Go <i>does</i> rely on monomorphization for generics, just like C++ and Rust. The only difference is that this is an implementation detail, so Go can group multiple monomorphizations without worrying about anything else [1]. This form of hybrid monomorphization is being increasingly common, GHC does that and Rust is also trying to do so [2], so nothing special for Go here.<p>On the other hand, explaining variance as a lifted polymorphism is---while not incorrect per se---also weird in part because a lack of variance is at worst just an annoyance. You can always make an adapter to unify heterogeneous types. Rust calls it `Box&lt;dyn Trait&gt;`, Go happens to call it an interface type instead. Both languages even do not allow heterogeneous <i>concrete</i> (or runtime) types in a single slice! So variance has no use in both languages because no concrete types are eligible for variance anyway.<p>I think the conclusion got weird because the term &quot;subtyping&quot; is being misused. Subtyping, in the broadest sense, is just a non-trivial type relation. Many languages thus have a <i>multiple</i> notion of subtyping, often (almost) identical to each other but sometimes not. Go in particular has a lot of them, and even some relation like &quot;T implements U&quot; is a straightforward record subtyping. So subtyping is indeed a red herring here. Given this, it is no surprise that the non-uniform value representation has the largest influence, and only monomorphization schemes and hetero-to-homogeneous adapters vary in this particular group.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;proposal&#x2F;blob&#x2F;master&#x2F;design&#x2F;generics-implementation-dictionaries-go1.18.md">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;proposal&#x2F;blob&#x2F;master&#x2F;design&#x2F;generi...</a><p>[2] <a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;compiler-team&#x2F;working-groups&#x2F;polymorphization&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;compiler-team&#x2F;working-groups&#x2F;pol...</a></div><br/></div></div><div id="37953032" class="c"><input type="checkbox" id="c-37953032" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#37953574">prev</a><span>|</span><a href="#37953037">next</a><span>|</span><label class="collapse" for="c-37953032">[-]</label><label class="expand" for="c-37953032">[1 more]</label></div><br/><div class="children"><div class="content">In my opinion the interface system in Go is largely redundant, because interfaces are mostly equivalent to… structs of function pointers. And the single function interface case is just equivalent to a single function pointer.<p>If Go had a slightly better syntax for that, a lot of the interface use cases could be largely simplified. The interface implementation as subtype could be replaced with explicit instantiation using an “extends” keyword, plus sum types, and it would have been a simpler approach.</div><br/></div></div><div id="37953037" class="c"><input type="checkbox" id="c-37953037" checked=""/><div class="controls bullet"><span class="by">kune</span><span>|</span><a href="#37953032">prev</a><span>|</span><a href="#37952810">next</a><span>|</span><label class="collapse" for="c-37953037">[-]</label><label class="expand" for="c-37953037">[2 more]</label></div><br/><div class="children"><div class="content">The statement &quot;An interface type A is assignable to interface type B if A’s methods are a subset of B’s.&quot; is wrong. It is not in the current language specification of Go. The author misunderstood the term type set from the Go language specification. The type set of an interface is the set of types implementing the interface and not the set of methods of an interface. If you use the right meaning of type set, the subset makes sense again.</div><br/><div id="37953445" class="c"><input type="checkbox" id="c-37953445" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#37953037">parent</a><span>|</span><a href="#37952810">next</a><span>|</span><label class="collapse" for="c-37953445">[-]</label><label class="expand" for="c-37953445">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not wrong, <a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#Assignability" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#Assignability</a>:<p><pre><code>    &gt; A value x of type V is assignable to a variable of type T (&quot;x is assignable to T&quot;) if
    &gt; ...
    &gt; T is an interface type, but not a type parameter, and x implements[1] T
</code></pre>
[1]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#Implementing_an_interface" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec#Implementing_an_interface</a>:<p><pre><code>    &gt; A type T implements an interface I if:
    &gt; ...
    &gt; T is an interface and the type set of T is a subset of the type set of I</code></pre></div><br/></div></div></div></div><div id="37952810" class="c"><input type="checkbox" id="c-37952810" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#37953037">prev</a><span>|</span><a href="#37953106">next</a><span>|</span><label class="collapse" for="c-37952810">[-]</label><label class="expand" for="c-37952810">[1 more]</label></div><br/><div class="children"><div class="content">This is an excellent article, also the first explanation of variance I&#x27;ve read that didn&#x27;t make my eyes glaze over.</div><br/></div></div><div id="37953106" class="c"><input type="checkbox" id="c-37953106" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#37952810">prev</a><span>|</span><a href="#37953432">next</a><span>|</span><label class="collapse" for="c-37953106">[-]</label><label class="expand" for="c-37953106">[1 more]</label></div><br/><div class="children"><div class="content">The writing style of Bob Nystrom is just awesome. He has the right balance between tech details and the wording.</div><br/></div></div><div id="37953432" class="c"><input type="checkbox" id="c-37953432" checked=""/><div class="controls bullet"><span class="by">stefano_c</span><span>|</span><a href="#37953106">prev</a><span>|</span><a href="#37953168">next</a><span>|</span><label class="collapse" for="c-37953432">[-]</label><label class="expand" for="c-37953432">[3 more]</label></div><br/><div class="children"><div class="content">The &quot;Variance of slice types&quot; paragraph is confusing as hell. The type Tree implements interface Barker, after all. To me it looks like this is more about what I call &quot;accidental implementation&quot; (which is one of the many reasons why I don&#x27;t like Go).
Can somebody please explain what I&#x27;m missing?</div><br/><div id="37953615" class="c"><input type="checkbox" id="c-37953615" checked=""/><div class="controls bullet"><span class="by">eloisant</span><span>|</span><a href="#37953432">parent</a><span>|</span><a href="#37953581">next</a><span>|</span><label class="collapse" for="c-37953615">[-]</label><label class="expand" for="c-37953615">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just a bad example because the dog barking and tree barking just happened to be called the same.<p>But let&#x27;s say you have Admin and EndUser that both implement the User class. You would think you could use a []EndUser on a function that takes a []User. Because you can use a EndUser when you need a User.<p>Except you can&#x27;t because of mutability. In Scala for example, ListBuffer is invarient (because you could append the wrong type) however the immutable List is covarient so you can call a function that takes a List[User] and pass it a List[EndUser].</div><br/></div></div><div id="37953581" class="c"><input type="checkbox" id="c-37953581" checked=""/><div class="controls bullet"><span class="by">shellac</span><span>|</span><a href="#37953432">parent</a><span>|</span><a href="#37953615">prev</a><span>|</span><a href="#37953168">next</a><span>|</span><label class="collapse" for="c-37953581">[-]</label><label class="expand" for="c-37953581">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it conflates a structural vs nominal type difference (i.e. punning &#x27;bark&#x27;), with a classic variance issue.<p>Ignore the tree. Suppose you have _seals_, who are plausibly &#x27;barkers&#x27; in the same sense as dogs. Take an array Dog[] and pass it to a function that accepts Barker[]. It seems reasonable to take a Barker from the array, nice and safe. But suppose we try to put a Seal into the array, that&#x27;s not fine: it&#x27;s a Dog[].<p>Famously java got this wrong, but runtime checks (somewhat) stop that being a disaster.</div><br/></div></div></div></div><div id="37953168" class="c"><input type="checkbox" id="c-37953168" checked=""/><div class="controls bullet"><span class="by">divan</span><span>|</span><a href="#37953432">prev</a><span>|</span><a href="#37953305">next</a><span>|</span><label class="collapse" for="c-37953168">[-]</label><label class="expand" for="c-37953168">[1 more]</label></div><br/><div class="children"><div class="content">One of the most insightful articles on Go in years. Great educational stuff!</div><br/></div></div><div id="37953305" class="c"><input type="checkbox" id="c-37953305" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#37953168">prev</a><span>|</span><a href="#37952816">next</a><span>|</span><label class="collapse" for="c-37953305">[-]</label><label class="expand" for="c-37953305">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>When that happens, all of the types the type checker poked at have cracked out of their chrysalides and emerged as beautiful runtime value butterflies flitting around in memory.</i><p>This sentence will forever change how I feel when debugging running programs.</div><br/></div></div><div id="37952816" class="c"><input type="checkbox" id="c-37952816" checked=""/><div class="controls bullet"><span class="by">JonathanBeuys</span><span>|</span><a href="#37953305">prev</a><span>|</span><label class="collapse" for="c-37952816">[-]</label><label class="expand" for="c-37952816">[40 more]</label></div><br/><div class="children"><div class="content">It is amazing what length people are willing to go in the hope of &quot;safety&quot;.<p>Is there anybody out there who successfully build their <i>own</i> product, not via VC or other investments, but on their <i>own</i> time and <i>own</i> money who likes types?<p>To me it seems that types are something consultants and people who get paid for their <i>time</i> instead of their productivity like. Because it makes things more complex. So to achieve the same task, you can bill more time.<p>I have not seen anybody successfully build something on their own time, money, risk who like types. If there is someone here, I would love to see it!<p>On the other hand, I have seen many examples of lean code like the following turning into successful life style businesses and companies:<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;nikcub&#x2F;3833406" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;nikcub&#x2F;3833406</a></div><br/><div id="37952940" class="c"><input type="checkbox" id="c-37952940" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37952897">next</a><span>|</span><label class="collapse" for="c-37952940">[-]</label><label class="expand" for="c-37952940">[5 more]</label></div><br/><div class="children"><div class="content">Quite an unusual take. There are millions of developers who prefer TypeScript over JavaScript for any job, including self-founded products.<p>But even if they didn’t exist, it’s a non sequitur. There are very good reasons for type systems regardless of how projects are founded.<p>You might not realize that Go has a very limited and awkwardly designed static type system that is the sole reason reason people prefer it for certain tasks over Python, which has both a dynamic, and by now an optional static type system.<p>Your final point, that types make things more complex and harder to develop is also flawed. Type systems exist to decrease the mental overhead and unload it from the programmer onto the compiler.<p>They might require more work upfront, but make software more solid, easier to reason about and easier to change. If you’re building a one-off that you will never change then a type less language might be of interest to you.<p>But it’s short sighted to think that you will be able to write it once and keep it running forever. Only managers who don’t code believe fairy tales like that. In reality many people sit down on a codebase, they fix things, and add functionality. When they do, they want to avoid bugs, they want the compiler to help them, they want LSP, they want to avoid null pointer dereference, double free, they want to be safer, and more productive.<p>They’d rather spend a week upfront instead of a day so that every one of the later changes takes a day instead of a week.</div><br/><div id="37953319" class="c"><input type="checkbox" id="c-37953319" checked=""/><div class="controls bullet"><span class="by">JonathanBeuys</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952940">parent</a><span>|</span><a href="#37952897">next</a><span>|</span><label class="collapse" for="c-37953319">[-]</label><label class="expand" for="c-37953319">[4 more]</label></div><br/><div class="children"><div class="content">So what is an example of a self-founded project that used types and is a business success now?</div><br/><div id="37953412" class="c"><input type="checkbox" id="c-37953412" checked=""/><div class="controls bullet"><span class="by">efnx</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953319">parent</a><span>|</span><a href="#37953437">next</a><span>|</span><label class="collapse" for="c-37953412">[-]</label><label class="expand" for="c-37953412">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;googlethatforyou.com&#x2F;?q=successful%20business%20built%20with%20rust" rel="nofollow noreferrer">https:&#x2F;&#x2F;googlethatforyou.com&#x2F;?q=successful%20business%20buil...</a><p>You get the picture.<p>Also, types are a spectrum. C++ has types, Objective-C has types. Those alone have enough success stories to fill tomes! But of course you’re talking about strong static type systems like Haskell, Ocaml, Scala or ML, so you should read up on Jane Street. Or Mercury. Blockchains like Cardano.<p>Personally I think the onus is on you to prove that types are _not_ useful. Many of us enjoy types.</div><br/></div></div><div id="37953437" class="c"><input type="checkbox" id="c-37953437" checked=""/><div class="controls bullet"><span class="by">dosshell</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953319">parent</a><span>|</span><a href="#37953412">prev</a><span>|</span><a href="#37953526">next</a><span>|</span><label class="collapse" for="c-37953437">[-]</label><label class="expand" for="c-37953437">[1 more]</label></div><br/><div class="children"><div class="content">How long list do you want?<p>Pretty much all successful indie games use typed languages. Of course, there is a mix with untyped scripts in there too. But many only depends on typed languages.</div><br/></div></div><div id="37953526" class="c"><input type="checkbox" id="c-37953526" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953319">parent</a><span>|</span><a href="#37953437">prev</a><span>|</span><a href="#37952897">next</a><span>|</span><label class="collapse" for="c-37953526">[-]</label><label class="expand" for="c-37953526">[1 more]</label></div><br/><div class="children"><div class="content">That’s like asking, who is an example of a white men in Germany..</div><br/></div></div></div></div></div></div><div id="37952897" class="c"><input type="checkbox" id="c-37952897" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37952940">prev</a><span>|</span><a href="#37952822">next</a><span>|</span><label class="collapse" for="c-37952897">[-]</label><label class="expand" for="c-37952897">[7 more]</label></div><br/><div class="children"><div class="content">You should watch this video [1] from Martin Odersky, creator of Scala.<p>It shows how the entire industry has moved towards stronger typing. Whether it&#x27;s existing languages like JavaScript and Python or new ones like Rust and Swift. The trend is undeniable.<p>I use Scala and Rust every day and I personally think they are better for startups because they allow you to rely more heavily on the compiler to verify things rather than having to check at runtime with unit tests. That means <i>more</i> time on new features and <i>less</i> time fixing bugs and writing tests.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7mTNZeiIK7E">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7mTNZeiIK7E</a></div><br/><div id="37952957" class="c"><input type="checkbox" id="c-37952957" checked=""/><div class="controls bullet"><span class="by">olivermuty</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952897">parent</a><span>|</span><a href="#37952822">next</a><span>|</span><label class="collapse" for="c-37952957">[-]</label><label class="expand" for="c-37952957">[6 more]</label></div><br/><div class="children"><div class="content">I don’t disagree on the summary of your post. Especially for refactoring, types can be great.<p>But it is funny you chose the creator of Scala as the example. The gold plated banana cables of typing. The entire language and its endless lang mailing list discussions is a meme by now.</div><br/><div id="37953158" class="c"><input type="checkbox" id="c-37953158" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952957">parent</a><span>|</span><a href="#37953236">next</a><span>|</span><label class="collapse" for="c-37953158">[-]</label><label class="expand" for="c-37953158">[1 more]</label></div><br/><div class="children"><div class="content">To be fair the new languages like Rust, Swift, Kotlin etc have all borrowed heavily from Scala in their design. So clearly it is resonating.<p>And his upcoming research work could be game changing. The benefits of Rust&#x27;s concurrency safety without the annoying borrow checker.</div><br/></div></div><div id="37953236" class="c"><input type="checkbox" id="c-37953236" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952957">parent</a><span>|</span><a href="#37953158">prev</a><span>|</span><a href="#37952822">next</a><span>|</span><label class="collapse" for="c-37953236">[-]</label><label class="expand" for="c-37953236">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not it. The issues Scala had were:<p>1. A whole lot of programmers who didn&#x27;t know how to use the language effectively in 2010. Less of an issue now the patterns are well established and industry wide the level of knowledge has increased (even Java has algebraic data types now)<p>2. Some idiots in the community, who have now left<p>3. Some rough edge cases in the Scala 2 type system; fixed in Scala 3</div><br/><div id="37953296" class="c"><input type="checkbox" id="c-37953296" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953236">parent</a><span>|</span><a href="#37952822">next</a><span>|</span><label class="collapse" for="c-37953296">[-]</label><label class="expand" for="c-37953296">[3 more]</label></div><br/><div class="children"><div class="content">4. Ignoring the fact that not only language but also tooling is a significant factor affecting developer experience. Extremely long compile times, weird build system, lack of good IDE support.<p>5. Breaking backwards compatibility with each release. This is something that businesses care a lot about.</div><br/><div id="37953541" class="c"><input type="checkbox" id="c-37953541" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953296">parent</a><span>|</span><a href="#37953492">next</a><span>|</span><label class="collapse" for="c-37953541">[-]</label><label class="expand" for="c-37953541">[1 more]</label></div><br/><div class="children"><div class="content">4. There is Mill now, which is very great (and also not scala-specific)<p>5. AFAIK it is also solved with Scala3 with a binary compatible format.</div><br/></div></div><div id="37953492" class="c"><input type="checkbox" id="c-37953492" checked=""/><div class="controls bullet"><span class="by">realusername</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953296">parent</a><span>|</span><a href="#37953541">prev</a><span>|</span><a href="#37952822">next</a><span>|</span><label class="collapse" for="c-37953492">[-]</label><label class="expand" for="c-37953492">[1 more]</label></div><br/><div class="children"><div class="content">Also the learning curve isn&#x27;t great for new developers in my opinion, lots of uncommon concepts and built-in keywords which aren&#x27;t googleable.<p>This is a big issue for a language which isn&#x27;t too popular since learning it is expected.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37952822" class="c"><input type="checkbox" id="c-37952822" checked=""/><div class="controls bullet"><span class="by">OccamsMirror</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37952897">prev</a><span>|</span><a href="#37953185">next</a><span>|</span><label class="collapse" for="c-37952822">[-]</label><label class="expand" for="c-37952822">[7 more]</label></div><br/><div class="children"><div class="content">I love type safety. When I drop down to a dynamically typed language I&#x27;m actually slower as I have to double check my work. I don&#x27;t understand how someone in 2023 can be against type safety.</div><br/><div id="37952826" class="c"><input type="checkbox" id="c-37952826" checked=""/><div class="controls bullet"><span class="by">JonathanBeuys</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952822">parent</a><span>|</span><a href="#37953185">next</a><span>|</span><label class="collapse" for="c-37952826">[-]</label><label class="expand" for="c-37952826">[6 more]</label></div><br/><div class="children"><div class="content">And did you build a successful software product on your own time, risking your own money?</div><br/><div id="37952982" class="c"><input type="checkbox" id="c-37952982" checked=""/><div class="controls bullet"><span class="by">valvar</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952826">parent</a><span>|</span><a href="#37953031">next</a><span>|</span><label class="collapse" for="c-37952982">[-]</label><label class="expand" for="c-37952982">[1 more]</label></div><br/><div class="children"><div class="content">Yes, as everyone knows, you are only entitled to an opinion about software if you are also a successful business entrepreneur without external funding.<p>Good type systems increase velocity by leaving less room for error, so that you don&#x27;t have to waste half your time debugging and fixing issues that could have been easily prevented. They also provide helpful structure and an IDE experience (the right values, functions, actions, etc are actually suggested for you wherever you are) that really does speed up development a lot.<p>There&#x27;s of course always a trade-off: bad type systems can get in your way with boilerplate that you have to wrangle. But I don&#x27;t think that&#x27;s the typical experience.</div><br/></div></div><div id="37953031" class="c"><input type="checkbox" id="c-37953031" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952826">parent</a><span>|</span><a href="#37952982">prev</a><span>|</span><a href="#37952985">next</a><span>|</span><label class="collapse" for="c-37953031">[-]</label><label class="expand" for="c-37953031">[3 more]</label></div><br/><div class="children"><div class="content">My shell (interactive command line environment + scripting language) is written in a type safe language. It’s tens of thousands of lines of code (maybe even hundreds of thousands, I’ve not counted) and has been actively developed for the best part of a decade.<p>I’d have completely failed at this project if it weren’t for type safety because refactoring anything that long lived and that much code would have been a nightmare.</div><br/><div id="37953313" class="c"><input type="checkbox" id="c-37953313" checked=""/><div class="controls bullet"><span class="by">JonathanBeuys</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953031">parent</a><span>|</span><a href="#37952985">next</a><span>|</span><label class="collapse" for="c-37953313">[-]</label><label class="expand" for="c-37953313">[2 more]</label></div><br/><div class="children"><div class="content">That is not a business though, is it?<p>So there was no risk involved like &quot;Will I tank my future if this fails?&quot;.<p>What I witnessed is that makers who are willing to bet on something with real consequences dislike types as they slow down the progress and therefore the chances of success.</div><br/><div id="37953358" class="c"><input type="checkbox" id="c-37953358" checked=""/><div class="controls bullet"><span class="by">DandyDev</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953313">parent</a><span>|</span><a href="#37952985">next</a><span>|</span><label class="collapse" for="c-37953358">[-]</label><label class="expand" for="c-37953358">[1 more]</label></div><br/><div class="children"><div class="content">Why don’t _you_ come up with examples where non-VC funded but successful businesses are doing well in part because they chose to ignore types?<p>At this point, I’m not even sure what you are trying to prove and I’m starting to feel that whatever it is, you’re trying to prove it to yourself mostly.</div><br/></div></div></div></div></div></div><div id="37952985" class="c"><input type="checkbox" id="c-37952985" checked=""/><div class="controls bullet"><span class="by">photonbeam</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952826">parent</a><span>|</span><a href="#37953031">prev</a><span>|</span><a href="#37953185">next</a><span>|</span><label class="collapse" for="c-37952985">[-]</label><label class="expand" for="c-37952985">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t the bar though, thats a ‘can I prototype something to MVP’ situation</div><br/></div></div></div></div></div></div><div id="37953185" class="c"><input type="checkbox" id="c-37953185" checked=""/><div class="controls bullet"><span class="by">eddtries</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37952822">prev</a><span>|</span><a href="#37952939">next</a><span>|</span><label class="collapse" for="c-37953185">[-]</label><label class="expand" for="c-37953185">[1 more]</label></div><br/><div class="children"><div class="content">Your non-typed code still uses types, you just have to remember what they are and test functions in more ways to check that your memory and assumptions are correct.</div><br/></div></div><div id="37952939" class="c"><input type="checkbox" id="c-37952939" checked=""/><div class="controls bullet"><span class="by">DandyDev</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37953185">prev</a><span>|</span><a href="#37952966">next</a><span>|</span><label class="collapse" for="c-37952939">[-]</label><label class="expand" for="c-37952939">[1 more]</label></div><br/><div class="children"><div class="content">That is an odd and cynical take.<p>I see a TON of open source projects (frameworks, libraries etc.) on the frontend alone that are built using TypeScript. And on the backend Golang is hugely popular and Rust is gaining a lot of traction. All in open source. Not every one of those open source projects is backed by VC money or built by consultants.</div><br/></div></div><div id="37952966" class="c"><input type="checkbox" id="c-37952966" checked=""/><div class="controls bullet"><span class="by">justinpombrio</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37952939">prev</a><span>|</span><a href="#37953451">next</a><span>|</span><label class="collapse" for="c-37952966">[-]</label><label class="expand" for="c-37952966">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have not seen anybody successfully build something on their own time, money, risk who like types. If there is someone here, I would love to see it!<p>Experiment: <i>you</i> go and search for people who have built something on &quot;their own time, money, and risk&quot;. Find them by what they&#x27;ve built. <i>First</i> decide whether you respect what they&#x27;ve made, and <i>only then</i> check what language they decided to use to build the thing. I predict that you&#x27;ll find plenty of people who have built respectable things using typed languages.</div><br/></div></div><div id="37953451" class="c"><input type="checkbox" id="c-37953451" checked=""/><div class="controls bullet"><span class="by">jonathanlydall</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37952966">prev</a><span>|</span><a href="#37953600">next</a><span>|</span><label class="collapse" for="c-37953451">[-]</label><label class="expand" for="c-37953451">[1 more]</label></div><br/><div class="children"><div class="content">C# is my language of choice and the strong typing allows me to refactor and change names of (“internal”) things at a whim on even extremely large solutions with no possibility of runtime failures due to the refactoring tooling doing all the work for me and the compiler complaining if something doesn’t line up.<p>My view is that people who don’t like strongly typed languages have either just never worked on very large codebases, or they avoid refactors due the general impracticality of it, or they have loads of unit tests to catch runtime “type mismatches” which would have just been caught by the compiler in a strongly typed language.<p>Choosing an untyped language vs a typed one is a trade off of less upfront work in typing things vs future analysis capabilities of your code. And for me, the upfront cost of typing things is negligible compared to the gains for the future, which in my decade+ of experience pays itself many many times over on any non trivial sized code base.</div><br/></div></div><div id="37953600" class="c"><input type="checkbox" id="c-37953600" checked=""/><div class="controls bullet"><span class="by">lemming</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37953451">prev</a><span>|</span><a href="#37952956">next</a><span>|</span><label class="collapse" for="c-37953600">[-]</label><label class="expand" for="c-37953600">[1 more]</label></div><br/><div class="children"><div class="content">Yes, me. I develop an IDE for Clojure code which is a mix of Clojure and Kotlin. I like both, but what I like about Clojure is the interactive programming, not the lack of types. If there were a statically typed Clojure I’d be all over it.</div><br/></div></div><div id="37952956" class="c"><input type="checkbox" id="c-37952956" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37953600">prev</a><span>|</span><a href="#37953034">next</a><span>|</span><label class="collapse" for="c-37952956">[-]</label><label class="expand" for="c-37952956">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you ignore types they will just go away<p>I agree, programming is very hard. Let&#x27;s go shopping.</div><br/></div></div><div id="37953034" class="c"><input type="checkbox" id="c-37953034" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37952956">prev</a><span>|</span><a href="#37953000">next</a><span>|</span><label class="collapse" for="c-37953034">[-]</label><label class="expand" for="c-37953034">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t agree with your comment in general, but I think I understand where you&#x27;re coming from. Many formerly loosely typed languages (JS, PHP, Python etc.) have tried to introduce stronger typing - I have the most experience with PHP, so I&#x27;ll talk about that: sometimes &quot;stronger&quot; typing can be a pain, especially if you try to introduce it to an existing weakly typed project, or if you&#x27;re interfacing with some other weakly typed system (e.g. JSON files). One example: everything is working fine, then you declare a function parameter as `string`, and suddenly you get runtime errors because one of the many callers occasionally passes `null`, and you forgot the question mark before the `string`.</div><br/><div id="37953119" class="c"><input type="checkbox" id="c-37953119" checked=""/><div class="controls bullet"><span class="by">DandyDev</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953034">parent</a><span>|</span><a href="#37953000">next</a><span>|</span><label class="collapse" for="c-37953119">[-]</label><label class="expand" for="c-37953119">[5 more]</label></div><br/><div class="children"><div class="content">So what you’re saying is that by introducing type checks, you’re actually uncovering bugs. Seems to me like proof of value right there.<p>What does surprise me is that adding types to your PHP code adds  _runtime_ errors. With Python, type annotations are predominantly used by static typecheckers and are ignored at runtime (except from some libraries like FastAPI that use reflection to inspect the type annotations). I always assumed all dynamically typed languages that introduced explicit types worked the same way</div><br/><div id="37953327" class="c"><input type="checkbox" id="c-37953327" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953119">parent</a><span>|</span><a href="#37953528">next</a><span>|</span><label class="collapse" for="c-37953327">[-]</label><label class="expand" for="c-37953327">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What does surprise me is that adding types to your PHP code adds _runtime_ errors<p>There are static analysers for PHP too, but yeah they’re also enforced at runtime.<p>I <i>think</i> I prefer that, if there’s going to be a non-zero risk of bad types landing in production code, I’d prefer that be an error than for it to just carry on and potentially fail later in strange ways.<p>That said, one of the reasons cited for PHP not having generics is the performance cost of runtime enforcement. So there are a few people out there now making the case for a generic syntax that is ignored at runtime, but that can be built into static tooling. Which I can get behind—PHPs type system is really not bad at this point, but generics would be really nice.</div><br/><div id="37953335" class="c"><input type="checkbox" id="c-37953335" checked=""/><div class="controls bullet"><span class="by">DandyDev</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953327">parent</a><span>|</span><a href="#37953528">next</a><span>|</span><label class="collapse" for="c-37953335">[-]</label><label class="expand" for="c-37953335">[1 more]</label></div><br/><div class="children"><div class="content">I would also prefer type checks to be done at runtime as well. The reason Python doesn’t do that is likely indeed the cost to performance</div><br/></div></div></div></div><div id="37953528" class="c"><input type="checkbox" id="c-37953528" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953119">parent</a><span>|</span><a href="#37953327">prev</a><span>|</span><a href="#37953000">next</a><span>|</span><label class="collapse" for="c-37953528">[-]</label><label class="expand" for="c-37953528">[2 more]</label></div><br/><div class="children"><div class="content">Well no, maybe there was a legitimate reason to pass null instead of a string (I mean, nullable types exist for a reason), and then you just <i>introduced</i> a bug because you didn&#x27;t look hard enough at all the places your function is called (which can take some time).</div><br/><div id="37953562" class="c"><input type="checkbox" id="c-37953562" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953528">parent</a><span>|</span><a href="#37953000">next</a><span>|</span><label class="collapse" for="c-37953562">[-]</label><label class="expand" for="c-37953562">[1 more]</label></div><br/><div class="children"><div class="content">If you have a null-aware type system, then you just can’t call your function with a null, so no bug?<p>Also, if you just annotated the same implementation that already didn’t handle nulls properly, how is it any different? Your code would just die at runtime a few lines later, with a less explicit errorz</div><br/></div></div></div></div></div></div></div></div><div id="37953000" class="c"><input type="checkbox" id="c-37953000" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37953034">prev</a><span>|</span><a href="#37953138">next</a><span>|</span><label class="collapse" for="c-37953000">[-]</label><label class="expand" for="c-37953000">[3 more]</label></div><br/><div class="children"><div class="content">Pretty much everything I build. I find it harder using languages that don’t have type safety.</div><br/><div id="37953259" class="c"><input type="checkbox" id="c-37953259" checked=""/><div class="controls bullet"><span class="by">augustk</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953000">parent</a><span>|</span><a href="#37953138">next</a><span>|</span><label class="collapse" for="c-37953259">[-]</label><label class="expand" for="c-37953259">[2 more]</label></div><br/><div class="children"><div class="content">Most languages are type-safe.</div><br/><div id="37953485" class="c"><input type="checkbox" id="c-37953485" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37953259">parent</a><span>|</span><a href="#37953138">next</a><span>|</span><label class="collapse" for="c-37953485">[-]</label><label class="expand" for="c-37953485">[1 more]</label></div><br/><div class="children"><div class="content">Some languages are weakly typed though, which can cause confusion at the points where one type is automatically converted to another (e.g. JS, where 1 + &quot;2&quot; = &quot;12&quot;), and you need to keep type conversion and precedence in mind.<p>It didn&#x27;t take long earlier in my career to realize that in JS, you need to be aware of the type of your variables and try and avoid any implicit type conversions.</div><br/></div></div></div></div></div></div><div id="37953138" class="c"><input type="checkbox" id="c-37953138" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37953000">prev</a><span>|</span><a href="#37952840">next</a><span>|</span><label class="collapse" for="c-37953138">[-]</label><label class="expand" for="c-37953138">[1 more]</label></div><br/><div class="children"><div class="content">Types are like a built-in test suite for your code. They constantly check that what you are doing is not nonsensical.<p>If you want a high-profile story, take Figma; it&#x27;s built with C++ which is a highly type-oriented language.<p>Anecdotally, in the last three startups I worked (including one really tiny), the code base was &#x2F; is largely in Typescript, Kotlin, Python with heavy type annotations, and small bits of Rust.</div><br/></div></div><div id="37952840" class="c"><input type="checkbox" id="c-37952840" checked=""/><div class="controls bullet"><span class="by">turndown</span><span>|</span><a href="#37952816">parent</a><span>|</span><a href="#37953138">prev</a><span>|</span><a href="#37953472">next</a><span>|</span><label class="collapse" for="c-37952840">[-]</label><label class="expand" for="c-37952840">[2 more]</label></div><br/><div class="children"><div class="content">Types, like many things in life, only matter once you are in a situation where you could really use them(or would sidestep a certain kind of problem…) If you are in one of those, and more importantly don’t realize it, that is when you really pay. The daily languages that we all use(99% of us) do not utilize complex type systems and thus cannot solve complex problems.</div><br/><div id="37953086" class="c"><input type="checkbox" id="c-37953086" checked=""/><div class="controls bullet"><span class="by">cdogl</span><span>|</span><a href="#37952816">root</a><span>|</span><a href="#37952840">parent</a><span>|</span><a href="#37953472">next</a><span>|</span><label class="collapse" for="c-37953086">[-]</label><label class="expand" for="c-37953086">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The daily languages that we all use(99% of us) do not utilize complex type systems and thus cannot solve complex problems.<p>It seems reasonable to assume that the 99% comprises the bulk of production software, which is solving complex problems everywhere every day.<p>The remaining 1% can be valuable and interesting but come down to a small fraction of real delivered code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>