<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723539678927" as="style"/><link rel="stylesheet" href="styles.css?v=1723539678927"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.maragu.dev/blog/go-is-my-hammer-and-everything-is-a-nail">Go is my hammer, and everything is a nail</a> <span class="domain">(<a href="https://www.maragu.dev">www.maragu.dev</a>)</span></div><div class="subtext"><span>markusw</span> | <span>415 comments</span></div><br/><div><div id="41233629" class="c"><input type="checkbox" id="c-41233629" checked=""/><div class="controls bullet"><span class="by">OezMaster</span><span>|</span><a href="#41224825">next</a><span>|</span><label class="collapse" for="c-41233629">[-]</label><label class="expand" for="c-41233629">[1 more]</label></div><br/><div class="children"><div class="content">Does the same apply to &#x27;platforms&#x27;? For example, is it better to learn C# + F# + Powershell instead of C# + Scala + Bash?</div><br/></div></div><div id="41224825" class="c"><input type="checkbox" id="c-41224825" checked=""/><div class="controls bullet"><span class="by">bborud</span><span>|</span><a href="#41233629">prev</a><span>|</span><a href="#41233492">next</a><span>|</span><label class="collapse" for="c-41224825">[-]</label><label class="expand" for="c-41224825">[35 more]</label></div><br/><div class="children"><div class="content">People always under-estimate the cost of properly learning a language.  At any given time I tend to have a &quot;main go-to language&quot;.  I typically spend 2-4 years getting to the point where I can say I &quot;know&quot; a language.  Then I try to stick to it long enough for the investment to pay off.  Usually 8-10 years.<p>A surprising number of people think this is a very long time. It isn&#x27;t.  This is typically the time it takes to understand enough of the language, the compiler, the runtime, the standard library, and idiomatic ways to do things.  It is the time it takes to where you can start to meaningfully contribute to evolving how the language is used and meaningfully coach architects, programmers and system designers. It is also what you need to absorb novices into the organization and train them fast.</div><br/><div id="41231597" class="c"><input type="checkbox" id="c-41231597" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41230071">next</a><span>|</span><label class="collapse" for="c-41231597">[-]</label><label class="expand" for="c-41231597">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It is the time it takes to where you can start to meaningfully contribute to evolving how the language is used and meaningfully coach architects, programmers and system designers. It is also what you need to absorb novices into the organization and train them fast.<p>I think these criteria in particular are much more than a lot of people mean when they say &quot;learn a language&quot;, which would explain why their estimates are lower than yours. You&#x27;re talking about expertise, whereas plenty of people are speaking of basic competency. This seems more like (natural) language semantics about what it means to &quot;know&quot; and the definition of &quot;properly learn&quot; than about the accuracy of people&#x27;s estimates.</div><br/><div id="41231989" class="c"><input type="checkbox" id="c-41231989" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41231597">parent</a><span>|</span><a href="#41230071">next</a><span>|</span><label class="collapse" for="c-41231989">[-]</label><label class="expand" for="c-41231989">[5 more]</label></div><br/><div class="children"><div class="content">2012:  Python is Awesome!<p>2014:  Python is a great language, but there are a few pitfalls<p>2016:  Python is a good language with the right IDE, tooling, and process.  The people are pretty cool though.<p>2018:  I like python, but I wish more people used type annotations.<p>2020:  You know, metaclasses are freaking awesome!  They saved me so much work!<p>2022:  Why can&#x27;t people code the most obvious solution in python?<p>2024:  Celery!  Jesus H. Christ!  What were you thinking?!</div><br/><div id="41232832" class="c"><input type="checkbox" id="c-41232832" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41231989">parent</a><span>|</span><a href="#41233181">next</a><span>|</span><label class="collapse" for="c-41232832">[-]</label><label class="expand" for="c-41232832">[1 more]</label></div><br/><div class="children"><div class="content">2012: Python is Awesome!<p>2014: Python is a pain in the butt to manage packages and dependencies, how the hell am I gonna deploy this?<p>It&#x27;s still a mess 10 years later unless you live deep in the ecosystem and know what third-party solutions du jour to manage that complexity. At least we have Docker now.<p>Also let&#x27;s not forget the Python 3 migration fiasco that lasted ~2008-2018 and I still find myself porting libraries to this day.<p>I haven&#x27;t used Python in a personal project in 10 years because of these painful paper cuts .</div><br/></div></div><div id="41233181" class="c"><input type="checkbox" id="c-41233181" checked=""/><div class="controls bullet"><span class="by">radicalbyte</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41231989">parent</a><span>|</span><a href="#41232832">prev</a><span>|</span><a href="#41230071">next</a><span>|</span><label class="collapse" for="c-41233181">[-]</label><label class="expand" for="c-41233181">[3 more]</label></div><br/><div class="children"><div class="content">I have a nice way of testing a language - I download a couple of projects written by beginner &#x2F; mid-level developers and not having commercial dependencies and see how much effort it takes to get them running.<p>Python is one of the worst performers (and Java is shockingly bad too, although a lot of that is down to the way the JVM&#x2F;language have been mismanaged). At least unless you&#x27;re comparing it to very low-level languages (VDL, C).</div><br/><div id="41233527" class="c"><input type="checkbox" id="c-41233527" checked=""/><div class="controls bullet"><span class="by">munksbeer</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41233181">parent</a><span>|</span><a href="#41233516">next</a><span>|</span><label class="collapse" for="c-41233527">[-]</label><label class="expand" for="c-41233527">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and Java is shockingly bad too, although a lot of that is down to the way the JVM&#x2F;language have been mismanaged<p>This is interesting and not what I would expect. Generally to get a java app running from github you&#x27;d install the correct JDK and that should be about it. Many projects will use maven, which will know how to obtain dependencies. Could you describe a typical issue?</div><br/></div></div><div id="41233516" class="c"><input type="checkbox" id="c-41233516" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41233181">parent</a><span>|</span><a href="#41233527">prev</a><span>|</span><a href="#41230071">next</a><span>|</span><label class="collapse" for="c-41233516">[-]</label><label class="expand" for="c-41233516">[1 more]</label></div><br/><div class="children"><div class="content">In which way do you believe the JVM&#x2F;language has been mismanaged?</div><br/></div></div></div></div></div></div></div></div><div id="41230071" class="c"><input type="checkbox" id="c-41230071" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41231597">prev</a><span>|</span><a href="#41233293">next</a><span>|</span><label class="collapse" for="c-41230071">[-]</label><label class="expand" for="c-41230071">[2 more]</label></div><br/><div class="children"><div class="content">And then you have the ever changing ecosystem, that can take years so sort out on it&#x27;s own and must be constantly studied.<p>E.G: if you arrive in Python right now, numpy is in version 2 and polars is stable. uv is all the rage, pydantic gained so much perf it&#x27;s not even funny, toml is part of the stdlib and textual is looking very good. Type hints are much better than 2 years ago, htmx is used a lot in the web department, fasthtml is having a moment in the light and pyscript got a platform. Is any of those information worth acting on? Should you ignore them all for the sake of productivity? Should you carefully evaluate each proposition?<p>Now if you have to do that with rust and erlang as well, it&#x27;s a lot of time you could spend on coding instead.</div><br/><div id="41231844" class="c"><input type="checkbox" id="c-41231844" checked=""/><div class="controls bullet"><span class="by">otteromkram</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41230071">parent</a><span>|</span><a href="#41233293">next</a><span>|</span><label class="collapse" for="c-41231844">[-]</label><label class="expand" for="c-41231844">[1 more]</label></div><br/><div class="children"><div class="content">IMHO, that&#x27;s not part of learning the language. You don&#x27;t really even need half of the packages you mentioned unless you don&#x27;t know the language and, instead, rely upon third-party crutches.</div><br/></div></div></div></div><div id="41233293" class="c"><input type="checkbox" id="c-41233293" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41230071">prev</a><span>|</span><a href="#41224912">next</a><span>|</span><label class="collapse" for="c-41233293">[-]</label><label class="expand" for="c-41233293">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, there&#x27;s such a wide knowledge gap between &quot;I read about this language design choice online&quot; and &quot;I know this from first principles&quot;. Truly, thoroughly understanding the languages and tools you work with every day unlocks a deeper level of understanding that you can&#x27;t substitute with anything else. It&#x27;s what people often describe when they first learn Lisp, but the same actually holds for every language, tool, etc. There is tremendous value in depth. However, since there is considerable opportunity cost in choosing what you put your time and effort into, do be mindful of the tools you decide to acquire this amount of knowledge in.</div><br/></div></div><div id="41224912" class="c"><input type="checkbox" id="c-41224912" checked=""/><div class="controls bullet"><span class="by">cube2222</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41233293">prev</a><span>|</span><a href="#41232766">next</a><span>|</span><label class="collapse" for="c-41224912">[-]</label><label class="expand" for="c-41224912">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Having a passing knowledge of many languages is of course easy (even being moderately productive with them, esp. with Copilot now), but knowing the ins and outs of a language and its ecosystem is a very nontrivial time investment.<p>Thus, I&#x27;m mostly an anti-fan of the idea of polyglot environments.</div><br/></div></div><div id="41232766" class="c"><input type="checkbox" id="c-41232766" checked=""/><div class="controls bullet"><span class="by">p0w3n3d</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41224912">prev</a><span>|</span><a href="#41229727">next</a><span>|</span><label class="collapse" for="c-41232766">[-]</label><label class="expand" for="c-41232766">[1 more]</label></div><br/><div class="children"><div class="content">I totally agree with you. Only after min 2 years of fully coding a viable production solution can one learn most of the pitfalls of given language. I would add frameworks which give another level of complexity and sometimes a framework is like a separate language.</div><br/></div></div><div id="41229727" class="c"><input type="checkbox" id="c-41229727" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41232766">prev</a><span>|</span><a href="#41229903">next</a><span>|</span><label class="collapse" for="c-41229727">[-]</label><label class="expand" for="c-41229727">[2 more]</label></div><br/><div class="children"><div class="content">It’s not just the time to understand those nuances, but to keep up with the pace of changes. There’s an aspect of navigating those in some languages (JS…) that can be time consuming depending on where it’s deployed.</div><br/><div id="41231312" class="c"><input type="checkbox" id="c-41231312" checked=""/><div class="controls bullet"><span class="by">tengbretson</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41229727">parent</a><span>|</span><a href="#41229903">next</a><span>|</span><label class="collapse" for="c-41231312">[-]</label><label class="expand" for="c-41231312">[1 more]</label></div><br/><div class="children"><div class="content">Not only is it the nuances and pace of changes, but theres also a temporal element of seeing cause and effect over time from within an ecosystem. Is there a way to just parachute in and learn how to judiciously use classes in JavaScript the way one would if they were out there assigning Thing.prototype.method = function () {}? Can Udemy give you the same a-ha moment learning Promises today that someone got when they were drowning in callback pyramids in their Express v3 app?</div><br/></div></div></div></div><div id="41229903" class="c"><input type="checkbox" id="c-41229903" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41229727">prev</a><span>|</span><a href="#41232959">next</a><span>|</span><label class="collapse" for="c-41229903">[-]</label><label class="expand" for="c-41229903">[1 more]</label></div><br/><div class="children"><div class="content">Naturally one can&#x27;t know all the languages of the world.<p>Even so, I have done consulting since 1999, with a small 2 years pause in research, and have several languages that I keep switching, every couple of months when project reassignment takes place.<p>The usual T-shape kind of consultant, know some stuff really well, and others good enough to deliver.</div><br/></div></div><div id="41232959" class="c"><input type="checkbox" id="c-41232959" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41229903">prev</a><span>|</span><a href="#41230779">next</a><span>|</span><label class="collapse" for="c-41232959">[-]</label><label class="expand" for="c-41232959">[1 more]</label></div><br/><div class="children"><div class="content">It takes forever to &quot;properly learn&quot; a language in my opinion, because it would mean the total emersion into the ecosystem and most prominent libraries built around that language as well, and they will be always moving targets even though the language itself might be static. Go is no exception, and in fact there are only a handful of languages that can be ever &quot;properly learned&quot; if we are strict about that. The trick is not to properly learn, but to know how to learn enough of anything you need and make the best use out of that.</div><br/></div></div><div id="41230779" class="c"><input type="checkbox" id="c-41230779" checked=""/><div class="controls bullet"><span class="by">brightball</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41232959">prev</a><span>|</span><a href="#41230087">next</a><span>|</span><label class="collapse" for="c-41230779">[-]</label><label class="expand" for="c-41230779">[1 more]</label></div><br/><div class="children"><div class="content">This is actually how I feel about Ruby. Not full on Rails because there is a lot more to learn there which comes with the time investment (which is also worth it in many cases).<p>But for most scripting work especially, just raw Ruby and maybe the Sequel library for a database just makes my productivity soar.</div><br/></div></div><div id="41230087" class="c"><input type="checkbox" id="c-41230087" checked=""/><div class="controls bullet"><span class="by">nemo1618</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41230779">prev</a><span>|</span><a href="#41232746">next</a><span>|</span><label class="collapse" for="c-41230087">[-]</label><label class="expand" for="c-41230087">[13 more]</label></div><br/><div class="children"><div class="content">One of the most important qualities of Go is that it is actually possible to <i>fully</i> understand the language -- in the sense that you <i>never</i> see a snippet of Go code and think &quot;wtf, you can do that?&quot; or &quot;hang on, why does that work?&quot;<p>Getting to that point takes many years, to be sure. But the language is simple enough, and changes slowly enough, that it is not an unrealistic goal -- the way it would be in C++, or Rust, or just about any other mainstream language.</div><br/><div id="41232910" class="c"><input type="checkbox" id="c-41232910" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41230087">parent</a><span>|</span><a href="#41231110">next</a><span>|</span><label class="collapse" for="c-41232910">[-]</label><label class="expand" for="c-41232910">[1 more]</label></div><br/><div class="children"><div class="content">Why is that important?<p>Let&#x27;s say one language has me find a weird rabbit hole every 50 hours of use, and I spend half an hour learning about it.<p>Let&#x27;s say another language has no rabbit holes, but I&#x27;m 5% slower at coding in it.<p>Why would I not prefer the first language?<p>(And 5% is supposed to be an intentional lowball.  I&#x27;m confident I can find language pairs where my productivity differs by significantly more.)</div><br/></div></div><div id="41231110" class="c"><input type="checkbox" id="c-41231110" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41230087">parent</a><span>|</span><a href="#41232910">prev</a><span>|</span><a href="#41232679">next</a><span>|</span><label class="collapse" for="c-41231110">[-]</label><label class="expand" for="c-41231110">[2 more]</label></div><br/><div class="children"><div class="content">Personally my biggest issue with reading go code has come from the &#x2F;&#x2F;go: magic comments that I never seem to <i>fully</i> understand.<p>For example, what the heck is a &#x2F;&#x2F;go:cgo_import_dynamic? As far as I can tell this is only documented on GitHub issues and mailing list comments.</div><br/><div id="41233072" class="c"><input type="checkbox" id="c-41233072" checked=""/><div class="controls bullet"><span class="by">tazjin</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41231110">parent</a><span>|</span><a href="#41232679">next</a><span>|</span><label class="collapse" for="c-41233072">[-]</label><label class="expand" for="c-41233072">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the cgo docs: <a href="https:&#x2F;&#x2F;go.dev&#x2F;src&#x2F;cmd&#x2F;cgo&#x2F;doc.go#L880" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;src&#x2F;cmd&#x2F;cgo&#x2F;doc.go#L880</a></div><br/></div></div></div></div><div id="41232679" class="c"><input type="checkbox" id="c-41232679" checked=""/><div class="controls bullet"><span class="by">mingusrude</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41230087">parent</a><span>|</span><a href="#41231110">prev</a><span>|</span><a href="#41230735">next</a><span>|</span><label class="collapse" for="c-41232679">[-]</label><label class="expand" for="c-41232679">[1 more]</label></div><br/><div class="children"><div class="content">This is similar to the experience that I had with Erlang. After having spent time with it, I was hardly every surprised looking at any code and my brain could deal with the actual problems at hand without having to figure out how to apply what I knew about the language.</div><br/></div></div><div id="41230735" class="c"><input type="checkbox" id="c-41230735" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41230087">parent</a><span>|</span><a href="#41232679">prev</a><span>|</span><a href="#41232746">next</a><span>|</span><label class="collapse" for="c-41230735">[-]</label><label class="expand" for="c-41230735">[8 more]</label></div><br/><div class="children"><div class="content">&gt; in the sense that you never see a snippet of Go code and think &quot;wtf, you can do that?&quot; or &quot;hang on, why does that work?&quot;<p>I am extremely doubtful that this is true and would like evidence.</div><br/><div id="41231238" class="c"><input type="checkbox" id="c-41231238" checked=""/><div class="controls bullet"><span class="by">monkeywork</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41230735">parent</a><span>|</span><a href="#41230906">next</a><span>|</span><label class="collapse" for="c-41231238">[-]</label><label class="expand" for="c-41231238">[5 more]</label></div><br/><div class="children"><div class="content">kind of hard for someone to prove a negative -  feel free to find some Go code that meets that definition.</div><br/><div id="41231451" class="c"><input type="checkbox" id="c-41231451" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41231238">parent</a><span>|</span><a href="#41230906">next</a><span>|</span><label class="collapse" for="c-41231451">[-]</label><label class="expand" for="c-41231451">[4 more]</label></div><br/><div class="children"><div class="content">I feel this way... very often.<p>* Init functions<p>* Top-level variables being shared between all files in a package<p>* For-loop sharing (fixed in 1.22 [0])<p>* ldflags (this is more of build behavior, but it took me a while to figure out how some variables were being set [1]. Note: Go does embed some data by default, but an app I was working on introduced more metadata)<p>* Go build directives prevent IDEs&#x2F;linters from analyzing a file at all. E.g. if you edit a linux-only file on macOS, you get _zero_ help.<p>I dunno, there are a lot of other weird, confusing things that Go does. It is less than most other languages, though.<p>[0] <a href="https:&#x2F;&#x2F;go.dev&#x2F;wiki&#x2F;LoopvarExperiment" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;wiki&#x2F;LoopvarExperiment</a><p>[1] <a href="https:&#x2F;&#x2F;www.digitalocean.com&#x2F;community&#x2F;tutorials&#x2F;using-ldflags-to-set-version-information-for-go-applications" rel="nofollow">https:&#x2F;&#x2F;www.digitalocean.com&#x2F;community&#x2F;tutorials&#x2F;using-ldfla...</a></div><br/><div id="41232163" class="c"><input type="checkbox" id="c-41232163" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41231451">parent</a><span>|</span><a href="#41232564">next</a><span>|</span><label class="collapse" for="c-41232163">[-]</label><label class="expand" for="c-41232163">[1 more]</label></div><br/><div class="children"><div class="content">Needing to cast nil to a type was weird.  C&#x2F;C++&#x2F;Java&#x2F;Python don&#x27;t do that.<p>They also take on the weird Java-ish culture that everything is better if it&#x27;s written in Go.<p>They also had this weird take on the C++ vtable, so they eschewed anything class like to keep everything statically linked for speed.<p>It also took them a long time to figure out their loop variable syntax was broken.  So ... hrm.</div><br/></div></div><div id="41232564" class="c"><input type="checkbox" id="c-41232564" checked=""/><div class="controls bullet"><span class="by">funny_falcon</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41231451">parent</a><span>|</span><a href="#41232163">prev</a><span>|</span><a href="#41230906">next</a><span>|</span><label class="collapse" for="c-41232564">[-]</label><label class="expand" for="c-41232564">[2 more]</label></div><br/><div class="children"><div class="content">First three are clearly documented in language reference, which could be read in several hours (at least before generics were introduced).</div><br/><div id="41232880" class="c"><input type="checkbox" id="c-41232880" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41232564">parent</a><span>|</span><a href="#41230906">next</a><span>|</span><label class="collapse" for="c-41232880">[-]</label><label class="expand" for="c-41232880">[1 more]</label></div><br/><div class="children"><div class="content">I like to read language references (not just Go&#x27;s, for example I have also fully read the ECMAScript standard as a part of my research in the past) and yet I will never say I can remember <i>everything</i> from those references. &quot;Documented&quot; isn&#x27;t same as &quot;easy to remember or recall&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="41230906" class="c"><input type="checkbox" id="c-41230906" checked=""/><div class="controls bullet"><span class="by">kylecazar</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41230735">parent</a><span>|</span><a href="#41231238">prev</a><span>|</span><a href="#41232746">next</a><span>|</span><label class="collapse" for="c-41230906">[-]</label><label class="expand" for="c-41230906">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s known for being a small and simple language.</div><br/><div id="41232999" class="c"><input type="checkbox" id="c-41232999" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41230906">parent</a><span>|</span><a href="#41232746">next</a><span>|</span><label class="collapse" for="c-41232999">[-]</label><label class="expand" for="c-41232999">[1 more]</label></div><br/><div class="children"><div class="content">Just like Brainfuck.</div><br/></div></div></div></div></div></div></div></div><div id="41232746" class="c"><input type="checkbox" id="c-41232746" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41230087">prev</a><span>|</span><a href="#41231703">next</a><span>|</span><label class="collapse" for="c-41232746">[-]</label><label class="expand" for="c-41232746">[2 more]</label></div><br/><div class="children"><div class="content">ChatGPT accelerates this timeline significantly. As a senior programmer you can largely skip the &quot;junior&quot; phase of the learning, almost like pair programming with a very proficient junior programmer.</div><br/><div id="41233300" class="c"><input type="checkbox" id="c-41233300" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224825">root</a><span>|</span><a href="#41232746">parent</a><span>|</span><a href="#41231703">next</a><span>|</span><label class="collapse" for="c-41233300">[-]</label><label class="expand" for="c-41233300">[1 more]</label></div><br/><div class="children"><div class="content">I am fully convinced that programming language generation out of stuff like ChatGPT is an intermediate step on their evolution, just like early compiler adopters wouldn&#x27;t trust compilers that wouldn&#x27;t show the Assembly output.<p>Eventually we will achieve another milestone in what it means to program computers, where tools like ChatGPT will directly produce executables, or perform actions, and only when asked it will produce something akin to source code for cross-checking.</div><br/></div></div></div></div><div id="41231703" class="c"><input type="checkbox" id="c-41231703" checked=""/><div class="controls bullet"><span class="by">ramijames</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41232746">prev</a><span>|</span><a href="#41230601">next</a><span>|</span><label class="collapse" for="c-41231703">[-]</label><label class="expand" for="c-41231703">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it is that long. Think of learning any spoken language. We expect that it takes AT LEAST ten years to be able to master it, and typically it takes much longer to meaningfully add to the compendium of literature. Usually we are talking about decades. It isn&#x27;t just about the tool (speaking, writing) but being so fluent that you can successfully express yourself in a way that has impact.<p>If you can do it in ten years with a software stack, I&#x27;d say that&#x27;s pretty impressive.</div><br/></div></div><div id="41230601" class="c"><input type="checkbox" id="c-41230601" checked=""/><div class="controls bullet"><span class="by">georgeecollins</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41231703">prev</a><span>|</span><a href="#41228357">next</a><span>|</span><label class="collapse" for="c-41230601">[-]</label><label class="expand" for="c-41230601">[1 more]</label></div><br/><div class="children"><div class="content">I also think it is a good idea to learn a few very different languages when you are starting out so that you have a sense of the tradeoffs and the different ways things can be done.  When I was in college they taught C and Lisp (I am dating myself) which seemed very different to me at the time but also useful in different ways.  Close to the hardware, vs supporting objects, lambda functions, etc.  Later I learned a number of other languages and now I try hard to avoid switching languages because of the lost productivity.<p>Now if I were starting out I think I would try to focus on two different languages, but more modern ones.  Maybe Rust and Python?</div><br/></div></div><div id="41228357" class="c"><input type="checkbox" id="c-41228357" checked=""/><div class="controls bullet"><span class="by">oooyay</span><span>|</span><a href="#41224825">parent</a><span>|</span><a href="#41230601">prev</a><span>|</span><a href="#41233492">next</a><span>|</span><label class="collapse" for="c-41228357">[-]</label><label class="expand" for="c-41228357">[1 more]</label></div><br/><div class="children"><div class="content">By now I <i>know</i> three major languages: Go, Python, and Typescript. I know tradeoffs at-a-glance, I deeply understand the syntax and its various forms, the full array of tooling and what they do, and lastly (but maybe most importantly) I can estimate more accurately because I can architect in my head.<p>I <i>can work</i> in a myriad of other languages. I may be able to do some of the things above in Java or Rust but not nearly to the degree to which I can in languages I <i>know</i>. I think the difference is I&#x27;m probably not going to be <i>leading</i> a Java project or producing anything really innovative at a code level.<p>To me, more important than picking <i>a hammer</i>, is knowing a variety of hammers that are good at certain tasks. I don&#x27;t focus on Rust or Java as much because, frankly, I can build most things that are pertinent to the constraints of my work environment with those tools and most people I encounter also know them. The other considerable factor I have is that most things I work on can be horizontally scaled so my need for Rust is very niche. With respect to Java, I have a lot of workarounds that are cleanly abstracted enough before I need its dynamism and subsequent mental overhead.</div><br/></div></div></div></div><div id="41233492" class="c"><input type="checkbox" id="c-41233492" checked=""/><div class="controls bullet"><span class="by">afiodorov</span><span>|</span><a href="#41224825">prev</a><span>|</span><a href="#41224464">next</a><span>|</span><label class="collapse" for="c-41233492">[-]</label><label class="expand" for="c-41233492">[1 more]</label></div><br/><div class="children"><div class="content">I used to work for a Go shop. We dealt with financial data. I found it so annoying that many of my colleagues would use Go for one-off tasks such as aggregating CSV files, updating the database with some data, or fetching data from the database, and then trying to make a plot. I saw my colleagues again and again implementing basic algorithms such as rolling median, or finding a maximum. Instead of loading data into Pandas and doing a group by, they would create some kind of loopy solution that would use maps.<p>I totally understand why some people prefer Go in production to Python, but I could never understand why people wouldn&#x27;t just learn the standard data science tools instead of reinventing the wheel in Go, always debugging their own off-by-one errors. It was difficult for me to trust the results of such analyses, given that I knew how many of the basic functions were written on the fly and probably not even tested.<p>In the end, I didn&#x27;t think it was a good use of the company&#x27;s time. It felt more like an ego thing - thinking and showing that Go is sufficient. It reminds me of how people try to use iPads to code - only to show that they can do it.</div><br/></div></div><div id="41224464" class="c"><input type="checkbox" id="c-41224464" checked=""/><div class="controls bullet"><span class="by">daghamm</span><span>|</span><a href="#41233492">prev</a><span>|</span><a href="#41224877">next</a><span>|</span><label class="collapse" for="c-41224464">[-]</label><label class="expand" for="c-41224464">[111 more]</label></div><br/><div class="children"><div class="content">The author lists multiple reasons for this, but for me the biggest one is the first one: Go is good for almost <i>everything</i>.<p>I have extremely good productivity when using Go. Once your project exceeds 100 lines it is usually even better than python. And yes, I am aware that Rustians did a survey where Rust was crowned as the most efficient language but in my reality (which may differ from yours) Go is simply the best tool for most tasks.<p>Why is that? Well, for me there are 3 reasosns:<p>1. The language is extremely simple. If you know 20% of C you are already a Go expert.<p>2. The core libraries are extremly well thought.<p>3. Batteries are included. The toolchain and the core libraries alone can do 90% of what most people will ever need.<p>When people argue about the validity of these claims, I simply point them to this talk <a href="https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;concurrency.slide#42" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;concurrency.slide#42</a></div><br/><div id="41225126" class="c"><input type="checkbox" id="c-41225126" checked=""/><div class="controls bullet"><span class="by">conor-</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41233279">next</a><span>|</span><label class="collapse" for="c-41225126">[-]</label><label class="expand" for="c-41225126">[72 more]</label></div><br/><div class="children"><div class="content">Go is the only language I&#x27;ve ever felt highly productive working in. Oftentimes in other stacks I find myself in analysis paralysis on meta things that don&#x27;t matter:<p>- what design patterns&#x2F;language features make sense to use<p>- what is the best lib to accomplish X<p>- how do you keep things up to date<p>With Go, the language is so simple that it&#x27;s pretty difficult to over engineer or write terse code. Everything you need is in stdlib. The tooling makes dependency management and upgrades trivial because of strong backwards compatibility.</div><br/><div id="41229922" class="c"><input type="checkbox" id="c-41229922" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225126">parent</a><span>|</span><a href="#41226282">next</a><span>|</span><label class="collapse" for="c-41229922">[-]</label><label class="expand" for="c-41229922">[11 more]</label></div><br/><div class="children"><div class="content">Sure, if everything one does is either CLI stuff, or UNIX daemons, containers, ....<p>Because in the reign of graphics , GUI, GPGPU, HPC, HFT, ML, game engines,numeric analysis, ... there is hardly any library that really stands out.</div><br/><div id="41229953" class="c"><input type="checkbox" id="c-41229953" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229922">parent</a><span>|</span><a href="#41226282">next</a><span>|</span><label class="collapse" for="c-41229953">[-]</label><label class="expand" for="c-41229953">[10 more]</label></div><br/><div class="children"><div class="content">Or servers, and about anything that really benefits from concurrency.<p>Even a lot of games could be made with go. The gc wouldn’t really kill the frame rate of a game unless you really push it.</div><br/><div id="41232457" class="c"><input type="checkbox" id="c-41232457" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229953">parent</a><span>|</span><a href="#41230941">next</a><span>|</span><label class="collapse" for="c-41232457">[-]</label><label class="expand" for="c-41232457">[3 more]</label></div><br/><div class="children"><div class="content">That is what <i>&quot;UNIX daemons, containers means&quot;</i> on my comment.<p>Gamedev in Go only for those that rather spend their time doing engines from scratch.<p>Additionally Go&#x27;s lack of support for dynamic linking is a no Go (pun intended) for big A game studios.</div><br/><div id="41232562" class="c"><input type="checkbox" id="c-41232562" checked=""/><div class="controls bullet"><span class="by">l33t7332273</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232457">parent</a><span>|</span><a href="#41230941">next</a><span>|</span><label class="collapse" for="c-41232562">[-]</label><label class="expand" for="c-41232562">[2 more]</label></div><br/><div class="children"><div class="content">My Go is a little rusty by now, but I thought they supported some type of dynamic linking(although if I recall correctly it comes with a number of free footguns)</div><br/><div id="41232714" class="c"><input type="checkbox" id="c-41232714" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232562">parent</a><span>|</span><a href="#41230941">next</a><span>|</span><label class="collapse" for="c-41232714">[-]</label><label class="expand" for="c-41232714">[1 more]</label></div><br/><div class="children"><div class="content">It does a very crude one, where one is bound to expose C ABI types, all shared objects have to be linked with the same runtime, and there are still issues making this rather basic support work on Windows, land of game developers.</div><br/></div></div></div></div></div></div><div id="41230941" class="c"><input type="checkbox" id="c-41230941" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229953">parent</a><span>|</span><a href="#41232457">prev</a><span>|</span><a href="#41232102">next</a><span>|</span><label class="collapse" for="c-41230941">[-]</label><label class="expand" for="c-41230941">[4 more]</label></div><br/><div class="children"><div class="content">Gamedev in Go will require cgo (and not just the easy parts), which ups the complexity quite a bit, unless you&#x27;re already very familiar with C.<p>I think it&#x27;s pretty viable nonetheless, but more for the experienced developer with specific goals outside of the nice parts of common engines, or for a hobbyist who knows the language and wants to tinker and learn.</div><br/><div id="41231439" class="c"><input type="checkbox" id="c-41231439" checked=""/><div class="controls bullet"><span class="by">tslocum</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230941">parent</a><span>|</span><a href="#41232102">next</a><span>|</span><label class="collapse" for="c-41231439">[-]</label><label class="expand" for="c-41231439">[3 more]</label></div><br/><div class="children"><div class="content">Sorry, this comment is so incorrect that I have to ask, what are you basing it on?<p>You can create games today using Go without cgo, and there are numerous examples of shipped games of varying complexity and quality. I do this to ship the bgammon.org client to Windows, Linux and WebAssembly users, all compiled using a Linux system without any cgo.<p><a href="https:&#x2F;&#x2F;ebitengine.org" rel="nofollow">https:&#x2F;&#x2F;ebitengine.org</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;sedyh&#x2F;awesome-ebitengine#games">https:&#x2F;&#x2F;github.com&#x2F;sedyh&#x2F;awesome-ebitengine#games</a></div><br/><div id="41231903" class="c"><input type="checkbox" id="c-41231903" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231439">parent</a><span>|</span><a href="#41232952">next</a><span>|</span><label class="collapse" for="c-41231903">[-]</label><label class="expand" for="c-41231903">[1 more]</label></div><br/><div class="children"><div class="content">It was based on my own experience (with e.g. sdl2) and, clearly, some ignorance.<p>I didn&#x27;t mean to imply that cgo was an insurmountable barrier. But apparently it was a big enough deal for the authors of this engine that they copied over large parts of major API surface to Go to avoid it. Impressive.<p>However, AFAICT avoiding cgo means using unsafe tricks and trusting that struct layout will stay compatible. Nevertheless, it&#x27;s a proven solution and as you say used by many already.</div><br/></div></div><div id="41232952" class="c"><input type="checkbox" id="c-41232952" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231439">parent</a><span>|</span><a href="#41231903">prev</a><span>|</span><a href="#41232102">next</a><span>|</span><label class="collapse" for="c-41232952">[-]</label><label class="expand" for="c-41232952">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;ebitengine.org&#x2F;en&#x2F;documents&#x2F;install.html" rel="nofollow">https:&#x2F;&#x2F;ebitengine.org&#x2F;en&#x2F;documents&#x2F;install.html</a><p>For anything other than windows:<p>&gt; Installing a C compiler<p>&gt; A C compiler is required as Ebitengine uses not only Go but also C.<p>I mean, even on platforms without cgo, it&#x27;s it working magically?<p>No; it&#x27;s using <a href="https:&#x2F;&#x2F;github.com&#x2F;ebitengine&#x2F;purego">https:&#x2F;&#x2F;github.com&#x2F;ebitengine&#x2F;purego</a>, which is:<p>&gt; A library for calling C functions from Go without Cgo.<p>Like... I mean.... okaaaay, it&#x27;s not cgo, but it&#x27;s basically cgo? ...but it&#x27;s not cgo so you can say &#x27;no cgo&#x27; on your banner page?<p>If you&#x27;re calling c functions, it&#x27;s not pure go.<p>If calls some C library, and it doesn&#x27;t work on any other platform, its like &#x27;pure go, single platform&#x27;.<p>hmm.<p>Seems kind of like... this is maybe not the right hammer for gamedev; or, perhaps, maybe not quite mature yet...<p>Certainly for someone in the &#x27;solo dev pick your tools carefully&#x27; team, like the OP, I don&#x27;t think this would be a good pick for people; even if they were deeply familiar with go.</div><br/></div></div></div></div></div></div><div id="41232102" class="c"><input type="checkbox" id="c-41232102" checked=""/><div class="controls bullet"><span class="by">tacticus</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229953">parent</a><span>|</span><a href="#41230941">prev</a><span>|</span><a href="#41226282">next</a><span>|</span><label class="collapse" for="c-41232102">[-]</label><label class="expand" for="c-41232102">[2 more]</label></div><br/><div class="children"><div class="content">both unity and unreal have GC these days.</div><br/><div id="41232476" class="c"><input type="checkbox" id="c-41232476" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232102">parent</a><span>|</span><a href="#41226282">next</a><span>|</span><label class="collapse" for="c-41232476">[-]</label><label class="expand" for="c-41232476">[1 more]</label></div><br/><div class="children"><div class="content">And dynamic linking, plugins....<p>Which Go doesn&#x27;t do really well, and there is no interest in improving.</div><br/></div></div></div></div></div></div></div></div><div id="41226282" class="c"><input type="checkbox" id="c-41226282" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225126">parent</a><span>|</span><a href="#41229922">prev</a><span>|</span><a href="#41225719">next</a><span>|</span><label class="collapse" for="c-41226282">[-]</label><label class="expand" for="c-41226282">[19 more]</label></div><br/><div class="children"><div class="content"><i>&gt; it&#x27;s pretty difficult to over engineer</i><p>I don&#x27;t know about that. Every programmer&#x27;s first Go program seems to like to go to channel city. Perhaps more accurately: Over-engineering your Go program is going to quickly lead to pain. It doesn&#x27;t have the escape hatches that help you paper over bad design decisions like some other languages do.</div><br/><div id="41229852" class="c"><input type="checkbox" id="c-41229852" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41226282">parent</a><span>|</span><a href="#41229198">next</a><span>|</span><label class="collapse" for="c-41229852">[-]</label><label class="expand" for="c-41229852">[17 more]</label></div><br/><div class="children"><div class="content">Also: interfaceiritus. Someone saw &quot;accept interfaces, return structs&quot; somewhere and now EVERYTHING accepts an interface, whether or makes sense or not. Many (sometimes even all) of these interfaces have just one implementation.</div><br/><div id="41230014" class="c"><input type="checkbox" id="c-41230014" checked=""/><div class="controls bullet"><span class="by">hellcow</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229852">parent</a><span>|</span><a href="#41230151">next</a><span>|</span><label class="collapse" for="c-41230014">[-]</label><label class="expand" for="c-41230014">[14 more]</label></div><br/><div class="children"><div class="content">Doing this allows you to mock out that implementation in unit tests.</div><br/><div id="41231329" class="c"><input type="checkbox" id="c-41231329" checked=""/><div class="controls bullet"><span class="by">tengbretson</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230014">parent</a><span>|</span><a href="#41231180">next</a><span>|</span><label class="collapse" for="c-41231329">[-]</label><label class="expand" for="c-41231329">[6 more]</label></div><br/><div class="children"><div class="content">A lot of times you want to be able to cmd+click on something and actually see what the hell the code actually does and not get dead-ended at an interface declaration.</div><br/><div id="41232404" class="c"><input type="checkbox" id="c-41232404" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231329">parent</a><span>|</span><a href="#41232118">next</a><span>|</span><label class="collapse" for="c-41232404">[-]</label><label class="expand" for="c-41232404">[4 more]</label></div><br/><div class="children"><div class="content">Sounds like a UI bug more than anything.<p>The compiler certainly knows how to determine if there is only one implementation of an interface and remove the interface indirection when so. There is nothing really stopping the cmd+click tooling from doing the same.</div><br/><div id="41232570" class="c"><input type="checkbox" id="c-41232570" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232404">parent</a><span>|</span><a href="#41232118">next</a><span>|</span><label class="collapse" for="c-41232570">[-]</label><label class="expand" for="c-41232570">[3 more]</label></div><br/><div class="children"><div class="content">Does the compiler do that? That sounds extremely unlikely, especially because an interface with only one implementation can store the nil type tag or a tagged pointer to an instance of that implementation.</div><br/><div id="41232687" class="c"><input type="checkbox" id="c-41232687" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232570">parent</a><span>|</span><a href="#41232118">next</a><span>|</span><label class="collapse" for="c-41232687">[-]</label><label class="expand" for="c-41232687">[2 more]</label></div><br/><div class="children"><div class="content">The nil interface is another implementation. I mean, unless it is being used as the sole implementation, but I think we can assume that isn&#x27;t the implementation being talked about given that it isn&#x27;t a practical implementation. We&#x27;re talking about where there is one implementation.</div><br/><div id="41232860" class="c"><input type="checkbox" id="c-41232860" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232687">parent</a><span>|</span><a href="#41232118">next</a><span>|</span><label class="collapse" for="c-41232860">[-]</label><label class="expand" for="c-41232860">[1 more]</label></div><br/><div class="children"><div class="content">Right. Can you cite anything that says that the go compiler does this sort of whole-program analysis to try to prove that a certain argument to a function is always non-nil, so that it can change the signature of that function and the types of variables declared in other functions?</div><br/></div></div></div></div></div></div></div></div><div id="41232118" class="c"><input type="checkbox" id="c-41232118" checked=""/><div class="controls bullet"><span class="by">zinodaur</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231329">parent</a><span>|</span><a href="#41232404">prev</a><span>|</span><a href="#41231180">next</a><span>|</span><label class="collapse" for="c-41232118">[-]</label><label class="expand" for="c-41232118">[1 more]</label></div><br/><div class="children"><div class="content">yeah gotta use an IDE for that</div><br/></div></div></div></div><div id="41231180" class="c"><input type="checkbox" id="c-41231180" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230014">parent</a><span>|</span><a href="#41231329">prev</a><span>|</span><a href="#41230613">next</a><span>|</span><label class="collapse" for="c-41231180">[-]</label><label class="expand" for="c-41231180">[1 more]</label></div><br/><div class="children"><div class="content">I agree with your point.  OP wrote:<p><pre><code>    &gt; Many (sometimes even all) of these interfaces have just one implementation.
</code></pre>
They are missing that mocks are the second implementation.  (It took me years to see this point.)  I would say that in most of my code at work, 95+% of my interfaces only have a single implementation for the production code, but any&#x2F;all of them can have a second implementation when mocking for unit tests.</div><br/></div></div><div id="41230613" class="c"><input type="checkbox" id="c-41230613" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230014">parent</a><span>|</span><a href="#41231180">prev</a><span>|</span><a href="#41230151">next</a><span>|</span><label class="collapse" for="c-41230613">[-]</label><label class="expand" for="c-41230613">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Many (sometimes even all) of these interfaces have just one implementation.</div><br/><div id="41230966" class="c"><input type="checkbox" id="c-41230966" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230613">parent</a><span>|</span><a href="#41230151">next</a><span>|</span><label class="collapse" for="c-41230966">[-]</label><label class="expand" for="c-41230966">[5 more]</label></div><br/><div class="children"><div class="content">The point of using a mockable interface, even if there&#x27;s only one real implementation, is to test the behavior of the caller in isolation without also testing the behavior of the callee.<p>This can be overdone of course, not everything needs this level of separation, but if it makes testing one or both sides easier, then it&#x27;s usually worth it. It&#x27;s especially useful for testing nontrivial interactions with other people&#x27;s code, such as libraries for services that connect to real infrastructure.</div><br/><div id="41231169" class="c"><input type="checkbox" id="c-41231169" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230966">parent</a><span>|</span><a href="#41230151">next</a><span>|</span><label class="collapse" for="c-41231169">[-]</label><label class="expand" for="c-41231169">[4 more]</label></div><br/><div class="children"><div class="content">Did you miss &quot;just one implementation&quot;? A mock is literally defined by being <i>another</i> implementation. If the &#x27;mock&#x27; is your sole implementation, we don&#x27;t call it a mock, that&#x27;s just a plain old regular implementation.</div><br/><div id="41231974" class="c"><input type="checkbox" id="c-41231974" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231169">parent</a><span>|</span><a href="#41231950">prev</a><span>|</span><a href="#41230151">next</a><span>|</span><label class="collapse" for="c-41231974">[-]</label><label class="expand" for="c-41231974">[2 more]</label></div><br/><div class="children"><div class="content">I think my comment was clear on the distinction between real and mock implementations. If the code was testable with no need for mocks then certainly remove the interface and devirtualize the method calls.</div><br/><div id="41232159" class="c"><input type="checkbox" id="c-41232159" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231974">parent</a><span>|</span><a href="#41230151">next</a><span>|</span><label class="collapse" for="c-41232159">[-]</label><label class="expand" for="c-41232159">[1 more]</label></div><br/><div class="children"><div class="content">Your comment was clear about mocks, but not why mocks are relevant to the topic at hand. The original comment was equally clear that it was in reference to where there is only one implementation. In fact, just to make sure you didn&#x27;t overlook that bit amid the other words, the author extracted that segment out into a secondary comment about that and that alone.<p>Mocks, by definition, are always a supplemental implementation – in other words, where there is two or more implementations. What you failed to make clear is why you would bring up mocks at all. Where is the relevance in a discussion about single implementations the other commenter has observed? I wondered if you had missed (twice!) the &quot;one implementation&quot; part, but it seems you deny that, making this ordeal even stranger.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41230151" class="c"><input type="checkbox" id="c-41230151" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229852">parent</a><span>|</span><a href="#41230014">prev</a><span>|</span><a href="#41229198">next</a><span>|</span><label class="collapse" for="c-41230151">[-]</label><label class="expand" for="c-41230151">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t Go compiler statically prove that such single implementation interfaces are indeed that and devirtualize the callsites referring to them?<p>Either way, the problem seems to happen in most languages of today, if they (or their community) ever happen to accidentally encourage passing an opaque type abstraction over a concrete one.</div><br/></div></div></div></div><div id="41229198" class="c"><input type="checkbox" id="c-41229198" checked=""/><div class="controls bullet"><span class="by">nasretdinov</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41226282">parent</a><span>|</span><a href="#41229852">prev</a><span>|</span><a href="#41225719">next</a><span>|</span><label class="collapse" for="c-41229198">[-]</label><label class="expand" for="c-41229198">[1 more]</label></div><br/><div class="children"><div class="content">Yeah too much concurrency and too many channels definitely hit home hard...</div><br/></div></div></div></div><div id="41225719" class="c"><input type="checkbox" id="c-41225719" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225126">parent</a><span>|</span><a href="#41226282">prev</a><span>|</span><a href="#41230830">next</a><span>|</span><label class="collapse" for="c-41225719">[-]</label><label class="expand" for="c-41225719">[37 more]</label></div><br/><div class="children"><div class="content">I do programming interviews and I found candidates struggling a lot in doing http request and parsing response json in Go while in Python its a breeze, what makes it particularly hard, is it lack of generics or dict data type?</div><br/><div id="41230259" class="c"><input type="checkbox" id="c-41230259" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225719">parent</a><span>|</span><a href="#41225861">next</a><span>|</span><label class="collapse" for="c-41230259">[-]</label><label class="expand" for="c-41230259">[4 more]</label></div><br/><div class="children"><div class="content">It comes down to how the standard library makes you do things. I don&#x27;t think there&#x27;s any reason why a more stringly-typed way of handling JSON (or, indeed, a more high-level way of using HTTP) is outside of the realm of possibility for Go. It&#x27;s just that the standard library authors saw fit not to pursue that avenue.<p>This variability is honestly one of the reasons why I dislike interviews that require me to synthesize solutions to toy problems in a very tightly constrained window of time, particularly if the recruiter makes me commit at the outset to one language over another as part of the overall interview process. It&#x27;s frustrating for me, and, having been on the other side, it&#x27;s noisy for the interviewer.<p>(In fact, my favorite interview loop of all time required that I use gdb to dig into a diabolical system that was crashing, along with some serious code spelunking. The rationale was that, if I&#x27;m good with a debugger and adept at reading the source that&#x27;s in front of me, the final third of synthesizing code solutions to problems and conforming to institutional practice can be dealt with once I&#x27;m in the door.)</div><br/><div id="41231444" class="c"><input type="checkbox" id="c-41231444" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230259">parent</a><span>|</span><a href="#41231196">next</a><span>|</span><label class="collapse" for="c-41231444">[-]</label><label class="expand" for="c-41231444">[1 more]</label></div><br/><div class="children"><div class="content">My favourite tech interview (so far) was similar: &quot;here&#x27;s the FOSS code base we&#x27;re working on. This issue looks like about the size we can tackle in the time we have. Let&#x27;s work on this together and solve it&quot;.<p>I got to show how I could grok a code base and work out where the problem was quickly, and work out a solution to the problem, and how I understood how to contribute a PR. Way better than random Leetcode bullshit, and actually useful: the issue was actually solved and the PR accepted.</div><br/></div></div><div id="41231196" class="c"><input type="checkbox" id="c-41231196" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230259">parent</a><span>|</span><a href="#41231444">prev</a><span>|</span><a href="#41225861">next</a><span>|</span><label class="collapse" for="c-41231196">[-]</label><label class="expand" for="c-41231196">[2 more]</label></div><br/><div class="children"><div class="content">I like your story about debugging during an interview.  I can say from experience, you always have one teammate that can just debug any problem.  I am always impressed to watch and learn new techniques from them.</div><br/><div id="41231378" class="c"><input type="checkbox" id="c-41231378" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231196">parent</a><span>|</span><a href="#41225861">next</a><span>|</span><label class="collapse" for="c-41231378">[-]</label><label class="expand" for="c-41231378">[1 more]</label></div><br/><div class="children"><div class="content">This has also been my experience, yeah. My interviewers were <i>very</i> interested in watching me rifle through that core dump. (:<p>Ultimately, it feels to me like selecting for people who both can navigate existing code and interrogate a running system (or, minimally, one that had gone off the rails and left clues as to why) is the right way to go. It has interesting knock-on effects throughout the organization (in, like, say, product support and quality assurance) that are direly understated.</div><br/></div></div></div></div></div></div><div id="41225861" class="c"><input type="checkbox" id="c-41225861" checked=""/><div class="controls bullet"><span class="by">conor-</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225719">parent</a><span>|</span><a href="#41230259">prev</a><span>|</span><a href="#41228834">next</a><span>|</span><label class="collapse" for="c-41225861">[-]</label><label class="expand" for="c-41225861">[1 more]</label></div><br/><div class="children"><div class="content">I think it depends on what kind of data you&#x27;re dealing with. If you know the shape of your data, it&#x27;s pretty trivial to create a struct with json tags and serialize&#x2F;deserialize into that struct. But if you&#x27;re dealing with data of an unknown shape it can be tricky to work with that. In Python because of dynamic typing and dicts it&#x27;s a little easier to deserialize arbitrary data.<p>Go&#x27;s net&#x2F;http is also slightly lower level. You have to concern yourself directly with some of the plumbing and complexity of making an http request and how to handle failures that can occur. Whereas in Python you can use the requests lib and fire off a request and a lot of that extra plumbing just happens for free and you don&#x27;t have to deal with any of the extra complexity if you don&#x27;t want to.<p>I find Go to be bad for interviewing in a lot of cases because you get bogged down with minutiae instead of working directly towards solving the exact problem presented in the interview. But that minutiae is also what makes Go nice to work with on real projects because you&#x27;re often forced into writing safer code</div><br/></div></div><div id="41228834" class="c"><input type="checkbox" id="c-41228834" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225719">parent</a><span>|</span><a href="#41225861">prev</a><span>|</span><a href="#41229888">next</a><span>|</span><label class="collapse" for="c-41228834">[-]</label><label class="expand" for="c-41228834">[8 more]</label></div><br/><div class="children"><div class="content">I think other languages cause folks to understand JSON responses as a big bag of keys and values, which have many convenient ways of being represented in those languages. When you get to Go and you want to parse a JSON response, it has to be a well-defined thing that you understand ahead of time, but I also think you adapt when doing this more than once in Go.</div><br/><div id="41229250" class="c"><input type="checkbox" id="c-41229250" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41228834">parent</a><span>|</span><a href="#41229379">next</a><span>|</span><label class="collapse" for="c-41229250">[-]</label><label class="expand" for="c-41229250">[3 more]</label></div><br/><div class="children"><div class="content">If I had one complaint, it’s the use of ‘tags’ to configure how json is handled on a struct, such that it basically becomes part of the struct’s type. It can lead to a fair bit of duplication of structs whose only difference is the json handling, or otherwise a lot of boilerplate code with custom marshal&#x2F;unmarshal methods. In some cases the advice is even to do parse the json into a map, do the conversion, and then serialise it again!<p>The case I ran into is where one API returned camelCase json but we wanted snake_case instead. Had to basically create another struct type with different json tags, rather than having something like decoders and encoders that can configure the output.<p>I like Go and a lot of the decisions it makes, but it has its fair share of pain points because of early decisions made in its design that results in repetitive and overly imperative code, and while that does help create code that is clear and comprehensible (mostly), it can distract attention away from the intended behaviour of the code.</div><br/><div id="41229474" class="c"><input type="checkbox" id="c-41229474" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229250">parent</a><span>|</span><a href="#41229349">next</a><span>|</span><label class="collapse" for="c-41229474">[-]</label><label class="expand" for="c-41229474">[1 more]</label></div><br/><div class="children"><div class="content">As an aside, you may be interested in some of the ongoing work to improve the Go JSON serializer&#x2F;deserializer:<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;go-json-experiment&#x2F;json" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;go-json-experiment&#x2F;json</a></div><br/></div></div><div id="41229349" class="c"><input type="checkbox" id="c-41229349" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229250">parent</a><span>|</span><a href="#41229474">prev</a><span>|</span><a href="#41229379">next</a><span>|</span><label class="collapse" for="c-41229349">[-]</label><label class="expand" for="c-41229349">[1 more]</label></div><br/><div class="children"><div class="content">You could wrap it in another struct and use a custom MarshalJSON implementation.</div><br/></div></div></div></div><div id="41229379" class="c"><input type="checkbox" id="c-41229379" checked=""/><div class="controls bullet"><span class="by">kloop</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41228834">parent</a><span>|</span><a href="#41229250">prev</a><span>|</span><a href="#41229888">next</a><span>|</span><label class="collapse" for="c-41229379">[-]</label><label class="expand" for="c-41229379">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    var res map[string]any
    err := json.Unmarshal(&amp;res)</code></pre></div><br/><div id="41231410" class="c"><input type="checkbox" id="c-41231410" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229379">parent</a><span>|</span><a href="#41229888">next</a><span>|</span><label class="collapse" for="c-41231410">[-]</label><label class="expand" for="c-41231410">[3 more]</label></div><br/><div class="children"><div class="content">Uh huh....and what comes next?<p>Trying to descend more than a couple of layers into a GoLang JSON object is a mess of casts.</div><br/><div id="41233330" class="c"><input type="checkbox" id="c-41233330" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231410">parent</a><span>|</span><a href="#41232950">next</a><span>|</span><label class="collapse" for="c-41233330">[-]</label><label class="expand" for="c-41233330">[1 more]</label></div><br/><div class="children"><div class="content">Well, one used to have <a href="https:&#x2F;&#x2F;github.com&#x2F;mitchellh&#x2F;mapstructure">https:&#x2F;&#x2F;github.com&#x2F;mitchellh&#x2F;mapstructure</a> which assisted here, but the lib then got abandoned.</div><br/></div></div><div id="41232950" class="c"><input type="checkbox" id="c-41232950" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231410">parent</a><span>|</span><a href="#41233330">prev</a><span>|</span><a href="#41229888">next</a><span>|</span><label class="collapse" for="c-41232950">[-]</label><label class="expand" for="c-41232950">[1 more]</label></div><br/><div class="children"><div class="content">Especially when you&#x27;re not certain of the type used for numbers.</div><br/></div></div></div></div></div></div></div></div><div id="41229888" class="c"><input type="checkbox" id="c-41229888" checked=""/><div class="controls bullet"><span class="by">randmeerkat</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225719">parent</a><span>|</span><a href="#41228834">prev</a><span>|</span><a href="#41232941">next</a><span>|</span><label class="collapse" for="c-41229888">[-]</label><label class="expand" for="c-41229888">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I do programming interviews and I found candidates struggling a lot in doing http request and parsing response json in Go while in Python its a breeze, what makes it particularly hard, is it lack of generics or dict data type?<p>Have you considered that your interview process is actually the problem? Focus on the candidate’s projects, or their past work experience, rather than forcing them to jump through arbitrary leet code challenges.</div><br/><div id="41230270" class="c"><input type="checkbox" id="c-41230270" checked=""/><div class="controls bullet"><span class="by">travisd</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229888">parent</a><span>|</span><a href="#41232941">next</a><span>|</span><label class="collapse" for="c-41230270">[-]</label><label class="expand" for="c-41230270">[2 more]</label></div><br/><div class="children"><div class="content">Making an HTTP request and dealing with JSON data is a weed-out question at best. Not sure if you are interpreting the grandparent comment as actually having them write a JSON parser, but I don&#x27;t think that&#x27;s what they meant.</div><br/><div id="41230429" class="c"><input type="checkbox" id="c-41230429" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230270">parent</a><span>|</span><a href="#41232941">next</a><span>|</span><label class="collapse" for="c-41230429">[-]</label><label class="expand" for="c-41230429">[1 more]</label></div><br/><div class="children"><div class="content">I either had that come up in an interview recently myself, OR it wasn&#x27;t clear to me that I was allowed to use encodings&#x2F;json to parse the json and then deal with that.  I happened to bomb that part of the interview spectacularly because I haven&#x27;t written a complex structure parser in years given every language I&#x27;ve used for such tasks ships with proper and optimized libraries to do that.</div><br/></div></div></div></div></div></div><div id="41232941" class="c"><input type="checkbox" id="c-41232941" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225719">parent</a><span>|</span><a href="#41229888">prev</a><span>|</span><a href="#41228540">next</a><span>|</span><label class="collapse" for="c-41232941">[-]</label><label class="expand" for="c-41232941">[2 more]</label></div><br/><div class="children"><div class="content">There is a dict-equivalent data type in Go for JSON (it&#x27;s `map[string]any`), it&#x27;s just rather counter-intuitive.<p>However, as a Go developer, I&#x27;m one of the people who consider that JSON support in Go should be burnt down and rebuilt from scratch. It&#x27;s both limited, annoying, full of nasty surprises, hard to debug and slow.</div><br/><div id="41233201" class="c"><input type="checkbox" id="c-41233201" checked=""/><div class="controls bullet"><span class="by">pjbster</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232941">parent</a><span>|</span><a href="#41228540">next</a><span>|</span><label class="collapse" for="c-41233201">[-]</label><label class="expand" for="c-41233201">[1 more]</label></div><br/><div class="children"><div class="content">There was a detailed proposal to introduce encoding&#x2F;json&#x2F;v2 last year but I don&#x27;t know how far it&#x27;s progressed since then (which you probably already know about but mentioning it here for others):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;63397">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;63397</a></div><br/></div></div></div></div><div id="41229203" class="c"><input type="checkbox" id="c-41229203" checked=""/><div class="controls bullet"><span class="by">jay_kyburz</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225719">parent</a><span>|</span><a href="#41228540">prev</a><span>|</span><a href="#41230830">next</a><span>|</span><label class="collapse" for="c-41229203">[-]</label><label class="expand" for="c-41229203">[17 more]</label></div><br/><div class="children"><div class="content">Hold on, did you just say Go doesn&#x27;t have a Dictionary data type?<p>I&#x27;m a Javascript, Lua, Python, and C# guy and Dict is my whole world.</div><br/><div id="41229267" class="c"><input type="checkbox" id="c-41229267" checked=""/><div class="controls bullet"><span class="by">AmpsterMan</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229203">parent</a><span>|</span><a href="#41232212">next</a><span>|</span><label class="collapse" for="c-41229267">[-]</label><label class="expand" for="c-41229267">[1 more]</label></div><br/><div class="children"><div class="content">It does. <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;maps" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;maps</a><p>What the poster was alluding to is that you usually prefer to deseialize to a struct rather than a record&#x2F;dict&#x2F;map</div><br/></div></div><div id="41232212" class="c"><input type="checkbox" id="c-41232212" checked=""/><div class="controls bullet"><span class="by">mseepgood</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229203">parent</a><span>|</span><a href="#41229267">prev</a><span>|</span><a href="#41229314">next</a><span>|</span><label class="collapse" for="c-41232212">[-]</label><label class="expand" for="c-41232212">[1 more]</label></div><br/><div class="children"><div class="content">It does (it&#x27;s called a map) and Go does have generics, the previous poster clearly doesn&#x27;t know what they&#x27;re talking about.</div><br/></div></div><div id="41229314" class="c"><input type="checkbox" id="c-41229314" checked=""/><div class="controls bullet"><span class="by">zhengyi13</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229203">parent</a><span>|</span><a href="#41232212">prev</a><span>|</span><a href="#41229338">next</a><span>|</span><label class="collapse" for="c-41229314">[-]</label><label class="expand" for="c-41229314">[6 more]</label></div><br/><div class="children"><div class="content">Not a programmer, so this is every programmer&#x27;s chance to hammer me on correctness.<p>No, Go doesn&#x27;t have a type named Dict, or Hash (my Perl is leaking), or whatever.<p>It <i>does</i> have a map type[1], where you can define your keys as one type, and your values of another type, and that pretty closely approximates Dicts in other languages, I think.<p>[1]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;maps" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;maps</a></div><br/><div id="41230630" class="c"><input type="checkbox" id="c-41230630" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229314">parent</a><span>|</span><a href="#41230464">next</a><span>|</span><label class="collapse" for="c-41230630">[-]</label><label class="expand" for="c-41230630">[1 more]</label></div><br/><div class="children"><div class="content">So, these types (and many more) are hash tables.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hash_table" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hash_table</a><p>They&#x27;re a very common and useful idea from Computer Science so you will find them in pretty much any modern language, there are a <i>lot</i> of variations on this idea, but the core idea recurs everywhere.</div><br/></div></div><div id="41230464" class="c"><input type="checkbox" id="c-41230464" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229314">parent</a><span>|</span><a href="#41230630">prev</a><span>|</span><a href="#41229495">next</a><span>|</span><label class="collapse" for="c-41230464">[-]</label><label class="expand" for="c-41230464">[1 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;d want to try to decode into map[string]interface{} (offhand), since string keys can be coerced to that in any event (they&#x27;re strings in the stream, quoted or otherwise), and a key can hold any valid json scalar, array, or object (another json sub-string).</div><br/></div></div><div id="41229495" class="c"><input type="checkbox" id="c-41229495" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229314">parent</a><span>|</span><a href="#41230464">prev</a><span>|</span><a href="#41229338">next</a><span>|</span><label class="collapse" for="c-41229495">[-]</label><label class="expand" for="c-41229495">[3 more]</label></div><br/><div class="children"><div class="content">And, if you hate strong typing, there&#x27;s always map[string]any.</div><br/><div id="41230092" class="c"><input type="checkbox" id="c-41230092" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229495">parent</a><span>|</span><a href="#41229338">next</a><span>|</span><label class="collapse" for="c-41230092">[-]</label><label class="expand" for="c-41230092">[2 more]</label></div><br/><div class="children"><div class="content">Really, the mismatch is at the JSON side; arbitrary JSON is the opposite of strongly typed. How a language lets you handle the (easily fallible) process of &quot;JSON -&gt; arbitrarily typed -&gt; the actual type you wanted&quot; is what matters.</div><br/><div id="41231223" class="c"><input type="checkbox" id="c-41231223" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230092">parent</a><span>|</span><a href="#41229338">next</a><span>|</span><label class="collapse" for="c-41231223">[-]</label><label class="expand" for="c-41231223">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; arbitrary JSON is the opposite of strongly typed
</code></pre>
On the surface, I agree.  In practice, many big enterprise systems use highly dynamic JSON payloads where new fields are added and changed all the time.</div><br/></div></div></div></div></div></div></div></div><div id="41229364" class="c"><input type="checkbox" id="c-41229364" checked=""/><div class="controls bullet"><span class="by">absoflutely</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229203">parent</a><span>|</span><a href="#41229338">prev</a><span>|</span><a href="#41229260">next</a><span>|</span><label class="collapse" for="c-41229364">[-]</label><label class="expand" for="c-41229364">[6 more]</label></div><br/><div class="children"><div class="content">Go has maps, json parsing and http built in. I&#x27;m not exactly sure what this person is referring to. Perhaps they are mostly interviewing beginners?</div><br/><div id="41231478" class="c"><input type="checkbox" id="c-41231478" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229364">parent</a><span>|</span><a href="#41229260">next</a><span>|</span><label class="collapse" for="c-41231478">[-]</label><label class="expand" for="c-41231478">[5 more]</label></div><br/><div class="children"><div class="content">Go maps have a defined type (like map[string]string), so you can only put values of that type in them. A JSON object with (e.g) numbers in it will fail if you try and parse that into a map of strings.<p>As others have said, the issue with Go parsing JSON is that Go doesn&#x27;t handle unstructured data at all well, and most other languages consider JSON to be unstructured data. Go expects the JSON to be strongly typed and rigidly defined, mirroring a struct in the Go code that it can use as a receiver for the values.<p>There are techniques for handling this, but they&#x27;re not obvious and usually learned by painful experience. This is not all Go&#x27;s fault - there are too many endpoints out there that return wildly variable JSON depending on context.</div><br/><div id="41233336" class="c"><input type="checkbox" id="c-41233336" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231478">parent</a><span>|</span><a href="#41231878">next</a><span>|</span><label class="collapse" for="c-41233336">[-]</label><label class="expand" for="c-41233336">[1 more]</label></div><br/><div class="children"><div class="content">Umm, you can unmarshall into a map[string]any, you know ?<p><pre><code>    dataMap := make(map[string]any)
    err = json.Unmarshal(bytes, &amp;dataMap)</code></pre></div><br/></div></div><div id="41231878" class="c"><input type="checkbox" id="c-41231878" checked=""/><div class="controls bullet"><span class="by">claytongulick</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231478">parent</a><span>|</span><a href="#41233336">prev</a><span>|</span><a href="#41229260">next</a><span>|</span><label class="collapse" for="c-41231878">[-]</label><label class="expand" for="c-41231878">[3 more]</label></div><br/><div class="children"><div class="content">I feel like good JSON handling is sort of table stakes for any language for me these days.<p>The pain of dealing with JSON in Go is one of the primary reasons I stick mostly with nodejs for my api servers.</div><br/><div id="41232728" class="c"><input type="checkbox" id="c-41232728" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231878">parent</a><span>|</span><a href="#41229260">next</a><span>|</span><label class="collapse" for="c-41232728">[-]</label><label class="expand" for="c-41232728">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The pain of dealing with JSON in Go is one of the primary reasons I stick mostly with nodejs for my api servers.<p>Unless you&#x27;re dealing with JSON input that has missing fields, or unexpected fields, there is no pain. Go can natively turn a JSON payload into a struct <i>as long as the payload&#x27;s fields recursively match the struct&#x27;s fields!</i><p>If, in <i>any</i> language, you&#x27;re consuming or generating JSON that doesn&#x27;t match a specific predetermined structure, you&#x27;re yolo&#x27;ing it and all bets are off. Go makes this particualr footgun hard to do, while JS, Python, etc makes it the default.<p>Default footguns are a <i>bad</i> idea, not a <i>good</i> idea.</div><br/><div id="41232803" class="c"><input type="checkbox" id="c-41232803" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232728">parent</a><span>|</span><a href="#41229260">next</a><span>|</span><label class="collapse" for="c-41232803">[-]</label><label class="expand" for="c-41232803">[1 more]</label></div><br/><div class="children"><div class="content">This.<p>In $other_language you&#x27;ll parse the JSON fine, but then smack into problems when the field you&#x27;re expecting to be there isn&#x27;t, or is in the wrong format, or the wrong type, etc.<p>In Go, as always, this is up front and explicit. You hit that problem when you parse the JSON, not later when you try to use the resulting data.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41229260" class="c"><input type="checkbox" id="c-41229260" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229203">parent</a><span>|</span><a href="#41229364">prev</a><span>|</span><a href="#41230830">next</a><span>|</span><label class="collapse" for="c-41229260">[-]</label><label class="expand" for="c-41229260">[1 more]</label></div><br/><div class="children"><div class="content">Go has had a dict-like data type from the jump; they&#x27;re called &quot;maps&quot; in Go.<p>Some of early Go&#x27;s design decisions were kinda stupid, but they didn&#x27;t screw that one up.</div><br/></div></div></div></div></div></div><div id="41230830" class="c"><input type="checkbox" id="c-41230830" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225126">parent</a><span>|</span><a href="#41225719">prev</a><span>|</span><a href="#41225449">next</a><span>|</span><label class="collapse" for="c-41230830">[-]</label><label class="expand" for="c-41230830">[1 more]</label></div><br/><div class="children"><div class="content">I feel the same.<p>Especially in the UI&#x2F;UX world when you want to just start building a demo you&#x27;re paralized by dozens of build toolchains in between.<p>Wanna get started with a starter template? Tough luck, it hasn&#x27;t been updated for a year, so it takes even longer.<p>In go, everything is opinionater and unified upstream. Conventions matter, because they allow efficiency and reuse of patterns and architectures.</div><br/></div></div><div id="41225449" class="c"><input type="checkbox" id="c-41225449" checked=""/><div class="controls bullet"><span class="by">justinsaccount</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225126">parent</a><span>|</span><a href="#41230830">prev</a><span>|</span><a href="#41233279">next</a><span>|</span><label class="collapse" for="c-41225449">[-]</label><label class="expand" for="c-41225449">[3 more]</label></div><br/><div class="children"><div class="content">Yep.. say you wanted to make a simple http service that needs to<p>* request a json.gz file from another HTTP service
* decompress it
* deserialize the json, transform it a bit<p>That&#x27;s net&#x2F;http (and maybe crypto&#x2F;tls), compress&#x2F;gzip, encoding&#x2F;json.  I need to make zero decisions to get the thing off the ground. Are they the best libraries in the world for those things? no.. but will they work just fine for almost every use case.</div><br/><div id="41228996" class="c"><input type="checkbox" id="c-41228996" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225449">parent</a><span>|</span><a href="#41233279">next</a><span>|</span><label class="collapse" for="c-41228996">[-]</label><label class="expand" for="c-41228996">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like<p><pre><code>    curl ... | jq ...
</code></pre>
to me!<p>Not saying you shouldn&#x27;t use Go for that problem, in a particular context, but it does drive home how much of programming is glue ... there is combinatorial amounts of glue, which is why JSON, HTTP, compression, etc. end up being part of so many problems</div><br/><div id="41229969" class="c"><input type="checkbox" id="c-41229969" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41228996">parent</a><span>|</span><a href="#41233279">next</a><span>|</span><label class="collapse" for="c-41229969">[-]</label><label class="expand" for="c-41229969">[1 more]</label></div><br/><div class="children"><div class="content">There’s a big difference between building something on curl and jq and building something using a language’s standard library.<p>Everything is just bits at the end of the day. Just about anything can do anything.</div><br/></div></div></div></div></div></div></div></div><div id="41233279" class="c"><input type="checkbox" id="c-41233279" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41225126">prev</a><span>|</span><a href="#41232925">next</a><span>|</span><label class="collapse" for="c-41233279">[-]</label><label class="expand" for="c-41233279">[1 more]</label></div><br/><div class="children"><div class="content">Go is not good for data science and ML. It doesn&#x27;t even have a proper, maintained dataframe library for data-science. R and Python beat it hands on. Rust also beats it now thanks to polars. And mobile ? gomobile is not maintained. Fyne is amateur level on mobile.<p>AFAIK Go has no maintained 3d game engines.<p>Go has its well-established niche for middle-ware services and CLI tools. And that&#x27;s about it. If your domain is outside this, its best to choose another language.</div><br/></div></div><div id="41232925" class="c"><input type="checkbox" id="c-41232925" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41233279">prev</a><span>|</span><a href="#41230608">next</a><span>|</span><label class="collapse" for="c-41232925">[-]</label><label class="expand" for="c-41232925">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The author lists multiple reasons for this, but for me the biggest one is the first one: Go is good for almost everything.<p>I&#x27;d nuance that claim.<p>I haven&#x27;t found Go to be _particularly good_ at any specific task I&#x27;ve undertaken, but Go was _good enough_ for many of these tasks. Which makes Go a reasonable general programming language.</div><br/></div></div><div id="41230608" class="c"><input type="checkbox" id="c-41230608" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41232925">prev</a><span>|</span><a href="#41231337">next</a><span>|</span><label class="collapse" for="c-41230608">[-]</label><label class="expand" for="c-41230608">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When people argue about the validity of these claims, I simply point them to this talk <a href="https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;concurrency.slide#42" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;concurrency.slide#42</a><p>There&#x27;s nothing impressive in these slides. This may have been pretty good in 2012, but this code looks very much like the equivalent Swift or Rust.</div><br/></div></div><div id="41231337" class="c"><input type="checkbox" id="c-41231337" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41230608">prev</a><span>|</span><a href="#41231882">next</a><span>|</span><label class="collapse" for="c-41231337">[-]</label><label class="expand" for="c-41231337">[3 more]</label></div><br/><div class="children"><div class="content">Personally I don&#x27;t find it great for prototyping. There&#x27;s just too much boilerplate, which is why I use other languages for fun&#x2F;personal projects.</div><br/><div id="41232518" class="c"><input type="checkbox" id="c-41232518" checked=""/><div class="controls bullet"><span class="by">pants2</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41231337">parent</a><span>|</span><a href="#41231882">next</a><span>|</span><label class="collapse" for="c-41232518">[-]</label><label class="expand" for="c-41232518">[2 more]</label></div><br/><div class="children"><div class="content">Is there much boilerplate aside from err checks and JSON tags? Even then, your IDE &#x2F; copilot should automatically insert those along with imports and package names.</div><br/><div id="41232932" class="c"><input type="checkbox" id="c-41232932" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41232518">parent</a><span>|</span><a href="#41231882">next</a><span>|</span><label class="collapse" for="c-41232932">[-]</label><label class="expand" for="c-41232932">[1 more]</label></div><br/><div class="children"><div class="content">The requirement to define at least one function by itself is a boilerplate. Also IDE doesn&#x27;t fully solve the inability to compile and run a partially written program (in fact, Go compiler is even more pedantic than rustc in some aspect), which happens a lot when working with dynamically typed languages and their strongest use cases.</div><br/></div></div></div></div></div></div><div id="41231882" class="c"><input type="checkbox" id="c-41231882" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41231337">prev</a><span>|</span><a href="#41232921">next</a><span>|</span><label class="collapse" for="c-41231882">[-]</label><label class="expand" for="c-41231882">[1 more]</label></div><br/><div class="children"><div class="content">I can totally agree that Go is <i>good enough</i> for most projects, to the extent it&#x27;s a go-to choice for many. However, it&#x27;s not always the best tool - frequently it wins just because it allows to prototype quicker. YMMV, but for me, it&#x27;s not a love relationship, it&#x27;s a love-hate relationship.<p>&gt; The language is extremely simple.<p>Simplicity is a double-edged sword. It didn&#x27;t even have basic generics for a long while, and it&#x27;s painful to remember how bad it was without them. Still doesn&#x27;t have a lot of stuff anyone would expect from a modern language.<p>&gt; If you know 20% of C you are already a Go expert.<p>Strong disagree. Knowing $language means knowing the patterns and caveats and (sorry for a cliche term, I&#x27;m not fond of it, but I don&#x27;t have a better term so I hope you get the meaning) &quot;best practices&quot;. Those are drastically different between C and Go. Especially when it comes to concurrency and parallelism.<p>&gt; The toolchain and the core libraries alone can do 90% of what most people will ever need.<p>This is provably false. Virtually every serious project out there pulls a ton of dependencies, like database drivers, configuration toolkits, tracing and logging libraries and so on. Heck, I think a lot of shops have project templates for this reason - to standardize on the layout and pull the company-preferred set of libraries for common stuff. Core libraries are slowly getting there but so far they don&#x27;t have very basic stuff like MapSet[T] or JSON codecs for nullable types like sql.NullString, so you gotta pull third-party stuff.</div><br/></div></div><div id="41232921" class="c"><input type="checkbox" id="c-41232921" checked=""/><div class="controls bullet"><span class="by">ternaryoperator</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41231882">prev</a><span>|</span><a href="#41229866">next</a><span>|</span><label class="collapse" for="c-41232921">[-]</label><label class="expand" for="c-41232921">[1 more]</label></div><br/><div class="children"><div class="content">Agreed on all points except #3 re the core libraries. Coming from the Java ecosystem, it was a bit of a shock to see how small the standard libraries are. For example, the minuscule collections library, among others.</div><br/></div></div><div id="41229866" class="c"><input type="checkbox" id="c-41229866" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41232921">prev</a><span>|</span><a href="#41229134">next</a><span>|</span><label class="collapse" for="c-41229866">[-]</label><label class="expand" for="c-41229866">[2 more]</label></div><br/><div class="children"><div class="content">My personal Python threshold is 10k lines. After that I tend to loose track of what I am doing and I start to miss static typing and nowadays, an IDE to navigate it. Maybe future Python IDEs can AI scan the codebase and compensate.</div><br/><div id="41232605" class="c"><input type="checkbox" id="c-41232605" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229866">parent</a><span>|</span><a href="#41229134">next</a><span>|</span><label class="collapse" for="c-41232605">[-]</label><label class="expand" for="c-41232605">[1 more]</label></div><br/><div class="children"><div class="content">Wait... in what year was this comment written ? ;)<p>There&#x27;s type hinting and IDEs do navigate it.</div><br/></div></div></div></div><div id="41229134" class="c"><input type="checkbox" id="c-41229134" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41229866">prev</a><span>|</span><a href="#41224862">next</a><span>|</span><label class="collapse" for="c-41229134">[-]</label><label class="expand" for="c-41229134">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m asking this earnestly but is Go suitable for native GUI apps (not web)?  3D graphics&#x2F;Games?  Audio processing?</div><br/><div id="41229315" class="c"><input type="checkbox" id="c-41229315" checked=""/><div class="controls bullet"><span class="by">xyproto</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229134">parent</a><span>|</span><a href="#41229188">next</a><span>|</span><label class="collapse" for="c-41229315">[-]</label><label class="expand" for="c-41229315">[3 more]</label></div><br/><div class="children"><div class="content">Yes, because one can either turn off the GC, allocate memory up front (arena style), or call C or Assembly from Go.<p>The performance is likely to be good enough with GC turned on, though, because it is unusually fast.</div><br/><div id="41230277" class="c"><input type="checkbox" id="c-41230277" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229315">parent</a><span>|</span><a href="#41229188">next</a><span>|</span><label class="collapse" for="c-41230277">[-]</label><label class="expand" for="c-41230277">[2 more]</label></div><br/><div class="children"><div class="content">Turning off the GC isn&#x27;t the blocker.  Plenty of GC languages manage.<p>I&#x27;m more interested in how Go handles graphics APIs and binding a render thread or working with GUI threads considering how goroutines are done.  Does one need to write non-idiomatic go, avoiding goroutines or is there some trick?<p>For example, GTK isn&#x27;t thread safe so you can&#x27;t just use that library without considering that.</div><br/><div id="41230482" class="c"><input type="checkbox" id="c-41230482" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230277">parent</a><span>|</span><a href="#41229188">next</a><span>|</span><label class="collapse" for="c-41230482">[-]</label><label class="expand" for="c-41230482">[1 more]</label></div><br/><div class="children"><div class="content">Offhand, I think the general pattern is to bind related external libraries (E.G. a gui stack) into one agent thread and use channels to send it messages.</div><br/></div></div></div></div></div></div><div id="41229188" class="c"><input type="checkbox" id="c-41229188" checked=""/><div class="controls bullet"><span class="by">nasretdinov</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229134">parent</a><span>|</span><a href="#41229315">prev</a><span>|</span><a href="#41229755">next</a><span>|</span><label class="collapse" for="c-41229188">[-]</label><label class="expand" for="c-41229188">[2 more]</label></div><br/><div class="children"><div class="content">For games potentially Ebiten, I believe it has some audio processing support too.</div><br/><div id="41229346" class="c"><input type="checkbox" id="c-41229346" checked=""/><div class="controls bullet"><span class="by">runeblaze</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229188">parent</a><span>|</span><a href="#41229755">next</a><span>|</span><label class="collapse" for="c-41229346">[-]</label><label class="expand" for="c-41229346">[1 more]</label></div><br/><div class="children"><div class="content">Probably not Ebiten for 3d games. To be fair at this point when you are doing somewhat specialist things Go starts to lose its edge. I remember trying to replicate some Numpy code in Go and that was a pain. However that&#x27;s just because Python is too good at scientific things.</div><br/></div></div></div></div><div id="41229755" class="c"><input type="checkbox" id="c-41229755" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229134">parent</a><span>|</span><a href="#41229188">prev</a><span>|</span><a href="#41224862">next</a><span>|</span><label class="collapse" for="c-41229755">[-]</label><label class="expand" for="c-41229755">[3 more]</label></div><br/><div class="children"><div class="content">People write games and GUI apps in Python, so why not?</div><br/><div id="41230242" class="c"><input type="checkbox" id="c-41230242" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229755">parent</a><span>|</span><a href="#41224862">next</a><span>|</span><label class="collapse" for="c-41230242">[-]</label><label class="expand" for="c-41230242">[2 more]</label></div><br/><div class="children"><div class="content">Is there some particular reason Python is similar to go with regards to GUIs or are you saying everything can do everything?</div><br/><div id="41230312" class="c"><input type="checkbox" id="c-41230312" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41230242">parent</a><span>|</span><a href="#41224862">next</a><span>|</span><label class="collapse" for="c-41230312">[-]</label><label class="expand" for="c-41230312">[1 more]</label></div><br/><div class="children"><div class="content">Python is a slow interpreted language (I write Python every day). Go is compiled and an order of magnitude faster for most everything.<p>So, I guess, yeah, everything can do everything. Computers are fast where language is rarely going to be the deciding factor.</div><br/></div></div></div></div></div></div></div></div><div id="41224862" class="c"><input type="checkbox" id="c-41224862" checked=""/><div class="controls bullet"><span class="by">cube2222</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41229134">prev</a><span>|</span><a href="#41229814">next</a><span>|</span><label class="collapse" for="c-41224862">[-]</label><label class="expand" for="c-41224862">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this. It&#x27;s just good enough for 95% of use-cases, while being very productive.<p>Personally, one of the biggest selling points for me is that imo modelling concurrency and asynchronicity via fibers (goroutines), rather than async&#x2F;await, is just a ton easier and faster to work with. Again, there are use-cases for the alternative (mainly performance, or if you like to express <i>everything</i> in your type-system) but it&#x27;s just great for 95% of use-cases.</div><br/></div></div><div id="41229814" class="c"><input type="checkbox" id="c-41229814" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41224862">prev</a><span>|</span><a href="#41224827">next</a><span>|</span><label class="collapse" for="c-41229814">[-]</label><label class="expand" for="c-41229814">[1 more]</label></div><br/><div class="children"><div class="content">Go has very little story when it comes to desktop or mobile GUI apps, which is too bad because it would be a very productive language for that kind of thing.</div><br/></div></div><div id="41224827" class="c"><input type="checkbox" id="c-41224827" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41224464">parent</a><span>|</span><a href="#41229814">prev</a><span>|</span><a href="#41224877">next</a><span>|</span><label class="collapse" for="c-41224827">[-]</label><label class="expand" for="c-41224827">[17 more]</label></div><br/><div class="children"><div class="content">How is it different than, say, java for this generalist purpose?</div><br/><div id="41225200" class="c"><input type="checkbox" id="c-41225200" checked=""/><div class="controls bullet"><span class="by">lantry</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41224827">parent</a><span>|</span><a href="#41225258">next</a><span>|</span><label class="collapse" for="c-41225200">[-]</label><label class="expand" for="c-41225200">[7 more]</label></div><br/><div class="children"><div class="content">IME, there are two main differences between go and java:<p>1) go is more &quot;batteries included&quot;. Modules, linting, testing, and much more are all part of the standard cli. Also, the go stdlib has a ton of stuff; in java, there is almost always a well-built third party library, but that requires you to find and learn more things instead of just reaching for stdlib every time.<p>2) golang is &quot;newer&quot; and &quot;more refined&quot;. this is pretty subjective, but golang seems to have fewer features and the features are more well-planned. It&#x27;s a more &quot;compact&quot; or &quot;ergonomic&quot; language. Whereas java has built up a lot of different features and not all of them are great. You can always ignore the java features you don&#x27;t like ofc, but this is still a bit of cognitive overhead and increased learning time.</div><br/><div id="41228920" class="c"><input type="checkbox" id="c-41228920" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225200">parent</a><span>|</span><a href="#41229045">next</a><span>|</span><label class="collapse" for="c-41228920">[-]</label><label class="expand" for="c-41228920">[1 more]</label></div><br/><div class="children"><div class="content">There are surprisingly few languages in this category, especially if you limit consideration to statically typed. Go, C#, Swift? Nim, Crystal? F#? Kotlin?<p>Go is not my favorite language, but it really is exceptional in terms of its effective utilitarian design.</div><br/></div></div><div id="41229045" class="c"><input type="checkbox" id="c-41229045" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225200">parent</a><span>|</span><a href="#41228920">prev</a><span>|</span><a href="#41225258">next</a><span>|</span><label class="collapse" for="c-41229045">[-]</label><label class="expand" for="c-41229045">[5 more]</label></div><br/><div class="children"><div class="content">Eh, imo the go libraries still aren&#x27;t up to par with out of the box java libraries.  Like there&#x27;s still no Set class, nor the equivalent of Map.keys.  yeah they&#x27;re easy to write but that&#x27;s still not an included battery.<p>Also, while the cli to add stuff is useful, there&#x27;s still nothing to the level of maven or gradle for dependency management, and I usually find myself doing some fun stuff with `find -execdir` for module management.<p>Different strokes for different folks though.  Java (really, kotlin) still makes a ton of sense for backend to me given how the jvm is architecture independent and you don&#x27;t have to make tradeoffs&#x2F;switch to graal if it&#x27;s a long lived service.<p>Golang is nice, love it, but it&#x27;s still got a bit to grow.  I&#x27;m just happy they added modules and generics.  I don&#x27;t think it&#x27;s a matter of being &#x27;well thought out&#x27; as much as it&#x27;s a simple language that cares a lot about simplicity and backwards compatibility and has iterated ever since.  For my the killer app isn&#x27;t go routines so much as you can produce a binary that&#x27;s resilient even to shared&#x2F;dynamically linked libraries in all platforms, which is awesome for portability independent of environment.  No more gcc vs clang vs msvc headaches, no more incompatible shared libraries, no more wrong version of jvm or a bad python modules path etc.<p>Oh, also java had like a 15 year headstart on golang, and it wasn&#x27;t until java 8 that many of my biggest complaints were addressed.  And yeah stuff like apache commons +log4j+mockito&#x2F;junit are pretty much required dependencies, and maven&#x2F;gradle aren&#x27;t language native.<p>The best STL is probably python imo but even that doesn&#x27;t support a proper heap&#x2F;priority queue inplementation.  For data structures specifically I think java&#x2F;kotlin has the best STL.  All of this ignoring .NET or apple platforms.</div><br/><div id="41231985" class="c"><input type="checkbox" id="c-41231985" checked=""/><div class="controls bullet"><span class="by">onionisafruit</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229045">parent</a><span>|</span><a href="#41229542">next</a><span>|</span><label class="collapse" for="c-41231985">[-]</label><label class="expand" for="c-41231985">[1 more]</label></div><br/><div class="children"><div class="content">maps.Keys is coming in a few days with 1.23.<p>I generally agree with what you are saying. Although I wouldn’t hold out Maven as a paragon. I used to make my living untangling pom.xml files. I don’t think anybody is feeding their family helping people with go.mod messes — although I wish somebody would do that for kubernetes.</div><br/></div></div><div id="41229542" class="c"><input type="checkbox" id="c-41229542" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229045">parent</a><span>|</span><a href="#41231985">prev</a><span>|</span><a href="#41225258">next</a><span>|</span><label class="collapse" for="c-41229542">[-]</label><label class="expand" for="c-41229542">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Like there&#x27;s still no Set class<p>map[T]struct{} ?</div><br/><div id="41231412" class="c"><input type="checkbox" id="c-41231412" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229542">parent</a><span>|</span><a href="#41230054">next</a><span>|</span><label class="collapse" for="c-41231412">[-]</label><label class="expand" for="c-41231412">[1 more]</label></div><br/><div class="children"><div class="content">So, like they said, no Set class.</div><br/></div></div><div id="41230054" class="c"><input type="checkbox" id="c-41230054" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41229542">parent</a><span>|</span><a href="#41231412">prev</a><span>|</span><a href="#41225258">next</a><span>|</span><label class="collapse" for="c-41230054">[-]</label><label class="expand" for="c-41230054">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;deckarep&#x2F;golang-set">https:&#x2F;&#x2F;github.com&#x2F;deckarep&#x2F;golang-set</a> offers a thread safety option and methods like contains all, intersect, and equal.</div><br/></div></div></div></div></div></div></div></div><div id="41225258" class="c"><input type="checkbox" id="c-41225258" checked=""/><div class="controls bullet"><span class="by">conor-</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41224827">parent</a><span>|</span><a href="#41225200">prev</a><span>|</span><a href="#41225150">next</a><span>|</span><label class="collapse" for="c-41225258">[-]</label><label class="expand" for="c-41225258">[3 more]</label></div><br/><div class="children"><div class="content">As someone who isn&#x27;t super proficient in Java I usually find Java daunting to get started with full of buckets of &quot;meta&quot; issues like in my other comment.<p>What JVM do I use? Does it matter?<p>Does it matter what version I install, what if I have to install&#x2F;manage multiple versions?<p>If I want to write a web service can I use vanilla Java stdlib or do I have to use Spring or some framework? If I use Spring, do I have to get into the weeds of dependency injection and other complexity to actually get my app off the ground?<p>With Go, none of those questions exist. I install the latest Go, create a main.go file, I use net&#x2F;http and I&#x27;m off to the races.</div><br/><div id="41233341" class="c"><input type="checkbox" id="c-41233341" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225258">parent</a><span>|</span><a href="#41228480">next</a><span>|</span><label class="collapse" for="c-41233341">[-]</label><label class="expand" for="c-41233341">[1 more]</label></div><br/><div class="children"><div class="content">Besides what neonsunset points out for .NET world, where alongside C#, we get the pleasure to enjoy F#, VB and C++&#x2F;CLI, it is relatively easy for Java.<p>When one doesn&#x27;t know, just like with Go, one picks up the reference implementation =&gt; OpenJDK.<p>For basic stuff, the standard library also has you covered in the jdk.httpserver module.<p>By the way, where is the Swing equivalent on Go&#x27;s standard library?</div><br/></div></div><div id="41228480" class="c"><input type="checkbox" id="c-41228480" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225258">parent</a><span>|</span><a href="#41233341">prev</a><span>|</span><a href="#41225150">next</a><span>|</span><label class="collapse" for="c-41228480">[-]</label><label class="expand" for="c-41228480">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s good that Go, among other well-made toolchains, brought attention to importance of good CLI UX.<p>But it&#x27;s not something that is unique to Go:<p><pre><code>    dotnet new web
    dotnet run
    curl localhost:5050
</code></pre>
also &#x27;dotnet watch&#x27; for hot-reload.</div><br/></div></div></div></div><div id="41225150" class="c"><input type="checkbox" id="c-41225150" checked=""/><div class="controls bullet"><span class="by">colonelpopcorn</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41224827">parent</a><span>|</span><a href="#41225258">prev</a><span>|</span><a href="#41225170">next</a><span>|</span><label class="collapse" for="c-41225150">[-]</label><label class="expand" for="c-41225150">[2 more]</label></div><br/><div class="children"><div class="content">Just from an ergonomic standpoint it&#x27;s a million times easier to deploy a go binary instead of a whole jvm and a jar file.</div><br/><div id="41233347" class="c"><input type="checkbox" id="c-41233347" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225150">parent</a><span>|</span><a href="#41225170">next</a><span>|</span><label class="collapse" for="c-41233347">[-]</label><label class="expand" for="c-41233347">[1 more]</label></div><br/><div class="children"><div class="content">When it is a pure Go application, only as CLI or UNIX server.</div><br/></div></div></div></div><div id="41225170" class="c"><input type="checkbox" id="c-41225170" checked=""/><div class="controls bullet"><span class="by">Dansvidania</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41224827">parent</a><span>|</span><a href="#41225150">prev</a><span>|</span><a href="#41225255">next</a><span>|</span><label class="collapse" for="c-41225170">[-]</label><label class="expand" for="c-41225170">[3 more]</label></div><br/><div class="children"><div class="content">java on its own is not a competitor to go, IMO, due to the batteries included &quot;culture&quot; in the go ecosystem.<p>I would need to compare it with, for example, Java + Spring(Boot).<p>I find Go to be simpler and more pleasant to use.</div><br/><div id="41233352" class="c"><input type="checkbox" id="c-41233352" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225170">parent</a><span>|</span><a href="#41230155">next</a><span>|</span><label class="collapse" for="c-41233352">[-]</label><label class="expand" for="c-41233352">[1 more]</label></div><br/><div class="children"><div class="content">Where is the GUI battery in Go?</div><br/></div></div><div id="41230155" class="c"><input type="checkbox" id="c-41230155" checked=""/><div class="controls bullet"><span class="by">matwood</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41225170">parent</a><span>|</span><a href="#41233352">prev</a><span>|</span><a href="#41225255">next</a><span>|</span><label class="collapse" for="c-41230155">[-]</label><label class="expand" for="c-41230155">[1 more]</label></div><br/><div class="children"><div class="content">I agree with Go being simpler, but modern Java and Spring Boot is also <i>fine</i>. Backend programmers are spoiled with riches nowadays with all the completely workable options we have.</div><br/></div></div></div></div><div id="41225255" class="c"><input type="checkbox" id="c-41225255" checked=""/><div class="controls bullet"><span class="by">aaomidi</span><span>|</span><a href="#41224464">root</a><span>|</span><a href="#41224827">parent</a><span>|</span><a href="#41225170">prev</a><span>|</span><a href="#41224877">next</a><span>|</span><label class="collapse" for="c-41225255">[-]</label><label class="expand" for="c-41225255">[1 more]</label></div><br/><div class="children"><div class="content">Dependencies in Java are a pain in the ass.<p>Publishing libraries for your own consumption is even harder.<p>Publishing libraries for world consumption means now you also need to be a PKI expert.</div><br/></div></div></div></div></div></div><div id="41224877" class="c"><input type="checkbox" id="c-41224877" checked=""/><div class="controls bullet"><span class="by">lairv</span><span>|</span><a href="#41224464">prev</a><span>|</span><a href="#41232072">next</a><span>|</span><label class="collapse" for="c-41224877">[-]</label><label class="expand" for="c-41224877">[57 more]</label></div><br/><div class="children"><div class="content">Go is everything I don’t want in a language for my personal projects. It’s verbose, every simple task feels like a lot to write. It’s not expressive, what would be a one-liner in Python makes you write three for loops in Go. I constantly need to find workarounds for the lack of proper enums, lack of sum types, no null safety etc.<p>I’m sure these are the exact reasons why Go is good for enterprise software, but for personal projects, I get no fun out of using it</div><br/><div id="41225289" class="c"><input type="checkbox" id="c-41225289" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41224877">parent</a><span>|</span><a href="#41225193">next</a><span>|</span><label class="collapse" for="c-41225289">[-]</label><label class="expand" for="c-41225289">[19 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why I love Go so much.<p>You want to write a very clever library using elegant abstraction and generics to have a cool innovative interface to solve your problem? Tough luck, you can&#x27;t. So instead, you will just have to write a bog standard implementation with for-loops and good old functions which you will have to copy and tweak as needed where you really need something more complicated. It will work perfectly fine and end up being very readable for you and for the other persons reading your code.<p>Go is basically anti-Haskell. It forces you to be less clever and that&#x27;s great.</div><br/><div id="41232418" class="c"><input type="checkbox" id="c-41232418" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225289">parent</a><span>|</span><a href="#41231091">next</a><span>|</span><label class="collapse" for="c-41232418">[-]</label><label class="expand" for="c-41232418">[2 more]</label></div><br/><div class="children"><div class="content">You can write abstractions in Go and it has generics. Its just that the abstraction aren&#x27;t as good so you end up with harder to read code.</div><br/><div id="41233010" class="c"><input type="checkbox" id="c-41233010" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41232418">parent</a><span>|</span><a href="#41231091">next</a><span>|</span><label class="collapse" for="c-41233010">[-]</label><label class="expand" for="c-41233010">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re holding the phone wrong. Kubernetes does the same. So does Docker, and just about every Go project. You don&#x27;t understand Go.</div><br/></div></div></div></div><div id="41231091" class="c"><input type="checkbox" id="c-41231091" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225289">parent</a><span>|</span><a href="#41232418">prev</a><span>|</span><a href="#41232000">next</a><span>|</span><label class="collapse" for="c-41231091">[-]</label><label class="expand" for="c-41231091">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It will work perfectly fine and end up being very readable for you and for the other persons reading your code.<p>And make all future work both 3 times simpler, and take 3 times as long. I suppose there’s situations in which this is great, but I’m partial to requiring more.<p>I’ll admit that hasn’t worked out very well for me unless I’m working my myself though.</div><br/></div></div><div id="41232000" class="c"><input type="checkbox" id="c-41232000" checked=""/><div class="controls bullet"><span class="by">kerkeslager</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225289">parent</a><span>|</span><a href="#41231091">prev</a><span>|</span><a href="#41227912">next</a><span>|</span><label class="collapse" for="c-41232000">[-]</label><label class="expand" for="c-41232000">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Simple&quot; is a cop-out word. Things can be simple along a lot of vectors. The vector you&#x27;ve chosen seems to be &quot;does less for you&quot; which taken ad absurdum would have you using assembly. Go does have elegant abstractions, and they aren&#x27;t the simplest along this vector, nor would anyone want them to be. Coroutines, for example, are actually quite conceptually complicated in some ways.<p>I prefer &quot;understandable&quot;--it appears this is what you&#x27;re trying to get when you say &quot;simple&quot;, but I think you&#x27;re drastically overselling the understandability of go code. Sure, you understand any given line easily (what you described as &quot;readable&quot;), but you&#x27;re not usually trying to understand one line of code. Since go&#x27;s sparse feature set provides few effective tools for chunking[1] your mental model of the program, complex functionality ends up being in too large of chunks to be understood easily. This problem gets worse as programs grow in size.<p>Another poster mentioned that they start running into problems and wishing they had explicit types with Python programs over 10K LOC, which approximately matches my experience. But comparing to go, you&#x27;ve got to realize that 10K LOC of Python does a whole lot more than 10K LOC of Go; you&#x27;d have to write a lot more Go to achieve the same functionality because of all the boilerplate. That&#x27;s not necessarily a downside because that boilerplate is giving you benefits, and I don&#x27;t think entering your code into the computer is the limiting factor in development speed. But it does mean that a fair comparison of equally-complex programs is going to be a lot more lines of Go than Python, i.e. a fair comparison of might be 10K LOC of Python vs 50K LOC of Go. I say &quot;might be&quot; because I don&#x27;t know what the numbers would be exactly.<p>How many people have written or worked on projects in Go of that complexity? How many people have written or worked on programs of equivalent complexity in other languages to compare? I&#x27;m seeing people discuss how easy it is to start a project in Go, but nobody is talking about how easy it is to maintain 50K LOC of Go.<p>I&#x27;ve worked on projects of &gt;200K LOC in Python, and the possibly-equivalent &gt;500K LOC in C#. I think the C# was easier to work with, but that&#x27;s largely because the 200K lines of Python made heavy use of monkey patching, and I&#x27;ve worked in smaller C# codebases that made heavy use of dependency injection to similar detriment. I&#x27;m honestly not sure which feels more maintainable to me, given a certain level of discipline to not use certain misfeatures.<p>I haven&#x27;t written as much Go, and I wouldn&#x27;t, because the features of C# which make it viable for projects of this complexity simply aren&#x27;t present, and unlike Python, Go doesn&#x27;t provide good alternatives. I suspect the reason we don&#x27;t have many people talking about this is that not many projects have grown to this complexity, and when they do these problems will become apparent.<p>The real weak point is Go&#x27;s type system--it&#x27;s genuinely terrible, because the features that came standard in other modern statically-typed languages decades before Go was invented were bolted onto Go after the fact. Gophers initially claimed they didn&#x27;t need generics for a few years. As a result you&#x27;ve got conflicting systems developed before `go generate` (using casts), after `go generate` but before generics (using go generate), and after generics (using generics). It&#x27;s telling that you seemingly reject generics (&quot;clever library using elegant abstraction and generics&quot;) even though go has them now.<p>Attacking Haskell is sort of a straw man--so far I haven&#x27;t seen anyone in this thread propose Haskell as a go alternative. I think we agree Haskell is far too dogmatic about its abstractions when it&#x27;s impractical to be used as a general-purpose language (because I don&#x27;t think it&#x27;s intended as a general-purpose language).<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chunking_(psychology)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chunking_(psychology)</a></div><br/><div id="41232588" class="c"><input type="checkbox" id="c-41232588" checked=""/><div class="controls bullet"><span class="by">truth_seeker</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41232000">parent</a><span>|</span><a href="#41233183">prev</a><span>|</span><a href="#41227912">next</a><span>|</span><label class="collapse" for="c-41232588">[-]</label><label class="expand" for="c-41232588">[1 more]</label></div><br/><div class="children"><div class="content">Spot on ! same feeling here !</div><br/></div></div></div></div><div id="41227912" class="c"><input type="checkbox" id="c-41227912" checked=""/><div class="controls bullet"><span class="by">GaryNumanVevo</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225289">parent</a><span>|</span><a href="#41232000">prev</a><span>|</span><a href="#41233355">next</a><span>|</span><label class="collapse" for="c-41227912">[-]</label><label class="expand" for="c-41227912">[8 more]</label></div><br/><div class="children"><div class="content">Take a look at a JSON parser or ORM written in Go. It&#x27;s god awful the things they have to do to work around Go&#x27;s type system. The average developer won&#x27;t see these things, they&#x27;re typically just writing glue code between Go&#x27;s great stdlib (which also contains wild things if you take a look) and other 3rd party dependencies.</div><br/><div id="41229180" class="c"><input type="checkbox" id="c-41229180" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41227912">parent</a><span>|</span><a href="#41233355">next</a><span>|</span><label class="collapse" for="c-41229180">[-]</label><label class="expand" for="c-41229180">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The average developer won&#x27;t see these things, they&#x27;re typically just writing glue code between Go&#x27;s great stdlib (which also contains wild things if you take a look) and other 3rd party dependencies.<p>This is what most of us are doing every day, and exactly what Go excels at.</div><br/><div id="41230082" class="c"><input type="checkbox" id="c-41230082" checked=""/><div class="controls bullet"><span class="by">kamov</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41229180">parent</a><span>|</span><a href="#41232003">next</a><span>|</span><label class="collapse" for="c-41230082">[-]</label><label class="expand" for="c-41230082">[3 more]</label></div><br/><div class="children"><div class="content">Sum types allow for more robust modeling of the API boundary in libraries, so in fact having a better type system is desirable even when &quot;just gluing libraries&quot;, because it can make incorrect program states physically unrepresentable.</div><br/><div id="41230820" class="c"><input type="checkbox" id="c-41230820" checked=""/><div class="controls bullet"><span class="by">mplewis</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41230082">parent</a><span>|</span><a href="#41232003">next</a><span>|</span><label class="collapse" for="c-41230820">[-]</label><label class="expand" for="c-41230820">[2 more]</label></div><br/><div class="children"><div class="content">Sum types are great – but Go manages to be unreasonably effective even in their absence.</div><br/><div id="41233042" class="c"><input type="checkbox" id="c-41233042" checked=""/><div class="controls bullet"><span class="by">GaryNumanVevo</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41230820">parent</a><span>|</span><a href="#41232003">next</a><span>|</span><label class="collapse" for="c-41233042">[-]</label><label class="expand" for="c-41233042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; unreasonably effective<p>I&#x27;m really tired of this PR speak when it comes to programming languages. Why &#x2F; how is it unreasonably effective? More effective than what?</div><br/></div></div></div></div></div></div><div id="41232003" class="c"><input type="checkbox" id="c-41232003" checked=""/><div class="controls bullet"><span class="by">kerkeslager</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41229180">parent</a><span>|</span><a href="#41230082">prev</a><span>|</span><a href="#41233355">next</a><span>|</span><label class="collapse" for="c-41232003">[-]</label><label class="expand" for="c-41232003">[3 more]</label></div><br/><div class="children"><div class="content">If you want to progress your career you&#x27;ll need to take on hard problems at some point.<p>Go isn&#x27;t particularly unique in excelling at easy problems.</div><br/><div id="41233305" class="c"><input type="checkbox" id="c-41233305" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41232003">parent</a><span>|</span><a href="#41233355">next</a><span>|</span><label class="collapse" for="c-41233305">[-]</label><label class="expand" for="c-41233305">[2 more]</label></div><br/><div class="children"><div class="content">Go doesn&#x27;t excel at easy problems. Go is fine at pretty much everything. Do you think Kubernetes is an easy problem?<p>The thing is just that Go is very opiniated in its feature set. That&#x27;s you see people here writing about complex projects using &quot;wild&quot; or even &quot;god awful&quot; things, and lament the inability to properly map API boundaries in the language.<p>The truth is obviously that all of these is not particularly wild. It&#x27;s just things that the commenter considers inelegant but is perfectly able to follow which is Go strength and why it&#x27;s so code. Want it or not, you will have to write code that someone else can follow.<p>Don&#x27;t get me wrong, I&#x27;m not going to pretend that Go is in anyway perfect or has the <i>correct</i> feature in as much as that exists. I probably enjoyed writing Ocaml more. But in practice, for a large scale project where collaboration is important, using Go is an awesome experience.</div><br/><div id="41233517" class="c"><input type="checkbox" id="c-41233517" checked=""/><div class="controls bullet"><span class="by">GaryNumanVevo</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41233305">parent</a><span>|</span><a href="#41233355">next</a><span>|</span><label class="collapse" for="c-41233517">[-]</label><label class="expand" for="c-41233517">[1 more]</label></div><br/><div class="children"><div class="content">Go is &quot;opinionated&quot; because it&#x27;s designed to be simple rather than complete.<p>- Why are lower cased symbols not exported? Because it would be too complicated to add private &#x2F; public keywords.<p>- Why isn&#x27;t there exception handling? It&#x27;s too complicated. It&#x27;s simpler to just have everyone manually handle exception flow.<p>- Why isn&#x27;t there an optional type? It&#x27;s too complicated. Just use a nil pointer and or default values.<p>- Why aren&#x27;t there sets or other rich datatypes in the stdlib? It&#x27;s too complicated. Now go and write it yourself or download a microlibrary.<p>- Why are there no nil pointer protections? It&#x27;s too complicated.<p>It&#x27;s very easy to buy into the Golang PR and say &quot;well it&#x27;s just opinionated&quot; as opposed to calling it &quot;simplistic&quot; or &quot;incomplete&quot;. It&#x27;s an okay language, I&#x27;ve written a lot of complicated stuff in it over the last 6 or so years, including a distributed KV database. Eventually you WILL hit the limits of &quot;opinionated&quot; design.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41233355" class="c"><input type="checkbox" id="c-41233355" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225289">parent</a><span>|</span><a href="#41227912">prev</a><span>|</span><a href="#41230349">next</a><span>|</span><label class="collapse" for="c-41233355">[-]</label><label class="expand" for="c-41233355">[1 more]</label></div><br/><div class="children"><div class="content">And yet they had to reach out to Haskell folks to fix their generics story.</div><br/></div></div><div id="41230349" class="c"><input type="checkbox" id="c-41230349" checked=""/><div class="controls bullet"><span class="by">therealdrag0</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225289">parent</a><span>|</span><a href="#41233355">prev</a><span>|</span><a href="#41225193">next</a><span>|</span><label class="collapse" for="c-41230349">[-]</label><label class="expand" for="c-41230349">[3 more]</label></div><br/><div class="children"><div class="content">For loops? Dang that’s some clever syntax you have there. Personally I prefer a big standard while loop. &#x2F;s</div><br/><div id="41232895" class="c"><input type="checkbox" id="c-41232895" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41230349">parent</a><span>|</span><a href="#41230745">next</a><span>|</span><label class="collapse" for="c-41232895">[-]</label><label class="expand" for="c-41232895">[1 more]</label></div><br/><div class="children"><div class="content">That gives me the impression you&#x27;ve never written in go. Certainly not a while loop.</div><br/></div></div><div id="41230745" class="c"><input type="checkbox" id="c-41230745" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41230349">parent</a><span>|</span><a href="#41232895">prev</a><span>|</span><a href="#41225193">next</a><span>|</span><label class="collapse" for="c-41230745">[-]</label><label class="expand" for="c-41230745">[1 more]</label></div><br/><div class="children"><div class="content">Nah, bog standard goto</div><br/></div></div></div></div></div></div><div id="41225193" class="c"><input type="checkbox" id="c-41225193" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41224877">parent</a><span>|</span><a href="#41225289">prev</a><span>|</span><a href="#41225048">next</a><span>|</span><label class="collapse" for="c-41225193">[-]</label><label class="expand" for="c-41225193">[24 more]</label></div><br/><div class="children"><div class="content">I would rather go had real enums, and I would _prefer_ if there were sum types.<p>I agree it&#x27;s more verbose, but I don&#x27;t find that that verbosity really bothers me most of the time. Is<p><pre><code>    res= [x for x in foo if &quot;banned&quot; in x]
</code></pre>
really actually more readable than<p><pre><code>    var result []string
    for _, x := range foo {
        if strings.Contains(x, &quot;banned&quot;) {
            result = append(result, x)
        }
    }
</code></pre>
? I know it&#x27;s 6 lines vs 1, but in practice I look at that and it&#x27;s just as readable.<p>I think go&#x27;s attitude here (for the most part) of &quot;there&#x27;s likely only one dumb, obvious way to do this&quot; is a benefit, and it makes me think more about the higher level rather than what&#x27;s the most go-esque way to do this.</div><br/><div id="41229794" class="c"><input type="checkbox" id="c-41229794" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225193">parent</a><span>|</span><a href="#41225939">next</a><span>|</span><label class="collapse" for="c-41229794">[-]</label><label class="expand" for="c-41229794">[3 more]</label></div><br/><div class="children"><div class="content">I agree that list comprehensions aren&#x27;t any easier to read. A proper streaming interface on the other hand lets you easily follow how the data is transformed:<p><pre><code>    foo
      .stream()
      .filter(x -&gt; x.contains(&quot;banned&quot;))
      .collect(Collectors.toList());
</code></pre>
As an aside, Go conflating lists and views irks me, in part due to what weird semantics it gives to append (e.g. if you have two disjunct slices and append an element to one slice, that might modify the other slice).</div><br/><div id="41230596" class="c"><input type="checkbox" id="c-41230596" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41229794">parent</a><span>|</span><a href="#41230727">next</a><span>|</span><label class="collapse" for="c-41230596">[-]</label><label class="expand" for="c-41230596">[1 more]</label></div><br/><div class="children"><div class="content">You could write your own syntax sugar functions with signatures like...<p><pre><code>    func copyArrStringShallow(x []string) []string { return x }
    &#x2F;&#x2F; strings are immutable in go, but for []byte etc also deep copy that.
    func copyArrStringDeep(x []string) []string {
      ret := make([]string, 0, len(x))
      copy(ret, x)
      return ret
    }</code></pre></div><br/></div></div><div id="41230727" class="c"><input type="checkbox" id="c-41230727" checked=""/><div class="controls bullet"><span class="by">valzam</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41229794">parent</a><span>|</span><a href="#41230596">prev</a><span>|</span><a href="#41225939">next</a><span>|</span><label class="collapse" for="c-41230727">[-]</label><label class="expand" for="c-41230727">[1 more]</label></div><br/><div class="children"><div class="content">The problem with this is that people again get way to clever with it. it&#x27;s not just stream -&gt; filter -&gt; collection, there will be a bunch of groupbys in there etc. If you have to debug or extend the functionality it&#x27;s a nightmare to understand what all the intermediate representations are</div><br/></div></div></div></div><div id="41225939" class="c"><input type="checkbox" id="c-41225939" checked=""/><div class="controls bullet"><span class="by">thornewolf</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225193">parent</a><span>|</span><a href="#41229794">prev</a><span>|</span><a href="#41231970">next</a><span>|</span><label class="collapse" for="c-41225939">[-]</label><label class="expand" for="c-41225939">[8 more]</label></div><br/><div class="children"><div class="content">I argue:<p>- The list comprehension is ever slightly more readable. (Small Positive)<p>- It is a bit faster to write the code for the Python variant. (Small Positive)<p>So this would be a small positive when using Python.<p>Furthermore, I believe there is this &quot;small positive&quot; trade-off on nearly every aspect of Python, when compared to Go. It makes me wonder why someone might prefer Go to Python in almost any context.<p>Some common critiques of Python might be:<p>- Performance in number crunching<p>- Performance in concurrency<p>- Development issues in managing a large code base<p>I believe the ecosystem is sufficiently developed that Numpy&#x2F;Numba JIT can address nearly all number crunching performance, Uvicorn w&#x2F; workers addresses concurrency in a web serving context, ThreadPool&#x2F;ProcessPool addresses concurrency elsewhere, and type hints are 90% of what you need for type safety. So where does the perceived legitimacy of these critiques come from? I don&#x27;t know.</div><br/><div id="41226319" class="c"><input type="checkbox" id="c-41226319" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225939">parent</a><span>|</span><a href="#41228504">next</a><span>|</span><label class="collapse" for="c-41226319">[-]</label><label class="expand" for="c-41226319">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The list comprehension is ever slightly more readable.<p>I disagree - it&#x27;s terse to the point of being hard to parse, particularly when you get smart ones like:<p><pre><code>    [x for x in t if x not in s]
</code></pre>
&gt; It is a bit faster to write the code for the Python variant.<p>Code should be written to be read. Saving a few keystrokes vs time spent figuring out the `not in in not with` dance gives the the edge to Golang here. It&#x27;s &quot;high context&quot;<p>&gt; - Performance in number crunching
&gt; - Performance in concurrency<p>And &quot;performance in all other areas&quot;. See the thread last week about massive speedups in function calls in python where it was still 5-10x slower than go.<p>&gt; So where does the perceived legitimacy of these critiques come from? I don&#x27;t know.<p>It&#x27;s pretty hard to discuss it when you&#x27;ve declared that performance isn&#x27;t a problem and that type annotations solve the scalability of development problem.</div><br/><div id="41227275" class="c"><input type="checkbox" id="c-41227275" checked=""/><div class="controls bullet"><span class="by">laserlight</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41226319">parent</a><span>|</span><a href="#41232274">next</a><span>|</span><label class="collapse" for="c-41227275">[-]</label><label class="expand" for="c-41227275">[3 more]</label></div><br/><div class="children"><div class="content">Luckily, we are writing Python, not Go, so we can use variable names with more than one letter:<p><pre><code>    [word for word in sentence if word not in bannedWords]
</code></pre>
Suddenly, nothing is hard to parse.</div><br/><div id="41230639" class="c"><input type="checkbox" id="c-41230639" checked=""/><div class="controls bullet"><span class="by">archargelod</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41227275">parent</a><span>|</span><a href="#41230063">next</a><span>|</span><label class="collapse" for="c-41230639">[-]</label><label class="expand" for="c-41230639">[1 more]</label></div><br/><div class="children"><div class="content">I still believe Python comprehensions have confusing structure and in real code I&#x27;ve seen it&#x27;s 10x worse with 5+ expressions packed in a single line. I much prefer a Nim&#x27;s style of list comprehensions:<p><pre><code>    let a = collect:
      for word in wordList:
        if word notin bannedWords:
          word
    let b = collect(for x in list: x)
</code></pre>
It&#x27;s still very terse, but, more importanly, it&#x27;s the same syntax as a regular `for loop`. It has the structure, where in Python complex comprehensions look like a &quot;keyword soup&quot;.</div><br/></div></div><div id="41230063" class="c"><input type="checkbox" id="c-41230063" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41227275">parent</a><span>|</span><a href="#41230639">prev</a><span>|</span><a href="#41232274">next</a><span>|</span><label class="collapse" for="c-41230063">[-]</label><label class="expand" for="c-41230063">[1 more]</label></div><br/><div class="children"><div class="content">I do think people should tend to be more verbose with variable names, in general.<p>And since it&#x27;s python, use snake case to add faux white space to help the eyes parse the statement.</div><br/></div></div></div></div><div id="41232274" class="c"><input type="checkbox" id="c-41232274" checked=""/><div class="controls bullet"><span class="by">dpkirchner</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41226319">parent</a><span>|</span><a href="#41227275">prev</a><span>|</span><a href="#41228504">next</a><span>|</span><label class="collapse" for="c-41232274">[-]</label><label class="expand" for="c-41232274">[1 more]</label></div><br/><div class="children"><div class="content">This is my (current) favorite list comprehension: <a href="https:&#x2F;&#x2F;github.com&#x2F;huggingface&#x2F;datasets&#x2F;blob&#x2F;871eabc7b23c27d677bc06ae2cc1ec3a2a04b10f&#x2F;src&#x2F;datasets&#x2F;data_files.py#L382">https:&#x2F;&#x2F;github.com&#x2F;huggingface&#x2F;datasets&#x2F;blob&#x2F;871eabc7b23c27d...</a> Someone was feeling awfully clever that day. (Not that I&#x27;m not occasionally guilty myself.)</div><br/></div></div></div></div><div id="41228504" class="c"><input type="checkbox" id="c-41228504" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225939">parent</a><span>|</span><a href="#41226319">prev</a><span>|</span><a href="#41231970">next</a><span>|</span><label class="collapse" for="c-41228504">[-]</label><label class="expand" for="c-41228504">[2 more]</label></div><br/><div class="children"><div class="content">Rust:<p><pre><code>    let results = foo
        .into_iter()
        .filter(|s| s.contains(&quot;banned&quot;))
        .collect::&lt;Vec&lt;&amp;str&gt;&gt;();
</code></pre>
C#:<p><pre><code>    var results = foo
        .Where(s =&gt; s.Contains(&quot;banned&quot;))
        .ToArray();
</code></pre>
Convenient, easy to understand <i>and</i> fast.</div><br/><div id="41228661" class="c"><input type="checkbox" id="c-41228661" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41228504">parent</a><span>|</span><a href="#41231970">next</a><span>|</span><label class="collapse" for="c-41228661">[-]</label><label class="expand" for="c-41228661">[1 more]</label></div><br/><div class="children"><div class="content">I think Rusts terseness shows here - I think C#&#x27;s approach is the best. Also, if you don&#x27;t use `.ToArray()`, you still have an IEnumerable which is very usable.</div><br/></div></div></div></div></div></div><div id="41231970" class="c"><input type="checkbox" id="c-41231970" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225193">parent</a><span>|</span><a href="#41225939">prev</a><span>|</span><a href="#41229689">next</a><span>|</span><label class="collapse" for="c-41231970">[-]</label><label class="expand" for="c-41231970">[1 more]</label></div><br/><div class="children"><div class="content">Filtering a container by a predicate is 50 year old technology and a very common thing. It&#x27;s unbelievable that a &quot;modern&quot; language has no shorter or clearer idiom than that convoluted boilerplate filled Ministry of Silly Walks blob. Python had filter() and then got list comprehensions from Haskell list comprehensions. PowerShell has Where-Object taking from C# LINQ .Where() which takes from SQL&#x27;s WHERE. Prolog has include&#x2F;3 which goes back to sublist(Test, Longer, Shorter) and LISP-Machine LISP had sublist in the 1970s[1]. APL has single character &#x2F; compressing an array from a bitmask result of a Boolean test in the original APL&#x2F;360 in 1968 and it was described in the book in 1962[2].<p>Brian Kernighan gave a talk on the readability of code and not getting too clever[3] &quot;Elements of Programming Style&quot; where he talks about languages having one way to write one thing so that you can spot mistakes easily. I am aware he&#x27;s one of the Go designers and I will mention that again in a moment. In Python the non-list-comprehension version might be:<p><pre><code>    result = []
    for x in foo:
        if &quot;banned&quot; in x:
            result.append(x)
</code></pre>
Which is still clearer than the Go, simply by having less going on. I usually argue that &quot;readable&quot; merely means &quot;familiar&quot; and Python is familiar to me and Go isn&#x27;t. Your Go code makes me wonder:<p>- &quot;var&quot; in C# does type inference. You declare []string but don&#x27;t declare types for _ x or the tuple _,x what&#x27;s up with the partial type inference? What is &quot;var&quot; adding to the code over classic &quot;int x&quot; style variable declarations?<p>- What is &quot;range&quot; doing? From _ I guess it does enumeration and that&#x27;s a throwaway for the index (if so it has an unclear name). If you have to enumerate and throw away the index into _ because there isn&#x27;t another way to iterate then why does keyword &quot;range&quot; need to exist? Conversely if there are other ways to iterate and the keyword &quot;range&quot; is optional, why do it this way with a variable taking up visual space only to be thrown away? (The code equivalent of saying &quot;for some reason&quot; and drawing the audience&#x27;s attention to ... nothing). And why is range a keyword instead of a function call, e.g. Python&#x27;s &quot;for (idx, elem) in enumerate(foo):&quot; ?<p>- Why is there assignment using both := and = ?<p>- Why string.Contains() with a module name and capital letter but append() with no module and all lowercase? Is there an unwritten import for &quot;strings&quot;?<p>- The order of arguments to Contains() and append(); Prof. Kernighan calls this out at 10m10s in that talk. C# has named arguments[3] or the object.Method() style haystack.Contains(needle) is clear, but the Go code has neither. It would be Bad Prolog(tm) to make a predicate Contains(String1, StringA) because it&#x27;s not clear which way round it works, but &quot;string_a in string_1&quot; is clear in Python because it reads like English. AFAIK a compiler&#x2F;type system can&#x27;t help here as both arguments are strings, so it&#x27;s more important that the style helps a reader notice if the arguments are accidentally the wrong way around, and this doesn&#x27;t. We could ask the same about the _, x  as well.<p>- &quot;result =&quot; looks like it&#x27;s overwriting the variable each time through the loop (which would be a common beginner mistake in other languages). If append is not modifying in place and instead returning a new array, is that a terrible performance hit like it is in C#? Python list comprehensions are explicitly making a completely new list, but if the Go code said &quot;result2 = append(result, x)&quot; is it valid to keep variable &quot;result&quot; from before the append, or invalid, or a subtle bug? The reader has to think of it, and know the answer, the Python code avoids that completely.<p>- And of course the forever curly brace &#x2F; indent question - are the closing } <i>really</i> ending the indented block that they look like they are ending judging from the dedent? I hear Go has mandatory formatting which might make that a non-issue, but this specific Python line has no block indentation at all so it&#x27;s less than a non-issue.<p>- The Python has five symbols =[&quot;&quot;] to mentally parse, pair and deal with, compared to twenty []_,:={.(,&quot;&quot;){=(,)}} in the Go.<p>Step back from those details to ask &quot;what is the code trying to achieve, and is this code achieving the goal?&quot; in the Go the core test &quot;.Contains()&quot; is hiding in the middle of the six lines. I&#x27;m not going to say you need to be able to read a language without learning it, but in the long-form Python what is there even to wonder about? B. Kernighan calls that out about 12:50 in the talk &quot;you get the sense the person who is writing the code doesn&#x27;t really understand the language properly&quot;. You say code is meant to be read more than written, and I claim it&#x27;s more likely that a reader won&#x27;t understand details, than will. Which means code with fewer details and which &quot;just works&quot; the way it looks like (Pythonic) is more readable. As BWK said in the talk &quot;It&#x27;s not that you <i>can&#x27;t</i> understand [the Go], it&#x27;s that you have to work at it, and you shouldn&#x27;t have to work at it for a task this simple&quot;.<p>[1] <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;comments&#x2F;14tvuta&#x2F;where_did_filter_map_reduce_originate&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;comments&#x2F;14tvu...</a><p>[2] <a href="https:&#x2F;&#x2F;keiapl.org&#x2F;archive&#x2F;APL360_UsersMan_Aug1968.pdf" rel="nofollow">https:&#x2F;&#x2F;keiapl.org&#x2F;archive&#x2F;APL360_UsersMan_Aug1968.pdf</a> 3.38 or PDF page 94, dating back to the original A Programming Language (APL) book in 1962, source <a href="https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;Replicate#History" rel="nofollow">https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;Replicate#History</a><p>[3] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8SUkrR7ZfTA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8SUkrR7ZfTA</a><p>[4] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;programming-guide&#x2F;classes-and-structs&#x2F;named-and-optional-arguments" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;programming-...</a></div><br/></div></div><div id="41229689" class="c"><input type="checkbox" id="c-41229689" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225193">parent</a><span>|</span><a href="#41231970">prev</a><span>|</span><a href="#41225229">next</a><span>|</span><label class="collapse" for="c-41229689">[-]</label><label class="expand" for="c-41229689">[1 more]</label></div><br/><div class="children"><div class="content"><i>”Is &lt;python code&gt; really actually more readable than &lt;go code&gt;?”</i><p>I mean, I mostly work in Python, but, yes absolutely.<p>There’s something to be said for locality of behavior. If I can see 6x as many lines at once that’s worth a lot in my experience.<p>This becomes blatantly apparent in other languages where we need 10 files open just to understand the code path of some inheritance hierarchy. And it’s not nearly that extreme in go, but the principle is the same.<p>But there is something to be said for the one way to do it, and not overthinking it.</div><br/></div></div><div id="41225229" class="c"><input type="checkbox" id="c-41225229" checked=""/><div class="controls bullet"><span class="by">aaomidi</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225193">parent</a><span>|</span><a href="#41229689">prev</a><span>|</span><a href="#41225253">next</a><span>|</span><label class="collapse" for="c-41225229">[-]</label><label class="expand" for="c-41225229">[2 more]</label></div><br/><div class="children"><div class="content">The new lines were eaten so it does make the python version more readable but I agree with you.</div><br/><div id="41226163" class="c"><input type="checkbox" id="c-41226163" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225229">parent</a><span>|</span><a href="#41225253">next</a><span>|</span><label class="collapse" for="c-41226163">[-]</label><label class="expand" for="c-41226163">[1 more]</label></div><br/><div class="children"><div class="content">Thanks - updated!</div><br/></div></div></div></div><div id="41225253" class="c"><input type="checkbox" id="c-41225253" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225193">parent</a><span>|</span><a href="#41225229">prev</a><span>|</span><a href="#41225048">next</a><span>|</span><label class="collapse" for="c-41225253">[-]</label><label class="expand" for="c-41225253">[8 more]</label></div><br/><div class="children"><div class="content">Go has real enums. All an enum does is count.<p>You&#x27;re probably thinking of value constraints? Or, perhaps, exhaustive case analysis? Go certainly lacks those future.<p>And, indeed, they sound like nice features, but, to be fair, not well supported in any popular programming language. At best we get some half-assery. Which always questions if the popular languages are popular <i>because</i> of their lacking type systems?</div><br/><div id="41226212" class="c"><input type="checkbox" id="c-41226212" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225253">parent</a><span>|</span><a href="#41225048">next</a><span>|</span><label class="collapse" for="c-41226212">[-]</label><label class="expand" for="c-41226212">[7 more]</label></div><br/><div class="children"><div class="content">This topic has been beaten to death, and being pedantic about the definition of an enum to say &quot;actually go has them&quot; isn&#x27;t helpful. There are dozens of articles from the last decade which explain the problems. Those problems don&#x27;t exist in plenty of programming languages.<p>No language is perfect, but go&#x27;s particular set of bugbears is a good tradeoff</div><br/><div id="41226431" class="c"><input type="checkbox" id="c-41226431" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41226212">parent</a><span>|</span><a href="#41225048">next</a><span>|</span><label class="collapse" for="c-41226431">[-]</label><label class="expand" for="c-41226431">[6 more]</label></div><br/><div class="children"><div class="content"><i>&gt; being pedantic about the definition of an enum to say &quot;actually go has them&quot; isn&#x27;t helpful.</i><p>Incorrect. The term &quot;real enums&quot;, where used to imply that enums are something other than the basic element of the same name, encompasses a number of distinct features that are completely independent of each other. In order to meaningfully talk about &quot;real enums&quot;, we need to break it down into the individual parts.<p>If you&#x27;re just trolling in bad faith, sure, leave it at &quot;real enums&quot; to prevent any discussion from taking place, but the rules of the site make it pretty clear that is not the intent of Hacker News.<p><i>&gt; Those problems don&#x27;t exist in plenty of programming languages.</i><p>Plenty, but none popular. Of the popular programming languages, Typescript seems to try the hardest, but even then just barely shows some semblance of supporting those features – still only providing support in some very narrow cases. The problems these features intend to solve are still very much present in general.</div><br/><div id="41229921" class="c"><input type="checkbox" id="c-41229921" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41226431">parent</a><span>|</span><a href="#41229839">next</a><span>|</span><label class="collapse" for="c-41229921">[-]</label><label class="expand" for="c-41229921">[2 more]</label></div><br/><div class="children"><div class="content">Words can have more than one meaning. As far as I know, no one voted you to be arbiter of all terms and their <i>One True Correct™</i> meaning. It&#x27;s pretty clear what the previous poster intended to say.</div><br/><div id="41232208" class="c"><input type="checkbox" id="c-41232208" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41229921">parent</a><span>|</span><a href="#41229839">next</a><span>|</span><label class="collapse" for="c-41232208">[-]</label><label class="expand" for="c-41232208">[1 more]</label></div><br/><div class="children"><div class="content">Quite clear, in fact, which is why we are able – in theory – to have a discussion about all the distinct features at play. If it weren&#x27;t clear, we wouldn&#x27;t be able to go there.<p>I say in theory, because as demonstrated by the sibling comment, there apparently isn&#x27;t much programming expertise around here. At least it was fascinating to see how a mind can go haywire when there isn&#x27;t a canned response to give.</div><br/></div></div></div></div><div id="41229839" class="c"><input type="checkbox" id="c-41229839" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41226431">parent</a><span>|</span><a href="#41229921">prev</a><span>|</span><a href="#41225048">next</a><span>|</span><label class="collapse" for="c-41229839">[-]</label><label class="expand" for="c-41229839">[3 more]</label></div><br/><div class="children"><div class="content">Dude. Everyone knew what &quot;real enums&quot; meant <i>including you</i>. Please stop.<p>And yes popular languages do have real type safe enums. C++, Typescript, Rust, god even Python.</div><br/><div id="41230701" class="c"><input type="checkbox" id="c-41230701" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41229839">parent</a><span>|</span><a href="#41225048">next</a><span>|</span><label class="collapse" for="c-41230701">[-]</label><label class="expand" for="c-41230701">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; And yes popular languages do have real type safe enums.</i><p>Right, as we already established, but which is only incredibly narrow support within the features in question. While you can find safety within the scope of enums and enums alone, it blows up as soon as you want the same safety applied to anything else. No popular language comes close to completing these features, doing it half-assed at most. We went over this several times now. Typescript goes a little further than most popular languages, but even it doesn&#x27;t go very far, leaving all kinds of gaps where the type system does not provide the aforementioned safety.<p>You clearly know how to read, by your own admission, so why are you flailing around like one of those wacky blow up men at the used car lot? Are you just not familiar with programming?</div><br/><div id="41233356" class="c"><input type="checkbox" id="c-41233356" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41230701">parent</a><span>|</span><a href="#41225048">next</a><span>|</span><label class="collapse" for="c-41233356">[-]</label><label class="expand" for="c-41233356">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Are you just not familiar with programming?<p>I am very familiar with programming. The only things you&#x27;ve said so far have been attempts to redefine well-understood terms and now ad hominem and incoherent rambling.<p>If you don&#x27;t have anything useful to say...</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41225048" class="c"><input type="checkbox" id="c-41225048" checked=""/><div class="controls bullet"><span class="by">Spartan-S63</span><span>|</span><a href="#41224877">parent</a><span>|</span><a href="#41225193">prev</a><span>|</span><a href="#41225164">next</a><span>|</span><label class="collapse" for="c-41225048">[-]</label><label class="expand" for="c-41225048">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this take. I find Rust a more exciting language from a personal project perspective—and it&#x27;s what I go with even when it doesn&#x27;t make 100% sense.<p>Go is fine, though, and works well in a team environment. It&#x27;s just clunky, but clunky in a productive way.</div><br/></div></div><div id="41225164" class="c"><input type="checkbox" id="c-41225164" checked=""/><div class="controls bullet"><span class="by">stuff4ben</span><span>|</span><a href="#41224877">parent</a><span>|</span><a href="#41225048">prev</a><span>|</span><a href="#41230622">next</a><span>|</span><label class="collapse" for="c-41225164">[-]</label><label class="expand" for="c-41225164">[3 more]</label></div><br/><div class="children"><div class="content">Damn, everything new really is old again. Everyone said the same thing about Java. Yet it still works and gets the job done. Go does as well. I&#x27;d rather poke my eyes out with a nail than use Python.</div><br/><div id="41230193" class="c"><input type="checkbox" id="c-41230193" checked=""/><div class="controls bullet"><span class="by">matwood</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225164">parent</a><span>|</span><a href="#41225273">next</a><span>|</span><label class="collapse" for="c-41230193">[-]</label><label class="expand" for="c-41230193">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d rather poke my eyes out with a nail than use Python.<p>Glad I&#x27;m not the only one. Every time I&#x27;m forced to use Python I cringe. What version disaster and I&#x27;m going to run into today? The 2-&gt;3 transition happened a long time ago at this point and I still run into lingering effects. Also, for short &#x27;script&#x27; like things Python doesn&#x27;t feel any quicker or easier to write. Go is my Goto (hehe) for short scripts.<p>And while I&#x27;m ranting, I&#x27;ll also say that modern&#x2F;latest version Java is also really nice.</div><br/></div></div><div id="41225273" class="c"><input type="checkbox" id="c-41225273" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225164">parent</a><span>|</span><a href="#41230193">prev</a><span>|</span><a href="#41230622">next</a><span>|</span><label class="collapse" for="c-41225273">[-]</label><label class="expand" for="c-41225273">[1 more]</label></div><br/><div class="children"><div class="content">Do you write Go for fun as hobby, or do you agree with the OP?</div><br/></div></div></div></div><div id="41230622" class="c"><input type="checkbox" id="c-41230622" checked=""/><div class="controls bullet"><span class="by">georgeecollins</span><span>|</span><a href="#41224877">parent</a><span>|</span><a href="#41225164">prev</a><span>|</span><a href="#41229981">next</a><span>|</span><label class="collapse" for="c-41230622">[-]</label><label class="expand" for="c-41230622">[3 more]</label></div><br/><div class="children"><div class="content">I feel like autocomplete has reduced the problem of verbosity for all languages.  And if I am writing something that is going to have to be supported a lot I want something that is very explicit and easy to read.  For me that is the &quot;verbose&quot; languages.</div><br/><div id="41231898" class="c"><input type="checkbox" id="c-41231898" checked=""/><div class="controls bullet"><span class="by">robinsonrc</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41230622">parent</a><span>|</span><a href="#41230761">next</a><span>|</span><label class="collapse" for="c-41231898">[-]</label><label class="expand" for="c-41231898">[1 more]</label></div><br/><div class="children"><div class="content">I feel the opposite way about this, and find this kind of verbosity reduces the signal to noise of the intention behind the code</div><br/></div></div><div id="41230761" class="c"><input type="checkbox" id="c-41230761" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41230622">parent</a><span>|</span><a href="#41231898">prev</a><span>|</span><a href="#41229981">next</a><span>|</span><label class="collapse" for="c-41230761">[-]</label><label class="expand" for="c-41230761">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly what I was going to say... ever since I started using Copilot, verbosity bothers me a lot less. It isn&#x27;t painful when I don&#x27;t have to type&#x2F;copy&#x2F;etc most of it.</div><br/></div></div></div></div><div id="41230911" class="c"><input type="checkbox" id="c-41230911" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#41224877">parent</a><span>|</span><a href="#41229981">prev</a><span>|</span><a href="#41225233">next</a><span>|</span><label class="collapse" for="c-41230911">[-]</label><label class="expand" for="c-41230911">[1 more]</label></div><br/><div class="children"><div class="content">For personal stuff I use use groovy.<p>Has the jvm and jdk and all the associated jars &#x2F;library ecosystem?<p>Has tons of really good stuff from python&#x2F;Ruby<p>Typing is optional so you can get full speed, static typing, but you can go dynamic when you need it.<p>That said, it&#x27;s basically a deadend language career wise.</div><br/></div></div><div id="41225233" class="c"><input type="checkbox" id="c-41225233" checked=""/><div class="controls bullet"><span class="by">kjksf</span><span>|</span><a href="#41224877">parent</a><span>|</span><a href="#41230911">prev</a><span>|</span><a href="#41232072">next</a><span>|</span><label class="collapse" for="c-41225233">[-]</label><label class="expand" for="c-41225233">[4 more]</label></div><br/><div class="children"><div class="content">So you&#x27;re ok with Python, which doesn&#x27;t have sum types or null safety, 2 out of 3 things you say are missing in Go.<p>In fact, Python didn&#x27;t have any compile-type type until recently and compared to Go is slow and bloated.<p>So maybe the issue is not Go&#x27;s lacking some features but something entirely different.</div><br/><div id="41225465" class="c"><input type="checkbox" id="c-41225465" checked=""/><div class="controls bullet"><span class="by">lairv</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225233">parent</a><span>|</span><a href="#41225750">next</a><span>|</span><label class="collapse" for="c-41225465">[-]</label><label class="expand" for="c-41225465">[2 more]</label></div><br/><div class="children"><div class="content">class A:
     def __init__():
  pass
     def f(self):
  pass<p>def g(a: A | None):
     a.f()<p>(edit: I don&#x27;t know how to format code on HN)<p>If I activate type-checking in VS Code this will highlight an error, although the python interpreter will indeed try to run it without compile time error<p>As I said, for my side projects this is enough for me to model my problems properly without having to resort to multiple hacks<p>And I took Python as an example, I also enjoy using Ocaml and Rust</div><br/><div id="41226876" class="c"><input type="checkbox" id="c-41226876" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225465">parent</a><span>|</span><a href="#41225750">next</a><span>|</span><label class="collapse" for="c-41226876">[-]</label><label class="expand" for="c-41226876">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t know how to format code on HN<p>two spaces: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;formatdoc">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;formatdoc</a></div><br/></div></div></div></div><div id="41225750" class="c"><input type="checkbox" id="c-41225750" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#41224877">root</a><span>|</span><a href="#41225233">parent</a><span>|</span><a href="#41225465">prev</a><span>|</span><a href="#41232072">next</a><span>|</span><label class="collapse" for="c-41225750">[-]</label><label class="expand" for="c-41225750">[1 more]</label></div><br/><div class="children"><div class="content">Mypy supports those for like 3-4 years already</div><br/></div></div></div></div></div></div><div id="41232072" class="c"><input type="checkbox" id="c-41232072" checked=""/><div class="controls bullet"><span class="by">WuxiFingerHold</span><span>|</span><a href="#41224877">prev</a><span>|</span><a href="#41224856">next</a><span>|</span><label class="collapse" for="c-41232072">[-]</label><label class="expand" for="c-41232072">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why Typescript is my hammer, unless I need a jack hammer, which is Rust.<p>With Deno and Typescript I get an even more versatile toolbox than with Go. And what&#x27;s even more important to me, Typescript is safer and more ergonomic than Go, but slightly slower. Rust is safer, more ergonomic and faster than Go, but much harder to learn.<p>Especially strict (which is a must) Typescript is underrated. Compared to Go, we get:<p>- null safety<p>- widely supported generics<p>- discriminated unions with either manually (some lines of code) or es-lint exhaustiveness checks<p>- much safer concurrency, as all Typescript code runs single-threaded. You need web workers, which are not as safe as Rust for concurrency, but much safer than Go.<p>- collection &#x2F; iterator methods<p>So far, I see only few downside. I&#x27;d be happy if people could provide more. Currently I&#x27;m scratching my head why I didn&#x27;t fall in love with Typescript (for backend and CLI) earlier. Maybe I haven&#x27;t seen the dark sides yet. So, some points where  Go is stronger than Typescript:<p>- Go is much more efficient in terms of size and memory usage<p>- Go&#x27;s GC is better than V8s<p>- Go is faster on CPU bound tasks<p>- Go has a greater std lib, however, Deno&#x27;s std lib is pretty nice as well.<p>- The ecosystem is smaller, but has not as much trash as NPM. The dependency trees with NPM are usually large. By the way, Rust has this problem as well, less than Typescript but more than Go. Still, many mainstream NPM packages are safe and rock solid.<p>What else could we say against Typescript (and preferably Deno or Bun)? I&#x27;m really eager to hear people having ditched it an why.</div><br/><div id="41232948" class="c"><input type="checkbox" id="c-41232948" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#41232072">parent</a><span>|</span><a href="#41232157">next</a><span>|</span><label class="collapse" for="c-41232948">[-]</label><label class="expand" for="c-41232948">[1 more]</label></div><br/><div class="children"><div class="content">- Typescript doesn&#x27;t protect you <i>at all</i> against external data.<p>- A Go program runs single-threaded, unless you explicitly tell it not too, so I don&#x27;t quite see that as a plus for Typescript.<p>- Go is quite a bit faster than Typescript.<p>- I haven&#x27;t had a versioning problem in Go, and I can still compile and run old code. Typescript still beats Python in that respect, but Go wins stability.<p>And I say this as someone who really likes Typescript. It&#x27;s a blessing for frontend browser work.</div><br/></div></div><div id="41232157" class="c"><input type="checkbox" id="c-41232157" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#41232072">parent</a><span>|</span><a href="#41232948">prev</a><span>|</span><a href="#41224856">next</a><span>|</span><label class="collapse" for="c-41232157">[-]</label><label class="expand" for="c-41232157">[2 more]</label></div><br/><div class="children"><div class="content">Amen. I was unreasonably opposed to TypeScript at first after lots of bad experiences with messy JavaScript when I was first learning development - but after immersing myself in it for a year or so at $NEW_JOB, I absolutely love it. The only ways in which I can see that Go outperforms TypeScript is in performance, but frankly I don&#x27;t care and most developers shouldn&#x27;t - unless you&#x27;re writing truly low-level high-performance utilities, you should (within reason) bias for being able to write (and iterate) fast over being able to execute fast. You can always re-write in Rust if you find that performance is a bottleneck.</div><br/><div id="41232356" class="c"><input type="checkbox" id="c-41232356" checked=""/><div class="controls bullet"><span class="by">Escapado</span><span>|</span><a href="#41232072">root</a><span>|</span><a href="#41232157">parent</a><span>|</span><a href="#41224856">next</a><span>|</span><label class="collapse" for="c-41232356">[-]</label><label class="expand" for="c-41232356">[1 more]</label></div><br/><div class="children"><div class="content">I have been using typescript as my primary language for years and since I am used to it I actually enjoy it (much more than I enjoyed Java or Python in the past). And depending on what you built I agree, especially for one off scripts or if you plan on hosting just one or two things somewhere. On the other hand I recently saw a video by webdev Cody that got me thinking, where he was comparing a dead simple api server in go and in bun hosted on railway and their memory usage was different by an order of magnitude in favour of go plus you can compile your program down to a few megabytes instead of bundling a ~100megabyte runtime. So if you have a couple dozen of side projects where you host servers&#x2F;apis that difference can end up in a noticeable operating cost differential. He made a few other points such as throughput, the more complete standard library and tooling such as go fmt and that writing the equivalent server in go wasn’t really all that different from the typescript code.
You’re right that rewriting is always an option but for all over the place folks like me the next 3 projects are half done before I even think about optimising my hosting bill. But as I said, strongly depends on what you build.<p>I guess there are no winners, just tradeoffs.<p>I wonder if one use case for llms in the future could be feeding a sizeable typescript&#x2F;python codebase into it and then have it spit out an equivalent in idiomatic rust&#x2F;zig&#x2F;c. I am aware that transpilers and assembly script and static Hermes exist but what I mean is more of a result that produces a maintainable rewritten version making use of the idiomatic libraries and coding conventions of the target language.</div><br/></div></div></div></div></div></div><div id="41224856" class="c"><input type="checkbox" id="c-41224856" checked=""/><div class="controls bullet"><span class="by">ManBeardPc</span><span>|</span><a href="#41232072">prev</a><span>|</span><a href="#41225137">next</a><span>|</span><label class="collapse" for="c-41224856">[-]</label><label class="expand" for="c-41224856">[1 more]</label></div><br/><div class="children"><div class="content">Go is my favorite general-purpose tool (combination of language + standard library + 3rd party libraries + tooling + documentation). Everything just works out of the box and is simple to use and understand. No collection of dozens of external tools with fiddly configuration, a simple command to compile and simple deployment via a single executable with no additional setup required. No other language gives me such a simple and hassle-free all-around experience.<p>I certainly think other languages (Java, C#, Rust, JS&#x2F;TS) have a lot of advantages over Go in some areas, but everything I&#x27;ve worked with so far has some other aspects that I absolutely hate.<p>POV from a (mainly) B2B fullstack SE</div><br/></div></div><div id="41225137" class="c"><input type="checkbox" id="c-41225137" checked=""/><div class="controls bullet"><span class="by">cybrexalpha</span><span>|</span><a href="#41224856">prev</a><span>|</span><a href="#41229166">next</a><span>|</span><label class="collapse" for="c-41225137">[-]</label><label class="expand" for="c-41225137">[18 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been coding in Go for over five years. I <i>like</i> Go, but I don&#x27;t <i>love</i> it. It&#x27;s never my first choice, although I don&#x27;t advocate for rewrites just to move away from it.<p>The tooling is a mess. Go modules still feel like a &#x27;first pass&#x27; implementation that never got finished. There&#x27;s no consistency in formatting or imports (even though Go claims there is). Generics are a good step but are still very primitive (no generics on interfaces, no types as a first-class object).<p>It still feels very unfinished as an ecosystem. I hope it&#x27;ll get better as the Go team mature things, like iterating on generics. But I can&#x27;t see Go modules continuing without a fundamental rewrite.</div><br/><div id="41226176" class="c"><input type="checkbox" id="c-41226176" checked=""/><div class="controls bullet"><span class="by">icholy</span><span>|</span><a href="#41225137">parent</a><span>|</span><a href="#41225384">next</a><span>|</span><label class="collapse" for="c-41226176">[-]</label><label class="expand" for="c-41226176">[5 more]</label></div><br/><div class="children"><div class="content">Not sure what you&#x27;re comparing to, but Go modules are probably the best dependency management system in any language.</div><br/><div id="41227322" class="c"><input type="checkbox" id="c-41227322" checked=""/><div class="controls bullet"><span class="by">cybrexalpha</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41226176">parent</a><span>|</span><a href="#41226192">next</a><span>|</span><label class="collapse" for="c-41227322">[-]</label><label class="expand" for="c-41227322">[3 more]</label></div><br/><div class="children"><div class="content">It does a lot well. For example it correctly pins dependencies by hash in go.sum. It&#x27;s by no means the worst dependency management system I&#x27;ve ever used.<p>IMO the biggest miss with Go modules is conflating the identity of a dependency with how you get it. This means that renaming a repo not only breaks the module itself (as you self-import other modules in the same source tree using the full path), but all of your dependencies. I&#x27;ve seen repos be renamed from github.com&#x2F;foo&#x2F;proj to github.com&#x2F;bar&#x2F;proj as part of organisational reshuffles, and then there&#x27;s a big warning somewhere that says &quot;never make a github.com&#x2F;foo&#x2F;proj repo or it&#x27;ll break GitHub&#x27;s automatic forwarding for renamed repos, and you&#x27;ll break every package that depends on us.&quot;<p>There are workarounds like using replace directives. But that makes an even worse situation where you can read a source file and assume a dependency is at github.com&#x2F;foo&#x2F;proj but actually it&#x27;s elsewhere. But ultimately a real fix involves touching every single file that imports your dependency. If Go modules left the way of pulling a dependency in go.mod alone it wouldn&#x27;t.<p>You <i>should</i> use a Go modules proxy to solve this, and a custom import path. But by the time most orgs realise they need this it&#x27;s too late and adopting one would be a huge change. So you end up with a patchwork of import issues.</div><br/><div id="41229204" class="c"><input type="checkbox" id="c-41229204" checked=""/><div class="controls bullet"><span class="by">icholy</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41227322">parent</a><span>|</span><a href="#41226192">next</a><span>|</span><label class="collapse" for="c-41229204">[-]</label><label class="expand" for="c-41229204">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But ultimately a real fix involves touching every single file that imports your dependency.<p>Why is that a problem?</div><br/><div id="41231121" class="c"><input type="checkbox" id="c-41231121" checked=""/><div class="controls bullet"><span class="by">cybrexalpha</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41229204">parent</a><span>|</span><a href="#41226192">next</a><span>|</span><label class="collapse" for="c-41231121">[-]</label><label class="expand" for="c-41231121">[1 more]</label></div><br/><div class="children"><div class="content">For an internal-only dependency it&#x27;s possible. But if you&#x27;ve got a lot of active branches, or long-lived feature branches, it&#x27;ll create chaos in merge conflicts. Even worse if you&#x27;ve got multiple supported versions of a product on release branches (e.g., `main-v1.0`, `main-v1.1`, `main-v1.2`, and `main` itself for the yet-to-be-released `v1.3`) you either make backports awful (by only changing the import path on `main`) or have to change even more things (by changing the import path on the release branches too).<p>It&#x27;s effectively impossible for pubic-facing dependencies. Imagine if <a href="https:&#x2F;&#x2F;github.com&#x2F;sirupsen&#x2F;logrus">https:&#x2F;&#x2F;github.com&#x2F;sirupsen&#x2F;logrus</a> wanted to change their Go modules import path, for example to move to another git hosting provider. (Logrus is great by the way, I&#x27;m only &#x27;picking&#x27; on it as a popular Go library that&#x27;s used everywhere.) GitHub tells me that almost 200,000 Go projects depend on it (<a href="https:&#x2F;&#x2F;github.com&#x2F;sirupsen&#x2F;logrus&#x2F;network&#x2F;dependents">https:&#x2F;&#x2F;github.com&#x2F;sirupsen&#x2F;logrus&#x2F;network&#x2F;dependents</a>), so all of them would need to change every source file they do logging in (probably most of them) in order to handle that.<p>GitHub seems like it&#x27;s going to be eternal for now, but when the industry moves on in 10 years time every single Go project is going to break. This would be a problem for any source dependency management solution of course, it&#x27;s not like any of the others are immune to this issue. But because Go has you encode the Git path in every source file you import it into, the level of change to fix it is an order of magnitude higher.</div><br/></div></div></div></div></div></div></div></div><div id="41225384" class="c"><input type="checkbox" id="c-41225384" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41225137">parent</a><span>|</span><a href="#41226176">prev</a><span>|</span><a href="#41225195">next</a><span>|</span><label class="collapse" for="c-41225384">[-]</label><label class="expand" for="c-41225384">[7 more]</label></div><br/><div class="children"><div class="content">Not sure what you mean by &quot;no generics on interfaces&quot;? <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;jGINeUt1JTE" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;jGINeUt1JTE</a><p>Also echoing not sure what you mean by &quot;no consistency in formatting or imports&quot;. It is increasingly difficult to use Go without gofmt getting run, since I have to imagine fewer and fewer people nowadays are using an editor that has neither custom support for their language nor LSP integration, and integration with gopls automatically runs goimports on save.</div><br/><div id="41225435" class="c"><input type="checkbox" id="c-41225435" checked=""/><div class="controls bullet"><span class="by">cybrexalpha</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41225384">parent</a><span>|</span><a href="#41225195">next</a><span>|</span><label class="collapse" for="c-41225435">[-]</label><label class="expand" for="c-41225435">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Not sure what you mean by &quot;no generics on interfaces&quot;?<p>I didn&#x27;t word this very well. You can have a generic interface, and functions on that interface can refer to generic types. But you can&#x27;t have a generic method on an interface that uses a different generic type. For example you can&#x27;t have:<p>```
type YieldThing[T any] interface {
 Yield() T
 DoOperation[U any](U)
}
```</div><br/><div id="41225569" class="c"><input type="checkbox" id="c-41225569" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41225435">parent</a><span>|</span><a href="#41225955">next</a><span>|</span><label class="collapse" for="c-41225569">[-]</label><label class="expand" for="c-41225569">[2 more]</label></div><br/><div class="children"><div class="content">I figured based on your comment you meant something by it.<p>In which case I&#x27;d point out that it goes beyond interfaces and Go just doesn&#x27;t permit that in general, for those who are playing along. All generics are always fully instantiated. You can have a<p><pre><code>    type Holder[T any, U any] struct {
        Val1 T
        Val2 U
    }
</code></pre>
but you can never have anything like a variable of type Holder[int], with a type-currying effect or something where the U bit is still unbound, or a bare variable of type &quot;Holder&quot; without any further parameters. All types within the language are always fully instantiated after compile.</div><br/><div id="41226708" class="c"><input type="checkbox" id="c-41226708" checked=""/><div class="controls bullet"><span class="by">cybrexalpha</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41225569">parent</a><span>|</span><a href="#41225955">next</a><span>|</span><label class="collapse" for="c-41226708">[-]</label><label class="expand" for="c-41226708">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I get it. I&#x27;ve found workarounds in the past. But it&#x27;s always involved some friction.<p>In general, Go&#x27;s generics are a huge step forward though. So I&#x27;m not that annoyed about it.</div><br/></div></div></div></div><div id="41225955" class="c"><input type="checkbox" id="c-41225955" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41225435">parent</a><span>|</span><a href="#41225569">prev</a><span>|</span><a href="#41225195">next</a><span>|</span><label class="collapse" for="c-41225955">[-]</label><label class="expand" for="c-41225955">[3 more]</label></div><br/><div class="children"><div class="content">There are good reasons for not allowing generic methods:<p><a href="https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;design&#x2F;43651-type-parameters.md#No-parameterized-methods" rel="nofollow">https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;des...</a></div><br/><div id="41229073" class="c"><input type="checkbox" id="c-41229073" checked=""/><div class="controls bullet"><span class="by">Nijikokun</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41225955">parent</a><span>|</span><a href="#41225195">next</a><span>|</span><label class="collapse" for="c-41229073">[-]</label><label class="expand" for="c-41229073">[2 more]</label></div><br/><div class="children"><div class="content">Realistically the reasons are this:<p>&gt; So while parameterized methods seem clearly useful at first glance, we would have to decide what they mean and how to implement that.<p>They just didn&#x27;t want to decide what they mean or how to implement them.</div><br/><div id="41230028" class="c"><input type="checkbox" id="c-41230028" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41229073">parent</a><span>|</span><a href="#41225195">next</a><span>|</span><label class="collapse" for="c-41230028">[-]</label><label class="expand" for="c-41230028">[1 more]</label></div><br/><div class="children"><div class="content">Right, but that&#x27;s because it is not obvious what they should mean or how to implement them. In particular, it seems that intolerable complications to the linker would be required. Contrast that with, say, a proposal to add a more concise syntax to Go for anonymous functions. Everyone can see exactly what that would mean and how it would be implemented.<p>I&#x27;m not saying that Go should never add generic methods to the language. But it&#x27;s at least reasonable to hold off from doing so until these issues are clarified.<p>There is a concise explanation of the central problem in a comment in the issue thread:<p>&gt; The crux of the problem is that with a parametric method, the generated code for the body depends on the type-parameter (e.g. addition on integers requires different CPU instructions than addition of floating point numbers). So for a generic method call to succeed, you either need to know all combinations of type-arguments when compiling the body (so that you can generate all bodies in advance), or you need to know all possible concrete types that a dynamic call could get dispatched to, when compiling the call (so you can generate the bodies on demand). The example from the design doc breaks that: The method call is via an interface, so it can dispatch to many concrete types and the concrete type is passed as an interface, so the compiler doesn&#x27;t know the call sites.<p>Rust allows generic methods on traits but doesn&#x27;t allow these traits to be instantiated as trait objects. Perhaps Go could do something similar. <a href="https:&#x2F;&#x2F;docs.rs&#x2F;erased-generic-trait&#x2F;latest&#x2F;erased_generic_trait&#x2F;#:~:text=In%20Rust%2C%20only%20object%20safe,the%20generic%20methods%20in%20them" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;erased-generic-trait&#x2F;latest&#x2F;erased_generic_t...</a>. But it&#x27;s far from obvious to me that this would be a good idea for Go, and I&#x27;m glad the Go team haven&#x27;t rushed into anything here.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41225195" class="c"><input type="checkbox" id="c-41225195" checked=""/><div class="controls bullet"><span class="by">acedTrex</span><span>|</span><a href="#41225137">parent</a><span>|</span><a href="#41225384">prev</a><span>|</span><a href="#41229166">next</a><span>|</span><label class="collapse" for="c-41225195">[-]</label><label class="expand" for="c-41225195">[5 more]</label></div><br/><div class="children"><div class="content">What do you mean by no consistency in formatting? go fmt is a solid formatter that does its job</div><br/><div id="41225408" class="c"><input type="checkbox" id="c-41225408" checked=""/><div class="controls bullet"><span class="by">cybrexalpha</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41225195">parent</a><span>|</span><a href="#41233003">next</a><span>|</span><label class="collapse" for="c-41225408">[-]</label><label class="expand" for="c-41225408">[3 more]</label></div><br/><div class="children"><div class="content">Go fmt is pretty good, but it&#x27;s not ideal. My biggest gripe is imports. Go fmt will just sort imports alphabetically in lists that aren&#x27;t separated by a blank line. Goimports will separate out core from 3rd party imports, unless you run it with the local flag then it&#x27;ll add a third block of &quot;local&quot; imports.<p>But this spread means that it&#x27;s not consistent across projects which style is preferred.<p>Some examples, based on cursory looking at big Go codebases:
- Kubernetes, one of the biggest public-facing Go projects, uses the 3-block style <a href="https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;master&#x2F;pkg&#x2F;controller&#x2F;cronjob&#x2F;cronjob_controllerv2.go#L19">https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;master&#x2F;pkg&#x2F;con...</a>
- TIDB uses 2-block style <a href="https:&#x2F;&#x2F;github.com&#x2F;pingcap&#x2F;tidb&#x2F;blob&#x2F;master&#x2F;pkg&#x2F;ddl&#x2F;placement&#x2F;bundle.go">https:&#x2F;&#x2F;github.com&#x2F;pingcap&#x2F;tidb&#x2F;blob&#x2F;master&#x2F;pkg&#x2F;ddl&#x2F;placemen...</a>
- MinIO uses 2-block <a href="https:&#x2F;&#x2F;github.com&#x2F;minio&#x2F;minio&#x2F;blob&#x2F;master&#x2F;internal&#x2F;grid&#x2F;connection.go">https:&#x2F;&#x2F;github.com&#x2F;minio&#x2F;minio&#x2F;blob&#x2F;master&#x2F;internal&#x2F;grid&#x2F;con...</a><p>In all of those cases if you make a change and just run &#x27;go fmt&#x27; it very well could inject any new imports in the first block, which would be wrong and you wouldn&#x27;t know until project CI picks it up.</div><br/><div id="41230617" class="c"><input type="checkbox" id="c-41230617" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41225408">parent</a><span>|</span><a href="#41233003">next</a><span>|</span><label class="collapse" for="c-41230617">[-]</label><label class="expand" for="c-41230617">[2 more]</label></div><br/><div class="children"><div class="content">It sounds to me like there are some people who don&#x27;t follow the style, rather than there not being a consistent style.</div><br/><div id="41231132" class="c"><input type="checkbox" id="c-41231132" checked=""/><div class="controls bullet"><span class="by">cybrexalpha</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41230617">parent</a><span>|</span><a href="#41233003">next</a><span>|</span><label class="collapse" for="c-41231132">[-]</label><label class="expand" for="c-41231132">[1 more]</label></div><br/><div class="children"><div class="content">Which of those options do you view as &#x27;the style&#x27;? One block, two blocks (core library and others), or three (core library, 3rd party, same-source-tree).</div><br/></div></div></div></div></div></div><div id="41233003" class="c"><input type="checkbox" id="c-41233003" checked=""/><div class="controls bullet"><span class="by">Mesopropithecus</span><span>|</span><a href="#41225137">root</a><span>|</span><a href="#41225195">parent</a><span>|</span><a href="#41225408">prev</a><span>|</span><a href="#41229166">next</a><span>|</span><label class="collapse" for="c-41233003">[-]</label><label class="expand" for="c-41233003">[1 more]</label></div><br/><div class="children"><div class="content">Funnily, 1.5 decades after Golang popularized formatters, in 2024 it is the only language that I work in that requires me to think about formatting. Mostly line length, but super annoying.</div><br/></div></div></div></div></div></div><div id="41229166" class="c"><input type="checkbox" id="c-41229166" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#41225137">prev</a><span>|</span><a href="#41228580">next</a><span>|</span><label class="collapse" for="c-41229166">[-]</label><label class="expand" for="c-41229166">[18 more]</label></div><br/><div class="children"><div class="content">I really like most aspects of Go, but as someone who writes a lot of numerical code, no operator overloading is a deal breaker. It&#x27;s so hard to accept something like Add(Scale(s1, vec1), Scale(s2, vec2)) over s1 * vec1 + s2 * vec2. So I stick with Python and C++ for now.<p>Rust is really appealing as a C++ replacement, but it has too many rules to replace Python for one-off scripts. Still need to try Nim and Swift, I guess...</div><br/><div id="41232993" class="c"><input type="checkbox" id="c-41232993" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#41229166">parent</a><span>|</span><a href="#41229497">next</a><span>|</span><label class="collapse" for="c-41232993">[-]</label><label class="expand" for="c-41232993">[1 more]</label></div><br/><div class="children"><div class="content">In the same line of reasoning, Go also doesn&#x27;t support getters&#x2F;setters. You can&#x27;t write v.a = 1 and expect it to call v.SetA(1). And that&#x27;s a good thing. Cosmetically, because it avoids that all thickheads add a trivial get&#x2F;set for each and every member. Functionally, because it can make code appear to do something it doesn&#x27;t do, and this also goes for other operator overloading.<p>I&#x27;ve worked on C# code where db.open was a test to check for a database connection, but assigning to it would open or close the database. It should simply not be possible to hide that behind an assignment symbol. It&#x27;s like having db.Query(...) delete the data.</div><br/></div></div><div id="41229497" class="c"><input type="checkbox" id="c-41229497" checked=""/><div class="controls bullet"><span class="by">SatvikBeri</span><span>|</span><a href="#41229166">parent</a><span>|</span><a href="#41232993">prev</a><span>|</span><a href="#41230931">next</a><span>|</span><label class="collapse" for="c-41229497">[-]</label><label class="expand" for="c-41229497">[3 more]</label></div><br/><div class="children"><div class="content">We switched from Python to Julia for numeric code. It&#x27;s generally much faster (and easier to optimize), and has slightly better syntax for mathy code.<p>It&#x27;s worth noting that Julia is very similar to go, despite superficial differences. They&#x27;re both small languages with big libraries, use the same concurrency model, use a mark-and-sweep GC with an emphasis on making it easy for the programmer to reduce garbage&#x2F;allocations, and both use structs + functions rather than classes.</div><br/><div id="41232557" class="c"><input type="checkbox" id="c-41232557" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41229497">parent</a><span>|</span><a href="#41230931">next</a><span>|</span><label class="collapse" for="c-41232557">[-]</label><label class="expand" for="c-41232557">[2 more]</label></div><br/><div class="children"><div class="content">Julia looks like a great language, but has the &quot;time to first plot&quot; issue been fixed yet? I don&#x27;t want a REPL-centric workflow.</div><br/><div id="41232672" class="c"><input type="checkbox" id="c-41232672" checked=""/><div class="controls bullet"><span class="by">SatvikBeri</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41232557">parent</a><span>|</span><a href="#41230931">next</a><span>|</span><label class="collapse" for="c-41232672">[-]</label><label class="expand" for="c-41232672">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s vastly faster than it was before (~5s compared to ~40s for the Plots package, and much less for most workflows) but it can never drop to 0, since it&#x27;s compiling each function the first time you use it.<p>Though honestly if you don&#x27;t want a REPL or notebook-centric workflow, I would probably recommend a different language.</div><br/></div></div></div></div></div></div><div id="41230931" class="c"><input type="checkbox" id="c-41230931" checked=""/><div class="controls bullet"><span class="by">bouncycastle</span><span>|</span><a href="#41229166">parent</a><span>|</span><a href="#41229497">prev</a><span>|</span><a href="#41229572">next</a><span>|</span><label class="collapse" for="c-41230931">[-]</label><label class="expand" for="c-41230931">[3 more]</label></div><br/><div class="children"><div class="content">in my case, I prefer to see that the code is calling functions, so that I&#x27;m aware that they take extra resources such as stack space and it&#x27;s easy to quickly jump into the functions to find what they are doing. Code that uses op overloading is hard to navigate and sometimes causes intense debugging pain. Simplicity always beats fancy features imo.</div><br/><div id="41232577" class="c"><input type="checkbox" id="c-41232577" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41230931">parent</a><span>|</span><a href="#41231396">next</a><span>|</span><label class="collapse" for="c-41232577">[-]</label><label class="expand" for="c-41232577">[1 more]</label></div><br/><div class="children"><div class="content">Operator overloading can be bad when abused for non-numeric types. But for numeric types, it is indispensable.<p>It&#x27;s not hard to remember that `__add__` is using extra resources when I&#x27;m working with big matrices in NumPy.</div><br/></div></div><div id="41231396" class="c"><input type="checkbox" id="c-41231396" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41230931">parent</a><span>|</span><a href="#41232577">prev</a><span>|</span><a href="#41229572">next</a><span>|</span><label class="collapse" for="c-41231396">[-]</label><label class="expand" for="c-41231396">[1 more]</label></div><br/><div class="children"><div class="content">Functions, especially functions like numerical operations, tend to get trivially inlined and consume no stack space.</div><br/></div></div></div></div><div id="41229572" class="c"><input type="checkbox" id="c-41229572" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#41229166">parent</a><span>|</span><a href="#41230931">prev</a><span>|</span><a href="#41229333">next</a><span>|</span><label class="collapse" for="c-41229572">[-]</label><label class="expand" for="c-41229572">[1 more]</label></div><br/><div class="children"><div class="content">Numerical programs seems like a great fit for DSLs, say Starlark[0] ;-) That&#x27;s what many C++ libs basically achieve with their heavy use of overloading, tmp, etc<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;starlark-go">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;starlark-go</a> or alternatively <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;starlark-rust">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;starlark-rust</a></div><br/></div></div><div id="41229333" class="c"><input type="checkbox" id="c-41229333" checked=""/><div class="controls bullet"><span class="by">gcau</span><span>|</span><a href="#41229166">parent</a><span>|</span><a href="#41229572">prev</a><span>|</span><a href="#41229435">next</a><span>|</span><label class="collapse" for="c-41229333">[-]</label><label class="expand" for="c-41229333">[5 more]</label></div><br/><div class="children"><div class="content">Is this something Go intentionally didn&#x27;t add?</div><br/><div id="41229612" class="c"><input type="checkbox" id="c-41229612" checked=""/><div class="controls bullet"><span class="by">jagged-chisel</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41229333">parent</a><span>|</span><a href="#41230293">next</a><span>|</span><label class="collapse" for="c-41229612">[-]</label><label class="expand" for="c-41229612">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Because &quot;things are simpler without it.&quot; Presumably &quot;simpler&quot; from the point of view of the language implementer as opposed to the user of the language.</div><br/></div></div><div id="41230293" class="c"><input type="checkbox" id="c-41230293" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41229333">parent</a><span>|</span><a href="#41229612">prev</a><span>|</span><a href="#41229373">next</a><span>|</span><label class="collapse" for="c-41230293">[-]</label><label class="expand" for="c-41230293">[2 more]</label></div><br/><div class="children"><div class="content">Operator overloading essentially makes code unreadable without deep diving past the interface boundary.<p>In Go, you can generally look at any snippet of code and know <i>precisely</i> what it does.</div><br/><div id="41233427" class="c"><input type="checkbox" id="c-41233427" checked=""/><div class="controls bullet"><span class="by">dsfasfd</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41230293">parent</a><span>|</span><a href="#41229373">next</a><span>|</span><label class="collapse" for="c-41233427">[-]</label><label class="expand" for="c-41233427">[1 more]</label></div><br/><div class="children"><div class="content">Not having operator overload making the code more readable is the same argument that was brought up with generics and it is still false.<p>Go does have operator overloading, for example + is overloaded for float.., int.. and even non numeric types like string.<p>And it does so for a very good reason: having operator overloading makes code much more readable when used correctly. It&#x27;s just that the language designers didn&#x27;t trust their users.<p>As long as you know the types of x and y you always know precisely what x + y does, same as you know what x.Add(y) does. There&#x27;s no difference.</div><br/></div></div></div></div><div id="41229373" class="c"><input type="checkbox" id="c-41229373" checked=""/><div class="controls bullet"><span class="by">sbhitz</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41229333">parent</a><span>|</span><a href="#41230293">prev</a><span>|</span><a href="#41229435">next</a><span>|</span><label class="collapse" for="c-41229373">[-]</label><label class="expand" for="c-41229373">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq#overloading" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq#overloading</a></div><br/></div></div></div></div><div id="41229435" class="c"><input type="checkbox" id="c-41229435" checked=""/><div class="controls bullet"><span class="by">hello_computer</span><span>|</span><a href="#41229166">parent</a><span>|</span><a href="#41229333">prev</a><span>|</span><a href="#41229752">next</a><span>|</span><label class="collapse" for="c-41229435">[-]</label><label class="expand" for="c-41229435">[2 more]</label></div><br/><div class="children"><div class="content">Something like Elixir&#x27;s function composition operator (-&gt;) would go a long way toward smoothing that out, but they rejected that as well.<p>I think the best we can do at the moment is runtime expression evaluation with something like this:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;expr-lang&#x2F;expr">https:&#x2F;&#x2F;github.com&#x2F;expr-lang&#x2F;expr</a><p>or this: <a href="https:&#x2F;&#x2F;github.com&#x2F;Knetic&#x2F;govaluate">https:&#x2F;&#x2F;github.com&#x2F;Knetic&#x2F;govaluate</a></div><br/><div id="41229714" class="c"><input type="checkbox" id="c-41229714" checked=""/><div class="controls bullet"><span class="by">dudeinjapan</span><span>|</span><a href="#41229166">root</a><span>|</span><a href="#41229435">parent</a><span>|</span><a href="#41229752">next</a><span>|</span><label class="collapse" for="c-41229714">[-]</label><label class="expand" for="c-41229714">[1 more]</label></div><br/><div class="children"><div class="content">Elixir&#x27;s function composition operator is |&gt;</div><br/></div></div></div></div></div></div><div id="41228580" class="c"><input type="checkbox" id="c-41228580" checked=""/><div class="controls bullet"><span class="by">bitbasher</span><span>|</span><a href="#41229166">prev</a><span>|</span><a href="#41224804">next</a><span>|</span><label class="collapse" for="c-41228580">[-]</label><label class="expand" for="c-41228580">[12 more]</label></div><br/><div class="children"><div class="content">Life is barely long enough to get good at one thing so you should choose your thing wisely. That&#x27;s wisdom I&#x27;ve held for quite some time.<p>Coincidentally, I chose Go as my language of choice as well. The factors that led me to that choice were many, but to highlight some:<p>- incredible standard library<p>- simple to read and write<p>- single static binary builds (assets included, like html&#x2F;images, etc)<p>- don&#x27;t need a container (my binary is the container)<p>- can be used anywhere (webdev, desktop apps, gamedev, embedded, etc)</div><br/><div id="41230061" class="c"><input type="checkbox" id="c-41230061" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41228580">parent</a><span>|</span><a href="#41230188">next</a><span>|</span><label class="collapse" for="c-41230061">[-]</label><label class="expand" for="c-41230061">[7 more]</label></div><br/><div class="children"><div class="content">I chose C# for the same reasons. It&#x27;s probably easier to make C# unreadable than Go due to plethora of features, but it all comes down to how you discipline yourself about writing code.</div><br/><div id="41233302" class="c"><input type="checkbox" id="c-41233302" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#41228580">root</a><span>|</span><a href="#41230061">parent</a><span>|</span><a href="#41231351">next</a><span>|</span><label class="collapse" for="c-41233302">[-]</label><label class="expand" for="c-41233302">[1 more]</label></div><br/><div class="children"><div class="content">&quot;it all comes down to how you discipline yourself about writing code.&quot;<p>I don&#x27;t think controlling one&#x27;s own code is a problem. I&#x27;m more worried about the opportunities the language gives for Bob (my junior coworker) to slowly introduce all sorts of unclear cutting-edge language nonsense. Go is pretty good for this in my opinion.</div><br/></div></div><div id="41231351" class="c"><input type="checkbox" id="c-41231351" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#41228580">root</a><span>|</span><a href="#41230061">parent</a><span>|</span><a href="#41233302">prev</a><span>|</span><a href="#41230236">next</a><span>|</span><label class="collapse" for="c-41231351">[-]</label><label class="expand" for="c-41231351">[2 more]</label></div><br/><div class="children"><div class="content">My main beef with C# was the culture. I spent around 15 years building stuff in C# (since 1.0), and absolutely loved the language. But, man. The Microsoft shops were so full of Kool-Aid drinkers, and there was so much enterprisey crap that often came along with that. I miss C#, but I don&#x27;t miss the culture.</div><br/></div></div><div id="41230236" class="c"><input type="checkbox" id="c-41230236" checked=""/><div class="controls bullet"><span class="by">mats852</span><span>|</span><a href="#41228580">root</a><span>|</span><a href="#41230061">parent</a><span>|</span><a href="#41231351">prev</a><span>|</span><a href="#41230188">next</a><span>|</span><label class="collapse" for="c-41230236">[-]</label><label class="expand" for="c-41230236">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;bflattened&#x2F;bflat">https:&#x2F;&#x2F;github.com&#x2F;bflattened&#x2F;bflat</a></div><br/><div id="41230367" class="c"><input type="checkbox" id="c-41230367" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41228580">root</a><span>|</span><a href="#41230236">parent</a><span>|</span><a href="#41230188">next</a><span>|</span><label class="collapse" for="c-41230367">[-]</label><label class="expand" for="c-41230367">[2 more]</label></div><br/><div class="children"><div class="content">Single file AOT is now officially supported by base dotnet.</div><br/><div id="41230460" class="c"><input type="checkbox" id="c-41230460" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41228580">root</a><span>|</span><a href="#41230367">parent</a><span>|</span><a href="#41230188">next</a><span>|</span><label class="collapse" for="c-41230460">[-]</label><label class="expand" for="c-41230460">[1 more]</label></div><br/><div class="children"><div class="content">bflat has somewhat different set of goals and offers &quot;zerolib&quot; and &quot;uefi&quot; runtime target flavours. Its author is also working on the official NativeAOT, which bflat builds on top of :)<p>While we&#x27;re at it, it&#x27;s impressive how much NativeAOT has improved within just 2 releases or so: <a href="https:&#x2F;&#x2F;migeel.sk&#x2F;blog&#x2F;2023&#x2F;11&#x2F;22&#x2F;top-3-whole-program-optimizations-for-aot-in-net-8&#x2F;" rel="nofollow">https:&#x2F;&#x2F;migeel.sk&#x2F;blog&#x2F;2023&#x2F;11&#x2F;22&#x2F;top-3-whole-program-optimi...</a><p>There are other niceties like dehydrated binary sections, metadata compression, linker that is deeply aware of the type system, etc. to keep the binary size scalable as you keep adding dependencies. I&#x27;m seeing even smaller sizes with .NET 9 preview.</div><br/></div></div></div></div></div></div></div></div><div id="41230188" class="c"><input type="checkbox" id="c-41230188" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#41228580">parent</a><span>|</span><a href="#41230061">prev</a><span>|</span><a href="#41229191">next</a><span>|</span><label class="collapse" for="c-41230188">[-]</label><label class="expand" for="c-41230188">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate the Rust approach where Rust &lt;-&gt; C and Rust &lt;-&gt; Python get along really well together.  They really thought about interoperability with existing infrastructure.<p>Java wanted everyone to rewrite everything in Java because that was easier than to interface with the existing libraries on the OS.</div><br/></div></div><div id="41229191" class="c"><input type="checkbox" id="c-41229191" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41228580">parent</a><span>|</span><a href="#41230188">prev</a><span>|</span><a href="#41224804">next</a><span>|</span><label class="collapse" for="c-41229191">[-]</label><label class="expand" for="c-41229191">[3 more]</label></div><br/><div class="children"><div class="content">What game engines use Go?</div><br/><div id="41230573" class="c"><input type="checkbox" id="c-41230573" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41228580">root</a><span>|</span><a href="#41229191">parent</a><span>|</span><a href="#41224804">next</a><span>|</span><label class="collapse" for="c-41230573">[-]</label><label class="expand" for="c-41230573">[2 more]</label></div><br/><div class="children"><div class="content">I should say what 3D game engines use Go?*</div><br/><div id="41232960" class="c"><input type="checkbox" id="c-41232960" checked=""/><div class="controls bullet"><span class="by">throwawaythekey</span><span>|</span><a href="#41228580">root</a><span>|</span><a href="#41230573">parent</a><span>|</span><a href="#41224804">next</a><span>|</span><label class="collapse" for="c-41232960">[-]</label><label class="expand" for="c-41232960">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if you&#x27;re being intentionally cheeky by pointing out a use case one wouldn&#x27;t use Go for but will answer anyway.<p>A language with a GC (like go) typically isn&#x27;t a good fit for a 3d engine. Almost all serious engines are C++, at least for the core code, for that reason.</div><br/></div></div></div></div></div></div></div></div><div id="41224804" class="c"><input type="checkbox" id="c-41224804" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#41228580">prev</a><span>|</span><a href="#41224300">next</a><span>|</span><label class="collapse" for="c-41224804">[-]</label><label class="expand" for="c-41224804">[2 more]</label></div><br/><div class="children"><div class="content">There are a lot of aspects of Go that I’m really not a fan of, but I’ve been writing an increasing amount of it over the last few months and on the whole I’m finding it really enjoyable—even though I’m not sure I could empirically explain why.<p>The tooling is <i>heaven</i> compared to other stuff we do a lot of at work (TS&#x2F;JS of course being the main offender), and generally I find I spend less time thinking about things that aren’t directly related to the problem I’m trying to solve. Though, that might just be because I’m not an expert and simply don’t yet know about other things I could be thinking about!</div><br/><div id="41225615" class="c"><input type="checkbox" id="c-41225615" checked=""/><div class="controls bullet"><span class="by">znkr</span><span>|</span><a href="#41224804">parent</a><span>|</span><a href="#41224300">next</a><span>|</span><label class="collapse" for="c-41225615">[-]</label><label class="expand" for="c-41225615">[1 more]</label></div><br/><div class="children"><div class="content">I have been writing Go code for many years, the fact that I don’t need to think about things unrelated to the problem I am trying to solve is why I love Go. I definitely learned a lot about Go and I am thinking more about certain aspects than before, but usually only in the context of API design.</div><br/></div></div></div></div><div id="41224300" class="c"><input type="checkbox" id="c-41224300" checked=""/><div class="controls bullet"><span class="by">read-bird</span><span>|</span><a href="#41224804">prev</a><span>|</span><a href="#41224588">next</a><span>|</span><label class="collapse" for="c-41224300">[-]</label><label class="expand" for="c-41224300">[3 more]</label></div><br/><div class="children"><div class="content">&quot;The world is laaaarge. The number of projects are basically infinite. Even if I carve out a tiny subset of infinite, that’s still infinite.&quot;
I liked the use of this wisdom in there.</div><br/><div id="41224522" class="c"><input type="checkbox" id="c-41224522" checked=""/><div class="controls bullet"><span class="by">kingforaday</span><span>|</span><a href="#41224300">parent</a><span>|</span><a href="#41224858">next</a><span>|</span><label class="collapse" for="c-41224522">[-]</label><label class="expand" for="c-41224522">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll enjoy set theory then. Just call the first set aleph-null.</div><br/></div></div><div id="41224858" class="c"><input type="checkbox" id="c-41224858" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224300">parent</a><span>|</span><a href="#41224522">prev</a><span>|</span><a href="#41224588">next</a><span>|</span><label class="collapse" for="c-41224858">[-]</label><label class="expand" for="c-41224858">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! I guess I have moments of insight sometimes. :D</div><br/></div></div></div></div><div id="41224588" class="c"><input type="checkbox" id="c-41224588" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#41224300">prev</a><span>|</span><a href="#41224271">next</a><span>|</span><label class="collapse" for="c-41224588">[-]</label><label class="expand" for="c-41224588">[8 more]</label></div><br/><div class="children"><div class="content">At the peak of my honeymoon phase with Golang, I went down this path too, and oh boy does it feels great and liberating, like finding a magic bullet, but soon as you start to scratch beyond the surface and dig deeper, you will find yourself trying to screw screws with a hammer, or tie your shoes with a chainsaw and ungodly things like that.<p>No tool deserves more love or loyalty than the productivity it brings, anything more is infatuation and a game for naive and the fool.</div><br/><div id="41224631" class="c"><input type="checkbox" id="c-41224631" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224588">parent</a><span>|</span><a href="#41224271">next</a><span>|</span><label class="collapse" for="c-41224631">[-]</label><label class="expand" for="c-41224631">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really about Go, I think. But it makes me productive, and I like that. I don&#x27;t think it&#x27;s a magic bullet at all. Lots of things annoy me about it. But it&#x27;s _good enough_ for quite a lot of things IMO.<p>But tying shoes with a chainsaw does sound kinda fun. :D</div><br/><div id="41224873" class="c"><input type="checkbox" id="c-41224873" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41224588">root</a><span>|</span><a href="#41224631">parent</a><span>|</span><a href="#41224866">next</a><span>|</span><label class="collapse" for="c-41224873">[-]</label><label class="expand" for="c-41224873">[2 more]</label></div><br/><div class="children"><div class="content">If someone can&#x27;t tie their shoes with a chainsaw, they just haven&#x27;t dedicated appropriate time to their tools :)<p>Side note, this reminds me of a local YouTuber who mostly films himself using a chainsaw and has a remarkably large following (516k followers right now!). He also loves axes. I present to you Buckin&#x27; Billy Ray: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;@BuckinBillyRaySmith" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;@BuckinBillyRaySmith</a><p>I&#x27;m pretty sure this guy ties his shoes with a chain saw</div><br/><div id="41228360" class="c"><input type="checkbox" id="c-41228360" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224588">root</a><span>|</span><a href="#41224873">parent</a><span>|</span><a href="#41224866">next</a><span>|</span><label class="collapse" for="c-41228360">[-]</label><label class="expand" for="c-41228360">[1 more]</label></div><br/><div class="children"><div class="content">Haha, sweet. :D</div><br/></div></div></div></div><div id="41224866" class="c"><input type="checkbox" id="c-41224866" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#41224588">root</a><span>|</span><a href="#41224631">parent</a><span>|</span><a href="#41224873">prev</a><span>|</span><a href="#41224271">next</a><span>|</span><label class="collapse" for="c-41224866">[-]</label><label class="expand" for="c-41224866">[4 more]</label></div><br/><div class="children"><div class="content">I completely understand, but the productivity is superficial in my opinion, once you need to dig your teeth deeper into anything not &quot;cloud&quot; and &quot;system engineering&quot; with Go, overall productivity plummets hard.<p>This is from some 10 years of Go experience. But like you say, it is not really about Go; my point is about the illusion of productivity that familiarity brings; it is very deceptive and hurts productivity in the long term.</div><br/><div id="41228383" class="c"><input type="checkbox" id="c-41228383" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224588">root</a><span>|</span><a href="#41224866">parent</a><span>|</span><a href="#41224271">next</a><span>|</span><label class="collapse" for="c-41228383">[-]</label><label class="expand" for="c-41228383">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand. How can it be an illusion of productivity when it actually produces something that&#x27;s very easy to see?</div><br/><div id="41228730" class="c"><input type="checkbox" id="c-41228730" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224588">root</a><span>|</span><a href="#41228383">parent</a><span>|</span><a href="#41230929">next</a><span>|</span><label class="collapse" for="c-41228730">[-]</label><label class="expand" for="c-41228730">[1 more]</label></div><br/><div class="children"><div class="content">He is saying what is very easy to see in certain contexts is not transferrable to the abstract. Go can be shockingly productive at certain tasks, but it also falls flat on its face at others. If you take your limited experience with Go (or whatever; this applies to all tools) where you found it to be highly productive and then conclude that it is always productive and therefore a tool you can use in all situations, you are bound to encounter negative productivity when you have a different problem to solve.<p>Need to write, say, a network service? Go can no doubt give just about anything else a productivity run for their money. Need to solve a machine learning problem? ... Good luck. It <i>can</i> be done, of course, but you&#x27;re quite likely in for a whole lot of extra work not needed in other ecosystems, destroying any semblance of productivity.<p>In other words, the comment is a thinly veiled &quot;use the right tool for the job&quot;.</div><br/></div></div><div id="41230929" class="c"><input type="checkbox" id="c-41230929" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#41224588">root</a><span>|</span><a href="#41228383">parent</a><span>|</span><a href="#41228730">prev</a><span>|</span><a href="#41224271">next</a><span>|</span><label class="collapse" for="c-41230929">[-]</label><label class="expand" for="c-41230929">[1 more]</label></div><br/><div class="children"><div class="content">Productivity is the sum of the aggregate output not just getting started.<p>If you&#x27;re familiar with a tool, you might be able to &quot;get something&quot; a lot quicker with it than learn to use the correct tool, but on the long term, the correct tool pays off better.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41224271" class="c"><input type="checkbox" id="c-41224271" checked=""/><div class="controls bullet"><span class="by">caerwy</span><span>|</span><a href="#41224588">prev</a><span>|</span><a href="#41224436">next</a><span>|</span><label class="collapse" for="c-41224271">[-]</label><label class="expand" for="c-41224271">[14 more]</label></div><br/><div class="children"><div class="content">This article is not so much about Go but about choosing to specialize in one language ecosystem instead of spreading one&#x27;s attention across several.</div><br/><div id="41224405" class="c"><input type="checkbox" id="c-41224405" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#41224271">parent</a><span>|</span><a href="#41224936">next</a><span>|</span><label class="collapse" for="c-41224405">[-]</label><label class="expand" for="c-41224405">[5 more]</label></div><br/><div class="children"><div class="content">With the caveat that the broadened perspective you obtain by learning a variety of languages will make you better at your primary language.</div><br/><div id="41224559" class="c"><input type="checkbox" id="c-41224559" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224405">parent</a><span>|</span><a href="#41224739">next</a><span>|</span><label class="collapse" for="c-41224559">[-]</label><label class="expand" for="c-41224559">[1 more]</label></div><br/><div class="children"><div class="content">This is true, but it doesn&#x27;t mean you should actually use a variety of languages for your day job if you&#x27;re self-employed; that is, you lose some productivity if you choose an unfamiliar tool, and you&#x27;ll shoot yourself in the foot if you choose a language unsuitable for the problem at hand.<p>The other thing to watch out for if you&#x27;re in a corporate setting is that if you use a language nobody else is using at your company, your project is doomed and &#x2F; or it will be stupid expensive compared to other projects because it uses a different language from the rest of the organization. See also <a href="https:&#x2F;&#x2F;boringtechnology.club&#x2F;" rel="nofollow">https:&#x2F;&#x2F;boringtechnology.club&#x2F;</a></div><br/></div></div><div id="41224739" class="c"><input type="checkbox" id="c-41224739" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224405">parent</a><span>|</span><a href="#41224559">prev</a><span>|</span><a href="#41224936">next</a><span>|</span><label class="collapse" for="c-41224739">[-]</label><label class="expand" for="c-41224739">[3 more]</label></div><br/><div class="children"><div class="content">I would say there are many, many other ways to broaden my perspective, not just learning and using a different programming language. There are so many things to learn!<p>(And I don&#x27;t necessarily suggest not learning different languages, if one fancies that. I just don&#x27;t use any other ones at the moment.)</div><br/><div id="41224972" class="c"><input type="checkbox" id="c-41224972" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224739">parent</a><span>|</span><a href="#41224936">next</a><span>|</span><label class="collapse" for="c-41224972">[-]</label><label class="expand" for="c-41224972">[2 more]</label></div><br/><div class="children"><div class="content">I actually find it a bit of a curse to know too many languages. Because settling on one for any given project becomes very difficult. Like you start coding it up and then hit some friction and start thinking about one of the other languages you know that would be more elegant. Or you might have chosen a language that does a lot of things elegantly but then start thinking of the performance you&#x27;ve given up performance for that. Swapping languages will never stop those thoughts because there&#x27;s always tradeoffs somewhere.</div><br/></div></div></div></div></div></div><div id="41224936" class="c"><input type="checkbox" id="c-41224936" checked=""/><div class="controls bullet"><span class="by">markhahn</span><span>|</span><a href="#41224271">parent</a><span>|</span><a href="#41224405">prev</a><span>|</span><a href="#41224279">next</a><span>|</span><label class="collapse" for="c-41224936">[-]</label><label class="expand" for="c-41224936">[5 more]</label></div><br/><div class="children"><div class="content">I always wonder: why do some people like to do this (spreading)?  I wonder the same about people who are &quot;distro tourists&quot;.  The latter tend to spend a lot of time on what seems like unproductive diddling (desktop skins, etc).</div><br/><div id="41225645" class="c"><input type="checkbox" id="c-41225645" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224936">parent</a><span>|</span><a href="#41230279">next</a><span>|</span><label class="collapse" for="c-41225645">[-]</label><label class="expand" for="c-41225645">[1 more]</label></div><br/><div class="children"><div class="content">1. Because I like engineering more than programming. If a problem is best solved by, say, a mechanical system then I will do that instead. But even where programming provides the best solution, not all ecosystems are equal. If I have a problem best solved by, say, AI&#x2F;ML, it is often impractical to avoid Python. Likewise, if I have a problem best solved in the web domain, it is often impractical to avoid Javsacript. SQL where databases are the best solution. So on and so forth.<p>2. Because I like to learn. In my younger days, I found a lot of value in exploring the different ways people live. In fairness, I&#x27;ve toured the programming world enough by now that I am less compelled to keep go on &quot;programming language vacations&quot; – at some point you start to feel like you&#x27;ve seen it all, but believe I would be a far worse programmer today had I not been able to take ideas from a wide range of different cultures over the years. There are some good ideas out there that don&#x27;t seem to ever gain mass adoption outside of their originating ecosystem.</div><br/></div></div><div id="41230279" class="c"><input type="checkbox" id="c-41230279" checked=""/><div class="controls bullet"><span class="by">matwood</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224936">parent</a><span>|</span><a href="#41225645">prev</a><span>|</span><a href="#41230936">next</a><span>|</span><label class="collapse" for="c-41230279">[-]</label><label class="expand" for="c-41230279">[1 more]</label></div><br/><div class="children"><div class="content">I can think of many reasons. Seeing other language perspectives definitely can help with your primary language. I have experienced this. But, I have also explored other languages as a means of procrastination or ways to do something <i>easy</i> when bumping into the more challenging depths of my language of choice.</div><br/></div></div><div id="41230936" class="c"><input type="checkbox" id="c-41230936" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224936">parent</a><span>|</span><a href="#41230279">prev</a><span>|</span><a href="#41226515">next</a><span>|</span><label class="collapse" for="c-41230936">[-]</label><label class="expand" for="c-41230936">[1 more]</label></div><br/><div class="children"><div class="content">Diff langs have their strengths and weaknesses, the same reason you don&#x27;t build every object out of concrete &quot;because it&#x27;s tough&quot; you don&#x27;t build every service out of Python (because it&#x27;s slow).</div><br/></div></div><div id="41226515" class="c"><input type="checkbox" id="c-41226515" checked=""/><div class="controls bullet"><span class="by">CodeMage</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224936">parent</a><span>|</span><a href="#41230936">prev</a><span>|</span><a href="#41224279">next</a><span>|</span><label class="collapse" for="c-41226515">[-]</label><label class="expand" for="c-41226515">[1 more]</label></div><br/><div class="children"><div class="content">Because there&#x27;s so much to learn from having different perspectives.<p>Back in 2006, I was working mainly in C with a bit of C++. One of the things I was taught was that &quot;macros are evil&quot;, period. Then, in my spare time, I decided to try Common Lisp. I had a blast. I never wrote anything more useful than a half-assed catalog for my MP3 collection, but I learned a lot. My main takeaway was the power of metaprogramming -- with all of its footguns and pitfalls -- and took that knowledge with me to my day job, where I suddenly had a more nuanced view of how preprocessor macros can avoid being evil.<p>Later, when I changed jobs, I went back to Java, which was my main language before the C stint. I slipped back into the comfort of having my memory managed for me and the expressiveness of OOP. But in my spare time, I discovered Self and Io, and the fact that you can have OOP without classes blew my mind.<p>At that same job, I undertook the task to make our proprietary in-house language not only transpile to C++, but also compile to be executed on JVM. Understanding how JVM bytecode instructions work was easier than it might have been had I not dabbled in Forth in my spare time.<p>These days my day job involves working with C++ full time, but my hobby projects in Rust taught me to structure my thinking about the ownership and lifecycle of memory allocations.<p>So yeah, most of what I do in my spare time with other languages is largely &quot;unproductive diddling&quot; if you only look at the code I write in those languages, but the insights I take away with me are useful.<p>Also, it&#x27;s fun ;)</div><br/></div></div></div></div><div id="41224279" class="c"><input type="checkbox" id="c-41224279" checked=""/><div class="controls bullet"><span class="by">dimgl</span><span>|</span><a href="#41224271">parent</a><span>|</span><a href="#41224936">prev</a><span>|</span><a href="#41224436">next</a><span>|</span><label class="collapse" for="c-41224279">[-]</label><label class="expand" for="c-41224279">[3 more]</label></div><br/><div class="children"><div class="content">Which is unfortunate because I think Go is very useful in a wide variety of business contexts.</div><br/><div id="41224373" class="c"><input type="checkbox" id="c-41224373" checked=""/><div class="controls bullet"><span class="by">the_real_cher</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224279">parent</a><span>|</span><a href="#41224436">next</a><span>|</span><label class="collapse" for="c-41224373">[-]</label><label class="expand" for="c-41224373">[2 more]</label></div><br/><div class="children"><div class="content">Then you would find this article very fortunate.</div><br/><div id="41224401" class="c"><input type="checkbox" id="c-41224401" checked=""/><div class="controls bullet"><span class="by">the-grump</span><span>|</span><a href="#41224271">root</a><span>|</span><a href="#41224373">parent</a><span>|</span><a href="#41224436">next</a><span>|</span><label class="collapse" for="c-41224401">[-]</label><label class="expand" for="c-41224401">[1 more]</label></div><br/><div class="children"><div class="content">It would be a misfortune indeed if I had nothing to complain about.</div><br/></div></div></div></div></div></div></div></div><div id="41224436" class="c"><input type="checkbox" id="c-41224436" checked=""/><div class="controls bullet"><span class="by">leecommamichael</span><span>|</span><a href="#41224271">prev</a><span>|</span><a href="#41224721">next</a><span>|</span><label class="collapse" for="c-41224436">[-]</label><label class="expand" for="c-41224436">[2 more]</label></div><br/><div class="children"><div class="content">The author feels happy and contented and you all are getting defensive. He’s a solo dev, just recognize that that scopes his projects and stop trying to shoot him down.<p>Use what you want.</div><br/><div id="41224519" class="c"><input type="checkbox" id="c-41224519" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224436">parent</a><span>|</span><a href="#41224721">next</a><span>|</span><label class="collapse" for="c-41224519">[-]</label><label class="expand" for="c-41224519">[1 more]</label></div><br/><div class="children"><div class="content">I choose to read most comments in a positive light, but thank you for your kindness. :)</div><br/></div></div></div></div><div id="41224721" class="c"><input type="checkbox" id="c-41224721" checked=""/><div class="controls bullet"><span class="by">andrew_eu</span><span>|</span><a href="#41224436">prev</a><span>|</span><a href="#41232366">next</a><span>|</span><label class="collapse" for="c-41224721">[-]</label><label class="expand" for="c-41224721">[4 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t really disagree with the points the article makes in favor of Go, and it&#x27;s not selling it over some other language&#x2F;framework&#x2F;tool but just celebrating how great of an ecosystem Go has. And it&#x27;s true -- Go&#x27;s ecosystem has matured into something very pleasant to work with.<p>By the same token I know professors who still write their simulation scripts in QBASIC because that&#x27;s what they are familiar with and they can solve their problems quickly. You can use all sorts of tools to drive a nail.<p>On Go, it&#x27;s almost a footnote in the context of the post, but I think a seriously underrated feature is its C-interoperability. Here [0] is an example.  It&#x27;s not unique of course -- tons of languages have some FFI solution for C libraries -- but Go&#x27;s is I believe one of the most straightforward to use if you&#x27;re already familiar with the language. And while there are portability&#x2F;stability sacrifices you make when you call a native library, it does also expand the available dependencies even beyond &quot;basically infinite.&quot;<p>[0] <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;cgo" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;cgo</a></div><br/><div id="41230224" class="c"><input type="checkbox" id="c-41230224" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#41224721">parent</a><span>|</span><a href="#41228401">next</a><span>|</span><label class="collapse" for="c-41230224">[-]</label><label class="expand" for="c-41230224">[1 more]</label></div><br/><div class="children"><div class="content">Go has one of the worst FFI support IMO. Code as comments? It doesn’t ever support C callback without a “bridge” method. MSVC support? Try debugging when CGO is enabled. Worst of it all, it’s also one of the slowest too.</div><br/></div></div><div id="41228401" class="c"><input type="checkbox" id="c-41228401" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224721">parent</a><span>|</span><a href="#41230224">prev</a><span>|</span><a href="#41229613">next</a><span>|</span><label class="collapse" for="c-41228401">[-]</label><label class="expand" for="c-41228401">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re totally right about CGo. For example, I&#x27;m very happy that I can use the insanely well-tested original SQLite C library directly in Go, and sleep easy that it&#x27;s not some half-ported pure Go library.<p>(I know there&#x27;s an auto-transpiled SQLite lib as well, which is probably just as good. But then I have to rely on no bugs in the transpilation process, and I don&#x27;t like that. That may be superstition though. ;) )</div><br/></div></div><div id="41229613" class="c"><input type="checkbox" id="c-41229613" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#41224721">parent</a><span>|</span><a href="#41228401">prev</a><span>|</span><a href="#41232366">next</a><span>|</span><label class="collapse" for="c-41229613">[-]</label><label class="expand" for="c-41229613">[1 more]</label></div><br/><div class="children"><div class="content">You might like Zig too. The C interop is amazing. Last time I checked you could use Zig to just compile C straight up.</div><br/></div></div></div></div><div id="41232366" class="c"><input type="checkbox" id="c-41232366" checked=""/><div class="controls bullet"><span class="by">mayoff</span><span>|</span><a href="#41224721">prev</a><span>|</span><a href="#41229152">next</a><span>|</span><label class="collapse" for="c-41232366">[-]</label><label class="expand" for="c-41232366">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p>Java for Everything<p><a href="https:&#x2F;&#x2F;www.teamten.com&#x2F;lawrence&#x2F;writings&#x2F;java-for-everything.html" rel="nofollow">https:&#x2F;&#x2F;www.teamten.com&#x2F;lawrence&#x2F;writings&#x2F;java-for-everythin...</a><p>Previously HN discussion of &quot;Java for Everything&quot;:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26934297">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26934297</a></div><br/></div></div><div id="41229152" class="c"><input type="checkbox" id="c-41229152" checked=""/><div class="controls bullet"><span class="by">textlapse</span><span>|</span><a href="#41232366">prev</a><span>|</span><a href="#41225374">next</a><span>|</span><label class="collapse" for="c-41229152">[-]</label><label class="expand" for="c-41229152">[1 more]</label></div><br/><div class="children"><div class="content">Heard from someone: &quot;C++ is a hammer, but then everything starts to look like your finger&quot;</div><br/></div></div><div id="41225374" class="c"><input type="checkbox" id="c-41225374" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41229152">prev</a><span>|</span><a href="#41233267">next</a><span>|</span><label class="collapse" for="c-41225374">[-]</label><label class="expand" for="c-41225374">[6 more]</label></div><br/><div class="children"><div class="content">I understand the sentiment. My goto hammer is Kotlin, which I like a bit better than Go. But that&#x27;s a highly subjective thing of course. And I use plenty of other languages as well (including very occasionally some Go).<p>It&#x27;s not about what is better in general but about what is better for you. Better here means less time wasted with figuring out syntax, tools, APIs, frameworks, etc. Once you know how to do a certain thing in one language, having to relearn to do the same things in another is slightly annoying. Although, LLMs are actually hugely helpful for this these days.<p>IMHO we&#x27;re about to see a minor renaissance in web development. I was playing with the Kotlin WASM compiler a few weeks ago just to verify that I could use existing web APIs. As it turns out, it&#x27;s are all there. Using them might not be the fastest right now but I&#x27;m sure that will get improved over time. Garbage collection is already in (and coming soon to Safari as well). There are some inefficiencies with making calls into js that need some attention. But that&#x27;s not really a show stopper unless you are doing this many times per second.<p>What that means is that you can just do web application in wasm; use all the stuff from the browser that you normally use but without any javascript (except for a tiny wrapper that loads the wasm). I actually use kotlin-js so it&#x27;s not a big leap for me. But wasm loads a bit faster and probably compiles a bit faster too. No more webpack uglification needed (which is actually slower than the kotlin compiler). So that&#x27;s 2x compiler performance right there.<p>The point here is not kotlin or javascript but that this now works with any language that you can get going with wasm. Including Go if you want. Javascript becomes completely optional. I&#x27;m sure some will be upset about that. But that would be mainly because it&#x27;s their preferred hammer.</div><br/><div id="41232760" class="c"><input type="checkbox" id="c-41232760" checked=""/><div class="controls bullet"><span class="by">zeroc8</span><span>|</span><a href="#41225374">parent</a><span>|</span><a href="#41229405">next</a><span>|</span><label class="collapse" for="c-41232760">[-]</label><label class="expand" for="c-41232760">[2 more]</label></div><br/><div class="children"><div class="content">But you also need the GUI part. Flutter seems to be the main competitor here. What&#x27;s the current situation with Kotlin? Is there a decent Compose for Web yet?</div><br/><div id="41232878" class="c"><input type="checkbox" id="c-41232878" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41225374">root</a><span>|</span><a href="#41232760">parent</a><span>|</span><a href="#41229405">next</a><span>|</span><label class="collapse" for="c-41232878">[-]</label><label class="expand" for="c-41232878">[1 more]</label></div><br/><div class="children"><div class="content">With browser dom support and CSS, that would be doable. Compose web is in alpha currently; it renders to a canvas.</div><br/></div></div></div></div><div id="41229405" class="c"><input type="checkbox" id="c-41229405" checked=""/><div class="controls bullet"><span class="by">ridiculous_leke</span><span>|</span><a href="#41225374">parent</a><span>|</span><a href="#41232760">prev</a><span>|</span><a href="#41228441">next</a><span>|</span><label class="collapse" for="c-41229405">[-]</label><label class="expand" for="c-41229405">[2 more]</label></div><br/><div class="children"><div class="content">I am planning a switch to Kotlin just because it seems more readable. As someone who has done both how do you rate Kotlin&#x27;s STL?</div><br/><div id="41232863" class="c"><input type="checkbox" id="c-41232863" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41225374">root</a><span>|</span><a href="#41229405">parent</a><span>|</span><a href="#41228441">next</a><span>|</span><label class="collapse" for="c-41232863">[-]</label><label class="expand" for="c-41232863">[1 more]</label></div><br/><div class="children"><div class="content">The standard library plus the growing number of multi platform libraries covers a lot of stuff at this point. There are still some things that are a bit lacking but most of those things have people working on them.</div><br/></div></div></div></div><div id="41228441" class="c"><input type="checkbox" id="c-41228441" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41225374">parent</a><span>|</span><a href="#41229405">prev</a><span>|</span><a href="#41233267">next</a><span>|</span><label class="collapse" for="c-41228441">[-]</label><label class="expand" for="c-41228441">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, WASM is interesting! I haven&#x27;t followed the space at all, but I guess the browser is the new JVM? :D</div><br/></div></div></div></div><div id="41233267" class="c"><input type="checkbox" id="c-41233267" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#41225374">prev</a><span>|</span><a href="#41224658">next</a><span>|</span><label class="collapse" for="c-41233267">[-]</label><label class="expand" for="c-41233267">[1 more]</label></div><br/><div class="children"><div class="content">The fact that monorepos are so easy helps make Go so versatile. It is so easy for me to make an adhoc CLI for data fixing which uses my core service code, for example.</div><br/></div></div><div id="41224658" class="c"><input type="checkbox" id="c-41224658" checked=""/><div class="controls bullet"><span class="by">fifilura</span><span>|</span><a href="#41233267">prev</a><span>|</span><a href="#41224224">next</a><span>|</span><label class="collapse" for="c-41224658">[-]</label><label class="expand" for="c-41224658">[8 more]</label></div><br/><div class="children"><div class="content">Where I feel go is lacking is for data wrangling.<p>Group by, filter, map, join. It is just very error prone, inconvenient and slow to implement with for loops.</div><br/><div id="41224731" class="c"><input type="checkbox" id="c-41224731" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41224658">parent</a><span>|</span><a href="#41224840">next</a><span>|</span><label class="collapse" for="c-41224731">[-]</label><label class="expand" for="c-41224731">[6 more]</label></div><br/><div class="children"><div class="content">Go does support functional programming constructs (as it has first-class functions) and there are some FP libraries out there, but they are discouraged because the execution is so much slower; Go is not optimized for FP, and chooses &quot;clumsy&quot; for loops over clever functional programming because the loops have mechanical sympathy and are simply faster in execution speed.<p>That said, if you have a use case with a lot of data wrangling like that, Go may not be the best choice and a functional programming language may be a better fit.</div><br/><div id="41224977" class="c"><input type="checkbox" id="c-41224977" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41224658">root</a><span>|</span><a href="#41224731">parent</a><span>|</span><a href="#41229488">next</a><span>|</span><label class="collapse" for="c-41224977">[-]</label><label class="expand" for="c-41224977">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps I’m thick but what kind of programming <i>doesn’t</i> involve data wrangling?<p>What are Go programmers doing that they don’t feel the need for map&#x2F;filter&#x2F;etc?<p>BTW there’s no reason why map and filter would be slower than loops, efficiently lowering such functions to loops was solved a very long time ago.</div><br/><div id="41230793" class="c"><input type="checkbox" id="c-41230793" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#41224658">root</a><span>|</span><a href="#41224977">parent</a><span>|</span><a href="#41229488">next</a><span>|</span><label class="collapse" for="c-41230793">[-]</label><label class="expand" for="c-41230793">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What are Go programmers doing that they don’t feel the need for map&#x2F;filter&#x2F;etc?<p>As a refugee from a scala project that went badly (we eventually ported the entire thing to go), it&#x27;s not so bad when you&#x27;re just using map and filter and friends.<p>But eventually there&#x27;s so many of those little methods each with their own nuances and I don&#x27;t want to have to remember them all (`sliding` comes to mind), and it&#x27;s just exhausting. I don&#x27;t want to deal with it any more. The for loop is freeing, I&#x27;ve written the map&#x2F;filter&#x2F;reduce&#x2F;groupBy functions a couple time, but I never end up using them. I don&#x27;t miss them anymore.<p>I guess, those methods were sold to me originally as less powerful than a for loop. You had guarantees about what they&#x27;re doing, and eventually there were enough of them that something flipped. The for loop feels easier. I can see everything that it&#x27;s doing. It&#x27;s all right there.<p>Same things with monads after a certain point. Result&#x2F;Option are sorta fine, but I&#x27;d rather just deal with remembering to close a file than use a Resource. I don&#x27;t want to have to think about Semigroups and Applicative Functors. I just want to call the function and do the thing. Eventually FP felt like my experiences with bad OO projects where I spent 80% of my time trying to figure out the platonic ideal of something and where it fit to make everything elegant. And then tracing my way through things was significantly worse when things went wrong (and they did still go wrong). I decided it wasn&#x27;t worth it.<p>And, yeah. Sometimes I find a gronky loop somewhere that&#x27;s doing too much. I just re-write it while I&#x27;m passing through so it doesn&#x27;t get out of control, and I move on.</div><br/></div></div></div></div><div id="41229546" class="c"><input type="checkbox" id="c-41229546" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41224658">root</a><span>|</span><a href="#41224731">parent</a><span>|</span><a href="#41229488">prev</a><span>|</span><a href="#41224992">next</a><span>|</span><label class="collapse" for="c-41229546">[-]</label><label class="expand" for="c-41229546">[1 more]</label></div><br/><div class="children"><div class="content">Mechanical sympathy now favors SIMD instructions and hyperthreads because sequential loops are slower even unrolled.</div><br/></div></div><div id="41224992" class="c"><input type="checkbox" id="c-41224992" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41224658">root</a><span>|</span><a href="#41224731">parent</a><span>|</span><a href="#41229546">prev</a><span>|</span><a href="#41224840">next</a><span>|</span><label class="collapse" for="c-41224992">[-]</label><label class="expand" for="c-41224992">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go is not optimized for FP, and chooses &quot;clumsy&quot; for loops over clever functional programming because the loops have mechanical sympathy and are simply faster in execution speed.<p>So are iterators in Rust which allow you to write idiomatic iterator experessions. Hell, even LINQ in C# has improved dramatically and now makes sense in general purpose code where you would have erred on the side of caution previously. You can pry ‘var arr = nums.Select(int.Parse).ToArray();’ from my cold dead hands.<p>At the end of the day, it is about having capable compiler that can deal with the kind of complexity compiling iterator expressions optimally brings.</div><br/></div></div></div></div><div id="41224840" class="c"><input type="checkbox" id="c-41224840" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224658">parent</a><span>|</span><a href="#41224731">prev</a><span>|</span><a href="#41224224">next</a><span>|</span><label class="collapse" for="c-41224840">[-]</label><label class="expand" for="c-41224840">[1 more]</label></div><br/><div class="children"><div class="content">With generics you can now write all of those in Go.</div><br/></div></div></div></div><div id="41224224" class="c"><input type="checkbox" id="c-41224224" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41224658">prev</a><span>|</span><a href="#41224432">next</a><span>|</span><label class="collapse" for="c-41224224">[-]</label><label class="expand" for="c-41224224">[94 more]</label></div><br/><div class="children"><div class="content">If all you know is a Hammer…<p>I was searching for reasons why to use the Go-Hammer when there are comparable ones such as Java, C#, etc. but the article left me wanting.<p>It strikes me that Go is riding the peak of hype languages, succeeding Rust and Node.js (which are all good pieces of technology and absolutely have their merit). And like with most hype driven decisions there is little (self) awareness of context and alternatives.<p>Note, this is explicitly not about the languages themselves, but rather the larger cult(ure) of mainstream programmers around them.</div><br/><div id="41224732" class="c"><input type="checkbox" id="c-41224732" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41225045">next</a><span>|</span><label class="collapse" for="c-41224732">[-]</label><label class="expand" for="c-41224732">[6 more]</label></div><br/><div class="children"><div class="content">It feels extremely strange to see Go described as a &quot;hype&quot; language. It was <i>somewhat</i> hyped around seven years ago, which is when I started using it almost exclusively. Before that, it had a strong hype peak about fourteen or fifteen years ago, just after it was born.<p>However, it&#x27;s not a young language any more. At this point I would actually submit the opposite criticism: it is a mature language which is perhaps starting to suffer from middle-aged spread, as the bored maintainers start to stuff in more features which the language doesn&#x27;t genuinely need. (Example: Iterators. Sure they&#x27;re nice, but does the language <i>really need</i> them?) If anything, I would say it&#x27;s going more the way of Java than Rust or Node.</div><br/><div id="41224851" class="c"><input type="checkbox" id="c-41224851" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224732">parent</a><span>|</span><a href="#41225045">next</a><span>|</span><label class="collapse" for="c-41224851">[-]</label><label class="expand" for="c-41224851">[5 more]</label></div><br/><div class="children"><div class="content">Count the number of posts with Go in the title, vs any other programming language. It easily beats out everything both here and on lobsters.</div><br/><div id="41227997" class="c"><input type="checkbox" id="c-41227997" checked=""/><div class="controls bullet"><span class="by">cy_hauser</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224851">parent</a><span>|</span><a href="#41225883">next</a><span>|</span><label class="collapse" for="c-41227997">[-]</label><label class="expand" for="c-41227997">[1 more]</label></div><br/><div class="children"><div class="content">I did this about 1-1&#x2F;2 years ago and just reran the numbers.<p>Today:<p><pre><code>  &quot;written|built in Rust&quot;           1113 (1036|77)
  &quot;written|built in Go&#x2F;Golang&quot;      1050 (889|25) &#x2F; (119|17)
  &quot;written|built in Python&quot;:         452 (422|30)
  &quot;written|built in Javascript&#x2F;JS&quot;   286 (233|14) &#x2F; (34|5)
  &quot;written|built in Java&quot;            115 (109|6)
  &quot;written|built in TypeScript&quot;       97 (89|8)
  &quot;written|built in C#&quot;               46 (43|3)
  &quot;written|built in Stone&quot;            13 (13|0)
</code></pre>
Feb 2023<p><pre><code>  &quot;written|built in Go&#x2F;Golang&quot;      918 (792|17) &#x2F; (102|7)
  &quot;written|built in Rust&quot;           832 (790|42)
  &quot;written|built in Python&quot;:        390 (364|26)
  &quot;written|built in Javascript&#x2F;JS&quot;  269 (220|14) &#x2F; (32|3)
  &quot;written|built in Java&quot;           107 (101|6)
  &quot;written|built in TypeScript&quot;      66 (61|5)
  &quot;written|built in C#&quot;              41 (38|3)
  &quot;written|built in Stone&quot;           10 (10|0)</code></pre></div><br/></div></div><div id="41225883" class="c"><input type="checkbox" id="c-41225883" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224851">parent</a><span>|</span><a href="#41227997">prev</a><span>|</span><a href="#41226138">next</a><span>|</span><label class="collapse" for="c-41225883">[-]</label><label class="expand" for="c-41225883">[2 more]</label></div><br/><div class="children"><div class="content">Well, it&#x27;s a very usable language which is strongly typed (by any layman&#x27;s definition), easy to pick up, easy to get stuff done in, relatively easy to live with and easy to maintain. If it&#x27;s hyped then it&#x27;s only in the same way The Beatles and Pizza are hyped.</div><br/><div id="41228473" class="c"><input type="checkbox" id="c-41228473" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41225883">parent</a><span>|</span><a href="#41226138">next</a><span>|</span><label class="collapse" for="c-41228473">[-]</label><label class="expand" for="c-41228473">[1 more]</label></div><br/><div class="children"><div class="content">I like that! Go is basically pizza! :D</div><br/></div></div></div></div><div id="41226138" class="c"><input type="checkbox" id="c-41226138" checked=""/><div class="controls bullet"><span class="by">kjksf</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224851">parent</a><span>|</span><a href="#41225883">prev</a><span>|</span><a href="#41225045">next</a><span>|</span><label class="collapse" for="c-41226138">[-]</label><label class="expand" for="c-41226138">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, but 80% of those are complains of some sort.<p>That&#x27;s the opposite of hype.</div><br/></div></div></div></div></div></div><div id="41225045" class="c"><input type="checkbox" id="c-41225045" checked=""/><div class="controls bullet"><span class="by">bborud</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224732">prev</a><span>|</span><a href="#41224290">next</a><span>|</span><label class="collapse" for="c-41225045">[-]</label><label class="expand" for="c-41225045">[3 more]</label></div><br/><div class="children"><div class="content">I think the hype has already peaked for Go. When we switched to Go 8-9 years ago I already felt the hype had died down.  We were late to the party.  And I saw that as a good thing. To me it suggested Go was going to stick around.<p>And now, almost a decade later, we&#x27;re still using it.<p>Note that at my company, we&#x27;re a bunch of grumpy old guys with about 30 years of experience each.  If you dangle a new and shiny language in front of us, our default instinct is to tell people to get lost. We don&#x27;t do &quot;fashionable&quot;.  We tend to make investments in learning languages that we expect to get at least a decade out of.<p>And I don&#x27;t think Go is succeeding Rust.  From what I can tell, people are going in both directions.</div><br/><div id="41225425" class="c"><input type="checkbox" id="c-41225425" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41225045">parent</a><span>|</span><a href="#41224290">next</a><span>|</span><label class="collapse" for="c-41225425">[-]</label><label class="expand" for="c-41225425">[2 more]</label></div><br/><div class="children"><div class="content">Go and Node have some significant overlap, but Go and Rust are barely even competitors. Of course there&#x27;s a lot of programs that you can use either to write. There&#x27;s a lot of programs where it hardly even matters which language you pick at all because they&#x27;re all perfectly acceptable solutions, though, so that really isn&#x27;t saying much. But if you map languages out by the programs where language choice matters at least a little and where a given language is legitimately one of the top contenders, Go and Rust don&#x27;t have a particularly strong amount of overlap in my opinion. They do, but again, lots of languages have overlap; I don&#x27;t see the Rust&#x2F;Go relationship being particularly heavily overlapping. (Go&#x2F;Java or Rust&#x2F;C++, now there&#x27;s overlap, for comparison.)</div><br/><div id="41227754" class="c"><input type="checkbox" id="c-41227754" checked=""/><div class="controls bullet"><span class="by">bborud</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41225425">parent</a><span>|</span><a href="#41224290">next</a><span>|</span><label class="collapse" for="c-41227754">[-]</label><label class="expand" for="c-41227754">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go and Node have some significant overlap, but Go and Rust are 
&gt; barely even competitors.<p>Among the people I know Go and Rust seem to be at the top of their list. Almost all people I know who program Rust also know Go. Not as many Go programmers I know program in Rust as well, but some know Rust and even more want to learn it.  Which probably isn&#x27;t too peculiar because Rust is more of a kerfuffle to program in.<p>I&#x27;m not denying your observation. I&#x27;m just reporting that from where I am, things look a bit different.<p>I agree that it mostly doesn&#x27;t matter that much which language you choose -- as long as it is a language that can meet certain minimum standards.  In my view there is only about a handful of languages to actually choose from.<p>The first is that it must be possible to produce proper binaries.  For instance, Python is unacceptable to me since it tends to place a large burden on the user. Next, it has to be a somewhat mainstream language with a sufficiently large community. With that sorted the more technical stuff needs to be evaluated.  Like its standard library, how ergonomic the tooling, what quality software&#x2F;libraries the community produces is etc.</div><br/></div></div></div></div></div></div><div id="41224290" class="c"><input type="checkbox" id="c-41224290" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41225045">prev</a><span>|</span><a href="#41224357">next</a><span>|</span><label class="collapse" for="c-41224290">[-]</label><label class="expand" for="c-41224290">[35 more]</label></div><br/><div class="children"><div class="content">&gt; It strikes me that Go is riding the peak of hype languages.<p>Very much so.  Also it seems to be a strange choice as a solo developer when its strengths are explicitly targeted at large organizations.  And I think the tooling is actually a bit of a mess compared to some other options.  God help you if as a solo developer you start building on top of protobufs (another basically default choice in the Golang world...).<p>I just don&#x27;t understand why you wouldn&#x27;t choose something faster and more expressive.</div><br/><div id="41224347" class="c"><input type="checkbox" id="c-41224347" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224290">parent</a><span>|</span><a href="#41224377">next</a><span>|</span><label class="collapse" for="c-41224347">[-]</label><label class="expand" for="c-41224347">[18 more]</label></div><br/><div class="children"><div class="content">Protobuf is not the default in Go the default is REST. What tools are a mess? Go tooling ( runtime ) and IDE integration is very good.<p>Go is not a hyped language, we&#x27;re past that cycle, some critical and widely used software are built in Go, millions of people rely on it.</div><br/><div id="41224364" class="c"><input type="checkbox" id="c-41224364" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224347">parent</a><span>|</span><a href="#41224421">next</a><span>|</span><label class="collapse" for="c-41224364">[-]</label><label class="expand" for="c-41224364">[8 more]</label></div><br/><div class="children"><div class="content">Bazel.<p>While not Go-specific, it&#x27;s the extremely popular option in the space and I&#x27;ve seen it bring many-a-seasoned wizard to their knees in tears.<p>Also managing your go dependencies if you cargo-cult other Google behaviors like monorepos tends to be painful.<p>Basically just cargo-culting Google behavior == pain. Choosing golang can often be part of this behavior pattern.</div><br/><div id="41224452" class="c"><input type="checkbox" id="c-41224452" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224364">parent</a><span>|</span><a href="#41230317">next</a><span>|</span><label class="collapse" for="c-41224452">[-]</label><label class="expand" for="c-41224452">[6 more]</label></div><br/><div class="children"><div class="content">Bazel is not a Go default either. You can get very far just by using the default Go Modules, and this is much more common than repos using Bazel.<p>Throw some Makefiles and shell scripts in the mix, if that&#x27;s your thing, and that&#x27;s perfectly fine.</div><br/><div id="41224628" class="c"><input type="checkbox" id="c-41224628" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224452">parent</a><span>|</span><a href="#41230317">next</a><span>|</span><label class="collapse" for="c-41224628">[-]</label><label class="expand" for="c-41224628">[5 more]</label></div><br/><div class="children"><div class="content">Obviously but if you look at a lot of Go projects you tend to see it.<p>Especially in a corporate space. It should be obvious that I&#x27;m referring to things that you see in a professional environment with professional standards.  I&#x27;m getting a lot of hate where that seems to be lost on people.<p>And even if someone is a solo developer I don&#x27;t assume that they don&#x27;t ever have to work with other people&#x27;s code -- that certainly wasn&#x27;t my experience when solo contracting.</div><br/><div id="41224759" class="c"><input type="checkbox" id="c-41224759" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224628">parent</a><span>|</span><a href="#41230317">next</a><span>|</span><label class="collapse" for="c-41224759">[-]</label><label class="expand" for="c-41224759">[4 more]</label></div><br/><div class="children"><div class="content">Because you are attributing things that are common in enterprise environments (Bazel, monorepos, and Protobufs) to Go. It&#x27;s fine if you hate these things, but saying that these are the defaults of Go isn&#x27;t right, and I bet that&#x27;s why people are hating on you. There&#x27;s nothing default about them in Go. If you work with enterprise-y code, it shouldn&#x27;t be surprising that a lot of them are going to follow Google&#x27;s steps.</div><br/><div id="41226100" class="c"><input type="checkbox" id="c-41226100" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224759">parent</a><span>|</span><a href="#41230317">next</a><span>|</span><label class="collapse" for="c-41226100">[-]</label><label class="expand" for="c-41226100">[3 more]</label></div><br/><div class="children"><div class="content">Go was designed for use in enterprise environments. It was literally designed for Google&#x27;s specific development problems.<p>Nothing about Go&#x27;s design should be talked about divorced from the context of it being tailor-built to solve Google-specific problems.<p>All other uses of Golang are basically in the territory of rounding error.</div><br/><div id="41229663" class="c"><input type="checkbox" id="c-41229663" checked=""/><div class="controls bullet"><span class="by">etse</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41226100">parent</a><span>|</span><a href="#41228444">next</a><span>|</span><label class="collapse" for="c-41229663">[-]</label><label class="expand" for="c-41229663">[1 more]</label></div><br/><div class="children"><div class="content">The opposite seems true (regarding Go being over-fitted to Google problems).<p>It was designed for Google, but Google has not adopted it widely. Google is still heavily C++ and Java after all these years. The outside world loves it way more. Kubernetes isn&#x27;t used internally at Google (except Cloud, which is not any different from any other cloud provider) though it&#x27;s sponsored by Google. Bazel is probably in a similar boat.<p>Being designed to solve Google problems doesn&#x27;t mean that it actually solves Google problems well, or that Google thinks it does.<p>I became introduced to Go through my startup and my experience was it a delight to work with in very small teams.</div><br/></div></div><div id="41228444" class="c"><input type="checkbox" id="c-41228444" checked=""/><div class="controls bullet"><span class="by">cy_hauser</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41226100">parent</a><span>|</span><a href="#41229663">prev</a><span>|</span><a href="#41230317">next</a><span>|</span><label class="collapse" for="c-41228444">[-]</label><label class="expand" for="c-41228444">[1 more]</label></div><br/><div class="children"><div class="content">True for the early days of Go but I don&#x27;t know about now. I think the switch started happening right after modules came out. Generics and the new range stuff seem more for the sake of growing the language than specific needs in Google.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41230317" class="c"><input type="checkbox" id="c-41230317" checked=""/><div class="controls bullet"><span class="by">flkenosad</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224364">parent</a><span>|</span><a href="#41224452">prev</a><span>|</span><a href="#41224421">next</a><span>|</span><label class="collapse" for="c-41230317">[-]</label><label class="expand" for="c-41230317">[1 more]</label></div><br/><div class="children"><div class="content">I wish Bazel was a Go project. Unfortunately, it&#x27;s written in Java.</div><br/></div></div></div></div><div id="41224421" class="c"><input type="checkbox" id="c-41224421" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224347">parent</a><span>|</span><a href="#41224364">prev</a><span>|</span><a href="#41224377">next</a><span>|</span><label class="collapse" for="c-41224421">[-]</label><label class="expand" for="c-41224421">[9 more]</label></div><br/><div class="children"><div class="content">Go tooling was relatively very good a decade ago but other languages have improved a <i>lot</i> since then, significantly because of its influence, and it&#x27;s now about average. It&#x27;s still better than python, and C or C++ of course. But about even with typescript, ruby, shit even php and ocaml have nearly caught up with their tooling. Go&#x27;s is significantly worse than rust god help us and elixir has always made good excellent here.<p>I wouldn&#x27;t call its tooling &quot;a mess&quot; but these days it&#x27;s nothing notable either.</div><br/><div id="41224801" class="c"><input type="checkbox" id="c-41224801" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224421">parent</a><span>|</span><a href="#41224691">next</a><span>|</span><label class="collapse" for="c-41224801">[-]</label><label class="expand" for="c-41224801">[5 more]</label></div><br/><div class="children"><div class="content">Go was explicitly designed for fast compile times, especially compared to C++, and I haven&#x27;t heard anything to suggest that&#x27;s no longer the case.  It was also designed as a more modern and mature replacement for C, and I can&#x27;t think of many application domains where C is still the better choice.<p>Python is at such a different point in the design space I don&#x27;t think you can really compare the two.  Same with PHP, Ruby, Javascript etc.<p>For OCaml, need to decide how strongly you want to commit yourself to functional programming.  Also, didn&#x27;t OCaml have weak support for concurrency?  Has that changed recently?<p>Similarly with Rust, comes down how much you want to commit yourself to learning and conforming to the borrow checker.<p>Elixir is an interesting comparison, as it&#x27;s another language that allows you to build highly concurrent back end services.  The tradeoffs are that Elixir provides even more robust scaling due to the Erlang VM.  But Go allows you to more easily understand and optimize the memory and CPU performance of your application.</div><br/><div id="41231539" class="c"><input type="checkbox" id="c-41231539" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224801">parent</a><span>|</span><a href="#41227168">next</a><span>|</span><label class="collapse" for="c-41231539">[-]</label><label class="expand" for="c-41231539">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, didn&#x27;t OCaml have weak support for concurrency? Has that changed recently?<p>OCaml has had Lwt for concurrent IO for long enough that it is now being deprecated in favor of Eio[1]:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ocsigen&#x2F;lwt">https:&#x2F;&#x2F;github.com&#x2F;ocsigen&#x2F;lwt</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ocaml-multicore&#x2F;eio">https:&#x2F;&#x2F;github.com&#x2F;ocaml-multicore&#x2F;eio</a></div><br/></div></div><div id="41227168" class="c"><input type="checkbox" id="c-41227168" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224801">parent</a><span>|</span><a href="#41231539">prev</a><span>|</span><a href="#41224924">next</a><span>|</span><label class="collapse" for="c-41227168">[-]</label><label class="expand" for="c-41227168">[1 more]</label></div><br/><div class="children"><div class="content">Well regardless of the goals or intent of its creators, it has found success as a general purpose language suited to a broad set of unrelated tasks. And in fact that is exactly how it is being recommended here by the articles author: so within this context I don&#x27;t think it makes sense to exclude these other languages.<p>But even aside from that we were just talking about tooling at the moment.</div><br/></div></div><div id="41224924" class="c"><input type="checkbox" id="c-41224924" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224801">parent</a><span>|</span><a href="#41227168">prev</a><span>|</span><a href="#41224691">next</a><span>|</span><label class="collapse" for="c-41224924">[-]</label><label class="expand" for="c-41224924">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Go was explicitly designed for fast compile times, especially compared to C++, and I haven&#x27;t heard anything to suggest that&#x27;s no longer the case<p>Well, it’s quite easy to be fast if you are just spewing out barely optimized machine code. Compilers aren’t slow just for the sake of it.</div><br/><div id="41225231" class="c"><input type="checkbox" id="c-41225231" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224924">parent</a><span>|</span><a href="#41224691">next</a><span>|</span><label class="collapse" for="c-41225231">[-]</label><label class="expand" for="c-41225231">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is there are more fundamental reasons for why Go compiles faster, like how it handles &quot;includes&quot;.  And not supporting the C++ templating system.<p>And some things that slow down compiles are not to improve optimization.  But to support complex, higher level language features.  Go seems to hit a sweet spot of being highly expressive without slow compile times.</div><br/></div></div></div></div></div></div><div id="41224691" class="c"><input type="checkbox" id="c-41224691" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224421">parent</a><span>|</span><a href="#41224801">prev</a><span>|</span><a href="#41225482">next</a><span>|</span><label class="collapse" for="c-41224691">[-]</label><label class="expand" for="c-41224691">[1 more]</label></div><br/><div class="children"><div class="content">I consider that a win too tbh; JS land has improved a lot with e.g. Prettier and now Biome, and those were inspired by Go&#x27;s formatter and stance saying &quot;shut the fuck up about code formatting already, this is how it&#x27;s formatted, end of story, go worry about more important things&quot;.</div><br/></div></div><div id="41225482" class="c"><input type="checkbox" id="c-41225482" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224421">parent</a><span>|</span><a href="#41224691">prev</a><span>|</span><a href="#41224377">next</a><span>|</span><label class="collapse" for="c-41225482">[-]</label><label class="expand" for="c-41225482">[2 more]</label></div><br/><div class="children"><div class="content">Go tooling is far better than Elixir and I would say above Rust.<p>You should have a look what the go command can do.</div><br/><div id="41227105" class="c"><input type="checkbox" id="c-41227105" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41225482">parent</a><span>|</span><a href="#41224377">next</a><span>|</span><label class="collapse" for="c-41227105">[-]</label><label class="expand" for="c-41227105">[1 more]</label></div><br/><div class="children"><div class="content">OK fair, I am a couple years out of date on go (and also rust) myself, so I&#x27;m comparing my recollection of both to elixir&#x27;s current state.</div><br/></div></div></div></div></div></div></div></div><div id="41224377" class="c"><input type="checkbox" id="c-41224377" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224290">parent</a><span>|</span><a href="#41224347">prev</a><span>|</span><a href="#41224396">next</a><span>|</span><label class="collapse" for="c-41224377">[-]</label><label class="expand" for="c-41224377">[1 more]</label></div><br/><div class="children"><div class="content">Author here. Well, it has worked pretty well for me so far, so I don&#x27;t know why I would switch. Go is fast and expressive enough for my use, and it&#x27;s probably outweighed by being super familiar anyway.<p>(BTW, in my eight years of Go, I think I&#x27;ve used protobufs maybe once or twice. HTTP FTW!)</div><br/></div></div><div id="41224396" class="c"><input type="checkbox" id="c-41224396" checked=""/><div class="controls bullet"><span class="by">azthecx</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224290">parent</a><span>|</span><a href="#41224377">prev</a><span>|</span><a href="#41224330">next</a><span>|</span><label class="collapse" for="c-41224396">[-]</label><label class="expand" for="c-41224396">[1 more]</label></div><br/><div class="children"><div class="content">Do you have better alternatives to Protobuf?<p>What are the shortcomings that you find with it? At work these choices have been out of my hands but I&#x27;ve used JSON Avro and Protobuf and I felt like Protobuf was the least prone to errors, best surrounding tooling and easy migrations while maintaining small payloads.</div><br/></div></div><div id="41224330" class="c"><input type="checkbox" id="c-41224330" checked=""/><div class="controls bullet"><span class="by">ergonaught</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224290">parent</a><span>|</span><a href="#41224396">prev</a><span>|</span><a href="#41224694">next</a><span>|</span><label class="collapse" for="c-41224330">[-]</label><label class="expand" for="c-41224330">[9 more]</label></div><br/><div class="children"><div class="content">&gt; I just don&#x27;t understand why you wouldn&#x27;t choose something faster and more expressive.<p>The answer to this is as simple as genuinely asking, answering, and understanding why you don&#x27;t do all of your development in assembly language.</div><br/><div id="41224348" class="c"><input type="checkbox" id="c-41224348" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224330">parent</a><span>|</span><a href="#41224694">next</a><span>|</span><label class="collapse" for="c-41224348">[-]</label><label class="expand" for="c-41224348">[8 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t mean faster in terms of execution time but in terms of development time.  And more expressive is doing more with less code.<p>We&#x27;re at complete opposite ends of the spectrum here -- how that indicated to you that I meant assembly...</div><br/><div id="41224475" class="c"><input type="checkbox" id="c-41224475" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224348">parent</a><span>|</span><a href="#41224386">next</a><span>|</span><label class="collapse" for="c-41224475">[-]</label><label class="expand" for="c-41224475">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m genuinely curious which language you see as having a better development time. I don&#x27;t mean that as arguing, I&#x27;m actually curious. I don&#x27;t know much about Go but I just began learning it 2 days ago. I&#x27;m already 50% of the way done through a really nice TUI app, and I haven&#x27;t even touched the docs.<p>To me at least, it feels extremely productive so far.</div><br/><div id="41224761" class="c"><input type="checkbox" id="c-41224761" checked=""/><div class="controls bullet"><span class="by">laserlight</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224475">parent</a><span>|</span><a href="#41224386">next</a><span>|</span><label class="collapse" for="c-41224761">[-]</label><label class="expand" for="c-41224761">[3 more]</label></div><br/><div class="children"><div class="content">Developing with Python is faster.</div><br/><div id="41225964" class="c"><input type="checkbox" id="c-41225964" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224761">parent</a><span>|</span><a href="#41225887">next</a><span>|</span><label class="collapse" for="c-41225964">[-]</label><label class="expand" for="c-41225964">[1 more]</label></div><br/><div class="children"><div class="content">When leaning on libraries pushing what&#x27;s new in computer science, like certain facets of machine learning as a prominent example, which generally aren&#x27;t found outside of the Python ecosystem, certainly. But head-to-head on well-trodden computer science paths, Python doesn&#x27;t stand a chance.</div><br/></div></div><div id="41225887" class="c"><input type="checkbox" id="c-41225887" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224761">parent</a><span>|</span><a href="#41225964">prev</a><span>|</span><a href="#41224386">next</a><span>|</span><label class="collapse" for="c-41225887">[-]</label><label class="expand" for="c-41225887">[1 more]</label></div><br/><div class="children"><div class="content">Only for small or new projects...</div><br/></div></div></div></div></div></div><div id="41224386" class="c"><input type="checkbox" id="c-41224386" checked=""/><div class="controls bullet"><span class="by">ergonaught</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224348">parent</a><span>|</span><a href="#41224475">prev</a><span>|</span><a href="#41224450">next</a><span>|</span><label class="collapse" for="c-41224386">[-]</label><label class="expand" for="c-41224386">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the same principle.<p>My own experience (I&#x27;m not the author) is that the investment required to reach the point where Go can be a &quot;hammer&quot; as in this case is lower (usually significantly lower) than with &quot;faster and more expressive&quot; languages.</div><br/></div></div><div id="41224450" class="c"><input type="checkbox" id="c-41224450" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224348">parent</a><span>|</span><a href="#41224386">prev</a><span>|</span><a href="#41224694">next</a><span>|</span><label class="collapse" for="c-41224450">[-]</label><label class="expand" for="c-41224450">[2 more]</label></div><br/><div class="children"><div class="content">Go might not be the most concise or expressive language, but it&#x27;s quite fast in terms of development time, IMO&#x2F;IME.</div><br/><div id="41224710" class="c"><input type="checkbox" id="c-41224710" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224450">parent</a><span>|</span><a href="#41224694">next</a><span>|</span><label class="collapse" for="c-41224710">[-]</label><label class="expand" for="c-41224710">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, you just write code without worrying about whether it can be done more concise or clever, it&#x27;s a very pragmatic language.<p>The downside is code volume, but honestly that is rarely the problem in software.</div><br/></div></div></div></div></div></div></div></div><div id="41224694" class="c"><input type="checkbox" id="c-41224694" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224290">parent</a><span>|</span><a href="#41224330">prev</a><span>|</span><a href="#41224397">next</a><span>|</span><label class="collapse" for="c-41224694">[-]</label><label class="expand" for="c-41224694">[4 more]</label></div><br/><div class="children"><div class="content">Faster on what axis?<p>Go has maybe the fastest compile times, for example.  Which is very important when you are iterating on a project.<p>What do you dislike about the tool chain?  Seems better than most languages to me.</div><br/><div id="41224940" class="c"><input type="checkbox" id="c-41224940" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224694">parent</a><span>|</span><a href="#41224397">next</a><span>|</span><label class="collapse" for="c-41224940">[-]</label><label class="expand" for="c-41224940">[3 more]</label></div><br/><div class="children"><div class="content">Java’s toolchain may leave some to be desired in ergonomics, but compile time is just as fast if not faster.</div><br/><div id="41225880" class="c"><input type="checkbox" id="c-41225880" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224940">parent</a><span>|</span><a href="#41224397">next</a><span>|</span><label class="collapse" for="c-41225880">[-]</label><label class="expand" for="c-41225880">[2 more]</label></div><br/><div class="children"><div class="content">What do you see missing in the Java toolchain? Frankly, I see it as one of the most complete and deep of all languages.</div><br/><div id="41228047" class="c"><input type="checkbox" id="c-41228047" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41225880">parent</a><span>|</span><a href="#41224397">next</a><span>|</span><label class="collapse" for="c-41228047">[-]</label><label class="expand" for="c-41228047">[1 more]</label></div><br/><div class="children"><div class="content">Only ergonomics, I do actually like most of it (maven central&#x2F;repository model and gradle). It is one of two truly general build tools (other being Bazel), and being that generic&#x2F;capable does mean that it can’t be as user friendly as a single-language build tool like Go’s or Rust’s. But these all break down the moment you introduce another language&#x2F;build step&#x2F;whatever, while Gradle can build the whole hodgepodge that is the Android platform just fine, which is quite a testament to its power.</div><br/></div></div></div></div></div></div></div></div><div id="41224397" class="c"><input type="checkbox" id="c-41224397" checked=""/><div class="controls bullet"><span class="by">azthecx</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224290">parent</a><span>|</span><a href="#41224694">prev</a><span>|</span><a href="#41224357">next</a><span>|</span><label class="collapse" for="c-41224397">[-]</label><label class="expand" for="c-41224397">[1 more]</label></div><br/><div class="children"><div class="content">Do you have better alternatives to Protobuf?<p>What are the shortcomings that you find with it? At work these choices have been out of my hands but I&#x27;ve used JSON Avro and Protobuf and I felt like Protobuf was the least prone to errors, best surrounding tooling and easy migrations while maintaining small payloads.</div><br/></div></div></div></div><div id="41224357" class="c"><input type="checkbox" id="c-41224357" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224290">prev</a><span>|</span><a href="#41224284">next</a><span>|</span><label class="collapse" for="c-41224357">[-]</label><label class="expand" for="c-41224357">[28 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t aiming for that. My point is more: I know Go already, it&#x27;s good enough for my purposes, so I&#x27;m using that as my hammer. I could just as well have been Java or C# I learned eight years ago and used that for everything. :)</div><br/><div id="41224422" class="c"><input type="checkbox" id="c-41224422" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224357">parent</a><span>|</span><a href="#41225725">next</a><span>|</span><label class="collapse" for="c-41224422">[-]</label><label class="expand" for="c-41224422">[19 more]</label></div><br/><div class="children"><div class="content">I just began using Go literally 2 days ago, but I could already see building most  of my projects in it from here on out. It has the type system I&#x27;d need from Java or C#, while being almost as simple and readable as Python. I love the module system so far and enjoy not having to decide on my own formatter.<p>Go is perfectly boring and simple, and seems to get out of my way. At least, that&#x27;s how it feels as a newcomer. I&#x27;m sure it will change over time, but I&#x27;m having a blast at the moment.</div><br/><div id="41232992" class="c"><input type="checkbox" id="c-41232992" checked=""/><div class="controls bullet"><span class="by">sam-hartmann</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224422">parent</a><span>|</span><a href="#41224605">next</a><span>|</span><label class="collapse" for="c-41232992">[-]</label><label class="expand" for="c-41232992">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It has the type system I&#x27;d need from Java or C#<p>Its type system is much more primitive than either one of those.</div><br/></div></div><div id="41224605" class="c"><input type="checkbox" id="c-41224605" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224422">parent</a><span>|</span><a href="#41232992">prev</a><span>|</span><a href="#41224542">next</a><span>|</span><label class="collapse" for="c-41224605">[-]</label><label class="expand" for="c-41224605">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using it for work projects for a year or two now and I still feel the same way as you.</div><br/></div></div><div id="41224542" class="c"><input type="checkbox" id="c-41224542" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224422">parent</a><span>|</span><a href="#41224605">prev</a><span>|</span><a href="#41224523">next</a><span>|</span><label class="collapse" for="c-41224542">[-]</label><label class="expand" for="c-41224542">[1 more]</label></div><br/><div class="children"><div class="content">It actually gets even better! :D Enjoy the journey!</div><br/></div></div><div id="41224523" class="c"><input type="checkbox" id="c-41224523" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224422">parent</a><span>|</span><a href="#41224542">prev</a><span>|</span><a href="#41225725">next</a><span>|</span><label class="collapse" for="c-41224523">[-]</label><label class="expand" for="c-41224523">[15 more]</label></div><br/><div class="children"><div class="content">What about the absence of exception handling?<p>Plus OO has its own advantages, even if you don&#x27;t use it all that much, its one of the best ways to fit problems into neat design patterns.<p>Go seems to be missing those features.</div><br/><div id="41224639" class="c"><input type="checkbox" id="c-41224639" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224523">parent</a><span>|</span><a href="#41225473">next</a><span>|</span><label class="collapse" for="c-41224639">[-]</label><label class="expand" for="c-41224639">[1 more]</label></div><br/><div class="children"><div class="content">In modern Java applications, interfaces are favored much more heavily than OO designs relying on inheritance.<p>And Go has very nice support for interfaces.  To the extent you don&#x27;t even need to declare support for an interface.  Go just figures it out if your type supports all the methods in the interface.<p>If you mean classical Smalltalk style OO, no Go doesn&#x27;t support that, but neither do Java or C# or C++.</div><br/></div></div><div id="41225473" class="c"><input type="checkbox" id="c-41225473" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224523">parent</a><span>|</span><a href="#41224639">prev</a><span>|</span><a href="#41224599">next</a><span>|</span><label class="collapse" for="c-41225473">[-]</label><label class="expand" for="c-41225473">[1 more]</label></div><br/><div class="children"><div class="content">Interfaces and functions do pretty much everything inheritance does. It&#x27;s just cut in a different direction. If you go in demanding that Go support inheritance you&#x27;ll be in for a bad time; if you go in demanding that it have <i>some</i> good solution to those problems that you may not be used to, you&#x27;ll find it generally has them.</div><br/></div></div><div id="41224599" class="c"><input type="checkbox" id="c-41224599" checked=""/><div class="controls bullet"><span class="by">kasey_junk</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224523">parent</a><span>|</span><a href="#41225473">prev</a><span>|</span><a href="#41224549">next</a><span>|</span><label class="collapse" for="c-41224599">[-]</label><label class="expand" for="c-41224599">[1 more]</label></div><br/><div class="children"><div class="content">Go has exceptions and exception handling in the form of panics and recovers, but go devs are discouraged from using them.<p>Go also supports most of the typical attributes of oo. It has polymorphism and encapsulation it’s just missing inheritance and uses composition instead. Most Java and C# code basis have stayed away from inheritance (for a long time) so there isn’t that big a difference.</div><br/></div></div><div id="41224549" class="c"><input type="checkbox" id="c-41224549" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224523">parent</a><span>|</span><a href="#41224599">prev</a><span>|</span><a href="#41224548">next</a><span>|</span><label class="collapse" for="c-41224549">[-]</label><label class="expand" for="c-41224549">[1 more]</label></div><br/><div class="children"><div class="content">What you see as missing, others (including myself) see as delightfully constrained and solved in a different way.</div><br/></div></div><div id="41224548" class="c"><input type="checkbox" id="c-41224548" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224523">parent</a><span>|</span><a href="#41224549">prev</a><span>|</span><a href="#41224633">next</a><span>|</span><label class="collapse" for="c-41224548">[-]</label><label class="expand" for="c-41224548">[6 more]</label></div><br/><div class="children"><div class="content">This is my first time working with a language that exclusively uses errors as values, and I haven&#x27;t had time to develop any strong feelings about it. So far it feels nice because it makes error handling crystal clear, but I could also see it becoming cumbersome over time.</div><br/><div id="41224656" class="c"><input type="checkbox" id="c-41224656" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224548">parent</a><span>|</span><a href="#41224890">next</a><span>|</span><label class="collapse" for="c-41224656">[-]</label><label class="expand" for="c-41224656">[1 more]</label></div><br/><div class="children"><div class="content">It can get verbose, but I&#x27;m willing to live with it for all the other benefits of the language.</div><br/></div></div><div id="41224890" class="c"><input type="checkbox" id="c-41224890" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224548">parent</a><span>|</span><a href="#41224656">prev</a><span>|</span><a href="#41224697">next</a><span>|</span><label class="collapse" for="c-41224890">[-]</label><label class="expand" for="c-41224890">[3 more]</label></div><br/><div class="children"><div class="content">It’s the exact same broken system as has been known from C, it’s literally checking `errno` all the time.</div><br/><div id="41231367" class="c"><input type="checkbox" id="c-41231367" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224890">parent</a><span>|</span><a href="#41224697">next</a><span>|</span><label class="collapse" for="c-41231367">[-]</label><label class="expand" for="c-41231367">[2 more]</label></div><br/><div class="children"><div class="content">I mean, you&#x27;re not wrong, It&#x27;s just strings (usually) instead of ints.<p>It&#x27;s pretty bad, but it turns out that exceptions and inverting my entire program to pass into a Result&#x27;s flatmap chain are even worse.<p>When they come up with another strategy, I&#x27;ll try that instead, but until then I&#x27;ll keep using the least bad option I&#x27;ve found.</div><br/><div id="41232977" class="c"><input type="checkbox" id="c-41232977" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41231367">parent</a><span>|</span><a href="#41224697">next</a><span>|</span><label class="collapse" for="c-41232977">[-]</label><label class="expand" for="c-41232977">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s pretty bad, but it turns out that exceptions and inverting my entire program to pass into a Result&#x27;s flatmap chain are even worse<p>Based on what? Exceptions do the sensible thing at all times: auto-bubbling up (no random swallowing), contain info about its origin, and a handler can be specified as tightly or widely as necessary.<p>It’s objectively superior to grepping for an error message, or straight up not doing anything which go is especially prone to do, as after a time all the if errs become just visual noise.</div><br/></div></div></div></div></div></div><div id="41224697" class="c"><input type="checkbox" id="c-41224697" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224548">parent</a><span>|</span><a href="#41224890">prev</a><span>|</span><a href="#41224633">next</a><span>|</span><label class="collapse" for="c-41224697">[-]</label><label class="expand" for="c-41224697">[1 more]</label></div><br/><div class="children"><div class="content">I mean to this end, Go is more closer to Perl(C&#x2F;Unix family) than to Python(Pascal? family).<p>But by now most programers are so very used to making the language do a lot of error handling kind of chores that having to do them manually kind of feels doing work that shouldn&#x27;t be done(Like doing what the language should have been doing).<p>Of course you could bolt OO onto Go. In a way similar to how Perl provides kind of bare bones means assemble a OO system. But that is not the point, having syntax to this baked into the language just makes it easier and standardised to learn and use well.<p>Perhaps Go is Perl done right? Than a replace for Python.<p>But one has to see for how long it can maintain its minimalism. On the longer run code turns to be as complicated as the problem you are trying to solve. Removing the features doesn&#x27;t make the code simple, it simply make it explicit(a.k.a Verbose)</div><br/></div></div></div></div><div id="41224633" class="c"><input type="checkbox" id="c-41224633" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224523">parent</a><span>|</span><a href="#41224548">prev</a><span>|</span><a href="#41225725">next</a><span>|</span><label class="collapse" for="c-41224633">[-]</label><label class="expand" for="c-41224633">[4 more]</label></div><br/><div class="children"><div class="content">? It doesn&#x27;t have exceptions, so it doesn&#x27;t need exception handling. It has an error system &#x2F; standard that isn&#x27;t based on exceptions.<p>I only know exceptions from Java myself, and in practice, what it calls exceptions are often... well, not exceptions at all. Files missing, SQL queries returning no errors, division by zero are not exceptional situations, but normal day to day events. And an exception generates a stack trace, which is an expensive operation.<p>I mean one way to avoiding that is defensive programming - check if a file exists, do a count on the SQL query first, do a pre-check or assertion before dividing - but that adds more and more code that you need to write, test and maintain.<p>OO has merit for what you describe, but Go&#x27;s alternative works just as well (imo) for that purpose; you have struct types containing data, you can add methods to those types to encapsulate behaviour. Go doesn&#x27;t have OO inheritance, but inheritance has been out of fashion for years now so it&#x27;s not missed.<p>TL;DR, exceptions and OO are solutions to problems, Go has its own solutions to those problems, neither of which are difficult to understand.</div><br/><div id="41228319" class="c"><input type="checkbox" id="c-41228319" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224633">parent</a><span>|</span><a href="#41224814">next</a><span>|</span><label class="collapse" for="c-41228319">[-]</label><label class="expand" for="c-41228319">[1 more]</label></div><br/><div class="children"><div class="content">Throwing prevents the caller&#x27;s control flow from passing into code that assumes a useful value was returned and ready to be consumed when it wasn&#x27;t. Handling a success or a failure with exactly the same code shouldn&#x27;t be a default because it almost never makes sense.<p>A Java exception can suppress stack trace init if needed, letting an instance be created once and reused very cheaply (though logs will be less useful).</div><br/></div></div><div id="41224814" class="c"><input type="checkbox" id="c-41224814" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224633">parent</a><span>|</span><a href="#41228319">prev</a><span>|</span><a href="#41225725">next</a><span>|</span><label class="collapse" for="c-41224814">[-]</label><label class="expand" for="c-41224814">[2 more]</label></div><br/><div class="children"><div class="content">The whole idea of exception handling with try&#x2F;catch comes from the fact that problems and error handling can all be standardised into one structure of patterns. Once you are here you can be sure the language(compiler) and tooling(IDE&#x2F;Editor etc) will generate them for you and provide you with means to handle them.<p>Nothing much has changed in terms of problems and interfaces. So the errors will remain the same.<p>Now when you use go, you will have to write a lot of code that other wise the language+tooling could do automatically for you. This is just doing work that you shouldn&#x27;t even be doing the first place and pointless verbosity.<p>Minimal is not always better. And some parts just feel like they were omitted because the language designer didn&#x27;t want to do the work for you. Whereas the whole point of a programming language is that it does as much work for you as it possibly can and make it easier for you.<p>Just saying writing the same&#x2F;similar code over and over again is waste work.</div><br/><div id="41227148" class="c"><input type="checkbox" id="c-41227148" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224814">parent</a><span>|</span><a href="#41225725">next</a><span>|</span><label class="collapse" for="c-41227148">[-]</label><label class="expand" for="c-41227148">[1 more]</label></div><br/><div class="children"><div class="content">Of course, Go has try&#x2F;catch, albeit under the keywords panic&#x2F;recover. The whole idea of not using it, most of the time, except for the case of exceptions, comes from the fact that problems and error handling have shown to not in any way fit well into a standardized structure. Ruby, for example, came to the same realization even before Go. This is something that was already becoming understood before Go was conceived.<p><i>Sometimes</i> it works out. Certainly encoding&#x2F;json in the Go standard library shows that it&#x27;s quite acceptable to use where appropriate – the programming tools are there to use, but it turns out that it is rarely appropriate. Which is also why most other languages are also trying their best to move away from the practice as a general rule, if it ever was adopted at all.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41225725" class="c"><input type="checkbox" id="c-41225725" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224357">parent</a><span>|</span><a href="#41224422">prev</a><span>|</span><a href="#41224434">next</a><span>|</span><label class="collapse" for="c-41225725">[-]</label><label class="expand" for="c-41225725">[1 more]</label></div><br/><div class="children"><div class="content">And this is a perfectly reasonable approach. Frankly, the cost&#x2F;benefit ratio of delving into another language is most often not appealing.<p>As a suggestion, you could have delved more into the &quot;hammer&quot; metaphor, mentioning that a hammer is a flexible tool: nail planks, remove nails, smash things and even as a defensive weapon! You shouldn&#x27;t misuse it for drilling walls, but that is outside the required scope of your work etc.<p>But in the end it&#x27;s a very personal post, and we typically crave here for universality and judge posts up high from a meta-perspective, haha. Often neglecting that we were not actually the intended audience.</div><br/></div></div><div id="41224434" class="c"><input type="checkbox" id="c-41224434" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224357">parent</a><span>|</span><a href="#41225725">prev</a><span>|</span><a href="#41224284">next</a><span>|</span><label class="collapse" for="c-41224434">[-]</label><label class="expand" for="c-41224434">[7 more]</label></div><br/><div class="children"><div class="content">Just looking at Go after having experience with Erlang and Crystal, does it still have a narrow-minded view of what features language won&#x27;t support?<p>Like I remember there was a whole drama about generics, errors being simple strings and always returned without being able to raise them, is this attitude still there or have things changed?</div><br/><div id="41224663" class="c"><input type="checkbox" id="c-41224663" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224434">parent</a><span>|</span><a href="#41224551">next</a><span>|</span><label class="collapse" for="c-41224663">[-]</label><label class="expand" for="c-41224663">[3 more]</label></div><br/><div class="children"><div class="content">That attitude is still there because there is no compelling reason to move away from that. A lot of languages have been diseased by bolting on features for no other reason than different languages have them, and it&#x27;s overcomplicated the languages and fragmented the codebases.<p>Example, if you ask ten Scala developers to solve a problem, you&#x27;ll get ten different solutions. That number drops quickly for less feature-rich and more opinionated languages like Go.</div><br/><div id="41225817" class="c"><input type="checkbox" id="c-41225817" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224663">parent</a><span>|</span><a href="#41224551">next</a><span>|</span><label class="collapse" for="c-41225817">[-]</label><label class="expand" for="c-41225817">[2 more]</label></div><br/><div class="children"><div class="content">I agree with that and Scala example, but also languages diseased by not evolving and not allowing new widely-accepted features. I wonder what would happen with Go if they never changed their mind and kept it without generics?<p>My point is not about bringing all features other languages have (its just not possible unless its a lisp), but rather creating a new language and not understanding how vital something like generics is for general purpose programming. That is an orange flag for me.</div><br/><div id="41227527" class="c"><input type="checkbox" id="c-41227527" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41225817">parent</a><span>|</span><a href="#41224551">next</a><span>|</span><label class="collapse" for="c-41227527">[-]</label><label class="expand" for="c-41227527">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I wonder what would happen with Go if they never changed their mind and kept it without generics?</i><p>Change their mind? What do you mean? Go always maintained it would get them, once the right design was found – which was echoed by Ian Lance Taylor actually working on them even before the first public release. He alone has, what, 8 different failed proposals?<p>The problem was always, quite explicitly, that nobody within the Go team had the full expertise necessary to create something that wasn&#x27;t going to be a nightmare later. As you may recall, once they finally got budget approval to hire an outside domain expert, the necessary progress was finally made.<p>Being an open source project, you&#x27;d think the armchair experts on HN would have stepped in and filled in that gap, but I suppose it is always easier to talk big than to act.</div><br/></div></div></div></div></div></div><div id="41224551" class="c"><input type="checkbox" id="c-41224551" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224434">parent</a><span>|</span><a href="#41224663">prev</a><span>|</span><a href="#41224778">next</a><span>|</span><label class="collapse" for="c-41224551">[-]</label><label class="expand" for="c-41224551">[1 more]</label></div><br/><div class="children"><div class="content">Nope, it&#x27;s the same. It&#x27;s one of the things I value about the language and project.</div><br/></div></div><div id="41224778" class="c"><input type="checkbox" id="c-41224778" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224434">parent</a><span>|</span><a href="#41224551">prev</a><span>|</span><a href="#41224672">next</a><span>|</span><label class="collapse" for="c-41224778">[-]</label><label class="expand" for="c-41224778">[1 more]</label></div><br/><div class="children"><div class="content">Well, Go has generics now and you can do quite a few tricks with errors. 
In the end error handling logic is up to developer.<p>UPD: thankfully Go does not try to bring in every &quot;feature&quot; possible. Not without consideration at least.</div><br/></div></div><div id="41224672" class="c"><input type="checkbox" id="c-41224672" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224434">parent</a><span>|</span><a href="#41224778">prev</a><span>|</span><a href="#41224284">next</a><span>|</span><label class="collapse" for="c-41224672">[-]</label><label class="expand" for="c-41224672">[1 more]</label></div><br/><div class="children"><div class="content">No, that attitude is core to the design of Go and one of the key reasons people pick it for projects.<p>Generics were eventually added.  But not until they thought through very carefully performance and compilation time implications.</div><br/></div></div></div></div></div></div><div id="41224284" class="c"><input type="checkbox" id="c-41224284" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224357">prev</a><span>|</span><a href="#41224625">next</a><span>|</span><label class="collapse" for="c-41224284">[-]</label><label class="expand" for="c-41224284">[2 more]</label></div><br/><div class="children"><div class="content">I think he could have chosen those alternatives just as well, he just happened to pick Go. His argument is that he strives to use his chosen tool in as many situations as possible instead of having a bunch of different ones.</div><br/><div id="41224388" class="c"><input type="checkbox" id="c-41224388" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224284">parent</a><span>|</span><a href="#41224625">next</a><span>|</span><label class="collapse" for="c-41224388">[-]</label><label class="expand" for="c-41224388">[1 more]</label></div><br/><div class="children"><div class="content">Yup, this exactly!</div><br/></div></div></div></div><div id="41224625" class="c"><input type="checkbox" id="c-41224625" checked=""/><div class="controls bullet"><span class="by">alemanek</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224284">prev</a><span>|</span><a href="#41224301">next</a><span>|</span><label class="collapse" for="c-41224625">[-]</label><label class="expand" for="c-41224625">[3 more]</label></div><br/><div class="children"><div class="content">I am someone with significant experience in Java, C#, C++, and JS&#x2F;TS.  I am a bit of a newbie to Go but have used it for a few things at work.  So, I can give a bit of a comparison for you.<p>I really like the DevX and strong standard library of Go.  Also I really like that the community around Go has a strong preference for just using the stdlib and not going crazy with third party libraries.<p>Languages are just tools but I have a strong preference for Go for backend services and CLI applications now. Just my 2cents.</div><br/><div id="41226335" class="c"><input type="checkbox" id="c-41226335" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224625">parent</a><span>|</span><a href="#41224301">next</a><span>|</span><label class="collapse" for="c-41226335">[-]</label><label class="expand" for="c-41226335">[2 more]</label></div><br/><div class="children"><div class="content">Hey, thanks for the reply. That sounds really nice!<p>I wonder, which aspects of the &quot;Go&quot; std lib are considered strong? Would you say it is more like .net where the std-lib also comes with framework-grade capabilities such as REST-endpoints and setting up applications?<p>Because in the classical sense of a library, I think Java is fantastic (collections, strings, NIO, HTTP 2.0, etc.). But it misses framework-level out-of-the-box solutions.</div><br/><div id="41230582" class="c"><input type="checkbox" id="c-41230582" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41226335">parent</a><span>|</span><a href="#41224301">next</a><span>|</span><label class="collapse" for="c-41230582">[-]</label><label class="expand" for="c-41230582">[1 more]</label></div><br/><div class="children"><div class="content">Not STD comes close to .NET, IMO.</div><br/></div></div></div></div></div></div><div id="41224301" class="c"><input type="checkbox" id="c-41224301" checked=""/><div class="controls bullet"><span class="by">kamikaz1k</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224625">prev</a><span>|</span><a href="#41224587">next</a><span>|</span><label class="collapse" for="c-41224301">[-]</label><label class="expand" for="c-41224301">[5 more]</label></div><br/><div class="children"><div class="content">Go is getting hype because TS is old news. And people got tired of being nerd sniped into trying Rust and being let down.<p>It’s okay, hype cycles are good since it shakes up mainstream opinion and gets people to try stuff. Like a new trendy food. I don’t feel much in the ways about it.<p>How do you feel about Go outside of the hype cycle?</div><br/><div id="41224460" class="c"><input type="checkbox" id="c-41224460" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224301">parent</a><span>|</span><a href="#41226238">next</a><span>|</span><label class="collapse" for="c-41224460">[-]</label><label class="expand" for="c-41224460">[3 more]</label></div><br/><div class="children"><div class="content">How is Go not older news than TS?</div><br/><div id="41224489" class="c"><input type="checkbox" id="c-41224489" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224460">parent</a><span>|</span><a href="#41226238">next</a><span>|</span><label class="collapse" for="c-41224489">[-]</label><label class="expand" for="c-41224489">[2 more]</label></div><br/><div class="children"><div class="content">I think hype is more about trends than it is about age. PHP is going through a bit of a hype phase right now, for instance, mostly because of Laravel and the fact that the language has been silently improving a lot since the wordpress days, and developers are just now starting to realize it.</div><br/><div id="41224572" class="c"><input type="checkbox" id="c-41224572" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224489">parent</a><span>|</span><a href="#41226238">next</a><span>|</span><label class="collapse" for="c-41224572">[-]</label><label class="expand" for="c-41224572">[1 more]</label></div><br/><div class="children"><div class="content">I believe there are many different hype cycles at once, depending on ones vantage point. The world is large!</div><br/></div></div></div></div></div></div><div id="41226238" class="c"><input type="checkbox" id="c-41226238" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224301">parent</a><span>|</span><a href="#41224460">prev</a><span>|</span><a href="#41224587">next</a><span>|</span><label class="collapse" for="c-41226238">[-]</label><label class="expand" for="c-41226238">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go is getting hype because TS is old news. And people got tired of being nerd sniped into trying Rust and being let down.<p>Sounds like my impression as well.<p>&gt; How do you feel about Go outside of the hype cycle?<p>I think it&#x27;s in a weird place, but I have a much higher opinion of the language ever since it got generics.<p>There is nothing which is inherently unique to Go, but it got some neat technical features: Static compilation, garbage collection, good model for multithreading, fast compilation times. With these qualities you can get pretty far and have good cloud readiness.<p>However, I&#x27;m a Java guy and the JVM is my working horse. I have seen how large projects (don&#x27;t) scale once you have 8+ developers and there are shortcomings in Go for projects of this size. And I think the explicit nature of nominal typing  (e.g. Java) absolutely wins over the implicit structural typing one (e.g Go).<p>You see this difference of philosophies by interface constraints: Java interfaces must be implemented explicitly and you can even limit who can implement them. Java is primarily a language designed for libraries &amp; frameworks and the quality shows it.<p>With structural and open implementation of interfaces, your line of code-ownership becomes blurry. This is not nearly as problematic as dynamic typing, but in my mind an interface is a specification. And you there should be a contract between the provider and consumer. This also helps with understanding the connections inside&#x2F;between code-bases.<p>Same about interfaces can be said about First Class Functions vs. Functional Interfaces. Functional Interfaces can be documented, domain-specific, extended and implemented. It feels like a perfect blend of FP and OOP, whereas with First Class Functions I feel like I am working with C-stylee primitives which don&#x27;t help me express the nature of the solution I want to model nearly as much.<p>As for Java, I have an immeasurable amount of respect for the current language designers (can&#x27;t say I have the same respect for Go Designers after the drama surrounding generics). I am an avid reader of their mailing list and time and time again, they have shown deep thought and tremendous foresight (their way of work is quite inspiring). Yes, they have to live with some nasty historical baggage, but they have a very high level of quality.<p>Then there are aspects such as the ever-evolving JVM, along with its choice of several garbage collectors and top-tier runtime analysis (Flight Recorder) &amp; optimization (Hot Spot).<p>Sorry, this is entirely subjective but you asked me how I &quot;feel&quot; about it :-)<p>Summing it up, I&#x27;d say Go is a comfortable local maximum which can give you a whole lot, but ultimately is less flexible. But it&#x27;s surely enough for 90% of applications. In this sense Go is like the big brother of PHP, which is a perfectly reasonable language if all you need in your backend are save&#x2F;load database operations. Go can cope with that too, but also scale into non-trivial domains, the cloud and multi-threaded problems.<p>But Java is &quot;corpoaraty&quot; and not &quot;trendy&quot;, so most people don&#x27;t even consider it as an option. And there are enough bad devs who started their carreer in JS&#x2F;TS and want to move towards something more performant, that is still as ad-hoc and don&#x27;t mind sharp edges because they never learned to reason about their application in a more formal sense.<p>But looking at the work that is currently being done to the JVM, I&#x27;m looking forward to the near future when we can run Java-compatible bytecode on GPUs and AVX512.</div><br/></div></div></div></div><div id="41224587" class="c"><input type="checkbox" id="c-41224587" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224301">prev</a><span>|</span><a href="#41224297">next</a><span>|</span><label class="collapse" for="c-41224587">[-]</label><label class="expand" for="c-41224587">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll give it a shot.<p>The tools make a lot of decisions for you that are pretty arbitrary, like how to format code, freeing up brain cycles for other things.<p>It compiles very fast, so the iteration cycle is similar to a dynamic language with a REPL.  Very little time between making a change, running and seeing the new result.  The language is designed from the bottom up for fast compile times even in large projects, with features at odds with fast compilation rejected.<p>Decent sized community and library ecosystem.<p>The networking APIs are very simple and productive.  More and more back end code is being written in Go for this reason.<p>The semantics are straight forward.  The other programming environment I need to deal with at work is Spring Java, which is unjustifiably complex and obfuscated for what it does.  Go allows you to read the code and run the program in your head understanding semantics and performance characteristics.<p>Builds single file executables that are simple to deploy.<p>Has just enough high level features to be productive without compromising above points about simplicity, fast compiles, and comprehensibility.  Channels and go routines work very well to model concurrency across a wide array of problem domains.<p>Maintainers are careful about adding new features.  Generics took a long time to arrive, but when it did was very well thought out and did not negatively impact performance very much.<p>I&#x27;m sure I&#x27;ll think of more.</div><br/></div></div><div id="41224297" class="c"><input type="checkbox" id="c-41224297" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224587">prev</a><span>|</span><a href="#41224676">next</a><span>|</span><label class="collapse" for="c-41224297">[-]</label><label class="expand" for="c-41224297">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s fine. Honestly I think there’s a lot more deep developers out there than broad developers. It’s just they don’t blog about depth the way broad developers blog about their shiny new toy.</div><br/></div></div><div id="41224676" class="c"><input type="checkbox" id="c-41224676" checked=""/><div class="controls bullet"><span class="by">daghamm</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224297">prev</a><span>|</span><a href="#41228874">next</a><span>|</span><label class="collapse" for="c-41224676">[-]</label><label class="expand" for="c-41224676">[2 more]</label></div><br/><div class="children"><div class="content">How can you call Go hype driven?<p>It was literally designed to be &quot;boring&quot;.</div><br/><div id="41228555" class="c"><input type="checkbox" id="c-41228555" checked=""/><div class="controls bullet"><span class="by">cy_hauser</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224676">parent</a><span>|</span><a href="#41228874">next</a><span>|</span><label class="collapse" for="c-41228555">[-]</label><label class="expand" for="c-41228555">[1 more]</label></div><br/><div class="children"><div class="content">I think it was the Go Marketing Team who decided to call it a boring language. &quot;Boring&quot; tested well for hyping the language.</div><br/></div></div></div></div><div id="41228874" class="c"><input type="checkbox" id="c-41228874" checked=""/><div class="controls bullet"><span class="by">gavindean90</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41224676">prev</a><span>|</span><a href="#41224309">next</a><span>|</span><label class="collapse" for="c-41228874">[-]</label><label class="expand" for="c-41228874">[1 more]</label></div><br/><div class="children"><div class="content">Honestly it gave me the feeling of not arguing to use Go but instead arguing to use the full featured language you know the best. The caveat being that it is of you are a single developer making all the decisions and writing all the code. Seemed to make a good case for that</div><br/></div></div><div id="41224309" class="c"><input type="checkbox" id="c-41224309" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41224224">parent</a><span>|</span><a href="#41228874">prev</a><span>|</span><a href="#41224432">next</a><span>|</span><label class="collapse" for="c-41224309">[-]</label><label class="expand" for="c-41224309">[6 more]</label></div><br/><div class="children"><div class="content">Thanks for posting this.<p>It’s an unfortunate choice of “one hammer to rule them all” given Go does not offer necessary coverage at both low and high ends of abstraction (and performance) the way C# does. For me, it’s a similar kind of hammer.<p>(I prefer to think of it as a crowbar ;D)</div><br/><div id="41225906" class="c"><input type="checkbox" id="c-41225906" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41224309">parent</a><span>|</span><a href="#41224432">next</a><span>|</span><label class="collapse" for="c-41225906">[-]</label><label class="expand" for="c-41225906">[5 more]</label></div><br/><div class="children"><div class="content">The problem with C# is its created by Microsoft, even if its a good language its hard to look at it and not think how much its limited while used outside of Windows.</div><br/><div id="41230118" class="c"><input type="checkbox" id="c-41230118" checked=""/><div class="controls bullet"><span class="by">rlp</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41225906">parent</a><span>|</span><a href="#41226015">next</a><span>|</span><label class="collapse" for="c-41230118">[-]</label><label class="expand" for="c-41230118">[1 more]</label></div><br/><div class="children"><div class="content">This is no longer remotely true. Most .NET teams I know now deploy on Linux and develop on Windows&#x2F;Mac&#x2F;Linux.</div><br/></div></div><div id="41226015" class="c"><input type="checkbox" id="c-41226015" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41225906">parent</a><span>|</span><a href="#41230118">prev</a><span>|</span><a href="#41224432">next</a><span>|</span><label class="collapse" for="c-41226015">[-]</label><label class="expand" for="c-41226015">[3 more]</label></div><br/><div class="children"><div class="content">It seems that you <i>might</i> be asking this question in bad faith.<p>But on the off chance you are not, please find previous replies that address the same kind of question below:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41037792">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41037792</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41189309">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41189309</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41211767">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41211767</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41197493">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41197493</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41218353">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41218353</a></div><br/><div id="41230477" class="c"><input type="checkbox" id="c-41230477" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41226015">parent</a><span>|</span><a href="#41224432">next</a><span>|</span><label class="collapse" for="c-41230477">[-]</label><label class="expand" for="c-41230477">[2 more]</label></div><br/><div class="children"><div class="content">I understand its probably not the case today, just that C# shares some of the MS reputation and its hard to get rid of. Especially when there are dozens of open-source independent languages around.</div><br/><div id="41230587" class="c"><input type="checkbox" id="c-41230587" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41224224">root</a><span>|</span><a href="#41230477">parent</a><span>|</span><a href="#41224432">next</a><span>|</span><label class="collapse" for="c-41230587">[-]</label><label class="expand" for="c-41230587">[1 more]</label></div><br/><div class="children"><div class="content">I think phrasing with <i>insistence</i> that it is &quot;<i>probably</i> not the case today&quot; despite demonstrable evidence of certainty means that the motivation for this reply was not to learn something new or share something you know but to try to get a raise with low-effort bait. This is both tiresome and goes against guidelines.<p>Somehow we all can normally discuss programming languages without bringing practices of Google or Oracle into the picture and focus instead on programming language development initiatives that they drive and sponsor, that are themselves sufficiently independent. Let&#x27;s keep it that way.<p>Also <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41218353">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41218353</a> (which was the last link in the list).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41224432" class="c"><input type="checkbox" id="c-41224432" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#41224224">prev</a><span>|</span><a href="#41232618">next</a><span>|</span><label class="collapse" for="c-41224432">[-]</label><label class="expand" for="c-41224432">[3 more]</label></div><br/><div class="children"><div class="content">None of these reasons are specific to Go.  They apply just as well to any Turing complete programming language.<p>Not to say the arguments are bad.  Just that the argument is for picking one tool and using it for everything to benefit from your investment in that tool across all your projects.</div><br/><div id="41233306" class="c"><input type="checkbox" id="c-41233306" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#41224432">parent</a><span>|</span><a href="#41224499">next</a><span>|</span><label class="collapse" for="c-41233306">[-]</label><label class="expand" for="c-41233306">[1 more]</label></div><br/><div class="children"><div class="content">I wish &quot;any Turing complete language&quot; wasn&#x27;t used as a catchphrase.<p>Especially that such a claim is so stinky. In what way the Brainfuck programming language environment is giving the coder same experience as Go, huh? Because, if it&#x27;s not, I just invalidated your claim.</div><br/></div></div><div id="41224499" class="c"><input type="checkbox" id="c-41224499" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41224432">parent</a><span>|</span><a href="#41233306">prev</a><span>|</span><a href="#41232618">next</a><span>|</span><label class="collapse" for="c-41224499">[-]</label><label class="expand" for="c-41224499">[1 more]</label></div><br/><div class="children"><div class="content">Yep, totally agree! But I learned Go, so I wrote about that. :D I tried Brainfuck once, but I don&#x27;t think my brain can wrap that enough to make it a career.</div><br/></div></div></div></div><div id="41232618" class="c"><input type="checkbox" id="c-41232618" checked=""/><div class="controls bullet"><span class="by">surfingdino</span><span>|</span><a href="#41224432">prev</a><span>|</span><a href="#41232824">next</a><span>|</span><label class="collapse" for="c-41232618">[-]</label><label class="expand" for="c-41232618">[1 more]</label></div><br/><div class="children"><div class="content">I was hesitant to learn Go after 10+ years of Python, but then I started work on a side project where performance translated into actual money savings for me. My Python code routinely took between 100-200ms to run. I was happy, but I was also curious if I could do better without rewriting it in C&#x2F;C++. Go proved to be easy to learn and being compiled it was much easier to deploy (that was before I could rely on Docker for packaging). The big surprise came when I ran my code and found out that each request would take 10-20ms to process same payloads. I have never written a line of code in another language on the backend ever since. The cherry on top is support for multithreading&#x2F;multi-core CPUs. I&#x27;ve been in Python by day client work), Golang by night (my own work) mode for many years now. It&#x27;s a great language. OK, I do admit to learning Rust, but... it&#x27;s just out of curiosity, not out of need for anything &quot;better&quot;.</div><br/></div></div><div id="41232824" class="c"><input type="checkbox" id="c-41232824" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#41232618">prev</a><span>|</span><a href="#41231205">next</a><span>|</span><label class="collapse" for="c-41232824">[-]</label><label class="expand" for="c-41232824">[1 more]</label></div><br/><div class="children"><div class="content">I feel the same, but for me Rust is currently my hammer ;)<p>Checks all of the checkboxes.</div><br/></div></div><div id="41231205" class="c"><input type="checkbox" id="c-41231205" checked=""/><div class="controls bullet"><span class="by">theappsecguy</span><span>|</span><a href="#41232824">prev</a><span>|</span><a href="#41224993">next</a><span>|</span><label class="collapse" for="c-41231205">[-]</label><label class="expand" for="c-41231205">[2 more]</label></div><br/><div class="children"><div class="content">I really want to love Go for side projects but it’s just so verbose and time consuming.<p>I understand that a framework with ”batteries” goes against Go principles, but coming from Rails, which solves the common boring problems for me, Go just makes it too much of a pain.<p>At least as far as web dev goes, I’m sure Go is great for other stuff.</div><br/><div id="41231235" class="c"><input type="checkbox" id="c-41231235" checked=""/><div class="controls bullet"><span class="by">srameshc</span><span>|</span><a href="#41231205">parent</a><span>|</span><a href="#41224993">next</a><span>|</span><label class="collapse" for="c-41231235">[-]</label><label class="expand" for="c-41231235">[1 more]</label></div><br/><div class="children"><div class="content">Back in 2012 or sometime around it, I was trying Akka a Java library and trying concurrency and stuff. Around the same time I gave Go a try and it was much less verbose and simple. Never looked at Java after that, but I never felt Go is verbose.</div><br/></div></div></div></div><div id="41224993" class="c"><input type="checkbox" id="c-41224993" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#41231205">prev</a><span>|</span><a href="#41231186">next</a><span>|</span><label class="collapse" for="c-41224993">[-]</label><label class="expand" for="c-41224993">[1 more]</label></div><br/><div class="children"><div class="content">I find Go akin to C ; it&#x27;s really fast to pick up, I can use it without internet if I have to, it has enough functionality and enough stable libraries for me not really to have to bother with the latest and the greatest of everything like in the javascript world.<p>I use it when I cannot use CL (for basically everything) or Racket (language &#x2F; code generation), which basically means &#x27;if my clients doesn&#x27;t accept the above&#x27;.<p>For web&#x2F;desktop&#x2F;backend CL and Go are both incredibly productive. CL for me is more productive, mostly because the effortless starting, far more expressive (do a lot with very little code), better repl, debugging, save and die etc. Single binaries are great about both and so is lightning fast compilation.<p>I guess I have two hammers; one of them has a more comfortable handle for whacking in those slightly more difficult nails.<p>Lately I cheat by using a subset of CL and generating the Go code.</div><br/></div></div><div id="41231186" class="c"><input type="checkbox" id="c-41231186" checked=""/><div class="controls bullet"><span class="by">999900000999</span><span>|</span><a href="#41224993">prev</a><span>|</span><a href="#41232493">next</a><span>|</span><label class="collapse" for="c-41231186">[-]</label><label class="expand" for="c-41231186">[1 more]</label></div><br/><div class="children"><div class="content">The article claims Go supports building GUI apps and links to this.<p>&gt;Wails is a project that enables you to write desktop apps using Go and web technologies<p>At that point why not just use Electron and Node JS.<p>I like Golang, I truly do. But after building mobile apps in both Golang and Fluter, I&#x27;m well aware of Go&#x27;s limitations.<p>Making anything look remotely nice is painful. Things get really difficult when you use the wrong tool for the job.<p>A much better argument could be made for JavaScript being a language that can do anything.  Even then when ever you run npm install you need to pray the house of cards that is modern JavaScript doesn&#x27;t collapse.<p>C# is also a contender, but people, particularly the FOSS crowd doesn&#x27;t like it because Microsoft == Bad.</div><br/></div></div><div id="41232493" class="c"><input type="checkbox" id="c-41232493" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#41231186">prev</a><span>|</span><a href="#41227103">next</a><span>|</span><label class="collapse" for="c-41232493">[-]</label><label class="expand" for="c-41232493">[1 more]</label></div><br/><div class="children"><div class="content">Same here, as a solo entrenpreuner who is 50+, I love Go for it&#x27;s simplicity. And e.g. migrated my Newsletter generation pipeline from Python to Go.</div><br/></div></div><div id="41227103" class="c"><input type="checkbox" id="c-41227103" checked=""/><div class="controls bullet"><span class="by">hintymad</span><span>|</span><a href="#41232493">prev</a><span>|</span><label class="collapse" for="c-41227103">[-]</label><label class="expand" for="c-41227103">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So, what, I’m going to limit my career options?<p>I don&#x27;t quite get this sentiment. In my experience, the career opportunities come from solving worthy problems, as opposed to using a particular language. Plus, I don&#x27;t believe that an engineer should be identified by a language, as in a Go programmer, or a Java programmer.</div><br/><div id="41228457" class="c"><input type="checkbox" id="c-41228457" checked=""/><div class="controls bullet"><span class="by">markusw</span><span>|</span><a href="#41227103">parent</a><span>|</span><label class="collapse" for="c-41228457">[-]</label><label class="expand" for="c-41228457">[1 more]</label></div><br/><div class="children"><div class="content">But often, a client needs a developer for an existing stack, and advertising as a Go programmer (for example) gives you an edge over someone who doesn&#x27;t, in my experience.</div><br/></div></div></div></div></div></div></div></div></div></body></html>