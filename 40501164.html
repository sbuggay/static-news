<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716973278411" as="style"/><link rel="stylesheet" href="styles.css?v=1716973278411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/turbo9team/turbo9">Turbo9 – A Compact and Efficient Pipelined 6809 Microprocessor IP</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>38 comments</span></div><br/><div><div id="40507867" class="c"><input type="checkbox" id="c-40507867" checked=""/><div class="controls bullet"><span class="by">anonymousiam</span><span>|</span><a href="#40503289">next</a><span>|</span><label class="collapse" for="c-40507867">[-]</label><label class="expand" for="c-40507867">[1 more]</label></div><br/><div class="children"><div class="content">Time to dust off OS-9 (MicroWare, not Apple) and give it a try on this thing...
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;OS-9" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;OS-9</a></div><br/></div></div><div id="40503289" class="c"><input type="checkbox" id="c-40503289" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#40507867">prev</a><span>|</span><a href="#40502778">next</a><span>|</span><label class="collapse" for="c-40503289">[-]</label><label class="expand" for="c-40503289">[2 more]</label></div><br/><div class="children"><div class="content">Interesting that there is no cache (instead it&#x27;s using a prefetch queue)..  &quot;Implement multi-cycle to reduce area &#x2F; power&quot;, I guess it&#x27;s not one-cycle per instruction, so maybe not needed.<p>Well, where is the superscalar variant? :-)  At least on an FPGA, there would be very diminishing returns for doing it.  Even bypassing has bad effects on fMAX.</div><br/><div id="40503326" class="c"><input type="checkbox" id="c-40503326" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40503289">parent</a><span>|</span><a href="#40502778">next</a><span>|</span><label class="collapse" for="c-40503326">[-]</label><label class="expand" for="c-40503326">[1 more]</label></div><br/><div class="children"><div class="content">Lately I&#x27;ve been curious about building things like display controllers and microprocessors on the FPGA.  It was<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Transport_triggered_architecture" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Transport_triggered_architectu...</a><p>that convinced me I could build a useful custom processor but it also got me to see how complex things get when you go pipelined, superscalar, depending on a cache, etc.</div><br/></div></div></div></div><div id="40502778" class="c"><input type="checkbox" id="c-40502778" checked=""/><div class="controls bullet"><span class="by">vlowther</span><span>|</span><a href="#40503289">prev</a><span>|</span><a href="#40502835">next</a><span>|</span><label class="collapse" for="c-40502778">[-]</label><label class="expand" for="c-40502778">[12 more]</label></div><br/><div class="children"><div class="content">Oooh. 6809 resurrection project.  I studied that arch obsessively when I was a kid with a Tandy Color Computer.</div><br/><div id="40502884" class="c"><input type="checkbox" id="c-40502884" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40502778">parent</a><span>|</span><a href="#40505867">next</a><span>|</span><label class="collapse" for="c-40502884">[-]</label><label class="expand" for="c-40502884">[10 more]</label></div><br/><div class="children"><div class="content">Funny I noticed this one when I was reading a paper about people using an OS-9 variant together with the Turbo9.  See <a href="https:&#x2F;&#x2F;www.mdpi.com&#x2F;2079-9292&#x2F;13&#x2F;10&#x2F;1978" rel="nofollow">https:&#x2F;&#x2F;www.mdpi.com&#x2F;2079-9292&#x2F;13&#x2F;10&#x2F;1978</a><p>I had a Coco 1 and a Coco 3, with the OS-9 operating system you could run C and Pascal compilers as well as use BASIC09 which was like a modern bytecode interpreted language (Python).  The 6809 stands out because it was designed to support compiled languages, shared libraries and such.  It not only had the right addressing modes but it had just enough registers that code generation was straightforward.<p>When I replaced my Coco3 with a 286 machine I switched to hardware that was more than an order of magnitude faster but MS-DOS was a big step back from OS-9.<p>Lately I have been obsessed with the lost 24-bit generation of micros and was quite delighted to discover the eZ80, would be nice to see the 6809 follow the same route but Motorola was too committed to the ultimately doomed 68k.</div><br/><div id="40507254" class="c"><input type="checkbox" id="c-40507254" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40502884">parent</a><span>|</span><a href="#40507896">next</a><span>|</span><label class="collapse" for="c-40507254">[-]</label><label class="expand" for="c-40507254">[1 more]</label></div><br/><div class="children"><div class="content">Funny fact: Motorola didn&#x27;t ship 68040 CPUs over 40Mhz because they didn&#x27;t think customers would tolerate even a small heat sink and fan combination being required for the chip.<p>*looks at massive heat sink and fan on my desktop system...</div><br/></div></div><div id="40507896" class="c"><input type="checkbox" id="c-40507896" checked=""/><div class="controls bullet"><span class="by">anonymousiam</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40502884">parent</a><span>|</span><a href="#40507254">prev</a><span>|</span><a href="#40503646">next</a><span>|</span><label class="collapse" for="c-40507896">[-]</label><label class="expand" for="c-40507896">[1 more]</label></div><br/><div class="children"><div class="content">About 35 years ago, I did some embedded development on a 68k platform running OS-9 (ported to 68k from 6809).  I was really impressed with the POSIX-like environment, but thoroughly disgusted with the very poor documentation.  I found that I had to write a lot of stub code to fully determine and understand the behavior of the system calls.<p>This was after I had purchased and fully digested the only documentation I could find: &quot;OS-9 Insights&quot;<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;OS-9-insights-advanced-programmers-guide&#x2F;dp&#x2F;0918035015" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;OS-9-insights-advanced-programmers-gu...</a></div><br/></div></div><div id="40503646" class="c"><input type="checkbox" id="c-40503646" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40502884">parent</a><span>|</span><a href="#40507896">prev</a><span>|</span><a href="#40505867">next</a><span>|</span><label class="collapse" for="c-40503646">[-]</label><label class="expand" for="c-40503646">[7 more]</label></div><br/><div class="children"><div class="content">I mean, was 68k really &quot;doomed&quot;? Millions of machines shipped with it, it went through like 6 generations (and then ColdFire), and it&#x27;s still used in military hardware with new chips made for that industry, and its existence heavily influenced everything about the Unix environments &amp; protocols we use today.<p>It was a great ISA (though clearly completely different from the 6809), and these days big endian looks like a serious anachronism.</div><br/><div id="40508005" class="c"><input type="checkbox" id="c-40508005" checked=""/><div class="controls bullet"><span class="by">Tor3</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40503646">parent</a><span>|</span><a href="#40503880">next</a><span>|</span><label class="collapse" for="c-40508005">[-]</label><label class="expand" for="c-40508005">[1 more]</label></div><br/><div class="children"><div class="content">It was simply phased out at some point, like so many other processors. I think it&#x27;s wrong to say it was &quot;doomed&quot;.
For one of the minicomputer systems I worked with until around 1995 all the interface boards used m68k CPUs and were running their own little operating systems. This made the whole mini quite efficient - all the intelligence in the peripherals meant that a lot of data transfers could be performed independently of the main CPU.</div><br/></div></div><div id="40503880" class="c"><input type="checkbox" id="c-40503880" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40503646">parent</a><span>|</span><a href="#40508005">prev</a><span>|</span><a href="#40505867">next</a><span>|</span><label class="collapse" for="c-40503880">[-]</label><label class="expand" for="c-40503880">[5 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t it the VAX that set the precedent for all the &quot;32-bit&quot; machines ever since?<p>Every company that invested in it,  however,  had to either go out of business or switch to another architecture,  usually the first.  Apple and Sun Microsystems survived.  Fragmentation,  with the Apple Macintosh,  Amiga, Atari ST, Sinclair QL, etc. (all similar machines that struggled with cost-performance tradeoffs in different ways),  didn&#x27;t help.<p>The BBC Micro developers probably had more space to really think about how to make a home computer and looked at many architectures and came to the conclusion that the 68k line punched below its weight.  People in the early 1980s didn&#x27;t see that one of the greatest rugpulls in computing was coming and were blindsided by IBM &quot;doing it again&quot; by maintaining long-term software compatibility with the 8088 and derivatives the way they did for the old 360...  Companies that invested in the x86 didn&#x27;t regret it, though many of them were crushed by an increasingly competitive market.</div><br/><div id="40504755" class="c"><input type="checkbox" id="c-40504755" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40503880">parent</a><span>|</span><a href="#40505867">next</a><span>|</span><label class="collapse" for="c-40504755">[-]</label><label class="expand" for="c-40504755">[4 more]</label></div><br/><div class="children"><div class="content">I absolutely agree that Motorola fucked up bigtime with the 68k-&gt;88k-&gt;PPC transition. They listened to the pundits who said the CISC ISA couldn&#x27;t scale, and then Intel proved that (mostly) wrong but it was too late for 68k&#x2F;ColdFire then. The rug-pulling actually is probably in large part responsible for both Atari and Commodore just packing it in, and led to Apple being in the wilderness for a decade as they did the first of 3 ISA transitions for the Mac.<p>Also yes the 68k was clearly a dog when it came to interrupt responsiveness and made no sense in home computers or video games, at least not until the &#x27;020.<p>It was meant to be a bargain VAX. And that&#x27;s why I say it was influential. A whole generation (X) of us grew up who could never hope (or care) to touch a VAX, but we had Atari STs, Amigas, etc at home, and were shelling into SunOS 68k boxes for fun or school etc. It lasted quite a while after VAX was a done deal, too.<p>To me 68k <i>was</i> the Unix workstation and hobbyist market and defined 32-bit ISAs as well. I never touched an x86 until I could run Linux on it. I&#x27;ve never learned  or written x86 assembly seriously in my entire career despite writing (and enjoying) 6502 68k, ARM, MIPS, RISC-V, others<p>Outside of the UK, ARM didn&#x27;t play a role except for in some embedded stuff. Obviously that changed :-)</div><br/><div id="40508145" class="c"><input type="checkbox" id="c-40508145" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40504755">parent</a><span>|</span><a href="#40506915">next</a><span>|</span><label class="collapse" for="c-40508145">[-]</label><label class="expand" for="c-40508145">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Also yes the 68k was clearly a dog when it came to interrupt responsiveness and made no sense in home computers or video games, at least not until the &#x27;020.<p>In what world? The interrupts were very fast, taking just a few cycles, and the behavior was deterministic.<p>This is why they were popular in realtime applications, and remained so for decades.<p>Back in the day, they were famously used in e.g. the Eurofighter Typhoon.</div><br/></div></div><div id="40506915" class="c"><input type="checkbox" id="c-40506915" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40504755">parent</a><span>|</span><a href="#40508145">prev</a><span>|</span><a href="#40505867">next</a><span>|</span><label class="collapse" for="c-40506915">[-]</label><label class="expand" for="c-40506915">[2 more]</label></div><br/><div class="children"><div class="content">We need to remember that everyone -- not just Motorola -- thought CISC was a dead-end by the late 1980&#x27;s. Even Intel!<p>And we also need to acknowledge that everyone was RIGHT! Intel ultimately threw billions into keeping x86 competitive, and they seem to have finally hit the wall now with performance per watt measures, which is what cost them Apple&#x27;s business and is now driving Microsoft to ARM.</div><br/><div id="40509581" class="c"><input type="checkbox" id="c-40509581" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40502778">root</a><span>|</span><a href="#40506915">parent</a><span>|</span><a href="#40505867">next</a><span>|</span><label class="collapse" for="c-40509581">[-]</label><label class="expand" for="c-40509581">[1 more]</label></div><br/><div class="children"><div class="content">&gt;And we also need to acknowledge that everyone was RIGHT!<p>And x86 will, too, be replaced.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40505867" class="c"><input type="checkbox" id="c-40505867" checked=""/><div class="controls bullet"><span class="by">mordechai9000</span><span>|</span><a href="#40502778">parent</a><span>|</span><a href="#40502884">prev</a><span>|</span><a href="#40502835">next</a><span>|</span><label class="collapse" for="c-40505867">[-]</label><label class="expand" for="c-40505867">[1 more]</label></div><br/><div class="children"><div class="content">Me too! I remember laboriously typing in the demo program from &quot;TRS-80 Color Computer Assembly Language Programming&quot; and watching it bubble sort the text on screen by directly accessing video memory.</div><br/></div></div></div></div><div id="40502835" class="c"><input type="checkbox" id="c-40502835" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40502778">prev</a><span>|</span><a href="#40506914">next</a><span>|</span><label class="collapse" for="c-40502835">[-]</label><label class="expand" for="c-40502835">[8 more]</label></div><br/><div class="children"><div class="content">So AIUI this is explicitly trying to be smaller than 32-bit RISC-V. And I can see that in the abstract, but I gotta ask: How much does it matter? My <i>very uninformed</i> impression was that with current fabrication, RISC-V is already more than small enough (on-chip surface area) and cheap enough ($) that there&#x27;s not a lot of market for anything underneath it. Am I mistaken?<p>(To be clear, I&#x27;d <i>like</i> it to work, just questioning the economics.)</div><br/><div id="40506933" class="c"><input type="checkbox" id="c-40506933" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40502835">parent</a><span>|</span><a href="#40502903">next</a><span>|</span><label class="collapse" for="c-40506933">[-]</label><label class="expand" for="c-40506933">[1 more]</label></div><br/><div class="children"><div class="content"><i>that there&#x27;s not a lot of market for anything underneath it.</i><p>You&#x27;d be very mistaken. 4-bit MCUs are still found in places where you wouldn&#x27;t even expect an MCU, and the 8-bit ones are numerous in ultra-high-volume highly cost-sensitive applications. Products that use COB-mounted sub-$0.01 die.</div><br/></div></div><div id="40502903" class="c"><input type="checkbox" id="c-40502903" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40502835">parent</a><span>|</span><a href="#40506933">prev</a><span>|</span><a href="#40505499">next</a><span>|</span><label class="collapse" for="c-40502903">[-]</label><label class="expand" for="c-40502903">[5 more]</label></div><br/><div class="children"><div class="content">Sometimes there doesn&#x27;t need to be a &quot;market&quot;, just an interest and passion.<p>I think there&#x27;s value in an open and modernized 8-bit MCU&#x2F;MPU that isn&#x27;t PIC or whatever.</div><br/><div id="40502911" class="c"><input type="checkbox" id="c-40502911" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40502835">root</a><span>|</span><a href="#40502903">parent</a><span>|</span><a href="#40505499">next</a><span>|</span><label class="collapse" for="c-40502911">[-]</label><label class="expand" for="c-40502911">[4 more]</label></div><br/><div class="children"><div class="content">I love AVR-8 myself.</div><br/><div id="40503573" class="c"><input type="checkbox" id="c-40503573" checked=""/><div class="controls bullet"><span class="by">garaetjjte</span><span>|</span><a href="#40502835">root</a><span>|</span><a href="#40502911">parent</a><span>|</span><a href="#40505499">next</a><span>|</span><label class="collapse" for="c-40503573">[-]</label><label class="expand" for="c-40503573">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really terrible that for cheap embedded cores things like 8051 are still being used, instead of sane architectures like AVR.</div><br/><div id="40503802" class="c"><input type="checkbox" id="c-40503802" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40502835">root</a><span>|</span><a href="#40503573">parent</a><span>|</span><a href="#40505499">next</a><span>|</span><label class="collapse" for="c-40503802">[-]</label><label class="expand" for="c-40503802">[2 more]</label></div><br/><div class="children"><div class="content">I find it pretty scary that C compilers target the 8051 but I also think C is a terrible waste of the AVR-8 (who needs to move the stack pointer around meaninglessly in a simple program where recursion is a problem and not a solution?  Probably the best thing that happened in the 1970s was that Microsoft BASIC beat Lisp and Logo,  otherwise a generation of people learning to code would have been victimized even more by bad Fibonacci implementations) which I only indulge in because I can port C code to a bigger microcontroller.</div><br/><div id="40504804" class="c"><input type="checkbox" id="c-40504804" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40502835">root</a><span>|</span><a href="#40503802">parent</a><span>|</span><a href="#40505499">next</a><span>|</span><label class="collapse" for="c-40504804">[-]</label><label class="expand" for="c-40504804">[1 more]</label></div><br/><div class="children"><div class="content">Have you ever played with the Parallax Propeller MCUs?  (I and II). 32-bit, but very &quot;retro&quot; feel to them. And an odd and interesting multicore architecture.<p>Unfortunately they&#x27;ve had a bad streak in terms of getting a proper GCC or Clang toolchain targeted towards them. The developers of the chip are focused on their own weird structured BASIC-Assembly fusion (&quot;SPIN&quot;).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40505499" class="c"><input type="checkbox" id="c-40505499" checked=""/><div class="controls bullet"><span class="by">MisterTea</span><span>|</span><a href="#40502835">parent</a><span>|</span><a href="#40502903">prev</a><span>|</span><a href="#40506914">next</a><span>|</span><label class="collapse" for="c-40505499">[-]</label><label class="expand" for="c-40505499">[1 more]</label></div><br/><div class="children"><div class="content">They state this as their reasoning so there must be merit in pursuing a smaller footprint:<p>&gt; Current industry trends are to adapt 32-bit RISC IP for microcontroller use, however their large 32x32 register files and loosely encoded instructions limit their absolute minimum footprint. So with the goal of a creating a performance and compact microprocessor IP, we need an 16-bit instruction set architecture (ISA).<p>Not every application requires 32 bits and as you can see from some of the use cases, there might be a dozen of these in a design so minimal footprint is important.</div><br/></div></div></div></div><div id="40506914" class="c"><input type="checkbox" id="c-40506914" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40502835">prev</a><span>|</span><a href="#40503919">next</a><span>|</span><label class="collapse" for="c-40506914">[-]</label><label class="expand" for="c-40506914">[3 more]</label></div><br/><div class="children"><div class="content"><i>The target applications are SoC sub-blocks or small mixed-signal ASICs that require a compact and efficient microprocessor for programmable high-level control. There are many 32 or 64-bit RISC-V or ARM cores that try to fill this niche, but prove to be inefficient solutions given many of these applications only require 16-bit precision.</i><p>Unfortunately 6502, 8051, Z80, and various other architectures from a similar era already fill that niche.</div><br/><div id="40507675" class="c"><input type="checkbox" id="c-40507675" checked=""/><div class="controls bullet"><span class="by">thristian</span><span>|</span><a href="#40506914">parent</a><span>|</span><a href="#40509002">next</a><span>|</span><label class="collapse" for="c-40507675">[-]</label><label class="expand" for="c-40507675">[1 more]</label></div><br/><div class="children"><div class="content">The 6809 is one of the architectures from the era of the 6502, 8051, and Z80. Specifically, it&#x27;s Motorola&#x27;s response to the 6502 eating the 6800&#x27;s lunch, the same way the 8086 was Intel&#x27;s response to the Z80 eating the 8080&#x27;s lunch.<p>I&#x27;m guessing they picked the 6809 because it&#x27;s a lot more friendly to C than those other architectures.</div><br/></div></div><div id="40509002" class="c"><input type="checkbox" id="c-40509002" checked=""/><div class="controls bullet"><span class="by">ataylor284_</span><span>|</span><a href="#40506914">parent</a><span>|</span><a href="#40507675">prev</a><span>|</span><a href="#40503919">next</a><span>|</span><label class="collapse" for="c-40509002">[-]</label><label class="expand" for="c-40509002">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re probably right.  There&#x27;s a lot of code for those processors that&#x27;s not going away.<p>Too bad though, the 6809 is the pinnacle of 8-bit CPU architecture.  It&#x27;s the result of analyzing the practical shortcomings of the 6800 and other CPUs and redesigning the ISA.  It has 16-bit index registers and 16-bit arithmetic, addressing two of the 6502s most annoying drawbacks.  Additionally, it has support for stack based locals, position independent code and a LEA instruction.  All those make building a high level language compiler much easier than other 8-bits.</div><br/></div></div></div></div><div id="40503919" class="c"><input type="checkbox" id="c-40503919" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#40506914">prev</a><span>|</span><a href="#40503056">next</a><span>|</span><label class="collapse" for="c-40503919">[-]</label><label class="expand" for="c-40503919">[5 more]</label></div><br/><div class="children"><div class="content">Were any MMUs ever made for the 6809? Or could it use an MMU for the 8086 or something?</div><br/><div id="40504431" class="c"><input type="checkbox" id="c-40504431" checked=""/><div class="controls bullet"><span class="by">pkaye</span><span>|</span><a href="#40503919">parent</a><span>|</span><a href="#40503056">next</a><span>|</span><label class="collapse" for="c-40504431">[-]</label><label class="expand" for="c-40504431">[4 more]</label></div><br/><div class="children"><div class="content">Looks like there was one.<p><a href="http:&#x2F;&#x2F;www.bitsavers.org&#x2F;components&#x2F;motorola&#x2F;_dataSheets&#x2F;6829.pdf" rel="nofollow">http:&#x2F;&#x2F;www.bitsavers.org&#x2F;components&#x2F;motorola&#x2F;_dataSheets&#x2F;682...</a></div><br/><div id="40504533" class="c"><input type="checkbox" id="c-40504533" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#40503919">root</a><span>|</span><a href="#40504431">parent</a><span>|</span><a href="#40503056">next</a><span>|</span><label class="collapse" for="c-40504533">[-]</label><label class="expand" for="c-40504533">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the CoCo 3 and worked pretty well!<p>Basically, it can page a couple of megabytes (maybe 4 I can&#x27;t remember off hand) into and out of the 16 bit address space as 2, 4, 8Kb pages.<p>The really nice thing is how well the 6809 can do relocatable code.  Made paging things in to and out of RAM flexible.</div><br/><div id="40507120" class="c"><input type="checkbox" id="c-40507120" checked=""/><div class="controls bullet"><span class="by">hashmash</span><span>|</span><a href="#40503919">root</a><span>|</span><a href="#40504533">parent</a><span>|</span><a href="#40503056">next</a><span>|</span><label class="collapse" for="c-40507120">[-]</label><label class="expand" for="c-40507120">[2 more]</label></div><br/><div class="children"><div class="content">The CoCo 3 had a custom chip which provided an MMU and a few other features, but the maximum amount of memory it supported was 512KB. Page size was fixed at 8KB.</div><br/><div id="40507665" class="c"><input type="checkbox" id="c-40507665" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#40503919">root</a><span>|</span><a href="#40507120">parent</a><span>|</span><a href="#40503056">next</a><span>|</span><label class="collapse" for="c-40507665">[-]</label><label class="expand" for="c-40507665">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you are right.  I am confusing that with some other system.  Sadly, I do not currently have a Coco 3.  The details fade with lack of use...<p>I do recall, I used 2 pages, 16Kb RAM for my projects.<p>Page one, run main code and page in subroutines as needed.  I could put graphics data under the main code too.  The draw routines got called in page 2, meaning page 1 could go away for a while.<p>It worked well.  Maybe it was the Atari featuring different page sizes.<p>How are people putting 2 Megabytes into the machine?  I never did one of those upgrades, though I did add a 6309.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40503056" class="c"><input type="checkbox" id="c-40503056" checked=""/><div class="controls bullet"><span class="by">phone8675309</span><span>|</span><a href="#40503919">prev</a><span>|</span><label class="collapse" for="c-40503056">[-]</label><label class="expand" for="c-40503056">[6 more]</label></div><br/><div class="children"><div class="content">That’s cool - the 6800 is getting its equivalent of the 65816</div><br/><div id="40509051" class="c"><input type="checkbox" id="c-40509051" checked=""/><div class="controls bullet"><span class="by">PixyMisa</span><span>|</span><a href="#40503056">parent</a><span>|</span><a href="#40503663">next</a><span>|</span><label class="collapse" for="c-40509051">[-]</label><label class="expand" for="c-40509051">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like it has similar (maybe the same) extensions as the Hitachi 6309 <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hitachi_6309" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hitachi_6309</a><p>That is, it has a 32-bit accumulator (made up of four 8-bit accumulators) but apparently no address extensions.</div><br/></div></div><div id="40503663" class="c"><input type="checkbox" id="c-40503663" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40503056">parent</a><span>|</span><a href="#40509051">prev</a><span>|</span><label class="collapse" for="c-40503663">[-]</label><label class="expand" for="c-40503663">[4 more]</label></div><br/><div class="children"><div class="content">skimming, it looks limited to 16-bit memory addressing, so not really equiv unfortunately.<p>&#x27;816 was a gross hack, but it at least let you get more memory on there without resorting to bankswitching</div><br/><div id="40505821" class="c"><input type="checkbox" id="c-40505821" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40503056">root</a><span>|</span><a href="#40503663">parent</a><span>|</span><label class="collapse" for="c-40505821">[-]</label><label class="expand" for="c-40505821">[3 more]</label></div><br/><div class="children"><div class="content">Kinda awful because it doesn’t have 24 bit index registers so writing programs that use the whole memory is a hassle.  I remember people complaining a lot about messing with the segment registers in the 8086|8088 which was worse than having a flat memory space but really wasn’t that bad, you could always find a memory model that worked for your application and I really enjoyed writing 80286 assembly.</div><br/><div id="40505877" class="c"><input type="checkbox" id="c-40505877" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40503056">root</a><span>|</span><a href="#40505821">parent</a><span>|</span><label class="collapse" for="c-40505877">[-]</label><label class="expand" for="c-40505877">[2 more]</label></div><br/><div class="children"><div class="content">yeah this is always my bitch with the 816. there&#x27;s no way to have a &quot;pointer&quot; in a register as a single value.<p>that and the stupid mode switching<p>oh, and stack and zero page not being able move out of first bank<p>not a compelling chip.</div><br/><div id="40507744" class="c"><input type="checkbox" id="c-40507744" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#40503056">root</a><span>|</span><a href="#40505877">parent</a><span>|</span><label class="collapse" for="c-40507744">[-]</label><label class="expand" for="c-40507744">[1 more]</label></div><br/><div class="children"><div class="content">8086 doesn&#x27;t support longer pointers either. You always had to load a segment and then an offset as two operations, no different from loading the DB (data bank register) in the &#x27;816.<p>The DB was not as flexible as segment registers, and there was only one of them, but you could easily load them both and then get a 16 bit value into the accumulator. Index registers also crossed bank boundaries. In contrast to the 8086, where the segments were a bit of a jail.<p>Mind, that&#x27;s a feature in that you could write a multiprocessing system without memory protection, and have code reasonably safe from accidentally stomping on other areas (for example, if your C compiler compiled to the Tiny model, a rogue C ptr shouldn&#x27;t be able to break out, obviously assembly could do anything).<p>Regarding the 68K and larger address space, on the original Macintosh, you were unable to request a single block of memory larger than 32K. So, like the Genie, unlimited power -- itty bitty living space. Sure, pointers could access anything, but at a system level, you weren&#x27;t going to get a large enough chunk of memory, all at once, to warrant a larger pointer, so you were working with almost &quot;virtually&quot; segmented memory anyway.<p>On the IIGS, based on the 816, they used a similar memory manager. The segment manager on IIGS is really pretty cool. It&#x27;s 2.0 of what the Macintosh had.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>