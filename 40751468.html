<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719046861062" as="style"/><link rel="stylesheet" href="styles.css?v=1719046861062"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://criu.org/Main_Page">CRIU, a project to implement checkpoint/restore functionality for Linux</a> <span class="domain">(<a href="https://criu.org">criu.org</a>)</span></div><div class="subtext"><span>JeremyNT</span> | <span>57 comments</span></div><br/><div><div id="40754009" class="c"><input type="checkbox" id="c-40754009" checked=""/><div class="controls bullet"><span class="by">monus</span><span>|</span><a href="#40752131">next</a><span>|</span><label class="collapse" for="c-40754009">[-]</label><label class="expand" for="c-40754009">[2 more]</label></div><br/><div class="children"><div class="content">I built crik[1] to orchestrate CRIU operations inside a container running in Kubernetes so that you can migrate containers when spot node gets a shutdown signal. Presented it at KubeCon Paris 2024 [2] with a deep dive for those interested in the technical details.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;qawolf&#x2F;crik">https:&#x2F;&#x2F;github.com&#x2F;qawolf&#x2F;crik</a><p>[2]: The Party Must Go On - Resume Pods After Spot Instance Shutdown, <a href="https:&#x2F;&#x2F;kccnceu2024.sched.com&#x2F;event&#x2F;1YeP3" rel="nofollow">https:&#x2F;&#x2F;kccnceu2024.sched.com&#x2F;event&#x2F;1YeP3</a></div><br/><div id="40757023" class="c"><input type="checkbox" id="c-40757023" checked=""/><div class="controls bullet"><span class="by">alexeldeib</span><span>|</span><a href="#40754009">parent</a><span>|</span><a href="#40752131">next</a><span>|</span><label class="collapse" for="c-40757023">[-]</label><label class="expand" for="c-40757023">[1 more]</label></div><br/><div class="children"><div class="content">great talk! I’m curious about an approach like this combined with CUDA checkpoint for GPU workloads <a href="https:&#x2F;&#x2F;github.com&#x2F;NVIDIA&#x2F;cuda-checkpoint">https:&#x2F;&#x2F;github.com&#x2F;NVIDIA&#x2F;cuda-checkpoint</a></div><br/></div></div></div></div><div id="40752131" class="c"><input type="checkbox" id="c-40752131" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40754009">prev</a><span>|</span><a href="#40752502">next</a><span>|</span><label class="collapse" for="c-40752131">[-]</label><label class="expand" for="c-40752131">[9 more]</label></div><br/><div class="children"><div class="content">I pulled apart the innards of CRIU because I needed to be able to checkpoint and restore a process within a few microseconds.<p>The project ended up being a dead end because it turned out running my program in a QEMU whole system vm and then fork()ING QEMU worked faster.</div><br/><div id="40753219" class="c"><input type="checkbox" id="c-40753219" checked=""/><div class="controls bullet"><span class="by">vient</span><span>|</span><a href="#40752131">parent</a><span>|</span><a href="#40752199">next</a><span>|</span><label class="collapse" for="c-40753219">[-]</label><label class="expand" for="c-40753219">[1 more]</label></div><br/><div class="children"><div class="content">There is a QEMU fork used by Nyx fuzzer, may be interesting to you <a href="https:&#x2F;&#x2F;github.com&#x2F;nyx-fuzz&#x2F;QEMU-Nyx">https:&#x2F;&#x2F;github.com&#x2F;nyx-fuzz&#x2F;QEMU-Nyx</a><p>Basically, for the fuzzing purposes speed is paramount so they made some changes to speed up snapshot restoring. Don&#x27;t know the limitations but since it is used to fuzz full operating systems, there should not be many.<p>I believe it should be faster than forking because why even patch QEMU otherwise.</div><br/></div></div><div id="40752199" class="c"><input type="checkbox" id="c-40752199" checked=""/><div class="controls bullet"><span class="by">kn100</span><span>|</span><a href="#40752131">parent</a><span>|</span><a href="#40753219">prev</a><span>|</span><a href="#40752502">next</a><span>|</span><label class="collapse" for="c-40752199">[-]</label><label class="expand" for="c-40752199">[7 more]</label></div><br/><div class="children"><div class="content">could you tell me a bit more about what you&#x27;re doing?</div><br/><div id="40752408" class="c"><input type="checkbox" id="c-40752408" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40752131">root</a><span>|</span><a href="#40752199">parent</a><span>|</span><a href="#40752502">next</a><span>|</span><label class="collapse" for="c-40752408">[-]</label><label class="expand" for="c-40752408">[6 more]</label></div><br/><div class="children"><div class="content">The goal was to have a web browser (chromium) able to &#x27;guess&#x27; stuff about what response it will get from the network (ie. Will the server return the same JavaScript blob as last time).   We start executing the JavaScript as-if the guess is correct.   If the guess is wrong, we revert to a snapshot.<p>It lets you make good use of CPU time whilst waiting for the network.<p>It turns out simple heuristics can get 99% accuracy on the question of &#x27;will the server return the same result as last time for this non-cachable response&#x27;.<p>However, since my machine has many CPU cores it made sense to have many &#x27;speculative&#x27; copies of the browser going at once.<p>A regular fork() call would have worked, if not for the fact chromium is multi thread and multi process, and it&#x27;s next to impossible to fork multiple processes as a group.</div><br/><div id="40756090" class="c"><input type="checkbox" id="c-40756090" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#40752131">root</a><span>|</span><a href="#40752408">parent</a><span>|</span><a href="#40756277">next</a><span>|</span><label class="collapse" for="c-40756090">[-]</label><label class="expand" for="c-40756090">[1 more]</label></div><br/><div class="children"><div class="content">Terrifying, I love it :) How was the performance in the end? Did you get a good speculation success rate?<p>It&#x27;d be cool to predict which resources are speculation safe (ie the cache headers don&#x27;t permit it, but the content in practice doesn&#x27;t change) and speculate those resources but not ones which you have repeatedly had a speculation abort (ie actual dynamic resources). If your predictor gets a high enough hit rate, you could probably do okay with just a single instance&#x2F;no snapshot and use an expensive rollback mechanism (reload the whole page non-speculatively?).</div><br/></div></div><div id="40756277" class="c"><input type="checkbox" id="c-40756277" checked=""/><div class="controls bullet"><span class="by">0x1ceb00da</span><span>|</span><a href="#40752131">root</a><span>|</span><a href="#40752408">parent</a><span>|</span><a href="#40756090">prev</a><span>|</span><a href="#40752776">next</a><span>|</span><label class="collapse" for="c-40756277">[-]</label><label class="expand" for="c-40756277">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you just change chrome so that it forks the tabs and runs them in the background? That seems a lot easier.</div><br/></div></div><div id="40752776" class="c"><input type="checkbox" id="c-40752776" checked=""/><div class="controls bullet"><span class="by">salamander014</span><span>|</span><a href="#40752131">root</a><span>|</span><a href="#40752408">parent</a><span>|</span><a href="#40756277">prev</a><span>|</span><a href="#40752502">next</a><span>|</span><label class="collapse" for="c-40752776">[-]</label><label class="expand" for="c-40752776">[3 more]</label></div><br/><div class="children"><div class="content">Sorry if I&#x27;m being thick, but why not just cache the response?<p>If you are guessing at the data anyway, what&#x27;s the difference?<p>Why set up an entire speculative execution engine &#x2F; runtime snapshot rollback framework when it sounds like adding heuristic decision caching would solve this problem?</div><br/><div id="40752872" class="c"><input type="checkbox" id="c-40752872" checked=""/><div class="controls bullet"><span class="by">InvisGhost</span><span>|</span><a href="#40752131">root</a><span>|</span><a href="#40752776">parent</a><span>|</span><a href="#40755384">next</a><span>|</span><label class="collapse" for="c-40752872">[-]</label><label class="expand" for="c-40752872">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like they were caching it since they could execute it before getting the response. The difference is that they wanted to avoid the situation where they execute stale code that the server never would&#x27;ve served. So they can execute the stale code while waiting for the response then either toss the result or continue on with it once they determine if the server response changed.</div><br/></div></div><div id="40755384" class="c"><input type="checkbox" id="c-40755384" checked=""/><div class="controls bullet"><span class="by">mostthingsweb</span><span>|</span><a href="#40752131">root</a><span>|</span><a href="#40752776">parent</a><span>|</span><a href="#40752872">prev</a><span>|</span><a href="#40752502">next</a><span>|</span><label class="collapse" for="c-40755384">[-]</label><label class="expand" for="c-40755384">[1 more]</label></div><br/><div class="children"><div class="content">How else will you discover new and exciting speculative execution vulnerabilities? &#x2F;s</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40752502" class="c"><input type="checkbox" id="c-40752502" checked=""/><div class="controls bullet"><span class="by">ahlCVA</span><span>|</span><a href="#40752131">prev</a><span>|</span><a href="#40752292">next</a><span>|</span><label class="collapse" for="c-40752502">[-]</label><label class="expand" for="c-40752502">[2 more]</label></div><br/><div class="children"><div class="content">I once used CRIU to implement the hacky equivalent of save-lisp-and-die to speed up the startup process of a low-powered embedded system where the main application was misguidedly implemented in Erlang and loading all the code took minutes each time the device started. It worked better than it should have (though in the end it wasn&#x27;t shipped because nobody (except the customer) cared enough about the startup behavior and eventually the product got canned (for different reasons)).</div><br/><div id="40754154" class="c"><input type="checkbox" id="c-40754154" checked=""/><div class="controls bullet"><span class="by">phildenhoff</span><span>|</span><a href="#40752502">parent</a><span>|</span><a href="#40752292">next</a><span>|</span><label class="collapse" for="c-40754154">[-]</label><label class="expand" for="c-40754154">[1 more]</label></div><br/><div class="children"><div class="content">What was misguided about using Erlang? That it was so expensive CPU-wise to start up?</div><br/></div></div></div></div><div id="40752292" class="c"><input type="checkbox" id="c-40752292" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#40752502">prev</a><span>|</span><a href="#40753075">next</a><span>|</span><label class="collapse" for="c-40752292">[-]</label><label class="expand" for="c-40752292">[5 more]</label></div><br/><div class="children"><div class="content">I discovered CRIU in this video below (1h) &quot;Container Migration and CRIU Details with Adrian Reber (Red Hat)&quot;, it has a live demo and the details about how much &quot;user space&quot; it really is. Here with the RH podman fork of docker.<p>Since everyone is treating containers as cattle CRIU doesn&#x27;t seem to get much attention, and might be why a video and not a blog post was my first introduction.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-7DgNxyuz_o" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-7DgNxyuz_o</a></div><br/><div id="40753084" class="c"><input type="checkbox" id="c-40753084" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#40752292">parent</a><span>|</span><a href="#40752599">next</a><span>|</span><label class="collapse" for="c-40753084">[-]</label><label class="expand" for="c-40753084">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Since everyone is treating containers as cattle CRIU doesn&#x27;t seem to get much attention<p>Nah, it&#x27;s more like &quot;I don&#x27;t trust that thing to not cause weird behavior in production&quot;.<p>VM-level snapshots are standard practice[1] because the abstraction there is right-sized for being able to do that reliably. CRIU isn&#x27;t, because it&#x27;s trying to solve a much harder problem.<p>[1]: And even there, beware cloning running memory state, you can get weird interactions from two identical parties trying to talk to the same 3rd service, separated by time. Cloning disk snapshots is <i>much</i> safer, and even there you can screw up because of duplicate machine IDs, crypto keys, nonces, etc.</div><br/></div></div><div id="40752599" class="c"><input type="checkbox" id="c-40752599" checked=""/><div class="controls bullet"><span class="by">JeremyNT</span><span>|</span><a href="#40752292">parent</a><span>|</span><a href="#40753084">prev</a><span>|</span><a href="#40753522">next</a><span>|</span><label class="collapse" for="c-40752599">[-]</label><label class="expand" for="c-40752599">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Since everyone is treating containers as cattle CRIU doesn&#x27;t seem to get much attention<p>Yeah, I guess that&#x27;s probably the reason. If you&#x27;re engineering your workloads with the idea that the world might &quot;poof&quot; out from under you at any moment you&#x27;d never wonder about &#x2F; reach for something like CRIU.<p>It&#x27;s a trick that I&#x27;d never much thought about, but now that I&#x27;ve learned it exists (so many years late) I find myself wondering about the path not taken here. It <i>feels</i> like it should be incredibly useful... but I can&#x27;t figure out exactly what I&#x27;d want to do with it myself.</div><br/></div></div><div id="40753522" class="c"><input type="checkbox" id="c-40753522" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#40752292">parent</a><span>|</span><a href="#40752599">prev</a><span>|</span><a href="#40753075">next</a><span>|</span><label class="collapse" for="c-40753522">[-]</label><label class="expand" for="c-40753522">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Here with the RH podman fork of docker<p>small nit: podman is not a docker fork, it&#x27;s a completely different codebase written from scratch</div><br/><div id="40753571" class="c"><input type="checkbox" id="c-40753571" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#40752292">root</a><span>|</span><a href="#40753522">parent</a><span>|</span><a href="#40753075">next</a><span>|</span><label class="collapse" for="c-40753571">[-]</label><label class="expand" for="c-40753571">[1 more]</label></div><br/><div class="children"><div class="content">It is absolutely not from scratch.
It is definitely reusing docker code (or at least it used to).</div><br/></div></div></div></div></div></div><div id="40753075" class="c"><input type="checkbox" id="c-40753075" checked=""/><div class="controls bullet"><span class="by">jasonvorhe</span><span>|</span><a href="#40752292">prev</a><span>|</span><a href="#40752931">next</a><span>|</span><label class="collapse" for="c-40753075">[-]</label><label class="expand" for="c-40753075">[2 more]</label></div><br/><div class="children"><div class="content">Interesting. I built a very primitive prototype for a hosting company a while a back where I wanted to figure out if we could offer something close to a live migration of one Linux account on host x to host y without causing a lot of downtime. The product didn&#x27;t support containers and isolation was just based on Linux user accounts so we couldn&#x27;t just use Docker.<p>Just a few months ago I was talking to a startup founder at KubeCon who built a product based on CRIU. Unfortunately I forgot the company&#x27;s name. (And I can&#x27;t find that git repo with the prototype anywhere, even in my backups. Sad.)</div><br/><div id="40753680" class="c"><input type="checkbox" id="c-40753680" checked=""/><div class="controls bullet"><span class="by">nravic</span><span>|</span><a href="#40753075">parent</a><span>|</span><a href="#40752931">next</a><span>|</span><label class="collapse" for="c-40753680">[-]</label><label class="expand" for="c-40753680">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m probably the cofounder of the guy you spoke with! Here&#x27;s our repo: <a href="https:&#x2F;&#x2F;github.com&#x2F;cedana&#x2F;cedana">https:&#x2F;&#x2F;github.com&#x2F;cedana&#x2F;cedana</a></div><br/></div></div></div></div><div id="40752931" class="c"><input type="checkbox" id="c-40752931" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#40753075">prev</a><span>|</span><a href="#40752517">next</a><span>|</span><label class="collapse" for="c-40752931">[-]</label><label class="expand" for="c-40752931">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m keeping an eye on this project as a way to give containers used with immutable distro installs (eg. silverblue) a kind of user-space hibernation feature. So I could hibernate different container workspaces at will. I would find this very useful for development projects where I often have a lot of state that I lose whenever I need to reboot or whatever. Last time I looked there were still to many limitations on what it could checkpoint, but maybe one day.</div><br/><div id="40753702" class="c"><input type="checkbox" id="c-40753702" checked=""/><div class="controls bullet"><span class="by">nravic</span><span>|</span><a href="#40752931">parent</a><span>|</span><a href="#40753063">next</a><span>|</span><label class="collapse" for="c-40753702">[-]</label><label class="expand" for="c-40753702">[1 more]</label></div><br/><div class="children"><div class="content">We do this using CRIU right now! <a href="https:&#x2F;&#x2F;github.com&#x2F;cedana&#x2F;cedana">https:&#x2F;&#x2F;github.com&#x2F;cedana&#x2F;cedana</a><p>In fact one of our customer&#x27;s use cases is exactly what you describe, allowing users to &quot;hibernate&quot; container workspaces.</div><br/></div></div><div id="40753063" class="c"><input type="checkbox" id="c-40753063" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#40752931">parent</a><span>|</span><a href="#40753702">prev</a><span>|</span><a href="#40752517">next</a><span>|</span><label class="collapse" for="c-40753063">[-]</label><label class="expand" for="c-40753063">[2 more]</label></div><br/><div class="children"><div class="content">CRIU is 11 years old, don&#x27;t expect it to be any more usable in the near future.</div><br/><div id="40753716" class="c"><input type="checkbox" id="c-40753716" checked=""/><div class="controls bullet"><span class="by">Manouchehri</span><span>|</span><a href="#40752931">root</a><span>|</span><a href="#40753063">parent</a><span>|</span><a href="#40752517">next</a><span>|</span><label class="collapse" for="c-40753716">[-]</label><label class="expand" for="c-40753716">[1 more]</label></div><br/><div class="children"><div class="content">rr took about 9 years to get first class aarch64 support.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rr-debugger&#x2F;rr&#x2F;issues&#x2F;1373">https:&#x2F;&#x2F;github.com&#x2F;rr-debugger&#x2F;rr&#x2F;issues&#x2F;1373</a></div><br/></div></div></div></div></div></div><div id="40752517" class="c"><input type="checkbox" id="c-40752517" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#40752931">prev</a><span>|</span><a href="#40752724">next</a><span>|</span><label class="collapse" for="c-40752517">[-]</label><label class="expand" for="c-40752517">[4 more]</label></div><br/><div class="children"><div class="content">CRIU is used by LXD to save the state of an LXD container, very similar to suspending or snapshotting a virtual machine.<p>Unfortunately, I was disappointed to find `lxd stop --stateful` couldn&#x27;t save <i>any</i> of my LXD containers.  There was always some error or other.  This is how I learned about CRIU, as it was due to limitations of CRIU when used with the sorts of things running in LXD.<p><pre><code>  # lxc stop --stateful test
  (00.121636) Error (criu&#x2F;namespaces.c:423): Can&#x27;t dump nested uts namespace for 2685261
  (00.121645) Error (criu&#x2F;namespaces.c:682): Can&#x27;t make utsns id
  (00.150794) Error (criu&#x2F;util.c:631): exited, status=1
  (00.190680) Error (criu&#x2F;util.c:631): exited, status=1
  (00.191997) Error (criu&#x2F;cr-dump.c:1768): Dumping FAILED.
  Error: snapshot dump failed
</code></pre>
LXD is generally used with &quot;distro-like&quot; containers, like running a small Debian or Ubuntu distro, rather than single-application containers as are used with Docker.<p>It turns out CRIU can&#x27;t save the state of those types of containers, so in practice `lxd stop --stateful` never worked for me.<p>I&#x27;d have to switch to VMs if I want their state saved across host reboots, but those don&#x27;t have other behaviours regarding host-guest filesystem sharing that I needed.<p>In practice this meant I had to live with never rebooting the host.  Thankfully Linux just keeps on working for years without a reboot :-)</div><br/><div id="40753290" class="c"><input type="checkbox" id="c-40753290" checked=""/><div class="controls bullet"><span class="by">virtuous_sloth</span><span>|</span><a href="#40752517">parent</a><span>|</span><a href="#40754881">next</a><span>|</span><label class="collapse" for="c-40753290">[-]</label><label class="expand" for="c-40753290">[1 more]</label></div><br/><div class="children"><div class="content">Stéphane Graber (key Incus née LXD contributor) just did a video about developing placement scriptlets in the Starlark language but the interesting thing is, if I&#x27;m interpreting what I saw correctly, his cluster was 6 beefy servers plus 3 decent-sized VMs and the idea was, I think, that containers could get placed on the nested VMs, neatly solving the migration issue with containers. The interesting part was it looked like the 3 VMs in the cluster may have been themselves in the cluster.<p>I could be wrong, though. Interesting approach if true</div><br/></div></div><div id="40754881" class="c"><input type="checkbox" id="c-40754881" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40752517">parent</a><span>|</span><a href="#40753290">prev</a><span>|</span><a href="#40754645">next</a><span>|</span><label class="collapse" for="c-40754881">[-]</label><label class="expand" for="c-40754881">[1 more]</label></div><br/><div class="children"><div class="content">&gt;   (00.121636) Error (criu&#x2F;namespaces.c:423): Can&#x27;t dump nested uts namespace for 2685261<p>Found a GitHub issue for this: <a href="https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;issues&#x2F;1430">https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;issues&#x2F;1430</a><p>The issue apparently is newer systemd versions create their own UTS namespace, so suddenly running systemd in a container results in nested UTS namespace. Containers with older versions of systemd, or which don&#x27;t use systemd, shouldn&#x27;t have the issue.<p>One commenter posted in April 2021 that they had a patch to add support for nested UTS namespaces, but they don&#x27;t appear to have submitted it: <a href="https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;issues&#x2F;1430#issuecomment-813359795">https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;issues&#x2F;1430#issue...</a><p>Comment on another issue has suggestion on how to implement nested UTS namespace support: <a href="https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;issues&#x2F;1011#issuecomment-621070848">https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;issues&#x2F;1011#issue...</a><p>It doesn&#x27;t sound like nested UTS namespace support is impossible, just something nobody has got around to implementing.<p>Comment in CRIU source code says nested namespaces are only supported for mount namespaces (CLONE_NEWNS) and network namespaces (CLONE_NEWNET): <a href="https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;blob&#x2F;b5e2025765b9dfc0b2f583478b7a6380452956b3&#x2F;criu&#x2F;include&#x2F;namespaces.h#L48">https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;blob&#x2F;b5e2025765b9...</a><p>But if you look at the OpenVZ fork of CRIU, you see it also supports PID (CLONE_NEWPID), UTS (CLONE_NEWUTS) and IPC (CLONE_NEWIPC) namespaces: <a href="https:&#x2F;&#x2F;bitbucket.org&#x2F;openvz&#x2F;criu.ovz&#x2F;src&#x2F;d9bf55896015a27df93580181e0e2ecc3149006b&#x2F;criu&#x2F;include&#x2F;namespaces.h#lines-51" rel="nofollow">https:&#x2F;&#x2F;bitbucket.org&#x2F;openvz&#x2F;criu.ovz&#x2F;src&#x2F;d9bf55896015a27df9...</a><p>I don&#x27;t know why these additional features in OpenVZ CRIU don&#x27;t exist in the upstream.<p>I think the main blocker to supporting nesting of the other namespace types (user, cgroup, time), is someone getting around to write the code for the support. It is possible some of them pose some kind of architectural issue where some kernel enhancement might be necessary (if that&#x27;s true of any, I&#x27;d say most likely of user), but I suspect for most of them it is simply a matter that nobody has gotten around to it.<p>The other issue is eventually someone will add another namespace type to the Linux kernel, and then CRIU will need to support that too.</div><br/></div></div><div id="40754645" class="c"><input type="checkbox" id="c-40754645" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#40752517">parent</a><span>|</span><a href="#40754881">prev</a><span>|</span><a href="#40752724">next</a><span>|</span><label class="collapse" for="c-40754645">[-]</label><label class="expand" for="c-40754645">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Linux just keeps on working for years without a reboot<p>Except I would strongly suggest not doing that as there have been some very nasty security issues fixed as of late.</div><br/></div></div></div></div><div id="40752724" class="c"><input type="checkbox" id="c-40752724" checked=""/><div class="controls bullet"><span class="by">albertzeyer</span><span>|</span><a href="#40752517">prev</a><span>|</span><a href="#40754224">next</a><span>|</span><label class="collapse" for="c-40752724">[-]</label><label class="expand" for="c-40752724">[4 more]</label></div><br/><div class="children"><div class="content">We considered to use sth like this to cache some Python program state to speed up the startup time, as the startup time was quite long for some of our scripts (due to slow NFS, but also importing lots of libs, like PyTorch or TensorFlow). We wanted to store the program state right after importing the modules and loading some static stuff, before executing the actual script or doing other dynamic stuff. So updating the script is still possible while keeping the same state.<p>Back then, CRIU turned out to not be an option for us. E.g. one of the problems was that it was not possible to be used as non-root (<a href="https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;pull&#x2F;1930">https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu&#x2F;pull&#x2F;1930</a>). I see that this PR was merged now, so maybe this works now? Not sure if there are other issues.<p>We also considered DMTCP (<a href="https:&#x2F;&#x2F;github.com&#x2F;dmtcp&#x2F;dmtcp&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;dmtcp&#x2F;dmtcp&#x2F;</a>) as another alternative to CRIU, but that had other issues (I don&#x27;t remember).<p>The solution I ended up was to implement a fork server. Some server proc starts initially and only preloads the modules and maybe other things, and then waits. Once I want to execute some script, I can fork from the server and use this forked process right away. I used similar logic as in reptyr (<a href="https:&#x2F;&#x2F;github.com&#x2F;nelhage&#x2F;reptyr">https:&#x2F;&#x2F;github.com&#x2F;nelhage&#x2F;reptyr</a>) to redirect the PTY. This worked quite well.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;albertz&#x2F;python-preloaded">https:&#x2F;&#x2F;github.com&#x2F;albertz&#x2F;python-preloaded</a></div><br/><div id="40755100" class="c"><input type="checkbox" id="c-40755100" checked=""/><div class="controls bullet"><span class="by">nravic</span><span>|</span><a href="#40752724">parent</a><span>|</span><a href="#40755146">next</a><span>|</span><label class="collapse" for="c-40755100">[-]</label><label class="expand" for="c-40755100">[2 more]</label></div><br/><div class="children"><div class="content">How were you handling GPU state w&#x2F; pytorch? We added some custom code around CRIU to enable GPU checkpointing fwiw: <a href="https:&#x2F;&#x2F;docs.cedana.ai&#x2F;setup&#x2F;gpu-checkpointing&#x2F;">https:&#x2F;&#x2F;docs.cedana.ai&#x2F;setup&#x2F;gpu-checkpointing&#x2F;</a></div><br/><div id="40755158" class="c"><input type="checkbox" id="c-40755158" checked=""/><div class="controls bullet"><span class="by">albertzeyer</span><span>|</span><a href="#40752724">root</a><span>|</span><a href="#40755100">parent</a><span>|</span><a href="#40755146">next</a><span>|</span><label class="collapse" for="c-40755158">[-]</label><label class="expand" for="c-40755158">[1 more]</label></div><br/><div class="children"><div class="content">Not at all. I forked before I used anything with CUDA. I didn&#x27;t need it but I guessed this could cause all kind of weird problems.</div><br/></div></div></div></div><div id="40755146" class="c"><input type="checkbox" id="c-40755146" checked=""/><div class="controls bullet"><span class="by">alksjdalkj</span><span>|</span><a href="#40752724">parent</a><span>|</span><a href="#40755100">prev</a><span>|</span><a href="#40754224">next</a><span>|</span><label class="collapse" for="c-40755146">[-]</label><label class="expand" for="c-40755146">[1 more]</label></div><br/><div class="children"><div class="content">This sounds similar to what&#x27;s been done to speedup FaaS cold starts - snapshot the VM after the startup code runs, then launch functions from the snapshot.  E.g., <a href="https:&#x2F;&#x2F;www.sysnet.ucsd.edu&#x2F;~voelker&#x2F;pubs&#x2F;faasnap-eurosys22.pdf" rel="nofollow">https:&#x2F;&#x2F;www.sysnet.ucsd.edu&#x2F;~voelker&#x2F;pubs&#x2F;faasnap-eurosys22....</a>.</div><br/></div></div></div></div><div id="40754224" class="c"><input type="checkbox" id="c-40754224" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#40752724">prev</a><span>|</span><a href="#40753139">next</a><span>|</span><label class="collapse" for="c-40754224">[-]</label><label class="expand" for="c-40754224">[3 more]</label></div><br/><div class="children"><div class="content">How do things like this handle sockets? Is there some kind of first class event that the app can detect, or does it just &quot;close&quot; them all and assume the app can cleanly reconnect to reestablish them (once they detect that the socket has rudely closed on them)?</div><br/><div id="40754339" class="c"><input type="checkbox" id="c-40754339" checked=""/><div class="controls bullet"><span class="by">touisteur</span><span>|</span><a href="#40754224">parent</a><span>|</span><a href="#40754318">next</a><span>|</span><label class="collapse" for="c-40754339">[-]</label><label class="expand" for="c-40754339">[1 more]</label></div><br/><div class="children"><div class="content">There are many ways to go about it. Standard way recommended with libsoccr (the criu library to handle tcp socket checkpoint&#x2F;restore) is to install a firewall rule to filter packets during checkpoint and let tcp resend whatever it needs to resync whenever the socket is restored.<p>If you want your original process to continue living after the checkpoint and not lose packets during checkpoint, you can go a pretty long way with the &#x27;plug&#x27; tc, IFBs. And if you&#x27;re aventurous, lots of support for getsockopt&#x2F;setsockopt and ioctls have been or are being merged within io_uring so checkpointing a big-buffered TCP socket can cost under 100us, even less IIRC.</div><br/></div></div><div id="40754318" class="c"><input type="checkbox" id="c-40754318" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40754224">parent</a><span>|</span><a href="#40754339">prev</a><span>|</span><a href="#40753139">next</a><span>|</span><label class="collapse" for="c-40754318">[-]</label><label class="expand" for="c-40754318">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu?tab=readme-ov-file#tcp-sockets-checkpoint-restore">https:&#x2F;&#x2F;github.com&#x2F;checkpoint-restore&#x2F;criu?tab=readme-ov-fil...</a><p>&gt; One of the CRIU features is the ability to save and restore state of a TCP socket without breaking the connection. This functionality is considered to be useful by itself, and we have it available as the libsoccr library.</div><br/></div></div></div></div><div id="40753139" class="c"><input type="checkbox" id="c-40753139" checked=""/><div class="controls bullet"><span class="by">arjvik</span><span>|</span><a href="#40754224">prev</a><span>|</span><a href="#40752189">next</a><span>|</span><label class="collapse" for="c-40753139">[-]</label><label class="expand" for="c-40753139">[7 more]</label></div><br/><div class="children"><div class="content">For my OS class&#x27;s final project last quarter, I built a way to live-migrate a process (running on a custom OS we built from scratch) from one Raspberry Pi to another, essentially using checkpoint&#x2F;restore!<p>Getting the code cleaned up enough to post it has been on my to-do list for quite some time, and this has inspired me to do it soon!</div><br/><div id="40753227" class="c"><input type="checkbox" id="c-40753227" checked=""/><div class="controls bullet"><span class="by">arjvik</span><span>|</span><a href="#40753139">parent</a><span>|</span><a href="#40752189">next</a><span>|</span><label class="collapse" for="c-40753227">[-]</label><label class="expand" for="c-40753227">[6 more]</label></div><br/><div class="children"><div class="content">Should mention, the coolest part is that I never sent over &quot;all&quot; the memory used by the process, because it was difficult to tell what is needed and what isn&#x27;t. Instead, I was clever with virtual memory, and when a page of memory was needed that wasn&#x27;t loaded by the recipient Pi, it would request and lazy-load just that page from the provider Pi, and with some careful bookkeeping mark that the page was owned by the recipient Pi.</div><br/><div id="40753928" class="c"><input type="checkbox" id="c-40753928" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40753139">root</a><span>|</span><a href="#40753227">parent</a><span>|</span><a href="#40755127">next</a><span>|</span><label class="collapse" for="c-40753928">[-]</label><label class="expand" for="c-40753928">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Instead, I was clever with virtual memory, and when a page of memory was needed that wasn&#x27;t loaded by the recipient Pi, it would request and lazy-load just that page from the provider Pi, and with some careful bookkeeping mark that the page was owned by the recipient Pi.<p>I wonder if that &quot;trick&quot; can be extended to a full implementation of distributed shared memory, i.e. multiple nodes running separate tasks in a single address space and implementing cache coherence over the network.  Probably needs quite a bit of extra compiler&#x2F;runtime support so it wouldn&#x27;t really apply to standard binaries, but it might still be useful nonetheless.</div><br/><div id="40754472" class="c"><input type="checkbox" id="c-40754472" checked=""/><div class="controls bullet"><span class="by">nradclif</span><span>|</span><a href="#40753139">root</a><span>|</span><a href="#40753928">parent</a><span>|</span><a href="#40755471">next</a><span>|</span><label class="collapse" for="c-40754472">[-]</label><label class="expand" for="c-40754472">[2 more]</label></div><br/><div class="children"><div class="content">Partitioned Global Address Space (PGAS) compilers&#x2F;runtimes do something similar to that. Unified Parallel C (UPC,<a href="https:&#x2F;&#x2F;upc.lbl.gov&#x2F;" rel="nofollow">https:&#x2F;&#x2F;upc.lbl.gov&#x2F;</a>) and Coarray Fortran&#x2F;Coarray C++ (<a href="https:&#x2F;&#x2F;docs.nersc.gov&#x2F;development&#x2F;programming-models&#x2F;coarrays&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.nersc.gov&#x2F;development&#x2F;programming-models&#x2F;coarra...</a>) are good examples commonly used in HPC. Fabric Attached Memory (OpenFAM, <a href="https:&#x2F;&#x2F;openfam.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;openfam.github.io&#x2F;</a>) is another example.</div><br/><div id="40755412" class="c"><input type="checkbox" id="c-40755412" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#40753139">root</a><span>|</span><a href="#40754472">parent</a><span>|</span><a href="#40755471">next</a><span>|</span><label class="collapse" for="c-40755412">[-]</label><label class="expand" for="c-40755412">[1 more]</label></div><br/><div class="children"><div class="content">“commonly used in HPC” is a bit of a stretch if you’re talking about production applications.</div><br/></div></div></div></div><div id="40755471" class="c"><input type="checkbox" id="c-40755471" checked=""/><div class="controls bullet"><span class="by">arjvik</span><span>|</span><a href="#40753139">root</a><span>|</span><a href="#40753928">parent</a><span>|</span><a href="#40754472">prev</a><span>|</span><a href="#40755127">next</a><span>|</span><label class="collapse" for="c-40755471">[-]</label><label class="expand" for="c-40755471">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually basically what I was doing! Was able to run programs compiled for a &quot;normal&quot; OS on a single unified distributed virtual address space!</div><br/></div></div></div></div><div id="40755127" class="c"><input type="checkbox" id="c-40755127" checked=""/><div class="controls bullet"><span class="by">alksjdalkj</span><span>|</span><a href="#40753139">root</a><span>|</span><a href="#40753227">parent</a><span>|</span><a href="#40753928">prev</a><span>|</span><a href="#40752189">next</a><span>|</span><label class="collapse" for="c-40755127">[-]</label><label class="expand" for="c-40755127">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a cool class project!  If I understand your approach correctly, this is how live virtual machine migration typically works (e.g., <a href="https:&#x2F;&#x2F;none.cs.umass.edu&#x2F;~shenoy&#x2F;courses&#x2F;spring18&#x2F;readings&#x2F;xen-live-nsdi05.pdf" rel="nofollow">https:&#x2F;&#x2F;none.cs.umass.edu&#x2F;~shenoy&#x2F;courses&#x2F;spring18&#x2F;readings&#x2F;...</a>).  It also sounds similar to this &quot;remote-fork&quot; concept: <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi23-wei-rdma.pdf" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi23-wei-rdma.pdf</a>.</div><br/></div></div></div></div></div></div><div id="40752189" class="c"><input type="checkbox" id="c-40752189" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40753139">prev</a><span>|</span><a href="#40754163">next</a><span>|</span><label class="collapse" for="c-40752189">[-]</label><label class="expand" for="c-40752189">[4 more]</label></div><br/><div class="children"><div class="content">Would love a low-tech version of this which simply suspends the process and puts all mapped pages in swap (no persistence across reboot ofc). I think it could be used for scheduling large memory-bound jobs whose resource usage is not known in advance.</div><br/><div id="40752251" class="c"><input type="checkbox" id="c-40752251" checked=""/><div class="controls bullet"><span class="by">dividuum</span><span>|</span><a href="#40752189">parent</a><span>|</span><a href="#40754163">next</a><span>|</span><label class="collapse" for="c-40752251">[-]</label><label class="expand" for="c-40752251">[3 more]</label></div><br/><div class="children"><div class="content">Not sure that’s needed. Sending SIGSTOP (or using cgroup freeze) and letting the linux memory management do its job should do most of that already.</div><br/><div id="40752322" class="c"><input type="checkbox" id="c-40752322" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#40752189">root</a><span>|</span><a href="#40752251">parent</a><span>|</span><a href="#40755228">next</a><span>|</span><label class="collapse" for="c-40752322">[-]</label><label class="expand" for="c-40752322">[1 more]</label></div><br/><div class="children"><div class="content">Yes I confirm it works - I’ve been using this very behavior for years</div><br/></div></div><div id="40755228" class="c"><input type="checkbox" id="c-40755228" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40752189">root</a><span>|</span><a href="#40752251">parent</a><span>|</span><a href="#40752322">prev</a><span>|</span><a href="#40754163">next</a><span>|</span><label class="collapse" for="c-40755228">[-]</label><label class="expand" for="c-40755228">[1 more]</label></div><br/><div class="children"><div class="content">Yep, nothing fancy needed</div><br/></div></div></div></div></div></div><div id="40754163" class="c"><input type="checkbox" id="c-40754163" checked=""/><div class="controls bullet"><span class="by">EatFlamingDeath</span><span>|</span><a href="#40752189">prev</a><span>|</span><a href="#40752902">next</a><span>|</span><label class="collapse" for="c-40754163">[-]</label><label class="expand" for="c-40754163">[2 more]</label></div><br/><div class="children"><div class="content">Can this be used for something like Steam Deck? It would be nice for when you are running a game and needs to stop but will resume gameplay later.</div><br/><div id="40756857" class="c"><input type="checkbox" id="c-40756857" checked=""/><div class="controls bullet"><span class="by">janosdebugs</span><span>|</span><a href="#40754163">parent</a><span>|</span><a href="#40752902">next</a><span>|</span><label class="collapse" for="c-40756857">[-]</label><label class="expand" for="c-40756857">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say unlikely, games do a lot of work within graphics cards that are not as easily dumpable&#x2F;restorable as memory.</div><br/></div></div></div></div><div id="40752902" class="c"><input type="checkbox" id="c-40752902" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40754163">prev</a><span>|</span><a href="#40752545">next</a><span>|</span><label class="collapse" for="c-40752902">[-]</label><label class="expand" for="c-40752902">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve interacted with some of these features as a means of code injection into running processes. (checkpoint, patch the checkpoint data, restore)<p>It&#x27;s useful because, by design, it&#x27;s difficult for the process to even notice it&#x27;s been stopped. And while it&#x27;s stopped, you can apply arbitrary patches completely atomically.</div><br/></div></div><div id="40752545" class="c"><input type="checkbox" id="c-40752545" checked=""/><div class="controls bullet"><span class="by">overspeed</span><span>|</span><a href="#40752902">prev</a><span>|</span><a href="#40754870">next</a><span>|</span><label class="collapse" for="c-40752545">[-]</label><label class="expand" for="c-40752545">[1 more]</label></div><br/><div class="children"><div class="content">Great project!<p>For long running containerised simulations, this saves a lot of time on failures ( as long as you have a safe place to write the snapshots to ) by not restarting from 0 every time.</div><br/></div></div><div id="40754870" class="c"><input type="checkbox" id="c-40754870" checked=""/><div class="controls bullet"><span class="by">vfclists</span><span>|</span><a href="#40752545">prev</a><span>|</span><a href="#40752295">next</a><span>|</span><label class="collapse" for="c-40754870">[-]</label><label class="expand" for="c-40754870">[1 more]</label></div><br/><div class="children"><div class="content">Some one uses it to start Emacs very quickly - <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;blak3mill3r&#x2F;emacs-ludicrous-speed" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;blak3mill3r&#x2F;emacs-ludicrous-speed</a></div><br/></div></div><div id="40752295" class="c"><input type="checkbox" id="c-40752295" checked=""/><div class="controls bullet"><span class="by">usixk</span><span>|</span><a href="#40754870">prev</a><span>|</span><a href="#40755213">next</a><span>|</span><label class="collapse" for="c-40752295">[-]</label><label class="expand" for="c-40752295">[2 more]</label></div><br/><div class="children"><div class="content">seriously cool project, used it at a prev workplace to checkpoint http servers for absolutely dirt nasty start speeds</div><br/><div id="40752341" class="c"><input type="checkbox" id="c-40752341" checked=""/><div class="controls bullet"><span class="by">bityard</span><span>|</span><a href="#40752295">parent</a><span>|</span><a href="#40755213">next</a><span>|</span><label class="collapse" for="c-40752341">[-]</label><label class="expand" for="c-40752341">[1 more]</label></div><br/><div class="children"><div class="content">nginx gone wild?</div><br/></div></div></div></div><div id="40755213" class="c"><input type="checkbox" id="c-40755213" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40752295">prev</a><span>|</span><a href="#40752372">next</a><span>|</span><label class="collapse" for="c-40755213">[-]</label><label class="expand" for="c-40755213">[1 more]</label></div><br/><div class="children"><div class="content">This is what supports Docker&#x27;s checkpoint create&#x2F;restore.<p>And Docker is a very convenient way to do this, e.g. workaround the PID limitation.<p>(Though I really wish it got more attention <a href="https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;cli&#x2F;issues&#x2F;4245">https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;cli&#x2F;issues&#x2F;4245</a> )</div><br/></div></div></div></div></div></div></div></body></html>