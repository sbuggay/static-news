<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701766854762" as="style"/><link rel="stylesheet" href="styles.css?v=1701766854762"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/unix/KernelNameCachesWhy">Why Unix kernels have grown caches for directory entries (&#x27;name caches&#x27;)</a> <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>pabs3</span> | <span>15 comments</span></div><br/><div><div id="38526894" class="c"><input type="checkbox" id="c-38526894" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#38527674">next</a><span>|</span><label class="collapse" for="c-38526894">[-]</label><label class="expand" for="c-38526894">[10 more]</label></div><br/><div class="children"><div class="content">(Note that everything in the sidebar is about &quot;conventional Unix&quot;.)<p>&gt; <i>A directory in a conventional Unix filesystem has either one name or no name (if it&#x27;s been removed). Because of this, the kernel&#x27;s name cache can always know the directory&#x27;s current name if it has one. If it wants to, the name cache can go further and provide the last name that the directory was known by before it was deleted, along with a mark that it was deleted.</i><p>In Linux, you can end up with directories having different names via bind-mounting one path to another, or via two processes having different mount namespaces. IDK if you count inside&#x2F;outside a chroot as &quot;different&quot; or not.<p>&gt; <i>A file can have no name (if it&#x27;s been removed since it was opened or mmap()&#x27;d), it can have one name, or it can have several names because there are several hardlinks to it. Because of this the kernel name cache may not necessarily know the current name of an open file. If it started out having multiple hardlinks, was opened through one hardlink, and then that hardlink was removed, the name cache may not know the name of the other remaining hardlink(s).</i><p>It can also have no name if it was simply never given one; on Linux you can open a file without ever linking it, essentially. (See open(2), the O_TMPFILE flag.) Usually for the same semantics as the deleted tempfile (hence the name), just atomic.<p>I sort of wish it was in there from the beginning, as it is what I think the atomic rename to write a file pattern should <i>really</i> look like in the common case:<p><pre><code>  1. create the file via open(2) with no name.
  2. write the contents
  3. atomically link the file with rename&#x27;s atomic replace semantics
</code></pre>
That avoids the ugliness of the file needing some temporary name at all.<p>(Note that these files are disk-backed: the open call takes a directory which essentially becomes the backing FS for the data.)<p>There&#x27;s also memfd_create(2), which is like the in-memory version of the above. You can&#x27;t link those. (Yet…? if you had an in-memory FS … IDK, maybe it could make sense…? how much do you like plan9?)</div><br/><div id="38527056" class="c"><input type="checkbox" id="c-38527056" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38526894">parent</a><span>|</span><a href="#38527674">next</a><span>|</span><label class="collapse" for="c-38527056">[-]</label><label class="expand" for="c-38527056">[9 more]</label></div><br/><div class="children"><div class="content">I wonder what happens if you violate the 0 xor 1 rule by hard linking a directory - it is <i>strongly</i> discouraged for very good reasons but was at least historically possible ( <a href="https:&#x2F;&#x2F;askubuntu.com&#x2F;questions&#x2F;210741&#x2F;why-are-hard-links-not-allowed-for-directories" rel="nofollow noreferrer">https:&#x2F;&#x2F;askubuntu.com&#x2F;questions&#x2F;210741&#x2F;why-are-hard-links-no...</a> comments discuss a bit in between the dire warnings). Or maybe it&#x27;s not possible on newer systems that have such a cache?</div><br/><div id="38527094" class="c"><input type="checkbox" id="c-38527094" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#38526894">root</a><span>|</span><a href="#38527056">parent</a><span>|</span><a href="#38527373">next</a><span>|</span><label class="collapse" for="c-38527094">[-]</label><label class="expand" for="c-38527094">[3 more]</label></div><br/><div class="children"><div class="content">Apple allows hard linking directories (I believe it is used for Time Machine somehow): <a href="https:&#x2F;&#x2F;jameshunt.us&#x2F;writings&#x2F;linking-dirs-in-macos&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jameshunt.us&#x2F;writings&#x2F;linking-dirs-in-macos&#x2F;</a></div><br/><div id="38527289" class="c"><input type="checkbox" id="c-38527289" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#38526894">root</a><span>|</span><a href="#38527094">parent</a><span>|</span><a href="#38527373">next</a><span>|</span><label class="collapse" for="c-38527289">[-]</label><label class="expand" for="c-38527289">[2 more]</label></div><br/><div class="children"><div class="content">Is that true on APFS? I know they added it to HFS+ for Time Machine, but I’d assumed it’s no longer necessary (or possible) with the newer filesystem that allows for real snapshots.</div><br/><div id="38527333" class="c"><input type="checkbox" id="c-38527333" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#38526894">root</a><span>|</span><a href="#38527289">parent</a><span>|</span><a href="#38527373">next</a><span>|</span><label class="collapse" for="c-38527333">[-]</label><label class="expand" for="c-38527333">[1 more]</label></div><br/><div class="children"><div class="content">It’s no longer possible.</div><br/></div></div></div></div></div></div><div id="38527373" class="c"><input type="checkbox" id="c-38527373" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#38526894">root</a><span>|</span><a href="#38527056">parent</a><span>|</span><a href="#38527094">prev</a><span>|</span><a href="#38527491">next</a><span>|</span><label class="collapse" for="c-38527373">[-]</label><label class="expand" for="c-38527373">[4 more]</label></div><br/><div class="children"><div class="content">You can do it with FUSE I&#x27;m pretty sure</div><br/><div id="38527928" class="c"><input type="checkbox" id="c-38527928" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38526894">root</a><span>|</span><a href="#38527373">parent</a><span>|</span><a href="#38527491">next</a><span>|</span><label class="collapse" for="c-38527928">[-]</label><label class="expand" for="c-38527928">[3 more]</label></div><br/><div class="children"><div class="content">Yes.  I&#x27;ve done that (but only on immutable filesystems, where it&#x27;s not (much of?) a problem).</div><br/><div id="38528124" class="c"><input type="checkbox" id="c-38528124" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38526894">root</a><span>|</span><a href="#38527928">parent</a><span>|</span><a href="#38527491">next</a><span>|</span><label class="collapse" for="c-38528124">[-]</label><label class="expand" for="c-38528124">[2 more]</label></div><br/><div class="children"><div class="content">Being ro helps with deleting directories (by preventing it, but w&#x2F;e), but cyclical links would be bad regardless. Granted, it&#x27;s the kind of thing that&#x27;s <i>probably</i> okay if you know what you&#x27;re doing well enough to avoid the footguns... but I have no experience, so can&#x27;t say for sure.</div><br/><div id="38528145" class="c"><input type="checkbox" id="c-38528145" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38526894">root</a><span>|</span><a href="#38528124">parent</a><span>|</span><a href="#38527491">next</a><span>|</span><label class="collapse" for="c-38528145">[-]</label><label class="expand" for="c-38528145">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I didn&#x27;t have any cycles.<p>I was exposing a git repository as a DAG of directories via FUSE, and was translating git internal IDs, based on hash, straight to inodes in a one-to-one fashion.  Git doesn&#x27;t allow cycles (unless you break the cryptographic hash function).</div><br/></div></div></div></div></div></div></div></div><div id="38527491" class="c"><input type="checkbox" id="c-38527491" checked=""/><div class="controls bullet"><span class="by">Affric</span><span>|</span><a href="#38526894">root</a><span>|</span><a href="#38527056">parent</a><span>|</span><a href="#38527373">prev</a><span>|</span><a href="#38527674">next</a><span>|</span><label class="collapse" for="c-38527491">[-]</label><label class="expand" for="c-38527491">[1 more]</label></div><br/><div class="children"><div class="content">That’s a good write up.</div><br/></div></div></div></div></div></div><div id="38527674" class="c"><input type="checkbox" id="c-38527674" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#38526894">prev</a><span>|</span><a href="#38526905">next</a><span>|</span><label class="collapse" for="c-38527674">[-]</label><label class="expand" for="c-38527674">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because of this the kernel name cache may not necessarily know the current name of an open file. If it started out having multiple hardlinks, was opened through one hardlink, and then that hardlink was removed, the name cache may not know the name of the other remaining hardlink(s).<p>I found this the hard way when implementing a FUSE file system for macOS that required knowing the “real path” of a file and that faked “hard links” for performance reasons. It was super hard to diagnose and I’m still not sure if there is a solution to the problem I faced. If you are curious, the details of the story are here: <a href="https:&#x2F;&#x2F;jmmv.dev&#x2F;2020&#x2F;01&#x2F;osxfuse-hardlinks-dladdr.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;jmmv.dev&#x2F;2020&#x2F;01&#x2F;osxfuse-hardlinks-dladdr.html</a></div><br/></div></div><div id="38526905" class="c"><input type="checkbox" id="c-38526905" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38527674">prev</a><span>|</span><a href="#38527379">next</a><span>|</span><label class="collapse" for="c-38526905">[-]</label><label class="expand" for="c-38526905">[1 more]</label></div><br/><div class="children"><div class="content">There may also be a 31 character limit on cached names, so spamming stat(&quot;long-uuid-unicorn-happy-fun-zone&quot;) could be slower than expected.</div><br/></div></div><div id="38527379" class="c"><input type="checkbox" id="c-38527379" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#38526905">prev</a><span>|</span><label class="collapse" for="c-38527379">[-]</label><label class="expand" for="c-38527379">[2 more]</label></div><br/><div class="children"><div class="content">This seems to be conflating caching the contents of directories and caching the names of files.<p>One is perfectly fine. One relies on sketchy invariants that I fine distasteful.</div><br/><div id="38527526" class="c"><input type="checkbox" id="c-38527526" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#38527379">parent</a><span>|</span><label class="collapse" for="c-38527526">[-]</label><label class="expand" for="c-38527526">[1 more]</label></div><br/><div class="children"><div class="content">Yes.  There&#x27;s the-kernel-knows-open-files&#x27;-names and the-kernel-has-a-cache-of-absolute-paths and the-kernel-has-a-cache-for-in-core-directories.  There&#x27;s a large variety of ways to do this with one or multiple caches.</div><br/></div></div></div></div></div></div></div></div></div></body></html>