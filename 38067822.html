<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698742865399" as="style"/><link rel="stylesheet" href="styles.css?v=1698742865399"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gregoryszorc.com/blog/2023/10/30/my-user-experience-porting-off-setup.py/">My User Experience Porting Off Setup.py</a> <span class="domain">(<a href="https://gregoryszorc.com">gregoryszorc.com</a>)</span></div><div class="subtext"><span>markdog12</span> | <span>38 comments</span></div><br/><div><div id="38074078" class="c"><input type="checkbox" id="c-38074078" checked=""/><div class="controls bullet"><span class="by">Taikonerd</span><span>|</span><a href="#38080789">next</a><span>|</span><label class="collapse" for="c-38074078">[-]</label><label class="expand" for="c-38074078">[13 more]</label></div><br/><div class="children"><div class="content">Packages have always been Python&#x27;s Achilles heel.  Python&#x27;s philosophy for <i>code</i> is, &quot;there should be one, and preferably only one, obvious way to do it.&quot;  But for <i>packaging systems</i>, their philosophy is more like Perl: &quot;there&#x27;s more than one way to do it (and all of them have their own pitfalls).&quot;<p>I don&#x27;t understand why the Python leadership hasn&#x27;t shown stronger... leadership... in which tools they recommend.</div><br/><div id="38081602" class="c"><input type="checkbox" id="c-38081602" checked=""/><div class="controls bullet"><span class="by">stabbles</span><span>|</span><a href="#38074078">parent</a><span>|</span><a href="#38076220">next</a><span>|</span><label class="collapse" for="c-38081602">[-]</label><label class="expand" for="c-38081602">[1 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s situation is pathetic. Some Python folks wanted to get rid of the builtin module `distutils`. Got deprecated, and now it&#x27;s finally removed in Python 3.12. That&#x27;s a breaking change in a minor release, probably because they&#x27;re too afraid to do a Python 4 release after the 2-&gt;3 debacle. Then they publish a migration guide only as part of the 3.12 release, which is too little too late, cause the majority of the projects hasn&#x27;t moved away from `distutils` yet. There&#x27;s a lot of unclarity like &quot;you can just install setuptools, it replaces distutils&quot; (setuptools has a startup script that hacks the search paths so you can still run `import distutils` and get their vendored copy of it). Except nobody knows whether to add a conditional dependency on setuptools then. Why on earth do you have to depend on another package to get a vendored copy of distutils? And a fraction of the projects doesn&#x27;t care and makes it a user problem: just install setuptools yourself as a system &#x2F; user site-package, then everything works. (Except it doesn&#x27;t when setuptools is in PYTHONPATH cause the startup script doesn&#x27;t run, which happens on nix and other prefix-based package managers). At the end of the day, every Python package has their own ugly solution.<p>All that could have been prevented by the Python folks who insisted on deprecating a builtin module. They could have jumped in and help migrate the popular Python packages away from distutils long ago, to set an example. But nope, they really like to keep things messy.</div><br/></div></div><div id="38076220" class="c"><input type="checkbox" id="c-38076220" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#38074078">parent</a><span>|</span><a href="#38081602">prev</a><span>|</span><a href="#38081597">next</a><span>|</span><label class="collapse" for="c-38076220">[-]</label><label class="expand" for="c-38076220">[4 more]</label></div><br/><div class="children"><div class="content">My impression is that there&#x27;s lots of different niches that have developed, each with their own needs, and trying to unify them is a mess.<p>If you&#x27;re putting something like a web app or something else that will be bundled and distributed as a unit, then you&#x27;re probably best off with something like Poetry, PDM, or pip-tools - you have a lock file for deterministic dependencies, most of your dependencies will be pure python wheels, and you only really need to test things once. On the other hand, if you&#x27;re developing a library, you&#x27;ll need to test against multiple versions of Python, and ideally multiple versions of some of your larger dependencies, to ensure that your library will work for as many users as possible. You&#x27;ll also need to be able to build and package wheels. Alternatively, you&#x27;re working in data science, and your main concern is probably making sure you can install the packages you need in the environments you&#x27;re going to use them - specifically, so that they work with the GPUs and other hardware you have available. And there&#x27;s still the group of people writing mainly scripts for server maintenance or other tasks, who want to be able to easily install dependencies and keep those dependencies up to date for security reasons, with the minimum number of breaking changes.<p>Right now, there are different tools, packaging systems, etc catering to each of these groups, and so building the One Ring of Python package management is going to involve (a) solving all of these problems, and (b) convincing all these groups of people that your general solution is better than their niche-specific solution. That&#x27;s certainly not easy, I don&#x27;t even know if it&#x27;s all that possible.<p>I do think that working from the ground up (i.e building the individual components like the package metadata file, or the pypackages folder experiment) seems to be working well, in that tools seem to be coalescing around these options and finding the best ways to use them, which is all work that might hopefully feed into new official tooling. But we&#x27;ll see.</div><br/><div id="38080412" class="c"><input type="checkbox" id="c-38080412" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#38074078">root</a><span>|</span><a href="#38076220">parent</a><span>|</span><a href="#38081597">next</a><span>|</span><label class="collapse" for="c-38080412">[-]</label><label class="expand" for="c-38080412">[3 more]</label></div><br/><div class="children"><div class="content">&gt; you&#x27;re working in data science, and your main concern is probably making sure you can install the packages you need in the environments you&#x27;re going to use them<p>Honest question from a web developer who sometimes has to work with Python — don&#x27;t containers solve exactly this?</div><br/><div id="38080620" class="c"><input type="checkbox" id="c-38080620" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#38074078">root</a><span>|</span><a href="#38080412">parent</a><span>|</span><a href="#38080779">next</a><span>|</span><label class="collapse" for="c-38080620">[-]</label><label class="expand" for="c-38080620">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately no, the problem here is that you&#x27;re probably going to need a lot of compiled extensions, and some of these extensions are going to be running on your GPU (especially if you&#x27;re in the ML world, but also more generally if you want to take advantage of e.g. your lab&#x27;s HPC cluster). PyPI can manage some of this with the wheels system (i.e. OS, architecture, Python ABI), but there&#x27;s no metadata to indicate, for example, which GPU you have available. So in most cases it&#x27;s possible to just precompile all the relevant variants and let people download the best one for them, or even in some cases allow people to compile everything for themselves, but there&#x27;s still situations where those aren&#x27;t good options.<p>This is why PyTorch is famously more complicated to install via newer packages managers such as Poetry, because it requires something slightly more complicated than the existing Wheel setup, and most package managers aren&#x27;t designed for that. (Pip isn&#x27;t designed for that either, but PyTorch has come up with workarounds for pip already.)<p>Containers can&#x27;t solve this problem because containers are tied to the architecture of the machine they&#x27;re running on, they can&#x27;t abstract that away. So even if your code is running in a container, it still needs to know which architecture, OS, resources, etc it has access to.</div><br/></div></div><div id="38080779" class="c"><input type="checkbox" id="c-38080779" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#38074078">root</a><span>|</span><a href="#38080412">parent</a><span>|</span><a href="#38080620">prev</a><span>|</span><a href="#38081597">next</a><span>|</span><label class="collapse" for="c-38080779">[-]</label><label class="expand" for="c-38080779">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly no - <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;63960319&#x2F;does-it-matter-if-the-version-of-cuda-on-docker-is-different-from-the-version-of" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;63960319&#x2F;does-it-matter-...</a><p>You need to be running a GPU driver on the host that supports the container cuda version.<p>So in theory yes, in practice, weird issue occur sometimes that really suck to debug. For example why do I get NaN loss after spending 8 days on 128 GPUs with this specific set of drivers+cuda container? (Don&#x27;t hold it that way, use a matching cuda version...)<p>Also a lot of data scientists HATE sys-admin tasks and docker falls squarely into that for many people.</div><br/></div></div></div></div></div></div><div id="38081597" class="c"><input type="checkbox" id="c-38081597" checked=""/><div class="controls bullet"><span class="by">enthus1ast</span><span>|</span><a href="#38074078">parent</a><span>|</span><a href="#38076220">prev</a><span>|</span><a href="#38076347">next</a><span>|</span><label class="collapse" for="c-38081597">[-]</label><label class="expand" for="c-38081597">[1 more]</label></div><br/><div class="children"><div class="content">Packaging was the reason I left python (in favor of Nim) roughly 10 years ago.</div><br/></div></div><div id="38076347" class="c"><input type="checkbox" id="c-38076347" checked=""/><div class="controls bullet"><span class="by">tracnar</span><span>|</span><a href="#38074078">parent</a><span>|</span><a href="#38081597">prev</a><span>|</span><a href="#38079740">next</a><span>|</span><label class="collapse" for="c-38076347">[-]</label><label class="expand" for="c-38076347">[1 more]</label></div><br/><div class="children"><div class="content">It seems to stem from the Python packaging story being driven by PyPA, rather than the Python foundation, which appears reluctant to pick a packaging solution and ship it with CPython. setuptools was kind of an in-between, it was included in CPython but in many cases you have to update it or add plugins...</div><br/></div></div><div id="38079740" class="c"><input type="checkbox" id="c-38079740" checked=""/><div class="controls bullet"><span class="by">eddyg</span><span>|</span><a href="#38074078">parent</a><span>|</span><a href="#38076347">prev</a><span>|</span><a href="#38081047">next</a><span>|</span><label class="collapse" for="c-38079740">[-]</label><label class="expand" for="c-38079740">[3 more]</label></div><br/><div class="children"><div class="content">I’m thinking <a href="https:&#x2F;&#x2F;astral.sh&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;astral.sh&#x2F;</a> are going to be the ones to “solve” this.</div><br/><div id="38080245" class="c"><input type="checkbox" id="c-38080245" checked=""/><div class="controls bullet"><span class="by">epicureanideal</span><span>|</span><a href="#38074078">root</a><span>|</span><a href="#38079740">parent</a><span>|</span><a href="#38079930">next</a><span>|</span><label class="collapse" for="c-38080245">[-]</label><label class="expand" for="c-38080245">[1 more]</label></div><br/><div class="children"><div class="content">Astral and Ruff look great, but what is their monetization strategy, and how do their interests intersect with the interests of the developer community in the long term?</div><br/></div></div><div id="38079930" class="c"><input type="checkbox" id="c-38079930" checked=""/><div class="controls bullet"><span class="by">preciousoo</span><span>|</span><a href="#38074078">root</a><span>|</span><a href="#38079740">parent</a><span>|</span><a href="#38080245">prev</a><span>|</span><a href="#38081047">next</a><span>|</span><label class="collapse" for="c-38079930">[-]</label><label class="expand" for="c-38079930">[1 more]</label></div><br/><div class="children"><div class="content">Unsure if slick promo or not, but that review by tiangolo instantly piqued my interest</div><br/></div></div></div></div><div id="38081047" class="c"><input type="checkbox" id="c-38081047" checked=""/><div class="controls bullet"><span class="by">ximm</span><span>|</span><a href="#38074078">parent</a><span>|</span><a href="#38079740">prev</a><span>|</span><a href="#38080616">next</a><span>|</span><label class="collapse" for="c-38081047">[-]</label><label class="expand" for="c-38081047">[1 more]</label></div><br/><div class="children"><div class="content">I believe PEP 517 was how the Python leadership wanted to improve the situation. Unfortunately it backfired hard. It broke the existing systems and further fractured the ecosystem.</div><br/></div></div><div id="38080616" class="c"><input type="checkbox" id="c-38080616" checked=""/><div class="controls bullet"><span class="by">gonzo41</span><span>|</span><a href="#38074078">parent</a><span>|</span><a href="#38081047">prev</a><span>|</span><a href="#38080789">next</a><span>|</span><label class="collapse" for="c-38080616">[-]</label><label class="expand" for="c-38080616">[1 more]</label></div><br/><div class="children"><div class="content">Python leadership did the python 2-&gt;3 adventure. So.....<p>But yeah, I agree. This is something that golang nails. They supply all the options out of the box.</div><br/></div></div></div></div><div id="38080789" class="c"><input type="checkbox" id="c-38080789" checked=""/><div class="controls bullet"><span class="by">ahgamut</span><span>|</span><a href="#38074078">prev</a><span>|</span><a href="#38081350">next</a><span>|</span><label class="collapse" for="c-38080789">[-]</label><label class="expand" for="c-38080789">[1 more]</label></div><br/><div class="children"><div class="content">Thank you Gregory for writing this post. There have been a bunch of announcements about &quot;setup.py has been deprecated&quot;, but few have clearly outlined how to move away from setup.py, and more importantly, fewer have outlined what a struggle it is to move away from setup.py.<p>I was sad to see setuptools officially deprecated, because it looks like another way in which Python packaging is being red-taped away for a non-expert. If someone like the OP (who has 10+ years programming Python) had to do so much for what appears to be a zstd CFFI&#x2F;Rust wrapper, where does that leave the rest of us?<p>Here&#x27;s a python package of mine that uses setup.py: <a href="https:&#x2F;&#x2F;github.com&#x2F;ahgamut&#x2F;cliquematch&#x2F;blob&#x2F;master&#x2F;setup.py">https:&#x2F;&#x2F;github.com&#x2F;ahgamut&#x2F;cliquematch&#x2F;blob&#x2F;master&#x2F;setup.py</a> which I have not upgraded to the new tool(s) yet. I think I will need to upgrade it soon. If anyone has suggestions for a tool that will _fully replace_ setup.py, I would like to see tutorials with the following examples:<p>1. How would I build a package that has pure-Python files and data files? With setuptools I would use maybe MANIFEST.in or package_dir.<p>2. How would I build a package that has a CPython extension accessed via cffi? (this post points to the answer)<p>3. How would I build a package that has a CPython extension _without_ cffi, that just wraps some small C code I wrote with CPython&#x27;s API? What about an extension that uses PyBind11? What about an extension that uses Rust?<p>4. How would I build a package that requires a &quot;system&quot; package like libblas-dev? Can something like numpy be built optimally without ever writing setup.py? What would a config for that look like? Last I remember numpy used their own patch of distutils to build, I wonder what it is now.</div><br/></div></div><div id="38081350" class="c"><input type="checkbox" id="c-38081350" checked=""/><div class="controls bullet"><span class="by">PennRobotics</span><span>|</span><a href="#38080789">prev</a><span>|</span><a href="#38081592">next</a><span>|</span><label class="collapse" for="c-38081350">[-]</label><label class="expand" for="c-38081350">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    I open https:&#x2F;&#x2F;blog.ganssle.io&#x2F;articles&#x2F;2021&#x2F;10&#x2F;setup-py-deprecated.html
    in my browser and see a 4,000+ word blog post.
    Oof. Do I really want&#x2F;need to read this?
</code></pre>
<i>*proceeds to write an 8,000 word blog post about it*</i><p>-----<p>Kidding aside, good content and a great reminder to think before blindly upgrading—at least until the kinks and details are worked through</div><br/></div></div><div id="38081592" class="c"><input type="checkbox" id="c-38081592" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#38081350">prev</a><span>|</span><a href="#38080140">next</a><span>|</span><label class="collapse" for="c-38081592">[-]</label><label class="expand" for="c-38081592">[1 more]</label></div><br/><div class="children"><div class="content">I’m quite surprised to see that setup.py has been deprecated for years. I set out to setup my first package earlier this year and after spending way too much time trying to figure out what is recommended and why I actually settled on setup.py<p>I knew it was “the old” way, but didn’t realize it was abandoned.<p>Getting your code packaged seems way harder than developing your code.</div><br/></div></div><div id="38080140" class="c"><input type="checkbox" id="c-38080140" checked=""/><div class="controls bullet"><span class="by">akubera</span><span>|</span><a href="#38081592">prev</a><span>|</span><a href="#38077613">next</a><span>|</span><label class="collapse" for="c-38080140">[-]</label><label class="expand" for="c-38080140">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had a similarly frustrating time trying to understand and wrangle the pyproject.toml builder system, (egg-layer? wheel-roller? cheese-monger?)<p>One thing the author might want to try is writing their own &quot;build-backend&quot;. You can specify your own script (even use setup.py) and that will be the target of python -m build or pip wheel or presumably whatever build-frontend you use.<p><pre><code>    # pyproject.toml
    [build-system]
    requires = [&quot;setuptools&quot;]
    build-backend = &quot;setup&quot;  # import setup.py as the build-module
    backend-path = [&quot;.&quot;]

</code></pre>
Then in setup.py you should write two functions:<p><pre><code>    def build_sdist(sdist_directory, config_settings):
        ...

    def build_wheel(wheel_directory, config_settings, metadata_directory):
        ...

</code></pre>
Where config_settings is a dictionary of the command line &quot;--config-settings&quot; options passed to the builder. (sys.argv does not have access to the actual invocation, I suppose to ensure frontend standardization)<p>example:<p><pre><code>    $ python -m build --config-setting=foo=bar --config-setting=can-spam

    # will call 
    &gt;&gt;&gt; build_sdist(&quot;the&#x2F;dist&#x2F;dir&quot;, {&quot;foo&quot;: &quot;bar&quot;, &quot;can&quot;: &quot;spam&quot;})

</code></pre>
Of course, you can extend the default setuptools build meta so you only have to
do the pre-compilation or whatever your custom build step requires:<p><pre><code>    from setuptools.build_meta import build_sdist as setuptools_build_sdist

    def build_sdist(sdist_directory, config_settings):
        # ... code-gen and copy files to source  ...

        # this will call setup.py::setup, to make things extra confusing
        return setuptools_build_sdist(sdist_directory, config_settings)
</code></pre>
I had to create a temporary MANIFEST.in file to make sure that the setuptools
build_sdist saw the generated files. Maybe there&#x27;s a better way?
I think the wheel &quot;just&quot; packages whatever the sdist produces, though that might be more difficult if you&#x27;re compiling .so files or whatnot.<p>Still overall pretty fiddly&#x2F;under-documented and a shame there seems to be a push for <i>more</i> dependencies rather than encouraging users to build their own solutions.<p>More info in PEP 517: <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0517&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0517&#x2F;</a></div><br/></div></div><div id="38077613" class="c"><input type="checkbox" id="c-38077613" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#38080140">prev</a><span>|</span><a href="#38081016">next</a><span>|</span><label class="collapse" for="c-38077613">[-]</label><label class="expand" for="c-38077613">[6 more]</label></div><br/><div class="children"><div class="content">A friend of mine had a critique of videogames that has stuck with me. He called them &quot;antiknowledge&quot;. Your brain&#x27;s learning faculties are repurposed into &quot;learning&quot; something that isn&#x27;t actually a <i>thing</i>. You get really good at some artificial skinner box treadmill system ... and then they change the meta and you have to keep up with the new stats and strategies and so on. Yet after sinking in hundreds of hours, you don&#x27;t come out the other end with any tangible real-life skill, that would be useful outside of the game.<p>That&#x27;s what Python packaging feels like. At least videogames are fun.</div><br/><div id="38079531" class="c"><input type="checkbox" id="c-38079531" checked=""/><div class="controls bullet"><span class="by">Pannoniae</span><span>|</span><a href="#38077613">parent</a><span>|</span><a href="#38080422">next</a><span>|</span><label class="collapse" for="c-38079531">[-]</label><label class="expand" for="c-38079531">[1 more]</label></div><br/><div class="children"><div class="content">Not all of them! Many of those skinnerbox type games actually have a pretty mediocre or outright unfun game loop - it&#x27;s the skins, battle passes and &quot;rewards&quot; which keep people playing.</div><br/></div></div><div id="38080422" class="c"><input type="checkbox" id="c-38080422" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#38077613">parent</a><span>|</span><a href="#38079531">prev</a><span>|</span><a href="#38079551">next</a><span>|</span><label class="collapse" for="c-38080422">[-]</label><label class="expand" for="c-38080422">[1 more]</label></div><br/><div class="children"><div class="content">A lot of videogames have you learning antiknowledge, but at the same time very useful meta skills. Build orders in Starcraft won&#x27;t help you in your office job, but a habit of working out complicated tradeoffs, feeling out your opponent and having a feel of un-intuitive consequences will.</div><br/></div></div><div id="38079551" class="c"><input type="checkbox" id="c-38079551" checked=""/><div class="controls bullet"><span class="by">totallywrong</span><span>|</span><a href="#38077613">parent</a><span>|</span><a href="#38080422">prev</a><span>|</span><a href="#38081016">next</a><span>|</span><label class="collapse" for="c-38079551">[-]</label><label class="expand" for="c-38079551">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s nonsense. The same could be said of most hobbies. The motivation isn&#x27;t learning real life skills, it&#x27;s entertainment.</div><br/><div id="38080966" class="c"><input type="checkbox" id="c-38080966" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#38077613">root</a><span>|</span><a href="#38079551">parent</a><span>|</span><a href="#38079815">next</a><span>|</span><label class="collapse" for="c-38080966">[-]</label><label class="expand" for="c-38080966">[1 more]</label></div><br/><div class="children"><div class="content">It can be. But isn&#x27;t it a question of balance?<p>If you play some useless¹ game for the majority of your days, you can have multiple reasons for this. Maybe it keeps you occupied and thinking of the problems in your life? But after a certain degree it certainly does not &quot;entertain&quot; you anymore: You are doing it because doing anything else that you can think of feels worse. And a few years after not a lot will be left of it, unless you played with your friends or there was something in it for you beyond just pushing the time forward.<p>If I am playing my instrument for hours, I have at least improved at expressing my feelings with my instrument while having a generally good and relaxing time. And after years of doing it I can do it well enough to play on concerts without feeling afraid.<p>I know to many people who are so afraid of their own thoughts, they will obsessively &quot;entertain&quot; themselves dueinf all wake hours, and the majority of the time they are not enjoying it. This is bad. We only have one life. You don&#x27;t get a price for having some the most, but at least do something that is meaningful.<p>¹ a game that you yourself don&#x27;t even love that much</div><br/></div></div><div id="38079815" class="c"><input type="checkbox" id="c-38079815" checked=""/><div class="controls bullet"><span class="by">smitty1e</span><span>|</span><a href="#38077613">root</a><span>|</span><a href="#38079551">parent</a><span>|</span><a href="#38080966">prev</a><span>|</span><a href="#38081016">next</a><span>|</span><label class="collapse" for="c-38079815">[-]</label><label class="expand" for="c-38079815">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m +infinity on &quot;antiknowledge&quot;, but I like your &quot;entertainment&quot; point.<p>To harmonize these ideas, I argue to the kids that the &quot;entertainment&quot; choices are like spice on the food. We want enough to enjoy the flavor in question, but not so much that the usage becomes expensive or overpowers the dish.</div><br/></div></div></div></div></div></div><div id="38081016" class="c"><input type="checkbox" id="c-38081016" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#38077613">prev</a><span>|</span><a href="#38069367">next</a><span>|</span><label class="collapse" for="c-38081016">[-]</label><label class="expand" for="c-38081016">[2 more]</label></div><br/><div class="children"><div class="content">&gt; No offence meant to the Poetry project here but I don&#x27;t perceive my project as needing whatever features Poetry provides: I&#x27;m just trying to publish a simple library package<p>I don&#x27;t understand... Poetry solves this too.</div><br/><div id="38081586" class="c"><input type="checkbox" id="c-38081586" checked=""/><div class="controls bullet"><span class="by">phanimahesh</span><span>|</span><a href="#38081016">parent</a><span>|</span><a href="#38069367">next</a><span>|</span><label class="collapse" for="c-38081586">[-]</label><label class="expand" for="c-38081586">[1 more]</label></div><br/><div class="children"><div class="content">It is not obvious it does.</div><br/></div></div></div></div><div id="38069367" class="c"><input type="checkbox" id="c-38069367" checked=""/><div class="controls bullet"><span class="by">stop50</span><span>|</span><a href="#38081016">prev</a><span>|</span><a href="#38079474">next</a><span>|</span><label class="collapse" for="c-38069367">[-]</label><label class="expand" for="c-38069367">[4 more]</label></div><br/><div class="children"><div class="content">Its more funny to migrate the old setup.py process to the pyproject.toml and an rpm specfile. with an setup.py you can say something like &quot;python3 setup.py install -root=$builddir&quot;</div><br/><div id="38079978" class="c"><input type="checkbox" id="c-38079978" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#38069367">parent</a><span>|</span><a href="#38079474">next</a><span>|</span><label class="collapse" for="c-38079978">[-]</label><label class="expand" for="c-38079978">[3 more]</label></div><br/><div class="children"><div class="content">With project.toml, the new strat is to build the wheel with `python3 -m build` and then install it with `pip install --root=$DESTDIR` plus a handful of flags to tell pip not to touch the network or the local cache.<p>It&#x27;s not great, but it&#x27;s also not terrible.<p>E.g. <a href="https:&#x2F;&#x2F;github.com&#x2F;cbarrick&#x2F;efiboot&#x2F;blob&#x2F;2ca46a7c27c837adf23ad1e9bcc73a2398f45b9d&#x2F;Makefile#L162">https:&#x2F;&#x2F;github.com&#x2F;cbarrick&#x2F;efiboot&#x2F;blob&#x2F;2ca46a7c27c837adf23...</a></div><br/><div id="38080894" class="c"><input type="checkbox" id="c-38080894" checked=""/><div class="controls bullet"><span class="by">stop50</span><span>|</span><a href="#38069367">root</a><span>|</span><a href="#38079978">parent</a><span>|</span><a href="#38080659">next</a><span>|</span><label class="collapse" for="c-38080894">[-]</label><label class="expand" for="c-38080894">[1 more]</label></div><br/><div class="children"><div class="content">I know that now, but at the time i migrated i didn&#x27;t and i had the same problems as the post. I still have my problems with using python in the company but it isn&#x27;t from python or its ecosystem itself. Its from redhat splitting their python packages into the different supported python versions(package a is only available for 3.6 and package b only for 3.11)</div><br/></div></div><div id="38080659" class="c"><input type="checkbox" id="c-38080659" checked=""/><div class="controls bullet"><span class="by">rpier001</span><span>|</span><a href="#38069367">root</a><span>|</span><a href="#38079978">parent</a><span>|</span><a href="#38080894">prev</a><span>|</span><a href="#38079474">next</a><span>|</span><label class="collapse" for="c-38080659">[-]</label><label class="expand" for="c-38080659">[1 more]</label></div><br/><div class="children"><div class="content">Out of context (and with limited knowledge) comment 3 seems terrifying.</div><br/></div></div></div></div></div></div><div id="38079474" class="c"><input type="checkbox" id="c-38079474" checked=""/><div class="controls bullet"><span class="by">badrabbit</span><span>|</span><a href="#38069367">prev</a><span>|</span><a href="#38081126">next</a><span>|</span><label class="collapse" for="c-38079474">[-]</label><label class="expand" for="c-38079474">[2 more]</label></div><br/><div class="children"><div class="content">I just wanna say I really hate the new poetry+toml crap, it&#x27;s just more complicated and yet another set of crap I gotta deal with arbitrarily by arbitrary projects.<p>Why not just improve upon pip? I don&#x27;t know, just have pip use toml and give it different flags or auto detect things? Was a whole new ecosystem of tools needed?<p>I look at decisions like this and I know a Python 4.0 is on the way, just like the 2-&gt;3 jump because why not right?<p>Any language that updates it&#x27;s syntax or toolset in a way that is impossible to have backwards compatibility is an irresponsible  toy language, as awesome and powerful as it may be, the developers are still toying and tinkering with it with no regard to real world impact of their decisions.<p>Why can&#x27;t python3.12 have a flag like --std=2.7.18 for example, like gcc? If the devs don&#x27;t have enough resources, I  would live to see a donate page I can help out with.<p>We are at a point where to deploy python you can&#x27;t use python but you need shell scripts to figure out versions, venvs, pyev, pipx, poetry, etc... and reliably fail of course and every time you have to troubleshoot the problem. This is a failure in software engineering, new grads should be taught of python and similar languages and the lack of planning and organization and resulting cascading chaos as examples of how not to design the user experience of any piece of software.<p>Sorry if I exaggerated a bit anywhere, it&#x27;s difficult to pretend all the frustrations and crying out &quot;why???&quot;  when using python don&#x27;t exist. But at the same time, it is still my #1 go to language for most use cases because the language itself is just fabulous!</div><br/><div id="38080563" class="c"><input type="checkbox" id="c-38080563" checked=""/><div class="controls bullet"><span class="by">piyh</span><span>|</span><a href="#38079474">parent</a><span>|</span><a href="#38081126">next</a><span>|</span><label class="collapse" for="c-38080563">[-]</label><label class="expand" for="c-38080563">[1 more]</label></div><br/><div class="children"><div class="content">I deal with aggressive vulnerability management at work, and we have a unified pipeline.  Figuring out what our servers will be running versus what we are doing locally versus what the pipeline expects us to do for dependencies, plus vuln management is so much work.<p>God forbid you have to upgrade a base python version and reopen the dusty tomes of python dependency hell.</div><br/></div></div></div></div><div id="38081126" class="c"><input type="checkbox" id="c-38081126" checked=""/><div class="controls bullet"><span class="by">anacrolix</span><span>|</span><a href="#38079474">prev</a><span>|</span><a href="#38080198">next</a><span>|</span><label class="collapse" for="c-38081126">[-]</label><label class="expand" for="c-38081126">[1 more]</label></div><br/><div class="children"><div class="content">from* ffs</div><br/></div></div><div id="38079549" class="c"><input type="checkbox" id="c-38079549" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#38080198">prev</a><span>|</span><label class="collapse" for="c-38079549">[-]</label><label class="expand" for="c-38079549">[4 more]</label></div><br/><div class="children"><div class="content">Ouch. I stopped reading 15% of the way through because I noticed that I was only 15% of the way through and I felt like it should be the end.<p>It seems like with a tenth of the effort of this blog rant the author could have written a flowchart or best practices.<p>Luckily for 99% of Python users, we only need to install libraries and not package them...</div><br/><div id="38079940" class="c"><input type="checkbox" id="c-38079940" checked=""/><div class="controls bullet"><span class="by">acemarke</span><span>|</span><a href="#38079549">parent</a><span>|</span><a href="#38081755">next</a><span>|</span><label class="collapse" for="c-38079940">[-]</label><label class="expand" for="c-38079940">[2 more]</label></div><br/><div class="children"><div class="content">I wrote a very similar post a couple months ago about trying to modernize the Redux JS packages to support ESM and CJS module formats:<p><a href="https:&#x2F;&#x2F;blog.isquaredsoftware.com&#x2F;2023&#x2F;08&#x2F;esm-modernization-lessons&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.isquaredsoftware.com&#x2F;2023&#x2F;08&#x2F;esm-modernization-...</a><p>I _liked_ Gregory&#x27;s post. I _felt_ all of the frustration, and the confusion over lack of good docs, and the plethora of competing tools and formats.  It resonated deeply for me.  I haven&#x27;t touched Python in years, but I could see exactly how all these pain points were happening thanks to the writing style and the explanations.  The goal is to share &quot;here&#x27;s what I tried&quot;, &quot;here&#x27;s what seems wrong or broken&quot;, &quot;here&#x27;s the pitfalls I ran into&quot;, and &quot;here&#x27;s the _frustration_ I&#x27;m feeling at how messed up this all is&quot;.  And it succeeded.<p>(And fwiw, I&#x27;ve had a lot of other folks in the JS ecosystem express similar thoughts as thanks for my post.  It&#x27;s a limited target audience, most people won&#x27;t care, but the folks who _do_ have to deal with these kinds of problems understand and appreciate the details and the effort involved.)</div><br/><div id="38080430" class="c"><input type="checkbox" id="c-38080430" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#38079549">root</a><span>|</span><a href="#38079940">parent</a><span>|</span><a href="#38081755">next</a><span>|</span><label class="collapse" for="c-38080430">[-]</label><label class="expand" for="c-38080430">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for this post! I&#x27;ve recently read it and then decided to abandon any attempt at such a migration.</div><br/></div></div></div></div><div id="38081755" class="c"><input type="checkbox" id="c-38081755" checked=""/><div class="controls bullet"><span class="by">bjornasm</span><span>|</span><a href="#38079549">parent</a><span>|</span><a href="#38079940">prev</a><span>|</span><label class="collapse" for="c-38081755">[-]</label><label class="expand" for="c-38081755">[1 more]</label></div><br/><div class="children"><div class="content">How can he write that when seemingly there is no best practices from Python?</div><br/></div></div></div></div></div></div></div></div></div></body></html>