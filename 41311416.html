<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724576472774" as="style"/><link rel="stylesheet" href="styles.css?v=1724576472774"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kyju.org/blog/rust-safe-garbage-collection/">Techniques for safe garbage collection in Rust</a> <span class="domain">(<a href="https://kyju.org">kyju.org</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>21 comments</span></div><br/><div><div id="41341504" class="c"><input type="checkbox" id="c-41341504" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#41344037">next</a><span>|</span><label class="collapse" for="c-41341504">[-]</label><label class="expand" for="c-41341504">[4 more]</label></div><br/><div class="children"><div class="content">I strongly encourage people interested in this topic to look at the piccolo VM that has been referenced in the post.  It is a fascinating exploration of how a stackless VM can work in Rust.  It uses &quot;sequences&quot; (think a bit like a future or promise) to express control flow that yields or calls into other VM methods.  Particularly for a little while now it has the concept of an async_sequence [1] which allows one to abuse (?) async&#x2F;await where it will create a shadow stack to make this code more readable.<p>I find all of this quite exciting because there are not that many stackless VMs out there that are readable and not a massive usability hazard if you do something wrong.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;kyren&#x2F;piccolo&#x2F;blob&#x2F;master&#x2F;tests&#x2F;async_sequence.rs">https:&#x2F;&#x2F;github.com&#x2F;kyren&#x2F;piccolo&#x2F;blob&#x2F;master&#x2F;tests&#x2F;async_seq...</a></div><br/><div id="41342364" class="c"><input type="checkbox" id="c-41342364" checked=""/><div class="controls bullet"><span class="by">twiss</span><span>|</span><a href="#41341504">parent</a><span>|</span><a href="#41341539">next</a><span>|</span><label class="collapse" for="c-41342364">[-]</label><label class="expand" for="c-41342364">[1 more]</label></div><br/><div class="children"><div class="content">Companion blog post: <a href="https:&#x2F;&#x2F;kyju.org&#x2F;blog&#x2F;piccolo-a-stackless-lua-interpreter&#x2F;" rel="nofollow">https:&#x2F;&#x2F;kyju.org&#x2F;blog&#x2F;piccolo-a-stackless-lua-interpreter&#x2F;</a></div><br/></div></div><div id="41341539" class="c"><input type="checkbox" id="c-41341539" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#41341504">parent</a><span>|</span><a href="#41342364">prev</a><span>|</span><a href="#41344037">next</a><span>|</span><label class="collapse" for="c-41341539">[-]</label><label class="expand" for="c-41341539">[2 more]</label></div><br/><div class="children"><div class="content">Why wouldn&#x27;t I forget about stackless VMs, &quot;sequences&quot; and yielding calls to VM methods and just make a normal native program with a lock free queue?</div><br/><div id="41341569" class="c"><input type="checkbox" id="c-41341569" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#41341504">root</a><span>|</span><a href="#41341539">parent</a><span>|</span><a href="#41344037">next</a><span>|</span><label class="collapse" for="c-41341569">[-]</label><label class="expand" for="c-41341569">[1 more]</label></div><br/><div class="children"><div class="content">Quite frankly I don&#x27;t understand the question.  The assume here is that you have the goal is to have&#x2F;write a dynamic language you will have to write a VM.  If you write a VM a stackless model is the preferred one for a variety of reasons.  However not having a stack causes pains for native calls that can detour via native objects back into the VM.  That you often have when embedding these languages (which is the goal).<p>So if you have that sort of setup, you will need to find solutions.<p>What piccolo does is quite pretty and definitely beats some other options out there.  A lot of stackless VMs just crash horribly if you do something naughty with re-entrant calls.</div><br/></div></div></div></div></div></div><div id="41341347" class="c"><input type="checkbox" id="c-41341347" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41344037">prev</a><span>|</span><a href="#41343937">next</a><span>|</span><label class="collapse" for="c-41341347">[-]</label><label class="expand" for="c-41341347">[11 more]</label></div><br/><div class="children"><div class="content">If you fit a gc on top of rust, the result is going to be less efficient than when using a modern gc&#x27;d language to begin with. So I&#x27;m curious what drove them to this.</div><br/><div id="41341490" class="c"><input type="checkbox" id="c-41341490" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41341347">parent</a><span>|</span><a href="#41341449">next</a><span>|</span><label class="collapse" for="c-41341490">[-]</label><label class="expand" for="c-41341490">[9 more]</label></div><br/><div class="children"><div class="content">This is a garbage collector written in Rust, not &quot;on top of&quot; Rust.<p>This isn&#x27;t equivalent to adding garbage collection to the entire language. It&#x27;s a garbage collected pointer type that can be employed for specific use cases.<p>The article and the repo explain why they developed it: Implementing VMs for garbage collected languages in Rust.</div><br/><div id="41341789" class="c"><input type="checkbox" id="c-41341789" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41341347">root</a><span>|</span><a href="#41341490">parent</a><span>|</span><a href="#41341449">next</a><span>|</span><label class="collapse" for="c-41341789">[-]</label><label class="expand" for="c-41341789">[8 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a garbage collected pointer type that can be employed for specific use cases.<p>You mean use cases where performance does not matter?</div><br/><div id="41342298" class="c"><input type="checkbox" id="c-41342298" checked=""/><div class="controls bullet"><span class="by">twiss</span><span>|</span><a href="#41341347">root</a><span>|</span><a href="#41341789">parent</a><span>|</span><a href="#41342975">next</a><span>|</span><label class="collapse" for="c-41342298">[-]</label><label class="expand" for="c-41342298">[1 more]</label></div><br/><div class="children"><div class="content">Do you think Lua (for example, or any other GC&#x27;d language) has valid use cases? If so, it needs an implementation. This blog post shows (part of) one way to do that.</div><br/></div></div><div id="41342975" class="c"><input type="checkbox" id="c-41342975" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41341347">root</a><span>|</span><a href="#41341789">parent</a><span>|</span><a href="#41342298">prev</a><span>|</span><a href="#41342393">next</a><span>|</span><label class="collapse" for="c-41342975">[-]</label><label class="expand" for="c-41342975">[2 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, what language do you think the Java, JavaScript, and Python VMs and garbage collectors are written in? If you can understand why the VM is typically written in a systems programming language that doesn&#x27;t itself have a VM or garbage collector, then you can start to think about why this is useful regardless of whether performance matters or not (&amp; Java and C# are generally considered fairly high performance languages and VM implementations with efficient garbage collectors - the downsides may not matter to your problem domain).</div><br/><div id="41343387" class="c"><input type="checkbox" id="c-41343387" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41341347">root</a><span>|</span><a href="#41342975">parent</a><span>|</span><a href="#41342393">next</a><span>|</span><label class="collapse" for="c-41343387">[-]</label><label class="expand" for="c-41343387">[1 more]</label></div><br/><div class="children"><div class="content">To expand on GPs point, I believe it implies that implementing a GC type for the Rust <i>itself</i> within its constraints (and even LLVM is not perfect, if we skip to LLVM-IR) is bound to be worse than in a language with bespoke precise+tracing+moving garbage collector which always requires deep compiler integration for &quot;VM&quot; to have exact information of where gcrefs are located at every safepoint (including registers!), be able to collect objects as soon as they are no longer referenced and not when they go out of scope later, determine whether write (or, worse, read) barriers are required or can be omitted and have the ability to suspend the execution to update the object references upon moving them to a different generation&#x2F;heap&#x2F;etc.<p>All GC implementations in Rust that I&#x27;ve seen so far relied on much more heavy handed techniques like having GC&lt;T&gt; to be a double indirection, pushing references to threadlocal queue, have GC pointers to be fat to pass around metadata inline, etc. They have been closer to modified RC with corresponding cost.</div><br/></div></div></div></div><div id="41342393" class="c"><input type="checkbox" id="c-41342393" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#41341347">root</a><span>|</span><a href="#41341789">parent</a><span>|</span><a href="#41342975">prev</a><span>|</span><a href="#41341449">next</a><span>|</span><label class="collapse" for="c-41342393">[-]</label><label class="expand" for="c-41342393">[4 more]</label></div><br/><div class="children"><div class="content">Use-cases like &quot;implementing a garbage-collected language.&quot;</div><br/><div id="41344255" class="c"><input type="checkbox" id="c-41344255" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41341347">root</a><span>|</span><a href="#41342393">parent</a><span>|</span><a href="#41341449">next</a><span>|</span><label class="collapse" for="c-41344255">[-]</label><label class="expand" for="c-41344255">[3 more]</label></div><br/><div class="children"><div class="content">High performance garbage collectors are typically written in assembly because of the intricacies of the cache hierarchy.</div><br/><div id="41344420" class="c"><input type="checkbox" id="c-41344420" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#41341347">root</a><span>|</span><a href="#41344255">parent</a><span>|</span><a href="#41345357">next</a><span>|</span><label class="collapse" for="c-41344420">[-]</label><label class="expand" for="c-41344420">[1 more]</label></div><br/><div class="children"><div class="content">Which one(s) are you thinking of? The JVM&#x27;s appear to be in C++, GHC&#x27;s and SBCL&#x27;s are in C, Go&#x27;s is in Go, and I&#x27;m not familiar with other high-performance garbage-collected platforms.</div><br/></div></div><div id="41345357" class="c"><input type="checkbox" id="c-41345357" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#41341347">root</a><span>|</span><a href="#41344255">parent</a><span>|</span><a href="#41344420">prev</a><span>|</span><a href="#41341449">next</a><span>|</span><label class="collapse" for="c-41345357">[-]</label><label class="expand" for="c-41345357">[1 more]</label></div><br/><div class="children"><div class="content">Citation very much needed, please; assembly wouldn&#x27;t give you more control over caches than any language with a prefetch intrinsic.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41341449" class="c"><input type="checkbox" id="c-41341449" checked=""/><div class="controls bullet"><span class="by">the_mitsuhiko</span><span>|</span><a href="#41341347">parent</a><span>|</span><a href="#41341490">prev</a><span>|</span><a href="#41343937">next</a><span>|</span><label class="collapse" for="c-41341449">[-]</label><label class="expand" for="c-41341449">[1 more]</label></div><br/><div class="children"><div class="content">The answer to your question is in the linked post.</div><br/></div></div></div></div><div id="41343937" class="c"><input type="checkbox" id="c-41343937" checked=""/><div class="controls bullet"><span class="by">keithalewis</span><span>|</span><a href="#41341347">prev</a><span>|</span><a href="#41344204">next</a><span>|</span><label class="collapse" for="c-41343937">[-]</label><label class="expand" for="c-41343937">[3 more]</label></div><br/><div class="children"><div class="content">Techniques for safe garbage collection in C++: unique_ptr and right curly brace }. Linear types with delayed gratification.</div><br/><div id="41345494" class="c"><input type="checkbox" id="c-41345494" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41343937">parent</a><span>|</span><a href="#41344271">next</a><span>|</span><label class="collapse" for="c-41345494">[-]</label><label class="expand" for="c-41345494">[1 more]</label></div><br/><div class="children"><div class="content">This is neither safe (you can still get raw pointers&#x2F;references to its contents) nor garbage collection in the usual sense (you can&#x27;t even share it!)</div><br/></div></div><div id="41344271" class="c"><input type="checkbox" id="c-41344271" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#41343937">parent</a><span>|</span><a href="#41345494">prev</a><span>|</span><a href="#41344204">next</a><span>|</span><label class="collapse" for="c-41344271">[-]</label><label class="expand" for="c-41344271">[1 more]</label></div><br/><div class="children"><div class="content">This is assuming people don’t abuse it and pass around raw references&#x2F;pointers to it (they will). The safest construct, though with definite performance impact, is std::shared_ptr but people think they are smarter than they are and don’t use it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>