<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683277251026" as="style"/><link rel="stylesheet" href="styles.css?v=1683277251026"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tratt.net/laurie/blog/2020/which_parsing_approach.html">Which Parsing Approach?</a> <span class="domain">(<a href="https://tratt.net">tratt.net</a>)</span></div><div class="subtext"><span>tomas789</span> | <span>9 comments</span></div><br/><div><div id="35826546" class="c"><input type="checkbox" id="c-35826546" checked=""/><div class="controls bullet"><span class="by">CipherThrowaway</span><span>|</span><a href="#35800602">next</a><span>|</span><label class="collapse" for="c-35826546">[-]</label><label class="expand" for="c-35826546">[3 more]</label></div><br/><div class="children"><div class="content">Generated lexers are still worth it but handwritten RD won on the parsing front. No other historical debate gets this Weekend at Bernie&#x27;s treatment the way parser generators do. Is it from dated undergrad + research material? There must be a reason all the references and approaches in this article are decades old and parser combinators get a single dismissive footnote. Pretty sure that Guy Steele quote even predates PEGs.<p>Bison and YACC are a mess. Sure, go and complicate your build by introducing code gen steps and ancient spaghetti DSLs with terrible tooling and an extra learning curve. Anything to avoid writing a readable parser in the same language as the rest of your compiler. The amount of ink spilled over parsing and parser generators is phenomenal when you consider how trivial parsing is compared to the other compilation phases. Look at source code for large compilers and you&#x27;ll find the handwritten parser is some of the easiest code to understand in the project. Lack of left recursion is a trivial limitation in practice.</div><br/><div id="35826614" class="c"><input type="checkbox" id="c-35826614" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#35826546">parent</a><span>|</span><a href="#35800602">next</a><span>|</span><label class="collapse" for="c-35826614">[-]</label><label class="expand" for="c-35826614">[2 more]</label></div><br/><div class="children"><div class="content">The front end of compilers gets a lot of attention because the problem looks complex, but is easy in practice, which is why there are a large number of materials trying to teach the topic.<p>On that note, what resources would you suggest to become familiar with the backends of a compiler? The CS classes I had mostly had a frontend focus with the backend only being covered at a high level and without delving too deep into the implementation details.</div><br/><div id="35826686" class="c"><input type="checkbox" id="c-35826686" checked=""/><div class="controls bullet"><span class="by">CipherThrowaway</span><span>|</span><a href="#35826546">root</a><span>|</span><a href="#35826614">parent</a><span>|</span><a href="#35800602">next</a><span>|</span><label class="collapse" for="c-35826686">[-]</label><label class="expand" for="c-35826686">[1 more]</label></div><br/><div class="children"><div class="content">I have a similar struggle and find you are largely limited to learning piecemeal. I have found the best learning resources are the technical docs, specifications, proposals and source code of major language projects and VMs. Research languages and associated research papers. Conference talks by compiler authors (Rust has some good ones).</div><br/></div></div></div></div></div></div><div id="35800602" class="c"><input type="checkbox" id="c-35800602" checked=""/><div class="controls bullet"><span class="by">fjfaase</span><span>|</span><a href="#35826546">prev</a><span>|</span><a href="#35826474">next</a><span>|</span><label class="collapse" for="c-35800602">[-]</label><label class="expand" for="c-35800602">[2 more]</label></div><br/><div class="children"><div class="content">An interesting article about parsing techniques that were developed half a century ago when there were still severe memory limitations. It would be nice if it at least would mention that these techniques were developed because back-tracking was not considered as a valid option for parsing, because it was simply not feasible to store a whole file in memory. Nowadays the whole source code of the linux kernel easily fits in RAM.<p>For many applications, using a back-tracking parser with some memorization&#x2F;caching, is feasible. IParse Studio [1] is an example of an interpretting parser that parses a grammar and an input at each change on the input and demonstrates that it works for rather complex grammars [2] on realistic input [3].<p>[1] <a href="https:&#x2F;&#x2F;fransfaase.github.io&#x2F;MCH2022ParserWorkshop&#x2F;IParseStudio.html" rel="nofollow">https:&#x2F;&#x2F;fransfaase.github.io&#x2F;MCH2022ParserWorkshop&#x2F;IParseStu...</a>
[2] <a href="https:&#x2F;&#x2F;fransfaase.github.io&#x2F;MCH2022ParserWorkshop&#x2F;C_grammar.txt" rel="nofollow">https:&#x2F;&#x2F;fransfaase.github.io&#x2F;MCH2022ParserWorkshop&#x2F;C_grammar...</a>
[3] <a href="https:&#x2F;&#x2F;fransfaase.github.io&#x2F;MCH2022ParserWorkshop&#x2F;scan_pc.txt" rel="nofollow">https:&#x2F;&#x2F;fransfaase.github.io&#x2F;MCH2022ParserWorkshop&#x2F;scan_pc.t...</a></div><br/><div id="35826310" class="c"><input type="checkbox" id="c-35826310" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#35800602">parent</a><span>|</span><a href="#35826474">next</a><span>|</span><label class="collapse" for="c-35826310">[-]</label><label class="expand" for="c-35826310">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I suspect that parsing performance worries date back to the period when parsing techniques were under heavy development. LR parsing was invented in 1965, a time when computers were painfully slow [19] and resource poor. &quot;<p>&quot;When combined with a couple of other techniques to squeeze the statetable’s memory footprint [22], even the most puny modern machine can run an arbitrary LR parser at impressive speeds.&quot;</div><br/></div></div></div></div><div id="35826474" class="c"><input type="checkbox" id="c-35826474" checked=""/><div class="controls bullet"><span class="by">rsecora</span><span>|</span><a href="#35800602">prev</a><span>|</span><a href="#35826552">next</a><span>|</span><label class="collapse" for="c-35826474">[-]</label><label class="expand" for="c-35826474">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;&gt; Over time, I’ve come to view LR parsing as equivalent to static typing: occasionally annoyingly restrictive, but providing enough static guarantees to be worth the annoyance for important software.<p>That&#x27;s also one of the points of using parser tools instead of  hand coded descendant parsers. The rule validation is also done by the tool. A lot of pitfalls can be avoided.</div><br/></div></div><div id="35826552" class="c"><input type="checkbox" id="c-35826552" checked=""/><div class="controls bullet"><span class="by">_0ffh</span><span>|</span><a href="#35826474">prev</a><span>|</span><a href="#35826008">next</a><span>|</span><label class="collapse" for="c-35826552">[-]</label><label class="expand" for="c-35826552">[1 more]</label></div><br/><div class="children"><div class="content">Personally, I swear by recursive descent parsing mixed with TDOP for expressions. Since I&#x27;ve tried that combination for the first time I haven&#x27;t looked back.</div><br/></div></div><div id="35826008" class="c"><input type="checkbox" id="c-35826008" checked=""/><div class="controls bullet"><span class="by">endorphine</span><span>|</span><a href="#35826552">prev</a><span>|</span><label class="collapse" for="c-35826008">[-]</label><label class="expand" for="c-35826008">[1 more]</label></div><br/><div class="children"><div class="content">(2020)</div><br/></div></div></div></div></div></div></div></body></html>