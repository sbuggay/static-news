<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704445253794" as="style"/><link rel="stylesheet" href="styles.css?v=1704445253794"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://people.inf.ethz.ch/wirth/ProjectOberon/PO.System.pdf">Project Oberon: Design of an operating system, a compiler, and a computer [pdf]</a>Â <span class="domain">(<a href="https://people.inf.ethz.ch">people.inf.ethz.ch</a>)</span></div><div class="subtext"><span>JoachimS</span> | <span>39 comments</span></div><br/><div><div id="38870566" class="c"><input type="checkbox" id="c-38870566" checked=""/><div class="controls bullet"><span class="by">guidoism</span><span>|</span><a href="#38870382">next</a><span>|</span><label class="collapse" for="c-38870566">[-]</label><label class="expand" for="c-38870566">[6 more]</label></div><br/><div class="children"><div class="content">I re-typeset the text in TeX and have a nicer looking PDF for those that care: <a href="https:&#x2F;&#x2F;github.com&#x2F;guidoism&#x2F;tex-oberon">https:&#x2F;&#x2F;github.com&#x2F;guidoism&#x2F;tex-oberon</a></div><br/><div id="38876806" class="c"><input type="checkbox" id="c-38876806" checked=""/><div class="controls bullet"><span class="by">berkeleynerd</span><span>|</span><a href="#38870566">parent</a><span>|</span><a href="#38871785">next</a><span>|</span><label class="collapse" for="c-38876806">[-]</label><label class="expand" for="c-38876806">[1 more]</label></div><br/><div class="children"><div class="content">Is it possible to use this version of the book to follow along and build everything without having to source the original FPGA board Wirth was using?</div><br/></div></div><div id="38871785" class="c"><input type="checkbox" id="c-38871785" checked=""/><div class="controls bullet"><span class="by">zvmaz</span><span>|</span><a href="#38870566">parent</a><span>|</span><a href="#38876806">prev</a><span>|</span><a href="#38872047">next</a><span>|</span><label class="collapse" for="c-38871785">[-]</label><label class="expand" for="c-38871785">[1 more]</label></div><br/><div class="children"><div class="content">I really liked reading the README. It shows that you are passionate about Project Oberon and the book. This in turn motivates me to read it. Thank you for your work.</div><br/></div></div><div id="38872047" class="c"><input type="checkbox" id="c-38872047" checked=""/><div class="controls bullet"><span class="by">sydbarrett74</span><span>|</span><a href="#38870566">parent</a><span>|</span><a href="#38871785">prev</a><span>|</span><a href="#38872156">next</a><span>|</span><label class="collapse" for="c-38872047">[-]</label><label class="expand" for="c-38872047">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for your hard work and dedication in keeping this alive.</div><br/></div></div><div id="38872156" class="c"><input type="checkbox" id="c-38872156" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#38870566">parent</a><span>|</span><a href="#38872047">prev</a><span>|</span><a href="#38876259">next</a><span>|</span><label class="collapse" for="c-38872156">[-]</label><label class="expand" for="c-38872156">[1 more]</label></div><br/><div class="children"><div class="content">Awesome! I&#x27;m guessing there&#x27;s a not-too-hard way to change change the paper format? I&#x27;m thinking of going to A5 so I can bind myself a nice book.</div><br/></div></div><div id="38876259" class="c"><input type="checkbox" id="c-38876259" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38870566">parent</a><span>|</span><a href="#38872156">prev</a><span>|</span><a href="#38870382">next</a><span>|</span><label class="collapse" for="c-38876259">[-]</label><label class="expand" for="c-38876259">[1 more]</label></div><br/><div class="children"><div class="content">thank you so much<p>this must have been a huge amount of work</div><br/></div></div></div></div><div id="38870382" class="c"><input type="checkbox" id="c-38870382" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38870566">prev</a><span>|</span><a href="#38870090">next</a><span>|</span><label class="collapse" for="c-38870382">[-]</label><label class="expand" for="c-38870382">[2 more]</label></div><br/><div class="children"><div class="content">After this follow up on the Oberon System 3, with its Gadgets component model, and a mix of JIT&#x2F;AOT compilers,<p>&quot;The Oberon companion - a guide to using and programming Oberon System 3&quot;<p><a href="https:&#x2F;&#x2F;www.semanticscholar.org&#x2F;paper&#x2F;The-Oberon-companion-a-guide-to-using-and-Oberon-3-Fischer-Marais&#x2F;00296fcdca9e9b317fe9cdc9a198662e76ccd52e" rel="nofollow">https:&#x2F;&#x2F;www.semanticscholar.org&#x2F;paper&#x2F;The-Oberon-companion-a...</a><p>You can access the source code from Rochus fork,<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;OberonSystem3">https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;OberonSystem3</a><p>Or the Active Oberon evolution, although not directly done by Niklaus Wirth,<p><a href="https:&#x2F;&#x2F;gitlab.inf.ethz.ch&#x2F;felixf&#x2F;oberon" rel="nofollow">https:&#x2F;&#x2F;gitlab.inf.ethz.ch&#x2F;felixf&#x2F;oberon</a><p>Screenshots and OS Manual,<p><a href="https:&#x2F;&#x2F;gitlab.inf.ethz.ch&#x2F;felixf&#x2F;oberon&#x2F;-&#x2F;blob&#x2F;main&#x2F;ocp&#x2F;Documentation&#x2F;A2Documentation.pdf?ref_type=heads" rel="nofollow">https:&#x2F;&#x2F;gitlab.inf.ethz.ch&#x2F;felixf&#x2F;oberon&#x2F;-&#x2F;blob&#x2F;main&#x2F;ocp&#x2F;Doc...</a><p>Or Component Pascal and Blackbox IDE, created by a startup out of ETHZ<p><a href="https:&#x2F;&#x2F;blackboxframework.org&#x2F;index.php" rel="nofollow">https:&#x2F;&#x2F;blackboxframework.org&#x2F;index.php</a></div><br/><div id="38871492" class="c"><input type="checkbox" id="c-38871492" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#38870382">parent</a><span>|</span><a href="#38870090">next</a><span>|</span><label class="collapse" for="c-38871492">[-]</label><label class="expand" for="c-38871492">[1 more]</label></div><br/><div class="children"><div class="content">The Active Oberon evolution started with the Active Object System (AOS) and the Bluebottle window manager; the source code of the last &quot;Current&quot; release can be accessed e.g. here: <a href="https:&#x2F;&#x2F;github.com&#x2F;OberonSystem3&#x2F;AOS_Bluebottle_Sources">https:&#x2F;&#x2F;github.com&#x2F;OberonSystem3&#x2F;AOS_Bluebottle_Sources</a>. If you want to study the source code, you can use this tool: <a href="https:&#x2F;&#x2F;github.com&#x2F;Rochus-Keller&#x2F;ActiveOberon">https:&#x2F;&#x2F;github.com&#x2F;Rochus-Keller&#x2F;ActiveOberon</a>.</div><br/></div></div></div></div><div id="38870090" class="c"><input type="checkbox" id="c-38870090" checked=""/><div class="controls bullet"><span class="by">i_don_t_know</span><span>|</span><a href="#38870382">prev</a><span>|</span><a href="#38870255">next</a><span>|</span><label class="collapse" for="c-38870090">[-]</label><label class="expand" for="c-38870090">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only the first half of the book. You can find all parts and software at: <a href="https:&#x2F;&#x2F;people.inf.ethz.ch&#x2F;wirth&#x2F;ProjectOberon&#x2F;" rel="nofollow">https:&#x2F;&#x2F;people.inf.ethz.ch&#x2F;wirth&#x2F;ProjectOberon&#x2F;</a></div><br/></div></div><div id="38870255" class="c"><input type="checkbox" id="c-38870255" checked=""/><div class="controls bullet"><span class="by">zvmaz</span><span>|</span><a href="#38870090">prev</a><span>|</span><a href="#38872859">next</a><span>|</span><label class="collapse" for="c-38870255">[-]</label><label class="expand" for="c-38870255">[8 more]</label></div><br/><div class="children"><div class="content">&gt; The largest chapter of the 1992 edition of this book dealt with the
compiler translating Oberon programs into code for the NS32032 processor. This processor is now neither available nor is its architecture recommendable. Instead of writing a new compiler for some other commercially available architecture, I decided to design my own in order to extend the desire for simplicity and regularity to the hardware. The ultimate benefit of this decision is not only that the software, but also the hardware of the Oberon System is described completely and rigorously. The processor is called RISC. The hardware modules are decribed exclusively in the language Verilog.<p>I wonder how it compares to Nand To Tetris. Other than that, it seems really interesting. Has anyone read it?</div><br/><div id="38872231" class="c"><input type="checkbox" id="c-38872231" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#38870255">parent</a><span>|</span><a href="#38871061">next</a><span>|</span><label class="collapse" for="c-38872231">[-]</label><label class="expand" for="c-38872231">[1 more]</label></div><br/><div class="children"><div class="content">As another user said, it&#x27;s not oriented towards a beginner.  You would want some, maybe most, of the background in NAND 2 Tetris first.  Chapter 16 about that mentioned processor for example, and it just throws you in the deep end with the Verilog code.  Here&#x27;s the CPU interface with the system bus, the registers, and how the multiplier unit works.<p>The good part is the commentary about the design decisions and trade-offs.  That is invaluable, because it is the wisdom of Niklaus Wirth, towards the end of his career, drawing on a lifetime of experience. He was one of those rare polymaths, with a broad and deep understanding, of both the circuitry, and the more abstract parts of CS.  He always generalized, tried to understand the principle, and places things in their historical context and explains how they developed.  Because it&#x27;s Wirth, the history lesson is often based on personal experience.  It produces a good synthesis, in my opinion.  For example:<p>&gt; The second [interface] (MouseX) is included here for historical reasons. It was used by the computer Lilith in 1979, and used the same Mouse as its ancestor Alto (at PARC, 1975). It is distinguished by a very simple hardware without its own microprocessor, which is currently contained in most mice. This goes at a cost of a 9-wire cable.  But today, microprocessors are cheaper than cables. We include this interface here, because it allows for a simple explanation of the principle of pointing devices.</div><br/></div></div><div id="38871061" class="c"><input type="checkbox" id="c-38871061" checked=""/><div class="controls bullet"><span class="by">hnthrowaway0328</span><span>|</span><a href="#38870255">parent</a><span>|</span><a href="#38872231">prev</a><span>|</span><a href="#38876322">next</a><span>|</span><label class="collapse" for="c-38871061">[-]</label><label class="expand" for="c-38871061">[1 more]</label></div><br/><div class="children"><div class="content">Nand2Tetris is the perfect introduction project of this field that spans Hardware, OS and compiler design. That said, I completed the project and found it lacking depths and in-depth investigation of all topics. But this is what makes it the perfect introduction project.<p>The University of Tokyo has a similar project that I believe can serve as a stepping stone. Check out the CPU experiment: <a href="https:&#x2F;&#x2F;ytsmiling.tech&#x2F;2017&#x2F;04&#x2F;02&#x2F;cpuex.html" rel="nofollow">https:&#x2F;&#x2F;ytsmiling.tech&#x2F;2017&#x2F;04&#x2F;02&#x2F;cpuex.html</a><p>If you don&#x27;t like it (probably due to lack of documentation), at this stage you can also design your own projects. Basically a CPU sub-project that uses Verilog or any HDL, which leads to an OS and compiler project.</div><br/></div></div><div id="38876322" class="c"><input type="checkbox" id="c-38876322" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38870255">parent</a><span>|</span><a href="#38871061">prev</a><span>|</span><a href="#38870598">next</a><span>|</span><label class="collapse" for="c-38876322">[-]</label><label class="expand" for="c-38876322">[1 more]</label></div><br/><div class="children"><div class="content">the wirth-the-risc processor is immensely simpler to describe and program than the tecs&#x2F;nand2tetris processor, which borders on unusable.  i&#x27;ve gone through the process of &#x27;designing&#x27; the nand2tetris processor on nandgame, and i&#x27;m pretty sure the nand2tetris processor is simpler to wire up from gates.  but the wirth-the-risc processor is a lot easier to get running on an fpga or, i bet, to simulate with verilator, because it uses a real hdl instead of something that someone who&#x27;s never designed hardware thinks an hdl might look like.  probably the nand2tetris processor would require less code in verilog if you coded it up, quite similar to chuck thacker&#x27;s &#x27;a tiny computer for teaching&#x27; <a href="https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;teaching&#x2F;1112&#x2F;ECAD+Arch&#x2F;files&#x2F;Thacker-A_Tiny_Computer-3.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;teaching&#x2F;1112&#x2F;ECAD+Arch&#x2F;files&#x2F;Thack...</a> which is, like the nand2tetris processor, based on the dirty genitals nova architecture<p>nand2tetris will get you from nand gates to tetris and to bytecode interpreters.  but oberon will get you from synthesizable verilog (which can be easily converted into nand gates but almost never is) to a fully usable gui operating system that can recompile its own source code.  sadly it cannot resynthesize its own fpga bitstream because you cannot run vivado on it (though i see 71bae0447c737f454371dcf3b84fc62c says below it can at least simulate its own hardware)<p>a thing they both have in common is the lack of a usable name for the processor architecture</div><br/></div></div><div id="38870598" class="c"><input type="checkbox" id="c-38870598" checked=""/><div class="controls bullet"><span class="by">i_don_t_know</span><span>|</span><a href="#38870255">parent</a><span>|</span><a href="#38876322">prev</a><span>|</span><a href="#38870543">next</a><span>|</span><label class="collapse" for="c-38870598">[-]</label><label class="expand" for="c-38870598">[1 more]</label></div><br/><div class="children"><div class="content">Project Oberon describes the final system as it is. Itâs not a tutorial that takes you step by step from the basics to a complete system.</div><br/></div></div><div id="38870543" class="c"><input type="checkbox" id="c-38870543" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38870255">parent</a><span>|</span><a href="#38870598">prev</a><span>|</span><a href="#38872859">next</a><span>|</span><label class="collapse" for="c-38870543">[-]</label><label class="expand" for="c-38870543">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s much less pedagogical than Nand to Tetris; if you need the background, read that first, then read this.<p>(he eventually ported the hardware description to his own HDL, Lola)</div><br/><div id="38876327" class="c"><input type="checkbox" id="c-38876327" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38870255">root</a><span>|</span><a href="#38870543">parent</a><span>|</span><a href="#38872859">next</a><span>|</span><label class="collapse" for="c-38876327">[-]</label><label class="expand" for="c-38876327">[2 more]</label></div><br/><div class="children"><div class="content">oh i had no idea, i have to see this.  does lola support any existing fpgas?</div><br/><div id="38876885" class="c"><input type="checkbox" id="c-38876885" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38870255">root</a><span>|</span><a href="#38876327">parent</a><span>|</span><a href="#38872859">next</a><span>|</span><label class="collapse" for="c-38876885">[-]</label><label class="expand" for="c-38876885">[1 more]</label></div><br/><div class="children"><div class="content">see <a href="https:&#x2F;&#x2F;people.inf.ethz.ch&#x2F;wirth&#x2F;Lola&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;people.inf.ethz.ch&#x2F;wirth&#x2F;Lola&#x2F;index.html</a><p>IIUC, in its 1990s incarnation Wirth had been able to get bitstream formats, but this century everything was closed off, so now it transpiles to Verilog.</div><br/></div></div></div></div></div></div></div></div><div id="38872859" class="c"><input type="checkbox" id="c-38872859" checked=""/><div class="controls bullet"><span class="by">fmeyer</span><span>|</span><a href="#38870255">prev</a><span>|</span><a href="#38876813">next</a><span>|</span><label class="collapse" for="c-38872859">[-]</label><label class="expand" for="c-38872859">[9 more]</label></div><br/><div class="children"><div class="content">The idea of an education computer is bugging my mind in the last 5 years.<p>If you consider modern hardware and OS is practically impossible to have a simple enough machine that you could teach the young generation. Fantasy consoles like pico-8 are good options for programming, but not for understanding the hardware underneath. That way you still have school who use old architectures for teaching.</div><br/><div id="38874048" class="c"><input type="checkbox" id="c-38874048" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#38872859">parent</a><span>|</span><a href="#38875252">next</a><span>|</span><label class="collapse" for="c-38874048">[-]</label><label class="expand" for="c-38874048">[6 more]</label></div><br/><div class="children"><div class="content">A minimal RISC-V implementation is quite simple. There is a RISC-V implementation of xv6 - though thatâll require slightly more than the absolute minimum RISC-V implementation, specifically youâll need CSRs, M, S and U mode and paging.<p>If you donât care about paged memory you could do with just M and U mode. I have a small rtos that targets some of the WCH microcontrollers with that configuration. It does use the PMP but even that isnât really necessary.</div><br/><div id="38876537" class="c"><input type="checkbox" id="c-38876537" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38872859">root</a><span>|</span><a href="#38874048">parent</a><span>|</span><a href="#38874270">next</a><span>|</span><label class="collapse" for="c-38876537">[-]</label><label class="expand" for="c-38876537">[1 more]</label></div><br/><div class="children"><div class="content">this sort of exists at <a href="https:&#x2F;&#x2F;github.com&#x2F;cksystemsteaching&#x2F;selfie">https:&#x2F;&#x2F;github.com&#x2F;cksystemsteaching&#x2F;selfie</a> (<a href="http:&#x2F;&#x2F;selfie.cs.uni-salzburg.at&#x2F;" rel="nofollow">http:&#x2F;&#x2F;selfie.cs.uni-salzburg.at&#x2F;</a>)<p>&gt; <i>Selfie is a self-contained 64-bit, 12KLOC C implementation of: (...) a tiny (...) subset of C called C Star (C*) (...) to a tiny (...) subset of RISC-V called RISC-U[;] a[n] (...) emulator (...) that executes RISC-U code[;] (...) a (...) hypervisor (...) that provides RISC-U virtual machines</i><p>so they have a self-hosted instruction set architecture, compiler, and operating system, though the operating system is much simpler than xv6.  because the instruction set is a subset of risc-v you can run its code on actual risc-v hardware (or qemu-system-riscv), but presumably you could also design risc-u hardware in verilog that was simpler than a full implementation of rv64i with whatever extensions the hypervisor needs</div><br/></div></div><div id="38874270" class="c"><input type="checkbox" id="c-38874270" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#38872859">root</a><span>|</span><a href="#38874048">parent</a><span>|</span><a href="#38876537">prev</a><span>|</span><a href="#38875252">next</a><span>|</span><label class="collapse" for="c-38874270">[-]</label><label class="expand" for="c-38874270">[4 more]</label></div><br/><div class="children"><div class="content">why would anybody NOT care about paged memory?<p>or maybe a better question is, why care about it? as far as I&#x27;ve understood, paged memory is a legacy from a time where cheap and fast memory wasn&#x27;t a thing<p>how feasible is it to get rid of memory pages? I guess the hardest thing would be untangling interprocess memory safety from pages??</div><br/><div id="38874844" class="c"><input type="checkbox" id="c-38874844" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#38872859">root</a><span>|</span><a href="#38874270">parent</a><span>|</span><a href="#38876611">next</a><span>|</span><label class="collapse" for="c-38874844">[-]</label><label class="expand" for="c-38874844">[1 more]</label></div><br/><div class="children"><div class="content">The answer is memory fragmentation. Process memory safety can theoretically be done with a different scheme such as hardware memory capabilities. You could probably even do demand paging if the memory capability is not a true pointer, but some sort of memory system coherent handle. But, as soon as a process wants to allocate a 1 GB chunk and you have 2 GB, but only in 64 KB chunks you have a problem. You could go around copying data to compact the physical memory, but now you have serious interference problems.<p>You then run into the next problem of using say 32 MB in a &quot;hot loop&quot; in the middle of a 64 GB demand-loaded data structure on a 32 GB machine. You can not greedily load in the entire data structure from disk, so you need some sort of subset feature on your memory handles. But then what do you do about using two disjoint sections separated by over 32 GB? You need some way of having multiple subsets that correspond to physical addresses that do not respect the handle offset. Subset 1 corresponds to physical address range A and subset B corresponds to a uncorrelated physical address range B. Congratulations, you have reinvented memory mapping with extra steps.</div><br/></div></div><div id="38876611" class="c"><input type="checkbox" id="c-38876611" checked=""/><div class="controls bullet"><span class="by">eterps</span><span>|</span><a href="#38872859">root</a><span>|</span><a href="#38874270">parent</a><span>|</span><a href="#38874844">prev</a><span>|</span><a href="#38876490">next</a><span>|</span><label class="collapse" for="c-38876611">[-]</label><label class="expand" for="c-38876611">[1 more]</label></div><br/><div class="children"><div class="content">Project Oberon does not use paged memory. For the most part memory defragmentation is done by a relatively simple system-wide garbage collector (by copying live objects to one end of the heap).</div><br/></div></div><div id="38876490" class="c"><input type="checkbox" id="c-38876490" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38872859">root</a><span>|</span><a href="#38874270">parent</a><span>|</span><a href="#38876611">prev</a><span>|</span><a href="#38875252">next</a><span>|</span><label class="collapse" for="c-38876490">[-]</label><label class="expand" for="c-38876490">[1 more]</label></div><br/><div class="children"><div class="content">adding an mmu to a basic rv32e processor might double its size and power consumption, and more than double the verification effort; moreover, if you&#x27;re targeting applications where deterministic execution time or even worst-case execution time (wcet) is a concern, the mmu is a very likely source of nondeterminism<p>so it&#x27;s not so much that you don&#x27;t care about it as that you might not be able to afford it.  &#x27;cheap and fast&#x27; depends on what scale of machine you&#x27;re talking about; a 1Â¢ computer (not yet available) can afford less than a 10Â¢ computer like the pms150c or (rv32e) ch32v003, which can afford less than a 1-dollar computer like the stm32f104c8t6 or (rv32i) gd32vf104, which can afford less than a 10-dollar computer like a raspberry pi, which can afford less than a 100-dollar computer like a cellphone, which can afford less than a 1000-dollar computer like a gaming rig, which can afford less than a 10-kilobuck computer like a largish cpu server, which can afford less than a 100-kilobuck computer like a petabox<p>unix originally ran on the pdp-11, the relevant models of which had interprocess memory safety in the form of segmentation, but no paging.  i&#x27;ve never used a pdp-11.  adding paging (for example, on the vax the sun-1, and the i386) enabled a variety of new unix features:<p>- as you point out, it enables a process to be larger than physical memory;<p>- fork() became immensely faster because it didn&#x27;t have to copy all of process memory, just the page table, and mark the existing pages copy-on-write;<p>- execve() became immensely faster for a similar reason: it could &#x27;demand-page&#x27; the program into memory as you executed parts of it, instead of waiting to start executing it until the whole thing had been loaded from disk;<p>- shared libraries became possible, so that executable code used by many programs at once could exist as only a single copy in memory (though you could do this without paging if all the processes share the same address space, perhaps with different permissions imposed by an mpu â this wasn&#x27;t considered an option for unix in part because it would involve either giving up fork() or only having one process in memory at a time);<p>- similarly, it became possible for processes to communicate through shared memory buffers, which is commonly used to get images onto the screen quickly;<p>- it became possible to memory-map files, like on multics, so you can access data in them without copying it, which normally takes about twice as long as accessing it;<p>- it became possible for user programs to use the paging hardware to implement the write barriers for their garbage collectors by using mprotect(), though that&#x27;s never been a very popular thing to do because sigsegv handlers are slow and usually nonportable;<p>- and, as veserv pointed out, it eased fragmentation.<p>non-unix systems used paging for a variety of even more creative purposes:<p>- efficient system image checkpointing as in keykos or eumel, by way of atomically marking all pages on the system copy-on-write and then streaming out the dirty ones to disk, so you never had to reboot; after a power failure or system crash, all the same programs would be running in the same state as at the last checkpoint.  qemu can do this too, i think<p>- distributed single-address-space oses, where memory pages migrate around a cluster over a network according to where they&#x27;re being accessed, so every program on the cluster is running in a single shared 64-bit address space; this didn&#x27;t turn out to be as useful as it sounds<p>- insert your mindblowing creative idea here<p>anyway it&#x27;s totally possible to implement memory protection without paging, and lots of computers have, past (with segmentation) and present (with mpus).  but paging gives you a lot more than just memory protection</div><br/></div></div></div></div></div></div><div id="38875252" class="c"><input type="checkbox" id="c-38875252" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#38872859">parent</a><span>|</span><a href="#38874048">prev</a><span>|</span><a href="#38874286">next</a><span>|</span><label class="collapse" for="c-38875252">[-]</label><label class="expand" for="c-38875252">[1 more]</label></div><br/><div class="children"><div class="content">Vintage 8-bit hardware is extremely comprehensible, and it teaches you fundamentals which absolutely still apply today. Ben Eater&#x27;s YouTube videos are fantastic for this, both his 6502 project and his homebrew &quot;from scratch&quot; breadboard computer.</div><br/></div></div><div id="38874286" class="c"><input type="checkbox" id="c-38874286" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#38872859">parent</a><span>|</span><a href="#38875252">prev</a><span>|</span><a href="#38876813">next</a><span>|</span><label class="collapse" for="c-38874286">[-]</label><label class="expand" for="c-38874286">[1 more]</label></div><br/><div class="children"><div class="content">I think that somehow a computer than can learn to talk to other computers would be the pinacle solution<p>this is within reach now with LLMs, the remaining challenges would be somehow connecting the computers (a hardware compatibility issue) but the software should be able to figure the other software out somehow</div><br/></div></div></div></div><div id="38876813" class="c"><input type="checkbox" id="c-38876813" checked=""/><div class="controls bullet"><span class="by">berkeleynerd</span><span>|</span><a href="#38872859">prev</a><span>|</span><a href="#38870186">next</a><span>|</span><label class="collapse" for="c-38876813">[-]</label><label class="expand" for="c-38876813">[1 more]</label></div><br/><div class="children"><div class="content">Has anyone updated the book to allow one work with newer FPGA boards?</div><br/></div></div><div id="38870186" class="c"><input type="checkbox" id="c-38870186" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#38876813">prev</a><span>|</span><a href="#38869969">next</a><span>|</span><label class="collapse" for="c-38870186">[-]</label><label class="expand" for="c-38870186">[1 more]</label></div><br/><div class="children"><div class="content">p. 59-75 covers the fast implementation of piece lists (recently covered on HN).<p>(Just saying because there were many threads on how to represent text buffers for fast editing on HN:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15381886">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15381886</a>
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11244103">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11244103</a>
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14129543">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14129543</a>
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15387672">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15387672</a>
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14046446">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14046446</a> )</div><br/></div></div><div id="38869969" class="c"><input type="checkbox" id="c-38869969" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#38870186">prev</a><span>|</span><a href="#38876464">next</a><span>|</span><label class="collapse" for="c-38869969">[-]</label><label class="expand" for="c-38869969">[5 more]</label></div><br/><div class="children"><div class="content">RIP Prof Wirth<p>Side note: can we get a better tag on this to show it&#x27;s a PDF file? I think the source is reputable but I always freak out when a url goes to a pdf.</div><br/><div id="38876859" class="c"><input type="checkbox" id="c-38876859" checked=""/><div class="controls bullet"><span class="by">gjvc</span><span>|</span><a href="#38869969">parent</a><span>|</span><a href="#38870268">next</a><span>|</span><label class="collapse" for="c-38876859">[-]</label><label class="expand" for="c-38876859">[1 more]</label></div><br/><div class="children"><div class="content">What, specifically, worries you about pdf files?</div><br/></div></div><div id="38870268" class="c"><input type="checkbox" id="c-38870268" checked=""/><div class="controls bullet"><span class="by">forgotpwd16</span><span>|</span><a href="#38869969">parent</a><span>|</span><a href="#38876859">prev</a><span>|</span><a href="#38870806">next</a><span>|</span><label class="collapse" for="c-38870268">[-]</label><label class="expand" for="c-38870268">[2 more]</label></div><br/><div class="children"><div class="content">Usually links leading to pdf are denoted with [pdf] at the end.</div><br/><div id="38870895" class="c"><input type="checkbox" id="c-38870895" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#38869969">root</a><span>|</span><a href="#38870268">parent</a><span>|</span><a href="#38870806">next</a><span>|</span><label class="collapse" for="c-38870895">[-]</label><label class="expand" for="c-38870895">[1 more]</label></div><br/><div class="children"><div class="content">it wasn&#x27;t formatted like this at the time</div><br/></div></div></div></div><div id="38870806" class="c"><input type="checkbox" id="c-38870806" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38869969">parent</a><span>|</span><a href="#38870268">prev</a><span>|</span><a href="#38876464">next</a><span>|</span><label class="collapse" for="c-38870806">[-]</label><label class="expand" for="c-38870806">[1 more]</label></div><br/><div class="children"><div class="content">The URL already ends in .pdf .</div><br/></div></div></div></div><div id="38876464" class="c"><input type="checkbox" id="c-38876464" checked=""/><div class="controls bullet"><span class="by">abdellah123</span><span>|</span><a href="#38869969">prev</a><span>|</span><a href="#38870863">next</a><span>|</span><label class="collapse" for="c-38876464">[-]</label><label class="expand" for="c-38876464">[1 more]</label></div><br/><div class="children"><div class="content">This is a jewel. Is there an attempt to repurpose oberon as a mobile &quot;computer&quot;?</div><br/></div></div><div id="38870863" class="c"><input type="checkbox" id="c-38870863" checked=""/><div class="controls bullet"><span class="by">ikhare</span><span>|</span><a href="#38876464">prev</a><span>|</span><a href="#38874442">next</a><span>|</span><label class="collapse" for="c-38870863">[-]</label><label class="expand" for="c-38870863">[1 more]</label></div><br/><div class="children"><div class="content">Back when I took compilers in college we wrote a compiler for Oberon. I couldnât quite find my original class site, but this one seems roughly right (from a few years before I took the class): <a href="https:&#x2F;&#x2F;cseweb.ucsd.edu&#x2F;~wgg&#x2F;CSE131B&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cseweb.ucsd.edu&#x2F;~wgg&#x2F;CSE131B&#x2F;</a><p>It was a great teaching language.</div><br/></div></div><div id="38874442" class="c"><input type="checkbox" id="c-38874442" checked=""/><div class="controls bullet"><span class="by">flamedoge</span><span>|</span><a href="#38870863">prev</a><span>|</span><a href="#38872625">next</a><span>|</span><label class="collapse" for="c-38874442">[-]</label><label class="expand" for="c-38874442">[1 more]</label></div><br/><div class="children"><div class="content">pretty good to save for post apocalyptic renaissance</div><br/></div></div><div id="38872625" class="c"><input type="checkbox" id="c-38872625" checked=""/><div class="controls bullet"><span class="by">I_am_tiberius</span><span>|</span><a href="#38874442">prev</a><span>|</span><label class="collapse" for="c-38872625">[-]</label><label class="expand" for="c-38872625">[2 more]</label></div><br/><div class="children"><div class="content">In an interview with Niklaus he was talking about a 500 page document...</div><br/><div id="38874446" class="c"><input type="checkbox" id="c-38874446" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#38872625">parent</a><span>|</span><label class="collapse" for="c-38874446">[-]</label><label class="expand" for="c-38874446">[1 more]</label></div><br/><div class="children"><div class="content">The original 1992 book is longer. As mentioned earlier the code generation chapter is smaller because the RISC CPU is much simpler than the original.<p>But, also, the original, I think, has much more source code. I donât know if the original book contains the entirety of the system, but the new one seems to contain more highlights of interfaces and selected examples. It likely relies on the ubiquity of source availability on internet, which clearly was not the case in 1992.</div><br/></div></div></div></div></div></div></div></div></div></body></html>