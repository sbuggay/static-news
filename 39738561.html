<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710752451890" as="style"/><link rel="stylesheet" href="styles.css?v=1710752451890"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/shg8/3DGS.cpp">Show HN: 3DGS.cpp – performant, cross platform Gaussian Splatting with Vulkan</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>0x02A</span> | <span>14 comments</span></div><br/><div><div id="39740312" class="c"><input type="checkbox" id="c-39740312" checked=""/><div class="controls bullet"><span class="by">0x02A</span><span>|</span><a href="#39740294">next</a><span>|</span><label class="collapse" for="c-39740312">[-]</label><label class="expand" for="c-39740312">[4 more]</label></div><br/><div class="children"><div class="content">Hey HN, this project started out when I was exploring rendering radiance fields in real-time for standalone VR and AR headsets. I was frustrated by the lack of performant, yet non-CUDA, implementations. Also, this would be a good excuse to learn about compute pipelines in Vulkan.<p>Right now, the renderer runs on Windows, Linux, macOS, iOS, and visionOS (as an iPad app). OpenXR support and an immersive visionOS app are coming soon. Training is also WIP. As we&#x27;re seeing the industry adopt research in Gaussian Splatting at a fast pace, I hope this makes it easier for folks implementing Gaussian Splatting or variants in their products.<p>Would love to hear your feedback!<p>For more context, see previous HN discussions on Gaussian Splatting:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39120016">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39120016</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38576974">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38576974</a></div><br/><div id="39740386" class="c"><input type="checkbox" id="c-39740386" checked=""/><div class="controls bullet"><span class="by">heliophobicdude</span><span>|</span><a href="#39740312">parent</a><span>|</span><a href="#39740294">next</a><span>|</span><label class="collapse" for="c-39740386">[-]</label><label class="expand" for="c-39740386">[3 more]</label></div><br/><div class="children"><div class="content">Thank you so much for open sourcing this!<p>I&#x27;ve started a project to initialize each pixel in an image into a mesh of GS. I used a depth map to unproject them into space.<p>I&#x27;ve been very curious what a few training iterations would do to optimize my scenes. The original 3DGS implementation is not accessible on my hardware at the moment! I really look forward to your training implementation!</div><br/><div id="39740508" class="c"><input type="checkbox" id="c-39740508" checked=""/><div class="controls bullet"><span class="by">pierotofy</span><span>|</span><a href="#39740312">root</a><span>|</span><a href="#39740386">parent</a><span>|</span><a href="#39740705">next</a><span>|</span><label class="collapse" for="c-39740508">[-]</label><label class="expand" for="c-39740508">[1 more]</label></div><br/><div class="children"><div class="content">For training you can also try <a href="https:&#x2F;&#x2F;github.com&#x2F;pierotofy&#x2F;opensplat">https:&#x2F;&#x2F;github.com&#x2F;pierotofy&#x2F;opensplat</a></div><br/></div></div><div id="39740705" class="c"><input type="checkbox" id="c-39740705" checked=""/><div class="controls bullet"><span class="by">0x02A</span><span>|</span><a href="#39740312">root</a><span>|</span><a href="#39740386">parent</a><span>|</span><a href="#39740508">prev</a><span>|</span><a href="#39740294">next</a><span>|</span><label class="collapse" for="c-39740705">[-]</label><label class="expand" for="c-39740705">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s super interesting. Are you trying to do single-view image to 3D?</div><br/></div></div></div></div></div></div><div id="39740294" class="c"><input type="checkbox" id="c-39740294" checked=""/><div class="controls bullet"><span class="by">w-m</span><span>|</span><a href="#39740312">prev</a><span>|</span><a href="#39738750">next</a><span>|</span><label class="collapse" for="c-39740294">[-]</label><label class="expand" for="c-39740294">[4 more]</label></div><br/><div class="children"><div class="content">Great project, it&#x27;s nice to see so many people are building stuff with Gaussian Splatting.<p>Just the other day I went through the whole list of known viewers on MrNeRF&#x27;s awesome 3DGS resources, to find one that runs on a MacBook. I&#x27;m working on compressing 3D scenes by sorting Gaussians into 2D grids [0], and I wanted a native viewer that I could for experiments on the go.. perhaps as an alternative backend to the CUDA one in my colleague&#x27;s exploratory Python viewer [1].<p>VulkanSplatting was the only one I could get to compile and run on my Intel MacBook. Unfortunately the feeble Intel GPU isn&#x27;t able to display even the Lego scene at an interactive framerate. Do you think there&#x27;s performance headroom, and that it will become possible in the future, or should I give up trying to run this on an Intel MBP?<p>[0]: <a href="https:&#x2F;&#x2F;fraunhoferhhi.github.io&#x2F;Self-Organizing-Gaussians&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fraunhoferhhi.github.io&#x2F;Self-Organizing-Gaussians&#x2F;</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;Florian-Barthel&#x2F;gaussian_viewer">https:&#x2F;&#x2F;github.com&#x2F;Florian-Barthel&#x2F;gaussian_viewer</a></div><br/><div id="39740347" class="c"><input type="checkbox" id="c-39740347" checked=""/><div class="controls bullet"><span class="by">0x02A</span><span>|</span><a href="#39740294">parent</a><span>|</span><a href="#39738750">next</a><span>|</span><label class="collapse" for="c-39740347">[-]</label><label class="expand" for="c-39740347">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for trying it out! I haven&#x27;t had the opportunity to benchmark this on an Intel Macbook. Were you able to see which kernel takes the most time? There should be a performance graph if you have the GUI enabled.<p>For my Apple Silicon benchmarks, the main bottleneck is the parallel radix sort that sorts the Gaussians by tile and depth. I used a some shaders from a sorting library, but it has some performance gaps with SOTA parallel sort algorithms. I think fixing this would give a 1.5x overall performance boost and maybe 3x on Macbooks. Also the wave size isn&#x27;t tuned for different GPUs.<p>Another area of improvement is better management of the shared memory. Right now, we just let the driver manage it as the L1 cache. However, we could manage it manually and group Gaussian retrievals together for the same tile. This is what the official implementation does.<p>Although 3DGS is the first radiance field with SOTA quality that runs in real-time, I think it&#x27;s still quite heavy. Due to the explicit representation of the scene, a lot of operations are memory bound. If you can&#x27;t get an interactive frame rate right now, it&#x27;s unlikely the improvements will make a material difference.<p>Hopefully that&#x27;s where your work on compression comes in and solves the problem :)</div><br/><div id="39740503" class="c"><input type="checkbox" id="c-39740503" checked=""/><div class="controls bullet"><span class="by">w-m</span><span>|</span><a href="#39740294">root</a><span>|</span><a href="#39740347">parent</a><span>|</span><a href="#39738750">next</a><span>|</span><label class="collapse" for="c-39740503">[-]</label><label class="expand" for="c-39740503">[2 more]</label></div><br/><div class="children"><div class="content">For some reason the GUI is not showing up for me in 3DGS.cpp. (I checked out the repo, made a build folder and built with Ninja, then launched .&#x2F;apps&#x2F;viewer&#x2F;vulkan_splatting_viewer).<p>I still have a VulkanSplatting build from this Wednesday though. In VulkanSplatting, when looking at the Lego scene from above with the default window size, I&#x27;m getting just below 1 ms for the sorting kernel and just above 1 ms for &quot;render&quot;, everything else is too small in the graph to register. But it only displays at a handful of fps, so it seems quite some time goes unaccounted for.<p>Maybe spinning up Instruments could give some more insights into what&#x27;s happening? I tried `cmake -G Xcode` to have that setup easily, but the Xcode CMake generation fails with<p><pre><code>    CMake Error in src&#x2F;shaders&#x2F;CMakeLists.txt:
      The custom command generating
    
        3DGS.cpp&#x2F;build-xcode&#x2F;shaders&#x2F;shaders.h
    
      is attached to multiple targets:
    
        shaders
        xcode_shaders
    
      but none of these is a common dependency of the other(s).  This is not
      allowed by the Xcode &quot;new build system&quot;.</code></pre></div><br/><div id="39740671" class="c"><input type="checkbox" id="c-39740671" checked=""/><div class="controls bullet"><span class="by">0x02A</span><span>|</span><a href="#39740294">root</a><span>|</span><a href="#39740503">parent</a><span>|</span><a href="#39738750">next</a><span>|</span><label class="collapse" for="c-39740671">[-]</label><label class="expand" for="c-39740671">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I gave it a try and timings seems to be very wrong. I&#x27;ll fix that soon.<p>I haven&#x27;t tried benchmarking SPIR-V shaders on macOS. Since they&#x27;re translated into Metal shaders anyways, it should be possible theoretically.<p>Also, for the command line viewer in the new version, I&#x27;ve only tested make or ninja. I&#x27;ll take a look at xcode when I get a chance.<p>Update:
I just gave Instruments a try and it seems like the Metal  compiler grouped all of the compute and copy operations together and just left the timestamp operations to run back to back. Since MoltenVK isn&#x27;t a conformant implementation, I&#x27;m guessing the synchronization dependencies weren&#x27;t respected.<p>However, I&#x27;m still getting 200ms frame times on the Garden scene at 4K with M1 Pro. The lego scene shouldn&#x27;t be too bad even on an Intel Mackbook.</div><br/></div></div></div></div></div></div></div></div><div id="39740282" class="c"><input type="checkbox" id="c-39740282" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#39738750">prev</a><span>|</span><label class="collapse" for="c-39740282">[-]</label><label class="expand" for="c-39740282">[4 more]</label></div><br/><div class="children"><div class="content">I wonder if this technique could be used to bring back PS1 esque pre-rendered background style games but with actual depth</div><br/><div id="39741248" class="c"><input type="checkbox" id="c-39741248" checked=""/><div class="controls bullet"><span class="by">0x02A</span><span>|</span><a href="#39740282">parent</a><span>|</span><a href="#39741086">next</a><span>|</span><label class="collapse" for="c-39741248">[-]</label><label class="expand" for="c-39741248">[2 more]</label></div><br/><div class="children"><div class="content">The original paper doesn&#x27;t work well with few-shot learning. I&#x27;m assuming that there is only one camera angle for each pre-rendered background. For single image to 3D, check out DreamGaussian. [1]<p>[1] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2309.16653.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2309.16653.pdf</a></div><br/><div id="39741578" class="c"><input type="checkbox" id="c-39741578" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#39740282">root</a><span>|</span><a href="#39741248">parent</a><span>|</span><a href="#39741086">next</a><span>|</span><label class="collapse" for="c-39741578">[-]</label><label class="expand" for="c-39741578">[1 more]</label></div><br/><div class="children"><div class="content">Pre-rendered in this context means you still have access to the full 3d scene so you can generate the full gaussian splatting model from that. The benefit here would be to lower the cost of rendering that complicated scene. There is a game called Fantasian (by the former FF dev) that uses real-life dioramas as backgrounds, I bet this tech would&#x27;ve been perfect fit for that too.</div><br/></div></div></div></div><div id="39741086" class="c"><input type="checkbox" id="c-39741086" checked=""/><div class="controls bullet"><span class="by">blarg1</span><span>|</span><a href="#39740282">parent</a><span>|</span><a href="#39741248">prev</a><span>|</span><label class="collapse" for="c-39741086">[-]</label><label class="expand" for="c-39741086">[1 more]</label></div><br/><div class="children"><div class="content">Probably, I saw one where they took scenes from movies and recreated 3D versions of them.</div><br/></div></div></div></div></div></div></div></div></div></body></html>