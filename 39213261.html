<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706864456339" as="style"/><link rel="stylesheet" href="styles.css?v=1706864456339"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Ask HN: Guide for Implementing Common Lisp</a>Â </div><div class="subtext"><span>HexDecOctBin</span> | <span>33 comments</span></div><br/><div><div id="39214049" class="c"><input type="checkbox" id="c-39214049" checked=""/><div class="controls bullet"><span class="by">oumua_don17</span><span>|</span><a href="#39218740">next</a><span>|</span><label class="collapse" for="c-39214049">[-]</label><label class="expand" for="c-39214049">[2 more]</label></div><br/><div class="children"><div class="content">Lisp from Nothing and Lisp System Implementation from [1].<p>There are quite a few open source Lisp implementations in addition to SBCL that you can peruse [2] (follow links to CL&#x27;s supported by Quicklisp). If you are targeting a specific platform (JVM or embedded), then ABCL&#x2F;ECL; see Clasp for using LLVM.<p>To reuse modules for writing your own lisp, see SICL [3]<p>[1] <a href="http:&#x2F;&#x2F;t3x.org" rel="nofollow">http:&#x2F;&#x2F;t3x.org</a><p>[2] <a href="https:&#x2F;&#x2F;www.quicklisp.org&#x2F;beta&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.quicklisp.org&#x2F;beta&#x2F;</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;robert-strandh&#x2F;SICL">https:&#x2F;&#x2F;github.com&#x2F;robert-strandh&#x2F;SICL</a></div><br/><div id="39221197" class="c"><input type="checkbox" id="c-39221197" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#39214049">parent</a><span>|</span><a href="#39218740">next</a><span>|</span><label class="collapse" for="c-39221197">[-]</label><label class="expand" for="c-39221197">[1 more]</label></div><br/><div class="children"><div class="content">also:  <a href="http:&#x2F;&#x2F;t3x.org&#x2F;lsi&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;t3x.org&#x2F;lsi&#x2F;index.html</a></div><br/></div></div></div></div><div id="39218740" class="c"><input type="checkbox" id="c-39218740" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39214049">prev</a><span>|</span><a href="#39225997">next</a><span>|</span><label class="collapse" for="c-39218740">[-]</label><label class="expand" for="c-39218740">[5 more]</label></div><br/><div class="children"><div class="content">Common Lisp compilers do not interact with read macros at all. Read macros are done by the time a compiler gets to the code.<p>Depending on the design, macros may also be expanded already; the compiler works with macro-expanded code.<p>The easiest approach, from a boostrapping point of view, is to write an interpreter in some host language. Get macro expansion and read macros working in the interpreter, and then add a compiler.</div><br/><div id="39224252" class="c"><input type="checkbox" id="c-39224252" checked=""/><div class="controls bullet"><span class="by">HexDecOctBin</span><span>|</span><a href="#39218740">parent</a><span>|</span><a href="#39225997">next</a><span>|</span><label class="collapse" for="c-39224252">[-]</label><label class="expand" for="c-39224252">[4 more]</label></div><br/><div class="children"><div class="content">I see. So what is the output of Read macros? It has to be text, right, since only the compiler will be able to deal with tokens&#x2F;objects?</div><br/><div id="39226371" class="c"><input type="checkbox" id="c-39226371" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#39218740">root</a><span>|</span><a href="#39224252">parent</a><span>|</span><a href="#39224866">next</a><span>|</span><label class="collapse" for="c-39226371">[-]</label><label class="expand" for="c-39226371">[1 more]</label></div><br/><div class="children"><div class="content">reader macros create Lisp data.<p>The compiler&#x2F;interpreter gets as input Lisp data. Let&#x27;s use READ, DESCRIBE and EVAL to see that working:<p><pre><code>    CL-USER 17 &gt; (defun example (&amp;aux input result)
                   (terpri)                    ; newline
                   (write-string &quot;Input&gt; &quot;)
                   (finish-output)
                   (terpri)
                   (setf input (read))         ; reading from input stream
                   (terpri)
                   (describe input)            ; what did we read?
                   (terpri)
                   (write-string &quot;Output&gt;&quot;)
                   (setf result (eval input))  ; evaluation
                   (terpri)
                   (write-string &quot;Result&gt;&quot;)
                   (print result)              ; printing the result
                   (values))                   ; return nothing
    EXAMPLE

    CL-USER 18 &gt; (example)

    Input&gt; 
    (progn
      (print (+ 1 3))
      (print &#x27;done))

    (PROGN (PRINT (+ 1 3)) (PRINT (QUOTE DONE))) is a LIST
    0      PROGN
    1      (PRINT (+ 1 3))
    2      (PRINT (QUOTE DONE))
    Output&gt;
    4 
    DONE 
    Result&gt;
    DONE
</code></pre>
As you can see READ in actual Lisp takes input from the keyboard and returns a list as data.<p>EVAL is then taking code as a list and evaluates it to a value, as side effects there might be printed output of the program.</div><br/></div></div><div id="39224866" class="c"><input type="checkbox" id="c-39224866" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39218740">root</a><span>|</span><a href="#39224252">parent</a><span>|</span><a href="#39226371">prev</a><span>|</span><a href="#39224880">next</a><span>|</span><label class="collapse" for="c-39224866">[-]</label><label class="expand" for="c-39224866">[1 more]</label></div><br/><div class="children"><div class="content">Read macros are processed at read time, the result is a change to the way the `read` function operates. The output is a lisp object.<p>On Lisp Ch 17, page 224: <a href="https:&#x2F;&#x2F;sep.turbifycdn.com&#x2F;ty&#x2F;cdn&#x2F;paulgraham&#x2F;onlisp.pdf" rel="nofollow">https:&#x2F;&#x2F;sep.turbifycdn.com&#x2F;ty&#x2F;cdn&#x2F;paulgraham&#x2F;onlisp.pdf</a><p>CLTL2 Section 22.1.1: <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node188.html#SECTION002611000000000000000" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node188.html#...</a> - Goes into a lot of detail on how the reader works.<p>The macros most people mean when they talk about Lisp macros are discussed in CLTL2 Ch 8. They are expanded during evaluation or compilation.<p>CLTL2 CH 8: <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node97.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node97.html</a><p>Read macros are able to produce (or not produce) lisp objects by taking control of the stream processing for some period of time.</div><br/></div></div><div id="39224880" class="c"><input type="checkbox" id="c-39224880" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#39218740">root</a><span>|</span><a href="#39224252">parent</a><span>|</span><a href="#39224866">prev</a><span>|</span><a href="#39225997">next</a><span>|</span><label class="collapse" for="c-39224880">[-]</label><label class="expand" for="c-39224880">[1 more]</label></div><br/><div class="children"><div class="content">The compiler deals with code in S-expression form, represented as lists and atoms. Reader macros produce Common Lisp objects.</div><br/></div></div></div></div></div></div><div id="39225997" class="c"><input type="checkbox" id="c-39225997" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#39218740">prev</a><span>|</span><a href="#39225035">next</a><span>|</span><label class="collapse" for="c-39225997">[-]</label><label class="expand" for="c-39225997">[2 more]</label></div><br/><div class="children"><div class="content">This is a very approachable paper from 1990 on one way to do it with a C kernel bootstrapping to Common Lisp: <a href="https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;LISP&#x2F;kcl&#x2F;paper&#x2F;kcl-paper.pdf" rel="nofollow">https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;LISP&#x2F;kcl&#x2F;paper...</a> Kyoto Common Lisp (KCL) is the ancestor of today&#x27;s Embeddable Common Lisp (ECL).<p>SICL is probably the best modern version of CL written in CL from a design standpoint, even if it&#x27;s not taking over SBCL&#x27;s role anytime soon: <a href="https:&#x2F;&#x2F;github.com&#x2F;robert-strandh&#x2F;SICL">https:&#x2F;&#x2F;github.com&#x2F;robert-strandh&#x2F;SICL</a> It uses some fancy bootstrapping to have the whole language available early, e.g. their definition of class &#x27;symbol is:<p><pre><code>    (defclass symbol (t)
      ((%name :reader symbol-name)
       (%package :reader symbol-package))
      (:metaclass built-in-class))
</code></pre>
vs SBCL:<p><pre><code>    (define-primitive-object
        (symbol :lowtag other-pointer-lowtag
                :widetag symbol-header-widetag
                :alloc-trans %make-symbol
                :type symbol)
      ...
      (name :ref-trans symbol-name :init :arg)
      (package :ref-trans symbol-package
               :set-trans %set-symbol-package
               :init :null)
      ...)
</code></pre>
(That&#x27;s from one of the papers from the 2019 European Lisp Symposium: <a href="https:&#x2F;&#x2F;www.european-lisp-symposium.org&#x2F;2019&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;www.european-lisp-symposium.org&#x2F;2019&#x2F;index.html</a> Scroll down to the bottom for proceedings with all the papers in the pdf. Going through the ELS archives and checking out papers and their references can be useful for learning more about this stuff too.)</div><br/><div id="39226080" class="c"><input type="checkbox" id="c-39226080" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#39225997">parent</a><span>|</span><a href="#39225035">next</a><span>|</span><label class="collapse" for="c-39226080">[-]</label><label class="expand" for="c-39226080">[1 more]</label></div><br/><div class="children"><div class="content">Also worth mentioning SICL is very modular, and components of it are used in other Common Lisp implementations. If memory serves me right, Clasp uses SICL&#x27;s Loop module to implement the LOOP macro, and this has allowed both Clasp and SICL devs to uncover lots of codebases with non-conformant usages of LOOP. (One common violation is e.g. WITH-clause after FOR-clause, and the SICL module decides to strictly follow the CL specification and error here).</div><br/></div></div></div></div><div id="39225035" class="c"><input type="checkbox" id="c-39225035" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#39225997">prev</a><span>|</span><a href="#39226542">next</a><span>|</span><label class="collapse" for="c-39225035">[-]</label><label class="expand" for="c-39225035">[3 more]</label></div><br/><div class="children"><div class="content">The readtables and reader macros are entirely independent of Common Lisp compilers.  The compilers work on the representation (that is, trees of cons cells) that is produced by the reader, which is after the readtables and reader macros have done their work.<p>If you are thinking of a Common Lisp compiler as working on a text file, you&#x27;re thinking about it wrong.   In Common Lisp, you can invoke the COMPILE function on a lambda expression that you cons up at runtime and that never is in a textual representation.<p>As a general rule, don&#x27;t reimplement a Lisp except as a learning exercise (in which case, you&#x27;re not going to reimplement Common Lisp; it&#x27;s too big.)</div><br/><div id="39225373" class="c"><input type="checkbox" id="c-39225373" checked=""/><div class="controls bullet"><span class="by">HexDecOctBin</span><span>|</span><a href="#39225035">parent</a><span>|</span><a href="#39226542">next</a><span>|</span><label class="collapse" for="c-39225373">[-]</label><label class="expand" for="c-39225373">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In Common Lisp, you can invoke the COMPILE function on a lambda expression that you cons up at runtime and that never is in a textual representation.<p>Ah, I see. This actually clarified some of the apparently contradictory stuff I have been reading, thanks.<p>&gt; As a general rule, don&#x27;t reimplement a Lisp except as a learning exercise<p>Oh, I am much too nuts for something as simple as that, I am actually planning to write a GPU-targeted language with ALGOL-syntax and Lisp-metaprogramming and REPL-driven-ish development. Wish me luck!</div><br/><div id="39225657" class="c"><input type="checkbox" id="c-39225657" checked=""/><div class="controls bullet"><span class="by">el_memorioso</span><span>|</span><a href="#39225035">root</a><span>|</span><a href="#39225373">parent</a><span>|</span><a href="#39226542">next</a><span>|</span><label class="collapse" for="c-39225657">[-]</label><label class="expand" for="c-39225657">[1 more]</label></div><br/><div class="children"><div class="content">Why m-expressions (Algol syntax)? McCarthy initially tried m-expressions for Lisp, but it turned out that programmers liked s-expressions better.</div><br/></div></div></div></div></div></div><div id="39226542" class="c"><input type="checkbox" id="c-39226542" checked=""/><div class="controls bullet"><span class="by">tensility</span><span>|</span><a href="#39225035">prev</a><span>|</span><a href="#39224932">next</a><span>|</span><label class="collapse" for="c-39226542">[-]</label><label class="expand" for="c-39226542">[1 more]</label></div><br/><div class="children"><div class="content">I would suggest reading Lisp In Small Pieces by Christian Quiennec.</div><br/></div></div><div id="39224932" class="c"><input type="checkbox" id="c-39224932" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#39226542">prev</a><span>|</span><a href="#39224835">next</a><span>|</span><label class="collapse" for="c-39224932">[-]</label><label class="expand" for="c-39224932">[4 more]</label></div><br/><div class="children"><div class="content">&gt; but I find it hard to understand how Common Lisp compilers work â what with their readtables and read macros and normal macros<p>Read tables and reader macros are used in the reader, which is separate from the compiler. The compiler macroexpands normal macros though.<p>&gt; what subsets are implemented before the rest<p>There are no obvious subsets in Common Lisp - see Baker on the matter &lt;<a href="https:&#x2F;&#x2F;www.plover.com&#x2F;~mjd&#x2F;misc&#x2F;hbaker-archive&#x2F;MetaCircular.html" rel="nofollow">https:&#x2F;&#x2F;www.plover.com&#x2F;~mjd&#x2F;misc&#x2F;hbaker-archive&#x2F;MetaCircular...</a>&gt;.<p>SBCL is mostly written without CLOS and then brings in a CLOS implementation late into bootstrapping; that of course prevents you from using CLOS in some places, so you may not want to do that though.<p>&gt; is there any implementation guide on how a Common Lisp is&#x2F;should be implemented?<p>You could do a lot better than the existing Common Lisp implementations, especially in compilers and GC, but the issues there are not specific to Common Lisp.</div><br/><div id="39225044" class="c"><input type="checkbox" id="c-39225044" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#39224932">parent</a><span>|</span><a href="#39224835">next</a><span>|</span><label class="collapse" for="c-39225044">[-]</label><label class="expand" for="c-39225044">[3 more]</label></div><br/><div class="children"><div class="content">&gt; SBCL is mostly written without CLOS and then brings in a CLOS implementation late into bootstrapping; that of course prevents you from using CLOS in some places, so you may not want to do that though.<p>This is one of the things that makes Common Lisp implementations tricky. Because the error handling system in CL is based on CLOS, it means you have to build the base system with a crippled error handler and then at some point replace the whole thing with the proper error handler atomically and pray you don&#x27;t get an error during the switchover.</div><br/><div id="39226627" class="c"><input type="checkbox" id="c-39226627" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#39224932">root</a><span>|</span><a href="#39225044">parent</a><span>|</span><a href="#39225058">next</a><span>|</span><label class="collapse" for="c-39226627">[-]</label><label class="expand" for="c-39226627">[1 more]</label></div><br/><div class="children"><div class="content">See here why Conditions is not defined in terms of CLOS:<p><a href="https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Issues&#x2F;iss048_w.htm" rel="nofollow">https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Issues&#x2F;iss...</a><p>&gt; The condition system should not be too tightly integrated into CLOS, for two reasons:  Some implementations already have a native condition system that is not based on CLOS, and it should be possible to integrate the native conditions and the ANSI CL conditions.  Some people would like to define an ANSI Common Lisp subset that does not contain CLOS but does contain conditions.</div><br/></div></div><div id="39225058" class="c"><input type="checkbox" id="c-39225058" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#39224932">root</a><span>|</span><a href="#39225044">parent</a><span>|</span><a href="#39226627">prev</a><span>|</span><a href="#39224835">next</a><span>|</span><label class="collapse" for="c-39225058">[-]</label><label class="expand" for="c-39225058">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because the error handling system in CL is based on CLOS<p>This is not the case.  CONDITION objects don&#x27;t have to be CLOS objects (although they are allowed to be).</div><br/></div></div></div></div></div></div><div id="39224835" class="c"><input type="checkbox" id="c-39224835" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#39224932">prev</a><span>|</span><a href="#39216075">next</a><span>|</span><label class="collapse" for="c-39224835">[-]</label><label class="expand" for="c-39224835">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Wa81OJnlsoI" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Wa81OJnlsoI</a></div><br/></div></div><div id="39216075" class="c"><input type="checkbox" id="c-39216075" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#39224835">prev</a><span>|</span><a href="#39224863">next</a><span>|</span><label class="collapse" for="c-39216075">[-]</label><label class="expand" for="c-39216075">[4 more]</label></div><br/><div class="children"><div class="content">Make a Lisp:  <a href="https:&#x2F;&#x2F;github.com&#x2F;kanaka&#x2F;mal">https:&#x2F;&#x2F;github.com&#x2F;kanaka&#x2F;mal</a><p>Make a Lisp is more Clojure-flavored than Common Lisp, but it might still be nice to examine because of how many different implementation languages it has been done in by various authors.<p>It also breaks down the implementation process into 11 distinct steps which are easy to understand.</div><br/><div id="39226090" class="c"><input type="checkbox" id="c-39226090" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#39216075">parent</a><span>|</span><a href="#39225667">next</a><span>|</span><label class="collapse" for="c-39226090">[-]</label><label class="expand" for="c-39226090">[1 more]</label></div><br/><div class="children"><div class="content">I find it strange to think in terms of implementing a parser for lists as producing some kind of AST.<p>The reader does not return an AST, but is a Lisp procedure which returns nested lists of atoms. As such it is independent of code and it just reads s-expression data. The input to EVAL or COMPILE then is also not an AST, but an s-expression representation. Thus the first thing one would do is to think about a data representation for s-expressions.<p>READ then needs to turn s-expressions into that data representation. READ then also does not work over a string, but a text stream.<p>People implement then a Clojure-like language, but miss the implementation implications that the input to EVAL is actually a basic Lisp data structure and they miss the nature of READ producing such a Lisp data structure from basic stream operations like READ-CHAR... Also in many cases it is useful to make the reader table-driven and not hard-wired.<p>Thus a typical question is to think how much of Lisp do I have to implement in that other language and how much Lisp then can be then implemented in Lisp.<p>So, one of the really basic ideas of Lisp is that READ is defined to take input from a stream (keyboard, file, ...) and returns basic Lisp data. It is a general tool for de-serialization of Lisp data, not a special tool for reading Lisp code.<p>READ is not converting a STRING to an AST.</div><br/></div></div><div id="39225667" class="c"><input type="checkbox" id="c-39225667" checked=""/><div class="controls bullet"><span class="by">Looveh</span><span>|</span><a href="#39216075">parent</a><span>|</span><a href="#39226090">prev</a><span>|</span><a href="#39226035">next</a><span>|</span><label class="collapse" for="c-39225667">[-]</label><label class="expand" for="c-39225667">[1 more]</label></div><br/><div class="children"><div class="content">I highly recommend anybody interested in Lisp and compilers to check this repo out. I went through it this weekend and built my own Lisp interpreter in Ruby with it, fwimc: <a href="https:&#x2F;&#x2F;github.com&#x2F;Looveh&#x2F;lovisp">https:&#x2F;&#x2F;github.com&#x2F;Looveh&#x2F;lovisp</a></div><br/></div></div><div id="39226035" class="c"><input type="checkbox" id="c-39226035" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#39216075">parent</a><span>|</span><a href="#39225667">prev</a><span>|</span><a href="#39224863">next</a><span>|</span><label class="collapse" for="c-39226035">[-]</label><label class="expand" for="c-39226035">[1 more]</label></div><br/><div class="children"><div class="content">Mal - while nice - has very little to do with common lisp.</div><br/></div></div></div></div><div id="39224863" class="c"><input type="checkbox" id="c-39224863" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#39216075">prev</a><span>|</span><a href="#39213442">next</a><span>|</span><label class="collapse" for="c-39224863">[-]</label><label class="expand" for="c-39224863">[2 more]</label></div><br/><div class="children"><div class="content">Starting with the obvious, are you familiar with the HyperSpec? <a href="https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Front&#x2F;index.htm" rel="nofollow">https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Front&#x2F;inde...</a></div><br/><div id="39225386" class="c"><input type="checkbox" id="c-39225386" checked=""/><div class="controls bullet"><span class="by">HexDecOctBin</span><span>|</span><a href="#39224863">parent</a><span>|</span><a href="#39213442">next</a><span>|</span><label class="collapse" for="c-39225386">[-]</label><label class="expand" for="c-39225386">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, though I just yesterday discovered Novaspec and CL-community spec which actually makes it readable.</div><br/></div></div></div></div><div id="39213442" class="c"><input type="checkbox" id="c-39213442" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#39224863">prev</a><span>|</span><a href="#39213706">next</a><span>|</span><label class="collapse" for="c-39213442">[-]</label><label class="expand" for="c-39213442">[3 more]</label></div><br/><div class="children"><div class="content">Lisp in Small Pieces is the standard recommendation.</div><br/><div id="39213685" class="c"><input type="checkbox" id="c-39213685" checked=""/><div class="controls bullet"><span class="by">HexDecOctBin</span><span>|</span><a href="#39213442">parent</a><span>|</span><a href="#39213706">next</a><span>|</span><label class="collapse" for="c-39213685">[-]</label><label class="expand" for="c-39213685">[2 more]</label></div><br/><div class="children"><div class="content">Thanks. I skimmed through it a while back, so my memory might be faulty, but I think it implemented a Lisp in a Lisp. Do they actually implement this whole machinery, or do they simply use the existing mechanisms?</div><br/><div id="39218292" class="c"><input type="checkbox" id="c-39218292" checked=""/><div class="controls bullet"><span class="by">i_don_t_know</span><span>|</span><a href="#39213442">root</a><span>|</span><a href="#39213685">parent</a><span>|</span><a href="#39213706">next</a><span>|</span><label class="collapse" for="c-39218292">[-]</label><label class="expand" for="c-39218292">[1 more]</label></div><br/><div class="children"><div class="content">The later chapters talk about compilation to byte-code and IIRC how you implement that in a VM in C. But it doesn&#x27;t talk about memory management and garbage collection. It has a chapter on macros.<p>SICP goes a little further from compiling Scheme to virtual assembly, a VM and memory management with garbage collection in their last chapter. It&#x27;s all implemented in Scheme itself, including the VM, but at that point it&#x27;s low-level enough that you should be able to make the step to C. It doesn&#x27;t talk about macros.<p><a href="https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;books_pres_0&#x2F;6515&#x2F;sicp.zip&#x2F;full-text&#x2F;book&#x2F;book-Z-H-30.html#%_chap_5" rel="nofollow">https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;b...</a><p>Neither one really talks about Common Lisp though and read macros etc. I&#x27;m also not sure how similar Scheme and Common Lisp compilers are.</div><br/></div></div></div></div></div></div><div id="39213706" class="c"><input type="checkbox" id="c-39213706" checked=""/><div class="controls bullet"><span class="by">GianFabien</span><span>|</span><a href="#39213442">prev</a><span>|</span><a href="#39215413">next</a><span>|</span><label class="collapse" for="c-39213706">[-]</label><label class="expand" for="c-39213706">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps reading the source code for SBCL, <a href="https:&#x2F;&#x2F;www.sbcl.org&#x2F;porting.html" rel="nofollow">https:&#x2F;&#x2F;www.sbcl.org&#x2F;porting.html</a> provide some of the answers you seek.</div><br/></div></div><div id="39215413" class="c"><input type="checkbox" id="c-39215413" checked=""/><div class="controls bullet"><span class="by">brudgers</span><span>|</span><a href="#39213706">prev</a><span>|</span><a href="#39225210">next</a><span>|</span><label class="collapse" for="c-39215413">[-]</label><label class="expand" for="c-39215413">[1 more]</label></div><br/><div class="children"><div class="content">SBCL is open source.<p>That might be a way to start.<p>Or not.<p>Good luck.</div><br/></div></div><div id="39225210" class="c"><input type="checkbox" id="c-39225210" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39215413">prev</a><span>|</span><label class="collapse" for="c-39225210">[-]</label><label class="expand" for="c-39225210">[3 more]</label></div><br/><div class="children"><div class="content">Mark: How do I compile Lisp source code?<p>Nolan: That&#x27;s the neat thing -- you don&#x27;t.<p>Lisp compilers operate on Lisp data structures -- generally speaking, mostly lists and atoms. The &#x27;read&#x27; function is what turns text into these data structures; reader macros alter how this function operates and control what data structures will be emitted by the reader. This really <i>is</i> the neat part about Lisp -- it&#x27;s much simpler to write a compiler that consumes an AST directly than one that consumes text, and the AST is expressed directly in terms of Lisp&#x27;s primitive data structures which you can easily write your own functions over. And it&#x27;s a relative doddle to write a reader for s-expressions compared to other expression formats. Join these two relatively simple pieces together and you have a complete Lisp compiler system.<p>As for regular macros, they transform the AST before it&#x27;s evaluated or compiled. So they come into play after the reader has consumed the source and produced an AST, but before the evaluator or compiler can work.</div><br/><div id="39225768" class="c"><input type="checkbox" id="c-39225768" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#39225210">parent</a><span>|</span><a href="#39225401">next</a><span>|</span><label class="collapse" for="c-39225768">[-]</label><label class="expand" for="c-39225768">[1 more]</label></div><br/><div class="children"><div class="content">Lisp compilers and interpreters are using s-expressions (-&gt; nested lists of atoms) as source input. But these are not an AST. The compiler&#x2F;interpreter has to find out what these lists &amp; atoms actually mean and may build an AST.<p>Macros also see only lists&#x2F;atoms. Macros then find out on their own what the embedded code should mean. That&#x27;s different from some other languages, where macros work over an AST. Which means that the code is parsed and needs to follow a syntax. That&#x27;s not the case in Common Lisp, macro forms can be in any syntax. (infix a + b)  is legal syntax in Common Lisp, the macro could for example convert infix syntax to prefix. In a language where the operator + is defined to be a prefix operator (-&gt; syntax), an expression prefix(+ a b) could not parse the thing into an addition call AST node, since it would need to know what syntax rules to use for the code. Somehow it would need to build an AST for a different syntax.</div><br/></div></div><div id="39225401" class="c"><input type="checkbox" id="c-39225401" checked=""/><div class="controls bullet"><span class="by">HexDecOctBin</span><span>|</span><a href="#39225210">parent</a><span>|</span><a href="#39225768">prev</a><span>|</span><label class="collapse" for="c-39225401">[-]</label><label class="expand" for="c-39225401">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Join these two relatively simple pieces together and you have a complete Lisp compiler system.<p>I see, this clarifies things a lot. Thanks.</div><br/></div></div></div></div></div></div></div></div></div></body></html>