<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721034065349" as="style"/><link rel="stylesheet" href="styles.css?v=1721034065349"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.sbensu.com/posts/demand-for-visual-programming/">We need visual programming. No, not like that</a> <span class="domain">(<a href="https://blog.sbensu.com">blog.sbensu.com</a>)</span></div><div class="subtext"><span>stopachka</span> | <span>88 comments</span></div><br/><div><div id="40966270" class="c"><input type="checkbox" id="c-40966270" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#40966001">next</a><span>|</span><label class="collapse" for="c-40966270">[-]</label><label class="expand" for="c-40966270">[1 more]</label></div><br/><div class="children"><div class="content">Sequence diagrames (that seems not much different swimlane diagrams) are great, so much so that I created a tool that generates them from appropriately built TLA+ specs representing message exchange scenarios: <a href="https:&#x2F;&#x2F;github.com&#x2F;eras&#x2F;tlsd">https:&#x2F;&#x2F;github.com&#x2F;eras&#x2F;tlsd</a><p>However, while they are good for <i>representing scenarios</i>, they are not that good for <i>specifying functionality</i>. You can easily represent the one golden path in the system, but if you need to start representing errors or diverging paths, you probably end up needing multiple diagrams, and if you need multiple diagrams, then how do you know if you have enough diagrams to fully specify the functionality?<p>&gt; The protocol is complicated enough for me to think that the diagrams are the source of truth of the protocol. In other words, I&#x27;d venture to say that if an implementation of the Double Rachet algorithm ever does something that doesn&#x27;t match the diagrams, it is more likely it is the code that is wrong than vice-versa.<p>I would believe the latter statement, but I wouldn&#x27;t say the first statement is that said in other words, so I don&#x27;t believe this is the correct conclusion.<p>My conclusion would be that diagrams are great way to visualize the truth of the protocol, but they are not a good way to be <i>the source of truth</i>: they should be generated from a more versatile (and formal) source truth.</div><br/></div></div><div id="40966001" class="c"><input type="checkbox" id="c-40966001" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#40966270">prev</a><span>|</span><a href="#40966188">next</a><span>|</span><label class="collapse" for="c-40966001">[-]</label><label class="expand" for="c-40966001">[10 more]</label></div><br/><div class="children"><div class="content">Far more important is instant feedback and that’s getting worse all the time: with lisp, smalltalk, Delphi, forth things were instant. With typescript or rust etc, if the project is larger than hello world, the feedback is well, far from instant. Bret victor talked about feedback, not necessarily visual programming and for some reason we are making things worse instead of better. When I show a Common Lisp dev session to young people, they think I am somehow cheating. I am, because I am not using the garbage people produce now and we are always faster (sbcl is incredible; sure you can do less latency and more performance with rust or c but then you don’t have the debugger and feedback while it takes a lot more code aka bugs and work), less bugs and not depressed while at work. We also don’t have to hire ‘devops’ to waste our profits; I like profits and I like not needing VCs.</div><br/><div id="40966150" class="c"><input type="checkbox" id="c-40966150" checked=""/><div class="controls bullet"><span class="by">ryandv</span><span>|</span><a href="#40966001">parent</a><span>|</span><a href="#40966069">next</a><span>|</span><label class="collapse" for="c-40966150">[-]</label><label class="expand" for="c-40966150">[3 more]</label></div><br/><div class="children"><div class="content">With strong, expressive type systems such as those offered by Haskell, Rust, TypeScript, etc... I find that you front-load all of your debugging to compile&#x2F;typecheck time. Instead of needing to experiment with your code at runtime through either manual or automated (TDD) tests, you are instead having a conversation with the compiler&#x2F;typechecker to statically guarantee its correctness. There&#x27;s just as tight a feedback loop with a typechecker as there is with a test runner; you in fact get your feedback even sooner during compile time, instead of during the subsequent runtime.<p>Where static verification against a typechecker shines over runtime verification against a test suite is that a test suite can only demonstrate the presence of bugs; type systems demonstrate their absence (presuming of course that you understand how to encode certain invariants into your types and don&#x27;t do some foolishness such as simply asserting all values as `any`).</div><br/><div id="40966200" class="c"><input type="checkbox" id="c-40966200" checked=""/><div class="controls bullet"><span class="by">aftoprokrustes</span><span>|</span><a href="#40966001">root</a><span>|</span><a href="#40966150">parent</a><span>|</span><a href="#40966212">next</a><span>|</span><label class="collapse" for="c-40966200">[-]</label><label class="expand" for="c-40966200">[1 more]</label></div><br/><div class="children"><div class="content">While I prefer expressive type systems by a long shot, I would be much more careful about it &quot;guaranteeing correctness&quot;.<p>Types can act as good documentation and as a safeguard for stupid mistakes. But the worst bugs are due to logic mistakes, wrong assumptions or non-foreseen corner cases. Here, either types do not help, or designing the type system is so difficult it is not worth the effort, and makes many future changes more difficult.<p>In my previous company we used Scala (with and without Spark) for everything, and this setup pretty much allows you both extremes. There was always a middle ground to be found, where types were expressive enough that they were useful, but not too much that they came in the way.</div><br/></div></div><div id="40966212" class="c"><input type="checkbox" id="c-40966212" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#40966001">root</a><span>|</span><a href="#40966150">parent</a><span>|</span><a href="#40966200">prev</a><span>|</span><a href="#40966069">next</a><span>|</span><label class="collapse" for="c-40966212">[-]</label><label class="expand" for="c-40966212">[1 more]</label></div><br/><div class="children"><div class="content">I am very much of eventual static typing and even proofs for some parts; cl is pretty good and we have a gradual type system in our company for cl. But it’s just faster and easier to build it first and add types later we found (our company is almost 40 years old now).</div><br/></div></div></div></div><div id="40966069" class="c"><input type="checkbox" id="c-40966069" checked=""/><div class="controls bullet"><span class="by">ta_1138</span><span>|</span><a href="#40966001">parent</a><span>|</span><a href="#40966150">prev</a><span>|</span><a href="#40966153">next</a><span>|</span><label class="collapse" for="c-40966069">[-]</label><label class="expand" for="c-40966069">[1 more]</label></div><br/><div class="children"><div class="content">As projects get bigger, things might get sadder. I worked at a certain large SF company that uses a lot of ruby, so most development was repl-based too. But this wasn&#x27;t a boon but a curse, as the total lack of data format guarantees on the very large, critical monorepo meant a lot of uncertainty. What does this method really do? I guess we have to run it! It worked for this specific input... but will it work for any and all inputs that get to this data path? Let&#x27;s hope so, because we aren&#x27;t sure! The company spent massive amounts of money on servers for parallel testing, just so that the suite could run in less than a few weeks. And when you need a large test suite to have a chance, most of the advantages of the REPL vs a compiler have been lost.<p>Eventually they did the same thing you can do in common lisp: Add so much metaprogramming that doublechecks invariants, it might as well be a compiled language.</div><br/></div></div><div id="40966153" class="c"><input type="checkbox" id="c-40966153" checked=""/><div class="controls bullet"><span class="by">FireInsight</span><span>|</span><a href="#40966001">parent</a><span>|</span><a href="#40966069">prev</a><span>|</span><a href="#40966205">next</a><span>|</span><label class="collapse" for="c-40966153">[-]</label><label class="expand" for="c-40966153">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what TypeScript projects you have worked on, but every one I have worked on is instant reload all the way down. Rust, on the other hand, is pretty miserable.</div><br/><div id="40966201" class="c"><input type="checkbox" id="c-40966201" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#40966001">root</a><span>|</span><a href="#40966153">parent</a><span>|</span><a href="#40966205">next</a><span>|</span><label class="collapse" for="c-40966201">[-]</label><label class="expand" for="c-40966201">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know; I am a programmer but more of a trouble shooter (it makes far more) and projects passing 100k LoC in ts which I see 100s a year, are not instant, in any way. I would love to see one, but I contribute to open source projects, and it’s all slow, very very slow.</div><br/></div></div></div></div><div id="40966205" class="c"><input type="checkbox" id="c-40966205" checked=""/><div class="controls bullet"><span class="by">ben_w</span><span>|</span><a href="#40966001">parent</a><span>|</span><a href="#40966153">prev</a><span>|</span><a href="#40966156">next</a><span>|</span><label class="collapse" for="c-40966205">[-]</label><label class="expand" for="c-40966205">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s also true, but not the thing they&#x27;re writing about.<p>My experience as an iOS developer has been mixed between places that use Interface Builder and those who create the UI in code. Something <i>like</i> Interface Builder is obviously a great idea for UI creation, which is why it survived so long and why Figma exists, but the actual tool itself isn&#x27;t really useful for desigers who want one thing that works on all platforms. (Complaints like &quot;xib and storyboard are hard to use with version control&quot; miss the point; a UI designer shouldn&#x27;t be seeing git-style text diffs anyway, they need a graphical diff).<p>Interface Builder is at least 5x faster than making the UI in code; one place in particular, I was making a native app by myself while a whole team was making a web app, and I wasn&#x27;t simply keeping up with them, I also cought up the headstart they had built while I&#x27;d been assigned to a different project. The next place I joined a team and their app was a coded UI, and development was correspondingly slow. (Though how much of this is &quot;teams are slower than solo developers&quot; vs. my hypothesis is unclear to me).<p>My first coding job was before iOS existed, I was industrial placement student in an academic research lab, and for that, my guess would be the best option mayhaps have been a mathematical formula WYSIWYG editor that output both latex and IDL.</div><br/></div></div><div id="40966156" class="c"><input type="checkbox" id="c-40966156" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40966001">parent</a><span>|</span><a href="#40966205">prev</a><span>|</span><a href="#40966188">next</a><span>|</span><label class="collapse" for="c-40966156">[-]</label><label class="expand" for="c-40966156">[2 more]</label></div><br/><div class="children"><div class="content">Typescript is pretty fast no? I&#x27;ve worked on the VSCode codebase a fair bit and the intellisense seems pretty fast. Like under a second, which is fine.<p>You don&#x27;t need to resort to Lisp to get instant feedback. Try Dart - it&#x27;s basically instant.<p>Rust I will give you...</div><br/><div id="40966224" class="c"><input type="checkbox" id="c-40966224" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#40966001">root</a><span>|</span><a href="#40966156">parent</a><span>|</span><a href="#40966188">next</a><span>|</span><label class="collapse" for="c-40966224">[-]</label><label class="expand" for="c-40966224">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I just prefer lisp. We use flutter a lot, but we do it in cl -&gt; dart; it makes everyone here (again taste, not gospel) happier.</div><br/></div></div></div></div></div></div><div id="40966188" class="c"><input type="checkbox" id="c-40966188" checked=""/><div class="controls bullet"><span class="by">d--b</span><span>|</span><a href="#40966001">prev</a><span>|</span><a href="#40966227">next</a><span>|</span><label class="collapse" for="c-40966188">[-]</label><label class="expand" for="c-40966188">[3 more]</label></div><br/><div class="children"><div class="content">&gt; One reason is because we think that other, more inexperienced, programmers might have an easier time with visual programming. If only code wasn&#x27;t as scary! If only it was visual! Excel Formula is the most popular programming language by a few orders of magnitude and it can look like this:<p>&gt; =INDEX(A1:A4,SMALL(IF(Active[A1:A4]=E$1,ROW(A1:A4)-1),ROW(1:1)),2)<p>Ahem. Excel is one of the most visual programming environment out there. Everything is laid out on giant 2d grids you can zoom in and out. You can paint arrows that give you the whole dependency tree. You can select, copy, paste, delete code with the mouse only. You can color things to help you categorize which cell does what. You can create user inputs, charts and pivot grids with clicks.</div><br/><div id="40966264" class="c"><input type="checkbox" id="c-40966264" checked=""/><div class="controls bullet"><span class="by">hnick</span><span>|</span><a href="#40966188">parent</a><span>|</span><a href="#40966257">next</a><span>|</span><label class="collapse" for="c-40966264">[-]</label><label class="expand" for="c-40966264">[1 more]</label></div><br/><div class="children"><div class="content">As a programmer who had used Excel for years, seeing my accountant start typing a formula, change sheets, select some cells, go back, repeat, was a learning process. I didn&#x27;t even know you could do that, and also, I hated it. But it worked very well for him.<p>I&#x27;ve more recently been exposed to a few spreadsheets that are used to calculate quotes in major insurance businesses when I was asked to create an online process instead, replicating the questions and formula.<p>They&#x27;re things of horrifying eldritch beauty. I seem to always find at least one error, and no one I&#x27;m allowed to talk to ever really knows how they work since they&#x27;re built up over years. Those dependency arrows are a life saver.</div><br/></div></div><div id="40966257" class="c"><input type="checkbox" id="c-40966257" checked=""/><div class="controls bullet"><span class="by">ambyra</span><span>|</span><a href="#40966188">parent</a><span>|</span><a href="#40966264">prev</a><span>|</span><a href="#40966227">next</a><span>|</span><label class="collapse" for="c-40966257">[-]</label><label class="expand" for="c-40966257">[1 more]</label></div><br/><div class="children"><div class="content">Excel could do this so much better though (and I think excel is the best candidate for visual scripting overhaul). The cell could have two parts; top parts is the function signature (other cells could reference by signature, or by cell number), bottom part is the code. Each cell is a function.<p>People put huge unreadable basic functions in that tiny box. It&#x27;s such an obvious pain point, surprised it&#x27;s never been addressed. Replace vba with c#, have a visual line linking cells to other cell references, bam million dollar product.</div><br/></div></div></div></div><div id="40966227" class="c"><input type="checkbox" id="c-40966227" checked=""/><div class="controls bullet"><span class="by">hnick</span><span>|</span><a href="#40966188">prev</a><span>|</span><a href="#40965329">next</a><span>|</span><label class="collapse" for="c-40966227">[-]</label><label class="expand" for="c-40966227">[1 more]</label></div><br/><div class="children"><div class="content">Most times in my career that I&#x27;ve seen people talking about visual programming, it&#x27;s not about the developers - it&#x27;s about lowering the bar so that (cheaper) non-developers can participate.<p>A Business Analyst may or may not have a coding background, but their specifications can be quite technical and logical and hopefully they understand the details. The assumption is that if we create our own Sufficiently Advanced Online Rule Engine they can just set it all up without involving the more expensive programmers.<p>This is discussed a bit in the first paragraph, but I just wanted to reiterate that most systems I had to deal with like this were talked about in terms of supplying business logic, rules, and control flow configuration to a pre-existing system or harness that executes that configuration. The &quot;real&quot; programmers work on that system, adding features, and code blocks for anything outside the specification, while the other staff setup the business logic.<p>It works to some degree. I think things like Zapier can be quite good for this crowd, and a lot of mailing list providers have visual workflow tools that let non-programmers do a lot. A DSL like Excel formulas would be in this group too, since it operates inside an existing application, except that it&#x27;s non-visual. Some document publishing tools like Exstream (I worked with it pre-HP, so years ago) did a lot in this space too.<p>I did read and appreciate the whole article, I just noticed this part for a reason - I&#x27;m working on a visual question builder again right now for a client who wants to edit their own customer application form on their custom coded website, instead of involving costly programmers. It always ended poorly in the past at my previous company, but maybe it&#x27;ll be different this time.</div><br/></div></div><div id="40965329" class="c"><input type="checkbox" id="c-40965329" checked=""/><div class="controls bullet"><span class="by">ejiblabahaba</span><span>|</span><a href="#40966227">prev</a><span>|</span><a href="#40964349">next</a><span>|</span><label class="collapse" for="c-40965329">[-]</label><label class="expand" for="c-40965329">[4 more]</label></div><br/><div class="children"><div class="content">As someone with a hardware background, I&#x27;ll throw in my $0.02. The schematic capture elements to connect up large blocks of HDL with a ton of I&#x2F;O going everywhere are one of the few applications of visual programming that I like. Once you get past defining the block behaviors in HDL, instantiation can become tedious and error-prone in text, since the tools all kinda suck with very little hinting or argument checking, and the modules can and regularly do have dozens of I&#x2F;O arguments. Instead, it&#x27;s often very easy to map the module inputs to schematic-level wires, particularly in situations where large buses can be combined into single fat lines, I&#x2F;O types can be visually distinguished, etc. IDE keyboard shortcuts also make these signals easy to follow and trace as they pass through hierarchical organization of blocks, all the way down to transistor-level implementations in many cases.<p>I&#x27;ve also always had an admiration for the Falstad circuit simulation tool[0], as the only SPICE-like simulator that visually depicts magnitude of voltages and currents during simulation (and not just on graphs). I reach for it once in a while when I need to do something a bit bigger than I can trivially fit in my head, but not so complex that I feel compelled to fight a more powerful but significantly shittier to work with IDE to extract an answer.<p>Schematics work really well for capturing information that&#x27;s independent of time, like physical connections or common simple functions (summers, comparators, etc). Diagrams with time included sacrifice a dimension to show sequential progress, which is fine for things that have very little changing state attached or where query&#x2F;response is highly predictable. Sometimes, animation helps restore the lost dimension for systems with time-evolution. But beyond trivial things that fit on an A4 sheet, I&#x27;d rather represent time-evolution of system state with timing diagrams. I don&#x27;t think there&#x27;s many analogous situations in typical programming applications that call for timing diagrams, but they are absolutely foundational for digital logic applications and low-level hardware drivers.<p>[0]: <a href="https:&#x2F;&#x2F;www.falstad.com&#x2F;circuit&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.falstad.com&#x2F;circuit&#x2F;</a></div><br/><div id="40965484" class="c"><input type="checkbox" id="c-40965484" checked=""/><div class="controls bullet"><span class="by">stefanpie</span><span>|</span><a href="#40965329">parent</a><span>|</span><a href="#40966136">next</a><span>|</span><label class="collapse" for="c-40965484">[-]</label><label class="expand" for="c-40965484">[1 more]</label></div><br/><div class="children"><div class="content">As much as I prefer to do everything in a text editor and use open-source EDA tools&#x2F;linters&#x2F;language servers, Xilinx&#x27;s Vivado deserves major credit from me for its block editor, schematic view, and implementation view.<p>For complex tasks like connecting AXI, SoC, memory, and custom IP components together, things like bussed wires and ports, as well as GUI configurators, make the process of getting something up and running on a real FPGA board much easier and quicker than if I had to do it all manually (of course, after I can dump the Tcl trace and move all that automation into reproducible source scripts).<p>I believe the biggest advantage of the Vivado block editor is the &quot;Run Block Automation&quot; flow that can quickly handle a lot of the wire connections and instantiation of required IPs when integrating an SoC block with modules. I think it would be interesting to explore if this idea could be successfully translated to other styles of visual programming. For example, I could place and connect a few core components and let the tooling handle the rest for me.<p>Also, a free idea (or I don&#x27;t know if it&#x27;s out there yet): an open-source HDL&#x2F;FPGA editor or editor extension with something like the Vivado block editor that works with all the open source EDA tools with all the same bells and whistles, including an IP library, programmable IP GUI configurators, bussed ports and connections, and block automation. You could even integrate different HDL front-ends as there are many more now than in the past. I know Icestudio is a thing, but that seems designed for educational use, which is also cool to see! I think a VSCode webview-based extension could be one easier way to prototype this.</div><br/></div></div><div id="40966136" class="c"><input type="checkbox" id="c-40966136" checked=""/><div class="controls bullet"><span class="by">bewo001</span><span>|</span><a href="#40965329">parent</a><span>|</span><a href="#40965484">prev</a><span>|</span><a href="#40965411">next</a><span>|</span><label class="collapse" for="c-40966136">[-]</label><label class="expand" for="c-40966136">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Schematics work really well for capturing information that&#x27;s independent of time, ..&quot; This spells out what always irked me about graphical software.</div><br/></div></div><div id="40965411" class="c"><input type="checkbox" id="c-40965411" checked=""/><div class="controls bullet"><span class="by">sbensu</span><span>|</span><a href="#40965329">parent</a><span>|</span><a href="#40966136">prev</a><span>|</span><a href="#40964349">next</a><span>|</span><label class="collapse" for="c-40965411">[-]</label><label class="expand" for="c-40965411">[1 more]</label></div><br/><div class="children"><div class="content">Amazing, thank you for taking the time</div><br/></div></div></div></div><div id="40964349" class="c"><input type="checkbox" id="c-40964349" checked=""/><div class="controls bullet"><span class="by">npunt</span><span>|</span><a href="#40965329">prev</a><span>|</span><a href="#40965448">next</a><span>|</span><label class="collapse" for="c-40964349">[-]</label><label class="expand" for="c-40964349">[3 more]</label></div><br/><div class="children"><div class="content">Great article. Any sufficiently complex problem requires looking at it from different angles in order to root out the unexpected and ambiguous. Visualizations do exactly that.<p>This is especially important in the age of AI coding tools and how coding is moving from lower level to higher level expression (with greater levels of ambiguity). One ideal use of AI coding tools would be to be on the lookout for ambiguities and outliers and draw the developer&#x27;s attention to them with relevant visualizations.<p>&gt; do you know exactly how your data is laid out in memory? Bad memory layouts are one of the biggest contributors to poor performance.<p>In this example from the article, if the developer indicates they need to improve performance or the AI evaluates the code and thinks its suboptimal, it could bring up a memory layout diagram to help the developer work through the problem.<p>&gt; Another very cool example is in the documentation for Signal&#x27;s Double Rachet algorithm. These diagrams track what Alice and Bob need at each step of the protocol to encrypt and decrypt the next message. The protocol is complicated enough for me to think that the diagrams are the source of truth of the protocol<p>This is the next step in visualizations: moving logic from raw code to expressions within the various visualizations. But we can only get there bottom-up, solving one particular problem, one method of visualization at a time. Past visual code efforts have all been top-down universal programming systems, which cannot look at things in all the different ways necessary to handle complexity.</div><br/><div id="40965382" class="c"><input type="checkbox" id="c-40965382" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#40964349">parent</a><span>|</span><a href="#40965448">next</a><span>|</span><label class="collapse" for="c-40965382">[-]</label><label class="expand" for="c-40965382">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Any sufficiently complex problem requires looking at it from different angles in order to root out the unexpected and ambiguous. Visualizations do exactly that.</i><p>To me, this is an underappreciated tenet of good visualization design.<p>Bad&#x2F;lazy visualizations show you what you already know, in prettier form.<p>Good visualizations give you a better understanding of things-you-don&#x27;t-know at the time of designing the visualization.<p>I.e. If I create a visualization using these rules, will I learn some new facts about the &quot;other stuff&quot;?</div><br/><div id="40965532" class="c"><input type="checkbox" id="c-40965532" checked=""/><div class="controls bullet"><span class="by">vanjajaja1</span><span>|</span><a href="#40964349">root</a><span>|</span><a href="#40965382">parent</a><span>|</span><a href="#40965448">next</a><span>|</span><label class="collapse" for="c-40965532">[-]</label><label class="expand" for="c-40965532">[1 more]</label></div><br/><div class="children"><div class="content">agreed, though bad&#x2F;lazy visualizations can still be useful for a cache. you know it today, but you might forget tomorrow</div><br/></div></div></div></div></div></div><div id="40965448" class="c"><input type="checkbox" id="c-40965448" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#40964349">prev</a><span>|</span><a href="#40964648">next</a><span>|</span><label class="collapse" for="c-40965448">[-]</label><label class="expand" for="c-40965448">[1 more]</label></div><br/><div class="children"><div class="content">The social problem with visual programming is indeed the same as with &quot;Mythical Non-Roboticist&quot;. But there is quite some issues on it on the technical side too:<p>- Any sufficiently advanced program has non-planar dataflow graph. Yes &quot;pipelines&quot; are fine, but anything beyond that - you are going to need labels. And with labels it becomes just like plain old non-visual program, just less structured.<p>- Code formatting becomes much more important and much harder to do. With textual program representation it is more or less trivial to do auto-formatting (and the code is somewhat readable ever with no formatting at all). Yet we still don&#x27;t have a reliable way to layout a non-trivial graph so that it doesn&#x27;t look like a spagetti bowl. I find UML state machines very useful and also painful because after every small edit I have to spend ten minutes fixing layout.<p>- Good data&#x2F;program entry interfaces are hard to design and novel tools rarely do a good job of it the first time. Most &quot;visual&quot; tools have a total disaster for a UI. Vs. text editors that were incrementally refined for some 70 years.</div><br/></div></div><div id="40964648" class="c"><input type="checkbox" id="c-40964648" checked=""/><div class="controls bullet"><span class="by">Harmohit</span><span>|</span><a href="#40965448">prev</a><span>|</span><a href="#40965877">next</a><span>|</span><label class="collapse" for="c-40964648">[-]</label><label class="expand" for="c-40964648">[14 more]</label></div><br/><div class="children"><div class="content">I am surprised I have not seen LabView mentioned in this thread. It is arguably one of the most popular visual programming languages after Excel and I absolutely hate it.<p>It has all the downsides of visual programming that the author mentions. The visual aspect of it makes it so hard to understand the flow of control. There is no clear left to right or top to bottom way of chronologically reading a program.</div><br/><div id="40964702" class="c"><input type="checkbox" id="c-40964702" checked=""/><div class="controls bullet"><span class="by">BobbyTables2</span><span>|</span><a href="#40964648">parent</a><span>|</span><a href="#40965050">next</a><span>|</span><label class="collapse" for="c-40964702">[-]</label><label class="expand" for="c-40964702">[2 more]</label></div><br/><div class="children"><div class="content">I agree.<p>LabView’s shining examples would be trivial Python scripts (aside from the GUI tweaking).     However, it’s runtime interactive 2D graph&#x2F;plot widgets are unequaled.<p>As soon as a “function” becomes slightly non trivial,  the graphical nature makes it hard to follow.<p>Structured data with the “weak typedef” is a minefield.<p>A simple program to solve a quadratic equation becomes an absolute mess when laid out graphically. Textually, it would be a simple 5-6 line function that is easy to read.<p>Source control is also a mess.  How does one “diff” a LabView program?</div><br/><div id="40965208" class="c"><input type="checkbox" id="c-40965208" checked=""/><div class="controls bullet"><span class="by">jki275</span><span>|</span><a href="#40964648">root</a><span>|</span><a href="#40964702">parent</a><span>|</span><a href="#40965050">next</a><span>|</span><label class="collapse" for="c-40965208">[-]</label><label class="expand" for="c-40965208">[1 more]</label></div><br/><div class="children"><div class="content">When I had some customers working with it a few years ago, they were trying to roll out a visual diff tool that would make source control possible.<p>I don&#x27;t know if they ever really delivered anything or not.  That system is such an abomination it drove me nuts dealing with it, and dealing with scientists who honestly believed it was the future of software engineering and all the rest of us were idiots for using C++.<p>The VIs are really nice, when you&#x27;re connecting them up to a piece of measurement hardware to collect data the system makes sense for that.  Anything further and it&#x27;s utter garbage.</div><br/></div></div></div></div><div id="40965050" class="c"><input type="checkbox" id="c-40965050" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#40964648">parent</a><span>|</span><a href="#40964702">prev</a><span>|</span><a href="#40964674">next</a><span>|</span><label class="collapse" for="c-40965050">[-]</label><label class="expand" for="c-40965050">[3 more]</label></div><br/><div class="children"><div class="content">Most industrial automation programming happens in an environment similar to
LabView, if not LabView itself.  DeltaV, Siemens, Allen-Bradley, etc.  Most industrial facilities are absolutely full of them with text-based code being likely a small minority for anything higher level than the firmware of individual PLCs and such.</div><br/><div id="40965241" class="c"><input type="checkbox" id="c-40965241" checked=""/><div class="controls bullet"><span class="by">ejiblabahaba</span><span>|</span><a href="#40964648">root</a><span>|</span><a href="#40965050">parent</a><span>|</span><a href="#40964674">next</a><span>|</span><label class="collapse" for="c-40965241">[-]</label><label class="expand" for="c-40965241">[2 more]</label></div><br/><div class="children"><div class="content">A lot of these environments inherit a visual presentation style (ladder logic) that comes from the pre-computer era, and that works extremely well for electrical schematics when conveying asynchronous conditional behaviors to anyone, even people without much of a math background. There&#x27;s a lot of more advanced functions these days that you write in plain C code in a hierarchical block, mostly for things like motor control.</div><br/><div id="40965490" class="c"><input type="checkbox" id="c-40965490" checked=""/><div class="controls bullet"><span class="by">applied_heat</span><span>|</span><a href="#40964648">root</a><span>|</span><a href="#40965241">parent</a><span>|</span><a href="#40964674">next</a><span>|</span><label class="collapse" for="c-40965490">[-]</label><label class="expand" for="c-40965490">[1 more]</label></div><br/><div class="children"><div class="content">I like function block on Schneider platform for
Process control with more analog values than Boolean. It visualizes  the inputs, control loop, and output nicely.<p>Numeric values in ladder feels a bit kludgey</div><br/></div></div></div></div></div></div><div id="40964674" class="c"><input type="checkbox" id="c-40964674" checked=""/><div class="controls bullet"><span class="by">etrautmann</span><span>|</span><a href="#40964648">parent</a><span>|</span><a href="#40965050">prev</a><span>|</span><a href="#40964976">next</a><span>|</span><label class="collapse" for="c-40964674">[-]</label><label class="expand" for="c-40964674">[2 more]</label></div><br/><div class="children"><div class="content">And Simulink. I lost years in grad school to Simulink, but it is very nice for complex state machine programming. It’s self documenting in that way. Just hope you don’t have to debug it because that’s a special hell.</div><br/><div id="40966169" class="c"><input type="checkbox" id="c-40966169" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40964648">root</a><span>|</span><a href="#40964674">parent</a><span>|</span><a href="#40964976">next</a><span>|</span><label class="collapse" for="c-40966169">[-]</label><label class="expand" for="c-40966169">[1 more]</label></div><br/><div class="children"><div class="content">I quite like Simulink because it&#x27;s designed for simulating physical systems which are naturally quite visual and bidirectional. Like circuit diagrams, pneumatics, engines, etc. You aren&#x27;t writing for loops.<p>Also it is actually visually decent unlike LabVIEW which looks like it was drawn by someone who discovered MS Paint EGA edition.</div><br/></div></div></div></div><div id="40964976" class="c"><input type="checkbox" id="c-40964976" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#40964648">parent</a><span>|</span><a href="#40964674">prev</a><span>|</span><a href="#40965118">next</a><span>|</span><label class="collapse" for="c-40964976">[-]</label><label class="expand" for="c-40964976">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly why a visual representation of code can be useful for analyzing certain things, but will rarely be the best (or even preferred) way to write code.<p>I think a happy medium would be an environment where you could easily switch between &quot;code&quot; and &quot;visual&quot; view, and maybe even make changes within each, but I suspect developers will stick with &quot;code&quot; view most of the time.<p>Also, from the article:
&gt; Developers say they want &quot;visual programming&quot;<p>I certainly don&#x27;t. What I <i>do</i> want is an IDE which has a better view into my entire project, including all the files, images, DB, etc., so it can make much better informed suggestions. Kind of like JetBrains on steroids, but with better built-in error checking and autocomplete suggestions. I want the ability to move a chunk of code somewhere else, and have the IDE warn me (or even fix the problem) when the code I move now references out-of-scope variables. In short, I want the IDE to handle most of the grunt work, so I can concentrate on the bigger picture.</div><br/></div></div><div id="40965118" class="c"><input type="checkbox" id="c-40965118" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#40964648">parent</a><span>|</span><a href="#40964976">prev</a><span>|</span><a href="#40965568">next</a><span>|</span><label class="collapse" for="c-40965118">[-]</label><label class="expand" for="c-40965118">[2 more]</label></div><br/><div class="children"><div class="content">I think the whole flow concept is really only good for media pipelines and such.<p>In mathematics, everything exists at once just like real life.<p>In most programming languages, things happen in explicit discrete steps which makes things a lot easier, and most node based systems don&#x27;t have that property.<p>I greatly prefer block based programming where you&#x27;re dragging rules and command blocks that work like traditional programming, but with higher level functions, ease of use on mobile, and no need to memorize all the API call names just for a one off tasks.</div><br/><div id="40965336" class="c"><input type="checkbox" id="c-40965336" checked=""/><div class="controls bullet"><span class="by">ocschwar</span><span>|</span><a href="#40964648">root</a><span>|</span><a href="#40965118">parent</a><span>|</span><a href="#40965568">next</a><span>|</span><label class="collapse" for="c-40965336">[-]</label><label class="expand" for="c-40965336">[1 more]</label></div><br/><div class="children"><div class="content">What would be useful is a data flow representation of the call stack of a piece of code. Generated from source, and then brought back from the GUI into source.</div><br/></div></div></div></div><div id="40965568" class="c"><input type="checkbox" id="c-40965568" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#40964648">parent</a><span>|</span><a href="#40965118">prev</a><span>|</span><a href="#40965877">next</a><span>|</span><label class="collapse" for="c-40965568">[-]</label><label class="expand" for="c-40965568">[3 more]</label></div><br/><div class="children"><div class="content">I still have to find somebody who worked with LabView that does not hate it.<p>It is a total abomination.</div><br/><div id="40965751" class="c"><input type="checkbox" id="c-40965751" checked=""/><div class="controls bullet"><span class="by">bboygravity</span><span>|</span><a href="#40964648">root</a><span>|</span><a href="#40965568">parent</a><span>|</span><a href="#40966074">next</a><span>|</span><label class="collapse" for="c-40965751">[-]</label><label class="expand" for="c-40965751">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t hate it, I feel it&#x27;s pretty good for talking to hardware, (understanding) multi-threading, agent oriented programming, message cues, etc.<p>It&#x27;s also fairly good for making money: the oil and gass industry seems to like using it (note: n = 1, I only did one oil n gas project with it).</div><br/></div></div><div id="40966074" class="c"><input type="checkbox" id="c-40966074" checked=""/><div class="controls bullet"><span class="by">InvisibleUp</span><span>|</span><a href="#40964648">root</a><span>|</span><a href="#40965568">parent</a><span>|</span><a href="#40965751">prev</a><span>|</span><a href="#40965877">next</a><span>|</span><label class="collapse" for="c-40966074">[-]</label><label class="expand" for="c-40966074">[1 more]</label></div><br/><div class="children"><div class="content">As someone who used to use (and hate) LabVIEW, a lot of my hatred towards it was directed at the truly abysmal IDE. The actual language itself has a lot of neat features, especially for data visualization and highly parallel tasks.</div><br/></div></div></div></div></div></div><div id="40965877" class="c"><input type="checkbox" id="c-40965877" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#40964648">prev</a><span>|</span><a href="#40964731">next</a><span>|</span><label class="collapse" for="c-40965877">[-]</label><label class="expand" for="c-40965877">[1 more]</label></div><br/><div class="children"><div class="content">I think people get too hung up on the visuals. There was a (failed) attempt to create something called intentional programming by Charles Simonyi. That happened in the middle of the model driven architecture craziness about 20 years ago.<p>In short, his ideas was to build a language where higher level primitives are created by doing transformations on lower level syntax trees. All the way down to assembly code. The idea would be that you would define languages in terms of how they manipulate existing syntax trees. Kind of a neat concept. And well suited to visual programming as well.<p>Weather you build that syntax tree by typing code in an editor or by manipulating things in a visual tool is beside the point. It all boils down to syntax trees.<p>Of course that never happened and MDA also fizzled out along with all the UML meta programming stuff. Meta programming itself is of course an old idea (e.g. Lisp) and still lives on in things like Ruby and a few other things.<p>But more useful in modern times is how refactoring IDEs work: they build syntax trees of your code and then transform them, hopefully without making the code invalid. Like a compiler, an IDE needs an internal representation of your code as a syntax tree in order to do these things. You only get so far with regular expressions and trying to rename things. But lately, compiler builders are catching onto the notion that good tools and good compilers need to share some logic. That too is an old idea (Smalltalk and IBM&#x27;s Visual Age). But it&#x27;s being re-discoverd in e.g. the Rust community and of course Kotlin is trying to get better as well (being developed by Jetbrains and all).<p>But beyond that, the idea seems a bit stuck. Too bad because I like the notion of programs being manipulated by programs. Which is what refactoring does. And which is what AI also needs to learn to do to become truly useful for programming.</div><br/></div></div><div id="40964731" class="c"><input type="checkbox" id="c-40964731" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#40965877">prev</a><span>|</span><a href="#40966174">next</a><span>|</span><label class="collapse" for="c-40964731">[-]</label><label class="expand" for="c-40964731">[11 more]</label></div><br/><div class="children"><div class="content">Anyone who mentions visual scripting without mentioning the game industry just hasn&#x27;t done enough research at all.  Its actually a really elegant way to handle transforming data.<p>Look up Unreal blueprints, shader graphs, procedural model generation in blender or Houdini.  Visual programming is already here and quite popular.</div><br/><div id="40964786" class="c"><input type="checkbox" id="c-40964786" checked=""/><div class="controls bullet"><span class="by">sbensu</span><span>|</span><a href="#40964731">parent</a><span>|</span><a href="#40965194">next</a><span>|</span><label class="collapse" for="c-40964786">[-]</label><label class="expand" for="c-40964786">[7 more]</label></div><br/><div class="children"><div class="content">[post author] I am familiar with those and have used a couple. There are similar examples in music, where visual programming dominates.<p>The implied audience of this post (not clear) is people writing business applications, web dev, etc. The examples are picked to reflect what could be useful to those developers. In other words, all the examples you mentioned are great but they are not how a &quot;software engineer in a software company&quot; does their job.</div><br/><div id="40964812" class="c"><input type="checkbox" id="c-40964812" checked=""/><div class="controls bullet"><span class="by">felixgallo</span><span>|</span><a href="#40964731">root</a><span>|</span><a href="#40964786">parent</a><span>|</span><a href="#40965194">next</a><span>|</span><label class="collapse" for="c-40964812">[-]</label><label class="expand" for="c-40964812">[6 more]</label></div><br/><div class="children"><div class="content">game developers are definitely software engineers in software companies.</div><br/><div id="40964934" class="c"><input type="checkbox" id="c-40964934" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#40964731">root</a><span>|</span><a href="#40964812">parent</a><span>|</span><a href="#40964870">next</a><span>|</span><label class="collapse" for="c-40964934">[-]</label><label class="expand" for="c-40964934">[4 more]</label></div><br/><div class="children"><div class="content">My experience is that the software engineers at game companies generally hate the visual programming tools. They want to work with code. It&#x27;s the game designers who (sometimes) like using visual tools.</div><br/><div id="40964978" class="c"><input type="checkbox" id="c-40964978" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#40964731">root</a><span>|</span><a href="#40964934">parent</a><span>|</span><a href="#40964870">next</a><span>|</span><label class="collapse" for="c-40964978">[-]</label><label class="expand" for="c-40964978">[3 more]</label></div><br/><div class="children"><div class="content">Some are bad but Blueprints is great.  Main issue is they don&#x27;t always play nice with text based coding tools.</div><br/><div id="40965873" class="c"><input type="checkbox" id="c-40965873" checked=""/><div class="controls bullet"><span class="by">voidUpdate</span><span>|</span><a href="#40964731">root</a><span>|</span><a href="#40964978">parent</a><span>|</span><a href="#40966050">next</a><span>|</span><label class="collapse" for="c-40965873">[-]</label><label class="expand" for="c-40965873">[1 more]</label></div><br/><div class="children"><div class="content">I spent about a year working with blueprints a while back and I found some things just really annoying. like making the execution line go backwards into the a previous block. if you do it straight there, it wont let you, if you use a single reroute note you get an ugly point, so you have to use two reroute nodes to get it to work properly and nicely. Also they don&#x27;t have all the nodes you need so you end up having to write some new ones anyway</div><br/></div></div><div id="40966050" class="c"><input type="checkbox" id="c-40966050" checked=""/><div class="controls bullet"><span class="by">amonith</span><span>|</span><a href="#40964731">root</a><span>|</span><a href="#40964978">parent</a><span>|</span><a href="#40965873">prev</a><span>|</span><a href="#40964870">next</a><span>|</span><label class="collapse" for="c-40966050">[-]</label><label class="expand" for="c-40966050">[1 more]</label></div><br/><div class="children"><div class="content">And AI - which kind of changed the game in the recent years.
A &quot;blueprints copilot&quot; akin to Github Copilot will be very difficult to create because there&#x27;s no &quot;blueprints text&quot; to train an AI on.
Nowadays in my hobby pet projects I find it easier to write C++ with copilot than Blueprints.</div><br/></div></div></div></div></div></div><div id="40964870" class="c"><input type="checkbox" id="c-40964870" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#40964731">root</a><span>|</span><a href="#40964812">parent</a><span>|</span><a href="#40964934">prev</a><span>|</span><a href="#40965194">next</a><span>|</span><label class="collapse" for="c-40964870">[-]</label><label class="expand" for="c-40964870">[1 more]</label></div><br/><div class="children"><div class="content">Of course, but you know what they&#x27;re saying.</div><br/></div></div></div></div></div></div><div id="40965194" class="c"><input type="checkbox" id="c-40965194" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#40964731">parent</a><span>|</span><a href="#40964786">prev</a><span>|</span><a href="#40966176">next</a><span>|</span><label class="collapse" for="c-40965194">[-]</label><label class="expand" for="c-40965194">[1 more]</label></div><br/><div class="children"><div class="content">As someone who works for games, I think the biggest problem of node-based systems is... they&#x27;re all different (in terms of UI&#x2F;UX).<p>Unreal blueprints, Substance Designer, Houdini, Blender&#x27;s geometry node, Unity shader nodes... they all look different and act differently. Different shortcuts and gestures. Different window&#x2F;panel management.<p>Different programming languages have different syntax rules and libraries, of course. But at least they&#x27;re all manipulated with one single interface, which is your editor. If you use vim binding, you don&#x27;t need to worry about &quot;what pressing K does&quot;. It moves the cursor down for all the languages.<p>People who spent X hours customizing their vim&#x2F;emacs will benefit from them no matter what language they use next. I spent a lot of time customizing my Houdini keybindings and scripts, and this effort will be thrown out the window if I later switch to Blender.</div><br/></div></div><div id="40966176" class="c"><input type="checkbox" id="c-40966176" checked=""/><div class="controls bullet"><span class="by">leovingi</span><span>|</span><a href="#40964731">parent</a><span>|</span><a href="#40965194">prev</a><span>|</span><a href="#40964800">next</a><span>|</span><label class="collapse" for="c-40966176">[-]</label><label class="expand" for="c-40966176">[1 more]</label></div><br/><div class="children"><div class="content">One could even go further and expand this to the players themselves, as there are certain games that might be viewed as visual programming tools. Factorio is a great example, as, conceptually speaking, there isn&#x27;t much of a difference between a player optimising their resource flow in the game vs a developer managing the data flow in a State Machine.</div><br/></div></div><div id="40964800" class="c"><input type="checkbox" id="c-40964800" checked=""/><div class="controls bullet"><span class="by">padolsey</span><span>|</span><a href="#40964731">parent</a><span>|</span><a href="#40966176">prev</a><span>|</span><a href="#40966174">next</a><span>|</span><label class="collapse" for="c-40964800">[-]</label><label class="expand" for="c-40964800">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using ComfyUI recently to manage complex image diffusion workflows, and I had no idea it was inherited from much older shader editors and vfx. It&#x27;s a shame we can end up using a tool for years without knowing anything about its predecessors.</div><br/></div></div></div></div><div id="40966174" class="c"><input type="checkbox" id="c-40966174" checked=""/><div class="controls bullet"><span class="by">brontosaurusrex</span><span>|</span><a href="#40964731">prev</a><span>|</span><a href="#40965950">next</a><span>|</span><label class="collapse" for="c-40966174">[-]</label><label class="expand" for="c-40966174">[1 more]</label></div><br/><div class="children"><div class="content">Two domain focused examples:
Blender material node: I could imagine certain material nodes to be highly annoying to script (or even represented differently than nodes), even something relatively simple like this  
<a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;kETcJYE.png" rel="nofollow">https:&#x2F;&#x2F;i.imgur.com&#x2F;kETcJYE.png</a> (nodes), 
<a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;eddAhcv.png" rel="nofollow">https:&#x2F;&#x2F;i.imgur.com&#x2F;eddAhcv.png</a> (final render)  
Fusion comp node: On the other hand, this seems like a lot of blocks for this simple image:
<a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;ftfHngt.png" rel="nofollow">https:&#x2F;&#x2F;i.imgur.com&#x2F;ftfHngt.png</a>
(Cool thing about Fusion is that any node can be copy&#x2F;pasted to notepad as text and vise-versa)
Note: I&#x27;am neither Blender nor Fusion expert.</div><br/></div></div><div id="40965950" class="c"><input type="checkbox" id="c-40965950" checked=""/><div class="controls bullet"><span class="by">socketcluster</span><span>|</span><a href="#40966174">prev</a><span>|</span><a href="#40966071">next</a><span>|</span><label class="collapse" for="c-40965950">[-]</label><label class="expand" for="c-40965950">[1 more]</label></div><br/><div class="children"><div class="content">The problem with most visual programming is that most platforms avoid making any tradeoffs.<p>A good visual programming tool should abstract away complexity  but it can only achieve that by reducing flexibility.<p>If you&#x27;re going to give people a visual tool that is as complex as code itself, people might as well learn to code.<p>It helps to focus on a set of use cases and abstract away from common, complicated, error-prone, critical functionality such as authentication, access control, filtering, schema definition and validation. All this stuff can be greatly simplified with a restrictive UI which simultaneously does the job and prevents people from shooting themselves in the foot.<p>You need to weed out unnecessary complexity; give people exactly the right amount of rope to achieve a certain set of possible goals, but not enough rope for them to hang themselves.<p>I&#x27;ve been working towards this with <a href="https:&#x2F;&#x2F;saasufy.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;saasufy.com&#x2F;</a><p>I&#x27;ve chosen to focus on CRUD apps. The goal is to push CRUD to its absolute maximum with auth, access control and real time data sync.<p>So far it&#x27;s at a point that you can build complex apps using only HTML tags. Next phase would be to support generating and editing the HTML tags via a friendly drag and drop UI.<p>Still, it&#x27;s for building front ends. It cannot and will never aim to be used to build stuff like data processing pipelines or for analytics. You&#x27;ll need to run it alongside other services to get that functionality.</div><br/></div></div><div id="40966071" class="c"><input type="checkbox" id="c-40966071" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#40965950">prev</a><span>|</span><a href="#40966045">next</a><span>|</span><label class="collapse" for="c-40966071">[-]</label><label class="expand" for="c-40966071">[1 more]</label></div><br/><div class="children"><div class="content">For me this is a class of “super-linter” - and potentially a unit test<p>If (if!) you can extract the diagram (or better the graphviz representation of the diagram) from the code, then you immediately have a test that says “hang on you chnaged the code so it no longer reflects the agreed diagram - that seems like a test fail to me”<p>This is not to dismiss the article - it’s fantastic and I want all of those capabilities now.  It’s just to emphasise (as the article does) that in almost no cases is this visual first - it’s code first</div><br/></div></div><div id="40966045" class="c"><input type="checkbox" id="c-40966045" checked=""/><div class="controls bullet"><span class="by">tofflos</span><span>|</span><a href="#40966071">prev</a><span>|</span><a href="#40965757">next</a><span>|</span><label class="collapse" for="c-40966045">[-]</label><label class="expand" for="c-40966045">[1 more]</label></div><br/><div class="children"><div class="content">Check out Spring Modulith at <a href="https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-modulith&#x2F;docs&#x2F;current-SNAPSHOT&#x2F;reference&#x2F;html&#x2F;#documentation" rel="nofollow">https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-modulith&#x2F;docs&#x2F;current-SNAPSHOT...</a>. Their pitch is that the application framework organizes your code in such a way that it makes the architecture of your application easier to visualize and to reason about. I haven&#x27;t tried it but have seen some talks on Youtube that makes we want to give it a shot in the future.</div><br/></div></div><div id="40965757" class="c"><input type="checkbox" id="c-40965757" checked=""/><div class="controls bullet"><span class="by">aetherspawn</span><span>|</span><a href="#40966045">prev</a><span>|</span><a href="#40964348">next</a><span>|</span><label class="collapse" for="c-40965757">[-]</label><label class="expand" for="c-40965757">[1 more]</label></div><br/><div class="children"><div class="content">Virtually everything safety critical (cars, planes, biomedical..) uses Simulink which is not shown or mentioned by this post and it works fine for very large apps.</div><br/></div></div><div id="40964348" class="c"><input type="checkbox" id="c-40964348" checked=""/><div class="controls bullet"><span class="by">twelvechairs</span><span>|</span><a href="#40965757">prev</a><span>|</span><a href="#40964496">next</a><span>|</span><label class="collapse" for="c-40964348">[-]</label><label class="expand" for="c-40964348">[8 more]</label></div><br/><div class="children"><div class="content">Most of this isn&#x27;t visual &quot;programming&quot; just good explanatory diagrams. I think it gets to a core issue which is a dichotomy between:<p>- trying to understand existing programs - for which visuals are wanted by most but they usually need concious input to be their best<p>- programming (creating new code) itself - where the efficiency of the keyboard (with its 1d input that goes straight to spaghetti code)  has never been replaced by visual (mouse based?) methods other than for very simple (click and connect) type models</div><br/><div id="40965686" class="c"><input type="checkbox" id="c-40965686" checked=""/><div class="controls bullet"><span class="by">airbreather</span><span>|</span><a href="#40964348">parent</a><span>|</span><a href="#40964797">next</a><span>|</span><label class="collapse" for="c-40965686">[-]</label><label class="expand" for="c-40965686">[1 more]</label></div><br/><div class="children"><div class="content">Yes, in order to be visual coding (or better yet specification) it needs to be executable in it&#x27;s native form, or maybe a very direct translation.<p>The concept of an executable specification first came to my attention in IEC 61499 the standard for Distributed Automation. First published in 2005 it was way, way ahead of it&#x27;s time, so far ahead it is still gaining traction today.<p>Shout out to anyone reading who was involved in the creation of IEC 61499 in 2005, it was a stroke of genius, and for it&#x27;s time, orders of magnitude more so. It is also worth a look just to prompt thinking for any one involved in distributed systems of any kind.<p>Initially I thought there was no way you could have such a thing as an executable specification, but then, over many years I evolved to a place where I could generically create an arbitrary executable specification for state based behavior (see my other post this topic).<p>I believe I have found the best achievable practice to allow defining behaviors for mission&#x2F;safety critical functionality, while avoiding implicit state.</div><br/></div></div><div id="40964797" class="c"><input type="checkbox" id="c-40964797" checked=""/><div class="controls bullet"><span class="by">sbensu</span><span>|</span><a href="#40964348">parent</a><span>|</span><a href="#40965686">prev</a><span>|</span><a href="#40964496">next</a><span>|</span><label class="collapse" for="c-40964797">[-]</label><label class="expand" for="c-40964797">[6 more]</label></div><br/><div class="children"><div class="content">You are right. The diagrams are used as explanations not as the source of the program. But wouldn&#x27;t it be neat if when you sketch out the state transition in a diagram (how I think about the state transitions), _that diagram_ was the source of truth for the program?<p>That is the implied point: let&#x27;s go to places where we already draw diagrams and check if we can elevate them into the program</div><br/><div id="40965024" class="c"><input type="checkbox" id="c-40965024" checked=""/><div class="controls bullet"><span class="by">charleslmunger</span><span>|</span><a href="#40964348">root</a><span>|</span><a href="#40964797">parent</a><span>|</span><a href="#40964999">next</a><span>|</span><label class="collapse" for="c-40965024">[-]</label><label class="expand" for="c-40965024">[3 more]</label></div><br/><div class="children"><div class="content">This can be really tricky to do. I reached the limit of my brain&#x27;s working capacity designing a priority inheritance system, and sketched the state machine out in a dot file, visualized with graphviz - this worked really well for reasoning through the correctness of the algorithm and explaining it to others. I tried to structure the implementation code to match it and I was able to get pretty close; but the actual states were a bunch of bit-packing and duplicated control flow to get optimal assembly output for the hottest paths. Each one of those changes was easy to reason about as an isolated correct transformation of the original structure in code, but would have been a mess visually.</div><br/><div id="40965371" class="c"><input type="checkbox" id="c-40965371" checked=""/><div class="controls bullet"><span class="by">sbensu</span><span>|</span><a href="#40964348">root</a><span>|</span><a href="#40965024">parent</a><span>|</span><a href="#40964999">next</a><span>|</span><label class="collapse" for="c-40965371">[-]</label><label class="expand" for="c-40965371">[2 more]</label></div><br/><div class="children"><div class="content">That sounds super interesting!<p>Did I understand correctly that the additional complexity came because you needed to emit optimal assembly? Or was implementing the logic from the state machine complicated enough?</div><br/><div id="40965940" class="c"><input type="checkbox" id="c-40965940" checked=""/><div class="controls bullet"><span class="by">charleslmunger</span><span>|</span><a href="#40964348">root</a><span>|</span><a href="#40965371">parent</a><span>|</span><a href="#40964999">next</a><span>|</span><label class="collapse" for="c-40965940">[-]</label><label class="expand" for="c-40965940">[1 more]</label></div><br/><div class="children"><div class="content">Designing the state machine was hard. The implementation of that state machine was not that bad, because I&#x27;d spent so much time thinking through the algorithm that I was able to implement it pretty quickly. The implementation difficulty was optimizing the uncontended case - I had to do things like duplicate code outside the main CAS loop to allow that to be inlined separately from the main body, structure functions so that the unlock path used the same or fewer stack bytes than the lock path, etc. Each of those code changes were straightforward but if I had faithfully copied all those the little tweaks into the state machine diagram, it would be so obfuscated that it&#x27;d hide any bugs in the actual core logic.<p>So I decided that the diagram was most useful for someone looking to understand the algorithm in the abstract, and only once they had been convinced of its correctness should they proceed to review the implementation code. The code was a terrible way to understand the algorithm, and the visualization was a terrible way to understand the implementation.</div><br/></div></div></div></div></div></div><div id="40964999" class="c"><input type="checkbox" id="c-40964999" checked=""/><div class="controls bullet"><span class="by">learn_more</span><span>|</span><a href="#40964348">root</a><span>|</span><a href="#40964797">parent</a><span>|</span><a href="#40965024">prev</a><span>|</span><a href="#40964496">next</a><span>|</span><label class="collapse" for="c-40964999">[-]</label><label class="expand" for="c-40964999">[2 more]</label></div><br/><div class="children"><div class="content">You might be interested in:<p><a href="https:&#x2F;&#x2F;schematix.com&#x2F;video&#x2F;depmap" rel="nofollow">https:&#x2F;&#x2F;schematix.com&#x2F;video&#x2F;depmap</a><p>I&#x27;m the founder.  It&#x27;s a tool for interacting with deployment diagrams like you mentioned in your article.<p>We have customers who also model state machines and generate code from the diagrams.</div><br/><div id="40965597" class="c"><input type="checkbox" id="c-40965597" checked=""/><div class="controls bullet"><span class="by">transpute</span><span>|</span><a href="#40964348">root</a><span>|</span><a href="#40964999">parent</a><span>|</span><a href="#40964496">next</a><span>|</span><label class="collapse" for="c-40965597">[-]</label><label class="expand" for="c-40965597">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Schematix provides diagrams as a dynamic resource using its API. They aren&#x27;t images you export, they don&#x27;t end up in My Documents. This isn&#x27;t Corel Draw. In Schematix, you specify part of your model using a graph expression, and the system automatically generates a diagram of the objects and relations that match. As your Schematix model changes, the results of the graph expression may change, and thus the visual diagram will also change. But the system doesn&#x27;t need you to point and click for it. Once you&#x27;ve told it what you want, you&#x27;re done.</i><p>What an interesting tool! It&#x27;s rare to see robust data models, flexible UX abstractions for dev + ops, lightweight process notations, programmatic inventory, live API dashboards and a multi-browser web client in one product.<p>Do you have commercial competitors? If not, it might be worth doing a blog post and&#x2F;or Show HN on OSS tooling (e.g Netbox inventory, netflow analysis of service dependencies) which offer a subset of Schematix, to help potential customers understand what you&#x27;ve accomplished.<p>Operational risk management consultants in the finance sector could benefit from Schematix, <a href="https:&#x2F;&#x2F;www.mckinsey.com&#x2F;capabilities&#x2F;risk-and-resilience&#x2F;our-insights&#x2F;the-future-of-operational-risk-management-in-financial-services" rel="nofollow">https:&#x2F;&#x2F;www.mckinsey.com&#x2F;capabilities&#x2F;risk-and-resilience&#x2F;ou...</a>.  Lots of complexity and data for neutral visualization tooling.</div><br/></div></div></div></div></div></div></div></div><div id="40964496" class="c"><input type="checkbox" id="c-40964496" checked=""/><div class="controls bullet"><span class="by">LeonB</span><span>|</span><a href="#40964348">prev</a><span>|</span><a href="#40965330">next</a><span>|</span><label class="collapse" for="c-40964496">[-]</label><label class="expand" for="c-40964496">[4 more]</label></div><br/><div class="children"><div class="content">Programming “via” Visualization — doesn’t scale. Great for demos. Good in limited places.<p>Visualizations “of” a Program — quite useful. Note there lots of different ways to visualize the same program to emphasise &#x2F; omit different details. The map is not the territory, all models are wrong etc.</div><br/><div id="40964775" class="c"><input type="checkbox" id="c-40964775" checked=""/><div class="controls bullet"><span class="by">astromaniak</span><span>|</span><a href="#40964496">parent</a><span>|</span><a href="#40965330">next</a><span>|</span><label class="collapse" for="c-40964775">[-]</label><label class="expand" for="c-40964775">[3 more]</label></div><br/><div class="children"><div class="content">It works and even scales up in some cases.<p>For example having models of capacitor and resistor you can put them together in schematic. Which in turn can be a part of the bigger design. Then test it in simulator. That&#x27;s how Simplorer works. Alternatively you can write the code in VHDL or Modelica. But visual is quicker, easier, and more reliable.<p>Obviously it works well for UI, was used for decades now.<p>As for the rest,... there are visual programmers for robots, mostly for kids.</div><br/><div id="40965223" class="c"><input type="checkbox" id="c-40965223" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#40964496">root</a><span>|</span><a href="#40964775">parent</a><span>|</span><a href="#40965330">next</a><span>|</span><label class="collapse" for="c-40965223">[-]</label><label class="expand" for="c-40965223">[2 more]</label></div><br/><div class="children"><div class="content">Schematics don&#x27;t scale well at all - net labels and multiple sheets demonstrate this.<p>HDLs rule for gate and transistor level circuit design. I don&#x27;t know what major PCB houses do but I&#x27;d be horrified to discover that 16-layer boards still have a visually built schematic producing their netlist: just finding the right pad on 256BGA components would be awful, let alone finding what else is connected to that net.</div><br/><div id="40965250" class="c"><input type="checkbox" id="c-40965250" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40964496">root</a><span>|</span><a href="#40965223">parent</a><span>|</span><a href="#40965330">next</a><span>|</span><label class="collapse" for="c-40965250">[-]</label><label class="expand" for="c-40965250">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Schematics don&#x27;t scale well at all<p>Schematics aren&#x27;t supposed to scale. They&#x27;re a lossy representation of a subcircuit without caring about the intricate details like footprints or electrical&#x2F;electro-mechanic constraints.<p>PCB designers largely don&#x27;t use HDLs because they don&#x27;t really solve their problems. Splitting a BGA component into subcircuits that have easily legible schematics is not hard, but it&#x27;s also not what they care about. That shit is easy, making sure the blocks are all connected correctly.<p>Verifying the electrical constraints of the 256 pad component is much harder and not represented in the schematic at all. They need to see the traces and footprint exactly.<p>As an example, the schematic doesn&#x27;t tell you if a naive designer put the silkscreen label and orientation marker underneath the component which will cause manufacturing defects like tombstoning in jellybean parts.</div><br/></div></div></div></div></div></div></div></div><div id="40965330" class="c"><input type="checkbox" id="c-40965330" checked=""/><div class="controls bullet"><span class="by">openrisk</span><span>|</span><a href="#40964496">prev</a><span>|</span><a href="#40966068">next</a><span>|</span><label class="collapse" for="c-40965330">[-]</label><label class="expand" for="c-40965330">[2 more]</label></div><br/><div class="children"><div class="content">Scratch seems to be reasonably successful in teaching kids to code [1].<p>But a large visual blocks program is as incomprehensible, if not more, than a pure textual representation.<p>Whether text or visual, the challenge for IDE&#x27;s is the ability to hide detail of large codebases in a way that still preserves the essential logic <i>and allows modifying it</i>. Folding&#x2F;unfolding code blocks is the primary available tool but its only a primitive way to reduce visual clutter, not a new visual abstraction that can stand on its own.<p>[1] <a href="https:&#x2F;&#x2F;scratch.mit.edu&#x2F;projects&#x2F;editor&#x2F;?tutorial=all" rel="nofollow">https:&#x2F;&#x2F;scratch.mit.edu&#x2F;projects&#x2F;editor&#x2F;?tutorial=all</a></div><br/><div id="40965738" class="c"><input type="checkbox" id="c-40965738" checked=""/><div class="controls bullet"><span class="by">jay_kyburz</span><span>|</span><a href="#40965330">parent</a><span>|</span><a href="#40966068">next</a><span>|</span><label class="collapse" for="c-40965738">[-]</label><label class="expand" for="c-40965738">[1 more]</label></div><br/><div class="children"><div class="content">I think scratch with a little more structure and lots of keyboard shortcuts would work for a &quot;real&quot; language.<p>It&#x27;s really just replacing indentation with blocks of color.</div><br/></div></div></div></div><div id="40966068" class="c"><input type="checkbox" id="c-40966068" checked=""/><div class="controls bullet"><span class="by">benrutter</span><span>|</span><a href="#40965330">prev</a><span>|</span><a href="#40966206">next</a><span>|</span><label class="collapse" for="c-40966068">[-]</label><label class="expand" for="c-40966068">[1 more]</label></div><br/><div class="children"><div class="content">I feel like one of the reaaally tricky bits of visual programming is avoiding bundling language and interface together.<p>Developers all have lots of (different) opinions about editors, but they&#x27;re fortunately seperated from the language they choose. People can work together on TypeScript usong Emacs, VSCode, Zed etc and it all gels.<p>The second someone starts with &quot;to use this language you have to use this editor&quot; the bar is <i>sooo</i> high for developers not getting their backs up.<p>It would be immense to have a visual way of programming that was language agnostic, but you&#x27;d need a seriously intense protocol to make that possible.<p>It does make me think of things like Smalltalk and Visual Basic that where designed to support multiple approaches. Interesting how that research avenue has drifted off recently.</div><br/></div></div><div id="40966206" class="c"><input type="checkbox" id="c-40966206" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#40966068">prev</a><span>|</span><a href="#40965078">next</a><span>|</span><label class="collapse" for="c-40966206">[-]</label><label class="expand" for="c-40966206">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But why do people keep coming back to visual programming?<p>Because real programming languages are free.<p>That&#x27;s it. That&#x27;s the main reason. Sure, there are hobby projects, yes, but almost every visual &quot;programming language&quot; in use in the industry, is a proprietary product, being licensed or sold. It&#x27;s a way to make money, and a pretty smart one to be honest: Once people invest time, resources, training, and build actual stuff in my proprietary system, they either invest a lot more money to get rid of it, or keep using it. And inertia in businesses being what it is, they usually chose the latter. What better vendor lock-in than a programming language?<p>-----<p>IMHO, no, we don&#x27;t need &quot;visual programming&quot;. I have worked with several such systems in professional settings. There is one thing they all have in common: They suck. No exceptions. It doesn&#x27;t matter what level they abstract at. They are all sold on the simplest of use cases, and to be fair: They can manage them very well. And some even look pretty and are a pleasure to work with.<p>At the start, that is.<p>Then the honeymoon is over, and you hit the first snag. The first thing the devs of it didn&#x27;t anticipate, or anticipated but implemented badly. And you build around that. And then the next thing happens. And then next. And the next.<p>And very soon, you keep running for the escape-hatch constantly, like calling into library code, or making HTTP requests to some server to do things that would have been a breeze in a real programming language. Congratulations, we are right back to &quot;non-visual-programming&quot;, only now our real code is tangled up in this mess, having to waste precious clock cycles pandering to the ideosyncracies of a less capable system, for no better reason that to not get rid of said system. And god help you if you have more than one of these things having to talk to each other. Now you can write glue-code between to pseudo-programming systems! FUN!<p>And, of course, these things are usually not accessible to any established tooling: There either is no version control at all or some vendors pet project idea of what a cool (read: bad) git alternative should look like. There usually is no way to unit- or integration-test anything. The only &quot;IDE&quot; that can deal with them, is the one the vendor provides. Also, `grep`, what&#x27;s that? Never heard of it.<p><i>&quot;But why do people keep coming back to visual programming?&quot;</i><p>Allow me to ask an alternative question: Why do people stick with textual programming, despite decades spent on trying to make visual programming happen?</div><br/></div></div><div id="40965078" class="c"><input type="checkbox" id="c-40965078" checked=""/><div class="controls bullet"><span class="by">ak217</span><span>|</span><a href="#40966206">prev</a><span>|</span><a href="#40964247">next</a><span>|</span><label class="collapse" for="c-40965078">[-]</label><label class="expand" for="c-40965078">[1 more]</label></div><br/><div class="children"><div class="content">People have mentioned a bunch of successful visual programming applications, but one that I&#x27;ve been thinking a lot about lately is Figma.<p>Figma has managed to bridge the gap between designers, UXR, and engineers in ways that I&#x27;ve never seen done before. I know teams that are incredibly passionate about Figma and use it for as much as they can (which is clearly a reflection of Figma themselves being passionate about delivering a great product) but what impressed me was how much they focus on removing friction from the process of shipping a working application starting from a UI mockup.<p>I think Figma holds a lot of lessons for anyone serious about both visual programming and cross-functional collaboration in organizations.</div><br/></div></div><div id="40964247" class="c"><input type="checkbox" id="c-40964247" checked=""/><div class="controls bullet"><span class="by">chacham15</span><span>|</span><a href="#40965078">prev</a><span>|</span><a href="#40965939">next</a><span>|</span><label class="collapse" for="c-40964247">[-]</label><label class="expand" for="c-40964247">[3 more]</label></div><br/><div class="children"><div class="content">I think the difficulty here is addressing: who is your target audience? Depending on that answer, you have different existing relatively succesful visual programming languages. For example, game designers have managed to make good use of Unreals&#x27; blueprints to great effect. Hobbists use Comfy UIs node language to wire up generative AI components to great effect. As far as generic computing goes, Scratch has managed to teach a lot of programming principles to people looking to learn. The problem comes in when you try and target a generic systems programmer: the target is too abstract to be able to create an effective visual language. In this article, they try and solve this issue by choosing specific subproblems which a visual representation is helpful: codebase visualization, computer network topology, memory layouts, etc...but none of them are programming languages</div><br/><div id="40964590" class="c"><input type="checkbox" id="c-40964590" checked=""/><div class="controls bullet"><span class="by">sbensu</span><span>|</span><a href="#40964247">parent</a><span>|</span><a href="#40965939">next</a><span>|</span><label class="collapse" for="c-40964590">[-]</label><label class="expand" for="c-40964590">[2 more]</label></div><br/><div class="children"><div class="content">[post author] I agree. On many domains you can find a great mapping between some visual representation and how the developer (beginner or not) wants to think about the problem.<p>I personally don&#x27;t see any one pictorial representation that maps to a general programming language. But if someone does find one, in the large and in the small, that&#x27;d be great!</div><br/><div id="40964728" class="c"><input type="checkbox" id="c-40964728" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#40964247">root</a><span>|</span><a href="#40964590">parent</a><span>|</span><a href="#40965939">next</a><span>|</span><label class="collapse" for="c-40964728">[-]</label><label class="expand" for="c-40964728">[1 more]</label></div><br/><div class="children"><div class="content">Not even all textual languages map well to every problem space.<p>Blueprints are a good callout(and Kismet before them). Many PLCs[1] are heavily visual language based with Ladder, FBD or other variants. I wouldn&#x27;t be surprised if they were the most widely used application of visual programming languages.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Programmable_logic_controller" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Programmable_logic_controller</a></div><br/></div></div></div></div></div></div><div id="40965939" class="c"><input type="checkbox" id="c-40965939" checked=""/><div class="controls bullet"><span class="by">parandroid</span><span>|</span><a href="#40964247">prev</a><span>|</span><a href="#40965882">next</a><span>|</span><label class="collapse" for="c-40965939">[-]</label><label class="expand" for="c-40965939">[1 more]</label></div><br/><div class="children"><div class="content">Great article. I do agree with it, while I&#x27;d add this conclusion (personal opinion):<p>- Usefulness of visualizing the codebase, interconnections, memory layouts - all of these are attempts of an overview of the things that aren&#x27;t immediately clear. It&#x27;s an attempt for an outside-of-the-box view, which becomes necessary in larger codebases&#x2F;environments&#x2F;companies. This is very useful for, say, an architect of a system (or systems), and even for individual contributors that are not comfortable in the current view (they may be struggling, or they may achieve better performance, of either the app or themselves with the insight gained from these visualizations).<p>- Actual visual programming only offers &quot;boxes&quot; of functionality and makes you frame everything the way it was initially imagined. It&#x27;s limiting expressiveness and makes your mental model adopt the framework&#x27;s way of thinking. Everyone I know has abandoned any visual programming only because they feel it is limiting them (&quot;It&#x27;s a nice toy, but it&#x27;s too difficult for me to create something more complex&quot; is a common thing I hear).</div><br/></div></div><div id="40965882" class="c"><input type="checkbox" id="c-40965882" checked=""/><div class="controls bullet"><span class="by">fstephany</span><span>|</span><a href="#40965939">prev</a><span>|</span><a href="#40965624">next</a><span>|</span><label class="collapse" for="c-40965882">[-]</label><label class="expand" for="c-40965882">[1 more]</label></div><br/><div class="children"><div class="content">It makes me think of <a href="https:&#x2F;&#x2F;moldabledevelopment.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;moldabledevelopment.com&#x2F;</a><p>You do not code in the visual environment but it helps you to create tools to visualize exactly what you want&#x2F;need to see. The interactivity is hard to beat and once you are used to it, you can quickly create visualizations that you can throw away (or keep).</div><br/></div></div><div id="40965624" class="c"><input type="checkbox" id="c-40965624" checked=""/><div class="controls bullet"><span class="by">trustno2</span><span>|</span><a href="#40965882">prev</a><span>|</span><a href="#40965044">next</a><span>|</span><label class="collapse" for="c-40965624">[-]</label><label class="expand" for="c-40965624">[4 more]</label></div><br/><div class="children"><div class="content">In banking, Camunda is increadibly popular.<p>You model state changes visually. The model - the diagram with boxes and arrows - IS the code. And then the boxes can have additional code logic in them.<p>It&#x27;s a giant pain to work in and debug. But the execs love it because they want to see the diagrams.</div><br/><div id="40965638" class="c"><input type="checkbox" id="c-40965638" checked=""/><div class="controls bullet"><span class="by">sakesun</span><span>|</span><a href="#40965624">parent</a><span>|</span><a href="#40965900">next</a><span>|</span><label class="collapse" for="c-40965638">[-]</label><label class="expand" for="c-40965638">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d rather generate data from diagram and match that against the data in actual code. This way we got all the benefit.</div><br/></div></div><div id="40965900" class="c"><input type="checkbox" id="c-40965900" checked=""/><div class="controls bullet"><span class="by">potamic</span><span>|</span><a href="#40965624">parent</a><span>|</span><a href="#40965638">prev</a><span>|</span><a href="#40965044">next</a><span>|</span><label class="collapse" for="c-40965900">[-]</label><label class="expand" for="c-40965900">[2 more]</label></div><br/><div class="children"><div class="content">Know of any open source equivalents to this?</div><br/><div id="40966081" class="c"><input type="checkbox" id="c-40966081" checked=""/><div class="controls bullet"><span class="by">trustno2</span><span>|</span><a href="#40965624">root</a><span>|</span><a href="#40965900">parent</a><span>|</span><a href="#40965044">next</a><span>|</span><label class="collapse" for="c-40966081">[-]</label><label class="expand" for="c-40966081">[1 more]</label></div><br/><div class="children"><div class="content">Google tells me there is something called ProcessMaker, I have never used it personally</div><br/></div></div></div></div></div></div><div id="40965044" class="c"><input type="checkbox" id="c-40965044" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#40965624">prev</a><span>|</span><a href="#40965369">next</a><span>|</span><label class="collapse" for="c-40965044">[-]</label><label class="expand" for="c-40965044">[2 more]</label></div><br/><div class="children"><div class="content">Twenty years ago I was a researcher (Fraunhofer) on executable UML, especially on aspect oriented programming (AOP which was a thing back then, but never caught on). You could draw a boundary around some UML process flow, and attach an aspect to it. For example a security boundry, and then the code generated would automatically add a security check aspect for all flows going inside.<p>What we did find out, text is just better to read and understand. It&#x27;s easier to refactor and much denser. We experimented with different levels to zoom in and zoom out for bigger programs but Visual programming does not scale (or didn&#x27;t at least back then).</div><br/><div id="40965641" class="c"><input type="checkbox" id="c-40965641" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#40965044">parent</a><span>|</span><a href="#40965369">next</a><span>|</span><label class="collapse" for="c-40965641">[-]</label><label class="expand" for="c-40965641">[1 more]</label></div><br/><div class="children"><div class="content">That was the premise of UML and the dream Rational was trying to sell with Rational Rose – that in the future, there would be no conventional programming languages, no software engineers, only architects, philosophers and visionaries wearing suits and ties, daydreaming and smoking pipes, who would be imbued with senses of self-importance and self-aggrandisement using Rational Rose and its visual language (UML) for system design and actually for every.single.thing., and Rational Rose would automatically generate the implementation (in an invisible intermediate conventional programming language as a byproduct). The idea was to obliterate the whole notion of programming as we know it today.<p>So the implementation in the intermediate programming language (C++) was not event meant to be readable to humans – <i>by design</i>. Rational Rose (the app), however, was too fat, too slow and (<i>most importantly</i>) buggy AF – to the point of the implementation it spat out nevery being able to work. And, UML did not meet the level of enthusiastic support Booch and Co wholeheartedly hoped for.<p>Whatever the reason was for Grady Booch&#x27;s personal crusade against the programming and an attempt to replace programming with visual programming, it has failed and done so miserably. Today, the only living remnant and legacy is UML sequence diagrams, and even class diagrams are no longer seen in the wild.</div><br/></div></div></div></div><div id="40965369" class="c"><input type="checkbox" id="c-40965369" checked=""/><div class="controls bullet"><span class="by">freetonik</span><span>|</span><a href="#40965044">prev</a><span>|</span><a href="#40965443">next</a><span>|</span><label class="collapse" for="c-40965369">[-]</label><label class="expand" for="c-40965369">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been dreaming about a visual editor for Clojure&#x2F;LISP, where inputs, outputs, and side effects are clearly identified visually similar to Feynman diagrams. Gave a talk about these ideas at a local Clojure meet up a while back: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;edQyRJyVsUg?si=q0M0D2jfsq9GmnqB" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;edQyRJyVsUg?si=q0M0D2jfsq9GmnqB</a></div><br/></div></div><div id="40965443" class="c"><input type="checkbox" id="c-40965443" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#40965369">prev</a><span>|</span><a href="#40965088">next</a><span>|</span><label class="collapse" for="c-40965443">[-]</label><label class="expand" for="c-40965443">[1 more]</label></div><br/><div class="children"><div class="content">More broadly it feels like there&#x27;s a lot of potential alpha in the tooling space that just gets left on the table by the industry<p>I don&#x27;t know what the reason is. Making tools is hard? Thankless? Tough to generalize? Devs are reluctant to adopt new tools?<p>Whatever the reason, I feel like workflows could be an order of magnitude more effective with better tooling. And I don&#x27;t even mean the table stakes of &quot;can install dependencies and reliably build and run on different laptops&quot; (which some ecosystems still fail). There&#x27;s huge untapped potential for &quot;tools that tell you interesting things about your code and&#x2F;or program&quot;<p>My personal theory is that the design of most programming languages today makes static analysis much harder than it needs to be. And then I guess, runtime analysis is just fundamentally hard to tack onto an existing language no matter how it&#x27;s designed</div><br/></div></div><div id="40965088" class="c"><input type="checkbox" id="c-40965088" checked=""/><div class="controls bullet"><span class="by">dwohnitmok</span><span>|</span><a href="#40965443">prev</a><span>|</span><a href="#40965831">next</a><span>|</span><label class="collapse" for="c-40965088">[-]</label><label class="expand" for="c-40965088">[1 more]</label></div><br/><div class="children"><div class="content">The Big Tech monolith (`bingo`, `papaya`, etc.) is a fantastic callback to this video: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=y8OnoxKotPQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=y8OnoxKotPQ</a>. Although that video is perhaps ironically about microservices.</div><br/></div></div><div id="40965831" class="c"><input type="checkbox" id="c-40965831" checked=""/><div class="controls bullet"><span class="by">ambyra</span><span>|</span><a href="#40965088">prev</a><span>|</span><label class="collapse" for="c-40965831">[-]</label><label class="expand" for="c-40965831">[2 more]</label></div><br/><div class="children"><div class="content">I always thought excel could do this, and everyone already knows excel. Toss out the vba, replace with python, every cell is a function, have a regular view, a relationship view that shows which cells connect to the current selected cell, have a run, stop pause, step&#x2F;break button. Everyone would use this.</div><br/><div id="40965876" class="c"><input type="checkbox" id="c-40965876" checked=""/><div class="controls bullet"><span class="by">thedevilslawyer</span><span>|</span><a href="#40965831">parent</a><span>|</span><label class="collapse" for="c-40965876">[-]</label><label class="expand" for="c-40965876">[1 more]</label></div><br/><div class="children"><div class="content">This is possible today with google sheets and javascript. The appscript integration is kind of amazing and allows for these flows effectively.</div><br/></div></div></div></div></div></div></div></div></div></body></html>