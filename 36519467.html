<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688288449529" as="style"/><link rel="stylesheet" href="styles.css?v=1688288449529"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://quickwit.io/blog/compressed-indexable-bitset/">A compressed indexable bitset</a> <span class="domain">(<a href="https://quickwit.io">quickwit.io</a>)</span></div><div class="subtext"><span>francoismassot</span> | <span>7 comments</span></div><br/><div><div id="36556233" class="c"><input type="checkbox" id="c-36556233" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#36557388">next</a><span>|</span><label class="collapse" for="c-36556233">[-]</label><label class="expand" for="c-36556233">[4 more]</label></div><br/><div class="children"><div class="content">&gt; We haven&#x27;t discussed other solutions like Partitioned Elias-Fano indexes or Tree-Encoded Bitmaps. We simply did not investigate them. There are no efficient off-the-shelf implementations of these solutions, so we had to implement one.<p>I guess they mean there are no implementations <i>in Rust</i>? The Partitioned Elias-Fano (PEF) paper links to the C++ implementation ([1], which I wrote) used for the experiments, it was efficient 9 years ago :) The library was later forked [2] and used in a few other papers, I believe it is somewhat maintained.
The EF core algorithm implemented in folly [3] may be a bit faster, and implementing partitioning on top of that is relatively easy.<p>It would definitely compress much better than roaring bitmaps. In terms of performance, it depends on the access patterns. If very sparse (large jumps), PEF would likely be faster, if dense (visit a large fraction of the bitmap), it&#x27;d be slower.<p>It is possible to squeeze a bit more compression out of PEF by introducing a chunk type for Elias-Fano of the chunk complement (for very dense chunks), but you lose the operation of skipping to a given position, which is however not needed in inverted indexes (you only need to skip past a given id, and that can be supported efficiently). That is not mentioned in the paper because at the time I thought the skip-to-position operation was a non-negotiable.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ot&#x2F;ds2i&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;ot&#x2F;ds2i&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;pisa-engine&#x2F;pisa">https:&#x2F;&#x2F;github.com&#x2F;pisa-engine&#x2F;pisa</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly&#x2F;blob&#x2F;main&#x2F;folly&#x2F;experimental&#x2F;EliasFanoCoding.h">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly&#x2F;blob&#x2F;main&#x2F;folly&#x2F;experiment...</a></div><br/><div id="36556713" class="c"><input type="checkbox" id="c-36556713" checked=""/><div class="controls bullet"><span class="by">francoismassot</span><span>|</span><a href="#36556233">parent</a><span>|</span><a href="#36556381">next</a><span>|</span><label class="collapse" for="c-36556713">[-]</label><label class="expand" for="c-36556713">[1 more]</label></div><br/><div class="children"><div class="content">Yes, just to confirm there was no off-the-shelf implementation in Rust.<p>We know the PISA project very well because... it is the fastest engine (though academic) in the tantivy benchmark: <a href="https:&#x2F;&#x2F;tantivy-search.github.io&#x2F;bench&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tantivy-search.github.io&#x2F;bench&#x2F;</a><p>But I did not know that they were using Partitioned Elias-Fano, maybe the author of the article fulmicoton knew that, I will check that.</div><br/></div></div><div id="36556381" class="c"><input type="checkbox" id="c-36556381" checked=""/><div class="controls bullet"><span class="by">boyter</span><span>|</span><a href="#36556233">parent</a><span>|</span><a href="#36556713">prev</a><span>|</span><a href="#36557946">next</a><span>|</span><label class="collapse" for="c-36556381">[-]</label><label class="expand" for="c-36556381">[1 more]</label></div><br/><div class="children"><div class="content">Unrelated to article but thanks for publicising the work on PEF. It’s one of those papers and codebases I scan though every now and then attempting to understand it better. I’ll get there one day and hopefully be able to reimplement it myself, for no real purpose other than understanding.</div><br/></div></div><div id="36557946" class="c"><input type="checkbox" id="c-36557946" checked=""/><div class="controls bullet"><span class="by">pgera</span><span>|</span><a href="#36556233">parent</a><span>|</span><a href="#36556381">prev</a><span>|</span><a href="#36557388">next</a><span>|</span><label class="collapse" for="c-36557946">[-]</label><label class="expand" for="c-36557946">[1 more]</label></div><br/><div class="children"><div class="content">Btw, core EF is quite efficient (perf wise) on the decoding side even on GPUs. I wanted to do PEF, but that seemed a bit more involved and I didn&#x27;t have the time to do it. Here&#x27;s a GPU implementation for graph problems if anyone is interested: <a href="https:&#x2F;&#x2F;github.com&#x2F;pgera&#x2F;efg">https:&#x2F;&#x2F;github.com&#x2F;pgera&#x2F;efg</a>. I also used folly on the encoding side and it works great.</div><br/></div></div></div></div><div id="36557388" class="c"><input type="checkbox" id="c-36557388" checked=""/><div class="controls bullet"><span class="by">inciampati</span><span>|</span><a href="#36556233">prev</a><span>|</span><a href="#36558957">next</a><span>|</span><label class="collapse" for="c-36557388">[-]</label><label class="expand" for="c-36557388">[1 more]</label></div><br/><div class="children"><div class="content">Also known as rank&#x2F;select dictionaries: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Succinct_data_structure#Succinct_indexable_dictionaries" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Succinct_data_structure#Succin...</a></div><br/></div></div><div id="36558957" class="c"><input type="checkbox" id="c-36558957" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36557388">prev</a><span>|</span><label class="collapse" for="c-36558957">[-]</label><label class="expand" for="c-36558957">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. I once made something like this for a search engine I built. It turned out to be a very useful data structure, especially when working with large, sparse sets.</div><br/></div></div></div></div></div></div></div></body></html>