<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716886857253" as="style"/><link rel="stylesheet" href="styles.css?v=1716886857253"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.ploetzli.ch/2024/should-i-use-jwt-for-authentication/">Should I use JWTs for authentication tokens?</a> <span class="domain">(<a href="https://blog.ploetzli.ch">blog.ploetzli.ch</a>)</span></div><div class="subtext"><span>pantalaimon</span> | <span>185 comments</span></div><br/><div><div id="40493818" class="c"><input type="checkbox" id="c-40493818" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40492163">next</a><span>|</span><label class="collapse" for="c-40493818">[-]</label><label class="expand" for="c-40493818">[38 more]</label></div><br/><div class="children"><div class="content">&quot;Just use the normal session mechanism that comes with your web framework and that you were using before someone told you that Google uses jwt. It has stood the test of time and is probably fine.&quot;<p>You don&#x27;t need to be Facebook or Google to have more than one service in your infrastructure that needs to authenticate a user&#x27;s existing session without forcing the user to log in again. Sharing the session across multiple services is its own distributed systems problem with numerous security implications to be aware of and bearer tokens might be a good alternative.<p>If all you have is a single monolith web app that is the identity provider, makes all authentication decisions etc then yes, you don&#x27;t need JWTs probably. There is a huge gap between that and being Google&#x2F;Facebook.<p>Apart from that, Google and Facebook don&#x27;t even use JWTs between the browser and backends after the initial login but actually do have some sort of distributed session concept last time I checked.</div><br/><div id="40494614" class="c"><input type="checkbox" id="c-40494614" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#40493818">parent</a><span>|</span><a href="#40498296">next</a><span>|</span><label class="collapse" for="c-40494614">[-]</label><label class="expand" for="c-40494614">[27 more]</label></div><br/><div class="children"><div class="content">&gt; You don&#x27;t need to be Facebook or Google to have more than one service in your infrastructure that needs to authenticate a user&#x27;s existing session without forcing the user to log in again.<p>Thank you. This middle ground between hyperscaler infrastructure and super simple web apps is where most of my career has been spent, yet the recent trend is to pretend like there are only two possible extremes: You’re either Facebook or you’re not doing anything complicated.<p>It has an unfortunate second order effect of convincing people that as soon as they encounter something more complicated than a simple web app, they need to adopt everything the hyperscalers do to solve it.<p>I wish we could spend more time discussing the middle ground rather than pretending it’s some sort of war between super simple or ultra complex.</div><br/><div id="40498126" class="c"><input type="checkbox" id="c-40498126" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494614">parent</a><span>|</span><a href="#40494849">next</a><span>|</span><label class="collapse" for="c-40498126">[-]</label><label class="expand" for="c-40498126">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Thank you. This middle ground between hyperscaler infrastructure and super simple web apps is where most of my career has been spent, yet the recent trend is to pretend like there are only two possible extremes: You’re either Facebook or you’re not doing anything complicated.<p>100% this. I am tired of you don&#x27;t need microservices, you don&#x27;t need JWT, you don&#x27;t need Kubernetes, you don&#x27;t need ElasticSearch, you don&#x27;t need IAM, you don&#x27;t need Redis, you don&#x27;t need Mongo and everything should stay in one SQL database.<p>Things are being used not because they exist, because people want to be fancy or because they don&#x27;t have something better to do. Things are being used because they solve problems and do so with least effort possible.</div><br/><div id="40498187" class="c"><input type="checkbox" id="c-40498187" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40498126">parent</a><span>|</span><a href="#40494849">next</a><span>|</span><label class="collapse" for="c-40498187">[-]</label><label class="expand" for="c-40498187">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Things are being used because they solve problems and do so with least effort possible&quot; in an ideal world sure in the real world there are many factors that influence technical decisions often having nothing to do with actual problem being solved</div><br/><div id="40498417" class="c"><input type="checkbox" id="c-40498417" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40498187">parent</a><span>|</span><a href="#40494849">next</a><span>|</span><label class="collapse" for="c-40498417">[-]</label><label class="expand" for="c-40498417">[2 more]</label></div><br/><div class="children"><div class="content">Having worked at many places over the last 30 years, yes, there is definitely &quot;resume-driven development&quot; where people pick something they want to put on their resume to solve a problem regardless of its suitability to the task in hand.<p>There&#x27;s also &quot;blinker-driven development&quot; where people pick the solution based on their own personal set of hammers rather than, again, something more suitable.<p>(There&#x27;s loads of these though - e.g. &quot;optimisation-driven development&quot; where the solution MUST GO BRRRRR even if the problem could be fixed by Frank typing in &quot;Yes&quot; once a week.  &quot;GOF-driven development&quot; where everything has to rigidly fit into a GOF pattern regardless of whether it actually does.  &quot;Go-driven development&quot; where everything has to be a interface and you end up reading a method called Validate which calls an interface method Validate which calls an interface method Validate which calls an interface method Validate and you wake up screaming every morning because why just wtf why please help me pleasehelp)</div><br/><div id="40498627" class="c"><input type="checkbox" id="c-40498627" checked=""/><div class="controls bullet"><span class="by">sunshinerag</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40498417">parent</a><span>|</span><a href="#40494849">next</a><span>|</span><label class="collapse" for="c-40498627">[-]</label><label class="expand" for="c-40498627">[1 more]</label></div><br/><div class="children"><div class="content">chuckle ... how far did you go into the validate rabbit hole</div><br/></div></div></div></div></div></div></div></div><div id="40494849" class="c"><input type="checkbox" id="c-40494849" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494614">parent</a><span>|</span><a href="#40498126">prev</a><span>|</span><a href="#40495514">next</a><span>|</span><label class="collapse" for="c-40494849">[-]</label><label class="expand" for="c-40494849">[20 more]</label></div><br/><div class="children"><div class="content">I still don&#x27;t think people in the middle need JWTs.<p>If we&#x27;re talking about a web session, time-limited randomly-generated session tokens that are stored in a DB still work fine.  If you really need it, put a caching layer (memcached or redis or valkey or whatever) in front of it.  Yes, then you&#x27;ve created cache invalidation problems for yourself, but it&#x27;s still less annoying than JWT.<p>If we&#x27;re talking about authenticating API requests, long-lived randomly-generated auth tokens stored in a database work fine, generally.  (But allow your users to create more than one, and make rotation and revocation easy.  Depending on your application, allowing your users to scope the tokens can also be a good thing to do.)  Again, put a caching layer in front of your database once you get to the scale where you need it.  You probably won&#x27;t need it for a while if you&#x27;re sending your reads to read-only replicas.<p>(Source: worked at Twilio for 10 years; we definitely eventually ran into scaling problems around our user&#x2F;auth DB, and our initial one-auth-token-is-all-you-need setup was terrible for users, but these problems were fixed over time.  Twilio does use JWTs for some things, but IMO that was unnecessary, and they created more headaches than they solved.)<p>I&#x27;m not saying no one ever needs JWTs, but I think they&#x27;re needed in far fewer circumstances than most people think, even people who agree that JWTs should be looked upon with some skepticism.  If you need to be able to log people out or invalidate sessions or disable accounts, then JWTs are going to create problems that are annoying to solve.<p>(One possibly-interesting solution for JWT-using systems that I haven&#x27;t tried anywhere is to do the reverse: don&#x27;t cache your user&#x2F;auth database, but have a distributed cache of JWTs that have been revoked.  The nice thing about JWTs is that they expire, so you can sweep your cache and drop tokens that have expired every night or whenever.  Not sure how well this would work in practice, but maybe it&#x27;s effective.  One big problem is that now your caching layer needs to be fail-closed, whereas in a system where you&#x27;re caching your user&#x2F;auth DB, a caching layer failure can fall back to the user&#x2F;auth DB... though that may melt it, of course.  I also feel like it&#x27;s easier to write logic bugs around &quot;if this record is not found, allow&quot; rather than &quot;if this record is not found, deny&quot;.)</div><br/><div id="40497670" class="c"><input type="checkbox" id="c-40497670" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40495114">next</a><span>|</span><label class="collapse" for="c-40497670">[-]</label><label class="expand" for="c-40497670">[1 more]</label></div><br/><div class="children"><div class="content">You don’t need jwts to pass internal permissions. We don’t, but we still extract claims from a jwt token at the beginning of a user flow. Then later we only use the claims to determine which resource a user has access to.<p>It’s not necessarily easier than just passing the jwt, but with our internal setups where when you first pass through the authorisation system, our traffic on your behalf is secure it doesn’t really warrant a reason to decode your token multiple times rather than simply passing your access permission claims.<p>We do still pass your jwt between isolated “products” where your access request doesn’t pass through dapr, but rather back through our central access gateway and then into the other “product”. A product is basically a collection of related services which are restricted to be a business component. Like a range of services which handles our solar plants, and another business component which handles our investment portfolios, and so on.</div><br/></div></div><div id="40495114" class="c"><input type="checkbox" id="c-40495114" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40497670">prev</a><span>|</span><a href="#40495013">next</a><span>|</span><label class="collapse" for="c-40495114">[-]</label><label class="expand" for="c-40495114">[1 more]</label></div><br/><div class="children"><div class="content">&quot;If we&#x27;re talking about a web session, time-limited randomly-generated session tokens that are stored in a DB still work fine. If you really need it, put a caching layer (memcached or redis or valkey or whatever) in front of it. Yes, then you&#x27;ve created cache invalidation problems for yourself, but it&#x27;s still less annoying than JWT.&quot;<p>You just (somewhat handwavingly) described what Google and Facebook are doing. You might not need to build this globally highly available distributed session store, JWTs might be an ok solution for your use case too (because you are not Google or Facebook) - or not. It depends on what your requirements are. AuthN across services is somewhat complex in any case, I don&#x27;t think there is an easy way around it without making tradeoffs somewhere. JWTs are a great tool to consider here.</div><br/></div></div><div id="40495013" class="c"><input type="checkbox" id="c-40495013" checked=""/><div class="controls bullet"><span class="by">MrDarcy</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40495114">prev</a><span>|</span><a href="#40495651">next</a><span>|</span><label class="collapse" for="c-40495013">[-]</label><label class="expand" for="c-40495013">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If we&#x27;re talking about a web session, time-limited randomly-generated session tokens that are stored in a DB still work fine<p>This works fine for a single service but you’re replying to a thread about the middle ground of multiple services. It’s an anti pattern to have every service talk to the same database just to authenticate every request.<p>By the time you add a caching layer you’re truly better off using an off the shelf oidc id provider and validating the id token claims.</div><br/><div id="40496538" class="c"><input type="checkbox" id="c-40496538" checked=""/><div class="controls bullet"><span class="by">a_random_canuck</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40495013">parent</a><span>|</span><a href="#40495651">next</a><span>|</span><label class="collapse" for="c-40496538">[-]</label><label class="expand" for="c-40496538">[2 more]</label></div><br/><div class="children"><div class="content">In my experience for medium sized services it’s still better to have everything talk to the same authentication database.<p>Postgres has insanely good read performance. Most companies and services are never going to reach the scale where any of this matters, and developer time is usually the more precious resource.<p>My advice is always, don’t get your dev team bogged down supporting all this complicated JWT stuff (token revocation, blacklisting, refresh, etc) when you are not Facebook scale &#x2F; don’t have concrete data showing your service really truly needs it.</div><br/><div id="40496641" class="c"><input type="checkbox" id="c-40496641" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40496538">parent</a><span>|</span><a href="#40495651">next</a><span>|</span><label class="collapse" for="c-40496641">[-]</label><label class="expand" for="c-40496641">[1 more]</label></div><br/><div class="children"><div class="content">+1<p>For mostly-read flow like authentication, a centralized database can scale really well. You don&#x27;t even need postgres for that.<p>If you have mutable state, JWT can&#x27;t help you anyway.<p>JWT start make sense only when you are doing other hyperscaler stuffs and you can reuse part of those architecture</div><br/></div></div></div></div></div></div><div id="40495651" class="c"><input type="checkbox" id="c-40495651" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40495013">prev</a><span>|</span><a href="#40494918">next</a><span>|</span><label class="collapse" for="c-40495651">[-]</label><label class="expand" for="c-40495651">[1 more]</label></div><br/><div class="children"><div class="content">As you point out, in most use cases a random token will be fine and it all comes down to how and where it is stored.<p>But that also means that you can have JWTs that are used as &quot;random token&quot; for most of your app, cost to produce them isn&#x27;t high, and only make use of the additional capacities for instance when<p>- when you want to check signatures (e.g. reject before hitting your application layer)<p>- store non sensitive base64 data that you want before restoring the session<p>Creating and handling JWT is only as costly and complicated as you want it to be, so there&#x27;s IMHO enough flexibility to have light use with very few penalities for it.</div><br/></div></div><div id="40494918" class="c"><input type="checkbox" id="c-40494918" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40495651">prev</a><span>|</span><a href="#40498192">next</a><span>|</span><label class="collapse" for="c-40494918">[-]</label><label class="expand" for="c-40494918">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But allow your users to create more than one, and make rotation and revocation easy<p>It&#x27;s shocking how often this advice isn&#x27;t followed. We often see it with non-tech companies who nonetheless deliver services over the internet.</div><br/></div></div><div id="40498192" class="c"><input type="checkbox" id="c-40498192" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40494918">prev</a><span>|</span><a href="#40496747">next</a><span>|</span><label class="collapse" for="c-40498192">[-]</label><label class="expand" for="c-40498192">[1 more]</label></div><br/><div class="children"><div class="content">&gt;If we&#x27;re talking about a web session, time-limited randomly-generated session tokens that are stored in a DB still work fine.<p>How is this better than JWT if we have 30 microservices called from front-end?</div><br/></div></div><div id="40496747" class="c"><input type="checkbox" id="c-40496747" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40498192">prev</a><span>|</span><a href="#40495079">next</a><span>|</span><label class="collapse" for="c-40496747">[-]</label><label class="expand" for="c-40496747">[2 more]</label></div><br/><div class="children"><div class="content">Why not just stick your auth token in the cache. It&#x27;s supposed to expire anyways.<p>Back in the day we used memcached for our primary store for all sorts of ephemeral things. Including user sessions.</div><br/><div id="40497902" class="c"><input type="checkbox" id="c-40497902" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40496747">parent</a><span>|</span><a href="#40495079">next</a><span>|</span><label class="collapse" for="c-40497902">[-]</label><label class="expand" for="c-40497902">[1 more]</label></div><br/><div class="children"><div class="content">Items are evicted from caches all the time for non-expired reasons. Memcached, in particular has &quot;slabs&quot; (spaces for objects of a certain size) and once those slabs are full, items are evicted to make space for new items.</div><br/></div></div></div></div><div id="40495079" class="c"><input type="checkbox" id="c-40495079" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40496747">prev</a><span>|</span><a href="#40497544">next</a><span>|</span><label class="collapse" for="c-40495079">[-]</label><label class="expand" for="c-40495079">[5 more]</label></div><br/><div class="children"><div class="content">&quot;have a distributed cache of JWTs that have been revoked. The nice thing about JWTs is that they expire, so you can sweep your cache and drop tokens that have expired every night or whenever.&quot;<p>Every cache has TTL, so you just set the TTL of the entry to the expiration date of the token you are caching. No need for nightly cleanups.</div><br/><div id="40496544" class="c"><input type="checkbox" id="c-40496544" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40495079">parent</a><span>|</span><a href="#40497544">next</a><span>|</span><label class="collapse" for="c-40496544">[-]</label><label class="expand" for="c-40496544">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure cache was the right word in the parent post-- you don&#x27;t want to use a cache (at least one with LRU&#x2F;bounded size) to store revocation without a backing store, or else the revocation could get pushed out of the cache and become ineffective. The backing store (likely a DB) would require such cleanups once the revocation record is no longer relevant.</div><br/><div id="40497246" class="c"><input type="checkbox" id="c-40497246" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40496544">parent</a><span>|</span><a href="#40497143">next</a><span>|</span><label class="collapse" for="c-40497246">[-]</label><label class="expand" for="c-40497246">[2 more]</label></div><br/><div class="children"><div class="content">I would challenge your assumption. Unless you absolutely need to have 100% durable, consistent revocations for some reasons, something like memcached is perfect here as the worst case scenario in case of a failure is a slight, temporary degradation in security without any visible user impact or operations nightmare (ie restoring backups). This assumes that your token lifetime is reasonably short (at least for access tokens), refresh tokens are a different story but only need to be tracked at the authn service, not globally.</div><br/><div id="40497976" class="c"><input type="checkbox" id="c-40497976" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40497246">parent</a><span>|</span><a href="#40497143">next</a><span>|</span><label class="collapse" for="c-40497976">[-]</label><label class="expand" for="c-40497976">[1 more]</label></div><br/><div class="children"><div class="content">If the revocation use case is soft, then totally fair. But if the application is potentially dangerous and the user says &quot;Sign out all devices&quot;, I think that should be a deterministically successful operation. Similarly, if there is a compromised account in an organization, I&#x27;d like to be confident that revoking all credentials was successful.<p>Revocation of tokens can be done for a simple logout operation, in which case the stakes are low, but more often it is the &quot;pull the fire alarm and get that user out&quot;, and in that case it should be reliable.</div><br/></div></div></div></div><div id="40497143" class="c"><input type="checkbox" id="c-40497143" checked=""/><div class="controls bullet"><span class="by">sturgill</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40496544">parent</a><span>|</span><a href="#40497246">prev</a><span>|</span><a href="#40497544">next</a><span>|</span><label class="collapse" for="c-40497143">[-]</label><label class="expand" for="c-40497143">[1 more]</label></div><br/><div class="children"><div class="content">Potentially you take both at once: use something like DynamoDB as the storage layer that also supports TTL natively.</div><br/></div></div></div></div></div></div><div id="40497544" class="c"><input type="checkbox" id="c-40497544" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494849">parent</a><span>|</span><a href="#40495079">prev</a><span>|</span><a href="#40495514">next</a><span>|</span><label class="collapse" for="c-40497544">[-]</label><label class="expand" for="c-40497544">[4 more]</label></div><br/><div class="children"><div class="content">Honestly, do you even need support for revoke? If you have a token whose lifetime can be measured in 2-3 minutes, I don&#x27;t think the abuse potential is huge, especially when some other security measures are in place.<p>Thing is, token refresh service can be stateless, but adding a revoke service basically kills JWTs main advantage, since every time we check its validity, we need a query to see if its been revoked.</div><br/><div id="40497650" class="c"><input type="checkbox" id="c-40497650" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40497544">parent</a><span>|</span><a href="#40497885">next</a><span>|</span><label class="collapse" for="c-40497650">[-]</label><label class="expand" for="c-40497650">[2 more]</label></div><br/><div class="children"><div class="content">Revocation is needed because you want to disable access to an intruder in the very second you detect unauthorized access using a stolen token. Same for certain kinds of banned users who must lose access immediately.<p>But since such a revocation list is going to be short (usually 0 entries, dozens at worst), it&#x27;s trivial to replicate across all the auth service nodes (which can as well be worker nodes) or keep it in Redis replicated per DC, with sub-millisecond lookup times.<p>Things get harder if you want a feature like logging out other sessions, or just an explicit logout on a shared computer (think about business settings: stores, pharmacies, post offices), you may have to have larger revocation lists. This may still not be a problem: a million tokens is a few dozen megabytes, again, a per-DC replicated Redis cluster would handle it trivially and very cheaply.</div><br/><div id="40497877" class="c"><input type="checkbox" id="c-40497877" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40497650">parent</a><span>|</span><a href="#40497885">next</a><span>|</span><label class="collapse" for="c-40497877">[-]</label><label class="expand" for="c-40497877">[1 more]</label></div><br/><div class="children"><div class="content">I still feel like the need for revocation kills the simplicity of JWT and thus the reason for its existence.<p>I&#x27;m of a more gradual opinion regarding this - say you operate a movie streaming service and control access to movies via JWT. It&#x27;s not a problem if an attacker has access for two more minutes than intended.<p>If you are talking to a single client, I think checking the remote IP address and encoding it in the token might work to see if the token is not stolen, but don&#x27;t quote me on that.</div><br/></div></div></div></div><div id="40497885" class="c"><input type="checkbox" id="c-40497885" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40497544">parent</a><span>|</span><a href="#40497650">prev</a><span>|</span><a href="#40495514">next</a><span>|</span><label class="collapse" for="c-40497885">[-]</label><label class="expand" for="c-40497885">[1 more]</label></div><br/><div class="children"><div class="content">All you really need for revocation in a revocation service are two fields: user id + inb (issued not before) and a bloom filter.<p>To revoke a token:<p>1. issue a new token to the revoker that is issued at current time (if business rules require revoker to be logged in).<p>2. set user inb to current time - 1 second with a TTL of longest issue * 1.5.<p>3. Add user to bloom filter.<p>4. upload bloom filter to s3, every service downloads this every 5 minutes.<p>5. Then on request, check bloom filter. If the user id is in the bloom filter, check with revocation service that inb &gt; issued time.<p>This is probably less than five hundred lines of code and pretty easy to maintain.</div><br/></div></div></div></div></div></div><div id="40495514" class="c"><input type="checkbox" id="c-40495514" checked=""/><div class="controls bullet"><span class="by">turtlebits</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494614">parent</a><span>|</span><a href="#40494849">prev</a><span>|</span><a href="#40494737">next</a><span>|</span><label class="collapse" for="c-40495514">[-]</label><label class="expand" for="c-40495514">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a trend.  Those on the extreme ends of the spectrum are always the most vocal.</div><br/></div></div><div id="40494737" class="c"><input type="checkbox" id="c-40494737" checked=""/><div class="controls bullet"><span class="by">rescbr</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40494614">parent</a><span>|</span><a href="#40495514">prev</a><span>|</span><a href="#40498296">next</a><span>|</span><label class="collapse" for="c-40494737">[-]</label><label class="expand" for="c-40494737">[1 more]</label></div><br/><div class="children"><div class="content">Specially since the middle is way larger than people think.</div><br/></div></div></div></div><div id="40498296" class="c"><input type="checkbox" id="c-40498296" checked=""/><div class="controls bullet"><span class="by">likis</span><span>|</span><a href="#40493818">parent</a><span>|</span><a href="#40494614">prev</a><span>|</span><a href="#40493945">next</a><span>|</span><label class="collapse" for="c-40498296">[-]</label><label class="expand" for="c-40498296">[1 more]</label></div><br/><div class="children"><div class="content">Agree, and he even mentions in the article &quot;If you process less than 10k requests per second, you’re not Google nor are you Facebook.&quot;<p>There is a huuuuuge gap between services handling 10k req&#x2F;s and Google&#x2F;Facebook.<p>I think one big upside with JWT that he doesn&#x27;t mention is that if you have some services geographically distributed, then having decentralized auth with JWTs is quite nice without having to geographically distribute you auth backend system.<p>So, yes, if you have a monolith or services colocated, or have some kind of monolothic API layer, then no, perhaps JWT does not make sense. But for a lot of distributed services, having JWTs makes perfect sense.<p>And you don&#x27;t have to introduce JWT revocation for logout, if you have short token expirations, you can accept the risk of token leakage. If the token is valid for  like 30 seconds or 1 minute, you would probably never be able to notice that a token has been leaked anyway.</div><br/></div></div><div id="40493945" class="c"><input type="checkbox" id="c-40493945" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#40493818">parent</a><span>|</span><a href="#40498296">prev</a><span>|</span><a href="#40497126">next</a><span>|</span><label class="collapse" for="c-40493945">[-]</label><label class="expand" for="c-40493945">[3 more]</label></div><br/><div class="children"><div class="content">This is a perfect example of &quot;it depends&quot; being the right answer.<p>Should a project use sessions or JWTs? One isn&#x27;t right or wrong, it all depends on the context of the project.</div><br/><div id="40497136" class="c"><input type="checkbox" id="c-40497136" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40493945">parent</a><span>|</span><a href="#40497126">next</a><span>|</span><label class="collapse" for="c-40497136">[-]</label><label class="expand" for="c-40497136">[2 more]</label></div><br/><div class="children"><div class="content">I mean, to be fair, the article literally calls out a fairly reasonable checklist.<p>Do you maintain a database of JWT session tokens for refresh and revoke?<p>Do you have a real session that you load for every user every request <i>anyway</i>?<p>If the answer is &#x27;yes&#x27;, then the answer to &#x27;use JWT&#x27; isn&#x27;t &#x27;it depends&#x27;.<p>It&#x27;s no.</div><br/><div id="40497336" class="c"><input type="checkbox" id="c-40497336" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40497136">parent</a><span>|</span><a href="#40497126">next</a><span>|</span><label class="collapse" for="c-40497336">[-]</label><label class="expand" for="c-40497336">[1 more]</label></div><br/><div class="children"><div class="content">The author here seems to be arguing that you should effectively never use JWTs. That, in my opinion, is a mistake.<p>JWTs have absolutely been over-hyped for the last 8-10 years, but they do have a use and you don&#x27;t have to be at the  scale of Google for it to be the right approach.<p>Software isn&#x27;t as simple as creating a checklist of a few basic categories and saying there is always a right or wrong answer. The answer should be &quot;it depends&quot; because there are many more factors at play when deciding something as fundamental as authentication and authorization.</div><br/></div></div></div></div></div></div><div id="40497126" class="c"><input type="checkbox" id="c-40497126" checked=""/><div class="controls bullet"><span class="by">Illniyar</span><span>|</span><a href="#40493818">parent</a><span>|</span><a href="#40493945">prev</a><span>|</span><a href="#40497182">next</a><span>|</span><label class="collapse" for="c-40497126">[-]</label><label class="expand" for="c-40497126">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty rare to have more then 1 client facing API even for large apps.
Whether it&#x27;s a monolith, an API gateway, Apollo federation or whatever.<p>What you do to authenticate between the BFF (for lack of a better name) and other services is a different matter.</div><br/></div></div><div id="40497182" class="c"><input type="checkbox" id="c-40497182" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#40493818">parent</a><span>|</span><a href="#40497126">prev</a><span>|</span><a href="#40497738">next</a><span>|</span><label class="collapse" for="c-40497182">[-]</label><label class="expand" for="c-40497182">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Sharing the session across multiple services is its own distributed systems problem with numerous security implications to be aware of and bearer tokens might be a good alternative.<p>JWT makes it possible to distribute the same access token across multiple systems, but so do stateful tokens. The security implications when you&#x27;re using JWT for this solution are much higher than with database tokens. Let&#x27;s look at this for a moment:<p>JWT Security Issues:<p>- Inherent design issues (alg=none, algorithm confusion, weak ciphers like RSA)<p>- Cannot be revoked.<p>- Key rotation and distribution is necessary to keep token safe over a long period of time<p>- Claim parsing needs to be standardized and enforced correctly in all services (otherwise impersonation is possible)<p>Database Tokens Security Issues:<p>- Timing Attacks against B-Tree indexes [1]<p>- Giving direct access to the database to all microservices is risky<p>The security issues with databases are ridiculously easy to solve: To prevent timing attacks, you can just use a hash table index, split the token into a search-key part and a constant-time-compare part or add an HMAC to your token. To prevent direct access to the database by all your microservices, you just wrap it with an API the verifies tokens.<p>The JWT security issues are much harder to solve. To prevent misconfiguration or misuse and standardize the way claims are used across your organization, you probably need to write your own library or deploy an API gateway. To counter the lack of revocation support, you either need to use very short lived access tokens (so your refresh token DB will still get a lot of hits and you would still need to deal with all the scaling issues) or set up a distributed revocation service (not easy at all). Setting up seamless key rotation also requires additional infrastructure that is not part of the hundreds of JWT libraries out there.<p>It&#x27;s really easy to get a JWT solution that just works and scales easily, but if you really care about security — especially if you care about security! — JWTs are not necessarily easier than stateful tokens. They&#x27;re probably harder.<p>&gt; Apart from that, Google and Facebook don&#x27;t even use JWTs between the browser and backends after the initial login but actually do have some sort of distributed session concept last time I checked.<p>Last time I checked (which was today for Google), neither Google, nor Facebook is using JWT for their access or refresh tokens. The only place I saw JWT with the ID Token in their Open ID Connect Flow, and they can&#x27;t really avoid that even if their wanted, since this is mandated by the spec.<p>Facebook and Google don&#x27;t need JWT. Scaling and distributing a read-only token database to handle a large amount of traffic is easier — not harder! — for these companies. Stateless tokens can be useful for them in certain scenarios, but even then, if you&#x27;re at Google or Facebook&#x27;s scale, why would you opt for JWT over an in-house format that is smaller, faster and suffers from less vulnerabilities?<p>[1] <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;event&#x2F;woot07&#x2F;tech&#x2F;full_papers&#x2F;futoransky&#x2F;futoransky_html&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;event&#x2F;woot07&#x2F;tech&#x2F;full_papers&#x2F;...</a></div><br/><div id="40497326" class="c"><input type="checkbox" id="c-40497326" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40497182">parent</a><span>|</span><a href="#40497738">next</a><span>|</span><label class="collapse" for="c-40497326">[-]</label><label class="expand" for="c-40497326">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think keys need to be distributed per se, rather made available at a URL that can be served by the same service that issues the tokens? You could call that distribution, but that&#x27;s probably not what you meant. I agree that a lot can go wrong, but isn&#x27;t that also true for home growing a distributed database tokens solution (I surely have seen some monsters in the wild). So can&#x27;t the problems with both solutions be mitigated using some good libraries?</div><br/><div id="40497585" class="c"><input type="checkbox" id="c-40497585" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#40493818">root</a><span>|</span><a href="#40497326">parent</a><span>|</span><a href="#40497738">next</a><span>|</span><label class="collapse" for="c-40497585">[-]</label><label class="expand" for="c-40497585">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Made available at a URL&quot; is one possible distribution mechanism, yes. But this only works for asymmetric keys. If you publish symmetric keys (e.g. for HS256) at a shared URL... Well, now everyone can get these keys and forge tokens to their heart&#x27;s content.<p>Even with asymmetric tokens and a key distribution URL, you still have to make sure the clients periodically update their list of keys — this is not something you get built-in with every JWT library. And you still have to setup a mechanism for generating the keys and distributing them between the various instances of your auth server. This is not so hard nowadays with cloud KMS services, but setting up this solution on our own infra was quite painful.<p>&gt; I agree that a lot can go wrong, but isn&#x27;t that also true for home growing a distributed database tokens solution (I surely have seen some monsters in the wild). So can&#x27;t the problems with both solutions be mitigated using some good libraries?<p>My point is not that a database solution is without its own issues. At my $DayJob we&#x27;re also using a mix of stateful and stateless tokens (with distributed revocation lists) and we had to deal with issues with both of them. But stateful tokens on a database rarely suffer from security issues — the issues we had were always related to scalability and performance. The mitigations for these issues are also different: they almost always have to do with optimizing the infrastructure (scaling out the database, adding a cache) rather than using a library. In fact, when we use stateful tokens in a distributed scenario (and I&#x27;m sure this is true for almost everyone out there), all token handling is centralized in the auth service, so libraries are not strictly necessary. At most, client libraries would be very thin wrapper around HTTP API calls.</div><br/></div></div></div></div></div></div><div id="40497738" class="c"><input type="checkbox" id="c-40497738" checked=""/><div class="controls bullet"><span class="by">pojzon</span><span>|</span><a href="#40493818">parent</a><span>|</span><a href="#40497182">prev</a><span>|</span><a href="#40496316">next</a><span>|</span><label class="collapse" for="c-40497738">[-]</label><label class="expand" for="c-40497738">[1 more]</label></div><br/><div class="children"><div class="content">Just use elasticcache for sessions duh. Its a very very old pattern.</div><br/></div></div><div id="40496316" class="c"><input type="checkbox" id="c-40496316" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#40493818">parent</a><span>|</span><a href="#40497738">prev</a><span>|</span><a href="#40492163">next</a><span>|</span><label class="collapse" for="c-40496316">[-]</label><label class="expand" for="c-40496316">[1 more]</label></div><br/><div class="children"><div class="content">Why would there be any relationship between user sessions and microservices? Are you exposing them directly to the internet?</div><br/></div></div></div></div><div id="40492163" class="c"><input type="checkbox" id="c-40492163" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#40493818">prev</a><span>|</span><a href="#40496478">next</a><span>|</span><label class="collapse" for="c-40492163">[-]</label><label class="expand" for="c-40492163">[41 more]</label></div><br/><div class="children"><div class="content">Okay I&#x27;ll bite...<p>This post doesn&#x27;t seem to address microservice architectures at all? For me, this is the primary reason to use JWT&#x27;s -- so you can pass authentication (&quot;claims&quot;, or whatever you want to call them) through your chain of microservice service-to-service calls. If you don&#x27;t have microservices then there&#x27;s much less reason to use JWT&#x27;s.<p>I&#x27;m not saying the article is a strawman exactly, but it does seem to miss the primary use case of JWT&#x27;s. At least, the way I&#x27;ve used them in anger.<p>Also, the &quot;JWT&#x27;s can be insecure if you use the wrong library or configure them incorrectly&quot; argument, while having <i>some</i> points, seems to me more of an argument that you should really do due diligence on any libraries you use for security. The better JWT libraries are not insecure by default.<p>I wouldn&#x27;t use JWT&#x27;s if I were making a monolith, but there are lots of companies who (for better or worse) use microservices.</div><br/><div id="40492189" class="c"><input type="checkbox" id="c-40492189" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#40492163">parent</a><span>|</span><a href="#40492199">next</a><span>|</span><label class="collapse" for="c-40492189">[-]</label><label class="expand" for="c-40492189">[23 more]</label></div><br/><div class="children"><div class="content">&gt;  so you can pass authentication (&quot;claims&quot;, or whatever you want to call them) through your chain of microservice service-to-service calls.<p>This is a misconception about so called zero trust. You can&#x27;t &quot;just&quot; pass the same token to someone else. They can use it to impersonate or misuse the token later. While you are going to say that &quot;my microservices will not impersonate users because to each other, they are all <i>trusted</i>,&quot; you have run directly into the difference between trusted and zero trust.</div><br/><div id="40493649" class="c"><input type="checkbox" id="c-40493649" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40492189">parent</a><span>|</span><a href="#40492248">next</a><span>|</span><label class="collapse" for="c-40493649">[-]</label><label class="expand" for="c-40493649">[11 more]</label></div><br/><div class="children"><div class="content">The audience and scope claims exist to address that problem. Provided that RPs reject JWTs issued for other audiences than themselves there’s no security weakness here.<p>This is why JWTs are used in OIDC (e.g. “Sign-in with Google”: any website can use it, and it doesn’t make Google’s own security weaker.<p>I’ll concede that small, but important, details like these are not readily understood by those following some tutorial off some coding-camp content-farm (or worse: using a shared-secret for signing tokens instead of asymmetric cryptography, ugh) - and that’s also where we see the vulnerabilities. OAuth2+OIDC is very hard to grok.</div><br/><div id="40496123" class="c"><input type="checkbox" id="c-40496123" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493649">parent</a><span>|</span><a href="#40494148">next</a><span>|</span><label class="collapse" for="c-40496123">[-]</label><label class="expand" for="c-40496123">[2 more]</label></div><br/><div class="children"><div class="content">&gt; (or worse: using a shared-secret for signing tokens instead of asymmetric cryptography, ugh)<p>What’s so terrible about that? Several security engineers I trust favor designs with symmetric crypto, e.g. Fly.io <a href="https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;macaroons-escalated-quickly&#x2F;">https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;macaroons-escalated-quickly&#x2F;</a> and Facebook <a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2018&#x2F;413.pdf" rel="nofollow">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2018&#x2F;413.pdf</a></div><br/><div id="40496289" class="c"><input type="checkbox" id="c-40496289" checked=""/><div class="controls bullet"><span class="by">ak217</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40496123">parent</a><span>|</span><a href="#40494148">next</a><span>|</span><label class="collapse" for="c-40496289">[-]</label><label class="expand" for="c-40496289">[1 more]</label></div><br/><div class="children"><div class="content">It limits your ability to compartmentalize your infrastructure, establish security perimeters, and provide defense-in-depth against vulnerabilities in your dependencies.</div><br/></div></div></div></div><div id="40494148" class="c"><input type="checkbox" id="c-40494148" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493649">parent</a><span>|</span><a href="#40496123">prev</a><span>|</span><a href="#40493731">next</a><span>|</span><label class="collapse" for="c-40494148">[-]</label><label class="expand" for="c-40494148">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The audience and scope claims exist to address that problem. Provided that RPs reject JWTs issued for other audiences than themselves there’s no security weakness here.<p>My interpretation is that the audience and scope claims, as other features like nonce, are in place to prevent tokens from being intercepted and misused, not to facilitate passing tokens around.</div><br/><div id="40495827" class="c"><input type="checkbox" id="c-40495827" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40494148">parent</a><span>|</span><a href="#40493731">next</a><span>|</span><label class="collapse" for="c-40495827">[-]</label><label class="expand" for="c-40495827">[2 more]</label></div><br/><div class="children"><div class="content">Don’t see how those prevent tokens from being misused? They just prevent anyone from issuing tokens as you. Not by themselves, but if you implement your server correctly.</div><br/><div id="40497593" class="c"><input type="checkbox" id="c-40497593" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40495827">parent</a><span>|</span><a href="#40493731">next</a><span>|</span><label class="collapse" for="c-40497593">[-]</label><label class="expand" for="c-40497593">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Don’t see how those prevent tokens from being misused?<p>The purpose of a nonce is to explicitly prevent the token from being reused.<p>The purpose of the other claims is to prevent them from being accepted (and used) in calls to other services.<p>If you implement your server correctly, each instance of each service is a principal which goes through auth flows independently and uses its own tokens.<p>There is no token sharing.</div><br/></div></div></div></div></div></div><div id="40493731" class="c"><input type="checkbox" id="c-40493731" checked=""/><div class="controls bullet"><span class="by">rwdf</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493649">parent</a><span>|</span><a href="#40494148">prev</a><span>|</span><a href="#40492248">next</a><span>|</span><label class="collapse" for="c-40493731">[-]</label><label class="expand" for="c-40493731">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also why we use DPoP for serious stuff.</div><br/><div id="40493902" class="c"><input type="checkbox" id="c-40493902" checked=""/><div class="controls bullet"><span class="by">dadadad100</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493731">parent</a><span>|</span><a href="#40492248">next</a><span>|</span><label class="collapse" for="c-40493902">[-]</label><label class="expand" for="c-40493902">[4 more]</label></div><br/><div class="children"><div class="content">I hadn’t heard of DPoP until this mention. Please tell us more. Google tells me it is Demonstrating Proof of Possession, but is it supported by any products?</div><br/><div id="40497680" class="c"><input type="checkbox" id="c-40497680" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493902">parent</a><span>|</span><a href="#40497726">next</a><span>|</span><label class="collapse" for="c-40497680">[-]</label><label class="expand" for="c-40497680">[2 more]</label></div><br/><div class="children"><div class="content">DPoP described in RFC9449 - you can see from the RFC number it&#x27;s quite new. I don&#x27;t think there&#x27;s wide support for it, but at least Okta supports it[1] and I think Auth0 are also working on adding DPoP.<p>Is it good? I&#x27;m not a fan. To use DPoP safely (without replay attacks), you need to add server-side nonces (&quot;nonce&quot;) and client-generated nonces (&quot;jti&quot;, great and definitely not confusing terminology there).<p>You need to make sure client-generated nonces are only used once, which requires setting up... wait for it... A database! And if you&#x27;ll be using DPoP in a distributed manner, with access tokens then, well, a database shared across all services. And this is not an easy-to-scale read-oriented database like you&#x27;d have to use for stateful tokens. No, this is a database that requires an equal number of reads and writes (assuming you&#x27;re not under a DDoS attack): for each DPoP validation, you&#x27;d need to read the nonce and then add it to the database. You&#x27;d also need to implement some sort of TTL mechanism to prevent the database from growing forever and implement strong rate limitation across all services to prevent very easy DDoS.<p>It seems like the main driving motivation behind DPoP is to mitigate the cost of refresh tokens being exfiltrated from public clients using XSS attacks, but I believe it is too cumbersome to be used <i>securely</i> as a general mechanism for safe token delegation that prevents &quot;pass-the-token&quot; attacks.<p>[1] <a href="https:&#x2F;&#x2F;developer.okta.com&#x2F;docs&#x2F;guides&#x2F;dpop&#x2F;nonoktaresourceserver&#x2F;main&#x2F;" rel="nofollow">https:&#x2F;&#x2F;developer.okta.com&#x2F;docs&#x2F;guides&#x2F;dpop&#x2F;nonoktaresources...</a></div><br/><div id="40497892" class="c"><input type="checkbox" id="c-40497892" checked=""/><div class="controls bullet"><span class="by">jmdc</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40497680">parent</a><span>|</span><a href="#40497726">next</a><span>|</span><label class="collapse" for="c-40497892">[-]</label><label class="expand" for="c-40497892">[1 more]</label></div><br/><div class="children"><div class="content">I agree that DPoP - especially the nonce - is quite complex, but I don&#x27;t think it&#x27;s as bad as you make out.<p>Proof tokens can only be used for a narrow window of time (seconds to minutes), so you just need a cache of recently seen token identifiers (jtis) to do replay detection. And proof tokens are bound to an endpoint with the htm and htu claims. They can&#x27;t be used across services, so I don&#x27;t see a need for that replay cache to be shared across all services.</div><br/></div></div></div></div><div id="40497726" class="c"><input type="checkbox" id="c-40497726" checked=""/><div class="controls bullet"><span class="by">jmdc</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493902">parent</a><span>|</span><a href="#40497680">prev</a><span>|</span><a href="#40492248">next</a><span>|</span><label class="collapse" for="c-40497726">[-]</label><label class="expand" for="c-40497726">[1 more]</label></div><br/><div class="children"><div class="content">DPoP is an OAuth extension that defends against token replay by sender constraining tokens. It is a new-ish spec, but support is pretty widespread already. It&#x27;s used in a lot of European banking that has pretty strict security requirements, and it&#x27;s supported by some of the big cloud identity providers as well as the OAuth framework I work on, IdentityServer. We have sample code and docs etc on our blog: <a href="https:&#x2F;&#x2F;blog.duendesoftware.com&#x2F;posts&#x2F;20230504_dpop&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.duendesoftware.com&#x2F;posts&#x2F;20230504_dpop&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="40492248" class="c"><input type="checkbox" id="c-40492248" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40492189">parent</a><span>|</span><a href="#40493649">prev</a><span>|</span><a href="#40492770">next</a><span>|</span><label class="collapse" for="c-40492248">[-]</label><label class="expand" for="c-40492248">[9 more]</label></div><br/><div class="children"><div class="content">&gt; This is a misconception about so called zero trust. You can&#x27;t &quot;just&quot; pass the same token to someone else. They can use it to impersonate or misuse the token later.<p>Put another way, JWTs used as bearer tokens have vulnerable to intra-audience replay attacks.<p>While this is true for many zero trust architectures, but you don&#x27;t have to build zero trust architectures this way. Simply have the token commit to a public key of a signing key held by the identity, then you can do Proof-of-Possession and remove these replay attacks. This is the direction zero trust is headed. For instance AWS is slowly moving toward this with sigV4A. Most zero trust solutions aren&#x27;t there yet.</div><br/><div id="40493799" class="c"><input type="checkbox" id="c-40493799" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40492248">parent</a><span>|</span><a href="#40492463">next</a><span>|</span><label class="collapse" for="c-40493799">[-]</label><label class="expand" for="c-40493799">[4 more]</label></div><br/><div class="children"><div class="content">Bearer tokens are vulnerable to man-in-the-middle impersonation.<p>It&#x27;s right in the name.<p>Anyway, zero trust architecture are wildly overrated and used in way more places than they should. But the entire thread is correct in that you can&#x27;t build them with bearer tokens.</div><br/><div id="40494485" class="c"><input type="checkbox" id="c-40494485" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493799">parent</a><span>|</span><a href="#40492463">next</a><span>|</span><label class="collapse" for="c-40494485">[-]</label><label class="expand" for="c-40494485">[3 more]</label></div><br/><div class="children"><div class="content">Man-in-the-middle impersonation is not the biggest threat because TLS 1.3 does a decent job of protecting the token in transit. The biggest issue is the endpoints:<p>1. The client that holds the token can&#x27;t use an HSM or SSM to protect the token because they need to transmit it. Thus a compromise of the client via an XSS or Malware, results in the token leaking.<p>2. The server that receives the token, might be compromised and they can replay the token to other servers or leak it accidentally e.g., with a log file or to an analytics service.<p>Both of these problems go away if you uses OpenPubkey or Verifiable Credentials with JWTs. The JWT is now a public value, and the client holds a signing key.<p>1. The client can protect the signing key with an HSM or SSM (modern web browsers grant javascript access to a SSM).<p>2. The server only receives the JWT (now a public value) and a signature specific to that server. They don&#x27;t have any secrets to protect.<p>&gt; But the entire thread is correct in that you can&#x27;t build them with bearer tokens.<p>You can and people do, but it is far better to use proof of possession JWTs than bearer JWTs. Even better to use JWS instead of JWTs so you can make use of multiple JWS signers (a JWT is a type of JWS, but a JWS with more than one signer can not be a JWT).</div><br/><div id="40495600" class="c"><input type="checkbox" id="c-40495600" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40494485">parent</a><span>|</span><a href="#40492463">next</a><span>|</span><label class="collapse" for="c-40495600">[-]</label><label class="expand" for="c-40495600">[2 more]</label></div><br/><div class="children"><div class="content">User X’s web browser calls Server A which makes a web service request to Server B that needs to authenticate that user X is making the call.<p>What types of tokens do you suggest in each case?</div><br/><div id="40496692" class="c"><input type="checkbox" id="c-40496692" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40495600">parent</a><span>|</span><a href="#40492463">next</a><span>|</span><label class="collapse" for="c-40496692">[-]</label><label class="expand" for="c-40496692">[1 more]</label></div><br/><div class="children"><div class="content">To pitch my own project, OpenPubkey[0], it is designed for exactly this use case. OpenPubkey let&#x27;s you add a public key to an ID Token (JWT) without needing any change at the IDP.<p>1. Alice generates an ephemeral key pair (if she is using a browser she can generate the key pair as a &quot;non-extractable key&quot;[1]).<p>2. Alice gets ID Token issued by Google that commits to their public key,<p>3. Alice signs her API request data to Service A and sends her ID Token to Service A.<p>4. Service A checks the ID Token (JWT) is issued by Google and that the identity (alice@gmail.com) is authorized to make this API call, then it extracts Alice&#x27;s public key from the ID Token and verifies the signature on the data in the API call. Then it passes the signed data to Service B.<p>5. Service B verifies everything again including that the data is validly signed by Alice. Service B could then write this data and its cryptographic prominence into the database.<p>Technically OpenPubkey uses a JWS, but it is a JWS composed of a JWT (ID Token) with additional signatures. OpenPubkey signed messages, like the ones passed via the API are also JWS.<p>I&#x27;m working on a system where each service in the path adds their signatures to the signed message so you can cryptographically enforce that messages must pass through particular services and then check that at during the database write or read. Using signature aggregation, you don&#x27;t get a linear increase in verification cost as the number of signatures increase. It doesn&#x27;t seem to add much overhead to service meshes since they are already standing up and tearing down mTLS tunnels.<p>The main question to me is how much autonomy do you want to give to your services. There are cases in which you want  services to query each other without those services having to prove that the call originated from a specific authorized user.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;openpubkey&#x2F;openpubkey">https:&#x2F;&#x2F;github.com&#x2F;openpubkey&#x2F;openpubkey</a><p>[1]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;CryptoKey&#x2F;extractable" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;CryptoKey&#x2F;e...</a></div><br/></div></div></div></div></div></div></div></div><div id="40492463" class="c"><input type="checkbox" id="c-40492463" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40492248">parent</a><span>|</span><a href="#40493799">prev</a><span>|</span><a href="#40492770">next</a><span>|</span><label class="collapse" for="c-40492463">[-]</label><label class="expand" for="c-40492463">[4 more]</label></div><br/><div class="children"><div class="content">Well a lot of value in application architectures like this is, I want to give something access to my Google Calendar forever, to schedule tasks and read stuff, expressly without user intervention. Most people want token exchange - that an all-powerful user token gets exchanged for a token with the privileges specific to the service that holds onto it. I don&#x27;t really want Google or Apple or whoever has, for idiosyncratic reasons, possession of a private key, to sign every request I make to Google Calendar, because they will inevitably revoke it sooner for obnoxious business reasons than any good security reason. And if I give a signing key to the service doing this deed for me, it&#x27;s kind of redundant to an ordinary exchanged JWT.<p>Really the ergonomics are why this hasn&#x27;t been adopted more readily. I wonder why it&#x27;s possible to have OpenTelemetry inject a header into thousands of different APIs and services for dozens of programming languages, more or less flawlessly. But if I wanted to do this at process boundaries, and the content of my header was the result of a stateless function of the current value of the header (aka token exchange + destination service): you are shit out of luck. Ultimately platform providers like Google, Apple and Meta lose their power when people do this, so I feel like the most sophisticated and cranky agitators are more or less right that the user experience is subordinate to the S&amp;P top 10&#x27;s bottom line, not real security concerns.</div><br/><div id="40492645" class="c"><input type="checkbox" id="c-40492645" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40492463">parent</a><span>|</span><a href="#40492770">next</a><span>|</span><label class="collapse" for="c-40492645">[-]</label><label class="expand" for="c-40492645">[3 more]</label></div><br/><div class="children"><div class="content">The first case sounds more like a case for OAuth which doesn&#x27;t have to use JWTs or digital signatures.<p>&gt; I don&#x27;t really want Google or Apple or whoever has, for idiosyncratic reasons, possession of a private key, to sign every request I make to Google Calendar, because they will inevitably revoke it sooner for obnoxious business reasons than any good security reason.<p>Can you provide more context on this? I would assume asymmetric signing keys are less likely to be revoked than say an HMAC key since an HMAC key must be securely stored at both the client and server whereas you can just put a asymmetric signing key in an HSM at the client and be done with it.</div><br/><div id="40493402" class="c"><input type="checkbox" id="c-40493402" checked=""/><div class="controls bullet"><span class="by">radicalbyte</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40492645">parent</a><span>|</span><a href="#40492770">next</a><span>|</span><label class="collapse" for="c-40493402">[-]</label><label class="expand" for="c-40493402">[2 more]</label></div><br/><div class="children"><div class="content">Which we have in modern computers and mobiles (the EU identity wallet concept is built around them).</div><br/><div id="40494411" class="c"><input type="checkbox" id="c-40494411" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493402">parent</a><span>|</span><a href="#40492770">next</a><span>|</span><label class="collapse" for="c-40494411">[-]</label><label class="expand" for="c-40494411">[1 more]</label></div><br/><div class="children"><div class="content">I thought the EU wallet was using JWTs that attest to public key. You don&#x27;t use them as bearer tokens, you use them as certificates and then do verifiable credential presentation via proof of possession and SD-JWTs.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40492770" class="c"><input type="checkbox" id="c-40492770" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40492189">parent</a><span>|</span><a href="#40492248">prev</a><span>|</span><a href="#40492199">next</a><span>|</span><label class="collapse" for="c-40492770">[-]</label><label class="expand" for="c-40492770">[2 more]</label></div><br/><div class="children"><div class="content">If someone nefarious steals your &lt;secret something&gt; then yes you have problems, this isn’t anything unique to JWTs</div><br/><div id="40493480" class="c"><input type="checkbox" id="c-40493480" checked=""/><div class="controls bullet"><span class="by">ummonk</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40492770">parent</a><span>|</span><a href="#40492199">next</a><span>|</span><label class="collapse" for="c-40493480">[-]</label><label class="expand" for="c-40493480">[1 more]</label></div><br/><div class="children"><div class="content">It makes a pretty big difference whether you have to send the secret down the wire to prove you possess it (e.g. a JWT, unlike say a private key).</div><br/></div></div></div></div></div></div><div id="40492199" class="c"><input type="checkbox" id="c-40492199" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492163">parent</a><span>|</span><a href="#40492189">prev</a><span>|</span><a href="#40493711">next</a><span>|</span><label class="collapse" for="c-40492199">[-]</label><label class="expand" for="c-40492199">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you don&#x27;t have microservices then there&#x27;s much less reason to use JWT&#x27;s.<p>Fair point. This post assumes a single database which opaque tokens can be mapped to. That said, a lot of smaller webapps are and should be monoliths.</div><br/></div></div><div id="40493711" class="c"><input type="checkbox" id="c-40493711" checked=""/><div class="controls bullet"><span class="by">Ozzie_osman</span><span>|</span><a href="#40492163">parent</a><span>|</span><a href="#40492199">prev</a><span>|</span><a href="#40493527">next</a><span>|</span><label class="collapse" for="c-40493711">[-]</label><label class="expand" for="c-40493711">[3 more]</label></div><br/><div class="children"><div class="content">Even with microservices, you still have the invalidation problem. I guess you could use non-Jwt for external auth and jwt between the services, but then you lose the benefit of standardization (and still don&#x27;t get full zero-trust). Or you could standardize on jwt, but then, invalidation problem again.</div><br/><div id="40493913" class="c"><input type="checkbox" id="c-40493913" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493711">parent</a><span>|</span><a href="#40493527">next</a><span>|</span><label class="collapse" for="c-40493913">[-]</label><label class="expand" for="c-40493913">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty rare in practice to be able to make authz decisions solely based on the information in JWT claims. Space in HTTP headers is limited and any moderately complex system will have a separate authz concept anyways that can be used to check for token invalidation.</div><br/><div id="40494640" class="c"><input type="checkbox" id="c-40494640" checked=""/><div class="controls bullet"><span class="by">hyperadvanced</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493913">parent</a><span>|</span><a href="#40493527">next</a><span>|</span><label class="collapse" for="c-40494640">[-]</label><label class="expand" for="c-40494640">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Learned this the hard way. JWT is good for “this token is legit and has XYZ role or group”, and letting it go to the next layer. The next layer should do some addition checking that token has legit claims on modifying a resource or taking other actions, however that might be.</div><br/></div></div></div></div></div></div><div id="40493527" class="c"><input type="checkbox" id="c-40493527" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#40492163">parent</a><span>|</span><a href="#40493711">prev</a><span>|</span><a href="#40492641">next</a><span>|</span><label class="collapse" for="c-40493527">[-]</label><label class="expand" for="c-40493527">[9 more]</label></div><br/><div class="children"><div class="content">Side question, anyone knows where the phrase &quot;used in anger&quot; comes from? I know it means using something in production but where does it come from?<p>Is it about battlefield and such?</div><br/><div id="40493613" class="c"><input type="checkbox" id="c-40493613" checked=""/><div class="controls bullet"><span class="by">mceachen</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493527">parent</a><span>|</span><a href="#40493566">next</a><span>|</span><label class="collapse" for="c-40493613">[-]</label><label class="expand" for="c-40493613">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always heard it as a shorter alternative to &quot;holy hell this tool is horrible but I&#x27;m unaware of an alternative, or cannot apply an alternative solution.&quot;</div><br/><div id="40495656" class="c"><input type="checkbox" id="c-40495656" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493613">parent</a><span>|</span><a href="#40496676">next</a><span>|</span><label class="collapse" for="c-40495656">[-]</label><label class="expand" for="c-40495656">[2 more]</label></div><br/><div class="children"><div class="content">Are you sure? I have never interpreted it this way and it is the first way I hear this interpretation.<p>My understanding: To use something &quot;for real&quot; on an actual project, not just toy around with it. (What you use can be good or bad, expression doesn&#x27;t say)</div><br/><div id="40498752" class="c"><input type="checkbox" id="c-40498752" checked=""/><div class="controls bullet"><span class="by">Zecc</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40495656">parent</a><span>|</span><a href="#40496676">next</a><span>|</span><label class="collapse" for="c-40498752">[-]</label><label class="expand" for="c-40498752">[1 more]</label></div><br/><div class="children"><div class="content">My interpretation has always been the same as mceachen&#x27;s, but other comments in this sub-thread have thought me I am wrong and your understanding is correct. Today I learned.<p>For what it&#x27;s worth[0]:<p>&gt; If you do something in anger, you do it in a real or important situation as it is intended to be done, rather than just learning or hearing about it<p>[0] <a href="https:&#x2F;&#x2F;dictionary.cambridge.org&#x2F;dictionary&#x2F;english&#x2F;in-anger" rel="nofollow">https:&#x2F;&#x2F;dictionary.cambridge.org&#x2F;dictionary&#x2F;english&#x2F;in-anger</a></div><br/></div></div></div></div><div id="40496676" class="c"><input type="checkbox" id="c-40496676" checked=""/><div class="controls bullet"><span class="by">7sidedmarble</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493613">parent</a><span>|</span><a href="#40495656">prev</a><span>|</span><a href="#40493566">next</a><span>|</span><label class="collapse" for="c-40496676">[-]</label><label class="expand" for="c-40496676">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s a military term. Firing a cannon in anger for instance means firing at the enemy, rather than in training.</div><br/></div></div></div></div><div id="40493566" class="c"><input type="checkbox" id="c-40493566" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493527">parent</a><span>|</span><a href="#40493613">prev</a><span>|</span><a href="#40496877">next</a><span>|</span><label class="collapse" for="c-40493566">[-]</label><label class="expand" for="c-40493566">[1 more]</label></div><br/><div class="children"><div class="content">It’s military based isn’t it? First time you use a weapon “in anger” is to test its effectiveness in real world conflict</div><br/></div></div><div id="40496877" class="c"><input type="checkbox" id="c-40496877" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493527">parent</a><span>|</span><a href="#40493566">prev</a><span>|</span><a href="#40495244">next</a><span>|</span><label class="collapse" for="c-40496877">[-]</label><label class="expand" for="c-40496877">[1 more]</label></div><br/><div class="children"><div class="content">Yes it’s an old britishism - comes from “shots fired in anger” (as opposed to training)</div><br/></div></div><div id="40495244" class="c"><input type="checkbox" id="c-40495244" checked=""/><div class="controls bullet"><span class="by">latentsea</span><span>|</span><a href="#40492163">root</a><span>|</span><a href="#40493527">parent</a><span>|</span><a href="#40496877">prev</a><span>|</span><a href="#40493892">next</a><span>|</span><label class="collapse" for="c-40495244">[-]</label><label class="expand" for="c-40495244">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it necessarily means using it in production but rather using it on some non-trivial capacity that exposes you to it&#x27;s various complexities and nuances such that you have more than just a surface level understanding. That probably coincides with using things in production a lot of the time, but that&#x27;s not strictly necessary.</div><br/></div></div></div></div><div id="40496313" class="c"><input type="checkbox" id="c-40496313" checked=""/><div class="controls bullet"><span class="by">ak217</span><span>|</span><a href="#40492163">parent</a><span>|</span><a href="#40492641">prev</a><span>|</span><a href="#40493383">next</a><span>|</span><label class="collapse" for="c-40496313">[-]</label><label class="expand" for="c-40496313">[1 more]</label></div><br/><div class="children"><div class="content">&gt; doesn&#x27;t seem to address microservice architectures at all<p>Or just, you know, service architectures. Most microservice architectures I&#x27;ve seen go way too far down the route of breaking up services and their infrastructure to an impractical level. But all you need in order to make JWTs really useful is two federated services. This happens all the time, often in the course of some partnership, acquisition, or just an organizational structure meant to decouple 2+ teams from each other.<p>Based on their mention of a single framework connecting to a single database, OP seems to have never moved past the point of developing a single service. Which is fine! It makes things simpler for sure, and you can get very far with that. But they are then dispensing advice about things they don&#x27;t seem to know much about.</div><br/></div></div><div id="40493383" class="c"><input type="checkbox" id="c-40493383" checked=""/><div class="controls bullet"><span class="by">johnnyAghands</span><span>|</span><a href="#40492163">parent</a><span>|</span><a href="#40496313">prev</a><span>|</span><a href="#40494813">next</a><span>|</span><label class="collapse" for="c-40493383">[-]</label><label class="expand" for="c-40493383">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I agree, but I think this post is for those cases where this design might be inappropriate, mainly monoliths with single dbs.<p>I disagree with the whole &quot;you&#x27;re not Google&#x2F;FB&quot;&#x2F;&quot;over arbitary RPS&quot; logic though. If the design makes sense then it makes sense, end of story. Just understand it.. lol</div><br/></div></div><div id="40494813" class="c"><input type="checkbox" id="c-40494813" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#40492163">parent</a><span>|</span><a href="#40493383">prev</a><span>|</span><a href="#40496478">next</a><span>|</span><label class="collapse" for="c-40494813">[-]</label><label class="expand" for="c-40494813">[1 more]</label></div><br/><div class="children"><div class="content">Same applies to non-micro service architectures.</div><br/></div></div></div></div><div id="40496478" class="c"><input type="checkbox" id="c-40496478" checked=""/><div class="controls bullet"><span class="by">oppositelock</span><span>|</span><a href="#40492163">prev</a><span>|</span><a href="#40492575">next</a><span>|</span><label class="collapse" for="c-40496478">[-]</label><label class="expand" for="c-40496478">[2 more]</label></div><br/><div class="children"><div class="content">JWT&#x27;s are perfectly fine if you don&#x27;t care about session revocation and their simplicity is an asset. They&#x27;re easy to work with and lots of library code is available in pretty much any language. The validation mistakes of the past have at this point been rectified.<p>Not needing a DB connection to verify means you don&#x27;t need to plumb a DB credentials or identity based auth into your service - simple.<p>Being able to decode it to see its contents really aids debugging, you don&#x27;t need to look in the DB - simple.<p>If you have a lot of individual services which share the same auth system, you can manage logins into multiple apps and API&#x27;s really easily.<p>That article seems to dislike JWT&#x27;s, but they&#x27;re just a tool. You can use them in a simple way that&#x27;s good enough for you, or you can overengineer a JWT based authentication mechanism, in which case they&#x27;re terrible. Whether or not to use them doesn&#x27;t really depend on their nature, but rather, your approach.</div><br/><div id="40498174" class="c"><input type="checkbox" id="c-40498174" checked=""/><div class="controls bullet"><span class="by">fefe23</span><span>|</span><a href="#40496478">parent</a><span>|</span><a href="#40492575">next</a><span>|</span><label class="collapse" for="c-40498174">[-]</label><label class="expand" for="c-40498174">[1 more]</label></div><br/><div class="children"><div class="content">You are confusing simplicity (it&#x27;s easy to understand and straightforward to implement safely) with convenience (I have zero understanding of how it works and couldn&#x27;t implement it securely if my life depended on it, but someone already wrote a library and I&#x27;m just going to pretend all risk is taken care of when I use it).</div><br/></div></div></div></div><div id="40492575" class="c"><input type="checkbox" id="c-40492575" checked=""/><div class="controls bullet"><span class="by">zemo</span><span>|</span><a href="#40496478">prev</a><span>|</span><a href="#40495597">next</a><span>|</span><label class="collapse" for="c-40492575">[-]</label><label class="expand" for="c-40492575">[14 more]</label></div><br/><div class="children"><div class="content">External services use jwts pretty often, so if you have to handle jwts anyway, using jwts means that there&#x27;s only one primitive, set of libraries, and concepts for your devs to know.<p>&quot;You don&#x27;t need all of that!&quot; sure but you probably already <i>have</i> it somewhere in your codebase and it&#x27;s pretty universal. You also probably don&#x27;t utilize every feature of http itself, that isn&#x27;t a cogent argument against using http.<p>JWTs are supported by a large number of tools, libraries, middleware appliances, etc; there&#x27;s a huge ecosystem out there to support it.<p>You also might delegate auth to a third party like Auth0 or FusionAuth so that you don&#x27;t handle <i>any</i> PII, because all of the PII is handled by a vendor, and you only store application-specific data.<p>&quot;You want to implement logout&quot; means a few things; in most apps you just ... have the client forget the token and you go about your day and it&#x27;s fine. &quot;but what about if a nefarious actor stole the token!!!&quot; you might say, but hand-rolled session tokens have the same problem.<p>&quot;You want to turn off access for all users&quot; is something you can do in http middleware; e.g., I have used middleware that do things like &quot;only allow through requests that have jwts with the &#x27;admin&#x27; role in their claims because we have turned off the system from users for downtime&quot;, and that works fine. (specifically I wrote a traefik plugin to do this in an afternoon).<p>&quot;You want to ban a single specific user really quickly&quot; is a thing JWT won&#x27;t do out of box.</div><br/><div id="40492719" class="c"><input type="checkbox" id="c-40492719" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40492575">parent</a><span>|</span><a href="#40495597">next</a><span>|</span><label class="collapse" for="c-40492719">[-]</label><label class="expand" for="c-40492719">[13 more]</label></div><br/><div class="children"><div class="content">The problem isn&#x27;t the mechanisms inside of JWT (though they are gross and worth avoiding on their own), it&#x27;s the systems-level tradeoffs you have to make to use them idiomatically, particularly around refresh tokens and revocation.<p>If you read this and think &quot;this doesn&#x27;t apply as long as I have to use JWTs for some service I rely on, anyways&quot;, you missed its point.</div><br/><div id="40493071" class="c"><input type="checkbox" id="c-40493071" checked=""/><div class="controls bullet"><span class="by">zemo</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40492719">parent</a><span>|</span><a href="#40495937">next</a><span>|</span><label class="collapse" for="c-40493071">[-]</label><label class="expand" for="c-40493071">[9 more]</label></div><br/><div class="children"><div class="content">refreshing the refresh token is always a database hit, and in the case of using a third party like Auth0 or FusionAuth, you can invalidate refresh tokens at the individual and at the user level. Saying &quot;the refresh token is the real token&quot; as the article does is pretty misleading; the refresh token always goes to the same system that would accept the username&#x2F;password, but the jwt itself gets carted around to other systems. So again, in the auth0&#x2F;fusionauth case, the refresh token is sent to auth0&#x2F;fusionauth, not your app, so even without any particular knowledge of what&#x27;s going on, the application developer is forced to utilize them in different ways. There&#x27;s a big assumption in this article that you&#x27;re talking about a monolithic system where logins are processed by the same application that handles all requests. Even if you <i>do</i> prefer to structure your application as a monolith and avoid microservices, once you delegate auth to a third party or a system separate from your app, the bearer token versus refresh token thing starts to matter a <i>lot</i>.<p>I think there&#x27;s a cyclic thing that&#x27;s been happening for <i>years</i> where people in the security community like to talk about how bad jwt is, but then not produce anything that meets application developers needs in a meaningful way. I spent <i>years</i> avoiding jwt and ultimately found avoiding jwts wasn&#x27;t actually a good use of my time.</div><br/><div id="40493157" class="c"><input type="checkbox" id="c-40493157" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40493071">parent</a><span>|</span><a href="#40493974">next</a><span>|</span><label class="collapse" for="c-40493157">[-]</label><label class="expand" for="c-40493157">[4 more]</label></div><br/><div class="children"><div class="content">This still doesn&#x27;t engage with the point. &quot;Refresh tokens&quot; are not a natural feature of every session scheme. They&#x27;re required by stateless JWTs because JWTs are motivated by migrating authN into its own independently-scaled microservice, and because online revocation is difficult in stateless schemes. If you just use your framework session system, you don&#x27;t ever think about refresh tokens. That&#x27;s the point the article is making. It&#x27;s not that JWT makes refresh harder, it&#x27;s that it makes it a thing at all.</div><br/><div id="40493299" class="c"><input type="checkbox" id="c-40493299" checked=""/><div class="controls bullet"><span class="by">zemo</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40493157">parent</a><span>|</span><a href="#40493974">next</a><span>|</span><label class="collapse" for="c-40493299">[-]</label><label class="expand" for="c-40493299">[3 more]</label></div><br/><div class="children"><div class="content">right so then the argument is less about &quot;should you use JWTs&quot; and more about &quot;should you use stateless session tokens&quot;.<p>&gt; JWTs are motivated by migrating authN into its own independently-scaled microservice<p>that&#x27;s definitely one use-case, although I don&#x27;t actually think having auth in a separate microservice under your own custody is the dominant use-case. The auth being in an entirely separate database means <i>PII</i> is in an entirely separate database, which can be a useful access control mechanism, or in the case of using a third-party auth service, means that <i>there is no PII in databases under your custody at all</i>. It makes the situation of &quot;developers can access all data created by the software that they work on&quot; really easy to implement while also maintaining &quot;developers do <i>not</i> have access to all of the PII&quot; as an access barrier. I think &quot;I just use Auth0&#x2F;FusionAuth and don&#x27;t think about it&quot; is actually the dominant use-case, and every third party offering that kind of developer experience utilizes stateless session tokens to make that happen.<p>&gt; If you just use your framework session system, you don&#x27;t ever think about refresh tokens.<p>right, but now the problem of keeping PII data access rules separate from your application domain data is an additional thing you have to engineer and think about securing, so I think the article is underestimating some of the negatives of that tradeoff; I&#x27;ve never seen a framework with a built in session system that did a good job of keeping access to the PII separate from the application data.</div><br/><div id="40493370" class="c"><input type="checkbox" id="c-40493370" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40493299">parent</a><span>|</span><a href="#40493974">next</a><span>|</span><label class="collapse" for="c-40493370">[-]</label><label class="expand" for="c-40493370">[2 more]</label></div><br/><div class="children"><div class="content">You wrote a comment upthread that misapprehended the post you were critiquing. I was motivated to offer some corrections. I&#x27;m less interested in the philosophical argument you now propose, except to say that PII segregation has only very rarely been the reason I&#x27;ve seen people adopt stateless tokens. It is <i>still</i> easier to segregate data using stateful token schemes than with JWT.<p>But I don&#x27;t want to pretend we&#x27;re still having the same conversation that started up thread. I assume you take my point, that if you think &quot;I already have to do JWT so I don&#x27;t save anything by not using them everywhere&quot; rebuts the post, you&#x27;ve misread it a bit.</div><br/><div id="40493477" class="c"><input type="checkbox" id="c-40493477" checked=""/><div class="controls bullet"><span class="by">zemo</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40493370">parent</a><span>|</span><a href="#40493974">next</a><span>|</span><label class="collapse" for="c-40493477">[-]</label><label class="expand" for="c-40493477">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you think &quot;I already have to do JWT so I don&#x27;t save anything by not using them everywhere&quot; rebuts the post<p>I have never believed that and I don&#x27;t think my comment ever suggested I did, I mentioned &quot;you might have jwt-handling tooling already&quot; as one concern among many, not an entire argument. It really seems like you&#x27;ve honed in on a single point and, as you would say, misapprehended my comment. That one argument is not reason alone to use JWT and I really don&#x27;t think my original comment ever implied I thought it was the entirety of the topic.</div><br/></div></div></div></div></div></div></div></div><div id="40493974" class="c"><input type="checkbox" id="c-40493974" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40493071">parent</a><span>|</span><a href="#40493157">prev</a><span>|</span><a href="#40495937">next</a><span>|</span><label class="collapse" for="c-40493974">[-]</label><label class="expand" for="c-40493974">[4 more]</label></div><br/><div class="children"><div class="content">My impression is that the article author is following the good old &quot;everything lives in my Rails monolith&quot; philosophy from 10 years ago where login and authn is just another library including db migrations that you slap onto your monolith to get user management set up in 15 minutes.</div><br/><div id="40494298" class="c"><input type="checkbox" id="c-40494298" checked=""/><div class="controls bullet"><span class="by">zemo</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40493974">parent</a><span>|</span><a href="#40495937">next</a><span>|</span><label class="collapse" for="c-40494298">[-]</label><label class="expand" for="c-40494298">[3 more]</label></div><br/><div class="children"><div class="content">in all fairness that&#x27;s what 95% of web application projects really should be.</div><br/><div id="40495033" class="c"><input type="checkbox" id="c-40495033" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40494298">parent</a><span>|</span><a href="#40495937">next</a><span>|</span><label class="collapse" for="c-40495033">[-]</label><label class="expand" for="c-40495033">[2 more]</label></div><br/><div class="children"><div class="content">70% of the web is Wordpress, so yeah.</div><br/><div id="40495951" class="c"><input type="checkbox" id="c-40495951" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40495033">parent</a><span>|</span><a href="#40495937">next</a><span>|</span><label class="collapse" for="c-40495951">[-]</label><label class="expand" for="c-40495951">[1 more]</label></div><br/><div class="children"><div class="content">95% of the non-wordpress part of the web.<p>We’re rebuilding our microservice hell as a monolith anyway.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40495937" class="c"><input type="checkbox" id="c-40495937" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40492719">parent</a><span>|</span><a href="#40493071">prev</a><span>|</span><a href="#40493365">next</a><span>|</span><label class="collapse" for="c-40495937">[-]</label><label class="expand" for="c-40495937">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure what you are trying to say here? That dealing with refresh token expiry revocation for a single system (and two sessions) is better than dealing with expiry and revocation for 3?<p>I see some strong arguments for standardizing on a single one.</div><br/></div></div><div id="40493365" class="c"><input type="checkbox" id="c-40493365" checked=""/><div class="controls bullet"><span class="by">notnullorvoid</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40492719">parent</a><span>|</span><a href="#40495937">prev</a><span>|</span><a href="#40495597">next</a><span>|</span><label class="collapse" for="c-40493365">[-]</label><label class="expand" for="c-40493365">[2 more]</label></div><br/><div class="children"><div class="content">Having authn stateless whether with JWTs or not is a bad idea. By extension refresh tokens are a bad idea. Doesn&#x27;t mean JWTs are a bad idea, if used as a general auth token they are fine. Implementing revocation of JWTs also isn&#x27;t very hard but you need somewhere to store the revocation state.</div><br/><div id="40493381" class="c"><input type="checkbox" id="c-40493381" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40492575">root</a><span>|</span><a href="#40493365">parent</a><span>|</span><a href="#40495597">next</a><span>|</span><label class="collapse" for="c-40493381">[-]</label><label class="expand" for="c-40493381">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, none of this is responsive to what I just wrote. I had a particular complaint about the critique I responded to, that&#x27;s all.</div><br/></div></div></div></div></div></div></div></div><div id="40495597" class="c"><input type="checkbox" id="c-40495597" checked=""/><div class="controls bullet"><span class="by">teliskr</span><span>|</span><a href="#40492575">prev</a><span>|</span><a href="#40497061">next</a><span>|</span><label class="collapse" for="c-40495597">[-]</label><label class="expand" for="c-40495597">[1 more]</label></div><br/><div class="children"><div class="content">Some people get entirely too dogmatic about their “XYZ is wrong, don’t do it!” beliefs.  At the time I implemented JWT in our system, many years ago; it was the most straightforward way to solve the problems that I had.  I read about the pitfalls and have yet to experience any of them.  So in short.. “no regrats” from this heathen.</div><br/></div></div><div id="40497061" class="c"><input type="checkbox" id="c-40497061" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#40495597">prev</a><span>|</span><a href="#40494243">next</a><span>|</span><label class="collapse" for="c-40497061">[-]</label><label class="expand" for="c-40497061">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the thing: neither Google, nor Facebook is using JWT for their access or refresh tokens. The only place they use JWT, as far as I know, is for the ID Token in their Open ID Connect Flow, since this is a mandatory (and terribly misguided) part of the spec.<p>I keep seeing the idea that JWT was designed for Google or Facebook scale being repeated over and over, but the reality is that neither company uses it. Last time I checked, both used rather short access and refresh tokens and it appears that at least the refresh token (if not both) is stateful.<p>Implementing stateful tokens on a global scale and sharing them across hundreds of service is HARD, but it&#x27;s easier when you are Google or Facebook, and you&#x27;ve got enough resources to throw at this trouble.<p>And if you do need to implement a stateful token, you&#x27;ve got every reason to choose your own format. Your applications are using your own authentication libraries and infrastructure (e.g. API gateways), so you don&#x27;t have to worry about complicating their life with a non-standard format. The upside for using your own stateless format is that you avoid all the design issues with JWT (alg=none, algorithm confusion, questionable support for outdated algorithms from the 1970s) and you can design a far more compact format that takes a fraction of the size of JWT[1].<p>There&#x27;s a reason JWT got popular with scrappy startups, enterprises hobby projects and Udemy&#x2F;Medium tutorial authors: they&#x27;re very easy to spin up and library support is everywhere. I don&#x27;t mean to say JWT is the right choice for any of these uses — it probably isn&#x27;t. But it&#x27;s the easy choice, the worse-is-better solution. The worse solution needs only be better in one respect to win: it should be easier to implement, copy and spread.<p>In the end of the day, JWT is not a good solution for either Google-scale companies or small startups. But it&#x27;s the small startups that usually lack the resources and awareness to adopt another solution.<p>[1] <a href="https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;api-tokens-a-tedious-survey&#x2F;#protobuf">https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;api-tokens-a-tedious-survey&#x2F;#protobuf</a></div><br/></div></div><div id="40494243" class="c"><input type="checkbox" id="c-40494243" checked=""/><div class="controls bullet"><span class="by">aranchelk</span><span>|</span><a href="#40497061">prev</a><span>|</span><a href="#40498459">next</a><span>|</span><label class="collapse" for="c-40494243">[-]</label><label class="expand" for="c-40494243">[1 more]</label></div><br/><div class="children"><div class="content">Even running in smaller environments:<p>1) You may not want your application servers having direct access to your auth service or auth database. You may not have the resources to control employee access to sensitive data when it’s shared across services. You may want to spend limited resources for security audits on the systems that contain the most sensitive data, and having them separated from everything else is helpful.<p>2) Depending on what 3rd party services you use it may not even be practical to have connectivity between auth and other services, and if you do, the latency may be bad enough that you wouldn’t want it to be blocking every request. This is especially compelling for hybrid environments, e.g. the 20 year old database in a colo with your user data, and a new service being built for you by consultants on a PaaS.<p>3) People act like revocation is such a nightmare, but you only need the auth service to sign invalidation tokens to be passed to the client-facing services, and those services only need to retain them for the max TTL of the auth tokens, after which they can be evicted. Yes, that’s something that could be motivated by having a massive environment like Google, it could also just be a way to keep costs down when you’re paying by the byte of storage or by the outbound request on some cloud. You could try to make the argument that storing invalidation data is just as bad as storing session data, but the key questions are “Where?” and “For how long?”, and then in some circumstances it breaks down very quickly.<p>4) You may not want sensitive user data stored in the jurisdictions where you want to host your apps. That’s not a big company problem, it’s dependent on the nature of the services you provide.</div><br/></div></div><div id="40498459" class="c"><input type="checkbox" id="c-40498459" checked=""/><div class="controls bullet"><span class="by">1penny42cents</span><span>|</span><a href="#40494243">prev</a><span>|</span><a href="#40492172">next</a><span>|</span><label class="collapse" for="c-40498459">[-]</label><label class="expand" for="c-40498459">[1 more]</label></div><br/><div class="children"><div class="content">It’s a great analysis but I think it’s too either-or.<p>If you have a monolith anyways then yes, why use a distributed systems solution like JWT? Completely agree.<p>But if you already have an auth service, making it optional for the majority of requests is a distributed systems win. Even if you need to implement forced logout or some other features which require hitting the auth database, they can be optional requests. If the auth service is available, you get better security, otherwise the services can decide whether to continue or not.<p>This is better than your entire app going down or slowing down with the auth service. Though the refresh token bit is still a challenge, it’s a smaller one than a hard dependency on the auth service on every request.<p>Again, if your auth service is just a component in your monolith, the author is completely right. It’s context-specific.</div><br/></div></div><div id="40492172" class="c"><input type="checkbox" id="c-40492172" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40498459">prev</a><span>|</span><a href="#40492440">next</a><span>|</span><label class="collapse" for="c-40492172">[-]</label><label class="expand" for="c-40492172">[5 more]</label></div><br/><div class="children"><div class="content">&gt; By just using a “normal” opaque session token and storing it in the database, the same way Google does with the refresh token, and dropping all jwt authentication token nonsense.<p>Not only is this true, but most actual deployments of JWTs just have you swap a JWT (ID Token) for a opaque session token.<p>That said, I really like having a JWT signed by an IDP which states the user&#x27;s identity because if designed correctly you only need to trust one party IDP. For instance Google (the IDP) is the ideal party to identify a gmail email address since you already have to trust them for this. I created OpenPubkey to leverage JWTs, while minimizing and in some cases removing trust.<p>OpenPubkey[0, 1] let&#x27;s you turn JWTs bearer tokens into certificates. This lets you use digital signatures with ephemeral secrets.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;openpubkey&#x2F;openpubkey">https:&#x2F;&#x2F;github.com&#x2F;openpubkey&#x2F;openpubkey</a>
[1]: <a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2023&#x2F;296" rel="nofollow">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2023&#x2F;296</a></div><br/><div id="40496286" class="c"><input type="checkbox" id="c-40496286" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40492172">parent</a><span>|</span><a href="#40495970">next</a><span>|</span><label class="collapse" for="c-40496286">[-]</label><label class="expand" for="c-40496286">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OpenPubkey let&#x27;s you turn JWTs bearer tokens into certificates.<p>This looks really awesome, thanks for sharing.</div><br/></div></div><div id="40495970" class="c"><input type="checkbox" id="c-40495970" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40492172">parent</a><span>|</span><a href="#40496286">prev</a><span>|</span><a href="#40492440">next</a><span>|</span><label class="collapse" for="c-40495970">[-]</label><label class="expand" for="c-40495970">[3 more]</label></div><br/><div class="children"><div class="content">Aren’t JWT bearer tokens certificates already? Only the issuing server has the private keys, and the public keys are used to validate that server signed them?</div><br/><div id="40496423" class="c"><input type="checkbox" id="c-40496423" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40492172">root</a><span>|</span><a href="#40495970">parent</a><span>|</span><a href="#40496734">next</a><span>|</span><label class="collapse" for="c-40496423">[-]</label><label class="expand" for="c-40496423">[1 more]</label></div><br/><div class="children"><div class="content">This is the other way around. It allows the user (token holder) to sign messages &quot;using&quot; the ID token.<p>To be able to sign a message you not only need the ID token but also the private&#x2F;signing key, and the corresponding public key is bound to the ID token (using the nonce field).<p>Thus you can prove that not only did Google say you are you, but you possess the signing key associated with the ID token that says so. Thus I can be sure someone else didn&#x27;t just steal your token in flight or from a log file for example.</div><br/></div></div><div id="40496734" class="c"><input type="checkbox" id="c-40496734" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492172">root</a><span>|</span><a href="#40495970">parent</a><span>|</span><a href="#40496423">prev</a><span>|</span><a href="#40492440">next</a><span>|</span><label class="collapse" for="c-40496734">[-]</label><label class="expand" for="c-40496734">[1 more]</label></div><br/><div class="children"><div class="content">Certificates use a signature to bind an identity to a public key.<p>JWT bearer tokens use a signature to issue an identity, but that don&#x27;t include the public key of that identity. The issuer has a public key, but the issuee does not.<p>There are plenty of JWTs that are certificates:<p>* proof-of-possession JWTs,<p>* self-issued JWTs, etc...</div><br/></div></div></div></div></div></div><div id="40492440" class="c"><input type="checkbox" id="c-40492440" checked=""/><div class="controls bullet"><span class="by">bebop</span><span>|</span><a href="#40492172">prev</a><span>|</span><a href="#40498505">next</a><span>|</span><label class="collapse" for="c-40492440">[-]</label><label class="expand" for="c-40492440">[33 more]</label></div><br/><div class="children"><div class="content">I would add two pros of jwts (I guess oauth 2 and oidc more specifically)<p>1. It standardizes your auth system. While sessions auth is mostly implemented in the same way across systems, learning oauth and oidc gives you a standard across the industry.<p>2. Jwts give an easy path to make “front end” applications and api authentication work in the same way. This in theory reduces your security surface area as all of your authnz code can be shared across your offerings.</div><br/><div id="40492535" class="c"><input type="checkbox" id="c-40492535" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40492440">parent</a><span>|</span><a href="#40497356">next</a><span>|</span><label class="collapse" for="c-40492535">[-]</label><label class="expand" for="c-40492535">[31 more]</label></div><br/><div class="children"><div class="content">3. Easy to implement.
4. Dont need to hit db.
5. Can store some information with the claim which is very convenient</div><br/><div id="40492626" class="c"><input type="checkbox" id="c-40492626" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492535">parent</a><span>|</span><a href="#40497356">next</a><span>|</span><label class="collapse" for="c-40492626">[-]</label><label class="expand" for="c-40492626">[30 more]</label></div><br/><div class="children"><div class="content">How do you revoke tokens if a one gets leaked without hitting a db? How long are your users vulnerable to attack?</div><br/><div id="40492801" class="c"><input type="checkbox" id="c-40492801" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492626">parent</a><span>|</span><a href="#40492893">next</a><span>|</span><label class="collapse" for="c-40492801">[-]</label><label class="expand" for="c-40492801">[2 more]</label></div><br/><div class="children"><div class="content">Good point.<p>If a short session time isnt good enough, you can use a simple key store to check for revoked tokens. Youll be hitting a db but its somewhat better since its just a very small db of revoked tokens.<p>Its hard for me to imagine though with like a 30 min or even few hour long token, under what circumstances you&#x27;d actually revoke tokens. If your db got leaked, you can rotate the key and invalidate all tokens. Otherwise, itd have to be something like you have some post login fraud detection in place. Cause jwt or not, if a user just signed in and a hacker got their auth token, what are you going to do? Sure you need to check the db to revoke it, but the problem is how would you know the tokens been compromised?</div><br/></div></div><div id="40492893" class="c"><input type="checkbox" id="c-40492893" checked=""/><div class="controls bullet"><span class="by">xorcist</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492626">parent</a><span>|</span><a href="#40492801">prev</a><span>|</span><a href="#40493032">next</a><span>|</span><label class="collapse" for="c-40492893">[-]</label><label class="expand" for="c-40492893">[12 more]</label></div><br/><div class="children"><div class="content">Another way to put it: &quot;Do you want a (functional) logout button?&quot;</div><br/><div id="40494129" class="c"><input type="checkbox" id="c-40494129" checked=""/><div class="controls bullet"><span class="by">tasuki</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492893">parent</a><span>|</span><a href="#40497296">next</a><span>|</span><label class="collapse" for="c-40494129">[-]</label><label class="expand" for="c-40494129">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not another way to put it. You can have a logout button which makes the client forget the jwt token.</div><br/><div id="40495779" class="c"><input type="checkbox" id="c-40495779" checked=""/><div class="controls bullet"><span class="by">pan69</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40494129">parent</a><span>|</span><a href="#40497296">next</a><span>|</span><label class="collapse" for="c-40495779">[-]</label><label class="expand" for="c-40495779">[2 more]</label></div><br/><div class="children"><div class="content">But if the jwt was leaked before the client forgot it, the jwt itself is still valid and can continued to be used by an attacker.</div><br/><div id="40497263" class="c"><input type="checkbox" id="c-40497263" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40495779">parent</a><span>|</span><a href="#40497296">next</a><span>|</span><label class="collapse" for="c-40497263">[-]</label><label class="expand" for="c-40497263">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if an extension to the concept of jwt that extends the cryptographics chain down into some hardware component such as a TPM or secure enclave is the right answer. Basically the payload of the token could contain a pubkey for checking a signature on the request payload. The logout button would then have two local effects on the client side: delete the token and tell the hardware component to forget the private key.</div><br/></div></div></div></div></div></div><div id="40497296" class="c"><input type="checkbox" id="c-40497296" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492893">parent</a><span>|</span><a href="#40494129">prev</a><span>|</span><a href="#40494338">next</a><span>|</span><label class="collapse" for="c-40497296">[-]</label><label class="expand" for="c-40497296">[3 more]</label></div><br/><div class="children"><div class="content">You can do what Google and everyone else does, which is store the revoked tokens. At scale this is easy to do efficiently and rarely requires a network request since the number of revoked unexpired tokens is small.</div><br/><div id="40497873" class="c"><input type="checkbox" id="c-40497873" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40497296">parent</a><span>|</span><a href="#40494338">next</a><span>|</span><label class="collapse" for="c-40497873">[-]</label><label class="expand" for="c-40497873">[2 more]</label></div><br/><div class="children"><div class="content">How does infrequentcy of revoked tokens reduce requests? Dont you have to check every token to see if its revoked?<p>Or Do all the server instances store a copy of all revoked tokens in memory&#x2F;local db?</div><br/><div id="40497903" class="c"><input type="checkbox" id="c-40497903" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40497873">parent</a><span>|</span><a href="#40494338">next</a><span>|</span><label class="collapse" for="c-40497903">[-]</label><label class="expand" for="c-40497903">[1 more]</label></div><br/><div class="children"><div class="content">All the servers can store a copy or a bloom filter because the number of revoked tokens is small and doesn&#x27;t change often</div><br/></div></div></div></div></div></div><div id="40494338" class="c"><input type="checkbox" id="c-40494338" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492893">parent</a><span>|</span><a href="#40497296">prev</a><span>|</span><a href="#40493032">next</a><span>|</span><label class="collapse" for="c-40494338">[-]</label><label class="expand" for="c-40494338">[5 more]</label></div><br/><div class="children"><div class="content">Why would you need to revoke on logout? Forgetting seems to be enough in all cases except maybe SSO revocation because in all other cases you can (and indeed often must) trust the client to protect the credential.</div><br/><div id="40495737" class="c"><input type="checkbox" id="c-40495737" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40494338">parent</a><span>|</span><a href="#40493032">next</a><span>|</span><label class="collapse" for="c-40495737">[-]</label><label class="expand" for="c-40495737">[4 more]</label></div><br/><div class="children"><div class="content">Because logging out is also supposed to invalidate the token so it can&#x27;t be reused by anyone who may have stolen it.<p>This thread is really making me despair. If you don&#x27;t see a problem with JWTs, you aren&#x27;t experienced enough to use JWTs.</div><br/><div id="40498634" class="c"><input type="checkbox" id="c-40498634" checked=""/><div class="controls bullet"><span class="by">thomasfromcdnjs</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40495737">parent</a><span>|</span><a href="#40497239">next</a><span>|</span><label class="collapse" for="c-40498634">[-]</label><label class="expand" for="c-40498634">[1 more]</label></div><br/><div class="children"><div class="content">I feel ya.<p>You have to store invalidated tokens anywhere they might pass through a service, which means you have to persist them for as long you can predict that there expiry will last. Simply putting them in a memory database isn&#x27;t 100% if that db gets flushed, and then you might start storing them in a disk database, which at that point, you might as well have just read the db in the first place using cookie auth.<p>In microservices, you generally have to put an invalidated JWT cache between every service, or compromised JWT&#x27;s are just floating around your intranet.<p>I&#x27;ve worked at a plethora of places who have JWT&#x27;s who have no invalidation strategy what so ever, the majority of developers think that when you log out and the user has forgotten the JWT then you are all good......</div><br/></div></div><div id="40497239" class="c"><input type="checkbox" id="c-40497239" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40495737">parent</a><span>|</span><a href="#40498634">prev</a><span>|</span><a href="#40493032">next</a><span>|</span><label class="collapse" for="c-40497239">[-]</label><label class="expand" for="c-40497239">[2 more]</label></div><br/><div class="children"><div class="content">I think you need to take this a step further and really define your threat model instead of being despaired :)<p>If an attacker is able to steal a victim&#x27;s cookie database, their system (or at the very least, their browser) is already deeply compromised. It is very likely that an attacker with such capabilities could prevent your website from ever sending the logout request (install a browser extension which blocks it, inject into the render process to silently drop it, modify the cached JavaScript on disk to inject code into the site, etc.). The logout functionality only works insofar as you trust the client, and in any circumstances where the client&#x27;s cookies could be stolen you really can&#x27;t trust the client. So logout revocation is not really a meaningful security boundary.</div><br/><div id="40498465" class="c"><input type="checkbox" id="c-40498465" checked=""/><div class="controls bullet"><span class="by">johtso</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40497239">parent</a><span>|</span><a href="#40493032">next</a><span>|</span><label class="collapse" for="c-40498465">[-]</label><label class="expand" for="c-40498465">[1 more]</label></div><br/><div class="children"><div class="content">How about the scenario of a stolen device that&#x27;s logged into the service. The victim logs in on another computer to try and reset their password and lock the thief out of the compromised account.<p>This can&#x27;t be done without revocation.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40493032" class="c"><input type="checkbox" id="c-40493032" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492626">parent</a><span>|</span><a href="#40492893">prev</a><span>|</span><a href="#40493002">next</a><span>|</span><label class="collapse" for="c-40493032">[-]</label><label class="expand" for="c-40493032">[4 more]</label></div><br/><div class="children"><div class="content">You can use a separate DB that acts more like a cache for revocations- usually something where you can set a time to live on the row equal to the duration of the token itself.<p>That keeps your application DB free for application load, while keeping your identity validation logic nice and snappy.<p>Of course, adding infrastructure may be intimidating, but most applications that face any real load are going to be using redis or something similar anyway at some place in the stack.</div><br/><div id="40493483" class="c"><input type="checkbox" id="c-40493483" checked=""/><div class="controls bullet"><span class="by">akerl_</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40493032">parent</a><span>|</span><a href="#40493002">next</a><span>|</span><label class="collapse" for="c-40493483">[-]</label><label class="expand" for="c-40493483">[3 more]</label></div><br/><div class="children"><div class="content">If I have to run a separate DB to check for revocations, why not skip JWTs and just use that separate DB for auth directly.</div><br/><div id="40493716" class="c"><input type="checkbox" id="c-40493716" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40493483">parent</a><span>|</span><a href="#40495872">next</a><span>|</span><label class="collapse" for="c-40493716">[-]</label><label class="expand" for="c-40493716">[1 more]</label></div><br/><div class="children"><div class="content">Not an issue for most cases but a cache of revoked tokens is going to be much smaller than a db of all users tokens.</div><br/></div></div><div id="40495872" class="c"><input type="checkbox" id="c-40495872" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40493483">parent</a><span>|</span><a href="#40493716">prev</a><span>|</span><a href="#40493002">next</a><span>|</span><label class="collapse" for="c-40495872">[-]</label><label class="expand" for="c-40495872">[1 more]</label></div><br/><div class="children"><div class="content">The advantage of redis or similar kv DBs &#x2F; caches comes in being lighter and faster than a full second database, mostly.<p>The secondary advantage is you don&#x27;t need to deal with cookie storage, sticky sessions or anything else along those lines.<p>If you&#x27;re manually hand crafting a server, go for it. If you&#x27;re treating them like cattle not pets, going stateless with a bearer token tends to be easier.</div><br/></div></div></div></div></div></div><div id="40493002" class="c"><input type="checkbox" id="c-40493002" checked=""/><div class="controls bullet"><span class="by">beeboobaa3</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492626">parent</a><span>|</span><a href="#40493032">prev</a><span>|</span><a href="#40495995">next</a><span>|</span><label class="collapse" for="c-40493002">[-]</label><label class="expand" for="c-40493002">[5 more]</label></div><br/><div class="children"><div class="content">Store reset_time per user. Use a message queue (or postgres notify) to <i>push</i> changes to this value to your apps. Check the user&#x27;s token was created after the reset_time when validating it.<p>You would be required to keep a Map&lt;UserId, Timestamp&gt; in memory, potentially with TTL. Most systems can handle this easily for their expected user load. If not, you should have the engineering capacity to figure it out ;)<p>Logout button sets reset_time to now, as does revoking tokens. This would only allow you to revoke all tokens for one user at the same time, but this tends to be fine, since JWTs should be short-lived anyway and apps should deal with the expectation of them being expired&#x2F;revoked.</div><br/><div id="40494397" class="c"><input type="checkbox" id="c-40494397" checked=""/><div class="controls bullet"><span class="by">nosefrog</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40493002">parent</a><span>|</span><a href="#40495995">next</a><span>|</span><label class="collapse" for="c-40494397">[-]</label><label class="expand" for="c-40494397">[4 more]</label></div><br/><div class="children"><div class="content">And hope your service hasn&#x27;t been restarted so it doesn&#x27;t lose the in-memory revocation list?</div><br/><div id="40494502" class="c"><input type="checkbox" id="c-40494502" checked=""/><div class="controls bullet"><span class="by">beeboobaa3</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40494397">parent</a><span>|</span><a href="#40495995">next</a><span>|</span><label class="collapse" for="c-40494502">[-]</label><label class="expand" for="c-40494502">[3 more]</label></div><br/><div class="children"><div class="content">Just populate the cache when you need it? You will need a database round trip for the first request per user per application restart, if they haven&#x27;t reset since. I assumed this was obvious.</div><br/><div id="40494568" class="c"><input type="checkbox" id="c-40494568" checked=""/><div class="controls bullet"><span class="by">nosefrog</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40494502">parent</a><span>|</span><a href="#40495995">next</a><span>|</span><label class="collapse" for="c-40494568">[-]</label><label class="expand" for="c-40494568">[2 more]</label></div><br/><div class="children"><div class="content">Oh, I didn&#x27;t realize that the design also has a database of revocations. In that case, you can just query that directly :P</div><br/><div id="40494604" class="c"><input type="checkbox" id="c-40494604" checked=""/><div class="controls bullet"><span class="by">beeboobaa3</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40494568">parent</a><span>|</span><a href="#40495995">next</a><span>|</span><label class="collapse" for="c-40494604">[-]</label><label class="expand" for="c-40494604">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll want to store your user credentials that they traded for a JWT somewhere. The point of using JWTs is that most of your requests don&#x27;t have to hit this database.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40495995" class="c"><input type="checkbox" id="c-40495995" checked=""/><div class="controls bullet"><span class="by">4star3star</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492626">parent</a><span>|</span><a href="#40493002">prev</a><span>|</span><a href="#40492684">next</a><span>|</span><label class="collapse" for="c-40495995">[-]</label><label class="expand" for="c-40495995">[1 more]</label></div><br/><div class="children"><div class="content">How do you find out a single token got leaked within the token lifetime? If it&#x27;s that easy to detect a leaked token, why aren&#x27;t you stopping the leak in the first place?</div><br/></div></div><div id="40492684" class="c"><input type="checkbox" id="c-40492684" checked=""/><div class="controls bullet"><span class="by">bebop</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492626">parent</a><span>|</span><a href="#40495995">prev</a><span>|</span><a href="#40492666">next</a><span>|</span><label class="collapse" for="c-40492684">[-]</label><label class="expand" for="c-40492684">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is the trade off. If you are working in an industry where you need to be highly sensitive for data access even for short periods of times then oauth&#x2F;oidc&#x2F;jwts are probably not for you. If you really need an emergency escape hatch you can always rotate your singing keys and jwks and invalidate all of your tokens and force everyone to sign back in.</div><br/></div></div><div id="40492666" class="c"><input type="checkbox" id="c-40492666" checked=""/><div class="controls bullet"><span class="by">moomoo11</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492626">parent</a><span>|</span><a href="#40492684">prev</a><span>|</span><a href="#40497356">next</a><span>|</span><label class="collapse" for="c-40492666">[-]</label><label class="expand" for="c-40492666">[4 more]</label></div><br/><div class="children"><div class="content">Use low TTL and put rate limits and other mechanisms in place?</div><br/><div id="40492821" class="c"><input type="checkbox" id="c-40492821" checked=""/><div class="controls bullet"><span class="by">jjice</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492666">parent</a><span>|</span><a href="#40497356">next</a><span>|</span><label class="collapse" for="c-40492821">[-]</label><label class="expand" for="c-40492821">[3 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re right, but it seems like you get into a tricky territory that&#x27;ll never be great (as everything with security has compromised). Too long is an issue for attacks, but convenient for users. Too short and you have to do an initial re-auth over and over again, partially defeating the benefits.<p>Even if the TTL is short, there are plenty of ways to compromise a token and use it immediately in an automated system.<p>If you&#x27;re using JWTs, I&#x27;d lean shorter TTLs and embrace this as a potential concern. Not sure what the best re-auth frequency is though. I&#x27;d be really interested to see other&#x27;s thoughts on that.</div><br/><div id="40493023" class="c"><input type="checkbox" id="c-40493023" checked=""/><div class="controls bullet"><span class="by">moomoo11</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40492821">parent</a><span>|</span><a href="#40497356">next</a><span>|</span><label class="collapse" for="c-40493023">[-]</label><label class="expand" for="c-40493023">[2 more]</label></div><br/><div class="children"><div class="content">But the token is used over SSL and the only way to get it afaik is to hijack the client device or somehow hijack the server. The first scenario is pretty rare and the second is pretty easy to avoid. I don’t think that’s really an edge case that’s concerning for 99% of applications.</div><br/><div id="40496790" class="c"><input type="checkbox" id="c-40496790" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#40492440">root</a><span>|</span><a href="#40493023">parent</a><span>|</span><a href="#40497356">next</a><span>|</span><label class="collapse" for="c-40496790">[-]</label><label class="expand" for="c-40496790">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the only way to get it afaik is to hijack the client device or somehow hijack the server.<p>Yet we have millions of passwords in dumps across the internet. Maybe hijacking the client or server is more common than thought?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40497356" class="c"><input type="checkbox" id="c-40497356" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#40492440">parent</a><span>|</span><a href="#40492535">prev</a><span>|</span><a href="#40498505">next</a><span>|</span><label class="collapse" for="c-40497356">[-]</label><label class="expand" for="c-40497356">[1 more]</label></div><br/><div class="children"><div class="content">OAuth2 has no dependency on JWT, and _most_ authentication cases don&#x27;t need OIDC, OAuth2 is enough.</div><br/></div></div></div></div><div id="40498505" class="c"><input type="checkbox" id="c-40498505" checked=""/><div class="controls bullet"><span class="by">vldb7</span><span>|</span><a href="#40492440">prev</a><span>|</span><a href="#40495632">next</a><span>|</span><label class="collapse" for="c-40498505">[-]</label><label class="expand" for="c-40498505">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think it is either-or type of choice. A lot, if not all arguments against that use of JWT disappear if you’re ok with compromise solution: user management actions will take time to propagate. If JWT lifetime is 5 mins, it means that all actions like logout, deactivating account etc will take 5 mins to finalize - and you’d be hitting the database exactly once per 5 mins for the purpose of checking if user is still active, refresh token is not barred by log out etc.</div><br/></div></div><div id="40495632" class="c"><input type="checkbox" id="c-40495632" checked=""/><div class="controls bullet"><span class="by">apatheticonion</span><span>|</span><a href="#40498505">prev</a><span>|</span><a href="#40496624">next</a><span>|</span><label class="collapse" for="c-40495632">[-]</label><label class="expand" for="c-40495632">[1 more]</label></div><br/><div class="children"><div class="content">I typically use a service like AWS cognito (using their built-in hosted UI) to handle authentication for my apps. That gives me MFA, Google&#x2F;Facebook login, email verification, etc for free and has a generous free tier.<p>I have a template that&#x27;s backed by terraform and the authentication client is in lambda so the whole thing is serverless, self-contained and practically free. So I just run &quot;terraform apply&quot; and I have scalable auth for my new service.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;alshdavid&#x2F;template-cognito">https:&#x2F;&#x2F;github.com&#x2F;alshdavid&#x2F;template-cognito</a> (only 1 dependency on AWS, everything else is stdlib)<p>If any service I create is lucky enough to break out of the free-tier and cost is an issue, then I can just move to another OAuth2&#x2F;OIDC provider. The auth mechanism Cognito uses is just a specification meaning I am not coupled to any one service provider (though the user accounts themselves are). Cognito, Auth0, IdentifyServer, or whatever - I can migrate if cost becomes a problem.<p>The big issue with JWTs are that, if lost, they give permissions to attackers without revocability.<p>For this reason, I keep auth-tokens short lived and refresh them often. Refresh-tokens are revocable and live for a few days. This means that a lost auth-token is only harmful for a few minutes while a lost refresh token is only harmful until revoked or expired.<p>Tokens are stored as path-specific http-only cookies so the only vector for attack is if a user physically opens devtools and gives an attacker the token - or if the attacker has access to the computer (physically or via a malicious terminal script).<p>High risk operations (e.g. delete account, delete content, anything high risk) requires &quot;step-up&quot; authentication - so a user is asked to re-authenticate in those cases.<p>Overall, when you consider that rolling your own authentication comes with the liability associated with holding user data (companies must announce a breach to users, etc) - if a service provider like Cognito is compromised, you won&#x27;t be liable or the only one affected.<p>JWTs have security concerns, but on balance, when used with third party provider, a sensible configuration and considering the risk of rolling your own - they are fine.</div><br/></div></div><div id="40496624" class="c"><input type="checkbox" id="c-40496624" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#40495632">prev</a><span>|</span><a href="#40496607">next</a><span>|</span><label class="collapse" for="c-40496624">[-]</label><label class="expand" for="c-40496624">[1 more]</label></div><br/><div class="children"><div class="content">So what’s “Facebook scale”?  Is there an edge TPS number? Number of discrete major services? If you are consistently doing 10TPS on 3 services, sure. But many systems are bigger than that.<p>Everyone wants to be big.  You can either frontload those problems, and risk drowning in irrelevant complexity, or defer them. The problem with deferring is that switching lanes appears like it will be expensive and time consuming.<p>The secret is that if you solve actual problems, rather than dreams and future hopes, the answers are almost always obvious. The work may be painful and people may be angry, but the rationale will be clear.</div><br/></div></div><div id="40496607" class="c"><input type="checkbox" id="c-40496607" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#40496624">prev</a><span>|</span><a href="#40496553">next</a><span>|</span><label class="collapse" for="c-40496607">[-]</label><label class="expand" for="c-40496607">[1 more]</label></div><br/><div class="children"><div class="content">Since JWTs can&#x27;t handle revocation on their own, the main benefit (other than the ability to do validation without a central authority) of JWTs over opaque tokens is the ability to embed data that an untrusted holder (ie client) can make use of. For example, attach the display name of the user and their avatar profile, so that even after the token expires the application can represent to the user who the token is (could be used for example to show a &quot;Sign back in, Tom&quot; view). This makes a Switch User feature very elegant to implement: the application need only store the signed authentication tokens, and those tokens are self describing.<p>Additionally, when using asymmetric validation, you can rely on JWTs as licenses: Your software can restrict offline features based on a locally stored token, simply by checking that the JWT was signed by the authority. In tandem with the ability to store metadata, your app (with code held by the untrusted user) can use the token to determine the user&#x27;s license features without requiring an always on connection. (Obviously patching out the license checks is another matter)<p>These features can be layered on top of opaque tokens, but since a JWT has all the benefits of an opaque token (store the opaque token as a claim just like the rest of the metadata), it&#x27;s actually a complete package that does it all without needing to roll it yourself.</div><br/></div></div><div id="40496553" class="c"><input type="checkbox" id="c-40496553" checked=""/><div class="controls bullet"><span class="by">menacingly</span><span>|</span><a href="#40496607">prev</a><span>|</span><a href="#40492077">next</a><span>|</span><label class="collapse" for="c-40496553">[-]</label><label class="expand" for="c-40496553">[4 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t use JWTs because we think we&#x27;re google scale, we use them because they&#x27;re kinda cool. Cheap, stateless auth across services is really handy. If I rolled my own solution, it would just look like a shitty jwt.<p>There are definitely arguments to me made against ridiculous over-engineering, modern web dev has taken the problems of 1% of engineers and made them problems for 100% of engineers, but I think this is a bit of a silly one to focus on</div><br/><div id="40496604" class="c"><input type="checkbox" id="c-40496604" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#40496553">parent</a><span>|</span><a href="#40492077">next</a><span>|</span><label class="collapse" for="c-40496604">[-]</label><label class="expand" for="c-40496604">[3 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t use JWT because we are NOT google scale.<p>A centralized database for sessions, and we can extend&#x2F;revoke any token anytime.</div><br/><div id="40496811" class="c"><input type="checkbox" id="c-40496811" checked=""/><div class="controls bullet"><span class="by">menacingly</span><span>|</span><a href="#40496553">root</a><span>|</span><a href="#40496604">parent</a><span>|</span><a href="#40496638">next</a><span>|</span><label class="collapse" for="c-40496811">[-]</label><label class="expand" for="c-40496811">[1 more]</label></div><br/><div class="children"><div class="content">I actually think the revocation argument is the over-engineering case here.<p>I&#x27;d argue that people who need to avoid hitting their database on every request outnumber people who need sub-minute revocation</div><br/></div></div><div id="40496638" class="c"><input type="checkbox" id="c-40496638" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#40496553">root</a><span>|</span><a href="#40496604">parent</a><span>|</span><a href="#40496811">prev</a><span>|</span><a href="#40492077">next</a><span>|</span><label class="collapse" for="c-40496638">[-]</label><label class="expand" for="c-40496638">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s interesting about this argument is that nothing is stopping you from doing this same thing using JWTs. Just generate your token and store it as a claim in the JWT. You can check the revocation of the stored token without even validating that the token is genuine, if that is fortuitous. What this buys you is the ability to attach clear text information with the token, and, if you are doing asymmetric validation, the ability to validate both the security credential and the included plaintext information in an untrusted (client side) setting.</div><br/></div></div></div></div></div></div><div id="40492077" class="c"><input type="checkbox" id="c-40492077" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#40496553">prev</a><span>|</span><a href="#40492239">next</a><span>|</span><label class="collapse" for="c-40492077">[-]</label><label class="expand" for="c-40492077">[5 more]</label></div><br/><div class="children"><div class="content">You <i>can</i> implement a blocklist of all the revoked JWT and publish it to all servers. The list should be small, because only otherwise valid tokens need to be included. It becomes so much more complicated than a simple check-the-db setup though.<p>I don&#x27;t think I would start with JWT if I did this again.</div><br/><div id="40492607" class="c"><input type="checkbox" id="c-40492607" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40492077">parent</a><span>|</span><a href="#40492164">next</a><span>|</span><label class="collapse" for="c-40492607">[-]</label><label class="expand" for="c-40492607">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re talking about tokens in general, not just JWT. The only alternative I know to tokens is to query the DB every time (or perhaps use a cache to make the lookup less often, but then you also have to find a way to invalidate the cache - back to square one?).</div><br/><div id="40494245" class="c"><input type="checkbox" id="c-40494245" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#40492077">root</a><span>|</span><a href="#40492607">parent</a><span>|</span><a href="#40492164">next</a><span>|</span><label class="collapse" for="c-40494245">[-]</label><label class="expand" for="c-40494245">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;re talking about tokens in general, not just JWT. 
Yes, all stateless tokens. But I have never seen an in-house token system that was not using JWT&#x27;s.<p>Yes, query the DB  or some sort of storage every time. It sounded so clean and nice and fast to just check JWTs without any network calls. But it ended up very messy and complicated. Might still be worth it in some cases, of course, but I would start my next project with random sessions stored in a db or redis or memcache or .. something :)<p>You can actually  do crazy stuff with your sessions as well, to avoid a normal db lookup. But in practice all services I have worked on would&#x2F;did not suffer noticeably for a fast DB lookup.</div><br/></div></div></div></div><div id="40492164" class="c"><input type="checkbox" id="c-40492164" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#40492077">parent</a><span>|</span><a href="#40492607">prev</a><span>|</span><a href="#40492239">next</a><span>|</span><label class="collapse" for="c-40492164">[-]</label><label class="expand" for="c-40492164">[2 more]</label></div><br/><div class="children"><div class="content">what would you do?</div><br/><div id="40494254" class="c"><input type="checkbox" id="c-40494254" checked=""/><div class="controls bullet"><span class="by">gizzlon</span><span>|</span><a href="#40492077">root</a><span>|</span><a href="#40492164">parent</a><span>|</span><a href="#40492239">next</a><span>|</span><label class="collapse" for="c-40494254">[-]</label><label class="expand" for="c-40494254">[1 more]</label></div><br/><div class="children"><div class="content">Sessions, like it&#x27;s 2005 :P See above.</div><br/></div></div></div></div></div></div><div id="40492239" class="c"><input type="checkbox" id="c-40492239" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#40492077">prev</a><span>|</span><a href="#40492697">next</a><span>|</span><label class="collapse" for="c-40492239">[-]</label><label class="expand" for="c-40492239">[6 more]</label></div><br/><div class="children"><div class="content">Browser sessions are not the only authentication scenario.<p>&gt; absolutely no one who is not Google&#x2F;Facebook needs to put up with the ensuing tradeoffs. If you process less than 10k requests per second, you’re not Google nor are you Facebook<p>What&#x27;s the magic property that flips when you pass 10K requests per second? Are we sure it&#x27;s at 10K requests per second, not 8K? or 5K? In general, at that kind of scale I&#x27;d think JWTs would become less appealing - AWS operates on IAM for example.<p>And why are Google and Facebook the best examples of companies who are operating at scale? There are different kinds of scale than just &#x27;ad auctions per second&#x27;. I would imagine the access management concerns of, say, JP Morgan Chase are at least as complex and challenging to scale as those of Facebook.</div><br/><div id="40492286" class="c"><input type="checkbox" id="c-40492286" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492239">parent</a><span>|</span><a href="#40494025">next</a><span>|</span><label class="collapse" for="c-40492286">[-]</label><label class="expand" for="c-40492286">[4 more]</label></div><br/><div class="children"><div class="content">I once operated a very low usage webservice that used JWT for auth. We got hit with a DDoS and it was trivial to mitigate by using AWS API gateway to drop HTTP requests that didn&#x27;t contain a valid JWT for the IDPs we supported.<p>Making authentication only require a signature verification at the edge (JWT) vs authentication middleware that needs to do a DB read (opaque), can be a life saver even if you have 10 requests a second most of the time.</div><br/><div id="40492443" class="c"><input type="checkbox" id="c-40492443" checked=""/><div class="controls bullet"><span class="by">etothepii</span><span>|</span><a href="#40492239">root</a><span>|</span><a href="#40492286">parent</a><span>|</span><a href="#40494025">next</a><span>|</span><label class="collapse" for="c-40492443">[-]</label><label class="expand" for="c-40492443">[3 more]</label></div><br/><div class="children"><div class="content">This is a great point. 10 requests per second is likely to be sufficient scale that you are noticeable to people that might want to attack you. The ability to validate the key before doing anything with it could be a huge time (and resource) saver on AWS.</div><br/><div id="40492823" class="c"><input type="checkbox" id="c-40492823" checked=""/><div class="controls bullet"><span class="by">logifail</span><span>|</span><a href="#40492239">root</a><span>|</span><a href="#40492443">parent</a><span>|</span><a href="#40494025">next</a><span>|</span><label class="collapse" for="c-40492823">[-]</label><label class="expand" for="c-40492823">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The ability to validate the key before doing anything with it [..]<p>Q: What about the endpoint that&#x27;s issuing the tokens?</div><br/><div id="40493126" class="c"><input type="checkbox" id="c-40493126" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492239">root</a><span>|</span><a href="#40492823">parent</a><span>|</span><a href="#40494025">next</a><span>|</span><label class="collapse" for="c-40493126">[-]</label><label class="expand" for="c-40493126">[1 more]</label></div><br/><div class="children"><div class="content">In OpenID Connect the endpoint is issuing the tokens is run by Google, Microsoft or some other company that is too big to fail (or rather if it fails everything goes down).<p>If you are issuing the tokens yourself, you can build a simple horizontally scaling identity service that only does authentication and token issuance. With refresh tokens, if that service goes down it only prevents users not already signed in from signing in. Generally users stay signed into to webapps for weeks at a time, so you have massively reduced the impact: rather than 100% of your users not being able to do anything on your site, now 0.5% of users are impacted.</div><br/></div></div></div></div></div></div></div></div><div id="40494025" class="c"><input type="checkbox" id="c-40494025" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40492239">parent</a><span>|</span><a href="#40492286">prev</a><span>|</span><a href="#40492697">next</a><span>|</span><label class="collapse" for="c-40494025">[-]</label><label class="expand" for="c-40494025">[1 more]</label></div><br/><div class="children"><div class="content">The notion that you have Google&#x2F;Facebook scale problems at 10k requests per second (vs 10s of millions of requests per second) is a pretty funny claim in its own right.</div><br/></div></div></div></div><div id="40492697" class="c"><input type="checkbox" id="c-40492697" checked=""/><div class="controls bullet"><span class="by">firefoxd</span><span>|</span><a href="#40492239">prev</a><span>|</span><a href="#40497820">next</a><span>|</span><label class="collapse" for="c-40492697">[-]</label><label class="expand" for="c-40492697">[1 more]</label></div><br/><div class="children"><div class="content">Some people made the distinction here, jwt on the front end vs the micro services across the network.<p>I&#x27;ve experienced more than once, issues where the auth service has bugs and the logged out session is still valid for a long time. Or an attacker that figured out the micro services blueprint and now had authed access to the entire network.<p>Jwt is still useful between services, however the front end can do just fine with a session id that can be easily revoked.</div><br/></div></div><div id="40497820" class="c"><input type="checkbox" id="c-40497820" checked=""/><div class="controls bullet"><span class="by">alex_young</span><span>|</span><a href="#40492697">prev</a><span>|</span><a href="#40494214">next</a><span>|</span><label class="collapse" for="c-40497820">[-]</label><label class="expand" for="c-40497820">[1 more]</label></div><br/><div class="children"><div class="content">“No.”<p>Whenever I see such a simple answer to a complex question, I know it’s probably an oversimplification.<p>The real answer is a solid “it depends on what you want to achieve.”<p>Say you handle invalidation by maintaining a cached table of revoked tokens. Is this table larger or smaller than the table of all users?<p>Perhaps you would like to embed some RBAC info in the token.  Is validating both the token and it’s absence from your revocation table more efficient than looking up all of the other information?<p>Perhaps you need to do this on a distributed basis.  Is the overhead of maintaining such a table more or less than making all the DB calls and creating a central choke point in your architecture?</div><br/></div></div><div id="40494214" class="c"><input type="checkbox" id="c-40494214" checked=""/><div class="controls bullet"><span class="by">jurassic</span><span>|</span><a href="#40497820">prev</a><span>|</span><a href="#40497664">next</a><span>|</span><label class="collapse" for="c-40494214">[-]</label><label class="expand" for="c-40494214">[3 more]</label></div><br/><div class="children"><div class="content">The more confidently people make blanket pronouncements, the less you should believe them. There are a lot of use cases for OAuth2 and OIDC that are not covered by “just use a web session”.<p>The real thing to push back on is the logout requirement. Everyone pretends they need this, when what almost everyone should do is just mandate appropriately short token lifetimes and revoke refresh tokens as needed.</div><br/><div id="40496161" class="c"><input type="checkbox" id="c-40496161" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40494214">parent</a><span>|</span><a href="#40497664">next</a><span>|</span><label class="collapse" for="c-40496161">[-]</label><label class="expand" for="c-40496161">[2 more]</label></div><br/><div class="children"><div class="content">&gt; revoke refresh tokens as needed<p>That’s a logout requirement?</div><br/><div id="40497290" class="c"><input type="checkbox" id="c-40497290" checked=""/><div class="controls bullet"><span class="by">jurassic</span><span>|</span><a href="#40494214">root</a><span>|</span><a href="#40496161">parent</a><span>|</span><a href="#40497664">next</a><span>|</span><label class="collapse" for="c-40497290">[-]</label><label class="expand" for="c-40497290">[1 more]</label></div><br/><div class="children"><div class="content">Not as I understand it. When I&#x27;ve seen this discussed, a &quot;logout requirement&quot; has usually meant some stakeholder thinks they need a way to prevent previously issued access tokens from being used even though the tokens are signed by the trusted authorization server and not expired (i.e. still valid). This requirement asks that you find a way to instantly shut off access even though the auth server has previously issued access tokens that should entitle the bearer to perform actions against protected resources until the token expires.<p>Blocking refresh in the authorization server is trivial, but trying to implement the same on access tokens in the resource server at the point of use breaks the entire security model of JWT. It&#x27;s unreliable, because now every resource server has to take on partial responsibility for authorization which multiplies opportunities for mistakes. As the OP points out, you need to keep track of some sort of block list and lose out on many of the benefits of JWT (i.e. a resource server being able to rely fully on claims in a signed token before allowing an action).<p>When people show up with this kind of requirement, in my experience, it is often because they foolishly configured a client with a very long expiration on access tokens (e.g. ~months&#x2F;years instead of ~minutes&#x2F;hours). This creates a problem when some aspect of a user&#x27;s access needs to change (e.g. disgruntled employee was fired, customer didn&#x27;t pay their bill, etc). You can address this more easily by pairing a short access token lifetime with a long refresh token lifetime.</div><br/></div></div></div></div></div></div><div id="40497664" class="c"><input type="checkbox" id="c-40497664" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40494214">prev</a><span>|</span><a href="#40493357">next</a><span>|</span><label class="collapse" for="c-40497664">[-]</label><label class="expand" for="c-40497664">[1 more]</label></div><br/><div class="children"><div class="content">Yes. I mean, no; you should use macaroons [1] instead, which are better than JWTs but are built on similar ideas.<p>[1]: <a href="https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;macaroons-escalated-quickly&#x2F;">https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;macaroons-escalated-quickly&#x2F;</a></div><br/></div></div><div id="40493357" class="c"><input type="checkbox" id="c-40493357" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#40497664">prev</a><span>|</span><a href="#40494734">next</a><span>|</span><label class="collapse" for="c-40493357">[-]</label><label class="expand" for="c-40493357">[3 more]</label></div><br/><div class="children"><div class="content">A former student of mine (Vera Yaseneva) redesigned our old auth architecture using jwts and I’m pretty happy with how it turned out. Maybe it is overkill for our simple autograder server, but it was fun getting it to work and I’m sure it is more secure than the old architecture which had many many flaws… it was a maintenance nightmare for years. After the redesign it has been a breeze. Here is the project <a href="https:&#x2F;&#x2F;github.com&#x2F;quickfeed&#x2F;quickfeed">https:&#x2F;&#x2F;github.com&#x2F;quickfeed&#x2F;quickfeed</a><p>The security arch is mainly in web&#x2F;auth and web&#x2F;interceptor packages if anyone is interested in learning from the code. It uses connectrpc, which has a nice interceptor arch.<p>Happy to share Vera’s thesis report if anyone is interested…</div><br/><div id="40493673" class="c"><input type="checkbox" id="c-40493673" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#40493357">parent</a><span>|</span><a href="#40494734">next</a><span>|</span><label class="collapse" for="c-40493673">[-]</label><label class="expand" for="c-40493673">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for sharing! I took a look at the code. Looks clean.<p>Please share her thesis. I&#x27;m interested.</div><br/><div id="40497233" class="c"><input type="checkbox" id="c-40497233" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#40493357">root</a><span>|</span><a href="#40493673">parent</a><span>|</span><a href="#40494734">next</a><span>|</span><label class="collapse" for="c-40497233">[-]</label><label class="expand" for="c-40497233">[1 more]</label></div><br/><div class="children"><div class="content">Here it is <a href="https:&#x2F;&#x2F;uis.brage.unit.no&#x2F;uis-xmlui&#x2F;bitstream&#x2F;handle&#x2F;11250&#x2F;3022596&#x2F;no.uis%3ainspera%3a92613534%3a6420238.pdf?sequence=1&amp;isAllowed=y" rel="nofollow">https:&#x2F;&#x2F;uis.brage.unit.no&#x2F;uis-xmlui&#x2F;bitstream&#x2F;handle&#x2F;11250&#x2F;3...</a></div><br/></div></div></div></div></div></div><div id="40494734" class="c"><input type="checkbox" id="c-40494734" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#40493357">prev</a><span>|</span><a href="#40496927">next</a><span>|</span><label class="collapse" for="c-40494734">[-]</label><label class="expand" for="c-40494734">[1 more]</label></div><br/><div class="children"><div class="content">So first of all, JWT is part of the OpenID Connect specification. So if you want to be either a service provider or identity provider for OIDC, you need to use JWTs as an authentication token in at least some cases.<p>Secondly, you don&#x27;t have to hit the database on every request. Unless you have really strict security requirements, you can have a short expiration time on the jwt with a refresh mechanism, and then you only have to check the database say once every 5 minutes.<p>Related to the above point, the database you check for the &quot;session&quot; token isn&#x27;t necessarily the same as the one used for other data used in the request, even if you are much smaller than Google or Facebook. It might not even ve the same type of database.<p>Finally, even if it makes sense to use a &quot;traditional&quot; session cookie for brower sessions, that probably doesn&#x27;t make sense for an external API, where the client may not have persistent cookies at all, and there may not really be a concept of a session.<p>So as was mentioned in another comment, I think the answer to the title question is a solid &quot;it depends&quot;.</div><br/></div></div><div id="40496927" class="c"><input type="checkbox" id="c-40496927" checked=""/><div class="controls bullet"><span class="by">redwoolf</span><span>|</span><a href="#40494734">prev</a><span>|</span><a href="#40498086">next</a><span>|</span><label class="collapse" for="c-40496927">[-]</label><label class="expand" for="c-40496927">[3 more]</label></div><br/><div class="children"><div class="content">I keep reading criticism of JWTs that involves impersonation or replay attacks. With JWT (or non JWT bearer tokens) you use a refresh token. It seems to me that if an attacker gets a JWT they also have the refresh token. So how are JWTs inherently more insecure than other authentication methods? Almost all data passed over the wire nowadays is TLS encrypted.<p>In my projects, we have used encrypted JWTs and it seems to me a fine solution. Log out can be implemented in a user facing client by deleting the JWT and refresh token. Given a short enough expiration time, this is sufficient for most use cases involving user facing applications. Isn’t it? Generally, at least in the domains of the applications I’ve worked on, users only intend to log out of their current application when logging out. Meaning if they are signed in on their phone and on their desktop browser, when they sign out in the browser they don’t intend to also log out of their phone application.<p>The only downside I see is that if you want to log out of all sessions it is impossible to implement without maintaining session state in the server.</div><br/><div id="40497024" class="c"><input type="checkbox" id="c-40497024" checked=""/><div class="controls bullet"><span class="by">mikeryan</span><span>|</span><a href="#40496927">parent</a><span>|</span><a href="#40498086">next</a><span>|</span><label class="collapse" for="c-40497024">[-]</label><label class="expand" for="c-40497024">[2 more]</label></div><br/><div class="children"><div class="content"><i>It seems to me that if an attacker gets a JWT they also have the refresh token.</i><p>No they don’t. JWTs can be used with third party services that  should never see a refresh token. Those are the requests that should be presumed vulnerable.</div><br/><div id="40497242" class="c"><input type="checkbox" id="c-40497242" checked=""/><div class="controls bullet"><span class="by">redwoolf</span><span>|</span><a href="#40496927">root</a><span>|</span><a href="#40497024">parent</a><span>|</span><a href="#40498086">next</a><span>|</span><label class="collapse" for="c-40497242">[-]</label><label class="expand" for="c-40497242">[1 more]</label></div><br/><div class="children"><div class="content">I’ve not come across such a use case as I’ve only ever written applications where we own both the service and the clients. Thanks for the explanation.</div><br/></div></div></div></div></div></div><div id="40498086" class="c"><input type="checkbox" id="c-40498086" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#40496927">prev</a><span>|</span><a href="#40492550">next</a><span>|</span><label class="collapse" for="c-40498086">[-]</label><label class="expand" for="c-40498086">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get why he is pretty sure everybody has only one database which stores user data and application data. At work we have user data in Keycloack and application data in at least 20 different databases.</div><br/></div></div><div id="40492550" class="c"><input type="checkbox" id="c-40492550" checked=""/><div class="controls bullet"><span class="by">lvlabguy</span><span>|</span><a href="#40498086">prev</a><span>|</span><a href="#40492333">next</a><span>|</span><label class="collapse" for="c-40492550">[-]</label><label class="expand" for="c-40492550">[1 more]</label></div><br/><div class="children"><div class="content">You should not use JWT if you have a single application in your organization. However, whenever you have multiple applications, you need some form of central authentication &#x2F; authorization service. Otherwise, you would have to maintain auth databases in each application, each application will need to be logged-in separately, you won&#x27;t be able to implement a simple &quot;suspend a user&#x27;s accounts after X unsuccessful auth attempt&quot;, you won&#x27;t have a central auth log.</div><br/></div></div><div id="40492333" class="c"><input type="checkbox" id="c-40492333" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#40492550">prev</a><span>|</span><a href="#40497535">next</a><span>|</span><label class="collapse" for="c-40492333">[-]</label><label class="expand" for="c-40492333">[9 more]</label></div><br/><div class="children"><div class="content">A big problem not addressed when not using a signature based authorization scheme is that you need to hit your database for every access attempt. This makes you much more susceptible to ddos attacks.<p>You need to be able to turn away malicious users as fast as possible. If you take the time to check a database first, that&#x27;s a precious resource they can consume.<p>&quot;Add a cache!&quot;, you might say? What if they use random client id and client secret for every request, how do you cache against that?</div><br/><div id="40492441" class="c"><input type="checkbox" id="c-40492441" checked=""/><div class="controls bullet"><span class="by">Y-bar</span><span>|</span><a href="#40492333">parent</a><span>|</span><a href="#40492418">next</a><span>|</span><label class="collapse" for="c-40492441">[-]</label><label class="expand" for="c-40492441">[4 more]</label></div><br/><div class="children"><div class="content">We use a rate-limiting rule in the existing firewall on the &#x2F;auth endpoint. Our default is on five failed attempts in a five minute window gets you a one hour ban.</div><br/><div id="40492965" class="c"><input type="checkbox" id="c-40492965" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#40492333">root</a><span>|</span><a href="#40492441">parent</a><span>|</span><a href="#40492418">next</a><span>|</span><label class="collapse" for="c-40492965">[-]</label><label class="expand" for="c-40492965">[3 more]</label></div><br/><div class="children"><div class="content">How do you fingerprint the requests? IP address?</div><br/><div id="40493258" class="c"><input type="checkbox" id="c-40493258" checked=""/><div class="controls bullet"><span class="by">Y-bar</span><span>|</span><a href="#40492333">root</a><span>|</span><a href="#40492965">parent</a><span>|</span><a href="#40493184">next</a><span>|</span><label class="collapse" for="c-40493258">[-]</label><label class="expand" for="c-40493258">[1 more]</label></div><br/><div class="children"><div class="content">Two ways, default key is [IP address + User ID] we also have a fallback with a higher limit on [IP address] only when we expect lots of attempts from e.g. a VPN.</div><br/></div></div><div id="40493184" class="c"><input type="checkbox" id="c-40493184" checked=""/><div class="controls bullet"><span class="by">tebbers</span><span>|</span><a href="#40492333">root</a><span>|</span><a href="#40492965">parent</a><span>|</span><a href="#40493258">prev</a><span>|</span><a href="#40492418">next</a><span>|</span><label class="collapse" for="c-40493184">[-]</label><label class="expand" for="c-40493184">[1 more]</label></div><br/><div class="children"><div class="content">The problem I had with IP address fingerprints is that we have a large number of customers all behind one hospital’s single IP address.</div><br/></div></div></div></div></div></div><div id="40492418" class="c"><input type="checkbox" id="c-40492418" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#40492333">parent</a><span>|</span><a href="#40492441">prev</a><span>|</span><a href="#40492755">next</a><span>|</span><label class="collapse" for="c-40492418">[-]</label><label class="expand" for="c-40492418">[1 more]</label></div><br/><div class="children"><div class="content">The client ID should be a primary key or some other indexed value, making those database hits fairly cheap.  You&#x27;d also typically have some kind of rate limiting.</div><br/></div></div><div id="40492755" class="c"><input type="checkbox" id="c-40492755" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40492333">parent</a><span>|</span><a href="#40492418">prev</a><span>|</span><a href="#40492547">next</a><span>|</span><label class="collapse" for="c-40492755">[-]</label><label class="expand" for="c-40492755">[1 more]</label></div><br/><div class="children"><div class="content">The article talks about when and how requests hit the database in <i>both</i> schemes, extensively.</div><br/></div></div><div id="40492547" class="c"><input type="checkbox" id="c-40492547" checked=""/><div class="controls bullet"><span class="by">dncornholio</span><span>|</span><a href="#40492333">parent</a><span>|</span><a href="#40492755">prev</a><span>|</span><a href="#40497535">next</a><span>|</span><label class="collapse" for="c-40492547">[-]</label><label class="expand" for="c-40492547">[2 more]</label></div><br/><div class="children"><div class="content">How do you think people make applications if every database call is suspectible to ddos?</div><br/><div id="40492717" class="c"><input type="checkbox" id="c-40492717" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#40492333">root</a><span>|</span><a href="#40492547">parent</a><span>|</span><a href="#40497535">next</a><span>|</span><label class="collapse" for="c-40492717">[-]</label><label class="expand" for="c-40492717">[1 more]</label></div><br/><div class="children"><div class="content">1. Authenticate using signed JWTs at the edge via something like AWS API Gateway.
2. If the attacker is smart enough to use valid JWTs from IDPs. Find the JWTs that match the DDoS attack and ban those identities at the edge. This rate limits the attacker to how quickly they can generate new accounts on say gmail or azure.
3. If the attacker is can generate new accounts fast enough, add a bloom filter to the edge of accounts you have seen before the attack started.<p>At some point the attacker either gives us or just switches to the brute force of flooding the pipes with so much traffic that the AS doing the filtering goes down. At that point it is now someone else&#x27;s problem. They might start de-peering the ASes generating the traffic.</div><br/></div></div></div></div></div></div><div id="40497535" class="c"><input type="checkbox" id="c-40497535" checked=""/><div class="controls bullet"><span class="by">devdiary</span><span>|</span><a href="#40492333">prev</a><span>|</span><a href="#40496637">next</a><span>|</span><label class="collapse" for="c-40497535">[-]</label><label class="expand" for="c-40497535">[1 more]</label></div><br/><div class="children"><div class="content">Start with usual session based authentication. Keep it until you see the absolute need to move to JWT. And make sure you understand JWT and &quot;invalidating JWT&quot; before using it - <a href="https:&#x2F;&#x2F;github.com&#x2F;gitcommitshow&#x2F;auth-jwt?tab=readme-ov-file#invalidating-jwt">https:&#x2F;&#x2F;github.com&#x2F;gitcommitshow&#x2F;auth-jwt?tab=readme-ov-file...</a></div><br/></div></div><div id="40496637" class="c"><input type="checkbox" id="c-40496637" checked=""/><div class="controls bullet"><span class="by">abalone</span><span>|</span><a href="#40497535">prev</a><span>|</span><a href="#40493554">next</a><span>|</span><label class="collapse" for="c-40496637">[-]</label><label class="expand" for="c-40496637">[2 more]</label></div><br/><div class="children"><div class="content">I see a flaw in the argument. He shifted from saying you&#x27;d use a 5 minute access token timeout to querying the DB on every request. There can actually be a big difference between those two scenarios. Some web APIs can be bursty. Even caching credentials for 5 minutes could take significant load off the DB.</div><br/><div id="40496696" class="c"><input type="checkbox" id="c-40496696" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#40496637">parent</a><span>|</span><a href="#40493554">next</a><span>|</span><label class="collapse" for="c-40496696">[-]</label><label class="expand" for="c-40496696">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pro JWT, but reducing load on the DB itself isn&#x27;t a massive argument in favor of JWTs, because an opaque token solution can simply cache the result of a revocation check at whatever time interval is comfortable for the use case of the token. So assuming the API has access to a cache layer, there isn&#x27;t a difference there. If there is no cache layer, there probably should be.<p>In a hyperscaler situation things are different, but we should avoid treating that as the norm.</div><br/></div></div></div></div><div id="40493554" class="c"><input type="checkbox" id="c-40493554" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#40496637">prev</a><span>|</span><label class="collapse" for="c-40493554">[-]</label><label class="expand" for="c-40493554">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m thankful every day I don&#x27;t have to work on a team where JWTs are a valid solution, and nobody suggests them regardless. What a nightmare.</div><br/></div></div></div></div></div></div></div></body></html>