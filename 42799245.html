<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737622878780" as="style"/><link rel="stylesheet" href="styles.css?v=1737622878780"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cloud.google.com/blog/products/api-management/understanding-grpc-openapi-and-rest-and-when-to-use-them">Understanding gRPC, OpenAPI and REST and when to use them in API design</a> <span class="domain">(<a href="https://cloud.google.com">cloud.google.com</a>)</span></div><div class="subtext"><span>hui-zheng</span> | <span>148 comments</span></div><br/><div><div id="42802116" class="c"><input type="checkbox" id="c-42802116" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#42800474">next</a><span>|</span><label class="collapse" for="c-42802116">[-]</label><label class="expand" for="c-42802116">[1 more]</label></div><br/><div class="children"><div class="content">Lot of gRPC hate here.<p>I like gRPC in terms of an API specification, because one only needs to define the “what”, whereas OpenAPI specs are about the “how”: parameter in path, query, body? I don’t care. Etc.<p>Plus the tooling: we ran into cases where we could only use the lowest common denominator of OpenAPI constructs to let different tech stacks communicate because of orthogonal limitations across OpenAPI codegenerators.<p>Plus, Buf’s gRPC linter that guarantees backwards compatibility.<p>Plus fewer silly discussions with REST-ish purists: “if an HTTP endpoint is idempotent should deleting the same resource twice give a 404 twice?” - dude, how’s that helping the company to make money?<p>Plus, easier communication of ideas and concepts between human readers of the (proto) spec.</div><br/></div></div><div id="42800474" class="c"><input type="checkbox" id="c-42800474" checked=""/><div class="controls bullet"><span class="by">jdwyah</span><span>|</span><a href="#42802116">prev</a><span>|</span><a href="#42800676">next</a><span>|</span><label class="collapse" for="c-42800474">[-]</label><label class="expand" for="c-42800474">[13 more]</label></div><br/><div class="children"><div class="content">If I could go back in time I would stop myself from ever learning about gRPC. I was so into the dream, but years later  way too many headaches. Don’t do it to yourself.<p>Saying gRPC hides the internals is a joke. You’ll get internals all right, when you’re blasting debug logging trying to figure out what the f is going on causing 1&#x2F;10 requests to fail and fine tuning 10-20 different poorly named and timeout &#x2F; retry settings.<p>Hours lost fighting with maven plugins. Hours lost debugging weird deadline exceeded. Hours lost with LBs that don’t like the esoteric http2. Firewall pain meaning we had to use Standard api anyway. Crappy docs. Hours lost trying to get error messages that don’t suck into observability.<p>I wish I’d never heard of it.</div><br/><div id="42800783" class="c"><input type="checkbox" id="c-42800783" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#42800474">parent</a><span>|</span><a href="#42802024">next</a><span>|</span><label class="collapse" for="c-42800783">[-]</label><label class="expand" for="c-42800783">[2 more]</label></div><br/><div class="children"><div class="content">IMO the problem with gRPC isn&#x27;t the protocol or the protobufs, but the terrible tooling - at least on the Java end. It generates shit code with awful developer ergonomics.<p>When you run the protobuf builder...<p>* The client stub is a concrete final class. It can&#x27;t be mocked in tests.<p>* When implementing a server, you have to extend a concrete class (not an interface).<p>* The server method has an async method signature. Screws up AOP-oriented behavior like `@Transactional`<p>* No support for exceptions.<p>* Immutable value classes yes, but you have to construct them with builders.<p>The net result is that if you want to use gRPC in your SOA, you have to write a lot of plumbing to hide the gRPC noise and get clean, testable code.<p>There&#x27;s no reason it has to be this way, but it is that way, and I don&#x27;t want to write my own protobuf compiler.<p>Thrift&#x27;s rpc compiler has many of the same problems, plus some others. Sigh.</div><br/><div id="42801798" class="c"><input type="checkbox" id="c-42801798" checked=""/><div class="controls bullet"><span class="by">rkagerer</span><span>|</span><a href="#42800474">root</a><span>|</span><a href="#42800783">parent</a><span>|</span><a href="#42802024">next</a><span>|</span><label class="collapse" for="c-42801798">[-]</label><label class="expand" for="c-42801798">[1 more]</label></div><br/><div class="children"><div class="content">Any alternatives that take a similar philosophy but get the tooling right?</div><br/></div></div></div></div><div id="42802024" class="c"><input type="checkbox" id="c-42802024" checked=""/><div class="controls bullet"><span class="by">bborud</span><span>|</span><a href="#42800474">parent</a><span>|</span><a href="#42800783">prev</a><span>|</span><a href="#42800839">next</a><span>|</span><label class="collapse" for="c-42802024">[-]</label><label class="expand" for="c-42802024">[1 more]</label></div><br/><div class="children"><div class="content">Since you mention Maven I&#x27;m going to make the assumption that you are using Java. I haven&#x27;t used Java in quite a while. The last 8 years or so I&#x27;ve been programming Go.<p>Your experience of gRPC seems to be very different from mine. How much of the difference in experience do you think might be down to Java and how much is down to gRPC as a technology?</div><br/></div></div><div id="42800839" class="c"><input type="checkbox" id="c-42800839" checked=""/><div class="controls bullet"><span class="by">dtquad</span><span>|</span><a href="#42800474">parent</a><span>|</span><a href="#42802024">prev</a><span>|</span><a href="#42801669">next</a><span>|</span><label class="collapse" for="c-42800839">[-]</label><label class="expand" for="c-42800839">[2 more]</label></div><br/><div class="children"><div class="content">Your problems has more to do with some implementations than the grpc&#x2F;protobuf specs themselves.<p>The modern .NET and C# experience with gRPC is so good that Microsoft has sunset its legacy RPC tech like WCF and gone all in on gRPC.</div><br/><div id="42800982" class="c"><input type="checkbox" id="c-42800982" checked=""/><div class="controls bullet"><span class="by">junto</span><span>|</span><a href="#42800474">root</a><span>|</span><a href="#42800839">parent</a><span>|</span><a href="#42801669">next</a><span>|</span><label class="collapse" for="c-42800982">[-]</label><label class="expand" for="c-42800982">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. The newest versions of .NET are now chef’s kiss and so damn fast.</div><br/></div></div></div></div><div id="42801669" class="c"><input type="checkbox" id="c-42801669" checked=""/><div class="controls bullet"><span class="by">divan</span><span>|</span><a href="#42800474">parent</a><span>|</span><a href="#42800839">prev</a><span>|</span><a href="#42800618">next</a><span>|</span><label class="collapse" for="c-42801669">[-]</label><label class="expand" for="c-42801669">[1 more]</label></div><br/><div class="children"><div class="content">I use gRPC with Go+Dart stack for years and never experienced these issues. Is it something specific to Java+gRPC?</div><br/></div></div><div id="42800618" class="c"><input type="checkbox" id="c-42800618" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#42800474">parent</a><span>|</span><a href="#42801669">prev</a><span>|</span><a href="#42800765">next</a><span>|</span><label class="collapse" for="c-42800618">[-]</label><label class="expand" for="c-42800618">[3 more]</label></div><br/><div class="children"><div class="content">The biggest project I’ve used it with was in Java.<p>Validating the output of the bindings protoc generated was more verbose and error prone than hand serializing data would have been.<p>The wire protocol is not type safe.  It has type tags, but they reuse the same tags for multiple datatypes.<p>Also, zig-zag integer encoding is slow.<p>Anyway, it’s a terrible RPC library.  Flatbuffer is the only one that I’ve encountered that is worse.</div><br/><div id="42800913" class="c"><input type="checkbox" id="c-42800913" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#42800474">root</a><span>|</span><a href="#42800618">parent</a><span>|</span><a href="#42800648">next</a><span>|</span><label class="collapse" for="c-42800913">[-]</label><label class="expand" for="c-42800913">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The wire protocol is not type safe. It has type tags, but they reuse the same tags for multiple datatypes.<p>When is this ever an issue in practice? Why would the client read int32 but then all of a sudden decide to read uint32?</div><br/></div></div><div id="42800648" class="c"><input type="checkbox" id="c-42800648" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#42800474">root</a><span>|</span><a href="#42800618">parent</a><span>|</span><a href="#42800913">prev</a><span>|</span><a href="#42800765">next</a><span>|</span><label class="collapse" for="c-42800648">[-]</label><label class="expand" for="c-42800648">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean with validating the bindings? GRPC is type safe. You don’t have to think about that part anymore.<p>But as the article mentions OpenAPI is also an RPC library with stub generation.<p>Manual parsing of the json is imho really Oldskool.<p>But it depends on your use case. That’s the whole point: it depends.</div><br/></div></div></div></div><div id="42800765" class="c"><input type="checkbox" id="c-42800765" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#42800474">parent</a><span>|</span><a href="#42800618">prev</a><span>|</span><a href="#42800676">next</a><span>|</span><label class="collapse" for="c-42800765">[-]</label><label class="expand" for="c-42800765">[3 more]</label></div><br/><div class="children"><div class="content">What would you recommend doing instead?</div><br/><div id="42800972" class="c"><input type="checkbox" id="c-42800972" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#42800474">root</a><span>|</span><a href="#42800765">parent</a><span>|</span><a href="#42800676">next</a><span>|</span><label class="collapse" for="c-42800972">[-]</label><label class="expand" for="c-42800972">[2 more]</label></div><br/><div class="children"><div class="content">Do you need bidirectional streams? If so, you should write a bespoke protocol, on top of UDP, TCP or websockets.<p>If you don&#x27;t, use GraphQL.</div><br/><div id="42801528" class="c"><input type="checkbox" id="c-42801528" checked=""/><div class="controls bullet"><span class="by">nithril</span><span>|</span><a href="#42800474">root</a><span>|</span><a href="#42800972">parent</a><span>|</span><a href="#42800676">next</a><span>|</span><label class="collapse" for="c-42801528">[-]</label><label class="expand" for="c-42801528">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Write a protocol and GraphQL&quot;, god damn it escalates quickly.<p>Fortunately, there are intermediate steps.</div><br/></div></div></div></div></div></div></div></div><div id="42800676" class="c"><input type="checkbox" id="c-42800676" checked=""/><div class="controls bullet"><span class="by">oppositelock</span><span>|</span><a href="#42800474">prev</a><span>|</span><a href="#42799946">next</a><span>|</span><label class="collapse" for="c-42800676">[-]</label><label class="expand" for="c-42800676">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been building API&#x27;s for a long time, using gRPC, and HTTP&#x2F;REST (we&#x27;ll not go into CORBA or DCOM, because I&#x27;ll cry). To that end, I&#x27;ve open sourced a Go library for generating your clients and servers from OpenAPI specs (<a href="https:&#x2F;&#x2F;github.com&#x2F;oapi-codegen&#x2F;oapi-codegen">https:&#x2F;&#x2F;github.com&#x2F;oapi-codegen&#x2F;oapi-codegen</a>).<p>I disagree with the way this article breaks down the options. There is no difference between OpenAPI and REST, it&#x27;s a strange distinction. OpenAPI is a way of documenting the behavior of your HTTP API. You can express a RESTful API using OpenAPI, or something completely random, it&#x27;s up to you. The purpose of OpenAPI is to have a schema language to describe your API for tooling to interpret, so in concept, it&#x27;s similar to Protocol Buffer files that are used to specify gRPC protocols.<p>gRPC is an RPC mechanism for sending protos back and forth. When Google open sourced protobufs, they didn&#x27;t opensource the RPC layer, called &quot;stubby&quot; at Google, which made protos really great. gRPC is not stubby, and it&#x27;s not as awesome, but it&#x27;s still very efficient at transport, and fairly easy too extend and hook into. The problem is, it&#x27;s a self-contained ecosystem that isn&#x27;t as robust as mainstream HTTP libraries, which give you all kinds of useful middleware like logging or auth. You&#x27;ll be implementing lots of these yourself with gRPC, particularly if you are making RPC calls across services implemented in different languages.<p>To me, the problem with gRPC is proto files. Every client must be built against .proto files compatible with the server; it&#x27;s not a discoverable protocol. With an HTTP API, you can make calls to it via curl or your own code without having the OpenAPI description, so it&#x27;s a &quot;softer&quot; binding. This fact alone makes it easier to work with and debug.</div><br/><div id="42800824" class="c"><input type="checkbox" id="c-42800824" checked=""/><div class="controls bullet"><span class="by">mandevil</span><span>|</span><a href="#42800676">parent</a><span>|</span><a href="#42800771">next</a><span>|</span><label class="collapse" for="c-42800824">[-]</label><label class="expand" for="c-42800824">[1 more]</label></div><br/><div class="children"><div class="content">There is a distinction between (proper) REST and what this blog calls &quot;OpenAPI&quot;. But the thing is, almost no one builds a true, proper REST API. In practice, everyone uses the OpenAPI approach.<p>The way that REST was defined by Roy Fielding in his 2000 Ph.D dissertation (&quot;Architectural Styles and the Design of Network-based Software Architectures&quot;) it was supposed to allow a web-like exploring of all available resources. You would GET the root URL, and the 200 OK Response would provide a set of links that would allow you to traverse all available resources provided by the API (it was allowed to be hierarchical- but everything had to be accessible somewhere in the link tree). This was supposed to allow discoverability.<p>In practice, everywhere I&#x27;ve ever worked over the past two decades has just used POST resource_name&#x2F;resource_id&#x2F;sub_resource&#x2F;sub_resource_id&#x2F;mutatation_type- or PUT resource_name&#x2F;resource_id&#x2F;sub_resource&#x2F;sub_resource_id depending on how that company handled the idempotency issues that PUT creates- with all of those being magic URL&#x27;s assembled by the client with knowledge of the structure (often defined in something like Swagger&#x2F;OpenAPI), lacking the link-traversal from root that was a hallmark of Fielding&#x27;s original work.<p>Pedants (which let&#x27;s face it, most of us are) will often describe what is done in practice as &quot;RESTful&quot; rather than &quot;REST&quot; just to acknowledge that they are not implementing Fielding&#x27;s definition of REST.</div><br/></div></div><div id="42800771" class="c"><input type="checkbox" id="c-42800771" checked=""/><div class="controls bullet"><span class="by">physicles</span><span>|</span><a href="#42800676">parent</a><span>|</span><a href="#42800824">prev</a><span>|</span><a href="#42801095">next</a><span>|</span><label class="collapse" for="c-42800771">[-]</label><label class="expand" for="c-42800771">[8 more]</label></div><br/><div class="children"><div class="content">&gt; There is no difference between OpenAPI and REST, it&#x27;s a strange distinction.<p>That threw me off too. What the article calls REST, I understand to be closer to HATEOAS.<p>&gt; I&#x27;ve open sourced a Go library for generating your clients and servers from OpenAPI specs<p>As a maintainer of a couple pretty substantial APIs with internal and external clients, I&#x27;m really struggling to understand the workflow that starts with generating code from OpenAPI specs. Once you&#x27;ve filled in all those generated stubs, how can you then iterate on the API spec? The tooling will just give you more stubs that you have to manually merge in, and it&#x27;ll get harder and harder to find the relevant updates as the API grows.<p>This is why I created an abomination that uses go&#x2F;ast and friends to <i>generate the OpenAPI spec from the code</i>. It&#x27;s not perfect, but it&#x27;s a 95% solution that works with both Echo and Gin. So when we need to stand up a new endpoint and allow the front end to start coding against it ASAP, the workflow looks like this:<p>1. In a feature branch, define the request and response structs, and write an empty handler that parses parameters and returns an empty response.<p>2. Generate the docs and send them to the front end dev.<p>Now, most devs never have to think about how to express their API in OpenAPI. And the docs will always be perfectly in sync with the code.</div><br/><div id="42800847" class="c"><input type="checkbox" id="c-42800847" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#42800676">root</a><span>|</span><a href="#42800771">parent</a><span>|</span><a href="#42801079">next</a><span>|</span><label class="collapse" for="c-42800847">[-]</label><label class="expand" for="c-42800847">[1 more]</label></div><br/><div class="children"><div class="content">HATEOAS is just REST as originally envisioned but accepting that the REST name has come to be attached to something different.</div><br/></div></div><div id="42801079" class="c"><input type="checkbox" id="c-42801079" checked=""/><div class="controls bullet"><span class="by">ak217</span><span>|</span><a href="#42800676">root</a><span>|</span><a href="#42800771">parent</a><span>|</span><a href="#42800847">prev</a><span>|</span><a href="#42801648">next</a><span>|</span><label class="collapse" for="c-42801079">[-]</label><label class="expand" for="c-42801079">[1 more]</label></div><br/><div class="children"><div class="content">In my part of the industry, a rite of passage is coming up with one&#x27;s own homegrown data pipeline workflow manager&#x2F;DAG execution engine.<p>In the OpenAPI world, the equivalent must be writing one&#x27;s own OpenAPI spec generator that scans an annotated server codebase, probably bundled with a client codegen tool as well. I know I&#x27;ve written one (mine too was a proper abomination) and it sounds like so have a few others in this thread.</div><br/></div></div><div id="42801648" class="c"><input type="checkbox" id="c-42801648" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#42800676">root</a><span>|</span><a href="#42800771">parent</a><span>|</span><a href="#42801079">prev</a><span>|</span><a href="#42801013">next</a><span>|</span><label class="collapse" for="c-42801648">[-]</label><label class="expand" for="c-42801648">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is why I created an abomination that uses go&#x2F;ast and friends to generate the OpenAPI spec from the code<p>OpenAPI is a spec not documentation. Write the spec first then <i>generate the code</i> from the spec.<p>You are doing it backwards, at least in my opinion.</div><br/></div></div><div id="42801013" class="c"><input type="checkbox" id="c-42801013" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#42800676">root</a><span>|</span><a href="#42800771">parent</a><span>|</span><a href="#42801648">prev</a><span>|</span><a href="#42801424">next</a><span>|</span><label class="collapse" for="c-42801013">[-]</label><label class="expand" for="c-42801013">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This is why I created an abomination that uses go&#x2F;ast and friends to generate the OpenAPI spec from the code.<p>This is against &quot;interface first&quot; principle and couples clients of your API to its implementation.<p>That might be OK if the only consumer of the API is your own application as in that case API is really just an internal implementation detail. But even then - once you have to support multiple versions of your own client it becomes difficult not to break them.</div><br/><div id="42801344" class="c"><input type="checkbox" id="c-42801344" checked=""/><div class="controls bullet"><span class="by">physicles</span><span>|</span><a href="#42800676">root</a><span>|</span><a href="#42801013">parent</a><span>|</span><a href="#42801509">next</a><span>|</span><label class="collapse" for="c-42801344">[-]</label><label class="expand" for="c-42801344">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why it couples clients to the implementation.<p>Effectively, there&#x27;s no difference between writing the code first and updating the OpenAPI spec, and updating the spec first and then doing some sort of code gen to update the implementation. The end state of the world is the same.<p>In either case, modifications to the spec will be scrutinized to make sure there are no breaking changes.</div><br/></div></div><div id="42801509" class="c"><input type="checkbox" id="c-42801509" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#42800676">root</a><span>|</span><a href="#42801013">parent</a><span>|</span><a href="#42801344">prev</a><span>|</span><a href="#42801424">next</a><span>|</span><label class="collapse" for="c-42801509">[-]</label><label class="expand" for="c-42801509">[1 more]</label></div><br/><div class="children"><div class="content">OpenAPI spec being authored by a human or a machine, it can still be the same YAML at the end of the day, so why would one approach be more brittle &#x2F; breaks your clients than the other?</div><br/></div></div></div></div><div id="42801424" class="c"><input type="checkbox" id="c-42801424" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42800676">root</a><span>|</span><a href="#42800771">parent</a><span>|</span><a href="#42801013">prev</a><span>|</span><a href="#42801095">next</a><span>|</span><label class="collapse" for="c-42801424">[-]</label><label class="expand" for="c-42801424">[1 more]</label></div><br/><div class="children"><div class="content">The oapi-codegen tool the OP was put out (which I use) solves this by emitting an interface though. OpenAPI has the concept of operation names (which also have a standard pattern), so your generated code is simply implementing operation names. You can happily rewrite the entire spec and provided operation names are the same, everything will still map correctly - which solves the coupling problem.</div><br/></div></div></div></div><div id="42801095" class="c"><input type="checkbox" id="c-42801095" checked=""/><div class="controls bullet"><span class="by">TheGoodBarn</span><span>|</span><a href="#42800676">parent</a><span>|</span><a href="#42800771">prev</a><span>|</span><a href="#42799946">next</a><span>|</span><label class="collapse" for="c-42801095">[-]</label><label class="expand" for="c-42801095">[1 more]</label></div><br/><div class="children"><div class="content">Just chiming in to say we use oapi-codegen everyday and it’s phenomenal.<p>Migrated away from Swaggo -&gt; oapi during a large migration to be interface first for separating out large vertical slices and it’s been a godsend.</div><br/></div></div></div></div><div id="42799946" class="c"><input type="checkbox" id="c-42799946" checked=""/><div class="controls bullet"><span class="by">bitzun</span><span>|</span><a href="#42800676">prev</a><span>|</span><a href="#42800563">next</a><span>|</span><label class="collapse" for="c-42799946">[-]</label><label class="expand" for="c-42799946">[9 more]</label></div><br/><div class="children"><div class="content">Unless you are doing bidirectional streaming (for which it seems pretty well suited, but I haven&#x27;t used it, so it might be a fucking mess), grpc is usually a waste of time. Runtime transitive dependency hell, toolchain hell, and the teams inside Google that manage various implementations philosophically disagree on how basic features should work. Try exposing a grpc api to a team that doesn&#x27;t use your language (particularly if they&#x27;re using a language that isn&#x27;t go, python or java, or is an old version of those.) Try exposing a grpc api to integrate with a cots product. Try exposing a grpc api to a browser. All will require a middleware layer.</div><br/><div id="42802101" class="c"><input type="checkbox" id="c-42802101" checked=""/><div class="controls bullet"><span class="by">txdv</span><span>|</span><a href="#42799946">parent</a><span>|</span><a href="#42799976">next</a><span>|</span><label class="collapse" for="c-42802101">[-]</label><label class="expand" for="c-42802101">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Try exposing a grpc api to a browser<p>I remember being grilled for not creating &quot;jsony&quot; interfaces:<p>message Response {
  string id = 1;
  oneof sub {
    SubTypeOne sub_type_one = 2;
    SubTypeTwo sub_type_two = 3;
  }
}<p>message SubTypeOne {
  string field = 1;
}<p>message SubTypeTwo {
}<p>In your current model you just don&#x27;t have any fields in this subtype, but the response looked like this with our auto translator:
 { &quot;id&quot;: &quot;id&quot;, &quot;sub_type_two&quot;: { } }<p>Functionally, it works, and code written for this will work if new fields appear. However, returning empty objects to signify the type of response is strange in the web world. But when you write the protobuf you might not notice</div><br/></div></div><div id="42799976" class="c"><input type="checkbox" id="c-42799976" checked=""/><div class="controls bullet"><span class="by">lordofgibbons</span><span>|</span><a href="#42799946">parent</a><span>|</span><a href="#42802101">prev</a><span>|</span><a href="#42800956">next</a><span>|</span><label class="collapse" for="c-42799976">[-]</label><label class="expand" for="c-42799976">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used grpc at multiple companies and teams within these companies, all of them 100-500ish engineering team size, and never had these dependency and tool chain issues. It was smooth sailing with grpc.</div><br/><div id="42800309" class="c"><input type="checkbox" id="c-42800309" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42799946">root</a><span>|</span><a href="#42799976">parent</a><span>|</span><a href="#42800956">next</a><span>|</span><label class="collapse" for="c-42800309">[-]</label><label class="expand" for="c-42800309">[1 more]</label></div><br/><div class="children"><div class="content">I have worked full time at now two companies of that size making the dependency and tool chain problems not be a problem for all the normies.</div><br/></div></div></div></div><div id="42799994" class="c"><input type="checkbox" id="c-42799994" checked=""/><div class="controls bullet"><span class="by">aaomidi</span><span>|</span><a href="#42799946">parent</a><span>|</span><a href="#42800956">prev</a><span>|</span><a href="#42800563">next</a><span>|</span><label class="collapse" for="c-42799994">[-]</label><label class="expand" for="c-42799994">[4 more]</label></div><br/><div class="children"><div class="content">Bidirectional streaming is generally a bad idea for anything you’re going to want to run “at scale” for what it’s worth.</div><br/><div id="42800577" class="c"><input type="checkbox" id="c-42800577" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#42799946">root</a><span>|</span><a href="#42799994">parent</a><span>|</span><a href="#42800563">next</a><span>|</span><label class="collapse" for="c-42800577">[-]</label><label class="expand" for="c-42800577">[3 more]</label></div><br/><div class="children"><div class="content">Why do you say that? I&#x27;m involved in the planning for bidi streaming for a product that supports over 200M monthly active users. I am genuinely curious what landmines we&#x27;re about to step on.</div><br/><div id="42802051" class="c"><input type="checkbox" id="c-42802051" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#42799946">root</a><span>|</span><a href="#42800577">parent</a><span>|</span><a href="#42801744">next</a><span>|</span><label class="collapse" for="c-42802051">[-]</label><label class="expand" for="c-42802051">[1 more]</label></div><br/><div class="children"><div class="content">bidi streaming screws with a whole bunch of assumptions you rely on in usual fault-tolerant software:<p>- there are multiple ways to retry - you can retry establishing the connection (e.g. say DNS resolution fails for a 30s window) _or_ you can retry establishing the stream<p>- your load-balancer needs to persist the stream to the backend; it can&#x27;t just re-route per single HTTP request&#x2F;response<p>- how long are your timeouts? if you don&#x27;t receive a message for 1s, OK, the client can probably keep the stream open, but what if you don&#x27;t receive a message for 30s? this percolates through the entire request path, generally in the form of &quot;how do I detect when a service in the request path has failed&quot;</div><br/></div></div><div id="42801744" class="c"><input type="checkbox" id="c-42801744" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#42799946">root</a><span>|</span><a href="#42800577">parent</a><span>|</span><a href="#42802051">prev</a><span>|</span><a href="#42800563">next</a><span>|</span><label class="collapse" for="c-42801744">[-]</label><label class="expand" for="c-42801744">[1 more]</label></div><br/><div class="children"><div class="content">Not going to give you any proper advice but rather a question to have an answer for. It&#x27;s not unsolvable or even difficult but needs an answer at scale.<p>How do you scale horizontally?<p>User A connects to server A. User A&#x27;s connection drops. User A reconnects to your endpoint. Did you have anything stateful you had to remember? Did they loadbalancer need to remember to reconnect user A to server A? What happens if the server dropped, how do you reconnect the user?<p>Now if your streaming is server to server over gRPC on your own internal backend then sure, build actors with message passing, you will probably need an orchestration layer (not k8s, that&#x27;s for ifra, you need an orchestrator for your services probably written by you), for the same reason as above. What happens if Server A goes down but instead of User A it was Server B. The orchestrator acts as your load balancer would have but it just remembers who exists and who they need to speak to.</div><br/></div></div></div></div></div></div></div></div><div id="42800563" class="c"><input type="checkbox" id="c-42800563" checked=""/><div class="controls bullet"><span class="by">jon_richards</span><span>|</span><a href="#42799946">prev</a><span>|</span><a href="#42800096">next</a><span>|</span><label class="collapse" for="c-42800563">[-]</label><label class="expand" for="c-42800563">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been having fun with connectrpc <a href="https:&#x2F;&#x2F;connectrpc.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;connectrpc.com&#x2F;</a><p>It fixes a lot of the problematic stuff with grpc and I&#x27;m excited for webtransport to finally be accepted by safari so connectrpc can develop better streaming.<p>I initially thought <a href="https:&#x2F;&#x2F;buf.build" rel="nofollow">https:&#x2F;&#x2F;buf.build</a> was overkill, but the killer feature was being able to import 3rd party proto files without having to download them individually:<p><pre><code>    deps:
      - buf.build&#x2F;landeed&#x2F;protopatch
      - buf.build&#x2F;googleapis&#x2F;googleapis

</code></pre>
The automatic SDK creation is also huge. I was going to grab a screenshot praising it auto-generating SDKs for ~9 languages, but it looks like they updated in the past day or two and now I count 16 languages, plus OpenAPI and some other new stuff.<p>Edit: I too was swayed by false promises of gRPC streaming. This document <i>exactly</i> mirrored my experiences <a href="https:&#x2F;&#x2F;connectrpc.com&#x2F;docs&#x2F;go&#x2F;streaming&#x2F;" rel="nofollow">https:&#x2F;&#x2F;connectrpc.com&#x2F;docs&#x2F;go&#x2F;streaming&#x2F;</a></div><br/><div id="42801657" class="c"><input type="checkbox" id="c-42801657" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42800563">parent</a><span>|</span><a href="#42800096">next</a><span>|</span><label class="collapse" for="c-42801657">[-]</label><label class="expand" for="c-42801657">[1 more]</label></div><br/><div class="children"><div class="content">It still uses protocol buffers though, which is where many of the problems I have with gRPC comes from</div><br/></div></div></div></div><div id="42800096" class="c"><input type="checkbox" id="c-42800096" checked=""/><div class="controls bullet"><span class="by">toprerules</span><span>|</span><a href="#42800563">prev</a><span>|</span><a href="#42799637">next</a><span>|</span><label class="collapse" for="c-42800096">[-]</label><label class="expand" for="c-42800096">[4 more]</label></div><br/><div class="children"><div class="content">As someone who has worked at a few of the FAANGs, having thrift&#x2F;grpc is a godsend for internal service routing, but a lot of the complexity is managed by teams building the libraries, creating the service discovery layers, doing the routing etc. But using an RPC protocol enables those things to happen on a much greater scale and speed than you could ever do with your typical JSON&#x2F;REST service. I&#x27;ve also never seen a REST API that didn&#x27;t leak verbs. If I need to build a backend service mesh or wire two local services together via an networked stream, I will always reach for grpc.<p>That said, I absolutely would not use grpc for anything customer or web facing. RPC is powerful because it locks you into a lot of decisions and gives you &quot;the one way&quot;. REST is far superior when you have many different clients with different technology stacks trying to use your service.</div><br/><div id="42801568" class="c"><input type="checkbox" id="c-42801568" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#42800096">parent</a><span>|</span><a href="#42801614">next</a><span>|</span><label class="collapse" for="c-42801568">[-]</label><label class="expand" for="c-42801568">[2 more]</label></div><br/><div class="children"><div class="content">For a public API I wouldn’t do this, but for private APIs we just do POST &#x2F;api&#x2F;doThingy with a JSON body, easy peasy RPC anyone can participate in with the most basic HTTP client. Works great on every OS and in every browser, no fucking around with “what goes in the URL path” vs “what goes in query params” vs “what goes in the body”.<p>You can even do this with gRPC if you’re using Buf or Connect - one of the server thingies that try not to suck; they will accept JSON via HTTP happily.</div><br/><div id="42801740" class="c"><input type="checkbox" id="c-42801740" checked=""/><div class="controls bullet"><span class="by">pandemic_region</span><span>|</span><a href="#42800096">root</a><span>|</span><a href="#42801568">parent</a><span>|</span><a href="#42801614">next</a><span>|</span><label class="collapse" for="c-42801740">[-]</label><label class="expand" for="c-42801740">[1 more]</label></div><br/><div class="children"><div class="content">This. The amount of time lost debating correct rest semantics for a use case is staggering.</div><br/></div></div></div></div><div id="42801614" class="c"><input type="checkbox" id="c-42801614" checked=""/><div class="controls bullet"><span class="by">rfw300</span><span>|</span><a href="#42800096">parent</a><span>|</span><a href="#42801568">prev</a><span>|</span><a href="#42799637">next</a><span>|</span><label class="collapse" for="c-42801614">[-]</label><label class="expand" for="c-42801614">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean by “leak verbs”?</div><br/></div></div></div></div><div id="42799637" class="c"><input type="checkbox" id="c-42799637" checked=""/><div class="controls bullet"><span class="by">NAHWheatCracker</span><span>|</span><a href="#42800096">prev</a><span>|</span><a href="#42799644">next</a><span>|</span><label class="collapse" for="c-42799637">[-]</label><label class="expand" for="c-42799637">[6 more]</label></div><br/><div class="children"><div class="content">My only work experience with gRPC was on a project where another senior dev pushed for it because we &quot;needed the performance&quot;. We ended up creating a JSON API anyways. Mostly because that&#x27;s what the frontend could consume. No one except for that developer had experience with gRPC. He didn&#x27;t go any deeper than the gRPC Python Quick start guide and wouldn&#x27;t help fix bugs.<p>The project was a mess for a hundred reasons and never got any sort of scale to justify gRPC.<p>That said, I&#x27;ve used gRPC in bits outside of work and I like it. It requires lot more work and thought. That&#x27;s mostly because I&#x27;ve worked on so many more JSON APIs.</div><br/><div id="42799990" class="c"><input type="checkbox" id="c-42799990" checked=""/><div class="controls bullet"><span class="by">lordofgibbons</span><span>|</span><a href="#42799637">parent</a><span>|</span><a href="#42799644">next</a><span>|</span><label class="collapse" for="c-42799990">[-]</label><label class="expand" for="c-42799990">[5 more]</label></div><br/><div class="children"><div class="content">That sounds more like a critique of the &quot;senior&quot; developer who didn&#x27;t know grpc isn&#x27;t compatible with browsers before adopting it than grpc itself.</div><br/><div id="42800097" class="c"><input type="checkbox" id="c-42800097" checked=""/><div class="controls bullet"><span class="by">NAHWheatCracker</span><span>|</span><a href="#42799637">root</a><span>|</span><a href="#42799990">parent</a><span>|</span><a href="#42800195">next</a><span>|</span><label class="collapse" for="c-42800097">[-]</label><label class="expand" for="c-42800097">[3 more]</label></div><br/><div class="children"><div class="content">Correct, I wasn&#x27;t critiquing gRPC. I was critiquing a type of person who might push for gRPC. That developer probably thought of it as a novelty and made up reasons to use it. It was a big hassle that  added to that teams workload with no upside.</div><br/><div id="42800384" class="c"><input type="checkbox" id="c-42800384" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#42799637">root</a><span>|</span><a href="#42800097">parent</a><span>|</span><a href="#42800195">next</a><span>|</span><label class="collapse" for="c-42800384">[-]</label><label class="expand" for="c-42800384">[2 more]</label></div><br/><div class="children"><div class="content">When all you have is a hammer…<p>gRPC is fantastic for its use case. Contract first services with built in auth. I can make a call to a service using an API that’s statically typed due to code generation and I don’t have to write it. That said, it’s not for browsers so Mr gRPC dev probably had no experience in browser technologies.<p>A company I worked for about 10 years ago was heavy gRPC but only as a service bridge that would call the REST handler (if you came in over REST, it would just invoke this handler anyway). Everything was great and dtos (messages) were automatically generated! Downside was the serialization hit.</div><br/><div id="42800671" class="c"><input type="checkbox" id="c-42800671" checked=""/><div class="controls bullet"><span class="by">whoevercares</span><span>|</span><a href="#42799637">root</a><span>|</span><a href="#42800384">parent</a><span>|</span><a href="#42800195">next</a><span>|</span><label class="collapse" for="c-42800671">[-]</label><label class="expand" for="c-42800671">[1 more]</label></div><br/><div class="children"><div class="content">gRPC is indeed for backend service to service calls with strong contract&#x2F;model first approach. It’s important for company in serious API and SDK vending business.</div><br/></div></div></div></div></div></div><div id="42800195" class="c"><input type="checkbox" id="c-42800195" checked=""/><div class="controls bullet"><span class="by">awinter-py</span><span>|</span><a href="#42799637">root</a><span>|</span><a href="#42799990">parent</a><span>|</span><a href="#42800097">prev</a><span>|</span><a href="#42799644">next</a><span>|</span><label class="collapse" for="c-42800195">[-]</label><label class="expand" for="c-42800195">[1 more]</label></div><br/><div class="children"><div class="content">yes who would imagine that the homegrown rpc of the internet and browser company would work on the internet and in a browser<p>very fair critique</div><br/></div></div></div></div></div></div><div id="42799644" class="c"><input type="checkbox" id="c-42799644" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#42799637">prev</a><span>|</span><a href="#42799917">next</a><span>|</span><label class="collapse" for="c-42799644">[-]</label><label class="expand" for="c-42799644">[21 more]</label></div><br/><div class="children"><div class="content">Google somehow psyoped the entire industry to use gRPC for internal service communications. The devex of gRPC is considerably worse than REST.<p>You can’t just give someone a simple command to call an endpoint—it requires additional tooling that isn’t standardized. Plus, the generated client-side code is some of the ugliest gunk you’ll find in any language.</div><br/><div id="42799922" class="c"><input type="checkbox" id="c-42799922" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42799644">parent</a><span>|</span><a href="#42799903">next</a><span>|</span><label class="collapse" for="c-42799922">[-]</label><label class="expand" for="c-42799922">[9 more]</label></div><br/><div class="children"><div class="content">&gt; You can’t just give someone a simple command to call an endpoint—it requires additional tooling that isn’t standardized.<p>GRPC <i>is</i> a standard in all the ways that matter. It (or Thrift) is a breath of fresh air compared to doing it all by hand - write down your data types and function signatures, get something that you can actually call like a function (clearly separated from an actual function function - as it should be, it behaves differently - but usable like one). Get on with your business logic instead of writing serialisation&#x2F;deserialisation boilerplate. GraphQL is even better.</div><br/><div id="42800127" class="c"><input type="checkbox" id="c-42800127" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42799922">parent</a><span>|</span><a href="#42799903">next</a><span>|</span><label class="collapse" for="c-42800127">[-]</label><label class="expand" for="c-42800127">[8 more]</label></div><br/><div class="children"><div class="content">&gt; GraphQL is even better<p>just a casual sentence at the end? How about no. It&#x27;s in the name, a query-oriented API, useless if you don&#x27;t need flexible queries.<p>Why don&#x27;t you address the problem they talked about, what is the cli tool I can use to test grpc, what about gui client?</div><br/><div id="42800288" class="c"><input type="checkbox" id="c-42800288" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800127">parent</a><span>|</span><a href="#42800262">next</a><span>|</span><label class="collapse" for="c-42800288">[-]</label><label class="expand" for="c-42800288">[3 more]</label></div><br/><div class="children"><div class="content">For GUI, I&#x27;ve been very happy with grpcui-web[0]. It really highlights the strengths of GRPC: you get a full list of available operations (either from the server directly if it exposes metadata, or by pointing to the .proto file if not), since everything is strongly typed you get client-side field validation and custom controls e.g. a date picker for timestamp types or drop-down for enums. The experience is a lot better than copy &amp; pasting from docs for trying out JSON-HTTP APIs.<p>In general though I agree devex for gRPC is poor. I primarily work with the Python and Go APIs and they can be very frustrating. Basic operations like &quot;turn pbtypes.Timestamp into a Python datetime or Go time.Time&quot; are poorly documented and not obvious. proto3 removing `optional` was a flub and then adding it back was an even bigger flub; I have a bunch of protos which rely on the `google.protobuf.Int64Value` wrapper types which can never be changed (without a massive migration which I&#x27;m not doing). And even figuring out how to build the stuff consistently is a challenge! I had to build out a centralized protobuf build server that could use consistent versions of protoc plus the appropriate proto-gen plugins. I think buf.build basically does this now but they didn&#x27;t exist then.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;fullstorydev&#x2F;grpcui">https:&#x2F;&#x2F;github.com&#x2F;fullstorydev&#x2F;grpcui</a></div><br/><div id="42800748" class="c"><input type="checkbox" id="c-42800748" checked=""/><div class="controls bullet"><span class="by">ewhauser421</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800288">parent</a><span>|</span><a href="#42800262">next</a><span>|</span><label class="collapse" for="c-42800748">[-]</label><label class="expand" for="c-42800748">[2 more]</label></div><br/><div class="children"><div class="content">timestamppb.New(time) is hard to figure out?</div><br/><div id="42801174" class="c"><input type="checkbox" id="c-42801174" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800748">parent</a><span>|</span><a href="#42800262">next</a><span>|</span><label class="collapse" for="c-42801174">[-]</label><label class="expand" for="c-42801174">[1 more]</label></div><br/><div class="children"><div class="content">&gt; timestamppb.New(time) is hard to figure out?<p>No need to be snarky; that API did not exist when I started using protobuf. The method was called `TimestampProto` which is not intuitive, especially given the poor documentation available. <i>And</i> it required error handling which is unergonomic. Given that they switched it to timestamppb.New, they must&#x27;ve agreed with me. <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;protobuf&#x2F;blame&#x2F;master&#x2F;ptypes&#x2F;timestamp.go">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;protobuf&#x2F;blame&#x2F;master&#x2F;ptypes&#x2F;times...</a> &lt;-- and you can still see the full code from this era on master because of the migration from `github.com&#x2F;golang&#x2F;protobuf` to `google.golang.org&#x2F;protobuf`, which was a whole <i>other</i> exercise in terrible DX.</div><br/></div></div></div></div></div></div><div id="42800262" class="c"><input type="checkbox" id="c-42800262" checked=""/><div class="controls bullet"><span class="by">apayan</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800127">parent</a><span>|</span><a href="#42800288">prev</a><span>|</span><a href="#42800399">next</a><span>|</span><label class="collapse" for="c-42800262">[-]</label><label class="expand" for="c-42800262">[1 more]</label></div><br/><div class="children"><div class="content">grpcurl is what I use to inspect gRPC apis.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;fullstorydev&#x2F;grpcurl">https:&#x2F;&#x2F;github.com&#x2F;fullstorydev&#x2F;grpcurl</a></div><br/></div></div><div id="42800399" class="c"><input type="checkbox" id="c-42800399" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800127">parent</a><span>|</span><a href="#42800262">prev</a><span>|</span><a href="#42800608">next</a><span>|</span><label class="collapse" for="c-42800399">[-]</label><label class="expand" for="c-42800399">[1 more]</label></div><br/><div class="children"><div class="content">Take the protobuf and generate a client… gRPC makes no assumptions on your topography, only that there’s a server, there’s a client, and it’s up to you to fill the logic. Or use grpcurl, or bloomrpc, or kreya.<p>The client is the easy part if you just want to test calls.</div><br/></div></div><div id="42800608" class="c"><input type="checkbox" id="c-42800608" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800127">parent</a><span>|</span><a href="#42800399">prev</a><span>|</span><a href="#42800285">next</a><span>|</span><label class="collapse" for="c-42800608">[-]</label><label class="expand" for="c-42800608">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s in the name, a query-oriented API, useless if you don&#x27;t need flexible queries.<p>It&#x27;s actually still nice even if you don&#x27;t use the flexibility. Throw up GraphiQL and you&#x27;ve got the testing tool you were worried about. (Sure, it&#x27;s not a command line tool, but people don&#x27;t expect that for e.g. SQL databases).</div><br/></div></div></div></div></div></div><div id="42799903" class="c"><input type="checkbox" id="c-42799903" checked=""/><div class="controls bullet"><span class="by">sitzkrieg</span><span>|</span><a href="#42799644">parent</a><span>|</span><a href="#42799922">prev</a><span>|</span><a href="#42799799">next</a><span>|</span><label class="collapse" for="c-42799903">[-]</label><label class="expand" for="c-42799903">[2 more]</label></div><br/><div class="children"><div class="content">i agree, was forced to use it at several companies and it was 99% not needed tech debt investment garbage<p>even in go its a pain in the ass to have to regen and figure out versioning shared protos and it only gets worse w each additional language<p>but every startup thinks they need 100 microservices and grpc so whatever</div><br/><div id="42800345" class="c"><input type="checkbox" id="c-42800345" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42799903">parent</a><span>|</span><a href="#42799799">next</a><span>|</span><label class="collapse" for="c-42800345">[-]</label><label class="expand" for="c-42800345">[1 more]</label></div><br/><div class="children"><div class="content">&gt; even in go its a pain in the ass to have to regen and figure out versioning shared protos and it only gets worse w each additional language<p>The secret is: don&#x27;t worry about it. There is no need to regenerate your proto bindings for every change to the protos defs. Only do it when you need to access something new in your application (which only happens when you will be making changes to the application anyway). Don&#x27;t try and automate it. That is, assuming you don&#x27;t make breaking changes to your protos (or if you do, you do so under a differently named proto).</div><br/></div></div></div></div><div id="42799799" class="c"><input type="checkbox" id="c-42799799" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#42799644">parent</a><span>|</span><a href="#42799903">prev</a><span>|</span><a href="#42799917">next</a><span>|</span><label class="collapse" for="c-42799799">[-]</label><label class="expand" for="c-42799799">[9 more]</label></div><br/><div class="children"><div class="content">&gt; The devex of gRPC is considerably worse than REST.<p>Hard disagree from the backend world.<p>From one protocol change you can statically determine which of your downstream consumers needs to be updated and redeployed. That can turn weeks of work into a hour long change.<p>You know that the messages you accept and emit are immediately validated. You can also store them cheaply for later rehydration.<p>You get incredibly readable API documentation with protos that isn&#x27;t muddled with code and business logic.<p>You get baked in versioning and deprecation semantics.<p>You have support for richer data structures (caveat: except for maps).<p>In comparison, JSON feels bloated and dated. At least on the backend.</div><br/><div id="42799906" class="c"><input type="checkbox" id="c-42799906" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42799799">parent</a><span>|</span><a href="#42799893">next</a><span>|</span><label class="collapse" for="c-42799906">[-]</label><label class="expand" for="c-42799906">[5 more]</label></div><br/><div class="children"><div class="content">I also disagree, at Google everything is RPCs in a similar way to gRPC internally, and I barely need to think about the mechanics of them most of the time, whereas with REST&#x2F;raw HTTP, you need to think about so much of the process – connection lifecycle, keepalive, error handling at more layers, connection pools, etc.<p>However, I used to work in a company that used HTTP internally, and moving to gRPC would have sucked. If you&#x27;re the one adding gRPC to a new service, that&#x27;s more of a pain than `import requests; requests.get(...)`. There is no quick and hacky solution for gRPC, you need a fully baked, well integrated solution, rolled out across everyone who will need it.</div><br/><div id="42800392" class="c"><input type="checkbox" id="c-42800392" checked=""/><div class="controls bullet"><span class="by">pianoben</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42799906">parent</a><span>|</span><a href="#42799893">next</a><span>|</span><label class="collapse" for="c-42800392">[-]</label><label class="expand" for="c-42800392">[4 more]</label></div><br/><div class="children"><div class="content">The flexibility of HTTP has advantages, too; it&#x27;s simple to whip up a `curl` command to try things out.  How does Google meet that need for gRPC APIs?</div><br/><div id="42800613" class="c"><input type="checkbox" id="c-42800613" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800392">parent</a><span>|</span><a href="#42800491">next</a><span>|</span><label class="collapse" for="c-42800613">[-]</label><label class="expand" for="c-42800613">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a curl for RPCs internally. It helps too that RPC servers are self describing, so you can actually list the services and methods exposed by a server. I&#x27;d say it&#x27;s much simpler than curl, although again that&#x27;s in large part because there&#x27;s a lot of shared infra and understanding, and starting from scratch on that would be hard.</div><br/></div></div><div id="42800491" class="c"><input type="checkbox" id="c-42800491" checked=""/><div class="controls bullet"><span class="by">allset_</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800392">parent</a><span>|</span><a href="#42800613">prev</a><span>|</span><a href="#42799893">next</a><span>|</span><label class="collapse" for="c-42800491">[-]</label><label class="expand" for="c-42800491">[2 more]</label></div><br/><div class="children"><div class="content">Server reflection exists (<a href="https:&#x2F;&#x2F;grpc.io&#x2F;docs&#x2F;guides&#x2F;reflection&#x2F;" rel="nofollow">https:&#x2F;&#x2F;grpc.io&#x2F;docs&#x2F;guides&#x2F;reflection&#x2F;</a>), but you don&#x27;t really need to whip out curl when you have the RPC service&#x27;s definition. It tells you everything you need to know about what to send and what you will receive, so you can just start writing type-safe code.</div><br/><div id="42801943" class="c"><input type="checkbox" id="c-42801943" checked=""/><div class="controls bullet"><span class="by">bootsmann</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42800491">parent</a><span>|</span><a href="#42799893">next</a><span>|</span><label class="collapse" for="c-42801943">[-]</label><label class="expand" for="c-42801943">[1 more]</label></div><br/><div class="children"><div class="content">&gt;you don&#x27;t really need to whip out curl when you have the RPC service&#x27;s definition<p>Following up a &quot;how do I experiment with this in my workflow&quot; with &quot;oh you don&#x27;t need to&quot; is not the greatest look. There is a vast portion of programming bugs that stem from someone misunderstanding what a given API does, so the ability to quickly self-verify that one is doing things right is essential.</div><br/></div></div></div></div></div></div></div></div><div id="42799893" class="c"><input type="checkbox" id="c-42799893" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42799799">parent</a><span>|</span><a href="#42799906">prev</a><span>|</span><a href="#42800750">next</a><span>|</span><label class="collapse" for="c-42799893">[-]</label><label class="expand" for="c-42799893">[1 more]</label></div><br/><div class="children"><div class="content">My perspective stems from working with it in backend services as well. The type safety and the declarative nature of protobufs are nice, but writing clients and servers isn’t.<p>The tooling is rough, and the documentation is sparse. Not saying REST doesn’t have its fair share of faults, but gRPC feels like a weird niche thing that’s hard to use for anything public-facing. No wonder none of the LLM vendors offer gRPC as an alternative to REST.</div><br/></div></div><div id="42800750" class="c"><input type="checkbox" id="c-42800750" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42799799">parent</a><span>|</span><a href="#42799893">prev</a><span>|</span><a href="#42801014">next</a><span>|</span><label class="collapse" for="c-42800750">[-]</label><label class="expand" for="c-42800750">[1 more]</label></div><br/><div class="children"><div class="content">The benefits you mention stem from having a total view on all services and which protos they are using.<p>The same is achievable with a registry of OpenAPI documents. The only thing you need to ensure is that teams share schema definitions. This holds for gRPC as well. If teams create new types just copying some of the fields they need your analysis will be lost as well.</div><br/></div></div><div id="42801014" class="c"><input type="checkbox" id="c-42801014" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#42799644">root</a><span>|</span><a href="#42799799">parent</a><span>|</span><a href="#42800750">prev</a><span>|</span><a href="#42799917">next</a><span>|</span><label class="collapse" for="c-42801014">[-]</label><label class="expand" for="c-42801014">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You get incredibly readable API documentation with protos that isn&#x27;t muddled with code and business logic.<p>I mean, ideally (hopefully) in the JSON case there&#x27;s some class defined in code that they can document in the comments<p>If it&#x27;s a shitty shop that&#x27;s sometimes less likely. Nice thing about protos is that the schemas are <i>somewhere</i></div><br/></div></div></div></div></div></div><div id="42799917" class="c"><input type="checkbox" id="c-42799917" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#42799644">prev</a><span>|</span><a href="#42799959">next</a><span>|</span><label class="collapse" for="c-42799917">[-]</label><label class="expand" for="c-42799917">[11 more]</label></div><br/><div class="children"><div class="content"><i>&gt; If your API is a REST API, then your clients never have to understand the format of your URLs and those formats are not part of the API specification given to clients.</i><p>Roy Fielding, who coined the term REST:<p><i>&quot;A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user’s manipulation of those representations.</i>&quot;<p><a href="https:&#x2F;&#x2F;roy.gbiv.com&#x2F;untangled&#x2F;2008&#x2F;rest-apis-must-be-hypertext-driven" rel="nofollow">https:&#x2F;&#x2F;roy.gbiv.com&#x2F;untangled&#x2F;2008&#x2F;rest-apis-must-be-hypert...</a><p>I know it&#x27;s a dead horse, but it&#x27;s so funny: the &quot;API specification&quot; given to clients, in a truly RESTful system, should only be the initial entry point URI&#x2F;URL.</div><br/><div id="42800502" class="c"><input type="checkbox" id="c-42800502" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#42799917">parent</a><span>|</span><a href="#42800133">next</a><span>|</span><label class="collapse" for="c-42800502">[-]</label><label class="expand" for="c-42800502">[1 more]</label></div><br/><div class="children"><div class="content">This idea of self-describing REST is now better known as HATEOAS. Personally I think it’s bloated and doesn’t solve a real problem.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;HATEOAS" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;HATEOAS</a></div><br/></div></div><div id="42800133" class="c"><input type="checkbox" id="c-42800133" checked=""/><div class="controls bullet"><span class="by">curt15</span><span>|</span><a href="#42799917">parent</a><span>|</span><a href="#42800502">prev</a><span>|</span><a href="#42800772">next</a><span>|</span><label class="collapse" for="c-42800133">[-]</label><label class="expand" for="c-42800133">[5 more]</label></div><br/><div class="children"><div class="content">How does one even write an API client against a REST API that only publishes the initial entry point? in particular, how should the client discover the resources that can be manipulated by the API or the request&#x2F;response models?</div><br/><div id="42800751" class="c"><input type="checkbox" id="c-42800751" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#42799917">root</a><span>|</span><a href="#42800133">parent</a><span>|</span><a href="#42800210">next</a><span>|</span><label class="collapse" for="c-42800751">[-]</label><label class="expand" for="c-42800751">[1 more]</label></div><br/><div class="children"><div class="content">The responses from prior requests give you URLs which form subsequent requests.<p>For example, if I,<p><pre><code>  GET &lt;account URL&gt;
</code></pre>
that might return the details of my account, which might include a list of links (URLs) to all subscriptions (or perhaps a URL to the entire collection) in the account.<p>(Obviously you have to get the account URL in this example somewhere too, and usually you just keep tugging on the objects in whatever data model you&#x27;re working with and there are a few natural, easy top-level URLs that might end up in a directory of sorts, if there&#x27;s &gt;1.)<p>See ACME for an example; it&#x27;s one of the few APIs I&#x27;d class as actually RESTful. <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8555#section-7.1.1" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8555#section-7.1.1</a>.<p>Needing a single URL is <i>beautiful</i>, IMO, both configuration-wise and easily lets one put in alternate implementations, mocks, etc., and you&#x27;re not guessing at URLs which I&#x27;ve had to do a few times with non-RESTful HTTP APIs. (Most recently being Google Cloud&#x27;s…)</div><br/></div></div><div id="42800210" class="c"><input type="checkbox" id="c-42800210" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#42799917">root</a><span>|</span><a href="#42800133">parent</a><span>|</span><a href="#42800751">prev</a><span>|</span><a href="#42801108">next</a><span>|</span><label class="collapse" for="c-42800210">[-]</label><label class="expand" for="c-42800210">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How does one even write an API client against a REST API that only publishes the initial entry point? in particular, how should the client discover the resources that can be manipulated by the API or the request&#x2F;response models?<p>HAL[0] is very useful for this requirement IMHO.  That in conjunction with defining contracts via RAML[1] I have found to be highly effective.<p>0 - <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-kelly-json-hal" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-kelly-json-hal</a><p>1 - <a href="https:&#x2F;&#x2F;github.com&#x2F;raml-org&#x2F;raml-spec&#x2F;blob&#x2F;master&#x2F;versions&#x2F;raml-10&#x2F;raml-10.md&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;raml-org&#x2F;raml-spec&#x2F;blob&#x2F;master&#x2F;versions&#x2F;r...</a></div><br/></div></div><div id="42801108" class="c"><input type="checkbox" id="c-42801108" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#42799917">root</a><span>|</span><a href="#42800133">parent</a><span>|</span><a href="#42800210">prev</a><span>|</span><a href="#42800391">next</a><span>|</span><label class="collapse" for="c-42801108">[-]</label><label class="expand" for="c-42801108">[1 more]</label></div><br/><div class="children"><div class="content">Look up HATEOS. The initial endpoint will you give you the next set of resources - maybe the user list and then the post list. Then as you navigate to say, the post list, it will have embedded pagination links. Once you have resource urls from this list you can post&#x2F;put&#x2F;delete as usual.</div><br/></div></div><div id="42800391" class="c"><input type="checkbox" id="c-42800391" checked=""/><div class="controls bullet"><span class="by">loudgas</span><span>|</span><a href="#42799917">root</a><span>|</span><a href="#42800133">parent</a><span>|</span><a href="#42801108">prev</a><span>|</span><a href="#42800772">next</a><span>|</span><label class="collapse" for="c-42800391">[-]</label><label class="expand" for="c-42800391">[1 more]</label></div><br/><div class="children"><div class="content">Your Web browser is probably the best example. When you visit a Web site, your browser discovers resources and understands how it can interact with them.</div><br/></div></div></div></div><div id="42800772" class="c"><input type="checkbox" id="c-42800772" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#42799917">parent</a><span>|</span><a href="#42800133">prev</a><span>|</span><a href="#42800115">next</a><span>|</span><label class="collapse" for="c-42800772">[-]</label><label class="expand" for="c-42800772">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>the &quot;API specification&quot; given to clients, in a truly RESTful system, should only be the initial entry point URI&#x2F;URL</i><p>I don&#x27;t know that I fully agree? The <i>configuration</i>, perhaps, but I think the API specification will be far more than just a URL. It&#x27;ll need to detail whatever media types the system the API is for uses. (I.e., you&#x27;ll need to spend a lot of words on the HTTP request&#x2F;response bodies, essentially.)<p>From your link:<p>&gt; <i>A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state</i><p><i>That.</i> I.e., you&#x27;re not just returning `application&#x2F;json` to your application, you&#x27;re returning `&lt;something specific&gt;+json`. (Unless you truly are working with JSON generically, but I don&#x27;t think most are; the JSON is holding business specific data that the application needs to understand &amp; work with.)<p>That is, &quot;and [the] set of standardized media types that are appropriate for the intended audience&quot; is also crucial.<p>(And I think this point gets lost in the popular discourse: it focuses on that initial entry URL, but the &quot;describe the media types&quot;, as Fielding says, should be the bulk of the work — sort of the &quot;rest of the owl&quot; of the spec. There&#x27;s a lot of work there, and I think sometimes people hearing &quot;all you need is one URL&quot; are right to wonder &quot;but where&#x27;s the rest of the specification?&quot;)</div><br/></div></div><div id="42800115" class="c"><input type="checkbox" id="c-42800115" checked=""/><div class="controls bullet"><span class="by">eadmund</span><span>|</span><a href="#42799917">parent</a><span>|</span><a href="#42800772">prev</a><span>|</span><a href="#42800065">next</a><span>|</span><label class="collapse" for="c-42800115">[-]</label><label class="expand" for="c-42800115">[1 more]</label></div><br/><div class="children"><div class="content">You both agree: when he writes ‘format of your URLs,’ he literally means the format of the <i>URLs</i>, not the format of the resources.  Like you, I clicked on the article expecting yet another blogger who doesn’t understand REST but it appears this author has at least some basic knowledge of the concepts.  Good for him!<p>I like gRPC too, and honestly for a commercial project it is pretty compelling.  But for a personal or idealistic project I think that REST is preferable.</div><br/></div></div><div id="42800065" class="c"><input type="checkbox" id="c-42800065" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#42799917">parent</a><span>|</span><a href="#42800115">prev</a><span>|</span><a href="#42800421">next</a><span>|</span><label class="collapse" for="c-42800065">[-]</label><label class="expand" for="c-42800065">[1 more]</label></div><br/><div class="children"><div class="content">Classic case of a good idea going viral, followed by people misunderstanding the idea but continuing to spread it anyway.</div><br/></div></div><div id="42800421" class="c"><input type="checkbox" id="c-42800421" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#42799917">parent</a><span>|</span><a href="#42800065">prev</a><span>|</span><a href="#42799959">next</a><span>|</span><label class="collapse" for="c-42800421">[-]</label><label class="expand" for="c-42800421">[1 more]</label></div><br/><div class="children"><div class="content">I think the original REST is only suitable for &quot;file&quot; resources, so there&#x27;s WebDAV and nobody bothers to use it these days.</div><br/></div></div></div></div><div id="42799959" class="c"><input type="checkbox" id="c-42799959" checked=""/><div class="controls bullet"><span class="by">gghoop</span><span>|</span><a href="#42799917">prev</a><span>|</span><a href="#42801605">next</a><span>|</span><label class="collapse" for="c-42799959">[-]</label><label class="expand" for="c-42799959">[7 more]</label></div><br/><div class="children"><div class="content">I dislike the use of gRPC within the data center. People reach for it citing performance, but gRPC is not high performance and the quality of the available open source clients is very poor, particularly outside of the core C++&#x2F;Java implementations like the nodejs implementation. I am not against the use of protobuf as an API spec but it should be possible to use it with a framing protocol over TCP, there just isn&#x27;t a clear dominant choice for that way of doing RPC. When it comes to web based APIs I am more in favour of readable payloads, but there are issues here since we tend to use JSON but the type specificity is loose, which leads to interop problems between backend languages, particularly in nodejs where JSON parse is used to implement a schema mapping. In order to do this properly, encoders and decoders need to be generated explicitly from schemas, which somewhat diminishes the use of JSON within the context of JS.</div><br/><div id="42800337" class="c"><input type="checkbox" id="c-42800337" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#42799959">parent</a><span>|</span><a href="#42801069">next</a><span>|</span><label class="collapse" for="c-42800337">[-]</label><label class="expand" for="c-42800337">[1 more]</label></div><br/><div class="children"><div class="content">I agree, though Zod greatly helps with the JS schema issue. I’m keeping an eye on Microsoft’s TypeSpec project too: typespec.io for interoperable schema generation.</div><br/></div></div><div id="42801069" class="c"><input type="checkbox" id="c-42801069" checked=""/><div class="controls bullet"><span class="by">kyrra</span><span>|</span><a href="#42799959">parent</a><span>|</span><a href="#42800337">prev</a><span>|</span><a href="#42800587">next</a><span>|</span><label class="collapse" for="c-42801069">[-]</label><label class="expand" for="c-42801069">[1 more]</label></div><br/><div class="children"><div class="content">The main benefit of protos is interop between various languages. If you are a single language tech stack, it matters less.<p>Also, if you use languages outside of Google&#x27;s primary languages, you&#x27;re likely not going to get as good of an experience.</div><br/></div></div><div id="42800587" class="c"><input type="checkbox" id="c-42800587" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#42799959">parent</a><span>|</span><a href="#42801069">prev</a><span>|</span><a href="#42800685">next</a><span>|</span><label class="collapse" for="c-42800587">[-]</label><label class="expand" for="c-42800587">[3 more]</label></div><br/><div class="children"><div class="content">In what situation is performance enough of a concern that you would consider gRPC but not enough of a concern that you would let nodeJS anywhere near your stack?</div><br/><div id="42800735" class="c"><input type="checkbox" id="c-42800735" checked=""/><div class="controls bullet"><span class="by">gghoop</span><span>|</span><a href="#42799959">root</a><span>|</span><a href="#42800587">parent</a><span>|</span><a href="#42800685">next</a><span>|</span><label class="collapse" for="c-42800735">[-]</label><label class="expand" for="c-42800735">[2 more]</label></div><br/><div class="children"><div class="content">No one is picking Nodejs for high performance, but when it is chosen for other reasons it&#x27;s still expected to perform well. The Nodejs gRPC library performs poorly relatively to the overall performance characteristics of Nodejs, and this is a problem because most of the work performed by typical Nodejs services is API-related work (sending data, encoding and decoding payloads, managing sockets etc). That&#x27;s not even touching on the bugs in the http2 implementation in node core or the grpc library itself, but much of the selling point of gRPC is supposedly the language interop, and this seems like false advertising to me.</div><br/><div id="42800894" class="c"><input type="checkbox" id="c-42800894" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#42799959">root</a><span>|</span><a href="#42800735">parent</a><span>|</span><a href="#42800685">next</a><span>|</span><label class="collapse" for="c-42800894">[-]</label><label class="expand" for="c-42800894">[1 more]</label></div><br/><div class="children"><div class="content">I would imagine the reason is really that Google internally doesn&#x27;t allow NodeJS in production, so the tooling for gRPC for NodeJS does not benefit from the same level of scrutiny as languages Google uses internally.</div><br/></div></div></div></div></div></div><div id="42800685" class="c"><input type="checkbox" id="c-42800685" checked=""/><div class="controls bullet"><span class="by">whoevercares</span><span>|</span><a href="#42799959">parent</a><span>|</span><a href="#42800587">prev</a><span>|</span><a href="#42801605">next</a><span>|</span><label class="collapse" for="c-42800685">[-]</label><label class="expand" for="c-42800685">[1 more]</label></div><br/><div class="children"><div class="content">There was a talk in 2023 of a non-TCP based protocol, Homa in RPC for data center use-case <a href="https:&#x2F;&#x2F;youtu.be&#x2F;xQQT8YUvWg8?si=g3u5TogBe0_QpPpj" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;xQQT8YUvWg8?si=g3u5TogBe0_QpPpj</a>.</div><br/></div></div></div></div><div id="42801605" class="c"><input type="checkbox" id="c-42801605" checked=""/><div class="controls bullet"><span class="by">rswail</span><span>|</span><a href="#42799959">prev</a><span>|</span><a href="#42799462">next</a><span>|</span><label class="collapse" for="c-42801605">[-]</label><label class="expand" for="c-42801605">[3 more]</label></div><br/><div class="children"><div class="content">The problem with gRPC is the &quot;R&quot;. It&#x27;s been the same with JMI, Corba, ONC-RPC and all the others.<p>Making &quot;procedure calls&quot; remote and hiding them underneath client libraries means that programmers do not consider the inherent problems of a networked environment. Problems like service discovery, authentication, etc are hidden beneath something that &quot;looks like&quot; a local procedure call.<p>That&#x27;s one problem, the other is that procedure calls are focusing on the verbs, not the nouns (called &quot;entities&quot; or &quot;resources&quot; in the article).<p>If you can&#x27;t express an FSM about a noun and what causes its state to change, then how the hell do you know what it does or how changes to its environment affect it?<p>If you don&#x27;t know whether some procedure call is idempotent, how the hell can you write code that handles the various network failure modes that you have to deal with?</div><br/><div id="42801677" class="c"><input type="checkbox" id="c-42801677" checked=""/><div class="controls bullet"><span class="by">divan</span><span>|</span><a href="#42801605">parent</a><span>|</span><a href="#42801620">next</a><span>|</span><label class="collapse" for="c-42801677">[-]</label><label class="expand" for="c-42801677">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;scholar.harvard.edu&#x2F;files&#x2F;waldo&#x2F;files&#x2F;waldo-94.pdf" rel="nofollow">https:&#x2F;&#x2F;scholar.harvard.edu&#x2F;files&#x2F;waldo&#x2F;files&#x2F;waldo-94.pdf</a></div><br/></div></div><div id="42801620" class="c"><input type="checkbox" id="c-42801620" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42801605">parent</a><span>|</span><a href="#42801677">prev</a><span>|</span><a href="#42799462">next</a><span>|</span><label class="collapse" for="c-42801620">[-]</label><label class="expand" for="c-42801620">[1 more]</label></div><br/><div class="children"><div class="content">That is a problem, certainly, but not the only one.</div><br/></div></div></div></div><div id="42799462" class="c"><input type="checkbox" id="c-42799462" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#42801605">prev</a><span>|</span><a href="#42799873">next</a><span>|</span><label class="collapse" for="c-42799462">[-]</label><label class="expand" for="c-42799462">[17 more]</label></div><br/><div class="children"><div class="content">always felt like grpc was unnecessarily inaccessible to the rest of us outside google land. the grpc js client unnecessarily heavy and kinda opaque. good idea but poorly executed compared to people who are familiar with the &quot;simplicity&quot; of REST</div><br/><div id="42799884" class="c"><input type="checkbox" id="c-42799884" checked=""/><div class="controls bullet"><span class="by">kyrra</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42799530">next</a><span>|</span><label class="collapse" for="c-42799884">[-]</label><label class="expand" for="c-42799884">[1 more]</label></div><br/><div class="children"><div class="content">The official grpc JavaScript implementation is sort of bad. The one by buf.build is good from what I&#x27;ve seen.<p><a href="https:&#x2F;&#x2F;buf.build&#x2F;blog&#x2F;protobuf-es-the-protocol-buffers-typescript-javascript-runtime-we-all-deserve" rel="nofollow">https:&#x2F;&#x2F;buf.build&#x2F;blog&#x2F;protobuf-es-the-protocol-buffers-type...</a></div><br/></div></div><div id="42799530" class="c"><input type="checkbox" id="c-42799530" checked=""/><div class="controls bullet"><span class="by">rgbrgb</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42799884">prev</a><span>|</span><a href="#42799650">next</a><span>|</span><label class="collapse" for="c-42799530">[-]</label><label class="expand" for="c-42799530">[1 more]</label></div><br/><div class="children"><div class="content">yes!<p>REST is kind of like HTML... source available by default, human-readable, easy to inspect<p>GRPC is for machines efficiently talking to other machines... slightly inconvenient for any human in the loop (whether that&#x27;s coding or inspecting requests and responses)<p>The different affordances make sense given the contexts and goals they were developed in, even if they are functionally very similar.</div><br/></div></div><div id="42799650" class="c"><input type="checkbox" id="c-42799650" checked=""/><div class="controls bullet"><span class="by">limaoscarjuliet</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42799530">prev</a><span>|</span><a href="#42799607">next</a><span>|</span><label class="collapse" for="c-42799650">[-]</label><label class="expand" for="c-42799650">[1 more]</label></div><br/><div class="children"><div class="content">There are uses where gRPC shines. Streaming is one of them - you can transparently send a stream of messages in one &quot;connection&quot;. For simple CRUD service, REST is more than enough indeed.</div><br/></div></div><div id="42799607" class="c"><input type="checkbox" id="c-42799607" checked=""/><div class="controls bullet"><span class="by">tempest_</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42799650">prev</a><span>|</span><a href="#42800029">next</a><span>|</span><label class="collapse" for="c-42799607">[-]</label><label class="expand" for="c-42799607">[1 more]</label></div><br/><div class="children"><div class="content">GRPC is a nice idea weighed down by the fact that it is full of solutions to google type problems I dont have. It seems like a lot of things have chosen it because a &quot;binary&quot; like rpc protocol with a contract is a nice thing to have but the further away from GoLang you get the worse it is.</div><br/></div></div><div id="42800029" class="c"><input type="checkbox" id="c-42800029" checked=""/><div class="controls bullet"><span class="by">masterj</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42799607">prev</a><span>|</span><a href="#42799599">next</a><span>|</span><label class="collapse" for="c-42800029">[-]</label><label class="expand" for="c-42800029">[1 more]</label></div><br/><div class="children"><div class="content">You should check out <a href="https:&#x2F;&#x2F;connectrpc.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;connectrpc.com&#x2F;</a> It&#x27;s based on grpc but works a lot better with web tooling</div><br/></div></div><div id="42799599" class="c"><input type="checkbox" id="c-42799599" checked=""/><div class="controls bullet"><span class="by">dlahoda</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42800029">prev</a><span>|</span><a href="#42799653">next</a><span>|</span><label class="collapse" for="c-42799599">[-]</label><label class="expand" for="c-42799599">[4 more]</label></div><br/><div class="children"><div class="content">afaik grpc did callbacks before we got sse&#x2F;ws&#x2F;webrtc&#x2F;webtransport. so grpc was needed kind of.<p>and also canonical content streaming was in grpc. in http there was no common accepted solution at old times.</div><br/><div id="42802037" class="c"><input type="checkbox" id="c-42802037" checked=""/><div class="controls bullet"><span class="by">kybernetikos</span><span>|</span><a href="#42799462">root</a><span>|</span><a href="#42799599">parent</a><span>|</span><a href="#42799968">next</a><span>|</span><label class="collapse" for="c-42802037">[-]</label><label class="expand" for="c-42802037">[1 more]</label></div><br/><div class="children"><div class="content">Even in 2025 grpc is still awful for streaming to browsers.  I was doing Browser streaming via a variety of different methods back in 2006, and it wasn&#x27;t like we were the only ones doing it back then.</div><br/></div></div><div id="42799968" class="c"><input type="checkbox" id="c-42799968" checked=""/><div class="controls bullet"><span class="by">coder543</span><span>|</span><a href="#42799462">root</a><span>|</span><a href="#42799599">parent</a><span>|</span><a href="#42802037">prev</a><span>|</span><a href="#42799907">next</a><span>|</span><label class="collapse" for="c-42799968">[-]</label><label class="expand" for="c-42799968">[1 more]</label></div><br/><div class="children"><div class="content">Your memory appears to be incorrect.<p>SSE was first built into a web browser back in 2006. By 2011, it was supported in all major browsers except IE. SSE is really just an enhanced, more efficient version of long polling, which I believe was possible much earlier.<p>Websocket support was added by all major browsers (including IE) between 2010 and 2012.<p>gRPC wasn&#x27;t open source until 2015.</div><br/></div></div><div id="42799907" class="c"><input type="checkbox" id="c-42799907" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#42799462">root</a><span>|</span><a href="#42799599">parent</a><span>|</span><a href="#42799968">prev</a><span>|</span><a href="#42799653">next</a><span>|</span><label class="collapse" for="c-42799907">[-]</label><label class="expand" for="c-42799907">[1 more]</label></div><br/><div class="children"><div class="content">Im old enough to have worked with asn.1 and its various proprietary “improvements” as well as SOAP&#x2F;wsdl and compared to that working with protobuf&#x2F;stubby (internal google predecessor to grpc) was the best thing since sliced bread</div><br/></div></div></div></div><div id="42799653" class="c"><input type="checkbox" id="c-42799653" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42799599">prev</a><span>|</span><a href="#42799569">next</a><span>|</span><label class="collapse" for="c-42799653">[-]</label><label class="expand" for="c-42799653">[2 more]</label></div><br/><div class="children"><div class="content">The frontend &#x2F; backend split is where you have the REST and JSON camps fighting with the RPC &#x2F; protobuf &#x2F; gRPC factions.<p>RPCs have more maintainable semantics than REST as a virtue of not trying to shoehorn your data model (cardinality, relationships, etc.) into a one-size-fits-all prescriptive pattern. Very few entities ever organically evolve to fit cleanly within RESTful semantics unless you design everything upfront with perfect foresight. In a world of rapidly evolving APIs, you&#x27;re never going to hit upon beautiful RESTful entities. In bigger teams with changing requirements and ownership, it&#x27;s better to design around services.<p>The frontend folks don&#x27;t maintain your backend systems. They want easy to reason about APIs, and so they want entities they can abstract into REST. They&#x27;re the ultimate beneficiaries of such designs.<p>The effort required for REST has a place in companies that sell APIs and where third party developers are your primary customers.<p>Protobufs and binary wire encodings are easier for backend development. You can define your API and share it across services in a statically typed way, and your services spend less time encoding and decoding messages. JSON isn&#x27;t semantic or typed, and it requires a lot of overhead.<p>The frontend folks natively deal with text and JSON. They don&#x27;t want to download protobuf definitions or handle binary data as second class citizens. It doesn&#x27;t work as cleanly with their tools, and JSON is perfectly elegant for them.<p>gRPC includes excellent routing, retry, side channel, streaming, and protocol deprecation semantics. None of this is ever apparent to the frontend. It&#x27;s all for backend consumers.<p>This is 100% a frontend &#x2F; backend tooling divide. There&#x27;s an interface and ergonomic mismatch.</div><br/><div id="42800146" class="c"><input type="checkbox" id="c-42800146" checked=""/><div class="controls bullet"><span class="by">eadmund</span><span>|</span><a href="#42799462">root</a><span>|</span><a href="#42799653">parent</a><span>|</span><a href="#42799569">next</a><span>|</span><label class="collapse" for="c-42800146">[-]</label><label class="expand" for="c-42800146">[1 more]</label></div><br/><div class="children"><div class="content">Protobufs vs. JSON are orthogonal to REST vs. RPC: you can have REST where the representations are protobufs or JSON objects; you can have RPC where the requests and responses are protobufs or JSON objects.</div><br/></div></div></div></div><div id="42799569" class="c"><input type="checkbox" id="c-42799569" checked=""/><div class="controls bullet"><span class="by">dlahoda</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42799653">prev</a><span>|</span><a href="#42799537">next</a><span>|</span><label class="collapse" for="c-42799569">[-]</label><label class="expand" for="c-42799569">[1 more]</label></div><br/><div class="children"><div class="content">there are well working (official) generators of openapi&#x2F;json schemas for grpc.<p>so once you wrote grpc, you get open api rpc for free.</div><br/></div></div><div id="42799537" class="c"><input type="checkbox" id="c-42799537" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#42799462">parent</a><span>|</span><a href="#42799569">prev</a><span>|</span><a href="#42799873">next</a><span>|</span><label class="collapse" for="c-42799537">[-]</label><label class="expand" for="c-42799537">[4 more]</label></div><br/><div class="children"><div class="content">How could gRPC be simpler without sacrificing performance?</div><br/><div id="42799593" class="c"><input type="checkbox" id="c-42799593" checked=""/><div class="controls bullet"><span class="by">jeeyoungk</span><span>|</span><a href="#42799462">root</a><span>|</span><a href="#42799537">parent</a><span>|</span><a href="#42799566">next</a><span>|</span><label class="collapse" for="c-42799593">[-]</label><label class="expand" for="c-42799593">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s two parts to gRPC&#x27;s performance<p>- 1. multiplexing protocol implemented on top of HTTP&#x2F;2
- 2. serialization format via protobuf<p>For most companies, neither 1 or 2 is needed, but the side effect of 2 (of having structured schema) is good enough. This was the idea behind twrip - <a href="https:&#x2F;&#x2F;github.com&#x2F;twitchtv&#x2F;twirp">https:&#x2F;&#x2F;github.com&#x2F;twitchtv&#x2F;twirp</a> - not sure whether this is still actively used &#x2F; maintained, but it&#x27;s protobuf as json over HTTP.</div><br/></div></div><div id="42799566" class="c"><input type="checkbox" id="c-42799566" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42799462">root</a><span>|</span><a href="#42799537">parent</a><span>|</span><a href="#42799593">prev</a><span>|</span><a href="#42799873">next</a><span>|</span><label class="collapse" for="c-42799566">[-]</label><label class="expand" for="c-42799566">[2 more]</label></div><br/><div class="children"><div class="content">What kind of performance? Read? Write? Bandwidth?</div><br/><div id="42799583" class="c"><input type="checkbox" id="c-42799583" checked=""/><div class="controls bullet"><span class="by">dlahoda</span><span>|</span><a href="#42799462">root</a><span>|</span><a href="#42799566">parent</a><span>|</span><a href="#42799873">next</a><span>|</span><label class="collapse" for="c-42799583">[-]</label><label class="expand" for="c-42799583">[1 more]</label></div><br/><div class="children"><div class="content">grpc &quot;urls&quot; and data are binary.<p>binary with schema separation.<p>3x smaller payload.</div><br/></div></div></div></div></div></div></div></div><div id="42799873" class="c"><input type="checkbox" id="c-42799873" checked=""/><div class="controls bullet"><span class="by">tyre</span><span>|</span><a href="#42799462">prev</a><span>|</span><a href="#42800516">next</a><span>|</span><label class="collapse" for="c-42799873">[-]</label><label class="expand" for="c-42799873">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The least-commonly used API model is REST—only a small minority of APIs are designed this way<p>brother.</div><br/><div id="42800170" class="c"><input type="checkbox" id="c-42800170" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42799873">parent</a><span>|</span><a href="#42800123">next</a><span>|</span><label class="collapse" for="c-42800170">[-]</label><label class="expand" for="c-42800170">[1 more]</label></div><br/><div class="children"><div class="content">Technically they&#x27;re right, though; the textbook definition of REST is rare to nonexistent in my experience. What people do instead is create JSON-RPCs-over-HTTP APIs, sometimes following a REST-like URL scheme, and sometimes using different HTTP verbs on the same URL to perform different actions as one would in REST... but the API isn&#x27;t <i>really</i> REST. The creator of REST has gone on the record multiple times about how you shouldn&#x27;t call these APIs REST[0].<p>But in practice when most people say REST they just mean &quot;JSON RPC over HTTP&quot;. I avoid calling things REST now and just use &quot;JSON HTTP API&quot; to avoid the &quot;well, actually...&quot; responses. (and yes, these APIs are by far the most common.)<p>[0] <a href="https:&#x2F;&#x2F;roy.gbiv.com&#x2F;untangled&#x2F;2008&#x2F;rest-apis-must-be-hypertext-driven" rel="nofollow">https:&#x2F;&#x2F;roy.gbiv.com&#x2F;untangled&#x2F;2008&#x2F;rest-apis-must-be-hypert...</a></div><br/></div></div><div id="42800123" class="c"><input type="checkbox" id="c-42800123" checked=""/><div class="controls bullet"><span class="by">eadmund</span><span>|</span><a href="#42799873">parent</a><span>|</span><a href="#42800170">prev</a><span>|</span><a href="#42800516">next</a><span>|</span><label class="collapse" for="c-42800123">[-]</label><label class="expand" for="c-42800123">[8 more]</label></div><br/><div class="children"><div class="content"><i>Real</i> REST is a very, very small minority.<p><i>Fake</i> REST (i.e., JSON RPC) is really ridiculously common.</div><br/><div id="42800239" class="c"><input type="checkbox" id="c-42800239" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#42799873">root</a><span>|</span><a href="#42800123">parent</a><span>|</span><a href="#42800221">next</a><span>|</span><label class="collapse" for="c-42800239">[-]</label><label class="expand" for="c-42800239">[6 more]</label></div><br/><div class="children"><div class="content">I’ve never liked the no true scotsman nature of REST (which is exacerbated by the fact that its canonical “specification” is a broad PhD dissertation with a lot of other concepts thrown in), so I have adopted a fairly lax definition: if your URLs are subjects and you use HTTP verbs for the verbs, I feel like it qualifies.</div><br/><div id="42800420" class="c"><input type="checkbox" id="c-42800420" checked=""/><div class="controls bullet"><span class="by">eadmund</span><span>|</span><a href="#42799873">root</a><span>|</span><a href="#42800239">parent</a><span>|</span><a href="#42800221">next</a><span>|</span><label class="collapse" for="c-42800420">[-]</label><label class="expand" for="c-42800420">[5 more]</label></div><br/><div class="children"><div class="content">Language is a means of communication, and we have to have some sort of agreement on terms.  REST had an original meaning; that is a useful thing to be able to discuss.  JSON-RPC is also a useful thing to discuss.  But the two things are <i>different</i>.  It’s confusing to use the one word or phrase to mean two different things (like ‘inflammable’!).<p>Granted, language is to some extent defined by usage: if enough people use a term incorrectly, and few enough people use it correctly, then the incorrect usage becomes correct and the correct incorrect.  Fine, we can use ‘REST’ to mean ‘RPC over HTTP with a JSON encoding.’  But could the advocates of that usage propose a term we can all use for what Fielding described in his thesis?  Potrzebie?<p>The thing that worries me, is if we start using ‘REST’ to mean JSON-RPC, and ‘Potrzebie’ to mean ‘the style formerly known as REST’: will people start using ‘Potrzebie’ to mean JSON-RPC?  Perhaps worse, maybe they will start using it to mean ‘gRPC with JSON encoding.’<p>I propose that it’s best to use words and phrases for what they originally mean, for as long as one can, and to fight strenuously against changing them.  Otherways wun May nyet wit was kood hap.</div><br/><div id="42800551" class="c"><input type="checkbox" id="c-42800551" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#42799873">root</a><span>|</span><a href="#42800420">parent</a><span>|</span><a href="#42800853">next</a><span>|</span><label class="collapse" for="c-42800551">[-]</label><label class="expand" for="c-42800551">[2 more]</label></div><br/><div class="children"><div class="content">REST’s original meaning is pretty ambiguous and poorly specified. The dissertation was written to describe the design and architecture of the HTTP protocol itself, which was largely designed with and alongside this concept of REST. It predates a lot of modern Internet usage and thus doesn’t map perfectly onto current paradigms. I’d argue that even saying a “REST API” means you’re already in the land of impurity.<p>“True REST” is expounded upon by Fielding in a variety of places, and is essentially HATEOS (hypermedia as the engine of application state). But no one, and I mean no one, actually does that. Thus, in order to communicate effectively and “have an agreement on terms,” as you say, we need a less strict definition. I provided my suggestion.<p>If your suggestion is to go back to the primary sources, I have. Multiple times. It does not provide a particularly concrete or useful definition (because its point was not to define REST). If it had, trying to define it would be much less of a no true scotsman game. Notice that we’re not sitting here debating the meaning of HTTP.</div><br/><div id="42801035" class="c"><input type="checkbox" id="c-42801035" checked=""/><div class="controls bullet"><span class="by">kelseyfrog</span><span>|</span><a href="#42799873">root</a><span>|</span><a href="#42800551">parent</a><span>|</span><a href="#42800853">next</a><span>|</span><label class="collapse" for="c-42801035">[-]</label><label class="expand" for="c-42801035">[1 more]</label></div><br/><div class="children"><div class="content">It is. One of the biggest points of tension is that we&#x27;ve more or less settled on JSON as an interchange format which is not exactly hypermedia put of the box. That contradiction has severe implications in the application of HATEOS as it exists re JSON APIs.</div><br/></div></div></div></div><div id="42800853" class="c"><input type="checkbox" id="c-42800853" checked=""/><div class="controls bullet"><span class="by">physicles</span><span>|</span><a href="#42799873">root</a><span>|</span><a href="#42800420">parent</a><span>|</span><a href="#42800551">prev</a><span>|</span><a href="#42800221">next</a><span>|</span><label class="collapse" for="c-42800853">[-]</label><label class="expand" for="c-42800853">[2 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;ve been educated in a strange part of the internet, but I assume that this ship already sailed ~10 years ago: when most people (90%+) hear REST, they imagine something vaguely like JSON-RPC.<p>(and this is how ChatGPT, a sort of average of all opinions on the Internet, understands it)<p>So if you say REST and mean something other than that, then you&#x27;re committing to being misunderstood by most people.</div><br/><div id="42801057" class="c"><input type="checkbox" id="c-42801057" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#42799873">root</a><span>|</span><a href="#42800853">parent</a><span>|</span><a href="#42800221">next</a><span>|</span><label class="collapse" for="c-42801057">[-]</label><label class="expand" for="c-42801057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>So if you say REST and mean something other than that, then you&#x27;re committing to being misunderstood by most people.</i><p>Perhaps, but TFA is clearly written in that it is using the actual, real meaning of REST, not the value-drift corruption the laity have wrought. (The upthread comment snips out the surrounding context that brings that clarity.) Which brings us right back to the problem at hand: Potrzebie.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42800516" class="c"><input type="checkbox" id="c-42800516" checked=""/><div class="controls bullet"><span class="by">abalaji</span><span>|</span><a href="#42799873">prev</a><span>|</span><a href="#42802084">next</a><span>|</span><label class="collapse" for="c-42800516">[-]</label><label class="expand" for="c-42800516">[6 more]</label></div><br/><div class="children"><div class="content">Everyone is hating on gRPC in this thread, but I thought I&#x27;d chime in as to where it shines. Because of the generated message definition stubs (which require additional tooling), clients almost never send malformed requests and the servers send a well understood response.<p>This makes stable APIs so much easier to integrate with.</div><br/><div id="42800560" class="c"><input type="checkbox" id="c-42800560" checked=""/><div class="controls bullet"><span class="by">inetknght</span><span>|</span><a href="#42800516">parent</a><span>|</span><a href="#42802084">next</a><span>|</span><label class="collapse" for="c-42800560">[-]</label><label class="expand" for="c-42800560">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Because of the generated message definition stubs (which require additional tooling), clients almost never send malformed requests and the servers send a well understood response.</i><p>Sure. Until you need some fields to be optional.<p>&gt; <i>This makes stable APIs so much easier to integrate with.</i><p>Only on your first iteration. After a year or two of iterating you&#x27;re back to JSON, checking if fields exist, and re-validating your data. Also there&#x27;s a half dozen bugs that you can&#x27;t reproduce and you don&#x27;t know why they happen, so you just work around them with retries.</div><br/><div id="42800678" class="c"><input type="checkbox" id="c-42800678" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#42800516">root</a><span>|</span><a href="#42800560">parent</a><span>|</span><a href="#42800898">next</a><span>|</span><label class="collapse" for="c-42800678">[-]</label><label class="expand" for="c-42800678">[2 more]</label></div><br/><div class="children"><div class="content">There’s also a gaping security hole in its design.<p>They don’t have sane support for protocol versioning or required fields, so every field of every type ends up being optional in practice.<p>So, if a message has N fields, there are 2^N combinations of fields that the generated stubs will accept and pass to you, and its up to business logic to decide which combinations are valid.<p>It’s actually worse than that, since the other side of the connection could be too new for you to understand.  In that case, the bindings just silently accept messages with unknown fields, and it’s up to you to decide how to handle them.<p>All of this means that, in practice, the endpoints and clients will accumulate validation bugs over time.  At that point maliciously crafted messages can bypass validation checks, and exploit unexpected behavior of code that assumes validated messages are well-formed.<p>I’ve never met a gRPC proponent that understands these issues, and all the gRPC applications I’ve worked with has had these problems.</div><br/><div id="42802076" class="c"><input type="checkbox" id="c-42802076" checked=""/><div class="controls bullet"><span class="by">kybernetikos</span><span>|</span><a href="#42800516">root</a><span>|</span><a href="#42800678">parent</a><span>|</span><a href="#42800898">next</a><span>|</span><label class="collapse" for="c-42802076">[-]</label><label class="expand" for="c-42802076">[1 more]</label></div><br/><div class="children"><div class="content">&gt; every field of every type ends up being optional in practice.<p>This also means that you cant write a client without loads of branches, harming performance.<p>I find it odd that grpc had a reputation for high performance.  Its at best good performance given a bunch of assumptions about how schemas will be maintained and evolved.</div><br/></div></div></div></div><div id="42800898" class="c"><input type="checkbox" id="c-42800898" checked=""/><div class="controls bullet"><span class="by">abalaji</span><span>|</span><a href="#42800516">root</a><span>|</span><a href="#42800560">parent</a><span>|</span><a href="#42800678">prev</a><span>|</span><a href="#42801042">next</a><span>|</span><label class="collapse" for="c-42800898">[-]</label><label class="expand" for="c-42800898">[1 more]</label></div><br/><div class="children"><div class="content">Hence, the qualification of stable API. You can mark fields as unused and fields as optional (recently):<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;62566052" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;62566052</a><p>When your API changes that dramatically, you should use a new message definition on the client and server and deprecate the old RPC.</div><br/></div></div><div id="42801042" class="c"><input type="checkbox" id="c-42801042" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#42800516">root</a><span>|</span><a href="#42800560">parent</a><span>|</span><a href="#42800898">prev</a><span>|</span><a href="#42802084">next</a><span>|</span><label class="collapse" for="c-42801042">[-]</label><label class="expand" for="c-42801042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; After a year or two of iterating you&#x27;re back to JSON, checking if fields exist, and re-validating your data.<p>Every time this has happened to me, it&#x27;s because of one-sided contract negotiation and dealing with teams where their incentives are not aligned<p>i.e. they can send whatever shit they want, and we have to interpret it and make it work</div><br/></div></div></div></div></div></div><div id="42802084" class="c"><input type="checkbox" id="c-42802084" checked=""/><div class="controls bullet"><span class="by">bborud</span><span>|</span><a href="#42800516">prev</a><span>|</span><a href="#42800000">next</a><span>|</span><label class="collapse" for="c-42802084">[-]</label><label class="expand" for="c-42802084">[1 more]</label></div><br/><div class="children"><div class="content">One thing that plagues almost all API solutions where you have to generate code is that the vast majority of code generators are bad, and often the code they generate is ugly.<p>I&#x27;ve never understood why so many code generators are so fiddly.  They are supposed to parse text and produce text as output.  You would think that it would be possible to do this without involving all manner of junk dependencies.<p>It reminds me of what I refer to as &quot;the most important slide in software engineering&quot;. It was a slide by Sterling Hughes (PHP, MyNewt etc) from a presentation I can no longer remember the details of.  But the slide simply said &quot;nobody cares if it works for you&quot;. In the sense that if you write code that other people are supposed to use, do make an effort to put yourself in their place.  Sterling was probably 16-17 at the time, and worked as a paid intern where I worked.  But despite his young age, he managed to express something that most of us will never fully take on board.<p>Whenever I get an OpenAPI yaml file instead of a client library for some system I know things are going to be frustrating.</div><br/></div></div><div id="42800000" class="c"><input type="checkbox" id="c-42800000" checked=""/><div class="controls bullet"><span class="by">awinter-py</span><span>|</span><a href="#42802084">prev</a><span>|</span><a href="#42800741">next</a><span>|</span><label class="collapse" for="c-42800000">[-]</label><label class="expand" for="c-42800000">[1 more]</label></div><br/><div class="children"><div class="content">unless you want to be locked into a cursed ecosystem where you spend all your time reimplementing libraries that have existed for decades in rest land, fighting code generators that produce hideous classes that will randomly break compatibility, and debugging random edge-casey things in your hosting stack bc nobody truly supports h2, steer clear of grpc<p>&#x27;rest&#x27; isn&#x27;t anything (complementary)</div><br/></div></div><div id="42800741" class="c"><input type="checkbox" id="c-42800741" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#42800000">prev</a><span>|</span><a href="#42801855">next</a><span>|</span><label class="collapse" for="c-42800741">[-]</label><label class="expand" for="c-42800741">[1 more]</label></div><br/><div class="children"><div class="content">It depends. That’s the whole point.<p>I see a lot of people here saying one is better than the other. But it depends on your use case and company size.<p>GRPC is a lot more complex to start using and hides internals. However it has some major advantages too like speed, streaming, type safety, stub generation. Once you have it in place adding a function is super easy.<p>The same can be said of OpenAPI. It’s easier to understand. Builds upon basic REST tech. However JSON parsing is slow, no streaming and has immature stub generation.<p>From my experience a lot of users who use OpenAPI only use it to generate a spec from the handwritten endpoints and do manual serialization. This is the worst of the two worlds. 
- manual code in mapping json to your objects 
- manual code mapping function parameters to get params or json
- often type mapping errors in clients<p>Those engineers often don’t understand that OpenAPI is capable of stub generation. Let alone understand GRPC.<p>GRPC saves a lot of work once in place. And is technical superior. However it comes at a cost.<p>I’ve seen OpenAPI generated from routes, with generated clients libs work really well. This requires some time to setup because you can hardly use OpenAPIGenerator out of the box. But once setup I think it hits a sweet spot:
- simple: http and json
- can be gradually introduced from hardcoded manual json serialization endpoint (client and server)
- can be used as an external api
- allows for client lib generation<p>But it really depends on your use case. But to dismiss GRPC so easily mainly shows you have never encountered a use case where you need it. Once you have it in place it is such a time saver. But the same holds for proper OpenAPI RPC use.<p>However my inner engineer hates how bad the tooling around OpenAPI is, the hardcoded endpoints often done instead of server stubs, and the amount of grunt work you still need todo to have proper client libs.</div><br/></div></div><div id="42799798" class="c"><input type="checkbox" id="c-42799798" checked=""/><div class="controls bullet"><span class="by">Glyptodon</span><span>|</span><a href="#42801855">prev</a><span>|</span><a href="#42800713">next</a><span>|</span><label class="collapse" for="c-42799798">[-]</label><label class="expand" for="c-42799798">[1 more]</label></div><br/><div class="children"><div class="content">According to this, what is GraphQL? This article seems like something written with limited or unusual experience.</div><br/></div></div><div id="42800713" class="c"><input type="checkbox" id="c-42800713" checked=""/><div class="controls bullet"><span class="by">bigmutant</span><span>|</span><a href="#42799798">prev</a><span>|</span><a href="#42801857">next</a><span>|</span><label class="collapse" for="c-42800713">[-]</label><label class="expand" for="c-42800713">[2 more]</label></div><br/><div class="children"><div class="content">Never really understood the folks pushing for RPC-over-HTTP. RPC is for systems that are close together (ie intra-DC). These simple rules work well:
1. JSON-over-HTTP for over the web
2. RPC (pick your flavor) for internal service-to-service<p>I will say that Amazon&#x27;s flavor (Coral-RPC) works well and doesn&#x27;t come with a ton of headache, its mostly &quot;add ${ServiceName}Client to build&quot; and incorporate into the code. Never mind its really odd config files<p>Related note, I&#x27;ve never understood why Avro didn&#x27;t take off over GRPC, I&#x27;ve used Avro for one project and it seems much easier to use (no weird id&#x2F;enumerations required for fields) while maintaining all the code-gen&#x2F;byte-shaving</div><br/></div></div><div id="42801353" class="c"><input type="checkbox" id="c-42801353" checked=""/><div class="controls bullet"><span class="by">larusso</span><span>|</span><a href="#42801857">prev</a><span>|</span><a href="#42799738">next</a><span>|</span><label class="collapse" for="c-42801353">[-]</label><label class="expand" for="c-42801353">[1 more]</label></div><br/><div class="children"><div class="content">I generally like the article. I wished the REST concept would have been explained with some code &#x2F; payload examples though. Other the that it managed to steer me away from gRPG. All the cons he mentioned are huge deal breakers in my opinion. I would only consider if I can control both server and client and its implementation details (tech stack in this case).<p>But he addressed some issues with OpenAPI I constantly struggle with. And the fact that seemingly none is able to say what the standard is for certain patterns. And don’t get me started with OData …</div><br/></div></div><div id="42799738" class="c"><input type="checkbox" id="c-42799738" checked=""/><div class="controls bullet"><span class="by">Octoth0rpe</span><span>|</span><a href="#42801353">prev</a><span>|</span><a href="#42800885">next</a><span>|</span><label class="collapse" for="c-42799738">[-]</label><label class="expand" for="c-42799738">[10 more]</label></div><br/><div class="children"><div class="content">Oof, I strongly disagree with this article&#x27;s description of how REST apis are used, and the distinction between openAPI and rest. If I design a REST api in 2023, and in 2024 produce an openapi yaml or json file for that API with no other changes, is it somehow no longer a REST api? of course not. The article seems to be predicated on this distinction.<p>&gt; The least-commonly used API model is REST<p>Is that true? I don&#x27;t think it is frankly, though I suppose if any API that would be a REST api _if it didn&#x27;t have an openapi spec_ is somehow no longer a REST api, then maybe? But as previously stated, I just don&#x27;t think that&#x27;s true.<p>&gt; A signature characteristic of [REST APIs] is that clients do not construct URLs from other information<p>I don&#x27;t think this is true in practice. Let us consider the case of a webapp that uses a REST api to fetch&#x2F;mutate data. The client is a browser, and is almost certainly using javascript to make requests. Javascript doesn&#x27;t just magically know how to access resources, your app code is written to construct urls (example: getting an ID from the url, and then constructing a new url using that extracted ID to make an api call to fetch that resource). In fact, the only situation where I think this description of how a REST api is used is _defensibly_ true (and this is hella weak), is where the REST api in question has provided an openapi spec, and from that spec, you&#x27;ve converted that into a client library (example: <a href="https:&#x2F;&#x2F;openapi-ts.dev" rel="nofollow">https:&#x2F;&#x2F;openapi-ts.dev</a>). In such a situation, the client has a nice set of functions to call that abstract away the construction of the URL. But somewhere in the client, _urls are still being constructed_. And going back to my first complaint about this article, this contrived situation combines what the article states are two entirely distinct methods for designing apis (rest vs openapi).<p>Re: the article&#x27;s description of rpc, I actually don&#x27;t have any major complaints.</div><br/><div id="42800024" class="c"><input type="checkbox" id="c-42800024" checked=""/><div class="controls bullet"><span class="by">golly_ned</span><span>|</span><a href="#42799738">parent</a><span>|</span><a href="#42799774">next</a><span>|</span><label class="collapse" for="c-42800024">[-]</label><label class="expand" for="c-42800024">[2 more]</label></div><br/><div class="children"><div class="content">This stood out to me as well. The author must have a particular understanding of REST that differs from the usual sense in which it’s used. He might be technically correct — I haven’t read the primary sources related to REST — but it distracted from the meat and potatoes of the article, which is really a comparison of gRPC and OpenAPI. It seemed very strange for this reason.</div><br/><div id="42800070" class="c"><input type="checkbox" id="c-42800070" checked=""/><div class="controls bullet"><span class="by">jijji</span><span>|</span><a href="#42799738">root</a><span>|</span><a href="#42800024">parent</a><span>|</span><a href="#42799774">next</a><span>|</span><label class="collapse" for="c-42800070">[-]</label><label class="expand" for="c-42800070">[1 more]</label></div><br/><div class="children"><div class="content">or he works for Google (author of gRPC) and is being paid to extol the virtues, albeit short sighted, of gRPC</div><br/></div></div></div></div><div id="42799774" class="c"><input type="checkbox" id="c-42799774" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#42799738">parent</a><span>|</span><a href="#42800024">prev</a><span>|</span><a href="#42800314">next</a><span>|</span><label class="collapse" for="c-42799774">[-]</label><label class="expand" for="c-42799774">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re being way too polite.  The article is garbage and completely incorrect about what REST and OpenAPI even are.</div><br/><div id="42800535" class="c"><input type="checkbox" id="c-42800535" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#42799738">root</a><span>|</span><a href="#42799774">parent</a><span>|</span><a href="#42800314">next</a><span>|</span><label class="collapse" for="c-42800535">[-]</label><label class="expand" for="c-42800535">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re wrong. The author is using &quot;REST&quot; to mean an API at Level 3 on the Richardson Maturity Model[0] - this was the original conception of what it meant to be a &quot;REST API&quot; before the wider internet decided &quot;REST&quot; meant &quot;nice looking URLs&quot;. What he refers to as &quot;OpenAPI APIs&quot; could be called Level 2 Web APIs on the same model.<p>He uses &quot;REST&quot; correctly. He uses &quot;OpenAPI&quot; as a shorthand for the class of web APIs that are resource-based and use HTTP verbs to interact with these resources.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Richardson_Maturity_Model" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Richardson_Maturity_Model</a></div><br/><div id="42800622" class="c"><input type="checkbox" id="c-42800622" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#42799738">root</a><span>|</span><a href="#42800535">parent</a><span>|</span><a href="#42800314">next</a><span>|</span><label class="collapse" for="c-42800622">[-]</label><label class="expand" for="c-42800622">[1 more]</label></div><br/><div class="children"><div class="content">I could concede perhaps he wasn&#x27;t necessarily wrong on REST, though I personally think it&#x27;s pedantic and incorrect, regardless of what the creator of the term says.  Things evolve, and returning a list of objects instead of a list of links was an obvious progression, since spamming 1000s of GET requests doesn&#x27;t scale well in the post 90s.  If the industry at large generally agrees on what makes an API restful, it feels like we should accept such evolution.<p>OpenAPI is a description language and has little to do with an API itself.  It&#x27;s documentation.  People were using &#x27;unpure&#x27; REST long before it or Swagger even existed.  And as the parent pointed out, you can add an openapi spec later, and it doesn&#x27;t magically change the API itself.<p>Further, it creates a weird circular logic that doesn&#x27;t work.<p>From <a href="https:&#x2F;&#x2F;swagger.io&#x2F;docs&#x2F;specification&#x2F;v3_0&#x2F;about&#x2F;" rel="nofollow">https:&#x2F;&#x2F;swagger.io&#x2F;docs&#x2F;specification&#x2F;v3_0&#x2F;about&#x2F;</a> -<p>&quot;OpenAPI Specification (formerly Swagger Specification) is an API description format for REST APIs&quot;</div><br/></div></div></div></div></div></div><div id="42800314" class="c"><input type="checkbox" id="c-42800314" checked=""/><div class="controls bullet"><span class="by">curt15</span><span>|</span><a href="#42799738">parent</a><span>|</span><a href="#42799774">prev</a><span>|</span><a href="#42800348">next</a><span>|</span><label class="collapse" for="c-42800314">[-]</label><label class="expand" for="c-42800314">[1 more]</label></div><br/><div class="children"><div class="content">HATEOAS is crucial to what [Roy Fielding](<a href="https:&#x2F;&#x2F;roy.gbiv.com&#x2F;untangled&#x2F;2008&#x2F;rest-apis-must-be-hypertext-driven" rel="nofollow">https:&#x2F;&#x2F;roy.gbiv.com&#x2F;untangled&#x2F;2008&#x2F;rest-apis-must-be-hypert...</a>) calls REST APIs.<p>&gt;A REST API must not define fixed resource names or hierarchies (an obvious coupling of client and server). Servers must have the freedom to control their own namespace. Instead, allow servers to instruct clients on how to construct appropriate URIs, such as is done in HTML forms and URI templates, by defining those instructions within media types and link relations.<p>Most APIs that people call &quot;RESTful&quot; -- regardless of whether they come with an OpenAPI spec -- don&#x27;t obey HATEOAS. A typical OpenAPI spec describes the possible request paths and verbs. However, you probably wouldn&#x27;t be able to discover all that information just by starting from the entry point and parsing the `hrefs` in the response bodies.</div><br/></div></div><div id="42800348" class="c"><input type="checkbox" id="c-42800348" checked=""/><div class="controls bullet"><span class="by">eadmund</span><span>|</span><a href="#42799738">parent</a><span>|</span><a href="#42800314">prev</a><span>|</span><a href="#42799860">next</a><span>|</span><label class="collapse" for="c-42800348">[-]</label><label class="expand" for="c-42800348">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; A signature characteristic of [REST APIs] is that clients do not construct URLs from other information<p>&gt; I don&#x27;t think this is true in practice.<p>&#x27;recursivedoubts: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42799917">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42799917</a><p>The blogger is completely correct.  In a true REST (i.e., not JSON-RPC) API, the client has a single entry URL, then calls the appropriate HTTP verb on it, then parses the response, and proceeds to follow URLs; it does not produce its own URLs.  Hypertext as the engine of application state.<p>For example, there might be a URL <a href="http:&#x2F;&#x2F;foocorp.example&#x2F;" rel="nofollow">http:&#x2F;&#x2F;foocorp.example&#x2F;</a>.  My OrderMaker client might GET <a href="http:&#x2F;&#x2F;foo.example&#x2F;" rel="nofollow">http:&#x2F;&#x2F;foo.example&#x2F;</a>, Accepting type application&#x2F;offerings.  It gets back a 200 response of type application&#x2F;offerings listing all the widgets FooCorp offers.  The offerings document might include a URL with an order-creation relationship.  That URL could be <a href="http:&#x2F;&#x2F;foocorp.example&#x2F;orders" rel="nofollow">http:&#x2F;&#x2F;foocorp.example&#x2F;orders</a>, or it could be <a href="http:&#x2F;&#x2F;foocorp.example&#x2F;82347327462" rel="nofollow">http:&#x2F;&#x2F;foocorp.example&#x2F;82347327462</a>, or it could be <a href="https:&#x2F;&#x2F;barcorp.example&#x2F;cats&#x2F;dog-attack&#x2F;boston-dysentery" rel="nofollow">https:&#x2F;&#x2F;barcorp.example&#x2F;cats&#x2F;dog-attack&#x2F;boston-dysentery</a> — it seriously doesn’t matter.<p>My client could POST to that URL and then get back a 401 Unauthorized response with a WWW-Authenticate header with the value ‘SuperAuthMechanism system=&quot;baz&quot;’, and then my client could prompt me for the right credentials and retry the POST with an Authorization header with the value ‘SuperAuthMechanism opensesame’ and receive a 201 response with a Location header containing a URL for the new empty order.  That could be <a href="http:&#x2F;&#x2F;foocorp.example&#x2F;orders&#x2F;1234" rel="nofollow">http:&#x2F;&#x2F;foocorp.example&#x2F;orders&#x2F;1234</a>, or it could be <a href="https:&#x2F;&#x2F;grabthar.example&#x2F;hammer" rel="nofollow">https:&#x2F;&#x2F;grabthar.example&#x2F;hammer</a> — what matters is that my client knows how to interact with it using HTTP verbs, headers and content types, not what the URL’s characters.<p>Then my client might POST a resource with content type application&#x2F;order-item describing a widget to that order URL, and get back 202 Accepted.  Then it might POST another resource describing a gadget, and get back 202 Accepted.  Then it might GET the original order URL, and get back a 200 OK of type application&#x2F;order which shows the order in an unconfirmed state.  That resource might include a particular confirm URL to PUT to, or perhaps my client might POST a resource with content type application&#x2F;order-confirmation — all that would be up to the order protocol definition (along with particulars like 202, or 200, or 201, or whatever).<p>Eventually my client non-idempotently PUTs or POSTs or whatever, and from then on can poll the order URL and see it change as FooCorp fulfills it.<p><i>That’s</i> a RESTful API.  The World Wide Web itself is a RESTful API for dealing with documents and also complete multimedia applications lying about being documents, but the RESTful model can be applied to other things.  You can even build a RESTful application using the same backend code in the example, but which talks HTML to human beings whose browsers ask for text&#x2F;html instead of application&#x2F;whatever.  Or you might build a client which asks for ‘text&#x2F;html; custom=orderML’ and knows how to parse the expected HTML to extract the right information, and everything shares common backend code.<p>Or you might use htmx and make all this reasonably easy and straightforward.<p>That’s what REST is.  What REST is not, is GETting <a href="http:&#x2F;&#x2F;api.foocorp.example&#x2F;v1&#x2F;order&#x2F;$ORDERID" rel="nofollow">http:&#x2F;&#x2F;api.foocorp.example&#x2F;v1&#x2F;order&#x2F;$ORDERID</a> and getting back a JSON blob, then parsing out an item ID from the JSON blob, then GETting <a href="http:&#x2F;&#x2F;api.foocorp.example&#x2F;v1&#x2F;item&#x2F;$ITEMID" rel="nofollow">http:&#x2F;&#x2F;api.foocorp.example&#x2F;v1&#x2F;item&#x2F;$ITEMID</a> and so forth.</div><br/><div id="42800653" class="c"><input type="checkbox" id="c-42800653" checked=""/><div class="controls bullet"><span class="by">ctxc</span><span>|</span><a href="#42799738">root</a><span>|</span><a href="#42800348">parent</a><span>|</span><a href="#42799860">next</a><span>|</span><label class="collapse" for="c-42800653">[-]</label><label class="expand" for="c-42800653">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the summary! :)</div><br/></div></div></div></div><div id="42799860" class="c"><input type="checkbox" id="c-42799860" checked=""/><div class="controls bullet"><span class="by">turnsout</span><span>|</span><a href="#42799738">parent</a><span>|</span><a href="#42800348">prev</a><span>|</span><a href="#42800885">next</a><span>|</span><label class="collapse" for="c-42799860">[-]</label><label class="expand" for="c-42799860">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the author has an extremely idiosyncratic take on the definition of REST which is either based on a misunderstanding, or a fundamentalist view of &quot;pure&quot; REST.</div><br/></div></div></div></div><div id="42800885" class="c"><input type="checkbox" id="c-42800885" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#42799738">prev</a><span>|</span><a href="#42802004">next</a><span>|</span><label class="collapse" for="c-42800885">[-]</label><label class="expand" for="c-42800885">[1 more]</label></div><br/><div class="children"><div class="content">I feel like this article just discusses API semantics, which just feels like a bunch of pedantic best-practices with no actual substance. It doesn&#x27;t mention any of the things that gRPC offers that the alternatives don&#x27;t offer, which you would expect from a google article of all places<p>Would&#x27;ve been nice if they talked about how schema evolution is different in both cases, bidirectional streaming, or performance differences for different workloads</div><br/></div></div><div id="42802004" class="c"><input type="checkbox" id="c-42802004" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#42800885">prev</a><span>|</span><a href="#42800879">next</a><span>|</span><label class="collapse" for="c-42802004">[-]</label><label class="expand" for="c-42802004">[1 more]</label></div><br/><div class="children"><div class="content">The lack of first class js support just kills it. Having to use middleware that doesn&#x27;t work too well on AWS is the nail in the coffin.<p>It&#x27;s different if you&#x27;ve drunk the microservices koolaid but for normal projects it doesn&#x27;t help generate front-end client API libs like you&#x27;d hope.</div><br/></div></div><div id="42800879" class="c"><input type="checkbox" id="c-42800879" checked=""/><div class="controls bullet"><span class="by">justinl33</span><span>|</span><a href="#42802004">prev</a><span>|</span><a href="#42800231">next</a><span>|</span><label class="collapse" for="c-42800879">[-]</label><label class="expand" for="c-42800879">[1 more]</label></div><br/><div class="children"><div class="content">I disagree that OpenAPI is just RPC mapped to HTTP. A well-designed OpenAPI spec can be quite RESTful. The problem is many developers don&#x27;t take the time to design good resource models and just slap RPC-style operations into URL paths.</div><br/></div></div><div id="42800231" class="c"><input type="checkbox" id="c-42800231" checked=""/><div class="controls bullet"><span class="by">msoad</span><span>|</span><a href="#42800879">prev</a><span>|</span><a href="#42800883">next</a><span>|</span><label class="collapse" for="c-42800231">[-]</label><label class="expand" for="c-42800231">[1 more]</label></div><br/><div class="children"><div class="content">I think everyone who worked at Google in the past has PTSD from having to migrate gRPC schemas. What a mess! Type safety doesn&#x27;t have to be this costly</div><br/></div></div><div id="42800883" class="c"><input type="checkbox" id="c-42800883" checked=""/><div class="controls bullet"><span class="by">justinl33</span><span>|</span><a href="#42800231">prev</a><span>|</span><a href="#42800707">next</a><span>|</span><label class="collapse" for="c-42800883">[-]</label><label class="expand" for="c-42800883">[1 more]</label></div><br/><div class="children"><div class="content">entity-oriented models are more stable over time compared to procedure-oriented RPC. In my experience, starting with resources&#x2F;entities and mapping operations to them does lead to cleaner APIs that are easier to evolve.</div><br/></div></div><div id="42800707" class="c"><input type="checkbox" id="c-42800707" checked=""/><div class="controls bullet"><span class="by">eichi</span><span>|</span><a href="#42800883">prev</a><span>|</span><a href="#42800495">next</a><span>|</span><label class="collapse" for="c-42800707">[-]</label><label class="expand" for="c-42800707">[1 more]</label></div><br/><div class="children"><div class="content">We should use gRPC only after conducting proper domain driven architect. Properly categorizing classes into domain&#x2F;services&#x2F;infra is more important.</div><br/></div></div><div id="42800495" class="c"><input type="checkbox" id="c-42800495" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#42800707">prev</a><span>|</span><label class="collapse" for="c-42800495">[-]</label><label class="expand" for="c-42800495">[1 more]</label></div><br/><div class="children"><div class="content">Keep in mind gRPC is not stable over the internet; middleboxes love to break it (looking at you, Google Cloud, exposing some of your services as gRPC-only APIs)</div><br/></div></div></div></div></div></div></div></body></html>