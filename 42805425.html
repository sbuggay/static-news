<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737709274090" as="style"/><link rel="stylesheet" href="styles.css?v=1737709274090"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://danluu.com/deconstruct-files/">Working with Files Is Hard (2019)</a> <span class="domain">(<a href="https://danluu.com">danluu.com</a>)</span></div><div class="subtext"><span>nathan_phoenix</span> | <span>81 comments</span></div><br/><div><div id="42806095" class="c"><input type="checkbox" id="c-42806095" checked=""/><div class="controls bullet"><span class="by">continuational</span><span>|</span><a href="#42806242">next</a><span>|</span><label class="collapse" for="c-42806095">[-]</label><label class="expand" for="c-42806095">[46 more]</label></div><br/><div class="children"><div class="content">&gt; Pillai et al., OSDI’14 looked at a bunch of software that writes to files, including things we&#x27;d hope write to files safely, like databases and version control systems: Leveldb, LMDB, GDBM, HSQLDB, Sqlite, PostgreSQL, Git, Mercurial, HDFS, Zookeeper. They then wrote a static analysis tool that can find incorrect usage of the file API, things like incorrectly assuming that operations that aren&#x27;t atomic are actually atomic, incorrectly assuming that operations that can be re-ordered will execute in program order, etc.<p>&gt; When they did this, they found that every single piece of software they tested except for SQLite in one particular mode had at least one bug. This isn&#x27;t a knock on the developers of this software or the software -- the programmers who work on things like Leveldb, LBDM, etc., know more about filesystems than the vast majority programmers and the software has more rigorous tests than most software. But they still can&#x27;t use files safely every time! A natural follow-up to this is the question: why the file API so hard to use that even experts make mistakes?</div><br/><div id="42806268" class="c"><input type="checkbox" id="c-42806268" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42806095">parent</a><span>|</span><a href="#42807094">next</a><span>|</span><label class="collapse" for="c-42806268">[-]</label><label class="expand" for="c-42806268">[27 more]</label></div><br/><div class="children"><div class="content">&gt; why the file API so hard to use that even experts make mistakes?<p>I think the short answer is that the APIs are bad. The POSIX fs APIs and associated semantics are so deeply entrenched in the software ecosystem (both at the OS level, and at the application level) that it&#x27;s hard to move away from them.</div><br/><div id="42809938" class="c"><input type="checkbox" id="c-42809938" checked=""/><div class="controls bullet"><span class="by">huntaub</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806268">parent</a><span>|</span><a href="#42809955">next</a><span>|</span><label class="collapse" for="c-42809938">[-]</label><label class="expand" for="c-42809938">[1 more]</label></div><br/><div class="children"><div class="content">I take a different view on this. IMO the tricks that existing file systems play to get more performance (specifically around ordering and atomicity) make it extra hard for developers to reason about. Obviously, you can&#x27;t do anything about fsync dropping error codes, but some of these failure modes just aren&#x27;t possible over file systems like NFS due to protocol semantics.</div><br/></div></div><div id="42809955" class="c"><input type="checkbox" id="c-42809955" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806268">parent</a><span>|</span><a href="#42809938">prev</a><span>|</span><a href="#42806378">next</a><span>|</span><label class="collapse" for="c-42809955">[-]</label><label class="expand" for="c-42809955">[4 more]</label></div><br/><div class="children"><div class="content">Not only that, but the POSIX file API also assumes that NFS is a thing but NFS breaks half the important guarantees of a file system. I don’t know if it’s a baby and bath water situation, but NFS just seems like a whole bunch of problems. It’s like having eval in a programming language.</div><br/><div id="42809966" class="c"><input type="checkbox" id="c-42809966" checked=""/><div class="controls bullet"><span class="by">huntaub</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42809955">parent</a><span>|</span><a href="#42806378">next</a><span>|</span><label class="collapse" for="c-42809966">[-]</label><label class="expand" for="c-42809966">[3 more]</label></div><br/><div class="children"><div class="content">What aspects of NFS do you think break half of the important guarantees of a file system?</div><br/><div id="42810735" class="c"><input type="checkbox" id="c-42810735" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42809966">parent</a><span>|</span><a href="#42806378">next</a><span>|</span><label class="collapse" for="c-42810735">[-]</label><label class="expand" for="c-42810735">[2 more]</label></div><br/><div class="children"><div class="content">Well, at least O_APPEND, O_EXCL, O_SYNC, and flock() aren&#x27;t guaranteed to work (although they can with recent versions as I understand it).<p>UID mapping causing read() to return -EACCES after open() succeeds breaks a <i>lot</i> of userland code.</div><br/><div id="42810946" class="c"><input type="checkbox" id="c-42810946" checked=""/><div class="controls bullet"><span class="by">DiggyJohnson</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42810735">parent</a><span>|</span><a href="#42806378">next</a><span>|</span><label class="collapse" for="c-42810946">[-]</label><label class="expand" for="c-42810946">[1 more]</label></div><br/><div class="children"><div class="content">Just ran into this one recently trying to replace Docker w&#x2F; Podman for a CICD runner. Before anyone protests we have very strong, abnormal requirements on my project preventing most saner architectures. It wasn’t the root cause but the failure behavior was weird due to the behavior you just described.</div><br/></div></div></div></div></div></div></div></div><div id="42806378" class="c"><input type="checkbox" id="c-42806378" checked=""/><div class="controls bullet"><span class="by">__loam</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806268">parent</a><span>|</span><a href="#42809955">prev</a><span>|</span><a href="#42808100">next</a><span>|</span><label class="collapse" for="c-42806378">[-]</label><label class="expand" for="c-42806378">[20 more]</label></div><br/><div class="children"><div class="content">POSIX is also so old and essential that it&#x27;s hard to imagine an alternative.</div><br/><div id="42809681" class="c"><input type="checkbox" id="c-42809681" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806378">parent</a><span>|</span><a href="#42807323">next</a><span>|</span><label class="collapse" for="c-42809681">[-]</label><label class="expand" for="c-42809681">[2 more]</label></div><br/><div class="children"><div class="content">Some of the problems transcend POSIX.  Someone I know maintains a non-relational db on IBM mainframes.  When diving into a data issue, he was gob-smacked to find out that sync&#x27;d writes did not necessarily make it to the disk.  They were cached in the drive memory and (I think) the disk controller memory.  If all failed, data was lost.</div><br/><div id="42809803" class="c"><input type="checkbox" id="c-42809803" checked=""/><div class="controls bullet"><span class="by">hackit2</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42809681">parent</a><span>|</span><a href="#42807323">next</a><span>|</span><label class="collapse" for="c-42809803">[-]</label><label class="expand" for="c-42809803">[1 more]</label></div><br/><div class="children"><div class="content">Just wait till he has to deal with raid controllers.</div><br/></div></div></div></div><div id="42807323" class="c"><input type="checkbox" id="c-42807323" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806378">parent</a><span>|</span><a href="#42809681">prev</a><span>|</span><a href="#42808934">next</a><span>|</span><label class="collapse" for="c-42807323">[-]</label><label class="expand" for="c-42807323">[16 more]</label></div><br/><div class="children"><div class="content">Not really, there&#x27;s been lots of APIs that have improved on the POSIX model.<p>The kind of model I prefer is something based on atomicity. Most applications can get by with file-level atomicity--make whole file read&#x2F;writes atomic with a copy-on-write model, and you can eliminate whole classes of filesystem bugs pretty quickly. (Note that something like writeFileAtomic is already a common primitive in many high-level filesystem APIs, and it&#x27;s something that&#x27;s already easily buildable with regular POSIX APIs). For cases like logging, you can extend the model slightly with atomic appends, where the only kind of write allowed is to atomically append a chunk of data to the file (so readers can only possibly either see no new data or the entire chunk of data at once).<p>I&#x27;m less knowledgeable about the way DBs interact with the filesystem, but there the solution is probably ditching the concept of the file stream entirely and just treating files as a sparse map of offsets to blocks, which can be atomically updated. (My understanding is that DBs basically do this already, except that &quot;atomically updated&quot; is difficult with the current APIs).</div><br/><div id="42807465" class="c"><input type="checkbox" id="c-42807465" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42807323">parent</a><span>|</span><a href="#42808690">next</a><span>|</span><label class="collapse" for="c-42807465">[-]</label><label class="expand" for="c-42807465">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Most applications can get by with file-level atomicity--make whole file read&#x2F;writes atomic with a copy-on-write model, and you can eliminate whole classes of filesystem bugs pretty quickly.<p><pre><code>    int fd = open(&quot;.config&quot;, O_RDWR | O_CREAT | O_SYNC_ON_CLOSE, 0o666);

    &#x2F;&#x2F; effects of calls to write(2)&#x2F;etc. are invisible through any other file description
    &#x2F;&#x2F; until the close(2) is called on all descriptors to this file description.

    close(fd);
</code></pre>
So now you can watch for e.g. either IN_MODIFY or IN_CLOSE_WRITE (and you don&#x27;t need to balance it with IN_OPEN), it doesn&#x27;t matter, you&#x27;ll never see partial updates... would be nice!</div><br/><div id="42809513" class="c"><input type="checkbox" id="c-42809513" checked=""/><div class="controls bullet"><span class="by">BobbyTables2</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42807465">parent</a><span>|</span><a href="#42808690">next</a><span>|</span><label class="collapse" for="c-42809513">[-]</label><label class="expand" for="c-42809513">[2 more]</label></div><br/><div class="children"><div class="content">Surely this can’t always be true?<p>What happens when a lot of data is written and exceeds the dirty threshold?</div><br/><div id="42810189" class="c"><input type="checkbox" id="c-42810189" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42809513">parent</a><span>|</span><a href="#42808690">next</a><span>|</span><label class="collapse" for="c-42810189">[-]</label><label class="expand" for="c-42810189">[1 more]</label></div><br/><div class="children"><div class="content">It gets written on the disk but into different inodes, I imagine.</div><br/></div></div></div></div></div></div><div id="42808690" class="c"><input type="checkbox" id="c-42808690" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42807323">parent</a><span>|</span><a href="#42807465">prev</a><span>|</span><a href="#42807808">next</a><span>|</span><label class="collapse" for="c-42808690">[-]</label><label class="expand" for="c-42808690">[1 more]</label></div><br/><div class="children"><div class="content">Writes in the POSIX API can be atomic depending on the underlying filesystem. For example, small writes on ZFS through the POSIX API are atomic since they either happen in their entirety or they do not (during power failure), although if the writes are big enough (spanning many records), they are split into separate transactions and partial writes are then possible:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;blob&#x2F;34205715e1544d343f9a64149b17c371282306ae&#x2F;module&#x2F;zfs&#x2F;zfs_vnops.c#L755">https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;blob&#x2F;34205715e1544d343f9a6414...</a><p>Writes on ZFS cease to be atomic around approximately 32MB in size if I read the code correctly.</div><br/></div></div><div id="42807808" class="c"><input type="checkbox" id="c-42807808" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42807323">parent</a><span>|</span><a href="#42808690">prev</a><span>|</span><a href="#42808152">next</a><span>|</span><label class="collapse" for="c-42807808">[-]</label><label class="expand" for="c-42807808">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not hard to design a less bug-prone API that would enable you to do everything the POSIX file API permits and admits equally-high-performance implementations.  But making that new API a <i>replacement</i> for the POSIX API would require rewriting essentially all of the software that somebody cares about to use your new, better API instead of the POSIX API.  This is probably only feasible in practice for small embedded systems with a fairly small universe of software.</div><br/><div id="42808442" class="c"><input type="checkbox" id="c-42808442" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42807808">parent</a><span>|</span><a href="#42808152">next</a><span>|</span><label class="collapse" for="c-42808442">[-]</label><label class="expand" for="c-42808442">[2 more]</label></div><br/><div class="children"><div class="content">You could do a phased transition, where both the legacy posix api and the new api are available. This has already happened with a lot of the old C standard library. Old, unsafe functions like strcpy were gradually replaced by safer alternatives like strncpy.<p>Database developers don’t want the complexity or poor performance of posix. It’s wild to me that we still don’t have any alternative to fsync in Linux that can act as a barrier without also flushing caches at the same time.</div><br/><div id="42809231" class="c"><input type="checkbox" id="c-42809231" checked=""/><div class="controls bullet"><span class="by">namibj</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808442">parent</a><span>|</span><a href="#42808152">next</a><span>|</span><label class="collapse" for="c-42809231">[-]</label><label class="expand" for="c-42809231">[1 more]</label></div><br/><div class="children"><div class="content">NVMe has no barrier that doesn&#x27;t flush the pipeline&#x2F;ringbuffer of IO requests submitted to it :(</div><br/></div></div></div></div></div></div><div id="42808152" class="c"><input type="checkbox" id="c-42808152" checked=""/><div class="controls bullet"><span class="by">timewizard</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42807323">parent</a><span>|</span><a href="#42807808">prev</a><span>|</span><a href="#42808934">next</a><span>|</span><label class="collapse" for="c-42808152">[-]</label><label class="expand" for="c-42808152">[8 more]</label></div><br/><div class="children"><div class="content">&gt; make whole file read&#x2F;writes atomic with a copy-on-write model,<p>I have many files that are several GB.  Are you sure this is a good idea?  What if my application only requires best effort?<p>&gt; eliminate whole classes of filesystem bugs pretty quickly.<p>Block level deduplication is notoriously difficult.<p>&gt; where the only kind of write allowed is to atomically append a chunk of data to the file<p>Which sounds good until you think about the complications involved in block oriented storage medium.  You&#x27;re stuck with RMW whether you think you&#x27;re strictly appending or not.</div><br/><div id="42808504" class="c"><input type="checkbox" id="c-42808504" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808152">parent</a><span>|</span><a href="#42808934">next</a><span>|</span><label class="collapse" for="c-42808504">[-]</label><label class="expand" for="c-42808504">[7 more]</label></div><br/><div class="children"><div class="content">It doesn’t have to be one or the other. Developers could decide by passing flags to open.<p>But even then, doing atomic writes of multi gigabyte files doesn’t sound that hard to implement efficiently. Just write to disk first and update the metadata atomically at the end. Or whenever you choose to as a programmer.<p>The downside is that, when overwriting, you’ll need enough free space to store both the old and new versions of your data. But I think that’s usually a good trade off.<p>It would allow all sorts of useful programs to be written easily - like an atomic mode for apt, where packages either get installed or not installed. But they can’t be half installed.</div><br/><div id="42808773" class="c"><input type="checkbox" id="c-42808773" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808504">parent</a><span>|</span><a href="#42808948">next</a><span>|</span><label class="collapse" for="c-42808773">[-]</label><label class="expand" for="c-42808773">[4 more]</label></div><br/><div class="children"><div class="content">Packages consist of multiple files. An atomic file write would not allow packages to be either installed or not installed by APT.</div><br/><div id="42810180" class="c"><input type="checkbox" id="c-42810180" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808773">parent</a><span>|</span><a href="#42809950">next</a><span>|</span><label class="collapse" for="c-42810180">[-]</label><label class="expand" for="c-42810180">[2 more]</label></div><br/><div class="children"><div class="content">Atomicity could encompass a whole bunch of writes at once.<p>Databases implemented atomic transactions in the 70s. Let’s stop pretending like this is an unsolvable CS problem. Its not.</div><br/><div id="42811093" class="c"><input type="checkbox" id="c-42811093" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42810180">parent</a><span>|</span><a href="#42809950">next</a><span>|</span><label class="collapse" for="c-42811093">[-]</label><label class="expand" for="c-42811093">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Databases implemented atomic transactions in the 70s.<p>And they have deadlocks as a result, which there is no good easy solution to (generally we work around by having only one program access a given database at a time, and even that is not 100% reliable).</div><br/></div></div></div></div><div id="42809950" class="c"><input type="checkbox" id="c-42809950" checked=""/><div class="controls bullet"><span class="by">huntaub</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808773">parent</a><span>|</span><a href="#42810180">prev</a><span>|</span><a href="#42808948">next</a><span>|</span><label class="collapse" for="c-42809950">[-]</label><label class="expand" for="c-42809950">[1 more]</label></div><br/><div class="children"><div class="content">This is kind of an interesting thought that more mirrors how Docker uses OverlayFS to track changes to the entire file system. No need for new file APIs.</div><br/></div></div></div></div><div id="42808948" class="c"><input type="checkbox" id="c-42808948" checked=""/><div class="controls bullet"><span class="by">timewizard</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808504">parent</a><span>|</span><a href="#42808773">prev</a><span>|</span><a href="#42808934">next</a><span>|</span><label class="collapse" for="c-42808948">[-]</label><label class="expand" for="c-42808948">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Developers could decide by passing flags to open.<p>Provided the underlying VFS has implemented them.  They may not.  Hence the point in the article that some developers only choose to support &#x27;ext4&#x27; and nothing else.<p>&gt; you’ll need enough free space to store both the old and new versions of your data.<p>The sacrifice is increased write wear on solid state devices.<p>&gt; It would allow all sorts of useful programs to be written easily<p>Sure.  As long as you don&#x27;t need multiple processes to access the same file simultaneously.  I think the article misses this point,  too,  in that,  every FS on a multi user system is effectively a &quot;distributed system.&quot;  It&#x27;s not distributed for _redundancy_ but it doesn&#x27;t eliminate the attendant challenges.</div><br/><div id="42810218" class="c"><input type="checkbox" id="c-42810218" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808948">parent</a><span>|</span><a href="#42808934">next</a><span>|</span><label class="collapse" for="c-42810218">[-]</label><label class="expand" for="c-42810218">[1 more]</label></div><br/><div class="children"><div class="content">Yes, a feature like this would need cooperation with the filesystem. But that’s just an implementation problem. That’s like saying we can’t add flexbox to browsers because all the browsers would need to add it. So?<p>As for wear on SSDs, I don’t think it would increase wear. You’re writing the same number of sectors on the drive. A 2gb write would still write 2gb (+ negligible metadata overhead). Why would the drive wear out faster in this scheme?<p>And I think it would work way better with multiple processes than the existing system. Right now the semantics when multiple processes edit the same file at once are somewhat undefined. With this approach, files would have database like semantics where any reader would either see the state before a write or the state after. It’s much cleaner - since it would become impossible for skewed reads or writes to corrupt a shared file.<p>Would you argue against the existence of database transactions? Of course not. Nobody does. They’re a great idea, and they’re way easier to reason about and use correctly compared to the POSIX filesystem api. I’m saying we should have the same integrity guarantees on the filesystem. I think if we had those guarantees already, you’d agree too.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42808934" class="c"><input type="checkbox" id="c-42808934" checked=""/><div class="controls bullet"><span class="by">MisterTea</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806378">parent</a><span>|</span><a href="#42807323">prev</a><span>|</span><a href="#42808100">next</a><span>|</span><label class="collapse" for="c-42808934">[-]</label><label class="expand" for="c-42808934">[1 more]</label></div><br/><div class="children"><div class="content">I use Plan 9 regularly and while its Unix heritage is there, it most certainly isn&#x27;t Unix and completely does away with POSIX.</div><br/></div></div></div></div><div id="42808100" class="c"><input type="checkbox" id="c-42808100" checked=""/><div class="controls bullet"><span class="by">timewizard</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806268">parent</a><span>|</span><a href="#42806378">prev</a><span>|</span><a href="#42807094">next</a><span>|</span><label class="collapse" for="c-42808100">[-]</label><label class="expand" for="c-42808100">[1 more]</label></div><br/><div class="children"><div class="content">&gt; POSIX fs APIs and associated semantics<p>Well I think that&#x27;s the actual problem.  POSIX gives you an abstract interface but it essentially does not enforce any particular semantics on those interfaces.</div><br/></div></div></div></div><div id="42807094" class="c"><input type="checkbox" id="c-42807094" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42806095">parent</a><span>|</span><a href="#42806268">prev</a><span>|</span><a href="#42806447">next</a><span>|</span><label class="collapse" for="c-42807094">[-]</label><label class="expand" for="c-42807094">[10 more]</label></div><br/><div class="children"><div class="content">By the way, LMDB&#x27;s main developer Howard Chu responded to the paper. He said,<p>&gt; They report on a single &quot;vulnerability&quot; in LMDB, in which LMDB depends on the atomicity of a single sector 106-byte write for its transaction commit semantics. Their claim is that not all storage devices may guarantee the atomicity of such a write. While I myself filed an ITS on this very topic a year ago, <a href="http:&#x2F;&#x2F;www.openldap.org&#x2F;its&#x2F;index.cgi&#x2F;Incoming?id=7668" rel="nofollow">http:&#x2F;&#x2F;www.openldap.org&#x2F;its&#x2F;index.cgi&#x2F;Incoming?id=7668</a> the reality is that all storage devices made in the past 20+ years actually do guarantee atomicity of single-sector writes. You would have to rewind back to 30 years at least, to find a HDD where this is not true.<p>So this is a case where the programmers of LMDB thought about the &quot;incorrect&quot; use and decided that it was a calculated risk to take because the incorrectness does not manifest on any recent hardware.<p>This is analogous to the case where someone complains some C code has undefined behavior, and the developer responds by saying they have manually checked the generated assembler to make sure the assembler is correct at the ISA level even though the C code is wrong at the abstract C machine level, and they commit to checking this in the future.<p>Furthermore both the LMDB issue and the Postgres issue are noted in the paper to be previously known. The paper author states that Postgres documents this issue. The paper mentions pg_control so I&#x27;m guessing it&#x27;s referring to this known issue here: <a href="https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;Full_page_writes" rel="nofollow">https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;Full_page_writes</a><p>&gt; We rely on 512 byte blocks (historical sector size of spinning disks) to be power-loss atomic, when we overwrite the &quot;control file&quot; at checkpoints.</div><br/><div id="42808154" class="c"><input type="checkbox" id="c-42808154" checked=""/><div class="controls bullet"><span class="by">yuboyt</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42807094">parent</a><span>|</span><a href="#42810632">next</a><span>|</span><label class="collapse" for="c-42808154">[-]</label><label class="expand" for="c-42808154">[8 more]</label></div><br/><div class="children"><div class="content">This assumption was wrong for Intel Optane memory. Power loss could cut the data stream anywhere in the middle. (Note: the DIMM nonvolatile memory version)</div><br/><div id="42808621" class="c"><input type="checkbox" id="c-42808621" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808154">parent</a><span>|</span><a href="#42811114">next</a><span>|</span><label class="collapse" for="c-42808621">[-]</label><label class="expand" for="c-42808621">[5 more]</label></div><br/><div class="children"><div class="content">consumer Optane were not &quot;power loss protected&quot;, that is every different than not honoring a requested a synchronous write.<p>The crash-consistency problem is very different than the durability of real synchronous writes problem.  There are some storage devices which will lie about synch writes, sometimes hoping that a backup battery will allow them to complete those write.<p>System crashes are inevitable, use things like write ahead logs depending on need etc...  No storage API will get rid of all system crashes and yes even apple games the system by disabling real sync writes, so that will always be a battle.</div><br/><div id="42808766" class="c"><input type="checkbox" id="c-42808766" checked=""/><div class="controls bullet"><span class="by">yuboyt</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808621">parent</a><span>|</span><a href="#42811114">next</a><span>|</span><label class="collapse" for="c-42808766">[-]</label><label class="expand" for="c-42808766">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re missing the point. GP was mentioning the common assumption that all systems in the last 30 years are sector-atomic under power loss condition. Either the sector is fully written or fully not written. Optane was a rare counter example, where sector can become partially written, thus not sector-atomic.</div><br/><div id="42809200" class="c"><input type="checkbox" id="c-42809200" checked=""/><div class="controls bullet"><span class="by">x1f604</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808766">parent</a><span>|</span><a href="#42811114">next</a><span>|</span><label class="collapse" for="c-42809200">[-]</label><label class="expand" for="c-42809200">[3 more]</label></div><br/><div class="children"><div class="content">It is not rare for flash storage devices to lose data on power loss, even data that is FLUSH&#x27;d. See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38371307">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38371307</a><p>There are known cases where power loss during a write can corrupt previously written data (data at rest). This is not some rare occurrence. This is why enterprise flash storage devices have power loss protection.<p>See also: <a href="https:&#x2F;&#x2F;serverfault.com&#x2F;questions&#x2F;923971&#x2F;is-there-a-way-to-protect-ssd-from-corruption-due-to-power-loss" rel="nofollow">https:&#x2F;&#x2F;serverfault.com&#x2F;questions&#x2F;923971&#x2F;is-there-a-way-to-p...</a></div><br/><div id="42809281" class="c"><input type="checkbox" id="c-42809281" checked=""/><div class="controls bullet"><span class="by">namibj</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42809200">parent</a><span>|</span><a href="#42811114">next</a><span>|</span><label class="collapse" for="c-42809281">[-]</label><label class="expand" for="c-42809281">[2 more]</label></div><br/><div class="children"><div class="content">I wish someone would sell an SSD that was at most a firmware update away between regular NVMe drive and ZNS NVMe drive.
The latter just doesn&#x27;t leave much room for the firmware to be clever and just swallow data.<p>Maybe also add a pSLC formatting mode for a namespace so one can be explicit about that capability...<p>It just has to be a drive that&#x27;s useable as a generic gaming SSD so people can just buy it and have casual fun with it, like they did with Nvidia GTX GPUs and CUDA.</div><br/><div id="42811162" class="c"><input type="checkbox" id="c-42811162" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42809281">parent</a><span>|</span><a href="#42811114">next</a><span>|</span><label class="collapse" for="c-42811162">[-]</label><label class="expand" for="c-42811162">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately manifacturers almost always prefer price gouging on features that &quot;CuStOmErS aRe NoT GoInG tO nEeD&quot;. Is it even a ZNS device available for someone who isn&#x27;t a hyperscale datacenter operator nowadays?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42811114" class="c"><input type="checkbox" id="c-42811114" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42808154">parent</a><span>|</span><a href="#42808621">prev</a><span>|</span><a href="#42810632">next</a><span>|</span><label class="collapse" for="c-42811114">[-]</label><label class="expand" for="c-42811114">[2 more]</label></div><br/><div class="children"><div class="content">Really? A 512-byte sector could get partially written? Did anyone actually observe this, or was it just a case of Intel CYA saying they didn&#x27;t guarantee anything?</div><br/><div id="42811413" class="c"><input type="checkbox" id="c-42811413" checked=""/><div class="controls bullet"><span class="by">yuboyt</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42811114">parent</a><span>|</span><a href="#42810632">next</a><span>|</span><label class="collapse" for="c-42811413">[-]</label><label class="expand" for="c-42811413">[1 more]</label></div><br/><div class="children"><div class="content">Yes, really. &quot;Crash-consistent data structures were proposed by enforcing cacheline-level failure-atomicity&quot; see references in: <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;3492321.3519556" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;3492321.3519556</a></div><br/></div></div></div></div></div></div><div id="42810632" class="c"><input type="checkbox" id="c-42810632" checked=""/><div class="controls bullet"><span class="by">senderista</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42807094">parent</a><span>|</span><a href="#42808154">prev</a><span>|</span><a href="#42806447">next</a><span>|</span><label class="collapse" for="c-42810632">[-]</label><label class="expand" for="c-42810632">[1 more]</label></div><br/><div class="children"><div class="content">This is called “Atomic Write Unit Power Failure” (AWUPF).</div><br/></div></div></div></div><div id="42806447" class="c"><input type="checkbox" id="c-42806447" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#42806095">parent</a><span>|</span><a href="#42807094">prev</a><span>|</span><a href="#42810422">next</a><span>|</span><label class="collapse" for="c-42806447">[-]</label><label class="expand" for="c-42806447">[5 more]</label></div><br/><div class="children"><div class="content">&gt; why the file API so hard to use that even experts make mistakes?<p>Sounds like Worse Is Better™: operating systems that tried to present safer abstractions were at a disadvantage compared to operating systems that shipped whatever was easiest to implement.<p>(I&#x27;m not an expert in the history, just observing the surface similarity and hoping someone with more knowledge can substantiate it.)</div><br/><div id="42809496" class="c"><input type="checkbox" id="c-42809496" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806447">parent</a><span>|</span><a href="#42808204">next</a><span>|</span><label class="collapse" for="c-42809496">[-]</label><label class="expand" for="c-42809496">[3 more]</label></div><br/><div class="children"><div class="content">POSIX file locking is clearly modeled around whatever was simplest to implement, although it makes no sense at all.</div><br/><div id="42809546" class="c"><input type="checkbox" id="c-42809546" checked=""/><div class="controls bullet"><span class="by">tjalfi</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42809496">parent</a><span>|</span><a href="#42808204">next</a><span>|</span><label class="collapse" for="c-42809546">[-]</label><label class="expand" for="c-42809546">[2 more]</label></div><br/><div class="children"><div class="content">Jeremy Allison tracked down why POSIX standardized this behavior[0].<p><i>The reason is historical and reflects a flaw in the POSIX standards process, in my opinion, one that hopefully won&#x27;t be repeated in the future. I finally tracked down why this insane behavior was standardized by the POSIX committee by talking to long-time BSD hacker and POSIX standards committee member Kirk McKusick (he of the BSD daemon artwork). As he recalls, AT&amp;T brought the current behavior to the standards committee as a proposal for byte-range locking, as this was how their current code implementation worked. The committee asked other ISVs if this was how locking should be done. The ISVs who cared about byte range locking were the large database vendors such as Oracle, Sybase and Informix (at the time). All of these companies did their own byte range locking within their own applications, none of them depended on or needed the underlying operating system to provide locking services for them. So their unanimous answer was &quot;we don&#x27;t care&quot;. In the absence of any strong negative feedback on a proposal, the committee added it &quot;as-is&quot;, and took as the desired behavior the specifics of the first implementation, the brain-dead one from AT&amp;T.</i><p>[0] <a href="https:&#x2F;&#x2F;www.samba.org&#x2F;samba&#x2F;news&#x2F;articles&#x2F;low_point&#x2F;tale_two_stds_os2.html" rel="nofollow">https:&#x2F;&#x2F;www.samba.org&#x2F;samba&#x2F;news&#x2F;articles&#x2F;low_point&#x2F;tale_two...</a></div><br/><div id="42809721" class="c"><input type="checkbox" id="c-42809721" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42809546">parent</a><span>|</span><a href="#42808204">next</a><span>|</span><label class="collapse" for="c-42809721">[-]</label><label class="expand" for="c-42809721">[1 more]</label></div><br/><div class="children"><div class="content">The most egregious part of it for me is that if I open and close a file I might be canceling some other library&#x27;s lock that I&#x27;m completely unaware of.<p>I resisted using them in my SQLite VFS, until I partially relented for WAL locks.<p>I wish more platforms embraced OFD locks. macOS has them, but hidden. illumos fakes them with BSD locks (which is worse, actually). The BSDs don&#x27;t add them. So it&#x27;s just Linux, and Windows with sane locking. In some ways Windows is actually better (supports timeouts).</div><br/></div></div></div></div></div></div><div id="42808204" class="c"><input type="checkbox" id="c-42808204" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#42806095">root</a><span>|</span><a href="#42806447">parent</a><span>|</span><a href="#42809496">prev</a><span>|</span><a href="#42810422">next</a><span>|</span><label class="collapse" for="c-42808204">[-]</label><label class="expand" for="c-42808204">[1 more]</label></div><br/><div class="children"><div class="content">Why does that seem more likely than file system API simply not having been a major factor in the success of failure of OSes?</div><br/></div></div></div></div><div id="42810422" class="c"><input type="checkbox" id="c-42810422" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#42806095">parent</a><span>|</span><a href="#42806447">prev</a><span>|</span><a href="#42810669">next</a><span>|</span><label class="collapse" for="c-42810422">[-]</label><label class="expand" for="c-42810422">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why the file API so hard to use that even experts make mistakes?<p>Because it was poorly designed, and there is a high resistance to change, so those design mistakes from decades ago continue to bite</div><br/></div></div><div id="42810669" class="c"><input type="checkbox" id="c-42810669" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#42806095">parent</a><span>|</span><a href="#42810422">prev</a><span>|</span><a href="#42806700">next</a><span>|</span><label class="collapse" for="c-42810669">[-]</label><label class="expand" for="c-42810669">[1 more]</label></div><br/><div class="children"><div class="content">And yet all of these systems basically work for day-to-day operations, and fail only under obscure error conditions.<p>It is totally acceptable for applications to say &quot;I do not support X conditions&quot;. Swap out the file half way through a read? Sorry don&#x27;t support that. Remove power to the storage devise in the middle of a sync operation? Sorry don&#x27;t support that.<p>For vital applications, for example databases, this is a known problem and risks of the API are accounted for. Other applications don&#x27;t have nearly that level of risk associated with them. My music tagging app doesn&#x27;t need to be resistant to the SSD being struck by lightning.<p>It is perfectly acceptable to design APIs for 95% of use cases and leave extremely difficult leaks to be solved by the small number of practitioners that really need to solve those leaks.</div><br/></div></div><div id="42806700" class="c"><input type="checkbox" id="c-42806700" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42806095">parent</a><span>|</span><a href="#42810669">prev</a><span>|</span><a href="#42806242">next</a><span>|</span><label class="collapse" for="c-42806700">[-]</label><label class="expand" for="c-42806700">[1 more]</label></div><br/><div class="children"><div class="content">Something this misses is that all programs make assumptions for example - “my process is the only one writing this file because it created it”<p>Evaluating correctness without that consideration is too high of a bar.<p>Safety and correctness cannot be “impossible to misuse”</div><br/></div></div></div></div><div id="42806242" class="c"><input type="checkbox" id="c-42806242" checked=""/><div class="controls bullet"><span class="by">praptak</span><span>|</span><a href="#42806095">prev</a><span>|</span><a href="#42806127">next</a><span>|</span><label class="collapse" for="c-42806242">[-]</label><label class="expand" for="c-42806242">[1 more]</label></div><br/><div class="children"><div class="content">Ext4 actually special-handles the rename trick so that it works even if it should not:<p>&quot;If auto_da_alloc is enabled, ext4 will detect the replace-via-rename and replace-via-truncate patterns and [basically save your ass]&quot;[0]<p>[0]<a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;ext4.html" rel="nofollow">https:&#x2F;&#x2F;docs.kernel.org&#x2F;admin-guide&#x2F;ext4.html</a></div><br/></div></div><div id="42806127" class="c"><input type="checkbox" id="c-42806127" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42806242">prev</a><span>|</span><a href="#42810082">next</a><span>|</span><label class="collapse" for="c-42806127">[-]</label><label class="expand" for="c-42806127">[10 more]</label></div><br/><div class="children"><div class="content">&gt; they found that every single piece of software they tested except for SQLite in one particular mode had at least one bug.<p>This is why whenever I need to persist any kind of state to disk, SQLite is the first tool I reach for. Filesystem APIs are scary, but SQLite is well-behaved.<p>Of course, it doesn&#x27;t always make sense to do that, like the dropbox use case.</div><br/><div id="42806901" class="c"><input type="checkbox" id="c-42806901" checked=""/><div class="controls bullet"><span class="by">nodamage</span><span>|</span><a href="#42806127">parent</a><span>|</span><a href="#42806194">next</a><span>|</span><label class="collapse" for="c-42806901">[-]</label><label class="expand" for="c-42806901">[7 more]</label></div><br/><div class="children"><div class="content">Before becoming too overconfident in SQLite note that Rebello et al. (<a href="https:&#x2F;&#x2F;ramalagappan.github.io&#x2F;pdfs&#x2F;papers&#x2F;cuttlefs.pdf" rel="nofollow">https:&#x2F;&#x2F;ramalagappan.github.io&#x2F;pdfs&#x2F;papers&#x2F;cuttlefs.pdf</a>) tested SQLite (along with Redis, LMDB, LevelDB, and PostgreSQL) using a proxy file system to simulate fsync errors and found that none of them handled all failure conditions safely.<p>In practice I believe I&#x27;ve seen SQLite databases corrupted due to what I suspect are two main causes:<p>1. The device powering off during the middle of a write, and<p>2. The device running out of space during the middle of a write.</div><br/><div id="42808760" class="c"><input type="checkbox" id="c-42808760" checked=""/><div class="controls bullet"><span class="by">justin66</span><span>|</span><a href="#42806127">root</a><span>|</span><a href="#42806901">parent</a><span>|</span><a href="#42807411">next</a><span>|</span><label class="collapse" for="c-42808760">[-]</label><label class="expand" for="c-42808760">[1 more]</label></div><br/><div class="children"><div class="content">I remembered Howard Chu commenting on that paper...<p><a href="https:&#x2F;&#x2F;lists.openldap.org&#x2F;hyperkitty&#x2F;list&#x2F;openldap-devel@openldap.org&#x2F;thread&#x2F;YUUKXVYXA347IWW3UKRS6NJHBU4FEE6M&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lists.openldap.org&#x2F;hyperkitty&#x2F;list&#x2F;openldap-devel@op...</a><p>I&#x27;m pretty sure that&#x27;s <i>not</i> where I originally saw his comments. I remember his criticisms being a little more pointed. Although I guess &quot;This is a bunch of academic speculation, with a total absence of real world modeling to validate the failure scenarios they presented&quot; is pretty pointed.</div><br/></div></div><div id="42807411" class="c"><input type="checkbox" id="c-42807411" checked=""/><div class="controls bullet"><span class="by">ablob</span><span>|</span><a href="#42806127">root</a><span>|</span><a href="#42806901">parent</a><span>|</span><a href="#42808760">prev</a><span>|</span><a href="#42806194">next</a><span>|</span><label class="collapse" for="c-42807411">[-]</label><label class="expand" for="c-42807411">[5 more]</label></div><br/><div class="children"><div class="content">I believe it is impossible to prevent dataloss if the device powers off during a write. The point about corruption still stands and appears to be used correctly from what I skimmed in the paper. Nice reference.</div><br/><div id="42811119" class="c"><input type="checkbox" id="c-42811119" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42806127">root</a><span>|</span><a href="#42807411">parent</a><span>|</span><a href="#42809552">next</a><span>|</span><label class="collapse" for="c-42811119">[-]</label><label class="expand" for="c-42811119">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I believe it is impossible to prevent dataloss if the device powers off during a write.<p>Most devices write sectors atomically, and so you can build a system on top of that that does not lose committed data. (Of course if the device powers off during a write then you can lose the uncommitted data you were trying to write, but the point is you don&#x27;t ever have corruption, you get either the data that was there before the write attempt or the data that is there after).</div><br/></div></div><div id="42809552" class="c"><input type="checkbox" id="c-42809552" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42806127">root</a><span>|</span><a href="#42807411">parent</a><span>|</span><a href="#42811119">prev</a><span>|</span><a href="#42807642">next</a><span>|</span><label class="collapse" for="c-42809552">[-]</label><label class="expand" for="c-42809552">[1 more]</label></div><br/><div class="children"><div class="content">If the file system uses strict COW it should survive that situation.</div><br/></div></div><div id="42807642" class="c"><input type="checkbox" id="c-42807642" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#42806127">root</a><span>|</span><a href="#42807411">parent</a><span>|</span><a href="#42809552">prev</a><span>|</span><a href="#42806194">next</a><span>|</span><label class="collapse" for="c-42807642">[-]</label><label class="expand" for="c-42807642">[2 more]</label></div><br/><div class="children"><div class="content">Only way I know of is if you have e.g. a RAID controller with a battery-backed write cache. Even that may not be 100% reliable but it&#x27;s the closest I know of. Of course that&#x27;s not a <i>software</i> solution at all.</div><br/><div id="42808277" class="c"><input type="checkbox" id="c-42808277" checked=""/><div class="controls bullet"><span class="by">count</span><span>|</span><a href="#42806127">root</a><span>|</span><a href="#42807642">parent</a><span>|</span><a href="#42806194">next</a><span>|</span><label class="collapse" for="c-42808277">[-]</label><label class="expand" for="c-42808277">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s uh, not running out of power in the middle of the write.  That&#x27;s having extra special backup power to finish the write.  If your battery dies mid cache-write-out, you&#x27;re still screwed.</div><br/></div></div></div></div></div></div></div></div><div id="42806194" class="c"><input type="checkbox" id="c-42806194" checked=""/><div class="controls bullet"><span class="by">ziddoap</span><span>|</span><a href="#42806127">parent</a><span>|</span><a href="#42806901">prev</a><span>|</span><a href="#42810082">next</a><span>|</span><label class="collapse" for="c-42806194">[-]</label><label class="expand" for="c-42806194">[2 more]</label></div><br/><div class="children"><div class="content">&gt;<i>SQLite is the first tool I reach for.</i><p>Hopefully in whichever particular mode is referenced!</div><br/><div id="42806231" class="c"><input type="checkbox" id="c-42806231" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42806127">root</a><span>|</span><a href="#42806194">parent</a><span>|</span><a href="#42810082">next</a><span>|</span><label class="collapse" for="c-42806231">[-]</label><label class="expand" for="c-42806231">[1 more]</label></div><br/><div class="children"><div class="content">WAL mode, yes!</div><br/></div></div></div></div></div></div><div id="42810082" class="c"><input type="checkbox" id="c-42810082" checked=""/><div class="controls bullet"><span class="by">edgarvaldes</span><span>|</span><a href="#42806127">prev</a><span>|</span><a href="#42806760">next</a><span>|</span><label class="collapse" for="c-42810082">[-]</label><label class="expand" for="c-42810082">[3 more]</label></div><br/><div class="children"><div class="content">As per HN headlines, files are hard, git is hard, regex is hard, time zones are hard, money as data type is hard, hiring is hard, people is hard.<p>I wonder what is easy.</div><br/><div id="42811060" class="c"><input type="checkbox" id="c-42811060" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42810082">parent</a><span>|</span><a href="#42810378">next</a><span>|</span><label class="collapse" for="c-42811060">[-]</label><label class="expand" for="c-42811060">[1 more]</label></div><br/><div class="children"><div class="content">Complaining :)</div><br/></div></div><div id="42810378" class="c"><input type="checkbox" id="c-42810378" checked=""/><div class="controls bullet"><span class="by">ssivark</span><span>|</span><a href="#42810082">parent</a><span>|</span><a href="#42811060">prev</a><span>|</span><a href="#42806760">next</a><span>|</span><label class="collapse" for="c-42810378">[-]</label><label class="expand" for="c-42810378">[1 more]</label></div><br/><div class="children"><div class="content">To reuse another HN headline, all this is probably because no one really cares X-)</div><br/></div></div></div></div><div id="42806760" class="c"><input type="checkbox" id="c-42806760" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#42810082">prev</a><span>|</span><a href="#42808483">next</a><span>|</span><label class="collapse" for="c-42806760">[-]</label><label class="expand" for="c-42806760">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if, in the Pillai paper, I wonder if they tested the SQLite Rollback option with the default synchronous [1] (`NORMAL`, I believe) or with `EXTRA`. I&#x27;m thinking that it was probably the default.<p>I kinda think, and I could be wrong, that SQLite rollback would not have any vulnerabilities with `synchronous=EXTRA` (and `fullfsync=F_FULLFSYNC` on macOS [2]).<p>[1]: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;pragma.html#pragma_synchronous" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;pragma.html#pragma_synchronous</a><p>[2]: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;pragma.html#pragma_fullfsync" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;pragma.html#pragma_fullfsync</a></div><br/></div></div><div id="42808483" class="c"><input type="checkbox" id="c-42808483" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42806760">prev</a><span>|</span><a href="#42809340">next</a><span>|</span><label class="collapse" for="c-42808483">[-]</label><label class="expand" for="c-42808483">[2 more]</label></div><br/><div class="children"><div class="content">&gt; On Linux ZFS, it appears that there&#x27;s a code path designed to do the right thing, but CPU usage spikes and the system may hang or become unusable.<p>ZFS fsync will not fail, although it could end up waiting forever when a pool faults due to hardware failures:<p><a href="https:&#x2F;&#x2F;papers.freebsd.org&#x2F;2024&#x2F;asiabsdcon&#x2F;norris_openzfs-fsync-failure&#x2F;" rel="nofollow">https:&#x2F;&#x2F;papers.freebsd.org&#x2F;2024&#x2F;asiabsdcon&#x2F;norris_openzfs-fs...</a></div><br/><div id="42809245" class="c"><input type="checkbox" id="c-42809245" checked=""/><div class="controls bullet"><span class="by">ein0p</span><span>|</span><a href="#42808483">parent</a><span>|</span><a href="#42809340">next</a><span>|</span><label class="collapse" for="c-42809245">[-]</label><label class="expand" for="c-42809245">[1 more]</label></div><br/><div class="children"><div class="content">ZFS on Linux unfortunately has a long standing bug which makes it unusable under load: <a href="https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;issues&#x2F;9130">https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;issues&#x2F;9130</a>. 5.5 years old, nobody knows the root cause. Symptoms: under load (such as what one or two large concurrent rsyncs may generate over a fast network - that&#x27;s how I encountered it) the pool begins to crap out and shows integrity errors and in some cases loses data (for some users - it never lost data for me). So if you do any high rate copies you _must_ hash-compare source and destination. This needs to be done after all the writes are completed to the zpool, because concurrent high rate reads seem to exacerbate the issue. Once the data is at rest, things seem to be fine. Low levels of load are also fine.</div><br/></div></div></div></div><div id="42809340" class="c"><input type="checkbox" id="c-42809340" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#42808483">prev</a><span>|</span><a href="#42806066">next</a><span>|</span><label class="collapse" for="c-42809340">[-]</label><label class="expand" for="c-42809340">[1 more]</label></div><br/><div class="children"><div class="content">No Javascript or SNI:<p><a href="https:&#x2F;&#x2F;archive.wikiwix.com&#x2F;cache&#x2F;index2.php?rev_t=&amp;url=https%3A%2F%2Fdanluu.com%2Fdeconstruct-files%2F" rel="nofollow">https:&#x2F;&#x2F;archive.wikiwix.com&#x2F;cache&#x2F;index2.php?rev_t=&amp;url=http...</a></div><br/></div></div><div id="42806066" class="c"><input type="checkbox" id="c-42806066" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42809340">prev</a><span>|</span><a href="#42809059">next</a><span>|</span><label class="collapse" for="c-42806066">[-]</label><label class="expand" for="c-42806066">[7 more]</label></div><br/><div class="children"><div class="content">No mention on ntfs and windows keywords in the article, for those interested.</div><br/><div id="42806797" class="c"><input type="checkbox" id="c-42806797" checked=""/><div class="controls bullet"><span class="by">pjdesno</span><span>|</span><a href="#42806066">parent</a><span>|</span><a href="#42806409">next</a><span>|</span><label class="collapse" for="c-42806797">[-]</label><label class="expand" for="c-42806797">[3 more]</label></div><br/><div class="children"><div class="content">Although the conference this was presented at is platform-agnostic, the author is an expert on Linux, and the motivation for the talk is Linux-specific. (Dropbox dropping support for non-ext4 file systems)<p>The post supports its points with extensive references to prior research - research which hasn&#x27;t been done in the Microsoft environment. For various reasons (NDAs, etc.) it&#x27;s likely that no such research will ever be published, either. Basically it&#x27;s impossible to write a post this detailed about safety issues in Microsoft file systems unless you work there. If you did, it would still take you a year or two of full-time work to do the background stuff, and when you finished, marketing and&#x2F;or legal wouldn&#x27;t let you actually tell anyone about it.</div><br/><div id="42809571" class="c"><input type="checkbox" id="c-42809571" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42806066">root</a><span>|</span><a href="#42806797">parent</a><span>|</span><a href="#42806409">next</a><span>|</span><label class="collapse" for="c-42809571">[-]</label><label class="expand" for="c-42809571">[2 more]</label></div><br/><div class="children"><div class="content">Universities can get Windows source code under NDA and do research on it but nobody really cares about such work.</div><br/><div id="42810704" class="c"><input type="checkbox" id="c-42810704" checked=""/><div class="controls bullet"><span class="by">pjdesno</span><span>|</span><a href="#42806066">root</a><span>|</span><a href="#42809571">parent</a><span>|</span><a href="#42806409">next</a><span>|</span><label class="collapse" for="c-42810704">[-]</label><label class="expand" for="c-42810704">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Getting windows source code under NDA&quot; doesn&#x27;t necessarily mean &quot;can do research on it&quot;.<p>If you can&#x27;t publish it, it&#x27;s not research. If the source code is under NDA, then Microsoft gets the final say about whether you can publish or not, and if the result is embarrassing to Microsoft, I&#x27;m guessing it&#x27;s &quot;or not&quot;.</div><br/></div></div></div></div></div></div><div id="42806409" class="c"><input type="checkbox" id="c-42806409" checked=""/><div class="controls bullet"><span class="by">yahayahya</span><span>|</span><a href="#42806066">parent</a><span>|</span><a href="#42806797">prev</a><span>|</span><a href="#42809059">next</a><span>|</span><label class="collapse" for="c-42806409">[-]</label><label class="expand" for="c-42806409">[3 more]</label></div><br/><div class="children"><div class="content">Is that because the windows APIs are better? Or because businesses build their embedded systems&#x2F;servers with Windows?</div><br/><div id="42808602" class="c"><input type="checkbox" id="c-42808602" checked=""/><div class="controls bullet"><span class="by">p_ing</span><span>|</span><a href="#42806066">root</a><span>|</span><a href="#42806409">parent</a><span>|</span><a href="#42808042">next</a><span>|</span><label class="collapse" for="c-42808602">[-]</label><label class="expand" for="c-42808602">[1 more]</label></div><br/><div class="children"><div class="content">Certainly depends on which APIs you ultimately use as a developer, right? If it is .NET, they&#x27;re super simple, and you can get IOCP for &quot;free&quot; and non-blocking async I&#x2F;O is quite easy to implement.<p>I can&#x27;t say the Win32 File API is &quot;pretty&quot;, but it&#x27;s also an abstraction, like the .NET File Class is. And if you touch the NT API, you&#x27;re naughty.<p>On Linux and macOS you use the same API, just the backends are different if you want async (epoll [blocking async] on Linux, kqueue on macOS).</div><br/></div></div><div id="42808042" class="c"><input type="checkbox" id="c-42808042" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42806066">root</a><span>|</span><a href="#42806409">parent</a><span>|</span><a href="#42808602">prev</a><span>|</span><a href="#42809059">next</a><span>|</span><label class="collapse" for="c-42808042">[-]</label><label class="expand" for="c-42808042">[1 more]</label></div><br/><div class="children"><div class="content">I doubt that, was just curious how it might compare in the article.</div><br/></div></div></div></div></div></div><div id="42809059" class="c"><input type="checkbox" id="c-42809059" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#42806066">prev</a><span>|</span><a href="#42805463">next</a><span>|</span><label class="collapse" for="c-42809059">[-]</label><label class="expand" for="c-42809059">[2 more]</label></div><br/><div class="children"><div class="content">The article wrap up with this salient point:<p>&gt; <i>In conclusion, computers don&#x27;t work (but I guess you already know this...</i></div><br/><div id="42811077" class="c"><input type="checkbox" id="c-42811077" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42809059">parent</a><span>|</span><a href="#42805463">next</a><span>|</span><label class="collapse" for="c-42811077">[-]</label><label class="expand" for="c-42811077">[1 more]</label></div><br/><div class="children"><div class="content">They work.<p>Just not all the time.</div><br/></div></div></div></div><div id="42808249" class="c"><input type="checkbox" id="c-42808249" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42805463">prev</a><span>|</span><label class="collapse" for="c-42808249">[-]</label><label class="expand" for="c-42808249">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it. The only times I&#x27;ve had problems with filesystem corruption in the past few decades was with a hardware problem, and said hardware was quickly replaced. FAT family has been perfectly fine while I&#x27;ve encountered corruption on every other FS including NTFS, exFAT, and the ext* family.<p>Meanwhile you can read plenty of stories of others having the exact opposite experience.<p>If you keep losing data to power losses or crashes, perhaps fix the cause of that? It doesn&#x27;t make sense to try to work around it.</div><br/><div id="42809882" class="c"><input type="checkbox" id="c-42809882" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42808249">parent</a><span>|</span><a href="#42808666">next</a><span>|</span><label class="collapse" for="c-42809882">[-]</label><label class="expand" for="c-42809882">[1 more]</label></div><br/><div class="children"><div class="content">There was that time (2009 or so?) I wrote 2 million files to a single directory on NTFS and that filesystem was never the same again.  It didn&#x27;t <i>seem</i> to be a hardware problem.  I used to be really careful to not put a crazy number of files in a directory on Linux and Windows storing them in subdirs like<p><pre><code>  b7&#x2F;b74a&#x2F;b74a56
</code></pre>
where the digits are derived from a hash of the file name but lately I&#x27;ve had some NTFS volumes with a 1M file directory that seem to be OK.<p>Hardware problems also manifest in mysterious ways.  On both Windows and MacOS I had computers that seemed to be OK until I did an OS update which caused enough IO that a failing HDD was pushed over the edge and the update failed;  in one case I was able to roll back the update but not apply the update,  in another case the machine was trashed.  Careful investigation (like taking the disk out and inspecting it on another computer) revealed a hard drive error although there was no clear indication of this in the UI and the average person would blame to software update</div><br/></div></div><div id="42808666" class="c"><input type="checkbox" id="c-42808666" checked=""/><div class="controls bullet"><span class="by">nodamage</span><span>|</span><a href="#42808249">parent</a><span>|</span><a href="#42809882">prev</a><span>|</span><a href="#42810018">next</a><span>|</span><label class="collapse" for="c-42808666">[-]</label><label class="expand" for="c-42808666">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If you keep losing data to power losses or crashes, perhaps fix the cause of that?<p>I keep telling my users to make sure to plug their phones in before the battery dies, but for some reason they keep forgetting...</div><br/><div id="42808971" class="c"><input type="checkbox" id="c-42808971" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42808249">root</a><span>|</span><a href="#42808666">parent</a><span>|</span><a href="#42810018">next</a><span>|</span><label class="collapse" for="c-42808971">[-]</label><label class="expand" for="c-42808971">[2 more]</label></div><br/><div class="children"><div class="content">Then that&#x27;s entirely their fault. They deserve all the corruption they get.</div><br/><div id="42809594" class="c"><input type="checkbox" id="c-42809594" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42808249">root</a><span>|</span><a href="#42808971">parent</a><span>|</span><a href="#42810018">next</a><span>|</span><label class="collapse" for="c-42809594">[-]</label><label class="expand" for="c-42809594">[1 more]</label></div><br/><div class="children"><div class="content">Seems like I hit a nerve. Apparently teaching users responsibility is a bad thing?<p>No wonder things are &quot;hard&quot;. Because otherwise many in this godforsaken industry wouldn&#x27;t need to be employed.</div><br/></div></div></div></div></div></div><div id="42810018" class="c"><input type="checkbox" id="c-42810018" checked=""/><div class="controls bullet"><span class="by">mystified5016</span><span>|</span><a href="#42808249">parent</a><span>|</span><a href="#42808666">prev</a><span>|</span><label class="collapse" for="c-42810018">[-]</label><label class="expand" for="c-42810018">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you keep losing data to power losses or crashes, perhaps fix the cause of that? It doesn&#x27;t make sense to try to work around it.<p>Ponder this notion for a moment: there are problems within one&#x27;s control and problems <i>outside</i> of one&#x27;s control.<p>For example, we can&#x27;t control the weather. If it snows three feet overnight you simply have to deal with the fact that you&#x27;re not getting to work today.<p>Since we can&#x27;t simply <i>stop</i> hardware from failing, we have to deal with the fact that hardware fails. Your seventeen redundant UPSes might experience a one in a trillion cascade failure. It might take the utility ten minutes longer to restore your power than you have onsite generation.<p>This is not a class of problem we can control or prevent. We fix these problems by building systems which withstand failures. You can&#x27;t just will electrons out of the wall socket, but you can build a better disk or FS that corrupts less data when the electrons stop.</div><br/></div></div></div></div></div></div></div></div></div></body></html>