<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701075668270" as="style"/><link rel="stylesheet" href="styles.css?v=1701075668270"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://muxup.com/2023q4/storing-data-in-pointers">Storing data in pointers</a> <span class="domain">(<a href="https://muxup.com">muxup.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>25 comments</span></div><br/><div><div id="38427351" class="c"><input type="checkbox" id="c-38427351" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#38426775">next</a><span>|</span><label class="collapse" for="c-38427351">[-]</label><label class="expand" for="c-38427351">[6 more]</label></div><br/><div class="children"><div class="content">I looked at the Go implementation of this in &quot;tagged pointers&quot; [0]<p>The amount of data that can be used for the tag is architecture-dependant, and the routine discards any tag bits that don&#x27;t fit into the tagged pointer without telling the caller.<p>To me, this seems ridiculous - why not just use a struct with a tag and a pointer, and not run the risk of your tag being destroyed without you knowing because the architecture can&#x27;t fit that many bits?<p>But the Go folks are smart, and must be doing this for a reason. Can anyone explain the thinking here?<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;runtime&#x2F;tagptr_64bit.go">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;runtime&#x2F;tagptr_...</a></div><br/><div id="38429760" class="c"><input type="checkbox" id="c-38429760" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#38427351">parent</a><span>|</span><a href="#38427992">next</a><span>|</span><label class="collapse" for="c-38429760">[-]</label><label class="expand" for="c-38429760">[1 more]</label></div><br/><div class="children"><div class="content">It is not a Go thing, tagged pointers have been around forever!!</div><br/></div></div><div id="38427992" class="c"><input type="checkbox" id="c-38427992" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38427351">parent</a><span>|</span><a href="#38429760">prev</a><span>|</span><a href="#38427981">next</a><span>|</span><label class="collapse" for="c-38427992">[-]</label><label class="expand" for="c-38427992">[1 more]</label></div><br/><div class="children"><div class="content">Auxiliary data is not free; by stuffing your data into a pointer you don’t need to pay the cost of extra storage.</div><br/></div></div><div id="38427981" class="c"><input type="checkbox" id="c-38427981" checked=""/><div class="controls bullet"><span class="by">Splizard</span><span>|</span><a href="#38427351">parent</a><span>|</span><a href="#38427992">prev</a><span>|</span><a href="#38428284">next</a><span>|</span><label class="collapse" for="c-38427981">[-]</label><label class="expand" for="c-38427981">[1 more]</label></div><br/><div class="children"><div class="content">Alignment, if you add a uint8 tag for example, you&#x27;ll end up effectively doubling your pointer size.</div><br/></div></div><div id="38428284" class="c"><input type="checkbox" id="c-38428284" checked=""/><div class="controls bullet"><span class="by">none_to_remain</span><span>|</span><a href="#38427351">parent</a><span>|</span><a href="#38427981">prev</a><span>|</span><a href="#38427424">next</a><span>|</span><label class="collapse" for="c-38428284">[-]</label><label class="expand" for="c-38428284">[1 more]</label></div><br/><div class="children"><div class="content">One good use case is if you are doing atomic operations on pointers, you can atomically modify the tag as well.</div><br/></div></div></div></div><div id="38426775" class="c"><input type="checkbox" id="c-38426775" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#38427351">prev</a><span>|</span><a href="#38427103">next</a><span>|</span><label class="collapse" for="c-38426775">[-]</label><label class="expand" for="c-38426775">[6 more]</label></div><br/><div class="children"><div class="content">Very old Macs used this trick to squeeze their ROM routines down a bit, operating with 24 bit addressing and using the top bits for flags and whatnot.  Of course they ran into trouble when machines with 16MB of memory started appearing.  If you do this you might be making more work for yourself in the future when you buy a new machine with 256EB of main memory.</div><br/><div id="38429144" class="c"><input type="checkbox" id="c-38429144" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#38426775">parent</a><span>|</span><a href="#38428373">next</a><span>|</span><label class="collapse" for="c-38429144">[-]</label><label class="expand" for="c-38429144">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing the problem occurred specifically with CPUs newer than the 68000 irrespective of amount of RAM?<p>(Microsoft&#x27;s) Amiga Basic also did this and stopped working on newer CPUs, as the 68000 only has 24 address lines and ignores the top 8 bits of a 32 bit address, but 68020 and up uses all 32 (I don&#x27;t remember about the 68010, but that was pin compatible with the 68000 so I&#x27;m guessing not)</div><br/></div></div><div id="38428373" class="c"><input type="checkbox" id="c-38428373" checked=""/><div class="controls bullet"><span class="by">drfuchs</span><span>|</span><a href="#38426775">parent</a><span>|</span><a href="#38429144">prev</a><span>|</span><a href="#38427524">next</a><span>|</span><label class="collapse" for="c-38428373">[-]</label><label class="expand" for="c-38428373">[1 more]</label></div><br/><div class="children"><div class="content">What’s old is new again: IBM 360 architecture also only used 24 bits for addresses back in the 1960s, so you could stuff data in the upper byte of pointers. Eventually, programs had to declare themselves to be in “Extended Mode” if they wanted to get access to 31-bit addressing instead.</div><br/></div></div><div id="38427524" class="c"><input type="checkbox" id="c-38427524" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#38426775">parent</a><span>|</span><a href="#38428373">prev</a><span>|</span><a href="#38427299">next</a><span>|</span><label class="collapse" for="c-38427524">[-]</label><label class="expand" for="c-38427524">[1 more]</label></div><br/><div class="children"><div class="content">x86_64 (among others) specifically avoided that incompatibility, by the CPU forcing programs to mask those bits out instead of ignoring them.  So programs are very compatible into the future, they just need to limit the range their memory allocator uses.<p>Then it later added <i>explicit</i> automatic masking, which also avoids the problem.  As long as your program can make do with smaller amounts of memory, there are no downsides.</div><br/></div></div><div id="38427299" class="c"><input type="checkbox" id="c-38427299" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#38426775">parent</a><span>|</span><a href="#38427524">prev</a><span>|</span><a href="#38427803">next</a><span>|</span><label class="collapse" for="c-38427299">[-]</label><label class="expand" for="c-38427299">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this was definitely a thing on old macs. Us olds also remember the pain and agony of cleaning this up for 32 bit addressing. Cool as these hacks are, do yourself a favor and avoid the (eventual) agony.</div><br/></div></div><div id="38427803" class="c"><input type="checkbox" id="c-38427803" checked=""/><div class="controls bullet"><span class="by">utopcell</span><span>|</span><a href="#38426775">parent</a><span>|</span><a href="#38427299">prev</a><span>|</span><a href="#38427103">next</a><span>|</span><label class="collapse" for="c-38427803">[-]</label><label class="expand" for="c-38427803">[1 more]</label></div><br/><div class="children"><div class="content">Slight correction: 256 TiB, not EiB.</div><br/></div></div></div></div><div id="38427103" class="c"><input type="checkbox" id="c-38427103" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#38426775">prev</a><span>|</span><a href="#38428260">next</a><span>|</span><label class="collapse" for="c-38427103">[-]</label><label class="expand" for="c-38427103">[1 more]</label></div><br/><div class="children"><div class="content">This is a nice summary of the practical aspects and considerations. It isn’t something anyone should be doing explicitly on a regular basis but there are occasions, particularly in libraries, where it is the perfect tool for the job.<p>There is also the inverse use case: smuggling pointers inside status codes, enums, and similar. For example, optionally encoding a pointer to additional error metadata for non-zero result codes. In C++ it isn’t that uncommon to also see Result types implemented similarly when the type allows it.</div><br/></div></div><div id="38428260" class="c"><input type="checkbox" id="c-38428260" checked=""/><div class="controls bullet"><span class="by">ForOldHack</span><span>|</span><a href="#38427103">prev</a><span>|</span><a href="#38427200">next</a><span>|</span><label class="collapse" for="c-38428260">[-]</label><label class="expand" for="c-38428260">[1 more]</label></div><br/><div class="children"><div class="content">My first thought was to use the Address calculation logic for an additional ALU, then... my second thought was trying to justify this during a code review... and lastly, why Microsoft used the LDT upper byte to make Xenix 286 incompatible... and the headache that changing architectures made for poor programming.</div><br/></div></div><div id="38427200" class="c"><input type="checkbox" id="c-38427200" checked=""/><div class="controls bullet"><span class="by">rr808</span><span>|</span><a href="#38428260">prev</a><span>|</span><a href="#38424126">next</a><span>|</span><label class="collapse" for="c-38427200">[-]</label><label class="expand" for="c-38427200">[3 more]</label></div><br/><div class="children"><div class="content">My favorite hack back in MFC days was a combo box which I stored the pointer address in the text (to the right after a lot of spaces so was hidden). When a user chooses an item, parse the pointer and de-reference it back to an object.</div><br/><div id="38428121" class="c"><input type="checkbox" id="c-38428121" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38427200">parent</a><span>|</span><a href="#38427275">next</a><span>|</span><label class="collapse" for="c-38428121">[-]</label><label class="expand" for="c-38428121">[1 more]</label></div><br/><div class="children"><div class="content">I guess you didn&#x27;t come across CB_SETITEMDATA &#x2F; CB_GETITEMDATA ?</div><br/></div></div><div id="38427275" class="c"><input type="checkbox" id="c-38427275" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#38427200">parent</a><span>|</span><a href="#38428121">prev</a><span>|</span><a href="#38424126">next</a><span>|</span><label class="collapse" for="c-38427275">[-]</label><label class="expand" for="c-38427275">[1 more]</label></div><br/><div class="children"><div class="content">I predict that some day, you&#x27;ll be beaten to death by an angry mob of screen-reader users :)</div><br/></div></div></div></div><div id="38424126" class="c"><input type="checkbox" id="c-38424126" checked=""/><div class="controls bullet"><span class="by">powera</span><span>|</span><a href="#38427200">prev</a><span>|</span><a href="#38427260">next</a><span>|</span><label class="collapse" for="c-38424126">[-]</label><label class="expand" for="c-38424126">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to say you should never do this.<p>But if you aren&#x27;t writing a compiler or an embedded system, you should never do this.</div><br/><div id="38425864" class="c"><input type="checkbox" id="c-38425864" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#38424126">parent</a><span>|</span><a href="#38427058">next</a><span>|</span><label class="collapse" for="c-38425864">[-]</label><label class="expand" for="c-38425864">[2 more]</label></div><br/><div class="children"><div class="content">It is also very useful for some lockfree algorithms, e.g. to fit a pointer and a sequence number within a 64-bit value.</div><br/><div id="38426762" class="c"><input type="checkbox" id="c-38426762" checked=""/><div class="controls bullet"><span class="by">teh_matt</span><span>|</span><a href="#38424126">root</a><span>|</span><a href="#38425864">parent</a><span>|</span><a href="#38427058">next</a><span>|</span><label class="collapse" for="c-38426762">[-]</label><label class="expand" for="c-38426762">[1 more]</label></div><br/><div class="children"><div class="content">You should be very careful when doing that. It may be rare in practice, but it&#x27;s surprisingly easy to trigger ABA issues with only a 16-bit sequence number.</div><br/></div></div></div></div></div></div><div id="38426787" class="c"><input type="checkbox" id="c-38426787" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38427260">prev</a><span>|</span><label class="collapse" for="c-38426787">[-]</label><label class="expand" for="c-38426787">[2 more]</label></div><br/><div class="children"><div class="content">The alpha only accessed 8-byte aligned mem addresses (originally anyway). The bottom 3 bits were ignored (masked out) on lookups, per the spec, to allow users to stuff juicy extra info into these.</div><br/><div id="38428927" class="c"><input type="checkbox" id="c-38428927" checked=""/><div class="controls bullet"><span class="by">asb</span><span>|</span><a href="#38426787">parent</a><span>|</span><label class="collapse" for="c-38428927">[-]</label><label class="expand" for="c-38428927">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a reference on that? This summary of the Alpha AXP &lt;<a href="https:&#x2F;&#x2F;danluu.com&#x2F;dick-sites-alpha-axp-architecture.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;danluu.com&#x2F;dick-sites-alpha-axp-architecture.pdf</a>&gt; states &quot;Normal load or store instructions that specify
an unaligned address take a precise data alignment trap to PALcode (which may do the access using two aligned accesses or report a fatal error, depending on the operating system design)&quot;</div><br/></div></div></div></div></div></div></div></div></div></body></html>