<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689238853539" as="style"/><link rel="stylesheet" href="styles.css?v=1689238853539"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fly.io/blog/tokenized-tokens/">Tokenized Tokens</a> <span class="domain">(<a href="https://fly.io">fly.io</a>)</span></div><div class="subtext"><span>darthShadow</span> | <span>30 comments</span></div><br/><div><div id="36701738" class="c"><input type="checkbox" id="c-36701738" checked=""/><div class="controls bullet"><span class="by">ShaneCurran</span><span>|</span><a href="#36702820">next</a><span>|</span><label class="collapse" for="c-36701738">[-]</label><label class="expand" for="c-36701738">[1 more]</label></div><br/><div class="children"><div class="content">Shameless plug, but we have a product at Evervault[0] called Outbound Relay[1] that’s basically a hosted, managed version of this flow. Secrets can be encrypted anywhere you collect them (either from third-party APIs or directly from the user in their browser) and then used any time you send a request to a downstream API provider.<p>[0]: <a href="https:&#x2F;&#x2F;evervault.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;evervault.com</a><p>[1]: <a href="https:&#x2F;&#x2F;docs.evervault.com&#x2F;products&#x2F;outbound-relay" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.evervault.com&#x2F;products&#x2F;outbound-relay</a></div><br/></div></div><div id="36702820" class="c"><input type="checkbox" id="c-36702820" checked=""/><div class="controls bullet"><span class="by">agwa</span><span>|</span><a href="#36701738">prev</a><span>|</span><a href="#36699559">next</a><span>|</span><label class="collapse" for="c-36702820">[-]</label><label class="expand" for="c-36702820">[1 more]</label></div><br/><div class="children"><div class="content">Props to Fly for open sourcing this!<p>Another thing you can do with a proxy like this is limit the types of requests which can be made to the 3rd party service.  This is very useful if the 3rd party service doesn&#x27;t support fine-grained permissions for its API keys and you don&#x27;t want your application to have full access to the 3rd party service.<p>(I implemented something very similar for my company, which I described here in case anyone is curious: <a href="https:&#x2F;&#x2F;sslmate.com&#x2F;resources&#x2F;protecting_customer_credentials" rel="nofollow noreferrer">https:&#x2F;&#x2F;sslmate.com&#x2F;resources&#x2F;protecting_customer_credential...</a>)</div><br/></div></div><div id="36699559" class="c"><input type="checkbox" id="c-36699559" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36702820">prev</a><span>|</span><a href="#36700983">next</a><span>|</span><label class="collapse" for="c-36699559">[-]</label><label class="expand" for="c-36699559">[6 more]</label></div><br/><div class="children"><div class="content">Psyched to get this out (I mean, I didn&#x27;t do any of the work, but I&#x27;m still psyched it&#x27;s getting out). I&#x27;m also a little bit surprised Vault doesn&#x27;t already have a feature like this as a Secrets Engine.</div><br/><div id="36706327" class="c"><input type="checkbox" id="c-36706327" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#36699559">parent</a><span>|</span><a href="#36702944">next</a><span>|</span><label class="collapse" for="c-36706327">[-]</label><label class="expand" for="c-36706327">[2 more]</label></div><br/><div class="children"><div class="content">This is really cool, but I think it ends up just being a complicated decryption oracle?<p>If I compromise your rails app, and (hypothetically) Stripe allows me to specify the message as it appears on a users credit card statement, could I not just ask it to insert the API key in that field as well and then check my bank statement? This gets easier if there is something where a value gets reflected back to the user, say an SSO error message.<p>My apology if there is already a protection for this, but I didn&#x27;t see any obvious use restrictions in the Github README example.</div><br/><div id="36706390" class="c"><input type="checkbox" id="c-36706390" checked=""/><div class="controls bullet"><span class="by">filleokus</span><span>|</span><a href="#36699559">root</a><span>|</span><a href="#36706327">parent</a><span>|</span><a href="#36702944">next</a><span>|</span><label class="collapse" for="c-36706390">[-]</label><label class="expand" for="c-36706390">[1 more]</label></div><br/><div class="children"><div class="content">As I read the docs, I think the specification for how the secret should be injected lives &quot;statically&quot; within the Tokenizer service, and is not configurable by the internal service making the request.<p>I.e, if you only get control of the Rails app would need to find an api.stripe.com endpoint that reflects back the authentication header.<p>----
EDIT: No, I misunderstood it completely, you are right. But hmm. One way I can think of solving what you mentioned is if the token itself contains the processor parameters. That way it wouldn&#x27;t be possible to change how the templating works after the secret have been tokenised (i.e by an attacker)</div><br/></div></div></div></div><div id="36702944" class="c"><input type="checkbox" id="c-36702944" checked=""/><div class="controls bullet"><span class="by">disintegrator</span><span>|</span><a href="#36699559">parent</a><span>|</span><a href="#36706327">prev</a><span>|</span><a href="#36700778">next</a><span>|</span><label class="collapse" for="c-36702944">[-]</label><label class="expand" for="c-36702944">[2 more]</label></div><br/><div class="children"><div class="content">Great project and write up!<p>Did the team consider developing a custom secret engine [1] for Vault? or is it that the specific dances between Rails, tokenizer, ssokenizer cannot be accommodated by a secret engine?<p>[1]: <a href="https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;vault&#x2F;tutorials&#x2F;custom-secrets-engine" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;vault&#x2F;tutorials&#x2F;custom-secre...</a></div><br/><div id="36703222" class="c"><input type="checkbox" id="c-36703222" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36699559">root</a><span>|</span><a href="#36702944">parent</a><span>|</span><a href="#36700778">next</a><span>|</span><label class="collapse" for="c-36703222">[-]</label><label class="expand" for="c-36703222">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re really picky about how our existing Vault clusters are exposed to applications, so building a Secret Engine for this would have required us to run an entire new Vault cluster. Moreover, we&#x27;re moving away from Vault for a bunch of use cases (not all of them! we&#x27;ll be running Vault indefinitely) --- not because of any failing of Vault, but because at this point we understand our needs very well, and operational legibility has become a really big priority. This also has a clearer path to integrating with our internal Macaroon tokens.<p>I have to imagine somebody is going to build a Secret Engine that does this.</div><br/></div></div></div></div><div id="36700778" class="c"><input type="checkbox" id="c-36700778" checked=""/><div class="controls bullet"><span class="by">JoachimSchipper</span><span>|</span><a href="#36699559">parent</a><span>|</span><a href="#36702944">prev</a><span>|</span><a href="#36700983">next</a><span>|</span><label class="collapse" for="c-36700778">[-]</label><label class="expand" for="c-36700778">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is cool - thanks to fly.io for documenting and open-sourcing it!</div><br/></div></div></div></div><div id="36700983" class="c"><input type="checkbox" id="c-36700983" checked=""/><div class="controls bullet"><span class="by">evisdrenova</span><span>|</span><a href="#36699559">prev</a><span>|</span><a href="#36705897">next</a><span>|</span><label class="collapse" for="c-36700983">[-]</label><label class="expand" for="c-36700983">[1 more]</label></div><br/><div class="children"><div class="content">This is pretty cool and I think the right direction. Would like to see more companies do this. I&#x27;ve built out systems like this in the past that essentially only handle tokens instead of sensitive data whether it&#x27;s secrets, PII, etc.<p>You can also take this a step further and do mathematical operations on encrypted data using homomorphic encryption without ever having to decrypt the data.<p>Just one small nitpick (mainly because I worked in this space for a few years) is that tokens and encrypted values are different. Tokens aren&#x27;t encrypted and instead randomly generated using a KV pair look up table so that an attacker could never reverse engineer them. Whereas encrypted values obviously use a key (whether symmetric or asymmetric) and could theoretically (although pretty much never practically if you&#x27;re using something like AES256) be hacked if someone got the key.</div><br/></div></div><div id="36705897" class="c"><input type="checkbox" id="c-36705897" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#36700983">prev</a><span>|</span><a href="#36702747">next</a><span>|</span><label class="collapse" for="c-36705897">[-]</label><label class="expand" for="c-36705897">[1 more]</label></div><br/><div class="children"><div class="content">This looks great. A little unfortunate that this effectively requires plaintext http&#x2F;1.1 (and won&#x27;t work with &quot;standard&quot; encrypted http&#x2F;2) - but that&#x27;s not fly.io&#x27;s fault.</div><br/></div></div><div id="36702747" class="c"><input type="checkbox" id="c-36702747" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#36705897">prev</a><span>|</span><a href="#36703787">next</a><span>|</span><label class="collapse" for="c-36702747">[-]</label><label class="expand" for="c-36702747">[2 more]</label></div><br/><div class="children"><div class="content">Summary: fly.io wrote two new programs (&quot;some little security thingies&quot;) to reduce the attack surface of their codebase.<p>1. &quot;Tokenizer is an HTTP proxy that injects third party authentication credentials into requests. Clients encrypt third party secrets using the proxy&#x27;s public key. When the client wants to send a request to the third party service, it does so via the proxy, sending along the encrypted secret in the Proxy-Tokenizer header. The proxy decrypts the secret and injects it into the client&#x27;s request. To ensure that encrypted secrets can only be used by authorized clients, the encrypted data also includes instructions on authenticating the client.&quot;<p><a href="https:&#x2F;&#x2F;github.com&#x2F;superfly&#x2F;tokenizer">https:&#x2F;&#x2F;github.com&#x2F;superfly&#x2F;tokenizer</a><p>2. &quot;Ssokenizer provides a layer of abstraction for applications wanting to authenticate users and access 3rd party APIs via OAuth, but not wanting to directly handle users&#x27; API tokens. Ssokenizer is responsible for performing the OAuth dance, obtaining the user&#x27;s OAuth access token. The token is then encrypted for use with the tokenizer HTTP proxy. By delegating OAuth authentication to ssokenizer and access token usage to tokenizer, applications limit the risk of tokens being lost, stolen, or misused.&quot;<p><a href="https:&#x2F;&#x2F;github.com&#x2F;superfly&#x2F;ssokenizer&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;superfly&#x2F;ssokenizer&#x2F;</a><p>If these sound interesting to you, click the submitted link for the &quot;big long essay about how the thingies came to be.&quot;</div><br/><div id="36703736" class="c"><input type="checkbox" id="c-36703736" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#36702747">parent</a><span>|</span><a href="#36703787">next</a><span>|</span><label class="collapse" for="c-36703736">[-]</label><label class="expand" for="c-36703736">[1 more]</label></div><br/><div class="children"><div class="content">To be fair to the author of that blog post, it was a pretty good non top much fluff read.</div><br/></div></div></div></div><div id="36703787" class="c"><input type="checkbox" id="c-36703787" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#36702747">prev</a><span>|</span><a href="#36702972">next</a><span>|</span><label class="collapse" for="c-36703787">[-]</label><label class="expand" for="c-36703787">[3 more]</label></div><br/><div class="children"><div class="content">I wish more things &#x2F; ecosystems supported mTLS. Then you aren’t storing any long lived tokens. You exchange per instance metadata with key material to generate client tls certs that are then used to auth server calls. The certs have a short lifetime.</div><br/><div id="36705105" class="c"><input type="checkbox" id="c-36705105" checked=""/><div class="controls bullet"><span class="by">csears</span><span>|</span><a href="#36703787">parent</a><span>|</span><a href="#36702972">next</a><span>|</span><label class="collapse" for="c-36705105">[-]</label><label class="expand" for="c-36705105">[2 more]</label></div><br/><div class="children"><div class="content">The same thing occurred to me while reading this.<p>I suspect mTLS adoption has been slow because it’s easier to reason about authentication when the mechanics are “closer” to your application code. The mental model of bearer tokens in HTTP headers is pretty easy. Using mTLS requires understanding a lot more moving parts, and TLS still feels like a magical black box in many ways.<p>Are there any libraries you would recommend that provide a good developer experience around using mTLS?</div><br/><div id="36705532" class="c"><input type="checkbox" id="c-36705532" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#36703787">root</a><span>|</span><a href="#36705105">parent</a><span>|</span><a href="#36702972">next</a><span>|</span><label class="collapse" for="c-36705532">[-]</label><label class="expand" for="c-36705532">[1 more]</label></div><br/><div class="children"><div class="content">We’ve used Istio for some and a open source system called AthenZ to manage the key material.</div><br/></div></div></div></div></div></div><div id="36702972" class="c"><input type="checkbox" id="c-36702972" checked=""/><div class="controls bullet"><span class="by">ozfive</span><span>|</span><a href="#36703787">prev</a><span>|</span><a href="#36702038">next</a><span>|</span><label class="collapse" for="c-36702972">[-]</label><label class="expand" for="c-36702972">[3 more]</label></div><br/><div class="children"><div class="content">Private Key is held in an environment variable called &#x27;OPEN_KEY&#x27;. Wouldn&#x27;t they be better served retrieving the key from Vault or KMS for revocation purposes?</div><br/><div id="36703006" class="c"><input type="checkbox" id="c-36703006" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36702972">parent</a><span>|</span><a href="#36702038">next</a><span>|</span><label class="collapse" for="c-36703006">[-]</label><label class="expand" for="c-36703006">[2 more]</label></div><br/><div class="children"><div class="content">In practice, we do store things in Vault, but we expose that to VMs (where this runs in our architecture) via environment variables injected into the entrypoint process by our init through our orchestrator. You could write direct Vault integration, or do what most people probably do and just use Vault to set an environment variable.</div><br/><div id="36704206" class="c"><input type="checkbox" id="c-36704206" checked=""/><div class="controls bullet"><span class="by">ozfive</span><span>|</span><a href="#36702972">root</a><span>|</span><a href="#36703006">parent</a><span>|</span><a href="#36702038">next</a><span>|</span><label class="collapse" for="c-36704206">[-]</label><label class="expand" for="c-36704206">[1 more]</label></div><br/><div class="children"><div class="content">Hey, thanks for clarifying that for me!</div><br/></div></div></div></div></div></div><div id="36702038" class="c"><input type="checkbox" id="c-36702038" checked=""/><div class="controls bullet"><span class="by">salgorithm</span><span>|</span><a href="#36702972">prev</a><span>|</span><a href="#36704306">next</a><span>|</span><label class="collapse" for="c-36702038">[-]</label><label class="expand" for="c-36702038">[1 more]</label></div><br/><div class="children"><div class="content">I could imagine developers using something like this to get credentials off laptops.</div><br/></div></div><div id="36704306" class="c"><input type="checkbox" id="c-36704306" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#36702038">prev</a><span>|</span><a href="#36703480">next</a><span>|</span><label class="collapse" for="c-36704306">[-]</label><label class="expand" for="c-36704306">[5 more]</label></div><br/><div class="children"><div class="content">It’s cool, but the http connection to the proxy makes this only viable with the “vpn” tunnel they use. Otherwise MITM becomes a thing.<p>Also, you’ve gotten the secret off the client machine, but the attacker can still do anything the secret can do by using the proxy? Perhaps I’m missing something.</div><br/><div id="36704335" class="c"><input type="checkbox" id="c-36704335" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36704306">parent</a><span>|</span><a href="#36703480">next</a><span>|</span><label class="collapse" for="c-36704335">[-]</label><label class="expand" for="c-36704335">[4 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t need it, nor does anyone who can set up a WireGuard tunnel between their app instance and their proxy instance, or any other IP-level secure channel, but if you really cared you could write the TLS termination logic to make this work --- every MITM testing proxy has it, and there&#x27;s Go code to do it. It&#x27;s just pointless in our environment.<p>The attacker can currently do anything with the secret <i>by interacting with the sites allowlisted for that secret</i>, but they can&#x27;t exfiltrate the secret, which is the goal of this security control. You can do better, if you like, by further locking down which endpoints they can call, but the wins past &quot;log carefully and no exfiltration&quot; get smaller and smaller, and at some point you&#x27;re burning time that can be spent more productively on unrelated controls.<p>If you get what it&#x27;s doing, you get it. :)</div><br/><div id="36704491" class="c"><input type="checkbox" id="c-36704491" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#36704306">root</a><span>|</span><a href="#36704335">parent</a><span>|</span><a href="#36703480">next</a><span>|</span><label class="collapse" for="c-36704491">[-]</label><label class="expand" for="c-36704491">[3 more]</label></div><br/><div class="children"><div class="content">I think I get what you’re doing, I’m just struggling to see the significance. The OAuth2 token is <i>supposed</i> to only provide the access the client needs. So you don’t get the raw token and instead need to interact via the proxy, so what? What have you blocked the attacker from doing? [edit] I do see intrinsic value in being able to prevent direct access to the tokens and secrets, it just doesn’t look the game changer implied here. Not to me at least.</div><br/><div id="36705995" class="c"><input type="checkbox" id="c-36705995" checked=""/><div class="controls bullet"><span class="by">chrismsnz</span><span>|</span><a href="#36704306">root</a><span>|</span><a href="#36704491">parent</a><span>|</span><a href="#36704748">next</a><span>|</span><label class="collapse" for="c-36705995">[-]</label><label class="expand" for="c-36705995">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What have you blocked the attacker from doing?<p>Not blocked necessarily, but if they want to leverage a stolen token, they’re now forced down a more difficult and highly visible pathway.<p>You can imagine anomaly detection along the lines if “hey your rails app just made a type of request that it has never made before”, but even just monitoring the metrics of the proxy could tip you off if something is going on.</div><br/></div></div><div id="36704748" class="c"><input type="checkbox" id="c-36704748" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36704306">root</a><span>|</span><a href="#36704491">parent</a><span>|</span><a href="#36705995">prev</a><span>|</span><a href="#36703480">next</a><span>|</span><label class="collapse" for="c-36704748">[-]</label><label class="expand" for="c-36704748">[1 more]</label></div><br/><div class="children"><div class="content">None of this is a game changer. It&#x27;s just a way to handle secrets and use them with code driven by Rails without giving Rails access to the secret bits in its memory.</div><br/></div></div></div></div></div></div></div></div><div id="36703480" class="c"><input type="checkbox" id="c-36703480" checked=""/><div class="controls bullet"><span class="by">twodave</span><span>|</span><a href="#36704306">prev</a><span>|</span><a href="#36705007">next</a><span>|</span><label class="collapse" for="c-36703480">[-]</label><label class="expand" for="c-36703480">[3 more]</label></div><br/><div class="children"><div class="content">First read this as “Tokenized Tolkiens”. What a let-down.</div><br/><div id="36703596" class="c"><input type="checkbox" id="c-36703596" checked=""/><div class="controls bullet"><span class="by">itake</span><span>|</span><a href="#36703480">parent</a><span>|</span><a href="#36705007">next</a><span>|</span><label class="collapse" for="c-36703596">[-]</label><label class="expand" for="c-36703596">[2 more]</label></div><br/><div class="children"><div class="content">South Park did an episode about this</div><br/><div id="36704234" class="c"><input type="checkbox" id="c-36704234" checked=""/><div class="controls bullet"><span class="by">ozfive</span><span>|</span><a href="#36703480">root</a><span>|</span><a href="#36703596">parent</a><span>|</span><a href="#36705007">next</a><span>|</span><label class="collapse" for="c-36704234">[-]</label><label class="expand" for="c-36704234">[1 more]</label></div><br/><div class="children"><div class="content">Ahhh just for fun... <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=L9fyB6iJvTU">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=L9fyB6iJvTU</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>